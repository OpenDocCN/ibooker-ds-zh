- en: 11 File finder
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 文件查找器
- en: Back in ancient times, one of the most popular MS-DOS utilities I wrote was
    the Fast File Finder. It wasn’t particularly fast, of course. But it did the job
    of finding a file anywhere on the PC’s hard drive when given a filename. This
    program was included on the companion floppy diskettes provided with many of my
    early computing books. Yes, floppy diskettes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在古代，我编写过最流行的 MS-DOS 工具之一是快速文件查找器。当然，它并不特别快。但给定一个文件名时，它可以在 PC 的硬盘上找到任何位置的文件。这个程序包含在我早期许多计算机书籍提供的配套软盘上。是的，软盘。
- en: In today’s operating systems, finding files is a big deal. Both Windows and
    Mac OS X feature powerful file-finding tools, locating files by not only name
    but also date, size, and content. The Linux command prompt offers its own slate
    of file-finding tools, just as powerful (if not more so) as their graphical counterparts.
    For a budding C programmer, or anyone desiring to build their C kung fu, using
    these tools is useful, but you can’t improve your programming skills by just using
    the tools.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的操作系统上，查找文件是一个大问题。Windows 和 Mac OS X 都提供了强大的文件查找工具，不仅可以通过名称，还可以通过日期、大小和内容来定位文件。Linux
    命令提示符提供了自己的文件查找工具，这些工具与它们的图形界面工具一样强大（如果不是更强大）。对于一位初学者 C 程序员，或者任何想要提高他们的 C 语言技能的人来说，使用这些工具是有用的，但仅仅使用这些工具并不能提高你的编程技能。
- en: 'Hunting for files, and potentially doing something with them, relies upon the
    directory-spelunking tools covered in chapter 10\. From this base, you can expand
    your knowledge of C by:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索文件，以及可能对它们进行某些操作，依赖于第 10 章中介绍的目录探险工具。从这个基础出发，你可以通过以下方式扩展你的 C 语言知识：
- en: Reviewing other file-finding utilities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查其他文件查找工具
- en: Exploring methods for finding text
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索查找文本的方法
- en: Locating files in a directory tree
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目录树中定位文件
- en: Using wildcards to match files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通配符匹配文件
- en: Finding filename duplicates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找文件名重复项
- en: When I program a utility, especially one that’s similar to one that’s already
    available, I look for improvements. Many command-line tools feature a parade of
    options and features. These switches make the command powerful but beyond what
    I need. I find the abundance of options overwhelming. Better for me is to build
    a more specific version of the utility. Although such a program may not have the
    muscle of something coded by expert C programmers of yore, it’s specific to my
    needs. By writing your own file tools, you learn more about programming in C,
    plus you get a tool you can use—and customize to your workflow.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我编写一个实用程序时，尤其是与已经可用的类似实用程序时，我会寻找改进。许多命令行工具都有一系列选项和功能。这些开关使命令变得强大，但超出了我的需求。我发现选项的丰富性令人不知所措。对我而言，构建一个更具体的实用程序版本会更好。虽然这样的程序可能没有像过去那些经验丰富的
    C 程序员编写的程序那样强大，但它符合我的需求。通过编写自己的文件工具，你可以更多地了解 C 语言编程，并且你可以使用这个工具——并根据自己的工作流程进行定制。
- en: 11.1 The great file hunt
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 大型文件搜索
- en: My personal-file finding utilities are based on frustration with the existing
    crop of Linux file finding tools—specifically, *find* and *grep*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人文件查找工具是基于对现有 Linux 文件查找工具的挫败感——特别是 *find* 和 *grep*。
- en: Nothing is wrong with these commands that some well-chosen curse words can’t
    address. Still, I find myself unable to commit the command formats and options
    to memory. I constantly refer to the documentation when it comes to using these
    file-finding tools. I understand that this admission could get me kicked out of
    the neighborhood computer club.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令没有问题，一些精心挑选的咒骂词就能解决。然而，我发现我无法记住命令格式和选项。在需要使用这些文件查找工具时，我总是不断查阅文档。我明白这种承认可能会让我被赶出社区计算机俱乐部。
- en: The *find* command is powerful. In Linux, such power implies options galore,
    often more command-line switches available than letters of the alphabet—upper-
    and lowercase. This complexity explains why many nerds resort instead to using
    GUI file-search tools instead of a terminal window to locate lost files.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*find* 命令功能强大。在 Linux 中，这种强大意味着有大量的选项，通常比字母表中的字母还要多——大小写字母。这种复杂性解释了为什么许多极客宁愿使用图形界面文件搜索工具，而不是终端窗口来查找丢失的文件。'
- en: 'Here is the deceptively simple format for the find command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 find 命令的看似简单的格式：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Yep. Easy.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。很简单。
- en: 'Suppose you want to locate a file named budget.csv, located somewhere in your
    home directory tree. Here is the command to use:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要定位一个名为 budget.csv 的文件，它位于你的主目录树中的某个位置。以下是你要使用的命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The pathname is ~, shortcut for your home directory. The -name switch identifies
    the file to locate, budget.csv. The final switch, -print (the one everyone forgets),
    directs the *find* command to send the results to standard output. You may think
    something like output would be the necessary default, but the *find* command can
    do more with found files than send their names to standard output.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 路径名是~，代表你的主目录。-name开关用于标识要查找的文件，budget.csv。最后的开关，-print（大家容易忘记的），指示*find*命令将结果发送到标准输出。你可能认为输出应该是必要的默认选项，但*find*命令可以对找到的文件做更多的事情，而不仅仅是将它们的名称发送到标准输出。
- en: 'The *find* command’s desired output may appear on a line by itself, which is
    fortunate. More common is that you must sift through a long series of errors and
    duplicate matches. Eventually the desired file is found, and its path revealed:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*find*命令期望的输出可能单独出现在一行上，这是幸运的。更常见的情况是，你必须筛选出一系列错误和重复的匹配。最终找到所需的文件，并显示其路径：'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Yes, you can create an alias to the specific *find* utility format you use often.
    No, I’m not going to get into a debate about how powerful and useful the *find*
    command is or why I’m a dweeb for not comparing it with a sunshine lollypop for
    delicious goodness.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你可以创建一个别名来指向你经常使用的特定*find*工具格式。不，我不会就*find*命令有多强大和有用或为什么我不把它与美味的棒棒糖进行比较进行辩论。
- en: 'The other file-finding command is *grep*, which I use specifically to locate
    files containing a specific tidbit of text. In fact, I’ve used grep many times
    when writing this book to locate defined constants in header files. From the /usr/include
    directory, here is the command to locate the time_t defined constant in various
    header files:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个文件查找命令是*grep*，我特别使用它来定位包含特定文本片段的文件。实际上，我在写这本书的时候多次使用grep来在头文件中定位定义的常量。从/usr/include目录，以下是查找各种头文件中time_t定义常量的命令：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The -r switch directs *grep* to recursively look through directories. The string
    to find is time_t and the * wildcard directs the program to search all filenames.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: -r开关指示*grep*递归地遍历目录。要查找的字符串是time_t，而*通配符指示程序搜索所有文件名。
- en: Many lines of text spew forth when issuing this command, because the time_t
    defined constant is referenced in multiple header files. Even this trick didn’t
    locate the specific definition I wanted, though it pointed me in the right direction.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行这个命令时，会输出许多行文本，因为time_t定义的常量在多个头文件中被引用。即使这个技巧也没有找到我想要的特定定义，但它确实指明了正确的方向。
- en: These utilities—*find* and *grep* (and its better cousin, *egrep*)—are wonderful
    and powerful. Yet I want something friendly and usable without the requirement
    of chronically checking *man* pages or referring to hefty command-line reference
    books. This is why I code my own versions, covered in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具——*find*和*grep*（以及它的更好伴侣，*egrep*）——非常棒且功能强大。然而，我想要一个友好且易于使用的工具，无需经常检查*man*页面或参考厚重的命令行参考书籍。这就是为什么我编写了自己的版本，这些版本在本章中有所介绍。
- en: With your knowledge of C, you can easily code your own file-finding utilities
    specific to your needs, as complex or as simple as you desire. Then, if you forget
    any of the options, you have only yourself to blame.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有了你对C语言的知识，你可以轻松地编写满足你需求的特定文件查找工具，无论是复杂还是简单。然后，如果你忘记了任何选项，你只能怪自己。
- en: 11.2 A file finder
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 文件查找器
- en: 'My goal for finding files is to type a command like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我寻找文件的目标是输入这样的命令：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The utility digs deep through the current directory tree, scouring subdirectory
    after subdirectory, hunting for the specific file. If found, the full pathname
    is output—useful information to me. Add in the capability of using wildcards to
    locate files, and I’ll never need the *find* command again—in the specific format
    to locate a file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 工具深入当前目录树，逐个子目录地搜索，寻找特定的文件。如果找到，将输出完整的路径名——对我非常有用。添加使用通配符定位文件的能力，我就再也不需要使用*find*命令了——在特定格式下查找文件。
- en: Oh, yeah—I suppose my own utility must be named something other than *find*,
    already used in Linux. How about *ff* for *Find File*?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，对了——我想我的工具名字不能叫*find*，因为Linux中已经使用了这个名字。那叫*ff*，代表*Find File*怎么样？
- en: 11.2.1 Coding the Find File utility
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 编写文件查找器工具
- en: Chapter 10 covers the process of directory exploration, using the recursive
    *dir()* function to plumb subdirectory depths. Building upon this function is
    perfect for creating a file-finding utility. The goal is to scan directories and
    compare those files found with a matching filename supplied by the user.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第 10 章涵盖了目录探索的过程，使用递归的 *dir()* 函数来深入子目录。在这个函数的基础上构建是创建文件查找工具的完美选择。目标是扫描目录，并将找到的文件与用户提供的匹配文件名进行比较。
- en: The *Find File* utility presented in this chapter doesn’t use the same *dir()*
    function from chapter 10\. No, the recursive directory-finding function requires
    modification to locate specific files, not all files. I’ve renamed the function
    *find()* because I know the name would infuriate the find utility.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中介绍的 *Find File* 工具不使用第 10 章中的相同 *dir()* 函数。不，递归目录查找函数需要修改以定位特定文件，而不是所有文件。我已将函数重命名为
    *find()*，因为我知道这个名字会激怒查找工具。
- en: My *find()* function features the same first two arguments as *dir()* from chapter
    10\. But as shown in the next listing, this updated function adds a third argument,
    match, to help hunt for the named file. Other differences between *dir()* and
    *find()* are commented in the listing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 *find()* 函数具有与第 10 章中的 *dir()* 相同的前两个参数。但如下一列表所示，这个更新的函数添加了一个第三个参数 match，以帮助寻找命名的文件。*dir()*
    和 *find()* 之间的其他差异在列表中已注释说明。
- en: Listing 11.1 The recursive *find()* function
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.1 递归 *find()* 函数
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Use the limits.h value for the maximum path size (see the discussion in the
    text).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 limits.h 中的最大路径大小值（参见文本中的讨论）。
- en: ❷ Performs a comparison for the filename found with the passed filename
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对找到的文件名与传递的文件名进行比较
- en: ❸ Outputs any matching filename
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输出任何匹配的文件名
- en: ❹ Increments the external count variable
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 增加外部 count 变量
- en: ❺ Avoids checking the hidden files
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 避免检查隐藏文件
- en: ❻ The recursive call, again with the passed filename to match as the third argument
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 再次进行递归调用，这次将传递的文件名作为第三个参数
- en: 'Beyond the additions noted in listing 11.1, I use the PATH_MAX defined constant,
    which requires including the limits.h header file. Because not every C library
    implements PATH_MAX, some preprocessor directives are required:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了列表 11.1 中提到的添加之外，我还使用了定义的 PATH_MAX 常量，这需要包含 limits.h 头文件。因为并非每个 C 库都实现了 PATH_MAX，所以需要一些预处理指令：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The value of PATH_MAX differs depending on the operating system. For example,
    in Windows it could be 260 bytes, but in my version of Ubuntu Linux, it’s 1024\.
    I’ve seen it as high as 4096 bytes, so 256 seems like a good value that won’t
    blow up anything. If you want to define a higher value, feel free to do so.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: PATH_MAX 的值因操作系统而异。例如，在 Windows 上可能是 260 字节，但在我使用的 Ubuntu Linux 版本中，它是 1024
    字节。我见过高达 4096 字节的，所以 256 似乎是一个不会导致任何问题的好值。如果你想定义一个更高的值，请随意定义。
- en: My *Find File* utility also counts matched files. To keep track, I use the variable
    count, which is defined externally. I am loath to use global variables, but in
    this situation having count be external is an effective way to keep track of files
    found. Otherwise, I could include count as a fourth argument to the *find()* function,
    but as a recursive function, maintaining its value consistently introduces all
    kinds of chaos.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 *Find File* 工具也计算匹配的文件数。为了跟踪，我使用了定义在外的变量 count。我非常不愿意使用全局变量，但在这个情况下，让 count
    成为外部变量是跟踪找到的文件的有效方法。否则，我可以在 *find()* 函数中将 count 包含为第四个参数，但作为一个递归函数，保持其值的一致性会引入各种混乱。
- en: The source code that includes the *find()* function is named findfile01.c, where
    the *main()* function is shown in the following listing. The *main()* function’s
    job is to fetch the filename from the command line, retrieve the current path,
    make the call to the *find()* function, and then report the results. The *main()*
    function is shown here.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 *find()* 函数的源代码文件名为 findfile01.c，其中 *main()* 函数在以下列表中显示。*main()* 函数的职责是从命令行获取文件名，检索当前路径，调用
    *find()* 函数，然后报告结果。*main()* 函数如下所示。
- en: Listing 11.2 The *main()* function from findfile01.c
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 findfile01.c 中的 *main()* 函数
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ A command-line argument is required.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 需要一个命令行参数。
- en: ❷ Initializes the external *int* variable count, keeping track of the files
    found
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 初始化外部 *int* 变量 count，用于跟踪找到的文件数量
- en: ❸ Calls the function, with the filename argument specified third
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 调用函数，指定文件名参数为第三个参数
- en: ❹ Reports the results
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 报告结果
- en: ❺ Magically adds “es” for any count value other than 1
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 对于除了 1 以外的任何 count 值，神奇地添加“es”
- en: 'Both *find()* and *main()* are included in the source code file findfile01.c,
    available in this book’s online repository. I’ve built the source code into the
    program file named *ff*. Here are a few sample runs:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*find()* 和 *main()* 都包含在源代码文件 findfile01.c 中，该文件可在本书的在线仓库中找到。我已经将源代码构建到名为 *ff*
    的程序文件中。以下是一些示例运行：'
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The *Find File* utility locates all the a.out files in my home directory tree:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*查找文件* 工具会定位我主目录树中的所有 a.out 文件：'
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the previous example, the utility doesn’t find any files named hello:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，该工具没有找到任何名为 hello 的文件：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The utility attempts to locate all files with the .c extension in the current
    directory. Rather than return them all, you see only the first match reported:
    finddupe01.c. The problem here is that the code doesn’t recognize wildcards; it
    finds only specific filenames.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具尝试定位当前目录中所有具有 .c 扩展名的文件。而不是返回所有文件，你只能看到第一个匹配的文件报告：finddupe01.c。这里的问题是代码没有识别通配符；它只找到特定的文件名。
- en: To match files with wildcards, you must understand something known as the glob.
    Unlike The Blob, star of the eponymous 1958 horror film, knowing the glob won’t
    get you killed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配具有通配符的文件，你必须了解一个称为 glob 的概念。与同名的 1958 年恐怖电影《 Blob》的主角不同，了解 glob 不会让你丧命。
- en: 11.2.2 Understanding the glob
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 理解 glob
- en: A glob can be an insidious lump of goo from outer space, but in the computer
    world, it’s short for *glob*al. Specifically, *glob* is a way to use wildcards
    to specify or match filenames. Most humans I know prefer to say “wildcard” as
    opposed to “glob.” But in the programming realm, the term is *glob*, the process
    is *globbing*, and people who glob are globbers. The C library function worthy
    of attention is *glob()*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: glob 可以是来自外太空的粘稠物质，但在计算机世界中，它简称为 *glob*al。具体来说，*glob* 是一种使用通配符指定或匹配文件名的方法。我知道的大多数人都更喜欢说“通配符”而不是“glob”。但在编程领域，术语是
    *glob*，过程是 *globbing*，而 globbing 的人被称为 globbers。值得关注的 C 库函数是 *glob()*。
- en: 'As a review, the filename wildcards are:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 作为复习，文件名通配符如下：
- en: '? to match a single character'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '? 匹配单个字符'
- en: '* to match a group of more than one character'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '* 匹配多个字符的组'
- en: In Windows, globbing takes place automatically. But in the Linux environment,
    the glob feature must be activated for wildcards to expand. If not, the * and
    ? wildcards are interpreted literally, which isn’t what most users expect.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，通配符匹配会自动进行。但在 Linux 环境中，必须激活通配符功能才能展开通配符。如果不这样做，*和? 通配符将被字面地解释，这并不是大多数用户所期望的。
- en: 'To ensure that globbing is active, type the **set -o** command. In the output,
    the *noglob* option should be set to *off*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要确保 globbing 是激活的，请输入 **set -o** 命令。在输出中，*noglob* 选项应设置为 *off*：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you see that the option is on, use this command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到选项是开启的，请使用此命令：
- en: set +o noglob
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: set +o noglob
- en: When globbing is active, the shell expands the ? and * wildcards to match files.
    In the preceding section, the input provided is *.c. Yet the program processed
    only one file named finddupe01.c. The filename is a match, but it’s not the only
    *.c filename in the directory. What gives?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当通配符激活时，shell 会展开 ? 和 * 通配符以匹配文件。在上一个部分中，提供的输入是 *.c。然而，程序只处理了一个名为 finddupe01.c
    的文件。文件名是匹配的，但它不是目录中唯一的 *.c 文件名。这是怎么回事？
- en: The code in the next listing helps you understand how globbing works when wildcards
    are typed at the command prompt. The program generated from glob01.c loops through
    all command-line options typed, minus the first item, which is the program filename.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表中的代码有助于你理解在命令提示符中输入通配符时 globbing 的工作方式。从 glob01.c 生成的程序遍历所有输入的命令行选项，除了第一个项目，即程序文件名。
- en: Listing 11.3 Source code for glob01.c
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3 glob01.c 的源代码
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Don’t bother if only the program name is typed at the prompt.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果在提示符下只输入程序名，无需烦恼。
- en: ❷ Loops through all the arguments
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历所有参数
- en: 'Here is a sample run of the program created from glob01.c, which is named a.out:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 glob01.c 创建的程序的一个示例运行，该程序被命名为 a.out：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The program dutifully echoes all command-line options. Now try running the
    same program, but with a wildcard specified:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序忠实地回显所有命令行选项。现在尝试运行相同的程序，但指定一个通配符：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The *.c wildcard (globby thing) is expanded by the shell, which feeds each matching
    filename from the current directory to the program as a command-line argument.
    Instead of a single argument, *.c, multiple arguments are supplied.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*.c 通配符（globby 事物）由 shell 展开，将当前目录中每个匹配的文件名作为命令行参数传递给程序。而不是提供一个单一的参数 *.c，而是提供了多个参数。'
- en: The problem with globbing is that your program really doesn’t know whether multiple
    command-line arguments are supplied or a single wildcard is typed and expanded.
    Further, because the wildcard argument is translated into multiple matching files,
    you have no way of knowing which wildcard was specified. Perhaps some way exists,
    because I know utilities that can perform wildcard matching in amazing ways, but
    I’ve yet to discover what this magic is.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通配符匹配的问题在于，你的程序实际上并不知道是否提供了多个命令行参数，或者输入了一个通配符并进行了展开。此外，由于通配符参数被转换成多个匹配的文件，你无法知道指定了哪个通配符。或许存在某种方法，因为我知道一些能够以惊人方式执行通配符匹配的实用程序，但我还没有发现这种魔法的本质。
- en: 'Rather than be flustered, you can rely upon the *glob()* function to do the
    pattern matching for you. Here is the *man* page format:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是感到困惑，你可以依赖 *glob()* 函数为你执行模式匹配。以下是 *man* 页面的格式：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The function has four arguments:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有四个参数：
- en: const char *pattern is a pathname wildcard pattern to match.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: const char *pattern 是一个路径名通配符模式，用于匹配。
- en: int flags are options to customize the function’s behavior, usually a series
    of defined constants logically OR’d together.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: int flags 是用于自定义函数行为的选项，通常是一系列逻辑 OR 一起定义的常量。
- en: int (*errfunc) is the name of an error-handling function (along with its two
    arguments), which is necessary because the *glob()* function can be quirky. Specify
    NULL to use the default error handler.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: int (*errfunc) 是一个错误处理函数的名称（及其两个参数），这是必要的，因为 *glob()* 函数可能有些古怪。指定 NULL 以使用默认的错误处理器。
- en: glob_t *pglob is a structure containing details about the matching files. Two
    useful members are gl_pathc, which lists the number of matching files, and gl_pathv,
    which serves as the base of a pointer list referencing matching filenames in the
    current directory.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: glob_t *pglob 是一个包含匹配文件详细信息的结构。两个有用的成员是 gl_pathc，它列出了匹配文件的数量，以及 gl_pathv，它作为指向当前目录中匹配文件名的指针列表的基址。
- en: The *glob()* function returns zero on success. Other return values include defined
    constants you can test to determine whether the function screwed up or failed
    to find any matching files.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*glob()* 函数在成功时返回零。其他返回值包括定义的常量，你可以测试这些常量以确定函数是否出错或未能找到任何匹配的文件。'
- en: More scintillating details are available about the *glob()* function in the
    *man* pages. Pay special attention to the flags argument because it’s easy for
    various issues to arise.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 *glob()* 函数的更多精彩细节可以在 *man* 页面中找到。请特别注意 flags 参数，因为它容易引发各种问题。
- en: You must include the glob.h header file in your source code to keep the compiler
    content with the *glob()* function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在源代码中包含 glob.h 头文件，以使编译器知道 *glob()* 函数。
- en: In the next listing, the source code for glob02.c uses the *glob()* function
    to scan for matching files in the current directory. The user is prompted for
    input. The input string is scrubbed of any newlines. The glob() function is called
    to process input, searching for filenames that match any wildcards specified.
    Finally, a *while* loop outputs the matching filenames.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，glob02.c 的源代码使用 *glob()* 函数在当前目录中搜索匹配的文件。用户被提示输入。输入字符串被清除任何换行符。调用 glob()
    函数处理输入，搜索与指定的任何通配符匹配的文件名。最后，一个 *while* 循环输出匹配的文件名。
- en: Listing 11.4 Source code for glob02.c
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.4 glob02.c 的源代码
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ For the definition of PATH_MAX—if available
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对于 PATH_MAX 的定义——如果可用
- en: ❷ If PATH_MAX isn’t defined, creates it
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果 PATH_MAX 没有定义，则创建它
- en: ❸ The return value of *glob()*
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ *glob()* 的返回值
- en: ❹ The structure specified in the *glob()* function
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在 *glob()* 函数中指定的结构
- en: ❺ A double-pointer to the list of matching filenames
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 一个指向匹配文件名列表的双指针
- en: ❻ Prompts for the filename wildcard; this chunk of code is to verify the input
    and remove the newline.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 提示输入文件名通配符；这段代码是为了验证输入并删除换行符。
- en: ❼ The call to the *glob()* function, mostly defaults except for the GLOB_ERR
    flag
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 对 *glob()* 函数的调用，大多数情况下默认，除了 GLOB_ERR 标志
- en: ❽ Checks for errors, specifically no matching filename
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 检查错误，特别是没有匹配的文件名
- en: ❾ Outputs the matches using structure member gl_pathc; the placeholder %zu is
    used for a *size_t* value.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 使用结构成员 gl_pathc 输出匹配项；占位符 %zu 用于 *size_t* 值。
- en: ❿ The gl_pathv member is the base of a pointer list, assigned to double pointer
    found.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ gl_pathv 成员是指针列表的基址，被分配给找到的双指针。
- en: ⓫ Loops as long as the string referenced by *found isn’t NULL
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 当 *found* 引用的字符串不为 NULL 时循环
- en: ⓬ Outputs the matching filename
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 输出匹配的文件名
- en: ⓭ Increments the found pointer to reference the next item in the list
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ⓭ 增加找到的指针以引用列表中的下一个项目
- en: 'Remember, the wildcard input must be supplied by the user because the program
    doesn’t interpret wildcard input as a command-line argument. Here is a sample
    run:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，通配符输入必须由用户提供，因为程序不会将通配符输入解释为命令行参数。以下是一个示例运行：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The program successfully found all files starting with find. The techniques
    used in the source code can now be incorporated into the *Find File* utility to
    use wildcards in its search.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 程序成功找到了所有以find开头的文件。现在可以将源代码中使用的技术整合到*查找文件*实用程序中，以便在搜索中使用通配符。
- en: 11.2.3 Using wildcards to find files
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3 使用通配符查找文件
- en: Some modifications are necessary for the Find File utility to take advantage
    of wildcards. To assist the *glob()* function, the matching filename must now
    be entered at a prompt, similar to the glob02.c program in the preceding section.
    Then the *glob()* function must be integrated into the *find()* function to help
    scour subdirectories for matching filenames.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对查找文件实用程序进行一些修改，以便利用通配符。为了辅助*glob()*函数，现在必须在提示符下输入匹配的文件名，类似于前一小节中的glob02.c程序。然后必须将*glob()*函数集成到*find()*函数中，以帮助搜索子目录中的匹配文件名。
- en: Modifications to the *main()* function can be found in the source code file,
    findfile02.c, available in the online repository. These updates reflect added
    statements from the glob02.c source code file, mostly to accept and confirm input
    regarding wildcards. The rest of the modifications are shown in the following
    listing, where the *glob()* function is integrated into the *find()* function.
    In this version of the code, the string argument match can be a specific filename
    or a filename including wildcards.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对*main()*函数的修改可以在源代码文件findfile02.c中找到，该文件可在在线仓库中找到。这些更新反映了从glob02.c源代码文件中添加的语句，主要是接受和确认有关通配符的输入。其余的修改如下所示，其中*glob()*函数被集成到*find()*函数中。在这个版本的代码中，字符串参数match可以是特定文件名或包含通配符的文件名。
- en: Listing 11.5 The *find()* function from source code file findfile02.c
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.5 源代码文件findfile02.c中的*find()*函数
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Uses *glob()* to find matching files in the directory
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用*glob()*在目录中查找匹配的文件
- en: ❷ Upon success, outputs the found files (here instead of below)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 成功后，输出找到的文件（这里而不是下面）
- en: ❸ This loop is still necessary to find and explore subdirectories.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 此循环仍然必要，以查找和探索子目录。
- en: ❹ Just look for directory files here; matching files already output.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 只在这里查找目录文件；匹配的文件已经输出。
- en: 'In its final incarnation, the *Find File* utility (source code file findfile02.c)
    prompts for input, which can be a specific file or a wildcard. All files in the
    current directory and in all subdirectories are searched with the results reported:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最终版本中，*查找文件*实用程序（源代码文件findfile02.c）会提示输入，可以是特定文件或通配符。当前目录及其所有子目录中的所有文件都会被搜索，并报告结果：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the *Find File* utility located 192 C source code files in my home folder.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*查找文件*实用程序在我的主目录中找到了192个C源代码文件。
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the sample run shown here, the *Find File* utility located my bank deposit
    document. Having the *glob()* function in the program allows wildcards to be used
    effectively. Though the program can still locate specific files when the full
    name is input:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里显示的示例运行中，*查找文件*实用程序找到了我的银行存款文件。程序中包含的*glob()*函数允许有效地使用通配符。尽管当输入完整名称时，程序仍然可以定位特定文件：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As I wrote earlier, I use this utility often because it’s simple and it generates
    the results I want. What I don’t want is to keep working on the utility, which
    may eventually lead me to reinvent the *find* program. No, instead, the concept
    of finding a file can be taken further to locating duplicate files.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前写的，我经常使用这个实用程序，因为它简单，并且能生成我想要的结果。我不希望继续修改这个实用程序，这可能会最终导致我重新发明*find*程序。不，相反，查找文件的概念可以进一步扩展到定位重复文件。
- en: 11.3 The duplicate file finder
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 重复文件查找器
- en: One my favorite shareware utilities for MS-DOS is *finddupe*. I’ve found nothing
    like it for Windows (not that I’ve aggressively looked). A version of the utility
    is still available for the command shell in Windows. It finds duplicate files,
    not just by name but also by contents. *finddupe* is a handy tool for cleaning
    up and organizing files on a mass storage device.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的MS-DOS共享软件实用程序之一是*finddupe*。我在Windows中找不到类似的东西（尽管我没有积极寻找）。该实用程序的版本仍然可在Windows的命令行界面中使用。它不仅通过名称，还通过内容查找重复文件。*finddupe*是清理和组织大容量存储设备上文件的便捷工具。
- en: 'I never bothered coding my own *finddupe* utility, mostly because the existing
    tool is spiffy. Even so, I often thought of the process: the program must not
    only scan all directories but also must record filenames. From the list of recorded
    filenames, each must be compared with others in the list to see whether the same
    name exists. I tremble at the thought of the added process of comparing file contents.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我从未费心编写自己的*finddupe*实用程序，主要是因为现有的工具很棒。即便如此，我经常思考这个过程：程序不仅必须扫描所有目录，还必须记录文件名。从记录的文件名列表中，每个都必须与其他列表中的文件进行比较，以查看是否存在相同的名称。一想到比较文件内容的过程，我就感到不寒而栗。
- en: 'Still, the topic intrigued me: How would you scan files in subdirectories and
    then check to see whether any duplicate names are found?'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这个话题仍然吸引了我：你是如何扫描子目录中的文件，然后检查是否找到任何重复的名称的？
- en: 'The process of creating a *Find Dupe* utility borrows heavily from the subdirectory
    scanning tools presented in chapter 10 and used earlier in this chapter. But the
    rest of the code—recording and scanning the list of saved files—is new territory:
    a list of files must be created. The list must be scanned for duplicates and then
    the duplicates output, along with their pathnames.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建*Find Dupe*实用程序的过程大量借鉴了第10章中介绍的子目录扫描工具，以及本章前面使用过的工具。但其余的代码——记录和扫描保存的文件列表——是新的领域：必须创建一个文件列表。该列表必须被扫描以查找重复项，然后输出重复项及其路径名。
- en: 11.3.1 Building a file list
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 构建文件列表
- en: 'As with any programming projects, I made several attempts to successfully build
    a list of files found in subdirectories. It was obvious that I’d need some kind
    of structure to hold the file information: name, path, and so on. But do I create
    a dynamic array (allocated pointers) of structures, use a linked list, make the
    structure array external, or just give up and become a dairy farmer?'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何编程项目一样，我尝试了多次才成功地构建了一个包含子目录中找到的文件的列表。很明显，我需要某种结构来保存文件信息：名称、路径等等。但是，我是创建一个动态数组（分配指针）的结构，使用链表，使结构数组外部化，还是放弃并成为一名乳牛农场主呢？
- en: To me, making any variable external is a last choice. Sometimes it’s the only
    choice, but never should it be a choice because it’s easy to do. As shown earlier
    in this chapter with the count variable, sometimes it’s necessary because the
    other ways to implement the variable are awkward. Especially with recursion, having
    an external variable untangles some knots that are otherwise at the Christmas-tree-light
    level.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，将任何变量外部化都是最后的手段。有时这是唯一的选择，但永远不应该是因为它容易做到而选择。正如本章前面所展示的，有时这是必要的，因为实现变量的其他方式很笨拙。特别是与递归一起使用时，外部变量可以解开一些否则处于圣诞树灯水平上的结。
- en: The two options remaining are to pass a dynamically allocated list or use a
    linked list. I wrote several iterations of the code where a dynamically allocated
    list of structures was passed to the recursive function. It failed, which is easy
    because pointers can get lost in recursion. Therefore, my only remaining option
    is to create a linked list.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的两个选项是传递一个动态分配的列表或使用链表。我编写了几次代码，其中将动态分配的结构列表传递给递归函数。它失败了，这是很容易理解的，因为指针在递归中可能会丢失。因此，我唯一剩下的选择是创建一个链表。
- en: 'A linked list structure must have as a member a pointer to the next item, or
    *node*, in the list. This member becomes part of the structure that stores found
    filenames and their paths. Here is its definition:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 链表结构必须有一个成员，指向列表中的下一个项目，即*节点*。这个成员成为存储找到的文件名及其路径的结构的一部分。以下是它的定义：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'I originally named the structure fileinfo. I would have kept the name, but
    this book’s margins are only so wide and I don’t like wrapping source code. So,
    I settled on finfo. This structure contains four members:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初将这个结构命名为fileinfo。我本想保留这个名称，但这本书的边距只有那么宽，我不喜欢源代码的换行。所以，我决定使用finfo。这个结构包含四个成员：
- en: index, which keeps a count of the files found (avoiding an external variable)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: index，它记录找到的文件数量（避免使用外部变量）
- en: name, which contains the name of the found file
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: name，包含找到的文件名
- en: path, which contains the full path to the file
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: path，包含文件的完整路径
- en: next, which references the next node in the linked list, or NULL for the end
    of the list
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: next，它引用链表中的下一个节点，或NULL表示列表的末尾
- en: This structure must be declared externally so that all functions in the code
    understand its definition.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构必须声明为外部，以便代码中的所有函数都理解其定义。
- en: 'My first build of the program is simply to see whether the thing works: that
    the linked list is properly allocated, filled, and returned from the recursive
    function. In the next listing, you see the *main()* function. It allocates the
    first node in the linked list. This structure must be empty; it’s the recursive
    function *find()* that builds the linked list. The *main()* function fetches the
    starting directory for a call to the recursive function. Upon completion, a *while*
    loop outputs the names of the files referenced by the linked list.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个程序的第一次构建仅仅是看看它是否工作：即链表是否被正确分配、填充，并且从递归函数中返回。在下一部分中，你可以看到 *main()* 函数。它为链表分配第一个节点。这个结构必须为空；是递归函数
    *find()* 构建了链表。*main()* 函数获取递归函数的起始目录。完成后，一个 *while* 循环输出链表引用的文件名。
- en: Listing 11.6 The *main()* function from finddupe01.c
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.6 从 finddupe01.c 的 *main()* 函数
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ A pointer is needed for the base (first) and for examining the items in the
    list (current).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 需要一个指针用于基础（第一个）和检查列表中的项（当前）。
- en: ❷ Allocates the base pointer
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 分配基础指针
- en: ❸ Confirms the pointer is allocated
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 确认指针已分配
- en: ❹ Fills the first node with empty values
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将第一个节点填充为空值
- en: ❺ Obtains the current directory for the *find()* function call
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 获取 *find()* 函数调用的当前目录
- en: ❻ Calls the recursive function
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 调用递归函数
- en: ❼ Sets the current pointer to the start of the list
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将当前指针设置为列表的开始
- en: ❽ Loops as long as the current pointer isn’t NULL
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 当当前指针不为 NULL 时循环
- en: ❾ Skips over the first item in the list, zero
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 跳过列表中的第一个项目，零
- en: ❿ Outputs the index value, pathname, and filename
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 输出索引值、路径名和文件名
- en: ⓫ References the next item in the list
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 引用列表中的下一个项目
- en: 'The *while* loop skips the first node in the linked list, the empty item. I
    could avoid the if( current->index > 0) text (shown earlier) by replacing the
    initialization statement for current with:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*while* 循环跳过了链表中的第一个节点，即空项。我可以通过将当前初始化语句替换为以下内容来避免 if( current->index > 0)
    文本（前面已展示）：'
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: I only just thought of this change now, so you won’t find it in the source code
    files. Either way, the first node in the linked list is skipped over.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在才想到这个变化，所以你不会在源代码文件中找到它。无论如何，链表中的第一个节点被跳过了。
- en: The *find()* function for my *Find Dupe* code is based upon the *find()* function
    in the *Find File* utility presented earlier in this chapter. The third argument
    of the *find()* function is replaced by a pointer to the current node in the linked
    list. The function’s job is to create new nodes, filling their structures as it
    finds files in the current directory.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我为 *Find Dupe* 代码编写的 *find()* 函数是基于本章前面介绍的 *Find File* 工具中的 *find()* 函数。*find()*
    函数的第三个参数被替换为链表当前节点的指针。该函数的任务是在当前目录中找到文件时创建新节点，并填充它们的结构。
- en: The next listing shows the *find()* function for the *Find Dupe* utility, which
    is called from the *main()* function shown in listing 11.6\. This function allocates
    storage for a new node in the list upon finding a file in the current directory.
    This change is the only addition to the function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分显示了 *Find Dupe* 实用程序的 *find()* 函数，该函数在列表 11.6 中展示的 *main()* 函数中被调用。当在当前目录中找到文件时，该函数在列表中为新节点分配存储空间。这是函数的唯一添加。
- en: Listing 11.7 The *find()* function from finddupe01.c
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.7 从 finddupe01.c 的 *find()* 函数
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Obtains the current directory—unchanged
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取当前目录——未改变
- en: ❷ Tests for a subdirectory and recursion
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 测试子目录和递归
- en: ❸ If not a subdirectory, saves the file information
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果不是子目录，则保存文件信息
- en: ❹ Allocates the next node in the linked list (and does error checking)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 分配链表中的下一个节点（并进行错误检查）
- en: ❺ Saves the current index value
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 保存当前索引值
- en: ❻ References the freshly allocated node
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 引用新分配的节点
- en: ❼ Updates the index value
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 更新索引值
- en: ❽ Saves the filename
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 保存文件名
- en: ❾ Saves the pathname
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 保存路径名
- en: ❿ Initializes the next pointer; the rest of the function is the same as the
    preceding examples.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 初始化下一个指针；函数的其余部分与前面的示例相同。
- en: The *find()* function makes a simple decision based on whether a directory entry
    is a subdirectory or a file. When a subdirectory is found, the function is recursively
    called. Otherwise, a new node in the linked list is allocated and the file entry
    information is recorded.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*find()* 函数根据目录条目是子目录还是文件做出简单的决定。当找到子目录时，函数会递归调用。否则，在链表中分配一个新的节点，并记录文件条目信息。'
- en: 'The full source code for finddupe01.c can be found in the online repository.
    Here is output from sample run in my working directory:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: finddupe01.c 的完整源代码可以在在线仓库中找到。以下是我在工作目录中样本运行的输出：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output was able to record files from the current directory as well as the
    sto subdirectory. However, when I changed to the parent directory (code) and ran
    the program again, the output didn’t change. It should: my code directory has
    over 100 files in various subdirectories. So why was the output unchanged?'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 输出能够记录当前目录以及 sto 子目录中的文件。然而，当我切换到父目录（代码）并再次运行程序时，输出没有变化。它应该变化：我的代码目录在各个子目录中有超过
    100 个文件。那么为什么输出没有变化呢？
- en: 'I puzzled over the bug with the assistance of my cat, trying to discover the
    solution. After a few purrs, it occurred to me: the problem is the recursive function,
    which should have been my first clue.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我在猫的帮助下思考这个错误，试图找到解决方案。经过几声喵喵叫后，我想到：问题在于递归函数，这应该是我首先应该注意的线索。
- en: When the *find()* function returns, or “unwinds,” the previous value of pointer
    f is used—not the newly allocated value in the recursive call. Each time the function
    changes to the parent directory, the structures created in the linked list are
    lost because pointer f is reset to the original value passed to the function.
    Ugh.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *find()* 函数返回，或“展开”时，使用的是指针 f 的先前值，而不是递归调用中分配的新值。每次函数切换到父目录时，链表中创建的结构就会丢失，因为指针
    f 被重置为传递给函数的原始值。唉。
- en: 'Fortunately, the solution is simple: return pointer f.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，解决方案很简单：返回指针 f。
- en: 'Updating the code requires only three changes and one addition. First, the
    *find()* function’s data type must be changed from void to struct finfo*:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 更新代码只需要三个更改和一个添加。首先，*find()* 函数的数据类型必须从 void 更改为 struct finfo*：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Second, the recursive call must capture the function’s return value:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，递归调用必须捕获函数的返回值：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Effectively, this change updates pointer f to reflect its new value after the
    recursive call.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个更改更新了指针 f，以反映递归调用后的新值。
- en: 'Third, the *return* statement in the error check for the *chdir()* function
    must specify the value of variable f:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，在 *chdir()* 函数的错误检查中的 *return* 语句必须指定变量 f 的值：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And finally, the *find()* function must have a statement at the end to return
    the value of pointer f:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*find()* 函数必须在末尾有一个语句来返回指针 f 的值：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: These updates are found in the source code file finddupe02.c in the online repository.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更新可以在在线仓库的源代码文件 finddupe02.c 中找到。
- en: 'Upon building the code, the program accurately scans subdirectories—and retains
    the linked list when it changes back to the parent directory. The output is complete
    and accurate: a record is made via a linked list of all files found in the current
    directory as well as its subdirectories.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 构建代码后，程序能够准确扫描子目录，并且在返回父目录时保留链表。输出完整且准确：通过链表记录了当前目录及其子目录中找到的所有文件。
- en: 11.3.2 Locating the duplicates
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 定位重复项
- en: The purpose of creating a linked list in the *Find Dupe* program is to find
    duplicates. At some point, the list must be scanned and a determination made as
    to which filenames are repeated and in which directories the duplicates are found.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Find Dupe* 程序中创建链表的目的是为了找到重复项。在某个时刻，必须扫描列表，并确定哪些文件名是重复的，以及重复项在哪些目录中找到。
- en: 'I thought of several ways to accomplish this task. Most of them involved creating
    a second list of filenames. But I didn’t want to build list after list. Instead,
    I added a new member to the finfo structure, repeat, as shown in this updated
    structure definition:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我想到了几种完成这个任务的方法。其中大多数涉及创建第二个文件名列表。但我不想一个接一个地构建列表。相反，我在 finfo 结构中添加了一个新的成员，repeat，如下所示更新结构定义：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ New member to track repeated filenames
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 新成员用于跟踪重复的文件名
- en: The repeat member tracks how many times a name repeats. Its value is initialized
    to one in the *find()* function as each node is created. After all, every filename
    found exists at least once.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: repeat 成员跟踪一个名称重复的次数。它在 *find()* 函数中初始化为 1，因为每个节点被创建。毕竟，每个找到的文件名至少存在一次。
- en: To track repeated filenames, the repeat member is incremented as the list is
    scanned after its creation. In the *main()* function, a nested loop works like
    a bubble sort. It compares each node in the list sequentially with the rest of
    the nodes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪重复的文件名，在创建列表后扫描列表时，repeat 成员会增加。在 *main()* 函数中，嵌套循环就像冒泡排序一样工作。它按顺序将列表中的每个节点与列表中的其余节点进行比较。
- en: 'To perform the second scan, I need another *struct* finfo variable declared
    in the *main()* function. This variable, *scan, is used in addition to *first
    and *current to scan the linked list:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行第二次扫描，我需要在*main()*函数中声明另一个*struct* finfo变量。这个变量*scan，除了*first和*current外，还用于扫描链表：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The nested *while* loop is added just before the *while* loop that outputs the
    list. This nested loop uses the *current pointer to process the entire linked
    list. The *scan pointer is used in an inner *while* loop to compare the current->name
    member with subsequent name members. When a match is found, the current->repeat
    structure member for the file with the repeated name is incremented, as shown
    here.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出列表的*while*循环之前添加嵌套的*while*循环。此嵌套循环使用*current指针处理整个链表。*scan指针在内层*while*循环中使用，以比较current->name成员与后续的name成员。当找到匹配项时，具有重复名称的文件的current->repeat结构成员递增，如下所示。
- en: Listing 11.8 The nested *while* loops added to the *main()* function in finddupe03.c
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.8 finddupe03.c中*main()*函数中添加的嵌套*while*循环
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Loops through the list until the value of current is NULL
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 循环遍历列表，直到current的值为NULL
- en: ❷ Skips the first, empty entry
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 跳过第一个空条目
- en: ❸ Obtains the address of the next entry, where the scanning starts
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取下一个条目的地址，扫描从这里开始
- en: ❹ Loops until scan references the final (NULL) node in the list
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 循环直到扫描引用列表中的最后一个（NULL）节点
- en: ❺ Compares the filenames
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 比较文件名
- en: ❻ If the names are identical, increments the repeat counter for the current
    entry
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 如果名称相同，则递增当前条目的重复计数器
- en: ❼ Continues the scan
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 继续扫描
- en: ❽ Continues incrementing through the entire list, comparing each node with the
    rest of the list
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 继续在整个列表中递增，比较每个节点与列表中的其余部分
- en: 'These nested loops update the repeat member of structures containing identical
    filenames. They’re followed by the existing *while* loop that outputs the list.
    The *printf()* statement in that second loop is updated to output the repeat value:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这些嵌套循环更新包含相同文件名的结构的repeat成员。它们后面跟着现有的输出列表的*while*循环。该循环中的*printf()*语句更新为输出重复值：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'All these changes are found in the finddupe03.c source code file, available
    in the online repository. The output doesn’t yet show duplicate files. This incremental
    improvement to the *Find Dupe* series of source code files merely outputs the
    same, full file list, but with the number of repeats shown at the end of the file
    pathname string:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些更改都可在finddupe03.c源代码文件中找到，该文件可在在线仓库中获取。输出尚未显示重复文件。对*Find Dupe*系列源代码文件的这一增量改进仅输出相同的完整文件列表，但文件路径字符串末尾显示了重复次数：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The next update to the *Find Dupe* program is found in source code file finddupe04.c.
    Obtain this source code file from the online repository, and display it in an
    editor. Follow along with the text to review the two improvements I’ll make.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*Find Dupe*程序的下一个更新可在源代码文件finddupe04.c中找到。从在线仓库获取此源代码文件，并在编辑器中显示它。随着文本的进行，回顾我将进行的两个改进。'
- en: 'First, a new *int* variable found is declared in the *main()* function, up
    top where I prefer to set my variable declarations:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在*main()*函数顶部声明一个新的*int*变量found，这是我更喜欢设置变量声明的地方：
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When a repeating filename is discovered in the nested *while* loops, the value
    of found is reset to 1:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当在嵌套的*while*循环中发现重复的文件名时，found的值重置为1：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The value of found need not accumulate; it’s effectively a Boolean variable.
    When it stays at 0, no duplicate filenames are found and the following statements
    are executed:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 找到的值不需要累积；它实际上是一个布尔变量。当它保持在0时，没有找到重复的文件名，然后执行以下语句：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The “No duplicates found” message is output, then the program exits with a return
    value of 1.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 输出“未找到重复项”的消息，然后程序以返回值1退出。
- en: When the value of found has been reset to 1, duplicate filenames are detected.
    The second *while* loop in the *main()* function proceeds to process the list.
    This loop is updated to catch and output the repeats, as illustrated in the following
    listing. Again, the *scan variable is used in a nested *while* loop, but this
    time to output duplicate filenames and their pathnames.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当found的值重置为1时，检测到重复的文件名。在*main()*函数中的第二个*while*循环继续处理列表。此循环更新为捕获并输出重复项，如下所示。同样，*scan变量在嵌套的*while*循环中使用，但这次用于输出重复的文件名及其路径名。
- en: Listing 11.9 A second nested *while* loop in the *main()* function in finddupe04.c
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.9 finddupe04.c中*main()*函数中的第二个嵌套*while*循环
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Churns through the entire list of files just as before
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如前所述，遍历整个文件列表
- en: ❷ Looks for items with a repeat count higher than 1
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 寻找重复计数大于1的项
- en: ❸ Outputs the number of duplicates for the given filename
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输出给定文件名的重复数量
- en: ❹ Outputs the current filename and its path
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 输出当前文件名及其路径
- en: ❺ Starts the nested loop to output the names and paths of matching filenames
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 开始嵌套循环以输出匹配文件名的名称和路径
- en: This update to the code in finddupe04.c outputs a shorter list, showing only
    those repeated filenames, plus listing all the duplicate names and their paths.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对finddupe04.c代码的这次更新输出了一个更短的列表，只显示那些重复的文件名，并列出所有重复的名称及其路径。
- en: 'For example, in my programming tree, I see five duplicates of the a.out file
    in the program’s output:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我的编程树中，我看到程序输出中有五个a.out文件的重复：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The problem is that the duplicates also show duplicates. So, the output continues
    for the same filename as follows for multiple occurrences of the a.out file:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，重复项也显示了重复。因此，对于a.out文件的多次出现，输出继续如下：
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This output is inefficient because it repeatedly lists the duplicates. The reason
    is that the repeat member for repeated filename structures in the linked list
    is greater than 1\. Because this value doesn’t change when the first repeated
    filename is output, the code catches all the duplicates.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这种输出效率低下，因为它反复列出重复项。原因是链表中重复的文件名结构中的重复成员大于1。因为这个值在第一个重复的文件名输出时不会改变，所以代码捕获了所有重复项。
- en: This problem frustrated me because I didn’t want to create yet another structure
    member nor did I want to return to rehab. My goal is to avoid exceptions in an
    already complex, nested *while* loop.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题让我很沮丧，因为我既不想创建另一个结构成员，也不想回到康复中心。我的目标是避免在一个已经复杂且嵌套的*while*循环中产生异常。
- en: 'I stewed over this problem for a while, but eventually inspiration hit me,
    and a one-line solution presented itself:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这个问题思考了一段时间，但最终灵感来了，一个一行解决方案呈现在眼前：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This single statement is added to the second nested *while* loop, shown in
    listing 11.9\. It appears after the matching filename is detected:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这条语句被添加到第二个嵌套*while*循环中，如列表11.9所示。它在检测到匹配的文件名之后出现：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the nested *while* loop, after the repeated filename is output, its repeat
    value is reset to 0\. This change prevents a repeated filename from appearing
    later in the output. This change is available in the source code file finddupe05.c.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌套*while*循环中，在输出重复的文件名之后，其重复值被重置为0。这种更改防止了重复的文件名在输出中再次出现。这种更改在源代码文件finddupe05.c中可用。
- en: 'The *Find Dupe* program is complete: it scans the current directory structure
    and lists matching filenames, showing the full pathname for all duplicates.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*Find Dupe*程序已完成：它扫描当前目录结构，列出匹配的文件名，显示所有重复项的完整路径名。'
- en: Like all code, the *Find Dupe* series can be improved upon. For example, the
    file’s size could be added to the finfo structure. Filename matches and file size
    matches could be output. And you could go whole hog and try to match file contents
    as well. The basic framework for whatever system you need is provided in the existing
    code. All that’s left is your desire to improve upon it and the time necessary
    to anticipate all those unexpected things that are bound to happen along the way.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有代码一样，*Find Dupe*系列可以进一步改进。例如，可以将文件大小添加到finfo结构中。可以输出文件名匹配和文件大小匹配。你也可以全力以赴，尝试匹配文件内容。所需系统的基本框架已在现有代码中提供。剩下的只是你改进它的愿望和必要的时间来预见那些注定会在过程中发生的不期而遇的事情。
