- en: 5 Mapping persistent classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 映射持久化类
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding entities and value types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解实体和值类型
- en: Mapping entity classes with identity
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标识符映射实体类
- en: Controlling entity-level mapping options
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制实体级映射选项
- en: This chapter presents some fundamental mapping options and explains how to map
    entity classes to SQL tables. This is essential knowledge for structuring classes
    in an application, no matter whether you work with Hibernate, Spring Data JPA,
    or some other persistence framework that implement the JPA specification. We’ll
    demonstrate and analyze how you can handle database identity and primary keys,
    and how you can use various other metadata settings to customize how Hibernate
    or Spring Data JPA using Hibernate as a persistence provider will load and store
    instances of your domain model classes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些基本的映射选项，并解释了如何将实体类映射到 SQL 表。这是在应用程序中构建类的基本知识，无论您是使用 Hibernate、Spring
    Data JPA 还是其他实现 JPA 规范的持久化框架。我们将演示和分析您如何处理数据库标识符和主键，以及您如何使用各种其他元数据设置来自定义 Hibernate
    或 Spring Data JPA（以 Hibernate 作为持久化提供者）如何加载和存储您的领域模型类的实例。
- en: Spring Data JPA, as a data access abstraction, sits on top of a JPA provider
    (such as Hibernate) and will significantly reduce the boilerplate code required
    to interact with the database. That is why, once the mapping of persistent classes
    is made, it can be used both from Hibernate and from Spring Data JPA. Our examples
    will demonstrate this, and all our mapping examples will use JPA annotations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JPA 作为一种数据访问抽象，位于 JPA 提供者（如 Hibernate）之上，并将显著减少与数据库交互所需的样板代码。这就是为什么一旦持久化类的映射完成，它就可以从
    Hibernate 和 Spring Data JPA 中使用。我们的示例将演示这一点，并且我们所有的映射示例都将使用 JPA 注解。
- en: Before we look at mapping, though, we’ll define the essential distinction between
    entities and value types and explain how you should approach the object/relational
    mapping of your domain model. The role of the engineer is to make the connection
    between the *application domain*, which is the environment of the problem that
    the system needs to address, and the *solution domain*, which is the software
    and the technologies that will build this system. In figure 5.1, the application
    domain is represented by the application domain model (the real entities), while
    the solution domain is represented by the system model (the objects from the software
    application).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看映射之前，我们将定义实体和值类型之间的基本区别，并解释您应该如何处理领域模型的面向对象/关系映射。工程师的角色是在 *应用领域*（即系统需要解决的问题的环境）和
    *解决方案领域*（即构建此系统的软件和技术）之间建立联系。在图 5.1 中，应用领域由应用领域模型（真实实体）表示，而解决方案领域由系统模型（软件应用中的对象）表示。
- en: '![](../../OEBPS/Images/CH05_F01_Tudose2.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH05_F01_Tudose2.png)'
- en: Figure 5.1 The different domains and models to be connected
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 需要连接的不同领域和模型
- en: 5.1 Understanding entities and value types
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 理解实体和值类型
- en: 'When you look at your domain model, you’ll notice a difference between classes:
    some of the types seem more important, representing first-class business objects
    (the term *object* is used here in its natural sense). Some examples are the `Item`,
    `Category`, and `User` classes: these are entities in the real world that you’re
    trying to represent (refer to figure 3.3 for a view of the example domain model).
    Other types present in your domain model, such as `Address`, seem less important.
    In this section, we’ll look at what it means to use fine-grained domain models
    and make the distinction between entities and value types.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当您查看您的领域模型时，您会注意到类之间的差异：一些类型似乎更重要，代表一等业务对象（这里的 *对象* 一词使用其自然意义）。一些例子是 `Item`、`Category`
    和 `User` 类：这些是在现实世界中您试图表示的实体（参见图 3.3 以查看示例领域模型）。在您的领域模型中出现的其他类型，如 `Address`，似乎不太重要。在本节中，我们将探讨使用细粒度领域模型的意义，并区分实体和值类型。
- en: 5.1.1 Fine-grained domain models
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 细粒度领域模型
- en: A major objective of Hibernate and Spring Data JPA using Hibernate as a persistence
    provider is providing support for fine-grained and rich domain models. It’s one
    reason we work with POJOs (Plain Old Java Objects)—regular Java objects not bound
    to any framework. In crude terms, *fine-grained* means having more classes than
    tables.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 和 Spring Data JPA（以 Hibernate 作为持久化提供者）的一个主要目标是提供对细粒度和丰富领域模型的支持。这也是我们与
    POJOs（Plain Old Java Objects）合作的原因——普通的 Java 对象，不受任何框架的约束。粗略地说，*细粒度*意味着拥有比表更多的类。
- en: For example, a user may have a home address in your domain model. In the database,
    you may have a single `USERS` table with the columns `HOME_STREET`, `HOME_CITY`,
    and `HOME_ZIPCODE`. (Remember the problem of SQL types we discussed in section
    1.2.1?) In the domain model, you could use the same approach, representing the
    address as three string-valued properties of the `User` class. But it’s much better
    to model this using an `Address` class, where `User` has a `homeAddress` property.
    This domain model achieves improved cohesion and greater code reuse, and it’s
    more understandable than SQL with inflexible type systems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在领域模型中，一个用户可能有一个家庭地址。在数据库中，你可能有一个包含 `HOME_STREET`、`HOME_CITY` 和 `HOME_ZIPCODE`
    列的单一 `USERS` 表。（还记得我们在 1.2.1 节中讨论的 SQL 类型问题吗？）在领域模型中，你可以使用相同的方法，将地址表示为 `User`
    类的三个字符串值属性。但使用 `Address` 类来建模会更好，其中 `User` 有一个 `homeAddress` 属性。这个领域模型实现了更好的内聚性和更大的代码重用，并且比具有不灵活类型系统的
    SQL 更易于理解。
- en: JPA emphasizes the usefulness of fine-grained classes for implementing type
    safety and behavior. For example, many people model an email address as a string-valued
    property of `User`. However, a more sophisticated approach is to define an `EmailAddress`
    class, which adds higher-level semantics and behavior. It may provide a `prepareMail()`
    method (but it shouldn’t have a `sendMail()` method, because you don’t want your
    domain model classes to depend on the mail subsystem).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 强调了细粒度类在实现类型安全和行为方面的有用性。例如，许多人将电子邮件地址建模为 `User` 的字符串值属性。然而，一个更复杂的方法是定义一个
    `EmailAddress` 类，它添加了更高级别的语义和行为。它可能提供 `prepareMail()` 方法（但不应该有 `sendMail()` 方法，因为你不希望你的领域模型类依赖于邮件子系统）。
- en: This granularity problem leads us to a distinction of central importance in
    ORM. In Java, all classes are of equal standing—all instances have their own identity
    and lifecycle. When you introduce persistence, some instances may not have their
    own identity and lifecycle but instead depend on others. Let’s walk through an
    example.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个粒度问题使我们区分了 ORM 中的一个中心问题。在 Java 中，所有类都是平等的——所有实例都有自己的身份和生命周期。当你引入持久性时，一些实例可能没有自己的身份和生命周期，而是依赖于其他实例。让我们通过一个例子来了解一下。
- en: 5.1.2 Defining application concepts
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 定义应用程序概念
- en: Suppose two people live in the same house, and they both register user accounts
    in CaveatEmptor. Let’s call them John and Jane. An instance of `User` represents
    each account. Because you want to load, save, and delete these `User` instances
    independently, `User` is an entity class and not a value type. Finding entity
    classes is easy.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两个人住在同一个房子里，并且他们都在 CaveatEmptor 上注册了用户账户。让我们称他们为约翰和简。`User` 的一个实例代表每个账户。因为你想要独立地加载、保存和删除这些
    `User` 实例，所以 `User` 是一个实体类，而不是值类型。寻找实体类是容易的。
- en: The `User` class has a `homeAddress` property; it’s an association with the
    `Address` class. Do both `User` instances have a runtime reference to the same
    `Address` instance, or does each `User` instance have a reference to its own `Address`?
    Does it matter that John and Jane live in the same house?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 类有一个 `homeAddress` 属性；它与 `Address` 类相关联。`User` 的实例是否都引用同一个 `Address`
    实例，或者每个 `User` 实例都引用自己的 `Address`？约翰和简住在同一个房子里是否重要？'
- en: '![](../../OEBPS/Images/CH05_F02_Tudose2.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2](../../OEBPS/Images/CH05_F02_Tudose2.png)'
- en: Figure 5.2 Two `User` instances have a reference to a single `Address`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 两个 `User` 实例引用单个 `Address`。
- en: In figure 5.2, you can see how two `User` instances share a single `Address`
    instance representing their home address (this is a UML object diagram, not a
    class diagram). If `Address` is supposed to support shared runtime references,
    it’s an entity type. The `Address` instance has its own life. You can’t delete
    it when John removes his `User` account—Jane might still have a reference to the
    `Address`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 5.2 中，你可以看到两个 `User` 实例共享一个表示他们家庭地址的单个 `Address` 实例（这是一个 UML 对象图，而不是类图）。如果
    `Address` 应该支持共享的运行时引用，它就是一个实体类型。`Address` 实例有自己的生命周期。当约翰删除他的 `User` 账户时，你不能删除它——简可能仍然引用这个
    `Address`。
- en: 'Now let’s look at the alternative model, where each `User` has a reference
    to its own `homeAddress` instance, as shown in figure 5.3\. In this case, you
    can make an instance of `Address` dependent on an instance of `User`: you make
    it a value type. When John removes his `User` account, you can safely delete his
    `Address` instance. Nobody else will hold a reference to it.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一种模型，其中每个`User`都有一个对其自己的`homeAddress`实例的引用，如图5.3所示。在这种情况下，您可以使`Address`实例依赖于`User`实例：您将其作为值类型。当John删除他的`User`账户时，您可以安全地删除他的`Address`实例。没有人会持有对该实例的引用。
- en: '![](../../OEBPS/Images/CH05_F03_Tudose2.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH05_F03_Tudose2.png)'
- en: Figure 5.3 Two `User` instances each have their own dependent `Address`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 两个`User`实例各自有自己的依赖`Address`。
- en: 'Hence, we can make the following essential distinction:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以做出以下基本区分：
- en: '*Entity type*—You can retrieve an instance of an *entity type* using its persistent
    identity; for example, a `User`, `Item`, or `Category` instance. A reference to
    an entity instance (a pointer in the JVM) is persisted as a reference in the database
    (a foreign key–constrained value). An entity instance has its own lifecycle; it
    can exist independently of any other entity. You map selected classes of your
    domain model as entity types.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实体类型*—您可以使用其持久标识符检索一个*实体类型*的实例；例如，一个`User`、`Item`或`Category`实例。实体实例的引用（在JVM中是一个指针）作为数据库中的引用（一个外键约束值）持久化。实体实例有自己的生命周期；它可以独立于任何其他实体存在。您可以将域模型中选定的类映射为实体类型。'
- en: '*Value type*—An instance of a *value type* has no persistent identifier property;
    it belongs to an entity instance, and its lifespan is bound to the owning entity
    instance. A value-type instance doesn’t support shared references. You can map
    your own domain model classes as value types; for example, `Address` and `MonetaryAmount`.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*值类型*—一个*值类型*的实例没有持久标识符属性；它属于一个实体实例，其生命周期绑定到拥有该实体实例。值类型实例不支持共享引用。您可以将自己的域模型类映射为值类型；例如，`Address`和`MonetaryAmount`。'
- en: If you read the JPA specification, you’ll find the same concepts, but value
    types are called *basic property types* or *embeddable classes* in JPA. We’ll
    come back to this in the next chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您阅读JPA规范，您会发现相同的概念，但在JPA中值类型被称为*基本属性类型*或*可嵌入类*。我们将在下一章中回到这一点。
- en: Identifying entities and value types in your domain model isn’t an ad hoc task
    but follows a certain procedure.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的域模型中识别实体和值类型不是一项临时任务，而是遵循一定的程序。
- en: 5.1.3 Distinguishing entities and value types
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 区分实体和值类型
- en: You may find it helpful to add stereotype information to your UML class diagrams
    so you can immediately recognize entities and value types (stereotypes are a UML
    extensibility mechanism). This practice will also force you to think about this
    distinction for all your classes, which is the first step toward an optimal mapping
    and well-performing persistence layer. Figure 5.4 shows an example, with the stereotype
    information in the double angle brackets.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现，将构型信息添加到您的UML类图中很有帮助，这样您可以立即识别实体和价值类型（构型是UML的可扩展机制）。这种做法还将迫使您思考所有类的这种区别，这是实现最佳映射和良好性能持久层的第一步。图5.4展示了示例，其中构型信息位于双尖括号内。
- en: '![](../../OEBPS/Images/CH05_F04_Tudose2.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH05_F04_Tudose2.png)'
- en: Figure 5.4 Diagramming stereotypes for entities and value types
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 实体和价值类型的图示化构型
- en: The `Item` and `User` classes are obvious entities. They each have their own
    identity, their instances have references from many other instances (shared references),
    and they have independent lifespans.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item`和`User`类是明显的实体。它们各自有自己的标识符，它们的实例有来自许多其他实例的引用（共享引用），并且它们有独立的生命周期。'
- en: 'Marking `Address` as a value type is also easy: a single `User` instance references
    a particular `Address` instance. You know this because the association has been
    created as a composition, with the `User` instance being fully responsible for
    the lifecycle of the referenced `Address` instance. Therefore, `Address` instances
    can’t be referenced by anyone else and don’t need their own identity.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Address`标记为值类型也很简单：单个`User`实例引用特定的`Address`实例。您知道这一点是因为关联已被创建为组合，其中`User`实例完全负责引用的`Address`实例的生命周期。因此，`Address`实例不能被其他人引用，也不需要自己的标识符。
- en: The `Bid` class could be a problem. In object-oriented modeling, this is marked
    as a composition (the association between `Item` and `Bid` with the full diamond).
    Composition is a type of association where an object can only exist as part of
    a container. If the container is destroyed, then the included object is also destroyed.
    Thus, an `Item` is the owner of its `Bid` instances and holds a collection of
    references. The `Bid` instances cannot exist without the `Item`. At first, this
    seems reasonable, because bids in an auction system are useless when the item
    they were made for disappears.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bid`类可能存在问题。在面向对象建模中，这被标记为组合（`Item`和`Bid`之间的关联，带有完整的菱形）。组合是一种关联类型，其中对象只能作为容器的一部分存在。如果容器被销毁，那么包含的对象也会被销毁。因此，`Item`是其`Bid`实例的所有者，并持有引用集合。`Bid`实例在没有`Item`的情况下无法存在。起初，这似乎是合理的，因为当为拍卖系统中的物品制作的出价消失时，出价在拍卖系统中是无用的。'
- en: But what if a future extension of the domain model requires a `User#bids` collection
    containing all bids made by a particular `User`? Right now, the association between
    `Bid` and `User` is unidirectional; a `Bid` has a `bidder` reference. What if
    this was bidirectional?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果领域模型的未来扩展需要包含特定`User`所做所有出价的`User#bids`集合呢？目前，`Bid`和`User`之间的关联是单向的；一个`Bid`有一个`bidder`引用。如果这是双向的会怎样？
- en: In that case, you would have to deal with possible shared references to `Bid`
    instances, so the `Bid` class would need to be an entity. It has a dependent lifecycle,
    but it must have its own identity to support (future) shared references.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，你将不得不处理对`Bid`实例可能的共享引用，因此`Bid`类需要成为一个实体。它具有依赖的生命周期，但它必须有自己的身份以支持（未来的）共享引用。
- en: You’ll often find this kind of mixed behavior, but your first reaction should
    be to make everything a value-typed class and promote it to an entity only when
    absolutely necessary. `Bid` is a value type because its identity is defined by
    `Item` and `User`. This does not necessarily mean that it won’t live in its own
    table. Try to simplify your associations; persistent collections, for example,
    frequently add complexity without offering any advantages. Instead of mapping
    the `Item#bids` and `User#bids` collections, you can write queries to obtain all
    the bids for an `Item` and those made by a particular `User`. The associations
    in the UML diagram will point from the `Bid` *to* the `Item` and `User`, unidirectionally,
    and not the other way. The stereotype on the `Bid` class would then be `<<Value
    type>>`. We’ll come back to this point in chapter 8.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会遇到这种混合行为，但你的第一个反应应该是将所有内容都做成值类型类，并且只有在绝对必要时才将其提升为实体。`Bid`是一个值类型，因为它的身份由`Item`和`User`定义。这并不一定意味着它不会生活在自己的表中。尝试简化你的关联；例如，持久化集合经常增加复杂性，而不提供任何优势。你可以编写查询来获取`Item`的所有出价以及特定`User`所做的出价，而不是映射`Item#bids`和`User#bids`集合。UML图中的关联将单向地从`Bid`指向`Item`和`User`，而不是相反。`Bid`类的构造型将是`<<值类型>>`。我们将在第8章回到这个话题。
- en: 'Next, you can take your domain model diagram and implement POJOs for all entities
    and value types. You’ll have to take care of three things:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以将你的领域模型图转换为所有实体和值类型的POJO实现。你需要注意三件事：
- en: '*Shared references*—Avoid shared references to value type instances when you
    write your POJO classes. For example, make sure only one `User` can reference
    an `Address`. You can make `Address` immutable with no public `setUser()` method
    and enforce the relationship with a public constructor that has a `User` argument.
    Of course, you’ll still need a no-argument, probably protected constructor, as
    we discussed in chapter 3, so Hibernate or Spring Data JPA can also create an
    instance.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*共享引用*——在编写你的POJO类时，避免对值类型实例的共享引用。例如，确保只有一个`User`可以引用一个`Address`。你可以通过没有公共`setUser()`方法使`Address`不可变，并通过具有`User`参数的公共构造函数强制关系。当然，你仍然需要一个无参数的，可能受保护的构造函数，正如我们在第3章中讨论的那样，这样Hibernate或Spring
    Data JPA也可以创建实例。'
- en: '*Lifecycle dependencies*—If a `User` is deleted, its `Address` dependency will
    have to be deleted as well. Persistence metadata will include cascading rules
    for all such dependencies, so Hibernate, Spring Data JPA, or the database can
    take care of removing the obsolete `Address`. You must design your application
    procedures and user interface to respect and expect such dependencies—write your
    domain model POJOs accordingly.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生命周期依赖性*—如果删除一个`用户`，其`地址`依赖也将必须被删除。持久化元数据将包括所有此类依赖的级联规则，因此 Hibernate、Spring
    Data JPA 或数据库可以处理删除过时的`地址`。您必须设计应用程序流程和用户界面以尊重并期望此类依赖性—相应地编写您的领域模型 POJO。'
- en: '*Identity*—Entity classes need an identifier property in almost all cases.
    Value type classes (and, of course, JDK classes such as `String` and `Integer`)
    don’t have an identifier property because instances are identified through the
    owning entity.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*身份*—在几乎所有情况下，实体类都需要一个标识属性。值类型类（当然，还包括像`String`和`Integer`这样的 JDK 类）没有标识属性，因为实例是通过拥有它们的实体来识别的。'
- en: We’ll come back to references, associations, and lifecycle rules when we discuss
    more advanced mappings in later chapters. Object identity and identifier properties
    are our next topic.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在后面的章节中讨论更高级的映射时，我们将回到引用、关联和生命周期规则。对象身份和标识属性是我们下一个话题。
- en: 5.2 Mapping entities with identity
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 使用身份映射实体
- en: Mapping entities with identity requires you to understand Java identity and
    equality. Once you know that, we can walk through an entity class example and
    its mapping, discuss terms like *database identity*, and look at how JPA manages
    identity. After that, we’ll be able to dig in deeper and select a primary key,
    configure key generators, and finally go through identifier generator strategies.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用身份映射实体需要您理解 Java 的身份和相等性。一旦您知道了这一点，我们就可以通过一个实体类示例及其映射来探讨，讨论像*数据库身份*这样的术语，并查看
    JPA 如何管理身份。之后，我们将能够深入挖掘并选择主键，配置键生成器，并最终通过标识生成器策略。
- en: 5.2.1 Understanding Java identity and equality
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 理解 Java 的身份和相等性
- en: Java developers understand the difference between Java object identity and equality.
    Object identity (`==`) is a notion defined by the Java virtual machine. Two references
    are identical if they point to the same memory location.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Java 开发者理解 Java 对象身份和相等性之间的区别。对象身份（`==`）是由 Java 虚拟机定义的一个概念。如果两个引用指向相同的内存位置，则它们是相同的。
- en: Object equality, on the other hand, is a notion defined by a class’s `equals()`
    method, sometimes also referred to as *equivalence*. Equivalence means two different
    (non-identical) instances have the same value—the same state. If you have a stack
    of freshly printed books of the same kind, and you have to choose one of them,
    it means you will have to choose one from several non-identical but equivalent
    objects.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，对象相等性是由类的`equals()`方法定义的一个概念，有时也称为*等价性*。等价性意味着两个不同的（非相同的）实例具有相同的值—相同的状态。如果您有一堆同类的全新书籍，您必须从中选择一本，这意味着您将不得不从几个非相同但等价的对象中选择一本。
- en: Two different instances of `String` are equal if they represent the same sequence
    of characters, even though each has its own location in the memory space of the
    virtual machine. (If you’re a Java guru, we acknowledge that `String` is a special
    case. Assume we used a different class to make the same point.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 两个不同的`String`实例如果表示相同的字符序列，则它们是相等的，尽管每个实例在虚拟机的内存空间中都有自己的位置。（如果您是 Java 大师，我们承认`String`是一个特殊情况。假设我们使用了一个不同的类来阐述同样的观点。）
- en: 'Persistence complicates this picture. With object/relational persistence, a
    persistent instance is an in-memory representation of a particular row (or rows)
    of a database table (or tables). Along with Java identity and equality, we define
    *database identity*. You now have three methods for distinguishing references:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化使这个情况变得复杂。在对象/关系持久化中，持久化实例是数据库表（或表）中特定行（或行）的内存表示。除了 Java 的身份和相等性之外，我们还定义了*数据库身份*。现在您有三种方法来区分引用：
- en: '*Object identify*—Objects are identical if they occupy the same memory location
    in the JVM. This can be checked with the `a` `==` `b` operator. This concept is
    known as *object identity*.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对象身份*—如果对象在 JVM 中占据相同的内存位置，则它们是相同的。这可以通过`a == b`运算符来检查。这个概念被称为*对象身份*。'
- en: '*Object equality*—Objects are equal if they have the same state, as defined
    by the `a.equals(Object b)` method. Classes that don’t explicitly override this
    method inherit the implementation defined by `java.lang.Object`, which compares
    object identity with `==`. This concept is known as *object equality*. As you’ll
    probably recall, the properties of object equality are reflexivity, symmetry,
    and transitivity. One thing they imply is that if `a == b`, then both `a.equals(b)`
    and `b.equals(a)` should be true.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对象相等性*——如果对象具有相同的由 `a.equals(Object b)` 方法定义的状态，则它们是相等的。没有显式重写此方法的类继承由 `java.lang.Object`
    定义的实现，该实现通过 `==` 比较对象身份。这个概念被称为 *对象相等性*。你可能还记得，对象相等性的属性是自反性、对称性和传递性。它们暗示的一件事是，如果
    `a == b`，那么 `a.equals(b)` 和 `b.equals(a)` 都应该是真的。'
- en: '*Database identity*—Objects stored in a relational database are identical if
    they share the same table and primary key value. This concept, mapped into the
    Java space, is known as *database identity*.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数据库身份*——存储在关系数据库中的对象如果它们共享相同的表和主键值，则被认为是相同的。这个概念映射到 Java 空间中，被称为 *数据库身份*。'
- en: We now need to look at how database identity relates to object identity and
    how we can express database identity in the mapping metadata. As an example, you’ll
    map an entity of a domain model.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要探讨数据库身份与对象身份之间的关系，以及我们如何在映射元数据中表达数据库身份。作为一个例子，你将映射一个领域模型中的实体。
- en: 5.2.2 A first entity class and mapping
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 第一个实体类及其映射
- en: The `@Entity` annotation isn’t enough to map a persistent class. You’ll also
    need an `@Id` annotation, as shown in the following listing (see the `generator`
    folder for the source code).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Entity` 注解不足以映射一个持久化类。你还需要一个 `@Id` 注解，如以下列表所示（源代码请参阅 `generator` 文件夹）。'
- en: Note To execute the examples from the source code, you’ll first need to run
    the Ch05.sql script.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要执行源代码中的示例，你首先需要运行 Ch05.sql 脚本。
- en: Listing 5.1 Mapped `Item` entity class with an identifier property
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 带有标识属性映射的 `Item` 实体类
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the most basic entity class, marked as “persistence capable” with the
    `@Entity` annotation and with an `@Id` mapping for the database identifier property.
    The class maps by default to a table named `ITEM` in the database schema.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个最基本的实体类，使用 `@Entity` 注解标记为“持久化能力”，并为数据库标识属性提供了一个 `@Id` 映射。该类默认映射到数据库模式中的名为
    `ITEM` 的表。
- en: Every entity class has to have an `@Id` property; it’s how JPA exposes database
    identity to the application. We haven’t shown the identifier property in our diagrams,
    but we assume that each entity class has one. In our examples, we always name
    the identifier property `id`. This is a good practice for your own projects; use
    the same identifier prop- erty name for all your domain model entity classes.
    If you specify nothing else, this property maps to a primary key column named
    `ID` in the table in your database schema.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实体类都必须有一个 `@Id` 属性；这是 JPA 向应用程序暴露数据库身份的方式。在我们的图中，我们没有展示标识属性，但我们假设每个实体类都有一个。在我们的示例中，我们总是将标识属性命名为
    `id`。这对于你的项目来说是一个好的实践；为所有你的领域模型实体类使用相同的标识属性名称。如果你没有指定其他内容，这个属性将映射到数据库模式中的表的主键列
    `ID`。
- en: 'Hibernate and Spring Data JPA will use the field to access the identifier property
    value when loading and storing items, not getter or setter methods. Because `@Id`
    is on a field, Hibernate or Spring Data JPA will enable every field of the class
    as a persistent property by default. The rule in JPA is this: if `@Id` is on a
    field, the JPA provider will access fields of the class directly and consider
    all fields to be part of the persistent state by default. In our experience, field
    access is often a better choice than using an accessor, because it gives you more
    freedom for accessor method design.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 和 Spring Data JPA 将使用该字段在加载和存储项目时访问标识属性值，而不是 getter 或 setter 方法。因为
    `@Id` 在字段上，Hibernate 或 Spring Data JPA 默认将类的每个字段都启用为持久化属性。JPA 的规则是：如果 `@Id` 在字段上，JPA
    提供商将直接访问类的字段，并默认将所有字段视为持久状态的一部分。根据我们的经验，字段访问通常比使用访问器更好，因为它为你提供了更多访问器方法设计的自由度。
- en: Should you have a public getter method for the identifier property? Applications
    often use database identifiers as convenient handles for particular instances,
    even outside the persistence layer. For example, it’s common for web applications
    to display the results of a search to the user as a list of summaries. When the
    user selects a particular element, the application may need to retrieve the selected
    item, and it’s common to use a lookup by identifier for this purpose—you’ve probably
    already used identifiers this way, even in applications that rely on JDBC.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该有一个公共获取器方法来获取标识属性吗？应用程序通常将数据库标识符用作特定实例的方便处理方式，即使在持久化层之外也是如此。例如，对于网络应用程序来说，将搜索结果以摘要列表的形式显示给用户是很常见的。当用户选择特定元素时，应用程序可能需要检索所选项目，并且通常使用标识符查找来达到这个目的——你可能已经以这种方式使用标识符，即使在依赖于
    JDBC 的应用程序中也是如此。
- en: Should you have a setter method? Primary key values never change, so you shouldn’t
    allow the identifier property value to be modified. Hibernate and Spring Data
    JPA using Hibernate as a provider won’t update a primary key column, and you shouldn’t
    expose a public identifier setter method on an entity.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该有一个设置器方法吗？主键的值永远不会改变，因此你不应该允许标识属性值被修改。Hibernate 和 Spring Data JPA 使用 Hibernate
    作为提供者时不会更新主键列，你不应该在实体上公开标识符设置器方法。
- en: The Java type of the identifier property, `java.lang.Long` in the previous example,
    depends on the primary key column type in the `ITEM` table and how key values
    are produced. This brings us to the `@GeneratedValue` annotation, and to primary
    keys in general.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 标识属性属性的 Java 类型，如前例中的 `java.lang.Long`，取决于 `ITEM` 表中的主键列类型以及键值的生成方式。这引出了 `@GeneratedValue`
    注解，以及主键的一般概念。
- en: 5.2.3 Selecting a primary key
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 选择主键
- en: The database identifier of an entity is mapped to a table’s primary key, so
    let’s first get some background on primary keys without worrying about mappings.
    Take a step back and think about how you identify entities.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实体的数据库标识符映射到表的主键，因此我们首先了解一下主键的背景，不必担心映射问题。退一步想想，你是如何识别实体的。
- en: 'A *candidate key* is a column or set of columns that you could use to identify
    a particular row in a table. To become the primary key, a candidate key must satisfy
    the following requirements:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*候选键* 是一个或一组列，你可以用它来识别表中的特定行。要成为主键，候选键必须满足以下要求：'
- en: The value of any candidate key column is never null. You can’t identify something
    with data that is unknown, and there are no nulls in the relational model. Some
    SQL products allow you to define (composite) primary keys with nullable columns,
    so you must be careful.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何候选键列的值永远不会为空。你不能用未知的数据来识别某物，关系模型中没有空值。一些 SQL 产品允许你定义（组合）主键，其中包含可空列，因此你必须小心。
- en: The value of the candidate key column (or columns) is a unique value for any
    row.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 候选键列（或列）的值对于任何行都是唯一的。
- en: The value of the candidate key column (or columns) never changes; it’s immutable.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 候选键列（或列）的值永远不会改变；它是不可变的。
- en: Must primary keys be immutable?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 主键必须是不可变的吗？
- en: The relational model requires that a candidate key must be unique and irreducible
    (no subset of the key attributes has the uniqueness property). Beyond that, picking
    a candidate key as *the* primary key is a matter of taste. But Hibernate and Spring
    Data JPA expect a candidate key to be immutable when it’s used as the primary
    key. Hibernate and Spring Data JPA with Hibernate as a provider don’t support
    updating primary key values with an API; if you try to work around this requirement,
    you’ll run into problems with Hibernate’s caching and dirty-checking engine. If
    your database schema relies on updatable primary keys (and maybe uses `ON` `UPDATE`
    `CASCADE` foreign key constraints), you must change the schema before it will
    work with Hibernate or Spring Data JPA using Hibernate as provider.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关系模型要求候选键必须是唯一的且不可约的（键属性子集没有唯一性属性）。除此之外，选择候选键作为 *主键* 是一个品味问题。但 Hibernate 和 Spring
    Data JPA 预期候选键在用作主键时是不可变的。Hibernate 和 Spring Data JPA 使用 Hibernate 作为提供者时不支持通过
    API 更新主键值；如果你试图绕过这个要求，你会在 Hibernate 的缓存和脏检查引擎中遇到问题。如果你的数据库模式依赖于可更新的主键（并且可能使用 `ON
    UPDATE CASCADE` 外键约束），你必须在该模式与 Hibernate 或 Spring Data JPA 使用 Hibernate 作为提供者之前更改该模式。
- en: If a table has only one identifying attribute, it becomes, by definition, the
    primary key. But several columns or combinations of columns may satisfy these
    properties for a particular table; you can choose between candidate keys to decide
    on the best primary key for the table. You should declare candidate keys that
    are not chosen as the primary key as unique keys in the database if their values
    are indeed unique (but maybe not immutable).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个表只有一个标识属性，那么根据定义，它就是主键。但几个列或列的组合可能满足特定表的这些属性；您可以在候选键之间进行选择，以决定表的最佳主键。如果它们的值确实是唯一的（但可能不是不可变的），那么您应该在数据库中将未选择的候选键声明为唯一键。
- en: 'Many legacy SQL data models use natural primary keys. A *natural key* is a
    key with business meaning: an attribute or combination of attributes that is unique
    by virtue of its business semantics. Examples of natural keys are the US Social
    Security Number and Australian Tax File Number. Distinguishing natural keys is
    simple: if a candidate key attribute has meaning outside the database context,
    it’s a natural key, regardless of whether it’s automatically generated. Think
    about the application’s users: if they refer to a key attribute when talking about
    and working with the application, it’s a natural key: “Can you send me the pictures
    of item #A23-abc?”'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 许多遗留的SQL数据模型使用自然主键。*自然键*是一个具有业务意义的键：一个或多个属性的组合，其唯一性源于其业务语义。自然键的例子包括美国的社保号码和澳大利亚的税号。区分自然键很简单：如果候选键属性在数据库上下文之外有意义，那么它就是一个自然键，无论它是否是自动生成的。考虑应用程序的用户：如果他们在讨论和操作应用程序时引用键属性，那么它就是一个自然键：“你能把A23-abc项目的图片发给我吗？”
- en: Experience has shown that natural primary keys usually cause problems in the
    end. A good primary key must be unique, immutable, and never null. Few entity
    attributes satisfy these requirements, and some that do can’t be efficiently indexed
    by SQL databases (although this is an implementation detail and shouldn’t be the
    deciding factor for or against a particular key). You should also make certain
    that a candidate key definition never changes throughout the lifetime of the database.
    Changing the value (or even the definition) of a primary key and all foreign keys
    that refer to it is a frustrating task. Expect your database schema to survive
    decades, even if your application won’t.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 经验表明，自然主键通常最终会引发问题。一个好的主键必须是唯一的、不可变的且永不为空。很少有实体属性满足这些要求，而且一些满足这些要求的属性可能无法被SQL数据库有效地索引（尽管这是一个实现细节，不应成为决定或反对特定键的因素）。您还应该确保候选键的定义在整个数据库生命周期中永不改变。更改主键的值（甚至定义）以及所有引用它的外键是一个令人沮丧的任务。预期您的数据库架构将生存数十年，即使您的应用程序不会。
- en: Furthermore, you can often only find natural candidate keys by combining several
    columns in a *composite* natural key. These composite keys, although certainly
    appropriate for some schema artifacts (like a link table in a many-to-many relationship),
    potentially make maintenance, ad hoc queries, and schema evolution much more difficult.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您通常只能通过组合一个*复合*自然键的几个列来找到自然候选键。这些复合键，尽管对于某些架构工件（如多对多关系中的链接表）肯定适用，但可能会使维护、即席查询和架构演变变得更加困难。
- en: For these reasons, we strongly recommend that you add synthetic identifiers,
    also called *surrogate keys*. Surrogate keys have no business meaning—they have
    unique values generated by the database or application. Application users ideally
    won’t see or refer to these key values; they’re part of the system’s internals.
    Introducing a surrogate key column is also appropriate in the common situation
    where there are no candidate keys. In other words, almost every table in your
    schema should have a dedicated surrogate primary key column with only this purpose.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，我们强烈建议您添加合成标识符，也称为*代理键*。代理键没有业务意义——它们是由数据库或应用程序生成的唯一值。理想情况下，应用程序用户不会看到或引用这些键值；它们是系统内部的一部分。在没有候选键的常见情况下，引入代理键列也是合适的。换句话说，您架构中的几乎每个表都应该有一个专门的代理主键列，仅为此目的。
- en: There are several well-known approaches to generating surrogate key values.
    The aforementioned `@GeneratedValue` annotation is how you configure this.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几种生成代理键值的方法。前面提到的`@GeneratedValue`注解就是如何配置这个的。
- en: 5.2.4 Configuring key generators
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 配置键生成器
- en: The `@Id` annotation is required to mark the identifier property of an entity
    class. Without the `@GeneratedValue` next to it, the JPA provider assumes that
    you’ll take care of creating and assigning an identifier value before you save
    an instance. We call this an *application-assigned* identifier. Assigning an entity
    identifier manually is necessary when you’re dealing with a legacy database or
    natural primary keys.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Id`注解是必需的，用于标记实体类的标识符属性。如果没有紧挨着`@GeneratedValue`，JPA提供者会假设你在保存实例之前会负责创建和分配标识符值。我们称这种标识符为*应用程序分配的*标识符。当你处理遗留数据库或自然主键时，手动分配实体标识符是必要的。'
- en: 'Usually you’ll want the system to generate a primary key value when you save
    an entity instance, so you can write the `@GeneratedValue` annotation next to
    `@Id`. JPA standardizes several value-generation strategies with the `javax.persistence.GenerationType`
    enum, which you select with `@GeneratedValue(strategy = ...)`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你希望在保存实体实例时让系统生成主键值，所以你可以将`@GeneratedValue`注解放在`@Id`旁边。JPA使用`javax.persistence.GenerationType`枚举标准化了几个值生成策略，你可以通过`@GeneratedValue(strategy
    = ...)`来选择：
- en: '`GenerationType.AUTO`—Hibernate (or Spring Data JPA using Hibernate as a persistence
    provider) picks an appropriate strategy, asking the SQL dialect of your configured
    database what is best. This is equivalent to `@GeneratedValue()` without any settings.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GenerationType.AUTO`—Hibernate（或使用Hibernate作为持久化提供者的Spring Data JPA）会选择一个合适的策略，询问配置的数据库的SQL方言什么是最合适的。这相当于没有设置任何内容的`@GeneratedValue()`。'
- en: '`GenerationType.SEQUENCE`—Hibernate (or Spring Data JPA using Hibernate as
    a persistence provider) expects (and creates, if you use the tools) a sequence
    named `HIBERNATE_SEQUENCE` in your database. The sequence will be called separately
    before every `INSERT`, producing sequential numeric values.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GenerationType.SEQUENCE`—Hibernate（或使用Hibernate作为持久化提供者的Spring Data JPA）期望（如果你使用工具，则会创建）一个名为`HIBERNATE_SEQUENCE`的序列在你的数据库中。在每次`INSERT`之前，将单独调用序列，生成顺序数值。'
- en: '`GenerationType.IDENTITY`—Hibernate (or Spring Data JPA using Hibernate as
    a persistence provider) expects (and creates in table DDL) a special auto-incremented
    primary key column that automatically generates a numeric value on `INSERT` in
    the database.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GenerationType.IDENTITY`—Hibernate（或使用Hibernate作为持久化提供者的Spring Data JPA）期望（并在表DDL中创建）一个特殊的自增主键列，该列在数据库中`INSERT`时自动生成一个数值。'
- en: '`GenerationType.TABLE`—Hibernate (or Spring Data JPA using Hibernate as a persistence
    provider) will use an extra table in your database schema that holds the next
    numeric primary key value, with one row for each entity class. This table will
    be read and updated before `INSERT`s. The default table name is `HIBERNATE_SEQUENCES`
    with the columns `SEQUENCE_NAME` and `NEXT_VALUE`.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GenerationType.TABLE`—Hibernate（或使用Hibernate作为持久化提供者的Spring Data JPA）将在你的数据库模式中使用一个额外的表，该表包含下一个数值主键值，每个实体类有一行。在`INSERT`之前，将读取和更新此表。默认表名为`HIBERNATE_SEQUENCES`，包含`SEQUENCE_NAME`和`NEXT_VALUE`列。'
- en: Although `AUTO` seems convenient, you’ll sometimes need more control over how
    IDs are created, so you usually should instead explicitly configure a primary
    key genera- tion strategy. Most applications work with database sequences, but
    you may want to customize the name and other settings of the database sequence.
    Therefore, instead of picking one of the JPA strategies, you can map the identifier
    with `@GeneratedValue (generator` `=` `"ID_GENERATOR")`, as shown in listing 5.1\.
    This is a *named* identifier generator; you are now free to set up the `ID_GENERATOR`
    configuration independently of your entity classes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`AUTO`看起来很方便，但有时你需要对ID的创建有更多的控制，所以通常你应该明确配置一个主键生成策略。大多数应用程序使用数据库序列，但你可能想自定义数据库序列的名称和其他设置。因此，而不是选择JPA策略之一，你可以使用`@GeneratedValue(generator="ID_GENERATOR")`将标识符映射，如列表5.1所示。这是一个*命名*的标识符生成器；你现在可以独立于你的实体类设置`ID_GENERATOR`配置。
- en: 'JPA has two built-in annotations you can use to configure named generators:
    `@javax .persistence.SequenceGenerator` and `@javax.persistence.TableGenerator`.
    With these annotations, you can create a named generator with your own sequence
    and table names. As usual with JPA annotations, you can unfortunately only use
    them at the top of a (maybe otherwise empty) class and not in a package-info.java
    file.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: JPA有两个内置的注解可以用来配置命名生成器：`@javax.persistence.SequenceGenerator`和`@javax.persistence.TableGenerator`。使用这些注解，你可以创建一个具有自己的序列和表名的命名生成器。与JPA注解的常规用法一样，不幸的是，你只能在（可能为空的）类的顶部使用它们，而不能在`package-info.java`文件中使用。
- en: For this reason, and because the JPA annotations don’t give you access to the
    full Hibernate feature set, we prefer the native `@org.hibernate.annotations.GenericGenerator`
    annotation as an alternative. It supports all Hibernate identifier generator strategies
    and their configuration details. Unlike the rather limited JPA annotations, you
    can use the Hibernate annotation in a package-info.java file, typically in the
    same package as your domain model classes. The following listing shows a recommended
    configuration, which can also be found in the `generator` folder.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，并且因为JPA注解没有给你提供访问完整的Hibernate功能集，我们更喜欢使用原生的`@org.hibernate.annotations.GenericGenerator`注解作为替代。它支持所有Hibernate标识生成策略及其配置细节。与相对有限的JPA注解不同，你可以在`package-info.java`文件中使用Hibernate注解，通常与你的领域模型类在同一个包中。以下列表显示了一个推荐的配置，这个配置也可以在`generator`文件夹中找到。
- en: Listing 5.2 Hibernate identifier generator configured as package-level metadata
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.2 Hibernate标识生成器配置为包级元数据
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Ⓐ The `enhanced-sequence` strategy produces sequential numeric values. If your
    SQL dialect supports sequences, Hibernate (or Spring Data JPA using Hibernate
    as a persistence provider) will use an actual database sequence. If your DBMS
    doesn’t support native sequences, Hibernate (or Spring Data JPA using Hibernate
    as a persistence provider) will manage and use an extra “sequence table,” simulating
    the behavior of a sequence. This gives you real portability: the generator can
    always be called before performing an SQL `INSERT`, unlike, for example, auto-increment
    identity columns, which produce a value on `INSERT` that has to be returned to
    the application afterward.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `enhanced-sequence`策略产生顺序数字值。如果你的SQL方言支持序列，Hibernate（或使用Hibernate作为持久化提供者的Spring
    Data JPA）将使用实际的数据库序列。如果你的数据库管理系统不支持原生序列，Hibernate（或使用Hibernate作为持久化提供者的Spring
    Data JPA）将管理并使用一个额外的“序列表”，模拟序列的行为。这为你提供了真正的可移植性：生成器总是在执行SQL `INSERT`之前被调用，与例如自动递增的标识列不同，后者在`INSERT`时产生一个值，之后必须将其返回给应用程序。
- en: Ⓑ You can configure the `sequence_name`. Hibernate (or Spring Data JPA using
    Hibernate as a persistence provider) will either use an existing sequence or create
    one when you generate the SQL schema automatically. If your DBMS doesn’t support
    sequences, this will be the special “sequence table” name.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 你可以配置`sequence_name`。Hibernate（或使用Hibernate作为持久化提供者的Spring Data JPA）将使用现有的序列或在你自动生成SQL模式时创建一个。如果你的数据库管理系统不支持序列，这将是一个特殊的“序列表”名称。
- en: 'Ⓒ You can start with an `initial_value` that gives you room for test data.
    For example, when your integration test runs, Hibernate (or Spring Data JPA using
    Hibernate as a persistence provider) will make any new data insertions from test
    code with identifier values greater than 1,000\. Any test data you want to import
    before the test can use numbers 1 to 999, and you can refer to the stable identifier
    values in your tests: “Load item with id 123 and run some tests on it.” This is
    applied when Hibernate (or Spring Data JPA using Hibernate as a persistence provider)
    generates the SQL schema and sequence; it’s a DDL option.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 你可以从一个`initial_value`开始，这为你提供了测试数据的空间。例如，当你的集成测试运行时，Hibernate（或使用Hibernate作为持久化提供者的Spring
    Data JPA）将使用测试代码中的标识值大于1,000的新数据插入。你想要在测试之前导入的任何测试数据可以使用1到999的数字，你可以在测试中引用稳定的标识值：“加载id为123的项目并对其运行一些测试。”这适用于Hibernate（或使用Hibernate作为持久化提供者的Spring
    Data JPA）生成SQL模式和序列；这是一个DDL选项。
- en: You can share the same database sequence among all your domain model classes.
    There is no harm in specifying `@GeneratedValue(generator` `=` `"ID_GENERATOR")`
    in all your entity classes. It doesn’t matter if primary key values aren’t contiguous
    for a particular entity, as long as they’re unique within one table.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在所有领域模型类之间共享相同的数据库序列。在所有实体类中指定`@GeneratedValue(generator="ID_GENERATOR")`没有任何害处。对于特定实体，主键值不连续没有关系，只要它们在表中是唯一的。
- en: 'Finally, you can use `java.lang.Long` as the type of the identifier property
    in the entity class, which maps perfectly to a numeric database sequence generator.
    You could also use a `long` primitive. The main difference is what `someItem.getId()`
    returns on a new item that hasn’t been stored in the database: either `null` or
    `0`. If you want to test whether an item is new, a `null` check is probably easier
    for someone else reading your code to understand. You shouldn’t use another integral
    type, such as `int` or `short,` for identifiers. Although they will work for a
    while (perhaps even years), as your database size grows, you may be limited by
    their range. An `Integer` would work for almost two months if you generated a
    new identifier each millisecond with no gaps, and a `Long` would last for about
    300 million years.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在实体类中将`java.lang.Long`用作标识符属性的类型，这完美映射到数值数据库序列生成器。你也可以使用原始类型`long`。主要区别在于新项目在数据库中未存储时`someItem.getId()`返回的值：要么是`null`，要么是`0`。如果你想测试一个项目是否为新项目，对`null`的检查可能更容易让其他人阅读你的代码时理解。你不应该使用其他整型，如`int`或`short`作为标识符。虽然它们可能工作一段时间（甚至可能几年），但随着数据库大小的增长，你可能会受到它们的范围的限制。如果你以每毫秒生成一个新标识符且没有空缺的方式生成标识符，`Integer`将适用于大约两个月，而`Long`将适用于大约3亿年。
- en: Although it is recommended for most applications, the `enhanced-sequence` strategy,
    as shown in listing 5.2, is just one of the strategies built into Hibernate. The
    key generator’s configuration is unaware of the framework that uses it, and the
    programmer will never manage the value of the primary key. This is done at the
    level of the frameworks. The code will look like listings 5.3 and 5.4.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于大多数应用来说这是推荐的，但如列表5.2所示，`enhanced-sequence`策略只是Hibernate内置的策略之一。关键生成器的配置不了解使用它的框架，程序员永远不会管理主键的值。这是在框架层面完成的。代码将类似于列表5.3和5.4。
- en: Listing 5.3 Persisting an `Item` with a generated primary key from Hibernate
    JPA
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 使用Hibernate JPA持久化具有生成主键的`Item`
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Listing 5.4 Persisting an `Item` with a generated primary key from Spring Data
    JPA
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.4 使用Spring Data JPA持久化具有生成主键的`Item`
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After running any of the Hibernate JPA or Spring Data JPA programs, a new `ITEM`
    will be inserted in the database with the `id` 1000, the first one specified by
    the generator (figure 5.5). The value to be generated for the next insertion is
    kept inside `JPWHSD_ SEQUENCE` (figure 5.6).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行任何Hibernate JPA或Spring Data JPA程序后，将在数据库中插入一个新的`ITEM`，其`id`为1000，这是生成器指定的第一个值（图5.5）。下一次插入要生成的值保留在`JPWHSD_SEQUENCE`中（图5.6）。
- en: '![](../../OEBPS/Images/CH05_F05_Tudose2.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F05_Tudose2.png)'
- en: Figure 5.5 The content of the `ITEM` table after inserting a row with a generated
    primary key
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 插入具有生成主键的行后`ITEM`表的内容
- en: '![](../../OEBPS/Images/CH05_F06_Tudose2.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F06_Tudose2.png)'
- en: Figure 5.6 The next generated value kept by `JPWHSD_SEQUENCE`
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 `JPWHSD_SEQUENCE`保留的下一个生成值
- en: 5.2.5 Identifier generator strategies
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.5 标识符生成策略
- en: Hibernate and Spring Data JPA using Hibernate as a provider offer several identifier
    generator strategies, and we’ll list and discuss them in this section. We won’t
    address the deprecated generator strategies.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Hibernate作为提供者的Hibernate和Spring Data JPA提供了几种标识符生成策略，我们将在本节中列出并讨论它们。我们不会讨论已弃用的生成策略。
- en: If you don’t want to read the whole list now, enable `GenerationType.AUTO` and
    check what Hibernate defaults to for your database dialect. It’s most likely `sequence`
    or `identity`—good choices, but maybe not the most efficient or portable choices.
    If you require consistent, portable behavior and identifier values that are available
    before `INSERT`s, use `enhanced-sequence`, as shown in the previous section. This
    is a portable, flexible, and modern strategy that also offers various optimizers
    for large datasets.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在不想阅读整个列表，请启用`GenerationType.AUTO`并检查Hibernate为你数据库方言默认的设置。它很可能是`sequence`或`identity`——这是不错的选择，但可能不是最有效或最便携的选择。如果你需要一致、便携的行为以及`INSERT`之前可用的标识符值，请使用`enhanced-sequence`，如前节所示。这是一个便携、灵活且现代的策略，同时也为大数据集提供了各种优化器。
- en: 'Generating identifiers before or after `INSERT`: what’s the difference?'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`INSERT`之前或之后生成标识符：有什么区别？
- en: An ORM service tries to optimize SQL `INSERT`s, such as by batching several
    at the JDBC level. Hence, SQL execution occurs as late as possible during a unit
    of work, and not when you call `entityManager.persist(someItem)`. This merely
    queues the insertion for later execution and, if possible, assigns the identifier
    value. However, if you now call `someItem.getId()`, you might get `null` back
    if the engine wasn’t able to generate an identifier before the `INSERT`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个ORM服务试图优化SQL `INSERT`，例如通过在JDBC级别批量处理多个`INSERT`。因此，SQL执行尽可能晚地发生在工作单元期间，而不是在您调用`entityManager.persist(someItem)`时。这仅仅是将插入排队以供稍后执行，并在可能的情况下分配标识符值。然而，如果您现在调用`someItem.getId()`，如果引擎在`INSERT`之前未能生成标识符，您可能会得到`null`。
- en: In general, we prefer *pre-insert* generation strategies that produce identifier
    values independently before `INSERT`. A common choice is to use a shared and concurrently
    accessible database sequence. Auto-incremented columns, column default values,
    and trigger-generated keys are available only after the `INSERT`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们更喜欢在`INSERT`之前独立生成标识符值的`pre-insert`生成策略。一个常见的选择是使用共享且可并发访问的数据库序列。自增列、列默认值和触发器生成的键仅在`INSERT`之后才可用。
- en: 'Before we discuss the full list of identifier generator strategies, the recommendations
    for these strategies are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论标识符生成策略的完整列表之前，以下是对这些策略的建议：
- en: In general, prefer pre-insert generation strategies that produce identifier
    values independently before `INSERT`.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，优先选择在`INSERT`之前独立生成标识符值的预插入生成策略。
- en: Use `enhanced-sequence`, which uses a native database sequence when that’s supported
    and otherwise falls back to using an extra database table with a single column
    and row, emulating a sequence.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`enhanced-sequence`，当数据库支持时使用原生数据库序列，否则退回到使用一个带有单列和单行的额外数据库表，模拟序列。
- en: The following list outlines Hibernate’s identifier generator strategies with
    their options and our usage recommendations. We also discuss the relationship
    between each standard JPA strategy and its native Hibernate equivalent. Hibernate
    has been growing organically, so there are now two sets of mappings between standard
    and native strategies; we refer to them as *old* and *new* in the list. You can
    switch this mapping with the `hibernate .id.new_generator_mappings` setting in
    your persistence.xml file. The default is `true`, which means the new mapping
    is used. Software doesn’t age quite as well as wine.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表概述了Hibernate的标识符生成策略及其选项，以及我们的使用建议。我们还讨论了每个标准JPA策略与其原生Hibernate等效策略之间的关系。由于Hibernate是自然增长的，现在有两套标准策略和原生策略之间的映射；我们在列表中将它们称为`*旧*`和`*新*`。您可以通过在`persistence.xml`文件中的`hibernate
    .id.new_generator_mappings`设置来切换此映射。默认值为`true`，这意味着使用新映射。软件并不像酒那样越陈越香。
- en: '`native`—This option automatically selects a strategy, such as `sequence` or
    `identity`, depending on the configured SQL dialect. You have to look at the Javadoc
    (or even the source) of the SQL dialect you configured in persistence.xml to determine
    which strategy will be selected. This is equivalent to JPA `GenerationType.AUTO`
    with the old mapping.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`native`—此选项根据配置的SQL方言自动选择策略，例如`sequence`或`identity`。您必须查看在`persistence.xml`中配置的SQL方言的Javadoc（甚至源代码）以确定将选择哪种策略。这与旧映射中的JPA
    `GenerationType.AUTO`等效。'
- en: '`sequence`—This strategy uses a native database sequence named `HIBERNATE_
    SEQUENCE`. The sequence is called before each `INSERT` of a new row. You can customize
    the sequence name and provide additional DDL settings; see the Javadoc for the
    `org.hibernate.id.SequenceGenerator` class.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sequence`—此策略使用名为`HIBERNATE_ SEQUENCE`的原生数据库序列。在每次新行的`INSERT`之前调用序列。您可以自定义序列名称并提供额外的DDL设置；请参阅`org.hibernate.id.SequenceGenerator`类的Javadoc。'
- en: '`enhanced-sequence`—This strategy uses a native database sequence when it’s
    supported; otherwise it falls back to using an extra database table with a single
    column and row, emulating a sequence (the default table name is `HIBERNATE_ SEQUENCE`).
    Using this strategy always calls the database “sequence” before an `INSERT`, providing
    the same behavior independently of whether the DBMS supports real sequences. This
    strategy also supports an `org.hibernate.id.enhanced .Optimizer` to avoid hitting
    the database before each `INSERT`, and it defaults to no optimization and fetching
    a new value for each `INSERT`. This is equivalent to JPA `GenerationType.SEQUENCE`
    and `GenerationType.AUTO` with the new mapping enabled, and it’s probably your
    best option of the built-in strategies. For all the parameters, see the Javadoc
    for the `org.hibernate.id.enhanced .SequenceStyleGenerator` class.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enhanced-sequence`—这种策略在支持原生数据库序列时使用原生数据库序列；否则，它将回退到使用一个包含单个列和行的额外数据库表，模拟序列（默认表名为`HIBERNATE_
    SEQUENCE`）。使用此策略始终在`INSERT`之前调用数据库“序列”，无论DBMS是否支持真实序列，都能提供相同的行为。此策略还支持`org.hibernate.id.enhanced
    .Optimizer`以避免在每次`INSERT`之前击中数据库，并且默认不进行优化，并为每次`INSERT`获取新值。这与启用新映射的JPA `GenerationType.SEQUENCE`和`GenerationType.AUTO`等效，可能是内置策略中最好的选择。有关所有参数，请参阅`org.hibernate.id.enhanced
    .SequenceStyleGenerator`类的Javadoc。'
- en: '`enhanced-table`—This strategy uses an extra table named `HIBERNATE_ SEQUENCES`,
    with one row by default representing the sequence and storing the next value.
    This value is selected and updated when an identifier value has to be generated.
    You can configure this generator to use multiple rows instead: one for each generator
    (see the Javadoc for `org.hibernate.id.enhanced .TableGenerator`). This is equivalent
    to JPA `GenerationType.TABLE` with the new mapping enabled. It replaces the outdated
    but similar `org.hibernate .id.MultipleHiLoPerTableGenerator`, which was the old
    mapping for JPA `GenerationType.TABLE`.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enhanced-table`—这种策略使用一个名为`HIBERNATE_ SEQUENCES`的额外表，默认情况下有一个行表示序列并存储下一个值。当需要生成标识值时，将选择并更新此值。您可以配置此生成器使用多行，每行代表一个生成器（请参阅`org.hibernate.id.enhanced
    .TableGenerator`的Javadoc）。这与启用新映射的JPA `GenerationType.TABLE`等效。它取代了过时但类似的`org.hibernate
    .id.MultipleHiLoPerTableGenerator`，它是JPA `GenerationType.TABLE`的老映射。'
- en: '`identity`—This strategy supports `IDENTITY` and auto-increment columns in
    DB2, MySQL, MS SQL Server, and Sybase. The identifier value for the primary key
    column will be generated on the `INSERT` of a row. It has no options. Unfortunately,
    due to a quirk in Hibernate’s code, you can*not* configure this strategy in `@GenericGenerator`.
    The DDL generation will not include the identity or auto-increment option for
    the primary key column. The only way to use it is with JPA `GenerationType.IDENTITY`
    and the old or new mapping, making it the default for `GenerationType.IDENTITY`.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`identity`—这种策略支持DB2、MySQL、MS SQL Server和Sybase中的`IDENTITY`和自动增长列。主键列的标识值将在插入行时生成。它没有选项。不幸的是，由于Hibernate代码中的一个怪癖，您**不能**在`@GenericGenerator`中配置此策略。DDL生成将不包括主键列的标识或自动增长选项。唯一使用它的方法是使用JPA
    `GenerationType.IDENTITY`和旧或新映射，使其成为`GenerationType.IDENTITY`的默认选项。'
- en: '`increment`—At Hibernate startup, this strategy reads the maximum (numeric)
    primary key column value of each entity’s table and increments the value by one
    each time a new row is inserted. This is especially efficient if a non-clustered
    Hibernate application has exclusive access to the database, but don’t use it in
    any other scenario.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`increment`—在Hibernate启动时，此策略读取每个实体表的最大的（数值）主键列值，并在每次插入新行时将值增加一。如果非聚集的Hibernate应用程序具有对数据库的独占访问权限，则此策略特别有效，但在任何其他场景中不要使用它。'
- en: '`select`—With this strategy, Hibernate won’t generate a key value or include
    the primary key column in an `INSERT` statement. Hibernate expects the DBMS to
    assign a value to the column on insertion (the default value in the schema or
    the value given by a trigger). Hibernate then retrieves the primary key column
    with a `SELECT` query after insertion. The required parameter is `key`, naming
    the database identifier property (such as `id`) for the `SELECT`. This strategy
    isn’t very efficient and should only be used with old JDBC drivers that can’t
    return generated keys directly.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select`—使用此策略，Hibernate 不会在 `INSERT` 语句中生成键值或包含主键列。Hibernate 预期数据库管理系统在插入时为该列分配一个值（模式中的默认值或触发器提供的值）。Hibernate
    然后在插入后通过 `SELECT` 查询检索主键列。所需的参数是 `key`，命名数据库标识符属性（如 `id`）的 `SELECT`。此策略效率不高，并且仅应与无法直接返回生成键的老旧
    JDBC 驱动程序一起使用。'
- en: '`uuid2`—This strategy produces a unique 128-bit UUID in the application layer.
    This is useful when you need globally unique identifiers across databases (such
    as if you merge data from several distinct production databases in batch runs
    every night into an archive). The UUID can be encoded either as a `java.lang.String`,
    a `byte[16]`, or a `java.util.UUID` property in your entity class. This replaces
    the legacy `uuid` and `uuid.hex` strategies. You configure it with an `org.hibernate
    .id.UUIDGenerationStrategy`; see the Javadoc for the `org.hibernate.id.UUIDGenerator`
    class for more details.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uuid2`—此策略在应用层生成一个唯一的 128 位 UUID。当您需要在数据库之间具有全局唯一标识符时很有用（例如，如果您每晚在批量运行中将来自几个不同生产数据库的数据合并到存档中）。UUID
    可以编码为实体类中的 `java.lang.String`、`byte[16]` 或 `java.util.UUID` 属性。这取代了传统的 `uuid`
    和 `uuid.hex` 策略。您可以通过 `org.hibernate.id.UUIDGenerationStrategy` 配置它；有关 `org.hibernate.id.UUIDGenerator`
    类的更多详细信息，请参阅 Javadoc。'
- en: '`guid`—This strategy uses a globally unique identifier produced by the database,
    with an SQL function available on Oracle, Ingres, MS SQL Server, and MySQL. Hibernate
    calls the database function before an `INSERT`. The value maps to a `java.lang.String`
    identifier property. If you need full control over identifier generation, configure
    the strategy of `@GenericGenerator` with the fully qualified name of a class that
    implements the `org.hibernate.id.IdentityGenerator` interface.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`guid`—此策略使用数据库生成的全局唯一标识符，在 Oracle、Ingres、MS SQL Server 和 MySQL 上有可用的 SQL 函数。Hibernate
    在 `INSERT` 之前调用数据库函数。值映射到 `java.lang.String` 标识符属性。如果您需要完全控制标识符生成，请使用实现 `org.hibernate.id.IdentityGenerator`
    接口的类的完全限定名称配置 `@GenericGenerator` 策略。'
- en: If you haven’t already, go ahead and add identifier properties to the entity
    classes of your domain model. Make sure you do not expose the identifier outside
    the business logic, such as through an API—this identifier has no business logic
    meaning and it is related only to the persistence.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请继续为您的领域模型中的实体类添加标识符属性。确保您不要在业务逻辑之外暴露标识符，例如通过 API——此标识符没有业务逻辑意义，它仅与持久性相关。
- en: After you complete the basic mapping of each entity and its identifier property,
    you can continue to map the value-typed properties of the entities. We’ll talk
    about value-type mappings in the next chapter. First, though, read on for some
    special options that can simplify and enhance your class mappings.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成每个实体及其标识符属性的基本映射后，您可以继续映射实体的值类型属性。我们将在下一章中讨论值类型映射。不过，首先，请继续阅读一些可以简化并增强您的类映射的特殊选项。
- en: 5.3 Entity-mapping options
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 实体映射选项
- en: 'You’ve now mapped a persistent class with `@Entity`, using defaults for all
    the other settings, such as the mapped SQL table name. We’ll now explore some
    class-level options and how you can control them:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已使用 `@Entity` 映射了一个持久化类，并使用默认值设置了所有其他设置，例如映射的 SQL 表名。现在，我们将探讨一些类级别选项以及您如何控制它们：
- en: Naming defaults and strategies
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名默认值和策略
- en: Dynamic SQL generation
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态 SQL 生成
- en: Entity mutability
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体可变性
- en: These are options. If you prefer, you can skip this section for now, and come
    back later when you have to deal with specific problems.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是选项。如果您愿意，现在可以跳过这一部分，稍后再回来处理具体问题时再回来。
- en: 5.3.1 Controlling names
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 控制名称
- en: Let’s talk about the naming of entity classes and tables. If you only specify
    `@Entity` on a persistence-capable class, the default mapped table name will be
    the same as the class name. For example, the Java entity class `Item` maps to
    the `ITEM` table. A Java entity class named `BidItem` will map to the `BID_ITEM`
    table (here, the camel case will be converted into snake case). You can override
    the table name with the JPA `@Table` annotation, as shown next. (See the `mapping`
    folder for the source code.)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈实体类和表的命名。如果你只在持久化能力类上指定 `@Entity`，默认映射的表名将与类名相同。例如，Java 实体类 `Item` 映射到
    `ITEM` 表。名为 `BidItem` 的 Java 实体类将映射到 `BID_ITEM` 表（在这里，驼峰式命名将被转换为蛇形命名）。你可以使用 JPA
    的 `@Table` 注解覆盖表名，如下所示。（请参阅 `mapping` 文件夹以获取源代码。）
- en: Note We write SQL artifact names in `UPPERCASE` to make them easier to distinguish—SQL
    is actually case insensitive.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们用 `UPPERCASE` 写 SQL 艺术品名称，以便更容易区分——SQL 实际上是大小写不敏感的。
- en: Listing 5.5 Overriding the mapped table name with the `@Table` annotation
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.5 使用 `@Table` 注解覆盖映射的表名
- en: '[PRE4]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `User` entity would map to the `USER` table, but this is a reserved keyword
    in most SQL DBMSs, so you can’t have a table with that name. Instead we have mapped
    it to `USERS`. The `@javax.persistence.Table` annotation also has `catalog` and
    `schema` options if your database layout requires these as naming prefixes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 实体将映射到 `USER` 表，但在大多数 SQL 数据库管理系统（DBMS）中，这是一个保留关键字，因此你不能有这样一个名称的表。相反，我们将其映射到
    `USERS`。如果你的数据库布局需要这些作为命名前缀，`@javax.persistence.Table` 注解也有 `catalog` 和 `schema`
    选项。'
- en: If you really have to, quoting allows you to use reserved SQL names and even
    work with case-sensitive names.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的需要，引用允许你使用保留的 SQL 名称，甚至可以处理大小写敏感的名称。
- en: Quoting SQL identifiers
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 引用 SQL 标识符
- en: From time to time, especially in legacy databases, you’ll encounter identifiers
    with strange characters or whitespace, or you’ll wish to force case sensitivity.
    Or, as in the previous example, the automatic mapping of a class or property would
    require a table or column name that is a reserved keyword. Hibernate and Spring
    Data JPA using Hibernate as a provider know the reserved keywords of your DBMS
    through the configured database dialect, and they can automatically put quotes
    around such strings when generating SQL. You can enable this automatic quoting
    with `hibernate .auto_quote_ keyword=true` in your persistence unit configuration.
    If you’re using an older version of Hibernate, or you find that the dialect’s
    information is incomplete, you must still apply quotes on names manually in your
    mappings if there is a conflict with a keyword.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，特别是在旧数据库中，你会遇到包含奇怪字符或空白的标识符，或者你希望强制执行大小写敏感性。或者，就像前面的示例一样，类或属性的自动映射可能需要一个保留关键字的表或列名。Hibernate
    和使用 Hibernate 作为提供者的 Spring Data JPA 通过配置的数据库方言知道你的 DBMS 的保留关键字，并且它们可以在生成 SQL
    时自动在这些字符串周围添加引号。你可以在持久化单元配置中使用 `hibernate .auto_quote_ keyword=true` 启用此自动引用。如果你使用的是较旧的
    Hibernate 版本，或者你发现方言的信息不完整，你必须仍然在你的映射中手动应用引号，如果与关键字冲突。
- en: If you quote a table or column name in your mapping with backticks, Hibernate
    always quotes this identifier in the generated SQL. This still works in the latest
    versions of Hibernate, but JPA 2.0 standardized this functionality as *delimited
    identifiers* with double quotes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用反引号在你的映射中引用表或列名，Hibernate 总是在生成的 SQL 中引用此标识符。这仍然在 Hibernate 的最新版本中有效，但
    JPA 2.0 将此功能标准化为 *delimited identifiers*，即双引号。
- en: 'This is the Hibernate-only quoting with backticks, modifying the previous example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是仅适用于 Hibernate 的使用反引号的引用，修改了前面的示例：
- en: '[PRE5]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To be JPA-compliant, you also have to escape the quotes in the string:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要符合 JPA 规范，你还需要在字符串中转义引号：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Either way works fine with Hibernate and Spring Data JPA using Hibernate as
    a provider. It knows the native quote character for your dialect and now generates
    SQL accordingly: `[USER]` for MS SQL Server, `''USER''` for MySQL, `"USER"` for
    H2, and so on.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，对于使用 Hibernate 作为提供者的 Hibernate 和 Spring Data JPA 都可以正常工作。它知道你方言的本地引号字符，并相应地生成
    SQL：`[USER]` 用于 MS SQL Server，`'USER'` 用于 MySQL，`"USER"` 用于 H2 等。
- en: If you have to quote *all* SQL identifiers, create an orm.xml file and add the
    setting `<delimited-identifiers/>` to its `<persistence-unit-defaults>` section,
    as you saw earlier in listing 3.8\. Hibernate then enforces quoted identifiers
    everywhere.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须引用 *所有* SQL 标识符，创建一个 orm.xml 文件，并在其 `<persistence-unit-defaults>` 部分添加设置
    `<delimited-identifiers/>`，就像你在列表 3.8 中看到的那样。Hibernate 然后在所有地方强制执行引用标识符。
- en: You should consider renaming tables or columns with reserved keyword names whenever
    possible. Ad hoc SQL queries are difficult to write in an SQL console if you have
    to quote and escape everything properly by hand. Also, you should avoid using
    quoted identifiers for databases that are also accessed by other means than Hibernate,
    JPA, or Spring Data (such as for reporting). Having to use delimiters for all
    identifiers in a (complex) report query is really painful.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，你应该考虑重命名具有保留关键字名称的表或列。如果你必须手动正确地引用和转义所有内容，那么在 SQL 控制台中编写临时 SQL 查询会很困难。此外，你还应该避免为也通过
    Hibernate、JPA 或 Spring Data（例如，用于报告）以外的其他方式访问的数据库使用引号标识符。在（复杂）报告查询中必须使用分隔符来标识所有标识符，这真的很痛苦。
- en: Next, let’s see how Hibernate and Spring Data JPA with Hibernate as a provider
    can help when you encounter organizations with strict conventions for database
    table and column names.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看当遇到对数据库表和列名称有严格约定的组织时，Hibernate 和 Spring Data JPA（以 Hibernate 作为提供者）如何提供帮助。
- en: Implementing naming conventions
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 实现命名约定
- en: Hibernate provides a feature that allows you to enforce naming standards automatically.
    Suppose that all table names in CaveatEmptor should follow the pattern `CE_<table`
    `name>`. One solution is to manually specify the `@Table` annotation on all entity
    classes, but this approach is time-consuming and easily forgotten. Instead, you
    can implement Hibernate’s `PhysicalNamingStrategy` interface or override an existing
    implementation, as in the following listing.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 提供了一个功能，允许你自动强制执行命名标准。假设 CaveatEmptor 中所有表名都应该遵循 `CE_<table name>`
    的模式。一种解决方案是手动在所有实体类上指定 `@Table` 注解，但这种方法既耗时又容易忘记。相反，你可以实现 Hibernate 的 `PhysicalNamingStrategy`
    接口或覆盖现有的实现，如下所示。
- en: Listing 5.6 Overriding default naming conventions with `PhysicalNamingStrategy`
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6 使用 `PhysicalNamingStrategy` 覆盖默认命名约定
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The overridden `toPhysicalTableName()` method prepends `CE_` to all generated
    table names in your schema. Look at the Javadoc of the `PhysicalNamingStrategy`
    interface; it offers methods for custom naming of columns, sequences, and other
    artifacts.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖的 `toPhysicalTableName()` 方法将 `CE_` 前缀添加到你的模式中所有生成的表名。查看 `PhysicalNamingStrategy`
    接口的 Javadoc；它提供了用于自定义命名列、序列和其他实体的方法。
- en: 'You have to enable the naming strategy implementation. With Hibernate JPA,
    this is done in persistence.xml:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须启用命名策略实现。在 Hibernate JPA 中，这通过 persistence.xml 完成：
- en: '[PRE8]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With Spring Data JPA using Hibernate as a persistence provider, this is done
    from the `LocalContainerEntityManagerFactoryBean` configuration:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Spring Data JPA 并以 Hibernate 作为持久化提供者时，这通过 `LocalContainerEntityManagerFactoryBean`
    配置来完成：
- en: '[PRE9]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let’s now take a quick look at another related problem, the naming of entities
    for queries.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们快速看一下另一个相关的问题，即查询实体的命名。
- en: Naming entities for querying
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为查询命名实体
- en: 'By default, all entity names are automatically imported into the namespace
    of the query engine. In other words, you can use short class names without a package
    prefix in JPA query strings, which is convenient:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有实体名称都会自动导入查询引擎的命名空间。换句话说，你可以在 JPA 查询字符串中使用不带包前缀的简短类名，这很方便：
- en: '[PRE10]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This only works when you have one `Item` class in your persistence unit. If
    you add another `Item` class in a different package, you should rename one of
    them for JPA if you want to continue using the short form in queries:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅在你在持久化单元中有一个 `Item` 类时才有效。如果你在另一个包中添加另一个 `Item` 类，如果你想继续在查询中使用简短形式，你应该为 JPA
    重命名其中一个：
- en: '[PRE11]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The short query form is now `select` `i` `from` `AuctionItem` `i` for the `Item`
    class in the `my.other.model` package. Thus you resolve the naming conflict with
    another `Item` class in another package. Of course, you can always use fully qualified
    long names with the package prefix.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `my.other.model` 包中的 `Item` 类，简短的查询形式现在是 `select i from AuctionItem i`。因此，你解决了另一个包中另一个
    `Item` 类的命名冲突。当然，你始终可以使用带有包前缀的完全限定长名称。
- en: This completes our tour of the naming options. Next we’ll discuss how Hibernate
    and Spring Data JPA using Hibernate generate the SQL that contains these names.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对命名选项的浏览。接下来，我们将讨论 Hibernate 和 Spring Data JPA 使用 Hibernate 生成包含这些名称的
    SQL 的方法。
- en: 5.3.2 Dynamic SQL generation
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 动态 SQL 生成
- en: By default, Hibernate and Spring Data JPA using Hibernate as a provider create
    SQL statements for each persistent class when the persistence unit is created
    on startup. These statements are simple create, read, update, and delete (CRUD)
    operations for reading a single row, deleting a row, and so on. It’s cheaper to
    create and cache them instead of generating SQL strings every time such a simple
    query has to be executed at runtime. Besides, prepared statement caching at the
    JDBC level is much more efficient if there are fewer statements.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Hibernate 和使用 Hibernate 作为提供者的 Spring Data JPA 在启动时创建持久化单元时为每个持久化类创建 SQL
    语句。这些语句是简单的创建、读取、更新和删除（CRUD）操作，用于读取单行、删除单行等。与每次在运行时执行此类简单查询时生成 SQL 字符串相比，创建和缓存它们更便宜。此外，如果语句较少，JDBC
    层的预处理语句缓存也更为高效。
- en: How can Hibernate create an `UPDATE` statement on startup? After all, the columns
    to be updated aren’t known at this time. The answer is that the generated SQL
    statement updates all columns, and if the value of a particular column isn’t modified,
    the statement sets it to its old value.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 如何在启动时创建 `UPDATE` 语句？毕竟，此时并不知道要更新的列。答案是生成的 SQL 语句更新所有列，如果特定列的值没有被修改，则语句将其设置为旧值。
- en: In some situations, such as a legacy table with hundreds of columns, where the
    SQL statements will be large for even the simplest operations (such as when only
    one column needs updating), you should disable this startup SQL generation and
    switch to dynamic statements generated at runtime. An extremely large number of
    entities can also influence startup time because Hibernate has to generate all
    the SQL statements for CRUD up front. Memory consumption for this query statement
    cache will also be high if a dozen statements must be cached for thousands of
    entities. This can be a concern in virtual environments with memory limitations
    or on low-power devices.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，例如具有数百列的遗留表，即使是最简单的操作（例如仅需要更新一列时）的 SQL 语句也会很大，你应该禁用此启动 SQL 生成，并切换到在运行时动态生成的语句。大量实体也可能影响启动时间，因为
    Hibernate 必须预先生成所有 CRUD 的 SQL 语句。如果必须为数千个实体缓存数十个语句，此查询语句缓存的内存消耗也会很高。这在内存限制的虚拟环境中或低功耗设备上可能是一个问题。
- en: 'To disable the generation of `INSERT` and `UPDATE` SQL statements on startup,
    you need to use native Hibernate annotations:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用启动时生成 `INSERT` 和 `UPDATE` SQL 语句，你需要使用本机 Hibernate 注解：
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By enabling dynamic insertion and updates, you tell Hibernate to produce the
    SQL strings when needed, not up front. The `UPDATE` will only contain columns
    with updated values, and the `INSERT` will only contain non-nullable columns.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启用动态插入和更新，你告诉 Hibernate 在需要时而不是一开始就生成 SQL 字符串。`UPDATE` 语句将只包含具有更新值的列，而 `INSERT`
    语句将只包含非空列。
- en: 5.3.3 Making an entity immutable
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 使实体不可变
- en: 'Instances of a particular class may be immutable. For example, in CaveatEmptor,
    a `Bid` made for an item is immutable. Hence, Hibernate or Spring Data JPA using
    Hibernate as a provider never needs to execute `UPDATE` statements on the `BID`
    table. Hibernate can also make a few other optimizations, such as avoiding dirty
    checking if you map an immutable class, as shown in the next example. Here the
    `Bid` class is immutable, and instances are never modified:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 特定类的实例可能是不可变的。例如，在 CaveatEmptor 中，为物品出价的一个 `Bid` 是不可变的。因此，Hibernate 或使用 Hibernate
    作为提供者的 Spring Data JPA 永远不需要在 `BID` 表上执行 `UPDATE` 语句。Hibernate 还可以执行一些其他优化，例如，如果你映射了一个不可变类，可以避免脏检查，如下一个示例所示。这里
    `Bid` 类是不可变的，实例永远不会被修改：
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A POJO is immutable if no public setter methods for any properties of the class
    are exposed—all values are set in the constructor. Hibernate or Spring Data JPA
    using Hibernate as a provider should access the fields directly when loading and
    storing instances. We talked about this earlier in this chapter: if the `@Id`
    annotation is on a field, Hibernate will access the fields directly, and you are
    free to design your getter and setter methods. Also, remember that not all frameworks
    work with POJOs without setter methods.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类的任何属性都没有公开的设置器方法，则 POJO 是不可变的——所有值都在构造函数中设置。Hibernate 或使用 Hibernate 作为提供者的
    Spring Data JPA 应在加载和存储实例时直接访问字段。我们在此章中之前已经讨论过这一点：如果 `@Id` 注解在字段上，Hibernate 将直接访问字段，你可以自由设计你的获取器和设置器方法。此外，请记住，并非所有框架都支持没有设置器方法的
    POJO。
- en: When you can’t create a view in your database schema, you can map an immutable
    entity class to an SQL `SELECT` query.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当你无法在数据库模式中创建视图时，你可以将不可变实体类映射到 SQL `SELECT` 查询。
- en: 5.3.4 Mapping an entity to a subselect
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.4 将实体映射到子查询
- en: 'Sometimes your DBA won’t allow you to change the database schema. Even adding
    a new view might not be possible. Let’s say you want to create a view that contains
    the identifier of an auction `Item` and the number of bids made for that item
    (see the `subselect` folder for the source code). Using a Hibernate annotation,
    you can create an application-level view, a read-only entity class mapped to an
    SQL `SELECT`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你的数据库管理员可能不允许你更改数据库模式。甚至添加一个新的视图也可能不可能。假设你想要创建一个包含拍卖 `Item` 的标识符和为此项进行的出价数量的视图（请参阅
    `subselect` 文件夹中的源代码）。使用 Hibernate 注解，你可以创建一个应用程序级别的视图，一个映射到 SQL `SELECT` 的只读实体类：
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You should list all the table names referenced in your `SELECT` in the `@org.hibernate
    .annotations.Synchronize` annotation. The framework will then know it has to flush
    modifications of `Item` and `Bid` instances before it executes a query against
    `ItemBidSummary`. If there are in-memory modifications that haven’t yet been persisted
    to the database but that may affect the query, Hibernate (or Spring Data JPA using
    Hibernate as a provider) detects this and flushes the changes before executing
    the query. Otherwise the result may be a stale state. As there is no `@Table`
    annotation on the `ItemBidSummary` class, the framework doesn’t know when it must
    auto-flush before executing a query. The `@org.hibernate.annotations.Synchronize`
    annotation indicates that the framework needs to flush the `ITEM` and `BID` tables
    before executing the query.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在 `@org.hibernate.annotations.Synchronize` 注解中列出你 `SELECT` 中引用的所有表名。然后框架将知道在执行针对
    `ItemBidSummary` 的查询之前，它必须刷新 `Item` 和 `Bid` 实例的修改。如果有尚未持久化到数据库但可能影响查询的内存中修改，Hibernate（或作为提供者的
    Spring Data JPA）会检测到这一点，并在执行查询之前刷新更改。否则，结果可能是一个过时的状态。由于 `ItemBidSummary` 类上没有
    `@Table` 注解，框架不知道在执行查询之前何时必须自动刷新。`@org.hibernate.annotations.Synchronize` 注解表明框架需要在执行查询之前刷新
    `ITEM` 和 `BID` 表。
- en: 'Using the read-only `ItemBidSummary` entity class from Hibernate JPA will look
    like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Hibernate JPA 中的只读 `ItemBidSummary` 实体类将看起来像这样：
- en: '[PRE15]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To use the read-only `ItemBidSummary` entity class from Spring Data JPA, you’ll
    first need to introduce a new Spring Data repository:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Spring Data JPA 中的只读 `ItemBidSummary` 实体类，你首先需要引入一个新的 Spring Data 仓库：
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The repository will be effectively used like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库将有效使用如下：
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Entities are coarser-grained classes of a system. Their instances have independent
    lifecycles and their own identities, and many other instances can reference them.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体是系统更粗粒度的类。它们的实例具有独立的生命周期和自己的标识，并且许多其他实例可以引用它们。
- en: Value types are dependent on a particular entity class. A value type instance
    is bound to its owning entity instance, and only one entity instance can reference
    it—it has no individual identity.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型依赖于特定的实体类。值类型实例绑定到其所属的实体实例，并且只有一个实体实例可以引用它——它没有单独的标识。
- en: 'Java identity, object equality, and database identity are different concepts:
    the first two apply in the object-oriented world and the last one in the relational
    database world.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 标识符、对象相等性和数据库标识符是不同的概念：前两个适用于面向对象的世界，最后一个适用于关系数据库世界。
- en: A good primary key is never null, is unique, and never changes.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好的主键永远不会为空，是唯一的，并且永远不会改变。
- en: Generators for primary keys can be configured using different strategies.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主键生成器可以使用不同的策略进行配置。
- en: You can use entities, mapping options, and naming strategies both from Hibernate
    JPA and from Spring Data JPA.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用来自 Hibernate JPA 和 Spring Data JPA 的实体、映射选项和命名策略。
