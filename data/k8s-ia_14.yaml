- en: Chapter 12\. Securing the Kubernetes API server
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 第12章。保护Kubernetes API服务器
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Understanding authentication
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解认证
- en: What ServiceAccounts are and why they’re used
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务账户是什么以及为什么使用它们
- en: Understanding the role-based access control (RBAC) plugin
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解基于角色的访问控制（RBAC）插件
- en: Using Roles and RoleBindings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Roles和RoleBindings
- en: Using ClusterRoles and ClusterRoleBindings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ClusterRoles和ClusterRoleBindings
- en: Understanding the default roles and bindings
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解默认角色和绑定
- en: In [chapter 8](index_split_070.html#filepos790863) you learned how applications
    running in pods can talk to the API server to retrieve or change the state of
    resources deployed in the cluster. To authenticate with the API server, you used
    the ServiceAccount token mounted into the pod. In this chapter, you’ll learn what
    ServiceAccounts are and how to configure their permissions, as well as permissions
    for other subjects using the cluster.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](index_split_070.html#filepos790863)中，你学习了运行在Pod中的应用程序如何与API服务器通信以检索或更改集群中部署的资源的状态。为了与API服务器进行认证，你使用了挂载到Pod中的服务账户令牌。在本章中，你将了解服务账户是什么以及如何配置它们的权限，以及如何配置集群中其他主体的权限。
- en: 12.1\. Understanding authentication
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 12.1. 理解认证
- en: In the previous chapter, we said the API server can be configured with one or
    more authentication plugins (and the same is true for authorization plugins).
    When a request is received by the API server, it goes through the list of authentication
    plugins, so they can each examine the request and try to determine who’s sending
    the request. The first plugin that can extract that information from the request
    returns the username, user ID, and the groups the client belongs to back to the
    API server core. The API server stops invoking the remaining authentication plugins
    and continues onto the authorization phase.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们提到API服务器可以配置一个或多个认证插件（同样适用于授权插件）。当API服务器收到请求时，它会通过认证插件列表，这样它们可以分别检查请求并尝试确定谁发送了请求。第一个能够从请求中提取该信息的插件将用户名、用户ID和客户端所属的组返回给API服务器核心。API服务器停止调用剩余的认证插件并继续到授权阶段。
- en: 'Several authentication plugins are available. They obtain the identity of the
    client using the following methods:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可用几种认证插件。它们使用以下方法获取客户端的身份：
- en: From the client certificate
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从客户端证书
- en: From an authentication token passed in an HTTP header
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从HTTP头中传递的认证令牌
- en: Basic HTTP authentication
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本HTTP认证
- en: Others
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他
- en: The authentication plugins are enabled through command-line options when starting
    the API server.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 认证插件通过启动API服务器时的命令行选项启用。
- en: 12.1.1\. Users and groups
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 12.1.1. 用户和组
- en: An authentication plugin returns the username and group(s) of the authenticated
    user. Kubernetes doesn’t store that information anywhere; it uses it to verify
    whether the user is authorized to perform an action or not.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 认证插件返回已认证用户的用户名和组。Kubernetes不会在任何地方存储该信息；它使用这些信息来验证用户是否有权执行操作。
- en: Understanding users
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 理解用户
- en: 'Kubernetes distinguishes between two kinds of clients connecting to the API
    server:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes区分了两种连接到API服务器的客户端：
- en: Actual humans (users)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际的人类（用户）
- en: Pods (more specifically, applications running inside them)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pods（更具体地说，运行在其内部的应用程序）
- en: Both these types of clients are authenticated using the aforementioned authentication
    plugins. Users are meant to be managed by an external system, such as a Single
    Sign On (SSO) system, but the pods use a mechanism called service accounts, which
    are created and stored in the cluster as ServiceAccount resources. In contrast,
    no resource represents user accounts, which means you can’t create, update, or
    delete users through the API server.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型的客户端都使用前面提到的认证插件进行认证。用户应由外部系统管理，例如单点登录（SSO）系统，但Pod使用一种称为服务账户的机制，这些服务账户作为ServiceAccount资源在集群中创建和存储。相比之下，没有资源代表用户账户，这意味着您无法通过API服务器创建、更新或删除用户。
- en: We won’t go into any details of how to manage users, but we will explore Service-Accounts
    in detail, because they’re essential for running pods. For more information on
    how to configure the cluster for authentication of human users, cluster administrators
    should refer to the Kubernetes Cluster Administrator guide at [http://kubernetes.io/docs/admin](http://kubernetes.io/docs/admin).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍如何管理用户，但我们将详细探讨服务账户，因为它们对于运行Pod至关重要。有关如何配置集群以认证人类用户的更多信息，集群管理员应参考Kubernetes集群管理员指南[http://kubernetes.io/docs/admin](http://kubernetes.io/docs/admin)。
- en: Understanding groups
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 理解组
- en: Both human users and ServiceAccounts can belong to one or more groups. We’ve
    said that the authentication plugin returns groups along with the username and
    user ID. Groups are used to grant permissions to several users at once, instead
    of having to grant them to individual users.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 人类用户和 ServiceAccounts 都可以属于一个或多个组。我们提到身份验证插件会返回与用户名和用户 ID 一起的组。组用于一次性授予多个用户的权限，而不是必须为每个用户单独授予。
- en: 'Groups returned by the plugin are nothing but strings, representing arbitrary
    group names, but built-in groups have special meaning:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 插件返回的组仅仅是字符串，代表任意组名，但内置组有特殊含义：
- en: The `system:unauthenticated` group is used for requests where none of the authentication
    plugins could authenticate the client.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system:unauthenticated` 组用于那些没有任何身份验证插件能够验证客户端的请求。'
- en: The `system:authenticated` group is automatically assigned to a user who was
    authenticated successfully.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system:authenticated` 组会自动分配给成功认证的用户。'
- en: The `system:serviceaccounts` group encompasses all ServiceAccounts in the system.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system:serviceaccounts` 组包含了系统中的所有 ServiceAccounts。'
- en: The `system:serviceaccounts:<namespace>` includes all ServiceAccounts in a specific
    namespace.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system:serviceaccounts:<namespace>` 包含了特定命名空间中的所有 ServiceAccounts。'
- en: 12.1.2\. Introducing ServiceAccounts
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 12.1.2\. 介绍 ServiceAccounts
- en: Let’s explore ServiceAccounts up close. You’ve already learned that the API
    server requires clients to authenticate themselves before they’re allowed to perform
    operations on the server. And you’ve already seen how pods can authenticate by
    sending the contents of the file`/var/run/secrets/kubernetes.io/serviceaccount/token`,
    which is mounted into each container’s filesystem through a `secret` volume.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们近距离探索 ServiceAccounts。你已经了解到 API 服务器要求客户端在允许它们在服务器上执行操作之前进行身份验证。你已经看到 pod
    可以通过发送文件 `/var/run/secrets/kubernetes.io/serviceaccount/token` 的内容来进行身份验证，该文件通过
    `secret` 卷挂载到每个容器的文件系统中。
- en: 'But what exactly does that file represent? Every pod is associated with a Service-Account,
    which represents the identity of the app running in the pod. The token file holds
    the ServiceAccount’s authentication token. When an app uses this token to connect
    to the API server, the authentication plugin authenticates the ServiceAccount
    and passes the ServiceAccount’s username back to the API server core. Service-Account
    usernames are formatted like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个文件究竟代表什么呢？每个 pod 都关联着一个 Service-Account，它代表了 pod 中运行的应用程序的标识。令牌文件包含了 ServiceAccount
    的身份验证令牌。当应用程序使用此令牌连接到 API 服务器时，身份验证插件会验证 ServiceAccount 并将 ServiceAccount 的用户名返回给
    API 服务器核心。Service-Account 用户名格式如下：
- en: '`system:serviceaccount:<namespace>:<service account name>`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`system:serviceaccount:<namespace>:<service account name>`'
- en: The API server passes this username to the configured authorization plugins,
    which determine whether the action the app is trying to perform is allowed to
    be performed by the ServiceAccount.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: API 服务器将此用户名传递给配置的身份验证插件，这些插件确定应用程序尝试执行的操作是否允许由 ServiceAccount 执行。
- en: ServiceAccounts are nothing more than a way for an application running inside
    a pod to authenticate itself with the API server. As already mentioned, applications
    do that by passing the ServiceAccount’s token in the request.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceAccounts 只是一种方式，让运行在 pod 内部的应用程序通过 API 服务器进行身份验证。正如之前提到的，应用程序通过在请求中传递
    ServiceAccount 的令牌来实现这一点。
- en: Understanding the ServiceAccount resource
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 ServiceAccount 资源
- en: ServiceAccounts are resources just like Pods, Secrets, ConfigMaps, and so on,
    and are scoped to individual namespaces. A default ServiceAccount is automatically
    created for each namespace (that’s the one your pods have used all along).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceAccounts 和 Pods、Secrets、ConfigMaps 等一样，是资源，并且范围限定在单个命名空间内。每个命名空间都会自动创建一个默认的
    ServiceAccount（这就是你的 pod 一直使用的那个）。
- en: 'You can list ServiceAccounts like you do other resources:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像列出其他资源一样列出 ServiceAccounts：
- en: '`$ kubectl get sa` `NAME      SECRETS   AGE default   1         1d`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get sa` `NAME      SECRETS   AGE default   1         1d`'
- en: '|  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The shorthand for `serviceaccount` is `sa`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`serviceaccount` 的简写是 `sa`。'
- en: '|  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: As you can see, the current namespace only contains the `default` ServiceAccount.
    Additional ServiceAccounts can be added when required. Each pod is associated
    with exactly one ServiceAccount, but multiple pods can use the same ServiceAccount.
    As you can see in [figure 12.1](#filepos1153659), a pod can only use a ServiceAccount
    from the same namespace.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当前命名空间只包含`default` ServiceAccount。在需要时可以添加额外的ServiceAccounts。每个Pod与一个ServiceAccount关联，但多个Pod可以使用同一个ServiceAccount。如[图12.1](#filepos1153659)所示，Pod只能使用同一命名空间下的ServiceAccount。
- en: Figure 12.1\. Each pod is associated with a single ServiceAccount in the pod’s
    namespace.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1\. 每个Pod与其命名空间中的单个ServiceAccount关联。
- en: '![](images/00195.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00195.jpg)'
- en: Understanding how ServiceAccounts tie into authorization
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 理解ServiceAccount如何与授权相关联
- en: You can assign a ServiceAccount to a pod by specifying the account’s name in
    the pod manifest. If you don’t assign it explicitly, the pod will use the default
    ServiceAccount in the namespace.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在Pod清单中指定账户的名称来将ServiceAccount分配给Pod。如果你没有明确指定，Pod将使用命名空间中的默认ServiceAccount。
- en: By assigning different ServiceAccounts to pods, you can control which resources
    each pod has access to. When a request bearing the authentication token is received
    by the API server, the server uses the token to authenticate the client sending
    the request and then determines whether or not the related ServiceAccount is allowed
    to perform the requested operation. The API server obtains this information from
    the system-wide authorization plugin configured by the cluster administrator.
    One of the available authorization plugins is the role-based access control (RBAC)
    plugin, which is discussed later in this chapter. From Kubernetes version 1.6
    on, the RBAC plugin is the plugin most clusters should use.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将不同的ServiceAccount分配给Pod，你可以控制每个Pod可以访问哪些资源。当API服务器接收到携带认证令牌的请求时，服务器使用令牌来验证发送请求的客户端，然后确定相关的ServiceAccount是否被允许执行请求的操作。API服务器从集群管理员配置的全局授权插件中获取这些信息。可用的授权插件之一是基于角色的访问控制（RBAC）插件，这将在本章后面讨论。从Kubernetes版本1.6开始，RBAC插件是大多数集群应该使用的插件。
- en: 12.1.3\. Creating ServiceAccounts
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 12.1.3\. 创建ServiceAccount
- en: We’ve said every namespace contains its own default ServiceAccount, but additional
    ones can be created if necessary. But why should you bother with creating Service-Accounts
    instead of using the default one for all your pods?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过每个命名空间都包含其自己的默认ServiceAccount，但如果需要，还可以创建额外的。但为什么你应该费心去创建ServiceAccount而不是使用所有Pod的默认ServiceAccount呢？
- en: The obvious reason is cluster security. Pods that don’t need to read any cluster
    metadata should run under a constrained account that doesn’t allow them to retrieve
    or modify any resources deployed in the cluster. Pods that need to retrieve resource
    metadata should run under a ServiceAccount that only allows reading those objects’
    metadata, whereas pods that need to modify those objects should run under their
    own ServiceAccount allowing modifications of API objects.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 显而易见的原因是集群安全。不需要读取任何集群元数据的Pod应该在限制账户下运行，该账户不允许它们检索或修改集群中部署的任何资源。需要检索资源元数据的Pod应该在只允许读取这些对象元数据的ServiceAccount下运行，而需要修改这些对象的Pod应该在允许修改API对象的自己的ServiceAccount下运行。
- en: Let’s see how you can create additional ServiceAccounts, how they relate to
    Secrets, and how you can assign them to your pods.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建额外的ServiceAccounts，它们如何与Secrets相关联，以及如何将它们分配给你的Pod。
- en: Creating a ServiceAccount
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建ServiceAccount
- en: 'Creating a ServiceAccount is incredibly easy, thanks to the dedicated `kubectl
    create serviceaccount` command. Let’s create a new ServiceAccount called `foo`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 创建ServiceAccount非常简单，多亏了专门的`kubectl create serviceaccount`命令。让我们创建一个名为`foo`的新ServiceAccount：
- en: '`$ kubectl create serviceaccount foo` `serviceaccount "foo" created`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create serviceaccount foo` `serviceaccount "foo" created`'
- en: Now, you can inspect the ServiceAccount with the `describe` command, as shown
    in the following listing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`describe`命令检查ServiceAccount，如下所示。
- en: Listing 12.1\. Inspecting a ServiceAccount with `kubectl describe`
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.1\. 使用`kubectl describe`检查ServiceAccount
- en: '`$ kubectl describe sa foo` `Name:               foo Namespace:          default
    Labels:             <none>  Image pull secrets: <none>` `1` `Mountable secrets: 
    foo-token-qzq7j` `2` `Tokens:             foo-token-qzq7j` `3`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl describe sa foo` `Name:               foo Namespace:          default
    Labels:             <none>  Image pull secrets: <none>` `1` `Mountable secrets: 
    foo-token-qzq7j` `2` `Tokens:             foo-token-qzq7j` `3`'
- en: 1 These will be added automatically to all pods using this ServiceAccount.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 这些将被自动添加到所有使用此 ServiceAccount 的 pod 中。
- en: 2 Pods using this ServiceAccount can only mount these Secrets if mountable Secrets
    are enforced.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用此 ServiceAccount 的 2 个 Pod 只能挂载这些密钥，如果强制执行可挂载密钥。
- en: 3 Authentication token(s). The first one is mounted inside the container.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 个身份验证令牌。第一个被挂载在容器内部。
- en: You can see that a custom token Secret has been created and associated with
    the ServiceAccount. If you look at the Secret’s data with `kubectl describe secret
    foo-token-qzq7j`, you’ll see it contains the same items (the CA certificate, namespace,
    and token) as the default ServiceAccount’s token does (the token itself will obviously
    be different), as shown in the following listing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到已经创建了一个自定义令牌密钥，并将其与 ServiceAccount 关联。如果你使用 `kubectl describe secret foo-token-qzq7j`
    查看密钥的数据，你会看到它包含与默认 ServiceAccount 令牌相同的项（CA 证书、命名空间和令牌），如以下列表所示。
- en: Listing 12.2\. Inspecting the custom ServiceAccount’s Secret
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.2\. 检查自定义 ServiceAccount 的密钥
- en: '`$ kubectl describe secret foo-token-qzq7j` `... ca.crt:         1066 bytes
    namespace:      7 bytes token:          eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl describe secret foo-token-qzq7j` `... ca.crt:         1066 bytes
    namespace:      7 bytes token:          eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...`'
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You’ve probably heard of JSON Web Tokens (JWT). The authentication tokens used
    in ServiceAccounts are JWT tokens.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过 JSON Web Tokens（JWT）。ServiceAccounts 中使用的身份验证令牌是 JWT 令牌。
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Understanding a ServiceAccount’s mountable secrets
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 ServiceAccount 的可挂载密钥
- en: 'The token is shown in the `Mountable secrets` list when you inspect a ServiceAccount
    with `kubectl describe`. Let me explain what that list represents. In [chapter
    7](index_split_063.html#filepos687721) you learned how to create Secrets and mount
    them inside a pod. By default, a pod can mount any Secret it wants. But the pod’s
    ServiceAccount can be configured to only allow the pod to mount Secrets that are
    listed as mountable Secrets on the Service-Account. To enable this feature, the
    ServiceAccount must contain the following annotation: `kubernetes.io/enforce-mountable-secrets="true"`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `kubectl describe` 检查 ServiceAccount 时，令牌会显示在“可挂载密钥”列表中。让我解释一下这个列表代表什么。在[第
    7 章](index_split_063.html#filepos687721)中，你学习了如何创建密钥并在 pod 内部挂载它们。默认情况下，pod 可以挂载它想要的任何密钥。但是，pod
    的 ServiceAccount 可以配置为只允许 pod 挂载 ServiceAccount 上列出的可挂载密钥。要启用此功能，ServiceAccount
    必须包含以下注解：`kubernetes.io/enforce-mountable-secrets="true"`。
- en: If the ServiceAccount is annotated with this annotation, any pods using it can
    mount only the ServiceAccount’s mountable Secrets—they can’t use any other Secret.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ServiceAccount 被注解了此注解，任何使用它的 pod 只能挂载 ServiceAccount 的可挂载密钥——它们不能使用任何其他密钥。
- en: Understanding a ServiceAccount’s image pull Secrets
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 ServiceAccount 的镜像拉取密钥
- en: A ServiceAccount can also contain a list of image pull Secrets, which we examined
    in [chapter 7](index_split_063.html#filepos687721). In case you don’t remember,
    they are Secrets that hold the credentials for pulling container images from a
    private image repository.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceAccount 还可以包含一个镜像拉取密钥列表，我们在[第 7 章](index_split_063.html#filepos687721)中进行了探讨。如果你不记得，它们是包含从私有镜像仓库拉取容器镜像凭证的密钥。
- en: The following listing shows an example of a ServiceAccount definition, which
    includes the image pull Secret you created in [chapter 7](index_split_063.html#filepos687721).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个 ServiceAccount 定义示例，其中包含你在[第 7 章](index_split_063.html#filepos687721)中创建的镜像拉取密钥。
- en: 'Listing 12.3\. ServiceAccount with an image pull Secret: sa-image-pull-secrets.yaml'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.3\. 带有镜像拉取密钥的 ServiceAccount：sa-image-pull-secrets.yaml
- en: '`apiVersion: v1 kind: ServiceAccount metadata:   name: my-service-account imagePullSecrets:
    - name: my-dockerhub-secret`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: ServiceAccount metadata:   name: my-service-account imagePullSecrets:
    - name: my-dockerhub-secret`'
- en: A ServiceAccount’s image pull Secrets behave slightly differently than its mountable
    Secrets. Unlike mountable Secrets, they don’t determine which image pull Secrets
    a pod can use, but which ones are added automatically to all pods using the Service-Account.
    Adding image pull Secrets to a ServiceAccount saves you from having to add them
    to each pod individually.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceAccount 的镜像拉取密钥的行为与其可挂载密钥略有不同。与可挂载密钥不同，它们不决定 pod 可以使用哪些镜像拉取密钥，而是自动添加到所有使用
    Service-Account 的 pod 中。将镜像拉取密钥添加到 ServiceAccount 中可以节省你逐个添加到每个 pod 中的时间。
- en: 12.1.4\. Assigning a ServiceAccount to a pod
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 12.1.4\. 将 ServiceAccount 分配给 pod
- en: After you create additional ServiceAccounts, you need to assign them to pods.
    This is done by setting the name of the ServiceAccount in the `spec.serviceAccountName`
    field in the pod definition.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建额外的 ServiceAccounts 后，你需要将它们分配给 pod。这是通过在 pod 定义中的 `spec.serviceAccountName`
    字段中设置 ServiceAccount 的名称来完成的。
- en: '|  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A pod’s ServiceAccount must be set when creating the pod. It can’t be changed
    later.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 pod 时必须设置 pod 的 ServiceAccount。之后不能更改。
- en: '|  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Creating a pod which uses a custom ServiceAccount
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建使用自定义 ServiceAccount 的 pod
- en: In [chapter 8](index_split_070.html#filepos790863) you deployed a pod that ran
    a container based on the `tutum/curl` image and an ambassador container alongside
    it. You used it to explore the API server’s REST interface. The ambassador container
    ran the `kubectl proxy` process, which used the pod’s ServiceAccount’s token to
    authenticate with the API server.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](index_split_070.html#filepos790863) 中，你部署了一个 pod，该 pod 运行基于 `tutum/curl`
    镜像的容器以及旁边的代理容器。你用它来探索 API 服务器的 REST 接口。代理容器运行了 `kubectl proxy` 进程，该进程使用 pod 的
    ServiceAccount 的令牌与 API 服务器进行身份验证。
- en: You can now modify the pod so it uses the `foo` ServiceAccount you created minutes
    ago. The next listing shows the pod definition.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以修改 pod，使其使用你几分钟前创建的 `foo` ServiceAccount。下一个列表显示了 pod 定义。
- en: 'Listing 12.4\. Pod using a non-default ServiceAccount: curl-custom-sa.yaml'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.4\. 使用非默认 ServiceAccount 的 pod：curl-custom-sa.yaml
- en: '`apiVersion: v1 kind: Pod metadata:   name: curl-custom-sa spec:   serviceAccountName:
    foo` `1` `containers:   - name: main     image: tutum/curl     command: ["sleep",
    "9999999"]   - name: ambassador     image: luksa/kubectl-proxy:1.6.2`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: v1 kind: Pod metadata:   name: curl-custom-sa spec:   serviceAccountName:
    foo` `1` `containers:   - name: main     image: tutum/curl     command: ["sleep",
    "9999999"]   - name: ambassador     image: luksa/kubectl-proxy:1.6.2`'
- en: 1 This pod uses the foo ServiceAccount instead of the default.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 此 pod 使用 foo ServiceAccount 而不是默认的。
- en: To confirm that the custom ServiceAccount’s token is mounted into the two containers,
    you can print the contents of the token as shown in the following listing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认自定义 ServiceAccount 的令牌已挂载到两个容器中，你可以打印出令牌的内容，如下所示。
- en: Listing 12.5\. Inspecting the token mounted into the pod’s container(s)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.5\. 检查挂载到 pod 容器中的令牌
- en: '`$ kubectl exec -it curl-custom-sa -c main`![](images/00006.jpg)`cat /var/run/secrets/kubernetes.io/serviceaccount/token`
    `eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec -it curl-custom-sa -c main`![](images/00006.jpg)`cat /var/run/secrets/kubernetes.io/serviceaccount/token`
    `eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...`'
- en: You can see the token is the one from the `foo` ServiceAccount by comparing
    the token string in [listing 12.5](#filepos1163557) with the one in [listing 12.2](#filepos1158187).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过比较 [列表 12.5](#filepos1163557) 中的令牌字符串与 [列表 12.2](#filepos1158187) 中的令牌字符串来看到令牌来自
    `foo` ServiceAccount。
- en: Using the custom ServiceAccount’s token to talk to the API server
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义 ServiceAccount 的令牌与 API 服务器通信
- en: Let’s see if you can talk to the API server using this token. As mentioned previously,
    the ambassador container uses the token when talking to the server, so you can
    test the token by going through the ambassador, which listens on `localhost:8001`,
    as shown in the following listing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否可以使用这个令牌与 API 服务器通信。如前所述，代理容器在与服务器通信时使用令牌，因此你可以通过代理容器进行测试，该代理容器监听 `localhost:8001`，如下所示。
- en: Listing 12.6\. Talking to the API server with a custom ServiceAccount
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.6\. 使用自定义 ServiceAccount 与 API 服务器通信
- en: '`$ kubectl exec -it curl-custom-sa -c main curl localhost:8001/api/v1/pods``{`
    `"kind": "PodList",   "apiVersion": "v1",   "metadata": {     "selfLink": "/api/v1/pods",
        "resourceVersion": "433895"   },   "items": [   ...`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec -it curl-custom-sa -c main curl localhost:8001/api/v1/pods``{`
    `"kind": "PodList",   "apiVersion": "v1",   "metadata": {     "selfLink": "/api/v1/pods",
        "resourceVersion": "433895"   },   "items": [   ...`'
- en: Okay, you got back a proper response from the server, which means the custom
    Service-Account is allowed to list pods. This may be because your cluster doesn’t
    use the RBAC authorization plugin, or you gave all ServiceAccounts full permissions,
    as instructed in [chapter 8](index_split_070.html#filepos790863).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，你从服务器得到了一个正确的响应，这意味着自定义 Service-Account 被允许列出 pod。这可能是因为你的集群没有使用 RBAC 授权插件，或者你按照
    [第 8 章](index_split_070.html#filepos790863) 中的说明赋予了所有 ServiceAccounts 完全权限。
- en: When your cluster isn’t using proper authorization, creating and using additional
    ServiceAccounts doesn’t make much sense, since even the default ServiceAccount
    is allowed to do anything. The only reason to use ServiceAccounts in that case
    is to enforce mountable Secrets or to provide image pull Secrets through the Service-Account,
    as explained earlier.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的集群没有使用适当的授权时，创建和使用额外的ServiceAccounts并没有太多意义，因为默认的ServiceAccount被允许做任何事情。在这种情况下使用ServiceAccounts的唯一原因是为了强制挂载Secrets或通过Service-Account提供图像拉取Secrets，正如之前所解释的。
- en: But creating additional ServiceAccounts is practically a must when you use the
    RBAC authorization plugin, which we’ll explore next.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但在使用RBAC授权插件时，创建额外的ServiceAccounts实际上几乎是必须的，我们将在下一节中探讨这一点。
- en: 12.2\. Securing the cluster with role-based access control
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 12.2. 集群基于角色的访问控制
- en: Starting with Kubernetes version 1.6.0, cluster security was ramped up considerably.
    In earlier versions, if you managed to acquire the authentication token from one
    of the pods, you could use it to do anything you want in the cluster. If you google
    around, you’ll find demos showing how a path traversal (or directory traversal)
    attack (where clients can retrieve files located outside of the web server’s web
    root directory) can be used to get the token and use it to run your malicious
    pods in an insecure Kubernetes cluster.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从Kubernetes版本1.6.0开始，集群安全性得到了显著提升。在早期版本中，如果你设法从某个Pod获取了认证令牌，你就可以用它来在集群中做任何你想做的事情。如果你在网上搜索，你会找到一些演示，展示了路径遍历（或目录遍历）攻击（客户端可以检索位于Web服务器Web根目录之外的文件）是如何被用来获取令牌，并使用它来在不受保护的Kubernetes集群中运行恶意Pod的。
- en: But in version 1.8.0, the RBAC authorization plugin graduated to GA (General
    Availability) and is now enabled by default on many clusters (for example, when
    deploying a cluster with kubadm, as described in [appendix B](index_split_138.html#filepos1737471)).
    RBAC prevents unauthorized users from viewing or modifying the cluster state.
    The default Service-Account isn’t allowed to view cluster state, let alone modify
    it in any way, unless you grant it additional privileges. To write apps that communicate
    with the Kubernetes API server (as described in [chapter 8](index_split_070.html#filepos790863)),
    you need to understand how to manage authorization through RBAC-specific resources.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但在版本1.8.0中，RBAC授权插件升级为GA（通用可用性），现在许多集群默认启用（例如，当使用kubadm部署集群时，如附录B中所述[appendix
    B](index_split_138.html#filepos1737471)）。RBAC阻止未经授权的用户查看或修改集群状态。默认Service-Account不允许查看集群状态，更不用说以任何方式修改它了，除非你授予它额外的权限。要编写与Kubernetes
    API服务器通信的应用程序（如第8章中所述[chapter 8](index_split_070.html#filepos790863)），你需要了解如何通过RBAC特定资源管理授权。
- en: '|  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In addition to RBAC, Kubernetes also includes other authorization plugins, such
    as the Attribute-based access control (ABAC) plugin, a Web-Hook plugin and custom
    plugin implementations. RBAC is the standard, though.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了RBAC之外，Kubernetes还包括其他授权插件，例如基于属性的访问控制（ABAC）插件、Web钩子插件和自定义插件实现。尽管如此，RBAC仍然是标准。
- en: '|  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 12.2.1\. Introducing the RBAC authorization plugin
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 12.2.1. 介绍RBAC授权插件
- en: The Kubernetes API server can be configured to use an authorization plugin to
    check whether an action is allowed to be performed by the user requesting the
    action. Because the API server exposes a REST interface, users perform actions
    by sending HTTP requests to the server. Users authenticate themselves by including
    credentials in the request (an authentication token, username and password, or
    a client certificate).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API服务器可以被配置为使用授权插件来检查用户请求的操作是否被允许执行。因为API服务器公开了一个REST接口，用户通过向服务器发送HTTP请求来执行操作。用户通过在请求中包含凭证（认证令牌、用户名和密码或客户端证书）来自我认证。
- en: Understanding actions
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 理解操作
- en: 'But what actions are there? As you know, REST clients send `GET`, `POST`, `PUT`,
    `DELETE`, and other types of HTTP requests to specific URL paths, which represent
    specific REST resources. In Kubernetes, those resources are Pods, Services, Secrets,
    and so on. Here are a few examples of actions in Kubernetes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但有哪些操作呢？正如你所知，REST客户端通过向特定URL路径发送`GET`、`POST`、`PUT`、`DELETE`和其他类型的HTTP请求来发送操作，这些路径代表特定的REST资源。在Kubernetes中，这些资源包括Pods、Services、Secrets等。以下是一些Kubernetes中操作示例：
- en: Get Pods
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取Pods
- en: Create Services
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建服务
- en: Update Secrets
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新Secrets
- en: And so on
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等
- en: The verbs in those examples (get, create, update) map to HTTP methods (`GET`,
    `POST`, `PUT`) performed by the client (the complete mapping is shown in [table
    12.1](#filepos1169820)). The nouns (Pods, Service, Secrets) obviously map to Kubernetes
    resources.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例中的动词（get、create、update）映射到客户端（客户端执行的 HTTP 方法）执行的 HTTP 方法（`GET`、`POST`、`PUT`）。名词（Pods、Service、Secrets）显然映射到
    Kubernetes 资源。
- en: An authorization plugin such as RBAC, which runs inside the API server, determines
    whether a client is allowed to perform the requested verb on the requested resource
    or not.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: API 服务器内部运行的授权插件 RBAC 确定客户端是否被允许在请求的资源上执行请求的动词。
- en: Table 12.1\. Mapping HTTP methods to authorization verbs
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.1\. 将 HTTP 方法映射到授权动词
- en: '| HTTP method | Verb for single resource | Verb for collection |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| HTTP 方法 | 单个资源的动词 | 集合的动词 |'
- en: '| GET, HEAD | get (and watch for watching) | list (and watch) |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| GET, HEAD | get（以及监视）| list（以及监视）|'
- en: '| POST | create | n/a |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| POST | create | n/a |'
- en: '| PUT | update | n/a |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| PUT | update | n/a |'
- en: '| PATCH | patch | n/a |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| PATCH | patch | n/a |'
- en: '| DELETE | delete | deletecollection |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| DELETE | delete | deletecollection |'
- en: '|  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The additional verb `use` is used for PodSecurityPolicy resources, which are
    explained in the next chapter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的动词 `use` 用于 PodSecurityPolicy 资源，这些资源将在下一章中解释。
- en: '|  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Besides applying security permissions to whole resource types, RBAC rules can
    also apply to specific instances of a resource (for example, a Service called
    `myservice`). And later you’ll see that permissions can also apply to non-resource
    URL paths, because not every path the API server exposes maps to a resource (such
    as the `/api` path itself or the server health information at `/healthz`).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将安全权限应用于整个资源类型之外，RBAC 规则还可以应用于资源的特定实例（例如，名为 `myservice` 的服务）。稍后您将看到，权限还可以应用于非资源
    URL 路径，因为并非 API 服务器公开的每个路径都映射到资源（例如，`/api` 路径本身或 `/healthz` 上的服务器健康信息）。
- en: Understanding the RBAC plugin
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 RBAC 插件
- en: The RBAC authorization plugin, as the name suggests, uses user roles as the
    key factor in determining whether the user may perform the action or not. A subject
    (which may be a human, a ServiceAccount, or a group of users or ServiceAccounts)
    is associated with one or more roles and each role is allowed to perform certain
    verbs on certain resources.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，RBAC 授权插件使用用户角色作为确定用户是否可以执行操作的关键因素。一个主体（可能是人类、ServiceAccount 或用户或 ServiceAccount
    的组）与一个或多个角色相关联，并且每个角色都允许在特定资源上执行某些动词。
- en: If a user has multiple roles, they may do anything that any of their roles allows
    them to do. If none of the user’s roles contains a permission to, for example,
    update Secrets, the API server will prevent the user from performing `PUT` or
    `PATCH` requests on Secrets.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户拥有多个角色，他们可以执行任何他们的角色允许他们做的事情。如果用户的所有角色中都没有更新 Secrets 的权限，API 服务器将阻止用户对 Secrets
    执行 `PUT` 或 `PATCH` 请求。
- en: Managing authorization through the RBAC plugin is simple. It’s all done by creating
    four RBAC-specific Kubernetes resources, which we’ll look at next.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 RBAC 插件管理授权很简单。所有操作都是通过创建四个特定的 RBAC Kubernetes 资源来完成的，我们将在下一节中探讨这些资源。
- en: 12.2.2\. Introducing RBAC resources
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 12.2.2\. 介绍 RBAC 资源
- en: 'The RBAC authorization rules are configured through four resources, which can
    be grouped into two groups:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC 授权规则通过四个资源进行配置，这些资源可以分为两组：
- en: Roles and ClusterRoles, which specify which verbs can be performed on which
    resources.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色和 ClusterRoles，它们指定可以在哪些资源上执行哪些动词。
- en: RoleBindings and ClusterRoleBindings, which bind the above roles to specific
    users, groups, or ServiceAccounts.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色绑定和 ClusterRoleBinding，它们将上述角色绑定到特定的用户、组或 ServiceAccount。
- en: Roles define what can be done, while bindings define who can do it (this is
    shown in [figure 12.2](#filepos1173328)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 角色定义可以做什么，而绑定定义谁可以做（这可以在 [图 12.2](#filepos1173328) 中看到）。
- en: Figure 12.2\. Roles grant permissions, whereas RoleBindings bind Roles to subjects.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2\. 角色授予权限，而角色绑定将角色绑定到主体。
- en: '![](images/00016.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00016.jpg)'
- en: The distinction between a Role and a ClusterRole, or between a RoleBinding and
    a ClusterRoleBinding, is that the Role and RoleBinding are namespaced resources,
    whereas the ClusterRole and ClusterRoleBinding are cluster-level resources (not
    namespaced). This is depicted in [figure 12.3](#filepos1173925).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 角色与 ClusterRole，或角色绑定与 ClusterRoleBinding 之间的区别在于，角色和角色绑定是命名空间资源，而 ClusterRole
    和 ClusterRoleBinding 是集群级别的资源（非命名空间）。这可以在 [图 12.3](#filepos1173925) 中看到。
- en: Figure 12.3\. Roles and RoleBindings are namespaced; ClusterRoles and ClusterRoleBindings
    aren’t.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3\. 角色和 RoleBindings 是命名空间级别的；ClusterRoles 和 ClusterRoleBindings 不是。
- en: '![](images/00037.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/00037.jpg)'
- en: As you can see from the figure, multiple RoleBindings can exist in a single
    name-space (this is also true for Roles). Likewise, multiple ClusterRoleBindings
    and Cluster-Roles can be created. Another thing shown in the figure is that although
    RoleBindings are namespaced, they can also reference ClusterRoles, which aren’t.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，一个命名空间中可以存在多个 RoleBindings（对于 Roles 也是如此）。同样，可以创建多个 ClusterRoleBindings
    和 Cluster-Roles。图中还显示，尽管 RoleBindings 是命名空间级别的，但它们也可以引用 ClusterRoles，而 ClusterRoles
    不是。
- en: The best way to learn about these four resources and what their effects are
    is by trying them out in a hands-on exercise. You’ll do that now.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这四种资源及其影响的最佳方式是通过实际操作练习来尝试它们。你现在将这样做。
- en: Setting up your exercise
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 设置你的练习
- en: Before you can explore how RBAC resources affect what you can do through the
    API server, you need to make sure RBAC is enabled in your cluster. First, ensure
    you’re using at least version 1.6 of Kubernetes and that the RBAC plugin is the
    only configured authorization plugin. There can be multiple plugins enabled in
    parallel and if one of them allows an action to be performed, the action is allowed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够探索 RBAC 资源如何影响通过 API 服务器可以执行的操作之前，你需要确保你的集群中启用了 RBAC。首先，确保你至少使用 Kubernetes
    的 1.6 版本，并且 RBAC 插件是唯一配置的授权插件。可以并行启用多个插件，如果其中之一允许执行某个操作，则该操作将被允许。
- en: '|  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re using GKE 1.6 or 1.7, you need to explicitly disable legacy authorization
    by creating the cluster with the `--no-enable-legacy-authorization` option. If
    you’re using Minikube, you also may need to enable RBAC by starting Minikube with
    `--extra-config=apiserver.Authorization.Mode=RBAC`
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 GKE 1.6 或 1.7，你需要通过使用 `--no-enable-legacy-authorization` 选项创建集群来显式禁用旧版授权。如果你使用的是
    Minikube，你也可能需要通过使用 `--extra-config=apiserver.Authorization.Mode=RBAC` 选项启动 Minikube
    来启用 RBAC。
- en: '|  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If you followed the instructions on how to disable RBAC in [chapter 8](index_split_070.html#filepos790863),
    now’s the time to re-enable it by running the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照 [第 8 章](index_split_070.html#filepos790863) 中的说明禁用了 RBAC，现在是时候通过运行以下命令重新启用它：
- en: '`$ kubectl delete clusterrolebinding permissive-binding`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl delete clusterrolebinding permissive-binding`'
- en: To try out RBAC, you’ll run a pod through which you’ll try to talk to the API
    server, the way you did in [chapter 8](index_split_070.html#filepos790863). But
    this time you’ll run two pods in different namespaces to see how per-namespace
    security behaves.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试 RBAC，你将运行一个 pod，通过这个 pod 你将尝试与 API 服务器通信，就像你在 [第 8 章](index_split_070.html#filepos790863)
    中做的那样。但这次你将在不同的命名空间中运行两个 pod，以查看每个命名空间的网络安全行为。
- en: In the examples in [chapter 8](index_split_070.html#filepos790863), you ran
    two containers to demonstrate how an application in one container uses the other
    container to talk to the API server. This time, you’ll run a single container
    (based on the `kubectl-proxy` image) and use `kubectl exec` to run `curl` inside
    that container directly. The proxy will take care of authentication and HTTPS,
    so you can focus on the authorization aspect of API server security.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](index_split_070.html#filepos790863) 中的示例中，你运行了两个容器来演示一个容器中的应用程序如何使用另一个容器与
    API 服务器通信。这次，你将运行一个单独的容器（基于 `kubectl-proxy` 镜像），并使用 `kubectl exec` 在该容器内部直接运行
    `curl`。代理将负责身份验证和 HTTPS，这样你就可以专注于 API 服务器安全性的授权方面。
- en: Creating the namespaces and running the pods
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 创建命名空间并运行 pod
- en: You’re going to create one pod in namespace `foo` and the other one in namespace
    `bar`, as shown in the following listing.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要在命名空间 `foo` 中创建一个 pod，在命名空间 `bar` 中创建另一个 pod，如下面的列表所示。
- en: Listing 12.7\. Running test pods in different namespaces
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.7\. 在不同命名空间中运行测试 pod
- en: '`$ kubectl create ns foo` `namespace "foo" created` `$ kubectl run test --image=luksa/kubectl-proxy
    -n foo` `deployment "test" created` `$ kubectl create ns bar` `namespace "bar"
    created` `$ kubectl run test --image=luksa/kubectl-proxy -n bar` `deployment "test"
    created`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create ns foo` `namespace "foo" created` `$ kubectl run test --image=luksa/kubectl-proxy
    -n foo` `deployment "test" created` `$ kubectl create ns bar` `namespace "bar"
    created` `$ kubectl run test --image=luksa/kubectl-proxy -n bar` `deployment "test"
    created`'
- en: 'Now open two terminals and use `kubectl exec` to run a shell inside each of
    the two pods (one in each terminal). For example, to run the shell in the pod
    in namespace `foo`, first get the name of the pod:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开两个终端，并使用 `kubectl exec` 在两个 pod 中运行一个 shell（每个终端一个 pod）。例如，要在命名空间 `foo`
    中的 pod 中运行 shell，首先获取 pod 的名称：
- en: '`$ kubectl get po -n foo` `NAME                   READY     STATUS    RESTARTS  
    AGE` `test-145485760-ttq36``   1/1       Running   0          1m`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get po -n foo` `NAME                   READY     STATUS    RESTARTS  
    AGE` `test-145485760-ttq36``   1/1       Running   0          1m`'
- en: 'Then use the name in the `kubectl exec` command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`kubectl exec`命令中的名称：
- en: '`$ kubectl exec -it test-145485760-ttq36 -n foo sh` `/ #`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl exec -it test-145485760-ttq36 -n foo sh` `/ #`'
- en: Do the same in the other terminal, but for the pod in the `bar` namespace.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中执行相同的操作，但针对`bar`命名空间中的Pod。
- en: Listing Services from your pods
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的Pod中列出服务
- en: 'To verify that RBAC is enabled and preventing the pod from reading cluster
    state, use `curl` to list Services in the `foo` namespace:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证RBAC是否启用并阻止Pod读取集群状态，请使用`curl`列出`foo`命名空间中的服务：
- en: '`/ # curl localhost:8001/api/v1/namespaces/foo/services` `User "system:serviceaccount:foo:default"
    cannot list services in the namespace "foo".`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`/ # curl localhost:8001/api/v1/namespaces/foo/services` `用户"system:serviceaccount:foo:default"无法在命名空间"foo"中列出服务。`'
- en: You’re connecting to `localhost:8001`, which is where the `kubectl proxy` process
    is listening (as explained in [chapter 8](index_split_070.html#filepos790863)).
    The process received your request and sent it to the API server while authenticating
    as the default ServiceAccount in the `foo` namespace (as evident from the API
    server’s response).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在连接到`localhost:8001`，这是`kubectl proxy`进程监听的位置（如第8章所述）。进程收到您的请求，并将其发送到API服务器，同时以`foo`命名空间中的默认ServiceAccount进行身份验证（如API服务器的响应所示）。
- en: The API server responded that the ServiceAccount isn’t allowed to list Services
    in the `foo` namespace, even though the pod is running in that same namespace.
    You’re seeing RBAC in action. The default permissions for a ServiceAccount don’t
    allow it to list or modify any resources. Now, let’s learn how to allow the ServiceAccount
    to do that. First, you’ll need to create a Role resource.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: API服务器响应称，ServiceAccount不允许在`foo`命名空间中列出服务，即使Pod在该命名空间中运行。您正在看到RBAC（基于角色的访问控制）的实际应用。ServiceAccount的默认权限不允许其列出或修改任何资源。现在，让我们学习如何允许ServiceAccount执行这些操作。首先，您需要创建一个角色资源。
- en: 12.2.3\. Using Roles and RoleBindings
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 12.2.3. 使用角色和角色绑定
- en: A Role resource defines what actions can be taken on which resources (or, as
    explained earlier, which types of HTTP requests can be performed on which RESTful
    resources). The following listing defines a Role, which allows users to `get`
    and `list` Services in the `foo` namespace.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 角色资源定义了可以在哪些资源上执行哪些操作（或者，如前所述，可以在哪些RESTful资源上执行哪些类型的HTTP请求）。以下列表定义了一个角色，允许用户在`foo`命名空间中`get`和`list`服务。
- en: 'Listing 12.8\. A definition of a `Role`: service-reader.yaml'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.8. 角色定义：service-reader.yaml
- en: '`apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata:   namespace:
    foo` `1` `name: service-reader rules: - apiGroups: [""]` `2` `verbs: ["get", "list"]`
    `3` `resources: ["services"]` `4`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: namespace: foo`
    `1` `name: service-reader rules: - apiGroups: [""]` `2` `verbs: ["get", "list"]`
    `3` `resources: ["services"]` `4`'
- en: 1 Roles are namespaced (if namespace is omitted, the current namespace is used).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 角色是命名空间级别的（如果省略命名空间，则使用当前命名空间）。
- en: 2 Services are resources in the core apiGroup, which has no name – hence the
    “”.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 服务是核心apiGroup中的资源，该apiGroup没有名称，因此为“”。
- en: 3 Getting individual Services (by name) and listing all of them is allowed.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 允许通过名称获取单个服务并列出所有服务。
- en: 4 This rule pertains to services (plural name must be used!).
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 此规则适用于服务（必须使用复数形式！）。
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The plural form must be used when specifying resources.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 指定资源时必须使用复数形式。
- en: '|  |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This Role resource will be created in the `foo` namespace. In [chapter 8](index_split_070.html#filepos790863),
    you learned that each resource type belongs to an API group, which you specify
    in the `apiVersion` field (along with the version) in the resource’s manifest.
    In a Role definition, you need to specify the `apiGroup` for the resources listed
    in each rule included in the definition. If you’re allowing access to resources
    belonging to different API groups, you use multiple rules.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此角色资源将在`foo`命名空间中创建。在第8章中，您学习了每种资源类型都属于一个API组，您在资源的清单中指定该API组（以及版本）字段。在角色定义中，您需要指定定义中包含的每个规则中列出的资源的`apiGroup`。如果您允许访问属于不同API组的资源，则使用多个规则。
- en: '|  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the example, you’re allowing access to all Service resources, but you could
    also limit access only to specific Service instances by specifying their names
    through an additional `resourceNames` field.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，您允许访问所有服务资源，但您也可以通过指定额外的`resourceNames`字段来仅限制对特定服务实例的访问。
- en: '|  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[Figure 12.4](#filepos1183144) shows the Role, its verbs and resources, and
    the namespace it will be created in.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12.4](#filepos1183144)显示了角色、其动词和资源以及它将被创建的命名空间。'
- en: Figure 12.4\. The service-reader Role allows getting and listing Services in
    the foo namespace.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4\. `service-reader`角色允许在foo命名空间中获取和列出服务。
- en: '![](images/00056.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00056.jpg)'
- en: Creating a Role
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 创建角色
- en: 'Create the previous Role in the `foo` namespace now:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`foo`命名空间中创建前面的角色：
- en: '`$ kubectl create -f service-reader.yaml -n foo` `role "service-reader" created`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create -f service-reader.yaml -n foo` `role "service-reader" created`'
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `-n` option is shorthand for `--namespace`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`-n`选项是`--namespace`的缩写。'
- en: '|  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Note that if you’re using GKE, the previous command may fail because you don’t
    have cluster-admin rights. To grant the rights, run the following command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您正在使用GKE，前面的命令可能会失败，因为您没有集群管理员权限。要授予权限，请运行以下命令：
- en: '`$ kubectl create clusterrolebinding cluster-admin-binding`![](images/00006.jpg)
    `--clusterrole=cluster-admin --user=your.email@address.com`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create clusterrolebinding cluster-admin-binding`![](images/00006.jpg)`--clusterrole=cluster-admin
    --user=your.email@address.com`'
- en: 'Instead of creating the `service-reader` Role from a YAML file, you could also
    create it with the special `kubectl create role` command. Let’s use this method
    to create the Role in the `bar` namespace:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从YAML文件创建`service-reader`角色外，您还可以使用特殊的`kubectl create role`命令创建它。让我们使用这种方法在`bar`命名空间中创建角色：
- en: '`$ kubectl create role service-reader --verb=get --verb=list`![](images/00006.jpg)`--resource=services
    -n bar` `role "service-reader" created`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create role service-reader --verb=get --verb=list`![](images/00006.jpg)`--resource=services
    -n bar` `role "service-reader" created`'
- en: These two Roles will allow you to list Services in the `foo` and `bar` namespaces
    from within your two pods (running in the `foo` and `bar` namespace, respectively).
    But creating the two Roles isn’t enough (you can check by executing the `curl`
    command again). You need to bind each of the Roles to the ServiceAccounts in their
    respective namespaces.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个角色将允许您从您的两个Pod中列出`foo`和`bar`命名空间中的服务（分别在`foo`和`bar`命名空间中运行）。但是创建两个角色还不够（您可以通过再次执行`curl`命令来检查）。您需要将每个角色绑定到它们各自命名空间中的服务账户。
- en: Binding a Role to a ServiceAccount
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将角色绑定到服务账户
- en: A Role defines what actions can be performed, but it doesn’t specify who can
    perform them. To do that, you must bind the Role to a subject, which can be a
    user, a Service-Account, or a group (of users or ServiceAccounts).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 角色定义了可以执行哪些操作，但它没有指定谁可以执行它们。为了做到这一点，您必须将角色绑定到主体，该主体可以是用户、服务账户或组（用户或服务账户的组）。
- en: 'Binding Roles to subjects is achieved by creating a RoleBinding resource. To
    bind the Role to the `default` ServiceAccount, run the following command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建RoleBinding资源将角色绑定到主体。要将角色绑定到`default`服务账户，请运行以下命令：
- en: '`$ kubectl create rolebinding test --role=service-reader`![](images/00006.jpg)`--serviceaccount=foo:default
    -n foo` `rolebinding "test" created`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create rolebinding test --role=service-reader`![](images/00006.jpg)`--serviceaccount=foo:default
    -n foo` `rolebinding "test" created`'
- en: The command should be self-explanatory. You’re creating a RoleBinding, which
    binds the `service-reader` Role to the `default` Service-Account in namespace
    `foo`. You’re creating the RoleBinding in namespace `foo`. The RoleBinding and
    the referenced ServiceAccount and Role are shown in [figure 12.5](#filepos1186684).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 命令应该是自解释的。您正在创建一个RoleBinding，它将`service-reader`角色绑定到`foo`命名空间中的`default`服务账户。您正在`foo`命名空间中创建RoleBinding。RoleBinding以及引用的服务账户和角色在[图12.5](#filepos1186684)中显示。
- en: Figure 12.5\. The test RoleBinding binds the `default ServiceAccount` with the
    `service-reader` Role.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5\. 测试RoleBinding将`default ServiceAccount`与`service-reader`角色绑定。
- en: '![](images/00076.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00076.jpg)'
- en: '|  |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To bind a Role to a user instead of a ServiceAccount, use the `--user` argument
    to specify the username. To bind it to a group, use `--group`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要将角色绑定到用户而不是服务账户，请使用`--user`参数指定用户名。要将它绑定到组，请使用`--group`。
- en: '|  |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The following listing shows the YAML of the RoleBinding you created.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了您创建的RoleBinding的YAML。
- en: Listing 12.9\. A RoleBinding referencing a Role
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.9\. 引用角色的RoleBinding
- en: '`$ kubectl get rolebinding test -n foo -o yaml` `apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding metadata:   name: test   namespace: foo   ... roleRef:   apiGroup:
    rbac.authorization.k8s.io   kind: Role` `1` `name: service-reader` `1` `subjects:
    - kind: ServiceAccount` `2` `name: default` `2` `namespace: foo` `2`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get rolebinding test -n foo -o yaml`'
- en: 1 This RoleBinding references the service-reader Role.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 此RoleBinding引用了service-reader Role。
- en: 2 And binds it to the default ServiceAccount in the foo namespace.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 并将其绑定到foo命名空间中的默认ServiceAccount。
- en: As you can see, a RoleBinding always references a single Role (as evident from
    the `roleRef` property), but can bind the Role to multiple `subjects` (for example,
    one or more Service-Accounts and any number of users or groups). Because this
    RoleBinding binds the Role to the ServiceAccount the pod in namespace `foo` is
    running under, you can now list Services from within that pod.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，RoleBinding始终引用单个Role（从`roleRef`属性中可以明显看出），但可以将Role绑定到多个`subjects`（例如，一个或多个Service-Accounts以及任意数量的用户或组）。因为这个RoleBinding将Role绑定到了在`foo`命名空间中运行的pod的ServiceAccount，所以您现在可以从该pod内部列出Services。
- en: Listing 12.10\. Getting Services from the API server
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.10\. 从API服务器获取Services
- en: '`/ # curl localhost:8001/api/v1/namespaces/foo/services` `{   "kind": "ServiceList",
      "apiVersion": "v1",   "metadata": {     "selfLink": "/api/v1/namespaces/foo/services",
        "resourceVersion": "24906"   },   "items": []` `1` `}`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`/ # curl localhost:8001/api/v1/namespaces/foo/services`'
- en: 1 The list of items is empty, because no Services exist.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 项目列表为空，因为没有Services存在。
- en: Including ServiceAccounts from other namespaces in a RoleBinding
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在RoleBinding中包含来自其他命名空间的ServiceAccounts
- en: 'The pod in namespace `bar` can’t list the Services in its own namespace, and
    obviously also not those in the `foo` namespace. But you can edit your RoleBinding
    in the `foo` namespace and add the other pod’s ServiceAccount, even though it’s
    in a different namespace. Run the following command:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间`bar`中的pod无法列出其自身的Services，显然也无法列出`foo`命名空间中的Services。但您可以在`foo`命名空间中编辑您的RoleBinding并添加另一个pod的ServiceAccount，即使它位于不同的命名空间中。运行以下命令：
- en: '`$ kubectl edit rolebinding test -n foo`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl edit rolebinding test -n foo`'
- en: Then add the following lines to the list of `subjects`, as shown in the following
    listing.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将以下行添加到`subjects`列表中，如下所示。
- en: Listing 12.11\. Referencing a ServiceAccount from another namespace
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.11\. 从另一个命名空间引用ServiceAccount
- en: '`subjects: - kind: ServiceAccount   name: default` `1` `namespace: bar` `1`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`subjects: - kind: ServiceAccount name: default`'
- en: 1 You’re referencing the default ServiceAccount in the bar namespace.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 您正在引用bar命名空间中的默认ServiceAccount。
- en: Now you can also list Services in the `foo` namespace from inside the pod running
    in the `bar` namespace. Run the same command as in [listing 12.10](#filepos1189299),
    but do it in the other terminal, where you’re running the shell in the other pod.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您也可以从运行在bar命名空间中的pod内列出`foo`命名空间中的Services。运行与[列表12.10](#filepos1189299)中相同的命令，但在另一个终端中运行，在那里您在另一个pod中运行shell。
- en: Before moving on to ClusterRoles and ClusterRoleBindings, let’s summarize what
    RBAC resources you currently have. You have a RoleBinding in namespace `foo`,
    which references the `service-reader` Role (also in the `foo` namespace) and binds
    the `default` ServiceAccounts in both the `foo` and the `bar` namespaces, as depicted
    in [figure 12.6](#filepos1191996).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续到ClusterRoles和ClusterRoleBindings之前，让我们总结一下您目前拥有的RBAC资源。您在`foo`命名空间中有一个RoleBinding，它引用了`service-reader`
    Role（也在`foo`命名空间中），并将`foo`和`bar`命名空间中的`default` ServiceAccounts绑定，如图12.6所示。
- en: Figure 12.6\. A RoleBinding binding ServiceAccounts from different namespaces
    to the same Role.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6\. 将不同命名空间中的ServiceAccounts绑定到同一Role。
- en: '![](images/00094.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00094.jpg)'
- en: 12.2.4\. Using ClusterRoles and ClusterRoleBindings
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 12.2.4\. 使用ClusterRoles和ClusterRoleBindings
- en: Roles and RoleBindings are namespaced resources, meaning they reside in and
    apply to resources in a single namespace, but, as we saw, RoleBindings can refer
    to Service-Accounts from other namespaces, too.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Roles和RoleBindings是命名空间资源，这意味着它们位于并应用于单个命名空间中的资源，但，正如我们所见，RoleBindings也可以引用其他命名空间中的Service-Accounts。
- en: 'In addition to these namespaced resources, two cluster-level RBAC resources
    also exist: ClusterRole and ClusterRoleBinding. They’re not namespaced. Let’s
    see why you need them.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些命名空间资源外，还存在两个集群级别的RBAC资源：集群角色和集群角色绑定。它们不是命名空间化的。让我们看看为什么你需要它们。
- en: A regular Role only allows access to resources in the same namespace the Role
    is in. If you want to allow someone access to resources across different namespaces,
    you have to create a Role and RoleBinding in every one of those namespaces. If
    you want to extend this to all namespaces (this is something a cluster administrator
    would probably need), you need to create the same Role and RoleBinding in each
    namespace. When creating an additional namespace, you have to remember to create
    the two resources there as well.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 常规角色仅允许访问与角色所在同一命名空间中的资源。如果您想允许某人访问不同命名空间中的资源，您必须在每个命名空间中创建一个角色和角色绑定。如果您想扩展到所有命名空间（这可能是一个集群管理员可能需要的），您需要在每个命名空间中创建相同的角色和角色绑定。在创建附加命名空间时，您必须记得在那里创建这两个资源。
- en: As you’ve learned throughout the book, certain resources aren’t namespaced at
    all (this includes Nodes, PersistentVolumes, Namespaces, and so on). We’ve also
    mentioned the API server exposes some URL paths that don’t represent resources
    (`/healthz` for example). Regular Roles can’t grant access to those resources
    or non-resource URLs, but ClusterRoles can.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在本书中学到的，某些资源根本不是命名空间化的（这包括节点、持久卷、命名空间等）。我们还提到API服务器公开了一些不表示资源的URL路径（例如`/healthz`）。常规角色无法授予对这些资源或非资源URL的访问权限，但集群角色可以。
- en: A ClusterRole is a cluster-level resource for allowing access to non-namespaced
    resources or non-resource URLs or used as a common role to be bound inside individual
    namespaces, saving you from having to redefine the same role in each of them.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 集群角色是一个集群级别的资源，用于允许访问非命名空间资源或非资源URL，或用作在单个命名空间内绑定的通用角色，从而节省您在每个命名空间中重新定义相同角色的麻烦。
- en: Allowing access to cluster-level resources
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 允许访问集群级别资源
- en: 'As mentioned, a ClusterRole can be used to allow access to cluster-level resources.
    Let’s look at how to allow your pod to list PersistentVolumes in your cluster.
    First, you’ll create a ClusterRole called `pv-reader`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，集群角色可以用来允许访问集群级别的资源。让我们看看如何允许您的Pod在您的集群中列出持久卷。首先，您将创建一个名为`pv-reader`的集群角色：
- en: '`$ kubectl create clusterrole pv-reader --verb=get,list`![](images/00006.jpg)`--resource=persistentvolumes`
    `clusterrole "pv-reader" created`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create clusterrole pv-reader --verb=get,list`![](images/00006.jpg)`--resource=persistentvolumes`
    `集群角色 "pv-reader" 已创建`'
- en: The ClusterRole’s YAML is shown in the following listing.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 集群角色的YAML配置如下所示。
- en: Listing 12.12\. A ClusterRole definition
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.12\. 集群角色定义
- en: '`$ kubectl get clusterrole pv-reader -o yaml` `apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole metadata:` `1` `name: pv-reader` `1` `resourceVersion: "39932"`
    `1` `selfLink: ...` `1` `uid: e9ac1099-30e2-11e7-955c-080027e6b159` `1` `rules:
    - apiGroups:` `2` `- ""` `2` `resources:` `2` `- persistentvolumes` `2` `verbs:`
    `2` `- get` `2` `- list` `2`'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get clusterrole pv-reader -o yaml` `apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole metadata:` `1` `name: pv-reader` `1` `resourceVersion: "39932"`
    `1` `selfLink: ...` `1` `uid: e9ac1099-30e2-11e7-955c-080027e6b159` `1` `rules:
    - apiGroups:` `2` `- ""` `2` `resources:` `2` `- persistentvolumes` `2` `verbs:`
    `2` `- get` `2` `- list` `2`'
- en: 1 ClusterRoles aren’t namespaced, hence no namespace field.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 集群角色不是命名空间化的，因此没有命名空间字段。
- en: 2 In this case, the rules are exactly like those in a regular Role.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 在这种情况下，规则与常规角色中的规则完全相同。
- en: 'Before you bind this ClusterRole to your pod’s ServiceAccount, verify whether
    the pod can list PersistentVolumes. Run the following command in the first terminal,
    where you’re running the shell inside the pod in the `foo` namespace:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在将此集群角色绑定到您的Pod的ServiceAccount之前，请验证Pod是否可以列出持久卷。在第一个终端中运行以下命令，其中您在`foo`命名空间内运行Pod内部的shell：
- en: '`/ # curl localhost:8001/api/v1/persistentvolumes` `User "system:serviceaccount:foo:default"
    cannot list persistentvolumes at the cluster scope.`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`/ # curl localhost:8001/api/v1/persistentvolumes` `用户 "system:serviceaccount:foo:default"
    无法在集群范围内列出持久卷。`'
- en: '|  |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The URL contains no namespace, because PersistentVolumes aren’t namespaced.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: URL中不包含命名空间，因为持久卷不是命名空间化的。
- en: '|  |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'As expected, the default ServiceAccount can’t list PersistentVolumes. You need
    to bind the ClusterRole to your ServiceAccount to allow it to do that. ClusterRoles
    can be bound to subjects with regular RoleBindings, so you’ll create a RoleBinding
    now:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，默认 ServiceAccount 无法列出 PersistentVolumes。你需要将 ClusterRole 绑定到你的 ServiceAccount
    以允许它执行此操作。ClusterRoles 可以通过常规 RoleBindings 绑定到主题，因此你现在将创建一个 RoleBinding：
- en: '`$ kubectl create rolebinding pv-test --clusterrole=pv-reader`![](images/00006.jpg)`--serviceaccount=foo:default
    -n foo` `rolebinding "pv-test" created`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create rolebinding pv-test --clusterrole=pv-reader`![](images/00006.jpg)`--serviceaccount=foo:default
    -n foo` `rolebinding "pv-test" created`'
- en: Can you list PersistentVolumes now?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以列出 PersistentVolumes 吗？
- en: '`/` `# curl localhost:8001/api/v1/persistentvolumes` `User "system:serviceaccount:foo:default"
    cannot list persistentvolumes at the cluster scope.`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`/` `# curl localhost:8001/api/v1/persistentvolumes` `User "system:serviceaccount:foo:default"
    cannot list persistentvolumes at the cluster scope.`'
- en: Hmm, that’s strange. Let’s examine the RoleBinding’s YAML in the following listing.
    Can you tell what (if anything) is wrong with it?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这很奇怪。让我们检查以下列表中 RoleBinding 的 YAML。你能说出它（如果有的话）有什么问题吗？
- en: Listing 12.13\. A RoleBinding referencing a ClusterRole
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.13\. 引用 ClusterRole 的 RoleBinding
- en: '`$ kubectl get rolebindings pv-test -o yaml` `apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding metadata:   name: pv-test   namespace: foo   ... roleRef:  
    apiGroup: rbac.authorization.k8s.io   kind: ClusterRole` `1` `name: pv-reader`
    `1` `subjects: - kind: ServiceAccount` `2` `name: default` `2` `namespace: foo`
    `2`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get rolebindings pv-test -o yaml` `apiVersion: rbac.authorization.k8s.io/v1
    kind: RoleBinding metadata:   name: pv-test   namespace: foo   ... roleRef:  
    apiGroup: rbac.authorization.k8s.io   kind: ClusterRole` `1` `name: pv-reader`
    `1` `subjects: - kind: ServiceAccount` `2` `name: default` `2` `namespace: foo`
    `2`'
- en: 1 The binding references the pv-reader ClusterRole.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 绑定引用了 pv-reader ClusterRole。
- en: 2 The bound subject is the default ServiceAccount in the foo namespace.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 绑定的主题是 foo 命名空间中的默认 ServiceAccount。
- en: The YAML looks perfectly fine. You’re referencing the correct ClusterRole and
    the correct ServiceAccount, as shown in [figure 12.7](#filepos1200207), so what’s
    wrong?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 看起来完全正常。你引用了正确的 ClusterRole 和正确的 ServiceAccount，如[图 12.7](#filepos1200207)所示，那么问题出在哪里？
- en: Figure 12.7\. A RoleBinding referencing a ClusterRole doesn’t grant access to
    clusterlevel resources.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7\. 引用 ClusterRole 的 RoleBinding 不授予对集群级别资源的访问权限。
- en: '![](images/00111.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00111.jpg)'
- en: Although you can create a RoleBinding and have it reference a ClusterRole when
    you want to enable access to namespaced resources, you can’t use the same approach
    for cluster-level (non-namespaced) resources. To grant access to cluster-level
    resources, you must always use a ClusterRoleBinding.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在想要启用对命名空间资源访问时创建 RoleBinding 并使其引用 ClusterRole，但你不能对集群级别（非命名空间）资源使用相同的方法。要授予对集群级别资源的访问权限，你必须始终使用
    ClusterRoleBinding。
- en: 'Luckily, creating a ClusterRoleBinding isn’t that different from creating a
    Role-Binding, but you’ll clean up and delete the RoleBinding first:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，创建 ClusterRoleBinding 并不像创建 Role-Binding 那样不同，但你需要先清理并删除 RoleBinding：
- en: '`$ kubectl delete rolebinding pv-test` `rolebinding "pv-test" deleted`'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl delete rolebinding pv-test` `rolebinding "pv-test" deleted`'
- en: 'Now create the ClusterRoleBinding:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建 ClusterRoleBinding：
- en: '`$ kubectl create clusterrolebinding pv-test --clusterrole=pv-reader`![](images/00006.jpg)`--serviceaccount=foo:default`
    `clusterrolebinding "pv-test" created`'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create clusterrolebinding pv-test --clusterrole=pv-reader`![](images/00006.jpg)`--serviceaccount=foo:default`
    `clusterrolebinding "pv-test" created`'
- en: As you can see, you replaced `rolebinding` with `clusterrolebinding` in the
    command and didn’t (need to) specify the namespace. [Figure 12.8](#filepos1201733)
    shows what you have now.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你在命令中将 `rolebinding` 替换为 `clusterrolebinding`，并且没有（需要）指定命名空间。[图 12.8](#filepos1201733)显示了你现在的情况。
- en: Figure 12.8\. A ClusterRoleBinding and ClusterRole must be used to grant access
    to cluster-level resources.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8\. 使用 ClusterRoleBinding 和 ClusterRole 授予对集群级别资源的访问权限。
- en: '![](images/00131.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00131.jpg)'
- en: 'Let’s see if you can list PersistentVolumes now:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看你是否可以列出 PersistentVolumes：
- en: '`/ # curl localhost:8001/api/v1/persistentvolumes` `{   "kind": "PersistentVolumeList",
      "apiVersion": "v1", ...`'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`/ # curl localhost:8001/api/v1/persistentvolumes` `{   "kind": "PersistentVolumeList",
      "apiVersion": "v1", ...`'
- en: You can! It turns out you must use a ClusterRole and a ClusterRoleBinding when
    granting access to cluster-level resources.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以！实际上，在授予对集群级别资源的访问权限时，你必须使用 ClusterRole 和 ClusterRoleBinding。
- en: '|  |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that a RoleBinding can’t grant access to cluster-level resources, even
    if it references a ClusterRoleBinding.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，即使 RoleBinding 引用了 ClusterRoleBinding，它也无法授予对集群级别资源的访问权限。
- en: '|  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Allowing access to non-resource URLs
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 允许访问非资源 URL
- en: We’ve mentioned that the API server also exposes non-resource URLs. Access to
    these URLs must also be granted explicitly; otherwise the API server will reject
    the client’s request. Usually, this is done for you automatically through the
    `system:discovery` ClusterRole and the identically named ClusterRoleBinding, which
    appear among other predefined ClusterRoles and ClusterRoleBindings (we’ll explore
    them in [section 12.2.5](#filepos1220059)).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到 API 服务器也公开了非资源 URL。对这些 URL 的访问必须明确授权；否则，API 服务器将拒绝客户端的请求。通常，这会通过 `system:discovery`
    ClusterRole 和同名 ClusterRoleBinding 自动完成，它们出现在其他预定义的 ClusterRoles 和 ClusterRoleBindings
    中（我们将在 [第 12.2.5 节](#filepos1220059) 中探讨它们）。
- en: Let’s inspect the `system:discovery` ClusterRole shown in the following listing.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下列表中显示的 `system:discovery` ClusterRole。
- en: Listing 12.14\. The default `system:discovery ClusterRole`
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.14\. 默认的 `system:discovery ClusterRole`
- en: '`$ kubectl get clusterrole system:discovery -o yaml` `apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole metadata:   name: system:discovery   ... rules: - nonResourceURLs:`
    `1` `- /api` `1` `- /api/*` `1` `- /apis` `1` `- /apis/*` `1` `- /healthz` `1`
    `- /swaggerapi` `1` `- /swaggerapi/*` `1` `- /version` `1` `verbs:` `2` `- get`
    `2`'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get clusterrole system:discovery -o yaml` `apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole metadata:   name: system:discovery   ... rules: - nonResourceURLs:`
    `1` `- /api` `1` `- /api/*` `1` `- /apis` `1` `- /apis/*` `1` `- /healthz` `1`
    `- /swaggerapi` `1` `- /swaggerapi/*` `1` `- /version` `1` `verbs:` `2` `- get`
    `2`'
- en: 1 Instead of referring to resources, this rule refers to non-resource URLs.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 与引用资源不同，此规则引用非资源 URL。
- en: 2 Only the HTTP GET method is allowed for these URLs.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅允许对这些 URL 使用 HTTP GET 方法。
- en: You can see this ClusterRole refers to URLs instead of resources (field `nonResource-URLs`
    is used instead of the `resources` field). The `verbs` field only allows the `GET`
    HTTP method to be used on these URLs.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到此 ClusterRole 指向 URL 而不是资源（使用 `nonResource-URLs` 字段而不是 `resources` 字段）。`verbs`
    字段仅允许在这些 URL 上使用 `GET` HTTP 方法。
- en: '|  |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For non-resource URLs, plain HTTP verbs such as `post`, `put`, and `patch` are
    used instead of `create` or `update`. The verbs need to be specified in lowercase.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非资源 URL，使用 `post`、`put` 和 `patch` 等纯 HTTP 动词，而不是 `create` 或 `update`。动词需要小写指定。
- en: '|  |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As with cluster-level resources, ClusterRoles for non-resource URLs must be
    bound with a ClusterRoleBinding. Binding them with a RoleBinding won’t have any
    effect. The `system:discovery` ClusterRole has a corresponding system:discovery
    Cluster-RoleBinding, so let’s see what’s in it by examining the following listing.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 与集群级别的资源一样，非资源 URL 的 ClusterRole 必须与 ClusterRoleBinding 绑定。使用 RoleBinding 绑定它们将没有任何效果。`system:discovery`
    ClusterRole 有对应的 `system:discovery Cluster-RoleBinding`，因此让我们通过以下列表检查其内容。
- en: Listing 12.15\. The default `system:discovery` ClusterRoleBinding
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.15\. 默认的 `system:discovery` ClusterRoleBinding
- en: '`$ kubectl get clusterrolebinding system:discovery -o yaml` `apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding metadata:   name: system:discovery   ... roleRef:   apiGroup:
    rbac.authorization.k8s.io   kind: ClusterRole` `1` `name: system:discovery` `1`
    `subjects: - apiGroup: rbac.authorization.k8s.io   kind: Group` `2` `name: system:authenticated`
    `2` `- apiGroup: rbac.authorization.k8s.io   kind: Group` `2` `name: system:unauthenticated`
    `2`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get clusterrolebinding system:discovery -o yaml` `apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding metadata:   name: system:discovery   ... roleRef:   apiGroup:
    rbac.authorization.k8s.io   kind: ClusterRole` `1` `name: system:discovery` `1`
    `subjects: - apiGroup: rbac.authorization.k8s.io   kind: Group` `2` `name: system:authenticated`
    `2` `- apiGroup: rbac.authorization.k8s.io   kind: Group` `2` `name: system:unauthenticated`
    `2`'
- en: 1 This ClusterRoleBinding references the system:discovery ClusterRole.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 此 ClusterRoleBinding 引用了 system:discovery ClusterRole。
- en: 2 It binds the ClusterRole to all authenticated and unauthenticated users (that
    is, everyone).
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 它将 ClusterRole 绑定到所有已认证和未认证的用户（即所有人）。
- en: The YAML shows the ClusterRoleBinding refers to the `system:discovery` ClusterRole,
    as expected. It’s bound to two groups, `system:authenticated` and `system:unauthenticated`,
    which makes it bound to all users. This means absolutely everyone can access the
    URLs listed in the ClusterRole.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 显示 ClusterRoleBinding 指向预期的 `system:discovery` ClusterRole。它绑定到两个组，`system:authenticated`
    和 `system:unauthenticated`，这使得它绑定到所有用户。这意味着绝对每个人都可以访问 ClusterRole 中列出的 URL。
- en: '|  |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Groups are in the domain of the authentication plugin. When a request is received
    by the API server, it calls the authentication plugin to obtain the list of groups
    the user belongs to. This information is then used in authorization.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 组属于身份验证插件的范围。当 API 服务器收到请求时，它会调用身份验证插件以获取用户所属的组列表。然后，这些信息用于授权。
- en: '|  |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You can confirm this by accessing the `/api` URL path from inside the pod (through
    the `kubectl proxy`, which means you’ll be authenticated as the pod’s ServiceAccount)
    and from your local machine, without specifying any authentication tokens (making
    you an unauthenticated user):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从Pod内部（通过`kubectl proxy`，这意味着你将以Pod的ServiceAccount身份进行认证）和从你的本地机器访问`/api`
    URL路径来确认这一点，而不需要指定任何认证令牌（使你成为一个未经认证的用户）：
- en: '`$ curl https://$(minikube ip):8443/api -k` `{   "kind": "APIVersions",   "versions":
    [   ...`'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ curl https://$(minikube ip):8443/api -k` `{ "kind": "APIVersions", "versions":
    [...]`'
- en: You’ve now used ClusterRoles and ClusterRoleBindings to grant access to cluster-level
    resources and non-resource URLs. Now let’s look at how ClusterRoles can be used
    with namespaced RoleBindings to grant access to namespaced resources in the Role-Binding’s
    namespace.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经使用了ClusterRole和ClusterRoleBinding来授予对集群级资源和非资源URL的访问权限。现在让我们看看ClusterRole如何与命名空间RoleBinding一起使用，以授予对Role-Binding命名空间中命名空间资源的访问权限。
- en: Using ClusterRoles to grant access to resources in specific namespaces
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ClusterRole授予特定命名空间中资源的访问权限
- en: ClusterRoles don’t always need to be bound with cluster-level ClusterRoleBindings.
    They can also be bound with regular, namespaced RoleBindings. You’ve already started
    looking at predefined ClusterRoles, so let’s look at another one called `view`,
    which is shown in the following listing.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ClusterRole不一定需要与集群级别的ClusterRoleBinding绑定。它们也可以与常规的命名空间RoleBinding绑定。你已经开始查看预定义的ClusterRole，那么让我们看看另一个名为`view`的ClusterRole，它将在下面的列表中展示。
- en: Listing 12.16\. The default `view` ClusterRole
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.16. 默认的`view` ClusterRole
- en: '`$ kubectl get clusterrole view -o yaml` `apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole metadata:   name: view   ... rules: - apiGroups:   - ""   resources:`
    `1` `- configmaps` `1` `- endpoints` `1` `- persistentvolumeclaims` `1` `- pods`
    `1` `- replicationcontrollers` `1` `- replicationcontrollers/scale` `1` `- serviceaccounts`
    `1` `- services` `1` `verbs:` `2` `- get` `2` `- list` `2` `- watch` `2` `...`'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get clusterrole view -o yaml` `apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRole metadata: name: view ... rules: - apiGroups: - "" resources:
    1 - configmaps 1 - endpoints 1 - persistentvolumeclaims 1 - pods 1 - replicationcontrollers
    1 - replicationcontrollers/scale 1 - serviceaccounts 1 - services 1 verbs: 2 -
    get 2 - list 2 - watch ...`'
- en: '1 This rule applies to these resources (note: they’re all namespaced resources).'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 此规则适用于这些资源（注意：它们都是命名空间资源）。
- en: 2 As the ClusterRole’s name suggests, it only allows reading, not writing the
    resources listed.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 如ClusterRole的名称所暗示的，它只允许读取，而不是写入列出的资源。
- en: This ClusterRole has many rules. Only the first one is shown in the listing.
    The rule allows getting, listing, and watching resources like ConfigMaps, Endpoints,
    Persistent-VolumeClaims, and so on. These are namespaced resources, even though
    you’re looking at a ClusterRole (not a regular, namespaced Role). What exactly
    does this Cluster-Role do?
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 此ClusterRole有许多规则。列表中只显示了第一个规则。该规则允许获取、列出和监视像ConfigMaps、Endpoints、Persistent-VolumeClaims等资源。尽管你正在查看ClusterRole（而不是常规的命名空间Role），但这些资源是命名空间资源。这个Cluster-Role究竟做了什么？
- en: It depends whether it’s bound with a ClusterRoleBinding or a RoleBinding (it
    can be bound with either). If you create a ClusterRoleBinding and reference the
    ClusterRole in it, the subjects listed in the binding can view the specified resources
    across all namespaces. If, on the other hand, you create a RoleBinding, the subjects
    listed in the binding can only view resources in the namespace of the RoleBinding.
    You’ll try both options now.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于它是否与ClusterRoleBinding或RoleBinding绑定（它可以与任一绑定）。如果你创建一个ClusterRoleBinding并在其中引用ClusterRole，则绑定中列出的主题可以查看所有命名空间中指定的资源。另一方面，如果你创建一个RoleBinding，则绑定中列出的主题只能查看RoleBinding命名空间中的资源。现在你将尝试这两种选项。
- en: 'You’ll see how the two options affect your test pod’s ability to list pods.
    First, let’s see what happens before any bindings are in place:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到这两种选项如何影响你的测试Pod列出Pod的能力。首先，让我们看看在没有任何绑定的情况下会发生什么：
- en: '`/ # curl localhost:8001/api/v1/pods` `User "system:serviceaccount:foo:default"
    cannot list pods at the cluster scope./ #` `/ # curl localhost:8001/api/v1/namespaces/foo/pods`
    `User "system:serviceaccount:foo:default" cannot list pods in the namespace "foo".`'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`/ # curl localhost:8001/api/v1/pods` `User "system:serviceaccount:foo:default"
    cannot list pods at the cluster scope./ #` `/ # curl localhost:8001/api/v1/namespaces/foo/pods`
    `User "system:serviceaccount:foo:default" cannot list pods in the namespace "foo".`'
- en: With the first command, you’re trying to list pods across all namespaces. With
    the second, you’re trying to list pods in the `foo` namespace. The server doesn’t
    allow you to do either.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第一个命令，你正在尝试列出所有命名空间中的Pod。使用第二个命令，你正在尝试列出`foo`命名空间中的Pod。服务器不允许你这样做。
- en: 'Now, let’s see what happens when you create a ClusterRoleBinding and bind it
    to the pod’s ServiceAccount:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当你创建一个ClusterRoleBinding并将其绑定到Pod的ServiceAccount时会发生什么：
- en: '`$ kubectl create clusterrolebinding view-test --clusterrole=view`![](images/00006.jpg)`--serviceaccount=foo:default`
    `clusterrolebinding "view-test" created`'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create clusterrolebinding view-test --clusterrole=view`![图片](images/00006.jpg)`--serviceaccount=foo:default`
    `clusterrolebinding "view-test" created`'
- en: Can the pod now list pods in the `foo` namespace?
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Pod可以列出`foo`命名空间中的Pod吗？
- en: '`/ # curl localhost:8001/api/v1/namespaces/foo/pods` `{   "kind": "PodList",
      "apiVersion": "v1",   ...`'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`/ # curl localhost:8001/api/v1/namespaces/foo/pods` `{   "kind": "PodList",
      "apiVersion": "v1",   ...`'
- en: 'It can! Because you created a ClusterRoleBinding, it applies across all namespaces.
    The pod in namespace `foo` can list pods in the `bar` namespace as well:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 可以！因为您创建了一个ClusterRoleBinding，它适用于所有命名空间。在`foo`命名空间中的Pod也可以列出`bar`命名空间中的Pod：
- en: '`/ # curl localhost:8001/api/v1/namespaces/bar/pods` `{   "kind": "PodList",
      "apiVersion": "v1",   ...`'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`/ # curl localhost:8001/api/v1/namespaces/bar/pods` `{   "kind": "PodList",
      "apiVersion": "v1",   ...`'
- en: 'Okay, the pod is allowed to list pods in a different namespace. It can also
    retrieve pods across all namespaces by hitting the /api/v1/pods URL path:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，Pod被允许列出不同命名空间中的Pod。它也可以通过访问/api/v1/pods URL路径来检索所有命名空间中的Pod：
- en: '`/ # curl localhost:8001/api/v1/pods` `{   "kind": "PodList",   "apiVersion":
    "v1",   ...`'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`/ # curl localhost:8001/api/v1/pods` `{   "kind": "PodList",   "apiVersion":
    "v1",   ...`'
- en: As expected, the pod can get a list of all the pods in the cluster. To summarize,
    combining a ClusterRoleBinding with a ClusterRole referring to namespaced resources
    allows the pod to access namespaced resources in any namespace, as shown in [figure
    12.9](#filepos1215606).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，该Pod可以获取集群中所有Pod的列表。总结来说，将ClusterRoleBinding与引用命名空间资源的ClusterRole结合使用，允许Pod访问任何命名空间中的命名空间资源，如图12.9所示。[链接](#filepos1215606)。
- en: Figure 12.9\. A ClusterRoleBinding and ClusterRole grants permission to resources
    across all namespaces.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9。ClusterRoleBinding和ClusterRole授予跨所有命名空间的资源权限。
- en: '![](images/00148.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/00148.jpg)'
- en: 'Now, let’s see what happens if you replace the ClusterRoleBinding with a RoleBinding.
    First, delete the ClusterRoleBinding:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果你用RoleBinding替换ClusterRoleBinding会发生什么。首先，删除ClusterRoleBinding：
- en: '`$ kubectl delete clusterrolebinding view-test` `clusterrolebinding "view-test"
    deleted`'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl delete clusterrolebinding view-test` `clusterrolebinding "view-test"
    deleted`'
- en: 'Next create a RoleBinding instead. Because a RoleBinding is namespaced, you
    need to specify the namespace you want to create it in. Create it in the `foo`
    namespace:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来创建一个RoleBinding。因为RoleBinding是命名空间级别的，你需要指定你想要在其中创建它的命名空间。在`foo`命名空间中创建它：
- en: '`$ kubectl create rolebinding view-test --clusterrole=view`![](images/00006.jpg)`--serviceaccount=foo:default
    -n foo` `rolebinding "view-test" created`'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl create rolebinding view-test --clusterrole=view`![图片](images/00006.jpg)`--serviceaccount=foo:default
    -n foo` `rolebinding "view-test" created`'
- en: You now have a RoleBinding in the `foo` namespace, binding the `default` Service-Account
    in that same namespace with the `view` ClusterRole. What can your pod access now?
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你在`foo`命名空间中有一个RoleBinding，将同一命名空间中的`default` Service-Account与`view` ClusterRole绑定在一起。你的Pod现在可以访问什么？
- en: '`/ # curl localhost:8001/api/v1/namespaces/foo/pods` `{   "kind": "PodList",
      "apiVersion": "v1",   ...` `/ # curl localhost:8001/api/v1/namespaces/bar/pods`
    `User "system:serviceaccount:foo:default" cannot list pods in the namespace "bar".`
    `/ # curl localhost:8001/api/v1/pods` `User "system:serviceaccount:foo:default"
    cannot list pods at the cluster scope.`'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`/ # curl localhost:8001/api/v1/namespaces/foo/pods` `{   "kind": "PodList",
      "apiVersion": "v1",   ...` `/ # curl localhost:8001/api/v1/namespaces/bar/pods`
    `用户 "system:serviceaccount:foo:default" 无法在命名空间 "bar" 中列出Pod。` `/ # curl localhost:8001/api/v1/pods`
    `用户 "system:serviceaccount:foo:default" 无法在集群范围内列出Pod。`'
- en: As you can see, your pod can list pods in the `foo` namespace, but not in any
    other specific namespace or across all namespaces. This is visualized in [figure
    12.10](#filepos1217688).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您的Pod可以列出`foo`命名空间中的Pod，但不能列出任何其他特定命名空间或所有命名空间中的Pod。这如图12.10所示。[链接](#filepos1217688)。
- en: Figure 12.10\. A RoleBinding referring to a ClusterRole only grants access to
    resources inside the RoleBinding’s namespace.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10。仅授予RoleBinding命名空间内资源的访问权限的ClusterRole引用。
- en: '![](images/00166.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/00166.jpg)'
- en: Summarizing Role, ClusterRole, RoleBinding, and ClusterRoleBinding combinations
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 总结Role、ClusterRole、RoleBinding和ClusterRoleBinding组合
- en: We’ve covered many different combinations and it may be hard for you to remember
    when to use each one. Let’s see if we can make sense of all these combinations
    by categorizing them per specific use case. Refer to [table 12.2](#filepos1218411).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了许多不同的组合，可能对您来说记住何时使用每个组合可能会有点困难。让我们看看我们是否可以通过按特定用例对它们进行分类来理解所有这些组合。请参阅[表12.2](#filepos1218411)。
- en: Table 12.2\. When to use specific combinations of role and binding types
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.2. 使用特定角色和绑定类型组合的时机
- en: '| For accessing | Role type to use | Binding type to use |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 用于访问 | 要使用的角色类型 | 要使用的绑定类型 |'
- en: '| Cluster-level resources (Nodes, PersistentVolumes, ...) | ClusterRole | ClusterRoleBinding
    |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 集群级别的资源（节点、持久卷、...） | ClusterRole | ClusterRoleBinding |'
- en: '| Non-resource URLs (/api, /healthz, ...) | ClusterRole | ClusterRoleBinding
    |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 非资源URL（/api, /healthz, ...） | ClusterRole | ClusterRoleBinding |'
- en: '| Namespaced resources in any namespace (and across all namespaces) | ClusterRole
    | ClusterRoleBinding |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 任何命名空间中的命名空间资源（以及所有命名空间） | ClusterRole | ClusterRoleBinding |'
- en: '| Namespaced resources in a specific namespace (reusing the same ClusterRole
    in multiple namespaces) | ClusterRole | RoleBinding |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 特定命名空间中的命名空间资源（在多个命名空间中重复使用相同的ClusterRole） | ClusterRole | RoleBinding |'
- en: '| Namespaced resources in a specific namespace (Role must be defined in each
    namespace) | Role | RoleBinding |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 特定命名空间中的命名空间资源（角色必须在每个命名空间中定义） | Role | RoleBinding |'
- en: Hopefully, the relationships between the four RBAC resources are much clearer
    now. Don’t worry if you still feel like you don’t yet grasp everything. Things
    may clear up as we explore the pre-configured ClusterRoles and ClusterRoleBindings
    in the next section.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 希望现在您对四个RBAC资源之间的关系有了更清晰的认识。如果您仍然觉得您还没有完全掌握所有内容，请不要担心。随着我们探索下一节中预配置的ClusterRoles和ClusterRoleBindings，事情可能会变得明朗起来。
- en: 12.2.5\. Understanding default ClusterRoles and ClusterRoleBindings
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 12.2.5. 理解默认的ClusterRoles和ClusterRoleBindings
- en: Kubernetes comes with a default set of ClusterRoles and ClusterRoleBindings,
    which are updated every time the API server starts. This ensures all the default
    roles and bindings are recreated if you mistakenly delete them or if a newer version
    of Kubernetes uses a different configuration of cluster roles and bindings.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes附带一组默认的ClusterRoles和ClusterRoleBindings，每次API服务器启动时都会更新。这确保了如果您不小心删除了它们，或者如果Kubernetes的新版本使用了不同的集群角色和绑定配置，所有默认的角色和绑定都会被重新创建。
- en: You can see the default cluster roles and bindings in the following listing.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下列表中查看默认的集群角色和绑定。
- en: Listing 12.17\. Listing all ClusterRoleBinding`s` and ClusterRole`s`
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.17. 列出所有ClusterRoleBinding`s`和ClusterRole`s`
- en: '`$ kubectl get clusterrolebindings` `NAME                                          
    AGE cluster-admin                                  1d system:basic-user                             
    1d system:controller:attachdetach-controller      1d ... system:controller:ttl-controller              
    1d system:discovery                               1d system:kube-controller-manager                
    1d system:kube-dns                                1d system:kube-scheduler                         
    1d system:node                                    1d system:node-proxier                           
    1d` `$ kubectl get clusterroles` `NAME                                          
    AGE admin                                          1d cluster-admin                                 
    1d edit                                           1d system:auth-delegator                         
    1d system:basic-user                              1d system:controller:attachdetach-controller     
    1d ... system:controller:ttl-controller               1d system:discovery                              
    1d system:heapster                                1d system:kube-aggregator                        
    1d system:kube-controller-manager                 1d system:kube-dns                               
    1d system:kube-scheduler                          1d system:node                                   
    1d system:node-bootstrapper                       1d system:node-problem-detector                  
    1d system:node-proxier                            1d system:persistent-volume-provisioner          
    1d view                                           1d`'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get clusterrolebindings` `NAME                                          
    AGE cluster-admin                                  1d system:basic-user                             
    1d system:controller:attachdetach-controller      1d ... system:controller:ttl-controller              
    1d system:discovery                               1d system:kube-controller-manager                
    1d system:kube-dns                                1d system:kube-scheduler                         
    1d system:node                                    1d system:node-proxier                           
    1d` `$ kubectl get clusterroles` `NAME                                          
    AGE admin                                          1d cluster-admin                                 
    1d edit                                           1d system:auth-delegator                         
    1d system:basic-user                              1d system:controller:attachdetach-controller     
    1d ... system:controller:ttl-controller               1d system:discovery                              
    1d system:heapster                                1d system:kube-aggregator                        
    1d system:kube-controller-manager                 1d system:kube-dns                               
    1d system:kube-scheduler                          1d system:node                                   
    1d system:node-bootstrapper                       1d system:node-problem-detector                  
    1d system:node-proxier                            1d system:persistent-volume-provisioner          
    1d view                                           1d`'
- en: The most important roles are the `view`, `edit`, `admin`, and `cluster-admin`
    ClusterRoles. They’re meant to be bound to ServiceAccounts used by user-defined
    pods.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的角色是`view`、`edit`、`admin`和`cluster-admin` ClusterRoles。它们旨在绑定到用户定义的Pod使用的ServiceAccounts。
- en: Allowing read-only access to resources with the view ClusterRole
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 允许对具有视图ClusterRole的资源进行只读访问
- en: You already used the default `view` ClusterRole in the previous example. It
    allows reading most resources in a namespace, except for Roles, RoleBindings,
    and Secrets. You’re probably wondering, why not Secrets? Because one of those
    Secrets might include an authentication token with greater privileges than those
    defined in the `view` ClusterRole and could allow the user to masquerade as a
    different user to gain additional privileges (privilege escalation).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您已经使用了默认的`view` ClusterRole。它允许读取命名空间中的大多数资源，除了Roles、RoleBindings和Secrets。您可能想知道，为什么不包括Secrets？因为那些Secrets中可能包含一个比`view`
    ClusterRole中定义的权限更大的认证令牌，这可能会允许用户伪装成不同的用户以获得额外的权限（权限提升）。
- en: Allowing modifying resources with the edit ClusterRole
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 使用edit ClusterRole修改资源
- en: Next is the `edit` ClusterRole, which allows you to modify resources in a namespace,
    but also allows both reading and modifying Secrets. It doesn’t, however, allow
    viewing or modifying Roles or RoleBindings—again, this is to prevent privilege
    escalation.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`edit` ClusterRole，它允许您修改命名空间中的资源，同时也允许读取和修改Secrets。然而，它不允许查看或修改Roles或RoleBindings——这同样是出于防止权限提升的目的。
- en: Granting full control of a namespace with the admin ClusterRole
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管理员ClusterRole授予命名空间的全权控制
- en: Complete control of the resources in a namespace is granted in the `admin` ClusterRole.
    Subjects with this ClusterRole can read and modify any resource in the namespace,
    except ResourceQuotas (we’ll learn what those are in [chapter 14](index_split_105.html#filepos1325290))
    and the Namespace resource itself. The main difference between the `edit` and
    the `admin` Cluster-Roles is in the ability to view and modify Roles and RoleBindings
    in the namespace.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `admin` ClusterRole 中授予命名空间中资源的完全控制权。具有此 ClusterRole 的主题可以读取和修改命名空间中的任何资源，除了
    ResourceQuotas（我们将在第 14 章[章节 14](index_split_105.html#filepos1325290)中学习这些内容）和命名空间资源本身。`edit`
    和 `admin` Cluster-Roles 之间的主要区别在于查看和修改命名空间中的角色和 RoleBindings 的能力。
- en: '|  |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To prevent privilege escalation, the API server only allows users to create
    and update Roles if they already have all the permissions listed in that Role
    (and for the same scope).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止权限提升，API 服务器只允许用户在已经拥有该角色中列出的所有权限（以及相同的范围）的情况下创建和更新角色。
- en: '|  |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Allowing complete control with the cluster-admin ClusterRole
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 cluster-admin ClusterRole 允许完全控制
- en: Complete control of the Kubernetes cluster can be given by assigning the `cluster-admin`
    ClusterRole to a subject. As you’ve seen before, the `admin` ClusterRole doesn’t
    allow users to modify the namespace’s ResourceQuota objects or the Namespace resource
    itself. If you want to allow a user to do that, you need to create a Role-Binding
    that references the `cluster-admin` ClusterRole. This gives the user included
    in the RoleBinding complete control over all aspects of the namespace in which
    the Role-Binding is created.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将 `cluster-admin` ClusterRole 分配给主题来授予对 Kubernetes 集群的完全控制权。正如你之前看到的，`admin`
    ClusterRole 不允许用户修改命名空间的 ResourceQuota 对象或命名空间资源本身。如果你想允许用户这样做，你需要创建一个引用 `cluster-admin`
    ClusterRole 的 Role-Binding。这会给 RoleBinding 中包含的用户在创建 RoleBinding 的命名空间中的所有方面提供完全控制权。
- en: If you’ve paid attention, you probably already know how to give users complete
    control of all the namespaces in the cluster. Yes, by referencing the `cluster-admin`
    ClusterRole in a ClusterRoleBinding instead of a RoleBinding.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了，你可能已经知道如何让用户完全控制集群中的所有命名空间。是的，通过在 ClusterRoleBinding 中引用 `cluster-admin`
    ClusterRole 而不是 RoleBinding 来实现。
- en: Understanding the other default ClusterRoles
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 理解其他默认 ClusterRoles
- en: The list of default ClusterRoles includes a large number of other ClusterRoles,
    which start with the `system:` prefix. These are meant to be used by the various
    Kubernetes components. Among them, you’ll find roles such as `system:kube-scheduler`,
    which is obviously used by the Scheduler, `system:node`, which is used by the
    Kubelets, and so on.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 ClusterRoles 列表中包含大量以 `system:` 前缀开头的其他 ClusterRoles，这些 ClusterRoles 旨在被各种
    Kubernetes 组件使用。其中，你可以找到诸如 `system:kube-scheduler` 这样的角色，显然它被调度器使用，`system:node`
    被 kubelets 使用，等等。
- en: 'Although the Controller Manager runs as a single pod, each controller running
    inside it can use a separate ClusterRole and ClusterRoleBinding (they’re prefixed
    with `system: controller:`).'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管控制器管理器作为一个单独的 pod 运行，但其中运行的每个控制器都可以使用单独的 ClusterRole 和 ClusterRoleBinding（它们以
    `system: controller:` 前缀开头）。'
- en: Each of these system ClusterRoles has a matching ClusterRoleBinding, which binds
    it to the user the system component authenticates as. The `system:kube-scheduler`
    ClusterRoleBinding, for example, assigns the identically named ClusterRole to
    the `system:kube-scheduler` user, which is the username the scheduler Authenticates
    as.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统 ClusterRoles 每个都有一个匹配的 ClusterRoleBinding，它将其绑定到系统组件认证的用户。例如，`system:kube-scheduler`
    ClusterRoleBinding 将同名 ClusterRole 分配给 `system:kube-scheduler` 用户，这是调度器认证时使用的用户名。
- en: 12.2.6\. Granting authorization permissions wisely
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 12.2.6\. 聪明地授予授权权限
- en: By default, the default ServiceAccount in a namespace has no permissions other
    than those of an unauthenticated user (as you may remember from one of the previous
    examples, the `system:discovery` ClusterRole and associated binding allow anyone
    to make GET requests on a few non-resource URLs). Therefore, pods, by default,
    can’t even view cluster state. It’s up to you to grant them appropriate permissions
    to do that.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，命名空间中的默认 ServiceAccount 除了未认证用户的权限外没有其他权限（正如你可能从之前的示例中记得的，`system:discovery`
    ClusterRole 和相关绑定允许任何人对一些非资源 URL 进行 GET 请求）。因此，默认情况下，pods 甚至无法查看集群状态。这取决于你授予它们适当的权限来执行此操作。
- en: Obviously, giving all your ServiceAccounts the `cluster-admin` ClusterRole is
    a bad idea. As is always the case with security, it’s best to give everyone only
    the permissions they need to do their job and not a single permission more (principle
    of least privilege).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，将所有ServiceAccounts都赋予`cluster-admin` ClusterRole是一个糟糕的想法。正如在安全方面总是那样，最好只给每个人他们完成工作所需的权限，而不是更多的权限（最小权限原则）。
- en: Creating specific ServiceAccounts for each pod
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个Pod创建特定的ServiceAccounts。
- en: It’s a good idea to create a specific ServiceAccount for each pod (or a set
    of pod replicas) and then associate it with a tailor-made Role (or a ClusterRole)
    through a RoleBinding (not a ClusterRoleBinding, because that would give the pod
    access to resources in other namespaces, which is probably not what you want).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个Pod（或一组Pod副本）创建一个特定的ServiceAccount，然后通过RoleBinding（而不是ClusterRoleBinding）将其与定制的Role（或ClusterRole）关联起来是一个好主意，因为ClusterRoleBinding会给予Pod访问其他命名空间资源的权限，这可能不是你想要的）。
- en: If one of your pods (the application running within it) only needs to read pods,
    while the other also needs to modify them, then create two different ServiceAccounts
    and make those pods use them by specifying the `serviceAccountName` property in
    the pod spec, as you learned in the first part of this chapter. Don’t add all
    the necessary permissions required by both pods to the default ServiceAccount
    in the namespace.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的某个Pod（其中运行的应用程序）只需要读取Pod，而另一个Pod还需要修改它们，那么就创建两个不同的ServiceAccounts，并通过在Pod规范中指定`serviceAccountName`属性来让这些Pod使用它们，正如你在本章的第一部分所学。不要将两个Pod所需的所有必要权限都添加到命名空间中的默认ServiceAccount中。
- en: Expecting your apps to be compromised
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 预期你的应用程序会被入侵
- en: Your aim is to reduce the possibility of an intruder getting hold of your cluster.
    Today’s complex apps contain many vulnerabilities. You should expect unwanted
    persons to eventually get their hands on the ServiceAccount’s authentication token,
    so you should always constrain the ServiceAccount to prevent them from doing any
    real damage.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标是减少入侵者获取你的集群的可能性。今天的复杂应用程序包含许多漏洞。你应该预料到不受欢迎的人最终会接触到ServiceAccount的认证令牌，因此你应该始终限制ServiceAccount，以防止他们造成任何真正的损害。
- en: 12.3\. Summary
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 12.3. 摘要
- en: 'This chapter has given you a foundation on how to secure the Kubernetes API
    server. You learned the following:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为你提供了如何保护Kubernetes API服务器的基础知识。你学习了以下内容：
- en: Clients of the API server include both human users and applications running
    in pods.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API服务器的客户端包括人类用户和运行在Pod中的应用程序。
- en: Applications in pods are associated with a ServiceAccount.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod中的应用程序与ServiceAccount相关联。
- en: Both users and ServiceAccounts are associated with groups.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户和ServiceAccounts都与组相关联。
- en: By default, pods run under the default ServiceAccount, which is created for
    each namespace automatically.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Pod在默认ServiceAccount下运行，该ServiceAccount为每个命名空间自动创建。
- en: Additional ServiceAccounts can be created manually and associated with a pod.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以手动创建额外的ServiceAccounts并将其与Pod关联。
- en: ServiceAccounts can be configured to allow mounting only a constrained list
    of Secrets in a given pod.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以配置ServiceAccounts，以允许在给定的Pod中仅挂载受限的Secrets列表。
- en: A ServiceAccount can also be used to attach image pull Secrets to pods, so you
    don’t need to specify the Secrets in every pod.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ServiceAccount也可以用来将图像拉取Secrets附加到Pod上，这样你就不需要在每个Pod中指定Secrets。
- en: Roles and ClusterRoles define what actions can be performed on which resources.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Roles和ClusterRoles定义了可以在哪些资源上执行哪些操作。
- en: RoleBindings and ClusterRoleBindings bind Roles and ClusterRoles to users, groups,
    and ServiceAccounts.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RoleBindings和ClusterRoleBindings将Roles和ClusterRoles绑定到用户、组和ServiceAccounts。
- en: Each cluster comes with default ClusterRoles and ClusterRoleBindings.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个集群都包含默认的ClusterRoles和ClusterRoleBindings。
- en: In the next chapter, you’ll learn how to protect the cluster nodes from pods
    and how to isolate pods from each other by securing the network.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何保护集群节点免受Pod的攻击，以及如何通过网络安全来隔离Pod。
