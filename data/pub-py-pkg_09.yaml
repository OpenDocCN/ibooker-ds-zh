- en: 9 Making a package evergreen
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 使你的包保持常青
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Choosing a versioning strategy for your package releases
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的包发布选择版本化策略
- en: Automating dependency updates with GitHub’s Dependabot
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitHub 的 Dependabot 自动化依赖项更新
- en: Setting test coverage thresholds
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置测试覆盖率阈值
- en: Upgrading your Python syntax using pyupgrade
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 pyupgrade 升级你的 Python 语法
- en: Reducing rework using pre-commit hooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 pre-commit 钩子减少返工
- en: In previous chapters, you successfully built a package locally and then published
    it so developers at all your client companies could benefit from all your hard
    work. You might imagine at this point that you’ve done most of the work, but releasing
    a project is often just the beginning for many developers. After people start
    using your package, new and broken use cases start to surface. A popular open
    source project might turn into a years-long endeavor.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你成功地在本地构建了一个包，然后发布它，以便你所有客户公司的开发者都能从你的辛勤工作中受益。你可能会想象在这个时候你已经做了大部分工作，但发布一个项目对许多开发者来说通常只是开始。当人们开始使用你的包时，新的和有问题的用例开始出现。一个流行的开源项目可能变成一项持续多年的工作。
- en: Even when the dust settles and a project reaches a stable level of maturity,
    the occasional update or bug fix comes along. If none of the maintainers have
    cracked the project open in a while, these moments can prove costly. If the ecosystem
    of dependencies and tools around the project has evolved significantly since the
    last update, what might have been a simple one-line change can balloon into a
    days-long excursion to update dependencies to compatible versions and get the
    project sputtering along again. In the worst cases, this happens in the face of
    a security vulnerability; the high stress and high stakes won’t do you any favors
    in making careful updates.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 即使尘埃落定，项目达到稳定成熟水平，偶尔的更新或错误修复也会出现。如果维护者有一段时间没有打开项目，这些时刻可能会变得代价高昂。如果项目周围的依赖项和工具生态系统自上次更新以来发生了显著变化，那么可能只是一行简单的更改也可能变成更新依赖项到兼容版本并让项目再次运转的几天之旅。在最坏的情况下，这种情况发生在安全漏洞面前；高压力和高风险不会在您进行仔细更新时帮上忙。
- en: This picture I’m painting is not meant to scare you; rather, I hope it will
    imprint upon you the continued importance of upkeep and automation. If you want
    to remain productive, stave off software rot, and sustain your projects a long
    time into the future, you need to keep a well-stocked toolbox of practices. This
    chapter covers a selection of tools and philosophy but should not be taken as
    comprehensive; the point is to practice continuous learning as your project evolves,
    so it will stay *evergreen*—the way conifers stay evergreen throughout the winter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我所描绘的这幅图景并非旨在吓唬你；相反，我希望它能给你留下持续维护和自动化的重要性印象。如果你想保持生产力，防止软件腐化，并将你的项目长期维持下去，你需要保持一个丰富的实践工具箱。本章涵盖了一系列工具和哲学，但不应该被视为全面的；目的是在项目演变过程中实践持续学习，这样它将保持*常青*——就像针叶树在整个冬天都保持常青一样。
- en: Important You can use the code companion ([http://mng.bz/69A5](http://mng.bz/69A5))
    to check your work for the exercises in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：您可以使用代码伴侣（[http://mng.bz/69A5](http://mng.bz/69A5)）来检查本章练习的工作。
- en: 9.1 Choosing a package-versioning strategy
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1 选择包版本化策略
- en: You first created your package and its distribution metadata, including the
    *version*, in chapter 3\. The version of a distribution package release helps
    distinguish it from other releases. You started by giving your package a version
    of `0.0.1`, and in chapter 7, you published a release to the Python Package Index
    with this version. In the first stages of a project, versions are often a detail
    of logistics, acting simply as a unique identifier so each release is distinguishable.
    But over time, people who use your project expect it to convey information about
    what’s contained in the release. You need to define a strategy for versioning
    your releases. Before diving directly into those details, you first need to understand
    the interplay between dependencies and release versions in the Python ecosystem.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先在第三章中创建了你的包及其分发元数据，包括*版本*。分发包的版本有助于将其与其他版本区分开来。你最初给你的包分配了版本 `0.0.1`，然后在第七章中，你使用这个版本将发布发布到
    Python 包索引。在项目的早期阶段，版本通常只是物流的细节，简单地作为唯一标识符，以便每个发布都可以区分。但随着时间的推移，使用你的项目的人期望它传达有关发布中包含内容的更多信息。你需要为你的发布定义一个版本化策略。在直接深入了解这些细节之前，你首先需要了解
    Python 生态系统中依赖项和发布版本之间的相互作用。
- en: 9.1.1 Direct and indirect dependencies
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 直接和间接依赖项
- en: Not all dependencies are equal. When you think about your package and its dependencies,
    you likely think about those you specified in the `install_requires` metadata
    list or those you specified in the `deps` list for your tox environments. These
    are dependencies you import directly in your code, or that you use directly during
    the development of your project. As an example, your package depends on the `termcolor`
    package to provide stylized output, and you depend on packages like `mypy` and
    `black` when you develop your package. These are *direct dependencies*, because
    you reference them explicitly by name.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有依赖项都是平等的。当您考虑您的包及其依赖项时，您可能首先想到的是在`install_requires`元数据列表中指定的那些，或者在您的tox环境中指定的`deps`列表中的那些。这些是您直接在代码中导入的依赖项，或者是在您项目开发过程中直接使用的依赖项。例如，您的包依赖于`termcolor`包以提供样式化的输出，当您开发您的包时，您依赖于像`mypy`和`black`这样的包。这些是*直接依赖项*，因为您通过名称明确引用了它们。
- en: Your project’s direct dependencies may themselves depend directly on yet other
    packages, which may depend on yet other packages, and so on. Those dependencies
    a layer or more down from your project’s direct dependencies are *indirect dependencies*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您项目的直接依赖项本身可能直接依赖于其他包，这些包可能又依赖于其他包，以此类推。比您项目的直接依赖项低一层或更多层的这些依赖项被称为*间接依赖项*。
- en: Note You may encounter sources that use different terminology around dependencies.
    Some sources may use “concrete/abstract” or “dependency/ subdependency” to refer
    to direct and indirect dependencies, respectively. Because Python only allows
    one version of a package to be installed in a particular environment, these words
    are mostly interchangeable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可能会遇到使用不同术语来描述依赖项的来源。一些来源可能使用“具体/抽象”或“依赖/子依赖”来分别指代直接和间接依赖项。由于Python只允许在特定环境中安装一个版本的包，这些术语基本上是可以互换的。
- en: A dependency can be both direct and indirect at the same time; your project
    may depend directly on package A and package B, and package B may depend directly
    on package A. In this way, a project’s dependencies produce a graph (as shown
    in figure 9.1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个依赖项可以同时是直接和间接的；您的项目可能直接依赖于包A和包B，而包B可能直接依赖于包A。以这种方式，一个项目的依赖项会产生一个图（如图9.1所示）。
- en: '![](../../OEBPS/Images/09-01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1](../../OEBPS/Images/09-01.png)'
- en: Figure 9.1 Python projects depend on a graph of direct and indirect dependencies.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 Python项目依赖于直接和间接依赖项的图。
- en: Keep this graph model in the back of your mind whenever you start using new
    dependencies in your projects. It isn’t a concept most tools will point out to
    you directly, so you need to commit it to your own understanding. The graph model
    comes in handy when resolving certain dependency issues, as discussed in the following
    section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您开始在项目中使用新的依赖项时，都要在脑海中保留这个图模型。这不是大多数工具会直接指出的概念，因此您需要将其内化到自己的理解中。当解决某些依赖项问题时，图模型会很有用，如下一节所述。
- en: Direct and indirect dependencies in practice
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 实际中的直接和间接依赖项
- en: The asymmetry of direct and indirect dependencies shows up occasionally in Python
    tooling. When you use the `python -m pip install` command to install a package,
    you specify the direct dependency only. When you use the `python -m pip list`
    command to list packages, it lists all installed packages, whether direct or indirect.
    This can lead to mistakes. Imagine you added `package-a` as a direct dependency
    some time ago. You haven’t worked on your project in a while, and when you come
    back to it later, you want to see what’s installed. When you list the installed
    packages, you see that `package-a` and `package-b` are installed. `package-b`
    is installed only because `package-a` depends on it; unless you double-check your
    direct dependencies, you might mistakenly believe you can use `package-b` safely
    in your project. This mistake could break your project later on if a new version
    of `package-a` stops depending on `package-b`, causing Python to produce an `ImportError`
    when the application runs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 直接和间接依赖项的不对称性偶尔会在Python工具中出现。当您使用`python -m pip install`命令安装包时，您只指定直接依赖项。当您使用`python
    -m pip list`命令列出包时，它会列出所有已安装的包，无论是直接还是间接的。这可能会导致错误。想象一下，您之前将`package-a`作为直接依赖项添加。您有一段时间没有在您的项目上工作，当您稍后回来时，您想查看已安装的内容。当您列出已安装的包时，您看到`package-a`和`package-b`都已安装。`package-b`仅因为`package-a`依赖于它而安装；除非您仔细检查您的直接依赖项，否则您可能会错误地认为您可以在项目中安全地使用`package-b`。如果`package-a`的新版本停止依赖于`package-b`，这可能会导致Python在应用程序运行时产生`ImportError`，这种错误可能会在以后破坏您的项目。
- en: Differentiating direct and indirect dependencies
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 区分直接和间接依赖
- en: Although direct and indirect dependencies get flattened into one list by pip
    at the time of this writing, other tools do track the distinction between the
    two types of dependencies. As an example, poetry ([https://python-poetry.org](https://python-poetry.org))
    provides a `poetry show --tree` command that lists the installed dependencies;
    it uses a tree instead of a graph for the sake of listing the packages linearly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在撰写本文时，pip将直接和间接依赖简化为单个列表，但其他工具确实跟踪这两种类型依赖之间的区别。例如，poetry ([https://python-poetry.org](https://python-poetry.org))
    提供了一个`poetry show --tree`命令，列出已安装的依赖关系；它使用树而不是图来线性列出包。
- en: There are also other approaches to dependency installation, such as the pip-tools
    flow ([http://mng.bz/xMdX](http://mng.bz/xMdX)). This can be valuable because
    you still have to manage your direct dependencies explicitly, but you also get
    a more repeatable build because pip-tools generates a static list of direct and
    indirect dependencies instead of resolving them again each time you install your
    dependencies. Though powerful, I recommend getting used to the core behavior of
    dependency management before adding this complexity to a project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他依赖关系安装的方法，例如pip-tools流程([http://mng.bz/xMdX](http://mng.bz/xMdX))。这很有价值，因为你仍然需要显式地管理你的直接依赖，但你也会得到一个更可重复的构建，因为pip-tools生成一个静态的直接和间接依赖关系列表，而不是每次安装依赖关系时再次解析它们。尽管功能强大，但我建议在向项目中添加这种复杂性之前，先熟悉依赖关系管理的核心行为。
- en: Think of dependencies as an API for a moment. The direct dependencies are part
    of the public API, and the indirect dependencies are part of the private API.
    You should depend only on the public API, because the private API is subject to
    change without notice (see figure 9.2).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时将依赖关系视为一个API。直接依赖是公共API的一部分，而间接依赖是私有API的一部分。你应该只依赖于公共API，因为私有API可能会在未通知的情况下发生变化（见图9.2）。
- en: '![](../../OEBPS/Images/09-02.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2](../../OEBPS/Images/09-02.png)'
- en: Figure 9.2 Thinking about dependencies as an interface between public and private
    behavior
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 将依赖关系视为公共和私有行为之间的接口
- en: Always ensure that any package you import into your runtime application is specified
    in the `install_requires` metadata, and ensure that any package you use to develop
    your project is specified in the `deps` list for the appropriate tox environment.
    This practice will ensure your project never breaks because of a shift in indirect
    dependencies. If you do run into such an issue down the road, your understanding
    of the graph model of dependencies will lead you to check that all imported packages
    are direct dependencies.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 总是要确保你导入到运行时应用程序中的任何包都在`install_requires`元数据中指定，并且确保你用于开发项目的任何包都在适当的tox环境中`deps`列表中指定。这种做法将确保你的项目不会因为间接依赖关系的变动而中断。如果你将来遇到此类问题，你对依赖关系图模型的理解将引导你检查所有导入的包是否为直接依赖。
- en: Distribution package release versions come into play with the dependency graph
    when tools like pip need to determine which set of dependency versions to install.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当像pip这样的工具需要确定要安装的依赖关系版本集时，依赖关系图与发行包的版本有关。
- en: Dependency resolution is nontrivial
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系解析非同小可
- en: It can be difficult to satisfy all the constraints in a project’s dependencies.
    There’s more to consider than you might think. Although dependency resolution
    algorithms are outside the scope of this book, the story of pip’s dependency resolution
    algorithm update is an interesting one (check out Podcast.__init__, episode 264,
    [http://mng.bz/woKQ](http://mng.bz/woKQ)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个项目的依赖关系中满足所有约束可能很困难。需要考虑的因素比你想象的要多。尽管依赖关系解析算法不在此书的范围之内，但pip的依赖关系解析算法更新故事却很有趣（查看Podcast.__init__，第264集，[http://mng.bz/woKQ](http://mng.bz/woKQ)）。
- en: 9.1.2 Python dependency specifiers and dependency hell
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 Python依赖指定符和依赖地狱
- en: 'In chapter 4, you added the `termcolor` package as a dependency. Recall that
    you specified allowing any version greater than 1.1.0 and less than 2.0.0, as
    shown in the following snippet:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，你将`termcolor`包作为依赖项添加。回想一下，你指定了允许任何大于1.1.0且小于2.0.0的版本，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'PEP 440 ([https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/))
    covers the variety of ways you can version a package and, in turn, how you can
    specify dependency versions. In the most common cases, projects specify dependencies
    in the following ways, from most restrictive to least restrictive:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 440 ([https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/))
    涵盖了你可以对包进行版本化的各种方式，以及反过来如何指定依赖项版本。在最常见的案例中，项目以以下方式指定依赖项，从最严格到最宽松：
- en: An exact match version, often called *pinning*. `termcolor==1.1.3` is an example
    of an exact match for version 1.1.3.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 精确匹配版本，通常称为*固定*。`termcolor==1.1.3`是版本1.1.3的精确匹配示例。
- en: A lower and upper bound, which may be exact matches or prefix matches. `termcolor>=1.1.0,<2`
    or `termcolor~=1.1` allows for any version greater than or equal to 1.1.0 but
    less than 2.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个下限和上限，这些可能是精确匹配或前缀匹配。`termcolor>=1.1.0,<2` 或 `termcolor~=1.1` 允许安装任何大于或等于1.1.0但小于2的版本。
- en: A lower bound only. `termcolor>=1.1.0` allows for any version greater than or
    equal to 1.1.0.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅下限。`termcolor>=1.1.0` 允许安装任何大于或等于1.1.0的版本。
- en: No version. `termcolor` without any additional specification allows for any
    version of `termcolor` to be installed.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有版本。没有额外指定的`termcolor`允许安装任何版本的`termcolor`。
- en: Think about the set of all available release versions of the `termcolor` package.
    They may range from version 0.0.1, like your own package, all the way to version
    5.6.2, or 10.8.19, or 1000.5.2\. By specifying the range of versions you allow
    to be installed, you restrict the installer to a smaller set of versions to resolve.
    In addition to the constraints you place on your project’s direct dependencies,
    the packages your project depends on may also constrain the set of allowed versions
    further. As shown in figure 9.3, these constraints may not always play well together.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`termcolor`包所有可用的发布版本集。它们可能从版本0.0.1，就像你的包一样，一直到版本5.6.2，或者10.8.19，或者1000.5.2。通过指定允许安装的版本范围，你可以限制安装器只解决更小版本的集合。除了你对项目直接依赖项施加的约束外，项目依赖的包也可能进一步限制允许的版本集。如图9.3所示，这些约束可能并不总是很好地协同工作。
- en: '![](../../OEBPS/Images/09-03.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/09-03.png)'
- en: Figure 9.3 Dependency version specifiers act as constraints on the set of all
    available release versions for a given package.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 依赖项版本指定符作为给定包所有可用发布版本集的约束。
- en: When resolution becomes impossible because of dependency version constraints,
    the course of action is often to investigate a potentially cascading set of tests
    to check if upgrading one of your direct dependencies fixes the issue. Because
    the graph of this situation sometimes looks like a diamond, this situation is
    sometimes referred to as a *diamond dependency conflict* (figure 9.4).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当由于依赖项版本约束导致解析变得不可能时，通常的做法是调查一系列潜在的测试，以检查升级你的直接依赖项之一是否解决了问题。因为这种情况的图有时看起来像菱形，所以这种情况有时被称为*菱形依赖冲突*（图9.4）。
- en: '![](../../OEBPS/Images/09-04.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/09-04.png)'
- en: Figure 9.4 Dependency resolution is sometimes impossible due to conflicts, and
    a diamond dependency conflict is one of the most common types.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 依赖关系解析有时由于冲突而变得不可能，而菱形依赖冲突是最常见的类型之一。
- en: Because this is rarely fun to fix and almost always frustrating, it’s also sometimes
    referred to as *dependency hell*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这很少是件有趣的事情，而且几乎总是令人沮丧，所以它有时也被称为*依赖地狱*。
- en: Managing dependency hell
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 管理依赖地狱
- en: Dependency hell is, frankly, part of the reality of software development. But
    it’s often exacerbated by packages that unnecessarily constrain their dependencies
    to a narrow range. If you use features introduced in a specific version of a dependency,
    it makes sense to specify that version as the lower bound of allowable versions.
    Upper bounds make less sense; they should generally be used only when your library
    has a known incompatibility with a newer version (see Henry Schreiner, *Should
    You Use Upper Bound Version Constraints?*, [http://mng.bz/099v](http://mng.bz/099v)
    for a profound exploration of the danger of upper bounds).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 实话实说，依赖地狱是软件开发现实的一部分。但它通常被那些不必要地将它们的依赖项约束在一个狭窄范围内的包所加剧。如果你使用了特定版本依赖项中引入的功能，那么指定该版本作为允许版本的下限是有意义的。上限则没有太多意义；它们通常只在你的库与较新版本有已知的兼容性问题时使用（参见Henry
    Schreiner的*Should You Use Upper Bound Version Constraints?*，[http://mng.bz/099v](http://mng.bz/099v)，对上限危险的深入探讨）。
- en: By leaving the range of allowed versions as wide as possible in your direct
    dependencies, you maximize the options for those using your package alongside
    other dependencies.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过尽可能宽泛地设置直接依赖项允许的版本范围，你最大化了那些使用你的包与其他依赖项一起使用时的选项。
- en: Now that you’ve got a solid foundation of understanding about direct and indirect
    dependencies, the dependency graph, version specifiers, and the tensions these
    can produce, you’re equipped to start thinking about the strategy you want to
    use for versioning your own package.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对直接和间接依赖、依赖图、版本指定符以及这些可能产生的紧张关系有了坚实的理解，你就可以开始考虑你想要用于自己包版本控制的策略了。
- en: 9.1.3 Semantic versioning and calendar versioning
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 语义版本控制和日历版本控制
- en: By far the two most prominent approaches to package versioning in the Python
    ecosystem are *semantic versioning* ([https://semver.org/](https://semver.org/))
    and *calendar versioning* ([https://calver.org/](https://calver.org/)). Both of
    these approaches are compatible with the PEP 440 specification, but they each
    emphasize different information about a distribution package release.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Python生态系统中最突出的两个包版本管理方法分别是**语义版本控制**([https://semver.org/](https://semver.org/))和**日历版本控制**([https://calver.org/](https://calver.org/))。这两种方法都与PEP
    440规范兼容，但它们各自强调了一个发行包版本发布的不同信息。
- en: 'Semantic versioning aims to communicate the degree to which the API of the
    behavior changed in the release. It focuses on the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本控制旨在传达发布中行为API变化的程度。它关注以下方面：
- en: If installed, will this release version break any existing behavior? If so,
    it’s a *major* change. The most significant version identifier number should increase
    by 1.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果安装了此版本，是否会破坏任何现有行为？如果是，则这是一个**重大**变更。最重要的版本标识符数字应增加1。
- en: If existing behavior is maintained, does this release version add new behavior?
    If so, it’s a *minor* change. The next most significant version identifier number
    should increase by 1.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果保持现有行为不变，此版本是否添加了新行为？如果是，则这是一个**次要**变更。下一个最重要的版本标识符数字应增加1。
- en: If no new behavior is added, the change must fix broken behavior, so it’s a
    *patch* change. The least significant version identifier number should increase
    by 1.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有添加新行为，则更改必须修复破坏的行为，因此这是一个**补丁**变更。最不重要的版本标识符数字应增加1。
- en: This scheme helps you discern that version 2.0.1 fixes something that was broken
    in version 2.0.0, or that you might need to update your usage when upgrading from
    version 2.7.3 to version 3.0.0\. This can be a very helpful scheme when navigating
    a wide variety of packages.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此方案有助于你辨别版本2.0.1修复了版本2.0.0中存在的问题，或者当你从版本2.7.3升级到版本3.0.0时可能需要更新你的使用方式。在导航各种包时，这可能是一个非常有益的方案。
- en: Exercise 9.1
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 练习9.1
- en: 'Write down the resulting semantic version for a major, minor, and patch release
    that comes after each of the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记录以下每个之后的重大、次要和补丁发布的最终语义版本：
- en: 17.8.3
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 17.8.3
- en: 0.4.6
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.4.6
- en: 1.0.19
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1.0.19
- en: An issue with semantic versioning is that a particular version may overpromise
    what users can expect, whether due to human error from the maintainers or too
    much user confidence in the versioning scheme. If you fix a bug, but fixing the
    bug also breaks existing behavior, should it be a patch or a major version release?
    Strictly speaking, you should issue a major version release. But even the semver
    specification says to “use your best judgment.” If you choose to issue a patch
    release and users believe that you would never break functionality without a major
    release, there is a communication breakdown and, therefore, the potential for
    frustration.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本控制的一个问题是，特定的版本可能过度承诺用户可以期待的内容，无论是由于维护者的错误还是用户对版本控制方案过度自信。如果你修复了一个错误，但修复错误也破坏了现有行为，它应该是一个补丁还是重大版本发布？严格来说，你应该发布一个重大版本。但即使是semver规范也说要“使用你的最佳判断”。如果你选择发布补丁版本，而用户认为你不会在没有重大版本发布的情况下破坏功能，那么就会发生沟通障碍，因此有潜在的挫败感。
- en: Another less impactful issue with semantic versioning is that it doesn’t give
    you a sense of when a particular version was released. You can typically look
    this up in the package repository where it’s published, but that may be tedious
    when you’re interested in looking at multiple packages or versions. Semantic versioning
    might even cause users to believe a particular version was released before another
    because of the version numbers, which isn’t guaranteed; you could release version
    4.0.0 one day and release a fix for version 2.1.0 as version 2.1.1 the next day.
    The fact that the timeline isn’t guaranteed and that even the semantics of semantic
    versioning aren’t guaranteed is partly what gave rise to calendar versioning.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本控制的一个不太重要的问题是，它不能给你一个特定版本发布时间的概念。你通常可以在发布它的包仓库中查找这个信息，但当你对查看多个包或版本感兴趣时，这可能很麻烦。语义版本控制甚至可能让用户相信一个特定版本是在另一个版本之前发布的，因为版本号，但这并不保证；你可以在某一天发布版本
    4.0.0，然后在第二天发布版本 2.1.0 的修复作为版本 2.1.1。时间线不可保证，甚至语义版本控制的语义也不保证，这部分是日历版本控制产生的原因。
- en: Calendar versioning is a less precise specification, but in general, projects
    using calendar versioning schemes start each version with the current year or
    month, followed by a more specific version number. Often, projects that use calendar
    versioning also release new versions on a set schedule, fitting in as many updates
    and fixes as they can until the next release. This gives predictability to the
    timeline but doesn’t necessarily promise anything about changes to the API.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 日历版本控制是一种不太精确的规范，但一般来说，使用日历版本控制方案的项目通常以当前年份或月份开始每个版本，然后跟一个更具体的版本号。通常，使用日历版本控制的项目也会按照一定的计划发布新版本，尽可能多地包含更新和修复，直到下一次发布。这为时间线提供了可预测性，但并不保证API的任何变化。
- en: Single-sourcing the package version
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 单源包版本
- en: You might discover some articles online discussing the value of single-sourcing
    the package version. This is a valuable thing to do, because if you keep the version
    stored in multiple places, you’ll inevitably update one and forget the other at
    some point. Historically, this discussion arose because project authors had a
    practice of providing the version of the package as a `__version__` attribute
    in the package’s root `__init__.py` module. Because the version also needs to
    be specified in a file such as setup.cfg or setup.py in order for the package
    build tooling to recognize it, approaches for specifying the version once and
    using it in both places were necessary (see the *Python Packaging User Guide*,
    “Single-sourcing the package version,” [http://mng.bz/qYp2](http://mng.bz/qYp2)).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在网上发现一些讨论单源包版本价值的文章。这是一件值得做的事情，因为如果你将版本存储在多个地方，你不可避免地会在某个时候更新一个而忘记另一个。历史上，这种讨论出现是因为项目作者有一个习惯，在包的根
    `__init__.py` 模块中提供包的版本作为 `__version__` 属性。因为版本还需要在 setup.cfg 或 setup.py 等文件中指定，以便包构建工具能够识别它，所以需要一次指定版本并在两个地方使用它的方法（参见
    *Python 包管理用户指南*，“单源包版本”，[http://mng.bz/qYp2](http://mng.bz/qYp2))。
- en: The `__version__` attribute is only a common practice and is not standardized—its
    only mention is in the rejected PEP 396 ([https://www.python.org/dev/peps/pep-0396/](https://www.python.org/dev/peps/pep-0396/)).
    A best practice going forward is to use the `importlib.metadata.version` function,
    as you did in your Sphinx documentation configuration in chapter 8\. Using this
    approach, you need only specify the version in your package’s static metadata
    for it to be readable elsewhere in your code or your users' code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`__version__` 属性仅是一种常见的做法，并没有标准化——它唯一被提及的地方是在被拒绝的PEP 396 ([https://www.python.org/dev/peps/pep-0396/](https://www.python.org/dev/peps/pep-0396/))。未来的最佳实践是使用
    `importlib.metadata.version` 函数，正如你在第8章中配置Sphinx文档时所做的。采用这种方法，你只需在包的静态元数据中指定版本，就可以在代码的其他部分或用户的代码中读取它。'
- en: Of the two approaches, semantic versioning is still overwhelmingly the most
    common. It does make sense to use a sequential version scheme, so you need to
    decide which is intuitive to you and your users. The most important thing in the
    end is communication, and communication often requires a little bit more elbow
    grease. One of the best ways to communicate about releases is through a consistent
    and thorough change log, which you’ll read more about in chapter 11.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种方法中，语义版本控制仍然是最常见的。使用顺序版本方案是有意义的，因此您需要决定哪个对您和您的用户来说更直观。最终最重要的是沟通，而沟通往往需要更多的努力。关于发布沟通的最好方式之一是通过一致且详尽的变更日志，您将在第
    11 章中了解更多关于变更日志的内容。
- en: The next section covers some of the features GitHub provides for managing dependency
    versions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个章节将介绍 GitHub 提供的一些用于管理依赖项版本的功能。
- en: 9.2 Getting the most out of GitHub
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2 充分利用 GitHub
- en: 'As a popular collaboration platform for software project changes, GitHub is
    positioned as a useful place to do software project maintenance as well. Over
    the last few years, they’ve developed or acquired several useful tools for managing
    software dependencies: security scans, automated vulnerability fixes and dependency
    updates, and a dependency graph. Learn more about each of these features in the
    following sections.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件项目变更的流行协作平台，GitHub 被定位为一个进行软件项目维护的有用场所。在过去几年中，他们开发或收购了几个用于管理软件依赖的有用工具：安全扫描、自动漏洞修复和依赖项更新，以及依赖图。在以下章节中详细了解每个功能。
- en: Note The availability of features similar to those covered in the following
    sections differs from platform to platform. If you want to use another platform
    for your software collaboration, you’ll need to read their documentation to see
    what they offer.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：以下章节中提到的类似功能在不同平台上的可用性各不相同。如果您想为您的软件协作使用其他平台，您需要阅读他们的文档以了解他们提供的内容。
- en: 9.2.1 The GitHub dependency graph
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 GitHub 依赖图
- en: GitHub inspects the files in your repository and extracts structured knowledge
    about dependencies from it. This works across several languages, and even works
    for some workflow- and framework-level things like GitHub Actions. Across all
    repositories, GitHub then uses this structured data to produce a graph of dependencies
    and dependents. The dependency graph is enabled for all public repositories, and
    you can enable it for private repositories as well in the repository settings.
    Because your repository is public, the dependency graph is already enabled.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 会检查您仓库中的文件，并从中提取关于依赖项的结构化知识。这适用于多种语言，甚至适用于一些工作流和框架级别的功能，如 GitHub Actions。在所有仓库中，GitHub
    使用这些结构化数据生成依赖项和依赖者的图。依赖图对所有公共仓库都是启用的，您也可以在仓库设置中将其启用为私有仓库。因为您的仓库是公开的，所以依赖图已经启用。
- en: Visit the GitHub page for your repository now. Click the Insights tab; then,
    in the left-hand navigation, click Dependency Graph. GitHub shows you, on a per-file
    basis, the dependencies it was able to identify. For each dependency, it links
    to that project’s repository and shows the version your project depends on. Figure
    9.5 shows that GitHub found a dependency on version 2 of the `setup-python` action
    in the GitHub Actions YAML file in a project and provides a link to the repository
    for that action.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在访问您仓库的 GitHub 页面。点击“洞察”标签；然后，在左侧导航中点击“依赖图”。GitHub 会根据每个文件显示它能够识别的依赖项。对于每个依赖项，它都会链接到该项目的仓库，并显示您的项目所依赖的版本。图
    9.5 显示，GitHub 在一个项目的 GitHub Actions YAML 文件中找到了对 `setup-python` 动作版本 2 的依赖，并提供了一个链接到该动作的仓库。
- en: '![](../../OEBPS/Images/09-05.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/09-05.png)'
- en: Figure 9.5 The dependencies in GitHub’s dependency graph from a project using
    GitHub Actions
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 使用 GitHub Actions 的项目在 GitHub 依赖图中的依赖关系
- en: Note GitHub doesn’t support dependencies defined in `install_requires` in the
    setup.cfg file at the time of this writing ([http://mng.bz/7yAy](http://mng.bz/7yAy)).
    Please help projects get better support in the GitHub dependency graph by upvoting
    and joining my feature request discussion on the topic ([http://mng.bz/K00O](http://mng.bz/K00O)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：截至本文写作时，GitHub 不支持在 setup.cfg 文件中定义的 `install_requires` 依赖项。[http://mng.bz/7yAy](http://mng.bz/7yAy)。请帮助项目在
    GitHub 依赖图中获得更好的支持，通过点赞并加入我在此主题上的功能请求讨论。[http://mng.bz/K00O](http://mng.bz/K00O)。
- en: You can also click the Dependents tab to see any projects that depend on yours.
    You likely don’t have any users of the package you’ve created for this book, but
    you can see examples of this in action on other popular projects like the requests
    package ([http://mng.bz/9VVr](http://mng.bz/9VVr)). As of this writing in March
    2022, over one million projects depend on requests (figure 9.6)!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以点击“依赖项”选项卡来查看任何依赖你的项目。你可能没有使用你为这本书创建的包的用户，但你可以在其他流行的项目（如requests包）中看到这一功能的实际应用示例（[http://mng.bz/9VVr](http://mng.bz/9VVr)）。截至2022年3月，超过一百万个项目依赖于requests（图9.6）！
- en: '![](../../OEBPS/Images/09-06.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/09-06.png)'
- en: Figure 9.6 The dependents in GitHub’s dependency graph from a popular project
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 来自流行项目的GitHub依赖关系图中的依赖项
- en: In addition to displaying the dependencies of your project, GitHub can check
    them for security vulnerabilities.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示你项目的依赖关系外，GitHub还可以检查它们是否存在安全漏洞。
- en: 9.2.2 Mitigating security vulnerabilities with Dependabot
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 使用Dependabot缓解安全漏洞
- en: 'Navigate to the settings page of your project’s GitHub repository. In the left-hand
    navigation, click Code Security and Analysis. On this page you can find the variety
    of features GitHub offers for dependency security in addition to the dependency
    graph, as described here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到你的GitHub仓库的设置页面。在左侧导航中，点击“代码安全和分析”。在这个页面上，你可以找到GitHub提供的各种依赖项安全功能，包括依赖关系图，如这里所述：
- en: '*Dependabot alerts*—GitHub can create automated notifications of vulnerable
    packages you depend on, with suggestions for mitigation. This is on by default.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Dependabot警报*—GitHub可以为你依赖的有漏洞的包创建自动通知，并提供缓解建议。默认情况下，此选项是开启的。'
- en: '*Dependabot security updates*—When Dependabot finds a vulnerable dependency,
    enabling this option will open a pull request automatically to update to a nonvulnerable
    version, if available. This is off by default.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Dependabot安全更新*—当Dependabot发现一个有漏洞的依赖项时，启用此选项将自动打开一个拉取请求以更新到非漏洞版本（如果可用）。默认情况下，此选项是关闭的。'
- en: '*Code scanning*—GitHub can scan your project code for vulnerabilities as well.
    This is off by default.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码扫描*—GitHub还可以扫描你的项目代码以查找漏洞。默认情况下，此选项是关闭的。'
- en: '*Secret scanning*—GitHub scans your code for potentially leaked passwords,
    API keys, and so on to protect you from attackers who scrape and use the information.
    This is always on.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*秘密扫描*—GitHub扫描你的代码以查找可能泄露的密码、API密钥等，以保护你免受那些刮取并使用这些信息的攻击者。此功能始终开启。'
- en: Note Dependabot security alerts aren’t easy to generate for the sake of example,
    and any existing vulnerabilities are sensitive private information to project
    maintainers. Refer to GitHub’s own documentation to see examples and read about
    interacting with the alerts themselves ([http://mng.bz/mOM2](http://mng.bz/mOM2)).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了示例，Dependabot安全警报不容易生成，并且任何现有的漏洞都是对项目维护者敏感的私人信息。请参考GitHub自己的文档以查看示例并了解如何与警报本身交互（[http://mng.bz/mOM2](http://mng.bz/mOM2)）。
- en: This may seem like a lot to take in, but these features are all automated and
    provide actionable alerts or pull requests that you can respond to as necessary.
    Security is best performed as a many-layered process, because each layer has its
    own focus and shortcomings (James T. Reason, “The Contribution of Latent Human
    Failures to the Breakdown of Complex Systems,” *Philosophical Transactions of
    the Royal Society*, [http://mng.bz/jAAe](http://mng.bz/jAAe)). The more variety
    you can introduce to your security strategy, the better.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来需要吸收很多信息，但这些功能都是自动化的，并提供可操作的警报或拉取请求，你可以根据需要做出回应。安全最好作为一个多层次的流程来执行，因为每一层都有自己的重点和不足（詹姆斯·T·雷恩，《潜在人为错误对复杂系统崩溃的贡献》，《皇家学会哲学学报》，[http://mng.bz/jAAe](http://mng.bz/jAAe))。你能在你的安全策略中引入更多多样性，那就越好。
- en: Enabling Dependabot security updates
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 启用Dependabot安全更新
- en: 'Click Enable next to Dependabot Security Updates. Dependabot will open a pull
    request to update vulnerable dependencies when it can. Dependabot opens pull requests
    from the `@dependabot` user, and the pull request includes the following useful
    pieces of information in addition to the code change:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Dependabot安全更新”旁边点击“启用”。Dependabot会在可能的情况下打开一个拉取请求来更新有漏洞的依赖项。Dependabot会从`@dependabot`用户打开拉取请求，除了代码更改外，拉取请求还包括以下有用的信息：
- en: Which dependency is being updated
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在更新的依赖项是哪个
- en: Where the dependency was found in the project
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项在项目中的位置
- en: The version of the dependency before and after the change
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项更改前后的版本
- en: Release notes, change log, and commits that happened between the old and new
    version
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布说明、变更日志以及旧版本和新版本之间的提交记录
- en: How likely it is that the new version introduces breaking changes, if known
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果已知，新版本引入破坏性更改的可能性有多大
- en: You can also interact with the pull request through comments to have Dependabot
    take additional actions. Importantly, Dependabot does not indicate in the pull
    request that the change addresses a vulnerability, because this would alert malicious
    actors to try exploiting the vulnerability. An example pull request description
    from the `black` package’s repository is shown in figure 9.7.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过评论与拉取请求互动，让Dependabot执行额外的操作。重要的是，Dependabot不会在拉取请求中表明更改解决了漏洞，因为这会警告恶意行为者尝试利用该漏洞。图9.7展示了来自`black`包存储库的一个示例拉取请求描述。
- en: '![](../../OEBPS/Images/09-07.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/09-07.png)'
- en: Figure 9.7 Dependabot opens pull requests to update vulnerable dependencies
    and provides information to assess the compatibility of the new version.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 Dependabot打开拉取请求以更新易受攻击的依赖项，并提供有关评估新版本兼容性的信息。
- en: After Dependabot opens a pull request, you can assess the compatibility of the
    change by observing the status of your tests and code quality checks. You can
    also check out the code locally to do any manual verification. If the change appears
    to be compatible, you can merge the pull request. Dependabot detects the updated
    dependency and removes any associated vulnerability alerts. Next, you’ll configure
    GitHub’s code scanning to scan your own code for security issues and bugs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Dependabot打开拉取请求后，您可以通过观察测试状态和代码质量检查来评估更改的兼容性。您还可以在本地检查代码以进行任何手动验证。如果更改看起来是兼容的，您可以合并拉取请求。Dependabot检测到更新的依赖项并移除任何相关的漏洞警报。接下来，您将配置GitHub的代码扫描以扫描您自己的代码中的安全问题和错误。
- en: Enabling GitHub code scanning
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 启用GitHub代码扫描
- en: 'GitHub uses a system called CodeQL, short for “code query language,” that enables
    developers to query their code base for particular code constructs ([https://codeql.github.com/](https://codeql.github.com/)).
    CodeQL works similarly to tools like mypy, black, and flake8 that use Python’s
    abstract syntax tree to find issues. As an example, you could use CodeQL to find
    areas in a Django project that are vulnerable to SQL injection because the code
    passes unvalidated user input directly into a database query. People can submit
    CodeQL queries to the community identifying common security issues and bugs. You
    can enable CodeQL scanning in your repository in a few steps, as shown here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub使用一个名为CodeQL的系统，简称“代码查询语言”，它使开发者能够查询其代码库中的特定代码结构([https://codeql.github.com/](https://codeql.github.com/))。CodeQL的工作方式类似于mypy、black和flake8等工具，这些工具使用Python的抽象语法树来查找问题。例如，您可以使用CodeQL查找Django项目中易受SQL注入攻击的区域，因为代码将未经验证的用户输入直接传递到数据库查询中。人们可以向社区提交CodeQL查询，以识别常见的安全问题和错误。您可以在几个步骤中在存储库中启用CodeQL扫描，如下所示：
- en: Navigate to the Code Security and Analysis settings for your repository.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到您存储库的代码安全和分析设置。
- en: Click Set Up next to Code Scanning.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击代码扫描旁边的“设置”。
- en: Click Set Up This Workflow in CodeQL Analysis. GitHub takes you to a prepopulated
    new file creation view for .github/workflows/codeql-analysis.yml.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“在CodeQL分析中设置此工作流程”，GitHub将带您到一个预先填充的新文件创建视图，用于.github/workflows/codeql-analysis.yml。
- en: Update the `on.schedule.cron` value to run as frequently as you desire. Once
    daily is a good starting place; use a site like Cron Helper ([https://cron.help](https://cron.help))
    to build a cron expression if you aren’t familiar with the syntax.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`on.schedule.cron`值更新为运行您所需的频率。每天一次是一个好的起点；如果您不熟悉语法，可以使用Cron Helper([https://cron.help](https://cron.help))构建cron表达式。
- en: Ensure the `language` field in the YAML configuration is set to `[ 'python'
    ]`. GitHub should populate this for you, but you can alter the value if it doesn’t
    detect it or detects a different language.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在YAML配置中的`language`字段设置为`[ 'python' ]`。GitHub应该为您完成此操作，但如果它没有检测到或检测到不同的语言，您可以更改此值。
- en: Click Start Commit, and fill out the details for the commit as desired. You
    can commit directly to your main branch or create a new branch to open a pull
    request.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“开始提交”，并填写所需的提交详细信息。您可以直接提交到主分支或创建一个新的分支以打开拉取请求。
- en: Click Commit New File.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“提交新文件”。
- en: Then, if you chose to create a new branch and pull request, click Create Pull
    Request, and merge the pull request after your checks pass.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果您选择创建新的分支和拉取请求，点击“创建拉取请求”，并在检查通过后合并拉取请求。
- en: After the CodeQL scanning configuration is added to your repository, GitHub
    will scan your repository on each pull request and periodically on the schedule
    you set. The GitHub Action result shows up on your pull request alongside those
    you created in previous chapters, so you’ll know whether your changes introduce
    any vulnerabilities or bugs found by CodeQL. Because it runs periodically, you
    can also learn whether any newly identified vulnerabilities are present in your
    code, even if you haven’t opened a pull request recently. This proactive scanning
    is particularly helpful for mature projects that aren’t being updated every day.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 CodeQL 扫描配置添加到您的仓库后，GitHub 将在每次拉取请求时以及您设置的定期计划中扫描您的仓库。GitHub Action 的结果将显示在您的拉取请求中，与您在之前章节中创建的结果并列，这样您就会知道您的更改是否引入了
    CodeQL 发现的任何漏洞或错误。由于它是定期运行的，您还可以了解是否有任何新识别的漏洞存在于您的代码中，即使您最近没有打开拉取请求。这种主动扫描对于每天不更新的成熟项目尤其有帮助。
- en: 'With Dependabot alerts, automated updates, and code scanning in place, you
    can feel confident that your dependencies and your code changes won’t impact your
    project with security vulnerabilities in the future. There’s still one threat
    model to your project, though: *the threat model of decay*.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Dependabot 警报、自动化更新和代码扫描就绪后，您可以有信心，您的依赖项和代码更改未来不会因安全漏洞而影响您的项目。尽管如此，您的项目仍存在一个威胁模型：*衰减威胁模型*。
- en: Updating dependencies automatically with Dependabot
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Dependabot 自动更新依赖项
- en: The threat model of decay (the first known usage of this phrase was by YCombinator
    user javajosh, [https://news.ycombinator.com/item?id=29474932](https://news.ycombinator.com/item?id=29474932))
    states that one of your biggest threats will be not from an outside malicious
    actor but from your own software and ecosystem crumbling around you due to lack
    of maintenance. In addition to your project’s dependencies having vulnerabilities,
    you should keep them updated so you don’t run into dependency hell or “big bang”
    updates that leave you pulling your hair out. Dependabot was originally created
    for precisely this use case.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 衰减威胁模型（这个短语首次由 YCombinator 用户 javajosh 提出，[https://news.ycombinator.com/item?id=29474932](https://news.ycombinator.com/item?id=29474932)）表明，您最大的威胁可能不是来自外部的恶意行为者，而是由于缺乏维护，您自己的软件和生态系统在您周围崩溃。除了您的项目依赖项有漏洞外，您还应保持它们更新，以免遇到依赖地狱或让您抓狂的“大爆炸”更新。Dependabot
    最初就是为了这个用例而创建的。
- en: You can configure Dependabot to automatically bump dependency versions for you,
    even when the existing versions aren’t vulnerable ([http://mng.bz/WMMW](http://mng.bz/WMMW)).
    To do so, you can configure aspects such as the software ecosystem, project location,
    strategy, and frequency of the updates in a .github/dependabot.yml file. Note
    that many of these settings are rather subjective; you will need to adjust them
    for the pacing that works for you and your team to avoid frustration.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以配置 Dependabot 以自动为您提升依赖项版本，即使现有版本没有漏洞（[http://mng.bz/WMMW](http://mng.bz/WMMW)）。为此，您可以在
    .github/dependabot.yml 文件中配置软件生态系统、项目位置、策略和更新的频率。请注意，许多这些设置相当主观；您需要根据您和您团队的工作节奏进行调整，以避免挫败感。
- en: 'A good minimum viable place to start with Dependabot updates for your package
    is to check for updates for your GitHub Actions and your Python dependencies once
    per day. You will need to use the following fields:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您的包的 Dependabot 更新，一个良好的最小可行起点是每天检查一次 GitHub Actions 和您的 Python 依赖项的更新。您需要使用以下字段：
- en: '`version`—The current Dependabot configuration version. At the time of this
    writing, the version is `2`.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`—当前 Dependabot 配置的版本。在撰写本文时，版本为 `2`。'
- en: '`updates`—The list of configurations to check for available updates.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updates`—要检查可用更新的配置列表。'
- en: '`package-ecosystem`—The ecosystem for a given configuration. You will have
    one for `github-actions` and one for `pip`.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package-ecosystem`—给定配置的生态系统。您将有一个用于 `github-actions` 和一个用于 `pip`。'
- en: '`directory`—The directory in which to check for the current dependency versions.
    You can use `"/"` for both your configurations.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directory`—检查当前依赖项版本的目录。您可以使用 `"/"` 来配置您的配置。'
- en: '`schedule.interval`, `schedule.day`, `schedule.time`, `schedule.timezone`—The
    frequency at which to check for updates. A check every Monday morning may be a
    good starting place.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schedule.interval`、`schedule.day`、`schedule.time`、`schedule.timezone`—检查更新的频率。每周一早上进行一次检查可能是一个好的起点。'
- en: Tip For a comprehensive list of all available configurations, refer to the GitHub
    documentation ([http://mng.bz/5QV1](http://mng.bz/5QV1)).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：要获取所有可用配置的完整列表，请参阅 GitHub 文档 ([http://mng.bz/5QV1](http://mng.bz/5QV1))。
- en: Create the dependabot.yml file in the .github/ directory of your project now.
    Note that it should not live in the .github/workflows/ directory next to your
    GitHub Actions, because it isn’t a GitHub Action. When you’re done, your configuration
    should look something like the following listing.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在您的项目 .github 目录中创建 dependabot.yml 文件。请注意，它不应位于与您的 GitHub Actions 并排的 .github/workflows/
    目录中，因为它不是 GitHub Action。完成之后，您的配置应类似于以下列表。
- en: Listing 9.1 An example configuration that updates on a weekly basis
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 一个每周更新的示例配置
- en: '[PRE1]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ The Dependabot configuration version
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Dependabot 配置版本
- en: ❷ The list of configurations for update checks
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 更新检查的配置列表
- en: ❸ An update configuration for GitHub Actions dependencies
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ GitHub Actions 依赖项的更新配置
- en: ❹ Checks for dependencies starting at the root of the project
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从项目根目录开始检查依赖项
- en: ❺ Checks for dependency updates weekly
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 每周检查依赖项更新
- en: ❻ Checks dependencies on Mondays
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 每周一检查依赖项
- en: ❼ Checks dependencies at 09:00
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 在 09:00 检查依赖项
- en: ❽ An update configuration for Python dependencies
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ Python 依赖项的更新配置
- en: Commit and push this new file to your repository. After the file is added, Dependabot
    will check for opportunities to update your dependencies on the schedule you specified.
    If Dependabot finds any updates that meet your parameters, it opens a pull request
    that looks exactly like those it opens for security vulnerability updates.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将此新文件提交并推送到您的仓库。文件添加后，Dependabot 将根据您指定的计划检查更新依赖项的机会。如果 Dependabot 找到任何符合您参数的更新，它将打开一个看起来与它为安全漏洞更新打开的请求完全相同的拉取请求。
- en: Now that you’ve covered a variety of practices around your dependencies, read
    on to take a look at other aspects that affect your project’s evergreen status.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了关于依赖项的各种实践，请继续阅读，了解影响您项目持续集成状态的其他方面。
- en: 9.3 Thresholding test coverage
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3 阈值测试覆盖率
- en: In chapter 5, you added unit testing and test coverage measurement to your package
    using pytest and pytest-cov. This configuration helps you understand how much
    of your code is untested and which files have the least coverage. Although this
    is useful information, it lacks any enforcement.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 章中，您使用 pytest 和 pytest-cov 为您的包添加了单元测试和测试覆盖率测量。此配置有助于您了解您的代码中有多少未测试的部分以及哪些文件覆盖率最低。尽管这是有用的信息，但它缺乏任何强制措施。
- en: It’s natural for many projects to outpace their test coverage. Not all contributors
    will include tests, and repeatedly telling people to write tests can cast you
    in a bad light, even though you’re just trying to protect the project. As you
    can probably guess, having an automated process tell people this instead helps
    a lot. They’ll be informed, and you won’t need to intervene in the majority of
    cases. If your project has already fallen way behind on coverage, it may seem
    insurmountable to start enforcing test coverage, but it turns out the opposite
    is true. Your goal should be to first stop the bleeding, so the coverage can’t
    get any worse, and then add enforcement that ensures the coverage only gets better.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多项目来说，测试覆盖率落后是自然的。并非所有贡献者都会包含测试，反复要求人们编写测试可能会让您显得不好，尽管您只是试图保护项目。正如您可能猜到的，有一个自动化的过程告诉人们这一点会大有帮助。他们会得到通知，您不需要在大多数情况下介入。如果您的项目在覆盖率方面已经落后很多，开始强制执行测试覆盖率可能看起来是一项艰巨的任务，但事实正好相反。您的目标应该是首先停止出血，这样覆盖率就不会变得更糟，然后添加强制措施，确保覆盖率只会变得更好。
- en: Recall that 100% coverage is not necessarily the end goal; it can be difficult
    to achieve and has diminishing returns. By instead focusing on *monotonically
    increasing* coverage, you don’t need to think so anxiously about the gap between
    where you are now and the end state you want. Instead, you can ensure the coverage
    is, at worst, staying the same, and incrementally improve it over time. This system
    is like a ratchet that tightens in only one direction. Any time new tests are
    added that increase the coverage, you need a way to say that the coverage will
    never drop back below that new value again (see figure 9.8).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，100%的覆盖率并不一定是最终目标；它可能很难实现，并且回报递减。通过专注于*单调递增*的覆盖率，您不需要如此焦虑地考虑您目前的位置和您想要达到的最终状态之间的差距。相反，您可以确保覆盖率在最坏的情况下保持不变，并随着时间的推移逐步提高。这个系统就像一个只能向一个方向紧固的棘轮。每当添加新的测试来提高覆盖率时，您都需要一种方式来说明覆盖率永远不会再次低于那个新值（见图9.8）。
- en: '![](../../OEBPS/Images/09-08.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/09-08.png)'
- en: Figure 9.8 Prioritize monotonically increasing coverage for sustained, incremental
    improvement over time.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 优先考虑单调递增的覆盖率，以实现随时间推移的持续、增量改进。
- en: 'You can build in a test coverage thresholding mechanism for your project with
    a single line of code. Open your setup.cfg file and locate the `[coverage:report]`
    section. Recall that you used this section in chapter 5 to control how the coverage
    is reported when you run the tox environment for tests. You can add a `fail_under`
    key to this section with a float value between 0.0 and 100.0\. If the test coverage
    percentage is below the value you specify, the step that reports coverage after
    your tests run will fail with a message similar to the following snippet:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用一行代码为项目构建测试覆盖率阈值机制。打开您的setup.cfg文件，找到`[coverage:report]`部分。回想一下，您在第五章中使用此部分来控制在运行测试的tox环境时如何报告覆盖率。您可以在该部分添加一个`fail_under`键，其值为0.0到100.0之间的浮点数。如果测试覆盖率百分比低于您指定的值，测试运行后报告覆盖率的那一步将失败，并显示类似于以下片段的消息：
- en: '[PRE2]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Exercise 9.2
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 练习9.2
- en: Run your tests now. They should still be at 100% coverage from your work in
    earlier chapters. Set the `fail_under` value to 100.0, and run the tests again.
    Do they pass? Try deleting a test or two temporarily. Do they pass now?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行您的测试。它们应该仍然是从前面章节中的工作达到的100%覆盖率。将`fail_under`值设置为100.0，然后再次运行测试。它们通过了吗？尝试暂时删除一个或两个测试。现在它们通过了吗？
- en: Any time your coverage improves, you should update your `fail_under` value to
    the new threshold. When others contribute new code without new tests, the GitHub
    Action for tests will fail due to decreased coverage, letting them know they need
    to test their work.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您的覆盖率提高时，您都应该将`fail_under`值更新到新的阈值。当其他人贡献新代码而没有新测试时，测试的GitHub Action会因为覆盖率下降而失败，这会让他们知道需要测试他们的工作。
- en: Tip Make sure to observe the coverage percentage for all combinations of the
    testing matrix. Different dependencies may cause the coverage percentage to be
    slightly different, and you’ll need to set `fail_under` to the lowest value among
    them so they don’t fail to meet the threshold.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 确保观察测试矩阵所有组合的覆盖率百分比。不同的依赖关系可能会导致覆盖率百分比略有不同，因此您需要将这些中的最低值设置为`fail_under`，以确保它们不会因未达到阈值而失败。
- en: 'With security and test coverage under your belt, turn next to an aspect less
    often thought about: the Python syntax you use.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握安全和测试覆盖率之后，接下来关注一个不太常被考虑的方面：您使用的Python语法。
- en: 9.4 Updating Python syntax using pyupgrade
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4 使用pyupgrade更新Python语法
- en: Part of what makes a language evolve is not only the features it provides but
    the syntax you use to write programs. Syntax sugar is added over time to make
    certain constructs easier, and sometimes using the built-in syntax of a new language
    version is faster or more correct than an older, manual way of doing the same
    thing. In some cases, new syntax even makes things possible that simply weren’t
    before.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使语言演变的部分原因不仅在于它提供的功能，还在于您用来编写程序的语法。随着时间的推移，语法糖被添加进来，使得某些结构更容易实现，有时使用新语言版本的内置语法比旧的手动方式更快或更正确。在某些情况下，新的语法甚至使得以前不可能的事情成为可能。
- en: pyupgrade ([https://github.com/asottile/pyupgrade](https://github.com/asottile/pyupgrade))
    updates the syntax of your Python code to take advantage of newer syntax available
    in the Python versions your project supports. Just like black, pyupgrade uses
    the abstract syntax tree to ensure that the old and the new code are functionally
    equivalent. Also, like black, you need only run the pyupgrade command by telling
    it which versions of Python need to remain supported after any changes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: pyupgrade ([https://github.com/asottile/pyupgrade](https://github.com/asottile/pyupgrade))
    更新你的Python代码的语法，以利用你的项目支持的Python版本中可用的较新语法。就像black一样，pyupgrade使用抽象语法树来确保新旧代码在功能上是等效的。同样，像black一样，你只需要运行pyupgrade命令，并告诉它需要在任何更改后继续支持哪些Python版本。
- en: Like code formatting, updating syntax might be something you want to stay out
    of your way until your code is functional, tested, type checked, and so on. This
    could be best handled by using pre-commit hooks in your repository. Read on through
    the next section to set up a hook that leverages pyupgrade.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 就像代码格式化一样，更新语法可能是在你的代码功能、测试、类型检查等完成之前你不想让它打扰你的事情。这最好通过在仓库中使用pre-commit钩子来处理。继续阅读下一节，以设置一个利用pyupgrade的钩子。
- en: 9.5 Reducing rework using pre-commit hooks
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5 使用pre-commit钩子减少返工
- en: '*Pre-commit hooks* are executable code that runs when you attempt to commit
    changes to a version-control system. Git has native support for hooks into various
    parts of the version-control lifecycle, with pre-commit being a popular one because
    of its ability to shift some code quality checks earlier in the development process,
    giving you a tighter feedback loop. These hooks can help stop improper code from
    making it into the repository in the first place. You can create your own fully
    custom hooks, but Git doesn’t force other developers to install these hooks, and
    managing many disparate hooks can become cumbersome over time.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*Pre-commit hooks* 是在你尝试将更改提交到版本控制系统时运行的可执行代码。Git对版本控制生命周期的各个部分提供了原生的钩子支持，其中pre-commit因其能够在开发过程中较早地转移一些代码质量检查的能力而变得流行。这些钩子可以帮助阻止不适当的代码最初就进入仓库。你可以创建自己的完全定制的钩子，但Git不会强迫其他开发者安装这些钩子，随着时间的推移，管理许多不同的钩子可能会变得繁琐。'
- en: 'pre-commit ([https://pre-commit.com/](https://pre-commit.com/)) is a framework
    for managing pre-commit hooks. It provides several nice improvements over dealing
    with Git hooks natively, as described here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: pre-commit ([https://pre-commit.com/](https://pre-commit.com/)) 是一个用于管理pre-commit钩子的框架。它提供了比原生处理Git钩子更好的几个改进，如以下所述：
- en: Hooks can be installed from repositories on the internet, creating a plugin-based
    architecture.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钩子可以从互联网上的仓库中安装，创建一个基于插件的架构。
- en: Most hooks run in an isolated container, decreasing the likelihood that they
    act on anything but the repository in which they’re installed.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数钩子在隔离的容器中运行，这降低了它们对安装它们的仓库之外的内容产生影响的可能性。
- en: Most hooks run only on changed files, which is useful for expensive checks.
    You can still run them across all files when desired.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数钩子仅在更改的文件上运行，这对于昂贵的检查很有用。当你需要时，你仍然可以在所有文件上运行它们。
- en: Important Before reading on, visit appendix B to install the tools you’ll need
    for this chapter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 重要：在继续阅读之前，请访问附录B以安装本章所需的工具。
- en: 'To get started configuring pre-commit, create a new .pre-commit-config.yaml
    file. In this YAML file, you need to use the following keys:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始配置pre-commit，创建一个新的`.pre-commit-config.yaml`文件。在这个YAML文件中，你需要使用以下键：
- en: '`repos`—The list of repositories from which to fetch pre-commit hooks.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repos`—要从中获取pre-commit钩子的仓库列表。'
- en: '`repo`—The repository for a specific hook, such as a URL.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repo`—特定钩子的仓库，例如URL。'
- en: '`rev`—The revision of the hook to use. This revision is typically one of the
    Git tags in the specified repository.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rev`—要使用的钩子版本。这个版本通常是特定仓库中的一些Git标签之一。'
- en: '`hooks`—The list of hooks to use from the specified repository.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hooks`—从指定仓库中要使用的钩子列表。'
- en: '`id`—The unique identifier of a hook supplied by the specified repository.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`—由指定仓库提供的钩子的唯一标识符。'
- en: '`args`—Additional arguments to pass to the hook when it runs.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`—在钩子运行时传递给钩子的额外参数。'
- en: Tip For a comprehensive list of all available configurations, refer to the pre-commit
    documentation ([http://mng.bz/822D](http://mng.bz/822D)).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：要获取所有可用配置的完整列表，请参阅pre-commit文档([http://mng.bz/822D](http://mng.bz/822D))。
- en: 'Create your first hook configuration for pyupgrade. Fill in the .pre-commit-config.yaml
    file with the following information:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为pyupgrade创建你的第一个钩子配置。在`.pre-commit-config.yaml`文件中填写以下信息：
- en: The repository for pyupgrade is [https://github.com/asottile/pyupgrade](https://github.com/asottile/pyupgrade).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pyupgrade 的仓库是 [https://github.com/asottile/pyupgrade](https://github.com/asottile/pyupgrade)。
- en: The latest revision available as of this writing is `v2.31.0`.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书写时最新的版本是 `v2.31.0`。
- en: The identifier for the hook is `pyupgrade`.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钩子的标识符为 `pyupgrade`。
- en: The arguments to pyupgrade indicate the Python versions you want to support.
    As an example, `--py37-plus` supports Python 3.7 and up. `--py3-plus` supports
    all versions of Python 3\. The versions you specify here should agree with the
    versions you specified for black in pyproject.toml as well as the versions you
    specified in your tox `envlist`.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给 pyupgrade 的参数表示您想要支持的 Python 版本。例如，`--py37-plus` 支持 Python 3.7 及以上版本。`--py3-plus`
    支持所有 Python 3 版本。您在这里指定的版本应与您在 pyproject.toml 中为 black 指定的版本以及您在 tox `envlist`
    中指定的版本一致。
- en: After you finish your pyupgrade configuration, it should look similar to the
    following listing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成您的 pyupgrade 配置后，它应该看起来类似于以下列表。
- en: Listing 9.2 An example pre-commit configuration that uses pyupgrade
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 使用 pyupgrade 的示例预提交配置
- en: '[PRE3]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The list of all hooks repos
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 所有钩子仓库列表
- en: ❷ The pyupgrade repository
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ pyupgrade 仓库
- en: ❸ The version of the pyupgrade hooks
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ pyupgrade 钩子的版本
- en: ❹ The list of hooks to use
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 要使用的钩子列表
- en: ❺ pyupgrade’s main hook
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ pyupgrade 的主要钩子
- en: ❻ Arguments to pass to the hook’s command
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 传递给钩子命令的参数
- en: After you create a configuration for your repository, install pre-commit into
    your repository so it can manage pre-commit hooks by running the `pre-commit install`
    command in the root directory of your project. After you install pre-commit hooks,
    any new commits you make will trigger the hooks to run against the changed files.
    To run pre-commit hooks against all files in your project, you can run the `pre-commit
    run --all-files` command. Run it now, and observe whether pyupgrade makes any
    syntax changes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在为您的仓库创建配置后，通过在项目根目录中运行 `pre-commit install` 命令将 pre-commit 安装到您的仓库中，以便它可以管理预提交钩子。在安装预提交钩子后，您所做的任何新提交都会触发钩子对更改的文件运行。要针对您项目中的所有文件运行预提交钩子，您可以运行
    `pre-commit run --all-files` 命令。现在运行它，并观察 pyupgrade 是否进行了任何语法更改。
- en: Exercise 9.3
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.3
- en: A growing number of tools provides pre-commit hooks. flake8 ([https://github.com/pycqa/flake8](https://github.com/pycqa/flake8))
    and black ([https://github.com/psf/black](https://github.com/psf/black)) both
    provide pre-commit hooks. The configuration of these hooks is nearly identical,
    with any specifics for `args` or other keys being tool-specific. Add a hook for
    flake8 and black to your pre-commit configuration now. black and flake8 configurations
    are included in the code companion. You should read the documentation for your
    favorite tools to see whether and how to use them as pre-commit hooks.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的工具提供了预提交钩子。flake8 ([https://github.com/pycqa/flake8](https://github.com/pycqa/flake8))
    和 black ([https://github.com/psf/black](https://github.com/psf/black)) 都提供了预提交钩子。这些钩子的配置几乎相同，其中
    `args` 或其他键的具体配置因工具而异。现在将 flake8 和 black 的钩子添加到您的 pre-commit 配置中。black 和 flake8
    的配置包含在代码伴侣中。您应该阅读您喜欢的工具的文档，以了解是否以及如何将它们用作预提交钩子。
- en: Although pre-commit hooks might feel like they’re a big productivity boost,
    it’s important to recognize that if they become too expensive and slow to run,
    they can have a nasty backfire effect. Even though your intent is to provide a
    tighter feedback loop on small, independent commits, slow commit hooks can encourage
    people to avoid committing until they’ve done all their work. Find a balance between
    how valuable each of the checks you install are and how long they take to execute.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然预提交钩子可能感觉像是大幅提高生产力的工具，但重要的是要认识到，如果它们变得过于昂贵且运行缓慢，它们可能会产生不良的反效果。即使你的意图是提供对小型独立提交的更紧密的反馈循环，缓慢的提交钩子也可能鼓励人们等到他们完成所有工作后再进行提交。在安装的每个检查的价值和它们执行所需的时间之间找到一个平衡点。
- en: You now have security scanning for your code and its dependencies, monotonically
    increasing test coverage, the latest and greatest Python syntax, and a way to
    prevent some common mistakes from even being committed to the repository in the
    first place. This will reduce a fair amount of noise in your project over its
    lifetime and help you proactively evolve over time to avoid the threat model of
    decay. In the next chapter, you’ll revisit some of what you’ve learned and extract
    a template so you can create this same experience across any new project you create.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以对代码及其依赖项进行安全扫描，实现单调递增的测试覆盖率，最新的Python语法，以及防止一些常见错误被提交到仓库的方法。这将减少项目在其生命周期中的大量噪音，并帮助你积极进化，避免衰败的威胁模型。在下一章中，你将回顾你所学的一些内容，并提取一个模板，以便你可以在创建的任何新项目中复制这种相同的体验。
- en: Answers to exercises
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习题答案
- en: '**9.1**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**9.1**'
- en: 18.0.0, 17.9.0, 17.8.4
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 18.0.0, 17.9.0, 17.8.4
- en: 1.0.0, 0.5.0, 0.4.7
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1.0.0, 0.5.0, 0.4.7
- en: 2.0.0, 1.1.0, 1.0.20
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2.0.0, 1.1.0, 1.0.20
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Software dependencies form a graph, and project authors should take care to
    constrain their dependencies as little as possible for maximum interoperability
    with other packages.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件依赖形成一个图，项目作者应尽量减少对依赖的限制，以实现与其他包的最大互操作性。
- en: Dependencies impact your project through security vulnerabilities and staleness.
    Update them regularly to avoid headaches down the road.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项通过安全漏洞和过时性影响你的项目。定期更新它们，以避免未来出现头痛问题。
- en: Don’t try to achieve 100% test coverage, especially on existing projects. Instead,
    use coverage thresholds for incremental and monotonically increasing coverage
    over time.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要试图达到100%的测试覆盖率，尤其是在现有项目中。相反，使用覆盖率阈值，随着时间的推移实现增量且单调递增的覆盖率。
- en: Pre-commit hooks help you prevent improper code from being committed in the
    first place, but you should use them judiciously to encourage frequent, small
    commits.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预提交钩子可以帮助你防止不适当的代码被提交，但你应谨慎使用它们，以鼓励频繁的小型提交。
