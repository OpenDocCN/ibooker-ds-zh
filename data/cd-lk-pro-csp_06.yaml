- en: 4 Manage your unmanaged resources!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 管理你的非托管资源！
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Discovering the underlying type of an object at compile time and run time
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译时和运行时发现对象的底层类型
- en: Writing code that uses `IDisposable` and `using` statements to dispose of unmanaged
    resources
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写使用 `IDisposable` 和 `using` 语句来释放非托管资源的代码
- en: Using method and constructor overloading
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法和构造函数重载
- en: Using attributes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性
- en: Accepting a JSON or XML input in an endpoint and parsing it into a custom object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在端点中接受 JSON 或 XML 输入并将其解析为自定义对象
- en: In chapter 3, the CEO of Flying Dutchman Airlines, Aljen van der Meulen, assigned
    us a project to revamp Flying Dutchman Airlines’ backend service so that the company
    can integrate with a third-party system (a flight aggregator called FlyTomorow).
    We were given an OpenAPI specification and took a look at the database schema
    and the configuration, model, and view classes. Figure 4.1 shows where we are
    in the scheme of the book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 章，飞荷兰人航空公司的首席执行官 Aljen van der Meulen 分配给我们一个项目，即重新设计飞荷兰人航空公司的后端服务，以便该公司可以与第三方系统（一个名为
    FlyTomorow 的航班聚合器）集成。我们得到了一个 OpenAPI 规范，并查看了数据库模式以及配置、模型和视图类。图 4.1 显示了我们在本书结构中的位置。
- en: '![](../Images/04_01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04_01.png)'
- en: Figure 4.1 In this chapter, we’ll bring part 2 to a close. We’ll look at the
    existing codebase’s controller class and discuss potential improvements we can
    make to the code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 在本章中，我们将结束第 2 部分。我们将查看现有的代码库的控制器类，并讨论我们可以对代码进行的潜在改进。
- en: WARNING This chapter deals with the existing codebase written in the .NET Framework.
    This means that we will see sloppy and incorrect code, diversions from the given
    requirements, and all-around bad things. We will fix them all in later chapters
    and migrate to .NET 5.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 本章涉及用 .NET Framework 编写的现有代码库。这意味着我们将看到混乱和不正确的代码、偏离给定要求以及各种不良情况。我们将在后面的章节中修复这些问题，并迁移到
    .NET 5。
- en: 'Our understanding of the existing codebase is gradually increasing, and we
    have almost covered the entirety of it. In this chapter, we’ll look at the last
    remaining part (the only controller in the codebase) and dive into the endpoints
    one by one as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对现有代码库的理解逐渐加深，我们几乎覆盖了它的全部内容。在本章中，我们将查看最后剩下的部分（代码库中的唯一控制器）并逐个深入探讨端点，如下所示：
- en: '`GET /flight`—This endpoint allows users to get information on all flights
    in the database.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /flight`—此端点允许用户获取数据库中所有航班的详细信息。'
- en: '`GET /flight/{flightNumber}`—This endpoint allows users to retrieve information
    about a specific flight, given a flight number.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /flight/{flightNumber}`—此端点允许用户在给定航班号的情况下检索特定航班的详细信息。'
- en: '`POST /flight/{flightNumber}`—This endpoint allows users to book flights when
    given a flight number.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /flight/{flightNumber}`—此端点允许用户在给定航班号时预订航班。'
- en: '`DELETE /Flight/{flightNumber}`—This endpoint allows the user to delete a flight
    from the database when given a flight number.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE /Flight/{flightNumber}`—此端点允许用户在给定航班号时从数据库中删除航班。'
- en: We’ll also discuss connection strings, enumerable types, garbage collection,
    method overloading, static constructors, method attributes, and much more. After
    reading this chapter, you should have a clear idea of where we can make improvements,
    what improvements we can make, and why.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论连接字符串、可枚举类型、垃圾回收、方法重载、静态构造函数、方法属性等等。阅读本章后，你应该清楚地了解我们可以进行哪些改进，我们可以做出哪些改进，以及为什么。
- en: '4.1 The FlightController: Assessing the GET /flight endpoint'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 飞行控制器：评估 GET /flight 端点
- en: 'Now we come to the meat and potatoes of the codebase we are supposed to fix
    and polish. As we learned in chapter 3, FlyTomorrow plans to use this endpoint
    to display all the possible flights users can book. The question before us is
    this: how close does the original codebase get to that intent?'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了我们应当修复和润色的代码库的核心部分。正如我们在第 3 章中学到的，FlyTomorrow 计划使用此端点来显示所有可能的航班供用户预订。我们面前的问题是：原始代码库在多大程度上接近了这一意图？
- en: 'The previous chapter covered the database schema, configuration, and supporting
    models. That’s all very important stuff, but we want to actually process some
    data (or book some flights) with all these models, schemas, and configurations.
    This is where a controller comes in (within the context of an MVC pattern), and
    this codebase has only one: FlightController.cs. This code is larger than the
    previous code files, so make sure you read through the code carefully. Combing
    through the code in this way gives us a very clear understanding of where we can
    make improvements and bug fixes.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章涵盖了数据库模式、配置和支持模型。这些都是非常重要的内容，但我们实际上想要使用所有这些模型、模式和配置来处理一些数据（或预订航班）。这就是控制器（在
    MVC 模式下）发挥作用的地方，而这个代码库只有一个：FlightController.cs。这段代码比之前的代码文件要大，所以请确保仔细阅读代码。以这种方式审查代码让我们非常清楚地了解我们可以进行改进和错误修复的地方。
- en: 4.1.1 The GET /flight endpoint and what it does
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 GET /flight 端点和它所执行的操作
- en: 'In this section, we’ll explore the `FlightController` class by way of the first
    endpoint: the `GET flight`, as shown in listing 4.1\. We’ll see how you can utilize
    a method attribute to generate documentation on the fly, how we can determine
    the type of an object at run time and compile time, why you may not want to hardcode
    a database connection string, and how to return an HTTP status from a controller.
    Hopefully, after looking over the existing code, we’ll get a sense of where we
    can make improvements and why we would want to make them.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过第一个端点：`GET flight`（如列表 4.1 所示），来探索 `FlightController` 类。我们将看到如何利用方法属性来动态生成文档，如何确定对象的运行时和编译时类型，为什么你可能不想硬编码数据库连接字符串，以及如何从控制器返回
    HTTP 状态码。希望在我们审查现有代码后，我们能感受到我们可以进行改进的地方以及为什么我们想要进行这些改进。
- en: Listing 4.1 FlightController.cs `GET` `/flight`
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 FlightController.cs `GET` `/flight`
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ A comment that attempts to describe the code. We should remove comments like
    this.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个试图描述代码的注释。我们应该移除这样的注释。
- en: ❷ Generates documentation on the fly
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 动态生成文档
- en: ❸ This connection string is hardcoded, which is a security problem.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这个连接字符串是硬编码的，这是一个安全问题。
- en: ❹ The using statement is used for disposing of disposable objects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用语句用于处理可处置对象。
- en: ❺ Opens the connection to the database
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 打开到数据库的连接
- en: ❻ Sets up a GET SQL query
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 设置一个 GET SQL 查询
- en: ❼ Reads the database return
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 读取数据库返回结果
- en: ❽ An alternative method to dispose of objects
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 处理对象的另一种方法
- en: ❾ For every flight, gets the destination Airport details
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 对于每趟航班，获取目的地机场的详细信息
- en: ❿ For every flight, gets the origin Airport details
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 对于每趟航班，获取出发机场的详细信息
- en: ⓫ Adds the resulting view to an internal collection
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 将生成的视图添加到内部集合中
- en: ⓬ Returns an HTTP 200 and the flights
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 返回 HTTP 200 状态码和航班信息
- en: '4.1.2 Method signature: The meaning of ResponseType and typeof'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 方法签名：ResponseType 和 typeof 的含义
- en: Welcome to the deep end. Listing 4.1 is a fair bit of code with a lot of things
    that may be new to us. All endpoints in the controller look similar to this one.
    They all use the same patterns to get and return the data, so after we fully understand
    what is happening here, the other endpoints are going to be a breeze.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到深入学习的部分。列表 4.1 是一段相当多的代码，其中包含许多对我们来说可能很新的内容。控制器中的所有端点看起来都像这个一样。它们都使用相同的模式来获取和返回数据，所以在我们完全理解这里发生的事情之后，其他端点将会变得非常简单。
- en: 'In this section, we’ll look at the method signature of the `/flight`’s `Get`
    method. We’ll start by examining the `ResponseType` attribute, followed by a discussion
    on the `typeof` keyword and what it does. Last, we’ll glimpse how the `ResponseType`
    attribute uses the `IEnumerable` interface and `typeof` operator. What does the
    method signature look like? See the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看 `/flight` 的 `Get` 方法的方法签名。我们将首先检查 `ResponseType` 属性，然后讨论 `typeof`
    关键字及其作用。最后，我们将一瞥 `ResponseType` 属性如何使用 `IEnumerable` 接口和 `typeof` 操作符。方法签名看起来是什么样子？请看以下内容：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `ResponseType` attribute is used to generate documentation on the fly and
    is not often used in a situation where we deal with OpenAPI (or Swagger) specifications.
    This attribute is very helpful if you do not use some kind of automatic OpenAPI
    generation. The `ResponseType` attribute has no impact on what type we can return
    from the method but does require us to specify the type. The attribute then wraps
    our returned data into an `HTTPResponseMessage` type and returns out of the method.
    To figure out what type an instance is, we can use the `typeof` operator, into
    which we can pass an argument to be tested. The `typeof` operator returns an instance
    of `System.Type`, which contains data that describes the type you passed into
    the `typeof` operator. This is done by the compiler at compile time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResponseType` 属性用于动态生成文档，并且在我们处理 OpenAPI（或 Swagger）规范的情况下不常使用。如果你不使用某种自动 OpenAPI
    生成工具，这个属性非常有用。`ResponseType` 属性不会影响我们从方法中返回的类型，但确实要求我们指定类型。该属性会将我们返回的数据包装成 `HTTPResponseMessage`
    类型，并从方法中返回。为了确定一个实例的类型，我们可以使用 `typeof` 操作符，我们可以向其中传递要测试的参数。`typeof` 操作符返回一个 `System.Type`
    类型的实例，它包含描述传递给 `typeof` 操作符的类型的数据。这是在编译时由编译器完成的。'
- en: '| ![](../Images/LightBulb.png)   | READONLY AND CONST Expression and statement
    values determined at compile time can be assigned to both `readonly` and `const`
    properties. Values determined dynamically at run time cannot be assigned to a
    `const` property because a constant cannot change after compile time, whereas
    a `readonly` property can be written to once (either at the declaration or in
    a constructor). Using `readonly` and `const` prevents reassignment at run time.
    In effect, this allows you to prohibit unwanted changes to your code, which enforces
    the intention that a value should not change at run time and could minimize the
    number of unintended side effects stemming from changes made by other developers.
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| ![灯泡](../Images/LightBulb.png)   | 在编译时确定的只读和常量表达式和语句值可以赋给 `readonly` 和 `const`
    属性。在运行时动态确定的值不能赋给 `const` 属性，因为常量在编译后不能改变，而 `readonly` 属性一旦声明或构造函数中写入后就可以被写入一次。使用
    `readonly` 和 `const` 可以防止在运行时重新赋值。实际上，这允许你禁止对代码进行不希望的改变，从而强制执行一个值在运行时不应该改变的意图，并可能最小化由其他开发者做出的更改引起的不期望的副作用数量。|'
- en: If we wanted to get the type of an instance at run time (through reflection,[¹](#pgfId-1182700)
    discussed in section 6.2.6), we could use the `GetType` method that the object
    type exposes (and because `object` is the base class of all types, as shown in
    figure 4.2, it is exposed on all types). If we were to omit the `typeof` operator,
    the attribute would cause a compiler error because `ResponseType` expects an instance
    of `System.Type`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在运行时获取一个实例的类型（通过反射，[¹](#pgfId-1182700) 在 6.2.6 节中讨论），我们可以使用对象类型公开的 `GetType`
    方法（因为 `object` 是所有类型的基类，如图 4.2 所示，它在所有类型上都是公开的）。如果我们省略了 `typeof` 操作符，由于 `ResponseType`
    期望一个 `System.Type` 类型的实例，这将导致编译器错误。
- en: '![](../Images/04_02.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片 04_02](../Images/04_02.png)'
- en: Figure 4.2 The common denominator of all types is `Object`. These screenshots
    were produced using Visual Studio’s Object Browser, which lets you inspect any
    object for its base types.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 所有类型的共同基类是 `Object`。这些截图是使用 Visual Studio 的对象浏览器生成的，它允许你检查任何对象及其基类型。
- en: NOTE You often encounter data structures that implement the `IEnumerable` interface
    directly or indirectly. The `IEnumerable` interface allows you to create enumerators
    to loop over collections in a variety of ways (most notably the `foreach` construct).
    If you want to create your own data structure that has an enumerator, just implement
    the `IEnumerable` interface.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你经常会遇到直接或间接实现 `IEnumerable` 接口的数据结构。`IEnumerable` 接口允许你以各种方式创建枚举器来遍历集合（最著名的是
    `foreach` 构造）。如果你想创建一个具有枚举器的自定义数据结构，只需实现 `IEnumerable` 接口即可。
- en: The `Get` method returns an instance of type `HttpResponseMessage`. This type
    contains the data used to return an HTTP response, including an HTTP status code
    and a JSON body.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get` 方法返回一个 `HttpResponseMessage` 类型的实例。该类型包含用于返回 HTTP 响应的数据，包括 HTTP 状态码和
    JSON 主体。'
- en: 4.1.3 Collecting flight information with collections
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 使用集合收集航班信息
- en: We are ready to dive into the `FlightController`’s `GET` method. In this section,
    we’ll take our first steps to return information on every flight in the database
    to our users. We’ll discuss the method instance collections we’ll use to achieve
    this goal, as well as the connection string that is hardcoded into the source
    code and why this is less than ideal.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备深入探讨 `FlightController` 的 `GET` 方法。在本节中，我们将迈出第一步，将数据库中每架飞机的信息返回给用户。我们将讨论我们将使用的方法实例集合来实现这一目标，以及硬编码到源代码中的连接字符串以及为什么这并不理想。
- en: 'Looking at the following first line of code, we see something that we could
    change:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码的第一行，我们看到一些可以改变的地方：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code declares a variable called `flightReturnViews` and assigns it to an
    empty instance of type `List` of `FlightReturnView`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了一个名为 `flightReturnViews` 的变量，并将其分配给一个空的 `FlightReturnView` 类型的 `List` 实例。
- en: NOTE I prefer using explicit types instead of the `var` keyword. To me, it makes
    the code more readable because I can easily spot what type I am working with.
    In this book, I use explicit typing, but you could definitely use the `var` keyword
    if you’d like. The code will generally run fine whether you use explicit typing,
    implicit typing, or a mix of both. Opinions vary greatly, and discussions inevitably
    heat up on whether to use the `var` keyword. It’s up to you to pick which one
    to use in what scenario.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我更喜欢使用显式类型而不是 `var` 关键字。对我来说，这使代码更易于阅读，因为我可以轻松地找到我正在使用的类型。在这本书中，我使用显式类型，但如果你愿意，当然可以使用
    `var` 关键字。无论你使用显式类型、隐式类型还是两者的混合，代码通常都能正常运行。意见差异很大，关于是否使用 `var` 关键字的讨论不可避免地会变得激烈。选择哪种方式取决于你，以及你将在何种场景下使用它。
- en: '| ![](../Images/LightBulb.png)   |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| ![灯泡](../Images/LightBulb.png)   |'
- en: The var keyword
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 关键字'
- en: 'Using the `var` keyword is a quick and easy way to declare variables. The compiler
    infers the type and you can move on. The other side of the story is that using
    the `var` keyword can lead to unnecessary ambiguity. For example, compare the
    following two statements:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 关键字是声明变量的快捷且简单的方式。编译器会推断类型，然后你可以继续前进。故事的另一面是，使用 `var` 关键字可能会导致不必要的歧义。例如，比较以下两个语句：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you were to use the `var` keyword, you would have to look into the `ProcessGrades`
    method to find out what the return type is. This promotes the idea of not needing
    to know any implementation details on the code you call. On the other hand, if
    you explicitly write down the return type as part of the variable declaration,
    you always know what type you are operating on. Knowing the type could allow us
    to make different decisions on how to implement a certain piece of code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `var` 关键字，你必须查看 `ProcessGrades` 方法以找出返回类型。这促进了不需要知道你调用的代码的任何实现细节的想法。另一方面，如果你在变量声明中显式地写下返回类型，你总是知道你正在操作的类型。了解类型可能允许我们根据如何实现特定的代码块做出不同的决策。
- en: The `var` keyword can help you write code faster and, depending on your background,
    more intuitively. Sometimes, you don’t need to know the underlying type—you just
    want to get on with writing your code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`var` 关键字可以帮助你更快地编写代码，并且根据你的背景，更加直观。有时，你不需要知道底层类型——你只想继续编写你的代码。'
- en: '|'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'The next two lines share a similar story:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行有相似的故事：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Take a minute to look over the two variables `flights` and `connectionString`,
    and think about ways to improve the code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 花一分钟时间查看两个变量 `flights` 和 `connectionString`，并思考改进代码的方法。
- en: 4.1.4 Connection strings, or how to give a security engineer a heart attack
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.4 连接字符串，或如何让安全工程师心惊胆战
- en: When considering the hardcoded connection string in section 4.1.3, what went
    through your mind? Did you see any problems with this? If so, what were they?
    The problem is not with the actual content of the connection string. The connection
    details are correct, and we want to have a list holding objects of type `Flight`.
    The problem is that we have a hardcoded connection string in our controller.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑第 4.1.3 节中的硬编码连接字符串时，你脑海中想的是什么？你是否看到了任何问题？如果有，它们是什么？问题不在于连接字符串的实际内容。连接细节是正确的，我们想要有一个包含类型为
    `Flight` 的对象的列表。问题在于我们在控制器中有一个硬编码的连接字符串。
- en: 'A hardcoded connection string is usually a major security and operational vulnerability.
    Imagine committing this code to a source control system and having it accidentally
    available for the public to see. It may be an unlikely scenario, but I have seen
    it happen once or twice (and may have caused it myself once). Now you have opened
    yourself up to all kinds of nasty things when it comes to your database. If that
    doesn’t convince you, let me try this: you’ve hardcoded your connection string
    instead of pulling it from some central storage (be it a config file or an environment
    variable injected in a containerized environment), and a different developer accidentally
    backspaces one too many times and deletes part of the connection string. Of course,
    the developer didn’t run any tests, and the code was reviewed and merged when
    you were on vacation. Now everything is broken. The moral of the story is this:
    it’s a small effort to not hardcode your connection strings (we’ll see how to
    use local environment variables for connection strings in section 5.3.3).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 固定的连接字符串通常是一个重大的安全和操作漏洞。想象一下，将此代码提交到源代码控制系统，并意外地使其对公众可见。这可能是一个不太可能的情况，但我见过一两次（也可能有一次是我自己造成的）。现在，当涉及到你的数据库时，你已暴露了自己面临各种糟糕的事情。如果这还不能说服你，让我试试这个：你将连接字符串硬编码，而不是从某个中央存储（无论是配置文件还是注入到容器化环境中的环境变量）中获取，而另一个开发者不小心多按了几次退格键，删除了连接字符串的一部分。当然，开发者没有运行任何测试，而且代码在你休假时被审查和合并。现在一切都坏了。这个故事的意义在于：不硬编码连接字符串只需要一点小小的努力（我们将在第
    5.3.3 节中看到如何使用本地环境变量来设置连接字符串）。
- en: NOTE The connection string listed in this chapter is, in fact, the correct connection
    string for use with our database. The database is deployed through Microsoft Azure
    and publicly accessible. If you cannot connect (or do not want to) to the database,
    a local SQL version of the database is provided with the source code files of
    this book. Instructions on installing and spinning up a local version of the deployed
    database are in appendix C.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中列出的连接字符串实际上是用于我们数据库的正确连接字符串。数据库通过 Microsoft Azure 部署，并公开可访问。如果您无法连接（或不想连接）到数据库，本书源代码文件中提供了一个本地
    SQL 版本的数据库。有关安装和启动部署数据库的本地版本的说明见附录 C。
- en: Instead of hardcoding a connection string, it would be better to either
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与硬编码连接字符串相比，更好的做法是：
- en: Store the connection strings in some kind of configuration file, or
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将连接字符串存储在某种配置文件中，或者
- en: Access them through an environment variable
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过环境变量访问它们
- en: We’ll explore the trade-offs between these two approaches when it comes time
    for us to fix this security issue.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们修复这个安全问题的时候，我们将探索这两种方法之间的权衡。
- en: 4.1.5 Using IDisposable to release unmanaged resources
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.5 使用 `IDisposable` 释放非托管资源
- en: The next code block is a statement that wraps some logic, and we have seen something
    like it before. This section deals with the `using` statement, shown next, and
    the `IDisposable` interface. We’ll learn how they tie into garbage collection
    and how to use them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块是一个包含某些逻辑的语句，我们之前见过类似的东西。本节将处理下面的 `using` 语句和 `IDisposable` 接口。我们将了解它们如何与垃圾回收器相关联以及如何使用它们。
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When we use a `using` statement in this way, we scope the enclosing variable
    to the `using` code block and automatically dispose of it when we are through
    with the `using` block. So, in this example, the connection variable of type `SqlConnection`
    is designated as ready for garbage collection once we reach the closing bracket
    of the `using` statement.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以这种方式使用 `using` 语句时，我们将封装变量的作用域限制在 `using` 代码块内，并在我们完成 `using` 块后自动释放它。因此，在这个例子中，一旦我们到达
    `using` 语句的结束括号，`SqlConnection` 类型的连接变量就被指定为准备进行垃圾回收。
- en: But why is this important? C# is a managed language with a garbage collector
    that is supposed to handle this for us. This means we do not have to do manual
    memory allocation and deallocation like you would do in an unmanaged language
    like C. Sometimes, though, we need to help the garbage collector out a little
    bit when it could get confused. For example, how does the garbage collector know
    when it can collect on something if that something may need to live on beyond
    the current code block or variable scope?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但这为什么重要呢？C# 是一种托管语言，拥有垃圾回收器，它应该为我们处理这些事情。这意味着我们不需要像在 C 这样的非托管语言中那样进行手动内存分配和释放。然而，有时我们可能需要稍微帮助垃圾回收器，因为它可能会感到困惑。例如，如果某个东西可能需要超出当前代码块或变量作用域继续存在，垃圾回收器如何知道何时可以回收它呢？
- en: The .NET garbage collector scans the code during run time for objects that no
    longer have any “links” to them. These links can be things like method calls or
    variable assignments. To do this, it uses so-called generations. These generations
    are running “lists” of objects that are either ready for collection or may be
    ready for collection in the future. The longer the object has lived, the higher
    its generation (the garbage collector uses three generations in total). Objects
    in the third generation are visited less often by the garbage collector than earlier
    generations. Let’s say we have an object that holds a property of type integer,
    assigned a value of 3\. This property acts as a counter in a conditional. If this
    variable lives on for a while after the method is over (its variable scope is
    longer than the code block) waiting for the garbage collector to collect on it,
    it is no big deal. The amount of memory taken by the variable is small, and it
    is not blocking any other execution. When an object such as this has no remaining
    links (often because its variable scope has expired), the garbage collector flags
    the object as safe for collection, frees up the appropriate memory on its next
    iteration, and removes the corresponding entry from its generation lists.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: .NET垃圾回收器在运行时扫描代码，寻找不再有任何“链接”到它们的对象。这些链接可以是方法调用或变量赋值等。为了做到这一点，它使用所谓的代数。这些代数是运行中的“列表”，其中包含的对象要么准备好被收集，要么可能在将来准备好被收集。对象存活的时间越长，其代数（垃圾回收器总共使用三代）就越高。第三代中的对象比早期代数的对象被垃圾回收器访问的频率要低。假设我们有一个包含整型属性的对象，赋值为3。这个属性在条件中充当计数器。如果这个变量在方法结束后还存活一段时间（其变量作用域比代码块长），等待垃圾回收器收集它，这并不是什么大问题。变量占用的内存量很小，并且它没有阻止其他执行。当一个对象如这样没有剩余的链接（通常是因为其变量作用域已过期）时，垃圾回收器将该对象标记为可收集，在其下一次迭代中释放适当的内存，并从其代数列表中删除相应的条目。
- en: Now imagine we have a connection to a SQL database, as in the code on the previous
    page. If that connection were to “live on” beyond its intended use case, it could
    prove to be an issue. We may run into issues where the connection remains open,
    blocking other code to execute on the same database, or we may even open ourselves
    up to buffer overflow hacks. To combat such a memory leak, we dispose of resources
    that are “unmanaged.” Unlike managed resources, which are garbage-collected anytime
    after the variable scope has concluded, we need to deal with unmanaged resources
    more directly. Yet, disposing of unmanaged resources correctly is an easy thing
    to forget. Typically, we want to dispose of an unmanaged resource whenever we
    are done with it as opposed to when all references (or links) to the object have
    disappeared and the garbage collector says we are done with it. Unmanaged resources
    typically implement the `IDisposable` interface, so to free an unmanaged resource,
    we call the `Dispose` method.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们有一个与SQL数据库的连接，就像上一页的代码所示。如果这个连接超出了其预期的使用范围，可能会成为一个问题。我们可能会遇到连接保持打开的情况，阻止其他代码在同一个数据库上执行，或者我们甚至可能暴露于缓冲区溢出攻击。为了对抗这种内存泄漏，我们需要处理“未管理”的资源。与在变量作用域结束后任何时候都会被垃圾回收的托管资源不同，我们需要更直接地处理未管理资源。然而，正确地处理未管理资源是一件容易忘记的事情。通常，我们希望在完成对未管理资源的操作时释放它，而不是当所有对对象的引用（或链接）消失，垃圾回收器说我们已经完成时。未管理资源通常实现`IDisposable`接口，因此要释放未管理资源，我们需要调用`Dispose`方法。
- en: Freeing an unmanaged resource can take the form of calling the `Dispose` method
    at the end of the method. But what if you have branching code with multiple return
    opportunities? You would have to have multiple `Dispose` calls. That may work
    for small methods but can quickly get confusing when dealing with large code blocks
    of conditionals and multiple paths of traversal through your code. The `using`
    statement is a solution for that. Under the hood, the compiler converts the `using`
    statement to a `try-finally` code block. An example of this is shown in figure
    4.3.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 释放未管理的资源可以采取在方法末尾调用`Dispose`方法的形式。但如果你的代码中有分支结构，并且有多个返回点，你会需要多次调用`Dispose`。这可能适用于小方法，但当处理大块的条件代码和代码中的多个遍历路径时，可能会很快变得令人困惑。`using`语句是解决这个问题的方法。在底层，编译器将`using`语句转换为`try-finally`代码块。这在一个示例中如图4.3所示。
- en: '![](../Images/04_03.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04_03.png)'
- en: Figure 4.3 A `using` statement is converted to a `try-finally` block by the
    compiler. Using a `try-catch` allows us to abstract the manual `Dispose` call.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 编译器将 `using` 语句转换为 `try-finally` 块。使用 `try-catch` 允许我们抽象手动调用 `Dispose`。
- en: A `try-finally` is a subset of the `try-catch-finally` construct we often use
    when dealing with error handling. When we wrap code in a `try` code block, followed
    by a `catch` code block, if an exception is thrown, it is caught in the `catch`
    code block versus having our code hard-crash. A `finally` is an optional code
    block attached to the end of the `catch` that executes code as it leaves the code
    block, whether or not there was an error caught. We could call the `Dispose` method
    in the `finally` code block, ensuring that the `Dispose` method is always called
    after the method has been executed, no matter what the outcome is or if any errors
    were thrown.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`try-finally` 是我们在处理错误处理时经常使用的 `try-catch-finally` 构造的一个子集。当我们用 `try` 代码块包裹代码，然后是
    `catch` 代码块，如果抛出异常，它会在 `catch` 代码块中被捕获，而不是让我们的代码硬性崩溃。`finally` 是一个可选的代码块，附加在 `catch`
    的末尾，在离开代码块时执行代码，无论是否捕获到错误。我们可以在 `finally` 代码块中调用 `Dispose` 方法，确保无论结果如何或是否抛出任何错误，`Dispose`
    方法都会被调用。'
- en: NOTE Calling `Dispose` on a resource implementing `IDisposable` does not cause
    an immediate garbage collection to happen. We are merely flagging it safe for
    collecting and requesting for it to happen at the next opportunity to do so. No
    impromptu garbage collection is initiated, but we take the management of when
    the resource is determined safe for collection into our own hands as opposed to
    letting the garbage collector decide.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在实现 `IDisposable` 的资源上调用 `Dispose` 不会立即触发垃圾回收。我们只是在标记它为安全收集，并请求在下一个机会进行收集。不会启动即兴的垃圾回收，但我们把何时确定资源安全收集的管理权掌握在自己手中，而不是让垃圾回收器来决定。
- en: 4.1.6 Querying a database with SqlCommand
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.6 使用 SqlCommand 查询数据库
- en: The constructor for `SqlConnection` takes in a parameter of type `string` that
    represents the connection string for us to connect to. After entering the `using`
    block, we can now operate on our newly created `SqlConnection` and query the database.
    In the next code listing, the code opens a connection to the database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`SqlConnection` 的构造函数接受一个类型为 `string` 的参数，代表我们用来连接的连接字符串。进入 `using` 块后，我们现在可以操作我们新创建的
    `SqlConnection` 并查询数据库。在接下来的代码列表中，代码打开到数据库的连接。'
- en: 'Listing 4.2 FlightController.cs `GET` `Flight`: inside the `SqlConnection`
    `using` statement'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 FlightController.cs `GET` `Flight`：在 `SqlConnection` `using` 语句内
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Opens the database connection
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打开数据库连接
- en: ❷ Creates a SqlCommand with a SQL query to select all flights
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 SQL 查询创建一个 SqlCommand 来选择所有航班
- en: ❸ Creates new flight instances
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建新的航班实例
- en: ❹ Disposes of the cmd instance
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 释放 cmd 实例
- en: If the database cannot be reached through the provided connection string, the
    code throws an exception (which is unhandled). Following that, a `SqlCommand`
    is created with a query to select all records from the `Flight` table (`"SELECT
    * FROM Flight"`). The eagle-eyed reader might have spotted that a couple of lines
    down, `cmd.Dispose` is called. We would have to call `Dispose` on `reader` as
    well if we did not use a `using` statement. It looks like our predecessors were
    not consistent in using `using` statements or manual disposal requests. We are
    going to fix that. The code in listing 4.2 has a `using` statement that creates
    a `reader` object, rendered from the `cmd.ExecuteReader()` method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无法通过提供的连接字符串访问数据库，代码会抛出一个异常（未处理）。之后，创建一个 `SqlCommand`，查询从 `Flight` 表中选择所有记录（`"SELECT
    * FROM Flight"`）。细心的读者可能会注意到，向下几行，调用了 `cmd.Dispose`。如果我们没有使用 `using` 语句，我们还需要在
    `reader` 上调用 `Dispose`。看起来我们的前辈在使用 `using` 语句或手动释放请求方面并不一致。我们将解决这个问题。列表 4.2 中的代码有一个
    `using` 语句，它创建了一个 `reader` 对象，由 `cmd.ExecuteReader()` 方法生成。
- en: The `reader` allows us to parse the database response into a more manageable
    form. We can see this in action if we step inside the `using` statement, where
    we create a new `Flight` object, as shown in figure 4.4.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`reader` 允许我们将数据库响应解析成更易于管理的形式。如果我们进入 `using` 语句，创建一个新的 `Flight` 对象，我们可以看到这一点，如图
    4.4 所示。'
- en: '![](../Images/04_04.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04_04.png)'
- en: Figure 4.4 The scope of a variable created in a `using` statement. The `reader`
    instance is scoped to the `using` statement and is not accessible when the code
    leaves the `using` code block.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 在 `using` 语句中创建的变量的作用域。`reader` 实例的作用域限于 `using` 语句，当代码离开 `using` 代码块时不可访问。
- en: 'The `Flight` object takes three parameters, all 32-bit integers (`int`): `flightNumber`,
    `originID`, and `destinationID`. These also are the columns of our Flight table
    (if we take into account the slight misnaming we discussed earlier in this chapter).
    We know the order the columns are returned in, because we know the database schema.
    It probably would have been cleaner to specify what columns the query should return.
    If we explicitly say what columns we want to be returned, we can control the data
    flow better and know exactly what we are going to get. It does not require a developer
    unfamiliar with the code or database schema to do more research to find out what
    the expected returns are.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flight`对象接受三个参数，都是32位整数（`int`）：`flightNumber`、`originID`和`destinationID`。这些也是我们航班表中的列（如果我们考虑到本章前面讨论的轻微命名错误）。我们知道列的返回顺序，因为我们知道数据库模式。指定查询应返回的列可能更干净。如果我们明确说明我们想要返回的列，我们可以更好地控制数据流并确切知道我们将得到什么。这不需要对代码或数据库模式不熟悉的开发者进行更多研究以找出预期的返回值。'
- en: The code in listing 4.2 calls the `reader`’s `GetInt32` method and passes in
    the value’s index we are looking for. Once the `Flight` object is created, it
    is added to the `flights` collection. Moving on, take a minute to look over the
    code in listing 4.3\. Hopefully, you’ll see some very familiar things.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2中的代码调用`reader`的`GetInt32`方法并传入我们正在寻找的值的索引。一旦创建`Flight`对象，它就被添加到`flights`集合中。继续前进，花一分钟时间查看列表4.3中的代码。希望你会看到一些非常熟悉的东西。
- en: 'Listing 4.3 FlightController.cs `GET` `Flight`: getting the `Origin` `Airport`
    details'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3 FlightController.cs `GET` `Flight`：获取`Origin` `Airport`详情
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Creates a SQL query to select the City column of a specific Airport
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个SQL查询以选择特定机场的`City`列
- en: ❷ Executes the SqlCommand
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 执行SqlCommand
- en: ❸ Reads the response from the database
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从数据库读取响应
- en: ❹ Assigns the first element of the database response to returnView.Origin
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将数据库响应的第一个元素赋值给returnView.Origin
- en: 'The code in listing 4.3 creates a new `SqlCommand` to select the `City` column
    from the Airport table, where `AirportID` is equal to `flight.OriginID` (last
    time around it was the `flight.destination`). The code executes the `SqlCommand`
    and reads the return value into the `returnView.Origin` field. Then the code disposes
    of `SqlCommand` and adds the `returnView` to the `flightReturnViews` collection.
    And with that, we’ve finally come to the end of this endpoint. There’s only one
    more line of code to consider:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3中的代码创建了一个新的`SqlCommand`来从机场表中选择`City`列，其中`AirportID`等于`flight.OriginID`（上一次是`flight.destination`）。代码执行`SqlCommand`并将返回值读取到`returnView.Origin`字段中。然后代码释放`SqlCommand`并将`returnView`添加到`flightReturnViews`集合中。就这样，我们终于到达了这个端点的末尾。接下来只需考虑一行代码：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Remember when we looked at the method signature? We discovered that we are supposed
    to return a `HttpResponseMessage`, and that is exactly what `Request.CreateResponse`
    gives us.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们查看方法签名时吗？我们发现我们应该返回一个`HttpResponseMessage`，这正是`Request.CreateResponse`给我们的。
- en: TIP If you ever want to find out more about specific namespaces or classes of
    the .NET Framework, .NET Core, or .NET 5, the Microsoft online documentation is
    excellent and can be found at [https://docs.microsoft.com/en-us/](https://docs.microsoft.com/en-us/).
    For example, the .NET Framework documentation for `HttpRequest` is at [https://
    docs.microsoft.com/en-us/dotnet/api/system.web.httprequest?view=netframe work-4.8.](https://docs.microsoft.com/en-us/dotnet/api/system.web.httprequest?view=netframework-4.8)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你想知道更多关于.NET Framework、.NET Core或.NET 5的特定命名空间或类的信息，Microsoft在线文档非常出色，可以在[https://docs.microsoft.com/en-us/](https://docs.microsoft.com/en-us/)找到。例如，`HttpRequest`的.NET
    Framework文档在[https://docs.microsoft.com/en-us/dotnet/api/system.web.httprequest?view=netframework-4.8](https://docs.microsoft.com/en-us/dotnet/api/system.web.httprequest?view=netframework-4.8)。
- en: The `CreateResponse` method has several method overloads we can use, but for
    this, we want to pass in both an HTTP status code and an object to be serialized
    and returned to the caller.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateResponse`方法有几个方法重载我们可以使用，但为此，我们想要传递一个HTTP状态码和一个要序列化并返回给调用者的对象。'
- en: Method overloading and static constructors
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 方法重载和静态构造函数
- en: '*Method overloading*, also called *function overloading*, allows multiple methods
    with the same name (but different parameters) in the same class. This means that
    we can have the methods `public uint ProcessData(short a, byte b)` and `public
    uint ProcessData(long a, string b)` in the same class with no problem. When we
    call the `ProcessData` method, our request is routed by the CLR to the appropriate
    method based on the input parameter types. What we cannot do is have two (or more)
    methods with the same name and input parameters. The reason for this is that the
    method call then becomes ambiguous. How is the CLR supposed to know where to direct
    our call? This also means that if we have the methods `internal void GetZebra(bool
    isRealZebra)` and `internal bool GetZebra(bool isRealZebra)`, we get a compiler
    error. Just changing the return type does not make the call less ambiguous to
    the CLR.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法重载*，也称为*函数重载*，允许在同一个类中有多个具有相同名称（但参数不同）的方法。这意味着我们可以在同一个类中拥有`public uint ProcessData(short
    a, byte b)`和`public uint ProcessData(long a, string b)`这样的方法，而不会有问题。当我们调用`ProcessData`方法时，我们的请求由CLR根据输入参数类型路由到适当的方法。我们不能做的是有两个（或更多）具有相同名称和输入参数的方法。这是因为方法调用变得模糊不清。CLR应该如何知道我们的调用应该指向哪里？这也意味着如果我们有`internal
    void GetZebra(bool isRealZebra)`和`internal bool GetZebra(bool isRealZebra)`这样的方法，我们将得到编译器错误。仅仅改变返回类型并不能使调用对CLR来说不那么模糊。'
- en: '![](../Images/04_04_UN01.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04_04_UN01.png)'
- en: Overloading `ProcessData`. The compiler routes the `ProcessData` calls to the
    appropriate overloaded methods at compile time. A compiler error is generated
    if no overloaded method is matched.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 重载`ProcessData`。编译器在编译时将`ProcessData`调用路由到适当的重载方法。如果没有匹配的重载方法，将生成编译器错误。
- en: We can also overload constructors. We call this *constructor overloading*, but
    it is the same principle as method overloading. We can use overloaded constructors
    to have multiple paths to object instantiation. For constructors, there is also
    the `static` constructor. Because we are dealing with `static`, there can be only
    one static constructor, and, therefore, it cannot be overloaded. When instantiating
    a class or calling a static member on a class, a `static` constructor is always
    called before instantiation or static member access. We can have `static` constructors
    and regular constructors, but the runtime always calls the `static` (once) before
    the very first regular constructor you use. Consequently, a `static` constructor
    is always parameterless, and `static` constructors do not contain access modifiers
    (a static constructor is always public).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以重载构造函数。我们称这种做法为*构造函数重载*，但它的原理与方法重载相同。我们可以使用重载构造函数来有多个对象实例化的路径。对于构造函数，也存在`static`构造函数。因为我们处理的是`static`，所以只能有一个静态构造函数，因此它不能被重载。在实例化类或调用类上的静态成员之前，总是先调用`static`构造函数。我们可以有`static`构造函数和常规构造函数，但运行时总是在使用第一个常规构造函数之前调用`static`（一次）。因此，`static`构造函数总是无参数的，`static`构造函数不包含访问修饰符（`static`构造函数总是公共的）。
- en: '![](../Images/04_04_UN02.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04_04_UN02.png)'
- en: 'Static and default constructors. The static constructor is called first before
    any other constructor. Step 1: static constructor; step 2: default (or explicitly
    declared) constructors.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 静态和默认构造函数。静态构造函数在调用任何其他构造函数之前首先被调用。步骤1：静态构造函数；步骤2：默认（或显式声明）构造函数。
- en: For the Java programmers out there, note that Java’s anonymous static initialization
    block is equivalent to a static constructor in C#. C# can have only one static
    constructor, however, whereas Java can have multiple anonymous static initialization
    blocks.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些Java程序员，请注意，Java的匿名静态初始化块在C#中相当于静态构造函数。然而，C#只能有一个静态构造函数，而Java可以有多个匿名静态初始化块。
- en: To pass in a status code, we cannot simply pass in an integer. The `CreateResponse`
    method requires us to pass in our selection of the `HttpStatusCode` enum field,
    in this case, `HttpStatusCode.OK` (which maps to a status code of 200). And with
    the return executed, our job in this method is done.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要传递一个状态码，我们不能简单地传递一个整数。`CreateResponse`方法要求我们传递对`HttpStatusCode`枚举字段的选取，在这种情况下，`HttpStatusCode.OK`（映射到状态码200）。随着返回的执行，我们在这个方法中的工作就完成了。
- en: 'In summation: although the `GET` `Flight` endpoint had some good things about
    it, we saw plenty of opportunities to refactor and improve.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说：尽管`GET` `Flight`端点有其优点，但我们看到了许多重构和改进的机会。
- en: '4.2 The FlightController: Assessing GET /flight/{flightNumber}'
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 飞行控制器：评估GET /flight/{flightNumber}
- en: Now that we have looked at the endpoints to get all the flights from the database,
    let’s examine how the previous developers implemented the logic to get a specific
    flight from the database. In this section, we’ll explore the `GET flight/{flightNumber}`
    endpoint and consider its strengths and flaws. We’ll also consider whether we
    can remove extraneous comments and see an example of code as a narrative.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了端点以从数据库中获取所有航班信息，接下来让我们看看之前的开发者是如何实现从数据库中获取特定航班的逻辑。在本节中，我们将探讨`GET flight/{flightNumber}`端点，并考虑其优点和缺点。我们还将考虑是否可以移除多余的注释，并展示代码作为叙述的例子。
- en: 'In listing 4.4, we’ll lift the veil on the `GET /flight/{flightNumber}` endpoint
    and see familiar non-optimal practices, such as a hardcoded connection string.
    A lot of the code in listing 4.4 is code you should be able to read without a
    problem. The differences are in the details: we’ll discuss the abundance of comments,
    the `HttpResponseMessage` class, and assigning `null` to implicit types (denoted
    by the `var` keyword).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表4.4中，我们将揭开`GET /flight/{flightNumber}`端点的面纱，并看到熟悉的非最佳实践，例如硬编码的连接字符串。列表4.4中的大部分代码你应该都能轻松阅读。区别在于细节：我们将讨论注释的丰富性、`HttpResponseMessage`类以及将`null`赋值给隐式类型（由`var`关键字表示）。
- en: Listing 4.4 FlightController.cs `GET` `flight/{flightNumber}`
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4 FlightController.cs `GET` `flight/{flightNumber}`
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, 99% of the endpoint logic comprises patterns and code from
    the previous endpoint (listing 4.1), but there are some differences. The first
    is something we can find in the method signature, as shown next:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，99%的端点逻辑都由上一个端点（列表4.1）的模式和代码组成，但也有一些不同之处。第一个是我们可以在方法签名中找到的，如下所示：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `Get` `flight/{flightNumber}` endpoint takes in an argument of type `integer`,
    stored in a variable called `id`. This maps directly to the `{flightNumber}` in
    the API path: "`/flight/{flightNumber}"`. The other difference is the following
    declaration of a `Flight` object instead of a list of flights. This makes sense
    because we want to deal with only an individual flight, not a whole bunch.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get` `flight/{flightNumber}`端点接收一个类型为`integer`的参数，存储在一个名为`id`的变量中。这直接映射到API路径中的`{flightNumber}`："`/flight/{flightNumber}"`。另一个不同之处在于，这里声明了一个`Flight`对象而不是航班列表。这很有道理，因为我们只想处理单个航班，而不是一大堆。'
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It may look strange at first that the developers did not use the `var` keyword
    here, but that would not have compiled correctly. You cannot assign `null` to
    a variable declared with the `var` keyword, because when using `var`, the type
    is implicitly deduced from the assigned expression. Because `null` does not contain
    any type information, the developers had to declare the type for `flight` explicitly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 刚开始可能会觉得开发者在这里没有使用`var`关键字看起来有些奇怪，但那样是无法正确编译的。你不能将`null`赋值给用`var`关键字声明的变量，因为在使用`var`时，类型是隐式地从赋值表达式推导出来的。因为`null`不包含任何类型信息，开发者不得不显式地声明`flight`的类型。
- en: 'The code being very similar allows us to take a step back and uncover some
    other unclean bits of code without having to focus on what we already know. Foremost,
    what is up with the comments describing the logic? They are undoubtedly meant
    to act like breadcrumbs for you to follow as you struggle your way through the
    method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常相似，这使得我们可以退一步，发现一些其他不干净的代码片段，而无需专注于我们已经知道的内容。首先，关于逻辑的注释有什么问题？它们无疑是为了在你努力通过方法时，像面包屑一样引导你：
- en: '`// Get Flight`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`// 获取航班`'
- en: '`// Get Destination Airport Details`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`// 获取目的地机场详情`'
- en: '`// Get Origin Airport Details`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`// 获取出发机场详情`'
- en: Wouldn’t it be nice if we put those in little small methods that could be reused
    by other endpoints? I have done exactly that in listing 4.5\. Imagine a method
    that reads like a narrative or list of steps, containing only a couple of small
    methods, instead of the gigantic mess we have now. Listing 4.5 takes the code
    from listing 4.4 and imagines a world where a developer has extracted out internal
    details into separate methods, calling them in one public method. Compare listings
    4.5 and 4.4\. The difference in complexity is enormous. Of course, we are now
    using multiple database connections to retrieve the data related to one item.
    There’s always a drawback, and that is one that may be too much for some people
    to bear. All the logic dealing with the *how* of getting things from the database
    has been abstracted away into private methods. A developer who is not intimately
    familiar with this class can now look at this method and instantly know what it
    does without knowing all the implementation details. Knowing the general flow
    of the method is often more than enough knowledge for a developer to gain. Notice
    that there is no code dealing with connection strings, opening database connections,
    and disposing of objects in the public method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些放入可以由其他端点重用的小型方法中会怎么样？我在列表 4.5 中正是这样做的。想象一下一个像叙述或步骤列表一样的方法，它只包含几个小方法，而不是我们现在所拥有的巨大混乱。列表
    4.5 从列表 4.4 中提取代码，并想象一个开发者将内部细节提取到单独的方法中，在一个公共方法中调用它们。比较列表 4.5 和 4.4。复杂性的差异是巨大的。当然，我们现在正在使用多个数据库连接来检索与一个项目相关的数据。总是有缺点，那就是可能对某些人来说过于沉重。所有处理从数据库获取事物“如何”的逻辑都已被抽象到私有方法中。一个不熟悉这个类的开发者现在可以查看这个方法，并立即知道它做什么，而无需了解所有实现细节。了解方法的总体流程通常对开发者来说已经足够了。注意，在公共方法中没有处理连接字符串、打开数据库连接和释放对象的代码。
- en: Listing 4.5 Example of a cleaned-up FlightController.cs `GET` `flight/{flightNumber}`
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 清理后的 FlightController.cs `GET` `flight/{flightNumber}`
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Gets flight details from database
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从数据库获取航班详情
- en: ❷ Creates a new instance of FlightReturnView
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个新的 FlightReturnView 实例
- en: ❸ Populates the returnView’s FlightNumber field
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 填充 returnView 的航班号字段
- en: ❹ Populates the returnView’s Destination field
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 填充 returnView 的目的地字段
- en: ❺ Populates the returnView’s Origin field
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 填充 returnView 的出发地字段
- en: ❻ Returns an HTTP 200 and the returnView
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 返回 HTTP 200 状态码和 returnView
- en: In listing 4.5, I extracted all the nitty-gritty details into their own private
    methods. The method in listing 4.5 is far from perfect (there is no error handling,
    for starters), but it is an improvement.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 4.5 中，我将所有琐碎的细节提取到它们自己的私有方法中。列表 4.5 中的方法远非完美（首先没有错误处理），但它是一个改进。
- en: The next endpoint is a `POST` endpoint that creates a booking in the database.
    It is also similar but sees us dealing with JSON deserialization.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个端点是创建数据库中预订的 `POST` 端点。它与之前的端点类似，但这次我们处理了 JSON 反序列化。
- en: '4.3 The FlightController: POST /flight'
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 航班控制器：POST /flight
- en: 'We have seen logic to get flights in two ways: get all of them at once, or
    get a single one based on the flight number. But what if we want to book a flight?
    This section examines the `POST /flight` endpoint, shown in the next listing,
    which allows users to book a flight. It is similar to the previous endpoints but
    sees us dealing with JSON deserialization for the first time. Besides JSON deserializing,
    this section touches on the Don’t Repeat Yourself (DRY) principle and the `ModelState`
    static class. One thing to note, however, is that FlyTomorrow’s OpenAPI specification
    said we needed a `POST /booking` endpoint, not a `POST /flight` endpoint. Let’s
    make a note of that, and fix it when the time comes.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了两种获取航班逻辑：一次性获取所有航班，或者根据航班号获取单个航班。但如果我们想预订航班怎么办？本节检查了下一个列表中显示的 `POST /flight`
    端点，它允许用户预订航班。它与之前的端点类似，但这是第一次处理 JSON 反序列化。除了 JSON 反序列化之外，本节还涉及了 Don’t Repeat Yourself
    (DRY) 原则和 `ModelState` 静态类。然而，有一点需要注意，FlyTomorrow 的 OpenAPI 规范表示我们需要一个 `POST /booking`
    端点，而不是 `POST /flight` 端点。让我们记下这一点，并在适当的时候进行修复。
- en: Listing 4.6 FlightController.cs `POST` `/flight`
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 FlightController.cs `POST` `/flight`
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Gets the destination Airport from the database
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从数据库获取目的地机场
- en: ❷ Gets the origin Airport from the database
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从数据库获取出发地机场
- en: ❸ Gets the details of the flight we want to book
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取我们想要预订的航班的详细信息
- en: ❹ SQL query to count all customers in the database
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 数据库中所有客户的 SQL 查询
- en: ❺ Assigns the count of all customers in the database to newCustomerID
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将数据库中所有客户的数量分配给 newCustomerID
- en: ❻ SQL command to insert a new customer into the database
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 执行插入新客户到数据库的 SQL 命令
- en: ❼ Executes the command
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 执行命令
- en: ❽ Creates an internal Customer object that mimics the in-database one
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 创建一个模拟数据库中客户的内部客户对象
- en: ❾ Creates a booking in the database
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 在数据库中创建一个预订
- en: ❿ Returns an HTTP Status 201 and a message with sensitive customer data
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 返回 HTTP 状态 201 和包含敏感客户数据的信息
- en: 'That has got to be the longest, most convoluted endpoint we have seen yet.
    Because our previous approach proved somewhat successful, let’s rinse and repeat.
    Once again, we see a method signature with the `ResponseType` attribute applied:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这一定是迄今为止我们见过的最长、最复杂的端点。由于我们之前的方案证明是相当成功的，让我们再来一次。再次，我们看到一个带有`ResponseType`属性的`方法签名`：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is a mostly familiar story to us by now. We also return an `HttpResponseMessage`.
    But there is a difference in this method signature when compared to the endpoints
    we looked at before: the `Post` method takes in a parameter of type `Booking`,
    and there’s an attribute applied to this parameter as well.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这个故事对我们来说已经很熟悉了。我们也返回一个 `HttpResponseMessage`。但是，与之前我们查看的端点相比，这个方法签名有一个不同之处：`Post`
    方法接受一个类型为 `Booking` 的参数，并且这个参数上也有一个属性。
- en: NOTE You can apply attributes not only to methods but also to variables, classes,
    delegates, interfaces, and much more. You can’t use attributes on variables because
    all data related to an attribute must be known at compile time. This cannot be
    guaranteed for a variable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您不仅可以给方法应用属性，还可以给变量、类、委托、接口等等应用。您不能在变量上使用属性，因为与属性相关的所有数据必须在编译时已知。这不能保证对于变量。
- en: 'You can use the `FromBody` attribute to automatically parse an XML or JSON
    body into any class you want (as long as the properties match between the input
    and the specified class). Here, the sent-in JSON body is mapped by the CLR to
    an instance of the `Booking` class. This magical little attribute is one of the
    most time-saving things you encounter in C#. A valid JSON payload for this endpoint
    would be as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `FromBody` 属性自动将 XML 或 JSON 主体解析为任何您想要的类（只要输入和指定的类之间的属性匹配）。在这里，发送的 JSON
    主体被 CLR 映射到 `Booking` 类的一个实例。这个神奇的小属性是您在 C# 中遇到的最节省时间的事情之一。此端点的有效 JSON 有效载荷如下：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These values map directly to the fields in the `Booking` class. The .NET Framework
    takes the JSON and spits out our new `Booking` instance with those values, as
    shown in figure 4.5\. Because this process binds a parameter to a model, we call
    the mapping process *model binding*. We’ll dive deep into model binding in chapter
    14.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值直接映射到`Booking`类中的字段。.NET 框架将 JSON 解析并输出带有这些值的新的`Booking`实例，如图 4.5 所示。因为这个过程将一个参数绑定到一个模型上，所以我们称这个过程为*模型绑定*。我们将在第
    14 章深入探讨模型绑定。
- en: '![](../Images/04_05.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04_05.png)'
- en: Figure 4.5 Deserializing a JSON payload into a C# class. The `[FromBody]` attribute
    takes a JSON or XML body and parses it to a model.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 将 JSON 有效载荷反序列化为 C# 类。`[FromBody]` 属性接收一个 JSON 或 XML 主体并将其解析为模型。
- en: With model binding, we still rely on the quality of the input data. If the input
    data is missing a field, the underlying code for `[FromBody]` throws an exception,
    and the method automatically returns an HTTP status code of 400\. If all the fields
    are in the JSON body, but the CLR cannot parse one of the fields for whatever
    reason, the CLR sets the global `ModelState.IsValid` property to `false`. It is
    therefore always a good thing to check for this, and we’ll do that when we go
    to refactor this method.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模型绑定，我们仍然依赖于输入数据的质量。如果输入数据缺少字段，则 `[FromBody]` 的底层代码会抛出异常，并且方法会自动返回 HTTP 状态码
    400。如果所有字段都在 JSON 主体中，但 CLR 由于某种原因无法解析其中一个字段，CLR 将全局 `ModelState.IsValid` 属性设置为
    `false`。因此，始终检查这一点是个好主意，我们将在重构此方法时这么做。
- en: As we scan through the method, we quickly realize that we have seen this all
    before. In fact, until we hit the last code block of the method, everything is
    old news—an enormous warning sign that this code violates the DRY principle.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们扫描这个方法时，我们很快意识到我们以前见过这一切。事实上，直到我们到达方法的最后一个代码块，一切都是旧闻——这是一个巨大的警告信号，表明这段代码违反了
    DRY 原则。
- en: '| ![](../Images/ThumbsUp.png)   |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '![点赞](../Images/ThumbsUp.png)  '
- en: The Don’t Repeat Yourself principle
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 不要重复自己原则
- en: 'Previously, we discussed refactoring methods into small pieces. This results
    in methods that read like narratives, following a couple of simple steps to produce
    the output. We do this to increase readability, but there is another angle to
    examine: the DRY principle.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了将方法重构为小块。这导致的方法读起来像叙述，遵循几个简单的步骤来生成输出。我们这样做是为了提高可读性，但还有一个角度需要检查：DRY原则。
- en: 'DRY stands for “don’t repeat yourself” and was coined in the book *The Pragmatic
    Programmer* (Addison-Wesley, 1999), written by Andrew Hunt and Dave Thomas. Hunt
    and Thomas defined the DRY principle to mean that “Every piece of knowledge must
    have a single, unambiguous, authoritative representation within a system (27).”
    In practical terms, this often means that you write the same code only once. In
    other words: don’t duplicate code.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: DRY代表“不要重复自己”，这一概念首次出现在安德鲁·亨特和戴夫·托马斯合著的书籍《实用程序员》（Addison-Wesley，1999）中。亨特和托马斯将DRY原则定义为：“系统内每条知识都必须有一个单一、明确、权威的表示（27）。”在实践中，这通常意味着你只需编写一次相同的代码。换句话说：不要重复代码。
- en: 'If you find yourself, for example, copying and pasting the same `foreach` loop
    (perhaps with a different collection to iterate over) multiple times in the same
    method, class, or even codebase, extract it out into a dedicated method and call
    it. This does two things: first, it makes the methods calling this extracted method
    much easier to read because you have encapsulated implementation details. Second,
    if you ever need to change the implementation of this `foreach` loop, you have
    to do it in only one spot versus everywhere in your codebase. So, as with comedy,
    keep it DRY!'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你发现自己在同一方法、类甚至整个代码库中多次复制粘贴相同的`foreach`循环（可能迭代不同的集合），请将其提取到一个专用方法中并调用它。这样做有两个好处：首先，它使得调用此提取方法的函数更容易阅读，因为你已经封装了实现细节。其次，如果你需要更改此`foreach`循环的实现，你只需在一个地方进行更改，而不是在代码库的每个地方。所以，就像喜剧一样，保持DRY！
- en: '|'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The last code block of the method, shown in the next listing, is short and almost
    surprisingly to the point.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法最后一段代码块，如下一列表所示，简短且几乎出人意料地直接。
- en: 'Listing 4.7 FlightController.cs `POST` `/flight`: Inserting a `Booking` object
    in the database'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.7 FlightController.cs `POST` `/flight`：在数据库中插入`Booking`对象
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ SQL Query command to insert a booking into the database
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将预订插入数据库的SQL查询命令
- en: ❷ Executes the command
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 执行命令
- en: ❸ Disposes of the SqlCommand object
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 释放SqlCommand对象
- en: ❹ Returns an HTTP status 201 along with sensitive customer data
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 返回一个HTTP状态码201以及敏感的客户数据
- en: The code in listing 4.7 creates a new `SqlCommand` to insert a new record into
    the `Booking` table, then executes on that query and disposes of the `SqlCommand`.
    Finally, it returns a response with an HTTP status code of 201 and a text blurb
    containing `customer.Name`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.7中的代码创建了一个新的`SqlCommand`以将新记录插入`Booking`表，然后执行该查询并释放`SqlCommand`。最后，它返回一个包含HTTP状态码201和包含`customer.Name`文本摘要的响应。
- en: '4.4 The FlightController: DELETE /flight/{flightNumber}'
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 飞行控制器：`DELETE /flight/{flightNumber}`
- en: 'We have looked at most of the endpoints in the `FlightController` class throughout
    this chapter and have found many ways in which we could improve the code. We have
    only one more endpoint to go in the controller: `DELETE flight/{flightNumber}`.
    Perhaps mercifully and appropriately, this method is less than 20 lines long.
    We can trim it down by extracting the connection string, but overall, we have
    seen much worse code in this chapter.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经探讨了`FlightController`类中的大多数端点，并发现了许多可以改进代码的方法。在控制器中，我们只剩下一个端点要处理：`DELETE
    flight/{flightNumber}`。或许幸运且恰当地，这个方法不到20行长。我们可以通过提取连接字符串来简化它，但总体来说，我们在本章中已经看到了更糟糕的代码。
- en: 'There is nothing new in this `DELETE` method (besides a different query passed
    into the `SqlCommand` constructor), and I am not going to take too much of your
    time going over it in detail in the next listing. There are two peculiarities,
    however: the OpenAPI specification we received from FlyTomorrow in chapter 3 did
    not specify we need a `DELETE /flight/{flightNumber}` endpoint at all. After all,
    why would we want to allow users to delete flights from the database? This endpoint
    is therefore not something we improve upon and not part of the requirements. Instead,
    we omit it and don’t bother refactoring it in the coming chapters.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`DELETE`方法中（除了传递给`SqlCommand`构造函数的不同查询之外），没有新的内容，我将在下一个列表中详细说明时不会占用你太多时间。然而，有两个特殊性：我们在第3章从FlyTomorrow收到的OpenAPI规范根本没有指定我们需要一个`DELETE
    /flight/{flightNumber}`端点。毕竟，我们为什么要允许用户从数据库中删除航班？因此，这个端点不是我们改进的内容，也不是需求的一部分。相反，我们省略了它，并在接下来的章节中不对其进行重构。
- en: Listing 4.8 FlightController.cs `DELETE` `flight/{flightNumber]`
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.8 FlightController.cs `DELETE` `flight/{flightNumber}`
- en: '[PRE17]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And with that, we have finished our exploration of the existing codebase. We
    can improve on a lot of things, and we also have some security problems that we
    *must* fix.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经完成了对现有代码库的探索。我们可以改进很多事情，我们也有一些安全问题必须解决。
- en: Exercises
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Exercise 4.1
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.1
- en: True or false? You can apply attributes only to methods.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是假的？你只能将属性应用于方法。
- en: Exercise 4.2
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.2
- en: True or false? You can’t apply attributes to variables.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是假的？你不能将属性应用于变量。
- en: Exercise 4.3
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.3
- en: True or false? The `IEnumerable` interface allows us to create new enums.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是假的？`IEnumerable`接口允许我们创建新的枚举。
- en: Exercise 4.4
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.4
- en: What are *bad* practices with database connection strings?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库连接字符串有哪些**不良**做法？
- en: a. Commit hardcoded connection strings to an SCM.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: a. 将硬编码的连接字符串提交到SCM。
- en: b. Never hardcode connection strings.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: b. 永远不要硬编码连接字符串。
- en: c. Store connection strings in a configuration file or environment variable.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: c. 将连接字符串存储在配置文件或环境变量中。
- en: d. Write connection strings on a sticky note and place it in your favorite copy
    of Harry Potter and the Chamber of Connection Strings.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: d. 将连接字符串写在便利贴上，并将其放在你最喜欢的《哈利·波特与密室连接字符串》副本中。
- en: Exercise 4.5
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.5
- en: Why do we need to dispose of a class implementing the `IDisposable` interface?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要销毁实现`IDisposable`接口的类？
- en: a. Otherwise, it becomes indisposed.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: a. 否则，它就会变得不可用。
- en: b. Classes implementing `IDisposable` typically hold on to some resources that
    can cause a memory leak if not disposed of.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: b. 实现`IDisposable`的类通常持有一些资源，如果不释放，可能会导致内存泄漏。
- en: c. You don’t have to dispose of a class implementing the `IDisposable` interface.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: c. 你不需要销毁实现`IDisposable`接口的类。
- en: Exercise 4.6
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.6
- en: If we call `Dispose` on a class, when does the garbage collector collect on
    the resource?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在类上调用`Dispose`，垃圾收集器何时回收资源？
- en: a. The next time it encounters the respective resource during its garbage collection
    rounds
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: a. 下次它在垃圾收集轮次中遇到相应的资源时
- en: b. Immediately
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: b. 立即
- en: c. At the end of the method
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: c. 在方法结束时
- en: Exercise 4.7
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.7
- en: Which one of these is *not* an appropriate technique for disposing of objects?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪一项不是处理对象**适当**的技术？
- en: a. Wrap the object creation in a `using` statement code block.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: a. 在`using`语句代码块中包装对象创建。
- en: b. Call `Dispose` at every exit point in your method.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: b. 在方法的每个退出点调用`Dispose`。
- en: c. Remove the `IDisposable` implementation from the object’s source code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: c. 从对象的源代码中移除`IDisposable`实现。
- en: Exercise 4.8
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.8
- en: True or false? A static constructor is run before default or defined (regular)
    constructors.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是假的？静态构造函数在默认构造函数或定义（常规）构造函数之前运行。
- en: Exercise 4.9
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.9
- en: True or false? A static constructor is run every time an object is instantiated.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是假的？每次实例化对象时都会运行静态构造函数。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We can use the `typeof` operator to determine the type of an object at compile
    time or the `GetType` method (from the `object` base type) at run time.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`typeof`运算符在编译时确定对象的类型，或者使用`GetType`方法（来自`object`基类型）在运行时确定。
- en: '`Object` is the base type for all types in C#. This means that, through polymorphism,
    all the methods that `object` exposes are useable on all types (such as `GetType`).
    This allows us to use a basic set of methods on every type in C#.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object`是C#中所有类型的基类型。这意味着，通过多态，`object`公开的所有方法都可以在所有类型上使用（如`GetType`）。这允许我们在C#的每个类型上使用一组基本方法。'
- en: By implementing the `IEnumerable` interface, we can create classes with enumerators.
    We can use these classes to represent collections and perform operations on the
    elements they contain. This comes in useful when we want to create a collection
    that is not provided by the .NET ecosystem.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现`IEnumerable`接口，我们可以创建具有枚举器的类。我们可以使用这些类来表示集合并对它们包含的元素执行操作。当我们想要创建.NET生态系统未提供的集合时，这非常有用。
- en: We should never hardcode a connection string. This is a security problem. Instead,
    store connection strings in a configuration file or environment variable.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们永远不应该硬编码连接字符串。这是一个安全问题。相反，应在配置文件或环境变量中存储连接字符串。
- en: The .NET garbage collector scans memory at run time for resources that have
    no remaining “links,” flags them, and frees up their memory the next time the
    garbage collector runs. This is what makes C# a managed language. Because of this,
    we do not have to manually and explicitly deal with pointers and memory allocation
    in C#.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET垃圾回收器在运行时扫描内存，寻找没有剩余“链接”的资源，将其标记，并在垃圾回收器下一次运行时释放其内存。这就是C#成为托管语言的原因。正因为如此，我们不需要在C#中手动和显式地处理指针和内存分配。
- en: The compiler resolves a `using` statement to a `try-finally` code block. This
    allows us to abstract away the `Dispose` call we find in a `try-finally` block
    when using classes that implement `IDisposable`. Abstracting away the `Dispose`
    call decreases the chances of forgetting to correctly dispose of the object and,
    therefore, creating a possible memory leak.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器将`using`语句解析为`try-finally`代码块。这允许我们在使用实现`IDisposable`的类时，抽象掉在`try-finally`块中找到的`Dispose`调用。抽象掉`Dispose`调用减少了忘记正确释放对象并因此创建可能的内存泄漏的机会。
- en: A `try-catch` code block can catch and handle exceptions. Whenever you have
    code that throws exceptions (expected or unexpected), consider wrapping it in
    a `try-catch` block. When you wrap code in a `try-catch` block and catch exceptions,
    you are given a chance to elegantly handle the exception and log it, or gracefully
    shut down the application.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try-catch`代码块可以捕获和处理异常。每当您有抛出异常（预期的或未预期的）的代码时，请考虑将其包裹在`try-catch`块中。当您将代码包裹在`try-catch`块中并捕获异常时，您有机会优雅地处理异常并记录它，或者优雅地关闭应用程序。'
- en: The `finally` code block in a `try-catch-finally` or `try-finally` is always
    executed right before the code block is exited, even if an exception was caught.
    The `finally` block is an optional addition to the `try-catch` code block. This
    is useful if you need to perform teardown or cleanup operations (such as disposal
    of an object implementing `IDisposable`).
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`try-catch-finally`或`try-finally`中的`finally`代码块总是在代码块退出之前执行，即使捕获到异常也是如此。`finally`块是`try-catch`代码块的可选附加部分。如果您需要执行拆卸或清理操作（例如，释放实现`IDisposable`的对象），这将非常有用。
- en: C# supports method overloading. This means we can have methods with the same
    name but with different arguments. Method calls are routed at run time by the
    CLR to the appropriate method. This is useful when extending an existing class’s
    functionality without changing the original method.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#支持方法重载。这意味着我们可以有具有相同名称但具有不同参数的方法。方法调用在运行时由CLR路由到适当的方法。这在扩展现有类的功能而不更改原始方法时非常有用。
- en: A `static` constructor is always executed once before the first instantiation
    of an object. This can be used to set values to static properties before any logic
    execution that uses them.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`static`构造函数总是在对象的第一次实例化之前执行一次。这可以用来在执行任何使用它们的逻辑之前设置静态属性的值。
- en: The `[FromBody]` attribute allows you to do parameter binding and deserialize
    a JSON body into a model. This is a big time saver when dealing with HTTP endpoints
    because you do not have to write your own JSON mapping logic.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[FromBody]`属性允许您进行参数绑定并将JSON主体反序列化为模型。当处理HTTP端点时，这是一个节省大量时间的方法，因为您不需要编写自己的JSON映射逻辑。'
- en: The Don’t Repeat Yourself (DRY) principle tells us to not duplicate code. Instead,
    refactor the code into an extracted method and call that. Using the DRY principle
    promotes code maintainability.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要重复自己（DRY）原则告诉我们不要重复代码。相反，将代码重构为提取的方法并调用它。使用DRY原则可以促进代码的可维护性。
- en: '* * *'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.)Even though the `Object.GetType` method is not part of the reflection namespace,
    I do consider it part of the “reflection” workflow. Reflection invariably starts
    by using `Object.GetType`, and it is used to get data from an instance at run
    time. This a very “reflection”-like operation. For more information, see section
    6.2.6 or Jeffrey Richter’s *CLR via C#* (4th edition; Microsoft Press, 2012).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: (1.) 尽管`Object.GetType`方法不是反射命名空间的一部分，但我确实认为它是“反射”工作流程的一部分。反射通常从使用`Object.GetType`开始，并且它用于在运行时从实例中获取数据。这是一个非常“反射”的操作。更多信息，请参阅第6.2.6节或杰弗里·里希特（Jeffrey
    Richter）的《CLR via C#》（第4版；微软出版社，2012年）。
