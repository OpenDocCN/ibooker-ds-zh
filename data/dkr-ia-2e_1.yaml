- en: Part 1\. Process isolation and environment-independent computing
  id: totrans-0
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第1部分\. 进程隔离和环境无关计算
- en: Isolation is a core concept to so many computing patterns, resource management
    strategies, and general accounting practices that it is difficult to even begin
    compiling a list. Someone who learns how Linux containers provide isolation for
    running programs and how to use Docker to control that isolation can accomplish
    amazing feats of reuse, resource efficiency, and system simplification.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 隔离是许多计算模式、资源管理策略和一般会计实践的核心概念，以至于很难开始列出。了解Linux容器如何为运行程序提供隔离以及如何使用Docker来控制这种隔离的人可以完成惊人的重用、资源效率和系统简化壮举。
- en: The most difficult part of learning how to apply containers is in translating
    the needs of the software you are trying to isolate. Different programs have different
    requirements. Web services are different from text editors, package managers,
    compilers, or databases. Containers for each of those programs will need different
    configurations.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 学习如何应用容器最困难的部分在于将您试图隔离的软件的需求进行转换。不同的程序有不同的需求。Web服务与文本编辑器、软件包管理器、编译器或数据库不同。为这些程序创建的容器将需要不同的配置。
- en: This part covers container configuration and operation fundamentals. It expands
    into more detailed container configurations to demonstrate the full spectrum of
    capabilities. For that reason, we suggest that you try to resist the urge to skip
    ahead. It may take some time to get to the specific question that is on your mind,
    but we’re confident that you’ll have more than a few revelations along the way.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本部分涵盖容器配置和操作的基本原理。它扩展到更详细的容器配置，以展示其全部功能范围。因此，我们建议您尽量抵制跳过前面的内容的冲动。找到您心中具体问题的答案可能需要一些时间，但我们相信，在这个过程中您将会有许多启示。
- en: Chapter 2\. Running software in containers
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第2章\. 在容器中运行软件
- en: This chapter covers
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: Running interactive and daemon terminal programs in containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中运行交互式和守护进程终端程序
- en: Basic Docker operations and commands
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本Docker操作和命令
- en: Isolating programs from each other and injecting configuration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将程序相互隔离并注入配置
- en: Running multiple programs in a container
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中运行多个程序
- en: Durable containers and the container life cycle
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可持久容器和容器生命周期
- en: Cleaning up
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理
- en: Before the end of this chapter, you’ll understand all the basics for working
    with containers and how to control basic process isolation with Docker. Most examples
    in this book use real software. Practical examples will help introduce Docker
    features and illustrate how you will use them in daily activities. Using off-the-shelf
    images also reduces the learning curve for new users. If you have software that
    you want to containerize and you’re in a rush, then [part 2](index_split_062.html#filepos666610)
    will likely answer more of your direct questions.
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本章结束之前，您将了解与容器工作相关的所有基础知识以及如何使用Docker控制基本进程隔离。本书中的大多数示例都使用了真实软件。实际示例将有助于介绍Docker功能并说明您如何在日常活动中使用它们。使用现成的镜像也有助于降低新用户的学习曲线。如果您有希望容器化的软件并且急于完成，那么[第2部分](index_split_062.html#filepos666610)可能会回答您更多直接的问题。
- en: In this chapter, you’ll install a web server called NGINX. Web servers are programs
    that make website files and programs accessible to web browsers over a network.
    You’re not going to build a website, but you are going to install and start a
    web server with Docker.
  id: totrans-13
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本章中，您将安装一个名为NGINX的Web服务器。Web服务器是使网站文件和程序通过网络对Web浏览器可访问的程序。您不会构建网站，但您将使用Docker安装并启动一个Web服务器。
- en: '2.1\. CONTROLLING CONTAINERS: BUILDING A WEBSITE MONITOR'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.1\. 控制容器：构建网站监控器
- en: 'Suppose a new client walks into your office and makes an outrageous request
    for you to build them a new website: they want a website that’s closely monitored.
    This particular client wants to run their own operations, so they’ll want the
    solution you provide to email their team when the server is down. They’ve also
    heard about this popular web server software called NGINX and have specifically
    requested that you use it. Having read about the merits of working with Docker,
    you’ve decided to use it for this project. [Figure 2.1](#filepos156800) shows
    your planned architecture for the project.'
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设一位新客户走进你的办公室，并提出了一个无理的要求，要求你为他们构建一个新网站：他们想要一个密切监控的网站。这位特定的客户希望运行自己的操作，因此他们希望你提供的解决方案在服务器宕机时向他们的团队发送电子邮件。他们还听说过这个流行的Web服务器软件NGINX，并特别要求你使用它。在阅读了关于与Docker合作的优点后，你决定为这个项目使用Docker。[图2.1](#filepos156800)显示了你的项目计划架构。
- en: Figure 2.1\. The three containers that you’ll build in this example
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图2.1\. 你将在本例中构建的三个容器
- en: '![](images/00064.jpg)'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00064.jpg)'
- en: 'This example uses three containers. The first will run NGINX; the second will
    run a program called a mailer. Both of these will run as detached containers.
    Detached means that the container will run in the background, without being attached
    to any input or output stream. A third program named `watcher` will run as a monitoring
    agent in an interactive container. Both the mailer and watcher agent are small
    scripts created for this example. In this section, you’ll learn how to do the
    following:'
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本例使用三个容器。第一个将运行NGINX；第二个将运行一个名为邮件发送程序的程序。这两个都将作为独立容器运行。独立意味着容器将在后台运行，不连接到任何输入或输出流。还有一个名为`watcher`的第三个程序将在交互式容器中作为监控代理运行。邮件发送程序和监控代理都是为这个例子创建的小脚本。在本节中，你将学习以下内容：
- en: Create detached and interactive containers
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建独立和交互式容器
- en: List containers on your system
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出系统上的容器
- en: View container logs
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看容器日志
- en: Stop and restart containers
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止和重启容器
- en: Reattach a terminal to a container
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将终端重新连接到容器
- en: Detach from an attached container
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从连接的容器断开连接
- en: Without further delay, let’s get started filling your client’s order.
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不再拖延，让我们开始为客户填写订单。
- en: 2.1.1\. Creating and starting a new container
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.1.1\. 创建并启动新容器
- en: Docker calls the collection of files and instructions needed to run a software
    program an image. When we install software with Docker, we are really using Docker
    to download or create an image. There are different ways to install an image and
    several sources for images. Images are covered in more detail in [chapter 3](index_split_032.html#filepos303917),
    but for now you can think of them as the shipping containers used to transport
    physical goods around the world. Docker images hold everything a computer needs
    in order to run software.
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker将运行软件程序所需的所有文件和指令的集合称为镜像。当我们使用Docker安装软件时，我们实际上是在使用Docker下载或创建一个镜像。安装镜像有不同的方法，并且有多个镜像来源。镜像将在第3章中详细介绍，但就现在而言，你可以将它们视为用于在世界各地运输物理商品的运输集装箱。Docker镜像包含了计算机运行软件所需的一切。
- en: 'In this example, we’re going to download and install an image for NGINX from
    Docker Hub. Remember, Docker Hub is the public registry provided by Docker Inc.
    The NGINX image is what Docker Inc. calls a trusted repository. Generally, the
    person or foundation that publishes the software controls the trusted repositories
    for that software. Running the following command will download, install, and start
    a container running NGINX:'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本例中，我们将从Docker Hub下载并安装NGINX的镜像。记住，Docker Hub是由Docker Inc.提供的公共注册库。NGINX镜像是Docker
    Inc.所说的可信仓库。通常，发布软件的个人或基金会控制该软件的可信仓库。运行以下命令将下载、安装并启动一个运行NGINX的容器：
- en: '`docker run --detach \` `1` `--name web nginx:latest`'
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --detach \` `1` `--name web nginx:latest`'
- en: 1 Note the detach flag.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 注意到独立标志。
- en: 'When you run this command, Docker will install `nginx:latest` from the NGINX
    repository hosted on Docker Hub (covered in [chapter 3](index_split_032.html#filepos303917))
    and run the software. After Docker has installed and started running NGINX, one
    line of seemingly random characters will be written to the terminal. It will look
    something like this:'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你运行此命令时，Docker将从Docker Hub上托管的NGINX仓库（在第3章中介绍）安装`nginx:latest`并运行该软件。Docker安装并启动运行NGINX后，终端将写入一行看似随机的字符。它看起来可能像这样：
- en: '`7cb5d2b9a7eab87f07182b5bf58936c9947890995b1b94f412912fa822a9ecb5`'
  id: totrans-32
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`7cb5d2b9a7eab87f07182b5bf58936c9947890995b1b94f412912fa822a9ecb5`'
- en: That blob of characters is the unique identifier of the container that was just
    created to run NGINX. Every time you run `docker run` and create a new container,
    that new container will get a unique identifier. It’s common for users to capture
    this output with a variable for use with other commands. You don’t need to do
    so for the purposes of this example.
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这串字符是刚刚创建用于运行NGINX的容器的唯一标识符。每次你运行`docker run`并创建一个新的容器时，该新容器都会获得一个唯一的标识符。用户通常会将此输出捕获到变量中，以便在其他命令中使用。在这个示例中，你不需要这样做。
- en: After the identifier is displayed, it might not seem like anything has happened.
    That’s because you used the `--detach` option and started the program in the background.
    This means that the program started but isn’t attached to your terminal. It makes
    sense to start NGINX this way because we’re going to run a few programs. Server
    software is generally run in detached containers because it is rare that the software
    depends on an attached terminal.
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在显示标识符后，可能看起来好像没有发生任何事情。这是因为你使用了`--detach`选项，并在后台启动了程序。这意味着程序已经启动，但没有连接到你的终端。以这种方式启动NGINX是有意义的，因为我们将要运行几个程序。服务器软件通常在独立容器中运行，因为软件很少依赖于连接的终端。
- en: Running detached containers is a perfect fit for programs that sit quietly in
    the background. That type of program is called a daemon, or a service. A daemon
    generally interacts with other programs or humans over a network or some other
    communication channel. When you launch a daemon or other program in a container
    that you want to run in the background, remember to use either the `--detach`
    flag or its short form, `-d`.
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行独立容器非常适合那些安静地运行在后台的程序。这类程序被称为守护进程或服务。守护进程通常通过网络或其他通信渠道与其他程序或人类进行交互。当你在一个想要在后台运行的容器中启动守护进程或其他程序时，请记住使用`--detach`标志或其简写形式`-d`。
- en: 'Another daemon that your client needs in this example is a mailer. A mailer
    waits for connections from a caller and then sends an email. The following command
    installs and run a mailer that will work for this example:'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个示例中，你的客户端还需要另一个守护进程，即邮件发送程序。邮件发送程序等待来自调用者的连接，然后发送电子邮件。以下命令安装并运行了一个邮件发送程序，该程序适用于本示例：
- en: '`docker run -d \` `1` `--name mailer \     dockerinaction/ch2_mailer`'
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d \` `1` `--name mailer \ dockerinaction/ch2_mailer`'
- en: 1 Starts detached
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 开始独立运行
- en: This command uses the short form of the `--detach` flag to start a new container
    named `mailer` in the background. At this point, you’ve run two commands and delivered
    two-thirds of the system that your client wants. The last component, called the
    agent, is a good fit for an interactive container.
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此命令使用`--detach`标志的简写形式在后台启动了一个名为`mailer`的新容器。到目前为止，你已经运行了两个命令，并交付了客户端所需系统的三分之二。最后一个组件，称为代理，非常适合交互式容器。
- en: 2.1.2\. Running interactive containers
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.1.2\. 运行交互式容器
- en: A terminal-based text editor is a great example of a program that requires an
    attached terminal. It takes input from the user via a keyboard (and maybe mouse)
    and displays output on the terminal. It is interactive over its input and output
    streams. Running interactive programs in Docker requires that you bind parts of
    your terminal to the input or output of a running container.
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 基于终端的文本编辑器是要求连接终端的程序的一个很好的例子。它通过键盘（可能还有鼠标）从用户那里获取输入，并在终端上显示输出。它在输入和输出流上是交互式的。在Docker中运行交互式程序需要将你的终端的一部分绑定到正在运行的容器的输入或输出。
- en: 'To get started working with interactive containers, run the following command:'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要开始使用交互式容器，请运行以下命令：
- en: '`docker run --interactive --tty \` `1` `--link web:web \     --name web_test
    \     busybox:1.29 /bin/sh`'
  id: totrans-43
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --interactive --tty \` `1` `--link web:web \ --name web_test \
    busybox:1.29 /bin/sh`'
- en: 1 Creates a virtual terminal and binds stdin
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 创建虚拟终端并绑定stdin
- en: 'The command uses two flags on the `run` command: `--interactive` (or `-i`)
    and `--tty` (or `-t`). First, the `--interactive` option tells Docker to keep
    the standard input stream (stdin) open for the container even if no terminal is
    attached. Second, the `--tty` option tells Docker to allocate a virtual terminal
    for the container, which will allow you to pass signals to the container. This
    is usually what you want from an interactive command-line program. You’ll usually
    use both of these when you’re running an interactive program such as a shell in
    an interactive container.'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 该命令在`run`命令中使用两个标志：`--interactive`（或`-i`）和`--tty`（或`-t`）。首先，`--interactive`选项告诉Docker即使在没有终端连接的情况下，也要保持容器标准输入流（stdin）打开。其次，`--tty`选项告诉Docker为容器分配一个虚拟终端，这将允许你向容器传递信号。这通常是交互式命令行程序所期望的。当你运行如交互式容器中的shell这样的交互式程序时，你通常会使用这两个选项。
- en: Just as important as the interactive flags, when you started this container,
    you specified the program to run inside the container. In this case, you ran a
    shell program called `sh`. You can run any program that’s available inside the
    container.
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与交互式标志一样重要的是，当你启动这个容器时，你指定了容器内要运行的程序。在这种情况下，你运行了一个名为`sh`的shell程序。你可以在容器内运行任何可用的程序。
- en: 'The command in the interactive container example creates a container, starts
    a UNIX shell, and is linked to the container that’s running NGINX. From this shell,
    you can run a command to verify that your web server is running correctly:'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 交互式容器中的命令创建了一个容器，启动了一个UNIX shell，并将其链接到运行NGINX的容器。从这个shell中，你可以运行命令来验证你的Web服务器是否正常运行：
- en: '`wget -O - http://web:80/`'
  id: totrans-48
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`wget -O - http://web:80/`'
- en: This uses a program called `wget` to make an HTTP request to the web server
    (the NGINX server you started earlier in a container) and then display the contents
    of the web page on your terminal. Among the other lines, there should be a message
    like `Welcome to NGINX!` If you see that message, then everything is working correctly,
    and you can go ahead and shut down this interactive container by typing `exit`.
    This will terminate the shell program and stop the container.
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这使用了一个名为`wget`的程序向Web服务器（你之前在容器中启动的NGINX服务器）发起HTTP请求，然后在你的终端上显示网页内容。在其他行中，应该有一条消息类似于`Welcome
    to NGINX!`。如果你看到这条消息，那么一切正常，你可以继续通过输入`exit`来关闭这个交互式容器。这将终止shell程序并停止容器。
- en: It’s possible to create an interactive container, manually start a process inside
    that container, and then detach your terminal. You can do so by holding down the
    Ctrl (or Control) key and pressing P and then Q. This will work only when you’ve
    used the `--tty` option.
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有可能创建一个交互式容器，手动在该容器内启动一个进程，然后断开你的终端。你可以通过按住Ctrl（或控制）键并按P然后按Q来实现。这只有在使用了`--tty`选项的情况下才会生效。
- en: 'To finish the work for your client, you need to start an agent. This is a monitoring
    agent that will test the web server as you did in the preceding example and send
    a message with the mailer if the web server stops. This command will start the
    agent in an interactive container by using the short-form flags:'
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了完成你客户的工作，你需要启动一个代理。这是一个监控代理，它将像前面的例子那样测试Web服务器，并在Web服务器停止时通过邮件发送消息。这个命令将通过使用简写标志在交互式容器中启动代理：
- en: '`docker run -it \` `1` `--name agent \     --link web:insideweb \     --link
    mailer:insidemailer \     dockerinaction/ch2_agent`'
  id: totrans-52
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -it \` `1` `--name agent \     --link web:insideweb \     --link
    mailer:insidemailer \     dockerinaction/ch2_agent`'
- en: 1 Creates a virtual terminal and binds stdin
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 创建一个虚拟终端并绑定stdin
- en: 'When running, the container will test the web container every second and print
    a message like the following:'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在运行时，容器将每秒测试一次Web容器，并打印出如下信息：
- en: '`System up.`'
  id: totrans-55
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`System up.`'
- en: Now that you’ve seen what it does, detach your terminal from the container.
    Specifically, when you start the container and it begins writing `System up`,
    hold the Ctrl (or Control) key and then press P and then Q. After doing so, you’ll
    be returned to the shell for your host computer. Do not stop the program; otherwise,
    the monitor will stop checking the web server.
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在你已经看到了它的工作方式，请从容器中断开你的终端。具体来说，当你启动容器并开始写入`System up`时，按住Ctrl（或控制）键然后按P再按Q。这样做之后，你将返回到宿主计算机的shell。不要停止程序；否则，监视器将停止检查Web服务器。
- en: Although you’ll usually use detached or daemon containers for software that
    you deploy to servers on your network, interactive containers are useful for running
    software on your desktop or for manual work on a server. At this point, you’ve
    started all three applications in containers that your client needs. Before you
    can confidently claim completion, you should test the system.
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然你通常会在你的网络服务器上部署软件时使用分离或守护进程容器，但交互式容器对于在桌面或服务器上手动工作很有用。到目前为止，你已经启动了客户端需要的所有三个容器中的应用程序。在你自信地声称完成之前，你应该测试系统。
- en: 2.1.3\. Listing, stopping, restarting, and viewing output of containers
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.1.3\. 列出、停止、重启和查看容器输出
- en: 'The first thing you should do to test your current setup is check which containers
    are currently running by using the `docker ps` command:'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 测试你当前设置的第一件事是使用`docker ps`命令检查当前正在运行的容器：
- en: '`docker ps`'
  id: totrans-60
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker ps`'
- en: 'Running the command will display the following information about each running
    container:'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行该命令将显示每个正在运行的容器的以下信息：
- en: The container ID
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的ID
- en: The image used
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的镜像
- en: The command executed in the container
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器中执行的命令
- en: The time since the container was created
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器创建的时间
- en: The duration that the container has been running
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器运行的时间
- en: The network ports exposed by the container
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器暴露的网络端口
- en: The name of the container
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的名称
- en: 'At this point, you should have three running containers with names: `web`,
    `mailer`, and `agent`. If any is missing but you’ve followed the example thus
    far, it may have been mistakenly stopped. This isn’t a problem because Docker
    has a command to restart a container. The next three commands will restart each
    container by using the container name. Choose the appropriate ones to restart
    the containers that were missing from the list of running containers:'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到目前为止，你应该有三个正在运行的容器，名称分别为：`web`、`mailer`和`agent`。如果任何一个容器缺失，但到目前为止你已按照示例操作，那么它可能被错误地停止了。这不是问题，因为Docker有一个命令可以重新启动容器。接下来的三个命令将通过容器名称重新启动每个容器。选择适当的命令来重新启动列表中缺失的容器：
- en: '`docker restart web docker restart mailer docker restart agent`'
  id: totrans-70
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker restart web docker restart mailer docker restart agent`'
- en: 'Now that all three containers are running, you need to test that the system
    is operating correctly. The best way to do that is to examine the logs for each
    container. Start with the `web` container:'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在三个容器都已经启动，你需要测试系统是否正常运行。最好的方法是检查每个容器的日志。从`web`容器开始：
- en: '`docker logs web`'
  id: totrans-72
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker logs web`'
- en: 'That should display a long log with several lines that contain this substring:'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这应该会显示一个包含以下子字符串的长日志，包含多行：
- en: '`"GET / HTTP/1.0" 200`'
  id: totrans-74
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`"GET / HTTP/1.0" 200`'
- en: This means that the web server is running and that the agent is testing the
    site. Each time the agent tests the site, one of these lines will be written to
    the log. The `docker logs` command can be helpful for these cases but is dangerous
    to rely on. Anything that the program writes to the stdout or stderr output streams
    will be recorded in this log. The problem with this pattern is that the log is
    never rotated or truncated by default, so the data written to the log for a container
    will remain and grow as long as the container exists. That long-term persistence
    can be a problem for long-lived processes. A better way to work with log data
    uses volumes and is discussed in [chapter 4](index_split_037.html#filepos379268).
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这意味着Web服务器正在运行，代理正在测试网站。每次代理测试网站时，其中一行将被写入日志。`docker logs`命令在这种情况下可能很有用，但依赖它是有风险的。程序写入stdout或stderr输出流中的任何内容都将记录在此日志中。这种模式的问题在于日志默认不会旋转或截断，因此写入容器日志的数据将保持并随着容器的存在而增长。这种长期持久性可能对长期运行的过程造成问题。更好的方法是使用卷来处理日志数据，这在第4章（index_split_037.html#filepos379268）中有讨论。
- en: 'You can tell that the agent is monitoring the web server by examining the logs
    for `web` alone. For completeness, you should examine the log output for `mailer`
    and `agent` as well:'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以通过检查`web`的日志来了解代理是否正在监控Web服务器。为了完整性，你应该检查`mailer`和`agent`的日志输出：
- en: '`docker logs mailer docker logs agent`'
  id: totrans-77
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker logs mailer docker logs agent`'
- en: 'The logs for `mailer` should look something like this:'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`mailer`的日志应该看起来像这样：'
- en: '`CH2 Example Mailer has started.`'
  id: totrans-79
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`CH2 Example Mailer has started.`'
- en: 'The logs for `agent` should contain several lines like the one you watched
    it write when you started the container:'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`agent`的日志应该包含几行类似于你在启动容器时观察到的日志：'
- en: '`System up.`'
  id: totrans-81
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`System up.`'
- en: '|    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `docker logs` command has a flag, `--follow` or `-f`, that will display
    the logs and then continue watching and updating the display with changes to the
    log as they occur. When you’ve finished, press Ctrl-C (or Command-C) to interrupt
    the `logs` command.
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker logs`命令有一个标志`--follow`或`-f`，它将显示日志，然后继续监视并随着日志的更改更新显示。完成时，按Ctrl-C（或Command-C）中断`logs`命令。'
- en: '|    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: 'Now that you’ve validated that the containers are running and that the agent
    can reach the web server, you should test that the agent will notice when the
    web container stops. When that happens, the agent should trigger a call to the
    mailer, and the event should be recorded in the logs for both `agent` and `mailer`.
    The `docker stop` command tells the program with PID 1 in the container to halt.
    Use it in the following commands to test the system:'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在您已经验证了容器正在运行，并且代理可以访问Web服务器，您应该测试代理是否会在Web容器停止时注意到。当发生这种情况时，代理应该触发对邮件器的调用，并且该事件应该记录在`agent`和`mailer`的日志中。`docker
    stop`命令告诉容器中PID为1的程序停止。在以下命令中使用它来测试系统：
- en: '`docker stop web` `1` `docker logs mailer` `2`'
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker stop web 1 docker logs mailer 2`'
- en: 1 Stops the web server by stopping the container
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 通过停止容器停止Web服务器
- en: 2 Waits a couple of seconds and checks the mailer logs
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 等待几秒钟并检查邮件器日志
- en: 'Look for a line at the end of the mailer logs that reads like this:'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在邮件器日志的末尾查找类似以下内容的行：
- en: '`Sending email: To: admin@work  Message: The service is down!`'
  id: totrans-91
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`发送邮件：收件人：admin@work  信息：服务已中断！`'
- en: That line means the agent successfully detected that the NGINX server in the
    container named `web` had stopped. Congratulations! Your client will be happy,
    and you’ve built your first real system with containers and Docker.
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这行意味着代理成功检测到名为`web`的容器中的NGINX服务器已停止。恭喜！您的客户会感到高兴，您已经使用容器和Docker构建了您的第一个真实系统。
- en: Learning the basic Docker features is one thing, but understanding why they’re
    useful and how to use them to customize isolation is another task entirely.
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 学习Docker的基本功能是一回事，但理解它们为什么有用以及如何使用它们来定制隔离是另一项完全不同的任务。
- en: 2.2\. SOLVED PROBLEMS AND THE PID NAMESPACE
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.2. 解决问题和PID命名空间
- en: Every running program—or process—on a Linux machine has a unique number called
    a process identifier (PID). A PID namespace is a set of unique numbers that identify
    processes. Linux provides tools to create multiple PID namespaces. Each namespace
    has a complete set of possible PIDs. This means that each PID namespace will contain
    its own PID 1, 2, 3, and so on.
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Linux机器上运行的每个程序或进程都有一个唯一的数字，称为进程标识符（PID）。PID命名空间是一组唯一的数字，用于标识进程。Linux提供了创建多个PID命名空间的工具。每个命名空间都包含一组可能的PID。这意味着每个PID命名空间将包含其自己的PID
    1, 2, 3，等等。
- en: Most programs will not need access to other running processes or be able to
    list the other running processes on the system. And so Docker creates a new PID
    namespace for each container by default. A container’s PID namespace isolates
    processes in that container from processes in other containers.
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数程序不需要访问其他正在运行的过程或能够列出系统上其他正在运行的过程。因此，Docker默认为每个容器创建一个新的PID命名空间。容器的PID命名空间将隔离该容器中的进程与其他容器中的进程。
- en: 'From the perspective of a process in one container with its own namespace,
    PID 1 might refer to an init system process such as `runit` or `supervisord`.
    In a different container, PID 1 might refer to a command shell such as bash. Run
    the following to see it in action:'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从一个具有其命名空间的容器的进程的角度来看，PID 1可能指的是init系统进程，如`runit`或`supervisord`。在另一个容器中，PID
    1可能指的是命令shell，如bash。运行以下命令以查看其实际效果：
- en: '`docker run -d --name namespaceA \     busybox:1.29 /bin/sh -c "sleep 30000"
    docker run -d --name namespaceB \     busybox:1.29 /bin/sh -c "nc -l 0.0.0.0 -p
    80"  docker exec namespaceA ps` `1` `docker exec namespaceB ps` `2`'
  id: totrans-98
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d --name namespaceA \    busybox:1.29 /bin/sh -c "sleep 30000"
    docker run -d --name namespaceB \    busybox:1.29 /bin/sh -c "nc -l 0.0.0.0 -p
    80"  docker exec namespaceA ps 1 docker exec namespaceB ps 2`'
- en: 'Command 1 should generate a process list similar to the following:'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命令1应生成一个类似于以下的过程列表：
- en: '`PID   USER     TIME  COMMAND   1   root     0:00  sleep 30000   8   root    
    0:00  ps`'
  id: totrans-100
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`PID   用户     时间  命令   1   root     0:00  sleep 30000   8   root     0:00 
    ps`'
- en: 'Command 2 should generate a slightly different process list:'
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命令2应生成一个略有不同的过程列表：
- en: '`PID   USER     TIME  COMMAND   1   root     0:00  nc -l 0.0.0.0 -p 80   9  
    root     0:00  ps`'
  id: totrans-102
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`PID   用户     时间  命令   1   root     0:00  nc -l 0.0.0.0 -p 80   9   root    
    0:00  ps`'
- en: In this example, you use the `docker exec` command to run additional processes
    in a running container. In this case, the command you use is called `ps`, which
    shows all the running processes and their PID. From the output, you can clearly
    see that each container has a process with PID 1\.
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个例子中，你使用`docker exec`命令在运行中的容器中运行额外的进程。在这种情况下，你使用的命令被称为`ps`，它显示了所有运行中的进程及其PID。从输出中，你可以清楚地看到每个容器都有一个PID为1的进程。
- en: Without a PID namespace, the processes running inside a container would share
    the same ID space as those in other containers or on the host. A process in a
    container would be able to determine what other processes were running on the
    host machine. Worse, processes in one container might be able to control processes
    in other containers. A process that cannot reference any processes outside its
    namespace is limited in its ability to perform targeted attacks.
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 没有PID命名空间，容器内运行的进程将与其他容器或主机上的进程共享相同的ID空间。容器中的进程能够确定主机机器上正在运行的其他进程。更糟糕的是，一个容器中的进程可能能够控制其他容器中的进程。无法引用其命名空间外任何进程的进程在执行针对性攻击的能力上受到限制。
- en: 'Like most Docker isolation features, you can optionally create containers without
    their own PID namespace. This is critical if you are using a program to perform
    a system administration task that requires process enumeration from within a container.
    You can try this yourself by setting the `--pid` flag on `docker create` or `docker
    run` and setting the value to `host`. Try it yourself with a container running
    BusyBox Linux and the `ps` Linux command:'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与大多数Docker隔离功能一样，你可以选择性地创建没有自己的PID命名空间的容器。如果你正在使用一个程序执行需要从容器内部进行进程枚举的系统管理任务，这是至关重要的。你可以通过在`docker
    create`或`docker run`上设置`--pid`标志并将值设置为`host`来自行尝试。使用运行BusyBox Linux的容器和`ps` Linux命令来尝试它：
- en: '`docker run --pid host busybox:1.29 ps` `1`'
  id: totrans-106
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --pid host busybox:1.29 ps` `1`'
- en: 1 Should list all processes running on the computer
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 应列出计算机上运行的所有进程
- en: 'Because containers all have their own PID namespace, they both cannot gain
    meaningful insight from examining it, and can take more static dependencies on
    it. Suppose a container runs two processes: a server and a local process monitor.
    That monitor could take a hard dependency on the server’s expected PID and use
    that to monitor and control the server. This is an example of environment independence.'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因为所有容器都有自己的PID命名空间，它们都不能从检查中获得有意义的见解，并且可能会对其产生更多的静态依赖。假设一个容器运行了两个进程：一个服务器和一个本地进程监控器。那个监控器可以严格依赖于服务器的预期PID，并使用它来监控和控制服务器。这是一个环境独立性的例子。
- en: 'Consider the previous web-monitoring example. Suppose you were not using Docker
    and were just running NGINX directly on your computer. Now suppose you forgot
    that you had already started NGINX for another project. When you start NGINX again,
    the second process won’t be able to access the resources it needs because the
    first process already has them. This is a basic software conflict example. You
    can see it in action by trying to run two copies of NGINX in the same container:'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑之前的网络监控示例。假设你没有使用Docker，而是直接在你的计算机上运行NGINX。现在假设你忘记了你已经为另一个项目启动了NGINX。当你再次启动NGINX时，第二个进程将无法访问它所需的资源，因为第一个进程已经占有了它们。这是一个基本的软件冲突示例。你可以通过尝试在同一容器中运行两个NGINX副本来看到它的实际效果：
- en: '`docker run -d --name webConflict nginx:latest docker logs webConflict` `1`
    `docker exec webConflict nginx -g ''daemon off;''` `2`'
  id: totrans-110
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d --name webConflict nginx:latest docker logs webConflict` `1`
    `docker exec webConflict nginx -g ''daemon off;''` `2`'
- en: 1 Output should be empty.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 输出应该是空的。
- en: 2 Starts a second NGINX process in the same container
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 在同一容器中启动第二个NGINX进程
- en: 'The last command should display output like this:'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后一条命令应该显示如下输出：
- en: '`2015/03/29 22:04:35 [emerg] 10#0: bind() to 0.0.0.0:80 failed (98: Address
    already in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already
    in use) ...`'
  id: totrans-114
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`2015/03/29 22:04:35 [emerg] 10#0: bind() to 0.0.0.0:80 failed (98: Address
    already in use) nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already
    in use) ...`'
- en: 'The second process fails to start properly and reports that the address it
    needs is already in use. Called a port conflict, this is a common issue in real-world
    systems in which several processes are running on the same computer or multiple
    people contribute to the same environment. It’s a great example of a conflict
    problem that Docker simplifies and solves. Run each in a different container,
    like this:'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第二个进程无法正确启动，并报告它需要的地址已被占用。这被称为端口冲突，这是在现实世界中常见的冲突问题，其中多个进程在同一台计算机上运行或多个人贡献于同一环境。这是一个很好的例子，说明Docker简化并解决了冲突问题。将每个进程运行在不同的容器中，如下所示：
- en: '`docker run -d --name webA nginx:latest` `1` `docker logs webA` `2` `docker
    run -d --name webB nginx:latest` `3` `docker logs webB` `4`'
  id: totrans-116
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d --name webA nginx:latest` `1` `docker logs webA` `2` `docker
    run -d --name webB nginx:latest` `3` `docker logs webB` `4`'
- en: 1 Starts the first NGINX instance
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 启动第一个NGINX实例
- en: 2 Verifies that it is working; should be empty.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 验证其是否正常工作；应该是空的。
- en: 3 Starts the second instance
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 启动第二个实例
- en: 4 Verifies that it is working; should be empty
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 验证其是否正常工作；应该是空的
- en: 'Environment independence provides the freedom to configure software taking
    dependencies on scarce system resources without regard for other co-located software
    with conflicting requirements. Here are some common conflict problems:'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 环境独立性提供了配置依赖于稀缺系统资源的软件的自由，而不考虑其他位于同一位置的具有冲突要求的软件。以下是一些常见的冲突问题：
- en: Two programs want to bind to the same network port.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个程序想要绑定到相同的网络端口。
- en: Two programs use the same temporary filename, and file locks are preventing
    that.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个程序使用相同的临时文件名，文件锁阻止了这种情况。
- en: Two programs want to use different versions of a globally installed library.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个程序想要使用全局安装的库的不同版本。
- en: Two processes want to use the same PID file.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个进程想要使用相同的PID文件。
- en: A second program you installed modified an environment variable that another
    program uses. Now the first program breaks.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你安装的第二个程序修改了一个其他程序使用的环境变量。现在第一个程序崩溃了。
- en: Multiple processes are competing for memory or CPU time.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个进程正在竞争内存或CPU时间。
- en: All these conflicts arise when one or more programs have a common dependency
    but can’t agree to share or have different needs. As in the earlier port conflict
    example, Docker solves software conflicts with such tools as Linux namespaces,
    resource limits, filesystem roots, and virtualized network components. All these
    tools are used to isolate software inside a Docker container.
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有这些冲突都是在一个或多个程序有一个共同的依赖关系，但无法同意共享或有不同的需求时出现的。就像之前的端口冲突例子一样，Docker通过Linux命名空间、资源限制、文件系统根和虚拟化网络组件等工具来解决软件冲突。所有这些工具都用于在Docker容器内隔离软件。
- en: '2.3\. ELIMINATING METACONFLICTS: BUILDING A WEBSITE FARM'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.3. 消除元冲突：构建网站农场
- en: In the preceding section, you saw how Docker helps you avoid software conflicts
    with process isolation. But if you’re not careful, you can end up building systems
    that create metaconflicts, or conflicts between containers in the Docker layer.
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在前面的章节中，你看到了Docker如何帮助你通过进程隔离避免软件冲突。但如果你不小心，你可能会构建出创建元冲突的系统，即Docker层中容器之间的冲突。
- en: 'Consider another example: a client has asked you to build a system on which
    you can host a variable number of websites for their customers. They’d also like
    to employ the same monitoring technology that you built earlier in this chapter.
    Expanding the system you built earlier would be the simplest way to get this job
    done without customizing the configuration for NGINX. In this example, you’ll
    build a system with several containers running web servers and a monitoring watcher
    for each web server. The system will look like the architecture described in [figure
    2.2](#filepos202591).'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑另一个例子：一位客户要求你构建一个系统，在这个系统上你可以为他们的客户托管可变数量的网站。他们还希望使用你在此章早期构建的相同监控技术。扩展你之前构建的系统是完成这项工作的最简单方法，而不需要为NGINX定制配置。在这个例子中，你将构建一个包含多个运行Web服务器的容器和每个Web服务器的监控监视器的系统。该系统将类似于[图2.2](#filepos202591)中描述的架构。
- en: Figure 2.2\. A fleet of web server containers and related monitoring agents
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图2.2. 一支由Web服务器容器和相关监控代理组成的舰队
- en: '![](images/00086.jpg)'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00086.jpg)'
- en: Your first instinct might be to simply start more web containers. But that’s
    not as simple as it looks. Identifying containers gets complicated as the number
    of containers increases.
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你的第一反应可能是简单地启动更多的Web容器。但这并不像看起来那么简单。随着容器数量的增加，识别容器会变得复杂。
- en: 2.3.1\. Flexible container identification
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.3.1. 灵活的容器标识
- en: 'The best way to find out why simply creating more copies of the NGINX container
    you used in the previous example is a bad idea is to try it for yourself:'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要找出为什么仅仅复制之前示例中使用的 NGINX 容器的更多副本是一个糟糕的想法，最好的方法就是亲自尝试：
- en: '`docker run -d --name webid nginx` `1` `docker run -d --name webid nginx` `2`'
  id: totrans-137
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d --name webid nginx` `1` `docker run -d --name webid nginx` `2`'
- en: 1 Creates a container named "webid"
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 创建一个名为 "webid" 的容器
- en: 2 Creates another container named "webid"
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 创建另一个名为 "webid" 的容器
- en: 'The second command here will fail with a conflict error:'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这里第二个命令将因冲突错误而失败：
- en: '`FATA[0000] Error response from daemon: Conflict. The name "webid" is already
    in use by container 2b5958ba6a00\. You have to delete (or rename) that container
    to be able to reuse that name.`'
  id: totrans-141
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`FATA[0000] 错误响应来自守护进程：冲突。名称 "webid" 已经被容器 2b5958ba6a00 使用。您必须删除（或重命名）该容器才能重用该名称。`'
- en: 'Using fixed container names such as `web` is useful for experimentation and
    documentation, but in a system with multiple containers, using fixed names like
    that can create conflicts. By default, Docker assigns a unique (human-friendly)
    name to each container it creates. The `--name` flag overrides that process with
    a known value. If a situation arises in which the name of a container needs to
    change, you can always rename the container with the `docker rename` command:'
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用固定容器名称，如 `web`，对于实验和文档很有用，但在具有多个容器的系统中，使用这样的固定名称可能会引起冲突。默认情况下，Docker 为其创建的每个容器分配一个唯一的（对人类友好的）名称。`--name`
    标志使用已知值覆盖该过程。如果出现需要更改容器名称的情况，您始终可以使用 `docker rename` 命令重命名容器：
- en: '`docker rename webid webid-old` `1` `docker run -d --name webid nginx` `2`'
  id: totrans-143
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker rename webid webid-old` `1` `docker run -d --name webid nginx` `2`'
- en: 1 Renames the current web container to "webid-old"
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 将当前 web 容器重命名为 "webid-old"
- en: 2 Creates another container named "webid"
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 创建另一个名为 "webid" 的容器
- en: 'Renaming containers can help alleviate one-off naming conflicts but does little
    to help avoid the problem in the first place. In addition to the name, Docker
    assigns a unique identifier that was mentioned in the first example. These are
    hex-encoded 1024-bit numbers and look something like this:'
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重命名容器可以帮助缓解一次性命名冲突，但对于避免最初的问题帮助不大。除了名称外，Docker 还分配了一个唯一的标识符，这在第一个示例中已经提到。这些是十六进制编码的
    1024 位数字，看起来像这样：
- en: '`7cb5d2b9a7eab87f07182b5bf58936c9947890995b1b94f412912fa822a9ecb5`'
  id: totrans-147
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`7cb5d2b9a7eab87f07182b5bf58936c9947890995b1b94f412912fa822a9ecb5`'
- en: 'When containers are started in detached mode, their identifier will be printed
    to the terminal. You can use these identifiers in place of the container name
    with any command that needs to identify a specific container. For example, you
    could use the previous ID with a `stop` or `exec` command:'
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当以分离模式启动容器时，其标识符将被打印到终端。您可以在需要识别特定容器的任何命令中使用这些标识符代替容器名称。例如，您可以使用之前的 ID 与 `stop`
    或 `exec` 命令一起使用：
- en: '`docker exec \     7cb5d2b9a7eab87f07182b5bf58936c9947890995b1b94f412912fa822a9ecb5
    \ echo hello  docker stop \     7cb5d2b9a7eab87f07182b5bf58936c9947890995b1b94f412912fa822a9ecb5`'
  id: totrans-149
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker exec \ \ \ 7cb5d2b9a7eab87f07182b5bf58936c9947890995b1b94f412912fa822a9ecb5
    \ echo hello  docker stop \ \ \ 7cb5d2b9a7eab87f07182b5bf58936c9947890995b1b94f412912fa822a9ecb5`'
- en: 'The high probability of uniqueness of the IDs that are generated means that
    it is unlikely that there will ever be a collision with this ID. To a lesser degree,
    it is also unlikely that there would even be a collision of the first 12 characters
    of this ID on the same computer. So in most Docker interfaces, you’ll see container
    IDs truncated to their first 12 characters. This makes generated IDs a bit more
    user-friendly. You can use them wherever a container identifier is required. The
    previous two commands could be written like this:'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 生成的 ID 具有高度的唯一性，这意味着几乎不可能与该 ID 发生冲突。在某种程度上，甚至不太可能在该计算机上发生该 ID 的前 12 个字符的冲突。因此，在大多数
    Docker 接口中，您会看到容器 ID 截短为其前 12 个字符。这使得生成的 ID 更易于用户使用。您可以在需要容器标识符的地方使用它们。前两个命令可以写成这样：
- en: '`docker exec 7cb5d2b9a7ea ps docker stop 7cb5d2b9a7ea`'
  id: totrans-151
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker exec 7cb5d2b9a7ea ps docker stop 7cb5d2b9a7ea`'
- en: Neither of these IDs is particularly well suited for human use. But they work
    well with scripts and automation techniques. Docker has several means of acquiring
    the ID of a container to make automation possible. In these cases, the full or
    truncated numeric ID will be used.
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这两个 ID 都不太适合人类使用。但它们与脚本和自动化技术配合得很好。Docker 有几种获取容器 ID 的方法，以便实现自动化。在这些情况下，将使用完整或截断的数字
    ID。
- en: 'The first way to get the numeric ID of a container is to simply start or create
    a new one and assign the result of the command to a shell variable. As you saw
    earlier, when a new container is started in detached mode, the container ID will
    be written to the terminal (stdout). You’d be unable to use this with interactive
    containers if this were the only way to get the container ID at creation time.
    Luckily, you can use another command to create a container without starting it.
    The `docker create` command is similar to `docker run`, the primary difference
    being that the container is created in a stopped state:'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 获取容器数字ID的第一种方法是通过简单地启动或创建一个新的容器，并将命令的结果分配给shell变量。如您之前所见，当以分离模式启动新容器时，容器ID将被写入终端（stdout）。如果这是获取创建时容器ID的唯一方法，您将无法使用此方法与交互式容器一起使用。幸运的是，您可以使用另一个命令创建一个容器而不启动它。`docker
    create`命令类似于`docker run`，主要区别在于容器是在停止状态下创建的：
- en: '`docker create nginx`'
  id: totrans-154
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker create nginx`'
- en: 'The result should be a line like this:'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 结果应该像这样的一行：
- en: '`b26a631e536d3caae348e9fd36e7661254a11511eb2274fb55f9f7c788721b0d`'
  id: totrans-156
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`b26a631e536d3caae348e9fd36e7661254a11511eb2274fb55f9f7c788721b0d`'
- en: 'If you’re using a Linux command shell such as sh or bash, you can assign that
    result to a shell variable and use it again later:'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您使用的是Linux命令shell，如sh或bash，您可以将该结果分配给shell变量，并在以后再次使用它：
- en: '`CID=$(docker create nginx:latest)` `1` `echo $CID`'
  id: totrans-158
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`CID=$(docker create nginx:latest)` `1` `echo $CID`'
- en: 1 This will work on POSIX-compliant shells.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 这将在POSIX兼容的shell上工作。
- en: Shell variables create a new opportunity for conflict, but the scope of that
    conflict is limited to the terminal session or current processing environment
    in which the script was launched. Those conflicts should be easily avoidable because
    one use or program is managing that environment. The problem with this approach
    is that it won’t help if multiple users or automated processes need to share that
    information. In those cases, you can use a container ID (CID) file.
  id: totrans-160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Shell变量创建了一个新的冲突机会，但这种冲突的范围仅限于启动脚本的终端会话或当前处理环境。这些冲突应该是容易避免的，因为只有一个使用或程序在管理该环境。这种方法的问题在于，如果多个用户或自动化进程需要共享该信息，则这种方法不会有所帮助。在这些情况下，您可以使用容器ID（CID）文件。
- en: 'Both the `docker run` and `docker create` commands provide another flag to
    write the ID of a new container to a known file:'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run`和`docker create`命令都提供了一个额外的标志，可以将新容器的ID写入一个已知的文件：'
- en: '`docker create --cidfile /tmp/web.cid nginx` `1` `cat /tmp/web.cid` `2`'
  id: totrans-162
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker create --cidfile /tmp/web.cid nginx` `1` `cat /tmp/web.cid` `2`'
- en: 1 Creates a new stopped container
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 创建一个新的停止容器
- en: 2 Inspects the file
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 检查文件
- en: Like the use of shell variables, this feature increases the opportunity for
    conflict. The name of the CID file (provided after `--cidfile`) must be known
    or have some known structure. Just like manual container naming, this approach
    uses known names in a global (Docker-wide) namespace. The good news is that Docker
    won’t create a new container by using the provided CID file if that file already
    exists. The command will fail just as it does when you create two containers with
    the same name.
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与Shell变量的使用一样，这个特性增加了冲突的机会。CID文件的名称（在`--cidfile`之后提供）必须是已知的或具有某种已知结构。就像手动容器命名一样，这种方法在全局（Docker-wide）命名空间中使用已知名称。好消息是，如果提供的CID文件已经存在，Docker不会使用该文件创建一个新的容器。命令将失败，就像您创建两个具有相同名称的容器时一样。
- en: One reason to use CID files instead of names is that CID files can be shared
    with containers easily and renamed for that container. This uses a Docker feature
    called volumes, which is covered in [chapter 4](index_split_037.html#filepos379268).
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用CID文件而不是名称的一个原因是可以轻松地将CID文件与容器共享，并为该容器重命名。这使用了一个名为卷的Docker功能，该功能在[第4章](index_split_037.html#filepos379268)中介绍。
- en: '|    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: Tip
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 小贴士
- en: One strategy for dealing with CID file-naming collisions is to partition the
    namespace by using known or predictable path conventions. For example, in this
    scenario, you might use a path that contains all web containers under a known
    directory and further partition that directory by the customer ID. This would
    result in a path such as /containers/web/customer1/web.cid or /containers/web/customer8/web.cid.
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 处理CID文件命名冲突的一种策略是通过使用已知或可预测的路径约定来分区命名空间。例如，在这个场景中，您可能使用一个包含所有Web容器的已知目录的路径，并通过客户ID进一步分区该目录。这将导致一个路径，如/containers/web/customer1/web.cid或/containers/web/customer8/web.cid。
- en: '|    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: 'In other cases, you can use other commands such as `docker ps` to get the ID
    of a container. For example, if you want to get the truncated ID of the last created
    container, you can use this:'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在其他情况下，您可以使用其他命令，如 `docker ps` 来获取容器的 ID。例如，如果您想获取最后创建的容器的截断 ID，可以使用以下命令：
- en: '`CID=$(docker ps --latest --quiet)` `1` `echo $CID  CID=$(docker ps -l -q)`
    `2` `echo $CID`'
  id: totrans-172
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`CID=$(docker ps --latest --quiet)` `1` `echo $CID` `CID=$(docker ps -l -q)`
    `2` `echo $CID`'
- en: 1 This will work on POSIX-compliant shells.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 这将在符合 POSIX 标准的 shell 上工作。
- en: 2 Run again with the short-form flags.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 再次使用简短形式的标志运行。
- en: '|    |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: Tip
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to get the full container ID, you can use the `--no-trunc` option
    on the `docker ps` command.
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您想获取完整的容器 ID，可以在 `docker ps` 命令中使用 `--no-trunc` 选项。
- en: '|    |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: Automation cases are covered by the features you’ve seen so far. But even though
    truncation helps, these container IDs are rarely easy to read or remember. For
    this reason, Docker also generates human-readable names for each container.
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自动化案例涵盖了您迄今为止所看到的特性。尽管截断有所帮助，但这些容器 ID 很少容易阅读或记忆。因此，Docker 还为每个容器生成了可读性强的名称。
- en: The naming convention uses a personal adjective; an underscore; and the last
    name of an influential scientist, engineer, inventor, or other such thought leader.
    Examples of generated names are `compassionate_swartz`, `hungry_goodall`, and
    `distracted_turing`. These seem to hit a sweet spot for readability and memory.
    When you’re working with the `docker` tool directly, you can always use `docker
    ps` to look up the human-friendly names.
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命名约定使用一个个人形容词；一个下划线；以及一位有影响力的科学家、工程师、发明家或其他类似思想领袖的姓氏。生成的名称示例有 `compassionate_swartz`、`hungry_goodall`
    和 `distracted_turing`。这些名称似乎在可读性和记忆性方面达到了一个完美的平衡。当你直接使用 `docker` 工具时，你总是可以使用 `docker
    ps` 来查找人性化的名称。
- en: Container identification can be tricky, but you can manage the issue by using
    the ID and name-generation features of Docker.
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 容器识别可能很复杂，但您可以通过使用 Docker 的 ID 和名称生成功能来管理这个问题。
- en: 2.3.2\. Container state and dependencies
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.3.2 容器状态和依赖关系
- en: 'With this new knowledge, the new system might look something like this:'
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 带着这些新知识，新的系统可能看起来像这样：
- en: '`MAILER_CID=$(docker run -d dockerinaction/ch2_mailer)` `1` `WEB_CID=$(docker
    create nginx)  AGENT_CID=$(docker create --link $WEB_CID:insideweb \     --link
    $MAILER_CID:insidemailer \     dockerinaction/ch2_agent)`'
  id: totrans-184
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`MAILER_CID=$(docker run -d dockerinaction/ch2_mailer)` `1` `WEB_CID=$(docker
    create nginx)` `AGENT_CID=$(docker create --link $WEB_CID:insideweb --link $MAILER_CID:insidemailer
    dockerinaction/ch2_agent)`'
- en: 1 Make sure mailer from first example is running.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 确保第一个示例中的邮件发送器正在运行。
- en: 'This snippet could be used to seed a new script that launches a new NGINX and
    agent instance for each of your client’s customers. You can use `docker ps` to
    see that they’ve been created:'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这段代码可以用来启动一个新的 NGINX 和代理实例，为您的每位客户的客户。您可以使用 `docker ps` 来查看它们是否已创建：
- en: '`docker ps`'
  id: totrans-187
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker ps`'
- en: The reason neither the NGINX nor the agent was included with the output has
    to do with container state. Docker containers will be in one of the states shown
    in [figure 2.3](#filepos227084). The Docker container management commands to move
    between states annotate each transition.
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: NGINX 或代理未包含在输出中的原因与容器状态有关。Docker 容器将处于 [图 2.3](#filepos227084) 中所示的状态之一。在 Docker
    容器管理命令之间移动状态时，会注释每个转换。
- en: Figure 2.3\. The state transition diagram for Docker containers
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 2.3. Docker 容器的状态转换图
- en: '![](images/00054.jpg)'
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00054.jpg)'
- en: 'Neither of the new containers you started appears in the list of containers
    because `docker ps` shows only running containers by default. Those containers
    were specifically created with `docker create` and never started (the created
    state). To see all the containers (including those in the created state), use
    the `-a` option:'
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您启动的两个新容器都没有出现在容器列表中，因为 `docker ps` 默认只显示正在运行的容器。这些容器是专门使用 `docker create` 创建的，从未启动（处于创建状态）。要查看所有容器（包括处于创建状态的容器），请使用
    `-a` 选项：
- en: '`docker ps -a`'
  id: totrans-192
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker ps -a`'
- en: The status of the new containers should be `"Created"`. The `docker ps` command
    displays the container state using the “friendly” names shown in gray in [figure
    2.3](#filepos227084). The `docker inspect` command uses the names shown in the
    bottom half of each state (for example, `created`). The `restarting`, `removing`,
    and `dead` (not illustrated) states are internal to Docker and are used to track
    transitions between the states visible in `docker ps`.
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 新容器的状态应该是 `"Created"`。`docker ps` 命令使用灰色显示的“友好”名称显示容器状态（例如，[图2.3](#filepos227084)）。`docker
    inspect` 命令使用每个状态下半部分的名称（例如，`created`）。`restarting`、`removing` 和 `dead`（未展示）状态是Docker内部的，用于跟踪`docker
    ps`中可见状态之间的转换。
- en: 'Now that you’ve verified that both of the containers were created, you need
    to start them. For that, you can use the `docker start` command:'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在你已经验证了两个容器都已创建，你需要启动它们。为此，你可以使用 `docker start` 命令：
- en: '`docker start $AGENT_CID docker start $WEB_CID`'
  id: totrans-195
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker start $AGENT_CID docker start $WEB_CID`'
- en: 'Running those commands will result in an error. The containers need to be started
    in reverse order of their dependency chain. Because you tried to start the agent
    container before the web container, Docker reported a message like this one:'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行这些命令会导致错误。容器需要按照其依赖链的相反顺序启动。因为你尝试在启动web容器之前启动agent容器，Docker报告了如下信息：
- en: '`Error response from daemon: Cannot start container 03e65e3c6ee34e714665a8dc4e33fb19257d11402b151380ed4c0a5e38779d0a:
    Cannot link to a non running container: /clever_wright AS /modest_hopper/insideweb
    FATA[0000] Error: failed to start one or more containers`'
  id: totrans-197
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Error response from daemon: Cannot start container 03e65e3c6ee34e714665a8dc4e33fb19257d11402b151380ed4c0a5e38779d0a:
    Cannot link to a non running container: /clever_wright AS /modest_hopper/insideweb
    FATA[0000] Error: failed to start one or more containers`'
- en: 'In this example, the agent container has a dependency on the web container.
    You need to start the web container first:'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个例子中，agent容器依赖于web容器。你需要先启动web容器：
- en: '`docker start $WEB_CID docker start $AGENT_CID`'
  id: totrans-199
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker start $WEB_CID docker start $AGENT_CID`'
- en: This makes sense when you consider the mechanics at work. The link mechanism
    injects IP addresses into dependent containers, and containers that aren’t running
    don’t have IP addresses. If you tried to start a container that has a dependency
    on a container that isn’t running, Docker wouldn’t have an IP address to inject.
    In [chapter 5](index_split_046.html#filepos458921), you’ll learn to connect containers
    with user-defined bridge networks to avoid this particular dependency problem.
    The key point here is that Docker will try to resolve a container’s dependencies
    before creating or starting a container to avoid application runtime failures.
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你考虑到其中的机制时，这就有意义了。链接机制将IP地址注入依赖的容器中，而未运行的容器没有IP地址。如果你尝试启动一个依赖于未运行容器的容器，Docker将没有IP地址可以注入。在[第5章](index_split_046.html#filepos458921)中，你将学习如何使用用户定义的桥接网络连接容器，以避免这种特定的依赖问题。这里的关键点是，Docker会在创建或启动容器之前尝试解决容器的依赖关系，以避免应用程序运行时失败。
- en: '|    |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: The legacy of container network linking
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 容器网络链接的传统
- en: You may notice that the Docker documentation describes network links as a legacy
    feature. Network links were an early and popular way to connect containers. Links
    create a unidirectional network connection from one container to other containers
    on the same host. Significant portions of the container ecosystem asked for fully
    peered, bidirectional connections between containers. Docker provides this with
    the user-defined networks described in [chapter 5](index_split_046.html#filepos458921).
    These networks can also extend across a cluster of hosts as described in [chapter
    13](index_split_103.html#filepos1346462). Network links and user-defined networks
    are not equivalent, but Docker recommends migrating to user-defined networks.
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能会注意到，Docker文档将网络链接描述为传统功能。网络链接是早期且流行的一种连接容器的方法。链接从一个容器创建到同一主机上其他容器的单向网络连接。容器生态系统的大部分内容都要求容器之间有完全对等的双向连接。Docker通过[第5章](index_split_046.html#filepos458921)中描述的用户定义网络提供这一点。这些网络也可以像[第13章](index_split_103.html#filepos1346462)中描述的那样跨越主机集群。网络链接和用户定义网络不等同，但Docker建议迁移到用户定义网络。
- en: It is uncertain whether the container network linking feature will ever be removed.
    Numerous useful tools and unidirectional communication patterns depend on linking,
    as illustrated by the containers used to inspect and watch the web and mailer
    components in this section.
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 容器网络链接功能是否会被移除还不确定。许多有用的工具和单向通信模式依赖于链接，正如本节中用于检查和监视Web和邮件组件的容器所示。
- en: '|    |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: Whether you’re using `docker run` or `docker create`, the resulting containers
    need to be started in the reverse order of their dependency chain. This means
    that circular dependencies are impossible to build using Docker container relationships.
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无论你使用`docker run`还是`docker create`，生成的容器需要按照它们的依赖链的相反顺序启动。这意味着使用Docker容器关系构建循环依赖是不可能的。
- en: 'At this point, you can put everything together into one concise script that
    looks like this:'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个阶段，你可以将所有内容整合成一个简洁的脚本，如下所示：
- en: '`MAILER_CID=$(docker run -d dockerinaction/ch2_mailer)  WEB_CID=$(docker run
    -d nginx)  AGENT_CID=$(docker run -d \     --link $WEB_CID:insideweb \     --link
    $MAILER_CID:insidemailer \     dockerinaction/ch2_agent)`'
  id: totrans-208
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`MAILER_CID=$(docker run -d dockerinaction/ch2_mailer)  WEB_CID=$(docker run
    -d nginx)  AGENT_CID=$(docker run -d \   --link $WEB_CID:insideweb \   --link
    $MAILER_CID:insidemailer \   dockerinaction/ch2_agent)`'
- en: Now you’re confident that this script can be run without exception each time
    your client needs to provision a new site. Your client has returned and thanked
    you for the web and monitoring work you’ve completed so far, but things have changed.
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，你确信这个脚本可以在每次你的客户需要部署新站点时无例外地运行。你的客户回来了，感谢你迄今为止完成的网站和监控工作，但情况已经发生了变化。
- en: They’ve decided to focus on building their websites with WordPress (a popular
    open source content-management and blogging program). Luckily, WordPress is published
    through Docker Hub in a repository named `wordpress`. All you’ll need to deliver
    is a set of commands to provision a new WordPress website that has the same monitoring
    and alerting features that you’ve already delivered.
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 他们决定专注于使用WordPress（一个流行的开源内容管理和博客程序）来构建他们的网站。幸运的是，WordPress通过Docker Hub发布在名为`wordpress`的仓库中。你所需要提供的只是一组命令，用于部署一个具有相同监控和警报功能的新的WordPress网站。
- en: An interesting thing about content-management systems and other stateful systems
    is that the data they work with makes each running program specialized. Adam’s
    WordPress blog is different from Betty’s WordPress blog, even if they’re running
    the same software. Only the content is different. Even if the content is the same,
    they’re different because they’re running on different sites.
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 内容管理系统和其他有状态系统的一个有趣之处在于，它们处理的数据使得每个运行程序都变得专业化。亚当的WordPress博客与贝蒂的WordPress博客不同，即使它们运行的是相同的软件。只有内容是不同的。即使内容相同，它们也是不同的，因为它们运行在不同的网站上。
- en: If you build systems or software that know too much about their environment—for
    example, addresses or fixed locations of dependency services—it’s difficult to
    change that environment or reuse the software. You need to deliver a system that
    minimizes environment dependence before the contract is complete.
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你构建的系统或软件对其环境了解得太多——例如，依赖服务的地址或固定位置——那么改变该环境或重用该软件就变得困难。在合同完成之前，你需要提供一个最小化环境依赖的系统。
- en: 2.4\. BUILDING ENVIRONMENT-AGNOSTIC SYSTEMS
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.4. 构建环境无关的系统
- en: Much of the work associated with installing software or maintaining a fleet
    of computers lies in dealing with specializations of the computing environment.
    These specializations come as global-scoped dependencies (for example, known host
    filesystem locations), hardcoded deployment architectures (environment checks
    in code or configuration), or data locality (data stored on a particular computer
    outside the deployment architecture). Knowing this, if your goal is to build low-maintenance
    systems, you should strive to minimize these things.
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与安装软件或维护计算机群相关的许多工作都在于处理计算环境的专门化。这些专门化表现为全局范围的依赖（例如，已知的宿主文件系统位置）、硬编码的部署架构（代码或配置中的环境检查）或数据局部性（在部署架构之外的特定计算机上存储的数据）。了解这一点后，如果你的目标是构建低维护系统，你应该努力最小化这些因素。
- en: 'Docker has three specific features to help build environment-agnostic systems:'
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker有三个特定的功能来帮助构建环境无关的系统：
- en: Read-only filesystems
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读文件系统
- en: Environment variable injection
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量注入
- en: Volumes
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷
- en: 'Working with volumes is a big subject and the topic of [chapter 4](index_split_037.html#filepos379268).
    To learn the first two features, consider a requirement change for the example
    situation used in the rest of this chapter: WordPress uses a database program
    called MySQL to store most of its data, so it’s a good idea to provide the container
    running WordPress with a read-only filesystem to ensure data is written only to
    the database.'
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与卷一起工作是一个很大的主题，也是第 4 章[卷](index_split_037.html#filepos379268)的主题。要了解前两个功能，请考虑本章其余部分使用的示例情况的需求变更：WordPress
    使用一个名为 MySQL 的数据库程序来存储大部分数据，因此为运行 WordPress 的容器提供一个只读文件系统以确保数据只写入数据库是一个好主意。
- en: 2.4.1\. Read-only filesystems
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.4.1. 只读文件系统
- en: Using read-only filesystems accomplishes two positive things. First, you can
    have confidence that the container won’t be specialized from changes to the files
    it contains. Second, you have increased confidence that an attacker can’t compromise
    files in the container.
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用只读文件系统可以完成两件好事。首先，您可以确信容器不会因为包含的文件的变化而变得特殊化。其次，您对攻击者无法破坏容器中的文件有了更大的信心。
- en: 'To get started working on your client’s system, create and start a container
    from the WordPress image by using the `--read-only` flag:'
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要开始为客户系统工作，请使用 `--read-only` 标志从 WordPress 镜像创建并启动一个容器：
- en: '`docker run -d --name wp --read-only \     wordpress:5.0.0-php7.2-apache`'
  id: totrans-223
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d --name wp --read-only \   wordpress:5.0.0-php7.2-apache`'
- en: 'When this is finished, check that the container is running. You can do so using
    any of the methods introduced previously, or you can inspect the container metadata
    directly. The following command will print `true` if the container named `wp`
    is running, and `false` otherwise:'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当这完成时，请检查容器是否正在运行。您可以使用之前介绍的任何方法，或者直接检查容器元数据。以下命令将打印 `true` 如果名为 `wp` 的容器正在运行，否则打印
    `false`：
- en: '`docker inspect --format "{{.State.Running}}" wp`'
  id: totrans-225
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker inspect --format "{{.State.Running}}" wp`'
- en: The `docker inspect` command will display all the metadata (a JSON document)
    that Docker maintains for a container. The format option transforms that metadata,
    and in this case, it filters everything except for the field indicating the running
    state of the container. This command should simply output `false`.
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker inspect` 命令将显示 Docker 为容器维护的所有元数据（一个 JSON 文档）。格式选项将转换这些元数据，在这种情况下，它过滤掉除了表示容器运行状态的字段之外的所有内容。这个命令应该简单地输出
    `false`。'
- en: 'In this case, the container isn’t running. To determine why, examine the logs
    for the container:'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这种情况下，容器没有运行。要确定原因，请检查容器的日志：
- en: '`docker logs wp`'
  id: totrans-228
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker logs wp`'
- en: 'That command should output something like this:'
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 那个命令应该输出类似以下内容：
- en: '`WordPress not found in /var/www/html - copying now... Complete! WordPress
    has been successfully copied to /var/www/html ... skip output ... Wed Dec 12 15:17:36
    2018 (1): Fatal Error Unable to create lock file:` ![](images/00055.jpg) `Bad
    file descriptor (9)`'
  id: totrans-230
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`WordPress not found in /var/www/html - copying now... Complete! WordPress
    has been successfully copied to /var/www/html ... skip output ... Wed Dec 12 15:17:36
    2018 (1): Fatal Error Unable to create lock file:` ![](images/00055.jpg) `Bad
    file descriptor (9)`'
- en: 'When running WordPress with a read-only filesystem, the Apache web server process
    reports that it is unable to create a lock file. Unfortunately, it does not report
    the location of the files it is trying to create. If we have the locations, we
    can create exceptions for them. Let’s run a WordPress container with a writable
    filesystem so that Apache is free to write where it wants:'
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当使用只读文件系统运行 WordPress 时，Apache 网络服务器进程报告它无法创建锁文件。不幸的是，它没有报告它试图创建的文件的位置。如果我们有这些位置，我们可以为它们创建例外。让我们运行一个具有可写文件系统的
    WordPress 容器，这样 Apache 就可以自由地写入它想要的地方：
- en: '`docker run -d --name wp_writable wordpress:5.0.0-php7.2-apache`'
  id: totrans-232
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d --name wp_writable wordpress:5.0.0-php7.2-apache`'
- en: 'Now let’s check where Apache changed the container’s filesystem with the `docker
    diff` command:'
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在让我们使用 `docker diff` 命令检查 Apache 在哪里更改了容器的文件系统：
- en: '`docker container diff wp_writable C /run C /run/apache2 A /run/apache2/apache2.pid`'
  id: totrans-234
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container diff wp_writable C /run C /run/apache2 A /run/apache2/apache2.pid`'
- en: We will explain the `diff` command and how Docker knows what changed on the
    filesystem in more detail in [chapter 3](index_split_032.html#filepos303917).
    For now, it’s sufficient to know that the output indicates that Apache created
    the /run/apache2 directory and added the apache2.pid file inside it.
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将在第 3 章[diff 命令](index_split_032.html#filepos303917)中更详细地解释 `diff` 命令以及 Docker
    如何知道文件系统上发生了什么变化。现在，只需知道输出指示 Apache 创建了 `/run/apache2` 目录并在其中添加了 `apache2.pid`
    文件就足够了。
- en: 'Since this is an expected part of normal application operation, we will make
    an exception to the `read-only` filesystem. We will allow the container to write
    to /run/apache2 by using a writable volume mounted from the host. We will also
    supply a temporary, in-memory, filesystem to the container at /tmp since Apache
    requires a writable temporary directory, as well:'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于这是正常应用程序操作的一部分，我们将对`只读`文件系统做出例外。我们将允许容器通过从主机挂载的可写卷写入/run/apache2，同时我们还将向容器提供位于/tmp的临时内存文件系统，因为Apache需要可写的临时目录，如下所示：
- en: '`docker run -d --name wp2 \   --read-only \` `1` `-v /run/apache2/ \` `2` `--tmpfs
    /tmp \` `3` `wordpress:5.0.0-php7.2-apache`'
  id: totrans-237
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d --name wp2 \    --read-only \` `1` `-v /run/apache2/ \` `2`
    `--tmpfs /tmp \` `3` `wordpress:5.0.0-php7.2-apache`'
- en: 1 Makes container’s root filesystem read-only
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 将容器的根文件系统设置为只读
- en: 2 Mounts a writable directory from the host
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 从主机挂载一个可写目录
- en: 3 Provides container an in-memory temp filesystem
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 为容器提供一个内存临时文件系统
- en: 'That command should log successful messages that look like this:'
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 该命令应该记录类似这样的成功消息：
- en: '`docker logs wp2 WordPress not found in /var/www/html - copying now... Complete!
    WordPress has been successfully copied to /var/www/html ... skip output ... [Wed
    Dec 12 16:25:40.776359 2018] [mpm_prefork:notice] [pid 1]` ![](images/00055.jpg)
    `AH00163: Apache/2.4.25 (Debian) PHP/7.2.13 configured --` ![](images/00055.jpg)
    `resuming normal operations [Wed Dec 12 16:25:40.776517 2018] [core:notice] [pid
    1]` ![](images/00055.jpg) `AH00094: Command line: ''apache2 -D FOREGROUND''`'
  id: totrans-242
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker logs wp2 WordPress not found in /var/www/html - copying now... Complete!
    WordPress has been successfully copied to /var/www/html ... skip output ... [Wed
    Dec 12 16:25:40.776359 2018] [mpm_prefork:notice] [pid 1]` ![](images/00055.jpg)
    `AH00163: Apache/2.4.25 (Debian) PHP/7.2.13 configured --` ![](images/00055.jpg)
    `resuming normal operations [Wed Dec 12 16:25:40.776517 2018] [core:notice] [pid
    1]` ![](images/00055.jpg) `AH00094: Command line: ''apache2 -D FOREGROUND''`'
- en: 'WordPress also has a dependency on a MySQL database. A database is a program
    that stores data in such a way that it’s retrievable and searchable later. The
    good news is that you can install MySQL by using Docker, just like WordPress:'
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: WordPress还依赖于MySQL数据库。数据库是一个程序，它以可检索和可搜索的方式存储数据。好消息是你可以使用Docker安装MySQL，就像WordPress一样：
- en: '`docker run -d --name wpdb \     -e MYSQL_ROOT_PASSWORD=ch2demo \     mysql:5.7`'
  id: totrans-244
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d --name wpdb \    -e MYSQL_ROOT_PASSWORD=ch2demo \    mysql:5.7`'
- en: 'Once that is started, create a different WordPress container that’s linked
    to this new database container:'
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦启动，创建一个连接到这个新数据库容器的不同WordPress容器：
- en: '`docker run -d --name wp3 \` `1` `--link wpdb:mysql \` `2` `-p 8000:80 \` `3`
    `--read-only \     -v /run/apache2/ \     --tmpfs /tmp \     wordpress:5.0.0-php7.2-apache`'
  id: totrans-246
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d --name wp3 \` `1` `--link wpdb:mysql \` `2` `-p 8000:80 \` `3`
    `--read-only \    -v /run/apache2/ \    --tmpfs /tmp \    wordpress:5.0.0-php7.2-apache`'
- en: 1 Uses a unique name
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 使用一个唯一名称
- en: 2 Creates a link to the database
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 创建到数据库的链接
- en: 3 Directs traffic from host port 8000 to container port 80
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 将主机端口8000的流量导向容器端口80
- en: 'Check one more time that WordPress is running correctly:'
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 再次检查WordPress是否运行正确：
- en: '`docker inspect --format "{{.State.Running}}" wp3`'
  id: totrans-251
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker inspect --format "{{.State.Running}}" wp3`'
- en: The output should now be `true`. If you would like to use your new WordPress
    installation, you can point a web browser to http://127.0.0.1:8000\.
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输出现在应该是`true`。如果你想使用你的新WordPress安装，你可以通过Web浏览器访问http://127.0.0.1:8000\.
- en: 'An updated version of the script you’ve been working on should look like this:'
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你正在工作的脚本更新版本应该看起来像这样：
- en: '`#!/bin/sh  DB_CID=$(docker create -e MYSQL_ROOT_PASSWORD=ch2demo mysql:5.7)  docker
    start $DB_CID  MAILER_CID=$(docker create dockerinaction/ch2_mailer) docker start
    $MAILER_CID  WP_CID=$(docker create --link $DB_CID:mysql -p 80 \     --read-only
    -v /run/apache2/ --tmpfs /tmp \     wordpress:5.0.0-php7.2-apache)  docker start
    $WP_CID  AGENT_CID=$(docker create --link $WP_CID:insideweb \     --link $MAILER_CID:insidemailer
    \     dockerinaction/ch2_agent)  docker start $AGENT_CID`'
  id: totrans-254
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`#!/bin/sh  DB_CID=$(docker create -e MYSQL_ROOT_PASSWORD=ch2demo mysql:5.7)  docker
    start $DB_CID  MAILER_CID=$(docker create dockerinaction/ch2_mailer) docker start
    $MAILER_CID  WP_CID=$(docker create --link $DB_CID:mysql -p 80 \    --read-only
    -v /run/apache2/ --tmpfs /tmp \    wordpress:5.0.0-php7.2-apache)  docker start
    $WP_CID  AGENT_CID=$(docker create --link $WP_CID:insideweb \    --link $MAILER_CID:insidemailer
    \    dockerinaction/ch2_agent)  docker start $AGENT_CID`'
- en: Congratulations—at this point, you should have a running WordPress container!
    By using a read-only filesystem and linking WordPress to another container running
    a database, you can be sure that the container running the WordPress image will
    never change. This means that if there is ever something wrong with the computer
    running a client’s WordPress blog, you should be able to start up another copy
    of that container elsewhere with no problems.
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 恭喜——在这个阶段，你应该有一个正在运行的WordPress容器！通过使用只读文件系统和将WordPress链接到运行数据库的另一个容器，你可以确保运行WordPress镜像的容器永远不会改变。这意味着如果运行客户WordPress博客的计算机出现任何问题，你应该能够在其他地方启动该容器的另一个副本而不会出现问题。
- en: But this design has two problems. First, the database is running in a container
    on the same computer as the WordPress container. Second, WordPress is using several
    default values for important settings such as database name, administrative user,
    administrative password, database salt, and so on.
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但这种设计有两个问题。首先，数据库在运行WordPress容器的同一台计算机上的容器中运行。其次，WordPress正在使用数据库名称、管理员用户、管理员密码、数据库盐等重要设置的默认值。
- en: To deal with this problem, you could create several versions of the WordPress
    software, each with a special configuration for the client. Doing so would turn
    your simple provisioning script into a monster that creates images and writes
    files. A better way to inject that configuration would be through the use of environment
    variables.
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你可以创建WordPress软件的几个版本，每个版本都为客户配置了特殊配置。这样做会将你的简单配置脚本变成一个怪物，它会创建镜像并写入文件。更好的注入配置的方法是使用环境变量。
- en: 2.4.2\. Environment variable injection
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.4.2\. 环境变量注入
- en: Environment variables are key/value pairs that are made available to programs
    through their execution context. They let you change a program’s configuration
    without modifying any files or changing the command used to start the program.
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 环境变量是通过程序的执行上下文提供给程序的键/值对。它们允许你更改程序配置，而无需修改任何文件或更改启动程序所使用的命令。
- en: Docker uses environment variables to communicate information about dependent
    containers, the hostname of the container, and other convenient information for
    programs running in containers. Docker also provides a mechanism for a user to
    inject environment variables into a new container. Programs that know to expect
    important information through environment variables can be configured at container-creation
    time. Luckily for you and your client, WordPress is one such program.
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker使用环境变量来传递有关依赖容器、容器的主机名以及其他方便程序在容器中运行的信息。Docker还提供了一个机制，允许用户将环境变量注入到新的容器中。知道通过环境变量期望重要信息的程序可以在容器创建时进行配置。幸运的是，对于你和你的客户来说，WordPress就是这样一种程序。
- en: 'Before diving into WordPress specifics, try injecting and viewing environment
    variables on your own. The UNIX command `env` displays all the environment variables
    in the current execution context (your terminal). To see environment variable
    injection in action, use the following command:'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在深入研究WordPress的具体内容之前，尝试自己注入并查看环境变量。UNIX命令`env`显示当前执行上下文（你的终端）中的所有环境变量。要查看环境变量注入的实际操作，请使用以下命令：
- en: '`docker run --env MY_ENVIRONMENT_VAR="this is a test" \` `1` `busybox:1.29
    \     env` `2`'
  id: totrans-262
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --env MY_ENVIRONMENT_VAR="这是一个测试" \` `1` `busybox:1.29 \   env`
    `2`'
- en: 1 Injects an environment variable
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 注入环境变量
- en: 2 Executes the env command inside the container
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 在容器内执行env命令
- en: 'The `--env` flag, or `-e` for short, can be used to inject any environment
    variable. If the variable is already set by the image or Docker, the value will
    be overridden. This way, programs running inside containers can rely on the variables
    always being set. WordPress observes the following environment variables:'
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可以使用`--env`标志（或简称`-e`）注入任何环境变量。如果变量已被镜像或Docker设置，则值将被覆盖。这样，容器内运行的程序可以依赖变量始终被设置。WordPress观察以下环境变量：
- en: '`WORDPRESS_DB_HOST`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORDPRESS_DB_HOST`'
- en: '`WORDPRESS_DB_USER`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORDPRESS_DB_USER`'
- en: '`WORDPRESS_DB_PASSWORD`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORDPRESS_DB_PASSWORD`'
- en: '`WORDPRESS_DB_NAME`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORDPRESS_DB_NAME`'
- en: '`WORDPRESS_AUTH_KEY`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORDPRESS_AUTH_KEY`'
- en: '`WORDPRESS_SECURE_AUTH_KEY`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORDPRESS_SECURE_AUTH_KEY`'
- en: '`WORDPRESS_LOGGED_IN_KEY`'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORDPRESS_LOGGED_IN_KEY`'
- en: '`WORDPRESS_NONCE_KEY`'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORDPRESS_NONCE_KEY`'
- en: '`WORDPRESS_AUTH_SALT`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORDPRESS_AUTH_SALT`'
- en: '`WORDPRESS_SECURE_AUTH_SALT`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORDPRESS_SECURE_AUTH_SALT`'
- en: '`WORDPRESS_LOGGED_IN_SALT`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORDPRESS_LOGGED_IN_SALT`'
- en: '`WORDPRESS_NONCE_SALT`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORDPRESS_NONCE_SALT`'
- en: '|    |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: Tip
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 小贴士
- en: This example neglects the `KEY` and `SALT` variables, but any real production
    system should absolutely set these values.
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个例子忽略了 `KEY` 和 `SALT` 变量，但任何真正的生产系统都应该绝对设置这些值。
- en: '|    |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: 'To get started, you should address the problem that the database is running
    in a container on the same computer as the WordPress container. Rather than using
    linking to satisfy WordPress’s database dependency, inject a value for the `WORDPRESS_DB_HOST`
    variable:'
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要开始，你应该解决数据库在运行 WordPress 容器的同一台计算机上的问题。与其使用链接来满足 WordPress 的数据库依赖，不如注入 `WORDPRESS_DB_HOST`
    变量的值：
- en: '`docker create --env WORDPRESS_DB_HOST=<my database hostname> \     wordpress:
    5.0.0-php7.2-apache`'
  id: totrans-283
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker create --env WORDPRESS_DB_HOST=<my database hostname> \    wordpress:
    5.0.0-php7.2-apache`'
- en: 'This example would create (not start) a container for WordPress that will try
    to connect to a MySQL database at whatever you specify at `<my database hostname>`.
    Because the remote database isn’t likely using any default username or password,
    you’ll have to inject values for those settings as well. Suppose the database
    administrator is a cat lover and hates strong passwords:'
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个例子将创建（而不是启动）一个 WordPress 容器，该容器将尝试连接到你在 `<my database hostname>` 中指定的 MySQL
    数据库。因为远程数据库可能不会使用任何默认的用户名或密码，所以你还需要注入这些设置的值。假设数据库管理员是一位猫爱好者，并且讨厌强密码：
- en: '`docker create \     --env WORDPRESS_DB_HOST=<my database hostname> \     --env
    WORDPRESS_DB_USER=site_admin \     --env WORDPRESS_DB_PASSWORD=MeowMix42 \    
    wordpress:5.0.0-php7.2-apache`'
  id: totrans-285
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker create \    --env WORDPRESS_DB_HOST=<my database hostname> \    --env
    WORDPRESS_DB_USER=site_admin \    --env WORDPRESS_DB_PASSWORD=MeowMix42 \    wordpress:5.0.0-php7.2-apache`'
- en: 'Using environment variable injection this way will help you separate the physical
    ties between a WordPress container and a MySQL container. Even when you want to
    host the database and your customer WordPress sites all on the same machine, you’ll
    still need to fix the second problem mentioned earlier. All the sites are using
    the same default database name, which means different clients will be sharing
    a single database. You’ll need to use environment variable injection to set the
    database name for each independent site by specifying the `WORDPRESS_DB_NAME`
    variable:'
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用这种方式的环境变量注入可以帮助你分离 WordPress 容器和 MySQL 容器之间的物理联系。即使你想要在同一台机器上托管数据库和客户 WordPress
    网站，你仍然需要解决前面提到的第二个问题。所有网站都使用相同的默认数据库名称，这意味着不同的客户将共享单个数据库。你需要使用环境变量注入来通过指定 `WORDPRESS_DB_NAME`
    变量设置每个独立网站的数据库名称：
- en: '`docker create --link wpdb:mysql \     -e WORDPRESS_DB_NAME=client_a_wp \`
    `1` `wordpress:5.0.0-php7.2-apache  docker create --link wpdb:mysql \     -e WORDPRESS_DB_NAME=client_b_wp
    \` `2` `wordpress:5.0.0-php7.2-apache`'
  id: totrans-287
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker create --link wpdb:mysql \    -e WORDPRESS_DB_NAME=client_a_wp \` `1`
    `wordpress:5.0.0-php7.2-apache  docker create --link wpdb:mysql \    -e WORDPRESS_DB_NAME=client_b_wp
    \` `2` `wordpress:5.0.0-php7.2-apache`'
- en: 1 For client A
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 对于客户 A
- en: 2 For client B
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 对于客户 B
- en: 'Now that you understand how to inject configuration into the WordPress application
    and connect it to collaborating processes, let’s adapt the provisioning script.
    First, let’s start database and mailer containers that will be shared by our clients
    and store the container IDs in environment variables:'
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何将配置注入到 WordPress 应用程序中并将其连接到协作进程，让我们来调整配置脚本。首先，让我们启动数据库和邮件容器，这些容器将由我们的客户共享，并将容器
    ID 存储在环境变量中：
- en: '`export DB_CID=$(docker run -d -e MYSQL_ROOT_PASSWORD=ch2demo mysql:5.7) export
    MAILER_CID=$(docker run -d dockerinaction/ch2_mailer)`'
  id: totrans-291
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`export DB_CID=$(docker run -d -e MYSQL_ROOT_PASSWORD=ch2demo mysql:5.7) export
    MAILER_CID=$(docker run -d dockerinaction/ch2_mailer)`'
- en: 'Now update the client site provisioning script to read the database container
    ID, mailer container ID, and a new `CLIENT_ID` from environment variables:'
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在更新客户端站点配置脚本以从环境变量中读取数据库容器 ID、邮件容器 ID 和新的 `CLIENT_ID`：
- en: '`#!/bin/sh  if [ ! -n "$CLIENT_ID" ]; then` `1` `echo "Client ID not set"    
    exit 1 fi  WP_CID=$(docker create \     --link $DB_CID:mysql \` `2` `--name wp_$CLIENT_ID
    \     -p 80 \     --read-only -v /run/apache2/ --tmpfs /tmp \     -e WORDPRESS_DB_NAME=$CLIENT_ID
    \     --read-only wordpress:5.0.0-php7.2-apache)  docker start $WP_CID  AGENT_CID=$(docker
    create \         --name agent_$CLIENT_ID \     --link $WP_CID:insideweb \    
    --link $MAILER_CID:insidemailer \     dockerinaction/ch2_agent)  docker start
    $AGENT_CID`'
  id: totrans-293
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`#!/bin/sh  if [ ! -n "$CLIENT_ID" ]; then` `1` `echo "Client ID not set"    exit
    1 fi  WP_CID=$(docker create \    --link $DB_CID:mysql \` `2` `--name wp_$CLIENT_ID
    \    -p 80 \    --read-only -v /run/apache2/ --tmpfs /tmp \    -e WORDPRESS_DB_NAME=$CLIENT_ID
    \    --read-only wordpress:5.0.0-php7.2-apache)  docker start $WP_CID  AGENT_CID=$(docker
    create \    --name agent_$CLIENT_ID \    --link $WP_CID:insideweb \    --link
    $MAILER_CID:insidemailer \    dockerinaction/ch2_agent)  docker start $AGENT_CID`'
- en: 1 Assumes $CLIENT_ID variable is set as input to script
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 假设$CLIENT_ID变量已设置为脚本的输入
- en: 2 Creates link using DB_CID
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 使用DB_CID创建链接
- en: 'If you save this script to a file named start-wp-for-client.sh, you can provision
    WordPress for the `dockerinaction` client by using a command like this:'
  id: totrans-296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你将此脚本保存为名为start-wp-for-client.sh的文件，你可以使用如下命令为`dockerinaction`客户端配置WordPress：
- en: '`CLIENT_ID=dockerinaction ./start-wp-multiple-clients.sh`'
  id: totrans-297
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`CLIENT_ID=dockerinaction ./start-wp-multiple-clients.sh`'
- en: This new script will start an instance of WordPress and the monitoring agent
    for each customer and connect those containers to each other as well as a single
    mailer program and MySQL database. The WordPress containers can be destroyed,
    restarted, and upgraded without any worry about loss of data. [Figure 2.4](#filepos272507)
    shows this architecture.
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个新脚本将为每个客户启动一个WordPress实例和监控代理，并将这些容器相互连接，以及连接到一个单独的邮件发送程序和MySQL数据库。WordPress容器可以被销毁、重启和升级，而无需担心数据丢失。[图2.4](#filepos272507)显示了这种架构。
- en: Figure 2.4\. Each WordPress and agent container uses the same database and mailer.
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图2.4。每个WordPress和代理容器使用相同的数据库和邮件发送程序。
- en: '![](images/00038.jpg)'
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00038.jpg)'
- en: The client should be pleased with what is being delivered. But one thing might
    be bothering you. In earlier testing, you found that the monitoring agent correctly
    notified the mailer when the site was unavailable, but restarting the site and
    agent required manual work. It would be better if the system tried to automatically
    recover when a failure was detected. Docker provides restart policies to help
    deal with that, but you might want something more robust.
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 客户应该对所提供的内容感到满意。但可能有一件事让你感到烦恼。在早期的测试中，你发现监控代理在网站不可用时正确地通知了邮件发送程序，但重启网站和代理需要手动操作。当检测到故障时，如果系统能够自动恢复会更好。Docker提供了重启策略来帮助处理这种情况，但你可能需要更健壮的解决方案。
- en: 2.5\. BUILDING DURABLE CONTAINERS
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.5. 构建持久容器
- en: Software may fail in rare conditions that are temporary in nature. Although
    it’s important to be made aware when these conditions arise, it’s usually at least
    as important to restore the service as quickly as possible. The monitoring system
    that you built in this chapter is a fine start for keeping system owners aware
    of problems with a system, but it does nothing to help restore service.
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 软件可能在罕见的情况下失败，这些情况本质上是暂时的。尽管在出现这些情况时通知是很重要的，但通常至少同样重要的是尽可能快地恢复服务。本章中构建的监控系统对于让系统所有者了解系统问题是一个很好的开始，但它对恢复服务没有帮助。
- en: 'When all the processes in a container have exited, that container will enter
    the exited state. Remember, a Docker container can be in one of six states:'
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当容器中的所有进程都已退出时，该容器将进入已退出的状态。记住，Docker容器可以处于以下六种状态之一：
- en: '`Created`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Created`'
- en: '`Running`'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Running`'
- en: '`Restarting`'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Restarting`'
- en: '`Paused`'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Paused`'
- en: '`Removing`'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Removing`'
- en: '`Exited` (also used if the container has never been started)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exited`（也用于容器从未启动过的情况）'
- en: A basic strategy for recovering from temporary failures is automatically restarting
    a process when it exits or fails. Docker provides a few options for monitoring
    and restarting containers.
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从临时故障中恢复的基本策略是在进程退出或失败时自动重启该进程。Docker提供了一些监控和重启容器的选项。
- en: 2.5.1\. Automatically restarting containers
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.5.1. 自动重启容器
- en: 'Docker provides this functionality with a restart policy. Using the `--restart`
    flag at container-creation time, you can tell Docker to do any of the following:'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker通过重启策略提供此功能。在容器创建时使用`--restart`标志，你可以告诉Docker执行以下任何一项操作：
- en: Never restart (default)
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永不重启（默认）
- en: Attempt to restart when a failure is detected
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当检测到故障时尝试重启
- en: Attempt for some predetermined time to restart when a failure is detected
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当检测到故障时，尝试在预定时间内重启
- en: Always restart the container regardless of the condition
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不论条件如何，始终重启容器
- en: Docker doesn’t always attempt to immediately restart a container. If it did,
    that would cause more problems than it solved. Imagine a container that does nothing
    but print the time and exit. If that container was configured to always restart,
    and Docker always immediately restarted it, the system would do nothing but restart
    that container. Instead, Docker uses an exponential backoff strategy for timing
    restart attempts.
  id: totrans-318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker并不总是立即尝试重启容器。如果它这样做，可能会造成更多问题而不是解决问题。想象一个容器除了打印时间和退出什么也不做。如果该容器被配置为始终重启，并且Docker总是立即重启它，系统将只会重启该容器。相反，Docker使用指数退避策略来安排重启尝试的时间。
- en: 'A backoff strategy determines the amount of time that should pass between successive
    restart attempts. An exponential back-off strategy will do something like double
    the previous time spent waiting on each successive attempt. For example, if the
    first time the container needs to be restarted Docker waits 1 second, then on
    the second attempt it would wait 2 seconds, 4 seconds on the third attempt, 8
    on the fourth, and so on. Exponential backoff strategies with low initial wait
    times are a common service-restoration technique. You can see Docker employ this
    strategy yourself by building a container that always restarts and simply prints
    the time:'
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 回退策略决定了连续重启尝试之间应该经过的时间。指数回退策略会在每次连续尝试中等待的时间翻倍。例如，如果容器第一次需要重启时 Docker 等待了 1 秒，那么第二次尝试时它将等待
    2 秒，第三次尝试时等待 4 秒，第四次尝试时等待 8 秒，以此类推。具有低初始等待时间的指数回退策略是常见的服务恢复技术。你可以通过构建一个总是重启并简单地打印时间的容器来亲自看到
    Docker 使用这种策略：
- en: '`docker run -d --name backoff-detector --restart always busybox:1.29 date`'
  id: totrans-320
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d --name backoff-detector --restart always busybox:1.29 date`'
- en: 'Then after a few seconds, use the trailing logs feature to watch it back off
    and restart:'
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后，几秒钟后，使用尾部日志功能来观察它回退并重启：
- en: '`docker logs -f backoff-detector`'
  id: totrans-322
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker logs -f backoff-detector`'
- en: The logs will show all the times it has already been restarted and will wait
    until the next time it is restarted, print the current time, and then exit. Adding
    this single flag to the monitoring system and the WordPress containers you’ve
    been working on would solve the recovery issue.
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 日志将显示它已经被重启的所有时间，并等待下一次重启，打印当前时间，然后退出。将此单个标志添加到监控系统和您一直在工作的 WordPress 容器中，就可以解决恢复问题。
- en: 'The only reason you might not want to adopt this directly is that during backoff
    periods, the container isn’t running. Containers waiting to be restarted are in
    the restarting state. To demonstrate, try to run another process in the `backoff-detector`
    container:'
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能不希望直接采用这种策略的唯一原因是，在回退期间，容器不会运行。等待重启的容器处于重启状态。为了演示，尝试在 `backoff-detector`
    容器中运行另一个进程：
- en: '`docker exec backoff-detector echo Just a Test`'
  id: totrans-325
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker exec backoff-detector echo Just a Test`'
- en: 'Running that command should result in an error message:'
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行该命令应该会显示错误信息：
- en: '`Container <ID> is restarting, wait until the container is running`'
  id: totrans-327
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`容器 <ID> 正在重启，等待容器运行`'
- en: That means you can’t do anything that requires the container to be in a running
    state, such as execute additional commands in the container. That could be a problem
    if you need to run diagnostic programs in a broken container. A more complete
    strategy is to use containers that start lightweight init systems.
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这意味着你不能做任何需要容器处于运行状态的事情，比如在容器中执行额外的命令。如果你需要在损坏的容器中运行诊断程序，这可能会成为一个问题。一个更完整的策略是使用启动轻量级初始化系统的容器。
- en: 2.5.2\. Using PID 1 and init systems
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.5.2\. 使用 PID 1 和初始化系统
- en: An init system is a program that’s used to launch and maintain the state of
    other programs. Any process with PID 1 is treated like an init process by the
    Linux kernel (even if it is not technically an init system). In addition to other
    critical functions, an init system starts other processes, restarts them in the
    event that they fail, transforms and forwards signals sent by the operating system,
    and prevents resource leaks. It is common practice to use real init systems inside
    containers when that container will run multiple processes or if the program being
    run uses child processes.
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 初始化系统是一种用于启动和维护其他程序状态的程序。Linux 内核将任何 PID 为 1 的进程视为初始化进程（即使它技术上不是初始化系统）。除了其他关键功能外，初始化系统还会启动其他进程，在它们失败时重启它们，转换并转发操作系统发送的信号，并防止资源泄漏。当容器将运行多个进程或运行的程序使用子进程时，在容器内部使用真实的初始化系统是一种常见的做法。
- en: Several such init systems could be used inside a container. The most popular
    include `runit`, `Yelp/dumb-init`, `tini`, `supervisord`, and `tianon/gosu`. Publishing
    software that uses these programs is covered in [chapter 8](index_split_069.html#filepos755104).
    For now, take a look at a container that uses `supervisord`.
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在容器内部可以使用几种这样的初始化系统。其中最受欢迎的有 `runit`、`Yelp/dumb-init`、`tini`、`supervisord` 和
    `tianon/gosu`。使用这些程序的软件的发布内容在[第8章](index_split_069.html#filepos755104)中有详细说明。现在，让我们看看一个使用
    `supervisord` 的容器。
- en: 'Docker provides an image that contains a full LAMP (Linux, Apache, MySQL PHP)
    stack inside a single container. Containers created this way use `supervisord`
    to make sure that all the related processes are kept running. Start an example
    container:'
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker提供了一个包含单个容器内完整LAMP（Linux、Apache、MySQL PHP）堆栈的镜像。以这种方式创建的容器使用`supervisord`确保所有相关进程都保持运行。启动一个示例容器：
- en: '`docker run -d -p 80:80 --name lamp-test tutum/lamp`'
  id: totrans-333
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d -p 80:80 --name lamp-test tutum/lamp`'
- en: 'You can see which processes are running inside this container by using the
    `docker top` command:'
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以使用`docker top`命令查看容器内正在运行哪些进程：
- en: '`docker top lamp-test`'
  id: totrans-335
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker top lamp-test`'
- en: The `top` subcommand will show the host PID for each of the processes in the
    container. You’ll see `supervisord`, `mysql`, and `apache` included in the list
    of running programs. Now that the container is running, you can test the `supervisord`
    restart functionality by manually stopping one of the processes inside the container.
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`top`子命令将显示容器中每个进程的主PID。您将看到`supervisord`、`mysql`和`apache`包含在运行程序列表中。现在容器正在运行，您可以通过手动停止容器内的一个进程来测试`supervisord`重启功能。'
- en: 'The problem is that to kill a process inside a container from within that container,
    you need to know the PID in the container’s PID namespace. To get that list, run
    the following `exec` subcommand:'
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 问题在于，要从容器内部杀死容器内的进程，您需要知道容器PID命名空间中的PID。要获取该列表，请运行以下`exec`子命令：
- en: '`docker exec lamp-test ps`'
  id: totrans-338
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker exec lamp-test ps`'
- en: 'The process list generated will list `apache2` in the CMD column:'
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 生成的进程列表将在CMD列中列出`apache2`：
- en: '`PID TTY          TIME CMD   1 ?        00:00:00 supervisord 433 ?        00:00:00
    mysqld_safe 835 ?        00:00:00 apache2 842 ?        00:00:00 ps`'
  id: totrans-340
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`PID TTY          TIME CMD   1 ?        00:00:00 supervisord 433 ?        00:00:00
    mysqld_safe 835 ?        00:00:00 apache2 842 ?        00:00:00 ps`'
- en: 'The values in the PID column will be different when you run the command. Find
    the PID on the row for `apache2` and then insert that for `<PID>` in the following
    command:'
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您运行命令时，PID列中的值将不同。找到`apache2`所在行的PID，然后在以下命令中的`<PID>`处插入该值：
- en: '`docker exec lamp-test kill <PID>`'
  id: totrans-342
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker exec lamp-test kill <PID>`'
- en: 'Running this command will run the Linux `kill` program inside the `lamp-test`
    container and tell the `apache2` process to shut down. When `apache2` stops, the
    `supervisord` process will log the event and restart the process. The container
    logs will clearly show these events:'
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行此命令将在`lamp-test`容器内运行Linux的`kill`程序，并指示`apache2`进程关闭。当`apache2`停止时，`supervisord`进程将记录事件并重新启动进程。容器日志将清楚地显示这些事件：
- en: '`... ... exited: apache2 (exit status 0; expected) ... spawned: ''apache2''
    with pid 820 ... success: apache2 entered RUNNING state, process has stayed up
    for >       than 1 seconds (startsecs)`'
  id: totrans-344
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`... ... exited: apache2 (exit status 0; expected) ... spawned: ''apache2''
    with pid 820 ... success: apache2 entered RUNNING state, process has stayed up
    for > than 1 seconds (startsecs)`'
- en: 'A common alternative to the use of init systems is using a startup script that
    at least checks the preconditions for successfully starting the contained software.
    These are sometimes used as the default command for the container. For example,
    the WordPress containers that you’ve created start by running a script to validate
    and set default environment variables before starting the WordPress process. You
    can view this script by overriding the default command with one to view the contents
    of the startup script:'
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用init系统的一个常见替代方案是使用启动脚本，该脚本至少检查成功启动容器内软件的先决条件。这些有时被用作容器的默认命令。例如，您创建的WordPress容器通过运行一个脚本来验证并设置默认环境变量，然后启动WordPress进程。您可以通过覆盖默认命令来查看此脚本的内容，以查看启动脚本：
- en: '`docker run wordpress:5.0.0-php7.2-apache \   cat /usr/local/bin/docker-entrypoint.sh`'
  id: totrans-346
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run wordpress:5.0.0-php7.2-apache \ cat /usr/local/bin/docker-entrypoint.sh`'
- en: 'Docker containers run something called an entrypoint before executing the command.
    Entrypoints are perfect places to put code that validates the preconditions of
    a container. Although this is discussed in depth in [part 2](index_split_062.html#filepos666610)
    of this book, you need to know how to override or specifically set the entrypoint
    of a container on the command line. Try running the last command again, but this
    time using the `--entrypoint` flag to specify the program to run and using the
    command section to pass arguments:'
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker容器在执行命令之前会运行一个名为entrypoint的程序。Entrypoints是放置验证容器预条件的代码的完美位置。尽管这一点在本书的第2部分（[index_split_062.html#filepos666610]）中有详细讨论，但你仍需要知道如何在命令行上覆盖或特别设置容器的entrypoint。尝试再次运行最后一个命令，但这次使用`--entrypoint`标志来指定要运行的程序，并使用命令部分来传递参数：
- en: '`docker run --entrypoint="cat" \` `1` `wordpress:5.0.0-php7.2-apache \    
    /usr/local/bin/docker-entrypoint.sh` `2`'
  id: totrans-348
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --entrypoint="cat" \` `1` `wordpress:5.0.0-php7.2-apache \ /usr/local/bin/docker-entrypoint.sh`
    `2`'
- en: 1 Uses “cat” as the entrypoint
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 使用“cat”作为entrypoint
- en: 2 Passes the full path of the default entrypoint script as an argument to cat
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 将默认entrypoint脚本的完整路径作为参数传递给cat
- en: If you run through the displayed script, you’ll see how it validates the environment
    variables against the dependencies of the software and sets default values. Once
    the script has validated that WordPress can execute, it will start the requested
    or default command.
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你运行显示的脚本，你会看到它是如何验证环境变量与软件依赖项的，并设置默认值。一旦脚本验证WordPress可以执行，它将启动请求的或默认命令。
- en: Startup scripts are an important part of building durable containers and can
    always be combined with Docker restart policies to take advantage of the strengths
    of each. Because both the MySQL and WordPress containers already use startup scripts,
    it’s appropriate to simply set the restart policy for each in an updated version
    of the example script.
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 启动脚本是构建耐用容器的重要部分，并且总是可以与Docker重启策略结合使用，以利用各自的优势。由于MySQL和WordPress容器已经使用了启动脚本，因此为每个容器在示例脚本的更新版本中设置重启策略是合适的。
- en: Running startup scripts as PID 1 is problematic when the script fails to meet
    the expectations that Linux has for init systems. Depending on your use case,
    you might find that one approach or a hybrid works best.
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当启动脚本未能满足Linux对init系统的期望时，以PID 1运行启动脚本是有问题的。根据你的使用情况，你可能发现一种方法或混合方法效果最好。
- en: With that final modification, you’ve built a complete WordPress site-provisioning
    system and learned the basics of container management with Docker. It has taken
    considerable experimentation. Your computer is likely littered with several containers
    that you no longer need. To reclaim the resources that those containers are using,
    you need to stop them and remove them from your system.
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 经过最后的修改，你已经构建了一个完整的WordPress站点配置系统，并学习了使用Docker进行容器管理的基础知识。这需要相当多的实验。你的电脑上可能充斥着几个你不再需要的容器。为了回收这些容器所使用的资源，你需要停止它们并将它们从系统中移除。
- en: 2.6\. CLEANING UP
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2.6\. 清理工作
- en: 'Ease of cleanup is one of the strongest reasons to use containers and Docker.
    The isolation that containers provide simplifies any steps that you’d have to
    take to stop processes and remove files. With Docker, the whole cleanup process
    is reduced to one of a few simple commands. In any cleanup task, you must first
    identify the container that you want to stop and/or remove. Remember, to list
    all the containers on your computer, use the `docker ps` command:'
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 清理的简便性是使用容器和Docker的最强理由之一。容器提供的隔离性简化了停止进程和删除文件所需的任何步骤。使用Docker，整个清理过程可以简化为几个简单的命令之一。在任何清理任务中，你必须首先确定你想要停止和/或删除的容器。记住，要列出你电脑上的所有容器，请使用`docker
    ps`命令：
- en: '`docker ps -a`'
  id: totrans-357
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker ps -a`'
- en: Because the containers you created for the examples in this chapter won’t be
    used again, you should be able to safely stop and remove all the listed containers.
    Make sure you pay attention to the containers you’re cleaning up if there are
    any that you created for your own activities.
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于本章示例中创建的容器将不再使用，你应该能够安全地停止和删除所有列出的容器。确保你注意清理的容器，如果你为个人活动创建了任何容器的话。
- en: All containers use hard drive space to store logs, container metadata, and files
    that have been written to the container filesystem. All containers also consume
    resources in the global namespace such as container names and host port mappings.
    In most cases, containers that will no longer be used should be removed.
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有容器都使用硬盘空间来存储日志、容器元数据和写入容器文件系统的文件。所有容器也消耗全局命名空间中的资源，例如容器名称和主机端口映射。在大多数情况下，不再使用的容器应该被移除。
- en: 'To remove a container from your computer, use the `docker rm` command. For
    example, to delete the stopped container named `wp`, you’d run this:'
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要从您的计算机中移除容器，请使用 `docker rm` 命令。例如，要删除名为 `wp` 的已停止容器，您将运行以下命令：
- en: '`docker rm wp`'
  id: totrans-361
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker rm wp`'
- en: 'You should go through all the containers in the list you generated by running
    `docker ps -a` and remove all containers that are in the exited state. If you
    try to remove a container that’s running, paused, or restarting, Docker will display
    a message like the following:'
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您应该遍历通过运行 `docker ps -a` 生成的所有容器列表，并移除所有处于退出状态的容器。如果您尝试移除一个正在运行、暂停或重新启动的容器，Docker
    将显示如下消息：
- en: '`Error response from daemon: Conflict, You cannot remove a running container.
    Stop the container before attempting removal or use -f FATA[0000] Error: failed
    to remove one or more containers`'
  id: totrans-363
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`错误响应来自守护进程：冲突，您不能移除一个正在运行的容器。在尝试移除之前停止容器或使用 -f FATA[0000] 错误：无法移除一个或多个容器`'
- en: The processes running in a container should be stopped before the files in the
    container are removed. You can do this with the `docker stop` command or by using
    the `-f` flag on `docker rm`. The key difference is that when you stop a process
    by using the `-f` flag, Docker sends a `SIG_KILL` signal, which immediately terminates
    the receiving process. In contrast, using `docker stop` will send a `SIG_HUP`
    signal. Recipients of `SIG_HUP` have time to perform finalization and cleanup
    tasks. The `SIG_KILL` signal makes for no such allowances and can result in file
    corruption or poor network experiences. You can issue a `SIG_KILL` directly to
    a container by using the `docker kill` command. But you should use `docker kill`
    or `docker rm -f` only if you must stop the container in less than the standard
    30-second maximum stop time.
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在移除容器中的文件之前，应该停止容器中运行的进程。您可以使用 `docker stop` 命令或通过在 `docker rm` 上使用 `-f` 标志来实现。关键区别在于，当您使用
    `-f` 标志停止进程时，Docker 会发送 `SIG_KILL` 信号，该信号会立即终止接收到的进程。相比之下，使用 `docker stop` 会发送
    `SIG_HUP` 信号。`SIG_HUP` 的接收者有时间执行最终化和清理任务。`SIG_KILL` 信号不提供此类允许，可能会导致文件损坏或网络体验不佳。您可以使用
    `docker kill` 命令直接向容器发送 `SIG_KILL` 信号。但您应该只在必须将容器停止时间少于标准的 30 秒最大停止时间时使用 `docker
    kill` 或 `docker rm -f`。
- en: 'In the future, if you’re experimenting with short-lived containers, you can
    avoid the cleanup burden by specifying `--rm` on the command. Doing so will automatically
    remove the container as soon as it enters the exited state. For example, the following
    command will write a message to the screen in a new BusyBox container, and the
    container will be removed as soon as it exits:'
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在未来，如果您正在尝试使用短暂容器，您可以通过在命令中指定 `--rm` 来避免清理负担。这样做将在容器进入退出状态时自动移除容器。例如，以下命令将在新的
    BusyBox 容器中向屏幕写入消息，并且容器将在退出后立即被移除：
- en: '`docker run --rm --name auto-exit-test busybox:1.29 echo Hello World docker
    ps -a`'
  id: totrans-366
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --rm --name auto-exit-test busybox:1.29 echo Hello World docker
    ps -a`'
- en: 'In this case, you could use either `docker stop` or `docker rm` to properly
    clean up, or it would be appropriate to use the single-step `docker rm -f` command.
    You should also use the `-v` flag for reasons that will be covered in [chapter
    4](index_split_037.html#filepos379268). The `docker` CLI makes it is easy to compose
    a quick cleanup command:'
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以使用 `docker stop` 或 `docker rm` 来正确清理，或者使用单步 `docker rm -f` 命令也是合适的。您还应该使用
    `-v` 标志，原因将在第 4 章中介绍。`docker` CLI 使得快速组合清理命令变得容易：
- en: '`docker rm -vf $(docker ps -a -q)`'
  id: totrans-368
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker rm -vf $(docker ps -a -q)`'
- en: This concludes the basics of running software in containers. Each chapter in
    the remainder of [part 1](index_split_023.html#filepos151791) will focus on a
    specific aspect of working with containers. The next chapter focuses on installing
    and uninstalling images, understanding how images relate to containers, and working
    with container filesystems.
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这就完成了在容器中运行软件的基础知识。[第 1 部分](index_split_023.html#filepos151791) 剩余的每一章都将专注于容器工作的一个特定方面。下一章将重点介绍安装和卸载镜像，了解镜像与容器之间的关系，以及与容器文件系统的工作。
- en: SUMMARY
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: 'The primary focus of the Docker project is to enable users to run software
    in containers. This chapter shows how you can use Docker for that purpose. The
    ideas and features covered include the following:'
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker 项目的核心目标是使用户能够在容器中运行软件。本章展示了如何使用 Docker 达到这个目的。涵盖的想法和特性包括以下内容：
- en: Containers can be run with virtual terminals attached to the user’s shell or
    in detached mode.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器可以以附加到用户 shell 的虚拟终端或分离模式运行。
- en: By default, every Docker container has its own PID namespace, isolating process
    information for each container.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，每个 Docker 容器都有自己的 PID 命名空间，为每个容器隔离进程信息。
- en: Docker identifies every container by its generated container ID, abbreviated
    container ID, or its human-friendly name.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 通过生成的容器 ID、简化的容器 ID 或其友好的名称来标识每个容器。
- en: 'All containers are in any one of six distinct states: created, running, restarting,
    paused, removing, or exited.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有容器都处于以下六个不同的状态之一：已创建、正在运行、重新启动、暂停、正在删除或已退出。
- en: The `docker exec` command can be used to run additional processes inside a running
    container.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `docker exec` 命令在运行的容器内运行额外的进程。
- en: A user can pass input or provide additional configuration to a process in a
    container by specifying environment variables at container-creation time.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以通过在容器创建时指定环境变量，向容器中的进程传递输入或提供额外的配置。
- en: Using the `--read-only` flag at container-creation time will mount the container
    filesystem as read-only and prevent specialization of the container.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器创建时使用 `--read-only` 标志将容器文件系统挂载为只读，并防止容器专业化。
- en: A container restart policy, set with the `--restart` flag at container-creation
    time, will help your systems automatically recover in the event of a failure.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器重启策略，在容器创建时通过 `--restart` 标志设置，将帮助系统在发生故障时自动恢复。
- en: Docker makes cleaning up containers with the `docker rm` command as simple as
    creating them.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 使得使用 `docker rm` 命令清理容器变得与创建它们一样简单。
- en: Chapter 3\. Software installation simplified
  id: totrans-381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第 3 章\. 软件安装简化
- en: This chapter covers
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Identifying software
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别软件
- en: Finding and installing software with Docker Hub
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker Hub 查找和安装软件
- en: Installing software from alternative sources
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其他来源安装软件
- en: Understanding filesystem isolation
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解文件系统隔离
- en: Working with images and layers
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与镜像和层一起工作
- en: '[Chapters 1](index_split_015.html#filepos91074) and [2](index_split_024.html#filepos153412)
    introduced new concepts and abstractions provided by Docker. This chapter dives
    deeper into container filesystems and software installation. It breaks software
    installation into three steps, as illustrated in [figure 3.1](#filepos305551).'
  id: totrans-388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[第 1 章](index_split_015.html#filepos91074) 和 [第 2 章](index_split_024.html#filepos153412)
    介绍了 Docker 提供的新概念和抽象。本章深入探讨了容器文件系统和软件安装。它将软件安装分解为三个步骤，如图 3.1 所示。'
- en: Figure 3.1\. Flow of topics covered in this chapter
  id: totrans-389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 3.1\. 本章涵盖的主题流程
- en: '![](images/00042.jpg)'
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00042.jpg)'
- en: The first step in installing any software is identifying the software you want
    to install. You know that software is distributed using images, but you need to
    know how to tell Docker exactly which image you want to install. We’ve already
    mentioned that repositories hold images, but this chapter shows how repositories
    and tags are used to identify images in order to install the software you want.
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 安装任何软件的第一步是确定你想要安装的软件。你知道软件是通过镜像进行分发的，但你需要知道如何告诉 Docker 你想要安装的确切镜像。我们已经提到，仓库包含镜像，但本章展示了如何使用仓库和标签来识别镜像，以便安装你想要的软件。
- en: 'This chapter details the three main ways to install Docker images:'
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章详细介绍了安装 Docker 镜像的三个主要方法：
- en: Using Docker registries
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 仓库
- en: Using image files with `docker save` and `docker load`
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `docker save` 和 `docker load` 命令使用镜像文件
- en: Building images with Dockerfiles
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Dockerfile 构建镜像
- en: In the course of reading this material, you’ll learn how Docker isolates installed
    software and you’ll be exposed to a new term, layer. Layers, an important concept
    when dealing with images, provide multiple important features. This chapter closes
    with a section about how images work. That knowledge will help you evaluate image
    quality and establish a baseline skillset for [part 2](index_split_062.html#filepos666610)
    of this book.
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在阅读这份材料的过程中，你将了解 Docker 如何隔离已安装的软件，并接触到一个新的术语，层。层是处理镜像时的重要概念，提供了多个重要特性。本章以关于镜像工作原理的部分结束。这些知识将帮助你评估镜像质量，并为本书第
    2 部分 [part 2](index_split_062.html#filepos666610) 建立一个基本技能集。
- en: 3.1\. IDENTIFYING SOFTWARE
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.1\. 识别软件
- en: Suppose you want to install a program called TotallyAwesomeBlog 2.0\. How would
    you tell Docker what you want to install? You would need a way to name the program,
    specify the version that you want to use, and specify the source that you want
    to install it from. Learning how to identify specific software is the first step
    in software installation, as illustrated in [figure 3.2](#filepos308653).
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设您想安装一个名为TotallyAwesomeBlog 2.0的程序。您会如何告诉Docker您想安装什么？您需要一个方法来命名程序，指定您想要使用的版本，以及指定您想要从中安装它的来源。学习如何识别特定软件是软件安装的第一步，如图3.2所示。
- en: Figure 3.2\. Step 1—software identification
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图3.2. 步骤1—软件识别
- en: '![](images/00089.jpg)'
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00089.jpg)'
- en: You’ve learned that Docker creates containers from images. An image is a file.
    It holds files that will be available to containers created from it and metadata
    about the image. This metadata contains labels, environment variables, default
    execution context, the command history for an image, and more.
  id: totrans-401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您已经了解到Docker从图像创建容器。图像是一个文件。它包含将可用于从它创建的容器中的文件以及关于图像的元数据。这些元数据包含标签、环境变量、默认执行上下文、图像的命令历史记录等。
- en: Every image has a globally unique identifier. You can use that identifier with
    image and container commands, but in practice it’s rare to actually work with
    raw image identifiers. They are long, unique sequences of letters and numbers.
    Each time a change is made to an image, the image identifier changes. Image identifiers
    are difficult to work with because they’re unpredictable. Instead, users work
    with named repositories.
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个图像都有一个全局唯一的标识符。您可以使用该标识符与图像和容器命令一起使用，但在实践中，实际上与原始图像标识符一起工作的很少。它们是长串的字母和数字的唯一序列。每次对图像进行更改时，图像标识符都会更改。图像标识符难以处理，因为它们是不可预测的。相反，用户使用命名仓库。
- en: 3.1.1\. What is a named repository?
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.1.1. 什么是命名仓库？
- en: A named repository is a named bucket of images. The name is similar to a URL.
    A repository’s name is made up of the name of the host where the image is located,
    the user account that owns the image, and a short name, as shown in [figure 3.3](#filepos310864).
    For example, later in this chapter you will install an image from the repository
    named `docker.io/dockerinaction/ch3_hello_registry`.
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命名仓库是图像的命名桶。名称类似于URL。仓库的名称由图像所在的主机名称、拥有图像的用户账户和简短名称组成，如图3.3所示。例如，在本章的后面，您将从名为`docker.io/dockerinaction/ch3_hello_registry`的仓库中安装一个图像。
- en: Figure 3.3\. The Docker image repository name
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图3.3. Docker图像仓库名称
- en: '![](images/00027.jpg)'
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00027.jpg)'
- en: Just as there can be several versions of software, a repository can hold several
    images. Each image in a repository is identified uniquely with tags. If you were
    to release a new version of `docker.io/dockerinaction/ch3_hello_registry`, you
    might tag it `v2` while tagging the old version with `v1`. If you wanted to download
    the old version, you could specifically identify that image by its `v1` tag.
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如软件可以有多个版本一样，仓库可以包含多个图像。仓库中的每个图像都通过标签唯一标识。如果您要发布`docker.io/dockerinaction/ch3_hello_registry`的新版本，您可能会将其标记为`v2`，而将旧版本标记为`v1`。如果您想下载旧版本，您可以通过其`v1`标签具体标识该图像。
- en: In [chapter 2](index_split_024.html#filepos153412), you installed an image from
    the NGINX repository on Docker Hub that was identified with the `latest` tag.
    A repository name and tag form a composite key, or a unique reference made up
    of a combination of nonunique components. In that example, the image was identified
    by `nginx:latest`. Although identifiers built in this fashion may occasionally
    be longer than raw image identifiers, they’re predictable and communicate the
    intention of the image.
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在[第2章](index_split_024.html#filepos153412)中，您从Docker Hub上的NGINX仓库安装了一个带有`latest`标签的图像。仓库名称和标签组成一个复合键，或由非唯一组件组合而成的唯一引用。在示例中，该图像通过`nginx:latest`进行标识。尽管以这种方式构建的标识符有时可能比原始图像标识符更长，但它们是可预测的，并且传达了图像的意图。
- en: 3.1.2\. Using tags
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.1.2. 使用标签
- en: Tags are both an important way to uniquely identify an image and a convenient
    way to create useful aliases. Whereas a tag can be applied to only a single image
    in a repository, a single image can have several tags. This allows repository
    owners to create useful versioning or feature tags.
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 标签既是唯一标识图像的重要方式，也是创建有用别名的便捷方式。虽然标签只能应用于仓库中的单个图像，但单个图像可以有多个标签。这允许仓库所有者创建有用的版本或功能标签。
- en: 'For example, the Java repository on Docker Hub maintains the following tags:
    `11-stretch`, `11-jdk-stretch`, `11.0-stretch`, `11.0-jdk-stretch`, `11.0.4-stretch`,
    and `11.0.4-jdk-stretch`. All these tags are applied to the same image. This image
    is built by installing the current Java 11 Development Kit (JDK) into a Debian
    Stretch base image. As the current patch version of Java 11 increases, and the
    maintainers release Java 11.0.5, the 11.0.4 tag will be replaced in this set with
    11.0.5\. If you care about which minor or patch version of Java 11 you’re running,
    you have to keep up with those tag changes. If you just want to make sure you’re
    always running the most recent version of Java 11, use the image tagged with `11-stretch`.
    It should always be assigned to the newest release of Java 11\. These tags give
    users great flexibility.'
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，Docker Hub上的Java仓库维护以下标签：`11-stretch`、`11-jdk-stretch`、`11.0-stretch`、`11.0-jdk-stretch`、`11.0.4-stretch`和`11.0.4-jdk-stretch`。所有这些标签都应用于相同的镜像。这个镜像是通过将当前的Java
    11开发工具包（JDK）安装到Debian Stretch基础镜像中构建的。随着Java 11的当前补丁版本的增加，维护者发布了Java 11.0.5，这个集合中的`11.0.4`标签将被替换为`11.0.5`。如果你关心你正在运行的Java
    11的次要或补丁版本，你必须跟上这些标签的变化。如果你只想确保你始终运行Java 11的最新版本，请使用带有`11-stretch`标签的镜像。它应该始终分配给Java
    11的最新发布版本。这些标签为用户提供了极大的灵活性。
- en: It’s also common to see different tags for images with different software configurations.
    For example, we’ve released two images for an open source program called freegeoip.
    It’s a web application that can be used to get the rough geographical location
    associated with a network address. One image is configured to use the default
    configuration for the software. It’s meant to run by itself with a direct link
    to the world. The second is configured to run behind a web load balancer. Each
    image has a distinct tag that allows the user to easily identify the image with
    the features required.
  id: totrans-412
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于具有不同软件配置的镜像，也常见到不同的标签。例如，我们为名为freegeoip的开源程序发布了两个镜像。这是一个可以用来获取与网络地址相关的大致地理位置的Web应用程序。一个镜像配置为使用软件的默认配置。它旨在通过直接链接到世界来独立运行。第二个配置为在Web负载均衡器后面运行。每个镜像都有一个独特的标签，使用户能够轻松地识别具有所需功能的镜像。
- en: '|    |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-414
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 小贴士
- en: When you’re looking for software to install, always pay careful attention to
    the tags offered in a repository. Many repositories publish multiple releases
    of their software, sometimes on multiple operating systems or in full or slim
    versions to support different use cases. Consult the repository's documentation
    for specifics of what the repository's tags mean and the image release practices.
  id: totrans-415
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你在寻找要安装的软件时，总是要仔细注意仓库提供的标签。许多仓库发布了它们软件的多个版本，有时在多个操作系统上或在完整或精简版本中，以支持不同的用例。请参阅仓库的文档，了解仓库标签的具体含义和镜像发布实践。
- en: '|    |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: That is all there is to identifying software for use with Docker. With this
    knowledge, you’re ready to start looking for and installing software with Docker.
  id: totrans-417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 那就是使用Docker识别软件的全部内容。有了这些知识，你就可以开始寻找和安装使用Docker的软件了。
- en: 3.2\. FINDING AND INSTALLING SOFTWARE
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.2. 软件的查找和安装
- en: You can identify software by a repository name, but how do you find the repositories
    that you want to install? Discovering trustworthy software is complex, and it
    is the second step in learning how to install software with Docker, as shown in
    [figure 3.4](#filepos320339).
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以通过仓库名称来识别软件，但你是如何找到你想要安装的仓库的呢？发现可信赖的软件是复杂的，它是学习如何使用Docker安装软件的第二步，如图3.4所示。
- en: Figure 3.4\. Step 2—locating repositories
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图3.4. 步骤2——定位仓库
- en: '![](images/00080.jpg)'
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00080.jpg)'
- en: The easiest way to find images is to use an index. Indexes are search engines
    that catalog repositories. There are several public Docker indexes, but by default
    `docker` is integrated with an index named Docker Hub.
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 找到镜像的最简单方法是使用索引。索引是目录仓库的搜索引擎。有几个公共Docker索引，但默认情况下`docker`与名为Docker Hub的索引集成。
- en: Docker Hub is a registry and index with a web user interface run by Docker Inc.
    It’s the default registry and index used by `docker` and is located at the host
    `docker.io`. When you issue a `docker pull` or `docker run` command without specifying
    an alternative registry, Docker will default to looking for the repository on
    Docker Hub. Docker Hub makes Docker more useful out of the box.
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker Hub是由Docker Inc.运营的具有Web用户界面的注册和索引。它是`docker`默认使用的注册和索引，位于主机`docker.io`上。当你发出不带指定替代注册表的`docker
    pull`或`docker run`命令时，Docker将默认在Docker Hub上查找仓库。Docker Hub使Docker更加实用。
- en: Docker Inc. has made efforts to ensure that Docker is an open ecosystem. It
    publishes a public image to run your own registry, and the `docker` command-line
    tool can be easily configured to use alternative registries. Later in this chapter,
    we cover alternative image installation and distribution tools included with Docker.
    But first, the next section covers how to use Docker Hub so you can get the most
    from the default toolset.
  id: totrans-424
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker Inc. 已努力确保 Docker 是一个开放的生态系统。它发布了一个公共镜像以运行自己的注册表，并且 `docker` 命令行工具可以轻松配置以使用替代注册表。在本章的后面部分，我们将介绍
    Docker 包含的替代镜像安装和分发工具。但首先，下一节将介绍如何使用 Docker Hub，以便你可以充分利用默认的工具集。
- en: 3.2.1\. Working with Docker registries from the command line
  id: totrans-425
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.2.1\. 从命令行使用 Docker 注册表
- en: 'An image author can publish images to a registry such as Docker Hub in two
    ways:'
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图像作者可以通过两种方式将图像发布到注册表，例如 Docker Hub：
- en: Use the command line to push images that they built independently and on their
    own systems.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行推送他们独立且在自己的系统上构建的镜像。
- en: Make a Dockerfile publicly available and use a continuous build system to publish
    images. Dockerfiles are scripts for building images. Images created from these
    automated builds are preferred because the Dockerfile is available for examination
    prior to installing the image.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Dockerfile 公开并使用持续构建系统发布镜像。Dockerfile 是用于构建镜像的脚本。从这些自动化构建中创建的镜像更受欢迎，因为可以在安装镜像之前检查
    Dockerfile。
- en: Most registries will require image authors to authenticate before publishing
    and enforce authorization checks on the repository they are updating. In these
    cases, you can use the `docker login` command to log in to specific registry servers
    such as Docker Hub. Once you’ve logged in, you’ll be able to pull from private
    repositories, tag images in your repositories, and push to any repository that
    you control. [Chapter 7](index_split_063.html#filepos667222) covers tagging and
    pushing images.
  id: totrans-429
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数注册表都会要求图像作者在发布之前进行身份验证，并在他们更新的仓库上执行授权检查。在这些情况下，你可以使用 `docker login` 命令登录到特定的注册表服务器，如
    Docker Hub。一旦登录，你将能够从私有仓库拉取，对你的仓库中的图像进行标记，并将图像推送到你控制的任何仓库。[第 7 章](index_split_063.html#filepos667222)
    介绍了标记和推送图像。
- en: Running `docker login` will prompt you for your [Docker.com](http://Docker.com)
    credentials. Once you’ve provided them, your command-line client will be authenticated,
    and you’ll be able to access your private repositories. When you’ve finished working
    with your account, you can log out with the `docker logout` command. If you’re
    using a different registry, you can specify the server name as an argument to
    the `docker login` and `docker logout` subcommands.
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行 `docker login` 将提示你输入你的 [Docker.com](http://Docker.com) 凭据。一旦你提供了它们，你的命令行客户端将进行身份验证，你将能够访问你的私有仓库。当你完成与账户的工作后，可以使用
    `docker logout` 命令登出。如果你使用的是不同的注册表，你可以将服务器名称作为 `docker login` 和 `docker logout`
    子命令的参数指定。
- en: 3.2.2\. Using alternative registries
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.2.2\. 使用替代注册表
- en: Docker makes the registry software available for anyone to run. Cloud companies
    including AWS and Google offer private registries, and companies that use Docker
    EE or that use the popular Artifactory project already have private registries.
    Running a registry from open source components is covered in [chapter 8](index_split_069.html#filepos755104),
    but it’s important that you learn how to use them early.
  id: totrans-432
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker 使注册表软件对任何人都可以运行。包括 AWS 和 Google 在内的云公司提供私有注册表，使用 Docker EE 或使用流行的 Artifactory
    项目的公司已经拥有私有注册表。在 [第 8 章](index_split_069.html#filepos755104) 中介绍了使用开源组件运行注册表，但重要的是你早期就学会如何使用它们。
- en: 'Using an alternative registry is simple. It requires no additional configuration.
    All you need is the address of the registry. The following command will download
    another “Hello, World” type of example from an alternative registry:'
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用替代注册表很简单。它不需要额外的配置。你只需要注册表的地址。以下命令将从替代注册表下载另一个“Hello, World”类型的示例：
- en: '`docker pull quay.io/dockerinaction/ch3_hello_registry:latest`'
  id: totrans-434
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker pull quay.io/dockerinaction/ch3_hello_registry:latest`'
- en: 'The registry address is part of the full repository specification covered in
    [section 3.1](index_split_033.html#filepos307910). The full pattern is as follows:'
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注册表地址是 [第 3.1 节](index_split_033.html#filepos307910) 中涵盖的完整仓库规范的一部分。完整的模式如下：
- en: '`[REGISTRYHOST:PORT/][USERNAME/]NAME[:TAG]`'
  id: totrans-436
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`[REGISTRYHOST:PORT/][USERNAME/]NAME[:TAG]`'
- en: 'Docker knows how to talk to Docker registries, so the only difference is that
    you specify the registry host. In some cases, working with registries will require
    an authentication step. If you encounter a situation where this is the case, consult
    the documentation or the group that configured the registry to find out more.
    When you’re finished with the `hello-registry` image you installed, remove it
    with the following command:'
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker 知道如何与 Docker 仓库通信，所以唯一的区别是你指定了仓库主机。在某些情况下，与仓库一起工作可能需要认证步骤。如果你遇到这种情况，请查阅文档或配置了仓库的团队以获取更多信息。当你完成安装的
    `hello-registry` 镜像后，使用以下命令删除它：
- en: '`docker rmi quay.io/dockerinaction/ch3_hello_registry`'
  id: totrans-438
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker rmi quay.io/dockerinaction/ch3_hello_registry`'
- en: Registries are powerful. They enable a user to relinquish control of image storage
    and transportation. But running your own registry can be complicated and may create
    a potential single point of failure for your deployment infrastructure. If running
    a custom registry sounds a bit complicated for your use case, and third-party
    distribution tools are out of the question, you might consider loading images
    directly from a file.
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 仓库非常强大。它们使用户能够放弃对镜像存储和传输的控制。但是运行自己的仓库可能很复杂，可能会为你的部署基础设施创建一个潜在的单一故障点。如果你的用例中运行自定义仓库听起来有点复杂，而且第三方分发工具又不可行，你可能考虑直接从文件加载镜像。
- en: 3.2.3\. Working with images as files
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.2.3\. 将镜像作为文件处理
- en: Docker provides a command to load images into Docker from a file. With this
    tool, you can load images that you acquired through other channels. Maybe your
    company has chosen to distribute images through a central file server or some
    type of version-control system. Maybe the image is small enough that your friend
    just sent it to you over email or shared it via flash drive. However you came
    upon the file, you can load it into Docker with the `docker load` command.
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker 提供了一个命令，可以将镜像从文件加载到 Docker 中。使用这个工具，你可以加载通过其他渠道获取的镜像。也许你的公司选择通过中央文件服务器或某种版本控制系统来分发镜像。也许镜像足够小，你的朋友只是通过电子邮件发送给你，或者通过闪存驱动器共享。无论你是如何获得这个文件的，你都可以使用
    `docker load` 命令将其加载到 Docker 中。
- en: You’ll need an image file to load before we can show you the `docker load` command.
    Because it’s unlikely that you have an image file lying around, we’ll show you
    how to save one from a loaded image. For the purposes of this example, you’ll
    pull `busybox:latest`. That image is small and easy to work with. To save that
    image to a file, use the `docker save` command. [Figure 3.5](#filepos330987) demonstrates
    `docker save` by creating a file from BusyBox.
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在我们向你展示 `docker load` 命令之前，你需要一个镜像文件。由于你不太可能有现成的镜像文件，我们将向你展示如何从已加载的镜像中保存一个。为了这个例子的目的，你将拉取
    `busybox:latest`。这个镜像很小，易于处理。要将该镜像保存到文件中，请使用 `docker save` 命令。[图 3.5](#filepos330987)
    通过从 BusyBox 创建文件来演示 `docker save`。
- en: Figure 3.5\. Parts of the `pull` and `save` subcommands
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 3.5\. `pull` 和 `save` 子命令的部分
- en: '![](images/00014.jpg)'
  id: totrans-444
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00014.jpg)'
- en: We used the .tar filename suffix in this example because the `docker save` command
    creates TAR archive files. You can use any filename you want. If you omit the
    `–o` flag, the resulting file will be streamed to the terminal.
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了 `.tar` 文件名后缀，因为 `docker save` 命令创建 TAR 归档文件。你可以使用任何你想要的文件名。如果你省略了
    `–o` 标志，生成的文件将流式传输到终端。
- en: '|    |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: Tip
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 小贴士
- en: Other ecosystems that use TAR archives for packing define custom file extensions.
    For example, Java uses .jar, .war, and .ear. In cases like these, using custom
    file extensions can help hint at the purpose and content of the archive. Although
    there are no defaults set by Docker and no official guidance on the matter, you
    may find using a custom extension useful if you work with these files often.
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 其他使用 TAR 归档进行打包的生态系统定义了自定义文件扩展名。例如，Java 使用 .jar、.war 和 .ear。在这些情况下，使用自定义文件扩展名可以帮助暗示归档的目的和内容。尽管
    Docker 没有设置默认值，也没有官方的指导，但如果你经常处理这些文件，使用自定义扩展名可能很有用。
- en: '|    |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: 'After running the `save` command, the `docker` program will terminate unceremoniously.
    Check that it worked by listing the contents of your current working directory.
    If the specified file is there, use this command to remove the image from Docker:'
  id: totrans-450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在运行 `save` 命令后，`docker` 程序将无礼地终止。通过列出你的当前工作目录的内容来检查它是否工作。如果指定的文件在那里，使用以下命令从
    Docker 中删除镜像：
- en: '`docker rmi busybox`'
  id: totrans-451
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker rmi busybox`'
- en: 'After removing the image, load it again from the file you created by using
    the `docker load` command. As with `docker save`, if you run `docker load` without
    the `–i` command, Docker will use the standard input stream instead of reading
    the archive from a file:'
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 删除镜像后，使用 `docker load` 命令再次从您创建的文件中加载它。与 `docker save` 类似，如果您不使用 `–i` 命令运行 `docker
    load`，Docker 将使用标准输入流而不是从文件中读取存档：
- en: '`docker load –i myfile.tar`'
  id: totrans-453
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker load –i myfile.tar`'
- en: Once you’ve run the `docker load` command, the image should be loaded. You can
    verify this by running the `docker images` command again. If everything worked
    correctly, BusyBox should be included in the list.
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行 `docker load` 命令后，镜像应该被加载。您可以通过再次运行 `docker images` 命令来验证这一点。如果一切正常，BusyBox
    应该包含在列表中。
- en: Working with images as files is as easy as working with registries, but you
    miss out on all the nice distribution facilities that registries provide. If you
    want to build your own distribution tools, or you already have something else
    in place, it should be trivial to integrate with Docker by using these commands.
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将镜像作为文件处理与处理注册表一样简单，但您会错过注册表提供的所有良好分发设施。如果您想构建自己的分发工具，或者您已经有所准备，那么通过使用这些命令与
    Docker 集成应该非常简单。
- en: Another popular project distribution pattern uses bundles of files with installation
    scripts. This approach is popular with open source projects that use public version-control
    repositories for distribution. In these cases, you work with a file, but the file
    is not an image; it is a Dockerfile.
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一种流行的项目分发模式是使用带有安装脚本的文件包。这种方法在开源项目中很受欢迎，这些项目使用公共版本控制仓库进行分发。在这些情况下，您处理的是一个文件，但这个文件不是一个镜像；它是一个
    Dockerfile。
- en: 3.2.4\. Installing from a Dockerfile
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.2.4\. 从 Dockerfile 安装
- en: A Dockerfile is a script that describes steps for Docker to take to build a
    new image. These files are distributed along with software that the author wants
    to be put into an image. In this case, you’re not technically installing an image.
    Instead, you’re following instructions to build an image. Working with Dockerfiles
    is covered in depth in [chapter 7](index_split_063.html#filepos667222).
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Dockerfile 是一个脚本，描述了 Docker 构建新镜像所需的步骤。这些文件与作者希望放入镜像中的软件一起分发。在这种情况下，您实际上并没有安装镜像，而是遵循指示来构建镜像。与
    Dockerfile 一起工作的内容在 [第 7 章](index_split_063.html#filepos667222) 中有详细说明。
- en: 'Distributing a Dockerfile is similar to distributing image files. You’re left
    to your own distribution mechanisms. A common pattern is to distribute a Dockerfile
    with software from common version-control systems like Git or Mercurial. If you
    have Git installed, you can try this by running an example from a public repository:'
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 分发 Dockerfile 与分发镜像文件类似。您需要自行选择分发机制。一种常见的模式是将 Dockerfile 与来自 Git 或 Mercurial
    等常见版本控制系统的软件一起分发。如果您已安装 Git，可以尝试从公共仓库运行一个示例：
- en: '`git clone https://github.com/dockerinaction/ch3_dockerfile.git docker build
    -t dia_ch3/dockerfile:latest ch3_dockerfile`'
  id: totrans-460
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`git clone https://github.com/dockerinaction/ch3_dockerfile.git docker build
    -t dia_ch3/dockerfile:latest ch3_dockerfile`'
- en: In this example, you copy the project from a public source repository onto your
    computer and then build and install a Docker image by using the Dockerfile included
    with that project. The value provided to the `-t` option of `docker build` is
    the repository where you want to install the image. Building images from Dockerfiles
    is a light way to move projects around that fits into existing workflows.
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个示例中，您将项目从公共源代码库复制到您的计算机上，然后通过使用该项目包含的 Dockerfile 来构建和安装 Docker 镜像。提供给 `docker
    build` 命令 `-t` 选项的值是您想要安装镜像的仓库。从 Dockerfile 构建镜像是一种轻量级的方法，适合现有的工作流程。
- en: This approach has two disadvantages. First, depending on the specifics of the
    project, the build process might take some time. Second, dependencies may drift
    between the time when the Dockerfile was authored and when an image is built on
    a user’s computer. These issues make distributing build files less than an ideal
    experience for a user. But it remains popular in spite of these drawbacks.
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种方法有两个缺点。首先，根据项目的具体细节，构建过程可能需要一些时间。其次，Dockerfile 编写的时间和在用户的计算机上构建镜像的时间之间，依赖项可能会发生变化。这些问题使得分发构建文件对用户来说不是一个理想的体验。尽管如此，它仍然因为这些缺点而保持流行。
- en: 'When you’re finished with this example, make sure to clean up your workspace:'
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 完成此示例后，请确保清理您的开发空间：
- en: '`docker rmi dia_ch3/dockerfile rm -rf ch3_dockerfile`'
  id: totrans-464
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker rmi dia_ch3/dockerfile rm -rf ch3_dockerfile`'
- en: 3.2.5\. Using Docker Hub from the website
  id: totrans-465
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.2.5\. 在网站上使用 Docker Hub
- en: 'If you have yet to stumble upon it while browsing the Docker website, you should
    take a moment to check out [https://hub.docker.com](https://hub.docker.com). Docker
    Hub lets you search for repositories, organizations, or specific users. User and
    organization profile pages list the repositories that the account maintains, recent
    activity on the account, and the repositories that the account has starred. On
    repository pages you can see the following:'
  id: totrans-466
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你浏览Docker网站时还没有遇到它，你应该花点时间查看[https://hub.docker.com](https://hub.docker.com)。Docker
    Hub允许你搜索存储库、组织或特定用户。用户和组织个人资料页面列出了账户维护的存储库、账户上的最近活动以及账户标记的存储库。在存储库页面上，你可以看到以下信息：
- en: General information about the image provided by the image publisher
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于图像发布者提供的图像的一般信息
- en: A list of the tags available in the repository
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库中可用的标签列表
- en: The date the repository was created
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库创建的日期
- en: The number of times it has been downloaded
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载次数
- en: Comments from registered users
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册用户的评论
- en: Docker Hub is free to join, and you’ll need an account later in this book. When
    you’re signed in, you can star and comment on repositories. You can create and
    manage your own repositories. We will do that in [part 2](index_split_062.html#filepos666610).
    For now, just get a feel for the site and what it has to offer.
  id: totrans-472
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker Hub免费加入，你将在本书的后面部分需要一个账户。当你登录后，你可以对存储库进行标记和评论。你可以创建和管理自己的存储库。我们将在[第2部分](index_split_062.html#filepos666610)中这样做。现在，只需感受一下网站及其提供的功能。
- en: '|    |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Activity: A Docker Hub scavenger hunt'
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 活动：Docker Hub寻宝游戏
- en: It’s good to practice finding software on Docker Hub by using the skills you
    learned in [chapter 2](index_split_024.html#filepos153412). This activity is designed
    to encourage you to use Docker Hub and practice creating containers. You will
    also be introduced to three new options on the `docker run` command.
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过使用你在[第2章](index_split_024.html#filepos153412)中学到的技能在Docker Hub上寻找软件是很好的练习。这个活动旨在鼓励你使用Docker
    Hub并练习创建容器。你还将了解到`docker run`命令上的三个新选项。
- en: 'In this activity, you’ll create containers from two images that are available
    through Docker Hub. The first is available from the `dockerinaction/ch3_ex2_hunt`
    repository. In that image, you’ll find a small program that prompts you for a
    password. You can find the password only by finding and running a container from
    the second mystery repository on Docker Hub. To use the programs in these images,
    you need to attach your terminal to the containers so that the input and output
    of your terminal are connected directly to the running container. The following
    command demonstrates how to do that and run a container that will be removed automatically
    when stopped:'
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个活动中，你将从Docker Hub上可用的两个图像创建容器。第一个来自`dockerinaction/ch3_ex2_hunt`存储库。在这个图像中，你会找到一个提示你输入密码的小程序。你只能通过找到并运行Docker
    Hub上的第二个神秘存储库中的容器来找到密码。要使用这些图像中的程序，你需要将你的终端连接到容器，以便你的终端的输入和输出直接连接到正在运行的容器。以下命令演示了如何做到这一点并运行一个在停止时自动删除的容器：
- en: '`docker run -it --rm dockerinaction/ch3_ex2_hunt`'
  id: totrans-477
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -it --rm dockerinaction/ch3_ex2_hunt`'
- en: When you run this command, the scavenger hunt program will prompt you for the
    password. If you know the answer already, go ahead and enter it now. If not, just
    enter anything, and it will give you a hint. At this point, you should have all
    the tools you need to complete the activity. The following diagram illustrates
    what you need to do from this point.
  id: totrans-478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你运行此命令时，寻宝游戏程序将提示你输入密码。如果你已经知道答案，请现在输入。如果不知道，随便输入什么，它将给你一个提示。此时，你应该拥有完成活动所需的所有工具。以下图表说明了从这一点开始你需要做什么。
- en: '![](images/00088.jpg)'
  id: totrans-479
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00088.jpg)'
- en: Still stuck? We can give you one more hint. The mystery repository is one that
    was created for this book. Maybe you should try searching for this book’s Docker
    Hub repositories. Remember, repositories are named with a username/repository
    pattern.
  id: totrans-480
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 仍然卡住了？我们可以再给你一个提示。神秘存储库是为这本书创建的。也许你应该尝试搜索这本书的Docker Hub存储库。记住，存储库使用用户名/存储库模式命名。
- en: 'When you get the answer, pat yourself on the back and remove the images by
    using the `docker rmi` command. The commands you run should look something like
    these:'
  id: totrans-481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你得到答案后，给自己鼓掌，并使用`docker rmi`命令删除图像。你运行的命令应该看起来像这样：
- en: '`docker rmi dockerinaction/ch3_ex2_hunt docker rmi <mystery repository>`'
  id: totrans-482
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker rmi dockerinaction/ch3_ex2_hunt docker rmi <mystery repository>`'
- en: If you were following the examples and using the `--rm` option on your `docker
    run` commands, you should have no containers to clean up. You learned a lot in
    this example. You found a new image on Docker Hub and used the `docker run` command
    in a new way. There’s a lot to know about running interactive containers. The
    next section covers that in greater detail.
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您正在遵循示例并使用 `docker run` 命令中的 `--rm` 选项，您应该没有需要清理的容器。在这个示例中，您学到了很多。您在 Docker
    Hub 上找到了一个新的镜像，并以新的方式使用了 `docker run` 命令。关于运行交互式容器有很多东西要了解。下一节将更详细地介绍这一点。
- en: '|    |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: 'Docker Hub is by no means the only source for software. Depending on the goals
    and perspective of software publishers, Docker Hub may not be an appropriate distribution
    point. Closed source or proprietary projects may not want to risk publishing their
    software through a third party. You can install software in three other ways:'
  id: totrans-485
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker Hub 绝对不是软件的唯一来源。根据软件发布者的目标和视角，Docker Hub 可能不是一个合适的分发点。闭源或专有项目可能不想通过第三方风险发布他们的软件。您可以通过以下三种其他方式安装软件：
- en: You can use alternative repository registries or run your own registry.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用替代的仓库注册表或运行自己的注册表。
- en: You can manually load images from a file.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以手动从文件加载镜像。
- en: You can download a project from some other source and build an image by using
    a provided Dockerfile.
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从其他来源下载一个项目，并通过提供的 Dockerfile 构建镜像。
- en: All three options are viable for private projects or corporate infrastructure.
    The next few subsections cover how to install software from each alternative source.
    [Chapter 9](index_split_077.html#filepos910548) covers Docker image distribution
    in detail. After reading this section, you should have a complete picture of your
    options to install software with Docker. When you install software, you should
    have an idea about what is in the software package and the changes being made
    to your computer.
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有三种选项都适用于私有项目或企业基础设施。接下来的几个小节将介绍如何从每个替代来源安装软件。[第 9 章](index_split_077.html#filepos910548)详细介绍了
    Docker 镜像的分布。阅读本节后，您应该对使用 Docker 安装软件的选项有一个完整的了解。当您安装软件时，您应该对软件包的内容以及计算机上所做的更改有所了解。
- en: 3.3\. INSTALLATION FILES AND ISOLATION
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.3\. 安装文件和隔离
- en: 'Understanding how images are identified, discovered, and installed is a minimum
    proficiency for a Docker user. If you understand what files are actually installed
    and how those files are built and isolated at runtime, you’ll be able to answer
    more difficult questions that come up with experience, such as these:'
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 理解镜像是如何被标识、发现和安装的，这是 Docker 用户的基本技能。如果您了解实际上安装了哪些文件以及这些文件是如何在运行时构建和隔离的，您将能够回答随着经验积累而出现的更难的问题，例如这些：
- en: What image properties factor into download and installation speeds?
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些镜像属性会影响下载和安装速度？
- en: What are all these unnamed images that are listed when I use the `docker images`
    command?
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我使用 `docker images` 命令时，列出的所有这些未命名的镜像是什么？
- en: Why does output from the `docker pull` command include messages about pulling
    dependent layers?
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么 `docker pull` 命令的输出包括拉取依赖层的信息？
- en: Where are the files that I wrote to my container’s filesystem?
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我写入容器文件系统的文件在哪里？
- en: Learning this material is the third and final step to understanding software
    installation with Docker, as illustrated in [figure 3.6](#filepos354160).
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 学习这些材料是理解 Docker 软件安装的第三步和最后一步，如图 3.6 所示。[figure 3.6](#filepos354160)。
- en: Figure 3.6\. Step 3—understanding how software is installed
  id: totrans-497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 3.6\. 第 3 步——理解软件的安装过程
- en: '![](images/00040.jpg)'
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00040.jpg)'
- en: So far, when we’ve written about installing software, we’ve used the term image.
    This was to infer that the software you were going to use was in a single image
    and that an image was contained within a single file. Although this may occasionally
    be accurate, most of the time what we’ve been calling an image is actually a collection
    of image layers.
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到目前为止，当我们提到安装软件时，我们使用了术语“镜像”。这是为了推断您将要使用的软件位于单个镜像中，并且镜像包含在一个单独的文件中。尽管这偶尔可能是准确的，但大多数时候我们所说的镜像实际上是一系列镜像层。
- en: A layer is set of files and file metadata that is packaged and distributed as
    an atomic unit. Internally, Docker treats each layer like an image, and layers
    are often called intermediate images. You can even promote a layer to an image
    by tagging it. Most layers build upon a parent layer by applying filesystem changes
    to the parent. For example, a layer might update the software in an image with
    a package manager by using, for example, Debian’s `apt-get update`. The resulting
    image contains the combined set of files from the parent and the layer that was
    added. It is easier to understand layers when you see them in action.
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一层是一组文件和文件元数据，它作为一个原子单元打包和分发。在内部，Docker将每一层视为一个镜像，层通常被称为中间镜像。您甚至可以通过标记来提升一个层为镜像。大多数层通过在父层上应用文件系统更改来构建在父层之上。例如，一个层可能通过使用例如Debian的`apt-get
    update`包管理器来更新镜像中的软件。生成的镜像包含从父层和添加的层中合并的文件集。当您看到它们在行动中时，更容易理解层。
- en: 3.3.1\. Image layers in action
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.3.1. 镜像层在行动中
- en: In this example, you’ll install the two images. Both depend on Java 11\. The
    applications themselves are simple “Hello, World”–style programs. We want you
    to keep an eye on what Docker does when you install each. You should notice how
    long it takes to install the first compared to the second and read what the `docker
    pull` command prints to the terminal. When an image is being installed, you can
    watch Docker determine which dependencies it needs to download and then see the
    progress of the individual image layer downloads. Java is great for this example
    because the layers are quite large, and that will give you a moment to really
    see Docker in action.
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个例子中，您将安装两个镜像。它们都依赖于Java 11。应用程序本身是简单的“Hello, World”风格的程序。我们希望您注意Docker在安装每个应用程序时所做的操作。您应该注意到安装第一个应用程序所需的时间与安装第二个应用程序所需的时间相比有多长，并阅读`docker
    pull`命令打印到终端的内容。当镜像正在安装时，您可以观察Docker确定它需要下载哪些依赖项，然后查看单个镜像层下载的进度。Java非常适合这个例子，因为层相当大，这将给您一个真正看到Docker在行动中的机会。
- en: 'The two images you’re going to install are `dockerinaction/ch3_myapp` and `docker-inaction/ch3_myotherapp`.
    You should just use the `docker pull` command because you need to only see the
    images install, not start a container from them. Here are the commands you should
    run:'
  id: totrans-503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您将要安装的两个镜像分别是`dockerinaction/ch3_myapp`和`docker-in-action/ch3_myotherapp`。您只需使用`docker
    pull`命令即可，因为您只需要看到镜像安装，而不是从它们启动容器。以下是您应该运行的命令：
- en: '`docker pull dockerinaction/ch3_myapp docker pull dockerinaction/ch3_myotherapp`'
  id: totrans-504
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker pull dockerinaction/ch3_myapp docker pull dockerinaction/ch3_myotherapp`'
- en: Did you see it? Unless your network connection is far better than mine, or you
    had already installed OpenJDK 11.0.4 (slim) as a dependency of some other image,
    the download of `dockerinaction/ch3_myapp` should have been much slower than `docker-inaction/ch3_myotherapp`.
  id: totrans-505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您看到了吗？除非您的网络连接比我好得多，或者您已经将OpenJDK 11.0.4（精简版）作为其他镜像的依赖项安装，否则`dockerinaction/ch3_myapp`的下载速度应该比`docker-in-action/ch3_myotherapp`慢得多。
- en: When you installed `ch3_myapp`, Docker determined that it needed to install
    the `openjdk:11.0.4-jdk-slim` image because it’s the direct dependency (parent
    layer) of the requested image. When Docker went to install that dependency, it
    discovered the dependencies of that layer and downloaded those first. Once all
    the dependencies of a layer are installed, that layer is installed. Finally, `openjdk:11.0.4-jdk-slim`
    was installed, and then the tiny `ch3_myapp` layer was installed.
  id: totrans-506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您安装`ch3_myapp`时，Docker确定它需要安装`openjdk:11.0.4-jdk-slim`镜像，因为它是请求的镜像的直接依赖（父层）。当Docker去安装这个依赖项时，它发现了该层的依赖项并首先下载了它们。一旦安装了层的所有依赖项，该层就被安装了。最后，安装了`openjdk:11.0.4-jdk-slim`，然后安装了微小的`ch3_myapp`层。
- en: When you issued the command to install `ch3_myotherapp`, Docker identified that
    `openjdk:11.0.4-jdk-slim` was already installed and immediately installed the
    image for `ch3_myotherapp`. Since the second application shared almost all of
    its image layers with the first application, Docker had much less to do. Installing
    the unique layer of `ch3_myotherapp` was very fast because less than one megabyte
    of data was transferred. But again, to the user it was an identical process.
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您发出安装`ch3_myotherapp`的命令时，Docker确定`openjdk:11.0.4-jdk-slim`已经安装，并立即安装了`ch3_myotherapp`的镜像。由于第二个应用程序几乎与第一个应用程序共享了所有的镜像层，Docker需要做的就少多了。安装`ch3_myotherapp`的独特层非常快，因为数据传输量不到一兆字节。但再次强调，对用户来说，这是一个相同的过程。
- en: From the user perspective, this ability is nice to have, but you wouldn’t want
    to have to try to optimize for it. Just take the benefits where they happen to
    work out. From the perspective of a software or image author, this ability should
    play a major factor in your image design. [Chapter 7](index_split_063.html#filepos667222)
    covers this in more detail.
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从用户的角度来看，这种能力很好，但你不想为了优化它而尝试。只需在它们起作用的地方享受这些好处。从软件或镜像作者的角度来看，这种能力应该在你的镜像设计中扮演一个重要因素。[第
    7 章](index_split_063.html#filepos667222) 将更详细地介绍这一点。
- en: 'If you run `docker images` now, you’ll see the following repositories listed:'
  id: totrans-509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你现在运行 `docker images`，你会看到以下仓库被列出：
- en: '`dockerinaction/ch3_myapp`'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dockerinaction/ch3_myapp`'
- en: '`dockerinaction/ch3_myotherapp`'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dockerinaction/ch3_myotherapp`'
- en: By default, the `docker images` command will show only repositories. As with
    other commands, if you specify the `-a` flag, the list will include every installed
    intermediate image or layer. Running `docker images -a` will show a list that
    includes several repositories and may also include some listed as `<none>`. Unnamed
    images can exist for several reasons, such as building an image without tagging
    it. The only way to refer to these is to use the value in the `IMAGE ID` column.
  id: totrans-512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认情况下，`docker images` 命令将仅显示仓库。与其他命令一样，如果你指定了 `-a` 标志，列表将包括所有安装的中间镜像或层。运行 `docker
    images -a` 将显示一个包括多个仓库的列表，也可能包括一些标记为 `<none>` 的列表。未命名的镜像可能存在多个原因，例如构建一个未标记的镜像。唯一引用这些镜像的方法是使用
    `IMAGE ID` 列中的值。
- en: 'In this example, you installed two images. Let’s clean them up now. You can
    do so more easily if you use the condensed `docker rmi` syntax:'
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个例子中，你安装了两个镜像。现在让我们清理它们。如果你使用压缩的 `docker rmi` 语法，这将更容易完成：
- en: '`docker rmi \     dockerinaction/ch3_myapp \     dockerinaction/ch3_myotherapp`'
  id: totrans-514
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker rmi \   dockerinaction/ch3_myapp \   dockerinaction/ch3_myotherapp`'
- en: The `docker rmi` command allows you to specify a space-separated list of images
    to be removed. This comes in handy when you need to remove a small set of images
    after an example. We’ll be using this when appropriate throughout the rest of
    the examples in this book.
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker rmi` 命令允许你指定一个由空格分隔的镜像列表以进行删除。当你需要在示例之后删除一小组镜像时，这非常有用。我们将在本书的其余示例中适当使用此命令。'
- en: 3.3.2\. Layer relationships
  id: totrans-516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.3.2\. 层关系
- en: Images maintain parent/child relationships. In these relationships, they build
    from their parents and form layers. The files available to a container are the
    union of all layers in the lineage of the image that the container was created
    from. Images can have relationships with any other image, including images in
    different repositories with different owners. The two application images in [section
    3.3.1](#filepos356103) use an OpenJDK 11.0.4 image as their parent. The OpenJDK
    image’s parent is a minimal version of the Debian Linux Buster operating system
    release. [Figure 3.7](#filepos365271) illustrates the full image ancestry of both
    images and the layers contained in each image.
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 镜像保持父/子关系。在这些关系中，它们从父级构建并形成层。容器可用的文件是容器创建时使用的镜像世系中所有层的并集。镜像可以与其他任何镜像建立关系，包括来自不同仓库、不同所有者的镜像。在
    [3.3.1 节](#filepos356103) 中的两个应用程序镜像使用 OpenJDK 11.0.4 镜像作为它们的父级。OpenJDK 镜像的父级是
    Debian Linux Buster 操作系统发布的最小版本。[图 3.7](#filepos365271) 展示了两个镜像的完整镜像世系以及每个镜像中包含的层。
- en: Figure 3.7\. The full lineage of the two Docker images used in [section 3.3.1](#filepos356103)
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 3.7\. 两个 Docker 镜像在 [3.3.1 节](#filepos356103) 中使用的完整世系
- en: '![](images/00041.jpg)'
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00041.jpg)'
- en: The images and layers in [figure 3.7](#filepos365271) show that the application
    images will inherit three layers from `openjdk:11.0.4-jdk-slim` and one more layer
    from `debian:buster-slim`. The three layers from OpenJDK contain common libraries
    and dependencies of the Java 11 software, and the Debian image contributes a minimal
    operating system toolchain.
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 3.7](#filepos365271) 中的镜像和层显示，应用程序镜像将从 `openjdk:11.0.4-jdk-slim` 继承三个层，并从
    `debian:buster-slim` 继承一个额外的层。来自 OpenJDK 的三个层包含 Java 11 软件的公共库和依赖项，而 Debian 镜像贡献了一个最小化的操作系统工具链。'
- en: An image is named when its author tags and publishes it. A user can create aliases,
    as you did in [chapter 2](index_split_024.html#filepos153412) by using the `docker
    tag` command. Until an image is tagged, the only way to refer to it is to use
    its unique identifier (ID) that was generated when the image was built. In [figure
    3.7](#filepos365271), the parent image of the OpenJDK 11.0.4 image is the Debian
    Buster OS whose ID is `83ed3c583403`. The Debian image authors tagged and published
    this image as `debian:buster-slim`. The figure labels these images with the first
    12 digits of their image ID, a common convention. Docker truncates the ID from
    65 (base 16) digits to 12 in output of common commands for the benefit of its
    human users. Internally and through API access, Docker uses the full 65\.
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当一个镜像被作者标记并发布时，它就有了一个名字。用户可以创建别名，就像你在[第2章](index_split_024.html#filepos153412)中通过使用`docker
    tag`命令所做的那样。在镜像被标记之前，唯一引用它的方式是使用在镜像构建时生成的唯一标识符（ID）。在[图3.7](#filepos365271)中，OpenJDK
    11.0.4镜像的父镜像是一个ID为`83ed3c583403`的Debian Buster操作系统。Debian镜像的作者标记并发布了这个镜像为`debian:buster-slim`。图中用这些镜像的ID的前12位来标记这些镜像，这是一个常见的约定。Docker将ID从65（十六进制）位截断到12位，以便在常见命令的输出中为人类用户提供便利。在内部和通过API访问时，Docker使用完整的65位。
- en: Even these “slim” Java images are sizable and were chosen to illustrate a point.
    At the time of this writing, the `openjdk:11.0.4-jdk-slim` image is 401 MB. You
    get some space savings when you use the runtime-only images, but even `openjdk:11.0.4-jre-slim-buster`
    is 204 MB. Because Docker uniquely identifies images and layers, it is able to
    recognize shared image dependencies between applications and avoid downloading
    those dependencies again. This is done without requiring any coordination between
    applications at runtime, only build time. [Chapter 10](index_split_084.html#filepos1058777)
    discusses image build pipelines in depth. Let’s continue by examining container
    filesystems.
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 即使这些“精简”的Java镜像也相当大，并且被选择来阐述一个观点。在撰写本文时，`openjdk:11.0.4-jdk-slim`镜像大小为401 MB。当你使用仅运行时镜像时，你可以节省一些空间，但即使是`openjdk:11.0.4-jre-slim-buster`也有204
    MB。因为Docker能够唯一标识镜像和层，所以它能够识别应用程序之间的共享镜像依赖关系，并避免再次下载这些依赖关系。这是在运行时不需要任何协调的情况下完成的，只在构建时进行。[第10章](index_split_084.html#filepos1058777)深入讨论了镜像构建管道。让我们继续通过检查容器文件系统来探讨。
- en: 3.3.3\. Container filesystem abstraction and isolation
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.3.3\. 容器文件系统抽象和隔离
- en: Programs running inside containers know nothing about image layers. From inside
    a container, the filesystem operates as though it’s not running in a container
    or operating on an image. From the perspective of the container, it has exclusive
    copies of the files provided by the image. This is made possible with something
    called a union file-system (UFS).
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在容器内运行的程序对镜像层一无所知。从容器内部看，文件系统就像它没有在容器中运行或操作镜像一样运行。从容器的角度来看，它拥有由镜像提供的文件的独家副本。这是通过一种称为联合文件系统（UFS）的技术实现的。
- en: Docker uses a variety of union filesystems and will select the best fit for
    your system. The details of how the union filesystem works are beyond what you
    need to know to use Docker effectively. A union filesystem is part of a critical
    set of tools that combine to create effective filesystem isolation. The other
    tools are MNT namespaces and the `chroot` system call.
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker使用多种联合文件系统，并将选择最适合您系统的文件系统。联合文件系统如何工作的细节超出了您使用Docker有效所需了解的内容。联合文件系统是创建有效文件系统隔离的一组关键工具之一。其他工具是MNT命名空间和`chroot`系统调用。
- en: The filesystem is used to create mount points on your host’s filesystem that
    abstract the use of layers. The layers created are bundled into Docker image layers.
    Likewise, when a Docker image is installed, its layers are unpacked and appropriately
    configured for use by the specific filesystem provider chosen for your system.
  id: totrans-526
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 文件系统用于在宿主机的文件系统中创建挂载点，以抽象层的使用。创建的层被打包进Docker镜像层中。同样，当安装Docker镜像时，其层会被解包并适当地配置，以便为系统选择的特定文件系统提供者使用。
- en: The Linux kernel provides a namespace for the MNT system. When Docker creates
    a container, that new container will have its own MNT namespace, and a new mount
    point will be created for the container to the image.
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Linux内核为MNT系统提供了一个命名空间。当Docker创建一个容器时，这个新容器将拥有自己的MNT命名空间，并为容器创建一个新的挂载点到镜像。
- en: Lastly, `chroot` is used to make the root of the image filesystem the root in
    the container’s context. This prevents anything running inside the container from
    referencing any other part of the host filesystem.
  id: totrans-528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，`chroot`用于将图像文件系统的根设置为容器上下文中的根。这防止了容器内运行的任何内容引用主机文件系统的任何其他部分。
- en: Using `chroot` and MNT namespaces is common for container technologies. By adding
    a union filesystem to the recipe, Docker containers have several benefits.
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用`chroot`和MNT命名空间对于容器技术来说是常见的。通过在配方中添加联合文件系统，Docker容器具有几个好处。
- en: 3.3.4\. Benefits of this toolset and filesystem structure
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.3.4. 此工具集和文件系统结构的优点
- en: The first and perhaps most important benefit of this approach is that common
    layers need to be installed only once. If you install any number of images and
    they all depend on a common layer, that common layer and all of its parent layers
    will need to be downloaded or installed only once. This means you might be able
    to install several specializations of a program without storing redundant files
    on your computer or downloading redundant layers. By contrast, most virtual machine
    technologies will store the same files as many times as you have redundant virtual
    machines on a computer.
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种方法的第一个也许是最重要的好处是，常见的层只需要安装一次。如果你安装了任意数量的图像，并且它们都依赖于一个共同的层，那么这个共同的层以及它的所有父层只需要下载或安装一次。这意味着你可能能够安装一个程序的多个专业版本，而无需在电脑上存储冗余文件或下载冗余层。相比之下，大多数虚拟机技术会在电脑上存储与冗余虚拟机数量相同的相同文件。
- en: Second, layers provide a coarse tool for managing dependencies and separating
    concerns. This is especially handy for software authors, and [chapter 7](index_split_063.html#filepos667222)
    talks more about this. From a user perspective, this benefit will help you quickly
    identify what software you’re running by examining which images and layers you’re
    using.
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 其次，层提供了一个粗略的工具来管理依赖关系和分离关注点。这对于软件作者来说特别有用，第7章将更多地讨论这一点。从用户的角度来看，这个好处将帮助你通过检查你使用的图像和层来快速识别你正在运行的软件。
- en: Lastly, it’s easy to create software specializations when you can layer minor
    changes on top of a basic image. That’s another subject covered in detail in [chapter
    7](index_split_063.html#filepos667222). Providing specialized images helps users
    get exactly what they need from software with minimal customization. This is one
    of the best reasons to use Docker.
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，当你可以在基本图像上叠加少量更改以创建软件专业版本时，创建软件专业版本变得很容易。这是第7章详细讨论的另一个主题。提供专业图像有助于用户以最小的定制从软件中获得他们所需的一切。这是使用Docker的最好理由之一。
- en: 3.3.5\. Weaknesses of union filesystems
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3.3.5. 联合文件系统的弱点
- en: Docker selects sensible defaults when it is started, but no implementation is
    perfect for every workload. In fact, in some specific use cases, you should pause
    and consider using another Docker feature.
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker在启动时选择合理的默认值，但没有一个实现适合所有工作负载。实际上，在某些特定用例中，你应该暂停并考虑使用另一个Docker功能。
- en: Different filesystems have different rules about file attributes, sizes, names,
    and characters. Union filesystems are in a position where they often need to translate
    between the rules of different filesystems. In the best cases, they’re able to
    provide acceptable translations. In the worst cases, features are omitted. For
    example, neither Btrfs nor OverlayFS provides support for the extended attributes
    that make SELinux work.
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不同的文件系统对文件属性、大小、名称和字符有不同的规则。联合文件系统处于一个位置，它们经常需要在不同文件系统的规则之间进行转换。在最好的情况下，它们能够提供可接受的转换。在最坏的情况下，功能会被省略。例如，Btrfs和OverlayFS都不提供支持SELinux工作的扩展属性。
- en: Union filesystems use a pattern called copy-on-write, and that makes implementing
    memory-mapped files (the `mmap` system call) difficult. Some union filesystems
    provide implementations that work under the right conditions, but it may be a
    better idea to avoid memory-mapping files from an image.
  id: totrans-537
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 联合文件系统使用一种称为写时复制的模式，这使得实现内存映射文件（`mmap`系统调用）变得困难。一些联合文件系统提供了在适当条件下工作的实现，但避免从图像中映射内存可能是一个更好的主意。
- en: The backing filesystem is another pluggable feature of Docker. You can determine
    which filesystem your installation is using with the `info` subcommand. If you
    want to specifically tell Docker which filesystem to use, do so with the `--storage-driver`
    or `-s` option when you start the Docker daemon. Most issues that arise with writing
    to the union filesystem can be addressed without changing the storage provider.
    These can be solved with volumes, the subject of [chapter 4](index_split_037.html#filepos379268).
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 后端文件系统是Docker的另一个可插拔功能。您可以使用`info`子命令确定您的安装正在使用哪个文件系统。如果您想特别告诉Docker使用哪个文件系统，可以在启动Docker守护进程时使用`--storage-driver`或`-s`选项。大多数与写入联合文件系统相关的问题都可以在不更改存储提供者的情况下解决。这些问题可以通过卷来解决，这是第4章的主题[第4章](index_split_037.html#filepos379268)。
- en: SUMMARY
  id: totrans-539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: 'The task of installing and managing software on a computer presents a unique
    set of challenges. This chapter explains how you can use Docker to address them.
    The core ideas and features covered by this chapter are as follows:'
  id: totrans-540
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在计算机上安装和管理软件的任务带来了一系列独特的挑战。本章解释了如何使用Docker来应对这些挑战。本章涵盖的核心思想和功能如下：
- en: Human users of Docker use repository names to communicate which software they
    would like Docker to install.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker的用户使用存储库名称来告知Docker他们希望安装哪种软件。
- en: Docker Hub is the default Docker registry. You can find software on Docker Hub
    through either the website or the `docker` command-line program.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Hub是默认的Docker注册库。您可以通过网站或`docker`命令行程序在Docker Hub上找到软件。
- en: The `docker` command-line program makes it simple to install software that’s
    distributed through alternative registries or in other forms.
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker`命令行程序使得安装通过替代注册库或其他形式分发的软件变得简单。'
- en: The image repository specification includes a registry host field.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图片存储库规范包括一个注册主机字段。
- en: The `docker load` and `docker save` commands can be used to load and save images
    from TAR archives.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker load`和`docker save`命令可以用来从TAR存档中加载和保存镜像。'
- en: Distributing a Dockerfile with a project simplifies image builds on user machines.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Dockerfile与项目一起分发简化了用户机器上的镜像构建。
- en: Images are usually related to other images in parent/child relationships. These
    relationships form layers. When we say that we have installed an image, we are
    saying that we have installed a target image and each image layer in its lineage.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像通常与其他镜像以父/子关系相关联。这些关系形成层。当我们说我们安装了一个镜像时，我们是在说我们安装了一个目标镜像及其世系中的每个镜像层。
- en: Structuring images with layers enables layer reuse and saves bandwidth during
    distribution and storage space on your computer and image distribution servers.
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过层结构镜像可以启用层重用，并在分发和存储过程中节省带宽，同时减少您计算机和镜像分发服务器上的存储空间。
- en: Chapter 4\. Working with storage and volumes
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第4章：与存储和卷一起工作
- en: This chapter covers
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introducing mount points
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍挂载点
- en: How to share data between the host and a container
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在主机和容器之间共享数据
- en: How to share data between containers
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在容器之间共享数据
- en: Using temporary, in-memory filesystems
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用临时、内存文件系统
- en: Managing data with volumes
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用卷管理数据
- en: Advanced storage with volume plugins
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用卷插件的高级存储
- en: At this point in the book, you’ve installed and run a few programs. You’ve seen
    a few toy examples but haven’t run anything that resembles the real world. The
    difference between the examples in the first three chapters and the real world
    is that in the real world, programs work with data. This chapter introduces Docker
    volumes and strategies that you’ll use to manage data with containers.
  id: totrans-557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到这本书的这一部分，你已经安装并运行了一些程序。你看到了一些玩具示例，但还没有运行过任何类似真实世界的程序。第一、二、三章中的示例与真实世界之间的区别在于，在真实世界中，程序与数据一起工作。本章介绍了Docker卷和策略，这些策略将用于管理容器中的数据。
- en: Consider what it might look like to run a database program inside a container.
    You would package the software with the image, and when you start the container,
    it might initialize an empty database. When programs connect to the database and
    enter data, where is that data stored? Is it in a file inside the container? What
    happens to that data when you stop the container or remove it? How would you move
    your data if you wanted to upgrade the database program? What happens to that
    storage on a cloud machine when it is terminated?
  id: totrans-558
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑在容器内运行数据库程序可能的样子。您会将与镜像打包的软件，当您启动容器时，它可能会初始化一个空数据库。当程序连接到数据库并输入数据时，这些数据存储在哪里？是在容器内的文件中吗？当您停止容器或删除它时，这些数据会发生什么？如果您想升级数据库程序，您会如何移动数据？当云机器终止时，该存储会发生什么？
- en: Consider another situation where you’re running a couple of different web applications
    inside different containers. Where would you write log files so that they will
    outlive the container? How would you get access to those logs to troubleshoot
    a problem? How can other programs such as log digest tools get access to those
    files?
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑另一种情况，你正在不同的容器中运行几个不同的网络应用程序。你会在哪里写入日志文件，以便它们能够比容器存活得更久？你将如何访问这些日志来解决问题？其他程序，如日志摘要工具，如何访问这些文件？
- en: The union filesystem is not appropriate for working with long-lived data or
    sharing data between containers, or a container and the host. The answer to all
    these questions involves managing the container filesystem and mount points.
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 联合文件系统不适合处理长期数据或容器之间、容器与主机之间的数据共享。所有这些问题的答案都涉及到管理容器文件系统和挂载点。
- en: 4.1\. FILE TREES AND MOUNT POINTS
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.1\. 文件树和挂载点
- en: Unlike other operating systems, Linux unifies all storage into a single tree.
    Storage devices such as disk partitions or USB disk partitions are attached to
    specific locations in that tree. Those locations are called mount points. A mount
    point defines the location in the tree, the access properties to the data at that
    point (for example, writability), and the source of the data mounted at that point
    (for example, a specific hard disk, USB device, or memory-backed virtual disk).
    [Figure 4.1](#filepos383411) depicts a filesystem constructed from multiple storage
    devices, with each device mounted to a specific location and level of access.
  id: totrans-562
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与其他操作系统不同，Linux 将所有存储统一到一个单一的树中。例如，磁盘分区或 USB 磁盘分区被连接到该树中的特定位置。这些位置被称为挂载点。挂载点定义了树中的位置，该位置数据的访问属性（例如，可写性），以及在该位置挂载的数据源（例如，特定的硬盘、USB
    设备或内存支持的虚拟磁盘）。[图 4.1](#filepos383411)展示了由多个存储设备构成的文件系统，每个设备都挂载到特定的位置和访问级别。
- en: Figure 4.1\. Storage devices attached to a filesystem tree at their mount point
  id: totrans-563
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 4.1\. 挂载点处连接到文件系统树的存储设备
- en: '![](images/00008.jpg)'
  id: totrans-564
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00008.jpg)'
- en: Mount points allow software and users to use the file tree in a Linux environment
    without knowing exactly how that tree is mapped into specific storage devices.
    This is particularly useful in container environments.
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 挂载点允许软件和用户在 Linux 环境中使用文件树，而无需确切知道该树是如何映射到特定存储设备的。这在容器环境中尤其有用。
- en: Every container has something called a MNT namespace and a unique file tree
    root. This is discussed in detail in [chapter 6](index_split_053.html#filepos544857).
    For now, it is enough to understand that the image that a container is created
    from is mounted at that container’s file tree root, or at the `/` point, and that
    every container has a different set of mount points.
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个容器都有一个称为 MNT 命名空间和唯一的文件树根。这将在第 6 章[文件位置 544857](index_split_053.html#filepos544857)中详细讨论。现在，只需理解从该容器创建的镜像被挂载在该容器的文件树根，或者挂载在
    `/` 点，并且每个容器都有一个不同的挂载点集合即可。
- en: Logic follows that if different storage devices can be mounted at various points
    in a file tree, we can mount nonimage-related storage at other points in a container
    file tree. That is exactly how containers get access to storage on the host filesystem
    and share storage between containers.
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果不同的存储设备可以在文件树的各个位置挂载，我们可以在容器文件树的其它位置挂载非镜像相关的存储。这正是容器如何访问主机文件系统上的存储并在容器之间共享存储的方式。
- en: 'The rest of this chapter elaborates on how to manage storage and the mount
    points in containers. The best place to start is by understanding the three most
    common types of storage mounted into containers:'
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章的其余部分将详细阐述如何管理容器中的存储和挂载点。最好的开始方式是理解三种最常见的被挂载到容器中的存储类型：
- en: Bind mounts
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定挂载
- en: In-memory storage
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存存储
- en: Docker volumes
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 卷
- en: These storage types can be used in many ways. [Figure 4.2](#filepos386647) shows
    an example of a container filesystem that starts with the files from the image,
    adds an in-memory `tmpfs` at `/tmp`, bind-mounts a configuration file from the
    host, and writes logs into a Docker volume on the host.
  id: totrans-572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些存储类型可以以多种方式使用。[图 4.2](#filepos386647)展示了从镜像文件开始，添加内存中的`tmpfs`到`/tmp`，从主机绑定挂载配置文件，并将日志写入主机
    Docker 卷的容器文件系统示例。
- en: Figure 4.2\. Example of common container storage mounts
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 4.2\. 常见容器存储挂载示例
- en: '![](images/00029.jpg)'
  id: totrans-574
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00029.jpg)'
- en: All three types of mount points can be created using the `--mount` flag on the
    `docker run` and `docker create` subcommands.
  id: totrans-575
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有三种类型的挂载点都可以使用`docker run`和`docker create`子命令上的`--mount`标志创建。
- en: 4.2\. BIND MOUNTS
  id: totrans-576
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.2\. 绑定挂载
- en: Bind mounts are mount points used to remount parts of a filesystem tree onto
    other locations. When working with containers, bind mounts attach a user-specified
    location on the host filesystem to a specific point in a container file tree.
    Bind mounts are useful when the host provides a file or directory that is needed
    by a program running in a container, or when that containerized program produces
    a file or log that is processed by users or programs running outside containers.
  id: totrans-577
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 绑定挂载是用于将文件系统树的一部分重新挂载到其他位置的挂载点。当与容器一起工作时，绑定挂载将主机文件系统中的一个用户指定位置连接到容器文件树中的特定点。绑定挂载在主机提供容器中运行的程序所需的文件或目录时非常有用，或者当容器化程序产生的文件或日志被容器外运行的用户或程序处理时。
- en: Consider the example in [figure 4.3](#filepos388910). Suppose you’re running
    a web server that depends on sensitive configuration on the host and emits access
    logs that need to be forwarded by your log-shipping system. You could use Docker
    to launch the web server in a container and bind-mount the configuration location
    as well as the location where you want the web server to write logs.
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑[图4.3](#filepos388910)中的示例。假设你正在运行一个依赖于主机敏感配置并需要通过你的日志传输系统转发访问日志的Web服务器。你可以使用Docker在容器中启动Web服务器，并将配置位置以及你希望Web服务器写入日志的位置绑定挂载。
- en: Figure 4.3\. Host files shared as a bind-mount volumes
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图4.3\. 作为绑定挂载卷共享的主机文件
- en: '![](images/00019.jpg)'
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00019.jpg)'
- en: 'You can try this for yourself. Create a placeholder log file and create a special
    NGINX configuration file named example.conf. Run the following commands to create
    and populate the files:'
  id: totrans-581
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以亲自尝试。创建一个占位符日志文件，并创建一个名为example.conf的特殊NGINX配置文件。运行以下命令来创建和填充文件：
- en: '`touch ~/example.log cat >~/example.conf <<EOF server {   listen 80;   server_name
    localhost;   access_log /var/log/nginx/custom.host.access.log main;   location
    / {     root /usr/share/nginx/html;     index index.html index.htm;   } } EOF`'
  id: totrans-582
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`touch ~/example.log cat >~/example.conf <<EOF server {   listen 80;   server_name
    localhost;   access_log /var/log/nginx/custom.host.access.log main;   location
    / {     root /usr/share/nginx/html;     index index.html index.htm;   } } EOF`'
- en: 'Once a server is started with this configuration file, it will offer the NGINX
    default site at http://localhost/, and access logs for that site will be written
    to a file in the container at /var/log/nginx/custom.host.access.log. The following
    command will start an NGINX HTTP server in a container where your new configuration
    is bind-mounted to the server’s configuration root:'
  id: totrans-583
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦使用此配置文件启动服务器，它将在http://localhost/提供NGINX默认站点，并且该站点的访问日志将写入容器中的文件/var/log/nginx/custom.host.access.log。以下命令将在容器中启动NGINX
    HTTP服务器，其中你的新配置绑定挂载到服务器的配置根：
- en: '`CONF_SRC=~/example.conf; \ CONF_DST=/etc/nginx/conf.d/default.conf; \  LOG_SRC=~/example.log;
    \ LOG_DST=/var/log/nginx/custom.host.access.log; \ docker run -d --name diaweb
    \   --mount type=bind,src=${CONF_SRC},dst=${CONF_DST} \   --mount type=bind,src=${LOG_SRC},dst=${LOG_DST}
    \   -p 80:80 \   nginx:latest`'
  id: totrans-584
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`CONF_SRC=~/example.conf; \ CONF_DST=/etc/nginx/conf.d/default.conf; \ LOG_SRC=~/example.log;
    \ LOG_DST=/var/log/nginx/custom.host.access.log; \ docker run -d --name diaweb
    \   --mount type=bind,src=${CONF_SRC},dst=${CONF_DST} \   --mount type=bind,src=${LOG_SRC},dst=${LOG_DST}
    \   -p 80:80 \   nginx:latest`'
- en: 'With this container running, you should be able to point your web browser at
    http://localhost/ and see the NGINX hello-world page, and you will not see any
    access logs in the container log stream: `docker logs diaweb`. However, you will
    be able to see those logs if you examine the example.log file in your home directory:
    `cat ~/example.log`.'
  id: totrans-585
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当这个容器运行时，你应该能够将你的网络浏览器指向http://localhost/并看到NGINX的hello-world页面，并且你将不会在容器日志流中看到任何访问日志：`docker
    logs diaweb`。然而，如果你检查家目录中的example.log文件，你将能够看到这些日志：`cat ~/example.log`。
- en: In this example you used the `--mount` option with the `type=bind` option. The
    other two mount parameters, `src` and `dst`, define the source location on the
    host file tree and the destination location on the container file tree. You must
    specify locations with absolute paths, but in this example, we used shell expansion
    and shell variables to make the command easier to read.
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个示例中，你使用了带有`type=bind`选项的`--mount`选项。其他两个挂载参数`src`和`dst`定义了主机文件树中的源位置和容器文件树中的目标位置。你必须指定带有绝对路径的位置，但在这个示例中，我们使用了shell扩展和shell变量来使命令更容易阅读。
- en: This example touches on an important feature of volumes. When you mount a volume
    on a container filesystem, it replaces the content that the image provides at
    that location. By default, the `nginx:latest` image provides some default configuration
    at /etc/nginx/conf.d/default.conf, but when you created the bind mount with a
    destination at that path, the content provided by the image was overridden by
    the content on the host. This behavior is the basis for the polymorphic container
    pattern discussed later in the chapter.
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个示例涉及到卷的一个重要特性。当你在一个容器文件系统上挂载一个卷时，它会替换掉在该位置由镜像提供的内容。默认情况下，`nginx:latest` 镜像在
    `/etc/nginx/conf.d/default.conf` 提供了一些默认配置，但当你创建了一个指向该路径的绑定挂载时，镜像提供的内容被主机上的内容覆盖了。这种行为是本章后面讨论的多态容器模式的基础。
- en: 'Expanding on this use case, suppose you want to make sure that the NGINX web
    server can’t change the contents of the configuration volume. Even the most trusted
    software can contain vulnerabilities, and it’s best to minimize the impact of
    an attack on your website. Fortunately, Linux provides a mechanism to make mount
    points read-only. You can do this by adding the `readonly=true` argument to the
    mount specification. In the example, you should change the `run` command to something
    like the following:'
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在扩展这个用例的基础上，假设你想确保 NGINX 网络服务器不能更改配置卷的内容。即使是受信任的软件也可能包含漏洞，因此最好尽量减少攻击对您网站的影响。幸运的是，Linux
    提供了一种机制来使挂载点只读。你可以通过在挂载指定中添加 `readonly=true` 参数来实现这一点。在示例中，你应该将 `run` 命令更改为以下类似的内容：
- en: '`docker rm -f diaweb  CONF_SRC=~/example.conf; \ CONF_DST=/etc/nginx/conf.d/default.conf;
    \ LOG_SRC=~/example.log; \ LOG_DST=/var/log/nginx/custom.host.access.log; \ docker
    run -d --name diaweb \   --mount type=bind,src=${CONF_SRC},dst=${CONF_DST},readonly=true
    \` `1` `--mount type=bind,src=${LOG_SRC},dst=${LOG_DST} \   -p 80:80 \   nginx:latest`'
  id: totrans-589
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker rm -f diaweb  CONF_SRC=~/example.conf; \ CONF_DST=/etc/nginx/conf.d/default.conf;
    \ LOG_SRC=~/example.log; \ LOG_DST=/var/log/nginx/custom.host.access.log; \ docker
    run -d --name diaweb \ --mount type=bind,src=${CONF_SRC},dst=${CONF_DST},readonly=true
    \` `1` `--mount type=bind,src=${LOG_SRC},dst=${LOG_DST} \ --mount type=bind,src=${CONF_SRC},dst=${CONF_DST},readonly=true
    \ -p 80:80 \ nginx:latest`'
- en: 1 Note the readonly flag.
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 注意只读标志。
- en: 'By creating the read-only mount, you can prevent any process inside the container
    from modifying the content of the volume. You can see this in action by running
    a quick test:'
  id: totrans-591
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过创建只读挂载，你可以防止容器内的任何进程修改卷的内容。你可以通过运行一个快速测试来看到这个效果：
- en: '`docker exec diaweb \     sed -i "s/listen 80/listen 8080/" /etc/nginx/conf.d/default.conf`'
  id: totrans-592
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker exec diaweb \ sed -i "s/listen 80/listen 8080/" /etc/nginx/conf.d/default.conf`'
- en: This command executes a `sed` command inside the `diaweb` container and attempts
    to modify the configuration file. The command fails because the file is mounted
    as read-only.
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个命令在 `diaweb` 容器内执行了一个 `sed` 命令并尝试修改配置文件。命令失败，因为文件被挂载为只读。
- en: The first problem with bind mounts is that they tie otherwise portable container
    descriptions to the filesystem of a specific host. If a container description
    depends on content at a specific location on the host filesystem, that description
    isn’t portable to hosts where the content is unavailable or available in some
    other location.
  id: totrans-594
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 绑定挂载的第一个问题是，它们将原本可移植的容器描述与特定主机的文件系统绑定在一起。如果一个容器描述依赖于主机文件系统上的特定位置的内容，那么这个描述就不适用于内容不可用或在其他位置可用的主机。
- en: The next big problem is that they create an opportunity for conflict with other
    containers. It would be a bad idea to start multiple instances of Cassandra that
    all use the same host location as a bind mount for data storage. In that case,
    each of the instances would compete for the same set of files. Without other tools
    such as file locks, that would likely result in corruption of the database.
  id: totrans-595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接下来的一个大问题是，它们为与其他容器的冲突创造了机会。启动多个使用相同主机位置作为数据存储绑定挂载的 Cassandra 实例是个坏主意。在这种情况下，每个实例都会竞争同一组文件。如果没有其他工具如文件锁，这很可能会导致数据库损坏。
- en: Bind mounts are appropriate tools for workstations, machines with specialized
    concerns, or in systems combined with more traditional configuration management
    tooling. It’s better to avoid these kinds of specific bindings in generalized
    platforms or hardware pools.
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 绑定挂载是适用于工作站、具有特定关注点的机器或与更传统的配置管理工具结合使用的系统中的适当工具。在通用平台或硬件池中最好避免这些类型的特定绑定。
- en: 4.3\. IN-MEMORY STORAGE
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.3\. 内存存储
- en: Most service software and web applications use private key files, database passwords,
    API key files, or other sensitive configuration files, and need upload buffering
    space. In these cases, it is important that you never include those types of files
    in an image or write them to disk. Instead, you should use in-memory storage.
    You can add in-memory storage to containers with a special type of mount.
  id: totrans-598
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大多数服务软件和 Web 应用程序使用私有密钥文件、数据库密码、API 密钥文件或其他敏感配置文件，并需要上传缓冲空间。在这些情况下，您绝对不应将这些类型的文件包含在镜像中或将它们写入磁盘。相反，您应使用内存存储。您可以通过特殊类型的挂载将内存存储添加到容器中。
- en: 'Set the `type` option on the `mount` flag to `tmpfs`. This is the easiest way
    to mount a memory-based filesystem into a container’s file tree. Consider this
    command:'
  id: totrans-599
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将 `mount` 标志上的 `type` 选项设置为 `tmpfs`。这是将基于内存的文件系统挂载到容器文件树的最简单方法。考虑以下命令：
- en: '`docker run --rm \     --mount type=tmpfs,dst=/tmp \     --entrypoint mount
    \     alpine:latest -v`'
  id: totrans-600
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --rm \   --mount type=tmpfs,dst=/tmp \   --entrypoint mount \   alpine:latest
    -v`'
- en: 'This command creates an empty `tmpfs` device and attaches it to the new container’s
    file tree at /tmp. Any files created under this file tree will be written to memory
    instead of disk. More than that, the mount point is created with sensible defaults
    for generic workloads. Running the command will display a list of all the mount
    points for the container. The list will include the following line:'
  id: totrans-601
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此命令创建一个空的 `tmpfs` 设备并将其附加到新容器文件树中的 `/tmp`。在此文件树下创建的任何文件都将写入内存而不是磁盘。不仅如此，挂载点使用适用于通用工作负载的合理默认值创建。运行此命令将显示容器所有挂载点的列表。列表将包括以下行：
- en: '`tmpfs on /tmp type tmpfs (rw,nosuid,nodev,noexec,relatime)`'
  id: totrans-602
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`tmpfs on /tmp type tmpfs (rw,nosuid,nodev,noexec,relatime)`'
- en: 'This line describes the mount-point configuration. From left-to-right it indicates
    the following:'
  id: totrans-603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这一行描述了挂载点配置。从左到右，它表示以下内容：
- en: A `tmpfs` device is mounted to the tree at /tmp.
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tmpfs` 设备已挂载到 `/tmp` 树。'
- en: The device has a `tmpfs` filesystem.
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该设备具有 `tmpfs` 文件系统。
- en: The tree is read/write capable.
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该树具有读写能力。
- en: '`suid` bits will be ignored on all files in this tree.'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此树中的所有文件上都将忽略 `suid` 位。
- en: No files in this tree will be interpreted as special devices.
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此树中的文件不会被解释为特殊设备。
- en: No files in this tree will be executable.
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此树中的文件将不可执行。
- en: File access times will be updated if they are older than the current modify
    or change time.
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们的访问时间比当前的修改或更改时间旧，则将更新文件访问时间。
- en: 'Additionally, the `tmpfs` device will not have any size limits by default and
    will be world-writable (has file permissions 1777 in octal). You can add a size
    limit and change the file mode with two additional options: `tmpfs-size` and `tmpfs-mode`:'
  id: totrans-611
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，`tmpfs` 设备默认没有大小限制，并且可由世界范围内的用户写入（八进制文件权限为 1777）。您可以使用两个附加选项 `tmpfs-size`
    和 `tmpfs-mode` 添加大小限制并更改文件模式：
- en: '`docker run --rm \     --mount type=tmpfs,dst=/tmp,tmpfs-size=16k,tmpfs-mode=1770
    \     --entrypoint mount \     alpine:latest -v`'
  id: totrans-612
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --rm \   --mount type=tmpfs,dst=/tmp,tmpfs-size=16k,tmpfs-mode=1770
    \   --entrypoint mount \   alpine:latest -v`'
- en: This command limits the `tmpfs` device mounted at /tmp to 16 KB and is not readable
    by `other` in-container users.
  id: totrans-613
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此命令将 `/tmp` 上挂载的 `tmpfs` 设备限制为 16 KB，并且容器内的 `other` 用户无法读取。
- en: 4.4\. DOCKER VOLUMES
  id: totrans-614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.4. DOCKER 卷
- en: Docker volumes are named filesystem trees managed by Docker. They can be implemented
    with disk storage on the host filesystem, or another more exotic backend such
    as cloud storage. All operations on Docker volumes can be accomplished using the
    `docker volume` subcommand set. Using volumes is a method of decoupling storage
    from specialized locations on the filesystem that you might specify with bind
    mounts.
  id: totrans-615
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker 卷是由 Docker 管理的命名文件系统树。它们可以使用主机文件系统上的磁盘存储，或使用云存储等其他更复杂的后端。可以使用 `docker
    volume` 子命令集完成对 Docker 卷的所有操作。使用卷是将存储与文件系统上可能通过绑定挂载指定的专用位置解耦的方法。
- en: If you were to convert the web server and log-forwarding container example from
    [section 4.2](index_split_039.html#filepos387539) to use a volume for sharing
    access to the logs, the pair could run on any machine without considering other
    software that might have a conflict with static locations on disk. That example
    would look like [figure 4.4](#filepos404794), and the containers would read and
    write logs through the `location-example` volume.
  id: totrans-616
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果要将 Web 服务器和日志转发容器示例从 [第 4.2 节](index_split_039.html#filepos387539) 转换为使用卷来共享对日志的访问权限，这对可以运行在任何机器上，无需考虑可能与其他软件在磁盘上的静态位置冲突的其他软件。该示例将类似于
    [图 4.4](#filepos404794)，容器将通过 `location-example` 卷读取和写入日志。
- en: Figure 4.4\. Sharing files between containers with a volume
  id: totrans-617
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图4.4\. 使用卷在容器之间共享文件
- en: '![](images/00072.jpg)'
  id: totrans-618
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00072.jpg)'
- en: 'You can create and inspect volumes by using the `docker volume create` and
    `docker volume inspect` subcommands. By default, Docker creates volumes by using
    the `local` volume plugin. The default behavior will create a directory to store
    the contents of a volume somewhere in a part of the host filesystem under control
    of the Docker engine. For example, the following two commands will create a volume
    named `location-example` and display the location of the volume host filesystem
    tree:'
  id: totrans-619
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以使用`docker volume create`和`docker volume inspect`子命令来创建和检查卷。默认情况下，Docker使用`local`卷插件创建卷。默认行为将在Docker引擎控制的宿主机文件系统的一部分创建一个目录来存储卷的内容。例如，以下两个命令将创建一个名为`location-example`的卷并显示卷宿主机文件系统树的位置：
- en: '`docker volume create \` `1` `--driver local \` `2` `--label example=location
    \` `3` `location-example docker volume inspect \` `4` `--format "{{json .Mountpoint}}"
    \` `5` `location-example`'
  id: totrans-620
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker volume create` `1` `--driver local` `2` `--label example=location`
    `3` `location-example` `docker volume inspect` `4` `--format "{{json .Mountpoint}}"`
    `5` `location-example`'
- en: 1 Creates the volume
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 创建卷
- en: 2 Specifies the “local” plugin
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 指定“本地”插件
- en: 3 Adds a volume label
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 添加卷标签
- en: 4 Inspects the volume
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 检查卷
- en: 5 Selects the location on the host
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 选择主机上的位置
- en: Docker volumes may seem difficult to work with if you’re manually building or
    linking tools together on your desktop, but for larger systems in which specific
    locality of the data is less important, volumes are a much more effective way
    to organize your data. Using them decouples volumes from other potential concerns
    of the system. By using Docker volumes, you’re simply stating, “I need a place
    to put some data that I’m working with.” This is a requirement that Docker can
    fill on any machine with Docker installed.
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你手动在桌面上构建或链接工具，Docker卷可能看起来难以操作，但对于数据特定位置性不那么重要的更大系统，卷是组织数据的一种更有效的方法。使用它们将卷从系统的其他潜在关注点中解耦。通过使用Docker卷，你只是在说，“我需要一个地方来存放我正在处理的一些数据。”这是一个Docker可以在任何安装了Docker的机器上满足的要求。
- en: Further, when you’re finished with a volume and you ask Docker to clean things
    up for you, Docker can confidently remove any directories or files that are no
    longer being used by a container. Using volumes in this way helps manage clutter.
    As Docker middleware or plugins evolve, volume users will be able to adopt more
    advanced features.
  id: totrans-627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，当你完成对卷的使用并要求Docker为你清理时，Docker可以自信地删除任何不再被容器使用的目录或文件。以这种方式使用卷有助于管理杂乱。随着Docker中间件或插件的演变，卷用户将能够采用更高级的功能。
- en: Sharing access to data is a key feature of volumes. If you have decoupled volumes
    from known locations on the filesystem, you need to know how to share volumes
    between containers without exposing the exact location of managed containers.
    The next section describes two ways to share data between containers by using
    volumes.
  id: totrans-628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 共享数据访问是卷的关键特性。如果你已经将卷从文件系统上的已知位置解耦，你需要知道如何在容器之间共享卷，而不会暴露管理容器的确切位置。下一节将描述两种使用卷在容器之间共享数据的方法。
- en: 4.4.1\. Volumes provide container-independent data management
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.4.1\. 卷提供容器独立的数据管理
- en: 'Semantically, a volume is a tool for segmenting and sharing data that has a
    scope or life cycle that’s independent of a single container. That makes volumes
    an important part of any containerized system design that shares or writes files.
    Examples of data that differs in scope or access from a container include the
    following:'
  id: totrans-630
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从语义上讲，卷是一个用于分割和共享数据的工具，其范围或生命周期独立于单个容器。这使得卷成为任何共享或写入文件的容器化系统设计中不可或缺的一部分。以下是一些与容器在范围或访问权限上存在差异的数据示例：
- en: Database software versus database data
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库软件与数据库数据
- en: Web application versus log data
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络应用程序与日志数据
- en: Data processing application versus input and output data
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据处理应用程序与输入和输出数据
- en: Web server versus static content
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络服务器与静态内容
- en: Products versus support tools
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品与支持工具
- en: Volumes enable separation of concerns and create modularity for architectural
    components. That modularity helps you understand, build, support, and reuse parts
    of larger systems more easily.
  id: totrans-636
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 卷允许关注点的分离，并为架构组件创建模块化。这种模块化有助于你更容易地理解、构建、支持和重用大型系统中的各个部分。
- en: 'Think about it this way: images are appropriate for packaging and distributing
    relatively static files such as programs; volumes hold dynamic data or specializations.
    This distinction makes images reusable and data simple to share. This separation
    of relatively static and dynamic file space allows application or image authors
    to implement advanced patterns such as polymorphic and composable tools.'
  id: totrans-637
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这样想吧：图像适合用于打包和分发相对静态的文件，例如程序；卷则用于存储动态数据或特殊化。这种区别使得图像可重用，数据易于共享。这种相对静态和动态文件空间的分离，使得应用程序或图像的作者能够实现诸如多态和可组合工具等高级模式。
- en: A polymorphic tool is one that maintains a consistent interface but might have
    several implementations that do different things. Consider an application such
    as a general application server. Apache Tomcat, for example, is an application
    that provides an HTTP interface on a network and dispatches any requests it receives
    to pluggable programs. Tomcat has polymorphic behavior. Using volumes, you can
    inject behavior into containers without modifying an image. Alternatively, consider
    a database program like MongoDB or MySQL. The value of a database is defined by
    the data it contains. A database program always presents the same interface but
    takes on a wholly different value depending on the data that can be injected with
    a volume. The polymorphic container pattern is the subject of [section 4.5.1](index_split_042.html#filepos434489).
  id: totrans-638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 多态工具是指保持一致接口但可能有几个实现，这些实现执行不同的操作。考虑一个像通用应用程序服务器这样的应用程序。例如，Apache Tomcat是一个提供网络HTTP接口并将接收到的任何请求分派给可插拔程序的应用程序。Tomcat具有多态行为。使用卷，你可以在不修改镜像的情况下将行为注入容器。或者，考虑一个像MongoDB或MySQL这样的数据库程序。数据库的价值由其包含的数据定义。数据库程序始终提供相同的接口，但根据可以注入卷的数据而具有完全不同的价值。多态容器模式是[第4.5.1节](index_split_042.html#filepos434489)的主题。
- en: More fundamentally, volumes enable the separation of application and host concerns.
    At some point, an image will be loaded onto a host and a container created from
    it. Docker knows little about the host where it’s running and can make assertions
    only about what files should be available to a container. Docker alone has no
    way to take advantage of host-specific facilities like mounted network storage
    or mixed spinning and solid-state hard drives. But a user with knowledge of the
    host can use volumes to map directories in a container to appropriate storage
    on that host.
  id: totrans-639
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更根本的是，卷使得应用程序和主机关注点的分离成为可能。在某个时刻，一个镜像将被加载到主机上，并从中创建一个容器。Docker对其运行的主机了解不多，只能对容器应该可用的文件做出断言。Docker本身无法利用主机特定的设施，如挂载的网络存储或混合的机械硬盘和固态硬盘。但一个了解主机的人可以使用卷将容器中的目录映射到主机上的适当存储。
- en: Now that you’re familiar with what volumes are and why they’re important, you
    can get started with them in a real-world example.
  id: totrans-640
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了卷是什么以及为什么它们很重要，你可以在一个真实世界的例子中开始使用它们。
- en: 4.4.2\. Using volumes with a NoSQL database
  id: totrans-641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.4.2\. 使用卷与NoSQL数据库
- en: The Apache Cassandra project provides a column database with built-in clustering,
    eventual consistency, and linear write scalability. It’s a popular choice in modern
    system designs, and an official image is available on Docker Hub. Cassandra is
    like other databases in that it stores its data in files on disk. In this section,
    you’ll use the official Cassandra image to create a single-node Cassandra cluster,
    create a keyspace, delete the container, and then recover that keyspace on a new
    node in another container.
  id: totrans-642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Apache Cassandra项目提供了一个具有内置集群、最终一致性和线性写入可伸缩性的列数据库。它是现代系统设计中的热门选择，Docker Hub上提供了官方镜像。Cassandra与其他数据库类似，它在磁盘上的文件中存储数据。在本节中，你将使用官方Cassandra镜像创建一个单节点Cassandra集群，创建一个键空间，删除容器，然后在另一个容器中的新节点上恢复该键空间。
- en: 'Get started by creating the volume that will store the Cassandra database files.
    This volume uses disk space on the local machine and in a part of the filesystem
    managed by the Docker engine:'
  id: totrans-643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过创建将存储Cassandra数据库文件的卷开始。这个卷使用本地机器上的磁盘空间以及由Docker引擎管理的文件系统部分：
- en: '`docker volume create \     --driver local \     --label example=cassandra
    \     cass-shared`'
  id: totrans-644
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker volume create \    --driver local \    --label example=cassandra \    cass-shared`'
- en: 'This volume is not associated with any containers; it is just a named bit of
    disk that can be accessed by containers. The volume you just created is named
    `cass-shared`. In this case, you added a label to the volume with the key `example`
    and the value `cassandra`. Adding label metadata to your volumes can help you
    organize and clean up volumes later. You’ll use this volume when you create a
    new container running Cassandra:'
  id: totrans-645
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此卷与任何容器无关；它只是一个可以被容器访问的命名磁盘块。您刚刚创建的卷名为 `cass-shared`。在这种情况下，您向卷添加了一个键为 `example`、值为
    `cassandra` 的标签。向您的卷添加标签元数据可以帮助您在以后组织和清理卷。您将在创建运行 Cassandra 的新容器时使用此卷：
- en: '`docker run -d \     --volume cass-shared:/var/lib/cassandra/data \` `1` `--name
    cass1 \     cassandra:2.2`'
  id: totrans-646
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d \   --volume cass-shared:/var/lib/cassandra/data \` `1` `--name
    cass1 \   cassandra:2.2`'
- en: 1 Mounts the volume into the container
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 将卷挂载到容器中
- en: 'After Docker pulls the `cassandra:2.2` image from Docker Hub, it creates a
    new container with the `cass-shared` volume mounted at /var/lib/cassandra/data.
    Next, start a container from the `cassandra:2.2` image, but run a Cassandra client
    tool (CQLSH) and connect to your running server:'
  id: totrans-648
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Docker 从 Docker Hub 拉取 `cassandra:2.2` 镜像后，它创建了一个新的容器，并将 `cass-shared` 卷挂载到
    `/var/lib/cassandra/data`。接下来，从 `cassandra:2.2` 镜像启动一个容器，但运行 Cassandra 客户端工具（CQLSH）并连接到您的运行中的服务器：
- en: '`docker run -it --rm \     --link cass1:cass \     cassandra:2.2 cqlsh cass`'
  id: totrans-649
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -it --rm \   --link cass1:cass \   cassandra:2.2 cqlsh cass`'
- en: 'Now you can inspect or modify your Cassandra database from the CQLSH command
    line. First, look for a keyspace named `docker_hello_world`:'
  id: totrans-650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，您可以从 CQLSH 命令行检查或修改您的 Cassandra 数据库。首先，查找名为 `docker_hello_world` 的键空间：
- en: '`select * from system.schema_keyspaces where keyspace_name = ''docker_hello_world'';`'
  id: totrans-651
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`select * from system.schema_keyspaces where keyspace_name = ''docker_hello_world'';`'
- en: 'Cassandra should return an empty list. This means the database hasn’t been
    modified by the example. Next, create that keyspace with the following command:'
  id: totrans-652
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Cassandra 应该返回一个空列表。这意味着数据库没有被示例修改。接下来，使用以下命令创建该键空间：
- en: '`create keyspace docker_hello_world with replication = {     ''class'' : ''SimpleStrategy'',
        ''replication_factor'': 1 };`'
  id: totrans-653
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`create keyspace docker_hello_world with replication = {   ''class'' : ''SimpleStrategy'',   ''replication_factor'':
    1 };`'
- en: 'Now that you’ve modified the database, you should be able to issue the same
    query again to see the results and verify that your changes were accepted. The
    following command is the same as the one you ran earlier:'
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在您已经修改了数据库，您应该能够再次发出相同的查询以查看结果并验证您的更改是否被接受。以下命令与您之前运行的命令相同：
- en: '`select * from system.schema_keyspaces where keyspace_name = ''docker_hello_world'';`'
  id: totrans-655
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`select * from system.schema_keyspaces where keyspace_name = ''docker_hello_world'';`'
- en: 'This time, Cassandra should return a single entry with the properties you specified
    when you created the keyspace. If you’re satisfied that you’ve connected to and
    modified your Cassandra node, quit the CQLSH program to stop the client container:'
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这次，Cassandra 应该返回一个条目，其属性与您创建键空间时指定的属性相同。如果您满意已连接并修改了您的 Cassandra 节点，请退出 CQLSH
    程序以停止客户端容器：
- en: '`# Leave and stop the current container quit`'
  id: totrans-657
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`# 离开并停止当前容器 quit`'
- en: 'The client container was created with the `--rm` flag and was automatically
    removed when the command stopped. Continue cleaning up the first part of this
    example by stopping and removing the Cassandra node you created:'
  id: totrans-658
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 客户端容器使用 `--rm` 标志创建，并在命令停止时自动删除。继续清理本例的第一部分，通过停止和删除您创建的 Cassandra 节点：
- en: '`docker stop cass1 docker rm -vf cass1`'
  id: totrans-659
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker stop cass1 docker rm -vf cass1`'
- en: Both the Cassandra client and server you created will be deleted after running
    those commands. If the modifications you made are persisted, the only place they
    could remain is the `cass-shared` volume. You can test this by repeating these
    steps. Create a new Cassandra node, attach a client, and query for the keyspace.
    [Figure 4.5](#filepos421963) illustrates the system and what you will have built.
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在运行这些命令后，您创建的 Cassandra 客户端和服务器将被删除。如果您所做的修改已持久化，它们唯一可能保留的地方是 `cass-shared`
    卷。您可以通过重复这些步骤来测试这一点。创建一个新的 Cassandra 节点，附加一个客户端，并查询键空间。[图 4.5](#filepos421963)
    展示了系统和您将构建的内容。
- en: Figure 4.5\. Key steps in creating and recovering data persisted to a volume
    with Cassandra
  id: totrans-661
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 4.5\. 使用 Cassandra 将数据持久化到卷中的关键步骤
- en: '![](images/00013.jpg)'
  id: totrans-662
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00013.jpg)'
- en: 'The next three commands test recovery of the data:'
  id: totrans-663
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 下面的三个命令测试数据的恢复：
- en: '`docker run -d \     --volume cass-shared:/var/lib/cassandra/data \     --name
    cass2 \     cassandra:2.2  docker run -it --rm \     --link cass2:cass \     cassandra:2.2
    \     cqlsh cass  select * from system.schema_keyspaces where keyspace_name =
    ''docker_hello_world'';`'
  id: totrans-664
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d \    --volume cass-shared:/var/lib/cassandra/data \    --name
    cass2 \    cassandra:2.2  docker run -it --rm \    --link cass2:cass \    cassandra:2.2
    \    cqlsh cass  select * from system.schema_keyspaces where keyspace_name = ''docker_hello_world'';`'
- en: 'The last command in this set returns a single entry, and it matches the keyspace
    you created in the previous container. This confirms the previous claims and demonstrates
    how volumes might be used to create durable systems. Before moving on, quit the
    CQLSH program and clean up your workspace. Make sure to remove that volume container
    as well:'
  id: totrans-665
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这组命令中的最后一个命令返回一个条目，并且它与你在上一个容器中创建的键空间相匹配。这证实了之前的说法，并展示了如何使用卷来创建持久系统。在继续之前，退出CQLSH程序并清理你的工作空间。确保也要删除该卷容器：
- en: '`quit  docker rm -vf cass2 cass-shared`'
  id: totrans-666
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`quit  docker rm -vf cass2 cass-shared`'
- en: This example demonstrates one way to use volumes without going into how they
    work, the patterns in use, or how to manage volume life cycle. The remainder of
    this chapter dives deeper into each facet of volumes, starting with the types
    available.
  id: totrans-667
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个例子演示了使用卷的一种方法，而不深入探讨它们的工作原理、使用的模式或如何管理卷的生命周期。本章的其余部分将更深入地探讨卷的各个方面，从可用的类型开始。
- en: 4.5\. SHARED MOUNT POINTS AND SHARING FILES
  id: totrans-668
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.5. 共享挂载点和文件共享
- en: Sharing access to the same set of files between multiple containers is where
    the value of volumes becomes most obvious. Compare the bind-mount and volume-based
    approaches.
  id: totrans-669
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在多个容器之间共享对同一组文件的访问是卷的价值最明显的地方。比较绑定挂载和基于卷的方法。
- en: 'Bind mounts are the most obvious way to share disk space between containers.
    You can see it in action in the following example:'
  id: totrans-670
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 绑定挂载是共享容器之间磁盘空间的最明显方式。你可以在以下示例中看到它的实际应用：
- en: '`LOG_SRC=~/web-logs-example mkdir ${LOG_SRC}` `1` `docker run --name plath
    -d \` `2` `--mount type=bind,src=${LOG_SRC},dst=/data \` `2` `dockerinaction/ch4_writer_a`
    `2` `docker run --rm \     --mount type=bind,src=${LOG_SRC},dst=/data \` `3` `alpine:latest
    \` `3` `head /data/logA` `3` `cat ${LOG_SRC}/logA` `4` `docker rm -f plath` `5`'
  id: totrans-671
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`LOG_SRC=~/web-logs-example mkdir ${LOG_SRC}` `1` `docker run --name plath
    -d \` `2` `--mount type=bind,src=${LOG_SRC},dst=/data \` `2` `dockerinaction/ch4_writer_a`
    `2` `docker run --rm \    --mount type=bind,src=${LOG_SRC},dst=/data \` `3` `alpine:latest
    \` `3` `head /data/logA` `3` `cat ${LOG_SRC}/logA` `4` `docker rm -f plath` `5`'
- en: 1 Sets up a known location
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 设置一个已知位置
- en: 2 Bind-mounts the location into a log-writing container
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 将位置绑定到日志写入容器中
- en: 3 Bind-mounts the same location into a container for reading
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 将相同位置绑定到容器中进行读取
- en: 4 Views the logs from the host
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 查看主机日志
- en: 5 Stops the writer
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 停止写入器
- en: 'In this example, you created two containers: one named `plath` that writes
    lines to a file and another that views the top part of the file. These containers
    share a common bind-mount definition. Outside any container, you can see the changes
    by listing the contents of the directory you created or viewing the new file.
    The major drawback to this approach is that all containers involved must agree
    on the exact location on the host file path, and they may conflict with other
    containers that also intend to read or manipulate files at that location.'
  id: totrans-677
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个例子中，你创建了两个容器：一个名为`plath`的容器将行写入文件，另一个容器查看文件的顶部部分。这些容器共享一个共同的绑定挂载定义。在任何容器外部，你可以通过列出你创建的目录内容或查看新文件来看到这些更改。这种方法的主要缺点是所有涉及的容器都必须同意主机文件路径上的确切位置，并且可能与也打算在相同位置读取或操作文件的其它容器发生冲突。
- en: 'Now compare that bind-mount example with an example that uses volumes. The
    following commands are equivalent to the prior example but have no host-specific
    dependencies:'
  id: totrans-678
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在将这个绑定挂载示例与使用卷的示例进行比较。以下命令与前面的示例等效，但没有主机特定的依赖项：
- en: '`docker volume create \` `1` `--driver local \` `1` `logging-example` `1` `docker
    run --name plath -d \` `2` `--mount type=volume,src=logging-example,dst=/data
    \` `2` `dockerinaction/ch4_writer_a` `2` `docker run --rm \     --mount type=volume,src=logging-example,dst=/data
    \` `3` `alpine:latest \` `3` `head /data/logA` `3` `cat "$(docker volume inspect
    \     --format "{{json .Mountpoint}}" logging-example)"/logA` `4` `docker stop
    plath` `5`'
  id: totrans-679
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker volume create \` `1` `--driver local \` `1` `logging-example` `1` `docker
    run --name plath -d \` `2` `--mount type=volume,src=logging-example,dst=/data
    \` `2` `dockerinaction/ch4_writer_a` `2` `docker run --rm \    --mount type=volume,src=logging-example,dst=/data
    \` `3` `alpine:latest \` `3` `head /data/logA` `3` `cat "$(docker volume inspect
    \    --format "{{json .Mountpoint}}" logging-example)"/logA` `4` `docker stop
    plath` `5`'
- en: 1 Sets up a named volume
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 设置一个命名卷
- en: 2 Mounts the volume into a log-writing container
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 将卷装载到日志写入容器中
- en: 3 Mounts the same volume into a container for reading
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 将相同的卷装载到容器中进行读取
- en: 4 Views the logs from the host
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 查看主机日志
- en: 5 Stops the writer
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 停止作者
- en: Unlike shares based on bind mounts, named volumes enable containers to share
    files without any knowledge of the underlying host filesystem. Unless the volume
    needs to use specific settings or plugins, it does not have to exist before the
    first container mounts it. Docker will automatically create volumes named in `run`
    or `create` commands by using the defaults. However, it is important to remember
    that a named volume that exists on the host will be reused and shared by any other
    containers with the same volume dependency.
  id: totrans-685
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与基于绑定挂载的共享不同，命名卷允许容器在无需了解底层主机文件系统的情况下共享文件。除非卷需要使用特定的设置或插件，否则它不需要在第一个容器挂载它之前存在。Docker会自动根据`run`或`create`命令中的默认值创建名为卷的卷。然而，重要的是要记住，存在于主机上的命名卷将被重用并由具有相同卷依赖关系的任何其他容器共享。
- en: This name conflict problem can be solved by using anonymous volumes and mount-point
    definition inheritance between containers.
  id: totrans-686
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过使用匿名卷和容器之间的挂载点定义继承，可以解决此名称冲突问题。
- en: 4.5.1\. Anonymous volumes and the volumes-from flag
  id: totrans-687
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.5.1 匿名卷和卷来源标志
- en: An anonymous volume is created without a name either before use with the `docker
    volume create` subcommand, or just in time with defaults using a `docker run`
    or `docker create` command. When the volume is created, it is assigned a unique
    identifier such as `1b3364a8debb5f653d1ecb9b190000622549ee2f812a4fb4ec8a83c43d87531b`
    instead of a human-friendly name. These are more difficult to work with if you
    are manually stitching together dependencies, but they are useful when you need
    to eliminate potential volume-naming conflicts. The Docker command line provides
    another way to specify mount dependencies instead of referencing volumes by name.
  id: totrans-688
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 匿名卷在没有名称的情况下创建，无论是使用`docker volume create`子命令之前，还是使用`docker run`或`docker create`命令的默认值即时创建。当卷创建时，它被分配一个唯一的标识符，如`1b3364a8debb5f653d1ecb9b190000622549ee2f812a4fb4ec8a83c43d87531b`，而不是一个友好的名称。如果您需要手动拼接依赖项，这些标识符更难处理，但它们在需要消除潜在的卷命名冲突时很有用。Docker命令行提供了另一种指定挂载依赖项的方法，而不是通过名称引用卷。
- en: 'The `docker run` command provides a flag, `--volumes-from`, that will copy
    the mount definitions from one or more containers to the new container. It can
    be set multiple times to specify multiple source containers. By combining this
    flag and anonymous volumes, you can build rich shared-state relationships in a
    host-independent way. Consider the following example:'
  id: totrans-689
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run`命令提供了一个标志`--volumes-from`，它将从一个或多个容器中复制挂载定义到新容器中。它可以多次设置以指定多个源容器。通过结合此标志和匿名卷，您可以以主机无关的方式构建丰富的共享状态关系。考虑以下示例：'
- en: '`docker run --name fowler \     --mount type=volume,dst=/library/PoEAA \    
    --mount type=bind,src=/tmp,dst=/library/DSL \     alpine:latest \     echo "Fowler
    collection created." docker run --name knuth \     --mount type=volume,dst=/library/TAoCP.vol1
    \     --mount type=volume,dst=/library/TAoCP.vol2 \     --mount type=volume,dst=/library/TAoCP.vol3
    \     --mount type=volume,dst=/library/TAoCP.vol4.a \     alpine:latest \    
    echo "Knuth collection created"  docker run --name reader \` `1` `--volumes-from
    fowler \` `1` `--volumes-from knuth \` `1` `alpine:latest ls -l /library/  docker
    inspect --format "{{json .Mounts}}" reader` `2`'
  id: totrans-690
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --name fowler \ --mount type=volume,dst=/library/PoEAA \ --mount
    type=bind,src=/tmp,dst=/library/DSL \ alpine:latest \ echo "Fowler collection
    created." docker run --name knuth \ --mount type=volume,dst=/library/TAoCP.vol1
    \ --mount type=volume,dst=/library/TAoCP.vol2 \ --mount type=volume,dst=/library/TAoCP.vol3
    \ --mount type=volume,dst=/library/TAoCP.vol4.a \ alpine:latest \ echo "Knuth
    collection created"  docker run --name reader \` --volumes-from fowler \` --volumes-from
    knuth \` alpine:latest ls -l /library/ docker inspect --format "{{json .Mounts}}"
    reader`'
- en: 1 Lists all volumes as they were copied into new container
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 列出所有卷，它们被复制到新容器中
- en: 2 Checks out volume list for reader
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 检查读者卷列表
- en: In this example, you created two containers that defined anonymous volumes as
    well as a bind-mount volume. To share these with a third container without the
    `--volumes-from` flag, you’d need to inspect the previously created containers
    and then craft bind-mount volumes to the Docker-managed host directories. Docker
    does all this on your behalf when you use the `--volumes-from` flag. It copies
    all mount-point definitions present on a referenced source container into the
    new container. In this case, the container named `reader` copied all the mount
    points defined by both `fowler` and `knuth`.
  id: totrans-693
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个示例中，你创建了两个容器，它们定义了匿名卷以及一个绑定挂载卷。要使用 `--volumes-from` 标志与第三个容器共享这些卷，你需要检查之前创建的容器，然后为
    Docker 管理的主机目录创建绑定挂载卷。当你使用 `--volumes-from` 标志时，Docker 会代表你完成所有这些操作。它将引用源容器上所有存在的挂载点定义复制到新容器中。在这种情况下，名为
    `reader` 的容器复制了 `fowler` 和 `knuth` 定义的挂载点。
- en: 'You can copy volumes directly or transitively. This means that if you’re copying
    the volumes from another container, you’ll also copy the volumes that it copied
    from some other container. Using the containers created in the preceding example
    yields the following:'
  id: totrans-694
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以直接或间接地复制卷。这意味着如果你从另一个容器复制卷，你也会复制它从另一个容器中复制的卷。使用前一个示例中创建的容器，可以得到以下结果：
- en: '`docker run --name aggregator \` `1` `--volumes-from fowler \     --volumes-from
    knuth \     alpine:latest \     echo "Collection Created."  docker run --rm \`
    `2` `--volumes-from aggregator \     alpine:latest \     ls -l /library/`'
  id: totrans-695
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --name aggregator \` `1` `--volumes-from fowler \    --volumes-from
    knuth \    alpine:latest \    echo "Collection Created."` `docker run --rm \`
    `2` `--volumes-from aggregator \    alpine:latest \    ls -l /library/`'
- en: 1 Creates an aggregation
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 创建一个聚合
- en: 2 Consumes volumes from a single source and lists them
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 从单个源消费卷并列出它们
- en: Copied volumes always have the same mount point. That means that you can’t use
    `--volumes-from` in three situations.
  id: totrans-698
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 复制的卷总是具有相同的挂载点。这意味着在以下三种情况下，你不能使用 `--volumes-from`：
- en: In the first situation, you can’t use `--volumes-from` if the container you’re
    building needs a shared volume mounted to a different location. It offers no tooling
    for remapping mount points. It will only copy and union the mount points indicated
    by the specified containers. For example, if the student in the previous example
    wanted to mount the library to a location like /school/library, they wouldn’t
    be able to do so.
  id: totrans-699
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在第一种情况下，如果你构建的容器需要一个挂载到不同位置的共享卷，你不能使用 `--volumes-from`。它不提供重新映射挂载点的工具。它只会复制和合并由指定容器指示的挂载点。例如，如果前一个示例中的学生想要将图书馆挂载到类似
    /school/library 的位置，他们将无法做到这一点。
- en: 'The second situation occurs when the volume sources conflict with each other
    or a new volume specification. If one or more sources create a managed volume
    with the same mount point, a consumer of both will receive only one of the volume
    definitions:'
  id: totrans-700
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第二种情况发生在卷源相互冲突或存在新的卷指定时。如果一个或多个源创建了一个具有相同挂载点的管理卷，那么两个卷的消费者将只收到其中一个卷的定义：
- en: '`docker run --name chomsky --volume /library/ss \     alpine:latest echo "Chomsky
    collection created." docker run --name lamport --volume /library/ss \     alpine:latest
    echo "Lamport collection created."  docker run --name student \     --volumes-from
    chomsky --volumes-from lamport \     alpine:latest ls -l /library/  docker inspect
    -f "{{json .Mounts}}" student`'
  id: totrans-701
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --name chomsky --volume /library/ss \    alpine:latest echo "Chomsky
    collection created."` `docker run --name lamport --volume /library/ss \    alpine:latest
    echo "Lamport collection created."` `docker run --name student \    --volumes-from
    chomsky --volumes-from lamport \    alpine:latest ls -l /library/` `docker inspect
    -f "{{json .Mounts}}" student`'
- en: When you run the example, the output of `docker inspect` will show that the
    last container has only a single volume listed at /library/ss, and its value is
    the same as one of the other two. Each source container defines the same mount
    point, and you create a race condition by copying both to the new container. Only
    one of the two copy operations can succeed.
  id: totrans-702
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你运行示例时，`docker inspect` 的输出将显示最后一个容器在 /library/ss 下只列出了一个卷，其值与另外两个中的一个相同。每个源容器定义了相同的挂载点，你通过将两者都复制到新容器中创建了一个竞争条件。这两个复制操作中只有一个可以成功。
- en: A real-world example of this limitation may occur if you copy the volumes of
    several web servers into a single container for inspection. If those servers are
    all running the same software or share common configuration (which is more likely
    than not in a containerized system), all those servers might use the same mount
    points. In that case, the mount points would conflict, and you’d be able to access
    only a subset of the required data.
  id: totrans-703
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种限制的现实世界例子可能发生在你将几个网络服务器的卷复制到一个单独的容器中进行检查时。如果这些服务器都在运行相同的软件或共享常见的配置（在容器化系统中这种情况更为常见），所有这些服务器可能会使用相同的挂载点。在这种情况下，挂载点将发生冲突，你只能访问所需数据的一部分。
- en: The third situation in which you can’t use `--volumes-from` occurs when you
    need to change the write permission of a volume. This is because `--volumes-from`
    copies the full volume definition. For example, if your source has a volume mounted
    with read/write access, and you want to share that with a container that should
    have only read access, using `--volumes-from` won’t work.
  id: totrans-704
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你不能使用 `--volumes-from` 的第三种情况是当你需要更改卷的写权限时。这是因为 `--volumes-from` 会复制完整的卷定义。例如，如果你的源卷是以读写访问挂载的，而你想要与一个只应有读访问权限的容器共享，使用
    `--volumes-from` 将不会起作用。
- en: Sharing volumes with the `--volumes-from` flag is an important tool for building
    portable application architectures, but it does introduce some limitations. The
    more challenging of these are in managing file permissions.
  id: totrans-705
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 `--volumes-from` 标志共享卷是构建可移植应用程序架构的重要工具，但它确实引入了一些限制。其中最具挑战性的是管理文件权限。
- en: Using volumes decouples containers from the data and filesystem structure of
    the host machine, and that’s critical for most production environments. The files
    and directories that Docker creates for managed volumes still need to be accounted
    for and maintained. The next section shows you how to keep a Docker environment
    clean.
  id: totrans-706
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用卷将容器与主机机的数据和文件系统结构解耦，这对于大多数生产环境至关重要。Docker为管理卷创建的文件和目录仍然需要被计入和维护。下一节将向你展示如何保持Docker环境整洁。
- en: 4.6\. CLEANING UP VOLUMES
  id: totrans-707
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.6. 清理卷
- en: By this point in the chapter, you should have quite a few containers and volumes
    to clean up. You can see all of the volumes present on your system by running
    the `docker volume list` subcommand. The output will list the type and name of
    each volume. Any volumes that were created with a name will be listed with that
    name. Any anonymous volumes will be listed by their identifier.
  id: totrans-708
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到这一章节为止，你应该有相当多的容器和卷需要清理。你可以通过运行 `docker volume list` 子命令来查看系统上所有现有的卷。输出将列出每个卷的类型和名称。任何带有名称创建的卷将以该名称列出。任何匿名卷将以其标识符列出。
- en: 'Anonymous volumes can be cleaned up in two ways. First, anonymous volumes are
    automatically deleted when the container they were created for are automatically
    cleaned up. This happens when containers are deleted via the `docker run --rm`
    or `docker rm -v` flags. Second, they can be manually deleted by issuing a `docker
    volume remove` command:'
  id: totrans-709
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 匿名卷可以通过两种方式清理。首先，当为它们创建的容器自动清理时，匿名卷会自动删除。这发生在通过 `docker run --rm` 或 `docker
    rm -v` 标志删除容器时。其次，可以通过发出 `docker volume remove` 命令手动删除：
- en: '`docker volume create --driver=local # Outputs: # 462d0bb7970e47512cd5ebbbb283ed53d5f674b9069b013019ff18ccee37d75d  docker
    volume remove \     462d0bb7970e47512cd5ebbbb283ed53d5f674b9069b013019ff18ccee37d75d
    # Outputs: # 462d0bb7970e47512cd5ebbbb283ed53d5f674b9069b013019ff18ccee37d75d`'
  id: totrans-710
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker volume create --driver=local # 输出：# 462d0bb7970e47512cd5ebbbb283ed53d5f674b9069b013019ff18ccee37d75d  docker
    volume remove \     462d0bb7970e47512cd5ebbbb283ed53d5f674b9069b013019ff18ccee37d75d
    # 输出：# 462d0bb7970e47512cd5ebbbb283ed53d5f674b9069b013019ff18ccee37d75d`'
- en: 'Unlike anonymous volumes, named volumes must always be deleted manually. This
    behavior can be helpful when containers are running jobs that collect partitioned
    or periodic data. Consider the following:'
  id: totrans-711
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与匿名卷不同，命名卷必须始终手动删除。当容器运行收集分区数据或周期性数据的作业时，这种行为可能很有帮助。考虑以下情况：
- en: '`for i in amazon google microsoft; \ do \ docker run --rm \     --mount type=volume,src=$i,dst=/tmp
    \      --entrypoint /bin/sh \     alpine:latest -c "nslookup $i.com > /tmp/results.txt";
    \ done`'
  id: totrans-712
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`for i in amazon google microsoft; \ do \ docker run --rm \     --mount type=volume,src=$i,dst=/tmp
    \     --entrypoint /bin/sh \     alpine:latest -c "nslookup $i.com > /tmp/results.txt";
    \ done`'
- en: This command performs a DNS lookup on [amazon.com](http://amazon.com), [google.com](http://google.com),
    and [microsoft.com](http://microsoft.com) in three separate containers and records
    the results in three different volumes. Those volumes are named `amazon`, `google`,
    and `microsoft`. Even though the containers are being cleaned up automatically,
    the named volumes will remain. If you run the command, you should be able to see
    the new volumes when you run `docker volume list`.
  id: totrans-713
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此命令在三个独立的容器中对 [amazon.com](http://amazon.com)、[google.com](http://google.com)
    和 [microsoft.com](http://microsoft.com) 进行 DNS 查找，并将结果记录在三个不同的卷中。这些卷分别命名为 `amazon`、`google`
    和 `microsoft`。尽管容器正在自动清理，但命名的卷将保留。如果你运行此命令，你应该能够在运行 `docker volume list` 时看到新卷。
- en: 'The only way to delete these named volumes is by specifying their name in the
    `docker volume remove` command:'
  id: totrans-714
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 删除这些命名的卷的唯一方法是在 `docker volume remove` 命令中指定它们的名称：
- en: '`docker volume remove \     amazon google microsoft`'
  id: totrans-715
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker volume remove \    amazon google microsoft`'
- en: The `remove` subcommand supports a list argument for specifying volume names
    and identifiers. The preceding command will delete all three named volumes.
  id: totrans-716
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`remove` 子命令支持一个列表参数，用于指定卷名和标识符。前面的命令将删除所有三个命名的卷。'
- en: 'There is only one constraint for deleting volumes: no volume that is currently
    in use can be deleted. More specifically, no volume attached to any container
    in any state can be deleted. If you attempt to do so, the Docker command will
    respond with a message stating, `volume is in use` and display the identifier
    of the container using the volume.'
  id: totrans-717
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 删除卷只有一个约束：当前正在使用的卷不能被删除。更具体地说，任何状态下的容器所附加的卷都不能被删除。如果你尝试这样做，Docker 命令将响应一条消息，指出“卷正在使用中”，并显示使用该卷的容器标识符。
- en: It can be annoying to determine which volumes are candidates for removal if
    you simply want to remove all or some of the volumes that can be removed. This
    happens all the time as part of periodic maintenance. The `docker volume prune`
    command is built for this case.
  id: totrans-718
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你只想删除所有或部分可以删除的卷，确定哪些卷是删除候选可能会很烦人。这种情况经常作为定期维护的一部分发生。`docker volume prune`
    命令就是为了这种情况而构建的。
- en: 'Running `docker volume prune` with no options will prompt you for confirmation
    and delete all volumes that can be deleted. You can filter that candidate set
    by providing volume labels:'
  id: totrans-719
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不带选项运行 `docker volume prune` 将会提示你确认，并删除所有可以删除的卷。你可以通过提供卷标签来过滤候选集：
- en: '`docker volume prune --filter example=cassandra`'
  id: totrans-720
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker volume prune --filter example=cassandra`'
- en: 'This command would prompt for confirmation and delete the volume you created
    earlier in the Cassandra example. If you’re automating these cleanup procedures,
    you might want to suppress the confirmation step. In that case, use the `--force`
    or `-f` flag:'
  id: totrans-721
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此命令将提示确认并删除你在 Cassandra 示例中创建的卷。如果你正在自动化这些清理程序，你可能想抑制确认步骤。在这种情况下，使用 `--force`
    或 `-f` 标志：
- en: '`docker volume prune --filter example=location --force`'
  id: totrans-722
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker volume prune --filter example=location --force`'
- en: Understanding volumes is critical for working with real-world containers, but
    in many cases using volumes on local disks can create problems. If you’re running
    software on a cluster of machines, the data that software stores in volumes will
    stay on the disk where it was written. If a container is moved to a different
    machine, it will lose access to its data in an old volume. You can solve this
    problem for your organization with volume plugins.
  id: totrans-723
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 理解卷对于与实际容器工作至关重要，但在许多情况下，在本地磁盘上使用卷可能会造成问题。如果你在一组机器上运行软件，该软件存储在卷中的数据将保留在写入它的磁盘上。如果容器被移动到另一台机器，它将失去对旧卷中数据的访问。你可以通过卷插件来解决你组织中的这个问题。
- en: 4.7\. ADVANCED STORAGE WITH VOLUME PLUGINS
  id: totrans-724
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4.7. 使用卷插件进行高级存储
- en: Docker provides a volume plugin interface as a means for the community to extend
    the default engine capabilities. That has been implemented by several storage
    management tools, and today users are free to use all types of backing storage
    including proprietary cloud block storage, network filesystem mounts, specialized
    storage hardware, and on-premises cloud solutions such as Ceph and vSphere storage.
  id: totrans-725
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker 提供了一个卷插件接口，作为社区扩展默认引擎功能的一种方式。这已被几个存储管理工具实现，如今用户可以自由使用所有类型的后端存储，包括专有云块存储、网络文件系统挂载、专用存储硬件以及本地云解决方案，如
    Ceph 和 vSphere 存储。
- en: These community and vendor plugins will help you solve the hard problems associated
    with writing files to disk on one machine and depending on them from another.
    They are simple to install, configure, and remove using the appropriate `docker
    plugin` subcommands.
  id: totrans-726
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些社区和供应商插件将帮助您解决与在单台机器上写入文件并从另一台机器依赖它们相关的难题。它们使用适当的`docker plugin`子命令安装、配置和删除都很简单。
- en: Docker plugins are not covered in detail in this text. They are always environment
    specific and difficult to demonstrate without using paid resources or endorsing
    specific cloud providers. Choosing a plugin depends on the storage infrastructure
    you want to integrate with, although a few projects simplify this to some degree.
    REX-Ray ([https://github.com/rexray/rexray](https://github.com/rexray/rexray))
    is a popular open source project that provides volumes on several cloud and on-premises
    storage platforms. If you’ve come to the point in your container journey that
    you need more sophisticated volume backends, you should look at the latest offerings
    on Docker Hub and look into the current status of REX-Ray.
  id: totrans-727
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本文本中没有详细说明Docker插件。它们总是环境特定的，并且没有使用付费资源或支持特定云提供商的情况下很难演示。选择插件取决于您想要集成的存储基础设施，尽管一些项目在某种程度上简化了这一点。REX-Ray
    ([https://github.com/rexray/rexray](https://github.com/rexray/rexray)) 是一个流行的开源项目，它为几个云和本地存储平台提供卷。如果您已经到达了容器之旅中需要更复杂的卷后端的位置，您应该查看Docker
    Hub上的最新产品，并了解REX-Ray的当前状态。
- en: SUMMARY
  id: totrans-728
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: 'One of the first major hurdles in learning how to use Docker is understanding
    how to work with files that are not part of images and might be shared with other
    containers or the host. This chapter covers mount points in depth, including the
    following:'
  id: totrans-729
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 学习如何使用Docker的第一个主要障碍之一是理解如何处理不属于镜像且可能与其他容器或主机共享的文件。本章深入探讨了挂载点，包括以下内容：
- en: Mount points allow many filesystems from many devices to be attached to a single
    file tree. Every container has its own file tree.
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载点允许来自多个设备的多个文件系统附加到单个文件树。每个容器都有自己的文件树。
- en: Containers can use bind mounts to attach parts of the host filesystem into a
    container.
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器可以使用绑定挂载将主机文件系统的一部分附加到容器中。
- en: In-memory filesystems can be attached to a container file tree so that sensitive
    or temporary data is not written to disk.
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将内存文件系统附加到容器文件树中，以便敏感或临时数据不会写入磁盘。
- en: Docker provides anonymous or named storage references called volumes.
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker提供了匿名或命名的存储引用，称为卷。
- en: Volumes can be created, listed, and deleted using the appropriate `docker volume`
    subcommand.
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用适当的`docker volume`子命令创建、列出和删除卷。
- en: Volumes are parts of the host filesystem that Docker mounts into containers
    at specified locations.
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷是主机文件系统的一部分，Docker将其挂载到容器中指定的位置。
- en: Volumes have life cycles of their own and might need to be periodically cleaned
    up.
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷有其自己的生命周期，可能需要定期清理。
- en: Docker can provide volumes backed by network storage or other more sophisticated
    tools if the appropriate volume plugin is installed.
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果安装了适当的卷插件，Docker可以提供由网络存储或其他更复杂的工具支持的卷。
- en: Chapter 5\. Single-host networking
  id: totrans-738
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第5章. 单主机网络
- en: This chapter covers
  id: totrans-739
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Networking background
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络背景
- en: Creating Docker container networks
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Docker容器网络
- en: Network-less and host-mode containers
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无网络和主机模式容器
- en: Publishing services on the ingress network
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在入口网络上发布服务
- en: Container network caveats
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器网络注意事项
- en: Networking is a whole field of computing, and so this chapter can only scratch
    the surface by covering specific challenges, structures, and tools required for
    container networks. If you want to run a website, database, email server, or any
    software that depends on networking, such as a web browser inside a Docker container,
    you need to understand how to connect that container to the network. After reading
    this chapter, you’ll be able to create containers with network exposure appropriate
    for the application you’re running, use network software in one container from
    another, and understand how containers interact with the host and the host’s network.
  id: totrans-745
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 网络是计算的一个完整领域，因此本章只能通过涵盖容器网络所需的特定挑战、结构和工具来触及表面。如果您想运行网站、数据库、电子邮件服务器或任何依赖网络的软件，例如Docker容器内的网络浏览器，您需要了解如何将容器连接到网络。阅读本章后，您将能够创建适合您运行的应用的具有网络暴露的容器，从一个容器中使用网络软件到另一个容器，并了解容器如何与主机及其网络交互。
- en: 5.1\. NETWORKING BACKGROUND (FOR BEGINNERS)
  id: totrans-746
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.1. 网络背景（针对初学者）
- en: A quick overview of relevant networking concepts will be helpful for understanding
    the topics in this chapter. This section includes only high-level detail; if you’re
    an expert, feel free to skip ahead.
  id: totrans-747
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对相关网络概念的快速概述将有助于理解本章的主题。本节仅包含高级细节；如果你是专家，可以自由地跳过。
- en: Networking is all about communicating between processes that may or may not
    share the same local resources. To understand the material in this chapter, you
    need to consider only a few basic network abstractions that are commonly used
    by processes. The better understanding you have of networking, the more you’ll
    learn about the mechanics at work. But a deep understanding isn’t required to
    use the tools provided by Docker. If anything, the material contained herein should
    prompt you to independently research selected topics as they come up. Those basic
    abstractions used by processes include protocols, network interfaces, and ports.
  id: totrans-748
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 网络通信主要涉及可能或可能不共享相同本地资源的进程之间的通信。为了理解本章的内容，你需要考虑一些常用的基本网络抽象概念。你对网络的了解越深入，你将越能了解其工作原理。但深入理解并不是使用Docker提供的工具所必需的。相反，本书中的材料应该促使你独立研究出现的选定主题。这些基本抽象包括协议、网络接口和端口。
- en: '5.1.1\. Basics: Protocols, interfaces, and ports'
  id: totrans-749
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.1.1\. 基础：协议、接口和端口
- en: A protocol with respect to communication and networking is a sort of language.
    Two parties that agree on a protocol can understand what the other is communicating.
    This is key to effective communication. Hypertext Transfer Protocol (HTTP) is
    one popular network protocol that many people have heard of. It’s the protocol
    that provides the World Wide Web. A huge number of network protocols and several
    layers of communication are created by those protocols. For now, it’s only important
    that you know what a protocol is so that you can understand network interfaces
    and ports.
  id: totrans-750
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于通信和网络的一个协议就像是一种语言。两个同意使用该协议的当事人可以理解对方正在传达的信息。这是有效沟通的关键。超文本传输协议（HTTP）是许多人所熟知的一种流行网络协议。它是提供万维网服务的协议。许多网络协议和多个通信层都是由这些协议创建的。目前，重要的是你要知道什么是协议，这样你才能理解网络接口和端口。
- en: A network interface has an address and represents a location. You can think
    of interfaces as analogous to real-world locations with addresses. A network interface
    is like a mailbox. Messages are delivered to a mailbox for recipients at that
    address, and messages are taken from a mailbox to be delivered elsewhere.
  id: totrans-751
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 网络接口有一个地址并代表一个位置。你可以将接口视为类似于现实世界中的地址位置。网络接口就像一个邮箱。消息被送到该地址的收件人邮箱，然后从邮箱中取出以发送到其他地方。
- en: Whereas a mailbox has a postal address, a network interface has an IP address,
    which is defined by the Internet Protocol. The details of IP are interesting but
    outside of the scope of this book. The important thing to know about IP addresses
    is that they are unique in their network and contain information about their location
    on their network.
  id: totrans-752
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与邮箱的邮政地址类似，网络接口有一个IP地址，这是由互联网协议定义的。IP的细节很有趣，但超出了本书的范围。关于IP地址的重要信息是，它们在其网络中是唯一的，并且包含有关它们在网络中的位置信息。
- en: 'It’s common for computers to have two kinds of interfaces: an Ethernet interface
    and a loopback interface. An Ethernet interface is what you’re likely most familiar
    with. It’s used to connect to other interfaces and processes. A loopback interface
    isn’t connected to any other interface. At first this might seem useless, but
    it’s often useful to be able to use network protocols to communicate with other
    programs on the same computer. In those cases, a loopback is a great solution.'
  id: totrans-753
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 计算机通常有两种接口：以太网接口和回环接口。以太网接口是你最熟悉的。它用于连接到其他接口和进程。回环接口不连接到任何其他接口。起初这可能会显得无用，但能够使用网络协议与同一台计算机上的其他程序通信通常很有用。在这些情况下，回环是一个很好的解决方案。
- en: In keeping with the mailbox metaphor, a port is like a recipient or a sender.
    Several people might receive messages at a single address. For example, a single
    address might receive messages for Wendy Webserver, Deborah Database, and Casey
    Cache, as illustrated in [figure 5.1](#filepos465542). Each recipient should open
    only their own messages.
  id: totrans-754
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 按照邮箱的隐喻，端口就像收件人或发件人。可能有多个人在同一个地址接收消息。例如，一个地址可能接收Wendy Web服务器、Deborah数据库和Casey缓存的消息，如图5.1所示。每个收件人应该只打开自己的消息。
- en: Figure 5.1\. Processes use the same interface and are uniquely identified in
    the same way that multiple people might use the same mailbox.
  id: totrans-755
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图5.1\. 进程使用相同的接口，并且以与多人可能使用同一个邮箱相同的方式唯一标识。
- en: '![](images/00020.jpg)'
  id: totrans-756
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00020.jpg)'
- en: In reality, ports are just numbers and defined as part of the Transmission Control
    Protocol (TCP) or User Datagram Protocol (UDP). Again, the details of the protocol
    are beyond the scope of this book, but we encourage you to read about it sometime.
    People who created standards for protocols, or companies that own a particular
    product, decide which port number should be used for specific purposes. For example,
    web servers provide HTTP on port 80 by default. MySQL, a database product, serves
    its protocol on port 3306 by default. Memcached, a fast cache technology, provides
    its protocol on port 11211\. Ports are written on TCP messages just as names are
    written on envelopes.
  id: totrans-757
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实际上，端口只是数字，并作为传输控制协议（TCP）或用户数据报协议（UDP）的一部分进行定义。再次强调，协议的细节超出了本书的范围，但我们鼓励你在某个时候阅读有关内容。创建协议标准的人或拥有特定产品的公司决定应该为特定目的使用哪个端口号。例如，默认情况下，Web服务器在端口80上提供HTTP服务。MySQL数据库产品默认在其端口3306上提供服务。Memcached快速缓存技术在其端口11211上提供其协议。端口就像名字写在信封上一样，被写在TCP消息中。
- en: Interfaces, protocols, and ports are all immediate concerns for software and
    users. By learning about these things, you develop a better appreciation for the
    way programs communicate as well as the way your computer fits into the bigger
    picture.
  id: totrans-758
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接口、协议和端口都是软件和用户直接关心的问题。通过了解这些内容，您将更好地理解程序如何通信，以及您的计算机如何融入更大的图景。
- en: '5.1.2\. Bigger picture: Networks, NAT, and port forwarding'
  id: totrans-759
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.1.2\. 更大的图景：网络、NAT和端口转发
- en: Interfaces are single points in larger networks. Networks are defined in the
    way that interfaces are linked together, and that linkage determines an interface’s
    IP address.
  id: totrans-760
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接口是更大网络中的单个点。网络是通过接口之间的连接方式来定义的，而这种连接方式决定了接口的IP地址。
- en: Sometimes a message has a recipient that an interface is not directly linked
    to, so instead it’s delivered to an intermediary that knows how to route the message
    for delivery. Coming back to the mail metaphor, this is similar to the way real-world
    mail carriers operate.
  id: totrans-761
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时，一条消息有一个接收者，该接口并没有直接连接到，因此它被发送到一个知道如何路由消息以进行投递的中介。回到邮件隐喻，这类似于现实世界中的邮件投递员的工作方式。
- en: When you place a message in your outbox, a mail carrier picks it up and delivers
    it to a local routing facility. That facility is itself an interface. It will
    take the message and send it along to the next stop on the route to a destination.
    A local routing facility for a mail carrier might forward a message to a regional
    facility, and then to a local facility for the destination, and finally to the
    recipient. It’s common for network routes to follow a similar pattern. [Figure
    5.2](#filepos468725) illustrates the described route and draws the relationships
    between physical message routing and network routing.
  id: totrans-762
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您将消息放入您的发件箱时，邮递员会取走它并将其递送到本地路由设施。该设施本身也是一个接口。它将接收消息并将其发送到下一个路由站，直到目的地。邮递员的本地路由设施可能会将消息转发到区域设施，然后转发到目的地的本地设施，最后转发给接收者。网络路由通常遵循类似的模式。[图5.2](#filepos468725)展示了描述的路径，并绘制了物理消息路由和网络路由之间的关系。
- en: Figure 5.2\. The path of a message in a postal system and a computer network
  id: totrans-763
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图5.2\. 邮政系统和计算机网络中消息的路径
- en: '![](images/00071.jpg)'
  id: totrans-764
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00071.jpg)'
- en: This chapter is concerned with interfaces that exist on a single computer, so
    the networks and routes we consider won’t be anywhere near that complicated. In
    fact, this chapter is about two specific networks and the way containers are attached
    to them. The first network is the one that your computer is connected to. The
    second is a virtual network that Docker creates to connect all of the running
    containers to the network that the computer is connected to. That second network
    is called a bridge.
  id: totrans-765
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章关注的是单个计算机上存在的接口，因此我们考虑的网络和路由不会非常复杂。实际上，本章是关于两个特定网络以及容器如何连接到这些网络的方式。第一个网络是您的计算机连接到的网络。第二个是一个Docker创建的虚拟网络，用于将所有正在运行的容器连接到计算机连接到的网络。第二个网络被称为桥接。
- en: A bridge is an interface that connects multiple networks so that they can function
    as a single network, as shown in [figure 5.3](#filepos470353). Bridges work by
    selectively forwarding traffic between the connected networks based on another
    type of network address. To understand the material in this chapter, you need
    to be comfortable with only this abstract idea.
  id: totrans-766
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 网桥是一种连接多个网络，使它们可以作为一个单一网络运行的接口，如图5.3所示。[图5.3](#filepos470353)。网桥通过根据另一种类型的网络地址选择性地转发连接网络之间的流量来工作。为了理解本章的内容，您只需要熟悉这个抽象概念。
- en: Figure 5.3\. A bridge interface connecting two distinct networks
  id: totrans-767
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图5.3\. 连接两个不同网络的网桥接口
- en: '![](images/00046.jpg)'
  id: totrans-768
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00046.jpg)'
- en: This has been a very rough introduction to some nuanced topics. The explanation
    only scratched the surface in order to help you understand how to use Docker and
    the networking facilities that it simplifies.
  id: totrans-769
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这只是一个对一些细微主题的非常粗略的介绍。解释只是触及了表面，以便帮助您了解如何使用Docker以及它简化的网络功能。
- en: 5.2\. DOCKER CONTAINER NETWORKING
  id: totrans-770
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.2\. DOCKER 容器网络
- en: Docker abstracts the underlying host-attached network from containers. Doing
    so provides a degree of runtime environment agnosticism for the application, and
    allows infrastructure managers to adapt the implementation to suit the operating
    environment. A container attached to a Docker network will get a unique IP address
    that is routable from other containers attached to the same Docker network.
  id: totrans-771
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker将底层主机附加的网络从容器中抽象出来。这样做为应用程序提供了一定程度的运行时环境无关性，并允许基础设施管理员根据操作环境调整实现方式。连接到Docker网络的容器将获得一个唯一的可路由IP地址，该地址可以从连接到同一Docker网络的其它容器中路由。
- en: The main problem with this approach is that there is no easy way for any software
    running inside a container to determine the IP address of the host where the container
    is running. This inhibits a container from advertising its service endpoint to
    other services outside the container network. [Section 5.5](index_split_051.html#filepos515902)
    covers a few methods for dealing with this edge case.
  id: totrans-772
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种方法的主要问题是，任何在容器内运行的软件都没有简单的方法来确定容器运行的主机的IP地址。这阻碍了容器向容器网络外的其他服务广告其服务端点。[第5.5节](index_split_051.html#filepos515902)介绍了处理这种边缘情况的一些方法。
- en: Docker also treats networks as first-class entities. This means that they have
    their own life cycle and are not bound to any other objects. You can define and
    manage them directly by using the `docker network` subcommands.
  id: totrans-773
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker也将网络视为一等实体。这意味着它们有自己的生命周期，并且不受任何其他对象的约束。您可以直接使用`docker network`子命令来定义和管理它们。
- en: 'To get started with networks in Docker, examine the default networks that are
    available with every Docker installation. Running `docker network ls` will print
    a table of all the networks to the terminal. The resulting table should look like
    this:'
  id: totrans-774
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要开始使用Docker中的网络，请检查每个Docker安装中可用的默认网络。运行`docker network ls`将在终端打印出所有网络的表格。生成的表格应如下所示：
- en: '`NETWORK ID          NAME                DRIVER              SCOPE 63d93214524b       
    bridge              bridge              local 6eeb489baff0        host               
    host                local 3254d02034ed        none                null               
    local`'
  id: totrans-775
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`网络 ID          名称                驱动程序              范围 63d93214524b       
    bridge              bridge              本地 6eeb489baff0        host               
    host                本地 3254d02034ed        none                null               
    本地`'
- en: By default, Docker includes three networks, and each is provided by a different
    driver. The network named `bridge` is the default network and provided by a `bridge`
    driver. The `bridge` driver provides intercontainer connectivity for all containers
    running on the same machine. The `host` network is provided by the `host` driver,
    which instructs Docker not to create any special networking namespace or resources
    for attached containers. Containers on the `host` network interact with the host’s
    network stack like uncontained processes. Finally, the `none` network uses the
    `null` driver. Containers attached to the `none` network will not have any network
    connectivity outside themselves.
  id: totrans-776
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认情况下，Docker包括三个网络，每个网络由不同的驱动程序提供。名为`bridge`的网络是默认网络，由`bridge`驱动程序提供。`bridge`驱动程序为在同一台机器上运行的容器提供容器间连接。`host`网络由`host`驱动程序提供，该驱动程序指示Docker不要为附加容器创建任何特殊的网络命名空间或资源。`host`网络上的容器与主机的网络堆栈交互，就像无容器进程一样。最后，`none`网络使用`null`驱动程序。连接到`none`网络的容器将不会与自身之外的网络有任何网络连接。
- en: 'The scope of a network can take three values: `local`, `global`, or `swarm`.
    This indicates whether the network is constrained to the machine where the network
    exists (local), should be created on every node in a cluster but not route between
    them (global), or seamlessly spans all of the hosts participating in a Docker
    swarm (multihost or cluster-wide). As you can see, all of the default networks
    have the `local` scope, and will not be able to directly route traffic between
    containers running on different machines.'
  id: totrans-777
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 网络的作用域可以取三个值：`本地`、`全局`或`蜂群`。这表示网络是否被限制在存在网络的机器上（本地），应该在集群中的每个节点上创建但不在它们之间路由（全局），或者无缝跨越参与Docker蜂群的所有主机（多主机或集群范围）。正如您所看到的，所有默认网络都具有`本地`作用域，并且无法直接在不同机器上运行的容器之间路由流量。
- en: The default `bridge` network maintains compatibility with legacy Docker and
    cannot take advantage of modern Docker features including service discovery or
    load balancing. Using it is not recommended. So the first thing you should do
    is create your own bridge network.
  id: totrans-778
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认的`桥接`网络与旧版Docker保持兼容，无法利用现代Docker功能，包括服务发现或负载均衡。使用它不被推荐。因此，您应该做的第一件事是创建自己的桥接网络。
- en: 5.2.1\. Creating a user-defined bridge network
  id: totrans-779
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.2.1. 创建用户定义的桥接网络
- en: The Docker `bridge` network driver uses Linux namespaces, virtual Ethernet devices,
    and the Linux firewall to build a specific and customizable virtual network topology
    called a bridge. The resulting virtual network is local to the machine where Docker
    is installed and creates routes between participating containers and the wider
    network where the host is attached. [Figure 5.4](#filepos478237) illustrates two
    containers attached to a bridge network and its components.
  id: totrans-780
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker `桥接`网络驱动程序使用Linux命名空间、虚拟以太网设备和Linux防火墙来构建一个特定且可定制的虚拟网络拓扑，称为桥接。生成的虚拟网络是Docker安装的机器上的本地网络，并在参与容器和连接的主机更广泛的网络之间创建路由。图5.4说明了连接到桥接网络及其组件的两个容器。
- en: Figure 5.4\. The default local Docker network topology and two attached containers
  id: totrans-781
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图5.4. 默认本地Docker网络拓扑和两个附加的容器
- en: '![](images/00022.jpg)'
  id: totrans-782
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00022.jpg)'
- en: Containers have their own private loopback interface and a separate virtual
    Ethernet interface linked to another virtual interface in the host’s namespace.
    These two linked interfaces form a link between the host’s network and the container.
    Just like typical home networks, each container is assigned a unique private IP
    address that’s not directly reachable from the external network. Connections are
    routed through another Docker network that routes traffic between containers and
    may connect to the host’s network to form a bridge.
  id: totrans-783
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 容器有自己的私有回环接口和连接到主机命名空间中另一个虚拟接口的单独虚拟以太网接口。这两个链接接口在主机的网络和容器之间形成连接。就像典型的家庭网络一样，每个容器都被分配了一个唯一的私有IP地址，该地址不能从外部网络直接访问。连接通过另一个Docker网络进行路由，该网络在容器之间路由流量，并且可能连接到主机的网络以形成一个桥接。
- en: 'Build a new network with a single command:'
  id: totrans-784
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用单个命令构建新的网络：
- en: '`docker network create \   --driver bridge \   --label project=dockerinaction
    \   --label chapter=5 \   --attachable \   --scope local \   --subnet 10.0.42.0/24
    \   --ip-range 10.0.42.128/25 \   user-network`'
  id: totrans-785
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker network create \   --driver bridge \   --label project=dockerinaction
    \   --label chapter=5 \   --attachable \   --scope local \   --subnet 10.0.42.0/24
    \   --ip-range 10.0.42.128/25 \   user-network`'
- en: This command creates a new local bridge network named `user-network`. Adding
    label metadata to the network will help in identifying the resource later. Marking
    the new network as `attachable` allows you to attach and detach containers to
    the network at any time. Here you’ve manually specified the network `scope` property
    and set it to the default value for this driver. Finally, a custom subnet and
    assignable address range was defined for this network, 10.0.42.0/24, assigning
    from the upper half of the last octet (10.0.42.128/25). This means that as you
    add containers to this network, they will receive IP addresses in the range from
    10.0.42.128 to 10.0.42.255\.
  id: totrans-786
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此命令创建了一个名为`user-network`的新本地桥接网络。向网络添加标签元数据有助于稍后识别资源。将新网络标记为`可附加`允许您在任何时候将容器附加到或从网络中分离。在这里，您已手动指定了网络的`作用域`属性并将其设置为该驱动程序的默认值。最后，为该网络定义了一个自定义子网和可分配的地址范围，10.0.42.0/24，从最后一个八位的上半部分（10.0.42.128/25）分配。这意味着随着您向此网络添加容器，它们将接收从10.0.42.128到10.0.42.255范围内的IP地址。
- en: You can inspect networks like other first-class Docker entities. The next section
    demonstrates how to use containers with user networks and inspect the resulting
    network configuration.
  id: totrans-787
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以像检查其他一等Docker实体一样检查网络。下一节将演示如何使用带有用户网络的容器并检查结果网络配置。
- en: 5.2.2\. Exploring a bridge network
  id: totrans-788
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.2.2. 探索桥接网络
- en: 'If you’re going to run network software inside a container on a container network,
    you should have a solid understanding of what that network looks like from within
    a container. Start exploring your new bridge network by creating a new container
    attached to that network:'
  id: totrans-789
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您打算在容器网络中运行网络软件，您应该对容器内部该网络的外观有一个扎实的理解。通过创建一个连接到该网络的新容器来开始探索您的新桥接网络：
- en: '`docker run -it \   --network user-network \   --name network-explorer \  
    alpine:3.8 \     sh`'
  id: totrans-790
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -it \   --network user-network \   --name network-explorer \   alpine:3.8
    \    sh`'
- en: 'Get a list of the IPv4 addresses available in the container from your terminal
    (which is now attached to the running container) by running the following:'
  id: totrans-791
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过在终端中运行以下命令，从容器中获取可用的IPv4地址列表（此时终端已连接到正在运行的容器）：
- en: '`ip -f inet -4 -o addr`'
  id: totrans-792
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ip -f inet -4 -o addr`'
- en: 'The results should look something like this:'
  id: totrans-793
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 结果应该看起来像这样：
- en: '`1: lo    inet 127.0.0.1/8 scope host lo\ ... 18: eth0    inet 10.0.42.129/24
    brd 10.0.42.255 scope global eth0\ ...`'
  id: totrans-794
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`1: lo    inet 127.0.0.1/8 scope host lo\ ... 18: eth0    inet 10.0.42.129/24
    brd 10.0.42.255 scope global eth0\ ...`'
- en: You can see from this list that the container has two network devices with IPv4
    addresses. Those are the loopback interface (or localhost) and eth0 (a virtual
    Ethernet device), which is connected to the bridge network. Further, you can see
    that eth0 has an IP address within the range and subnet specified by the user-network
    configuration (the range from 10.0.42.128 to 10.0.42.255). That IP address is
    the one that any other container on this bridge network would use to communicate
    with services you run in this container. The loopback interface can be used only
    for communication within the same container.
  id: totrans-795
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以从此列表中看到，容器有两个具有IPv4地址的网络设备。这些是回环接口（或本地主机）和eth0（一个虚拟以太网设备），它们连接到桥接网络。此外，您可以看到eth0具有用户-network配置指定的IP地址范围和子网内的IP地址（从10.0.42.128到10.0.42.255）。该IP地址是任何其他在此桥接网络上运行的容器用来与您在此容器中运行的服务通信的IP地址。回环接口只能用于容器内部通信。
- en: 'Next, create another bridge network and attach your running `network-explorer`
    container to both networks. First, detach your terminal from the running container
    (press Ctrl-P and then Ctrl-Q) and then create the second bridge network:'
  id: totrans-796
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接下来，创建另一个桥接网络并将正在运行的`network-explorer`容器连接到这两个网络。首先，从运行中的容器断开终端连接（按Ctrl-P然后按Ctrl-Q），然后创建第二个桥接网络：
- en: '`docker network create \   --driver bridge \   --label project=dockerinaction
    \   --label chapter=5 \    --attachable \   --scope local \   --subnet 10.0.43.0/24
    \   --ip-range 10.0.43.128/25 \   user-network2`'
  id: totrans-797
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker network create \   --driver bridge \   --label project=dockerinaction
    \   --label chapter=5 \    --attachable \    --scope local \    --subnet 10.0.43.0/24
    \    --ip-range 10.0.43.128/25 \    user-network2`'
- en: 'Once the second network has been created, you can attach the `network-explorer`
    container (still running):'
  id: totrans-798
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦创建了第二个网络，您可以将`network-explorer`容器（仍在运行）连接到该网络：
- en: '`docker network connect \   user-network2 \` `1` `network-explorer` `2`'
  id: totrans-799
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker network connect \   user-network2 \` `1` `network-explorer` `2`'
- en: 1 Network name (or ID)
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 网络名称（或ID）
- en: 2 Target container name (or ID)
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 目标容器名称（或ID）
- en: 'After the container has been attached to the second network, reattach your
    terminal to continue your exploration:'
  id: totrans-802
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在容器连接到第二个网络后，重新连接您的终端以继续探索：
- en: '`docker attach network-explorer`'
  id: totrans-803
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker attach network-explorer`'
- en: 'Now, back in the container, examining the network interface configuration again
    will show something like this:'
  id: totrans-804
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，回到容器中，再次检查网络接口配置将显示如下：
- en: '`1: lo    inet 127.0.0.1/8 scope host lo\ ... 18: eth0    inet 10.0.42.129/24
    brd 10.0.42.255 scope global eth0\ ... 20: eth1    inet 10.0.43.129/24 brd 10.0.43.255
    scope global eth1\ ...`'
  id: totrans-805
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`1: lo    inet 127.0.0.1/8 scope host lo\ ... 18: eth0    inet 10.0.42.129/24
    brd 10.0.42.255 scope global eth0\ ... 20: eth1    inet 10.0.43.129/24 brd 10.0.43.255
    scope global eth1\ ...`'
- en: As you might expect, this output shows that the `network-explorer` container
    is attached to both user-defined bridge networks.
  id: totrans-806
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如您所预期，此输出显示`network-explorer`容器连接到两个用户定义的桥接网络。
- en: 'Networking is all about communication between multiple parties, and examining
    a network with only one running container can be a bit boring. But is there anything
    else attached to a bridge network by default? Another tool is needed to continue
    exploring. Install the nmap package inside your running container by using this
    command:'
  id: totrans-807
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 网络完全是关于多方之间的通信，仅使用一个运行的容器来检查网络可能会有些无聊。但是，默认情况下是否有其他设备连接到桥接网络？需要另一个工具来继续探索。通过以下命令在运行的容器中安装
    nmap 软件包：
- en: '`apk update && apk add nmap`'
  id: totrans-808
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`apk update && apk add nmap`'
- en: 'Nmap is a powerful network inspection tool that can be used to scan network
    address ranges for running machines, fingerprint those machines, and determine
    what services they are running. For our purposes, we simply want to determine
    what other containers or other network devices are available on our bridge network.
    Run the following command to scan the 10.0.42.0/24 subnet that we defined for
    our bridge network:'
  id: totrans-809
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Nmap 是一款强大的网络检查工具，可用于扫描网络地址范围中的运行中的机器，识别这些机器，并确定它们正在运行的服务。对于我们来说，我们只想确定在桥接网络上还有哪些其他容器或其他网络设备可用。运行以下命令来扫描我们为桥接网络定义的
    10.0.42.0/24 子网：
- en: '`nmap -sn 10.0.42.* -sn 10.0.43.* -oG /dev/stdout | grep Status`'
  id: totrans-810
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`nmap -sn 10.0.42.* -sn 10.0.43.* -oG /dev/stdout | grep Status`'
- en: 'The command should output something like this:'
  id: totrans-811
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命令应输出类似以下内容：
- en: '`Host: 10.0.42.128 ()       Status: Up Host: 10.0.42.129 (7c2c161261cb)   Status:
    Up  Host: 10.0.43.128 ()       Status: Up Host: 10.0.43.129 (7c2c161261cb)   Status:
    Up`'
  id: totrans-812
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`主机: 10.0.42.128 ()       状态: 启用 主机: 10.0.42.129 (7c2c161261cb)   状态: 启用  主机:
    10.0.43.128 ()       状态: 启用 主机: 10.0.43.129 (7c2c161261cb)   状态: 启用`'
- en: 'This shows that only two devices are attached to each of the bridge networks:
    the gateway adapters created by the bridge network driver and the currently running
    container. Create another container on one of the two bridge networks for more
    interesting results.'
  id: totrans-813
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这表明每个桥接网络中只连接了两个设备：由桥接网络驱动程序创建的网关适配器和当前正在运行的容器。在两个桥接网络之一上创建另一个容器以获得更有趣的结果。
- en: 'Detach from the terminal again (Ctrl-P, Ctrl-Q) and start another container
    attached to `user-network2`. Run the following:'
  id: totrans-814
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 再次从终端断开（Ctrl-P, Ctrl-Q）并启动另一个连接到 `user-network2` 的容器。运行以下命令：
- en: '`docker run -d \   --name lighthouse \   --network user-network2 \   alpine:3.8
    \     sleep 1d`'
  id: totrans-815
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d \ --name lighthouse \ --network user-network2 \ alpine:3.8 \
    sleep 1d`'
- en: 'After the `lighthouse` container has started, reattach to your `network-explorer`
    container:'
  id: totrans-816
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 `lighthouse` 容器启动后，重新连接到你的 `network-explorer` 容器：
- en: '`docker attach network-explorer`'
  id: totrans-817
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker attach network-explorer`'
- en: 'And from the shell in that container, run the network scan again. The results
    show that the `lighthouse` container is up and running, and accessible from the
    `network-explorer` container via its attachment to `user-network2`. The output
    should be similar to this:'
  id: totrans-818
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后在容器的 shell 中再次运行网络扫描。结果显示，`lighthouse` 容器正在运行，并且可以通过其连接到 `user-network2` 的方式从
    `network-explorer` 容器访问。输出应类似于以下内容：
- en: '`Host: 10.0.42.128 ()       Status: Up Host: 10.0.42.129 (7c2c161261cb)   Status:
    Up Host: 10.0.43.128 ()       Status: Up Host: 10.0.43.130 (lighthouse.user-network2)      
    Status: Up Host: 10.0.43.129 (7c2c161261cb)    Status: Up`'
  id: totrans-819
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`主机: 10.0.42.128 ()       状态: 启用 主机: 10.0.42.129 (7c2c161261cb)   状态: 启用 主机:
    10.0.43.128 ()       状态: 启用 主机: 10.0.43.130 (lighthouse.user-network2)       状态:
    启用 主机: 10.0.43.129 (7c2c161261cb)    状态: 启用`'
- en: Discovering the `lighthouse` container on the network confirms that the network
    attachment works as expected, and demonstrates how the DNS-based service discovery
    system works. When you scanned the network, you discovered the new node by its
    IP address, and nmap was able to resolve that IP address to a name. This means
    that you (or your code) can discover individual containers on the network based
    on their name. Try this yourself by running `nslookup lighthouse` inside the container.
    Container hostnames are based on the container name, or can be set manually at
    container creation time by specifying the `--hostname` flag.
  id: totrans-820
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在网络上发现 `lighthouse` 容器确认了网络连接按预期工作，并演示了基于 DNS 的服务发现系统是如何工作的。当你扫描网络时，你通过其 IP
    地址发现了新的节点，nmap 能够解析该 IP 地址。这意味着你可以（或你的代码）根据名称在网络中查找单个容器。通过在容器内运行 `nslookup lighthouse`
    来尝试自己这样做。容器主机名基于容器名称，或者可以在创建容器时通过指定 `--hostname` 标志手动设置。
- en: This exploration has demonstrated your ability to shape bridge networks to fit
    your environment, the ability to attach a running container to more than one network,
    and what those networks look like to running software inside an attached container.
    But bridge networks work on only a single machine. They are not cluster-aware,
    and the container IP addresses are not routable from outside that machine.
  id: totrans-821
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这次探索展示了你调整桥接网络以适应环境的能力，将运行中的容器附加到多个网络上的能力，以及这些网络在附加容器内运行的软件看来是什么样子。但是桥接网络仅在单个机器上工作。它们不具备集群感知性，并且容器IP地址不能从该机器外部路由。
- en: 5.2.3\. Beyond bridge networks
  id: totrans-822
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.2.3\. 超越桥接网络
- en: Depending on your use case, bridge networks might be enough. For example, bridge
    networks are typically great for single-server deployments such as a LAMP stack
    running a content management system, or most local development tasks. But if you
    are running a multiserver environment that is designed to tolerate machine failure,
    you need to be able to seamlessly route traffic between containers on different
    machines. Bridge networks will not do this.
  id: totrans-823
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 根据你的用例，桥接网络可能已经足够。例如，桥接网络通常非常适合单服务器部署，如运行内容管理系统或大多数本地开发任务的LAMP堆栈。但是，如果你正在运行一个设计为容忍机器故障的多服务器环境，你需要能够无缝地在不同机器上的容器之间路由流量。桥接网络无法做到这一点。
- en: Docker has a few options to handle this use case out of the box. The best option
    depends on the environment where you are building the network. If you are using
    Docker on Linux hosts and have control of the host network, you can use underlay
    networks provided by the `macvlan` or `ipvlan` network drivers. Underlay networks
    create first-class network addresses for each container. Those identities are
    discoverable and routable from the same network where the host is attached. Each
    container running on a machine just looks like an independent node on the network.
  id: totrans-824
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker提供了一些选项来处理这种用例。最佳选项取决于你构建网络的环境。如果你在Linux主机上使用Docker并且控制主机网络，你可以使用由`macvlan`或`ipvlan`网络驱动程序提供的底层网络。底层网络为每个容器创建第一类网络地址。这些身份是可发现的并且可以从主机附加的网络中进行路由。在机器上运行的每个容器看起来就像网络上的一个独立节点。
- en: If you are running Docker for Mac or Docker for Windows or are running in a
    managed cloud environment, those options will not work. Further, underlay network
    configuration is dependent on the host network, and so definitions are rarely
    portable. The more popular multihost container network option is overlay networks.
  id: totrans-825
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你正在运行Docker for Mac或Docker for Windows，或者在一个托管云环境中运行，这些选项将不起作用。此外，底层网络配置依赖于主机网络，因此定义很少是可移植的。更受欢迎的跨主机容器网络选项是overlay网络。
- en: The overlay network driver is available on Docker engines where swarm mode is
    enabled. Overlay networks are similar in construction to bridge networks, but
    the logical bridge component is multihost-aware and can route intercontainer connections
    between every node in a swarm.
  id: totrans-826
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在启用了swarm模式的Docker引擎上，overlay网络驱动程序可用。overlay网络在结构上与桥接网络相似，但逻辑桥接组件是跨主机感知的，并且可以在swarm中的每个节点之间路由容器间的连接。
- en: Just like on a bridge network, containers on an overlay network are not directly
    routable from outside the cluster. But intercontainer communication is simple,
    and network definitions are mostly independent of the host network environment.
  id: totrans-827
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 就像在桥接网络上一样，overlay网络上的容器不能从集群外部直接路由。但容器间通信简单，网络定义在很大程度上独立于主机网络环境。
- en: In some cases, you’ll have special network requirements that aren’t covered
    by underlay or overlay networks. Maybe you need to be able to tune the host network
    configuration or to make sure that a container operates with total network isolation.
    In those cases, you should use one of the special container networks.
  id: totrans-828
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能会有底层或overlay网络无法覆盖的特殊网络需求。也许你需要能够调整主机网络配置，或者确保容器以完全网络隔离的方式运行。在这些情况下，你应该使用特殊容器网络之一。
- en: '5.3\. SPECIAL CONTAINER NETWORKS: HOST AND NONE'
  id: totrans-829
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.3\. 特殊容器网络：主机和none
- en: 'When you list the available networks with `docker network list`, the results
    will include two special entries: `host` and `none`. These are not really networks;
    instead, they are network attachment types with special meaning.'
  id: totrans-830
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你使用`docker network list`列出可用的网络时，结果将包括两个特殊条目：`host`和`none`。这些实际上不是网络；相反，它们是具有特殊意义的网络附加类型。
- en: When you specify the `--network host` option on a `docker run` command, you
    are telling Docker to create a new container without any special network adapters
    or network namespace. Whatever software is running inside the resulting container
    will have the same degree of access to the host network as it would running outside
    the container. Since there is no network namespace, all of the kernel tools for
    tuning the network stack are available for modification (as long as the modifying
    process has access to do so).
  id: totrans-831
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你在`docker run`命令中指定`--network host`选项时，你是在告诉Docker创建一个没有特殊网络适配器或网络命名空间的新的容器。在结果容器内运行的任何软件都将具有与容器外部运行相同的访问主机网络的程度。由于没有网络命名空间，所有用于调整网络堆栈的内核工具都可用于修改（只要修改进程有权这样做）。
- en: 'Containers running on the host network are able to access host services running
    on localhost and are able to see and bind to any of the host network interfaces.
    The following command demonstrates this by listing all of the available network
    interfaces from inside a container on the host network:'
  id: totrans-832
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在主机网络上运行容器可以访问运行在localhost上的主机服务，并且可以查看并绑定到主机网络接口的任何接口。以下命令通过列出主机网络上容器内所有可用的网络接口来演示这一点：
- en: '`docker run --rm \     --network host \     alpine:3.8 ip -o addr`'
  id: totrans-833
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --rm \   --network host \   alpine:3.8 ip -o addr`'
- en: Running on the host network is useful for system services or other infrastructure
    components. But it is not appropriate in multitenant environments and should be
    disallowed for third-party containers. Along these lines, you’ll often want to
    not attach a container to a network. In the spirit of building systems of least
    privilege, you should use the `none` network whenever possible.
  id: totrans-834
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在主机网络上运行很有用，适用于系统服务或其他基础设施组件。但在多租户环境中不合适，并且应禁止第三方容器使用。沿着这些思路，你通常会希望不将容器连接到网络。本着构建最小权限系统的精神，你应该尽可能使用`none`网络。
- en: Creating a container on the `none` network instructs Docker not to provision
    any connected virtual Ethernet adapters for the new container. It will have its
    own network namespace and so it will be isolated, but without adapters connected
    across the namespace boundary, it will not be able to use the network to communicate
    outside the container. Containers configured this way will still have their own
    loopback interface, and so multiprocess containers can still use connections to
    localhost for interprocess communication.
  id: totrans-835
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在`none`网络上创建容器指示Docker不为新容器提供任何连接的虚拟以太网适配器。它将有自己的网络命名空间，因此它将是隔离的，但由于没有跨越命名空间边界的适配器连接，它将无法使用网络与容器外部通信。以这种方式配置的容器仍然有自己的回环接口，因此多进程容器仍然可以使用连接到localhost的连接进行进程间通信。
- en: 'You can verify this by inspecting the network configuration yourself. Run the
    following command to list the available interfaces inside a container on the `none`
    network:'
  id: totrans-836
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以通过检查自己的网络配置来验证这一点。运行以下命令以列出`none`网络中容器内的可用接口：
- en: '`docker run --rm \     --network none \     alpine:3.8 ip -o addr`'
  id: totrans-837
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --rm \   --network none \   alpine:3.8 ip -o addr`'
- en: 'Running this example, you can see that the only network interface available
    is the loopback interface, bound to the address 127.0.0.1\. This configuration
    means three things:'
  id: totrans-838
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行此示例，你可以看到唯一可用的网络接口是回环接口，绑定到地址127.0.0.1。这种配置意味着三件事：
- en: Any program running in the container can connect to or wait for connections
    on that interface.
  id: totrans-839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器中运行的任何程序都可以连接到该接口或等待连接。
- en: Nothing outside the container can connect to that interface.
  id: totrans-840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器外部无法连接到该接口。
- en: No program running inside that container can reach anything outside the container.
  id: totrans-841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器内部运行的任何程序都无法连接到容器外部。
- en: 'That last point is important and easily demonstrated. If you’re connected to
    the internet, try to reach a popular service that should always be available.
    In this case, try to reach Cloudflare’s public DNS service:'
  id: totrans-842
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后一点很重要，并且很容易证明。如果你连接到了互联网，尝试连接到一个应该始终可用的流行服务。在这种情况下，尝试连接到Cloudflare的公共DNS服务：
- en: '`docker run --rm \     --network none \` `1` `alpine:3.8 \     ping -w 2 1.1.1.1`
    `2`'
  id: totrans-843
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --rm \   --network none \` `1` `alpine:3.8 \   ping -w 2 1.1.1.1`
    `2`'
- en: 1 Creates a closed container
  id: totrans-844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 创建一个封闭的容器
- en: 2 Pings Cloudflare
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 向Cloudflare发送ping请求
- en: 'In this example, you create a network-isolated container and try to test the
    speed between your container and the public DNS server provided by Cloudflare.
    This attempt should fail with a message like `ping: send-to: Network is unreachable`.
    This makes sense because we know that the container has no route to the larger
    network.'
  id: totrans-846
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '在这个例子中，你创建了一个网络隔离的容器，并尝试测试你的容器与Cloudflare提供的公共DNS服务器之间的速度。这次尝试应该会失败，并显示类似“ping:
    send-to: Network is unreachable”的消息。这很合理，因为我们知道该容器没有通往更大网络的路径。'
- en: '|    |'
  id: totrans-847
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: When to use closed containers
  id: totrans-848
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 何时使用封闭容器
- en: The `none` network should be used when the need for network isolation is the
    highest or whenever a program doesn’t require network access. For example, running
    a terminal text editor shouldn’t require network access. Running a program to
    generate a random password should be run inside a container without network access
    to prevent the theft of that secret.
  id: totrans-849
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当需要最高级别的网络隔离，或者程序不需要网络访问时，应使用`none`网络。例如，运行终端文本编辑器不应需要网络访问。运行生成随机密码的程序应在没有网络访问的容器内运行，以防止该秘密被盗。
- en: '|    |'
  id: totrans-850
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: Containers on the `none` network are isolated from each other and the rest of
    the world, but remember that even containers on the `bridge` network are not directly
    routable from outside the host running the Docker engine.
  id: totrans-851
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在`none`网络上的容器彼此之间以及与世界其他部分都是隔离的，但请记住，即使在`bridge`网络上的容器也不是可以从运行Docker引擎的主机外部直接路由的。
- en: Bridge networks use network address translation (NAT) to make all outbound container
    traffic with destinations outside the bridge network look like it is coming from
    the host itself. This means that the service software you have running in containers
    is isolated from the rest of the world, and the parts of the network where most
    of your clients and customers are located. The next section describes how to bridge
    that gap.
  id: totrans-852
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 桥接网络使用网络地址转换（NAT）来使所有目标在桥接网络之外的外出容器流量看起来像是从主机本身发出的。这意味着你在容器中运行的服务的软件与世界其他部分以及客户和客户主要所在的网络部分是隔离的。下一节将描述如何弥合这一差距。
- en: 5.4\. HANDLING INBOUND TRAFFIC WITH NODEPORT PUBLISHING
  id: totrans-853
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.4. 使用NODEPORT发布处理入站流量
- en: Docker container networks are all about simple connectivity and routing between
    containers. Connecting services running in those containers with external network
    clients requires an extra step. Since container networks are connected to the
    broader network via network address translation, you have to specifically tell
    Docker how to forward traffic from the external network interfaces. You need to
    specify a TCP or UDP port on the host interface and a target container and container
    port, similar to forwarding traffic through a NAT barrier on your home network.
  id: totrans-854
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker容器网络主要关注容器之间的简单连接和路由。将运行在容器中的服务与外部网络客户端连接需要额外的一步。由于容器网络通过网络地址转换连接到更广泛的网络，你必须明确告诉Docker如何从外部网络接口转发流量。你需要在主机接口上指定一个TCP或UDP端口以及目标容器和容器端口，类似于在家网络中通过NAT屏障转发流量。
- en: NodePort publishing is a term we’ve used here to match Docker and other ecosystem
    projects. The Node portion is an inference to the host as typically a node in
    a larger cluster of machines.
  id: totrans-855
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这里，我们使用NodePort发布这个术语来匹配Docker和其他生态系统项目。Node部分是对主机的一种推断，因为在更大的机器集群中，节点通常指的是主机。
- en: 'Port publication configuration is provided at container creation time and cannot
    be changed later. The `docker run` and `docker create` commands provide a `-p`
    or `--publish` list option. Like other options, the `-p` option takes a colon-delimited
    string argument. That argument specifies the host interface, the port on the host
    to forward, the target port, and the port protocol. All of the following arguments
    are equivalent:'
  id: totrans-856
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 端口发布配置在容器创建时提供，以后不能更改。`docker run`和`docker create`命令提供了一个`-p`或`--publish`列表选项。与其他选项一样，`-p`选项接受冒号分隔的字符串参数。该参数指定了主机接口、要转发的宿主端口、目标端口和端口协议。以下所有参数都是等效的：
- en: '`0.0.0.0:8080:8080/tcp`'
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.0.0.0:8080:8080/tcp`'
- en: '`8080:8080/tcp`'
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`8080:8080/tcp`'
- en: '`8080:8080`'
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`8080:8080`'
- en: 'Each of those options will forward TCP port 8080 from all host interfaces to
    TCP port 8080 in the new container. The first argument is the full form. To put
    the syntax in a more complete context, consider the following example commands:'
  id: totrans-860
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些选项中的每一个都会将所有主机接口上的TCP端口8080转发到新容器中的TCP端口8080。第一个参数是完整形式。为了将语法放在更完整的上下文中，考虑以下示例命令：
- en: '`docker run --rm \   -p 8080 \   alpine:3.8 echo "forward ephemeral TCP ->
    container TCP 8080"  docker run --rm \   -p 8088:8080/udp \   alpine:3.8 echo
    "host UDP 8088 -> container UDP 8080"  docker run --rm \   -p 127.0.0.1:8080:8080/tcp
    \   -p 127.0.0.1:3000:3000/tcp \   alpine:3.8 echo "forward multiple TCP ports
    from localhost"`'
  id: totrans-861
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --rm \   -p 8080 \   alpine:3.8 echo "forward ephemeral TCP ->
    container TCP 8080"  docker run --rm \   -p 8088:8080/udp \   alpine:3.8 echo
    "host UDP 8088 -> container UDP 8080"  docker run --rm \   -p 127.0.0.1:8080:8080/tcp
    \   -p 127.0.0.1:3000:3000/tcp \   alpine:3.8 echo "forward multiple TCP ports
    from localhost"`'
- en: These commands all do different things and demonstrate the flexibility of the
    syntax. The first problem that new users encounter is in presuming that the first
    example will map 8080 on the host to port 8080 in the container. What actually
    happens is the host operating system will select a random host port, and traffic
    will be routed to port 8080 in the container. The benefit to this design and default
    behavior is that ports are scarce resources, and choosing a random port allows
    the software and the tooling to avoid potential conflicts. But programs running
    inside a container have no way of knowing that they are running inside a container,
    that they are bound to a container network, or which port is being forwarded from
    the host.
  id: totrans-862
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些命令执行不同的操作，展示了语法的灵活性。新用户遇到的第一问题可能是假设第一个示例会将宿主机的 8080 端口映射到容器的 8080 端口。实际上，宿主机操作系统将选择一个随机的主机端口，并且流量将被路由到容器的
    8080 端口。这种设计和默认行为的好处是端口是稀缺资源，选择随机端口可以使软件和工具避免潜在的冲突。但是，容器内运行的程序无法知道它们是在容器内运行的，它们绑定到容器网络，或者哪个端口是从宿主机转发过来的。
- en: 'Docker provides a mechanism for looking up port mappings. That feature is critical
    when you let the operating system choose a port. Run the `docker port` subcommand
    to see the ports forwarded to any given container:'
  id: totrans-863
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker 提供了一种查找端口映射的机制。当您让操作系统选择端口时，这个功能至关重要。运行 `docker port` 子命令以查看转发到任何给定容器的端口：
- en: '`docker run -d -p 8080 --name listener alpine:3.8 sleep 300 docker port listener`'
  id: totrans-864
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d -p 8080 --name listener alpine:3.8 sleep 300 docker port listener`'
- en: 'This information is also available in summary form with the `docker ps` subcommand,
    but picking specific mappings out of the table can be tiresome and does not compose
    well with other commands. The `docker port` subcommand also allows you to narrow
    the lookup query by specifying the container port and protocol. That is particularly
    useful when multiple ports are published:'
  id: totrans-865
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此信息也可以通过 `docker ps` 子命令以摘要形式获取，但从表中挑选特定的映射可能会很麻烦，并且与其他命令的兼容性不佳。`docker port`
    子命令还允许您通过指定容器端口和协议来缩小查找查询。这在多个端口已发布时特别有用：
- en: '`docker run -d \   -p 8080 \` `1` `-p 3000 \` `1` `-p 7500 \` `1` `--name multi-listener
    \   alpine:3.8 sleep 300  docker port multi-listener 3000` `2`'
  id: totrans-866
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run -d \   -p 8080 \` `1` `-p 3000 \` `1` `-p 7500 \` `1` `--name multi-listener
    \   alpine:3.8 sleep 300  docker port multi-listener 3000` `2`'
- en: 1 Publishes multiple ports
  id: totrans-867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 发布多个端口
- en: 2 Looks up the host port mapped to container port 3000
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 查找映射到容器端口 3000 的主机端口
- en: With the tools covered in this section, you should be able to manage routing
    any inbound traffic to the correct container running on your host. But there are
    several other ways to customize container network configurations and caveats in
    working with Docker networks. Those are covered in the next section.
  id: totrans-869
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用本节中介绍的工具，您应该能够管理将任何传入流量路由到在您的宿主机上运行的正确容器。但是，还有几种其他方式来自定义容器网络配置和与 Docker 网络一起使用的注意事项。这些内容将在下一节中介绍。
- en: 5.5\. CONTAINER NETWORKING CAVEATS AND CUSTOMIZATIONS
  id: totrans-870
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.5\. 容器网络注意事项和自定义
- en: Networking is used by all kinds of applications and in many contexts. Some bring
    requirements that cannot be fulfilled today, or might require further network
    customization. This section covers a short list of topics that any user should
    be familiar with in adopting containers for networked applications.
  id: totrans-871
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 网络被各种应用程序和许多环境所使用。有些需求目前无法满足，或者可能需要进一步的网络自定义。本节涵盖了一些任何用户在采用容器用于网络应用程序时应熟悉的简短主题列表。
- en: 5.5.1\. No firewalls or network policies
  id: totrans-872
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.5.1\. 没有防火墙或网络策略
- en: Today Docker container networks do not provide any access control or firewall
    mechanisms between containers. Docker networking was designed to follow the namespace
    model that is in use in so many other places in Docker. The namespace model solves
    resource access-control problems by transforming them into addressability problems.
    The thinking is that software that’s in two containers in the same container network
    should be able to communicate. In practice, this is far from the truth, and nothing
    short of application-level authentication and authorization can protect containers
    from each other on the same network. Remember, different applications carry different
    vulnerabilities and might be running in containers on different hosts with different
    security postures. A compromised application does not need to escalate privileges
    before it opens network connections. The firewall will not protect you.
  id: totrans-873
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 今天，Docker容器网络在容器之间不提供任何访问控制或防火墙机制。Docker网络设计遵循Docker其他许多地方使用的命名空间模型。命名空间模型通过将资源访问控制问题转化为可寻址问题来解决资源访问控制问题。这种想法是，位于同一容器网络中的两个容器中的软件应该能够通信。在实践中，这远远不是事实，只有应用程序级的身份验证和授权才能保护同一网络上的容器彼此不受侵害。记住，不同的应用程序携带不同的漏洞，可能在不同主机上的容器中运行，具有不同的安全态势。一个被破坏的应用程序在打开网络连接之前不需要提升权限。防火墙不能保护您。
- en: This design decision impacts the way we have to architect internetwork service
    dependencies and model common service deployments. In short, always deploy containers
    with appropriate application-level access-control mechanisms because containers
    on the same container network will have mutual (bidirectional) unrestricted network
    access.
  id: totrans-874
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个设计决策影响了我们构建互联网服务依赖关系和模型常见服务部署的方式。简而言之，始终使用适当的应用程序级访问控制机制来部署容器，因为同一容器网络上的容器将具有相互（双向）无限制的网络访问。
- en: 5.5.2\. Custom DNS configuration
  id: totrans-875
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.5.2. 自定义DNS配置
- en: Domain Name System (DNS) is a protocol for mapping hostnames to IP addresses.
    This mapping enables clients to decouple from a dependency on a specific host
    IP and instead depend on whatever host is referred to by a known name. One of
    the most basic ways to change outbound communications is by creating names for
    IP addresses.
  id: totrans-876
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 域名系统（DNS）是一种将主机名映射到IP地址的协议。这种映射使得客户端可以从对特定主机IP的依赖中解耦，转而依赖于由已知名称引用的任何主机。改变出站通信的最基本方法之一是为IP地址创建名称。
- en: Typically, containers on the bridge network and other computers on your network
    have private IP addresses that aren’t publicly routable. This means that unless
    you’re running your own DNS server, you can’t refer to them by a name. Docker
    provides different options for customizing the DNS configuration for a new container.
  id: totrans-877
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通常，桥接网络上的容器和您网络上的其他计算机具有私有IP地址，这些地址不能公开路由。这意味着除非您运行自己的DNS服务器，否则您不能通过名称来引用它们。Docker为自定义新容器的DNS配置提供了不同的选项。
- en: 'First, the `docker run` command has a `--hostname` flag that you can use to
    set the hostname of a new container. This flag adds an entry to the DNS override
    system inside the container. The entry maps the provided hostname to the container’s
    bridge IP address:'
  id: totrans-878
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先，`docker run` 命令有一个 `--hostname` 标志，您可以使用它来设置新容器的主机名。此标志会在容器内部的DNS覆盖系统中添加一个条目。该条目将提供的主机名映射到容器的桥接IP地址：
- en: '`docker run --rm \     --hostname barker \` `1` `alpine:3.8 \     nslookup
    barker` `2`'
  id: totrans-879
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --rm \   --hostname barker \` `1` `alpine:3.8 \   nslookup barker`
    `2`'
- en: 1 Sets the container hostname
  id: totrans-880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` 设置容器主机名'
- en: 2 Resolves the hostname to an IP address
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2` 解析主机名到IP地址'
- en: 'This example creates a new container with the hostname `barker` and runs a
    program to look up the IP address for the same name. Running this example will
    generate output that looks something like the following:'
  id: totrans-882
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此示例创建了一个具有主机名 `barker` 的新容器，并运行了一个程序来查找相同名称的IP地址。运行此示例将生成类似以下输出的输出：
- en: '`Server:    10.0.2.3 Address 1: 10.0.2.3  Name:      barker Address 1: 172.17.0.22
    barker`'
  id: totrans-883
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Server:    10.0.2.3 Address 1: 10.0.2.3  Name:      barker Address 1: 172.17.0.22
    barker`'
- en: The IP address on the last line is the bridge IP address for the new container.
    The IP address provided on the line labeled `Server` is the address of the server
    that provided the mapping.
  id: totrans-884
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后行上的IP地址是新容器的桥接IP地址。标有 `Server` 的行上提供的地址是提供映射的服务器地址。
- en: Setting the hostname of a container is useful when programs running inside a
    container need to look up their own IP address or must self-identify. Because
    other containers don’t know this hostname, its uses are limited. But if you use
    an external DNS server, you can share those hostnames.
  id: totrans-885
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 设置容器的主机名对于容器内运行的程序需要查找自己的IP地址或必须自我识别时很有用。因为其他容器不知道这个主机名，所以它的用途有限。但是，如果你使用外部DNS服务器，你可以共享这些主机名。
- en: 'The second option for customizing the DNS configuration of a container is the
    ability to specify one or more DNS servers to use. To demonstrate, the following
    example creates a new container and sets the DNS server for that container to
    Google’s public DNS service:'
  id: totrans-886
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 修改容器DNS配置的第二个选项是能够指定一个或多个要使用的DNS服务器。为了演示，以下示例创建了一个新的容器，并将该容器的DNS服务器设置为谷歌的公共DNS服务：
- en: '`docker run --rm \     --dns 8.8.8.8 \` `1` `alpine:3.8 \     nslookup docker.com`
    `2`'
  id: totrans-887
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --rm \ --dns 8.8.8.8 \` `1` `alpine:3.8 \ --dns 8.8.8.8 \` `2`'
- en: 1 Sets primary DNS server
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 设置主DNS服务器
- en: 2 Resolves IP address of [docker.com](http://docker.com)
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 解析[docker.com](http://docker.com)的IP地址
- en: 'Using a specific DNS server can provide consistency if you’re running Docker
    on a laptop and often move between internet service providers. It’s a critical
    tool for people building services and networks. There are a few important notes
    on setting your own DNS server:'
  id: totrans-890
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你在一个笔记本电脑上运行Docker并且经常在不同的互联网服务提供商之间移动，使用特定的DNS服务器可以提供一致性。这对于构建服务和网络的人来说是一个关键工具。在设置自己的DNS服务器时，有一些重要的注意事项：
- en: 'The value must be an IP address. If you think about it, the reason is obvious:
    the container needs a DNS server to perform the lookup on a name.'
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值必须是IP地址。如果你这么想，原因很明显：容器需要一个DNS服务器来执行名称查找。
- en: The  `--dns=[]`  flag can be set multiple times to set multiple DNS servers
    (in case one or more are unreachable).
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--dns=[]`标志可以设置多次以设置多个DNS服务器（以防一个或多个不可达）。'
- en: The  `--dns=[]`  flag can be set when you start up the Docker engine that runs
    in the background. When you do so, those DNS servers will be set on every container
    by default. But if you stop the engine with containers running and change the
    default when you restart the engine, the running containers will still have the
    old DNS settings. You’ll need to restart those containers for the change to take
    effect.
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在后台运行Docker引擎时，可以设置`--dns=[]`标志。当你这样做时，默认情况下，这些DNS服务器将设置在每个容器上。但是，如果你在容器运行时停止引擎，并在重启引擎时更改默认设置，运行中的容器仍然会保留旧的DNS设置。你需要重新启动这些容器才能使更改生效。
- en: 'The third DNS-related option, `--dns-search=[]`, allows you to specify a DNS
    search domain, which is like a default hostname suffix. With one set, any hostnames
    that don’t have a known top-level domain (for example, .com or .net) will be searched
    for with the specified suffix appended:'
  id: totrans-894
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第三个与DNS相关的选项`--dns-search=[]`允许你指定一个DNS搜索域，类似于默认的主机名后缀。设置后，任何没有已知顶级域名（例如，.com或.net）的主机名都将使用指定的后缀进行搜索：
- en: '`docker run --rm \     --dns-search docker.com \` `1` `alpine:3.8 \     nslookup
    hub` `2`'
  id: totrans-895
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --rm \ --dns-search docker.com \` `1` `alpine:3.8 \ --dns 8.8.8.8
    \` `2`'
- en: 1 Sets search domain
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 设置搜索域
- en: 2 Looks up shortcut for [hub.docker.com](http://hub.docker.com)
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 查找[hub.docker.com](http://hub.docker.com)的快捷方式
- en: 'This command will resolve to the IP address of hub.docker.com because the DNS
    search domain provided will complete the hostname. It works by manipulating /etc/resolv.conf,
    a file used to configure common name-resolution libraries. The following command
    shows how these DNS manipulation options impact the file:'
  id: totrans-898
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此命令将解析为hub.docker.com的IP地址，因为提供的DNS搜索域将完成主机名。它是通过操作/etc/resolv.conf文件来实现的，该文件用于配置常见的名称解析库。以下命令显示了这些DNS操作选项如何影响文件：
- en: '`docker run --rm \     --dns-search docker.com \` `1` `--dns 1.1.1.1 \` `2`
    `alpine:3.8 cat /etc/resolv.conf # Will display contents that look like: # search
    docker.com # nameserver 1.1.1.1`'
  id: totrans-899
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --rm \ --dns-search docker.com \` `1` `--dns 1.1.1.1 \` `2` `alpine:3.8
    cat /etc/resolv.conf # 将显示类似的内容：# search docker.com # nameserver 1.1.1.1`'
- en: 1 Sets search domain
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 设置搜索域
- en: 2 Sets primary DNS server
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 设置主DNS服务器
- en: This feature is most often used for trivialities such as shortcut names for
    internal corporate networks. For example, your company might maintain an internal
    documentation wiki that you can simply reference at [http://wiki/](http://wiki/).
    But this can be much more powerful.
  id: totrans-902
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此功能最常用于诸如内部企业网络的快捷名称等琐事。例如，你的公司可能维护一个内部文档维基，你可以简单地通过[http://wiki/](http://wiki/)来引用。但这可以更强大。
- en: 'Suppose you maintain a single DNS server for your development and test environments.
    Rather than building environment-aware software (with hardcoded environment-specific
    names such as myservice.dev.mycompany.com), you might consider using DNS search
    domains and using environment-unaware names (for example, `myservice`):'
  id: totrans-903
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你为你的开发和测试环境维护一个单独的 DNS 服务器。与其构建环境感知的软件（例如使用硬编码的环境特定名称，如 myservice.dev.mycompany.com），你可能会考虑使用
    DNS 搜索域并使用环境无关的名称（例如，`myservice`）：
- en: '`docker run --rm \     --dns-search dev.mycompany \` `1` `alpine:3.8 \    
    nslookup myservice` `2` `docker run --rm \     --dns-search test.mycompany \`
    `3` `alpine:3.8 \     nslookup myservice` `4`'
  id: totrans-904
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --rm \   --dns-search dev.mycompany \` `1` `alpine:3.8 \   nslookup
    myservice` `2` `docker run --rm \   --dns-search test.mycompany \` `3` `alpine:3.8
    \   nslookup myservice` `4`'
- en: 1 Note dev prefix.
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 注意开发前缀。
- en: 2 Resolves to myservice.dev.mycompany
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 解析为 myservice.dev.mycompany
- en: 3 Note test prefix.
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 注意测试前缀。
- en: 4 Resolves to myservice.test.mycompany
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 解析为 myservice.test.mycompany
- en: 'Using this pattern, the only change is the context in which the program is
    running. As with providing custom DNS servers, you can provide several custom
    search domains for the same container. Simply set the flag as many times as you
    have search domains. For example:'
  id: totrans-909
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用这种模式，唯一的变化是程序运行的上下文。与提供自定义 DNS 服务器一样，你可以为同一容器提供几个自定义搜索域。只需将标志设置为与搜索域数量相同即可。例如：
- en: '`docker run --rm \     --dns-search mycompany \     --dns-search myothercompany
    ...`'
  id: totrans-910
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --rm \   --dns-search mycompany \   --dns-search myothercompany
    ...`'
- en: This flag can also be set when you start up the Docker engine to provide defaults
    for every container created. Again, remember that these options are set for a
    container only when it is created. If you change the defaults when a container
    is running, that container will maintain the old values.
  id: totrans-911
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此标志也可以在启动 Docker 引擎时设置，为创建的每个容器提供默认值。再次提醒，这些选项仅在容器创建时为容器设置。如果你在容器运行时更改默认值，该容器将保持旧值。
- en: 'The last DNS feature to consider provides the ability to override the DNS system.
    This uses the same system that the `--hostname` flag uses. The `--add-host=[]`
    flag on the `docker run` command lets you provide a custom mapping for an IP address
    and hostname pair:'
  id: totrans-912
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后要考虑的 DNS 功能提供了覆盖 DNS 系统的能力。这使用与 `--hostname` 标志相同的系统。`docker run` 命令上的 `--add-host=[]`
    标志让你可以为 IP 地址和主机名对提供自定义映射：
- en: '`docker run --rm \     --add-host test:10.10.10.255 \` `1` `alpine:3.8 \    
    nslookup test` `2`'
  id: totrans-913
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --rm \   --add-host test:10.10.10.255 \` `1` `alpine:3.8 \   nslookup
    test` `2`'
- en: 1 Adds host entry
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 添加主机条目
- en: 2 Resolves to 10.10.10.255
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 解析为 10.10.10.255
- en: Like `--dns` and `--dns-search`, this option can be specified multiple times.
    But unlike those other options, this flag can’t be set as a default at engine
    startup.
  id: totrans-916
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与 `--dns` 和 `--dns-search` 一样，此选项可以指定多次。但与那些其他选项不同，此标志不能在引擎启动时设置为默认值。
- en: This feature is a sort of name-resolution scalpel. Providing specific name mappings
    for individual containers is the most fine-grained customization possible. You
    can use this to effectively block targeted hostnames by mapping them to a known
    IP address such as 127.0.0.1\. You could use it to route traffic for a particular
    destination through a proxy. This is often used to route unsecure traffic through
    secure channels such as an SSH tunnel. Adding these overrides is a trick that
    has been used for years by web developers who run their own local copies of a
    web application. If you spend some time thinking about the interface that name-to-IP
    address mappings provide, we’re sure you can come up with all sorts of uses.
  id: totrans-917
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个功能是一种名称解析手术刀。为单个容器提供特定的名称映射是可能的最细粒度定制。你可以通过将它们映射到已知的 IP 地址（如 127.0.0.1）来有效地阻止目标主机名。你可以用它来将特定目的地的流量通过代理路由。这通常用于将不安全的流量通过安全的通道（如
    SSH 隧道）路由。添加这些覆盖是多年来运行自己本地副本的网页开发者使用的一种技巧。如果你花点时间思考名称到 IP 地址映射提供的接口，我们相信你可以想出各种各样的用途。
- en: 'All the custom mappings live in a file at /etc/hosts inside your container.
    If you want to see what overrides are in place, all you have to do is inspect
    that file. Rules for editing and parsing this file can be found online and are
    a bit beyond the scope of this book:'
  id: totrans-918
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有自定义映射都存储在容器内 /etc/hosts 文件中。如果你想查看已设置的覆盖，只需检查该文件即可。编辑和解析此文件的规则可以在网上找到，但这超出了本书的范围：
- en: '`docker run --rm \     --hostname mycontainer \` `1` `--add-host docker.com:127.0.0.1
    \` `2` `--add-host test:10.10.10.2 \` `3` `alpine:3.8 \     cat /etc/hosts` `4`'
  id: totrans-919
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker run --rm \     --hostname mycontainer \` `1` `--add-host docker.com:127.0.0.1
    \` `2` `--add-host test:10.10.10.2 \` `3` `alpine:3.8 \     cat /etc/hosts` `4`'
- en: 1 Sets hostname
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 设置主机名
- en: 2 Creates host entry
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 创建主机条目
- en: 3 Creates another host entry
  id: totrans-922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 创建另一个主机条目
- en: 4 Views all entries
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 查看所有条目
- en: 'This should produce output that looks something like the following:'
  id: totrans-924
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这应该会产生类似以下内容的输出：
- en: '`172.17.0.45  mycontainer 127.0.0.1    localhost ::1          localhost ip6-localhost
    ip6-loopback fe00::0      ip6-localnet ff00::0      ip6-mcastprefix ff02::1     
    ip6-allnodes ff02::2      ip6-allrouters 10.10.10.2   test 127.0.0.1    docker.com`'
  id: totrans-925
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`172.17.0.45  mycontainer 127.0.0.1    localhost ::1          localhost ip6-localhost
    ip6-loopback fe00::0      ip6-localnet ff00::0      ip6-mcastprefix ff02::1     
    ip6-allnodes ff02::2      ip6-allrouters 10.10.10.2   test 127.0.0.1    docker.com`'
- en: DNS is a powerful system for changing behavior. The name-to-IP address map provides
    a simple interface that people and programs can use to decouple themselves from
    specific network addresses. If DNS is your best tool for changing outbound traffic
    behavior, then the firewall and network topology is your best tool for controlling
    inbound traffic.
  id: totrans-926
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: DNS 是一个强大的系统，可以改变行为。名称到 IP 地址的映射提供了一个简单的接口，人们和程序可以使用它来将自己与特定的网络地址解耦。如果 DNS 是您改变出站流量行为的最佳工具，那么防火墙和网络拓扑是您控制入站流量的最佳工具。
- en: 5.5.3\. Externalizing network management
  id: totrans-927
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5.5.3\. 外部化网络管理
- en: Finally, some organizations, infrastructures, or products require direct management
    of container network configuration, service discovery, and other network-related
    resources. In those cases, you or the container orchestrator you are using will
    create containers by using the Docker `none` network. Then use some other container-aware
    tooling to create and manage the container network interfaces, manage NodePort
    publishing, register containers with service-discovery systems, and integrate
    with upstream load-balancing systems.
  id: totrans-928
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，一些组织、基础设施或产品需要直接管理容器网络配置、服务发现和其他网络相关资源。在这些情况下，您或您使用的容器编排器将使用 Docker `none`
    网络创建容器。然后使用其他容器感知工具来创建和管理容器网络接口，管理 NodePort 发布，将容器注册到服务发现系统中，并与上游负载均衡系统集成。
- en: Kubernetes has a whole ecosystem of networking providers, and depending on how
    you are consuming Kubernetes (as the project, a productized distribution, or managed
    service), you may or may not have any say in which provider you use. Entire books
    could be written about networking options for Kubernetes. I won’t do them the
    disservice of attempting to summarize them here.
  id: totrans-929
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Kubernetes 拥有一个完整的网络提供商生态系统，根据您如何使用 Kubernetes（作为项目、产品化发行版或托管服务），您可能或可能没有对您使用的提供商有任何发言权。关于
    Kubernetes 的网络选项可以写整本书。我不会在这里尝试总结它们，以免对它们造成不公。
- en: Above the network provider layer, a whole continuum of service-discovery tools
    use various features of Linux and container technology. Service discovery is not
    a solved problem, so the solution landscape changes quickly. If you find Docker
    networking constructs insufficient to solve your integration and management problems,
    survey the field. Each tool has its own documentation and implementation patterns,
    and you will need to consult those guides to integrate them effectively with Docker.
  id: totrans-930
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在网络提供商层之上，一系列服务发现工具使用 Linux 和容器技术的各种功能。服务发现不是一个已解决的问题，因此解决方案领域变化很快。如果您发现 Docker
    网络结构不足以解决您的集成和管理问题，请调查该领域。每个工具都有自己的文档和实现模式，您需要查阅这些指南才能有效地将它们与 Docker 集成。
- en: When you externalize network management, Docker is still responsible for creating
    the network namespace for the container, but it will not create or manage any
    of the network interfaces. You will not be able to use any of the Docker tooling
    to inspect the network configuration or port mapping. If you are running a blended
    environment in which some container networking has been externalized, the built-in
    service discovery mechanisms cannot be used to route traffic from Docker-managed
    containers to externalized containers. Blended environments are rare and should
    be avoided.
  id: totrans-931
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您外部化网络管理时，Docker 仍然负责为容器创建网络命名空间，但它不会创建或管理任何网络接口。您将无法使用任何 Docker 工具来检查网络配置或端口映射。如果您在一个混合环境中运行，其中一些容器网络已被外部化，则内置的服务发现机制不能用于将
    Docker 管理的容器流量路由到外部化容器。混合环境很少见，应避免。
- en: SUMMARY
  id: totrans-932
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Networking is a broad subject that would take several books to cover properly.
    This chapter should help readers with a basic understanding of network fundamentals
    adopt the single-host networking facilities provided by Docker. In reading this
    material, you learned the following:'
  id: totrans-933
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 网络是一个广泛的主题，需要几本书才能全面覆盖。本章旨在帮助对网络基础知识有基本理解的读者采用Docker提供的单主机网络功能。在阅读本材料时，你学习了以下内容：
- en: Docker networks are first-class entities that can be created, listed, and removed
    just like containers, volumes, and images.
  id: totrans-934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网络是一等实体，可以像容器、卷和镜像一样创建、列出和删除。
- en: Bridge networks are a special kind of network that allows direct intercontainer
    network communication with built-in container name resolution.
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接网络是一种特殊类型的网络，它允许通过内置的容器名称解析直接进行容器间的网络通信。
- en: 'Docker provides two other special networks by default: `host` and `none`.'
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker默认提供另外两个特殊网络：`host`和`none`。
- en: Networks created with the `none` driver will isolate attached containers from
    the network.
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`none`驱动程序创建的网络将隔离附加的容器与网络。
- en: A container on a host network will have full access to the network facilities
    and interfaces on the host.
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主机网络上的容器将完全访问主机上的网络设施和接口。
- en: Forward network traffic to a host port into a target container and port with
    NodePort publishing.
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将网络流量转发到主机端口，进入目标容器的端口，并使用NodePort发布。
- en: Docker bridge networks do not provide any network firewall or access-control
    functionality.
  id: totrans-940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker桥接网络不提供任何网络防火墙或访问控制功能。
- en: The network name-resolution stack can be customized for each container. Custom
    DNS servers, search domains, and static hosts can be defined.
  id: totrans-941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络名称解析堆栈可以针对每个容器进行自定义。可以定义自定义DNS服务器、搜索域和静态主机。
- en: Network management can be externalized with third-party tooling and by using
    the Docker `none` network.
  id: totrans-942
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过第三方工具和使用Docker的`none`网络将网络管理外部化。
- en: Chapter 6\. Limiting risk with resource controls
  id: totrans-943
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第6章. 使用资源控制限制风险
- en: This chapter covers
  id: totrans-944
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖以下内容：
- en: Setting resource limits
  id: totrans-945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置资源限制
- en: Sharing container memory
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享容器内存
- en: Setting users, permissions, and administrative privileges
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置用户、权限和管理权限
- en: Granting access to specific Linux features
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授予访问特定Linux功能
- en: Working with SELinux and AppArmor
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与SELinux和AppArmor协同工作
- en: Containers provide isolated process contexts, not whole system virtualization.
    The semantic difference may seem subtle, but the impact is drastic. [Chapter 1](index_split_015.html#filepos91074)
    touched on the differences a bit. [Chapters 2](index_split_024.html#filepos153412)
    through [5](index_split_046.html#filepos458921) each covered a different isolation
    feature set of Docker containers. This chapter covers the remaining four and includes
    information about enhancing security on your system.
  id: totrans-950
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 容器提供隔离的进程上下文，而不是整个系统虚拟化。语义上的差异可能看起来很微妙，但影响是巨大的。[第1章](index_split_015.html#filepos91074)简要提到了这些差异。[第2章](index_split_024.html#filepos153412)到[第5章](index_split_046.html#filepos458921)分别涵盖了Docker容器不同的隔离功能集。本章涵盖了剩余的四个，并包括有关增强系统安全性的信息。
- en: The features covered in this chapter focus on managing or limiting the risks
    of running software. These features prevent software from misbehaving because
    of a bug or attack from consuming resources that might leave your computer unresponsive.
    Containers can help ensure that software only uses the computing resources and
    accesses the data you expect. You will learn how to give containers resource allowances,
    access shared memory, run programs as specific users, control the type of changes
    that a container can make to your computer, and integrate with other Linux isolation
    tools. Some of these topics involve Linux features that are beyond the scope of
    this book. In those cases, we try to give you an idea about their purpose and
    basic usage examples, and how you can integrate them with Docker. [Figure 6.1](#filepos547831)
    shows the eight namespaces and features that are used to build Docker containers.
  id: totrans-951
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章介绍的功能主要集中在管理或限制运行软件的风险。这些功能可以防止软件因错误或攻击而表现不佳，因为它们可能会消耗可能导致你的计算机无响应的资源。容器可以帮助确保软件只使用你期望的计算资源并访问数据。你将学习如何为容器分配资源限制、访问共享内存、以特定用户身份运行程序、控制容器可以对你的计算机做出的更改类型，以及与其他Linux隔离工具集成。其中一些主题涉及本书范围之外的Linux功能。在这些情况下，我们试图给你一个关于它们目的和基本使用示例的想法，以及如何将它们与Docker集成。[图6.1](#filepos547831)显示了用于构建Docker容器的八个命名空间和功能。
- en: Figure 6.1\. Eight-sided containers
  id: totrans-952
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图6.1. 八边形容器
- en: '![](images/00030.jpg)'
  id: totrans-953
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00030.jpg)'
- en: 'One last reminder: Docker and the technology it uses are evolving projects.
    The examples in this chapter should work for Docker 1.13 and later. Once you learn
    the tools presented in this chapter, remember to check for developments, enhancements,
    and new best practices when you go to build something valuable.'
  id: totrans-954
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后提醒一次：Docker 及其使用的技术是不断发展的项目。本章中的示例适用于 Docker 1.13 及以后的版本。一旦你学会了本章中介绍的工具，记得在构建有价值的东西时检查发展、增强和新最佳实践。
- en: 6.1\. SETTING RESOURCE ALLOWANCES
  id: totrans-955
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.1. 设置资源限制
- en: Physical system resources such as memory and time on the CPU are scarce. If
    the resource consumption of processes on a computer exceeds the available physical
    resources, the processes will experience performance issues and may stop running.
    Part of building a system that creates strong isolation includes providing resource
    allowances on individual containers.
  id: totrans-956
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 物理系统资源，如内存和 CPU 上的时间，是稀缺的。如果计算机上进程的资源消耗超过了可用的物理资源，进程将遇到性能问题，并且可能停止运行。构建一个强大隔离的系统的一部分包括为单个容器提供资源限制。
- en: If you want to make sure that a program won’t overwhelm other programs on your
    computer, the easiest thing to do is set limits on the resources that it can use.
    You can manage memory, CPU, and device resource allowances with Docker. By default,
    Docker containers may use unlimited CPU, memory, and device I/O resources. The
    `docker container create` and `run` commands provide flags for managing resources
    available to the container.
  id: totrans-957
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想要确保一个程序不会耗尽你电脑上的其他程序，最简单的事情就是设置它可以使用的资源限制。你可以使用 Docker 管理内存、CPU 和设备资源限制。默认情况下，Docker
    容器可能使用无限 CPU、内存和设备 I/O 资源。`docker container create` 和 `run` 命令提供了管理容器可用资源的标志。
- en: 6.1.1\. Memory limits
  id: totrans-958
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.1.1. 内存限制
- en: 'Memory limits are the most basic restriction you can place on a container.
    They restrict the amount of memory that processes inside a container can use.
    Memory limits are useful for ensuring that one container can’t allocate all of
    the system’s memory, starving other programs for the memory they need. You can
    put a limit in place by using the `-m` or `--memory` flag on the `docker container
    run` or `docker container create` commands. The flag takes a value and a unit.
    The format is as follows:'
  id: totrans-959
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 内存限制是对容器可以使用的内存的最基本限制。它们限制了容器内进程可以使用的内存量。内存限制对于确保一个容器不能分配所有系统内存，从而让其他程序因缺少内存而无法运行非常有用。你可以通过在
    `docker container run` 或 `docker container create` 命令中使用 `-m` 或 `--memory` 标志来设置限制。该标志接受一个值和一个单位。格式如下：
- en: '`<number><optional unit> where unit = b, k, m or g`'
  id: totrans-960
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`<数字><可选单位> 其中单位 = b, k, m 或 g`'
- en: 'In the context of these commands, `b` refers to bytes, `k` to kilobytes, `m`
    to megabytes, and `g` to gigabytes. Put this new knowledge to use and start up
    a database application that you’ll use in other examples:'
  id: totrans-961
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这些命令的上下文中，`b` 代表字节，`k` 代表千字节，`m` 代表兆字节，而 `g` 代表吉字节。将这项新知识应用于实践，启动一个你将在其他示例中使用的数据库应用程序：
- en: '`docker container run -d --name ch6_mariadb \     --memory 256m \` `1` `--cpu-shares
    1024 \     --cap-drop net_raw \     -e MYSQL_ROOT_PASSWORD=test \     mariadb:5.5`'
  id: totrans-962
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run -d --name ch6_mariadb \   --memory 256m \` `1` `--cpu-shares
    1024 \   --cap-drop net_raw \   -e MYSQL_ROOT_PASSWORD=test \   mariadb:5.5`'
- en: 1 Sets a memory constraint
  id: totrans-963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 设置内存限制
- en: With this command, you install database software called MariaDB and start a
    container with a memory limit of 256 megabytes. You might have noticed a few extra
    flags on this command. This chapter covers each of those, but you may already
    be able to guess what they do. Something else to note is that you don’t expose
    any ports or bind any ports to the host’s interfaces. It will be easiest to connect
    to this database by linking to it from another container on the host. Before we
    get to that, we want to make sure you have a full understanding of what happens
    here and how to use memory limits.
  id: totrans-964
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用此命令，你将安装名为 MariaDB 的数据库软件，并启动一个内存限制为 256 兆字节的容器。你可能已经注意到了这个命令上的一些额外标志。本章将涵盖这些标志中的每一个，但你可能已经能够猜出它们的作用。还有一点需要注意，你不会暴露任何端口或将端口绑定到主机的接口。通过从主机上的另一个容器链接到这个数据库，将是最容易连接到这个数据库的方式。在我们到达那里之前，我们想确保你对这里发生的事情以及如何使用内存限制有一个全面的理解。
- en: The most important thing to understand about memory limits is that they’re not
    reservations. They don’t guarantee that the specified amount of memory will be
    available. They’re only a protection from overconsumption. Additionally, the implementation
    of the memory accounting and limit enforcement by the Linux kernel is very efficient,
    so you don’t need to worry about runtime overhead for this feature.
  id: totrans-965
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于内存限制，最重要的理解是它们并不是预留。它们不能保证指定数量的内存将可用。它们只是防止过度消耗的一种保护措施。此外，Linux内核对内存会计和限制执行的实现非常高效，因此你不需要担心这个特性的运行时开销。
- en: Before you put a memory allowance in place, you should consider two things.
    First, can the software you’re running operate under the proposed memory allowance?
    Second, can the system you’re running on support the allowance?
  id: totrans-966
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在实施内存配额之前，你应该考虑两件事。首先，你运行的软件是否可以在提议的内存配额下运行？其次，你运行的系统是否可以支持这个配额？
- en: 'The first question is often difficult to answer. It’s not common to see minimum
    requirements published with open source software these days. Even if it were,
    though, you’d have to understand how the memory requirements of the software scale
    based on the size of the data you’re asking it to handle. For better or worse,
    people tend to overestimate and adjust based on trial and error. One option is
    to run the software in a container with real workloads and use the `docker stats`
    command to see how much memory the container uses in practice. For the `mariadb`
    container we just started, `docker stats ch6_mariadb` shows that the container
    is using about 100 megabytes of memory, fitting well inside its 256-megabyte limit.
    In the case of memory-sensitive tools like databases, skilled professionals such
    as database administrators can make better-educated estimates and recommendations.
    Even then, the question is often answered by another: how much memory do you have?
    And that leads to the second question.'
  id: totrans-967
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第一个问题通常很难回答。如今，很少看到开源软件会公布最低要求。即使公布了，你也必须理解软件的内存需求是如何根据你要处理的数据大小进行缩放的。无论是好是坏，人们往往会高估并根据试错进行调整。一个选择是在具有实际工作负载的容器中运行软件，并使用`docker
    stats`命令查看容器在实际中使用了多少内存。对于刚刚启动的`mariadb`容器，`docker stats ch6_mariadb`显示容器使用了大约100兆字节的内存，很好地适应了其256兆字节的限制。在内存敏感的工具，如数据库的情况下，数据库管理员等熟练的专业人士可以做出更明智的估计和建议。即便如此，问题通常由另一个问题回答：你有多少内存？这引出了第二个问题。
- en: Can the system you’re running on support the allowance? It’s possible to set
    a memory allowance that’s bigger than the amount of available memory on the system.
    On hosts that have swap space (virtual memory that extends onto disk), a container
    may realize the allowance. It is possible to specify an allowance that’s greater
    than any physical memory resource. In those cases, the limitations of the system
    will always cap the container, and runtime behavior will be similar to not having
    specified an allowance at all.
  id: totrans-968
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你运行的系统是否可以支持这个配额？可以设置一个比系统上可用内存更大的内存配额。在具有交换空间（扩展到磁盘的虚拟内存）的主机上，容器可以实现这个配额。可以指定一个比任何物理内存资源更大的配额。在这些情况下，系统的限制将始终限制容器，运行时行为将与没有指定配额时相似。
- en: Finally, understand that there are several ways that software can fail if it
    exhausts the available memory. Some programs may fail with a memory access fault,
    whereas others may start writing out-of-memory errors to their logging. Docker
    neither detects this problem nor attempts to mitigate the issue. The best it can
    do is apply the restart logic you may have specified using the `--restart` flag
    described in [chapter 2](index_split_024.html#filepos153412).
  id: totrans-969
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，了解如果软件耗尽可用内存，软件可能会以几种方式失败。一些程序可能会因为内存访问错误而失败，而其他程序可能会开始将内存不足错误写入它们的日志。Docker既检测不到这个问题，也不会尝试减轻这个问题。它能做的最好的事情是应用你可能通过`--restart`标志指定的重启逻辑，该标志在[第2章](index_split_024.html#filepos153412)中描述。
- en: 6.1.2\. CPU
  id: totrans-970
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.1.2\. CPU
- en: Processing time is just as scarce as memory, but the effect of starvation is
    performance degradation instead of failure. A paused process that is waiting for
    time on the CPU is still working correctly. But a slow process may be worse than
    a failing one if it’s running an important latency-sensitive data-processing program,
    a revenue-generating web application, or a backend service for your app. Docker
    lets you limit a container’s CPU resources in two ways.
  id: totrans-971
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 处理时间与内存一样稀缺，但饥饿效应是性能下降而不是失败。等待 CPU 时间的暂停进程仍在正确工作。但如果它运行的是一个重要的延迟敏感型数据处理程序、一个盈利的
    Web 应用程序或您的应用程序的后端服务，则慢速进程可能比失败的进程更糟糕。Docker 允许您以两种方式限制容器的 CPU 资源。
- en: First, you can specify the relative weight of a container to other containers.
    Linux uses this to determine the percentage of CPU time the container should use
    relative to other running containers. That percentage is for the sum of the computing
    cycles of all processors available to the container.
  id: totrans-972
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先，您可以指定容器相对于其他容器的相对权重。Linux 使用此来决定容器相对于其他运行容器应使用的 CPU 时间百分比。这个百分比是针对容器可用的所有处理器的计算周期总和。
- en: 'To set the CPU shares of a container and establish its relative weight, both
    `docker container run` and `docker container create` offer a `--cpu-shares` flag.
    The value provided should be an integer (which means you shouldn’t quote it).
    Start another container to see how CPU shares work:'
  id: totrans-973
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要设置容器的 CPU 分享并建立其相对权重，`docker container run` 和 `docker container create` 都提供了
    `--cpu-shares` 标志。提供的值应该是一个整数（这意味着您不应该引用它）。启动另一个容器以查看 CPU 分享如何工作：
- en: '`docker container run -d -P --name ch6_wordpress \ --memory 512m \ --cpu-shares
    512 \` `1` `--cap-drop net_raw \ --link ch6_mariadb:mysql \ -e WORDPRESS_DB_PASSWORD=test
    \ wordpress:5.0.0-php7.2-apache`'
  id: totrans-974
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run -d -P --name ch6_wordpress \ --memory 512m \ --cpu-shares
    512 \` `1` `--cap-drop net_raw \ --link ch6_mariadb:mysql \ -e WORDPRESS_DB_PASSWORD=test
    \ wordpress:5.0.0-php7.2-apache`'
- en: 1 Sets a relative process weight
  id: totrans-975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 设置相对进程权重
- en: This command will download and start WordPress version 5.0\. It’s written in
    PHP and is a great example of software that has been challenged by adapting to
    security risks. Here we’ve started it with a few extra precautions. If you’d like
    to see it running on your computer, use `docker port ch6_wordpress` to get the
    port number (we’ll call it `<port>`) that the service is running on and open http://localhost:<port>
    in your web browser. If you’re using Docker Machine, you’ll need to use `docker-machine
    ip` to determine the IP address of the virtual machine where Docker is running.
    When you have that, substitute that value for localhost in the preceding URL.
  id: totrans-976
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此命令将下载并启动 WordPress 版本 5.0。它用 PHP 编写，是软件适应安全风险挑战的一个很好的例子。在这里，我们启动它时采取了一些额外的预防措施。如果您想在您的计算机上看到它运行，请使用
    `docker port ch6_wordpress` 获取服务正在运行的端口号（我们将称之为 `<端口号>`），然后在您的网页浏览器中打开 http://localhost:<端口号>。如果您使用
    Docker Machine，您需要使用 `docker-machine ip` 来确定 Docker 运行的虚拟机的 IP 地址。当您有了这个信息后，将此值替换为先前
    URL 中的 localhost。
- en: When you started the MariaDB container, you set its relative weight (`cpu-shares`)
    to `1024`, and you set the relative weight of WordPress to 512\. These settings
    create a system in which the MariaDB container gets two CPU cycles for every one
    WordPress cycle. If you started a third container and set its `--cpu-shares` value
    to `2048`, it would get half of the CPU cycles, and MariaDB and WordPress would
    split the other half at the same proportions as they were before. [Figure 6.2](#filepos562595)
    shows how portions change based on the total weight of the system.
  id: totrans-977
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您启动 MariaDB 容器时，您将其相对权重（`cpu-shares`）设置为 `1024`，并将 WordPress 的相对权重设置为 512。这些设置创建了一个系统，其中
    MariaDB 容器每获得一个 WordPress 循环就获得两个 CPU 循环。如果您启动了第三个容器并将其 `--cpu-shares` 值设置为 `2048`，则它将获得一半的
    CPU 循环，MariaDB 和 WordPress 将以前相同的比例分割另一半。[图 6.2](#filepos562595) 展示了根据系统总权重如何改变部分。
- en: Figure 6.2\. Relative weight and CPU shares
  id: totrans-978
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 6.2\. 相对权重和 CPU 分享
- en: '![](images/00050.jpg)'
  id: totrans-979
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](images/00050.jpg)'
- en: CPU shares differ from memory limits in that they’re enforced only when there
    is contention for time on the CPU. If other processes and containers are idle,
    the container may burst well beyond its limits. This approach ensures that CPU
    time is not wasted and that limited processes will yield if another process needs
    the CPU. The intent of this tool is to prevent one or a set of processes from
    overwhelming a computer, not to hinder performance of those processes. The defaults
    won’t limit the container, and it will be able to use 100% of the CPU if the machine
    is otherwise idle.
  id: totrans-980
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: CPU份额与内存限制不同，因为它们只在CPU时间竞争时强制执行。如果其他进程和容器处于空闲状态，容器可能会超出其限制。这种方法确保CPU时间不会被浪费，并且当其他进程需要CPU时，有限的进程会释放。此工具的目的是防止一个或一组进程压倒计算机，而不是阻碍这些进程的性能。默认设置不会限制容器，如果机器其他时间空闲，它将能够使用100%的CPU。
- en: 'Now that you have learned how `cpu-shares` allocates CPU proportionately, we
    will introduce the `cpus` option, which provides a way to limit the total amount
    of CPU used by a container. The `cpus` option allocates a quota of CPU resources
    the container may use by configuring the Linux Completely Fair Scheduler (CFS).
    Docker helpfully allows the quota to be expressed as the number of CPU cores the
    container should be able to use. The CPU quota is allocated, enforced, and ultimately
    refreshed every 100ms by default. If a container uses all of its CPU quota, its
    CPU usage will be throttled until the next measurement period begins. The following
    command will let the previous WordPress example consume a maximum of 0.75 CPU
    cores:'
  id: totrans-981
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在您已经了解了`cpu-shares`如何按比例分配CPU，我们将介绍`cpus`选项，它提供了一种限制容器使用的总CPU数量的方法。`cpus`选项通过配置Linux完全公平调度器（CFS）为容器分配CPU资源配额。Docker允许将配额表示为容器应该能够使用的CPU核心数。默认情况下，CPU配额每100毫秒分配、强制执行和刷新一次。如果一个容器使用了所有的CPU配额，其CPU使用率将被限制，直到下一个测量周期开始。以下命令将允许之前的WordPress示例消耗最多0.75个CPU核心：
- en: '`docker container run -d -P --name ch6_wordpress \ --memory 512m \ --cpus 0.75
    \` `1` `--cap-drop net_raw \ --link ch6_mariadb:mysql \ -e WORDPRESS_DB_PASSWORD=test
    \ wordpress:5.0.0-php7.2-apache`'
  id: totrans-982
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run -d -P --name ch6_wordpress \ --memory 512m \ --cpus 0.75
    \` `1` `--cap-drop net_raw \ --link ch6_mariadb:mysql \ -e WORDPRESS_DB_PASSWORD=test
    \ wordpress:5.0.0-php7.2-apache`'
- en: 1 Uses a maximum of 0.75 cpus
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 使用最多0.75个CPU
- en: Another feature Docker exposes is the ability to assign a container to a specific
    CPU set. Most modern hardware uses multicore CPUs. Roughly speaking, a CPU can
    process as many instructions in parallel as it has cores. This is especially useful
    when you’re running many processes on the same computer.
  id: totrans-984
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker还暴露了将容器分配到特定CPU集的能力。大多数现代硬件都使用多核CPU。粗略地说，CPU可以并行处理与核心数量相等的指令。这在您在同一台计算机上运行多个进程时特别有用。
- en: A context switch is the task of changing from executing one process to executing
    another. Context switching is expensive and may cause a noticeable impact on the
    performance of your system. In some cases, it makes sense to reduce context switching
    of critical processes by ensuring they are never executed on the same set of CPU
    cores. You can use the `--cpuset-cpus` flag on `docker container run` or `docker
    container create` to limit a container to execute only on a specific set of CPU
    cores.
  id: totrans-985
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 上下文切换是将执行一个进程的任务切换到执行另一个进程。上下文切换代价高昂，可能会对系统的性能产生明显的影响。在某些情况下，通过确保关键进程永远不会在相同的CPU核心集上执行，可以减少关键进程的上下文切换。您可以使用`docker
    container run`或`docker container create`命令中的`--cpuset-cpus`标志来限制容器只执行在特定的CPU核心集上。
- en: 'You can see the CPU set restrictions in action by stressing one of your machine
    cores and examining your CPU workload:'
  id: totrans-986
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以通过对机器的一个核心进行压力测试并检查CPU工作负载来看到CPU集限制的实际效果：
- en: '`# Start a container limited to a single CPU and run a load generator docker
    container run -d \     --cpuset-cpus 0 \` `1` `--name ch6_stresser dockerinaction/ch6_stresser  #
    Start a container to watch the load on the CPU under load docker container run
    -it --rm dockerinaction/ch6_htop`'
  id: totrans-987
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`# 启动一个仅限于单个CPU的容器并运行负载生成器 docker container run -d \ --cpuset-cpus 0 \` `1`
    `--name ch6_stresser  # 启动一个容器来监控负载下的CPU docker container run -it --rm dockerinaction/ch6_htop`'
- en: 1 Restricts to CPU number 0
  id: totrans-988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 限制为CPU编号0
- en: 'Once you run the second command, you’ll see `htop` display the running processes
    and the workload of the available CPUs. The `ch6_stresser` container will stop
    running after 30 seconds, so it’s important not to delay when you run this experiment.
    When you finish with `htop`, press Q to quit. Before moving on, remember to shut
    down and remove the container named `ch6_stresser`:'
  id: totrans-989
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你运行第二个命令时，你会看到`htop`显示正在运行的过程和可用CPU的工作负载。`ch6_stresser`容器将在30秒后停止运行，因此当你运行这个实验时不要延迟。使用完`htop`后，按Q键退出。在继续之前，请记住关闭并删除名为`ch6_stresser`的容器：
- en: '`docker rm -vf ch6_stresser`'
  id: totrans-990
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker rm -vf ch6_stresser`'
- en: 'We thought this was exciting when we first used it. To get the best appreciation,
    repeat this experiment a few times by using different values for the `--cpuset-cpus`
    flag. If you do, you’ll see the process assigned to different cores or different
    sets of cores. The value can be either a list or range:'
  id: totrans-991
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们第一次使用它时觉得这很令人兴奋。为了获得最佳体验，请通过使用不同的`--cpuset-cpus`标志值重复此实验几次。如果你这样做，你会看到分配给不同核心或不同核心集的过程。值可以是列表或范围：
- en: '`0,1,2`—  A list including the first three cores of the CPU'
  id: totrans-992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0,1,2`—  包含CPU的前三个核心的列表'
- en: '`0-2`—  A range including the first three cores of the CPU'
  id: totrans-993
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0-2`—  包含CPU前三个核心的范围'
- en: 6.1.3\. Access to devices
  id: totrans-994
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.1.3. 设备访问
- en: Devices are the final resource type we will cover. Controlling access to devices
    differs from memory and CPU limits. Providing access to a host’s device inside
    a container is more like a resource-authorization control than a limit.
  id: totrans-995
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 设备是我们将要讨论的最后一类资源。控制对设备的访问与内存和CPU限制不同。在容器内提供对主机设备的访问更像是资源授权控制，而不是限制。
- en: Linux systems have all sorts of devices, including hard drives, optical drives,
    USB drives, mouse, keyboard, sound devices, and webcams. Containers have access
    to some of the host’s devices by default, and Docker creates other devices specifically
    for each container. This works similarly to how a virtual terminal provides dedicated
    input and output devices to the user.
  id: totrans-996
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Linux系统拥有各种设备，包括硬盘、光驱、USB驱动器、鼠标、键盘、音频设备和网络摄像头。容器默认可以访问主机的一些设备，而Docker为每个容器创建其他特定设备。这类似于虚拟终端为用户提供专用输入和输出设备的方式。
- en: 'On occasion, it may be important to share other devices between a host and
    a specific container. Say you’re running computer vision software that requires
    access to a webcam, for example. In that case, you’ll need to grant access to
    the container running your software to the webcam device attached to the system;
    you can use the `--device` flag to specify a set of devices to mount into the
    new container. The following example would map your webcam at /dev/video0 to the
    same location within a new container. Running this example will work only if you
    have a webcam at /dev/video0:'
  id: totrans-997
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时，在主机和特定容器之间共享其他设备可能很重要。比如说，你正在运行需要访问网络摄像头的计算机视觉软件。在这种情况下，你需要授予运行你的软件的容器对系统上连接的网络摄像头设备的访问权限；你可以使用`--device`标志来指定要挂载到新容器中的一组设备。以下示例将你的网络摄像头在`/dev/video0`映射到新容器内的相同位置。运行此示例仅在你有一个在`/dev/video0`的网络摄像头时有效：
- en: '`docker container run -it --rm \     --device /dev/video0:/dev/video0 \` `1`
    `ubuntu:16.04 ls -al /dev`'
  id: totrans-998
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run -it --rm --device /dev/video0:/dev/video0 \` `1` `ubuntu:16.04
    ls -al /dev`'
- en: 1 Mounts video0
  id: totrans-999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 挂载video0
- en: The value provided must be a map between the device file on the host operating
    system and the location inside the new container. The device flag can be set many
    times to grant access to different devices.
  id: totrans-1000
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 提供的值必须是在主机操作系统上的设备文件与容器内部位置之间的映射。设备标志可以设置多次，以授予对不同设备的访问权限。
- en: People in situations with custom hardware or proprietary drivers will find this
    kind of access to devices useful. It’s preferable to resorting to modifying their
    host operating system.
  id: totrans-1001
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在具有定制硬件或专有驱动程序的情况下，人们会发现这种设备访问方式很有用。与修改主机操作系统相比，这是一种更可取的方法。
- en: 6.2\. SHARING MEMORY
  id: totrans-1002
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.2. 共享内存
- en: Linux provides a few tools for sharing memory between processes running on the
    same computer. This form of interprocess communication (IPC) performs at memory
    speeds. It’s often used when the latency associated with network or pipe-based
    IPC drags software performance down below requirements. The best examples of shared
    memory-based IPC use are in scientific computing and some popular database technologies
    such as PostgreSQL.
  id: totrans-1003
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Linux 为同一计算机上运行的进程之间共享内存提供了一些工具。这种基于共享内存的进程间通信（IPC）以内存速度运行。当网络或基于管道的 IPC 的延迟导致软件性能低于要求时，通常会使用这种形式的
    IPC。基于共享内存的 IPC 使用的最佳例子是在科学计算和一些流行的数据库技术，如 PostgreSQL。
- en: Docker creates a unique IPC namespace for each container by default. The Linux
    IPC namespace partitions share memory primitives such as named shared memory blocks
    and semaphores, as well as message queues. It’s OK if you’re not sure what these
    are. Just know that they’re tools used by Linux programs to coordinate processing.
    The IPC namespace prevents processes in one container from accessing the memory
    on the host or in other containers.
  id: totrans-1004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker 默认为每个容器创建一个唯一的 IPC 命名空间。Linux IPC 命名空间分区共享内存原语，如命名共享内存块和信号量，以及消息队列。如果你不确定这些是什么，只需知道它们是
    Linux 程序用来协调处理的一些工具。IPC 命名空间防止一个容器中的进程访问主机或其他容器上的内存。
- en: 6.2.1\. Sharing IPC primitives between containers
  id: totrans-1005
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.2.1\. 在容器之间共享 IPC 原语
- en: 'We’ve created an image named `dockerinactionch6_ipc` that contains both a producer
    and consumer. They communicate using shared memory. The following will help you
    understand the problem with running these in separate containers:'
  id: totrans-1006
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `dockerinactionch6_ipc` 的镜像，其中包含生产者和消费者。它们使用共享内存进行通信。以下内容将帮助你理解在单独的容器中运行这些程序的问题：
- en: '`docker container run -d -u nobody --name ch6_ipc_producer \` `1` `--ipc shareable
    \     dockerinaction/ch6_ipc -producer  docker container run -d -u nobody --name
    ch6_ipc_consumer \` `2` `dockerinaction/ch6_ipc -consumer`'
  id: totrans-1007
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run -d -u nobody --name ch6_ipc_producer \` `1` `--ipc shareable
    \ dockerinaction/ch6_ipc -producer` `docker container run -d -u nobody --name
    ch6_ipc_consumer \` `2` `dockerinaction/ch6_ipc -consumer`'
- en: 1 Starts producer
  id: totrans-1008
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 启动生产者
- en: 2 Starts consumer
  id: totrans-1009
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 启动消费者
- en: 'These commands start two containers. The first creates a message queue and
    begins broadcasting messages on it. The second should pull from the message queue
    and write the messages to the logs. You can see what each is doing by using the
    following commands to inspect the logs of each:'
  id: totrans-1010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些命令启动了两个容器。第一个创建了一个消息队列，并开始在它上面广播消息。第二个应该从消息队列中提取消息并将其写入日志。你可以通过以下命令检查每个容器的日志来了解它们各自在做什么：
- en: '`docker logs ch6_ipc_producer  docker logs ch6_ipc_consumer`'
  id: totrans-1011
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker logs ch6_ipc_producer` `docker logs ch6_ipc_consumer`'
- en: Notice that something is wrong with the containers you started. The consumer
    never sees any messages on the queue. Each process uses the same key to identify
    the shared memory resource, but they refer to different memory. The reason is
    that each container has its own shared memory namespace.
  id: totrans-1012
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意到你所启动的容器中存在问题。消费者从未在队列中看到任何消息。每个进程使用相同的密钥来识别共享内存资源，但它们引用的是不同的内存。原因是每个容器都有自己的共享内存命名空间。
- en: If you need to run programs that communicate with shared memory in different
    containers, then you’ll need to join their IPC namespaces with the `--ipc` flag.
    The `--ipc` flag has a container mode that will create a new container in the
    same IPC namespace as another target container. This works like the `--network`
    flag covered in [chapter 5](index_split_046.html#filepos458921). [Figure 6.3](#filepos578895)
    illustrates the relationship between containers and their namespaced shared memory
    pools.
  id: totrans-1013
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你需要运行与不同容器中共享内存通信的程序，那么你需要使用 `--ipc` 标志将它们的 IPC 命名空间联合起来。`--ipc` 标志有一个容器模式，它将在与另一个目标容器相同的
    IPC 命名空间中创建一个新的容器。这就像第 5 章中提到的 `--network` 标志一样。[图 6.3](#filepos578895) 展示了容器及其命名空间共享内存池之间的关系。
- en: Figure 6.3\. Three containers and their shared memory pools; `producer` and
    `consumer` share a single pool.
  id: totrans-1014
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图 6.3\. 三个容器及其共享内存池；`producer` 和 `consumer` 共享单个池。
- en: '![](images/00051.jpg)'
  id: totrans-1015
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00051.jpg)'
- en: 'Use the following commands to test joined IPC namespaces for yourself:'
  id: totrans-1016
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用以下命令自行测试联合 IPC 命名空间：
- en: '`docker container rm -v ch6_ipc_consumer` `1` `docker container run -d --name
    ch6_ipc_consumer \` `2` `--ipc container:ch6_ipc_producer \` `3` `dockerinaction/ch6_ipc
    -consumer`'
  id: totrans-1017
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container rm -v ch6_ipc_consumer` `1` `docker container run -d --name
    ch6_ipc_consumer \` `2` `--ipc container:ch6_ipc_producer \` `3` `dockerinaction/ch6_ipc
    -consumer`'
- en: 1 Removes original consumer
  id: totrans-1018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 移除原始消费者
- en: 2 Starts new consumer
  id: totrans-1019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 启动新消费者
- en: 3 Joins IPC namespace
  id: totrans-1020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 联合 IPC 命名空间
- en: 'These commands rebuild the consumer container and reuse the IPC namespace of
    the `ch6_ipc_producer` container. This time, the consumer should be able to access
    the same memory location where the server is writing. You can see this working
    by using the following commands to inspect the logs of each:'
  id: totrans-1021
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些命令重新构建了消费者容器，并重用了 `ch6_ipc_producer` 容器的 IPC 命名空间。这次，消费者应该能够访问服务器正在写入的相同内存位置。您可以通过以下命令检查每个容器的日志来查看此功能是否正常工作：
- en: '`docker logs ch6_ipc_producer  docker logs ch6_ipc_consumer`'
  id: totrans-1022
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker logs ch6_ipc_producer  docker logs ch6_ipc_consumer`'
- en: 'Remember to clean up your running containers before moving on:'
  id: totrans-1023
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在继续之前，请记得清理您的运行中的容器：
- en: '`docker rm -vf ch6_ipc_producer ch6_ipc_consumer`'
  id: totrans-1024
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker rm -vf ch6_ipc_producer ch6_ipc_consumer`'
- en: The `v` option will clean up volumes.
  id: totrans-1025
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `v` 选项将清理卷。
- en: The `f` option will kill the container if it is running.
  id: totrans-1026
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `f` 选项如果容器正在运行，则会将其终止。
- en: The `rm` command takes a list of containers.
  id: totrans-1027
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm` 命令接受容器列表。'
- en: Reusing the shared memory namespaces of containers has obvious security implications.
    But this option is available if you need it. Sharing memory between containers
    is a safer alternative than sharing memory with the host. Sharing memory with
    the host is possible using the `--ipc=host` option. However, sharing host memory
    is difficult in modern Docker distributions because it contradicts Docker’s secure-by-default
    posture for containers.
  id: totrans-1028
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重复使用容器共享内存命名空间具有明显的安全影响。但如果需要，此选项是可用的。在容器之间共享内存比与主机共享内存更安全。可以使用 `--ipc=host`
    选项与主机共享内存。然而，在现代 Docker 发行版中，共享主机内存是困难的，因为这违反了 Docker 对容器默认安全策略。
- en: Feel free to check out the source code for this example. It’s an ugly but simple
    C program. You can find it by checking out the source repository linked from the
    image’s page on Docker Hub.
  id: totrans-1029
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 随意查看此示例的源代码。这是一个丑陋但简单的 C 程序。您可以通过查看 Docker Hub 上镜像页面的源代码仓库来找到它。
- en: 6.3\. UNDERSTANDING USERS
  id: totrans-1030
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.3. 理解用户
- en: Docker starts containers as the user that is specified by the image metadata
    by default, which is often the root user. The root user has almost full privileged
    access to the state of the container. Any processes running as that user inherit
    those permissions. It follows that if there’s a bug in one of those processes,
    it might damage the container. There are ways to limit the damage, but the most
    effective way to prevent these types of issues is not to use the root user.
  id: totrans-1031
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker 默认以由镜像元数据指定的用户启动容器，通常是 root 用户。root 用户几乎可以完全访问容器的状态。以该用户身份运行的任何进程都会继承这些权限。因此，如果这些进程中的一个存在错误，可能会损坏容器。有方法可以限制损害，但最有效的防止此类问题的方式是不使用
    root 用户。
- en: Reasonable exceptions exist; sometimes using the root user is the best or only
    available option. You use the root user for building images, and at runtime when
    there’s no other option. Similarly, at times you might want to run system administration
    software inside a container. In those cases, the process needs privileged access
    not only to the container but also to the host operating system. This section
    covers the range of solutions to these problems.
  id: totrans-1032
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 存在合理的例外；有时使用 root 用户可能是最佳或唯一的选择。您使用 root 用户来构建镜像，在运行时没有其他选择时。类似地，有时您可能想在容器内运行系统管理软件。在这些情况下，进程需要不仅对容器而且对主机操作系统的特权访问。本节涵盖了这些问题的各种解决方案。
- en: 6.3.1\. Working with the run-as user
  id: totrans-1033
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.3.1. 使用 run-as 用户工作
- en: 'Before you create a container, it would be nice to be able to know what username
    (and user ID) is going to be used by default. The default is specified by the
    image. There’s currently no way to examine an image to discover attributes such
    as the default user in Docker Hub. You can inspect image metadata by using the
    `docker inspect` command. If you missed it in [chapter 2](index_split_024.html#filepos153412),
    the `inspect` subcommand displays the metadata of a specific container or image.
    Once you’ve pulled or created an image, you can get the default username that
    the container is using with the following commands:'
  id: totrans-1034
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在创建容器之前，能够知道默认将使用哪个用户名（以及用户 ID）将很好。默认值由镜像指定。目前还没有方法可以检查镜像以发现诸如 Docker Hub 中的默认用户之类的属性。您可以使用
    `docker inspect` 命令检查镜像元数据。如果您在[第 2 章](index_split_024.html#filepos153412)中错过了它，`inspect`
    子命令显示特定容器或镜像的元数据。一旦您已拉取或创建了一个镜像，您可以使用以下命令获取容器正在使用的默认用户名：
- en: '`docker image pull busybox:1.29 docker image inspect busybox:1.29` `1` `docker
    inspect` `--``format "{{.Config.User}}" busybox:1.29` `2`'
  id: totrans-1035
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker image pull busybox:1.29 docker image inspect busybox:1.29` `1` `docker
    inspect` `--``format "{{.Config.User}}" busybox:1.29` `2`'
- en: 1 Displays all of busybox’s metadata
  id: totrans-1036
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 显示了busybox的所有元数据
- en: 2 Shows only the run-as user defined by the busybox image
  id: totrans-1037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 仅显示由busybox镜像定义的运行用户
- en: If the result is blank, the container will default to running as the root user.
    If it isn’t blank, either the image author specifically named a default run-as
    user or you set a specific run-as user when you created the container. The `--format`
    or `-f` option used in the second command allows you to specify a template to
    render the output. In this case, you’ve selected the `User` field of the `Config`
    property of the document. The value can be any valid Golang template, so if you’re
    feeling up to it, you can get creative with the results.
  id: totrans-1038
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果结果是空的，容器将默认以root用户运行。如果结果不为空，则可能是镜像作者特别指定了默认运行用户，或者你在创建容器时设置了特定的运行用户。第二个命令中使用的`--format`或`-f`选项允许你指定一个模板来渲染输出。在这种情况下，你选择了文档的`Config`属性的`User`字段。值可以是任何有效的Golang模板，所以如果你愿意，你可以用结果来发挥创意。
- en: This approach has a problem. The run-as user might be changed by the entrypoint
    or command the image uses to start up. These are sometimes referred to as boot,
    or init, scripts. The metadata returned by `docker inspect` includes only the
    configuration that the container will start with. So if the user changes, it won’t
    be reflected there.
  id: totrans-1039
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种方法有一个问题。运行用户可能会被镜像使用的入口点或命令更改。这些有时被称为引导或init脚本。`docker inspect`返回的元数据仅包括容器启动时的配置。因此，如果用户更改，它将不会反映在那里。
- en: 'Currently, the only way to fix this problem is to look inside the image. You
    could expand the image files after you download them, and examine the metadata
    and init scripts by hand, but doing so is time-consuming and easy to get wrong.
    For the time being, it may be better to run a simple experiment to determine the
    default user. This will solve the first problem but not the second:'
  id: totrans-1040
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 目前，修复这个问题的唯一方法就是查看镜像内部。你可以在下载镜像文件后扩展它们，并手动检查元数据和init脚本，但这样做既耗时又容易出错。目前，进行一个简单的实验来确定默认用户可能更好。这将解决第一个问题，但不会解决第二个：
- en: '`docker container run --rm --entrypoint "" busybox:1.29 whoami` `1` `docker
    container run --rm --entrypoint "" busybox:1.29 id` `2`'
  id: totrans-1041
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm --entrypoint "" busybox:1.29 whoami` `1` `docker
    container run --rm --entrypoint "" busybox:1.29 id` `2`'
- en: '1 Outputs: root'
  id: totrans-1042
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 输出：root
- en: '2 Outputs: uid=0(root) gid=0(root) groups=10(wheel)'
  id: totrans-1043
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 输出：uid=0(root) gid=0(root) groups=10(wheel)
- en: This demonstrates two commands that you might use to determine the default user
    of an image (in this case, `busybox:1.29`). Both the `whoami` and `id` commands
    are common among Linux distributions, and so they’re likely to be available in
    any given image. The second command is superior because it shows both the name
    and ID details for the run-as user. Both these commands are careful to unset the
    entrypoint of the container. This will make sure that the command specified after
    the image name is the command that is executed by the container. These are poor
    substitutes for a first-class image metadata tool, but they get the job done.
    Consider the brief exchange between two root users in [figure 6.4](#filepos592501).
  id: totrans-1044
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这展示了两个你可能使用的命令来确定镜像的默认用户（在本例中为`busybox:1.29`）。`whoami`和`id`命令在Linux发行版中很常见，因此它们很可能在任何给定的镜像中都可用。第二个命令更优越，因为它显示了运行用户的名字和ID详情。这两个命令都小心地取消了容器的入口点。这将确保在镜像名称之后指定的命令是容器执行的命令。这些虽然不能替代一流的形象元数据工具，但它们能完成任务。考虑两个root用户之间的简短交流，见[图6.4](#filepos592501)。
- en: Figure 6.4\. Root versus root—a security drama
  id: totrans-1045
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图6.4\. 根用户对根用户——一场安全剧
- en: '![](images/00011.jpg)'
  id: totrans-1046
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](images/00011.jpg)'
- en: 'You can entirely avoid the default user problem if you change the run-as user
    when you create the container. The quirk with using this is that the username
    must exist on the image you’re using. Different Linux distributions ship with
    different users predefined, and some image authors reduce or augment that set.
    You can get a list of available users in an image with the following command:'
  id: totrans-1047
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你创建容器时更改运行用户，你可以完全避免默认用户问题。使用这个方法的怪癖是，用户名必须存在于你使用的镜像上。不同的Linux发行版带有预定义的不同用户，有些镜像作者会减少或增加这个集合。你可以使用以下命令来获取镜像中可用的用户列表：
- en: '`docker container run --rm busybox:1.29 awk -F: ''$0=$1'' /etc/passwd`'
  id: totrans-1048
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm busybox:1.29 awk -F: ''$0=$1'' /etc/passwd`'
- en: 'We won’t go into much detail here, but the Linux user database is stored in
    a file located at /etc/passwd. This command will read that file from the container
    filesystem and pull the list of usernames. Once you’ve identified the user you
    want to use, you can create a new container with a specific run-as user. Docker
    provides the `--user` or `-u` flag on `docker container run` and `docker container
    create` for setting the user. This will set the user to `nobody`:'
  id: totrans-1049
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这里我们不会深入细节，但 Linux 用户数据库存储在位于 /etc/passwd 的文件中。此命令将从容器文件系统中读取该文件并提取用户名列表。一旦你确定了想要使用的用户，你可以创建一个新的容器并指定运行用户。Docker
    在 `docker container run` 和 `docker container create` 命令中提供了 `--user` 或 `-u` 标志来设置用户。这将用户设置为
    `nobody`：
- en: '`docker container run --rm \     --user nobody \` `1` `busybox:1.29 id` `2`'
  id: totrans-1050
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm \    --user nobody ` `1` `busybox:1.29 id` `2`'
- en: 1 Sets run-as user to nobody
  id: totrans-1051
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 设置运行用户为 nobody
- en: '2 Outputs: uid=65534(nobody) gid=65534(nogroup)'
  id: totrans-1052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 输出：uid=65534(nobody) gid=65534(nogroup)
- en: 'This command used the `nobody` user. That user is common and intended for use
    in restricted-privileges scenarios such as running applications. That is just
    one example. You can use any username defined by the image here, including root.
    This only scratches the surface of what you can do with the `-u` or `--user` flag.
    The value can accept any user or group pair. When you specify a user by name,
    that name is resolved to the user ID (UID) specified in the container’s `passwd`
    file. Then the command is run with that UID. This leads to another feature. The
    `--user` flag also accepts user and group names or IDs. When you use IDs instead
    of names, the options start to open up:'
  id: totrans-1053
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此命令使用了 `nobody` 用户。该用户是常见的，并旨在用于受限权限场景，例如运行应用程序。这只是其中一个例子。你可以使用在此图像中定义的任何用户名，包括
    root。这仅仅触及了 `-u` 或 `--user` 标志所能做到的一小部分。该值可以接受任何用户或组对。当你通过名称指定用户时，该名称将被解析为容器 `passwd`
    文件中指定的用户 ID (UID)。然后命令将使用该 UID 运行。这导致另一个特性。`--user` 标志也接受用户和组名称或 ID。当你使用 ID 而不是名称时，选项开始增多：
- en: '`docker container run --rm \     -u nobody:nogroup \` `1` `busybox:1.29 id`
    `2` `docker container run --rm \     -u 10000:20000 \` `3` `busybox:1.29 id` `4`'
  id: totrans-1054
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm \    -u nobody:nogroup ` `1` `busybox:1.29 id` `2`
    `docker container run --rm \    -u 10000:20000 ` `3` `busybox:1.29 id` `4`'
- en: 1 Sets run-as user to nobody and group to nogroup
  id: totrans-1055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 设置运行用户为 nobody 和组为 nogroup
- en: '2 Outputs: uid=65534(nobody) gid=65534(nogroup)'
  id: totrans-1056
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 输出：uid=65534(nobody) gid=65534(nogroup)
- en: 3 Sets UID and GID
  id: totrans-1057
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 设置 UID 和 GID
- en: '4 Outputs: uid=10000 gid=20000'
  id: totrans-1058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 输出：uid=10000 gid=20000
- en: The second command starts a new container that sets the run-as user and group
    to a user and group that do not exist in the container. When that happens, the
    IDs won’t resolve to a user or group name, but all file permissions will work
    as if the user and group did exist. Depending on how the software packaged in
    the container is configured, changing the run-as user may cause problems. Otherwise,
    this is a powerful feature that can simplify running applications with limited
    privileges and solving file-permission problems.
  id: totrans-1059
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第二个命令启动了一个新的容器，将运行用户和组设置为容器中不存在的用户和组。当这种情况发生时，ID 不会解析为用户或组名称，但所有文件权限都将像用户和组确实存在一样工作。根据容器中打包的软件的配置方式，更改运行用户可能会引起问题。否则，这是一个强大的功能，可以简化以有限权限运行应用程序并解决文件权限问题。
- en: The best way to be confident in your runtime configuration is to pull images
    from trusted sources or build your own. As with any standard Linux distribution,
    it’s possible to do malicious things such as turning a default nonroot user into
    the root user by using an `suid`-enabled program or opening up access to the root
    account without authentication. The threat of the `suid` example can be mitigated
    by using the custom container security options described in [section 6.6](index_split_059.html#filepos641771),
    specifically the `--security-opt no-new-privileges` option. However, that’s late
    in the delivery process to address that problem. Like a full Linux host, images
    should be analyzed and secured using the principle of least privilege. Fortunately,
    Docker images can be purpose-built to support the application that needs to be
    run with everything else left out. [Chapters 7](index_split_063.html#filepos667222),
    [8](index_split_069.html#filepos755104), and [10](index_split_084.html#filepos1058777)
    cover how to create minimal application images.
  id: totrans-1060
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在你的运行时配置中建立信心最好的方式是从受信任的来源拉取镜像或者构建你自己的镜像。与任何标准的Linux发行版一样，有可能进行恶意操作，例如通过使用启用了`suid`的程序将默认的非root用户转变为root用户，或者在不进行身份验证的情况下开放对root账户的访问。通过使用在第6.6节中描述的自定义容器安全选项可以减轻`suid`示例中的威胁，特别是`--security-opt
    no-new-privileges`选项。然而，这已经是交付过程中的后期来解决这个问题。就像完整的Linux主机一样，镜像应该使用最小权限原则进行分析和加固。幸运的是，Docker镜像可以被专门构建来支持需要运行的应用程序，同时将其他所有内容排除在外。[第7章](index_split_063.html#filepos667222)、[第8章](index_split_069.html#filepos755104)和[第10章](index_split_084.html#filepos1058777)介绍了如何创建最小化应用程序镜像。
- en: 6.3.2\. Users and volumes
  id: totrans-1061
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.3.2. 用户和卷
- en: 'Now that you’ve learned how users inside containers share the same user ID
    space as the users on your host system, you need to learn how those two might
    interact. The main reason for that interaction is the file permissions on files
    in volumes. For example, if you’re running a Linux terminal, you should be able
    to use these commands directly; otherwise, you’ll need to use the `docker-machine
    ssh` command to get a shell in your Docker Machine virtual machine:'
  id: totrans-1062
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在你已经了解了容器内的用户与主机系统上的用户共享相同的用户ID空间，你需要了解这两者之间可能如何交互。这种交互的主要原因是在卷中的文件权限。例如，如果你正在运行Linux终端，你应该能够直接使用这些命令；否则，你需要使用`docker-machine
    ssh`命令在你的Docker Machine虚拟机中获取shell：
- en: '`echo "e=mc^2" > garbage` `1` `chmod 600 garbage` `2` `sudo chown root garbage`
    `3` `docker container run --rm -v "$(pwd)"/garbage:/test/garbage \     -u nobody
    \     ubuntu:16.04 cat /test/garbage` `4` `docker container run --rm -v "$(pwd)"/garbage:/test/garbage
    \     -u root ubuntu:16.04 cat /test/garbage` `5` `# Outputs: "e=mc^2"  # cleanup
    that garbage sudo rm -f garbage`'
  id: totrans-1063
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`echo "e=mc^2" > garbage` `1` `chmod 600 garbage` `2` `sudo chown root garbage`
    `3` `docker container run --rm -v "$(pwd)"/garbage:/test/garbage \    -u nobody
    \    ubuntu:16.04 cat /test/garbage` `4` `docker container run --rm -v "$(pwd)"/garbage:/test/garbage
    \    -u root ubuntu:16.04 cat /test/garbage` `5` `# 输出: "e=mc^2"  # 清理垃圾 sudo
    rm -f garbage`'
- en: 1 Creates new file on your host
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 在你的主机上创建新文件
- en: 2 Makes file readable only by its owner
  id: totrans-1065
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 使文件只对文件所有者可读
- en: 3 Makes file owned by root (assuming you have sudo access)
  id: totrans-1066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 使文件属于root（假设你有sudo访问权限）
- en: 4 Tries to read file as nobody
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 尝试以nobody读取文件
- en: 5 Tries to read file as “container root”
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 尝试以“容器root”读取文件
- en: The second-to-last `docker` command should fail with an error message like `Permission
    denied`. But the last `docker` command should succeed and show you the contents
    of the file you created in the first command. This means that file permissions
    on files in volumes are respected inside the container. But this also reflects
    that the user ID space is shared. Both root on the host and root in the container
    have user ID 0\. So, although the container’s `nobody` user with ID 65534 can’t
    access a file owned by root on the host, the container’s root user can.
  id: totrans-1069
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第二个最后的`docker`命令应该失败并显示类似`Permission denied`的错误消息。但是最后一个`docker`命令应该成功并显示你第一个命令中创建的文件的内容。这意味着在卷中的文件权限在容器内部是被尊重的。但这同时也反映出用户ID空间是共享的。主机上的root和容器中的root都有用户ID
    0。因此，尽管容器中的`nobody`用户（ID为65534）无法访问主机上root拥有的文件，但容器中的root用户可以。
- en: Unless you want a file to be accessible to a container, don’t mount it into
    that container with a volume.
  id: totrans-1070
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你不希望文件对容器可访问，不要将该文件通过卷挂载到该容器中。
- en: The good news about this example is that you’ve seen how file permissions are
    respected and can solve some more mundane—but practical—operational issues. For
    example, how do you handle a log file written to a volume?
  id: totrans-1071
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于这个例子的好消息是，你已经看到了文件权限是如何被尊重的，并且可以解决一些更平凡但实用的操作问题。例如，你如何处理写入卷的日志文件？
- en: The preferred way is with volumes, as described in [chapter 4](index_split_037.html#filepos379268).
    But even then you need to consider file ownership and permission issues. If logs
    are written to a volume by a process running as user 1001, and another container
    tries to access that file as user 1002, then file permissions might prevent the
    operation.
  id: totrans-1072
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最理想的方式是使用卷，如第4章所述。但即使如此，你也需要考虑文件所有权和权限问题。如果日志文件是由以用户1001身份运行的进程写入卷的，而另一个容器试图以用户1002的身份访问该文件，那么文件权限可能会阻止操作。
- en: 'One way to overcome this obstacle would be to specifically manage the user
    ID of the running user. You can either edit the image ahead of time by setting
    the user ID of the user you’re going to run the container with, or you can use
    the desired user and group ID (GID):'
  id: totrans-1073
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 克服这个障碍的一种方法就是专门管理运行用户的用户ID。你可以通过在运行容器之前编辑镜像来设置你将要运行的用户的用户ID，或者你可以使用所需的用户和组ID（GID）：
- en: '`mkdir logFiles  sudo chown 2000:2000 logFiles` `1` `docker container run --rm
    -v "$(pwd)"/logFiles:/logFiles \` `2` `-u 2000:2000 ubuntu:16.04 \` `3` `/bin/bash
    -c "echo This is important info > /logFiles/important.log"  docker container run
    --rm -v "$(pwd)"/logFiles:/logFiles \` `4` `-u 2000:2000 ubuntu:16.04 \` `5` `/bin/bash
    -c "echo More info >> /logFiles/important.log"  sudo rm –r logFiles`'
  id: totrans-1074
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`mkdir logFiles  sudo chown 2000:2000 logFiles` `1` `docker container run --rm
    -v "$(pwd)"/logFiles:/logFiles \` `2` `-u 2000:2000 ubuntu:16.04 \` `3` `/bin/bash
    -c "echo This is important info > /logFiles/important.log"  docker container run
    --rm -v "$(pwd)"/logFiles:/logFiles \` `4` `-u 2000:2000 ubuntu:16.04 \` `5` `/bin/bash
    -c "echo More info >> /logFiles/important.log"  sudo rm –r logFiles`'
- en: 1 Sets ownership of directory to desired user and group
  id: totrans-1075
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将目录的所有权设置为所需的用户和组
- en: 2 Writes important log file
  id: totrans-1076
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 写入重要日志文件
- en: 3 Sets UID:GID to 2000:2000
  id: totrans-1077
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 将UID:GID设置为2000:2000
- en: 4 Appends to log from another container
  id: totrans-1078
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 从另一个容器追加日志
- en: 5 Also sets UID:GID to 2000:2000
  id: totrans-1079
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 还将UID:GID设置为2000:2000
- en: After running this example, you’ll see that the file could be written to the
    directory that’s owned by user 2000\. Not only that, but any container that uses
    a user or group with write access to the directory could write a file in that
    directory or to the same file if the permissions allow. This trick works for reading,
    writing, and executing files.
  id: totrans-1080
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运行这个例子后，你会看到文件可以写入由用户2000拥有的目录。不仅如此，任何使用具有对该目录写入访问权限的用户或组的容器都可以在该目录中写入文件，或者如果权限允许，可以写入相同的文件。这个技巧适用于读取、写入和执行文件。
- en: One UID and filesystem interaction bears special mention. By default, the Docker
    daemon API is accessible via a UNIX domain socket located on the host at /var/run/
    docker.sock. The domain socket is protected with filesystem permissions ensuring
    that only the root user and members of the `docker` group may send commands or
    retrieve data from the Docker daemon. Some programs are built to interact directly
    with the Docker daemon API and know how to send commands to inspect or run containers.
  id: totrans-1081
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有一个UID和文件系统交互需要特别提及。默认情况下，Docker守护进程API可以通过位于主机上的/ var/run/docker.sock的UNIX域套接字访问。域套接字通过文件系统权限受到保护，确保只有root用户和`docker`组的成员可以发送命令或从Docker守护进程检索数据。
- en: '|    |'
  id: totrans-1082
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The power of the Docker API
  id: totrans-1083
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker API的力量
- en: The `docker` command-line program interacts with the Docker daemon almost entirely
    via the API, which should give you a sense of how powerful the API is. Any program
    that can read and write to the Docker API can do anything `docker` can do, subject
    to Docker’s Authorization plugin system.
  id: totrans-1084
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker` 命令行程序几乎完全通过API与Docker守护进程交互，这应该让你感受到API的强大。任何可以读取和写入Docker API的程序都可以做`docker`能做的任何事情，前提是受Docker授权插件系统的限制。'
- en: '|    |'
  id: totrans-1085
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Programs that manage or monitor containers often require the ability to read
    or even write to the Docker daemon’s endpoint. The ability to read or write to
    Docker’s API is often provided by running the management program as a user or
    group that has permission to read or write to `docker.sock` and mounting `/var/run/docker.sock`
    into the container:'
  id: totrans-1086
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 管理或监控容器的程序通常需要能够读取甚至写入Docker守护进程的端点。读取或写入Docker API的能力通常是通过以具有读取或写入`docker.sock`权限的用户或组运行管理程序，并将`/var/run/docker.sock`挂载到容器中来提供的：
- en: '`docker container run --rm -it   –v /var/run/docker.sock:/var/run/docker.sock:ro
    \` `1` `-u root  monitoringtool` `2`'
  id: totrans-1087
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm -it –v /var/run/docker.sock:/var/run/docker.sock:ro
    ` `1` `-u root  monitoringtool` `2`'
- en: 1 Binds docker.sock from host into container as a read-only file
  id: totrans-1088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 将主机上的docker.sock绑定到容器中作为只读文件
- en: 2 Container runs as root user, aligning with file permissions on host
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 容器以root用户运行，与宿主机的文件权限相匹配
- en: The preceding example illustrates a relatively common request by authors of
    privileged programs. You should be careful about which users or programs on your
    systems can control your Docker daemon. If a user or program controls your Docker
    daemon, it effectively controls the root account on your host and can run any
    program or delete any file.
  id: totrans-1090
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 上述示例说明了特权程序作者相对常见的请求。你应该小心对待系统中哪些用户或程序可以控制你的Docker守护进程。如果用户或程序控制了你的Docker守护进程，那么它实际上控制了宿主机的root账户，可以运行任何程序或删除任何文件。
- en: 6.3.3\. Introduction to the Linux user namespace and UID remapping
  id: totrans-1091
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.3.3. Linux用户命名空间和UID重映射简介
- en: Linux’s user (USR) namespace maps users in one namespace to users in another.
    The user namespace operates like the process identifier (PID) namespace with container
    UIDs and GIDs partitioned from the host’s default identities.
  id: totrans-1092
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Linux的USR用户命名空间将一个命名空间中的用户映射到另一个命名空间中的用户。用户命名空间的操作类似于进程标识符（PID）命名空间，容器UID和GID与主机的默认标识分离。
- en: By default, Docker containers do not use the USR namespace. This means that
    a container running with a user ID (number, not name) that’s the same as a user
    on the host machine has the same host file permissions as that user. This isn’t
    a problem. The filesystem available inside a container has been mounted so that
    changes made inside that container will stay inside that container’s filesystem.
    But this does impact volumes in which files are shared between containers or with
    the host.
  id: totrans-1093
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 默认情况下，Docker容器不使用USR命名空间。这意味着运行与主机机器上用户ID（数字，而非名称）相同的用户ID的容器具有与该用户相同的宿主文件权限。这并不是一个问题。容器内可用的文件系统已经被挂载，以便在容器内所做的更改将保留在容器文件系统中。但这确实会影响在容器之间或与主机共享文件的卷。
- en: When a user namespace is enabled for a container, the container’s UIDs are mapped
    to a range of unprivileged UIDs on the host. Operators activate user namespace
    remapping by defining `subuid` and `subgid` maps for the host in Linux and configuring
    the Docker daemon’s `userns-remap` option. The mappings determine how user IDs
    on the host correspond to user IDs in a container namespace. For example, UID
    remapping could be configured to map container UIDs to the host starting with
    host UID 5000 and a range of 1000 UIDs. The result is that UID 0 in containers
    would be mapped to host UID 5000, container UID 1 to host UID 5001, and so on
    for 1000 UIDs. Since UID 5000 is an unprivileged user from Linux’ perspective
    and doesn’t have permissions to modify the host system files, the risk of running
    with `uid=0` in the container is greatly reduced. Even if a containerized process
    gets ahold of a file or other resource from the host, the containerized process
    will be running as a remapped UID without privileges to do anything with that
    resource unless an operator specifically gave it permissions to do so.
  id: totrans-1094
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当为容器启用用户命名空间时，容器的UID会被映射到主机上的一组非特权UID。操作员通过在Linux中为主机定义`subuid`和`subgid`映射以及配置Docker守护进程的`userns-remap`选项来激活用户命名空间重映射。映射确定主机上的用户ID如何对应于容器命名空间中的用户ID。例如，UID重映射可以配置为将容器UID映射到从主机UID
    5000开始的1000个UID范围内。结果是，容器中的UID 0会被映射到主机UID 5000，容器UID 1映射到主机UID 5001，以此类推，直到1000个UID。由于从Linux的角度来看，UID
    5000是一个非特权用户，没有权限修改宿主系统文件，因此在容器中以`uid=0`运行的风险大大降低。即使容器化的进程从主机获取了文件或其他资源，该进程也将以重映射的UID运行，没有权限对该资源进行任何操作，除非操作员明确授予它这样做。
- en: 'User namespace remapping is particularly useful for resolving file permission
    issues in cases like reading and writing to volumes. Let’s step through an example
    of sharing a filesystem between containers whose process runs as UID 0 in the
    container with user namespacing enabled. In our example, we will assume Docker
    is using the following:'
  id: totrans-1095
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用户命名空间重映射对于解决诸如在卷中读写等情况下文件权限问题特别有用。让我们通过一个示例来了解在用户命名空间启用的情况下，容器之间共享文件系统的情况。在我们的示例中，我们将假设Docker使用以下内容：
- en: The (default) `dockremap` user for remapping container UID and GID ranges
  id: totrans-1096
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （默认的）`dockremap`用户用于重映射容器UID和GID范围
- en: An entry in /etc/subuid of `dockremap:5000:10000`, providing a range of 10,000
    UIDs starting at 5000
  id: totrans-1097
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/subuid`中的`dockremap:5000:10000`条目，提供从5000开始的10,000个UID范围'
- en: An entry in /etc/subgid of `dockremap:5000:10000`, providing a range of 10,000
    GIDs starting at 5000
  id: totrans-1098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/subgid`中的`dockremap:5000:10000`条目，提供从5000开始的10,000个GID范围'
- en: First, let’s check the user and group ID of the `dockeremap` user on the host.
    Then, we will create a shared directory owned by the remapped container UID 0,
    host UID 5000\.
  id: totrans-1099
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先，让我们检查主机上`dockeremap`用户的用户ID和组ID。然后，我们将创建一个由重映射容器UID 0、主机UID 5000拥有的共享目录。
- en: '`# id dockremap` `1` `uid=997(dockremap) gid=993(dockremap) groups=993(dockremap)
    # cat /etc/subuid dockremap:5000:10000 # cat /etc/subgid dockremap:5000:10000
    # mkdir /tmp/shared # chown -R 5000:5000 /tmp/shared` `2`'
  id: totrans-1100
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`# id dockremap` `1` `uid=997(dockremap) gid=993(dockremap) groups=993(dockremap)`
    `# cat /etc/subuid dockremap:5000:10000` `# cat /etc/subgid dockremap:5000:10000`
    `# mkdir /tmp/shared` `# chown -R 5000:5000 /tmp/shared` `2`'
- en: 1 Inspects user and group ID of dockremap user on host
  id: totrans-1101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 检查主机上dockremap用户的用户ID和组ID
- en: 2 Changes ownership of “shared” directory to UID used for remapped container
    UID 0
  id: totrans-1102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 将“shared”目录的所有权更改为用于重映射容器UID 0的UID
- en: 'Now run a container as the container’s root user:'
  id: totrans-1103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在以容器的root用户运行容器：
- en: '`# docker run -it --rm --user root -v /tmp/shared:/shared -v /:/host alpine
    ash / # touch /host/afile` `1` `touch: /host/afile: Permission denied / # echo
    "hello from $(id) in $(hostname)" >> /shared/afile / # exit # back in the host
    shell # ls -la /tmp/shared/afile -rw-r--r--. 1 5000 5000 157 Apr 16 00:13 /tmp/shared/afile  #
    cat /tmp/shared/afile` `2` `hello from uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),`
    `3` `3(sys),4(adm),6(disk),10(wheel),11(floppy),20(dialout),26(tape),` `3` `27(video)
    in d3b497ac0d34` `3`'
  id: totrans-1104
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`# docker run -it --rm --user root -v /tmp/shared:/shared -v /:/host alpine
    ash / # touch /host/afile` `1` `touch: /host/afile: Permission denied / # echo
    "hello from $(id) in $(hostname)" >> /shared/afile / # exit # 回到主机shell # ls -la
    /tmp/shared/afile -rw-r--r--. 1 5000 5000 157 Apr 16 00:13 /tmp/shared/afile  #
    cat /tmp/shared/afile` `2` `hello from uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),`
    `3` `3(sys),4(adm),6(disk),10(wheel),11(floppy),20(dialout),26(tape),` `3` `27(video)
    in d3b497ac0d34` `3`'
- en: '1 The /host mount is owned by host’s UID and GID: 0:0, so write disallowed'
  id: totrans-1105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 主机挂载点由主机的UID和GID拥有：0:0，因此不允许写入
- en: '2 /tmp/shared is owned by host’s nonprivileged UID and GID: 5000:5000, so write
    allowed'
  id: totrans-1106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 `/tmp/shared`由主机的非特权UID和GID拥有：5000:5000，因此允许写入
- en: 3 UID for root in container was 0
  id: totrans-1107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 容器中root的UID为0
- en: This example demonstrates the implications on filesystem access when using user
    namespaces with containers. User namespaces can be useful in tightening security
    of applications that run or share data between containers as a privileged user.
    User namespace remapping can be disabled on a per container basis when creating
    or running the container, making it easier to make it the default execution mode.
    Note that user namespaces are incompatible with some optional features such as
    SELinux or using a privileged container. Consult the Security documentation on
    the Docker website for further details in designing and implementing a Docker
    configuration leveraging user namespace remapping that supports your use cases.
  id: totrans-1108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此示例演示了在使用用户命名空间时对文件系统访问的影响。用户命名空间对于以特权用户运行或在不同容器之间共享数据的应用程序加强安全性非常有用。可以在创建或运行容器时根据容器禁用用户命名空间重映射，使其更容易成为默认执行模式。请注意，用户命名空间与某些可选功能（如SELinux或使用特权容器）不兼容。有关设计和实现利用用户命名空间重映射的Docker配置的详细信息，请参阅Docker网站上的安全文档。
- en: 6.4\. ADJUSTING OS FEATURE ACCESS WITH CAPABILITIES
  id: totrans-1109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.4. 使用能力调整操作系统功能访问
- en: Docker can adjust a container’s authorization to use individual operating system
    features. In Linux, these feature authorizations are called capabilities, but
    as native support expands to other operating systems, other backend implementations
    would need to be provided. Whenever a process attempts to make a gated system
    call such as opening a network socket, the capabilities of that process are checked
    for the required capability. The call will succeed if the process has the required
    capability, and fail otherwise.
  id: totrans-1110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker可以调整容器的授权以使用单个操作系统功能。在Linux中，这些功能授权被称为能力，但随着原生支持扩展到其他操作系统，将需要提供其他后端实现。每当进程尝试执行受限制的系统调用（如打开网络套接字）时，都会检查该进程的能力以确定所需的能力。如果进程具有所需的能力，则调用将成功，否则将失败。
- en: 'When you create a new container, Docker drops all capabilities except for an
    explicit list of capabilities that are necessary and safe to run most applications.
    This further isolates the running process from the administrative functions of
    the operating system. A sample of the 37 dropped capabilities follows, and you
    might be able to guess at the reasons for their removal:'
  id: totrans-1111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你创建一个新的容器时，Docker会移除除了运行大多数应用程序所必需和安全的显式能力列表之外的所有能力。这进一步隔离了运行进程与操作系统的管理功能。以下是一个移除的37个能力的示例，你可能能够猜测到它们被移除的原因：
- en: SYS_MODULE—  Insert/remove kernel modules
  id: totrans-1112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYS_MODULE—  插入/移除内核模块
- en: SYS_RAWIO—  Modify kernel memory
  id: totrans-1113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYS_RAWIO—  修改内核内存
- en: SYS_NICE—  Modify priority of processes
  id: totrans-1114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYS_NICE—  修改进程的优先级
- en: SYS_RESOURCE—  Override resource limits
  id: totrans-1115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYS_RESOURCE—  覆盖资源限制
- en: SYS_TIME—  Modify the system clock
  id: totrans-1116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYS_TIME—  修改系统时钟
- en: AUDIT_CONTROL—  Configure audit subsystem
  id: totrans-1117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AUDIT_CONTROL—  配置审计子系统
- en: MAC_ADMIN—  Configure MAC configuration
  id: totrans-1118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MAC_ADMIN—  配置MAC配置
- en: SYSLOG—  Modify kernel print behavior
  id: totrans-1119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYSLOG—  修改内核打印行为
- en: NET_ADMIN—  Configure the network
  id: totrans-1120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NET_ADMIN—  配置网络
- en: SYS_ADMIN—  Catchall for administrative functions
  id: totrans-1121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SYS_ADMIN—  管理功能的总称
- en: 'The default set of capabilities provided to Docker containers provides a reasonable
    feature reduction, but at times you’ll need to add or reduce this set further.
    For example, the capability NET_RAW can be dangerous. If you wanted to be a bit
    more careful than the default configuration, you could drop NET_RAW from the list
    of capabilities. You can drop capabilities from a container by using the `--cap-drop`
    flag on `docker container create` or `docker container run`. First, print the
    default capabilities of a containerized process running on your machine and notice
    that `net_raw` is in the list of capabilities:'
  id: totrans-1122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker容器默认提供的功能集提供了合理的功能缩减，但在某些时候你可能需要进一步添加或减少这个集合。例如，能力NET_RAW可能很危险。如果你想比默认配置更加小心，你可以从能力列表中移除NET_RAW。你可以通过在`docker
    container create`或`docker container run`中使用`--cap-drop`标志来从容器中移除能力。首先，打印出在你的机器上运行的容器化进程的默认能力，并注意`net_raw`在能力列表中：
- en: '`docker container run --rm -u nobody \     ubuntu:16.04 \     /bin/bash -c
    "capsh --print | grep net_raw"`'
  id: totrans-1123
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm -u nobody \ ubuntu:16.04 \ /bin/bash -c "capsh --print
    | grep net_raw"`'
- en: 'Now, drop the `net_raw` capability when starting the container. Grep cannot
    find the string `net_raw` because the capability has been dropped and so there
    is no visible output:'
  id: totrans-1124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，在启动容器时移除`net_raw`能力。Grep无法找到字符串`net_raw`，因为能力已经被移除，所以没有可见的输出：
- en: '`docker container run --rm -u nobody \     --cap-drop net_raw \` `1` `ubuntu:16.04
    \     /bin/bash -c "capsh --print | grep net_raw"`'
  id: totrans-1125
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm -u nobody \ --cap-drop net_raw \` `1` `ubuntu:16.04
    \ /bin/bash -c "capsh --print | grep net_raw"`'
- en: 1 Drops NET_RAW capability
  id: totrans-1126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 移除NET_RAW能力
- en: In Linux documentation, you’ll often see capabilities named in all uppercase
    and prefixed with CAP_, but that prefix won’t work if provided to the capability-management
    options. Use unprefixed and lowercase names for the best results.
  id: totrans-1127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在Linux文档中，你经常会看到以全部大写字母命名并带有CAP_前缀的能力，但如果你将其提供给能力管理选项，这个前缀将不起作用。为了获得最佳结果，请使用不带前缀的小写名称。
- en: 'Similar to the `--cap-drop` flag, the `--cap-add` flag will add capabilities.
    If you needed to add the SYS_ADMIN capability for some reason, you’d use a command
    like the following:'
  id: totrans-1128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与`--cap-drop`标志类似，`--cap-add`标志可以添加能力。如果你需要出于某种原因添加SYS_ADMIN能力，你可以使用以下命令：
- en: '`docker container run --rm -u nobody \     ubuntu:16.04 \     /bin/bash -c
    "capsh --print | grep sys_admin"` `1` `docker container run --rm -u nobody \    
    --cap-add sys_admin \` `2` `ubuntu:16.04 \     /bin/bash -c "capsh --print | grep
    sys_admin"`'
  id: totrans-1129
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm -u nobody \ ubuntu:16.04 \ /bin/bash -c "capsh --print
    | grep sys_admin"` `1` `docker container run --rm -u nobody \ --cap-add sys_admin
    \` `2` `ubuntu:16.04 \ /bin/bash -c "capsh --print | grep sys_admin"`'
- en: 1 SYS_ADMIN is not included.
  id: totrans-1130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 SYS_ADMIN不包括在内。
- en: 2 Adds SYS_ADMIN
  id: totrans-1131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 添加SYS_ADMIN
- en: Like other container-creation options, both `--cap-add` and `--cap-drop` can
    be specified multiple times to add or drop multiple capabilities, respectively.
    These flags can be used to build containers that will let a process perform exactly
    and only what is required for proper operation. For example, you might be able
    to run a network management daemon as the `nobody` user and give it the NET_ADMIN
    capability instead of running it as root directly on the host or as a privileged
    container. If you are wondering whether any capabilities were added or dropped
    from a container, you can inspect the container and print the `.HostConfig.CapAdd`
    and `.HostConfig.CapDrop` members of the output.
  id: totrans-1132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与其他容器创建选项一样，`--cap-add` 和 `--cap-drop` 都可以多次指定，分别用于添加或删除多个能力。这些标志可以用来构建容器，使进程能够执行恰好且仅是正确操作所必需的操作。例如，您可能能够以
    `nobody` 用户身份运行网络管理守护进程，并给它 NET_ADMIN 能力，而不是直接在主机上以 root 用户身份或作为特权容器运行。如果您想知道容器中是否添加或删除了任何能力，您可以检查容器并打印输出中的
    `.HostConfig.CapAdd` 和 `.HostConfig.CapDrop` 成员。
- en: 6.5\. RUNNING A CONTAINER WITH FULL PRIVILEGES
  id: totrans-1133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.5. 以完全权限运行容器
- en: When you need to run a system administration task inside a container, you can
    grant that container privileged access to your computer. Privileged containers
    maintain their filesystem and network isolation but have full access to shared
    memory and devices and possess full system capabilities. You can perform several
    interesting tasks, including running Docker inside a container, with privileged
    containers.
  id: totrans-1134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您需要在容器内运行系统管理任务时，您可以授予该容器对您的计算机的特权访问权限。特权容器保持其文件系统和网络隔离，但可以完全访问共享内存和设备，并拥有完整的系统能力。您可以使用特权容器执行多个有趣的任务，包括在容器内运行
    Docker。
- en: The bulk of the uses for privileged containers is administrative. Take, for
    example, an environment in which the root filesystem is read-only, or installing
    software outside a container has been disallowed, or you have no direct access
    to a shell on the host. If you wanted to run a program to tune the operating system
    (for something like load balancing) and you had access to run a container on that
    host, then you could simply run that program in a privileged container.
  id: totrans-1135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 特权容器的大部分用途是管理性的。例如，在一个根文件系统为只读的环境、在容器外安装软件被禁止或您无法直接访问主机上的 shell 的情况下。如果您想运行一个程序来调整操作系统（例如负载均衡），并且您有权在该主机上运行容器，那么您只需在特权容器中运行该程序即可。
- en: 'If you find a situation that can be solved only with the reduced isolation
    of a privileged container, use the `--privileged` flag on `docker container create`
    or `docker container run` to enable this mode:'
  id: totrans-1136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您发现只有通过特权容器的减少隔离才能解决的问题，请在 `docker container create` 或 `docker container run`
    中使用 `--privileged` 标志来启用此模式：
- en: '`docker container run --rm \     --privileged \     ubuntu:16.04 id` `1` `docker
    container run --rm \     --privileged \     ubuntu:16.04 capsh --print` `2` `docker
    container run --rm \     --privileged \     ubuntu:16.04 ls /dev` `3` `docker
    container run --rm \     --privileged \     ubuntu:16.04 networkctl` `4`'
  id: totrans-1137
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm --privileged ubuntu:16.04 id` `1` `docker container
    run --rm --privileged ubuntu:16.04 capsh --print` `2` `docker container run --rm
    --privileged ubuntu:16.04 ls /dev` `3` `docker container run --rm --privileged
    ubuntu:16.04 networkctl` `4`'
- en: 1 Checks out IDs
  id: totrans-1138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 检查 ID
- en: 2 Checks out Linux capabilities
  id: totrans-1139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 检查 Linux 能力
- en: 3 Checks out list of mounted devices
  id: totrans-1140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 检查挂载设备列表
- en: 4 Examines network configuration
  id: totrans-1141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 检查网络配置
- en: Privileged containers are still partially isolated. For example, the network
    namespace will still be in effect. If you need to tear down that namespace, you’ll
    need to combine this with `--net host` as well.
  id: totrans-1142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 特权容器仍然部分隔离。例如，网络命名空间仍然有效。如果您需要拆除该命名空间，您需要将其与 `--net host` 结合使用。
- en: 6.6\. STRENGTHENING CONTAINERS WITH ENHANCED TOOLS
  id: totrans-1143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.6. 使用增强工具加强容器
- en: Docker uses reasonable defaults and a “batteries included” toolset to ease adoption
    and promote best practices. Most modern Linux kernels enable seccomp, and Docker’s
    default seccomp profile blocks over 40 kernel system calls (syscalls) that most
    programs don’t need. You can enhance the containers Docker builds if you bring
    additional tools. Tools you can use to harden your containers include custom seccomp
    profiles, AppArmor, and SELinux.
  id: totrans-1144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker 使用合理的默认值和“包含电池”的工具集来简化采用并促进最佳实践。大多数现代 Linux 内核都启用了 seccomp，Docker 的默认
    seccomp 配置文件阻止了超过 40 个大多数程序不需要的内核系统调用（syscalls）。如果您带来额外的工具，可以增强 Docker 构建的容器。您可以使用自定义
    seccomp 配置文件、AppArmor 和 SELinux 等工具来加固容器。
- en: Whole books have been written about each of these tools. They bring their own
    nuances, benefits, and required skillsets. Their use can be more than worth the
    effort. Support for each varies by Linux distribution, so you may be in for a
    bit of work. But once you’ve adjusted your host configuration, the Docker integration
    is simpler.
  id: totrans-1145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于这些工具，已经写下了整本书。它们带来了自己的细微差别、优势和所需技能集。它们的使用可能比努力更有价值。对每个工具的支持因 Linux 发行版而异，所以你可能需要做一点工作。但一旦你调整了主机配置，Docker
    的集成就会变得简单。
- en: '|    |'
  id: totrans-1146
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: Security research
  id: totrans-1147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 安全研究
- en: The information security space is complicated and constantly evolving. It’s
    easy to feel overwhelmed when reading through open conversations between InfoSec
    professionals. These are often highly skilled people with long memories and very
    different contexts from developers or general users. If you can take away any
    one thing from open InfoSec conversations, it is that balancing system security
    with user needs is complex.
  id: totrans-1148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 信息安全领域复杂且不断演变。在阅读 InfoSec 专业人员之间的公开对话时，很容易感到不知所措。这些人通常技能高超，记忆力强，与开发人员或普通用户有着非常不同的背景。如果你能从公开的
    InfoSec 对话中汲取任何东西，那就是平衡系统安全与用户需求是复杂的。
- en: One of the best things you can do if you’re new to this space is start with
    articles, papers, blogs, and books before you jump into conversations. This will
    give you an opportunity to digest one perspective and gain deeper insight before
    switching to thoughts from a different perspective. When you’ve had an opportunity
    to form your own insight and opinions, these conversations become much more valuable.
  id: totrans-1149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你刚开始接触这个领域，最好的做法是在参与对话之前先从文章、论文、博客和书籍开始。这将给你一个机会消化一个观点，并在转向不同观点之前获得更深入的见解。当你有机会形成自己的见解和观点时，这些对话就会变得更有价值。
- en: It’s difficult to read one paper or learn one thing and know the best possible
    way to build a hardened solution. Whatever your situation, the system will evolve
    to include improvements from several sources. The best thing you can do is take
    each tool and learn it by itself. Don’t be intimidated by the depth some tools
    require for a strong understanding. The effort will be worth the result, and you’ll
    understand the systems you use much better for it.
  id: totrans-1150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 阅读一篇论文或学习一项内容，并了解构建加固解决方案的最佳方式是很困难的。无论你的情况如何，系统都会通过包含来自多个来源的改进而不断发展。你能做的最好的事情就是单独学习每个工具。不要因为某些工具需要深入理解而感到害怕。这种努力是值得的，而且你会对你使用的系统有更深入的了解。
- en: Docker isn’t a perfect solution. Some would argue that it’s not even a security
    tool. But the improvements it provides are far better than the alternative of
    forgoing any isolation because of perceived cost. If you’ve read this far, maybe
    you’d be willing to go further with these auxiliary topics.
  id: totrans-1151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker 并非完美的解决方案。有些人甚至认为它不是一种安全工具。但它提供的改进远比放弃任何隔离以节省成本的替代方案要好。如果你已经读到这儿，也许你愿意进一步探讨这些辅助主题。
- en: '|    |'
  id: totrans-1152
  prefs: []
  type: TYPE_TB
  zh: '|    |'
- en: 6.6.1\. Specifying additional security options
  id: totrans-1153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.6.1\. 指定额外的安全选项
- en: Docker provides a single `--security-opt` flag for specifying options that configure
    Linux’s seccomp and Linux Security Modules (LSM) features. Security options can
    be provided to the `docker container run` and `docker container create` commands.
    This flag can be set multiple times to pass multiple values.
  id: totrans-1154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker 提供了一个单独的 `--security-opt` 标志来指定配置 Linux 的 seccomp 和 Linux 安全模块（LSM）功能的选项。安全选项可以提供给
    `docker container run` 和 `docker container create` 命令。此标志可以设置多次以传递多个值。
- en: 'Seccomp configures which Linux system calls a process may invoke. Docker’s
    default seccomp profile blocks all syscalls by default and then explicitly permits
    more than 260 syscalls as safe for use by most programs. The 44 blocked system
    calls are unneeded or are unsafe for normal programs (for example, `unshare`,
    used in creating new namespaces) or cannot be namespaced (for example, `clock_settime`,
    which sets the machine’s time). Changing Docker’s default seccomp profile is not
    recommended. If the default seccomp profile is too restrictive or permissive,
    a custom profile can be specified as a security option:'
  id: totrans-1155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Seccomp 配置进程可以调用的 Linux 系统调用。Docker 的默认 seccomp 配置默认阻止所有系统调用，然后明确允许超过 260 个系统调用作为大多数程序的安全使用。被阻止的
    44 个系统调用是不必要的，或者对于正常程序来说是不安全的（例如，`unshare`，用于创建新的命名空间）或者不能进行命名空间化（例如，`clock_settime`，用于设置机器的时间）。不建议更改
    Docker 的默认 seccomp 配置。如果默认的 seccomp 配置过于严格或过于宽松，可以指定一个自定义配置作为安全选项：
- en: '`docker container run --rm -it \     --security-opt seccomp=<FULL_PATH_TO_PROFILE>
    \     ubuntu:16.04 sh`'
  id: totrans-1156
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`docker container run --rm -it \    --security-opt seccomp=<FULL_PATH_TO_PROFILE>
    \    ubuntu:16.04 sh`'
- en: '`<FULL_PATH_TO_PROFILE>` is the full path to a seccomp profile defining the
    allowed syscalls for the container. The Moby project on GitHub contains Docker’s
    default seccomp profile at profiles/seccomp/default.json that can be used as a
    starting point for a custom profile. Use the special value `unconfined` to disable
    use of seccomp for the container.'
  id: totrans-1157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`<FULL_PATH_TO_PROFILE>` 是定义容器允许的系统调用的seccomp配置文件的完整路径。GitHub上的Moby项目包含Docker的默认seccomp配置文件，位于profiles/seccomp/default.json，可以作为自定义配置文件的起点。使用特殊值
    `unconfined` 来禁用容器对seccomp的使用。'
- en: Linux Security Modules is a framework Linux adopted to act as an interface layer
    between the operating system and security providers. AppArmor and SELinux are
    LSM providers. Both provide mandatory access control, or MAC (the system defines
    access rules), and replace the standard Linux discretionary access control (file
    owners define access rules).
  id: totrans-1158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Linux安全模块（Linux Security Modules）是Linux采纳的一个框架，作为操作系统和安全提供者之间的接口层。AppArmor和SELinux是LSM提供者。两者都提供强制访问控制，或MAC（系统定义访问规则），并替换了标准的Linux自主访问控制（文件所有者定义访问规则）。
- en: 'The LSM security option values are specified in one of seven formats:'
  id: totrans-1159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: LSM安全选项值指定在以下七种格式之一中：
- en: To prevent a container from gaining new privileges after it starts, use `no-new-privileges`.
  id: totrans-1160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要防止容器在启动后获得新的权限，使用 `no-new-privileges`。
- en: To set a SELinux user label, use the form `label=user:<USERNAME>`, where `<USERNAME>`
    is the name of the user you want to use for the label.
  id: totrans-1161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要设置SELinux用户标签，使用形式 `label=user:<USERNAME>`，其中 `<USERNAME>` 是你想要用于标签的用户名。
- en: To set a SELinux role label, use the form `label=role:<ROLE>`, where `<ROLE>`
    is the name of the role you want to apply to processes in the container.
  id: totrans-1162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要设置SELinux角色标签，使用形式 `label=role:<ROLE>`，其中 `<ROLE>` 是你想要应用于容器中进程的角色名称。
- en: To set a SELinux type label, use the form `label=type:<TYPE>`, where `<TYPE>`
    is the type name of the processes in the container.
  id: totrans-1163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要设置SELinux类型标签，使用形式 `label=type:<TYPE>`，其中 `<TYPE>` 是容器中进程的类型名称。
- en: To set a SELinux-level label, use the form `label:level:<LEVEL>`, where `<LEVEL>`
    is the level at which processes in the container should run. Levels are specified
    as low-high pairs. Where abbreviated to the low level only, SELinux will interpret
    the range as single level.
  id: totrans-1164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要设置SELinux级别的标签，使用形式 `label:level:<LEVEL>`，其中 `<LEVEL>` 是容器中进程应运行的级别。级别指定为低-高对。如果仅缩写为低级别，SELinux将解释范围为单个级别。
- en: To disable SELinux label confinement for a container, use the form `label= disable`.
  id: totrans-1165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要禁用容器的SELinux标签约束，使用形式 `label= disable`。
- en: To apply an AppArmor profile on the container, use the form `apparmor= <PROFILE>`,
    where `<PROFILE>` is the name of the AppArmor profile to use.
  id: totrans-1166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在容器上应用AppArmor配置文件，使用形式 `apparmor= <PROFILE>`，其中 `<PROFILE>` 是要使用的AppArmor配置文件名称。
- en: As you can guess from these options, SELinux is a labeling system. A set of
    labels, called a context, is applied to every file and system object. A similar
    set of labels is applied to every user and process. At runtime, when a process
    attempts to interact with a file or system resource, the sets of labels are evaluated
    against a set of allowed rules. The result of that evaluation determines whether
    the interaction is allowed or blocked.
  id: totrans-1167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如您从这些选项中可以猜到的，SELinux是一个标签系统。一组标签，称为上下文，应用于每个文件和系统对象。类似的一组标签应用于每个用户和进程。在运行时，当进程尝试与文件或系统资源交互时，标签集将根据一组允许的规则进行评估。该评估的结果将确定交互是否被允许或阻止。
- en: The last option will set an AppArmor profile. AppArmor is frequently substituted
    for SELinux because it works with file paths instead of labels and has a training
    mode that you can use to passively build profiles based on observed application
    behavior. These differences are often cited as reasons why AppArmor is easier
    to adopt and maintain.
  id: totrans-1168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后一个选项将设置AppArmor配置文件。AppArmor经常被SELinux替代，因为它与文件路径而不是标签一起工作，并且有一个训练模式，可以用来根据观察到的应用程序行为被动地构建配置文件。这些差异通常被引用为AppArmor更容易采用和维护的原因。
- en: Free and commercial tools that monitor a program’s execution and generate custom
    profiles tailored for applications are available. These tools help operators use
    information from actual program behavior in test and production environments to
    create a profile that works.
  id: totrans-1169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有免费和商业工具可以监控程序的执行并生成针对应用程序定制的配置文件。这些工具帮助操作员使用测试和生产环境中实际程序行为的信息来创建一个有效的配置文件。
- en: 6.7\. BUILDING USE-CASE-APPROPRIATE CONTAINERS
  id: totrans-1170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.7\. 构建适用于用例的容器
- en: Containers are a cross-cutting concern. There are more reasons and ways that
    people could use them than we could ever enumerate. So it’s important, when you
    use Docker to build containers to serve your own purposes, that you take the time
    to do so in a way that’s appropriate for the software you’re running.
  id: totrans-1171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 容器是一个跨领域的关注点。人们使用它们的原因和方式比我们能列举的要多。所以，当你使用Docker构建容器来满足自己的需求时，花时间以适合你运行软件的方式去做是很重要的。
- en: The most secure tactic for doing so would be to start with the most isolated
    container you can build and justify reasons for weakening those restrictions.
    In reality, people tend to be a bit more reactive than proactive. For that reason,
    we think Docker hits a sweet spot with the default container construction. It
    provides reasonable defaults without hindering the productivity of users.
  id: totrans-1172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现这一点的最安全策略是从你可以构建的最隔离的容器开始，并合理地解释为什么需要放宽这些限制。现实中，人们往往比主动更倾向于反应。因此，我们认为Docker在默认容器构建方面找到了一个甜蜜点。它提供了合理的默认设置，同时又不阻碍用户的效率。
- en: Docker containers are not the most isolated by default. Docker does not require
    that you enhance those defaults. It will let you do silly things in production
    if you want to. This makes Docker seem much more like a tool than a burden and
    something people generally want to use rather than feel like they have to use.
    For those who would rather not do silly things in production, Docker provides
    a simple interface to enhance container isolation.
  id: totrans-1173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Docker容器默认情况下并不是最隔离的。Docker并不要求你增强那些默认设置。如果你愿意，它会让你在生产环境中做一些愚蠢的事情。这使得Docker看起来更像是一个工具，而不是负担，人们更愿意使用而不是感觉不得不使用。对于那些不愿意在生产环境中做愚蠢事情的人来说，Docker提供了一个简单的接口来增强容器隔离。
- en: 6.7.1\. Applications
  id: totrans-1174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.7.1 应用程序
- en: Applications are the whole reason we use computers. Most applications are programs
    that other people wrote and that work with potentially malicious data. Consider
    your web browser.
  id: totrans-1175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应用程序是我们使用计算机的全部原因。大多数应用程序是其他人编写的程序，它们可能处理恶意数据。考虑一下你的网络浏览器。
- en: A web browser is a type of application that’s installed on almost every computer.
    It interacts with web pages, images, scripts, embedded video, Flash documents,
    Java applications, and anything else out there. You certainly didn’t create all
    that content, and most people were not contributors on web browser projects. How
    can you trust your web browser to handle all that content correctly?
  id: totrans-1176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 网络浏览器是一种几乎安装在每台计算机上的应用程序。它与网页、图片、脚本、嵌入式视频、Flash文档、Java应用程序以及任何其他内容交互。你当然没有创建所有这些内容，大多数人也不是网络浏览器项目的贡献者。你怎么能信任你的网络浏览器正确处理所有这些内容呢？
- en: 'Some more cavalier readers might just ignore the problem. After all, what’s
    the worst thing that could happen? Well, if an attacker gains control of your
    web browser (or other application), they will gain all the capabilities of that
    application and the permissions of the user it’s running as. They could trash
    your computer, delete your files, install other malware, or even launch attacks
    against other computers from yours. So, this isn’t a good thing to ignore. The
    question remains: how do you protect yourself when this is a risk you need to
    take?'
  id: totrans-1177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些更加轻率的读者可能会忽略这个问题。毕竟，最糟糕的事情会是什么？好吧，如果攻击者控制了你的网络浏览器（或其他应用程序），他们将获得该应用程序的所有功能和运行该应用程序的用户权限。他们可能会破坏你的计算机，删除你的文件，安装其他恶意软件，甚至从你的计算机上对其他计算机发起攻击。所以，这不是可以忽视的好事情。问题仍然是：当你需要承担这种风险时，你该如何保护自己？
- en: The best approach is to isolate the risk of running the program. First, make
    sure the application is running as a user with limited permissions. That way,
    if there’s a problem, it won’t be able to change the files on your computer. Second,
    limit the system capabilities of the browser. In doing so, you make sure your
    system configuration is safer. Third, set limits on how much of the CPU and memory
    the application can use. Limits help reserve resources to keep the system responsive.
    Finally, it’s a good idea to specifically whitelist devices that it can access.
    That will keep snoops off your webcam, USB, and the like.
  id: totrans-1178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最好的做法是隔离程序运行的风险。首先，确保应用程序以有限权限的用户身份运行。这样，如果出现问题，它将无法更改你计算机上的文件。其次，限制浏览器的系统功能。这样做可以确保你的系统配置更安全。第三，限制应用程序可以使用的CPU和内存量。限制有助于保留资源以保持系统响应。最后，具体列出它可以访问的设备也是一个好主意。这将防止窥探者访问你的网络摄像头、USB等设备。
- en: 6.7.2\. High-level system services
  id: totrans-1179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.7.2 高级系统服务
- en: High-level system services are a bit different from applications. They’re not
    part of the operating system, but your computer makes sure they’re started and
    kept running. These tools typically sit alongside applications outside the operating
    system, but they often require privileged access to the operating system to operate
    correctly. They provide important functionality to users and other software on
    a system. Examples include `cron`, `syslogd`, `dnsmasq`, `sshd`, and `docker`.
  id: totrans-1180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 高级系统服务与应用程序略有不同。它们不是操作系统的一部分，但您的计算机确保它们被启动并保持运行。这些工具通常位于操作系统之外的应用程序旁边，但它们通常需要特权访问权限才能正确运行。它们为系统上的用户和其他软件提供重要的功能。例如包括`cron`、`syslogd`、`dnsmasq`、`sshd`和`docker`。
- en: If you’re unfamiliar with these tools (hopefully not all of them), it’s all
    right. They do things like keep system logs, run scheduled commands, and provide
    a way to get a secure shell on the system from the network, and `docker` manages
    containers.
  id: totrans-1181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您不熟悉这些工具（希望不是全部），没关系。它们执行的任务包括保持系统日志、运行计划命令，以及提供从网络获取系统安全外壳的方法，而`docker`管理容器。
- en: Although running services as root is common, few of them need full privileged
    access. Consider containerizing services and use capabilities to tune their access
    for the specific features they need.
  id: totrans-1182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然以root身份运行服务很常见，但其中很少需要完整的特权访问。考虑将服务容器化，并使用能力调整它们的访问权限，以满足它们需要的特定功能。
- en: 6.7.3\. Low-level system services
  id: totrans-1183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6.7.3. 低级系统服务
- en: Low-level services control things like devices or the system’s network stack.
    They require privileged access to the components of the system they provide (for
    example, firewall software needs administrative access to the network stack).
  id: totrans-1184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 低级服务控制诸如设备或系统网络堆栈之类的功能。它们需要对其提供的系统组件具有特权访问权限（例如，防火墙软件需要网络堆栈的行政访问权限）。
- en: It’s rare to see these run inside containers. Tasks such as filesystem management,
    device management, and network management are core host concerns. Most software
    run in containers is expected to be portable. So machine-specific tasks like these
    are a poor fit for general container use cases.
  id: totrans-1185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在容器内运行这些任务很少见。例如，文件系统管理、设备管理和网络管理都是主机核心关注点。大多数在容器中运行的软件都期望是可移植的。因此，像这些特定于机器的任务并不适合一般的容器使用场景。
- en: The best exceptions are short-running configuration containers. For example,
    in an environment where all deployments happen with Docker images and containers,
    you’d want to push network stack changes in the same way you push software. In
    this case, you might push an image with the configuration to the host and make
    the changes with a privileged container. The risk in this case is reduced because
    you authored the configuration to be pushed, the container is not long running,
    and changes like these are simple to audit.
  id: totrans-1186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最好的例外是短运行配置容器。例如，在一个所有部署都使用Docker镜像和容器进行的环境中，您可能希望以推送软件的方式推送网络堆栈更改。在这种情况下，您可能将带有配置的镜像推送到主机，并使用特权容器进行更改。在这种情况下，风险降低，因为您编写了要推送的配置，容器不是长时间运行的，并且像这样的更改很容易审计。
- en: SUMMARY
  id: totrans-1187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter introduced the isolation features provided by Linux and talked
    about how Docker uses those to build configurable containers. With this knowledge,
    you will be able to customize that container isolation and use Docker for any
    use case. The following points were covered in this chapter:'
  id: totrans-1188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章介绍了Linux提供的隔离功能，并讨论了Docker如何使用这些功能来构建可配置的容器。有了这些知识，您将能够自定义容器隔离并使用Docker处理任何使用场景。本章涵盖了以下要点：
- en: Docker uses cgroups, which let a user set memory limits, CPU weight, limits,
    and core restrictions as well as restrict access to specific devices.
  id: totrans-1189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker使用cgroups，允许用户设置内存限制、CPU权重、限制和核心限制，以及限制对特定设备的访问。
- en: Docker containers each have their own IPC namespace that can be shared with
    other containers or the host in order to facilitate communication over shared
    memory.
  id: totrans-1190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker容器各自都有自己的IPC命名空间，可以与其他容器或主机共享，以便通过共享内存促进通信。
- en: Docker supports isolating the USR namespace. By default, user and group IDs
    inside a container are equivalent to the same IDs on the host machine. When the
    user namespace is enabled, user and group IDs in the container are remapped to
    IDs that do not exist on the host.
  id: totrans-1191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker支持隔离USR命名空间。默认情况下，容器内的用户和组ID与主机机器上的相同ID等效。当启用用户命名空间时，容器内的用户和组ID被重新映射到主机上不存在的ID。
- en: You can and should use the `-u` option on `docker container run` and `docker
    container create` to run containers as nonroot users.
  id: totrans-1192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用并应该使用 `docker container run` 和 `docker container create` 中的 `-u` 选项来以非root用户运行容器。
- en: Avoid running containers in privileged mode whenever possible.
  id: totrans-1193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，尽量避免以特权模式运行容器。
- en: Linux capabilities provide operating system feature authorization. Docker drops
    certain capabilities in order to provide reasonably isolating defaults.
  id: totrans-1194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 能力提供了操作系统功能授权。Docker 会取消某些能力，以提供合理的隔离默认设置。
- en: The capabilities granted to any container can be set with the `--cap-add` and
    `--cap-drop` flags.
  id: totrans-1195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `--cap-add` 和 `--cap-drop` 标志来设置任何容器所授予的能力。
- en: Docker provides tooling for integrating easily with enhanced isolation technologies
    such as seccomp, SELinux, and AppArmor. These are powerful tools that security-conscious
    Docker adopters should investigate.
  id: totrans-1196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 提供了与增强隔离技术（如 seccomp、SELinux 和 AppArmor）轻松集成的工具。这些是安全意识强的 Docker 用户应该调查的强大工具。
