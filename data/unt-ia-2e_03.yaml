- en: 2 Building a demo that puts you in 3D space
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 构建一个让你置身于3D空间的演示
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: Understanding 3D coordinate space
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解3D坐标空间
- en: Putting a player in a scene
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景中放置玩家
- en: Writing a script that moves objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写移动物体的脚本
- en: Implementing FPS controls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现FPS控制
- en: Chapter 1 concluded with the traditional “Hello World!” introduction to a new
    programming tool; now it’s time to dive into a nontrivial Unity project, a project
    with interactivity and graphics. You’ll put objects into a scene and write code
    to enable a player to walk around that scene. Basically, it’ll be *Doom* without
    the monsters (something like the depiction in figure 2.1). The visual editor in
    Unity enables new users to start assembling a 3D prototype right away, without
    needing to write a lot of boilerplate code first (for things like initializing
    a 3D view or establishing a rendering loop).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章以传统的“Hello World！”介绍了一种新的编程工具；现在，是时候深入一个非平凡的Unity项目了，一个具有交互性和图形的项目。你将把物体放入场景，并编写代码使玩家能够在场景中行走。基本上，这将是一个没有怪物的*《Doom》*（类似于图2.1中的描绘）。Unity中的视觉编辑器使新用户能够立即开始组装一个3D原型，而无需先编写大量的模板代码（例如初始化3D视图或建立渲染循环）。
- en: '![CH02_F01_Hocking3](../Images/CH02_F01_Hocking3.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F01_Hocking3](../Images/CH02_F01_Hocking3.png)'
- en: Figure 2.1 Screenshot of the 3D demo (basically, *Doom* without the monsters)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 3D演示的截图（基本上，*《Doom》*没有怪物）
- en: It’s tempting to immediately start building the scene in Unity, especially with
    such a simple (in concept!) project. But it’s always a good idea to pause at the
    beginning and plan out what you’re going to do, and this is especially important
    right now because you’re new to the process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 很有诱惑力立即在Unity中开始构建场景，尤其是这样一个（在概念上！）简单的项目。但是，在开始之前暂停并规划你要做什么总是一个好主意，而且现在这一点尤为重要，因为你对这个过程还不太熟悉。
- en: NOTE Remember, the project for every chapter can be downloaded from the book’s
    website ([http://mng.bz/VBY5)](http://mng.bz/VBY5). First open the project in
    Unity and then open the main scene (usually just named Scene) to run and inspect.
    While you’re learning, I recommend you type out all the code yourself and use
    the downloaded sample only for reference.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个章节的项目都可以从本书的网站上下载（[http://mng.bz/VBY5](http://mng.bz/VBY5)）。首先在Unity中打开项目，然后打开主场景（通常只命名为Scene）以运行和检查。在你学习的过程中，我建议你自己输入所有代码，并将下载的样本仅作为参考使用。
- en: 2.1 Before you start . . .
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 在开始之前...
- en: Unity makes it easy for a newcomer to get started, but let’s go over a couple
    of points before you build the complete scene. Even when working with a tool as
    flexible as Unity, you need to have a sense of the goal you’re working toward.
    You also need to grasp how 3D coordinates operate, or you could get lost as soon
    as you try to position an object in the scene.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Unity使新手容易开始，但在你构建完整的场景之前，让我们先过一下几个要点。即使在与Unity这样灵活的工具一起工作时，你也需要有一个明确的目标感。你还需要掌握3D坐标如何运作，否则你一尝试在场景中定位物体就会迷失方向。
- en: 2.1.1 Planning the project
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 规划项目
- en: Before you start programming anything, you always want to pause and ask yourself,
    “So what am I building here?” Game design is a huge topic, with many impressively
    large books focused on how to design a game. Fortunately, for our purposes, you
    need only a brief outline of this simple demo in mind to develop a basic learning
    project. These initial projects won’t be terribly complex designs anyway, in order
    to avoid distracting you from learning programming concepts. You can (and should!)
    worry about higher-level design issues after you’ve mastered the fundamentals
    of game development.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写任何代码之前，你总是想要停下来问问自己，“我在这里要构建什么？”游戏设计是一个巨大的主题，有大量令人印象深刻的大型书籍专注于如何设计游戏。幸运的是，为了我们的目的，你只需要在心中有一个关于这个简单演示的简要概述，就可以开发一个基本的学习项目。这些初始项目本身设计不会太复杂，以免分散你学习编程概念。在你掌握了游戏开发的基本原理之后，你可以（并且应该！）担心更高级的设计问题。
- en: 'For this first project, you’ll build a basic first-person shooter (FPS) scene.
    We will create a room to navigate around, and players will see the world from
    their character’s point of view and can control the character by using the mouse
    and keyboard. All the interesting complexity of a complete game can be stripped
    away for now to concentrate on the core mechanics: moving around in a 3D space.
    Figure 2.2 depicts the road map for this project, laying out the checklist I built
    in my head:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个第一个项目，你将构建一个基本的单人第一人称射击（FPS）场景。我们将创建一个房间供玩家导航，玩家将从他们的角色视角看到世界，并且可以通过使用鼠标和键盘来控制角色。现在可以移除完整游戏的所有有趣复杂性，以便专注于核心机制：在3D空间中移动。图2.2展示了这个项目的路线图，列出了我在脑海中构建的清单：
- en: 'Set up the room: create the floor, outer walls, and inner walls.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置房间：创建地板、外墙和内墙。
- en: Place the lights and camera.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放置灯光和相机。
- en: Create the player object (including attaching the camera on top).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建玩家对象（包括在顶部附加相机）。
- en: 'Write movement scripts: rotate with the mouse and move with the keyboard.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写移动脚本：用鼠标旋转，用键盘移动。
- en: '![CH02_F02_Hocking3](../Images/CH02_F02_Hocking3.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F02_Hocking3](../Images/CH02_F02_Hocking3.png)'
- en: Figure 2.2 Road map for the 3D demo
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 3D演示的路线图
- en: Don’t be scared off by everything in this road map! It sounds like a lot of
    steps in this chapter, but Unity makes them easy. The upcoming sections about
    movement scripts are so extensive only because we’ll be going through every line
    so that you can understand all the concepts in detail.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被这个路线图中的所有内容吓倒！听起来这个章节有很多步骤，但Unity会让它们变得简单。接下来关于移动脚本的章节之所以内容广泛，仅仅是因为我们将逐行分析，以便你能够详细理解所有概念。
- en: This project is a first-person demo in order to keep the art requirements simple;
    because you can’t see yourself, it’s fine for “you” to be a cylindrical shape
    with a camera on top! Now you need to understand how 3D coordinates work so that
    placing everything in the visual editor will be easy.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目是一个第一人称演示，为了保持艺术要求简单；因为你看不到自己，所以“你”可以是一个顶部带有相机的圆柱形！现在你需要理解3D坐标是如何工作的，这样在视觉编辑器中放置所有内容就会变得容易。
- en: 2.1.2 Understanding 3D coordinate space
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 理解3D坐标空间
- en: 'If you think about the simple plan we’re starting with, it has three aspects:
    a room, a view, and controls. All of these items rely on you understanding how
    positions and movements are represented in 3D computer simulations. If you’re
    new to working with 3D graphics, you might not already know this stuff.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你思考一下我们刚开始的简单计划，它有三个方面：一个房间、一个视野和控件。所有这些项目都依赖于你理解如何在3D计算机模拟中表示位置和运动。如果你是3D图形的新手，你可能还不知道这些内容。
- en: It all boils down to numbers that indicate points in space, and the way those
    numbers correlate to the space is through coordinate axes. If you think back to
    math class, you’ve probably seen and used x- and y-axes (see figure 2.3) for assigning
    coordinates to points on the page. This is referred to as a *Cartesian coordinate
    system*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些最终都归结为表示空间中点的数字，这些数字与空间相关联的方式是通过坐标轴。如果你回想起数学课，你可能见过并使用过x轴和y轴（见图2.3）来为页面上的点分配坐标。这被称为*笛卡尔坐标系*。
- en: '![CH02_F03_Hocking3](../Images/CH02_F03_Hocking3.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F03_Hocking3](../Images/CH02_F03_Hocking3.png)'
- en: Figure 2.3 Coordinates along the x- and y-axes define a 2D point.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 x轴和y轴上的坐标定义了一个2D点。
- en: 'Two axes give you 2D coordinates, with all points in the same plane. Three
    axes are used to define 3D space. Because the x-axis goes along the page horizontally
    and the y-axis goes along the page vertically, we now imagine a third axis that
    sticks straight into and out of the page, perpendicular to both the x- and y-axes.
    Figure 2.4 depicts the x-, y-, and z-axes for 3D coordinate space. Everything
    that has a specific position in the scene will have x-, y-, and z-coordinates:
    the position of the player, the placement of a wall, and so forth.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 两个轴提供了2D坐标，所有点都在同一平面上。三个轴用于定义3D空间。因为x轴沿着页面水平方向，y轴沿着页面垂直方向，所以我们现在想象一个垂直于x轴和y轴的第三轴，从页面中直插出来。图2.4展示了3D坐标空间的x轴、y轴和z轴。场景中所有具有特定位置的对象都将具有x轴、y轴和z坐标：玩家的位置、墙的位置等等。
- en: '![CH02_F04_Hocking3](../Images/CH02_F04_Hocking3.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F04_Hocking3](../Images/CH02_F04_Hocking3.png)'
- en: Figure 2.4 Coordinates along the x-, y-, and z-axes define a 3D point.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 x轴、y轴和z轴上的坐标定义了一个3D点。
- en: In Unity’s Scene view, you can see these three axes displayed. In the Inspector,
    you can type in the three numbers required to position an object. You will not
    only write code to position objects using these three-number coordinates, but
    also define movements as a distance to move along each axis.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity的场景视图中，你可以看到这三个轴被显示出来。在检查器中，你可以输入定位对象所需的三个数字。你不仅会使用这三个数字坐标编写代码来定位对象，还会定义沿着每个轴的移动距离。
- en: Left-handed vs. right-handed coordinates
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 左手系与右手系坐标
- en: The positive and negative direction of each axis is arbitrary, and the coordinates
    still work no matter in which direction the axes point. You simply need to maintain
    consistency within a given 3D graphics tool (animation tool, game development
    tool, and so forth).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每个轴的正负方向是任意的，无论轴指向哪个方向，坐标仍然有效。你只需要在给定的3D图形工具（动画工具、游戏开发工具等）中保持一致性。
- en: But in almost all cases, x goes to the right and y goes up; what differs between
    different tools is whether z goes into or comes out of the page. These two directions
    are referred to as *left-handed* or *right-handed*; as this figure shows, if you
    point your thumb along the x-axis and your index finger along the y-axis, then
    your middle finger points along the z-axis.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但在几乎所有情况下，x轴向右延伸，y轴向上延伸；不同工具之间的区别在于z轴是进入页面还是从页面出来。这两个方向被称为*左手系*或*右手系*；如图所示，如果你将大拇指沿着x轴方向，食指沿着y轴方向，那么中指就会指向z轴。
- en: '![CH02_UN01_Hocking3](../Images/CH02_UN01_Hocking3.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_UN01_Hocking3](../Images/CH02_UN01_Hocking3.png)'
- en: The z-axis points in a different direction on the left hand versus the right
    hand.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 左手系和右手系的z轴指向不同的方向。
- en: Unity uses a left-handed coordinate system, as do many 3D art applications.
    Many other tools use right-handed coordinate systems (OpenGL, for example), so
    don’t get confused if you ever see different coordinate directions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Unity使用左手坐标系，许多3D艺术应用程序也是如此。许多其他工具使用右手坐标系（例如OpenGL），所以如果你看到不同的坐标方向，不要感到困惑。
- en: Now that you have a plan in mind for this project and know how coordinates are
    used to position objects in 3D space, it’s time to start building the scene.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经为这个项目制定了计划，并且知道如何使用坐标在3D空间中定位对象，是时候开始构建场景了。
- en: '2.2 Begin the project: Place objects in the scene'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 开始项目：在场景中放置对象
- en: Let’s create and place objects in the scene. First, you’ll set up all the static
    scenery—the floor and walls. Then you’ll place lights around the scene and position
    the camera. Lastly, you’ll create the object that will be the player, the object
    to which you’ll attach scripts to walk around the scene. Figure 2.5 shows what
    the editor will look like with everything in place.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在场景中创建和放置对象。首先，你将设置所有静态场景——地板和墙壁。然后你将在场景周围放置灯光，并定位摄像机。最后，你将创建玩家对象，即你将附加脚本以在场景中四处走动的对象。图2.5显示了所有对象放置就绪的编辑器外观。
- en: '![CH02_F05_Hocking3](../Images/CH02_F05_Hocking3.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F05_Hocking3](../Images/CH02_F05_Hocking3.png)'
- en: Figure 2.5 Scene in the editor with floor, walls, lights, a camera, and the
    player
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 编辑器中的场景，包含地板、墙壁、灯光、摄像机和玩家
- en: Chapter 1 showed how to create a new project in Unity, so you’ll do that now.
    Choose New in Unity Hub (or File > New Project in the editor) and then name your
    new project in the window that pops up. The scene starts out mostly empty, and
    the first objects to create are the most obvious ones.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章展示了如何在Unity中创建新项目，所以你现在将这样做。在Unity Hub中选择“新建”（或编辑器中的“文件 > 新建项目”），然后在弹出的窗口中命名你的新项目。场景一开始几乎是空的，首先创建的对象是最明显的。
- en: '2.2.1 The scenery: Floor, outer walls, and inner walls'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 景观：地板、外墙和内墙
- en: Select the GameObject menu at the top of the screen and then hover over 3D Object
    to see that drop-down menu. Select Cube to create a new cube object in the scene
    (later, we’ll use other shapes, like Sphere and Capsule). Adjust the position
    and scale of this object, as well as its name, to make the floor. Figure 2.6 shows
    which values the floor should be set to in the Inspector (it’s a cube only initially,
    before you stretch it out).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕顶部选择GameObject菜单，然后悬停在3D Object上以查看下拉菜单。选择Cube以在场景中创建一个新的立方体对象（稍后我们将使用其他形状，如Sphere和Capsule）。调整这个对象的位置和缩放，以及它的名称，以创建地板。图2.6显示了检查器中地板应设置哪些值（它最初只是一个立方体，在你将其拉伸之前）。
- en: NOTE You can think about the numbers for position in terms of any units you
    want, as long as you’re consistent throughout the scene. The most common choice
    for units is meters, and that’s what I generally choose, but I also use feet sometimes,
    and I’ve even seen other people decide that the numbers are inches!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 您可以将位置数值视为您想要的任何单位，只要在整个场景中保持一致即可。最常见的单位是米，我通常选择米，但有时我也使用英尺，甚至见过其他人决定使用英寸！
- en: Repeat the same steps to create outer walls for the room. You can create new
    cubes each time, or you can copy and paste existing objects by using the standard
    shortcuts. Move, rotate, and scale the walls to form a perimeter around the floor.
    Experiment with different numbers (for example, 1, 4, 50 for Scale) or use the
    transform tools introduced in section 1.2.2 (remember that the mathematical term
    for moving and rotating in 3D space is *transform*).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重复相同的步骤来创建房间的外墙。每次都可以创建新的立方体，或者您可以通过使用标准快捷键复制并粘贴现有对象。移动、旋转和缩放墙壁以在楼面周围形成边界。尝试不同的数字（例如，缩放为1、4、50）或使用第1.2.2节中介绍的变换工具（记住，在3D空间中移动和旋转的数学术语是
    *变换*）。
- en: TIP Recall the navigation controls in chapter 1 to view the scene from different
    angles or zoom out for a bird’s-eye view. If you ever get lost in the scene, press
    F to reset the view on the currently selected object.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 回想一下第1章中的导航控制，以从不同角度查看场景或放大以获得鸟瞰视图。如果您在场景中迷路了，请按F键重置当前选中对象的视图。
- en: '![CH02_F06_Hocking3](../Images/CH02_F06_Hocking3.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F06_Hocking3](../Images/CH02_F06_Hocking3.png)'
- en: Figure 2.6 Inspector view for the floor
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 楼面检查器视图
- en: Once the outer walls are in place, create inner walls to navigate around. Position
    the inner walls however you like; the idea is to create hallways and obstacles
    to walk around once you write code for movement. The exact Transform values that
    the walls end up with will vary depending on how you rotate and scale the cubes
    to fit, and on how the objects are linked together in the Hierarchy view. If you
    need an example to copy working values from, download the sample project and refer
    to the walls there.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦外墙就位，创建内墙以进行导航。将内墙放置在您喜欢的位置；想法是在编写移动代码后创建走廊和障碍物。墙壁最终具有的确切变换值将取决于您如何旋转和缩放立方体以适应，以及对象在层次视图中的链接方式。如果您需要从示例中复制有效值，请下载示例项目并参考那里的墙壁。
- en: TIP Drag objects on top of each other in the Hierarchy view to establish linkages.
    Objects that have accompanying objects attached are referred to as *parents*;
    objects attached to parent objects are referred to as *children*. When the parent
    object is moved (or rotated or scaled), the child objects are transformed along
    with it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 在层次视图中将对象拖到彼此上方以建立链接。带有附加对象的物体被称为 *父对象*；附加到父对象的对象被称为 *子对象*。当父对象移动（或旋转或缩放）时，子对象会与其一起变换。
- en: Definition A *root* object (closely related to the concepts of parent and child
    objects) is an object at the base of a hierarchy that does not itself have a parent.
    Thus, all root objects are parents, but not all parents are root objects.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 *根* 对象（与父对象和子对象的概念密切相关）是位于层次结构底部且本身没有父对象的对象。因此，所有根对象都是父对象，但并非所有父对象都是根对象。
- en: You can also create empty game objects to use for organizing the scene. From
    the GameObject menu, choose Create Empty. By linking visible objects to a root
    object, their Hierarchy list can be collapsed. For example, in figure 2.7, the
    walls are all children of an empty root object (named Building) so that the Hierarchy
    list will look organized.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建空的游戏对象来组织场景。从游戏对象菜单中选择创建空对象。通过将可见对象链接到根对象，可以折叠其层次列表。例如，在图2.7中，墙壁都是空根对象（命名为Building）的子对象，这样层次列表看起来就会很整齐。
- en: '![CH02_F07_Hocking3](../Images/CH02_F07_Hocking3.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F07_Hocking3](../Images/CH02_F07_Hocking3.png)'
- en: Figure 2.7 The Hierarchy view showing the walls and floor organized under an
    empty object
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 展示墙壁和楼面组织在空对象下的层次视图
- en: Warning Before linking any child objects to it, make sure to reset the Transform
    options (Position and Rotation to 0, 0, 0 and Scale to 1, 1, 1) of the empty root
    object to avoid any oddities in the position of child objects.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在将任何子对象链接到它之前，请确保将空根对象（位置和旋转设置为0, 0, 0，缩放设置为1, 1, 1）的变换选项重置，以避免子对象位置出现任何异常。
- en: What is GameObject?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是GameObject？
- en: All scene objects are instances of the GameObject class, similar to the way
    all script components inherit from the MonoBehaviour class. This fact was more
    explicit with the empty object actually named GameObject, but is still true regardless
    of whether the object is named Floor, Camera, or Player.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所有场景对象都是GameObject类的实例，类似于所有脚本组件都继承自MonoBehaviour类的方式。当空对象被实际命名为GameObject时，这一事实更为明确，但无论对象被命名为Floor、Camera还是Player，这一事实仍然是真实的。
- en: GameObject is really a container for a bunch of components. The main purpose
    of GameObject is to provide MonoBehaviour something to attach to. What exactly
    the object is in the scene depends on which components have been added to that
    GameObject. Cube objects have a Cube component, Sphere objects have a Sphere component,
    and so on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: GameObject实际上是一系列组件的容器。GameObject的主要目的是为MonoBehaviour提供一些可以附加的东西。物体在场景中的确切位置取决于已经添加到该GameObject的哪些组件。立方体对象有Cube组件，球体对象有Sphere组件，依此类推。
- en: Remember to save the changed scene if you haven’t yet. Now the scene has a room
    in it, but we still need to set up the lighting. Let’s take care of that next.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有保存更改的场景，请记住保存。现在场景中有一个房间，但我们仍然需要设置灯光。让我们接下来处理这个问题。
- en: 2.2.2 Lights and cameras
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 光源和相机
- en: Typically, you light a 3D scene with a directional light and then a series of
    point lights. Start with a directional light. The scene probably already has one
    by default, but if not, create one by choosing GameObject > Light and selecting
    Directional Light.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你使用方向光和一系列点光源来照亮3D场景。从一个方向光开始。场景默认情况下可能已经有一个了，如果没有，可以通过选择GameObject > Light并选择方向光来创建一个。
- en: Types of lights
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 光源类型
- en: You can create several types of light sources, defined by how and where they
    project light rays. The three main types are point, spot, and directional.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建几种类型的光源，这些光源由它们如何以及在哪里投射光线来定义。三种主要类型是点光源、聚光灯和方向光源。
- en: In *point lights*, all the light rays originate from a single point and project
    out in all directions, like a light bulb in the real world. The light is brighter
    up close because the light rays are bunched up.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在*点光源*中，所有光线都从一个点发出并向所有方向投射，就像现实世界中的灯泡一样。光线在近距离更亮，因为光线是聚集在一起的。
- en: In *spot lights*, all the light rays originate from a single point but project
    out in only a limited cone. No spot lights are used in the current project, but
    these lights are commonly used to highlight parts of a level.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在*聚光灯*中，所有光线都从一个点发出，但只在一个有限的锥体中投射。当前项目中没有使用聚光灯，但这些灯光通常用于突出显示关卡的一部分。
- en: In *directional lights*, all the light rays are parallel and project evenly,
    lighting everything in the scene the same way. This is like the sun in the real
    world.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在*方向光*中，所有光线都是平行的并且均匀投射，以相同的方式照亮场景中的所有物体。这就像现实世界中的太阳一样。
- en: The position of a directional light doesn’t affect the light cast from it, only
    the direction the light source is facing, so technically, you could place that
    light anywhere in the scene. I recommend placing the directional light high above
    the room so that it intuitively feels like the sun and so that it’s out of the
    way when you’re manipulating the rest of the scene. Rotate this light and watch
    the effect on the room; I recommend rotating it slightly on both the x- and y-axes
    to get a good effect.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 方向光的位子不会影响从它发出的光，只会影响光源面对的方向，所以从技术上讲，你可以在场景的任何地方放置那个光。我建议将方向光放置在房间上方较高的位置，这样它就会直观地感觉像太阳，而且在你操作场景的其他部分时不会碍事。旋转这个光并观察它对房间的影响；我建议在x轴和y轴上稍微旋转以获得良好的效果。
- en: You will see an Intensity setting when you look in the Inspector (see figure
    2.8). As the name indicates, that setting controls the brightness of the light.
    If this were the only light, it’d have to be more intense, but because you’ll
    add a bunch of point lights as well, this directional light can be pretty dim—for
    example, 0.6 Intensity. This light should also have a slight yellow tinge, like
    the sun, while the other lights will be white.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在检查器中查看时，你会看到一个强度设置（见图2.8）。正如其名所示，该设置控制光的亮度。如果这是唯一的光源，它就必须更亮，但由于你还会添加许多点光源，这个方向光可以相当暗——例如，0.6强度。此光还应略带黄色调，就像太阳一样，而其他光源将是白色的。
- en: '![CH02_F08_Hocking3](../Images/CH02_F08_Hocking3.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F08_Hocking3](../Images/CH02_F08_Hocking3.png)'
- en: Figure 2.8 Directional light settings in the Inspector
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 检查器中的方向光设置
- en: As for point lights, create several by using the same menu and place them in
    dark spots around the room to make sure all the walls are lit. You don’t want
    too many, because performance can degrade if the game has lots of lights. Placing
    one near each corner should be fine (I suggest raising them to the tops of the
    walls), plus one placed high above the scene (for example, a Y position of 18)
    to give variety to the light in the room.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于点光源，使用相同的菜单创建几个，并将它们放置在房间周围的暗处，以确保所有墙壁都被照亮。你不希望太多，因为如果游戏中有许多光源，性能可能会下降。在每个角落放置一个应该就足够了（我建议将它们提升到墙壁的顶部），再加上一个放置在场景上方较高的位置（例如，Y位置为18），以给房间中的光线增加多样性。
- en: Note that point lights have a Range setting added to the Inspector (see figure
    2.9). This controls how far away the light reaches; whereas directional lights
    cast light evenly throughout the entire scene, point lights are brighter when
    an object is closer. The point lights closer to the floor should have a range
    of around 18, but the light placed high up should have a range of around 40 to
    reach the entire room. Set Intensity to 0.8 for the lights closer to the floor,
    while the high one is dim extra light to fill the space, at intensity 0.4.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，点光源在Inspector中添加了一个Range设置（见图2.9）。这控制了光能达到多远；而方向性光源在整个场景中均匀地投射光线，点光源在物体较近时更亮。靠近地板的点光源应该有大约18的范围，但放置在较高位置的光源应该有大约40的范围以照亮整个房间。将靠近地板的光源强度设置为0.8，而较高的光源则通过强度0.4减少额外光线以填充空间。
- en: '![CH02_F09_Hocking3](../Images/CH02_F09_Hocking3.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F09_Hocking3](../Images/CH02_F09_Hocking3.png)'
- en: Figure 2.9 Point light settings in the Inspector
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 Inspector中的点光源设置
- en: The other kind of object needed for the player to see the scene is a camera,
    but the “empty” scene came with a main camera, so you’ll use that. If you ever
    need to create new cameras (such as for split-screen views in multiplayer games),
    Camera is another choice in the same GameObject menu, like Cube and Lights. We
    will position the camera around the top of the player so that the view appears
    to be through the player’s eyes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家需要看到场景的另一种对象是相机，但“空”场景自带了一个主相机，所以你会使用它。如果你需要创建新的相机（例如，用于多人游戏中的分屏视图），Camera是同一GameObject菜单中的另一个选择，就像Cube和Lights一样。我们将相机定位在玩家的顶部周围，以便看起来是通过玩家的眼睛看到的。
- en: 2.2.3 The player’s collider and viewpoint
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 玩家的碰撞器和视点
- en: For this project, a simple primitive shape will do to represent the player.
    In the GameObject menu (remember, hover over 3D Object to expand the menu), click
    Capsule. Unity creates a cylindrical shape with rounded ends; this primitive shape
    will represent the player. Position this object at 1.1 on the y-axis (half the
    height of the object, plus a bit to avoid overlapping the floor). You can move
    the object along the x-axis and z-axis wherever you like, as long as it’s inside
    the room and not touching any walls. Name the object Player.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，用一个简单的原始形状来表示玩家就足够了。在GameObject菜单中（记住，将鼠标悬停在3D Object上以展开菜单），点击Capsule。Unity创建了一个两端圆润的圆柱形形状；这个原始形状将代表玩家。将此对象定位在y轴上的1.1处（对象高度的一半，再加上一点以避免与地板重叠）。你可以将对象沿x轴和z轴移动到任何你喜欢的地方，只要它在房间内且不接触任何墙壁。将对象命名为Player。
- en: In the Inspector, you’ll notice that this object has a capsule collider assigned
    to it. That’s a logical default choice for a capsule object, just as cube objects
    have a box collider by default. But this particular object will be the player
    and thus needs a slightly different sort of component than most objects. Remove
    the capsule collider by clicking the menu icon at the top right of that component,
    shown in figure 2.10; that will display a menu that includes the option Remove
    Component. The collider is a green mesh surrounding the object, so you’ll see
    the green mesh disappear after deleting the capsule collider.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在Inspector中，你会注意到这个对象被分配了一个胶囊碰撞器。对于一个胶囊对象来说，这是一个合理的默认选择，就像立方体对象默认有盒子碰撞器一样。但这个特定的对象将是玩家，因此需要比大多数对象稍微不同类型的组件。通过点击该组件右上角的菜单图标（如图2.10所示）来移除胶囊碰撞器；这将显示一个包括移除组件选项的菜单。碰撞器是一个围绕对象的绿色网格，因此删除胶囊碰撞器后，你会看到绿色网格消失。
- en: '![CH02_F10_Hocking3](../Images/CH02_F10_Hocking3.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F10_Hocking3](../Images/CH02_F10_Hocking3.png)'
- en: Figure 2.10 Removing a component in the Inspector
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 在Inspector中移除组件
- en: Instead of a capsule collider, we’re going to assign a *character controller*
    to this object. At the bottom of the Inspector is a button labeled Add Component;
    click that button to open a menu of components that you can add. In the Physics
    section of this menu, you’ll find Character Controller; select that option. As
    the name indicates, this component will allow the object to behave like a character.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不为这个对象分配胶囊碰撞器，而是分配一个 *角色控制器*。在检查器的底部有一个标有“添加组件”的按钮；点击该按钮以打开可以添加的组件菜单。在菜单的物理部分，您将找到角色控制器；选择该选项。正如其名称所示，此组件将允许对象像角色一样行为。
- en: 'You need to complete one last step to set up the player object: attaching the
    camera. As mentioned previously in section 2.2.1, objects can be dragged onto
    each other in the Hierarchy view. Drag the camera object onto the player capsule
    to attach the camera to the player. Now position the camera so that it’ll look
    like the player’s eyes (I suggest a Position of 0, 0.5, 0). If necessary, reset
    the camera’s Rotation to 0, 0, 0 (this will be off if you’ve rotated the capsule).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要完成最后一步来设置玩家对象：附加相机。如前文 2.2.1 节所述，对象可以在层次结构视图中相互拖动。将相机对象拖动到玩家胶囊上，以将相机附加到玩家。现在调整相机位置，使其看起来像玩家的眼睛（我建议位置为
    0, 0.5, 0）。如有必要，将相机的旋转重置为 0, 0, 0（如果已经旋转了胶囊，这将不适用）。
- en: You’ve created all the objects needed for this scene. What remains is writing
    code to move the player object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经创建了此场景所需的所有对象。剩下的是编写代码来移动玩家对象。
- en: '2.3 Make things move: A script that applies transforms'
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 使事物移动：应用变换的脚本
- en: To have the player walk around the scene, you’ll write movement scripts attached
    to the player. Remember, components are modular bits of functionality that you
    add to objects, and scripts are a kind of component. Eventually, those scripts
    will respond to keyboard and mouse input, but first you’ll make the player spin
    in place.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要让玩家在场景中行走，您将编写附加到玩家的移动脚本。记住，组件是添加到对象的功能模块，而脚本是一种组件。最终，这些脚本将响应键盘和鼠标输入，但首先您将使玩家原地旋转。
- en: This modest beginning will teach you how to apply transforms in code. Remember
    that the three transforms are Translate, Rotate, and Scale; spinning an object
    means changing the rotation. But there’s more to know about this task than only
    “this involves rotation.”
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的开始将教会您如何在代码中应用变换。记住，三个变换是平移、旋转和缩放；旋转对象意味着改变旋转。但关于这个任务，除了“这涉及到旋转”之外，还有更多需要了解的。
- en: 2.3.1 Visualizing how movement is programmed
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 可视化运动的编程方式
- en: Animating an object (such as making it spin) boils down to moving it a small
    amount every frame, with the frames playing over and over. By themselves, transforms
    apply instantly, as opposed to visibly moving over time. But applying the transforms
    over and over causes the object to appear to visibly move, like a series of still
    drawings in a flip-book. Figure 2.11 illustrates how this works.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对象动画（如使其旋转）归结为每帧移动一小量，帧不断播放。单独的变换会立即应用，而不是在一段时间内可见地移动。但重复应用变换会使对象看起来像一系列静止的图画在翻书一样可见地移动。图
    2.11 说明了这是如何工作的。
- en: '![CH02_F11_Hocking3](../Images/CH02_F11_Hocking3.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F11_Hocking3](../Images/CH02_F11_Hocking3.png)'
- en: 'Figure 2.11 The appearance of movement: a cyclical process of transforming
    between still pictures'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 运动的外观：在静止图片之间转换的循环过程
- en: Recall that script components have an Update() method that runs every frame.
    To spin the cube, add code inside Update() that rotates the cube a small amount.
    This code will run over and over every frame. Sounds pretty simple, right?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，脚本组件有一个 Update() 方法，该方法每帧运行一次。要旋转立方体，请在 Update() 内添加旋转立方体一小量的代码。此代码将每帧重复运行。听起来很简单，对吧？
- en: 2.3.2 Writing code to implement the diagram
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 编写代码以实现图示
- en: Now let’s put into action the concepts we’ve just discussed. Create a new C#
    script (remember, from the Assets menu, open the Create submenu), name it Spin,
    and write in this code (don’t forget to save the file after typing in it!).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将刚刚讨论的概念付诸实践。创建一个新的 C# 脚本（记住，从“资产”菜单打开“创建”子菜单），命名为 Spin，并编写以下代码（在输入后不要忘记保存文件！）。
- en: Listing 2.1 Making the object spin
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 使对象旋转
- en: '[PRE0]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Pull Unity’s classes into this script.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 Unity 的类拉入此脚本。
- en: ❷ Declare a public variable for the speed of rotation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 声明一个用于旋转速度的公共变量。
- en: ❸ Put the Rotate command here so that it runs every frame.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将旋转命令放在这里，使其每帧运行。
- en: To add the script component to the player object, drag the script up from the
    Project view and drop it onto Player in the Hierarchy view. Now click Play, and
    you’ll see the view spin around; you’ve written code to make an object move! This
    code is pretty much the default template for a new script plus two new added lines,
    so let’s examine what those two lines do.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要将脚本组件添加到玩家对象，从项目视图拖动脚本并将其拖放到层次结构视图中的 Player 上。现在点击播放，你会看到视图旋转；你已经编写了使对象移动的代码！这段代码基本上是新的脚本模板加上两行新添加的代码，所以让我们看看这两行代码做了什么。
- en: First, we’ve added the variable for speed toward the top of the class definition
    (the f after the number tells the computer to treat this as a float value; otherwise,
    C# treats decimal numbers as a double). The rotation speed is defined as a variable
    rather than a constant because Unity does something handy with public variables
    in script components, as described in the following tip.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在类定义的顶部添加了速度变量（数字后面的 f 告诉计算机将其视为浮点值；否则，C# 将十进制数字视为双精度浮点数）。旋转速度被定义为变量而不是常量，因为
    Unity 在脚本组件中对公共变量做了一些方便的处理，如下面的提示所述。
- en: TIP Public variables are exposed in the Inspector so that you can adjust the
    component’s values after adding a component to a game object. This is referred
    to as *serializing* the value, because Unity saves the modified state of the variable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：公共变量在 Inspector 中暴露，以便在将组件添加到游戏对象后调整组件的值。这被称为 *序列化* 值，因为 Unity 保存了变量的修改状态。
- en: Figure 2.12 shows what the component in the Inspector looks like when you select
    the Player object. You can type in a new number, and then the script will use
    that value instead of the default value defined in the code. This is a handy way
    to adjust settings for the component on different objects, working within the
    visual editor instead of hardcoding every value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 展示了在选中 Player 对象时，Inspector 中组件的外观。你可以输入一个新的数字，然后脚本将使用该值而不是代码中定义的默认值。这是一种方便的方法，可以在视觉编辑器中调整不同对象的组件设置，而不是硬编码每个值。
- en: '![CH02_F12_Hocking3](../Images/CH02_F12_Hocking3.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F12_Hocking3](../Images/CH02_F12_Hocking3.png)'
- en: Figure 2.12 The Inspector displaying a public variable declared in the script
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 Inspector 显示脚本中声明的公共变量
- en: The second line to examine from listing 2.1 is the Rotate() method. That’s inside
    Update() so that the command runs every frame. Rotate() is a method of the Transform
    class, so it’s called with dot notation through the transform component of this
    object (as in most object-oriented languages, this.transform is implied if you
    type just transform). The transform is rotated by speed degrees every frame, resulting
    in a smooth spinning movement. But why are the parameters to Rotate() listed as
    (0, speed, 0) as opposed to, say, (speed, 0, 0)?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表 2.1 中检查的第二行是 Rotate() 方法。它在 Update() 内部，因此命令会每帧运行。Rotate() 是 Transform 类的一个方法，因此通过该对象的
    transform 组件（如大多数面向对象的语言，如果你只输入 transform，则隐含 this.transform）使用点符号调用。transform
    每帧旋转速度度数，从而产生平滑的旋转运动。但为什么 Rotate() 的参数被列为 (0, speed, 0) 而不是，比如说，(speed, 0, 0)？
- en: 'Recall that three axes exist in 3D space, labeled x, y, and z. Understanding
    how these axes relate to positions and movements is fairly intuitive, but these
    axes can also be used to describe rotations. Aeronautics describes rotations in
    a similar way, so programmers working with 3D graphics often use a set of terms
    borrowed from aeronautics: pitch, yaw, and roll. Figure 2.13 illustrates what
    these terms mean: *pitch* is rotation around the x-axis, *yaw* is rotation around
    the y-axis, and *roll* is rotation around the z-axis.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在三维空间中存在三个轴，分别标记为 x、y 和 z。理解这些轴与位置和运动的关系相对直观，但这些轴也可以用来描述旋转。航空学以类似的方式描述旋转，因此处理三维图形的程序员经常使用从航空学借来的术语：俯仰、偏航和滚转。图
    2.13 展示了这些术语的含义：*俯仰*是围绕 x 轴的旋转，*偏航*是围绕 y 轴的旋转，而*滚转*是围绕 z 轴的旋转。
- en: '![CH02_F13_Hocking3](../Images/CH02_F13_Hocking3.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F13_Hocking3](../Images/CH02_F13_Hocking3.png)'
- en: Figure 2.13 Illustration of pitch, yaw, and roll rotation of an aircraft
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 飞机俯仰、偏航和滚转旋转的示意图
- en: Given that we can describe rotations around the x-, y-, and z-axes, that means
    the three parameters for Rotate() are X, Y, and Z rotation. Because we want the
    player to only spin around sideways, as opposed to tilting up and down, a number
    should be given for only the Y rotation, and 0 for X and Z rotation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们可以描述围绕x、y和z轴的旋转，这意味着Rotate()方法的三个参数是X、Y和Z旋转。因为我们想让玩家只围绕侧面旋转，而不是上下倾斜，所以应该只给出Y旋转的数值，而X和Z旋转为0。
- en: Hopefully, you can guess what will happen if you change the parameters to (speed,
    0, 0) and then play the scene. Try that now! Next, you need to understand one
    other subtle point about rotations and 3D coordinate axes, embodied in an optional
    fourth parameter to the Rotate() method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能猜到如果你将参数更改为(speed, 0, 0)并播放场景会发生什么。现在就试试！接下来，你需要理解关于旋转和3D坐标轴的另一个微妙之处，体现在Rotate()方法的可选第四个参数中。
- en: 2.3.3 Understanding local vs. global coordinate space
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 理解局部与全局坐标空间
- en: 'By default, the Rotate() method operates on local coordinates. The other kind
    of coordinates you could use are global. You tell the method whether to use local
    or global coordinates by using an optional fourth parameter and writing either
    Space.Self or Space.World, like so: Rotate(0, speed, 0, Space.World).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Rotate()方法作用于局部坐标。你可以使用的另一种坐标是全局坐标。你通过使用可选的第四个参数并写入Space.Self或Space.World来告诉方法是否使用局部或全局坐标，如下所示：Rotate(0,
    speed, 0, Space.World)。
- en: 'Refer to the explanation about 3D coordinate space in section 2.1.2 and ponder
    these questions: Where is (0, 0, 0) located? Which direction is the x-axis pointing
    in? Can the coordinate system itself move around?'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 参考第2.1.2节中关于3D坐标空间的解释，并思考这些问题：原点(0, 0, 0)在哪里？x轴指向哪个方向？坐标系本身可以移动吗？
- en: It turns out that every single object has its own origin point, as well as its
    own direction for the three axes, and this coordinate system moves around with
    the object. This is referred to as *local coordinates*. The overall 3D scene also
    has its own origin point and its own direction for the three axes, and this coordinate
    system never moves. This is referred to as *global coordinates*. Therefore, when
    you specify local or global for the Rotate() method, you’re telling it whose x-,
    y-, and z-axes to rotate around (see figure 2.14).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，每个对象都有自己的原点，以及三个轴的方向，这个坐标系随着对象移动。这被称为*局部坐标*。整个3D场景也有自己的原点和三个轴的方向，这个坐标系永远不会移动。这被称为*全局坐标*。因此，当你指定局部或全局给Rotate()方法时，你是在告诉它围绕哪个对象的x、y和z轴旋转（见图2.14）。
- en: '![CH02_F14_Hocking3](../Images/CH02_F14_Hocking3.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F14_Hocking3](../Images/CH02_F14_Hocking3.png)'
- en: Figure 2.14 Local versus global coordinate axes
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 局部与全局坐标轴
- en: If you’re new to 3D graphics, this is somewhat of a mind-bending concept. The
    different axes are depicted in figure 2.14 (notice how “left” to the plane is
    a different direction than “left” to the world), but the easiest way to understand
    local and global is through an example.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触3D图形，这个概念可能会让你感到困惑。不同的轴在图2.14中有所表示（注意平面的“左”方向与世界的“左”方向是不同的），但理解局部和全局最简单的方法是通过一个例子。
- en: Select the player object and then tilt it a bit (something like 30 for the X
    rotation). This will throw off the local coordinates so that local and global
    rotations look different. Now try running the Spin script both with and without
    Space.World added to the parameters. If it’s too hard for you to visualize what’s
    happening, try removing the spin component from the player object and instead
    spin a tilted cube placed in front of the player. You’ll see the object rotating
    around different axes when you set the command to local or global coordinates.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 选择玩家对象，然后稍微倾斜一下（比如X旋转的30度）。这将使局部坐标发生变化，使得局部和全局旋转看起来不同。现在尝试运行带有和没有添加Space.World到参数中的Spin脚本。如果你觉得难以可视化正在发生的事情，尝试从玩家对象中移除旋转组件，并代替旋转一个放置在玩家前面的倾斜的立方体。当你将命令设置为局部或全局坐标时，你会看到物体围绕不同的轴旋转。
- en: '2.4 Script component for looking around: MouseLook'
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 用于环顾四周的脚本组件：MouseLook
- en: Now you’ll make rotation respond to input from the mouse (that is, rotation
    of the object this script is attached to, which in this case will be the player).
    You’ll do this in several steps, progressively adding new movement abilities to
    the character. First, the player will rotate only side to side, and then the player
    will rotate only up and down. Eventually, the player will be able to look around
    in all directions (rotating horizontally and vertically at the same time), a behavior
    referred to as *mouse-look*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将使旋转响应鼠标输入（即，此脚本附加到的对象的旋转，在这种情况下将是玩家）。你将通过几个步骤来完成，逐步为角色添加新的移动能力。首先，玩家将只能左右旋转，然后玩家将只能上下旋转。最终，玩家将能够向所有方向看（同时水平垂直旋转），这种行为被称为
    *鼠标查看*。
- en: Given that we will use three types of rotation behavior (horizontal, vertical,
    and both), you’ll start by writing the framework for supporting all three. Create
    a new C# script, name it MouseLook, and write in this code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用三种类型的旋转行为（水平、垂直和两者），你将首先编写支持所有三种行为的框架。创建一个新的C#脚本，命名为MouseLook，并编写以下代码。
- en: Listing 2.2 MouseLook framework with enum for the Rotation setting
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2 带有枚举旋转设置的MouseLook框架
- en: '[PRE1]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Define an enum data structure to associate names with settings.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义一个枚举数据结构，将名称与设置关联起来。
- en: ❷ Declare a public variable to set in Unity’s editor.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在Unity的编辑器中声明一个公共变量来设置。
- en: ❸ Put code here for horizontal rotation only.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 仅在此处放置水平旋转的代码。
- en: ❹ Put code here for vertical rotation only.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 仅在此处放置垂直旋转的代码。
- en: ❺ Put code here for both horizontal and vertical rotation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在这里放置水平和垂直旋转的代码。
- en: Notice that an enum is used to choose horizontal or vertical rotation for the
    MouseLook script. Defining an enum data structure allows you to set values by
    name, rather than typing in numbers and trying to remember what each number means
    (is 0 horizontal rotation? Is it 1?). If you then declare a public variable typed
    to that enum, it will display in the Inspector as a drop-down menu (see figure
    2.15), which is useful for selecting settings.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在MouseLook脚本中使用枚举来选择水平或垂直旋转。定义枚举数据结构允许你通过名称设置值，而不是输入数字并试图记住每个数字的含义（0是水平旋转吗？是1吗？）。如果你声明一个类型为该枚举的公共变量，它将在检查器中显示为下拉菜单（见图2.15），这对于选择设置非常有用。
- en: '![CH02_F15_Hocking3](../Images/CH02_F15_Hocking3.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F15_Hocking3](../Images/CH02_F15_Hocking3.png)'
- en: Figure 2.15 The Inspector displays public enum variables as a drop-down menu.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 检查器显示公共枚举变量为下拉菜单。
- en: Remove the Spin component (the same way you removed the player’s capsule earlier,
    using the menu at the top right) and attach this new script to the player object
    instead. Use the Axes drop-down menu in the Inspector to switch the direction
    of rotation. With the horizontal/vertical rotation setting in place, you can fill
    in code for each branch of the conditional statement.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 移除旋转组件（与之前移除玩家胶囊的方式相同，使用右上角的菜单），然后将此新脚本附加到玩家对象上。使用检查器中的轴下拉菜单切换旋转方向。在设置好水平/垂直旋转设置后，你可以为条件语句的每个分支填写代码。
- en: WARNING Make sure to stop the game before changing the menu setting for this
    axis. Unity allows you to edit the Inspector during the game (to test settings
    changes) but then reverts the change after you stop the game.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：在更改此轴的菜单设置之前，请确保停止游戏。Unity允许你在游戏过程中编辑检查器（以测试设置更改），但在停止游戏后，它会撤销更改。
- en: Namespaces
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: '*Namespaces* are an optional programming construct used to organize the code
    in a project. Because namespaces are not mandatory, they are omitted from both
    the script files created by Unity and this book’s sample projects. In fact, if
    you aren’t already familiar with namespaces, you may wish to skip this discussion
    for now.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*命名空间* 是一个可选的编程结构，用于在项目中组织代码。因为命名空间不是强制的，所以它们被省略了，既包括Unity创建的脚本文件，也包括这本书的示例项目。实际上，如果你还不熟悉命名空间，你可能希望暂时跳过这个讨论。'
- en: While this book’s sample code doesn’t use namespaces, you should strongly consider
    using them in your own projects, as that will establish clearer organization in
    a large codebase. Namespaces contain related classes and interfaces, and putting
    classes into namespaces solves the problem of naming conflicts. Two classes can
    have the same name if they are in different namespaces.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这本书的示例代码没有使用命名空间，但你应该强烈考虑在自己的项目中使用它们，因为这样会在大型代码库中建立更清晰的组织结构。命名空间包含相关的类和接口，将类放入命名空间可以解决命名冲突的问题。如果两个类在不同的命名空间中，它们可以拥有相同的名称。
- en: 'To put a class into a namespace, enclose it inside curly braces like so:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个类放入命名空间中，将其放在大括号内，如下所示：
- en: '[PRE2]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To then access that class in other code (for example, with the GetComponent
    statement introduced in the next section), either that other code must also be
    in the same namespace or you add a statement such as using UnityInAction; to the
    code. And namespaces don’t interfere with script components, so you can still
    use that class in Unity’s editor without trouble.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要在其他代码（例如，使用下一节中引入的 GetComponent 语句）中访问该类，要么其他代码也必须在同一命名空间中，或者你需要在代码中添加一个如 using
    UnityInAction; 的语句。并且命名空间不会干扰脚本组件，所以你仍然可以在 Unity 的编辑器中无障碍地使用该类。
- en: 2.4.1 Horizontal rotation that tracks mouse movement
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 跟随鼠标移动的水平旋转
- en: The first and simplest branch is for horizontal rotation. Start by writing the
    same rotation command you used in listing 2.1 to make the object spin. Don’t forget
    to declare a public variable for the rotation speed; declare the new variable
    after axes but before Update(), and call the variable sensitivityHor because speed
    is too generic a name after you have multiple rotations involved. Increase the
    value of the variable to 9 this time, because that value needs to be bigger for
    the code written over the next couple of listings. The adjusted code should look
    like this listing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个也是最简单的分支是用于水平旋转。首先，编写与列表 2.1 中相同的旋转命令，使对象旋转。别忘了声明一个用于旋转速度的公共变量；在 axes 之后但在
    Update() 之前声明新变量，并将其命名为 sensitivityHor，因为在你涉及多个旋转之后，speed 这个名字太泛了。这次将变量的值增加到 9，因为接下来的几个列表中的代码需要更大的值。调整后的代码应如下所示。
- en: Listing 2.3 Horizontal rotation, not yet responding to the mouse
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 水平旋转，尚未响应鼠标
- en: '[PRE3]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Italicized code was already in script; it’s shown here for reference.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 已在脚本中斜体化的代码；这里展示是为了参考。
- en: ❷ Declare a variable for the speed of rotation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 声明一个用于旋转速度的变量。
- en: ❸ Put the Rotate command here so that it runs every frame.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 Rotate 命令放在这里，以便每帧运行。
- en: 'Set the Axes menu of the MouseLook component to horizontal rotation and play
    the script; the view will spin as before. The next step is to make the rotation
    react to mouse movement, so let’s introduce a new method: Input.GetAxis(). The
    Input class has a bunch of methods for handling input devices (such as the mouse),
    and the GetAxis() method returns numbers correlated to the movement of the mouse
    (positive 1 to -1, depending on the direction of movement). GetAxis() takes the
    name of the axis desired as a parameter, and the horizontal axis is called Mouse
    X.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 将 MouseLook 组件的 Axes 菜单设置为水平旋转并播放脚本；视图将像之前一样旋转。下一步是使旋转响应鼠标移动，因此让我们介绍一个新的方法：Input.GetAxis()。Input
    类有一系列用于处理输入设备（如鼠标）的方法，GetAxis() 方法返回与鼠标移动相关的数字（正 1 到 -1，取决于移动方向）。GetAxis() 方法接受所需轴的名称作为参数，水平轴称为
    Mouse X。
- en: If you multiply the rotation speed by the axis value, the rotation will respond
    to mouse movement. The speed will scale according to mouse movement, scaling down
    to zero or even reversing direction. The Rotate command now looks like the following
    listing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将旋转速度乘以轴值，旋转将响应鼠标移动。速度将根据鼠标移动进行缩放，缩小到零甚至反向。现在，Rotate 命令看起来如下所示。
- en: Listing 2.4 Rotate command adjusted to respond to the mouse
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 调整后的 Rotate 命令以响应鼠标
- en: '[PRE4]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Note the use of GetAxis() to get mouse input.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注意使用 GetAxis() 获取鼠标输入。
- en: WARNING Make sure to type a space in Mouse X. The axis names for this command
    are defined by Unity, not the axis names from our code. Typing MouseX for this
    axis is a common mistake.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：确保在 Mouse X 中输入一个空格。此命令的轴名称由 Unity 定义，而不是我们代码中的轴名称。为此轴输入 MouseX 是一个常见的错误。
- en: Click Play and then move the mouse around. As you move the mouse from side to
    side, the view will rotate from side to side. That’s pretty cool! The next step
    is to rotate vertically instead of horizontally.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 点击播放，然后移动鼠标。当你从一侧移动鼠标到另一侧时，视图将从一侧旋转到另一侧。这非常酷！下一步是将旋转改为垂直而不是水平。
- en: 2.4.2 Vertical rotation with limits
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 带限制的垂直旋转
- en: For horizontal rotation, we’ve been using the Rotate() method, but we’ll take
    a different approach with vertical rotation. Although that method is convenient
    for applying transforms, it’s also kind of inflexible. It’s useful only for incrementing
    the rotation without limit, which was fine for horizontal rotation, but vertical
    rotation needs limits on how much the view can tilt up or down. This listing shows
    the vertical rotation code for MouseLook; a detailed explanation of the code will
    immediately follow.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于水平旋转，我们一直使用Rotate()方法，但对于垂直旋转，我们将采取不同的方法。虽然该方法适用于应用变换，但它也有些不灵活。它只适用于无限制地增加旋转，这对于水平旋转来说是可行的，但垂直旋转需要限制视图可以倾斜的上限和下限。此列表显示了MouseLook的垂直旋转代码；代码的详细解释将立即跟随。
- en: Listing 2.5 Vertical rotation for MouseLook
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5 MouseLook的垂直旋转
- en: '[PRE5]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Declare variables used for vertical rotation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 声明用于垂直旋转的变量。
- en: ❷ Declare a private variable for the vertical angle.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 声明一个用于垂直角度的私有变量。
- en: ❸ Increment the vertical angle based on the mouse.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 根据鼠标移动来增加垂直角度。
- en: ❹ Clamp the vertical angle between minimum and maximum limits.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将垂直角度限制在最小和最大限制之间。
- en: ❺ Keep the same Y angle (i.e., no horizontal rotation).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 保持相同的Y角度（即，没有水平旋转）。
- en: ❻ Create a new vector from the stored rotation values.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 从存储的旋转值创建一个新的向量。
- en: Set the Axes menu of the MouseLook component to vertical rotation and play the
    new script. Now the view won’t rotate sideways but will tilt up and down when
    you move the mouse up and down. The tilt stops at upper and lower limits.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将MouseLook组件的Axes菜单设置为垂直旋转并播放新脚本。现在，当你上下移动鼠标时，视图不会左右旋转，而是会上下倾斜。倾斜会在上下极限处停止。
- en: 'This code introduces several new concepts that need to be explained. First
    off, we’re not using Rotate() this time, so we need a variable in which to store
    the rotation angle (this variable is called verticalRot here, and remember that
    vertical rotation goes around the x-axis). The Rotate() method increments the
    current rotation, whereas this code sets the rotation angle directly. It’s the
    difference between saying “add 5 to the angle” and “set the angle to 30.” We do
    still need to increment the rotation angle, but that’s why the code has the -=
    operator: to subtract a value from the rotation angle, rather than set the angle
    to that value. By not using Rotate(), we can manipulate the rotation angle in
    various ways aside from only incrementing it. The rotation value is multiplied
    by Input.GetAxis(), as in the code for horizontal rotation, except now we ask
    for Mouse Y because that’s the vertical axis of the mouse.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码引入了几个需要解释的新概念。首先，这次我们没有使用Rotate()方法，因此需要一个变量来存储旋转角度（这个变量在这里称为verticalRot，并记住垂直旋转是围绕x轴进行的）。Rotate()方法增加当前旋转，而此代码直接设置旋转角度。这区别于说“将角度增加5”和“将角度设置为30”。我们仍然需要增加旋转角度，这就是为什么代码中有
    -= 运算符：从旋转角度中减去一个值，而不是将角度设置为那个值。不使用Rotate()，我们可以以各种方式操作旋转角度，而不仅仅是增加它。旋转值乘以Input.GetAxis()，就像水平旋转的代码一样，但现在我们请求Mouse
    Y，因为那是鼠标的垂直轴。
- en: The rotation angle is manipulated further on the next line. We use Mathf.Clamp()
    to keep the rotation angle between minimum and maximum limits. Those limits are
    public variables declared earlier in the code, and they ensure that the view can
    tilt only 45 degrees up or down. The Clamp() method isn’t specific to rotation
    but is generally useful for keeping a number variable between limits. To see what
    happens, try commenting out the Clamp() line; now the tilt doesn’t stop at upper
    and lower limits, allowing you to even rotate completely upside down! Clearly,
    viewing the world upside down is undesirable, hence the limits.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行进一步操作旋转角度。我们使用Mathf.Clamp()来保持旋转角度在最小和最大限制之间。这些限制是在代码中较早声明的公共变量，并确保视图只能倾斜45度上下。Clamp()方法不仅限于旋转，但通常对于保持数字变量在限制之间非常有用。为了看看会发生什么，尝试注释掉Clamp()行；现在倾斜不会在上下极限处停止，甚至允许你完全颠倒旋转！显然，颠倒观看世界是不理想的，这就是为什么有这些限制。
- en: Because the angles property of transform is a Vector3, we need to create a new
    Vector3 with the rotation angle passed in to the constructor. The Rotate() method
    was automating this process for us, incrementing the rotation angle and then creating
    a new vector.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因为transform的角度属性是一个Vector3，我们需要创建一个新的Vector3，将旋转角度传递给构造函数。Rotate()方法为我们自动化了这个过程，增加旋转角度然后创建一个新的向量。
- en: DEFINITION A *vector* is multiple numbers stored together as a unit. For example,
    a Vector3 is three numbers (labeled x, y, z).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义** 一个**向量**是存储在一起作为一个单元的多个数字。例如，一个Vector3是三个数字（标记为x、y、z）。'
- en: WARNING The reason we need to create a new Vector3 instead of changing values
    in the existing vector in the transform is that those values are read-only for
    transforms. This is a common mistake that can trip you up.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告** 我们需要创建一个新的Vector3而不是在变换中更改现有向量的值，因为这些值对于变换来说是只读的。这是一个常见的错误，可能会让你陷入困境。'
- en: Euler angles vs. quaternion
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉角与四元数
- en: You’re probably wondering why the property is called localEulerAngles and not
    localRotation. First, you need to know about quaternions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么属性被称为localEulerAngles而不是localRotation。首先，你需要了解四元数。
- en: '*Quaternions* are another mathematical construct for representing rotations.
    They’re distinct from Euler angles, which is the name for the x-, y-, z-axes approach
    we’ve been taking. Remember the whole discussion of pitch, yaw, and roll? Well,
    that method of representing rotations uses Euler angles. Quaternions are . . .
    different. It’s hard to explain quaternions, because they’re an obscure aspect
    of higher math, involving movement through four dimensions. For a detailed explanation,
    try “Using Quaternion to Perform 3D Rotations” on the Cprogramming.com website
    ([http:// mng.bz/xX0B](https://shortener.manning.com/xX0B)).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**四元数**是另一种表示旋转的数学结构。它们与欧拉角不同，欧拉角是我们一直采用的x、y、z轴方法的名字。还记得关于俯仰、偏航和滚转的整个讨论吗？嗯，那种表示旋转的方法使用的是欧拉角。四元数是……不同的。解释四元数很难，因为它们是高等数学中一个晦涩的方面，涉及通过四个维度的运动。要获得详细解释，请尝试访问Cprogramming.com网站上的“使用四元数执行3D旋转”（[http://
    mng.bz/xX0B](https://shortener.manning.com/xX0B)）。'
- en: 'It’s a bit easier to explain why quaternions are used to represent rotations:
    interpolating between rotation values (going through a bunch of in-between values
    to gradually change from one value to another) looks smoother and more natural
    when using quaternions.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 解释为什么使用四元数来表示旋转要容易一些：在旋转值之间进行插值（通过一系列中间值逐渐从一个值变为另一个值）在使用四元数时看起来更平滑、更自然。
- en: To return to the initial question, we use localEulerAngles because localRotation
    is a quaternion, rather than Euler angles. Unity also provides the Euler angles
    property to make manipulating rotations easier to understand; the Euler angles
    property is converted to and from quaternion values automatically. Unity handles
    the harder math for you behind the scenes, so you don’t have to worry about handling
    it yourself.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 回到最初的问题，我们使用localEulerAngles，因为localRotation是一个四元数，而不是欧拉角。Unity还提供了一个欧拉角属性，使操作旋转更容易理解；欧拉角属性会自动转换为四元数值。Unity在幕后处理更复杂的数学，所以你不必担心自己处理。
- en: 'One more rotation setting for MouseLook needs code: horizontal and vertical
    rotation at the same time.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更多的代码来设置MouseLook的一个旋转：同时进行水平和垂直旋转。
- en: 2.4.3 Horizontal and vertical rotation at the same time
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 同时进行水平和垂直旋转
- en: 'This last chunk of code won’t use Rotate() either, for the same reason: the
    vertical rotation angle is clamped between limits after being incremented. That
    means the horizontal rotation needs to be calculated directly now. Remember, Rotate()
    was automating the process of incrementing the rotation angle, shown here.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这段最后的代码也不会使用Rotate()，原因相同：垂直旋转角度在增加后会被限制在一定的范围内。这意味着现在需要直接计算水平旋转。记住，Rotate()是自动增加旋转角度的过程，如下所示。
- en: Listing 2.6 Horizontal and vertical MouseLook
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.6 水平和垂直MouseLook
- en: '[PRE6]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ delta is the amount to change the rotation by.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ delta是旋转改变的量。
- en: ❷ Increment the rotation angle by delta.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过delta增加旋转角度。
- en: The first couple of lines, dealing with verticalRot, are exactly the same as
    in listing 2.5\. Remember that rotating around the object’s x-axis is vertical
    rotation. Because horizontal rotation is no longer being handled using the Rotate()
    method, that’s what the delta and horizontalRot lines are doing. *Delta* is a
    common mathematical term for *the amount of change*, so our calculation of delta
    is the amount that rotation should change. That amount of change is then added
    to the current rotation angle to get the desired new rotation angle.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行，处理verticalRot的，与列表2.5中的完全相同。记住，围绕对象的x轴旋转是垂直旋转。因为水平旋转不再使用Rotate()方法处理，这就是delta和horizontalRot行所做的事情。“Delta”是表示**改变量**的常见数学术语，因此我们的delta计算是旋转应该改变的数量。然后，将这个改变量加到当前的旋转角度上，以得到期望的新旋转角度。
- en: Finally, both angles, vertical and horizontal, are used to create a new vector
    that’s assigned to the transform component’s angle property.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用这两个角度（垂直和水平）创建一个新的向量，并将其分配给变换组件的角度属性。
- en: Disallow physics rotation on the player
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 禁止玩家进行物理旋转
- en: Although this doesn’t matter quite yet for this project, most modern FPS games
    use a complex physics simulation affecting everything in the scene. This simulation
    causes objects to bounce and tumble around. Although this behavior looks and works
    great for most objects, the player’s rotation needs to be solely controlled by
    the mouse and not affected by the physics simulation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这对当前项目来说还不是很重要，但大多数现代第一人称射击游戏都使用一个复杂的物理模拟，影响场景中的所有对象。这个模拟导致对象弹跳和滚动。尽管这种行为对大多数对象来说看起来和效果都很好，但玩家的旋转需要完全由鼠标控制，而不受物理模拟的影响。
- en: 'For that reason, mouse input scripts usually set the freezeRotation property
    on the player’s Rigidbody. Add this Start() method to the MouseLook script:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，鼠标输入脚本通常会在玩家的Rigidbody上设置freezeRotation属性。将此Start()方法添加到MouseLook脚本中：
- en: '[PRE7]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ This component may not have been added, so check if it exists.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此组件可能尚未添加，请检查它是否存在。
- en: (A Rigidbody is an additional component an object can have. The physics simulation
    acts on Rigidbody components and manipulates objects they’re attached to.)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: （Rigidbody是对象可以拥有的附加组件。物理模拟作用于Rigidbody组件，并操纵它们所附加的对象。）
- en: In case you’ve gotten lost on where to make the various changes and additions
    we’ve gone over, this listing has the full finished script. Alternatively, download
    the example project.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在我们讨论的各种更改和添加的地方感到困惑，这个列表包含了完整的最终脚本。或者，下载示例项目。
- en: Listing 2.7 The finished MouseLook script
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.7 完成的MouseLook脚本
- en: '[PRE8]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When you set the Axes menu and run the new code, you’re able to look around
    in all directions while moving the mouse. Great! But you’re still stuck in one
    place, looking around as if mounted on a turret. The next step is moving around
    the scene.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设置轴菜单并运行新代码时，你可以在移动鼠标的同时向所有方向张望。太棒了！但你仍然被困在一个地方，就像被安装在炮塔上一样四处张望。下一步是移动到场景中。
- en: '2.5 Keyboard input component: First-person controls'
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 键盘输入组件：第一人称控制
- en: Looking around in response to mouse input is an important part of first-person
    controls, but you’re only halfway there. The player also needs to move in response
    to keyboard input. Let’s write a keyboard control component to complement the
    mouse control component; create a new C# script called FPSInput and attach that
    to the player (alongside the MouseLook script). For the moment, set the MouseLook
    component to horizontal rotation only.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 根据鼠标输入四处张望是第一人称控制的重要部分，但你只完成了一半。玩家还需要根据键盘输入进行移动。让我们编写一个键盘控制组件来补充鼠标控制组件；创建一个新的C#脚本名为FPSInput并将其附加到玩家（与MouseLook脚本一起）。目前，将MouseLook组件设置为仅水平旋转。
- en: TIP The keyboard and mouse controls explained here are split into separate scripts.
    You don’t have to structure the code this way and could have everything bundled
    into a single player control script. But a component system (such as the one in
    Unity) tends to be most flexible and therefore most useful when you have functionality
    split into several smaller components.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：这里解释的键盘和鼠标控制被分成单独的脚本。你不必以这种方式结构化代码，可以将所有内容打包到一个玩家控制脚本中。但组件系统（如Unity中的系统）在功能被分成几个较小的组件时，通常是最灵活的，因此也最有用。
- en: The code you wrote in the previous section affected rotation only, but now we’ll
    change the object’s position instead. Refer to listing 2.1; type that into FPSInput,
    but change Rotate() to Translate(). When you click Play, the view slides up instead
    of spinning around.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你在上一节中编写的代码只影响了旋转，但现在我们将改变对象的位置。参考列表2.1；将其输入FPSInput，但将Rotate()改为Translate()。当你点击播放时，视图会向上滑动而不是旋转。
- en: Try changing the parameter values to see how the movement changes (in particular,
    try swapping the first and second numbers). After experimenting with that for
    a bit, you can move on to adding keyboard input.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改参数值以查看运动如何改变（特别是尝试交换前两个数字）。在尝试了一段时间后，你可以继续添加键盘输入。
- en: Listing 2.8 Spin code from listing 2.1, with a couple of minor changes
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8 列表2.1中的旋转代码，经过一些小的修改
- en: '[PRE9]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ This will be too fast at first but will be corrected later.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始时可能会太快，但稍后会进行修正。
- en: ❷ Change Rotate() to Translate().
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将Rotate()改为Translate()。
- en: 2.5.1 Responding to keypresses
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 响应按键
- en: The code for moving according to keypresses is similar to the code for rotating
    according to the mouse. The GetAxis() method is used as well and in a similar
    way. This listing demonstrates how to use it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 根据按键移动的代码与根据鼠标旋转的代码类似。同样使用GetAxis()方法，并且以类似的方式使用。这个列表演示了如何使用它。
- en: Listing 2.9 Positional movement responding to keypresses
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.9 根据按键进行位置移动
- en: '[PRE10]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Horizontal and Vertical are indirect names for keyboard mappings.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 水平和垂直是键盘映射的间接名称。
- en: As before, the GetAxis() values are multiplied by speed to determine the amount
    of movement. Whereas before, the requested axis was always “Mouse something,”
    now we pass in either Horizontal or Vertical. These names are abstractions for
    input settings in Unity; if you look in the Edit menu under Project Settings and
    then look under Input Manager, you’ll find a list of abstract input names and
    the exact controls mapped to those names. Both the left and right arrow keys and
    the letters A and D are mapped to Horizontal, whereas both the up and down arrow
    keys and the letters W and S are mapped to Vertical.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，GetAxis()值乘以速度来确定移动量。之前，请求的轴总是“鼠标某个东西”，现在我们传递水平或垂直。这些名称是Unity中输入设置的抽象；如果你在项目设置下的编辑菜单中查看，然后在输入管理器下查看，你会找到一个抽象输入名称列表以及映射到这些名称的确切控制。左右箭头键和字母A和D都映射到水平，而上下箭头键和字母W和S都映射到垂直。
- en: Note that the movement values are applied to the x- and z-coordinates. As you
    probably noticed while experimenting with the Translate() method, the x-coordinate
    moves from side to side, and the z-coordinate moves forward and backward.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，移动值应用于x和z坐标。正如你可能在使用Translate()方法进行实验时注意到的，x坐标在左右移动，而z坐标向前和向后移动。
- en: Put in this new movement code and you should be able to move around by pressing
    either the arrow keys or W, A, S, and D letter keys, the standard in most FPS
    games. The movement script is nearly complete, but we have a few more adjustments
    to go over.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 输入新的移动代码后，你应该可以通过按箭头键或W、A、S、D字母键来移动，这是大多数FPS游戏中的标准。移动脚本几乎完成了，但我们还有一些调整需要讨论。
- en: 2.5.2 Setting a rate of movement independent of the computer’s speed
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 设置与电脑速度无关的移动速率
- en: It’s not obvious right now because you’ve been running the code on only one
    computer (yours), but if you ran the code on different machines, it’d run at different
    speeds. That’s because some computers can process code and graphics faster than
    others. Right now, the player would move at different speeds on different computers
    because the movement code is tied to the computer’s speed. That is referred to
    as *frame-rate dependent*, because the movement code is dependent on the frame
    rate of the game.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还不明显，因为你只是在你的电脑上运行代码，但如果你在不同的机器上运行代码，它们的运行速度会不同。这是因为一些电脑可以比其他电脑更快地处理代码和图形。目前，玩家在不同电脑上的移动速度会不同，因为移动代码与电脑的速度相关联。这被称为*帧率依赖性*，因为移动代码依赖于游戏的帧率。
- en: Imagine you run this demo on two computers, one that gets 30 frames per second
    (fps) and one that gets 60 fps. That means Update() would be called twice as often
    on the second computer, and the same speed value of 6 would be applied every time.
    At 30 fps, the rate of movement would be 180 units/second, and the movement at
    60 fps would be 360 units/second. For most games, movement speed that varies like
    this would be bad news.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你在两台电脑上运行这个演示，一台每秒30帧（fps），另一台每秒60帧。这意味着第二台电脑上的Update()会被调用两次，每次应用相同的速度值6。在30fps下，移动速度将是每秒180单位，而在60fps下的移动将是每秒360单位。对于大多数游戏来说，这种速度变化的移动是不好的消息。
- en: The solution is to adjust the movement code to make it *frame-rate independent*.
    This speed of movement is not dependent on the frame rate of the game. The way
    to achieve this is by not applying the same speed value at every frame rate. Instead,
    scale the speed value higher or lower depending on how quickly the computer runs.
    This is achieved by multiplying the speed value by another value called deltaTime.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是调整移动代码，使其*不依赖于帧率*。这种移动速度不依赖于游戏的帧率。实现这一点的方法是在每个帧率上不应用相同的速度值。相反，根据电脑的运行速度，将速度值放大或缩小。这是通过将速度值乘以另一个称为deltaTime的值来实现的。
- en: Listing 2.10 Frame-rate independent movement using deltaTime
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.10 使用deltaTime实现帧率无关的移动
- en: '[PRE11]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That was a simple change. The Time class has properties and methods that are
    useful for timing, and one of those properties is deltaTime. We know that *delta*
    means the amount of change, so that means deltaTime is the amount of change in
    time. Specifically, deltaTime is the amount of time between frames. The time between
    frames varies at different frame rates (for example, 30 fps has a deltaTime of
    1/30th of a second), so multiplying the speed value by deltaTime will scale the
    speed value on different computers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的更改。Time类具有用于计时的属性和方法，其中一个属性是deltaTime。我们知道*delta*意味着变化量，所以这意味着deltaTime是时间的变化量。具体来说，deltaTime是帧之间的时间量。帧之间的时间量在不同帧率下会有所不同（例如，30
    fps的deltaTime为1/30秒），所以将速度值乘以deltaTime将根据不同的计算机调整速度值。
- en: Now the movement speed will be the same on all computers. But the movement script
    is still not quite done. When you move around the room, you can pass through walls,
    so we need to adjust the code further to prevent that.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有计算机上的移动速度都将相同。但移动脚本仍然没有完成。当你四处移动时，你可以穿过墙壁，所以我们需要进一步调整代码以防止这种情况。
- en: 2.5.3 Moving the CharacterController for collision detection
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.3 为碰撞检测移动CharacterController
- en: Directly changing the object’s transform doesn’t apply collision detection,
    so the character will pass through walls. To apply collision detection, what we
    want to do instead is use CharacterController, a component that makes the object
    move more like a character in a game, including colliding with walls. Recall that,
    back when we set up the player, we attached a CharacterController, so now we’ll
    use that component with the movement code in FPSInput.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 直接更改对象的变换不应用碰撞检测，因此角色会穿过墙壁。为了应用碰撞检测，我们想要做的是使用CharacterController，这是一个使对象移动更像游戏中的角色的组件，包括与墙壁碰撞。回想一下，在我们设置玩家时，我们附加了一个CharacterController，所以现在我们将使用FPSInput中的移动代码来使用该组件。
- en: Listing 2.11 Moving CharacterController instead of Transform
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.11 替换Transform移动CharacterController
- en: '[PRE12]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Variable for referencing the CharacterController
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 参考CharacterController的变量
- en: ❷ Access other components attached to the same object.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 访问同一对象上附加的其他组件。
- en: ❸ Limit diagonal movement to the same speed as movement along an axis.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将对角线移动限制为与沿轴移动相同的速度。
- en: ❹ Transform the movement vector from local to global coordinates.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将移动向量从局部坐标转换为全局坐标。
- en: ❺ Tell the CharacterController to move by that vector.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 告诉CharacterController按该向量移动。
- en: This code excerpt introduces several new concepts. The first concept to point
    out is the variable for referencing the CharacterController. This variable creates
    a local reference to the object (code object, that is—not to be confused with
    scene objects); multiple scripts can have references to this one CharacterController
    instance.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段介绍了几个新概念。首先需要指出的是，用于引用CharacterController的变量。这个变量创建了对对象的本地引用（代码对象，即不要与场景对象混淆）；多个脚本可以引用这个CharacterController实例。
- en: That variable starts out empty, so before you can use the reference, you need
    to assign an object for it to refer to. This is where GetComponent() comes into
    play; that method returns other components attached to the same GameObject. Rather
    than passing a parameter inside the parentheses, you use the C# syntax of defining
    the type inside angle brackets, <>.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量最初是空的，所以在你可以使用引用之前，你需要为它分配一个对象。这就是GetComponent()发挥作用的地方；该方法返回附加到同一GameObject上的其他组件。而不是在括号内传递参数，你使用C#语法在尖括号<>内定义类型。
- en: Once you have a reference to the CharacterController, you can call Move() on
    the controller. Pass in a vector to that method, similar to the way the mouse
    rotation code used a vector for rotation values. Also, similar to the way rotation
    values were limited, use Vector3.ClampMagnitude() to limit the vector’s magnitude
    to the movement speed. The clamp is used because, otherwise, diagonal movement
    would have a greater magnitude than movement directly along an axis (picture the
    sides and hypotenuse of a right triangle).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了CharacterController的引用，你就可以在控制器上调用Move()方法。向该方法传递一个向量，类似于鼠标旋转代码使用向量作为旋转值的方式。同样，类似于限制旋转值的方式，使用Vector3.ClampMagnitude()来限制向量的长度到移动速度。使用限制是因为，否则，对角线移动的长度将大于沿轴直接移动的长度（想象一下直角三角形的边和斜边）。
- en: But there’s one tricky aspect to the movement vector here, and it has to do
    with local versus global, as we discussed earlier for rotations. We’ll create
    the vector with a value to move, say, to the left. That’s the *player’s* left,
    though, which may be a completely different direction from the *world’s* left—that
    is, we’re talking about left in local space, not global space.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里的移动向量有一个棘手的地方，这与局部和全局有关，正如我们之前在讨论旋转时提到的。我们将创建一个向量，其值用于向左移动，比如说。但这实际上是 *玩家*
    的左侧，然而，这可能与 *世界* 的左侧完全不同——也就是说，我们在这里讨论的是局部空间中的左侧，而不是全局空间。
- en: We need to pass a movement vector defined in global space to the Move() method,
    so we’re going to need to convert the local space vector into a global space vector.
    Doing that conversion is complex math, but fortunately for us, Unity takes care
    of that math for us, and we simply need to call the TransformDirection() method
    in order to, well, transform the direction.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将定义在全局空间中的移动向量传递给 Move() 方法，因此我们需要将局部空间向量转换为全局空间向量。这个转换过程涉及复杂的数学计算，但幸运的是，Unity
    已经为我们处理了这些数学问题，我们只需调用 TransformDirection() 方法即可，嗯，转换方向。
- en: DEFINITION *Transform* in this context means to convert from one coordinate
    space to another (refer to section 2.3.3 if you don’t remember what a coordinate
    space is). Don’t get confused with the other definitions of transform, including
    both the Transform component and the action of moving the object around the scene.
    It’s sort of an overloaded term, because all these meanings refer to the same
    underlying concept.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，*变换* 的定义是指从一个坐标系转换到另一个坐标系（如果你不记得坐标系是什么，请参考第 2.3.3 节）。不要与其他变换的定义混淆，包括
    Transform 组件和对象在场景中移动的动作。这是一个有点过载的术语，因为所有这些含义都指代同一个基本概念。
- en: Test playing the movement code now. If you haven’t done so already, set the
    MouseLook component to both horizontal and vertical rotation. You can look around
    the scene fully and fly around the scene by using keyboard controls. This is pretty
    great if you want the player to fly around the scene, but what if you want the
    player walking instead of flying?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试移动代码。如果你还没有这样做，将 MouseLook 组件设置为水平和垂直旋转。你可以完全环顾场景，并通过使用键盘控制来在场景中飞行。如果你想让玩家在场景中飞行，这非常棒，但如果你想让玩家行走而不是飞行怎么办？
- en: 2.5.4 Adjusting components for walking instead of flying
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.4 调整组件以实现行走而不是飞行
- en: Now that collision detection is working, the script can have gravity, and the
    player will stay down against the floor. Declare a gravity variable and use that
    value for the y-axis.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在碰撞检测已经生效，脚本可以包含重力，玩家将保持在地板上。声明一个重力变量，并使用该值作为 y 轴。
- en: Listing 2.12 Adding gravity to the movement code
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.12 向移动代码添加重力
- en: '[PRE13]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Use the gravity value instead of just 0.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用重力值而不是仅仅 0。
- en: Now there’s a constant downward force on the player, but it’s not always pointed
    straight down, because the player object can tilt up and down with the mouse.
    Fortunately, everything we need to fix that is already in place, so we need only
    to make minor adjustments to the way components are set up on the player. First,
    set the MouseLook component on the player object to horizontal rotation only.
    Add the MouseLook component to the camera object, and set that one to vertical
    rotation only. That’s right; you’re going to have two objects responding to the
    mouse!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家有一个恒定的向下力，但它并不总是指向正下方，因为玩家对象可以随着鼠标上下倾斜。幸运的是，我们需要的所有东西都已经就位，所以我们只需要对玩家上组件的设置进行一些小的调整。首先，将玩家对象上的
    MouseLook 组件设置为仅水平旋转。将 MouseLook 组件添加到相机对象上，并将该设置为仅垂直旋转。没错；你将有两个对象响应鼠标！
- en: Because the player object now only rotates horizontally, there’s no longer any
    problem with the downward force of gravity being tilted. The camera object is
    parented to the player object (remember when we did that in the Hierarchy view?),
    so even though the camera rotates vertically independently from the player, the
    camera rotates horizontally along with the player.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 因为玩家对象现在只进行水平旋转，所以重力向下的力不再倾斜。相机对象是玩家对象的子对象（记得我们在 Hierarchy 视图中做的那件事吗？），所以尽管相机垂直旋转独立于玩家，但相机在水平方向上与玩家一起旋转。
- en: Polishing the finished script
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 精炼完成的脚本
- en: Use the RequireComponent attribute to ensure that other components needed by
    the script are also attached. Sometimes other components are optional (that is,
    the code says, “If this other component is also attached, then . . . ”), but other
    times you want to make the other components mandatory. Add RequireComponent to
    the top of the script in order to enforce that dependency, and give the required
    component as a parameter inside parentheses.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RequireComponent属性来确保脚本需要的其他组件也被附加。有时其他组件是可选的（也就是说，代码中会说，“如果这个其他组件也被附加，那么……”），但有时你希望其他组件是强制性的。将RequireComponent添加到脚本的顶部以强制依赖，并在括号内提供所需的组件作为参数。
- en: 'Similarly, if you add the AddComponentMenu attribute to the top of your scripts,
    that script will be added to the component menu in Unity’s editor. Tell the attribute
    the name of the menu item you want to add, and then the script can be selected
    when you click Add Component at the bottom of the Inspector. Handy! A script with
    both attributes added to the top would look something like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你将AddComponentMenu属性添加到你的脚本顶部，那么该脚本将被添加到Unity编辑器的组件菜单中。告诉属性你想要添加的菜单项的名称，然后当你点击检查器底部的添加组件时，可以选择脚本。方便！同时添加了这两个属性的脚本看起来可能像这样：
- en: '[PRE14]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Listing 2.13 shows the full finished script. Along with the small adjustments
    to the way components are set up on the player, the player can walk around the
    room. Even with the gravity variable being applied, you can still use this script
    for flying movement by setting Gravity to 0 in the Inspector.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.13显示了完整的完成脚本。除了对玩家上组件设置的微小调整外，玩家可以在房间里四处走动。即使应用了重力变量，你仍然可以通过在检查器中将重力设置为0来使用此脚本进行飞行移动。
- en: Listing 2.13 The finished FPSInput script
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.13 完成的FPSInput脚本
- en: '[PRE15]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Congratulations on building this 3D project! We covered a lot of ground in this
    chapter, and now you’re well versed in how to code movement in Unity. As exciting
    as this first demo is, it’s still a long way from being a complete game. After
    all, the project plan described this as a basic FPS scene, and what’s a shooter
    if you can’t shoot? So give yourself a well-deserved pat on the back for this
    chapter’s project and then get ready for the next step.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你构建了这个3D项目！在本章中，我们涵盖了大量的内容，现在你对如何在Unity中编写移动代码已经非常熟悉。尽管这个第一个演示很令人兴奋，但它离成为一个完整的游戏还差得很远。毕竟，项目计划将这个描述为一个基本的FPS场景，如果你不能射击，那射击游戏又是什么呢？所以，为这一章的项目给自己一个应得的掌声，然后准备下一步。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 3D coordinate space is defined by x-, y-, and z-axes.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D坐标空间由x、y和z轴定义。
- en: Objects and lights in a room set the scene.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 房间中的物体和灯光设置场景。
- en: The player in a first-person scene is essentially a camera.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一人称场景中的玩家本质上是一个摄像头。
- en: Movement code applies small transforms repeatedly in every frame.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动代码在每个帧中重复应用小的变换。
- en: FPS controls consist of mouse rotation and keyboard movement.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FPS控制包括鼠标旋转和键盘移动。
