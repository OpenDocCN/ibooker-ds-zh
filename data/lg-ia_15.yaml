- en: 11 Logging frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 日志框架
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Examining characteristics of logging frameworks
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查日志框架的特性
- en: Selecting logging frameworks for use with apps
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序选择日志框架
- en: Calling Fluentd direct from logging frameworks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接从日志框架调用Fluentd
- en: Calling Fluentd from an app without a framework
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从没有框架的应用程序中调用Fluentd
- en: In the previous chapter, we looked at how we can create log events that can
    be used to give the most meaning and value. Another significant way we can easily
    derive more value from logs is by using logging frameworks for our application
    development. Most programming languages these days will be able to use a logging
    framework. In some cases, the third-party ones predate the language native feature
    and become something of a de facto standard. Other logging frameworks have come
    as part of an application container or platform to address weaknesses perceived
    or proven in the native solutions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了如何创建具有最大意义和价值的日志事件。我们还可以通过使用日志框架来轻松地从日志中获取更多价值。如今，大多数编程语言都能够使用日志框架。在某些情况下，第三方日志框架比语言原生功能出现得更早，并成为了一种事实上的标准。其他日志框架则作为应用程序容器或平台的一部分出现，以解决原生解决方案中感知或证明的弱点。
- en: This chapter will explore the logging framework landscape, as there is a range
    of commonalities in their capability and in design. A general understanding of
    this will help us appreciate the “art of the possible” and make informed decisions
    when choosing a framework. We will also look at whether the more dominant frameworks
    for different languages can support the ability to connect directly to Fluentd.
    Fluentd has also helped us in this space by providing logging libraries for multiple
    languages, so we’ll look at those to understand how they may fit into the options
    we have.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨日志框架的格局，因为它们在能力和设计上存在许多共同点。对这一点的理解将帮助我们欣赏“可能的技艺”，并在选择框架时做出明智的决定。我们还将探讨不同语言的更主导框架是否能够支持直接连接到Fluentd的能力。Fluentd也通过为多种语言提供日志库来帮助我们在这个领域，因此我们将研究这些库，以了解它们如何适应我们拥有的选项。
- en: If frameworks or Fluentd libraries aren’t an option, we can obviously have our
    applications write to files. We’ve seen that Fluentd can consume such information.
    But connecting via a file is less efficient than connecting the application directly.
    If you are working with a *Function as a Service* (FaaS) like AWS Lambda and Functions
    services from Oracle Cloud, Microsoft Azure, and Google, or even self-hosted functions
    via Fn Project ([https://fnproject.io/](https://fnproject.io/)), you’ll recognize
    that the services are very transient. As a result, these very transient services
    are more challenging to efficiently log from. Trying to connect to storage can
    be more complex to configure and slower to connect, and therefore more suited
    to network-based logging. So, we will explore how it is possible to communicate
    with Fluentd more directly.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果框架或Fluentd库不是选项，我们显然可以让我们的应用程序写入文件。我们已经看到Fluentd可以消费此类信息。但是通过文件连接比直接连接应用程序效率低。如果你在与AWS
    Lambda和Oracle Cloud Functions、Microsoft Azure Functions、Google Functions或通过Fn
    Project（[https://fnproject.io/](https://fnproject.io/)）自托管函数一起工作，你会认识到这些服务非常短暂。因此，这些非常短暂的服务在高效日志记录方面更具挑战性。尝试连接到存储可能配置更复杂，连接速度更慢，因此更适合基于网络的日志记录。因此，我们将探讨如何更直接地与Fluentd通信。
- en: 11.1 Value of logging frameworks
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 日志框架的价值
- en: 'Regardless of the genesis of the logging framework(s), they all address the
    following key themes to a greater or lesser extent:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 无论日志框架的起源如何，它们都在一定程度上解决了以下关键主题：
- en: Providing an easy way to output log events using a log level classification
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种使用日志级别分类轻松输出日志事件的方法
- en: Allowing the control of log events sent via configuration
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许通过配置控制发送的日志事件
- en: Directing the log events to different output forms, such as files, stdout, HTTP,
    etc.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将日志事件定向到不同的输出形式，例如文件、stdout、HTTP等。
- en: While log levels can be traced back to Syslog standards (RFC 5424, [https://tools.ietf.org/html/rfc5424](https://tools.ietf.org/html/rfc5424))
    for application development (as opposed to OS-level tooling that led to the definition
    of RFC 5424), one of the strongest influencers on logging libraries is *Apache
    Log4J*. This influence could be attributed to the fact that the Apache Software
    Foundation ported the design and implementation to several different languages.
    But its influence goes further than that. While it is possible to arrive at very
    similar or even the same answers based on the same needs, you can see very similar
    if not the same APIs and features in the logging frameworks for many other languages.
    Some logging frameworks not linked to the Apache Software Foundation openly acknowledge
    drawing on the design principles of Log4J. To be open and transparent, my entry
    into open source was when I started developing with Java 1.2, so my perspective
    may be a little biased.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然日志级别可以追溯到 Syslog 标准（RFC 5424，[https://tools.ietf.org/html/rfc5424](https://tools.ietf.org/html/rfc5424)）以用于应用程序开发（与导致
    RFC 5424 定义的操作系统级别工具相比），但影响日志库的最强因素之一是 *Apache Log4J*。这种影响可以归因于 Apache 软件基金会将该设计和实现移植到多种不同的语言。但它的作用远不止于此。尽管基于相同的需求可以得出非常相似甚至相同的答案，但你可以在许多其他语言的日志框架中看到非常相似甚至相同的
    API 和功能。一些与 Apache 软件基金会无关的日志框架公开承认借鉴了 Log4J 的设计原则。为了保持开放和透明，我进入开源领域是在我开始使用 Java
    1.2 时，因此我的观点可能有些偏见。
- en: The beauty of following the Log4J route is the ability for third parties to
    implement certain parts of the framework, so the application doesn’t see any difference.
    Still, the configuration could change behaviors, such as how the logs are stored,
    from flat files to databases. We’ll see this in more detail in the next couple
    of sections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随 Log4J 路线的美丽之处在于第三方可以实施框架的某些部分，因此应用程序不会看到任何差异。然而，配置可能会改变行为，例如日志的存储方式，从平面文件到数据库。我们将在下一两个部分中更详细地了解这一点。
- en: NOTE References to Log4J can cause some confusion, as there are two versions—Log4J
    and Log4J2\. When referencing Log4J today, you can assume it refers to version
    2\. Version 1 was declared as being at the end of its life in 2015\. Versions
    1 and 2 aren’t radically different in terms of ideas. But version 2 was rewritten
    to address some weaknesses of the version 1 implementation; this meant the implementation
    could be written to utilize new language features.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对 Log4J 的引用可能会引起一些混淆，因为有两个版本——Log4J 和 Log4J2。当今天提到 Log4J 时，可以假设它指的是版本 2。版本
    1 在 2015 年被宣布已结束其生命周期。版本 1 和 2 在理念上并没有根本的不同。但版本 2 是为了解决版本 1 实现的一些弱点而重写的；这意味着实现可以编写以利用新的语言特性。
- en: 11.2 Typical structure of a logging framework
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 日志框架的典型结构
- en: Given the Log4J influence across many logging frameworks and languages, it is
    best to start by examining the Log4J structure. We can easily understand and master
    other frameworks. Figure 11.1 illustrates this structure and the relationships
    with the different classes (we’ve used UML class notation with a couple of tweaks,
    as the key shows; [www.omg.org/spec/UML/](https://www.omg.org/spec/UML/)). We
    can see that the classes or modules involved are the *Logger Context*, *Configuration*,
    *Filter*, *Logger*, *Logger Config*, *Formatter,* and an *Appender.*
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Log4J 在许多日志框架和语言中的影响，最好从检查 Log4J 结构开始。我们可以轻松理解和掌握其他框架。图 11.1 展示了这种结构以及与不同类的关系（我们使用了经过一些调整的
    UML 类符号，如图所示；[www.omg.org/spec/UML/](https://www.omg.org/spec/UML/))。我们可以看到涉及的类或模块是
    *Logger Context*、*Configuration*、*Filter*、*Logger*、*Logger Config*、*Formatter*
    和 *Appender*。
- en: '![](../Images/CH11_F01_Wilkins.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH11_F01_Wilkins.png)'
- en: Figure 11.1 Common logging structure represented using UML class notation, including
    indicating the quantities in the relationships, such as 0 or 1 to many
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 使用 UML 类符号表示的常见日志结构，包括表示关系中的数量，如 0 或 1 到多
- en: In the following sections, we’ll describe the role that each of these components
    plays. We have ordered the components based on how much their logic impacts the
    use and behavior of the logging framework.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将描述每个组件所扮演的角色。我们根据它们的逻辑对日志框架的使用和行为影响程度对组件进行了排序。
- en: 11.2.1 Logger context
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 日志上下文
- en: This is the foundation of the framework within your application. It takes responsibility
    for holding the references to specific logger objects. It will process any configuration
    files, creating the necessary logger objects as necessary.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序中框架的基础。它负责保留对特定日志记录器对象的引用。它将处理任何配置文件，根据需要创建必要的日志记录器对象。
- en: The logger context typically forms a “one-stop shop” for all your logging elements;
    within the application, this class is used to retrieve an object that will handle
    the relevant processing of log events (represented by an instance of a logger
    object). When a request is made on the logger context for a logger object, it
    can derive or use parameters to determine which logger object to provide. If no
    specific logging configurations are associated with the identifier provided (usually
    a logical name or classpath), then a default logging behavior will be provided.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录器上下文通常是一个“一站式”商店，用于处理所有日志元素；在应用程序中，这个类用于检索一个将处理相关日志事件的对象（由日志记录器对象的实例表示）。当对日志记录器上下文请求一个日志记录器对象时，它可以推导或使用参数来确定提供哪个日志记录器对象。如果没有与提供的标识符（通常是一个逻辑名称或类路径）关联的特定日志记录配置，则将提供默认的日志记录行为。
- en: Depending on the implementation, it may also orchestrate any details such as
    connection pools, and so on. This is the only point where there is a certainty
    of having a single object, making it the root for all Log4J configuration values.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据实现，它还可能协调任何细节，例如连接池等。这是唯一一个可以确定只有一个对象的地方，使其成为所有Log4J配置值的根。
- en: 11.2.2 Appender
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 追加器
- en: 'The appender’s task is the easiest to relate to and is key to processing log
    events. Depending upon the specific logging framework implementation, the appender
    may be called an *adaptor* or *transport*, as this layer is responsible for taking
    the log events and sending them to the appropriate destination. For example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 追加器的任务是最容易关联的，也是处理日志事件的关键。根据具体的日志记录框架实现，追加器可能被称为*适配器*或*传输器*，因为这一层负责接收日志事件并将它们发送到适当的目的地。例如：
- en: Transmitting them using techniques such as TCP/IP messages
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TCP/IP消息等技术进行传输
- en: Using API calls to services such as Logstash
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对Logstash等服务进行API调用的方式
- en: Writing or appending the log event to the end of a file (hence the name)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将日志事件写入或追加到文件的末尾（因此得名）
- en: Each appender will make use of filters to control which log events it may need
    to append. An appender can also use a formatter to convert the internal representation
    of the event to how it should be outputted; this can range from JSON to tab-separated
    rows. Some types of appender can only emit log events in a specific way; this
    relationship can sometimes get simplified and combined into a single class or
    module.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个追加器将使用过滤器来控制它可能需要追加哪些日志事件。追加器还可以使用格式化程序将事件的内部表示转换为输出方式；这可以从JSON到制表符分隔的行。某些类型的追加器只能以特定方式发出日志事件；这种关系有时可以简化并合并为单个类或模块。
- en: Within the configuration of a logging framework, it is possible (and expected)
    to see several different appenders configured to address sending some events to
    multiple destinations with different log levels.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志记录框架的配置中，可以看到配置了多个不同的追加器，以将某些事件发送到多个目的地，并使用不同的日志级别。
- en: 11.2.3 Logger
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3 日志记录器
- en: It is possible to define multiple loggers (or just the context defaults) so
    that different application parts can use logging in different ways—for example,
    a separate logger for recording official audit events versus generic application
    audit trails. The official audit events may need to be sent to the database, and
    all events, including the audit, should be sent to the logging framework. These
    loggers can then be selected within the code. There will be different configurations
    with different loggers, such as which appender to use, which filters to apply,
    and so on.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义多个日志记录器（或仅使用上下文默认值），以便不同的应用程序部分可以以不同的方式使用日志记录。例如，为记录官方审计事件和通用应用程序审计跟踪使用单独的日志记录器。官方审计事件可能需要发送到数据库，并且所有事件，包括审计，都应该发送到日志记录框架。然后可以在代码中选择这些日志记录器。将会有不同的配置与不同的日志记录器相关联，例如使用哪个追加器、应用哪些过滤器等。
- en: By having multiple loggers, we benefit from varying the configuration for different
    parts of the code base and even having multiple configurations for parts of the
    application (e.g., log errors to `stdout` and log everything to file).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拥有多个日志记录器，我们可以从为代码库的不同部分调整配置中受益，甚至可以为应用程序的部分拥有多个配置（例如，将错误记录到`stdout`并将所有内容记录到文件中）。
- en: 11.2.4 Filter
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.4 过滤器
- en: The filter determines which log events should be emitted, primarily by determining
    whether the log event is at a level above or below the threshold set in the configuration.
    As filters are associated with appenders, different log destinations can be configured
    with different log levels. For example, I could set the console appender to have
    a log level of `Warning` and a file appender set to `Info`. The result is that
    only `Warning` and `Error` events go to the console, but more details are included
    in the file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器确定哪些日志事件应该被发出，主要是通过确定日志事件是否在配置中设置的阈值之上或之下。由于过滤器与附加器相关联，可以配置不同的日志级别到不同的日志目的地。例如，我可以将控制台附加器的日志级别设置为
    `Warning`，并将文件附加器的日志级别设置为 `Info`。结果是只有 `Warning` 和 `Error` 事件会发送到控制台，但文件中包含了更多细节。
- en: 11.2.5 Formatter
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.5 格式化器
- en: As described by the appender, the formatter’s task is to construct the appender
    output so that the log entry is presented as wanted or required (e.g., time in
    a 12- or 24-hour format). Some appenders will allow flexibility (e.g., file appenders).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如附加器所述，格式化器的任务是构建附加器输出，以便日志条目以所需或需要的方式呈现（例如，以 12 小时或 24 小时格式显示时间）。一些附加器将允许灵活性（例如，文件附加器）。
- en: 11.2.6 Configuration
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.6 配置
- en: Typically, we want to drive the logging of an application through configuration
    rather than code, as this allows the logging to be configured without necessarily
    making invasive code changes. This also makes for a quicker turnaround in the
    verification of configurations. It allows us to change how logs are processed,
    depending upon the deployment context. For example, we could have a configuration
    that sends everything to `stdout` for our development machines. However, in test
    and production environments, the configuration is set to send the logs to Elasticsearch.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望通过配置而不是代码来驱动应用程序的日志记录，因为这样可以在不必要进行侵入性代码更改的情况下配置日志。这也使得配置的验证过程更加迅速。它允许我们根据部署环境来改变日志的处理方式。例如，我们可能为开发机器配置一个将所有内容发送到
    `stdout` 的配置。然而，在测试和生产环境中，配置被设置为将日志发送到 Elasticsearch。
- en: 11.2.7 Logger config
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.7 日志记录器配置
- en: The logger config is a subset of the total logging configuration for a particular
    logger (see section 11.2.3). This will track the relevant configuration section
    and translate it into the correct objects in the code. This may include using
    things like factory design patterns.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录器配置是特定日志记录器总日志配置的一个子集（参见第 11.2.3 节）。这将跟踪相关的配置部分并将其转换为代码中的正确对象。这可能包括使用工厂设计模式等。
- en: 11.3 Appender structures
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 附加器结构
- en: Typically, appenders are built through a hierarchy of inheritance or encapsulation
    so that each layer of sophistication can leverage simpler operations. Ultimately,
    this will depend on a standard interface definition so that regardless of appender,
    they are orchestrated the same way, just as Fluentd does with its plugins. In
    figure 11.2, we can see how Log4J has organized its appenders through inheritance
    from a base class that realizes an interface and provides common logic, which
    is then extended to provide a set of basic appenders, such as the console appender.
    From this layer of derivation, we see the layering build an increase in specializations.
    This is most notable with the `AbstractOutputStreamAppender`, which is then used
    for general socket use cases and is further specialized for sending logs into
    a Syslog compliant solution.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通过继承或封装的层次结构来构建附加器，以便每一层复杂性都可以利用更简单的操作。最终，这将取决于标准接口定义，以便无论附加器如何，它们都以相同的方式进行编排，就像
    Fluentd 对其插件所做的那样。在图 11.2 中，我们可以看到 Log4J 是如何通过从实现接口并提供公共逻辑的基本类进行继承来组织其附加器的。然后从这个派生层扩展，提供一组基本附加器，例如控制台附加器。从这个派生层，我们看到层叠构建了专业化的增加。这最显著的是
    `AbstractOutputStreamAppender`，它随后用于一般的套接字用例，并进一步专门化以将日志发送到符合 Syslog 的解决方案。
- en: '![](../Images/CH11_F02_Wilkins.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH11_F02_Wilkins.png)'
- en: Figure 11.2 UML representation of how some of the appenders of Log4J are related
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 Log4J 的一些附加器关系的 UML 表示
- en: 11.4 Logging framework landscape
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 日志框架概览
- en: The number of logging frameworks is substantial, with most languages having
    a native capability and open source frameworks. In appendix E, we have pulled
    together a list of logging frameworks for a range of languages commonly used.
    We also provide some details about the dominant frameworks, some of which are
    the language-native options and where to obtain more information.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 日志框架的数量相当多，大多数语言都有本地的能力以及开源框架。在附录E中，我们收集了一系列常用语言的日志框架列表。我们还提供了一些关于主导框架的详细信息，其中一些是语言本地的选项，以及如何获取更多信息。
- en: In addition to logging frameworks, some libraries provide a programmatic interface
    and a mapping between the API and several different popular frameworks. Those
    familiar with Log4J will probably have heard of *SL4J* ([www.slf4j.org](http://www.slf4j.org)),
    which abstracts Log4J, the Java native logging framework, and another called Logback.
    As a result, it is possible to switch the logging frameworks transparently. With
    these abstractions, a means to instantiate the desired logging framework is needed.
    This can be achieved by implementing a factory ([http://mng.bz/KB00](http://mng.bz/KB00))
    or dependency injection ([http://mng.bz/DxZw](http://mng.bz/DxZw)) pattern. Another
    example of this abstraction is .Net native logging (more detail can be found at
    [http://mng.bz/9KV1](http://mng.bz/9KV1)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了日志记录框架之外，一些库提供了程序化接口以及API与几个不同流行框架之间的映射。熟悉Log4J的人可能听说过*SL4J* ([www.slf4j.org](http://www.slf4j.org))，它抽象了Java本地的日志框架Log4J，另一个叫做Logback。因此，可以透明地切换日志框架。有了这些抽象，需要一种实例化所需日志框架的方法。这可以通过实现工厂([http://mng.bz/KB00](http://mng.bz/KB00))或依赖注入([http://mng.bz/DxZw](http://mng.bz/DxZw))模式来实现。这种抽象的另一个例子是.NET本地的日志记录（更多详情请见[http://mng.bz/9KV1](http://mng.bz/9KV1))。
- en: 11.5 Choosing a framework
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5 选择框架
- en: 'When evaluating a logging framework to adopt, some things should be considered
    to help select the most appropriate framework. We have developed a set of questions
    that will help you evaluate your needs and select a framework to meet those needs.
    By reviewing these questions, it will help you determine your priorities in terms
    of a logging framework. Once the questions have been given some form of priority,
    it becomes easier to evaluate the frameworks against the questions to see how
    well they match your needs. The questions are the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当评估要采用的日志框架时，应考虑一些因素以帮助选择最合适的框架。我们开发了一套问题，这些问题将帮助你评估需求并选择满足这些需求的框架。通过审查这些问题，将有助于确定你在日志框架方面的优先级。一旦这些问题被赋予了某种形式的优先级，评估框架与问题的匹配程度将更容易，以查看它们如何满足你的需求。问题如下：
- en: What appenders are available? Are they limited to one type of appender, such
    as files? Are there out-of-the-box appenders that can work with your log unification
    solution, such as Fluentd or Logstash?
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的追加器有哪些？它们是否仅限于一种类型的追加器，例如文件？是否有现成的追加器可以与你的日志统一解决方案一起工作，例如Fluentd或Logstash？
- en: Can the appender behavior be tailored or optimized? For example, are log rotation
    or network ports and addresses configurable?
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否可以定制或优化追加器的行为？例如，日志轮转或网络端口和地址是否可配置？
- en: Is it possible to tailor the output of log events based on the different parts
    of the application? For example, log thresholds for the application framework,
    such as Spring or Core .Net, are set to `Warning` and `Error`, but your custom
    logic can have thresholds set to `Info`.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否可以根据应用程序的不同部分定制日志事件的输出？例如，应用程序框架（如Spring或Core .Net）的日志阈值设置为`Warning`和`Error`，但你的自定义逻辑可以设置阈值为`Info`。
- en: How easy is it to tailor the logging configuration (without using code)? You
    may wish to tune logging, and if there is an operational issue, ideally you can
    update or override the default logging configurations to selectively get more
    information.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制日志配置（不使用代码）有多容易？你可能希望调整日志记录，如果存在操作问题，理想情况下可以更新或覆盖默认的日志配置，以选择性地获取更多信息。
- en: How much information does the framework derive for you (e.g., providing method
    and class names for tracepoints) with correctly structured timestamps?
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架为你提供了多少信息（例如，为跟踪点提供方法和类名）以及正确结构的时戳？
- en: Can you tailor the log output formatting (e.g., JSON, XML)? This question reflects
    the previous chapter where the best logs have a structure allowing the log event
    to be both humanly readable and machine-readable.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否可以定制日志输出格式（例如，JSON，XML）？这个问题反映了前一章中提到的最佳日志具有结构，允许日志事件既可读性又可机器读取。
- en: How compact is the footprint (this is important in IoT use cases)? For the IoT
    and mobile solutions, we need to have a tight footprint to limit resource use.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚印有多紧凑（这在物联网用例中很重要）？对于物联网和移动解决方案，我们需要有一个紧凑的脚印来限制资源使用。
- en: Can you make the log output secure—use TLS, encrypt files, and so on? Is the
    security good enough for the data being handled?
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您能否使日志输出安全——使用 TLS、加密文件等？安全性是否足够处理所处理的数据？
- en: Will the framework have a material impact on my application’s throughput/performance,
    particularly the final I/O phase? Can logging end up being a thread-blocking mechanism?
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架会对我的应用程序的吞吐量/性能产生重大影响吗，尤其是在最终的 I/O 阶段？日志是否会变成一个线程阻塞机制？
- en: How easy is the logging framework’s API to work with? If the calls within the
    application code are difficult to use, developers may avoid creating log events.
    Ideally, the interfaces will be intuitive, but having good supporting documentation
    to reference can be invaluable, particularly for those starting their development
    careers.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志框架的 API 是否易于使用？如果应用程序代码中的调用难以使用，开发者可能会避免创建日志事件。理想情况下，接口将是直观的，但拥有良好的支持文档进行参考可能非常有价值，尤其是对于刚开始他们职业生涯的开发者。
- en: Rather than evaluating every possible option, it is worth trying to narrow the
    field of options. The details in the appendix E, table E.11 can help here, as
    they reflect what we believe are the most important and/or most dominant logging
    frameworks.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是评估所有可能的选择，尝试缩小选择范围是值得的。附录 E 中的 E.11 表格中的细节可以在这里有所帮助，因为它们反映了我们认为最重要的和/或最占主导地位的日志框架。
- en: 11.5.1 Putting optimizing application logging into action
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5.1 将优化应用程序日志投入实际应用
- en: The adoption of Fluentd in your organization is going well, and you have been
    asked to determine whether the current logging framework in use is up to the job
    going forward or whether the success of Fluentd allows supporting a case of changing
    logging frameworks. Using the factors described, evaluate the current solution
    being used by your development team. Compare this with an alternative (examine
    appendix E to see if an alternative option has been offered).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您组织中的 Fluentd 采用情况良好，您被要求确定当前使用的日志框架是否能够满足未来的需求，或者 Fluentd 的成功是否允许支持更改日志框架的情况。使用所描述的因素，评估您的开发团队正在使用的当前解决方案。将其与一个替代方案进行比较（查看附录
    E，看看是否提供了替代选项）。
- en: Answer
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 答案
- en: As we clearly cannot give you a specific solution for this exercise, we hope
    you have found that you are already using a logging framework, and it fits well
    with your needs. If your logging framework is not a great fit, you will probably
    have recognized the issues already. If you haven’t pinpointed the issues with
    your current framework, this list of considerations should have helped qualify
    the problems.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们显然无法为这个练习提供特定的解决方案，我们希望您已经发现您已经在使用一个日志框架，并且它与您的需求很好地匹配。如果您的日志框架并不非常适合，您可能已经发现了问题。如果您还没有确定当前框架的问题，这份考虑事项列表应该有助于确定问题。
- en: 11.6 Fluentd’s own logging and appenders
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6 Fluentd 自身的日志和追加器
- en: What happens if the logging framework being used does not provide support specific
    to Fluentd? There are several possibilities to overcome this. One approach is
    through the use of Fluentd-provided libraries.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在使用的日志框架没有提供针对 Fluentd 的特定支持，会发生什么？有几种方法可以克服这个问题。一种方法是通过使用 Fluentd 提供的库。
- en: Depending upon the language, the Fluentd logging library implementation may
    have some or all of the structures described earlier, such as appenders and filters.
    These implementations may work with and extend the native language logging library,
    as is the case for Python and Ruby. In other cases, the Fluentd libraries do not
    align with a framework, often when there is no native language logging library
    or an established dominant solution. In these cases, the library will be more
    straightforward and will need to be used directly from your code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 根据语言的不同，Fluentd 日志库的实现可能包含之前描述的一些或所有结构，例如追加器和过滤器。这些实现可能与本地语言的日志库一起工作并扩展它，例如
    Python 和 Ruby。在其他情况下，Fluentd 库与框架不匹配，通常在没有本地语言日志库或已确立的占主导地位解决方案的情况下。在这些情况下，库将更加直接，并且需要直接从您的代码中使用。
- en: You may have established the use of a logging framework with no feature for
    connecting to Fluentd, and the Fluentd-provided library does not automatically
    plug in to a framework. In these situations, it may be possible to find additional
    open source software to wrap or extend the Fluentd library to allow its use within
    a framework structure. We can change how the log events are handled using configuration
    alone and not impact application code. Of course, you could create the code that
    bridges the gap. Depending on the combination of language, Fluentd library, and
    framework, the trickiest part of this will most likely be how to supply configuration
    values into the Fluentd library.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经建立了一个没有连接到Fluentd功能的日志框架，并且Fluentd提供的库不会自动集成到框架中。在这些情况下，可能可以找到额外的开源软件来包装或扩展Fluentd库，以便在框架结构中使用。我们可以仅通过配置来更改日志事件的处理方式，而不会影响应用程序代码。当然，您也可以创建代码来填补这个差距。根据语言、Fluentd库和框架的组合，这最棘手的部分很可能是如何向Fluentd库提供配置值。
- en: In table 11.1, we can see how Fluentd supports different programming languages
    with libraries. We have also suggested other open source options that will allow
    the logging code to communicate with Fluentd.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在表11.1中，我们可以看到Fluentd如何通过库支持不同的编程语言。我们还建议了其他开源选项，这些选项将允许日志代码与Fluentd通信。
- en: Table 11.1 Where Fluentd can integrate into a native or commonly used framework
    directly or indirectly
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1 Fluentd可以直接或间接集成到本地或常用框架中的位置
- en: '| Language | Has native logging library | Fluentd logger library | Alternate
    open source solution |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 语言 | 是否有本地日志库 | Fluentd日志库 | 其他开源解决方案 |'
- en: '| Erlang | Y | [https://github.com/fluent/fluent-logger-erlang](https://github.com/fluent/fluent-logger-erlang)
    |  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| Erlang | Y | [https://github.com/fluent/fluent-logger-erlang](https://github.com/fluent/fluent-logger-erlang)
    | '
- en: '| Go | N | [https://github.com/fluent/fluent-logger-golang](https://github.com/fluent/fluent-logger-golang)
    |  |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| Go | N | [https://github.com/fluent/fluent-logger-golang](https://github.com/fluent/fluent-logger-golang)
    |'
- en: '| Java | N | [https://github.com/fluent/fluent-logger-java](https://github.com/fluent/fluent-logger-java)
    | Log4J: [https://github.com/tuxetuxe/fluentd4log4j](https://github.com/tuxetuxe/fluentd4log4j)
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| Java | N | [https://github.com/fluent/fluent-logger-java](https://github.com/fluent/fluent-logger-java)
    | Log4J: [https://github.com/tuxetuxe/fluentd4log4j](https://github.com/tuxetuxe/fluentd4log4j)
    |'
- en: '| Node.js | N | [https://github.com/fluent/fluent-logger-node](https://github.com/fluent/fluent-logger-node)
    | Directly integrates with Log4JS |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| Node.js | N | [https://github.com/fluent/fluent-logger-node](https://github.com/fluent/fluent-logger-node)
    | 直接与Log4JS集成'
- en: '| OCaml | N | [https://github.com/fluent/fluent-logger-ocaml](https://github.com/fluent/fluent-logger-ocaml)
    |  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| OCaml | N | [https://github.com/fluent/fluent-logger-ocaml](https://github.com/fluent/fluent-logger-ocaml)
    | '
- en: '| Perl | N | [https://github.com/fluent/fluent-logger-perl](https://github.com/fluent/fluent-logger-perl)
    | Log4perl: [https://metacpan.org/pod/Log::Log4perl::Appender::Fluent](https://metacpan.org/pod/Log::Log4perl::Appender::Fluent)
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| Perl | N | [https://github.com/fluent/fluent-logger-perl](https://github.com/fluent/fluent-logger-perl)
    | Log4perl: [https://metacpan.org/pod/Log::Log4perl::Appender::Fluent](https://metacpan.org/pod/Log::Log4perl::Appender::Fluent)
    |'
- en: '| PHP | N | [https://github.com/fluent/fluent-logger-php](https://github.com/fluent/fluent-logger-php)
    | [https://github.com/Seldaek/monolog](https://github.com/Seldaek/monolog) |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| PHP | N | [https://github.com/fluent/fluent-logger-php](https://github.com/fluent/fluent-logger-php)
    | [https://github.com/Seldaek/monolog](https://github.com/Seldaek/monolog) |'
- en: '| Python | Y | [https://github.com/fluent/fluent-logger-python](https://github.com/fluent/fluent-logger-python)
    |  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| Python | Y | [https://github.com/fluent/fluent-logger-python](https://github.com/fluent/fluent-logger-python)
    | '
- en: '| Ruby | Y | [https://github.com/fluent/fluent-logger-ruby](https://github.com/fluent/fluent-logger-ruby)
    |  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| Ruby | Y | [https://github.com/fluent/fluent-logger-ruby](https://github.com/fluent/fluent-logger-ruby)
    | '
- en: '| Scala | N | [https://github.com/fluent/fluent-logger-scala](https://github.com/fluent/fluent-logger-scala)
    | Via Logback compatibility with SLF4S |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| Scala | N | [https://github.com/fluent/fluent-logger-scala](https://github.com/fluent/fluent-logger-scala)
    | 通过Logback与SLF4S的兼容性'
- en: If you don’t have a suitable logging framework or wrapper layer, then there
    is the option to use the Fluentd logging library directly within your core application
    code. As with all things, there are pros and cons to such an approach. To that
    end, in table 11.2, we’ve called out the pros and cons of using the libraries
    directly to help you make informed decisions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有合适的日志框架或包装层，那么您可以直接在核心应用程序代码中使用Fluentd日志库。与所有事情一样，这种方法也有其优缺点。因此，在表11.2中，我们列出了直接使用库的优缺点，以帮助您做出明智的决定。
- en: Table 11.2 Pros and cons of using Fluentd’s own log framework
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.2 使用Fluentd自带的日志框架的优缺点
- en: '| Pros | Cons |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 优点 | 缺点 |'
- en: '| Small footprint, as it is only providing for output to Fluentd. | Locked
    into using Fluentd. For packaged solutions, you had better not try to force its
    logging to work differently from the options it provides. This is where it may
    be better to consider a custom plugin or find a compromise configuration. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 脚本占用小，因为它只为输出到Fluentd提供支持 | 锁定使用Fluentd。对于打包解决方案，你最好不要尝试强制其日志工作方式与它提供的选项不同。这可能更适合考虑一个自定义插件或找到一个折衷的配置。
    |'
- en: '| The Fluentd logging library provides the same programmer interface as other
    frameworks, giving a comparable development experience. But the Fluentd server
    offers significantly more sophistication than a logging framework for handling
    the log events. |  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| Fluentd日志库提供了与其他框架相同的程序员接口，提供了可比的开发体验。但Fluentd服务器在处理日志事件方面提供了比日志框架更复杂的处理能力。
    |  |'
- en: '| Communication to Fluentd is over the network. Using msgpack compression means
    efficient communication and can limit hosting complexities (e.g., external storage
    for containers, complexities of storage for FaaS). |  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 与Fluentd的通信是通过网络进行的。使用msgpack压缩意味着高效的通信，并可以限制托管复杂性（例如，容器的外部存储，FaaS的存储复杂性）。
    |  |'
- en: The final possible option for logging directly to Fluentd is to leverage a framework’s
    plugins to communicate using TCP/IP or HTTP(s) and send log events using those
    protocols. These routes mean you have no library dependencies (assuming your programming
    language can provide basic networking).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志直接发送到Fluentd的最终可能选项是利用框架的插件通过TCP/IP或HTTP(s)进行通信，并使用这些协议发送日志事件。这些路径意味着你没有任何库依赖（假设你的编程语言可以提供基本的网络功能）。
- en: 11.7 Illustrations of an application logging directly to Fluentd
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.7 直接将应用程序日志记录到Fluentd的示例
- en: Having now looked at logging framework structures, the considerations involved
    in selecting a logging framework, and the possibility of logging directly to Fluentd
    without a framework, let’s see how the different approaches for direct logging
    can look in reality. Each illustration will move further away from the ideal abstracted
    connection to Fluentd but will show how direct communication can be realized.
    In each case, we’re going to transmit a simple log message to Fluentd.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了日志框架的结构，选择日志框架时需要考虑的因素，以及在没有框架的情况下直接将日志发送到Fluentd的可能性，让我们看看不同的直接日志记录方法在现实中是如何表现的。每个示例都将进一步偏离理想的抽象连接到Fluentd，但将展示如何实现直接通信。在每种情况下，我们将传输一个简单的日志消息到Fluentd。
- en: For these illustrations, we’ve chosen to use Python because it
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些示例，我们选择使用Python，因为它
- en: Supports using the Fluentd library with its native logging framework to show
    the most ideal option
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持使用Fluentd库与其本地的日志框架一起使用，以展示最理想的选项
- en: Is a widely adopted language, and the language constructs are easy to read and
    map to other languages
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是一种广泛使用的语言，其语言结构易于阅读并映射到其他语言
- en: Is a scripted language, so no additional effort is needed to set up and run
    a compilation process first (compared to Java, C#, etc.)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是一种脚本语言，因此不需要额外的努力来设置和运行编译过程（与Java、C#等相比）
- en: Is a different language from the implementation of Fluentd and so helps illustrate
    the language-agnostic use of working with Fluentd
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Fluentd的实现语言不同，因此有助于说明与Fluentd合作的语言无关性
- en: '11.7.1 Python with logging framework: Using the Fluentd library'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.1 使用日志框架的Python：使用Fluentd库
- en: 'In most situations, having the Fluentd library plugging directly into the logging
    framework is ideal, as we can configure different ways to log without any code
    changes. Let’s start with the code that creates the logging framework driven by
    the configuration file; our application then uses the framework to record a log
    event. To achieve this illustration, we need to establish some code and configuration,
    which we will review in the coming listings:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，将Fluentd库直接插入到日志框架中是理想的，因为我们可以在不更改任何代码的情况下配置不同的日志记录方式。让我们从创建由配置文件驱动的日志框架的代码开始；然后我们的应用程序使用该框架记录日志事件。为了实现这个示例，我们需要建立一些代码和配置，我们将在接下来的列表中回顾：
- en: A simple Python test application to use the logging framework and generate a
    log event
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的Python测试应用程序，用于使用日志框架并生成日志事件
- en: A configuration file telling the logging framework how and what to log
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个配置文件，用于告知日志框架如何以及记录什么
- en: A Fluentd server and configuration so it can receive the log events
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Fluentd服务器和配置，以便它可以接收日志事件
- en: In the code shown in listing 11.1, we can see the Python test application, which
    creates a configuration object from the configuration file and passes this into
    the logging context, and then requests a logger object. With the logging object
    ready, we could use that object as many times as we like. In our example, we then
    construct content in the log message—here, the date-time string representation.
    Then the logging framework is called twice, once as a text message and again as
    a JSON construct. When you review the code, note the complete absence of Fluentd
    references. This is all handled in the logging framework for us based on the configuration.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 11.1 节中显示的代码中，我们可以看到 Python 测试应用程序，它从配置文件中创建一个配置对象，并将其传递到日志上下文中，然后请求一个日志记录器对象。有了日志对象，我们可以多次使用该对象。在我们的示例中，我们然后在日志消息中构建内容——这里，日期时间的字符串表示。然后日志框架被调用两次，一次作为文本消息，再次作为
    JSON 结构。当您查看代码时，请注意 Fluentd 引用的完全缺失。这一切都是根据配置由日志框架为我们处理的。
- en: Listing 11.1 Chapter11/clients/log-conf.py—Test Python client—configuration
    only
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.1 第 11 章/clients/log-conf.py—测试 Python 客户端—配置信息
- en: '[PRE0]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Loads the configuration file, which will describe the logging setup wanted
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加载配置文件，该文件将描述所需的日志设置
- en: ❷ Gets the correct logger object; by not providing a specific name, we will
    be given the default setting
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取正确的日志记录器对象；由于没有提供特定的名称，我们将得到默认设置
- en: ❸ Generates log event
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 生成日志事件
- en: ❹ It would be preferable to create JSON for the log event being passed to the
    library. But building JSON objects first distracts from the point we’re trying
    to make.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 对于传递给库的日志事件，最好是创建 JSON。但首先构建 JSON 对象会分散我们试图说明的重点。
- en: The configuration shown in listing 11.2 is the detail loaded in the application
    and interpreted by the logging framework to establish the desired ways of logging.
    Only the configuration will drive logging to communicate to Fluentd directly through
    the definition of *handlers* (or appenders, using the naming we described earlier).
    Note how the configuration entities relate back to the structure illustrated in
    figure 11.1, with loggers referencing a handler (appender) by name and the handler
    referencing a formatter implemented to work with Fluentd. Here the filters are
    not decoupled but specified within the loggers and handlers using the `level`
    attribute.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第 11.2 节中显示的配置是应用程序中加载的详细信息，并由日志框架解释以建立所需的日志方式。只有配置将驱动日志通过定义 *处理器*（或使用我们之前描述的命名方式称为附加器）直接与
    Fluentd 通信。注意配置实体如何关联回图 11.1 中所示的结构，其中日志记录器通过名称引用处理器（附加器），处理器引用用于与 Fluentd 一起工作的格式化程序。在这里，过滤器没有解耦，而是在日志记录器和处理器中使用
    `level` 属性指定。
- en: 'Listing 11.2 Chapter11/clients/logging.yaml—Test Python client: configuration'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.2 第 11 章/clients/logging.yaml—测试 Python 客户端：配置
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Defines how the log event will be represented
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义日志事件将如何表示
- en: ❷ We still need to tell the logging framework which class will implement the
    formatter interface. Here we have a customer formatter for Fluentd, so the server
    will receive a correctly structured event.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们仍然需要告诉日志框架哪个类将实现格式化器接口。在这里，我们有一个用于 Fluentd 的自定义格式化器，因此服务器将接收到正确结构的日志事件。
- en: ❸ Defines the handler (the appender) and provides it with the configuration
    necessary to communicate with our Fluentd node
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 定义处理器（附加器）并提供与我们的 Fluentd 节点通信所需的配置
- en: ❹ Identifies the class that knows how to actually communicate with the Fluentd
    server
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 识别知道如何实际与 Fluentd 服务器通信的类
- en: ❺ Defines the default logger object and the default settings, and links the
    default logging configuration to the relevant handlers
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 定义默认日志记录器对象和默认设置，并将默认日志配置链接到相关处理器
- en: For Fluentd to work with the examples, we have provided a configuration file.
    If you review the configuration file in listing 11.3, you’ll see two sources configured.
    The source using the `forward` input plugin will receive the log events. You can
    confirm that by comparing the port number in the configuration to the logger YAML
    file; we will see the other source put to use shortly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 Fluentd 能够与示例一起工作，我们提供了一个配置文件。如果您查看第 11.3 节中的配置文件，您将看到配置了两个来源。使用 `forward`
    输入插件的来源将接收日志事件。您可以通过比较配置文件中的端口号和日志记录器 YAML 文件来确认这一点；我们将在稍后使用另一个来源。
- en: Listing 11.3 Chapter11/fluentd/http.conf—simple HTTP source
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.3 第 11 章/fluentd/http.conf—简单的 HTTP 来源
- en: '[PRE2]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Sets the logging to debug to help us understand what is happening. Given that
    HTTP is highly configurable in its behavior, let’s ensure that assumed configurations
    are compatible.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将日志设置为调试以帮助我们理解正在发生的事情。鉴于HTTP的行为高度可配置，让我们确保假设的配置是兼容的。
- en: ❷ Let’s not worry about the expected structure at this stage and process the
    log event as a single string received over HTTP.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在这个阶段，我们不必担心预期的结构，将日志事件作为通过HTTP接收的单个字符串处理。
- en: ❸ Using a different port, we can take the log event using HTTP in a JSON structure.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的端口，我们可以通过HTTP以JSON结构获取日志事件。
- en: ❹ Using the forward plugin, we can receive the payload as JSON text or compressed
    with msgpack.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用转发插件，我们可以以JSON文本或使用msgpack压缩的形式接收有效负载。
- en: 'To start things up, we’ll need two shell windows; having navigated to the folder
    with all the provided resources, Fluentd can be started with the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动，我们需要两个shell窗口；在导航到包含所有提供资源的文件夹后，可以使用以下命令启动Fluentd：
- en: '[PRE3]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is followed by navigating to the `Chapter11/clients` folder and executing
    the command
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这之后，导航到`Chapter11/clients`文件夹并执行以下命令
- en: '[PRE4]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once executed, you will see that the Fluentd server will write the generated
    log event to the console in a JSON format.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，您将看到Fluentd服务器将以JSON格式将生成的日志事件写入控制台。
- en: 11.7.2 Invoking Fluentd appender directly
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.2 直接调用Fluentd附加器
- en: Let’s now look at how the code may appear using the Fluentd Python library directly
    from our application instead of a logging framework. While this is the Python
    implementation, the logger libraries work similarly for most of the supported
    languages. Obviously, each implementation may have differences because of the
    constraints of how the programming language works. For example, Go doesn’t have
    classes and inheritance like Python and Java, but rather has modules and types.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用Fluentd Python库直接从我们的应用程序而不是日志框架中查看代码可能的样子。虽然这是Python实现，但大多数支持的语言的日志库工作方式相似。显然，由于编程语言的工作方式限制，每种实现可能都有所不同。例如，Go没有像Python和Java那样的类和继承，而是有模块和类型。
- en: To make it easy to compare the direct calls to the Fluentd logging library approach
    using the logging framework, we have created a new Python test client shown in
    listing 11.4\. The first immediate difference is the client we need to explicitly
    import the Fluentd library into our code. Our code no longer establishes the logger
    context and logger object but interacts with a sender, which is a specific implementation
    of an appender (or handler, as Python calls it). The sender object is constructed
    with the configuration needed to connect to Fluentd (you could, of course, retrieve
    this data from a generic configuration file). As before, we’re constructing the
    time to put into the log event message. Then, finally, we can use either the Fluent
    library’s `emit` or `emit_with_timestamp` functions to transmit the log event.
    The emit functions require the payload to be represented as a hashmap (or dictionary,
    using Python’s naming).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于比较直接调用Fluentd日志库的方法与使用日志框架的方法，我们创建了一个新的Python测试客户端，如列表11.4所示。第一个明显的区别是我们需要显式地将Fluentd库导入到我们的代码中。我们的代码不再建立日志上下文和日志对象，而是与一个发送者交互，这是一个特定的实现，即附加器（或Python所说的处理器）。发送者对象使用连接到Fluentd所需的配置来构建（当然，您也可以从通用配置文件中检索这些数据）。与之前一样，我们正在构建要放入日志事件消息中的时间。然后，最后，我们可以使用Fluent库的`emit`或`emit_with_timestamp`函数来传输日志事件。emit函数需要将有效负载表示为哈希表（或使用Python的命名，即字典）。
- en: Listing 11.4 Chapter11/clients/log-fluent.py—Direct Fluentd library use
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.4 Chapter11/clients/log-fluent.py—直接使用Fluentd库
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ The import making a direct dependency on the Fluentd library
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 直接依赖Fluentd库的导入
- en: ❷ Creates an instance of the Fluentd handler
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Fluentd处理器的实例
- en: ❸ Sends the log event
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 发送日志事件
- en: To see this scenario run, restart Fluentd as we did in section 11.7.1\. This
    means that the log events will, when received, be displayed in Fluentd’s console
    session. Then, in the second shell, we need to run the command (from `Chapter11/clients`
    folder)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到此场景运行，需要重新启动Fluentd，就像我们在11.7.1节中所做的那样。这意味着当收到日志事件时，它们将在Fluentd的控制台会话中显示。然后，在第二个shell中，我们需要在`Chapter11/clients`文件夹中运行以下命令
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 11.7.3 Illustration with only Python’s logging
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.3 仅使用Python的日志库的示例
- en: In the examples so far, the logging has used the Fluentd logging library directly
    (using its sender object) and indirectly (using the Python logging framework and
    configuration). This time, we’re going to look at how we can work without using
    the Fluentd library at all. If you examine the code of the Fluentd library, you
    will find the library uses the msgpack compression mechanism that we encountered
    in chapters 3 and 4\. Msgpack is part of Fluentd, not the native Python logging
    itself. As a result, when working with only the native layer, we don’t benefit
    from the compression provided by msgpack. The only way to overcome this would
    be to implement our own formatter code that uses msgpack.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，日志记录直接使用了 Fluentd 日志库（使用其发送对象）和间接使用（使用 Python 日志框架和配置）。这次，我们将探讨在不使用
    Fluentd 库的情况下如何工作。如果您检查 Fluentd 库的代码，您会发现该库使用我们在第 3 章和第 4 章中遇到的 msgpack 压缩机制。Msgpack
    是 Fluentd 的一部分，而不是 Python 日志本身的本地部分。因此，当仅使用本地层工作时，我们无法从 msgpack 提供的压缩中受益。克服这一点的唯一方法是我们实现自己的格式化代码，该代码使用
    msgpack。
- en: Without resorting to developing your own version of the Fluentd library, the
    next option is to use a prebuilt Python logging handler (or, as we have called
    it, an appender) to talk to Fluentd directly. The value of this approach for Python
    is nonexistent. But it may be necessary if you wanted to use a comparative approach
    in another language.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在不开发自己版本的 Fluentd 库的情况下，下一个选项是使用预构建的 Python 日志处理器（或我们称之为附加器）直接与 Fluentd 通信。这种方法对
    Python 来说价值不大。但如果您想在另一种语言中使用比较方法，这可能是有必要的。
- en: As not all languages benefit from the Fluentd library, let’s look at how things
    need to be implemented without that help. In this case, we will exploit the prebuilt
    `HTTPHandler` (most languages have a comparable feature). As with the preceding
    illustrations, we have provided another client implementation shown in listing
    11.5\. For this to work, we instantiate a Python `HTTPHandler` for logging, with
    the necessary connection details. Note that in the connection, we provide both
    the server address and a URL path separately. Fluentd will expect a path rather
    than an attempt to talk to the root address. We have provided a custom formatter
    and attached that to the handler. We then go through the same formatting process
    to form part of the log event and invoke the logger object with the log event
    string.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并非所有语言都能从 Fluentd 库中受益，让我们看看在没有这种帮助的情况下需要如何实现。在这种情况下，我们将利用预构建的 `HTTPHandler`（大多数语言都有类似的功能）。与前面的示例一样，我们提供了另一个客户端实现，如列表
    11.5 所示。为了使其工作，我们实例化一个 Python `HTTPHandler` 用于日志记录，并包含必要的连接细节。请注意，在连接中，我们分别提供了服务器地址和
    URL 路径。Fluentd 预期的是一个路径，而不是尝试与根地址通信。我们提供了一个自定义格式化程序并将其附加到处理器上。然后我们通过相同的格式化过程来形成日志事件的一部分，并使用日志事件字符串调用日志记录器对象。
- en: Using the prebuilt HTTPHandler means that the Fluentd configuration will need
    an HTTP source plugin to be included, which we have already done.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预构建的 HTTPHandler 意味着 Fluentd 配置需要包含一个 HTTP 源插件，这我们已经完成了。
- en: Listing 11.5 Chapter11/clients/log-simple.py—Direct Fluentd library use
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.5 Chapter11/clients/log-simple.py—直接使用 Fluentd 库
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Needs to import the core classes for both logging and the handlers
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 需要导入日志和处理器所需的核心类
- en: ❷ Creates the HTTPHandler and provides the details; in a secured production
    environment, this would include the use of certificates as well.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建 HTTPHandler 并提供详细信息；在受保护的生产环境中，这还包括使用证书。
- en: ❸ Creates the logger to use if it doesn’t already exist
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果尚未存在，则创建要使用的记录器
- en: ❹ We add the log handler we created to the root log object ready for use.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们将创建的日志处理器添加到根日志对象中，以便使用。
- en: ❺ Invokes the handler. When implementing a language-specific version of this
    code, ideally you would use a library to generate the JSON rather than manually
    inject it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 调用处理器。在实现特定语言的代码版本时，理想情况下您会使用库来生成 JSON，而不是手动注入。
- en: 'To run this example, open two shells as done previously. Navigate the root
    folder, and then start up Fluentd. Once running, execute the Python script in
    each shell using the following commands (from the `Chapter11/clients` folder for
    the Python script):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，请像之前一样打开两个外壳。导航到根文件夹，然后启动 Fluentd。一旦运行，请在每个外壳中使用以下命令执行 Python 脚本（对于 Python
    脚本，请从 `Chapter11/clients` 文件夹执行）：
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 11.7.4 Illustration without Python’s logging or Fluentd library
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.4 无 Python 的 logging 或 Fluentd 库的示例
- en: While there is no reason to stop using the Python logging framework in the real
    world, it may not be an option in other languages, so let’s see how that might
    look. For continuity and ease of comparison, we’ll demonstrate what this could
    look like with Python. Most languages provide the means to interact with HTTP
    services without any dependencies. We can interact with the Fluentd HTTP source
    plugin, as we eliminated Fluentd’s logging library. But we are now responsible
    for constructing all the HTTP headers, handling the HTTP connection to keep things
    open, and closing the connections, as shown in listing 11.6\. This listing follows
    the same previous pattern of a client file to make it easy to make side-by-side
    comparisons.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在现实世界中没有停止使用 Python 日志框架的理由，但在其他语言中可能没有这样的选择，所以让我们看看这可能会是什么样子。为了保持连贯性和便于比较，我们将使用
    Python 来演示这一点。大多数语言都提供了与 HTTP 服务交互的手段，而不需要任何依赖。我们可以与 Fluentd HTTP 源插件交互，因为我们已经消除了
    Fluentd 的日志库。但现在我们负责构建所有的 HTTP 头部，处理 HTTP 连接以保持其开启，以及关闭连接，如列表 11.6 所示。这个列表遵循了之前客户端文件的相同模式，以便于进行并排比较。
- en: As you can see, code populates the header with details such as the content type
    and content length. This should feel familiar, as, in many ways, these few lines
    of code are exactly the same as how we configured Postman in our “Hello World”
    scenario in chapter 2\. As this is using the HTTP connection, we again don’t benefit
    from the msgpack compression.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码通过填充诸如内容类型和内容长度等详细信息来填充头部。这在很多方面应该感觉熟悉，因为这些几行代码与我们第 2 章中“Hello World”场景中配置
    Postman 的方式完全相同。由于这是使用 HTTP 连接，我们再次没有从 msgpack 压缩中受益。
- en: Listing 11.6 Chapter11/clients/log.py—logging without any support
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.6 Chapter11/clients/log.py—无任何支持的日志记录
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Manually populates the HTTP header attributes
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 手动填充 HTTP 头部属性
- en: ❷ Creates the connection
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建连接
- en: ❸ Sends the log event
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 发送日志事件
- en: ❹ We’re responsible for closing the resources.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们负责关闭资源。
- en: Assuming that the Fluentd server is still running from the previous examples,
    then all we need to do is run the command (from the `Chapter11/clients` folder)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 Fluentd 服务器仍然在运行之前的示例中，那么我们只需要运行命令（从 `Chapter11/clients` 文件夹）
- en: '[PRE10]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As before, we should expect to see the log events being written to the Fluentd
    server console.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们应该期待看到日志事件被写入 Fluentd 服务器控制台。
- en: 11.7.5 Porting the Fluentd calls to another language into action
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.5 将 Fluentd 调用端口到另一种语言的实现
- en: The company you work for is trialing some smart devices with some custom functionality
    in your manufacturing facility. The trialed smart devices are currently known
    to support several core languages, including Java, Python, and Ruby. The idea
    has been put forward that the smart devices already call the central server when
    they need or have to send data. Doing so allows battery power to be conserved
    by not powering wireless until it is needed. That principle could be applied to
    logging any issues that the smart devices experience. To keep the software footprint
    as small as possible, you have been asked to not add any additional libraries.
    You have been asked to provide a proof of concept as to whether the devices could
    talk directly to your current Fluentd infrastructure rather than needing a custom
    solution that acts as a proxy between the smart device and Fluentd.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您所在的公司正在其制造设施中试用一些具有自定义功能的智能设备。目前已知这些试用智能设备支持包括 Java、Python 和 Ruby 在内的几种核心语言。已经提出了一种观点，即智能设备在需要或必须发送数据时会调用中央服务器。这样做可以通过在需要时才开启无线电源来节省电池电量。这个原则可以应用于记录智能设备遇到的问题。为了尽可能保持软件占用空间最小，您被要求不要添加任何额外的库。您被要求提供一个概念证明，以证明设备是否可以直接与您当前的
    Fluentd 基础设施通信，而不是需要一个作为智能设备和 Fluentd 之间代理的定制解决方案。
- en: Answer
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 答案
- en: Our primary languages are Java and Groovy (Groovy running on the Java Virtual
    Machine). We have built a small Groovy example using native HTTP calls to a Fluentd
    server. This can be found in `Chapter11/ExerciseResults/native-fluentd .groovy`.
    Groovy does bring an overhead but allows us to produce the proof quickly, as we
    don’t need to set up a build and package setup (and we’ve previously introduced
    a Groovy setup in the book).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要语言是 Java 和 Groovy（Groovy 运行在 Java 虚拟机上）。我们已经使用原生 HTTP 调用创建了一个小的 Groovy
    示例，用于连接 Fluentd 服务器。这个示例可以在 `Chapter11/ExerciseResults/native-fluentd .groovy`
    中找到。Groovy 虽然带来了一些开销，但允许我们快速地生成证明，因为我们不需要设置构建和打包环境（我们已经在书中介绍了 Groovy 的设置）。
- en: You should have produced a similar outcome with your preferred language and
    demonstrated the result using our simple Fluentd configuration or one of your
    own.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经使用你喜欢的语言产生了类似的结果，并使用我们简单的Fluentd配置或你自己的配置来展示结果。
- en: '11.7.6 Using generic appenders: The takeaways'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7.6 使用通用appender：要点
- en: As you have seen, working with common protocols is possible, but it does increase
    the development effort. Additionally, without more effort, you do not gain the
    benefits of msgpack and knowing that the library has been proven. So, if you cannot
    use a prebuilt Fluentd library, consider looking for or developing a wrapper that
    will translate the way the logging framework works with the interface provided
    by the Fluentd library.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，使用通用协议是可能的，但这确实增加了开发工作量。此外，如果不付出更多努力，你将无法获得msgpack的好处，也不知道库已经被验证。因此，如果你不能使用预构建的Fluentd库，考虑寻找或开发一个包装器，该包装器将翻译日志框架与Fluentd库提供的接口之间的工作方式。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: There are efficiencies to be gained if the logging of events can be sent directly
    from the application without having to resort to using an intermediary, such as
    a file.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果事件日志可以直接从应用程序发送，而不必求助于使用中介，如文件，那么可以从中获得效率。
- en: Many logging frameworks have a common set of characteristics, although they
    are often called different things. These include an abstracted mechanism to send
    logs to a type of consumer (referred to as an *appender*, *handler*, or *sender*).
    Another common element is a decoupled formatter, which translates the log event
    to be represented in a manner that can be understood downstream.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多日志框架具有一组共同的特征，尽管它们通常被称作不同的名称。这些特征包括一个抽象的机制，用于将日志发送到一种消费者类型（称为*appender*、*handler*或*sender*）。另一个共同元素是一个解耦的格式化器，它将待表示的日志事件转换为下游可以理解的形式。
- en: 'When reviewing logging frameworks, a number of questions need to be asked about
    the framework to determine suitability: Does it have a native appender for Fluentd
    or other components used? Is it possible to fall back to writing to files? Can
    you transmit log events over HTTP(S) or TCP/IP?'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在审查日志框架时，需要就框架提出一些问题，以确定其适用性：它是否有为Fluentd或其他组件提供的本地appender？是否可以回退到写入文件？是否可以通过HTTP(S)或TCP/IP传输日志事件？
- en: Fluentd provides a series of logging libraries that support various programming
    languages, including Ruby, Java, Python, and others. These libraries can, in some
    cases, integrate with the language’s native logging framework.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fluentd提供了一系列支持各种编程语言的日志库，包括Ruby、Java、Python等。在某些情况下，这些库可以与语言的本地日志框架集成。
