- en: 18 Defining parametric types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18 定义参数化类型
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Working with and defining parametric methods and types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用和定义参数化方法和类型
- en: Using parametric types to improve type safety and catch bugs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数化类型提高类型安全性和捕获错误
- en: Improving memory usage and performance by using parametric types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用参数化类型提高内存使用率和性能
- en: In chapter 10, I introduced parametric types to help explain how the union type
    works. We have also discussed parametric types in relation to collections such
    as arrays, dictionaries, and sets. With type parameters, you can restrict which
    elements can be used in your collections and thus get better type safety. However,
    all previous usage of parametric types have been as users of parametric types
    defined by others.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10章中，我介绍了参数化类型来帮助解释联合类型的工作原理。我们还讨论了与数组、字典和集合等集合相关的参数化类型。通过类型参数，你可以限制在集合中使用哪些元素，从而获得更好的类型安全。然而，所有之前的参数化类型使用都是作为其他人定义的参数化类型的用户。
- en: 'In this chapter, I will show you how to make your own parametric types and
    cover some common misconceptions and pitfalls when dealing with parametric types.
    But why would you want to make your own parametric types? Parametric types in
    Julia have two key benefits, which we will explore in detail in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向你展示如何创建自己的参数化类型，并涵盖处理参数化类型时的一些常见误解和陷阱。但为什么你想创建自己的参数化类型呢？Julia中的参数化类型有两个关键优势，我们将在本章中详细探讨：
- en: Enabling more type-safe code. Julia can catch errors early at runtime, such
    as trying to put a string into an array of numbers.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用更安全的类型代码。Julia可以在运行时早期捕获错误，例如尝试将字符串放入数字数组中。
- en: Improving performance when working with large datasets.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理大型数据集时提高性能。
- en: 'You will explore these topics through geometric code in 2D space (for simplicity).
    I will attempt to motivate you with a possible use in your rocket example project:
    to express the position of a rocket in space you need a Point type to represent
    a position in space and a Vec2D type to represent force, acceleration, and velocity
    in different directions.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过在二维空间中的几何代码（为了简单起见）来探索这些主题。我将尝试通过你的火箭示例项目中的一个可能用途来激励你：为了表达火箭在空间中的位置，你需要一个Point类型来表示空间中的位置，以及一个Vec2D类型来表示不同方向上的力、加速度和速度。
- en: 18.1 Defining parametric methods
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.1 定义参数化方法
- en: I’ll start simply by presenting methods that take type parameters and exploring
    how type parameters can make your methods more type safe and reduce boilerplate.
    Before jumping in, let me refresh you on the concept of *type parameters*. Previously,
    I used an analogy with a function call y = f(x), where the function f takes a
    value x and produces a new value y (figure 18.1). Likewise, you can think of the
    type expression S = P{T} as parametric type P, taking a type parameter T and returning
    a new concrete type S. Both T and S are concrete types, while P is just a template
    for making types.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我将简单地通过展示接受类型参数的方法，并探讨类型参数如何使你的方法更安全并减少样板代码。在深入之前，让我先回顾一下*类型参数*的概念。之前，我使用了一个函数调用的类比
    y = f(x)，其中函数 f 接收一个值 x 并产生一个新的值 y（图18.1）。同样，你可以将类型表达式 S = P{T} 视为参数化类型 P，它接受一个类型参数
    T 并返回一个新的具体类型 S。T 和 S 都是具体类型，而 P 只是创建类型的模板。
- en: '![18-01](../Images/18-01.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![18-01](../Images/18-01.png)'
- en: Figure 18.1 Analogy between a function and a parameterized type. The former
    produces values, while the latter produces types.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.1函数与参数化类型之间的类比。前者产生值，而后者产生类型。
- en: The linearsearch function defined in listing 18.1 does a *linear search* through
    the array haystack, looking for the element needle.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.1中定义的linearsearch函数在数组haystack中进行*线性搜索*，寻找元素needle。
- en: Note Using a linear search means you are not doing anything clever. You just
    start at the first element and look at every element in succession. When you find
    the element you are looking for, you return the index of that element.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用线性搜索意味着你没有做任何聪明的事情。你只是从第一个元素开始，依次查看每个元素。当你找到你正在寻找的元素时，你返回该元素的索引。
- en: linearsearch is a parametric method because it takes a type parameter T. It
    is the where T clause that defines T as a type parameter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: linearsearch是一个参数化方法，因为它接受一个类型参数T。定义T为类型参数的是where T子句。
- en: Listing 18.1 linearsearch in collection haystack for element needle
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.1在集合haystack中搜索元素needle的线性搜索
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What advantages does using a type parameter provide in this case? Could you
    instead annotate haystack with the AbstractVector type and give needle the Any
    type annotation? No. That would not give the same strong type checking at runtime.
    You have defined linearsearch such that needle must have the same type as all
    the elements of haystack. Let me demonstrate in the REPL:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，使用类型参数提供了哪些优势？你能否用 AbstractVector 类型注解 haystack，并给 needle 提供任何类型注解？不。那样不会在运行时提供相同强度的类型检查。你已经定义了
    linearsearch，使得 needle 必须与 haystack 的所有元素具有相同的类型。让我在 REPL 中演示一下：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The error message tells you there is no method taking a vector with Int64 elements
    and a String search object. I have defined linearsearch such that whatever type
    T is, it must be the same for the haystack elements and the needle object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息告诉你没有方法可以接受一个包含 Int64 元素的向量和一个 String 搜索对象。我已经定义了 linearsearch，使得无论 T 是什么类型，它都必须与
    haystack 元素和 needle 对象相同。
- en: Parametric types do not only improve type safety, but they also provide opportunities
    for reducing boilerplate code. Say you wanted to implement your own version of
    the Julia typeof function. A naive approach would be writing the code like the
    following.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化类型不仅提高了类型安全性，还提供了减少样板代码的机会。假设你想实现你自己的 Julia typeof 函数版本。一个简单的方法是编写如下代码。
- en: Listing 18.2 Naive implementation of a typeof-style function
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.2 typeof 风格函数的简单实现
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can try kindof in the REPL and see that it works for 64-bit integer values,
    floating-point values, and strings. However, that’s it. Trying to add a method
    for every type in Julia is a fool’s errand. As you may have guessed already, defining
    kindof as a parametric method solves the problem elegantly, as follows.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 REPL 中尝试 kindof 并看到它适用于 64 位整数值、浮点值和字符串。然而，仅此而已。尝试为 Julia 中的每个类型添加方法是一个徒劳之举。正如你可能已经猜到的，将
    kindof 定义为参数化方法优雅地解决了这个问题，如下所示。
- en: Listing 18.3 Implementing kindof using a type parameter
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.3 使用类型参数实现 kindof
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'While names like T, S, T1, and T2 are popular for denoting type parameters,
    you could use any name; the name is not essential. It is the where clause that
    turns the name into a type parameter. Let’s hammer this point home by restarting
    Julia and defining a type parameter named Int64:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 T、S、T1 和 T2 等名称常用于表示类型参数，但你也可以使用任何名称；名称不是关键。是 where 子句将名称转换为类型参数。让我们通过重新启动
    Julia 并定义一个名为 Int64 的类型参数来强调这一点：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The fact that Int64 is an actual type doesn’t matter here. The where clause
    turns Int64 into a type parameter and prevents it from being interpreted as a
    concrete type. Of course, you should avoid using known types as type parameter
    names, as this would massively confuse readers of your code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Int64 是一个实际类型的事实在这里并不重要。where 子句将 Int64 转换为类型参数，并防止它被解释为具体类型。当然，你应该避免使用已知类型作为类型参数的名称，因为这会极大地混淆代码的读者。
- en: 18.2 Defining parametric types
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.2 定义参数化类型
- en: Through the whole book we’ve used parametric types such as arrays, dictionaries,
    and tuples, but we have not defined such types ourselves. Let’s look at how that
    can be done.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们使用了数组、字典和元组等参数化类型，但我们并没有自己定义这些类型。让我们看看如何实现这一点。
- en: I will define the types Point and Vec2D. Figure 18.2 shows the relation between
    points and vectors in the coordinate space. Points are usually drawn like dots,
    while vectors are drawn like arrows. A vector represents a displacement along
    each axis in the coordinate system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我将定义 Point 和 Vec2D 类型。图 18.2 展示了坐标空间中点和向量之间的关系。点通常以点状绘制，而向量则以箭头形式绘制。向量表示在坐标系中每个轴上的位移。
- en: '![18-02](../Images/18-02.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![18-02](../Images/18-02.png)'
- en: Figure 18.2 The geometric relation between points and vectors
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.2 点和向量之间的几何关系
- en: Mathematically speaking, points and vectors are related through different operations.
    If you subtract the point E from point F, you get vector **u**. You could flip
    this around and add vector **u** to point E to get point F. I will discuss these
    details in greater depth later. First, I want to walk you through the details
    of a parametric type definition (listing 18.4). Don’t define these in the REPL
    yet because you will modify the definitions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学的角度讲，点和向量通过不同的运算相关联。如果你从点 F 减去点 E，你会得到向量 **u**。你也可以反过来，将向量 **u** 加到点 E 上以得到点
    F。我将在稍后更深入地讨论这些细节。首先，我想带你详细了解参数化类型定义的细节（列表 18.4）。请在 REPL 中不要定义这些，因为你会修改这些定义。
- en: Listing 18.4 Defining parametric types Point and Vec2D
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.4 定义参数化类型 Point 和 Vec2D
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Use \Delta to get the Δ symbol. It is a symbol commonly used in mathematics
    to represent differences or displacements.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 \Delta 获取 Δ 符号。它是数学中常用以表示差异或位移的符号。
- en: Point and Vec2D should not be thought of as types but templates for creating
    actual types. To create an actual type, you must provide a concrete type for the
    type parameter T. Without parametric types, you would have had to define numerous
    concrete types to deal with different numbers. Every method would have had to
    be defined for every type, leading to code bloat. For instance, with a parametric
    type, you could define norm once. Without it, you would need to define it for
    every concrete 2D vector type, as shown in the following listing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Point 和 Vec2D 不应被视为类型，而应被视为创建实际类型的模板。要创建一个实际类型，你必须为类型参数 T 提供一个具体类型。如果没有参数化类型，你将不得不定义许多具体类型来处理不同的数字。每个方法都必须为每个类型定义，从而导致代码膨胀。例如，使用参数化类型，你可以只定义一次
    norm。如果没有它，你将需要为每个具体的 2D 向量类型定义它，如下面的列表所示。
- en: Listing 18.5 Code bloat when you don’t have parametric types
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.5 没有参数化类型时的代码膨胀
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A Python, Ruby, or JavaScript developer, however, would object to this approach
    and say it is completely unnecessary to define multiple concrete types. If you
    want flexibility in the type for Δx and Δy just leave out the type annotation,
    as shown in the following listing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个 Python、Ruby 或 JavaScript 开发者可能会反对这种做法，并说定义多个具体类型是完全不必要的。如果你想在 Δx 和 Δy
    的类型上获得灵活性，只需省略类型注解，如下面的列表所示。
- en: Listing 18.6 Vec2 type without type annotations (any type)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.6 没有类型注解的 Vec2 类型（任何类型）
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Nothing prevents you from defining a 2D vector in this manner. So why not do
    it that way and avoid all the extra complexities introduced by parametric types?
    Dropping annotations is bad for numerous reasons:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何东西阻止你以这种方式定义一个 2D 向量。那么为什么不这样做，从而避免参数化类型引入的所有额外复杂性呢？省略注解有多个原因：
- en: You take away valuable type checking at runtime performed by the Julia JIT compiler.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你剥夺了 Julia JIT 编译器在运行时进行的宝贵类型检查。
- en: You increase memory usage and reduce performance.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你增加了内存使用并降低了性能。
- en: I’ll cover each of these points in greater detail.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我将更详细地介绍这些观点。
- en: 18.3 Type safety benefits from parametric types
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.3 参数化类型带来的类型安全优势
- en: 'I will compare 2D vectors with and without type annotations to show the type
    safety benefits of using parametric types. I’ll start by creating two throwaway
    types, GVec2D and PVec2D, just for this comparison. I will not be building on
    these types further. Notice how it is perfectly valid to define a type definition
    on a single line—just separate individual statements with a semicolon. GVec2D
    is the weakly typed variant, and PVec2D is the strongly typed variant:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过比较有类型注解和无类型注解的 2D 向量来展示使用参数化类型的类型安全优势。我将首先创建两个临时类型，GVec2D 和 PVec2D，仅用于这个比较。我不会进一步构建这些类型。注意，在单行上定义类型定义是完全有效的——只需用分号分隔单个语句即可。GVec2D
    是弱类型变体，而 PVec2D 是强类型变体：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Create a composite data type without type annotations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个没有类型注解的复合数据类型。
- en: ❷ Add type annotations to fields in the new data type.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在新数据类型的字段中添加类型注解。
- en: ❸ There are no restrictions on argument types.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对参数类型没有限制。
- en: ❹ Type annotations prevent wrong types from being input.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 类型注解阻止了错误类型的输入。
- en: ❺ Infer the type parameter from arguments.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 从参数中推断类型参数。
- en: ❻ Explicitly set the type parameter to Int.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 明确设置类型参数为 Int。
- en: The GVec2D does not use type annotations, and thus when creating the q point
    I get no complaints from Julia about using two different numbers types for representing
    the *x* and *y* delta. If you were to try that with PVec2D, which has type annotations,
    the Julia JIT compiler would complain because you are trying to use two different
    types of Δx and Δy. Because of this problem, Julia has no way of inferring what
    the type parameter T should be, and it must give up and throw an exception. That
    helps you catch cases in which you are not paying attention to the types of numbers
    you are passing around in your code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: GVec2D 不使用类型注解，因此当创建 q 点时，我从 Julia 那里没有收到关于使用两种不同的数字类型来表示 *x* 和 *y* 的 delta
    的任何抱怨。如果你尝试使用具有类型注解的 PVec2D，Julia JIT 编译器会抱怨，因为你正在尝试使用两种不同类型的 Δx 和 Δy。由于这个问题，Julia
    没有办法推断类型参数 T 应该是什么，它必须放弃并抛出异常。这有助于你捕捉到你没有注意代码中传递的数字类型的情况。
- en: 'This issue can be solved in two ways: Either make sure each argument is of
    the same type or use the curly braces {} to explicitly state what the type parameter
    is rather than asking Julia to infer it. Julia will then know the type of each
    field and perform an automatic conversion to that number type. Both are valid
    choices.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题可以通过两种方式解决：要么确保每个参数具有相同的类型，要么使用花括号 {} 明确地声明类型参数，而不是让 Julia 推断它。然后 Julia
    将知道每个字段的类型，并自动将其转换为该数值类型。这两种选择都是有效的。
- en: 'Type safety can be taken much further with parametric types. Do you remember
    the <: subtype operator? You have used this operator in a variety of cases, including
    testing whether one type is a subtype of another and indicating that a composite
    type is a subtype of an abstract type. You can also use this operator to impose
    constraints on the type parameter T. Currently, T can be any type, including nonnumerical
    types. That is not desirable, as coordinates are represented by numbers. The final
    Vec2D type, shown in the following listing, will constrain T to being a number.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数化类型可以进一步提高类型安全性。你还记得 `<:` 子类型操作符吗？你已经在各种情况下使用过这个操作符，包括测试一个类型是否是另一个类型的子类型，以及表明一个复合类型是抽象类型的子类型。你还可以使用这个操作符来对类型参数
    T 施加约束。目前，T 可以是任何类型，包括非数值类型。这并不理想，因为坐标是由数字表示的。下面的列表中显示的最终 Vec2D 类型将约束 T 为一个数字。
- en: Listing 18.7 Point and Vec2D defined so the type parameter must be a number
    type
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.7 定义 Point 和 Vec2D，使得类型参数必须是数值类型
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can see there is no problem creating a PVec2D of characters because the
    type parameter T has not been constrained in any way. Vec2D, on the other hand,
    will not accept characters as arguments. Try experimenting with different values
    yourself to validate that the type constraints work:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到创建一个字符的 PVec2D 没有问题，因为类型参数 T 没有以任何方式被约束。另一方面，Vec2D 将不接受字符作为参数。尝试自己用不同的值进行实验以验证类型约束是否有效：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Thus far you have only used one type parameter in all expressions. But you know
    from using dictionaries, tuples, and pairs that there can be many type parameters.
    For the point subtraction operator in listing 18.7, I have required each point
    p and q to have the same number type, but this is not required. Listing 18.8 demonstrates
    the subtraction operator implemented with different number types for point p and
    q.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只在使用所有表达式中使用了一个类型参数。但你知道从使用字典、元组和配对中，可以有多个类型参数。对于列表 18.7 中的点减法操作符，我要求每个点
    p 和 q 必须具有相同的数值类型，但这不是必需的。列表 18.8 展示了使用点 p 和 q 的不同数值类型实现的减法操作符。
- en: Listing 18.8 Substract defined so arguments p and q don’t need to be the same
    type
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.8 定义减法操作，使得参数 p 和 q 不需要是同一类型
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Shorthand version without explicit type parameters
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 无显式类型参数的简写版本
- en: Because in this example I am not using the type parameters T and S to constrain
    anything, I can omit them entirely. In Julia, writing Point is equivalent to writing
    Point{T} if T is unconstrained (figure 18.3 illustrates these type relationships).
    For instance, if you have a function sum that takes a vector as argument and you
    aren’t concerned with the types of the elements, you could write sum(xs::Vector),
    which is identical to writing sum(xs::Vector{T}) where T.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在这个例子中，我没有使用类型参数 T 和 S 来约束任何内容，所以我可以完全省略它们。在 Julia 中，编写 Point 等同于编写 Point{T}，如果
    T 没有约束（图 18.3 展示了这些类型关系）。例如，如果你有一个函数 sum，它接受一个向量作为参数，而你又不关心元素的类型，你可以写 sum(xs::Vector)，这等同于写
    sum(xs::Vector{T}) 其中 T。
- en: '![18-03](../Images/18-03.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![18-03](../Images/18-03.png)'
- en: Figure 18.3 Subtype relations between parametric types. Functions taking parametric
    type A will, for instance, accept values of type A{Int64} and A{Char}.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.3 参数化类型之间的子类型关系。接受参数化类型 A 的函数，例如，将接受类型 A{Int64} 和 A{Char} 的值。
- en: In parametric methods, the key reason for using a named type parameter such
    as T is that you want to express that two or more arguments use the same type
    parameter. In other cases you don’t want to enforce such a strict requirement.
    Instead you simply want the type parameters to be of a similar type. Say you want
    subtraction between points to only apply to integers (see the following listing).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在参数化方法中，使用命名类型参数（如 T）的关键原因是你想表达两个或多个参数使用相同的类型参数。在其他情况下，你不想强制执行这样的严格要求。相反，你只想让类型参数具有相似的类型。比如说，你只想让点之间的减法运算适用于整数（见以下列表）。
- en: Listing 18.9 Arguments p and q constrained to have integer-based type parameters
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 18.9 参数化类型 p 和 q 被约束为具有基于整数的类型参数
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, p could have UInt8 fields, while q could have Int16 fields. The
    example is, of course, contrived, as this particular restriction does not make
    sense. So why didn’t I constrain p and q to Number? Wouldn’t that be more realistic?
    It would not because there is no way to create Point objects that don’t contain
    numbers. Remember that is a constraint on the type parameter to the Point type
    itself and its associated constructor.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，p可以具有UInt8字段，而q可以具有Int16字段。这个例子当然是人为的，因为这个特定的限制没有意义。那么为什么我没有将p和q限制为Number呢？这不是更现实吗？不会，因为没有办法创建不包含数字的Point对象。记住，这是对Point类型及其相关构造函数的类型参数的约束。
- en: 18.4 Performance benefits from parametric types
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.4 参数化类型带来的性能优势
- en: Julia is a high-performance, dynamic language. Without parametric types, that
    would not be possible. Let’s discuss how parametric types influence performance.
    A benefit of understanding this is that you can more easily anticipate performance
    problems in your code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Julia是一种高性能的动态语言。没有参数化类型，这是不可能的。让我们讨论参数化类型是如何影响性能的。了解这一点的好处是，你可以更容易地预测你代码中的性能问题。
- en: One of the key reasons dynamically typed languages are slow is because of something
    called *boxing*. Its name comes from the fact that most values have to be put
    in special containers that contain information about the value they contain, including
    its type and garbage collection details, which could be a mark or a reference
    count (see figure 18.4). The specifics of how the garbage collection occurs (i.e.,
    how memory is freed) is not essential to this argument. The key point is that
    these generic containers have a bunch of bookkeeping data.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型语言运行缓慢的一个关键原因是所谓的*装箱*。这个名字来源于大多数值必须放入特殊的容器中，这些容器包含有关它们包含的值的信息，包括其类型和垃圾回收细节，这可能是一个标记或引用计数（见图18.4）。垃圾回收发生的具体细节（即内存释放的方式）对于这个论点不是本质的。关键点是这些通用容器有一堆账本数据。
- en: '![18-04](../Images/18-04.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![18-04](../Images/18-04.png)'
- en: Figure 18.4 The difference between boxed and unboxed values
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.4 装箱值和非装箱值的区别
- en: What is the point of this bookkeeping data? It is what allows you to handle
    arbitrary values at runtime. Imagine a simple function multiply for scaling a
    vector by a constant k (see the following listing).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种账本数据有什么用呢？它允许你在运行时处理任意值。想象一个简单的函数multiply，用于将向量乘以一个常数k（见以下列表）。
- en: Listing 18.10 Vec2D defined with abstract type fields to mimic regular dynamic
    languages
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.10 使用抽象类型字段定义的Vec2D，以模仿常规动态语言
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ To support explanation not for running
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 支持解释而非运行
- en: ❷ Need to be boxed
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 需要装箱
- en: This looks simple, right? But in a dynamic language, lots of code must run to
    perform this operation. In the following listing, I will walk you through a Julia
    pseudocode variant of what is going on.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单，对吧？但在动态语言中，执行这个操作需要运行很多代码。在以下列表中，我将带你了解Julia伪代码变体中正在发生的事情。
- en: Listing 18.11 Pseudocode of how multiply would work in a normal dynamic language
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表18.11 在正常动态语言中乘法将如何工作的伪代码
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code is not meant to be an accurate representation of what is going on.
    Think of it more as a form of pseudocode to help develop a rough intuition about
    how dynamic languages work under the hood.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不是要准确表示正在发生的事情。把它看作是一种伪代码，有助于你大致了解动态语言在底层是如何工作的。
- en: In most dynamic languages, you don’t know what fields a composite type has until
    runtime. That means you cannot generate code accessing fields directly, which
    is why you see the getfield(u, :Δx) line in listing 18.11\. You must verify that
    each field is actually present and of the expected type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数动态语言中，你不知道复合类型有哪些字段，直到运行时。这意味着你不能生成直接访问字段的代码，这就是为什么你在列表18.11中看到getfield(u,
    :Δx)这一行。你必须验证每个字段实际上都存在并且是预期的类型。
- en: 'Julia does not have this problem because it imposes a series of restrictions
    on its types that are not common in other dynamic languages:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Julia没有这个问题，因为它对其类型施加了一系列在其他动态语言中不常见的限制：
- en: Fields are fixed by the type. Instances of a type cannot add or remove fields
    at runtime.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段由类型固定。类型的实例在运行时不能添加或删除字段。
- en: You cannot store values that don’t match the field types on a composite object.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能在复合对象上存储与字段类型不匹配的值。
- en: These restrictions greatly simplify the job for the Julia JIT compiler when
    it tries to generate optimized machine code. For a refresher on Julia method calls
    see section 7.4\. The key takeaway is that when Julia generates code for a method,
    it knows *exactly* what the type of every input argument is. Since types cannot
    change in Julia, the JIT compiler will also know exactly what fields the arguments
    have and their types. This allows Julia to generate highly optimized machine code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制大大简化了Julia JIT编译器在尝试生成优化机器代码时的任务。关于Julia方法调用的复习，请参阅第7.4节。关键要点是，当Julia为方法生成代码时，它确切地知道每个输入参数的类型。由于在Julia中类型不能改变，JIT编译器也将确切知道参数具有哪些字段及其类型。这允许Julia生成高度优化的机器代码。
- en: 18.5 Memory benefits of parametric types
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.5 参数类型内存优势
- en: The benefits of parametric types don’t stop at allowing the compiler to create
    more optimized code and include making it easier to have a more optimized layout
    of data in memory. If you define an array of type Vector{Point{Int32}} with *N*
    number of elements, then the Julia JIT can figure out exactly how many bytes are
    required to hold all those elements. That allows you to avoid memory fragmentation,
    which reduces the amount of available memory and performance of your applications.
    In short, parametric types give you better type safety, performance, and memory
    usage.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 参数类型的优势不仅在于允许编译器生成更优化的代码，还包括使内存中数据的优化布局更容易实现。如果你定义了一个类型为Vector{Point{Int32}}的数组，包含*N*个元素，那么Julia
    JIT可以精确计算出存储所有这些元素所需的字节数。这允许你避免内存碎片化，从而减少可用内存和应用程序的性能。简而言之，参数类型为你提供了更好的类型安全、性能和内存使用。
- en: Summary
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Parametric types improve type safety at runtime.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数类型在运行时提高了类型安全。
- en: Julia determines whether a type is a type parameter in a function definition
    by looking at the where clause.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia通过查看where子句来确定一个类型是否是函数定义中的类型参数。
- en: Type parameters can be named anything, including actual type names, such as
    Int8 and Char. However, to avoid confusing developers reading your code, try to
    use names such as T, T1, T2, and S.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型参数可以命名为任何东西，包括实际的类型名称，例如Int8和Char。然而，为了避免混淆阅读你代码的开发者，尽量使用T、T1、T2和S等名称。
- en: For composite types use {T1, T2, T3} to specify a type with three different
    type parameters.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于复合类型，使用{T1, T2, T3}来指定具有三个不同类型参数的类型。
- en: 'Use the subtype operator T <: S to constrain a parametric type T to being a
    subtype of another type S.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用子类型运算符T <: S来约束参数类型T成为另一个类型S的子类型。'
- en: Boxing is when values are stored with bookkeeping information to help determine
    the data type stored at runtime.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号化是指存储值时带有账目信息，以帮助确定在运行时存储的数据类型。
- en: Boxing kills the performance of dynamic languages. Parametric types combined
    with immutable types minimize the usage of boxing in Julia and thus allow the
    compiler to generate optimized machine code.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号化（Boxing）会降低动态语言的性能。在Julia中，参数类型与不可变类型结合使用，最小化了括号化的使用，从而允许编译器生成优化的机器代码。
- en: Parametric types provide a more optimal memory layout for collections and individual
    objects, reducing memory usage and improving performance.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数类型为集合和单个对象提供了更优的内存布局，减少了内存使用并提高了性能。
