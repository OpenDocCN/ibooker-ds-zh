- en: 9 Miscellaneous problems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 其他问题
- en: 'Throughout this book we have covered a myriad of problem-solving techniques
    relevant to modern software development tasks. To study each technique, we have
    explored famous computer science problems. But not every famous problem fits the
    mold of the prior chapters. This chapter is a gathering point for famous problems
    that did not quite fit into any other chapter. Think of these problems as a bonus:
    more interesting problems with less scaffolding around them.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们已经涵盖了与现代软件开发任务相关的众多问题解决技术。为了研究每种技术，我们探讨了著名的计算机科学问题。但并非每个著名问题都适合前几章的模式。本章是那些不太适合其他章节的著名问题的汇集点。将这些问题视为额外奖励：更有趣的问题，周围的支持结构较少。
- en: 9.1 The knapsack problem
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 背包问题
- en: The knapsack problem is an optimization problem that takes a common computational
    need--finding the best use of limited resources given a finite set of usage options--and
    spins it into a fun story. A thief enters a home with the intent to steal. He
    has a knapsack, and he is limited in what he can steal by the capacity of the
    knapsack. How does he figure out what to put into the knapsack? The problem is
    illustrated in figure 9.1.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 背包问题是一个优化问题，它将一个常见的计算需求——在有限的使用选项中找到有限资源的最佳使用方式——转化为一个有趣的故事。一个小偷带着偷东西的意图进入一栋房子。他有一个背包，他可以偷的东西受到背包容量的限制。他是如何决定把什么放进背包的呢？这个问题在图9.1中得到了说明。
- en: '![9-1](../Images/9-1.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![9-1](../Images/9-1.png)'
- en: Figure 9.1 The burglar must decide what items to steal because the capacity
    of the knapsack is limited.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 小偷必须决定要偷哪些物品，因为背包的容量是有限的。
- en: 'If the thief could take any amount of any item, he could simply divide each
    item’s value by its weight to figure out the most valuable items for the available
    capacity. But to make the scenario more realistic, let’s say that the thief cannot
    take half of an item (such as 2.5 televisions). Instead, we will come up with
    a way to solve the 0/1 variant of the problem, so-called because it enforces another
    rule: the thief may only take one or none of each item.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果小偷可以拿走任何数量的任何物品，他可以简单地通过将每个物品的价值除以它的重量来找出在可用容量下最有价值的物品。但为了使场景更现实，让我们假设小偷不能拿走物品的一半（例如2.5台电视）。相反，我们将想出一个方法来解决0/1变体的问题，之所以称为0/1变体，是因为它强制执行另一条规则：小偷只能拿走每个物品的一个或零个。
- en: First, let’s define an inner class, Item, to hold our items.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个内部类，Item，来存储我们的物品。
- en: Listing 9.1 Knapsack.java
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1 Knapsack.java
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If we tried to solve this problem using a brute-force approach, we would look
    at every combination of items available to be put in the knapsack. For the mathematically
    inclined, this is known as a *powerset*, and a powerset of a set (in our case,
    the set of items) has 2^*N* different possible subsets, where *N* is the number
    of items. Therefore, we would need to analyze 2^*N* combinations (O(2^*N*)). This
    is okay for a small number of items, but it is untenable for a large number. Any
    approach that solves a problem using an exponential number of steps is an approach
    we want to avoid.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用暴力方法解决这个问题，我们将查看所有可能的物品组合，这些物品可以放入背包中。对于数学爱好者来说，这被称为*幂集*，一个集合（在我们的情况下，是物品集合）的幂集有2^*N*个不同的可能子集，其中*N*是物品的数量。因此，我们需要分析2^*N*种组合（O(2^*N*)）。对于少量物品来说，这还可以接受，但对于大量物品来说，这是不可行的。任何使用指数级步骤解决问题的方法都是我们想要避免的方法。
- en: Instead, we will use a technique known as *dynamic programming*, which is similar
    in concept to memoization (chapter 1). Instead of solving a problem outright with
    a brute-force approach, in dynamic programming one solves subproblems that make
    up the larger problem, stores those results, and utilizes those stored results
    to solve the larger problem. As long as the capacity of the knapsack is considered
    in discrete steps, the problem can be solved with dynamic programming.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将使用一种称为*动态规划*的技术，它在概念上与记忆化（第1章）相似。在动态规划中，不是直接使用暴力方法解决问题，而是解决构成更大问题的子问题，存储这些结果，并利用这些存储的结果来解决更大的问题。只要背包的容量被考虑为离散的步骤，问题就可以用动态规划来解决。
- en: For instance, to solve the problem for a knapsack with a 3-pound capacity and
    three items, we can first solve the problem for a 1-pound capacity and one possible
    item, 2-pound capacity and one possible item, and 3-pound capacity and one possible
    item. We can then use the results of that solution to solve the problem for 1-pound
    capacity and two possible items, 2-pound capacity and two possible items, and
    3-pound capacity and two possible items. Finally, we can solve for all three possible
    items.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了解决一个容量为 3 磅且有三件物品的背包问题，我们首先可以解决一个容量为 1 磅且有一件可能物品、2 磅容量且有一件可能物品、以及 3 磅容量且有一件可能物品的问题。然后，我们可以使用这个解决方案的结果来解决容量为
    1 磅且有两件可能物品、2 磅容量且有两件可能物品、以及 3 磅容量且有两件可能物品的问题。最后，我们可以解决所有三件可能物品的问题。
- en: All along the way we will fill in a table that tells us the best possible solution
    for each combination of items and capacity. Our function will first fill in the
    table and then figure out the solution based on the table.[1](#pgfId-1166175)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，我们将填写一个表格，告诉我们每种物品组合和容量的最佳解决方案。我们的函数首先填写表格，然后根据表格找出解决方案。[1](#pgfId-1166175)
- en: Listing 9.2 Knapsack.java continued
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 Knapsack.java 继续列出
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The inner loop of the first part of this function will execute *N* * *C* times,
    where *N* is the number of items and *C* is the maximum capacity of the knapsack.
    Therefore, the algorithm performs in O(*N* * *C*) time, a significant improvement
    over the brute-force approach for a large number of items. For instance, for the
    11 items that follow, a brute-force algorithm would need to examine 2^11, or 2,048,
    combinations. The preceding dynamic programming function will execute 825 times,
    because the maximum capacity of the knapsack in question is 75 arbitrary units
    (11 * 75). This difference would grow exponentially with more items.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数第一部分的内循环将执行 *N* * *C* 次，其中 *N* 是物品的数量，*C* 是背包的最大容量。因此，该算法的时间复杂度为 O(*N* *
    *C*)，对于大量物品来说，这是一个显著的改进。例如，对于接下来的 11 件物品，暴力算法需要检查 2^11，即 2,048 种组合。前面的动态规划函数将执行
    825 次，因为所讨论的背包的最大容量是 75 个任意单位（11 * 75）。随着物品数量的增加，这种差异将以指数级增长。
- en: Let’s look at the solution in action.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看解决方案的实际应用。
- en: Listing 9.3 Knapsack.java continued
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 Knapsack.java 继续列出
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you inspect the results printed to the console, you will see that the optimal
    items to take are the painting, jewelry, clothing, laptop, stereo, and candlesticks.
    Here’s some sample output showing the most valuable items for the thief to steal,
    given the limited-capacity knapsack:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查打印到控制台的结果，你会看到最佳选择物品是画作、珠宝、服装、笔记本电脑、立体声和烛台。以下是一些示例输出，显示了小偷在有限容量的背包中可以偷取的最有价值物品：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To get a better idea of how this all works, let’s look at some of the particulars
    of the knapsack() method:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一切是如何工作的，让我们看看 knapsack() 方法的某些具体细节：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For each possible number of items, we loop through all of the capacities in
    a linear fashion, up to the maximum capacity of the knapsack. Notice that I say
    “each possible number of items” instead of each item. When i equals 2, it does
    not just represent item 2\. It represents the possible combinations of the first
    two items for every explored capacity. item is the next item that we are considering
    stealing:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种可能的物品数量，我们以线性方式遍历所有容量，直到背包的最大容量。请注意，我说的是“每种可能的物品数量”，而不是每个物品。当 i 等于 2 时，它不仅仅代表第
    2 件物品。它代表在每种探索的容量下前两件物品的可能组合。item 是我们正在考虑偷取的下一件物品：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: prevItemValue is the value of the last combination of items at the current capacity
    being explored. For each possible combination of items, we consider whether adding
    in the latest “new” item is even possible.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: prevItemValue 是当前探索的容量下最后一种物品组合的值。对于每种可能的物品组合，我们考虑是否添加最新的“新”物品是可能的。
- en: 'If the item weighs more than the knapsack capacity we are considering, we simply
    copy over the value for the last combination of items that we considered for the
    capacity in question:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果物品的重量超过我们考虑的背包容量，我们只需简单地复制我们考虑的最后一个物品组合的值：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Otherwise, we consider whether adding in the “new” item will result in a higher
    value than the last combination of items at that capacity that we considered.
    We do this by adding the value of the item to the value already computed in the
    table for the previous combination of items at a capacity equal to the item’s
    weight, subtracted from the current capacity we are considering. If this value
    is higher than the last combination of items at the current capacity, we insert
    it; otherwise, we insert the last value:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们考虑添加“新”物品是否会比我们之前考虑的该容量下最后一种物品组合的价值更高。我们通过将物品的价值添加到表格中已经计算的前一个组合的价值，并从当前考虑的容量中减去物品的重量来实现这一点。如果这个值高于当前容量下的最后一种物品组合，我们就插入它；否则，我们插入最后一个值：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That concludes building up the table. To actually find which items are in the
    solution, though, we need to work backward from the highest capacity and the final
    explored combination of items:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了表格的构建。然而，要实际上找到解决方案中的物品，我们需要从最高容量和最终探索的物品组合开始反向工作：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We start from the end and loop through our table from right to left, checking
    whether there was a change in the value inserted into the table at each stop.
    If there was, that means we added the new item that was considered in a particular
    combination because the combination was more valuable than the prior one. Therefore,
    we add that item to the solution. Also, capacity is decreased by the weight of
    the item, which can be thought of as moving up the table:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从末尾开始，从右到左遍历我们的表格，检查在每个停止点是否插入了表中的值发生了变化。如果有变化，这意味着我们添加了在特定组合中考虑的新物品，因为该组合比先前的组合更有价值。因此，我们将该物品添加到解决方案中。同时，容量减少到物品的重量，这可以被视为向上移动表格：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note Throughout both the buildup of the table and the solution search, you may
    have noticed some manipulation of iterators and table size by 1\. This is done
    for convenience from a programmatic perspective. Think about how the problem is
    built from the bottom up. When the problem begins, we are dealing with a zero-capacity
    knapsack. If you work your way up from the bottom in a table, it will become clear
    why we need the extra row and column.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在整个表格构建和解决方案搜索过程中，你可能已经注意到了对迭代器和表格大小的1次操作。这是从程序化角度考虑的便利性。想想问题是如何从底部构建的。当问题开始时，我们处理的是一个零容量的背包。如果你从底部向上在表格中工作，就会清楚地知道为什么我们需要额外的行和列。
- en: 'Are you still confused? Table 9.1 is the table the knapsack() function builds.
    It would be quite a large table for the preceding problem, so instead, let’s look
    at a table for a knapsack with 3-pound capacity and three items: matches (1 pound),
    flashlight (2 pounds), and book (1 pound). Assume those items are valued at $5,
    $10, and $15, respectively.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你还是感到困惑吗？表9.1是knapsack()函数构建的表格。对于前面的问题，这将是一个相当大的表格，所以让我们看看一个容量为3磅、包含三个物品（火柴1磅、手电筒2磅和书1磅）的背包表格：假设这些物品的价值分别是$5、$10和$15。
- en: An example of a knapsack problem of three items
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 三个物品的背包问题的例子
- en: '|  | 0 lb. | 1 lb. | 2 lb. | 3 lb. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|  | 0磅 | 1磅 | 2磅 | 3磅 |'
- en: '| Matches (1 lb., $5) | 0 | 05 | 05 | 05 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 火柴（1磅，$5） | 0 | 05 | 05 | 05 |'
- en: '| Flashlight (2 lbs., $10) | 0 | 05 | 10 | 15 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 手电筒（2磅，$10） | 0 | 05 | 10 | 15 |'
- en: '| Book (1 lb., $15) | 0 | 15 | 20 | 25 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 书（1磅，$15） | 0 | 15 | 20 | 25 |'
- en: As you look across the table from left to right, the weight is increasing (how
    much you are trying to fit in the knapsack). As you look down the table from top
    to bottom, the number of items you are attempting to fit is increasing. On the
    first row, you are only trying to fit the matches. On the second row, you fit
    the most valuable combination of the matches and the flashlight that the knapsack
    can hold. On the third row, you fit the most valuable combination of all three
    items.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从左到右查看表格时，重量在增加（你试图放入背包中的物品重量）。当你从上到下查看表格时，你试图放入的物品数量在增加。在第一行，你只尝试放入火柴。在第二行，你放入背包能容纳的火柴和手电筒中最有价值的组合。在第三行，你放入所有三个物品中最有价值的组合。
- en: As an exercise to facilitate your understanding, try filling in a blank version
    of this table yourself, using the algorithm described in the knapsack() method
    with these same three items. Then use the algorithm at the end of the function
    to read back the right items from the table. This table corresponds to the table
    variable in the function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项练习，以帮助您更好地理解，请尝试自己填写这个表格的空白版本，使用knapsack()方法中描述的算法，并使用这三个相同的物品。然后使用函数末尾的算法从表中读取正确的物品。此表对应于函数中的table变量。
- en: 9.2 The Traveling Salesman Problem
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 旅行商问题
- en: The Traveling Salesman Problem is one of the most classic and talked-about problems
    in all of computing. A salesman must visit all of the cities on a map exactly
    once, returning to his start city at the end of the journey. There is a direct
    connection from every city to every other city, and the salesman may visit the
    cities in any order. What is the shortest path for the salesman?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 旅行商问题是计算领域中最为经典和广为人知的难题之一。销售人员必须访问地图上的所有城市恰好一次，并在旅程结束时返回他的起始城市。每个城市都有直接连接到其他所有城市的连接，销售人员可以按任何顺序访问城市。销售人员的最短路径是什么？
- en: The problem can be thought of as a graph problem (chapter 4), with the cities
    being the vertices and the connections between them being the edges. Your first
    instinct might be to find the minimum spanning tree, as described in chapter 4\.
    Unfortunately, the solution to the Traveling Salesman Problem is not so simple.
    The minimum spanning tree is the way to connect all of the cities with the least
    amount of road, but it does not provide the shortest path for visiting all of
    them exactly once.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将这个问题视为一个图问题（第4章），其中城市是顶点，它们之间的连接是边。您的第一反应可能是找到第4章中描述的最小生成树。不幸的是，旅行商问题的解决方案并不那么简单。最小生成树是连接所有城市所需道路最少的方法，但它并不提供访问所有城市恰好一次的最短路径。
- en: Although the problem, as posed, appears fairly simple, there is no algorithm
    that can solve it quickly for an arbitrary number of cities. What do I mean by
    “quickly”? I mean that the problem is what is known as *NP hard*. An NP-hard (non-deterministic
    polynomial hard) problem is a problem for which no polynomial time algorithm is
    known. (The time it takes is a polynomial function of the size of the input.)
    As the number of cities that the salesman needs to visit increases, the difficulty
    of solving the problem grows exceptionally quickly. It is much harder to solve
    the problem for 20 cities than 10\. It is impossible (to the best of current knowledge),
    in a reasonable amount of time, to solve the problem perfectly (optimally) for
    millions of cities.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个问题看起来相当简单，但没有任何算法可以快速解决任意数量的城市。我说的“快速”是什么意思？我的意思是这个问题是所谓的*NP难题*。一个NP难题（非确定性多项式难题）是对于该问题没有已知的多项式时间算法的问题。（所需时间是输入大小的多项式函数。）随着销售人员需要访问的城市数量的增加，解决问题的难度会异常迅速增长。对于20个城市来说，解决问题比10个城市要困难得多。根据目前的知识，在合理的时间内，不可能完美（最优）地解决数百万城市的问题。
- en: NOTE The naive approach to the Traveling Salesman Problem is O(*n*!). Why this
    is the case is discussed in section 9.2.2\. We suggest reading section 9.2.1 before
    reading 9.2.2, though, because the implementation of a naive solution to the problem
    will make its complexity obvious.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：旅行商问题的直观方法是O(*n*!)。为什么是这样，将在9.2.2节中讨论。尽管如此，我们建议在阅读9.2.2节之前先阅读9.2.1节，因为对问题的直观解决方案的实现将使其复杂性显而易见。
- en: 9.2.1 The naive approach
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 直观方法
- en: The naive approach to the problem is simply to try every possible combination
    of cities. Attempting the naive approach will illustrate the difficulty of the
    problem and this approach’s unsuitability for brute-force attempts at larger scales.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于该问题的直观方法是简单地尝试所有可能的城市的组合。尝试直观方法将说明问题的难度以及这种方法在更大规模上的不适用性。
- en: Our sample data
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的样本数据
- en: In our version of the Traveling Salesman Problem, the salesman is interested
    in visiting five of the major cities of Vermont. We will not specify a starting
    (and therefore ending) city. Figure 9.2 illustrates the five cities and the driving
    distances between them. Note that there is a distance listed for the route between
    every pair of cities.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们版本的旅行商问题中，销售人员有兴趣访问佛蒙特州的主要城市中的五个。我们不会指定一个起始城市（因此也是结束城市）。图9.2展示了这五个城市以及它们之间的驾驶距离。请注意，每对城市之间都列出了一个距离。
- en: Perhaps you have seen driving distances in table form before. In a driving-distance
    table, one can easily look up the distance between any two cities. Table 9.2 lists
    the driving distances for the five cities in the problem.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你之前已经见过以表格形式呈现的驾驶距离。在驾驶距离表中，可以轻松查找任何两个城市之间的距离。表9.2列出了问题中五个城市的驾驶距离。
- en: Driving distances between cities in Vermont
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 佛蒙特州城市之间的驾驶距离
- en: '|  | Rutland | Burlington | White River Junction | Bennington | Brattleboro
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '|  | Rutland | Burlington | White River Junction | Bennington | Brattleboro
    |'
- en: '| **Rutland** | 00 | 067 | 46 | 055 | 075 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| **Rutland** | 00 | 067 | 46 | 055 | 075 |'
- en: '| **Burlington** | 67 | 000 | 91 | 122 | 153 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **Burlington** | 67 | 000 | 91 | 122 | 153 |'
- en: '| **White River Junction** | 46 | 091 | 00 | 098 | 065 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **White River Junction** | 46 | 091 | 00 | 098 | 065 |'
- en: '| **Bennington** | 55 | 122 | 98 | 000 | 040 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **Bennington** | 55 | 122 | 98 | 000 | 040 |'
- en: '| **Brattleboro** | 75 | 153 | 65 | 040 | 000 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **Brattleboro** | 75 | 153 | 65 | 040 | 000 |'
- en: '![9-2](../Images/9-2.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![9-2](../Images/9-2.png)'
- en: Figure 9.2 Five cities in Vermont and the driving distances between them
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2佛蒙特州的五个城市及其之间的驾驶距离
- en: We will need to codify both the cities and the distances between them for our
    problem. To make the distances between cities easy to look up, we will use a map
    of maps, with the outer set of keys representing the first of a pair and the inner
    set of keys representing the second. This will be the type Map<String, Map<String,
    Integer>>, and it will allow lookups like vtDistances.get("Rutland").get("Burlington"),
    which should return 67\. We will use the vtDistances map when we actually solve
    the problem for Vermont, but first, let’s do some setup. Our class holds the map
    and has a utility method we will use later for doing a swap of the items at two
    locations within an array.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将城市及其之间的距离编码化，以解决我们的问题。为了使城市之间的距离易于查找，我们将使用一个地图的地图，外层键表示一对中的第一个，内层键表示第二个。这将是一个类型为Map<String,
    Map<String, Integer>>的地图，它将允许进行如vtDistances.get("Rutland").get("Burlington")这样的查找，它应该返回67。当我们实际解决佛蒙特州的问题时，我们将使用vtDistances地图，但首先，让我们做一些设置。我们的类包含这个地图，并有一个我们将稍后用于在数组中两个位置之间交换项的实用方法。
- en: Listing 9.4 TSP.java
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 TSP.java
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finding all permutations
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找所有排列
- en: The naive approach to solving the Traveling Salesman Problem requires generating
    every possible permutation of the cities. There are many permutation-generation
    algorithms; they are simple enough to ideate that you could almost certainly come
    up with one on your own.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 解决旅行商问题的直观方法需要生成所有可能的城市排列。有许多排列生成算法；它们足够简单，以至于你几乎可以自己想出一个。
- en: One common approach is backtracking. You first saw backtracking in chapter 3
    in the context of solving a constraint-satisfaction problem. In constraint-satisfaction
    problem solving, backtracking is used after a partial solution is found that does
    not satisfy the problem’s constraints. In such a case, you revert to an earlier
    state and continue the search along a different path than that which led to the
    incorrect partial solution.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的方法是回溯。你第一次在第三章中看到回溯是在解决约束满足问题的上下文中。在约束满足问题解决中，在找到一个不满足问题约束的局部解决方案后，使用回溯。在这种情况下，你回到一个较早的状态，并沿着不同于导致错误局部解决方案的路径继续搜索。
- en: To find all of the permutations of the items in an array (eventually, our cities),
    we will also use backtracking. After we make a swap between elements and go down
    a path of further permutations, we will backtrack to the state before the swap
    was made so we can make a different swap and go down a different path.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到数组中（最终是我们的城市）的所有排列，我们也将使用回溯法。在交换元素并进入进一步排列的路径之后，我们将回溯到交换之前的状态，以便我们可以进行不同的交换并沿着不同的路径前进。
- en: Listing 9.5 TSP.java continued
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.5 TSP.java继续
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This recursive function is labeled a “helper” because it will actually be called
    by another function that takes fewer arguments. The parameters of allPermutationsHelper()
    are the starting permutation we are working with, the permutations generated so
    far, and the number of remaining items to swap around.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个递归函数被标记为“辅助”函数，因为它实际上将由另一个参数较少的函数调用。allPermutationsHelper()的参数是我们正在处理的起始排列，到目前为止生成的排列，以及剩余要交换的项的数量。
- en: A common pattern for recursive functions that need to keep multiple items of
    state across calls is to have a separate outward-facing function with fewer parameters
    that is easier to use. allPermutations() is that simpler function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要跨调用保持多个状态项的递归函数，一个常见的模式是有一个具有较少参数的独立面向外部的函数，更容易使用。allPermutations()就是那个更简单的函数。
- en: Listing 9.6 TSP.java continued
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6 TSP.java继续
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'allPermutations() takes just a single argument: the array for which the permutations
    should be generated. It calls allPermutationsHelper() to find those permutations.
    This saves the user of allPermutations() from having to provide the parameters
    permutations and n to allPermutationsHelper().'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: allPermutations() 只接受一个参数：需要生成排列的数组。它调用 allPermutationsHelper() 来找到这些排列。这避免了
    allPermutations() 的用户需要向 allPermutationsHelper() 提供排列和 n 的参数。
- en: The backtracking approach to finding all permutations presented here is fairly
    efficient. Finding each permutation requires just two swaps within the array.
    However, it is possible to find all the permutations of an array with just one
    swap per permutation. One efficient algorithm that accomplishes that task is Heap’s
    algorithm (not to be confused with the heap data structure--Heap, in this case,
    is the name of the inventor of the algorithm).[2](#pgfId-1166611) This difference
    in efficiency may be important for very large data sets (which is not what we
    are dealing with here).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提出的回溯法寻找所有排列相当高效。找到每个排列只需要在数组中进行两次交换。然而，只需每个排列进行一次交换，就可以找到数组的所有排列。一个完成这个任务的效率高的算法是堆算法（不要与堆数据结构混淆——这里的堆是算法发明者的名字）。[2](#pgfId-1166611)
    这种效率差异对于非常大的数据集可能很重要（我们这里处理的数据集不是这样的）。
- en: Brute-force search
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 暴力搜索
- en: We can now generate all of the permutations of the city list, but this is not
    quite the same as a Traveling Salesman Problem path. Recall that in the Traveling
    Salesman Problem, the salesman must return, at the end, to the same city that
    he started in. We can easily add the distance from the last city the salesman
    visited to the first city visited when we calculate which path is the shortest,
    and we will do that shortly.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以生成城市列表的所有排列，但这并不完全等同于旅行商问题的路径。回想一下，在旅行商问题中，销售员必须最终返回他开始的城市。当我们计算哪条路径是最短的时候，我们可以轻松地加上销售员访问的最后一个城市到第一个访问的城市之间的距离，我们很快就会这么做。
- en: We are now ready to try testing the paths we have permuted. A brute-force search
    approach painstakingly looks at every path in a list of paths and uses the distance
    between the two cities in the lookup table (distances) to calculate each path’s
    total distance. It prints both the shortest path and that path’s total distance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以尝试测试我们排列的路径。暴力搜索方法痛苦地查看路径列表中的每一条路径，并使用查找表（distances）中两个城市之间的距离来计算每条路径的总距离。它打印出最短路径以及该路径的总距离。
- en: Listing 9.7 TSP.java continued
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.7 TSP.java继续
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We finally can brute-force the cities of Vermont, finding the shortest path
    to reach all five. The output should look something like the following, and the
    best path is illustrated in figure 9.3.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终可以暴力搜索佛蒙特州的城市，找到到达所有五个城市的最短路径。输出应该看起来像以下这样，最佳路径在图9.3中展示。
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![9-3](../Images/9-3.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![9-3](../Images/9-3.png)'
- en: Figure 9.3 The shortest path for the salesman to visit all five cities in Vermont
    is illustrated.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3展示了销售员访问佛蒙特州所有五个城市的最短路径。
- en: 9.2.2 Taking it to the next level
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 提升到下一个层次
- en: There is no easy answer to the Traveling Salesman Problem. Our naive approach
    quickly becomes infeasible. The number of permutations generated is *n* factorial
    (*n*!), where *n* is the number of cities in the problem. If we were to include
    just one more city (six instead of five), the number of evaluated paths would
    grow by a factor of six. Then it would be seven times harder to solve the problem
    for just one more city after that. This is not a scalable approach!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 旅行商问题没有简单的答案。我们直观的方法很快变得不可行。生成的排列数是 *n* 的阶乘 (*n*!)，其中 *n* 是问题中的城市数量。如果我们只增加一个城市（六个而不是五个），评估的路径数量将增加六倍。然后，在增加一个城市之后，解决问题将变得困难七倍。这不是一个可扩展的方法！
- en: In the real world, the naive approach to the Traveling Salesman Problem is seldom
    used. Most algorithms for instances of the problem with a large number of cities
    are approximations. They try to solve the problem for a near-optimal solution.
    The near-optimal solution may be within a small known band of the perfect solution.
    (For example, perhaps they will be no more than 5% less efficient.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，对旅行商问题的直观方法很少被使用。大多数用于具有大量城市的问题实例的算法都是近似解。它们试图为近最优解解决问题。近最优解可能位于完美解的小范围内。（例如，可能不会比完美解低5%。）
- en: Two techniques that have already appeared in this book have been used to attempt
    the Traveling Salesman Problem on large data sets. Dynamic programming, which
    we used in the knapsack problem earlier in this chapter, is one approach. Another
    is genetic algorithms, as described in chapter 5\. Many journal articles have
    been published attributing genetic algorithms to near-optimal solutions for the
    traveling salesman with large numbers of cities.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本书已经介绍过的两种技术已被用于在大数据集上尝试旅行商问题。动态规划，我们在本章早些时候的背包问题中使用过，是一种方法。另一种是遗传算法，如第5章所述。许多期刊文章已经发表，将遗传算法归因于具有大量城市的旅行商问题的近似最优解。
- en: 9.3 Phone number mnemonics
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 电话号码助记符
- en: Before there were smartphones with built-in address books, telephones included
    letters on each of the keys on their number pads. The reason for these letters
    was to provide easy mnemonics by which to remember phone numbers. In the United
    States, typically the 1 key would have no letters, 2 would have ABC, 3 DEF, 4
    GHI, 5 JKL, 6 MNO, 7 PQRS, 8 TUV, 9 WXYZ, and 0 no letters. For example, 1-800-MY-APPLE
    corresponds to the phone number 1-800-69-27753\. Once in a while you will still
    find these mnemonics in advertisements, so the numbers on the keypad have made
    their way into modern smartphone apps, as evidenced by figure 9.4.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在智能手机内置地址簿出现之前，电话的数字键盘上每个键都标有字母。这些字母的原因是为了提供易于记忆的助记符，以便记住电话号码。在美国，通常1键没有字母，2键有ABC，3键有DEF，4键有GHI，5键有JKL，6键有MNO，7键有PQRS，8键有TUV，9键有WXYZ，而0键没有字母。例如，1-800-MY-APPLE对应电话号码1-800-69-27753。偶尔你还会在广告中找到这些助记符，因此键盘上的数字已经进入了现代智能手机应用，如图9.4所示。
- en: '![9-4](../Images/9-4.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![9-4](../Images/9-4.png)'
- en: Figure 9.4 The Phone app in iOS retains the letters on keys that its telephone
    forebears contained.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 iOS中的电话应用保留了其电话前辈所包含的字母键。
- en: How does one come up with a new mnemonic for a phone number? In the 1990s there
    was popular shareware to help with the effort. These pieces of software would
    generate every ordered combination of a phone number’s letters and then look through
    a dictionary to find words that were contained in the combinations. They would
    then show the combinations with the most complete words to the user. We will do
    the first half of the problem. The dictionary lookup will be left as an exercise.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如何为电话号码想出一个新的助记符？在20世纪90年代，有流行的共享软件来帮助这项工作。这些软件会生成电话号码字母的每个有序组合，然后通过查找字典来寻找包含在这些组合中的单词。然后，它们会将包含最完整单词的组合显示给用户。我们将完成问题的前半部分。字典查找将留作练习。
- en: In the last problem, when we looked at permutation generation, we generated
    our answers by taking an existing permutation and swapping to get a different
    permutation. You can think about it like starting with a finished product and
    working backwards. For this problem, instead of swapping positions in an existing
    solution to generate a new one, we will generate each solution from the ground
    up, starting with an empty string. We will do this by looking at the letters that
    potentially match each numeral in the phone number and continually adding more
    options to the end as we go to each successive numeral. This is a kind of Cartesian
    product.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个问题中，当我们查看排列生成时，我们通过交换现有排列来生成不同的排列来得到答案。你可以把它想象成从一个成品开始，然后倒着工作。对于这个问题，我们不会通过交换现有解决方案中的位置来生成新的解决方案，而是从零开始生成每个解决方案，从一个空字符串开始。我们将通过查看可能匹配电话号码中每个数字的字母，并在我们到达每个后续数字时不断添加更多选项到末尾来实现这一点。这是一种笛卡尔积。
- en: What’s a Cartesian product? In set theory, a Cartesian product is the set of
    all combinations of the members from one set with each of the members in another
    set. For example, if one set contains the letters “A” and “B,” and another set
    contains the letters “C” and “D,” then the Cartesian product would be the set
    “AC,” “AD,” “BC,” and “BD.” “A” was combined with every letter it could in the
    second set, and “B” was combined with every letter it could in the second set.
    If our phone number were 234, we would need to find the Cartesian product of “A,”
    “B,” “C” with “D,” “E,” and “F.” Once we found that result, we would need to take
    it and find its Cartesian product with “G,” “H,” “I.” And that product of a product
    would be our answer.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是笛卡尔积？在集合论中，笛卡尔积是来自一个集合的每个成员与另一个集合中的每个成员的所有组合的集合。例如，如果一个集合包含字母“A”和“B”，另一个集合包含字母“C”和“D”，那么笛卡尔积将是集合“AC”、“AD”、“BC”和“BD”。“A”与第二个集合中它能结合的每个字母结合，而“B”与第二个集合中它能结合的每个字母结合。如果我们的电话号码是
    234，我们需要找到“ABC”与“DEF”的笛卡尔积。一旦我们找到了这个结果，我们还需要将其与“GHI”的笛卡尔积结合起来。这个积的积就是我们的答案。
- en: We will not be working with sets. We will be working with arrays. It is just
    more convenient for our data representation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会使用集合。我们将使用数组。这对我们的数据表示来说更方便。
- en: First, we will define a mapping of numerals to potential letters and a constructor.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个数字到潜在字母的映射和一个构造函数。
- en: Listing 9.8 PhoneNumberMnemonics.java
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.8 PhoneNumberMnemonics.java
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The next method performs a Cartesian product of two String arrays by simply
    adding every item in the first array to every item in the second array and aggregating
    those results.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法通过简单地将第一个数组中的每个项目添加到第二个数组中的每个项目，并汇总这些结果，执行两个字符串数组的笛卡尔积。
- en: Listing 9.9 PhoneNumberMnemonics.java continued
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.9 PhoneNumberMnemonics.java 继续显示
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now we can find all of the possible mnemonics for a phone number. getMnemonics()
    does this by successively taking the Cartesian product of each previous product
    (starting with an array of one empty string) and the array of letters representing
    the next numeral. main() runs getMnemonics() for any phone number provided by
    the user.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以找到电话号码的所有可能的助记符。`getMnemonics()` 通过逐次取每个先前积的笛卡尔积（从包含一个空字符串的数组开始）和表示下一个数字的字母数组来实现这一点。`main()`
    为用户提供的任何电话号码运行 `getMnemonics()`。
- en: Listing 9.10 PhoneNumberMnemonics.java continued
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.10 PhoneNumberMnemonics.java 继续显示
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It turns out that the phone number 1440787 can also be written as 1GH0STS. That
    is easier to remember.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，电话号码 1440787 也可以写成 1GH0STS。这样更容易记住。
- en: 9.4 Real-world applications
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 现实世界应用
- en: Dynamic programming, as used with the knapsack problem, is a widely applicable
    technique that can make seemingly intractable problems solvable by breaking them
    into constituent smaller problems and building up a solution from those parts.
    The knapsack problem itself is related to other optimization problems where a
    finite amount of resources (the capacity of the knapsack) must be allocated among
    a finite but exhaustive set of options (the items to steal). Imagine a college
    that needs to allocate its athletic budget. It does not have enough money to fund
    every team, and it has some expectation of how much alumni donations each team
    will bring in. It can run a knapsack-like problem to optimize the budget’s allocation.
    Problems like this are common in the real world.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划，如与背包问题一起使用，是一种广泛适用的技术，可以通过将问题分解为构成的小问题并从这些部分构建解决方案来解决看似难以解决的问题。背包问题本身与涉及有限资源（背包的容量）必须在有限但详尽的选项（要偷的物品）之间分配的其他优化问题相关。想象一下，一所大学需要分配其体育预算。它没有足够的钱来资助每个团队，并且对每个团队将带来的校友捐款有一定的期望。它可以运行类似背包的问题来优化预算的分配。这类问题在现实世界中很常见。
- en: The Traveling Salesman Problem is an everyday occurrence for shipping and distribution
    companies like UPS and FedEx. Package delivery companies want their drivers to
    travel the shortest routes possible. Not only does this make the drivers’ jobs
    more pleasant, but it also saves fuel and maintenance costs. We all travel for
    work or for pleasure, and finding optimal routes when visiting many destinations
    can save resources. But the Traveling Salesman Problem is not just for routing
    travel; it comes up in almost any routing scenario that requires singular visits
    to nodes. Although a minimum spanning tree (chapter 4) may minimize the amount
    of wire needed to connect a neighborhood, it does not tell us the optimal amount
    of wire if every house must be forward-connected to just one other house as part
    of a giant circuit that returns to its origination. The Traveling Salesman Problem
    does.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 旅行商问题（Traveling Salesman Problem）对于像UPS和FedEx这样的运输和分销公司来说是日常发生的事情。包裹递送公司希望他们的司机走尽可能短的路线。这不仅使司机的任务更加愉快，而且还能节省燃料和维护成本。我们为了工作或娱乐而旅行，在访问多个目的地时找到最佳路线可以节省资源。但旅行商问题不仅仅是用于路线规划；它几乎出现在任何需要单一访问节点的路由场景中。尽管最小生成树（第4章）可以最小化连接社区所需的最小电线量，但它并不能告诉我们如果每个房子都必须作为巨型回路的一部分连接到另一座房子时，最优的电线量是多少。旅行商问题可以。
- en: Permutation and combination generation techniques like the ones used in the
    naive approach to the Traveling Salesman Problem and the phone number mnemonics
    problem are useful for testing all sorts of brute-force algorithms. For instance,
    if you were trying to crack a short password and you knew its length, you could
    generate every possible permutation of the characters that could potentially be
    in the password. Practitioners of such large-scale permutation-generation tasks
    would be wise to use an especially efficient permutation-generation algorithm
    like Heap’s algorithm.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与用于旅行商问题（Traveling Salesman Problem）和电话号码助记程序的朴素方法中使用的排列和组合生成技术一样，这些技术对于测试各种穷举算法非常有用。例如，如果你试图破解一个短密码，并且知道它的长度，你可以生成密码中可能包含的所有可能的字符排列。从事此类大规模排列生成任务的实践者明智地使用像堆算法（Heap’s
    algorithm）这样的特别高效的排列生成算法。
- en: 9.5 Exercises
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 练习
- en: Reprogram the naive approach to the Traveling Salesman Problem using the graph
    framework from chapter 4.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用第4章中的图框架重新编程旅行商问题的朴素方法。
- en: Implement a genetic algorithm, as described in chapter 5, to solve the Traveling
    Salesman Problem. Start with the simple data set of Vermont cities described in
    this chapter. Can you get the genetic algorithm to arrive at the optimal solution
    in a short amount of time? Then attempt the problem with an increasingly large
    number of cities. How well does the genetic algorithm hold up? You can find a
    large number of data sets specifically made for the Traveling Salesman Problem
    by searching the web. Develop a testing framework for checking the efficiency
    of your method.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现第5章中描述的遗传算法来解决旅行商问题。从本章描述的佛蒙特州城市简单数据集开始。你能否让遗传算法在短时间内找到最优解？然后尝试使用越来越多城市的这个问题。遗传算法的表现如何？你可以在网上搜索到大量专门为旅行商问题制作的数据集。为检查你方法的有效性开发一个测试框架。
- en: Use a dictionary with the phone number mnemonics program and return only permutations
    that contain valid dictionary words.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用带有电话号码助记程序的字典，并仅返回包含有效字典单词的排列。
- en: '* * *'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1. I studied several resources to write this solution, the most authoritative
    of which was Algorithms (Addison-Wesley, 1988), 2nd ed., by Robert Sedgewick (p.
    596). I looked at several examples of the 0/1 knapsack problem on Rosetta Code,
    most notably the Python dynamic programming solution ([http://mng.bz/kx8C](http://mng.bz/kx8C)),
    which this function is largely a port of, originally from the Swift version of
    the book. (It went from Python to Swift, back to Python again, and then to Java.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 我研究了多个资源来编写这个解决方案，其中最权威的是罗伯特·赛杰威克（Robert Sedgewick）的《算法》（Addison-Wesley，1988年），第2版（p.
    596）。我查看了Rosetta Code上的几个0/1背包问题示例，最值得注意的是Python动态规划解决方案([http://mng.bz/kx8C](http://mng.bz/kx8C))，这个函数在很大程度上是移植自书的Swift版本。（它从Python到Swift，再回到Python，然后到Java。）
- en: 2. Robert Sedgewick, “Permutation Generation Methods” (Princeton University),
    [http://mng.bz/87Te](http://mng.bz/87Te).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 罗伯特·赛杰威克（Robert Sedgewick），“排列生成方法”（普林斯顿大学），[http://mng.bz/87Te](http://mng.bz/87Te).
