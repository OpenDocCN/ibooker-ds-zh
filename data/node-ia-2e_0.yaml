- en: Part 1\. Welcome to Node
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分. 欢迎来到Node
- en: Node is now a mature web development platform. In [chapters 1](kindle_split_011.xhtml#ch01)
    to [3](kindle_split_013.xhtml#ch03), you’ll learn about Node’s main features,
    including how to use the core modules and npm. You’ll also see how Node uses modern
    JavaScript, and how to build a web application from scratch. After reading these
    chapters, you’ll have a solid understanding of what Node can do and of how to
    create your own projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Node现在是一个成熟的Web开发平台。在第[1章](kindle_split_011.xhtml#ch01)到[3章](kindle_split_013.xhtml#ch03)中，您将了解Node的主要功能，包括如何使用核心模块和npm。您还将看到Node如何使用现代JavaScript，以及如何从头开始构建Web应用程序。阅读这些章节后，您将对Node能做什么以及如何创建自己的项目有一个坚实的理解。
- en: Chapter 1\. Welcome to Node.js
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1章. 欢迎来到Node.js
- en: '*This chapter covers*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: What is Node.js?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Node.js？
- en: Defining Node applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义Node应用程序
- en: The advantages of using Node
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node的优势
- en: Asynchronous and nonblocking I/O
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步和非阻塞I/O
- en: 'Node.js is an asynchronous, event-driven JavaScript runtime that offers a powerful
    but concise standard library. It’s managed and supported by the Node.js Foundation,
    an industry consortium with an open governance model. Two actively supported versions
    of Node are available: Long-Term Support (LTS) and Current. If you want to learn
    more about how Node is managed, the official website has plenty of documentation
    ([https://nodejs.org/](https://nodejs.org/)).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是一个异步、事件驱动的JavaScript运行时，它提供了一个强大而简洁的标准库。它由Node.js基金会管理和支持，该基金会是一个具有开放治理模式的行业联盟。目前有两个活跃支持的Node版本：长期支持（LTS）和当前版本。如果您想了解更多关于Node如何管理的相关信息，官方网站提供了丰富的文档([https://nodejs.org/](https://nodejs.org/))。
- en: 'Since Node.js appeared in 2009, JavaScript has gone from a barely tolerated
    browser-centric language to one of the most important languages for all kinds
    of software development. This is partly due to the arrival of ECMAScript 2015,
    which solved several critical problems in previous versions of the language. Node
    uses Google’s V8 JavaScript engine that’s based on the sixth edition of the ECMAScript
    standard, which is sometimes called ES6 and abbreviated as ES2015\. It’s also
    due to innovative technologies such as Node, React, and Electron, which allow
    Java-Script to be used everywhere: from the server to the browser, and in native
    mobile applications. Even big companies such as Microsoft are embracing JavaScript,
    and Microsoft has even contributed to the success of Node.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Node.js在2009年出现以来，JavaScript已经从一种几乎不被容忍的以浏览器为中心的语言转变为各种软件开发中最重要的语言之一。这部分是由于ECMAScript
    2015的推出，它解决了语言先前版本中的几个关键问题。Node使用基于ECMAScript第六版的Google V8 JavaScript引擎，有时称为ES6，缩写为ES2015。这也得益于Node、React和Electron等创新技术，这些技术使得JavaScript可以在任何地方使用：从服务器到浏览器，以及原生移动应用程序。甚至像微软这样的大公司也在拥抱JavaScript，微软甚至为Node的成功做出了贡献。
- en: In this chapter, you’ll learn more about Node, its event-driven nonblocking
    model, and some of the reasons that JavaScript has become a great general-purpose
    programming language. First, let’s look at a typical Node web application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解更多关于Node、其事件驱动的非阻塞模型以及JavaScript成为优秀的通用编程语言的一些原因。首先，让我们看看一个典型的Node
    Web应用程序。
- en: 1.1\. A typical Node web application
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1. 一个典型的Node Web应用程序
- en: 'One of the strengths of Node and JavaScript in general is their single-threaded
    programming model. Threads are a common source of bugs, and although some recent
    programming languages, including Go and Rust, have attempted to offer safer concurrency
    tools, Node retains the model used in the browser. In browser-based code, we write
    sequences of instructions that execute one at a time; code doesn’t execute in
    parallel. This doesn’t make sense for user interfaces, however: users don’t want
    to wait around for slow operations such as network or file access to finish. To
    get around this, browsers use events: when you click a button, an event fires,
    and a function runs that has previously been defined but not yet executed. This
    avoids some of the issues found in threaded programming, including resource deadlocks
    and race conditions.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Node和JavaScript的一般优势之一是它们的单线程编程模型。线程是常见的错误来源，尽管一些最近的编程语言，包括Go和Rust，试图提供更安全的并发工具，但Node仍然保留了浏览器中使用的模型。在基于浏览器的代码中，我们编写一系列依次执行的指令；代码不会并行执行。然而，这对于用户界面来说是没有意义的：用户不希望等待缓慢的操作，如网络或文件访问完成。为了解决这个问题，浏览器使用事件：当你点击一个按钮时，会触发一个事件，并运行一个之前已定义但尚未执行的功能。这避免了线程编程中的一些问题，包括资源死锁和竞争条件。
- en: 1.1.1\. Nonblocking I/O
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1. 非阻塞I/O
- en: 'What does this mean in the context of server-side programming? The situation
    is similar: I/O requests such as disk and network access are also comparatively
    slow, so we don’t want the runtime to block business logic from executing while
    reading files or sending messages over the network. To solve this, Node uses three
    techniques: events, asynchronous APIs, and nonblocking I/O. *Nonblocking I/O*
    is a low-level term from a Node programmer’s perspective. It means your program
    can make a request for a network resource while doing something else, and then,
    when the network operation has finished, a callback will run that handles the
    result.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端编程的上下文中这意味着什么？情况类似：I/O 请求，如磁盘和网络访问，也是相对较慢的，所以我们不希望运行时在读取文件或通过网络发送消息时阻塞业务逻辑的执行。为了解决这个问题，Node
    使用三种技术：事件、异步 API 和非阻塞 I/O。*非阻塞 I/O* 是从 Node 程序员的角度来看的一个低级术语。这意味着你的程序可以在做其他事情的同时请求网络资源，然后，当网络操作完成时，将运行一个回调来处理结果。
- en: '[Figure 1.1](#ch01fig01) shows a typical Node web application that uses the
    web application library Express to handle the order flow for a shop. Browsers
    make requests to buy a product, and then the application checks the current stock
    inventory, creates an account for the user, emails the receipt, and sends back
    a JSON HTTP response. Concurrently, other things happen as well: an email receipt
    is sent, and a database is updated with the user’s details and order. The code
    itself is straightforward, imperative JavaScript, but the runtime behaves concurrently
    because it uses nonblocking I/O.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1.1](#ch01fig01) 展示了一个典型的 Node 网络应用程序，该程序使用 Web 应用程序库 Express 来处理商店的订单流程。浏览器发出购买产品的请求，然后应用程序检查当前的库存，为用户创建账户，发送电子邮件收据，并发送
    JSON HTTP 响应。同时，还有其他事情发生：发送电子邮件收据，并使用户的详细信息更新数据库。代码本身很简单，是命令式 JavaScript，但运行时是并发的，因为它使用了非阻塞
    I/O。'
- en: Figure 1.1\. Asynchronous and nonblocking components in a Node application
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.1. Node 应用程序中的异步和非阻塞组件
- en: '![](Images/01fig01_alt.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片 01fig01](Images/01fig01_alt.jpg)'
- en: In [figure 1.1](#ch01fig01) the database is accessed over the network. In Node,
    that network access is nonblocking, because Node uses a library called libuv ([http://libuv.org/](http://libuv.org/))
    to provide access to the operating system’s nonblocking network calls. This is
    implemented differently in Linux, macOS, and Windows, but all you have to worry
    about is your friendly Java-Script database library. While you’re writing code
    such as `db.insert(query, err => {})`, Node is doing highly optimized, nonblocking
    networking underneath.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 1.1](#ch01fig01) 中，数据库是通过网络访问的。在 Node 中，这种网络访问是非阻塞的，因为 Node 使用一个名为 libuv
    ([http://libuv.org/](http://libuv.org/)) 的库来提供对操作系统非阻塞网络调用的访问。这在 Linux、macOS 和
    Windows 中的实现方式不同，但你只需要关心你友好的 JavaScript 数据库库。当你编写 `db.insert(query, err => {})`
    这样的代码时，Node 在底层进行高度优化的非阻塞网络操作。
- en: Disk access is similar, but intriguingly not the same. When the email receipt
    is generated and the email template is read from the disk, libuv uses a thread
    pool to provide the illusion that a nonblocking call is being used. Managing a
    thread pool is no fun at all, but writing `email.send('template.ejs', (err, html)
    => {})` is definitely much easier to understand.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘访问类似，但有趣的是并不完全相同。当生成电子邮件收据并从磁盘读取电子邮件模板时，libuv 使用线程池来提供使用非阻塞调用的错觉。管理线程池一点也不好玩，但编写
    `email.send('template.ejs', (err, html) => {})` 的确更容易理解。
- en: The real benefit to using asynchronous APIs with nonblocking I/O is that Node
    can do other things while these comparatively slow processes happen. Even though
    you have only a single-threaded, single-process Node web app running, it can handle
    more than one connection from potentially thousands of website visitors at any
    one time. To understand this, you need to look at the event loop.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异步 API 和非阻塞 I/O 的真正好处是，Node 可以在这些相对较慢的过程发生时做其他事情。尽管你只有一个线程、单进程的 Node 网络应用程序在运行，但它可以同时处理来自可能成千上万的网站访问者的多个连接。要理解这一点，你需要看看事件循环。
- en: 1.1.2\. The event loop
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2. 事件循环
- en: 'Now let’s zoom into a specific aspect of [figure 1.1](#ch01fig01): responding
    to browser requests. In this application, Node’s built-in HTTP server library,
    which is a core module called http.Server, handles the request by using a combination
    of streams, events, and Node’s HTTP request parser, which is native code. This
    triggers a callback in your application to run, which has been added using the
    Express ([https://expressjs.com/](https://expressjs.com/)) web application library.
    The callback that runs causes a database query to run, and eventually the application
    responds with JSON using HTTP. This whole process uses a minimum of three nonblocking
    network calls: one for the request, one for the database, and another for the
    response. How does Node schedule all these nonblocking network operations? The
    answer is the event loop. [Figure 1.2](#ch01fig02) shows how the event loop is
    used for these three network operations.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们聚焦于[图1.1](#ch01fig01)的一个具体方面：响应浏览器请求。在这个应用中，Node的内置HTTP服务器库，即核心模块http.Server，通过结合流、事件和Node的HTTP请求解析器（这是原生代码）来处理请求。这会在你的应用中触发一个回调函数的执行，该回调函数是通过Express
    ([https://expressjs.com/](https://expressjs.com/)) 网络应用库添加的。运行的回调函数会导致数据库查询执行，最终应用通过HTTP以JSON格式响应。整个过程使用了至少三个非阻塞的网络调用：一个用于请求，一个用于数据库，另一个用于响应。Node是如何调度所有这些非阻塞网络操作的？答案是事件循环。[图1.2](#ch01fig02)展示了事件循环是如何用于这三个网络操作的。
- en: Figure 1.2\. The event loop
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.2. 事件循环
- en: '![](Images/01fig02_alt.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/01fig02_alt.jpg)'
- en: The event loop runs one way (it’s a first-in, first-out queue) and goes through
    several phases. [Figure 1.2](#ch01fig02) shows a simplified set of the important
    phases that run on each iteration of the loop. First, the timers execute, which
    are the timers scheduled with the JavaScript functions `setTimeout` and `setInterval`.
    Next, I/O callbacks run, so if any I/O has returned from one of the nonblocking
    network calls, this is where your callback is triggered. The poll phase is where
    new I/O events are retrieved, and then callbacks scheduled with `setImmediate`
    run at the end. This is a special case because it allows you to schedule a callback
    to run immediately after the current I/O callbacks already in the queue. This
    might sound abstract at this stage, but what you should take away is the idea
    that although Node is single-threaded, it does give you tools to write efficient
    and scalable code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环以一个方向运行（它是一个先进先出队列）并经过几个阶段。[图1.2](#ch01fig02)展示了循环每次迭代运行的重要阶段的简化集合。首先，定时器执行，这些是使用JavaScript函数`setTimeout`和`setInterval`安排的定时器。接下来，I/O回调运行，如果任何I/O从非阻塞网络调用中返回，那么你的回调就会在这里被触发。轮询阶段是获取新的I/O事件的地方，然后使用`setImmediate`安排的回调在最后运行。这是一个特殊情况，因为它允许你在队列中已经存在的当前I/O回调之后立即安排一个回调。这个阶段可能听起来很抽象，但你应该记住的是，尽管Node是单线程的，但它确实为你提供了编写高效和可扩展代码的工具。
- en: Over the last few pages, you might have noticed that the examples have been
    written using ES2015 arrow functions. Node supports many new JavaScript features,
    so before moving on, let’s look at what new language features you can use to write
    better code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几页中，你可能已经注意到示例是使用ES2015箭头函数编写的。Node支持许多新的JavaScript特性，所以在继续之前，让我们看看你可以使用哪些新的语言特性来编写更好的代码。
- en: 1.2\. ES2015, Node, and V8
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2. ES2015、Node和V8
- en: 'If you’ve ever used JavaScript and been disheartened by the lack of classes
    and strange scoping rules, you’re in luck: Node has fixed most of these problems!
    You can now make classes, and using `const` and `let` (instead of `var`) fixes
    scoping issues. As of Node 6, you can use default function parameters, rest parameters,
    the `spread` operator, `for...of` loops, template strings, destructuring, generators,
    and more. A great summary of Node’s ES2015 support can be found at [http://node.green](http://node.green).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过JavaScript并且因为缺乏类和奇怪的作用域规则而感到沮丧，那么你很幸运：Node已经修复了这些问题中的大多数！你现在可以创建类，使用`const`和`let`（而不是`var`）可以解决作用域问题。截至Node
    6，你可以使用默认函数参数、剩余参数、`spread`操作符、`for...of`循环、模板字符串、解构、生成器等等。关于Node对ES2015支持的详细总结可以在[http://node.green](http://node.green)找到。
- en: 'First, let’s look at classes. ES5 and earlier versions required the use of
    prototype objects to create class-like constructs:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看类。ES5及更早版本需要使用原型对象来创建类似类的结构：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With Node 6 and ES2015, you can now write the same code by using classes:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node 6和ES2015，你现在可以使用类来编写相同的代码：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This uses less code and is a little easier to read. But there’s more: Node
    also supports subclassing, `super`, and static methods. For those versed in other
    languages, the adoption of class syntax makes Node more accessible than when we
    were stuck with ES5.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更简洁，也更易于阅读。但不仅如此：Node 还支持子类化、`super` 和静态方法。对于那些熟悉其他语言的开发者来说，采用类语法使得 Node
    比我们当时只能使用 ES5 时更容易上手。
- en: Another important feature in Node 4 and above is the addition of `const` and
    `let`. In ES5, all variables were created with `var`. The problem with `var` is
    it defines variables in function or global scope, so you couldn’t define a block-level
    variable in an `if` statement, `for` loop, or `other` block.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Node 4 及以上版本中另一个重要的特性是 `const` 和 `let` 的加入。在 ES5 中，所有变量都是用 `var` 创建的。`var` 的问题在于它定义了函数或全局作用域中的变量，因此你无法在
    `if` 语句、`for` 循环或其他块中定义块级变量。
- en: '|  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Should I use const or let?**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**我应该使用 const 还是 let？**'
- en: When deciding whether to use `const` or `let`, you almost always want `const`.
    Because most of your code will use instances of your own classes, object literals,
    or values that don’t change, you can use `const` most of the time. Even instances
    of objects that have properties that change can be declared with `const`, because
    `const` means only that the reference is read-only, not that the value is immutable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定是否使用 `const` 或 `let` 时，你几乎总是想要 `const`。因为你的大部分代码将使用你自己的类的实例、对象字面量或不变的值，所以你大部分时间都可以使用
    `const`。即使具有可变属性的对象的实例也可以用 `const` 声明，因为 `const` 只意味着引用是只读的，并不意味着值是不可变的。
- en: '|  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Node also has native promises and generators. *Promises* are supported by lots
    of libraries, allowing you to write asynchronous code with a fluent interface
    style. You’re probably familiar with fluent interfaces already: if you’ve ever
    used an API such as jQuery or even JavaScript arrays, you’ll have seen it. The
    following short example shows you how to chain calls to manipulate an array in
    JavaScript:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Node 还具有原生的 promises 和 generators。*Promises* 被许多库支持，允许你以流畅的接口风格编写异步代码。你可能已经熟悉流畅的接口：如果你曾经使用过
    jQuery 或甚至 JavaScript 数组这样的 API，你肯定见过。以下简短的例子展示了如何在 JavaScript 中通过链式调用操作数组：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Generators* are used to give a synchronous programming style to asynchronous
    I/O. If you want to see a practical example of generators in Node, take a look
    at the Koa web application library ([http://koajs.com/](http://koajs.com/)). If
    you use promises or other generators with Koa, you can yield on values rather
    than nesting callbacks.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*Generators* 用于给异步 I/O 提供同步编程风格。如果你想看看 Node 中 generators 的实际例子，可以看看 Koa Web
    应用程序库（[http://koajs.com/](http://koajs.com/)）。如果你在 Koa 中使用 promises 或其他 generators，你可以对值进行
    yield 而不是嵌套回调。'
- en: 'One other useful ES2015 feature in Node is *template strings*. In ES5, string
    literals didn’t support interpolation or multiple lines. Now by using the backtick
    symbol (`` ` ``), you can insert values and span strings over several lines. This
    is useful when stubbing quick bits of HTML for web apps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Node 中另一个有用的 ES2015 特性是 *模板字符串*。在 ES5 中，字符串字面量不支持插值或多行。现在通过使用反引号符号（`` ` ``），你可以插入值并将字符串跨越多行。这在为
    Web 应用快速生成 HTML 时非常有用：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In ES5, the previous example would have to be written like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES5 中，前面的例子将不得不这样写：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The older style not only used more code but also made introducing bugs easy.
    The final big feature, which is of particular importance to Node programmers,
    is arrow functions. *Arrow functions* let you streamline syntax. For example,
    if you’re writing a callback that has a single argument and returns a value, you
    can write it with hardly any syntax at all:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 旧式语法不仅代码量更多，而且更容易引入错误。对 Node 开发者来说特别重要的最后一个大特性是箭头函数。*箭头函数* 可以让你简化语法。例如，如果你正在编写一个只有一个参数并返回值的回调函数，你可以几乎不使用任何语法就写出来：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In Node we typically need two arguments, because the first argument to a callback
    is often an error object. In that case, you need to use parentheses around the
    arguments:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 中，我们通常需要两个参数，因为回调函数的第一个参数通常是错误对象。在这种情况下，你需要使用括号包围参数：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you need to use more than one line in the function body, you need to use
    curly brackets. The value of arrow functions isn’t just in the streamlined syntax;
    it has to do with JavaScript scopes. In ES5 and before, defining functions inside
    other functions makes the `this` reference become the global object. Here’s an
    ES5-style class that suffers from a bug due to this issue:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在函数体中使用多行，则需要使用花括号。箭头函数的价值不仅在于简化的语法；它与JavaScript作用域有关。在ES5及之前版本中，在其它函数内部定义函数会使`this`引用成为全局对象。以下是一个受此问题影响的ES5风格类：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The line that assigns `self.name` can’t be written as `this.name`, because
    the function’s `this` will be the global object. A workaround used to be to assign
    a variable to `this` at the entry point to the parent function or method. But
    arrow functions are bound correctly. In ES2015, the previous example can be rewritten
    to be much more intuitive:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 分配`self.name`的行不能写成`this.name`，因为函数的`this`将是全局对象。过去，一种解决方案是在父函数或方法的入口点将变量分配给`this`。但箭头函数绑定正确。在ES2015中，前面的示例可以重写为更直观的形式：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Not only can you use `const` to better model the database query, but there’s
    also no need for the clumsy `self` variable. ES2015 has many other great features
    that make Node code more readable, but let’s look at what powers this in Node
    and how it relates to the nonblocking I/O features that you’ve already looked
    at.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您不仅可以使用`const`更好地模拟数据库查询，而且也不需要笨拙的`self`变量。ES2015有许多其他出色的功能，使Node代码更具可读性，但让我们看看在Node中是什么在驱动这些功能，以及它与您已经查看的非阻塞I/O功能有何关联。
- en: 1.2.1\. Node and V8
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1. Node和V8
- en: Node is powered by the V8 JavaScript engine, which is developed by the Chromium
    project for Google Chrome. The notable feature of V8 is that it compiles directly
    to machine code, and it includes code-optimization features that help keep Node
    fast. In [section 1.1.1](#ch01lev2sec1), we talked about the other main native
    part of Node, libuv. That part handles I/O; V8 handles interpreting and running
    your JavaScript code. To use libuv with V8, you use a C++ binding layer. [Figure
    1.3](#ch01fig03) shows all of the separate software components that make up Node.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Node由V8 JavaScript引擎驱动，该引擎由Chromium项目为Google Chrome开发。V8的显著特点是它可以直接编译成机器码，并且包含代码优化功能，有助于保持Node的快速运行。在[第1.1.1节](#ch01lev2sec1)中，我们讨论了Node的另一个主要原生部分，libuv。该部分处理I/O；V8负责解释和运行您的JavaScript代码。要使用libuv与V8一起，您需要使用C++绑定层。[图1.3](#ch01fig03)显示了构成Node的所有单独的软件组件。
- en: Figure 1.3\. Node’s software stack
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.3. Node的软件栈
- en: '![](Images/01fig03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/01fig03.jpg)'
- en: The specific JavaScript features that are available to Node therefore come down
    to what V8 supports. This support is managed through feature groups.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Node可用的具体JavaScript功能因此取决于V8支持的内容。这种支持通过功能组进行管理。
- en: 1.2.2\. Working with feature groups
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2. 与功能组一起工作
- en: 'Node includes ES2015 features based on what V8 provides. Features are grouped
    under *shipping*, *staged*, and *in progress*. The shipping features are turned
    on by default, but staged and in progress can be enabled using command-line flags.
    If you want to use staged features, which are almost complete but not considered
    complete by the V8 team, then you can run Node with the `--harmony` flag. In-progress
    features, however, are less stable and are enabled with specific feature flags.
    Node’s documentation recommends querying the currently available in-progress features
    by grepping for `in progress`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Node根据V8提供的内容包含ES2015功能。功能被分组为*已发布*、*已测试*和*进行中*。默认情况下，已发布功能是开启的，但已测试和进行中可以通过命令行标志启用。如果您想使用已测试功能，这些功能几乎完成但V8团队尚未认为完全完成，那么您可以使用`--harmony`标志运行Node。然而，进行中的功能稳定性较低，需要特定的功能标志来启用。Node的文档建议通过搜索`in
    progress`来查询当前可用的进行中功能：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The list will vary between Node releases. Node itself also has a versioning
    schedule that defines which APIs are available.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表将在Node版本之间有所不同。Node本身也有一个版本计划，该计划定义了哪些API可用。
- en: 1.2.3\. Understanding Node’s release schedule
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.3. 理解Node的发布计划
- en: Node releases are grouped into Long-Term Support (LTS), Current, and Nightly.
    LTS releases get 18 months of support and then 12 months of maintenance support.
    Releases are made according to semantic versioning (SemVer). SemVer gives releases
    a major, minor, and patch version number. For example, 6.9.1 has a major version
    of 6, minor of 9, and patch of 1\. Whenever you see a major version change for
    Node, it means some of the APIs may be incompatible with your projects, and you’ll
    need to retest them against this version of Node. Also, in Node release terminology,
    a major version increment means a new Current release has been cut. Nightly builds
    are automatically generated every 24 hours with the latest changes, but are typically
    used only for testing Node’s latest features.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Node的版本分为长期支持（LTS）、当前版本（Current）和夜间版本（Nightly）。LTS版本将获得18个月的支持和12个月的维护支持。版本发布遵循语义版本控制（SemVer）。SemVer为版本分配主版本号、次版本号和补丁版本号。例如，6.9.1的主版本号是6，次版本号是9，补丁号是1。每次你看到Node的主版本号发生变化时，这意味着一些API可能与你的项目不兼容，你需要重新测试它们与这个版本的Node。此外，在Node的版本发布术语中，主版本号的增加意味着一个新的当前版本已经发布。夜间构建每24小时自动生成，包含最新的更改，但通常仅用于测试Node的最新功能。
- en: 'Which version you use depends on your project and organization. Some may prefer
    LTS because updates are less frequent: this might work well in larger enterprises
    that find it harder to manage frequent updates. But if you want the latest performance
    and feature improvements, Current is a better choice.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用的版本取决于你的项目和组织。有些人可能更喜欢长期支持版本（LTS），因为更新频率较低：这在大企业中可能效果很好，因为这些企业发现管理频繁更新比较困难。但如果你想要最新的性能和功能改进，当前版本（Current）是一个更好的选择。
- en: 1.3\. Installing Node
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3. 安装Node
- en: The easiest way to install Node is to use the installer from [https://nodejs.org](https://nodejs.org).
    Install the latest Current version (version 6.5 at the time of this writing) by
    using the Mac or Windows installer. You can download the source yourself, or install
    it by using your operating system’s package manager. Debian, Ubuntu, Arch, Fedora,
    FreeBSD, Gentoo, and SUSE all have packages. There are also packages for Homebrew
    and Smart-OS. If your operating system doesn’t have a package, you can build from
    source.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Node最简单的方法是使用[https://nodejs.org](https://nodejs.org)上的安装程序。使用Mac或Windows安装程序安装最新的当前版本（在撰写本文时为版本6.5）。你可以自己下载源代码，或者使用操作系统的包管理器进行安装。Debian、Ubuntu、Arch、Fedora、FreeBSD、Gentoo和SUSE都有相应的包。还有Homebrew和Smart-OS的包。如果你的操作系统没有相应的包，你可以从源代码构建。
- en: '|  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '[Appendix A](kindle_split_025.xhtml#app01) provides more details on installing
    Node.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[附录A](kindle_split_025.xhtml#app01)提供了关于安装Node的更多详细信息。'
- en: '|  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The full list of packages is on Node’s website ([https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/)),
    and the source is on GitHub ([https://github.com/nodejs/node](https://github.com/nodejs/node)).
    Bookmarking the GitHub source is worthwhile in case you want to poke around in
    the source without downloading it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 包的完整列表可以在Node的网站上找到 ([https://nodejs.org/en/download/package-manager/](https://nodejs.org/en/download/package-manager/))，源代码在GitHub上
    ([https://github.com/nodejs/node](https://github.com/nodejs/node))。如果你想在不需要下载的情况下查看源代码，将GitHub源代码添加书签是值得的。
- en: 'Once you’ve installed Node, you can try it out straight away by typing `node
    -v` in the terminal. This should print out the version of Node that you just downloaded
    and installed. Next, create a file called hello.js that looks like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Node后，你可以在终端中直接通过输入`node -v`来尝试它。这将打印出你刚刚下载和安装的Node版本。接下来，创建一个名为hello.js的文件，其内容如下：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Save the file and run it by typing `node hello.js`. Congratulations—you’re now
    ready to start writing applications with Node!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，通过输入`node hello.js`来运行它。恭喜你——你现在可以开始用Node编写应用程序了！
- en: '|  |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Getting started quickly in Windows, Linux, and macOS**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**在Windows、Linux和macOS上快速入门**'
- en: If you’re fairly new to programming in general and you don’t yet have a preferred
    text editor, then a solid choice for Node is Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/)).
    It’s made by Microsoft, but it’s open source and a free download, and supports
    Windows, Linux, and macOS.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你总的来说对编程还比较新手，并且还没有一个偏好的文本编辑器，那么Node的一个不错的选择是Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))。它是微软开发的，但它是开源的，可以免费下载，并且支持Windows、Linux和macOS。
- en: Some of the beginner-friendly features in Visual Studio Code include JavaScript
    syntax highlighting and Node core module completion, so your JavaScript will look
    clearer and you’ll be able to see lists of supported methods and objects as you
    type. You can also open a command-line interface where Node can be invoked just
    by typing `Node`. This is useful for running Node and npm commands. Windows users
    might prefer this to using cmd.exe. We tested the listings with Windows and Visual
    Studio Code, so you shouldn’t need anything special to run the examples.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code中的一些适合初学者的功能包括JavaScript语法高亮和Node核心模块完成，这样你的JavaScript看起来会更清晰，你可以在键入时看到支持的方法和对象的列表。你还可以打开一个命令行界面，在Node中只需输入`Node`即可调用。这对于运行Node和npm命令很有用。Windows用户可能更喜欢这种方式而不是使用cmd.exe。我们已经在Windows和Visual
    Studio Code上测试了列表，所以你不需要任何特殊的东西来运行示例。
- en: To get started, you can follow a Visual Studio Code Node.js tutorial ([https://code.visualstudio.com/docs/runtimes/nodejs](https://code.visualstudio.com/docs/runtimes/nodejs)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，你可以遵循Visual Studio Code Node.js教程([https://code.visualstudio.com/docs/runtimes/nodejs](https://code.visualstudio.com/docs/runtimes/nodejs))。
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'When you install Node, you also get some built-in tools. Node isn’t just the
    interpreter: it’s a whole suite of tools that form the Node platform. Let’s look
    in more detail at the tools that are bundled with Node.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装Node时，你也会获得一些内置工具。Node不仅仅是解释器：它是一套完整的工具，构成了Node平台。让我们更详细地看看Node附带的一些工具。
- en: 1.4\. Node’s built-in tools
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4\. Node的内置工具
- en: Node comes with a built-in package manager, the core JavaScript modules that
    support everything from file and network I/O to zlib compression, and a debugger.
    The npm package manager is a critical piece of this infrastructure, so let’s look
    at it in more detail.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Node自带内置的包管理器，核心JavaScript模块支持从文件和网络I/O到zlib压缩的一切，以及调试器。npm包管理器是这个基础设施的关键部分，所以让我们更详细地看看它。
- en: If you want to verify that Node has been installed correctly, you can run `node
    -v` and `npm -v` on the command-line. These commands show the version of Node
    and npm that you have installed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要验证Node是否已正确安装，你可以在命令行上运行`node -v`和`npm -v`。这些命令显示了您已安装的Node和npm的版本。
- en: 1.4.1\. npm
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.1\. npm
- en: The npm command-line tool can be invoked by typing `npm`. You can use it to
    install packages from the central npm registry, but you can also use it to find
    and share your own open and closed source projects. Every npm package in the registry
    has a website that shows the readme file, author, and statistics about downloads.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: npm命令行工具可以通过输入`npm`来调用。你可以用它从中央npm注册表安装包，但你也可以用它来查找和分享你自己的开源和闭源项目。注册表中的每个npm包都有一个网站，显示readme文件、作者和下载统计信息。
- en: 'That doesn’t cover everything, though. npm is also npm, Inc.—the company that
    runs the npm service and that provides services used by commercial enterprises.
    This includes hosting private npm packages: you can pay a monthly fee to host
    your company’s source code so your JavaScript developers can easily install it
    with npm.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不涵盖所有内容，但npm也是npm, Inc.——这家公司运营npm服务，并为商业企业提供服务。这包括托管私有npm包：你可以支付每月费用来托管你公司的源代码，这样你的JavaScript开发者就可以轻松地使用npm安装它。
- en: When installing packages with the npm install command, you have to decide whether
    you’re adding them to your current project or installing them globally. Globally
    installed packages are usually used for tools, typically programs you run on the
    command line. A good example of this is the gulp-cli package.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用npm install命令安装包时，你必须决定你是要将它们添加到当前项目还是全局安装。全局安装的包通常用于工具，通常是你在命令行上运行的程序。gulp-cli包就是一个很好的例子。
- en: 'To use npm, create a package.json file in a directory that will contain your
    Node project. The easiest way to create a package.json file is to use npm to do
    it for you. Type the following on the command line:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用npm，在将包含你的Node项目的目录中创建一个package.json文件。创建package.json文件的最简单方法就是使用npm为你完成。在命令行中输入以下内容：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you open package.json, you’ll see a simple JSON file that describes your
    project. If you now install a module from [www.npmjs.com](http://www.npmjs.com)
    and use the `--save` option, npm will automatically update your package.json file.
    Try it out by typing `npm install`, or `npm i` for short:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开package.json，你会看到一个简单的JSON文件，它描述了你的项目。如果你现在从[www.npmjs.com](http://www.npmjs.com)安装一个模块并使用`--save`选项，npm将自动更新你的package.json文件。你可以通过输入`npm
    install`或简写为`npm i`来尝试它：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you open your package.json file, you should see `express` added under the
    `dependencies` property. Also, if you look inside the node_modules folder, you’ll
    see an express directory. This contains the version of Express that you just installed.
    You can also install modules globally by using the `--global` option. You should
    use local modules as much as possible, but global modules can be useful for command-line
    tools that you want to use outside Node JavaScript code. An example of a command-line
    tool that’s installable with npm is ESLint ([http://eslint.org/](http://eslint.org/)).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开你的 package.json 文件，你应该在 `dependencies` 属性下看到添加了 `express`。此外，如果你查看 node_modules
    文件夹，你会看到一个 express 目录。这包含你刚刚安装的 Express 版本。你也可以使用 `--global` 选项全局安装模块。你应该尽可能使用本地模块，但全局模块对于你希望在
    Node JavaScript 代码之外使用的命令行工具非常有用。一个可以使用 npm 安装的命令行工具示例是 ESLint ([http://eslint.org/](http://eslint.org/))。
- en: When you’re starting out with Node, you’ll often use packages from npm. Node
    comes with lots of useful built-in libraries, which are known as the *core modules*.
    Let’s look at these in more detail.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚开始使用 Node 时，你通常会使用 npm 的包。Node 包含许多有用的内置库，这些库被称为 *核心模块*。让我们更详细地看看这些模块。
- en: 1.4.2\. The core modules
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.2\. 核心模块
- en: Node’s core modules are similar to other languages’ standard libraries; these
    are the tools you need to write server-side JavaScript. The JavaScript standards
    themselves don’t include anything for working with the network, or even file I/O
    as most server-side developers know it. Node has to add features for files and
    TCP/IP networking at a minimum to be a viable server-side language.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的核心模块与其他语言的标准库类似；这些是编写服务器端 JavaScript 所需的工具。JavaScript 标准本身不包含用于处理网络或文件
    I/O 的任何内容，正如大多数服务器端开发者所知。Node 至少需要添加文件和 TCP/IP 网络的功能，才能成为一个可行的服务器端语言。
- en: Filesystem
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 文件系统
- en: Node ships with a filesystem library (fs, path), TCP clients and servers (net),
    HTTP (http and https), and domain name resolution (dns). There’s a useful assertion
    library that’s used mostly to write tests (assert), and an operating system library
    for querying information about the platform (os).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Node 随带一个文件系统库（fs、path）、TCP 客户端和服务器（net）、HTTP（http 和 https）以及域名解析（dns）。有一个有用的断言库，主要用于编写测试（assert），还有一个操作系统库用于查询有关平台的信息（os）。
- en: Node also has libraries that are unique to Node. The events module is a small
    library for working with events, and it’s used as a basis for much of Node’s APIs.
    For example, the stream module uses the events module to provide abstract interfaces
    for working with streams of data. Because all data streams in Node use the same
    APIs, you can easily compose software components; if you have a file-stream reader,
    you can pipe it through a zlib transform that compresses the data, and then pipe
    it through a file-stream writer to write the data out to a file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Node 还有一些独特的库。事件模块是一个用于处理事件的简单库，它被用作 Node 许多 API 的基础。例如，流模块使用事件模块来提供处理数据流的抽象接口。因为
    Node 中的所有数据流都使用相同的 API，你可以轻松地组合软件组件；如果你有一个文件流读取器，你可以通过 zlib 转换器压缩数据，然后将数据通过文件流写入器写入文件。
- en: The following listing shows how to use Node’s fs module to create read- and
    write-streams that can be piped through another stream (gzip) to transform the
    data—in this case, by compressing it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何使用 Node 的 fs 模块创建可以管道传输到另一个流（gzip）以转换数据的读写流——在这种情况下，通过压缩数据。
- en: Listing 1.1\. Using core modules and streams
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.1\. 使用核心模块和流
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Networking
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 网络
- en: 'For a while, we used to say that creating a simple HTTP server was Node’s true
    Hello World example. To build a server in Node, you just need to load the http
    module and give it a function. The function accepts two arguments: the incoming
    request and the outgoing response. The next listing shows an example you can run
    in your terminal.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间里，我们曾经说创建一个简单的 HTTP 服务器是 Node 的真正 Hello World 示例。要在 Node 中构建服务器，你只需要加载 http
    模块并给它一个函数。该函数接受两个参数：传入的请求和传出的响应。下一个列表展示了你可以在终端中运行的示例。
- en: Listing 1.2\. Hello World with Node’s http module
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.2\. 使用 Node 的 http 模块编写 Hello World
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Save [listing 1.2](#ch01ex02) as `hello.js` and run it with `node hello.js`.
    If you visit http://localhost:8080, you should see the message from line 4.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将 [列表 1.2](#ch01ex02) 保存为 `hello.js` 并使用 `node hello.js` 运行它。如果你访问 http://localhost:8080，你应该能看到第
    4 行的消息。
- en: Node’s core modules are minimal but also powerful. You can often achieve a lot
    just by using these modules, without even installing anything from npm. For more
    on the core modules, refer to [https://nodejs.org/api/](https://nodejs.org/api/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Node的核心模块既精简又强大。你通常只需使用这些模块就能完成很多事情，甚至无需从npm安装任何东西。有关核心模块的更多信息，请参阅[https://nodejs.org/api/](https://nodejs.org/api/).
- en: The final built-in tool is the debugger. The next section introduces Node’s
    debugger with an example.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个内置工具是调试器。下一节将介绍Node的调试器及其示例。
- en: 1.4.3\. The debugger
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.3. 调试器
- en: 'Node includes a debugger that supports single-stepping and a REPL (read-eval-print
    loop). The debugger works by talking to your program with a network protocol.
    To run your program with a debugger, use the `debug` argument at the command line.
    Let’s say you’re debugging [listing 1.2](#ch01ex02):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Node包含一个支持单步执行和REPL（读取-评估-打印循环）的调试器。调试器通过使用网络协议与你的程序通信来工作。要使用调试器运行你的程序，请在命令行中使用`debug`参数。假设你正在调试[列表1.2](#ch01ex02)：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then you should see the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你应该会看到以下输出：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Node has invoked your program and is debugging it by connecting on port 5858\.
    At this point, you can type `help` to see the list of available commands, and
    then `c` to continue program execution. Node always starts the program in a *break*
    state, so you always need to continue execution before you can do anything else.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Node已经调用了你的程序，并通过在端口5858上连接来调试它。在这个时候，你可以输入`help`来查看可用命令列表，然后输入`c`来继续程序执行。Node总是以*中断*状态启动程序，所以你总是需要在做其他任何事情之前继续执行。
- en: You can make the debugger break by adding a `debugger` statement anywhere in
    your code. When the `debugger` statement is encountered, the debugger will halt,
    allowing you to issue commands. Imagine you’ve written a REST API that creates
    accounts for new users, and your user creation code doesn’t seem to be persisting
    the new user’s password hash to the database. You could add `debugger` to the
    `save` method in the `User` class, and then step over each instruction to see
    what happens.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在代码的任何位置添加一个`debugger`语句来使调试器中断。当遇到`debugger`语句时，调试器将停止，允许你发出命令。想象一下，你已经编写了一个创建新用户账户的REST
    API，而你创建用户代码似乎没有将新用户的密码散列持久化到数据库中。你可以在`User`类的`save`方法中添加`debugger`，然后逐条指令地查看发生了什么。
- en: '|  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Interactive debugging**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**交互式调试**'
- en: 'Node supports the Chrome Debugging Protocol. To debug a script using Chrome’s
    Developer Tools, use the `--inspect` flag when running a program:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Node支持Chrome调试协议。要使用Chrome的开发者工具调试脚本，请在运行程序时使用`--inspect`标志：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will make Node launch the debugger and break on the first line. It’ll print
    a URL to the console that you can open in Chrome so you can use Chrome’s built-in
    debugger. Chrome’s debugger lets you step through code line by line, and it shows
    the value in each variable and object. It’s a much better alternative to typing
    `console.log`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使Node启动调试器并在第一行中断。它会在控制台打印一个URL，你可以在Chrome中打开它，以便使用Chrome内置的调试器。Chrome的调试器允许你逐行执行代码，并显示每个变量和对象中的值。它是一个比输入`console.log`更好的替代方案。
- en: '|  |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Debugging is covered in more detail in [chapter 9](kindle_split_020.xhtml#ch09).
    If you want to try it right now, the best place to start is the Node manual page
    on the debugger ([https://nodejs.org/api/debugger.html](https://nodejs.org/api/debugger.html)).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 调试将在第9章中详细介绍。如果你想现在尝试，最好的起点是Node的调试器手册页([https://nodejs.org/api/debugger.html](https://nodejs.org/api/debugger.html)).
- en: So far in this chapter, we’ve talked about how Node works and what it provides
    to developers. You’re probably also itching to hear about the kinds of things
    that people are using Node for in production. The next section looks at the types
    of programs you can make with Node.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们讨论了Node的工作原理以及它为开发者提供了什么。你可能也迫不及待地想了解人们在生产中用Node做什么。下一节将探讨你可以用Node制作的程序类型。
- en: 1.5\. The three main types of Node program
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5. Node程序的三种主要类型
- en: 'Node programs can be divided into three typical types: web applications, command-line
    tools and daemons, and desktop applications. Web applications include simple apps
    that serve up single-page applications, REST microservices, and full-stack web
    apps. You may have already used command-line tools written with Node—for example,
    npm, Gulp, and webpack. Daemons are background services. A good example is the
    PM2 ([www.npmjs.com/package/pm2](http://www.npmjs.com/package/pm2)) process manager.
    Desktop applications tend to be software written with the Electron framework ([http://electron.atom.io/](http://electron.atom.io/)),
    which uses Node as the back end for web-based desktop apps. Examples include the
    Atom ([https://atom.io/](https://atom.io/)) and Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
    text editors.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Node 程序可以分为三种典型类型：网络应用程序、命令行工具和守护进程、桌面应用程序。网络应用程序包括提供单页应用程序、REST 微服务和全栈网络应用程序的简单应用程序。你可能已经使用过用
    Node 编写的命令行工具——例如 npm、Gulp 和 webpack。守护进程是后台服务。一个很好的例子是 PM2 ([www.npmjs.com/package/pm2](http://www.npmjs.com/package/pm2))
    进程管理器。桌面应用程序通常是用 Electron 框架编写的软件([http://electron.atom.io/](http://electron.atom.io/))，它将
    Node 作为基于网络的桌面应用程序的后端。例如包括 Atom ([https://atom.io/](https://atom.io/)) 和 Visual
    Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))
    文本编辑器。
- en: 1.5.1\. Web applications
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.1. 网络应用程序
- en: Node is server-side JavaScript, so it makes sense as a platform for building
    web applications. By running JavaScript on both the client and server, opportunities
    exist for code reuse between each environment. Node web apps tend to be written
    with frameworks such as Express ([http://expressjs.com/](http://expressjs.com/)).
    [Chapter 6](kindle_split_017.xhtml#ch06) reviews the major server-side frameworks
    available for Node. [Chapter 7](kindle_split_018.xhtml#ch07) is specifically about
    Express and Connect, and [chapter 8](kindle_split_019.xhtml#ch08) is about web
    application templating.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Node 是服务器端 JavaScript，因此它作为构建网络应用程序的平台是有意义的。通过在客户端和服务器上运行 JavaScript，可以在每个环境中实现代码的重用。Node
    网络应用程序通常使用 Express 等框架编写([http://expressjs.com/](http://expressjs.com/))。[第 6
    章](kindle_split_017.xhtml#ch06) 回顾了 Node 可用的主要服务器端框架。[第 7 章](kindle_split_018.xhtml#ch07)
    专门介绍 Express 和 Connect，[第 8 章](kindle_split_019.xhtml#ch08) 则是关于网络应用程序模板。
- en: 'You can create a quick Express web application by creating a new directory
    and then installing the Express module:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过创建一个新的目录并安装 Express 模块来快速创建一个 Express 网络应用程序：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, add the following JavaScript code to a file called server.js.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下 JavaScript 代码添加到名为 server.js 的文件中。
- en: Listing 1.3\. A Node web application
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.3. 一个 Node 网络应用程序
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now type `npm start` and you’ll have a Node web server running on port 3000\.
    If you open http://localhost:3000 in a browser you’ll be able to see the text
    from the `res.send` line.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入 `npm start`，你将有一个运行在端口 3000 上的 Node 网络服务器。如果你在浏览器中打开 http://localhost:3000，你将能够看到
    `res.send` 行中的文本。
- en: Node is also a big part of the front-end development world, because it’s the
    main tool used when transpiling other languages such as TypeScript to JavaScript.
    Transpilers compile languages from one high-level language to another; this contrasts
    with traditional compilers, which compile from high-level to low-level languages.
    [Chapter 4](kindle_split_015.xhtml#ch04) is dedicated to front-end build systems,
    where we look at using npm scripts, Gulp, and webpack.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Node 也是前端开发世界的一个重要部分，因为它是将其他语言如 TypeScript 转换为 JavaScript 的主要工具。转译器将一种高级语言编译成另一种高级语言；这与将高级语言编译成低级语言的传统编译器形成对比。[第
    4 章](kindle_split_015.xhtml#ch04) 专门介绍前端构建系统，我们探讨了使用 npm 脚本、Gulp 和 webpack。
- en: Not all web development involves building web apps. Sometimes you need to do
    things such as extract data from a legacy website to use when rebuilding it. We’ve
    included [appendix B](kindle_split_026.xhtml#app02), which is all about web scraping,
    as a way of showing how Node’s JavaScript runtime can be used to work with the
    Document Object Model (DOM), as well as showing how to use Node outside the comfort
    zone of typical Express web apps. If you just want to quickly make a basic web
    app, [chapter 3](kindle_split_013.xhtml#ch03) provides a self-contained tutorial
    on building Node web applications.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有网络开发都涉及构建网络应用程序。有时你需要做一些事情，比如从旧网站中提取数据，以便在重建时使用。我们包括了[附录 B](kindle_split_026.xhtml#app02)，它全部关于网络爬取，作为展示如何使用
    Node 的 JavaScript 运行时与文档对象模型 (DOM) 交互的一种方式，同时也展示了如何在典型的 Express 网络应用程序的舒适区之外使用
    Node。如果你只想快速制作一个基本的网络应用程序，[第 3 章](kindle_split_013.xhtml#ch03) 提供了一个关于构建 Node
    网络应用程序的独立教程。
- en: 1.5.2\. Command-line tools and daemons
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.2. 命令行工具和守护进程
- en: Node is used to write command-line tools such as process managers and JavaScript
    transpilers that are used by JavaScript developers. But it’s also used as a convenient
    way to write handy command-line tools that do other things, including image conversion,
    and scripts for controlling media playback.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Node 用于编写命令行工具，如进程管理器和 JavaScript 转译器，这些工具被 JavaScript 开发者使用。但它也被用作编写方便的命令行工具的便捷方式，这些工具可以执行其他任务，包括图像转换和媒体播放控制的脚本。
- en: 'Here’s a quick command-line example that you can try. Create a new file called
    cli.js and add the following lines:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的命令行示例，你可以尝试。创建一个名为 cli.js 的新文件，并添加以下行：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run the script with `node cli.js yourName` and you’ll see `Hello yourName`.
    This works by using ES2015 destructuring to pull out the third argument from `process.argv`.
    The `process` object is available to every Node program and forms the basis for
    accepting arguments when users run your programs.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `node cli.js yourName` 运行脚本，你会看到 `Hello yourName`。这是通过使用 ES2015 解构来从 `process.argv`
    中提取第三个参数实现的。`process` 对象对每个 Node 程序都可用，并构成了当用户运行你的程序时接受参数的基础。
- en: 'You can do a few other things with Node command-line programs. If you add a
    line to the start of the program that starts with `#!`, and grant it execute permissions
    (`chmod +x cli.js`), then you can make the shell use Node when it invokes the
    program. Now you can run your Node programs just like any other shell script.
    Just use a line like this for Unix-like systems:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Node 命令行程序做几件事情。如果你在程序的开始处添加一行以 `#!` 开头，并授予它执行权限 (`chmod +x cli.js`)，那么你可以让
    shell 在调用程序时使用 Node。现在你可以像运行任何其他 shell 脚本一样运行你的 Node 程序。对于类 Unix 系统，你可以使用如下行：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By using Node this way, you can replace your shell scripts with Node. This means
    Node can be used with any other command-line tools, including background programs.
    Node programs can be invoked by cron, or run in the background as daemons.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式使用 Node，你可以用 Node 替换你的 shell 脚本。这意味着 Node 可以与任何其他命令行工具一起使用，包括后台程序。Node
    程序可以通过 cron 调用，或作为守护进程在后台运行。
- en: 'If all of this is new to you, don’t worry: [chapter 11](kindle_split_023.xhtml#ch11)
    introduces writing command-line utilities, and shows how this type of program
    plays into Node’s strengths. For example, command-line tools make heavy use of
    streams as a universal API, and streams are one of Node’s most powerful features.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些都对你来说是新的，不要担心：第 11 章 [chapter 11](kindle_split_023.xhtml#ch11) 介绍了编写命令行工具，并展示了这类程序如何发挥
    Node 的优势。例如，命令行工具大量使用流作为通用 API，而流是 Node 最强大的功能之一。
- en: 1.5.3\. Desktop applications
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.3\. 桌面应用
- en: If you’ve been using the Atom or Visual Studio Code text editors, then you’ve
    been using Node all along. The Electron framework uses Node as the back end, so
    whenever I/O such as disk or network access is required, Electron uses Node. Electron
    also uses Node for managing dependencies, which means you can add packages from
    npm to Electron projects.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直在使用 Atom 或 Visual Studio Code 文本编辑器，那么你一直在使用 Node。Electron 框架使用 Node 作为后端，因此每当需要磁盘或网络访问等
    I/O 操作时，Electron 都会使用 Node。Electron 还使用 Node 来管理依赖项，这意味着你可以将 npm 包添加到 Electron
    项目中。
- en: 'If you want to quickly try Electron now, you can clone the Electron repository
    and start up an application:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在想快速尝试 Electron，你可以克隆 Electron 仓库并启动一个应用：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To learn how to write an app with Electron, flip ahead to [chapter 12](kindle_split_024.xhtml#ch12).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用 Electron 编写应用，请翻到第 12 章 [chapter 12](kindle_split_024.xhtml#ch12)。
- en: 1.5.4\. Applications suited to Node
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.5.4\. 适合 Node 的应用
- en: We’ve walked through some of the types of applications you can build with Node,
    but there are certain types of applications that Node excels at. Node is commonly
    used to create real-time web applications, which can mean anything from user-facing
    applications such as chat servers to back ends for collecting analytics. Because
    functions are first-class objects in JavaScript, and Node has a built-in event
    model, writing asynchronous real-time programs feels more natural than other scripting
    languages.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了一些可以使用 Node 构建的应用类型，但 Node 在某些类型的应用上表现出色。Node 通常用于创建实时网络应用，这可能意味着从面向用户的应用，如聊天服务器，到收集分析的后端。由于函数在
    JavaScript 中是一等对象，并且 Node 内置了事件模型，因此编写异步实时程序比其他脚本语言更自然。
- en: If you’re building traditional Model-View-Controller (MVC) web applications,
    Node can do this well. Popular blogging engines are built with Node, such as Ghost
    ([https://ghost.org/](https://ghost.org/)); Node is now a proven platform for
    building these types of web applications. The style of development is different
    from WordPress, which is built with PHP, but Ghost supports similar features,
    including templates and a multiuser administration area.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建传统的模型-视图-控制器（MVC）Web应用程序，Node可以很好地完成这项工作。流行的博客引擎都是用Node构建的，例如Ghost ([https://ghost.org/](https://ghost.org/));
    Node现在是一个经过验证的平台，用于构建这类Web应用程序。其开发风格与用PHP构建的WordPress不同，但Ghost支持类似的功能，包括模板和多用户管理区域。
- en: Node can also do things that are much harder in other languages. It’s based
    on JavaScript, and it’s possible to run browser JavaScript in Node. Complex client-side
    applications can be adapted to run on a Node server, allowing servers to pre-render
    web applications, which speeds up page rendering time in the browser and also
    facilitates search engines.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Node还可以做其他语言中很难做到的事情。它基于JavaScript，并且可以在Node中运行浏览器JavaScript。复杂的客户端应用程序可以适配在Node服务器上运行，允许服务器预先渲染Web应用程序，这可以加快浏览器中的页面渲染时间，并便于搜索引擎。
- en: Finally, if you’re considering building a desktop or mobile app, you should
    try Electron, which is powered by Node. Now that web user interfaces are as rich
    as desktop experiences, Electron desktop apps can rival native web applications
    and cut down development time. Electron also supports three major platforms, so
    you can reuse your code across Windows, Linux, and macOS.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你在考虑构建桌面或移动应用程序，你应该尝试Electron，它由Node提供支持。现在，随着Web用户界面与桌面体验一样丰富，Electron桌面应用程序可以与原生Web应用程序相媲美，并缩短开发时间。Electron还支持三个主要平台，因此你可以在Windows、Linux和macOS之间重用代码。
- en: 1.6\. Summary
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6\. 总结
- en: Node is an evented and nonblocking platform for building JavaScript applications.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点是一个事件驱动且非阻塞的平台，用于构建JavaScript应用程序。
- en: V8 is used as the JavaScript runtime.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: V8用作JavaScript运行时。
- en: libuv is the native library that provides fast, cross-platform, nonblocking
    I/O.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: libuv是提供快速、跨平台、非阻塞I/O的本地库。
- en: Node has a small standard library known as the core modules that add network
    and disk I/O to JavaScript.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node有一个小型的标准库，称为核心模块，它为JavaScript添加了网络和磁盘I/O。
- en: Node comes with a debugger and a dependency manager (npm).
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node自带调试器和依赖管理器（npm）。
- en: Node is used for building web applications, command-line tools, and even desktop
    applications.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node用于构建Web应用程序、命令行工具，甚至桌面应用程序。
- en: Chapter 2\. Node programming fundamentals
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章\. Node编程基础
- en: '*This chapter covers*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Organizing your code into modules
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码组织成模块
- en: Handling one-off events with callbacks
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用回调处理一次性事件
- en: Handling repeating events with event emitters
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件发射器处理重复事件
- en: Implementing serial and parallel flow control
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现串行和并行流控制
- en: Using flow-control tools
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流控制工具
- en: 'Node, unlike many open source platforms, is easy to set up and doesn’t require
    much in terms of memory and disk space. No complex integrated development environments
    or build systems are required. Some fundamental knowledge will, however, help
    you a lot when starting out. In this chapter, we address two challenges that new
    Node developers face:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多开源平台不同，Node易于设置，对内存和磁盘空间的要求不高。不需要复杂的集成开发环境或构建系统。然而，一些基本知识在开始时将非常有帮助。在本章中，我们讨论了新Node开发者面临的两项挑战：
- en: How to organize your code
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何组织你的代码
- en: How asynchronous programming works
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程是如何工作的
- en: In this chapter, you’ll learn important asynchronous programming techniques
    that will allow you to keep a tight rein on how your application executes. You’ll
    learn
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习重要的异步编程技术，这将使你能够紧密控制应用程序的执行方式。你将学习
- en: How to respond to one-time events
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何响应一次性事件
- en: How to handle repeating events
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理重复事件
- en: How to sequence asynchronous logic
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编排异步逻辑
- en: We’ll start, however, with how you can tackle the problem of code organization
    through the use of *modules*, which are Node’s way of keeping code organized and
    packaged for easy reuse.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍如何通过使用*模块*来处理代码组织的问题，这是Node保持代码组织并便于重用的方式。
- en: 2.1\. Organizing and reusing Node functionality
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 组织和重用Node功能
- en: When creating an application, Node or otherwise, you often reach a point where
    putting all your code in a single file becomes unwieldy. When this happens, the
    conventional approach, as represented in [figure 2.1](#ch02fig01), is to take
    a file containing a lot of code and try to organize it by grouping related logic
    and moving it into separate files.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个应用程序时，无论是 Node 还是其他，你通常会达到一个点，将所有代码放入一个文件中会变得难以管理。当这种情况发生时，如图 2.1 所示的传统方法是将包含大量代码的文件取出来，尝试通过将相关的逻辑分组并移动到单独的文件中来组织它。
- en: Figure 2.1\. Navigating your code is easier if you organize it into directories
    and separate files rather than keeping your application in one long file.
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.1\. 如果将你的代码组织成目录和单独的文件，而不是将应用程序保存在一个长文件中，那么导航你的代码会更简单。
- en: '![](Images/02fig01.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1](Images/02fig01.jpg)'
- en: In some language implementations, such as PHP and Ruby, incorporating the logic
    from another file (we call this the *included* file) can mean that all the logic
    executed in that file affects the global scope. Any variables created and functions
    declared in the included file risk overwriting those created and declared by the
    application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言实现中，例如 PHP 和 Ruby，从另一个文件（我们称之为 *包含文件*）中引入逻辑（我们称之为 *包含文件*）可能意味着该文件中执行的所有逻辑都会影响全局作用域。在包含文件中创建的任何变量和声明的任何函数都可能覆盖应用程序中创建和声明的变量和函数。
- en: 'Say you’re programming in PHP; your application might contain the following
    logic:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在 PHP 中编程；你的应用程序可能包含以下逻辑：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If your string_handlers.php file also attempted to define an `uppercase_trim`
    function, you’d receive the following error:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 string_handlers.php 文件也尝试定义一个 `uppercase_trim` 函数，你会收到以下错误：
- en: '[PRE24]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In PHP you can avoid this by using *namespaces*, and Ruby offers similar functionality
    through *modules*. Node, however, avoids this potential problem by not offering
    an easy way to accidentally pollute the global namespace.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 中，你可以通过使用 *命名空间* 来避免这种情况，而 Ruby 通过 *模块* 提供类似的功能。然而，Node 通过不提供一种简单的方式来意外地污染全局命名空间，从而避免了这种潜在问题。
- en: '|  |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: PHP namespaces, Ruby modules
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: PHP 命名空间，Ruby 模块
- en: 'PHP namespaces are discussed in the PHP language manual at [http://php.net/manual/en/language.namespaces.php](http://php.net/manual/en/language.namespaces.php).
    Ruby modules are explained in the Ruby documentation: [http://ruby-doc.org/core-2.3.1/Module.html](http://ruby-doc.org/core-2.3.1/Module.html).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 命名空间在 PHP 语言手册中有讨论：[http://php.net/manual/en/language.namespaces.php](http://php.net/manual/en/language.namespaces.php)。Ruby
    模块在 Ruby 文档中有解释：[http://ruby-doc.org/core-2.3.1/Module.html](http://ruby-doc.org/core-2.3.1/Module.html)。
- en: '|  |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Node modules bundle up code for reuse, but they don’t alter global scope. Suppose,
    for example, you’re developing an open source content management system (CMS)
    application by using PHP, and you want to use a third-party API library that doesn’t
    use namespaces. This library could contain a class with the same name as one in
    your application, which would break your application unless you changed the class
    name either in your application or the library. Changing the class name in your
    application, however, could cause problems for other developers using your CMS
    as the basis of their own projects. Changing the class name in the library would
    require you to remember to repeat this hack each time you update the library in
    your application’s source tree. Naming collisions are a problem best avoided altogether.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 节点模块将代码捆绑起来以供重用，但它们不会改变全局作用域。例如，假设你正在使用 PHP 开发一个开源内容管理系统（CMS）应用程序，并且你想使用一个不使用命名空间的第三方
    API 库。这个库可能包含一个与你的应用程序中相同名称的类，这会破坏你的应用程序，除非你更改应用程序或库中的类名。然而，更改应用程序中的类名可能会给其他使用你的
    CMS 作为他们项目基础的开发者带来问题。在库中更改类名将要求你在应用程序的源树中更新库时记住重复这个技巧。命名冲突是一个最好完全避免的问题。
- en: Node modules allow you to select which functions and variables from the included
    file are exposed to the application. If the module is returning more than one
    function or variable, the module can specify these by setting the properties of
    an object called `exports`. If the module is returning a single function or variable,
    the property `module.exports` can instead be set. [Figure 2.2](#ch02fig02) shows
    how this works.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 节点模块允许你选择从包含的文件中暴露给应用程序的哪些函数和变量。如果模块返回多个函数或变量，模块可以通过设置一个名为 `exports` 的对象的属性来指定这些函数或变量。如果模块只返回一个函数或变量，则可以设置
    `module.exports` 属性。![图 2.2](#ch02fig02) 展示了这是如何工作的。
- en: Figure 2.2\. The population of the `module.exports` property or the exports
    object allows a module to select what should be shared with the application.
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.2\. `module.exports` 属性或 `exports` 对象的设置允许模块选择与应用程序共享的内容。
- en: '![](Images/02fig02.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.2](Images/02fig02.jpg)'
- en: If this seems a bit confusing, don’t worry; we run through several examples
    in this chapter. By avoiding pollution of the global scope, Node’s module system
    avoids naming conflicts and simplifies code reuse. Modules can then be published
    to the npm (package manager) registry, an online collection of ready-to-use Node
    modules, and shared with the Node community without those using the modules having
    to worry about one module overwriting the variables and functions of another.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来有点复杂，不要担心；我们将在本章中通过几个示例来讲解。通过避免全局作用域的污染，Node 的模块系统避免了命名冲突并简化了代码重用。然后，模块可以被发布到
    npm（包管理器）注册表，这是一个在线的、可用的 Node 模块集合，并与 Node 社区共享，而无需担心使用模块的人会覆盖其他模块的变量和函数。
- en: 'To help you organize your logic into modules, we cover the following topics:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你将逻辑组织到模块中，我们涵盖了以下主题：
- en: How you can create modules
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以如何创建模块
- en: Where modules are stored in the filesystem
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块在文件系统中的存储位置
- en: Things to be aware of when creating and using modules
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用模块时需要注意的事项
- en: Let’s dive into learning the Node module system by starting a new Node project
    and then creating a simple module.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过启动一个新的 Node 项目并创建一个简单的模块来深入学习 Node 模块系统。
- en: 2.2\. Starting a new Node project
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. 开始一个新的 Node 项目
- en: 'Creating a new Node project is easy: create a folder and then run `npm init`.
    That’s it! The `npm` command will ask you a few questions, and you can answer
    yes to all of them. Here’s a full example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Node 项目很简单：创建一个文件夹，然后运行 `npm init`。就这样！`npm` 命令会问你几个问题，你可以对它们都回答“是”。以下是一个完整的示例：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `-y` flag means *yes*. That means npm will create a package.json file with
    default values. If you want more control, leave off the `-y` flag, and npm will
    run you through a set of questions about the project’s license, author name, and
    so on. After you’ve done this, look at the contents of package.json. You can manually
    edit it, but remember, it has to be valid JSON.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`-y` 标志表示“是”。这意味着 npm 将使用默认值创建一个 package.json 文件。如果你想有更多的控制权，请去掉 `-y` 标志，npm
    将会引导你回答一系列关于项目许可证、作者姓名等问题。完成这些后，查看 package.json 的内容。你可以手动编辑它，但请记住，它必须是有效的 JSON
    格式。'
- en: Now that you have an empty project, you can create your own module.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个空项目，你可以创建自己的模块。
- en: 2.2.1\. Creating modules
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1\. 创建模块
- en: 'Modules can be either single files or directories containing one or more files,
    as you can see in [figure 2.3](#ch02fig03). If a module is a directory, the file
    in the module directory that will be evaluated is typically named index.js (although
    this can be overridden: see [section 2.5](#ch02lev1sec5)).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以是单个文件，也可以是包含一个或多个文件的目录，正如你在[图 2.3](#ch02fig03)中看到的。如果模块是一个目录，那么将被评估的模块目录中的文件通常命名为
    index.js（尽管这可以被覆盖：参见[第 2.5 节](#ch02lev1sec5)）。
- en: Figure 2.3\. Node modules can be created by using either files (example 1) or
    directories (example 2).
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.3\. 可以通过使用文件（示例 1）或目录（示例 2）来创建 Node 模块。
- en: '![](Images/02fig03.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.3](Images/02fig03.jpg)'
- en: To create a typical module, you create a file that defines properties on the
    `exports` object with any kind of data, such as strings, objects, and functions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个典型的模块，你需要创建一个文件，该文件定义了 `exports` 对象上的属性，可以是任何类型的数据，如字符串、对象和函数。
- en: To show how a basic module is created, let’s see how to add some currency conversion
    functionality to a file named currency.js. This file, shown in the following listing,
    will contain two functions that convert Canadian dollars to U.S. dollars, and
    vice versa.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何创建一个基本的模块，让我们看看如何向名为 currency.js 的文件添加一些货币转换功能。这个文件，如以下列表所示，将包含两个函数，用于将加拿大元转换为美元，反之亦然。
- en: Listing 2.1\. Defining a Node module (currency.js)
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.1\. 定义 Node 模块（currency.js）
- en: '![](Images/02lis01_alt.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.1](Images/02lis01_alt.jpg)'
- en: Note that only two properties of the `exports` object are set. Therefore, only
    the two functions, `canadianToUS` and `USToCanadian`, can be accessed by the application
    including the module. The variable `canadianDollar` acts as a private variable
    that affects the logic in `canadianToUS` and `USToCanadian` but can’t be directly
    accessed by the application.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有 `exports` 对象的两个属性被设置。因此，只有两个函数，`canadianToUS` 和 `USToCanadian`，可以被应用程序包括模块访问。变量
    `canadianDollar` 作为私有变量，影响 `canadianToUS` 和 `USToCanadian` 中的逻辑，但应用程序不能直接访问它。
- en: To use your new module, use Node’s `require` function, which takes a path to
    the module you wish to use as an argument. Node performs a synchronous lookup
    to locate the module and loads the file’s contents. The order in which Node looks
    for files is first core modules, then the current directory, and finally node_modules.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用你的新模块，使用 Node 的 `require` 函数，该函数将模块的路径作为参数。Node 执行同步查找以定位模块并加载文件内容。Node 查找文件的顺序是首先核心模块，然后是当前目录，最后是
    node_modules。
- en: '|  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**A note about require and synchronous I/O**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于 require 和同步 I/O 的注意事项**'
- en: '`require` is one of the few synchronous I/O operations available in Node. Because
    modules are used often and are typically included at the top of a file, having
    `require` be synchronous helps keep code clean, ordered, and readable.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`require` 是 Node 中可用的少数几个同步 I/O 操作之一。由于模块经常被使用，并且通常包含在文件的顶部，因此使 `require` 同步有助于保持代码整洁、有序和可读。'
- en: Avoid using `require` in I/O-intensive parts of your application. Any synchronous
    call will block Node from doing anything until the call has finished. For example,
    if you’re running an HTTP server, you’d take a performance hit if you used `require`
    on each incoming request. This is typically why `require` and other synchronous
    operations are used only when the application initially loads.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在应用程序的 I/O 密集部分使用 `require`。任何同步调用都会阻塞 Node 执行任何操作，直到调用完成。例如，如果你正在运行一个 HTTP
    服务器，如果你在每次传入请求时都使用 `require`，那么你会遭受性能损失。这通常是为什么 `require` 和其他同步操作仅在应用程序最初加载时使用的原因。
- en: '|  |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the next listing, which shows test-currency.js, you `require` the currency.js
    module.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，展示了 test-currency.js，你 `require` 了 currency.js 模块。
- en: Listing 2.2\. Requiring a module (test_currency.js)
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2\. 引入模块（test_currency.js）
- en: '![](Images/02lis02_alt.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02lis02_alt.jpg)'
- en: Requiring a module that begins with ./ means that if you were to create your
    application script named test-currency.js in a directory named currency_app, then
    your currency.js module file, as represented in [figure 2.4](#ch02fig04), would
    also need to exist in the currency_app directory. When requiring, the .js extension
    is assumed, so you can omit it if desired. If you don’t include .js, Node will
    also check for a .json file. JSON files are loaded as JavaScript objects.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 引入以 ./ 开头的模块意味着，如果你在名为 currency_app 的目录中创建名为 test-currency.js 的应用程序脚本，那么如图 [2.4](#ch02fig04)
    所示的 currency.js 模块文件也需要存在于 currency_app 目录中。在引入时，假定 .js 扩展名，所以如果你希望的话可以省略它。如果你不包括
    .js，Node 也会检查 .json 文件。JSON 文件被加载为 JavaScript 对象。
- en: Figure 2.4\. When you put ./ at the beginning of a module `require`, Node will
    look in the same directory as the program file being executed.
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.4\. 当你在模块 `require` 的开始处放置 ./ 时，Node 将在执行程序文件相同的目录中查找。
- en: '![](Images/02fig04.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig04.jpg)'
- en: After Node has located and evaluated your module, the `require` function returns
    the contents of the `exports` object defined in the module. You’re then able to
    use the two functions returned by the module to perform currency conversion.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 定位并评估你的模块之后，`require` 函数返回模块中定义的 `exports` 对象的内容。然后你可以使用模块返回的两个函数来执行货币转换。
- en: 'If you want to organize related modules, you can put modules into subdirectories.
    If, for example, you want to put the currency module in a folder called lib/,
    you can do so by changing the line with `require` to the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要组织相关的模块，你可以将模块放入子目录中。例如，如果你想将货币模块放入名为 lib/ 的文件夹中，你可以通过将 `require` 的行更改为以下内容来实现：
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Populating the `exports` object of a module gives you a simple way to group
    reusable code in separate files.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 填充模块的 `exports` 对象为你提供了一个简单的方法来在单独的文件中分组可重用代码。
- en: 2.3\. Fine-tuning module creation by using module.exports
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3\. 通过使用 module.exports 调整模块创建的细节
- en: Although populating the `exports` object with functions and variables is suitable
    for most module-creation needs, at times you’ll want a module to deviate from
    this model.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用函数和变量填充 `exports` 对象对于大多数模块创建需求来说是合适的，但有时你可能希望模块偏离这种模式。
- en: 'The currency converter module created in the previous section, for example,
    could be redone to return a single `Currency` constructor function rather than
    an object containing functions. An object-oriented implementation could behave
    something like the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，之前创建的货币转换模块可以重写为返回单个 `Currency` 构造函数，而不是包含函数的对象。面向对象的实现可能如下所示：
- en: '[PRE27]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Returning a function from `require`, rather than an object, will make your code
    more elegant if it’s the only thing you need from the module.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `require` 返回一个函数而不是一个对象，如果这是你从模块中需要的唯一东西，会使你的代码更加优雅。
- en: To create a module that returns a single variable or function, you might guess
    that you need to set `exports` to whatever you want to return. But this won’t
    work, because Node expects `exports` to not be reassigned to any other object,
    function, or variable. The module code in the next listing attempts to set `exports`
    to a function.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个返回单个变量或函数的模块，你可能认为你需要将 `exports` 设置为你想要返回的内容。但这不会起作用，因为 Node 预期 `exports`
    不会被重新分配给任何其他对象、函数或变量。下一个列表中的模块代码尝试将 `exports` 设置为一个函数。
- en: Listing 2.3\. Module won’t work as expected
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.3\. 模块无法按预期工作
- en: '![](Images/02lis03.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02lis03.jpg)'
- en: To get the previous module code to work as expected, you’d need to replace `exports`
    with `module.exports`. The `module.exports` mechanism enables you to export a
    single variable, function, or object. If you create a module that populates both
    `exports` and `module.exports`, `module.exports` will be returned, and `exports`
    will be ignored.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要使先前的模块代码按预期工作，你需要将 `exports` 替换为 `module.exports`。`module.exports` 机制允许你导出一个变量、函数或对象。如果你创建了一个同时填充了
    `exports` 和 `module.exports` 的模块，`module.exports` 将被返回，而 `exports` 将被忽略。
- en: '|  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**What really gets exported**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**真正导出的内容**'
- en: What ultimately gets exported in your application is `module.exports`. `exports`
    is set up as a global reference to `module.exports`, which initially is defined
    as an empty object that you can add properties to. `exports.myFunc` is shorthand
    for `module.exports.myFunc`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中最终导出的是 `module.exports`。`exports` 被设置为对 `module.exports` 的全局引用，它最初被定义为可以添加属性的空对象。`exports.myFunc`
    是 `module.exports.myFunc` 的简写。
- en: 'As a result, if `exports` is set to anything else, it breaks the *reference*
    between `module.exports` and `exports`. Because `module.exports` is what gets
    exported, `exports` will no longer work as expected—it doesn’t reference `module.exports`
    anymore. If you want to maintain that link, you can make `module.exports` reference
    `exports` again as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果 `exports` 被设置为其他任何内容，它就会破坏 `module.exports` 和 `exports` 之间的 *引用*。因为 `module.exports`
    是被导出的内容，`exports` 将不再按预期工作——它不再引用 `module.exports`。如果你想保持这个链接，你可以按照以下方式再次使 `module.exports`
    引用 `exports`：
- en: '[PRE28]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By using either `exports` or `module.exports`, depending on your needs, you
    can organize functionality into modules and avoid the pitfall of ever-growing
    application scripts.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的需求，使用 `exports` 或 `module.exports`，你可以将功能组织到模块中，并避免不断增长的应用程序脚本中的陷阱。
- en: '|  |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.4\. Reusing modules by using the node_modules folder
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4\. 通过使用 node_modules 文件夹重用模块
- en: Requiring modules in the filesystem to exist relative to an application is useful
    for organizing application-specific code, but isn’t as useful for code you’d like
    to reuse between applications or share with others. Node includes a unique mechanism
    for code reuse that allows modules to be required without knowing their location
    in the filesystem. This mechanism is the use of node_modules directories.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件系统中按相对于应用程序的方式要求模块存在，对于组织特定于应用程序的代码很有用，但对于你希望在应用程序之间重用或与他人共享的代码来说并不那么有用。Node
    包含一个独特的代码重用机制，允许在不了解它们在文件系统中的位置的情况下要求模块。这个机制就是使用 node_modules 目录。
- en: In the earlier module example, you required ./currency. If you omit the ./ and
    simply require currency, Node will follow certain rules, as specified in [figure
    2.5](#ch02fig05), to search for this module.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的模块示例中，你要求 ./currency。如果你省略了 ./ 并简单地要求 currency，Node 将遵循如图 2.5 所示的某些规则来搜索此模块。
- en: Figure 2.5\. Steps to finding a module
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.5\. 寻找模块的步骤
- en: '![](Images/02fig05.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig05.jpg)'
- en: The `NODE_PATH` environmental variable provides a way to specify alternative
    locations for Node modules. If used, `NODE_PATH` should be set to a list of directories
    separated by semicolons in Windows, or colons in other operating systems.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`NODE_PATH` 环境变量提供了一种指定 Node 模块替代位置的方法。如果使用，Windows 上的 `NODE_PATH` 应该设置为用分号分隔的目录列表，在其他操作系统上用冒号分隔。'
- en: 2.5\. Exploring caveats
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5\. 探索注意事项
- en: Although the essence of Node’s module system is straightforward, you should
    be aware of two points.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Node的模块系统本质上是简单的，但你应该注意两个要点。
- en: First, if a module is a directory, the file in the module directory that will
    be evaluated must be named index.js, unless specified otherwise by a file in the
    module directory named package.json. To specify an alternative to index.js, the
    package.json file must contain JavaScript Object Notation (JSON) data defining
    an object with a key named `main` that specifies the path, within the module directory,
    to the main file. [Figure 2.6](#ch02fig06) shows a flowchart summarizing these
    rules.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果一个模块是一个目录，该模块目录中将被评估的文件必须命名为 index.js，除非模块目录中的名为 package.json 的文件有其他指定。要指定
    index.js 的替代方案，package.json 文件必须包含定义一个具有 `main` 键的对象的 JavaScript 对象表示法（JSON）数据，该键指定了模块目录内主文件的路径。[图
    2.6](#ch02fig06) 展示了一个总结这些规则的流程图。
- en: Figure 2.6\. The package.json file, when placed in a module directory, allows
    you to define your module by using a file other than index.js.
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.6\. 将 package.json 文件放置在模块目录中，允许你使用除 index.js 之外的文件定义你的模块。
- en: '![](Images/02fig06_alt.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig06_alt.jpg)'
- en: 'Here’s an example of a package.json file specifying that currency.js is the
    main file:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 package.json 文件指定 currency.js 是主文件的示例：
- en: '[PRE29]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The other thing to be aware of is Node’s capability to cache modules as objects.
    If two files in an application require the same module, the first `require` will
    store the data returned in application memory so the second `require` won’t need
    to access and evaluate the module’s source files. This means loading a module
    with `require` in the same process returns the same object. Imagine you’ve built
    an MVC web application that has a main app object. You can set up that app object,
    export it, and then `require` it from anywhere within the project. If you’ve added
    useful configuration values to the app object, you can then access those values
    from other files, given a directory structure as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的则是 Node 能够将模块缓存为对象。如果一个应用程序中的两个文件需要相同的模块，第一个 `require` 会将返回的数据存储在应用程序内存中，这样第二个
    `require` 就不需要访问和评估模块的源文件。这意味着在同一个进程中使用 `require` 加载的模块返回的是同一个对象。想象一下，你构建了一个 MVC
    网络应用程序，其中有一个主应用程序对象。你可以设置该应用程序对象，导出它，然后在整个项目中的任何地方 `require` 它。如果你已经向应用程序对象添加了有用的配置值，那么你可以从其他文件中访问这些值，前提是目录结构如下：
- en: '[PRE30]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[Figure 2.7](#ch02fig07) shows how this works.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.7](#ch02fig07) 展示了它是如何工作的。'
- en: Figure 2.7\. Shared app object in a web app
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.7\. 网络应用程序中的共享应用程序对象
- en: '![](Images/02fig07.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig07.jpg)'
- en: The best way to get comfortable with Node’s module system is to play with it,
    verifying the behavior described in this section yourself. Now that you have a
    basic understanding of how modules work, let’s move on to asynchronous programming
    techniques.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉 Node 的模块系统最好的方法就是与之互动，亲自验证本节所描述的行为。现在你已经对模块的工作原理有了基本的了解，让我们继续学习异步编程技术。
- en: 2.6\. Using asynchronous programming techniques
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6\. 使用异步编程技术
- en: 'If you’ve done front-end web programming in which interface events (such as
    mouse clicks) trigger logic, you’ve done asynchronous programming. Server-side
    asynchronous programming is no different: events occur that trigger response logic.
    Two popular models are used in the Node world for managing response logic: callbacks
    and event listeners.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经进行过前端网络编程，其中界面事件（如鼠标点击）触发逻辑，那么你已经进行过异步编程。服务器端异步编程没有不同：发生事件触发响应逻辑。在 Node
    世界中，用于管理响应逻辑的两种流行模型是回调和事件监听器。
- en: '*Callbacks* generally define logic for one-off responses. If you perform a
    database query, for example, you can specify a callback to determine what to do
    with the query results. The callback may display the database results, perform
    a calculation based on the results, or execute another callback by using the query
    results as an argument.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*回调* 通常定义了针对一次性响应的逻辑。例如，如果你执行一个数据库查询，你可以指定一个回调来确定如何处理查询结果。回调可以显示数据库结果，根据结果执行计算，或者使用查询结果作为参数执行另一个回调。'
- en: '*Event listeners*, on the other hand, are callbacks associated with a conceptual
    entity (an *event*). For comparison, a mouse click is an event you would handle
    in the browser when someone clicks the mouse. As an example, in Node an HTTP server
    emits a `request` event when an HTTP request is made. You can listen for that
    `request` event to occur and add response logic. In the following example, the
    function `handle-Request` will be called whenever a `request` event is emitted,
    by using the `Event-Emitter.prototype.on` method to bind an event listener to
    the server:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，*事件监听器*是与一个概念实体（一个*事件*）相关联的回调。为了比较，鼠标点击是在浏览器中处理的事件，当有人点击鼠标时。例如，在Node中，当发起HTTP请求时，HTTP服务器会发射一个`request`事件。你可以监听该`request`事件的发生，并添加响应逻辑。在下面的示例中，当使用`Event-Emitter.prototype.on`方法将事件监听器绑定到服务器时，`handle-Request`函数将在发射`request`事件时被调用：
- en: '[PRE31]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A Node HTTP server instance is an example of an *event emitter*, a class (`Event-Emitter`)
    that can be inherited and that adds the ability to emit and handle events. Many
    aspects of Node’s core functionality inherit from `EventEmitter`, and you can
    also create your own event emitter.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Node HTTP服务器实例是一个*事件发射器*的例子，这是一个可以继承的类（`Event-Emitter`），它增加了发射和处理事件的能力。Node的核心功能中的许多方面都继承自`EventEmitter`，你也可以创建自己的事件发射器。
- en: 'Now that we’ve established that response logic is generally organized in one
    of two ways in Node, you’re ready to jump into how it all works by learning about
    the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了在Node中响应逻辑通常以两种方式组织，你现在可以通过学习以下内容来了解这一切是如何工作的：
- en: How to handle one-off events with callbacks
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用回调处理一次性事件
- en: How to respond to repeating events by using event listeners
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用事件监听器响应重复事件
- en: How to handle some of the challenges of asynchronous programming
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理异步编程的一些挑战
- en: 'Let’s look first at one of the most common ways asynchronous code is handled:
    the use of callbacks.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看处理异步代码最常见的一种方式：使用回调。
- en: 2.7\. Handling one-off events with callbacks
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.7\. 使用回调处理一次性事件
- en: A *callback* is a function, passed as an argument to an asynchronous function,
    that describes what to do after the asynchronous operation has completed. Callbacks
    are used frequently in Node development, more so than event emitters, and they’re
    simple to use.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*回调*是一个函数，作为参数传递给异步函数，它描述了异步操作完成后要执行的操作。在Node开发中，回调的使用频率比事件发射器更高，而且它们的使用很简单。'
- en: 'To demonstrate the use of callbacks in an application, let’s see how to make
    a simple HTTP server that does the following:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示在应用程序中使用回调，让我们看看如何创建一个简单的HTTP服务器，该服务器执行以下操作：
- en: Pulls the titles of recent posts stored as a JSON file asynchronously
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步拉取存储为JSON文件的最近帖子标题
- en: Pulls a basic HTML template asynchronously
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步拉取基本HTML模板
- en: Assembles an HTML page containing the titles
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组装包含标题的HTML页面
- en: Sends the HTML page to the user
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将HTML页面发送给用户
- en: The results will be similar to [figure 2.8](#ch02fig08).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将与[图2.8](#ch02fig08)相似。
- en: Figure 2.8\. An HTML response from a web server that pulls titles from a JSON
    file and returns results as a web page
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.8\. 从JSON文件中提取标题并返回网页的HTML响应
- en: '![](Images/02fig08.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig08.jpg)'
- en: The JSON file (titles.json), shown in the following listing, is formatted as
    an array of strings containing titles of posts.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中显示了JSON文件（titles.json），它格式化为包含帖子标题的字符串数组。
- en: Listing 2.4\. A list of post titles
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.4\. 帖子标题列表
- en: '[PRE32]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The HTML template file (template.html), shown next, includes just a basic structure
    to insert the titles of the blog posts.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的HTML模板文件（template.html）仅包含插入博客帖子标题的基本结构。
- en: Listing 2.5\. A basic HTML template to render the blog titles
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.5\. 用于渲染博客标题的基本HTML模板
- en: '![](Images/02lis05.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02lis05.jpg)'
- en: The code that pulls in the JSON file and renders the web page is shown next
    (blog_recent.js).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取JSON文件并渲染网页的代码如下（blog_recent.js）。
- en: Listing 2.6\. Using callbacks in a simple application
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.6\. 在简单应用程序中使用回调
- en: '![](Images/02lis06_alt.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02lis06_alt.jpg)'
- en: 'This example nests three levels of callbacks:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例嵌套了三个级别的回调：
- en: '[PRE33]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Using three levels isn’t bad, but the more levels of callbacks you use, the
    more cluttered your code looks, and the harder it is to refactor and test, so
    it’s good to limit callback nesting. By creating named functions that handle the
    individual levels of callback nesting, you can express the same logic in a way
    that requires more lines of code, but that could be easier to maintain, test,
    and refactor. The following listing is functionally equivalent to [listing 2.6](#ch02ex06).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三个级别并不坏，但回调级别的数量越多，你的代码看起来就越混乱，重构和测试就越困难，因此限制回调嵌套是好的。通过创建处理回调嵌套各个级别的命名函数，你可以以需要更多行代码的方式表达相同的逻辑，但可能更容易维护、测试和重构。以下列表在功能上等同于[列表2.6](#ch02ex06)。
- en: Listing 2.7\. Reducing nesting by creating intermediary functions
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.7\. 通过创建中间函数减少嵌套
- en: '![](Images/ch02ex07-0.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch02ex07-0.jpg)'
- en: '![](Images/ch02ex07-1.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch02ex07-1.jpg)'
- en: 'You can also reduce the nesting caused by `if/else` blocks with another common
    idiom in Node development: returning early from a function. The following listing
    is functionally the same but avoids further nesting by returning early. It also
    explicitly indicates that the function shouldn’t continue executing.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用Node开发中的另一个常见习语来减少由`if/else`块引起的嵌套：从函数中提前返回。以下列表在功能上相同，但通过提前返回避免了进一步的嵌套。它还明确表示函数不应该继续执行。
- en: Listing 2.8\. Reducing nesting by returning early
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.8\. 通过提前返回减少嵌套
- en: '![](Images/02lis08_alt.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02lis08_alt.jpg)'
- en: Now that you’ve learned how to use callbacks to handle one-off events for such
    tasks as defining responses when reading files and web server requests, let’s
    move on to organizing events by using event emitters.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用回调来处理一次性的事件，例如在读取文件和Web服务器请求时定义响应，让我们继续通过使用事件发射器来组织事件。
- en: '|  |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The Node convention for asynchronous callbacks**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node的异步回调约定**'
- en: 'Most Node built-in modules use callbacks with two arguments: the first argument
    is for an error, should one occur, and the second argument is for the results.
    The error argument is often abbreviated as `err`.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Node内置模块使用两个参数的回调：第一个参数用于错误，如果发生错误，第二个参数用于结果。错误参数通常缩写为`err`。
- en: 'Here’s a typical example of this common function signature:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个这种常见函数签名的典型示例：
- en: '[PRE34]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|  |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.8\. Handling repeating events with event emitters
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.8\. 使用事件发射器处理重复事件
- en: Event emitters fire events and include the ability to handle those events when
    triggered. Some important Node API components, such as HTTP servers, TCP servers,
    and streams, are implemented as event emitters. You can also create your own.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 事件发射器会触发事件，并包括在触发时处理这些事件的能力。一些重要的Node API组件，如HTTP服务器、TCP服务器和流，都是作为事件发射器实现的。你也可以创建自己的。
- en: 'As we mentioned earlier, events are handled through the use of listeners. A
    *listener* is the association of an event with a callback function that gets triggered
    each time the event occurs. For example, a TCP socket in Node has an event called
    `data` that’s triggered whenever new data is available on the socket:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，事件是通过使用监听器来处理的。一个*监听器*是将事件与一个回调函数关联起来，每当事件发生时，该回调函数就会被触发。例如，Node中的TCP套接字有一个名为`data`的事件，每当套接字上有新数据可用时就会触发：
- en: '[PRE35]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let’s look at using `data` events to create an echo server.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`data`事件来创建一个回声服务器。
- en: 2.8.1\. An example event emitter
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.8.1\. 一个示例事件发射器
- en: A simple example of repeated events occurs in an echo server. When you send
    data to an echo server, it echoes the data back, as shown in [figure 2.9](#ch02fig09).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在回声服务器中发生重复事件的简单示例。当你向回声服务器发送数据时，它会将数据回显，如图2.9所示：
- en: Figure 2.9\. An echo server repeating the data sent to it
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.9\. 回声服务器重复发送给它的数据
- en: '![](Images/02fig09.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig09.jpg)'
- en: '[Listing 2.9](#ch02ex09) shows the code needed to implement an echo server.
    Whenever a client connects, a socket is created. The socket is an event emitter
    to which you can then add a listener, using the `on` method, to respond to `data`
    events. These `data` events are emitted whenever new data is available on the
    socket.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表2.9](#ch02ex09)显示了实现回声服务器的代码。每当客户端连接时，就会创建一个套接字。套接字是一个事件发射器，你可以使用`on`方法添加监听器，以响应`data`事件。这些`data`事件会在套接字上有新数据可用时被发射。'
- en: Listing 2.9\. Using the `on` method to respond to events
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.9\. 使用`on`方法响应事件
- en: '![](Images/02lis09_alt.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02lis09_alt.jpg)'
- en: 'You run this echo server by entering the following command:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入以下命令来运行这个回声服务器：
- en: '[PRE36]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After the echo server is running, you can connect to it by entering the following
    command:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在echo服务器运行后，你可以通过输入以下命令来连接到它：
- en: '[PRE37]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Every time data is sent from your connected telnet session to the server, it
    will be echoed back into the telnet session.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 每次从你的连接telnet会话向服务器发送数据时，它都会被回显到telnet会话中。
- en: '|  |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Telnet on Windows
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Windows上的Telnet
- en: 'If you’re using the Microsoft Windows operating system, telnet may not be installed
    by default, and you’ll have to install it yourself. TechNet has instructions for
    the various versions of Windows: [http://mng.bz/egzr](http://mng.bz/egzr).'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Microsoft Windows操作系统，telnet可能默认未安装，你需要自己安装它。TechNet提供了各种Windows版本的说明：[http://mng.bz/egzr](http://mng.bz/egzr)。
- en: '|  |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.8.2\. Responding to an event that should occur only once
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.8.2\. 响应只应发生一次的事件
- en: Listeners can be defined to repeatedly respond to events, as the previous example
    shows, or listeners can be defined to respond only once. The following listing,
    using the `once` method, modifies the previous echo server example to echo only
    the first chunk of data sent to it.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义监听器来重复响应事件，如前一个示例所示，或者可以定义监听器来只响应一次。以下使用`once`方法的列表修改了之前的echo服务器示例，使其只回显发送给它的第一块数据。
- en: Listing 2.10\. Using the `once` method to respond to a single event
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.10\. 使用`once`方法响应单个事件
- en: '![](Images/02lis10.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02lis10.jpg)'
- en: '2.8.3\. Creating event emitters: a publish/subscribe example'
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.8.3\. 创建事件发射器：发布/订阅示例
- en: In the previous example, you used a built-in Node API that uses event emitters.
    Node’s built-in events module, however, allows you to create your own event emitters.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，你使用了内置的Node API，该API使用事件发射器。然而，Node的内置事件模块允许你创建自己的事件发射器。
- en: 'The following code defines a `channel` event emitter with a single listener
    that responds to someone joining the channel. Note that you use `on` (or, alternatively,
    the longer form `addListener`) to add a listener to an event emitter:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了一个具有单个监听器的`channel`事件发射器，该监听器响应有人加入频道的事件。请注意，你使用`on`（或，可选地，较长的形式`addListener`）向事件发射器添加监听器：
- en: '[PRE38]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This `join` callback, however, won’t ever be called, because you haven’t emitted
    any events yet. You could add a line to the listing that would trigger an event
    using the `emit` function:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个`join`回调永远不会被调用，因为你还没有发射任何事件。你可以在列表中添加一行来触发一个事件，使用`emit`函数：
- en: '[PRE39]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|  |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Event names
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 事件名称
- en: 'Events are keys that can have any string value: `data`, `join`, or `some crazy
    long event name`. Only one event, called `error`, is special, and you’ll look
    at it soon.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是具有任何字符串值的键：`data`、`join`或`一些疯狂长的事件名称`。只有一个名为`error`的事件是特殊的，你很快就会看到它。
- en: '|  |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s look at how you could implement your own publish/subscribe logic by using
    `EventEmitter` to make a communication channel. If you run the script in [listing
    2.11](#ch02ex11), you’ll have a simple chat server. A chat server channel is implemented
    as an event emitter that responds to `join` events emitted by clients. When a
    client joins the channel, the join listener logic, in turn, adds an additional
    client-specific listener to the channel for the `broadcast` event that will write
    any message broadcast to the client socket. The names of the event types, such
    as `join` and `broadcast`, are completely arbitrary. You could use other names
    for these event types if you wished.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`EventEmitter`来创建一个通信通道，从而实现自己的发布/订阅逻辑。如果你运行[列表2.11](#ch02ex11)中的脚本，你将拥有一个简单的聊天服务器。聊天服务器频道作为响应客户端发出的`join`事件的发射器来实现。当客户端加入频道时，加入监听器逻辑反过来会向频道添加一个额外的客户端特定监听器，用于`broadcast`事件，该事件将向客户端套接字写入任何广播的消息。事件类型的名称，如`join`和`broadcast`，完全是任意的。如果你愿意，可以为这些事件类型使用其他名称。
- en: Listing 2.11\. A simple publish/subscribe system using an event emitter
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.11\. 使用事件发射器实现的简单发布/订阅系统
- en: '![](Images/02lis11_alt.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02lis11_alt.jpg)'
- en: 'After you have the chat server running, open a new command line and enter the
    following code to enter the chat:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的聊天服务器运行后，打开一个新的命令行并输入以下代码以进入聊天：
- en: '[PRE40]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you open up a few command lines, you’ll see that anything typed in one command
    line is echoed to the others.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开几个命令行，你会看到在其中一个命令行中输入的任何内容都会被回显到其他命令行中。
- en: The problem with this chat server is that when users close their connections
    and leave the chat room, they leave behind a listener that will attempt to write
    to a client that’s no longer connected. This will, of course, generate an error.
    To fix this issue, you need to add the listener in the following listing to the
    `channel` event emitter, and add logic to the server’s `close` event listener
    to emit the channel’s `leave` event. The `leave` event removes the `broadcast`
    listener originally added for the client.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这个聊天服务器的问题在于，当用户关闭他们的连接并离开聊天室时，他们留下了一个监听器，该监听器将尝试向不再连接的客户端写入。这当然会生成一个错误。为了解决这个问题，你需要将以下列表中的监听器添加到`channel`事件发射器中，并添加逻辑到服务器的`close`事件监听器以发出通道的`leave`事件。`leave`事件移除了最初为客户端添加的`broadcast`监听器。
- en: Listing 2.12\. Creating a listener to clean up when clients disconnect
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.12\. 创建一个监听器以在客户端断开连接时进行清理
- en: '![](Images/02lis12_alt.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02lis12_alt.jpg)'
- en: 'If you want to prevent a chat for some reason but don’t want to shut down the
    server, you can use the `removeAllListeners` event emitter method to remove all
    listeners of a given type. The following code shows how this is implemented for
    our chat server example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因你想阻止聊天但不想关闭服务器，你可以使用`removeAllListeners`事件发射器方法来移除特定类型的所有监听器。以下代码展示了如何在我们的聊天服务器示例中实现这一点：
- en: '[PRE41]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can then add support for a chat command that triggers the shutdown. To
    do so, change the listener for the `data` event to the following code:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以添加对触发关闭的聊天命令的支持。为此，将`data`事件的监听器更改为以下代码：
- en: '[PRE42]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now when any chat participant enters `shutdown` into the chat, it’ll cause all
    participants to be kicked off.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当任何聊天参与者将`shutdown`输入到聊天中时，它将导致所有参与者被踢出。
- en: '|  |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Error handling**'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误处理**'
- en: A convention you can use when creating event emitters is to emit an `error`
    type event instead of directly throwing an error. This allows you to define custom
    event response logic by setting one or more listeners for this event type.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建事件发射器时，你可以使用的一个约定是发出一个`error`类型的事件而不是直接抛出错误。这允许你通过设置一个或多个监听器来定义自定义事件响应逻辑。
- en: 'The following code shows how an error listener handles an emitted error by
    logging on the console:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了错误监听器如何通过在控制台记录来处理发出的错误：
- en: '[PRE43]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If no listener for this event type is defined when the `error` event type is
    emitted, the event emitter will output a stack trace (a list of program instructions
    that executed up to the point when the error occurred) and halt execution. The
    stack trace indicates an error of the type specified by the `emit` call’s second
    argument. This behavior is unique to `error` type events; when other event types
    are emitted, and they have no listeners, nothing happens.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在发出`error`事件类型时未定义此事件类型的监听器，事件发射器将输出堆栈跟踪（一个程序指令列表，直到错误发生时执行）并停止执行。堆栈跟踪指示由`emit`调用的第二个参数指定的错误类型。这种行为是`error`类型事件独有的；当发出其他事件类型，并且它们没有监听器时，不会发生任何事情。
- en: 'If an `error` type event is emitted without an `error` object supplied as the
    second argument, a stack trace will indicate an `Uncaught, unspecified ''error''
    event` error, and your application will halt. There is a deprecated method you
    can use to deal with this error—you can define your own response by defining a
    global handler via the following code:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在未提供`error`对象作为第二个参数的情况下发出`error`类型的事件，堆栈跟踪将指示一个`未捕获的，未指定的'error'事件`错误，并且你的应用程序将停止。你可以使用一个已弃用的方法来处理这个错误——你可以通过以下代码定义一个全局处理程序来定义自己的响应：
- en: '[PRE44]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Alternatives to this, such as domains ([http://nodejs.org/api/domain.html](http://nodejs.org/api/domain.html)),
    are being developed, but they’re not considered production-ready.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，如域([http://nodejs.org/api/domain.html](http://nodejs.org/api/domain.html))正在开发中，但它们尚未被认为是生产就绪的。
- en: '|  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'If you want to provide users connecting to chat with a count of currently connected
    users, you can use the following `listeners` method, which returns an array of
    listeners for a given event type:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要为连接到聊天的用户提供当前连接用户数的计数，你可以使用以下`listeners`方法，它返回给定事件类型的监听器数组：
- en: '[PRE45]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To increase the number of listeners that an event emitter has, and to avoid
    the warnings Node displays when there are more than 10 listeners, you can use
    the `setMaxListeners` method. Using your channel event emitter as an example,
    you use the following code to increase the number of allowed listeners:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加事件发射器拥有的监听器数量，并避免Node在监听器超过10个时显示的警告，你可以使用`setMaxListeners`方法。以你的通道事件发射器为例，你使用以下代码来增加允许的监听器数量：
- en: '[PRE46]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '2.8.4\. Extending the event emitter: a file watcher example'
  id: totrans-378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.8.4. 扩展事件发射器：文件监控示例
- en: If you want to build upon the event emitter’s behavior, you can create a new
    JavaScript class that inherits from the event emitter. For example, you can create
    a class called `Watcher` that processes files placed in a specified filesystem
    directory. You then use this class to create a utility that watches a directory
    (renaming any files placed in it to lowercase and then copying the files into
    a separate directory).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要扩展事件发射器的行为，你可以创建一个新的JavaScript类，该类继承自事件发射器。例如，你可以创建一个名为`Watcher`的类，该类处理放置在指定文件系统目录中的文件。然后，你使用这个类创建一个工具来监控目录（将放置在其中的文件重命名为小写，然后将文件复制到另一个目录中）。
- en: After setting up the `Watcher` object, you need to extend the methods inherited
    from `EventEmitter` with two new methods, as shown in the following listing.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好`Watcher`对象之后，你需要扩展从`EventEmitter`继承的方法，如下所示的两个新方法。
- en: Listing 2.13\. Extending the event emitter’s functionality
  id: totrans-381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.13. 扩展事件发射器的功能
- en: '![](Images/02lis13_alt.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02lis13_alt.jpg)'
- en: The `watch` method cycles through the directory, processing any files found.
    The `start` method starts the directory monitoring. The monitoring uses Node’s
    `fs.watchFile` function, so when something happens in the watched directory, the
    `watch` method is triggered, cycling through the watched directory and emitting
    a `process` event for each file found.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`watch`方法遍历目录，处理找到的任何文件。`start`方法开始目录监控。监控使用Node的`fs.watchFile`函数，因此当被监控目录发生变动时，`watch`方法会被触发，遍历被监控目录并为每个找到的文件发出一个`process`事件。'
- en: 'Now that you’ve defined the `Watcher` class, you can put it to work by creating
    a `Watcher` object with the following code:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了`Watcher`类，你可以通过以下代码创建一个`Watcher`对象来使用它：
- en: '[PRE47]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'With your newly created `Watcher` object, you can use the `on` method, inherited
    from the event emitter class, to set the logic used to process each file, as shown
    in this snippet:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你新创建的`Watcher`对象，你可以使用从事件发射器类继承的`on`方法来设置处理每个文件的逻辑，如以下代码片段所示：
- en: '[PRE48]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now that all the necessary logic is in place, you can start the directory monitor
    by using the following code:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有必要的逻辑都已经就绪，你可以使用以下代码开始目录监控：
- en: '[PRE49]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After putting the `Watcher` code into a script and creating watch and done directories,
    you should be able to run the script by using Node, drop files into the watch
    directory, and see the files pop up, renamed to lowercase, in the done directory.
    This is an example of how the event emitter can be a useful class from which to
    create new classes.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Watcher`代码放入脚本中并创建监控和完成目录后，你应该能够通过使用Node运行脚本，将文件放入监控目录，然后在完成目录中看到文件出现，重命名为小写。这是事件发射器可以成为一个有用的类来创建新类的示例。
- en: 'By learning how to use callbacks to define one-off asynchronous logic and how
    to use event emitters to dispatch asynchronous logic repeatedly, you’re one step
    closer to mastering control of a Node application’s behavior. In a single callback
    or event emitter listener, however, you may want to include logic that performs
    additional asynchronous tasks. If the order in which these tasks are performed
    is important, you may be faced with a new challenge: how to control exactly when
    each task, in a series of asynchronous tasks, executes.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习如何使用回调来定义一次性异步逻辑以及如何使用事件发射器来重复派发异步逻辑，你离掌握Node应用程序行为控制更近一步。然而，在一个回调或事件发射器监听器中，你可能想要包含执行额外异步任务的逻辑。如果这些任务执行的顺序很重要，你可能面临一个新的挑战：如何在一系列异步任务中精确控制每个任务的执行时机。
- en: Before we get to controlling when tasks execute—coming up in [section 2.10](#ch02lev1sec10)—let’s
    take a look at some of the challenges you’ll likely encounter as you write asynchronous
    code.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论如何控制任务执行时机之前——将在[第2.10节](#ch02lev1sec10)中介绍——让我们看看你在编写异步代码时可能会遇到的一些挑战。
- en: 2.9\. Challenges with asynchronous development
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.9. 异步开发中的挑战
- en: 'When creating asynchronous applications, you have to pay close attention to
    the way your application flows and keep a watchful eye on application state: the
    conditions of the event loop, application variables, and any other resources that
    change as program logic executes.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建异步应用程序时，你必须密切关注应用程序的流程，并密切关注应用程序状态：事件循环的条件、应用程序变量以及程序逻辑执行过程中发生变化的任何其他资源。
- en: Node’s event loop, for example, keeps track of asynchronous logic that hasn’t
    completed processing. As long as there’s uncompleted asynchronous logic, the Node
    process won’t exit. A continually running Node process is desirable behavior for
    something like a web server, but it isn’t desirable to continue running processes
    that are expected to end after a period of time, such as command-line tools. The
    event loop keeps track of any database connections until they’re closed, preventing
    Node from exiting.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Node的事件循环跟踪尚未完成处理的异步逻辑。只要存在未完成的异步逻辑，Node进程就不会退出。对于像Web服务器这样的应用程序，持续运行的Node进程是理想的行为，但并不希望命令行工具等在一段时间后结束的程序继续运行。事件循环跟踪任何数据库连接，直到它们被关闭，防止Node退出。
- en: Application variables can also change unexpectedly if you’re not careful. [Listing
    2.14](#ch02ex14) shows an example of how the order in which asynchronous code
    executes can lead to confusion. If the example code was executing synchronously,
    you’d expect the output to be “The color is blue.” Because the example is asynchronous,
    however, the value of the `color` variable changes before `console.log` executes,
    and the output is “The color is green.”
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不小心，应用程序变量也可能意外改变。[列表2.14](#ch02ex14)展示了异步代码执行顺序可能导致混淆的一个例子。如果示例代码是同步执行的，你会期望输出是“颜色是蓝色。”然而，由于示例是异步的，`color`变量的值在`console.log`执行之前就改变了，输出是“颜色是绿色。”
- en: Listing 2.14\. How scope behavior can lead to bugs
  id: totrans-397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.14\. 范围行为可能导致错误
- en: '![](Images/02lis14_alt.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02lis14_alt.jpg)'
- en: To “freeze” the contents of the `color` variable, you can modify your logic
    and use a JavaScript closure. In [listing 2.15](#ch02ex15), you wrap the call
    to `asyncFunction` in an anonymous function that takes a `color` argument. You
    then execute the anonymous function immediately, sending it the current contents
    of `color`. By making `color` an argument for the anonymous function, it becomes
    local to the scope of that function, and when the value of `color` is changed
    outside the anonymous function, the local version is unaffected.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 要“冻结”`color`变量的内容，你可以修改你的逻辑并使用JavaScript闭包。在[列表2.15](#ch02ex15)中，你将`asyncFunction`的调用包裹在一个接受`color`参数的匿名函数中。然后你立即执行这个匿名函数，传递给它`color`的当前内容。通过将`color`作为匿名函数的参数，它变成了该函数作用域内的局部变量，当`color`的值在匿名函数外部改变时，局部版本不受影响。
- en: Listing 2.15\. Using an anonymous function to preserve a global variable’s value
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.15\. 使用匿名函数保留全局变量的值
- en: '[PRE50]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is but one of many JavaScript programming tricks you’ll come across in
    your Node development.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是你在Node开发中会遇到许多JavaScript编程技巧之一。
- en: '|  |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Closures
  id: totrans-404
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 闭包
- en: 'For more information on closures, see the Mozilla JavaScript documentation:
    [https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Closures](https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Closures).'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于闭包的信息，请参阅Mozilla JavaScript文档：[https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Closures](https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Closures)。
- en: '|  |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that you understand how to use closures to control your application state,
    let’s look at sequencing asynchronous logic in order to keep the flow of your
    application under control.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何使用闭包来控制你的应用程序状态，让我们来看看如何顺序执行异步逻辑，以保持应用程序的流程控制。
- en: 2.10\. Sequencing asynchronous logic
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.10\. 异步逻辑的顺序
- en: During the execution of an asynchronous program, some tasks can happen anytime,
    independent of what the rest of the program is doing, without causing problems.
    But some tasks should happen only before or after certain other tasks.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步程序的执行过程中，一些任务可以在任何时候发生，独立于程序的其他部分正在做什么，而不会引起问题。但有些任务应该在某些其他任务之前或之后发生。
- en: 'The concept of sequencing groups of asynchronous tasks is called *flow control*
    by the Node community. There are two types of flow control: *serial* and *parallel*,
    as [figure 2.10](#ch02fig10) shows.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: Node社区将异步任务组的顺序概念称为*流控制*。有两种类型的流控制：*串行*和*并行*，如图2.10所示。
- en: 'Figure 2.10\. Serial execution of asynchronous tasks is similar, conceptually,
    to synchronous logic: tasks are executed in sequence. Parallel tasks, however,
    don’t have to execute one after another.'
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.10\. 异步任务的串行执行在概念上类似于同步逻辑：任务按顺序执行。然而，并行任务不需要一个接一个地执行。
- en: '![](Images/02fig10_alt.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig10_alt.jpg)'
- en: Tasks that need to happen one after the other are called *serial*. A simple
    example is the task of creating a directory and the task of storing a file in
    it. You can’t store the file before creating the directory.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 需要依次发生的任务被称为 *串行*。一个简单的例子是创建目录的任务和将文件存储在其中的任务。您不能在创建目录之前存储文件。
- en: Tasks that don’t need to happen one after the other are called *parallel*. It
    isn’t necessarily important when these tasks start and stop relative to one another,
    but they should all be completed before further logic executes. One example is
    downloading numerous files that will later be compressed into a zip archive. The
    files can be downloaded simultaneously, but all of the downloads should be completed
    before creating the archive.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要依次发生的任务被称为 *并行*。这些任务相对于彼此开始和结束的时间并不一定重要，但它们应该在进一步逻辑执行之前全部完成。一个例子是下载多个文件，这些文件稍后将被打包成
    zip 存档。文件可以同时下载，但所有下载应该在创建存档之前完成。
- en: Keeping track of serial and parallel flow control requires programmatic bookkeeping.
    When you implement serial flow control, you need to keep track of the task currently
    executing or maintain a queue of unexecuted tasks. When you implement parallel
    flow control, you need to keep track of how many tasks have executed to completion.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪串行和并行流程控制需要程序化记账。当您实现串行流程控制时，您需要跟踪当前正在执行的任务或维护一个未执行任务队列。当您实现并行流程控制时，您需要跟踪已执行完成的任务数量。
- en: Flow-control tools handle the bookkeeping for you, which makes grouping asynchronous
    serial or parallel tasks easy. Although plenty of community-created add-ons deal
    with sequencing asynchronous logic, implementing flow control yourself demystifies
    it and helps you gain a deeper understanding of how to deal with the challenges
    of asynchronous programming.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 流程控制工具为您处理记账，这使得分组异步串行或并行任务变得容易。尽管许多社区创建的附加组件处理异步逻辑的排序，但自己实现流程控制可以消除神秘感，并帮助您更深入地理解如何处理异步编程的挑战。
- en: In the following sections we show you
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将向您展示
- en: When to use serial flow control
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用串行流程控制
- en: How to implement serial flow control
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现串行流程控制
- en: How to implement parallel flow control
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现并行流程控制
- en: How to use third-party modules for flow control
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用第三方模块进行流程控制
- en: Let’s start by looking at when and how you handle serial flow control in an
    asynchronous world.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看在异步世界中何时以及如何处理串行流程控制。
- en: 2.11\. When to use serial flow control
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.11\. 何时使用串行流程控制
- en: To execute numerous asynchronous tasks in sequence, you could use callbacks,
    but if you have a significant number of tasks, you’ll have to organize them. If
    you don’t, you’ll end up with messy code due to excessive callback nesting.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 要按顺序执行大量异步任务，您可以使用回调函数，但如果您有很多任务，您将不得不组织它们。如果您不这样做，您将因为过多的回调嵌套而得到杂乱的代码。
- en: 'The following code is an example of executing tasks in sequence by using callbacks.
    The example uses `setTimeout` to simulate tasks that take time to execute: the
    first task takes one second, the next takes half of a second, and the last takes
    one-tenth of a second. `setTimeout` is only an artificial simulation; in real
    code you could be reading files, making HTTP requests, and so on. Although this
    example code is short, it’s arguably a bit messy, and there’s no easy way to programmatically
    add another task.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是使用回调函数按顺序执行任务的示例。该示例使用 `setTimeout` 来模拟需要时间执行的任务：第一个任务需要一秒钟，下一个任务需要半秒钟，最后一个任务需要十分之一秒。`setTimeout`
    只是一个人工模拟；在实际代码中，您可能正在读取文件、发起 HTTP 请求等。尽管这段示例代码很短，但它可能有点杂乱，而且没有简单的方法来程序化地添加另一个任务。
- en: '[PRE51]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Alternatively, you can use a flow-control tool such as Async ([http://caolan.github.io/async/](http://caolan.github.io/async/))
    to execute these tasks. Async is straightforward to use and benefits from having
    a small codebase (a mere 837 bytes, minified and compressed). You can install
    Async with the following command:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用流程控制工具，例如 Async ([http://caolan.github.io/async/](http://caolan.github.io/async/))
    来执行这些任务。Async 使用简单，并且得益于拥有一个小型代码库（仅有 837 字节，已压缩和最小化）。您可以使用以下命令安装 Async：
- en: '[PRE52]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, use the code in the next listing to re-implement the previous code snippet
    with serial flow control.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用下一列表中的代码重新实现之前的代码片段，使用串行流程控制。
- en: Listing 2.16\. Serial control using a community-created add-on
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.16\. 使用社区创建的附加组件进行串行控制
- en: '![](Images/02lis16_alt.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02lis16_alt.jpg)'
- en: Although the implementation using flow control means more lines of code, it’s
    generally easier to read and maintain. You’re likely not going to use flow control
    all the time, but if you run into a situation where you want to avoid callback
    nesting, it’s a handy tool for improving code legibility.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用流程控制的实现意味着代码行数更多，但它通常更容易阅读和维护。你可能不会一直使用流程控制，但如果遇到想要避免回调嵌套的情况，它是一个提高代码可读性的实用工具。
- en: Now that you’ve seen an example of the use of serial flow control with a specialized
    tool, let’s look at how to implement it from scratch.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了使用专用工具进行串行流程控制的示例，让我们看看如何从头开始实现它。
- en: 2.12\. Implementing serial flow control
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.12\. 实现串行流程控制
- en: 'To execute numerous asynchronous tasks in sequence by using serial flow control,
    you first need to put the tasks in an array, in the desired order of execution.
    This array, as [figure 2.11](#ch02fig11) shows, acts as a queue: when you finish
    one task, you extract the next task in sequence from the array.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用串行流程控制按顺序执行多个异步任务，你首先需要将这些任务按执行顺序放入一个数组中。如图 2.11 所示，这个数组充当一个队列：当你完成一个任务时，你会从数组中按顺序提取下一个任务。
- en: Figure 2.11\. How serial flow control works
  id: totrans-436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.11\. 串行流程控制的工作原理
- en: '![](Images/02fig11_alt.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![第二章图11的替代文本](Images/02fig11_alt.jpg)'
- en: Each task exists in the array as a function. When a task has completed, the
    task should call a handler function to indicate error status and results. The
    handler function in this implementation will halt execution if there’s an error.
    If there isn’t an error, the handler will pull the next task from the queue and
    execute it.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务都以函数的形式存在于数组中。当任务完成时，任务应调用处理函数来指示错误状态和结果。在这个实现中，如果存在错误，处理函数将停止执行。如果没有错误，处理函数将从队列中提取下一个任务并执行它。
- en: 'To demonstrate an implementation of serial flow control, you’ll make a simple
    application that displays a single article’s title and URL from a randomly chosen
    RSS feed. The list of possible RSS feeds is specified in a text file. The application’s
    output will look something like the following text:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示串行流程控制的实现，你将创建一个简单的应用程序，该应用程序从随机选择的 RSS 源中显示单个文章的标题和 URL。可能的 RSS 源列表指定在一个文本文件中。应用程序的输出将类似于以下文本：
- en: '[PRE53]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Our example requires the use of two helper modules from the npm registry. First,
    open a command-line prompt, and then enter the following commands to create a
    directory for the example and install the helper modules:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例需要使用 npm 注册表中的两个辅助模块。首先，打开命令提示符，然后输入以下命令以创建示例目录并安装辅助模块：
- en: '[PRE54]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `request` module is a simplified HTTP client that you can use to fetch RSS
    data. The `htmlparser` module has functionality that allows you to turn raw RSS
    data into JavaScript data structures.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`request` 模块是一个简化的 HTTP 客户端，你可以使用它来获取 RSS 数据。`htmlparser` 模块具有将原始 RSS 数据转换为
    JavaScript 数据结构的功能。'
- en: Next, create a file named index.js inside your new directory that contains the
    code shown here.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在你的新目录中创建一个名为 index.js 的文件，其中包含以下代码。
- en: Listing 2.17\. Serial flow control implemented in a simple application
  id: totrans-445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.17\. 在简单应用程序中实现的串行流程控制
- en: '![](Images/ch02ex17-0.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![第二章示例17-0](Images/ch02ex17-0.jpg)'
- en: '![](Images/ch02ex17-1.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![第二章示例17-1](Images/ch02ex17-1.jpg)'
- en: 'Before trying out the application, create the file rss_feeds.txt in the same
    directory as the application script. If you don’t have any feeds at hand, you
    can try the Node blog’s feed, which is [http://blog.nodejs.org/feed/](http://blog.nodejs.org/feed/).
    Put the URLs of RSS feeds into the text file, one on each line of the file. After
    you’ve created this file, open a command line and enter the following commands
    to change to the application directory and execute the script:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试应用程序之前，在应用程序脚本相同的目录中创建文件 rss_feeds.txt。如果你没有现成的源，你可以尝试 Node blog 的源，其地址为
    [http://blog.nodejs.org/feed/](http://blog.nodejs.org/feed/)。将 RSS 源的 URL 放入文本文件中，每行一个。创建此文件后，打开命令行并输入以下命令以切换到应用程序目录并执行脚本：
- en: '[PRE55]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Serial flow control, as this example implementation shows, is a way of putting
    callbacks into play when they’re needed, rather than simply nesting them.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 如此例实现所示，串行流程控制是一种在需要时将回调函数投入使用的做法，而不是简单地嵌套它们。
- en: Now that you know how to implement serial flow control, let’s look at how to
    execute asynchronous tasks in parallel.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何实现串行流程控制，让我们看看如何并行执行异步任务。
- en: 2.13\. Implementing parallel flow control
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.13\. 实现并行流程控制
- en: To execute numerous asynchronous tasks in parallel, you again need to put the
    tasks in an array, but this time the order of the tasks is unimportant. Each task
    should call a handler function that will increment the number of completed tasks.
    When all tasks are complete, the handler function should perform some subsequent
    logic.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 要并行执行多个异步任务，你再次需要将任务放入一个数组中，但这次任务的顺序不重要。每个任务应调用一个处理函数，该函数将增加已完成任务的数目。当所有任务都完成后，处理函数应执行一些后续逻辑。
- en: For a parallel flow-control example, you’ll make a simple application that reads
    the contents of text files and outputs the frequency of word use throughout the
    files. Reading the contents of the text files will be done using the asynchronous
    `readFile` function, so numerous file reads can be done in parallel. [Figure 2.12](#ch02fig12)
    shows how this application works.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 对于并行流控制示例，你将创建一个简单的应用程序，该应用程序读取文本文件的内容，并输出文件中单词使用的频率。读取文本文件的内容将使用异步的`readFile`函数，因此可以并行执行多个文件读取。[图2.12](#ch02fig12)显示了该应用程序的工作方式。
- en: Figure 2.12\. Using parallel flow control to implement a frequency count of
    word use in numerous files
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.12\. 使用并行流控制实现多个文件中单词使用的频率计数
- en: '![](Images/02fig12_alt.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![第二章示例19-1的替代图](Images/02fig12_alt.jpg)'
- en: 'The output looks something like the following text (although it’ll likely be
    much longer):'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来类似于以下文本（尽管它可能更长）：
- en: '[PRE56]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Open a command-line prompt and enter the following commands to create two directories—one
    for the example, and another within that to contain the text files you want to
    analyze:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 打开命令行提示符，输入以下命令以创建两个目录——一个用于示例，另一个包含你想要分析的文本文件：
- en: '[PRE57]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Next, create a file named word_count.js inside the listing_218 directory that
    contains the code that follows.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在listing_218目录中创建一个名为word_count.js的文件，其中包含以下代码。
- en: Listing 2.18\. Parallel flow control implemented in a simple application
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.18\. 在简单应用程序中实现并行流控制
- en: '![](Images/ch02ex18-0.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![第二章示例18-0](Images/ch02ex18-0.jpg)'
- en: '![](Images/ch02ex18-1.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![第二章示例18-1](Images/ch02ex18-1.jpg)'
- en: 'Before trying out the application, create some text files in the text directory
    you created earlier. Then open a command line and enter the following commands
    to change to the application directory and execute the script:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试应用程序之前，在之前创建的文本目录中创建一些文本文件。然后打开命令行，输入以下命令以切换到应用程序目录并执行脚本：
- en: '[PRE58]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now that you’ve learned how serial and parallel flow control work under the
    hood, let’s look at how to use community-created tools that allow you to easily
    benefit from flow control in your applications, without having to implement it
    yourself.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了串行和并行流控制的工作原理，让我们看看如何使用社区创建的工具，这些工具允许你轻松地在应用程序中受益于流控制，而无需自己实现。
- en: 2.14\. Using community tools
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.14\. 使用社区工具
- en: Many community add-ons provide convenient flow-control tools. Some popular add-ons
    include Async, Step, and Seq. Although each of these is worth checking out, we’ll
    use Async again for another example.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 许多社区插件提供了方便的流控制工具。一些流行的插件包括Async、Step和Seq。尽管每个都值得检查，但我们将再次使用Async作为另一个示例。
- en: '|  |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Community add-ons for flow control
  id: totrans-471
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 流控制社区插件
- en: 'For more information about community add-ons for flow control, see the article
    “Virtual Panel: How to Survive Asynchronous Programming in JavaScript” by Werner
    Schuster and Dio Synodinos on InfoQ: [http://mng.bz/wKnV](http://mng.bz/wKnV).'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 有关流控制社区插件的更多信息，请参阅Werner Schuster和Dio Synodinos在InfoQ上的文章“虚拟面板：如何在JavaScript中生存异步编程”：[http://mng.bz/wKnV](http://mng.bz/wKnV)。
- en: '|  |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[Listing 2.19](#ch02ex19) is an example of using Async to sequence tasks in
    a script that uses parallel flow control to download two files simultaneously
    and then archive them.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表2.19](#ch02ex19) 是一个示例，展示了如何在脚本中使用Async按顺序执行任务，该脚本使用并行流控制同时下载两个文件，然后归档它们。'
- en: '|  |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The following example won’t work in Microsoft Windows
  id: totrans-476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 以下示例在Microsoft Windows中无法工作
- en: Because the Windows operating system doesn’t come with the `tar` and `curl`
    commands, the following example won’t work in this operating system.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Windows操作系统没有自带`tar`和`curl`命令，以下示例在该操作系统中无法工作。
- en: '|  |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this example, we use serial control to make sure that the downloading is
    done before proceeding to archiving.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用串行控制确保在归档之前完成下载。
- en: Listing 2.19\. Using a community add-on flow-control tool in a simple application
  id: totrans-480
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.19\. 在简单应用程序中使用社区插件流控制工具
- en: '![](Images/ch02ex19-0.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![第二章示例19-0](Images/ch02ex19-0.jpg)'
- en: '![](Images/ch02ex19-1.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![第二章示例19-1](Images/ch02ex19-1.jpg)'
- en: 'The script defines a helper function that downloads any specified release version
    of the Node source code. Two tasks are then executed in series: the parallel downloading
    of two versions of Node and the bundling of the downloaded versions into a new
    archive file.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本定义了一个辅助函数，用于下载任何指定的Node源代码版本。然后执行两个连续的任务：并行下载两个版本的Node以及将下载的版本捆绑成一个新的存档文件。
- en: 2.15\. Summary
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.15. 摘要
- en: Node modules can be organized into reusable modules.
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点模块可以被组织成可重用的模块。
- en: The `require` function is used to load modules.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`require` 函数用于加载模块。'
- en: The `module.exports` and `exports` objects are used to share functions and variables
    from within a module.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module.exports` 和 `exports` 对象用于在模块内部共享函数和变量。'
- en: The package.json file is used to specify dependencies and which file is exported
    as the main file.
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: package.json 文件用于指定依赖项以及哪个文件被导出为主文件。
- en: Asynchronous logic can be controlled with nested callbacks, event emitters,
    and flow-control utilities.
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步逻辑可以通过嵌套回调、事件发射器和流程控制工具进行控制。
- en: Chapter 3\. What is a Node web application?
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章。什么是Node网络应用程序？
- en: '*This chapter covers*'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Creating a new web application
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的网络应用程序
- en: Building RESTful services
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建RESTful服务
- en: Persisting data
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化数据
- en: Working with templates
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板
- en: This chapter is all about Node web applications. After reading this chapter,
    you’ll understand what Node web applications look like and how to start building
    them. You’ll do everything a modern web developer does when building an application.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于Node网络应用程序。阅读本章后，你将了解Node网络应用程序的样子以及如何开始构建它们。你将做现代网络开发者在构建应用程序时所做的所有事情。
- en: You’re going to build a web application called *later* that’s inspired by popular
    read-it-later websites such as Instapaper ([www.instapaper.com](http://www.instapaper.com))
    and Pocket ([getpocket.com](http://getpocket.com)). This involves starting a new
    Node project, managing dependencies, creating a RESTful API, saving data to a
    database, and making an interface with templates. That might sound like a lot,
    but you’ll explore each of the ideas in this chapter again in subsequent chapters.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 你将构建一个名为 *later* 的网络应用程序，该应用程序灵感来源于流行的“稍后阅读”网站，如Instapaper ([www.instapaper.com](http://www.instapaper.com))
    和 Pocket ([getpocket.com](http://getpocket.com))。这包括启动一个新的Node项目，管理依赖项，创建RESTful
    API，将数据保存到数据库中，并使用模板制作界面。这听起来可能很多，但你将在后续章节中再次探索本章中的每个想法。
- en: '[Figure 3.1](#ch03fig01) shows what the result should look like.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.1](#ch03fig01) 展示了结果应该看起来像什么。'
- en: Figure 3.1\. A read-it-later web application
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1. 一个“稍后阅读”网络应用程序
- en: '![](Images/03fig01_alt.jpg)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig01_alt.jpg)'
- en: The read-it-later page on the left has stripped away all of the navigation from
    the target website, preserving the main content and title. More significantly,
    the article is permanently saved to a database, which means you can read it at
    a future date when the original article may no longer be retrievable.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的“稍后阅读”页面已经从目标网站中移除了所有导航，保留了主要内容和标题。更重要的是，文章被永久保存在数据库中，这意味着你可以在未来某个日期阅读它，而此时原始文章可能已无法检索。
- en: Before building a web application, you should create a fresh project. The next
    section shows how to create Node projects from scratch.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建网络应用程序之前，你应该创建一个新的项目。下一节将展示如何从头开始创建Node项目。
- en: 3.1\. Understanding a Node web application’s structure
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1. 理解Node网络应用程序的结构
- en: 'A typical Node web application has the following components:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的Node网络应用程序具有以下组件：
- en: package.json—A file that contains a list of dependencies, and the command that
    runs the application
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: package.json——一个包含依赖项列表和运行应用程序的命令的文件
- en: public/—A folder of static assets, such as CSS and client-side JavaScript
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: public/——一个静态资产文件夹，例如CSS和客户端JavaScript
- en: node_modules/—The place where the project’s dependencies get installed
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: node_modules/——项目依赖项安装的地方
- en: One or more JavaScript files that contains your application code
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个包含你的应用程序代码的JavaScript文件
- en: 'The application code is often further subdivided as follows:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序代码通常进一步细分为以下部分：
- en: app.js or index.js—The code that sets up the application
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: app.js 或 index.js——设置应用程序的代码
- en: models/—Database models
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: models/——数据库模型
- en: views/—The templates that are used to render the pages in the application
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: views/——用于渲染应用程序页面的模板
- en: controllers/ or routes/—HTTP request handlers
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: controllers/ 或 routes/——HTTP请求处理器
- en: middleware/—Middleware components
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: middleware/——中间件组件
- en: 'There are no rules that dictate how your application should be structured:
    most web frameworks are flexible and require configuration. But this template
    is the general outline that you’ll find in most projects.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 没有规则规定你的应用程序应该如何构建：大多数 Web 框架都很灵活，需要配置。但这个模板是大多数项目中都会找到的一般轮廓。
- en: It’s much easier to learn how to do this if you practice, so let’s see how to
    create a skeleton web application the way a seasoned Node programmer would.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你练习，学习如何做这件事会容易得多，所以让我们看看如何以经验丰富的 Node 程序员的方式创建一个骨架 Web 应用程序。
- en: 3.1.1\. Starting a new web app
  id: totrans-517
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.1\. 开始一个新的 Web 应用程序
- en: 'To create a new web app, you need to make a new Node project. Refer to [chapter
    2](kindle_split_012.xhtml#ch02) if you want to refresh your memory, but to recap,
    you need to create a directory and run `npm init` with defaults:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的 Web 应用程序，你需要创建一个新的 Node 项目。如果你想刷新记忆，请参考[第 2 章](kindle_split_012.xhtml#ch02)，但为了回顾，你需要创建一个目录并使用默认值运行
    `npm init`：
- en: '[PRE59]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now you have a fresh project; what’s next? Most people would add a module from
    npm that makes web development easier. Node has a built-in http module that has
    a server, but it’s easier to use something that reduces the boilerplate required
    for command web development tasks. Let’s see how to install Express.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个新的项目；接下来是什么？大多数人会添加一个来自 npm 的模块，使 Web 开发更容易。Node 有一个内置的 http 模块，它有一个服务器，但使用减少命令行
    Web 开发任务样板代码的东西更容易。让我们看看如何安装 Express。
- en: Adding a dependency
  id: totrans-521
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加依赖项
- en: 'To add a dependency to a project, use `npm install`. The following command
    installs Express:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 要向项目中添加依赖项，请使用 `npm install`。以下命令安装了 Express：
- en: '[PRE60]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now if you look at package.json, you should see that Express has been added.
    The following snippet shows the section in question:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你查看 package.json，你应该会看到 Express 已经被添加。以下片段显示了相关部分：
- en: '[PRE61]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The Express module is in the project’s node_modules/ folder. If you wanted to
    uninstall Express from the project, you would run `npm rm express --save`. This
    removes it from node_modules/ and updates the package.json file.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: Express 模块位于项目的 node_modules/ 文件夹中。如果你想从项目中卸载 Express，你可以运行 `npm rm express
    --save`。这将将其从 node_modules/ 中删除，并更新 package.json 文件。
- en: A simple server
  id: totrans-527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 一个简单的服务器
- en: 'Express is focused on modeling your application in terms of HTTP requests and
    responses, and it’s built using Node’s built-in http module. To make a basic application,
    you need to make an application instance by using `express()`, add a route handler,
    and then bind the application to a TCP port. Here’s a full example:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: Express 专注于用 HTTP 请求和响应来建模你的应用程序，它是使用 Node 的内置 http 模块构建的。要创建一个基本的应用程序，你需要使用
    `express()` 创建一个应用程序实例，添加一个路由处理程序，然后将应用程序绑定到一个 TCP 端口。以下是一个完整的示例：
- en: '[PRE62]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: It’s not as complicated as it sounds! Save this code to a file called index.js,
    and run it by typing `node index.js`. Then visit http://localhost:3000 to view
    the result. To avoid having to remember exactly how to run each application, most
    people use npm scripts to simplify the process.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不像听起来那么复杂！将此代码保存到名为 index.js 的文件中，并通过输入 `node index.js` 来运行它。然后访问 http://localhost:3000
    来查看结果。为了避免记住每个应用程序的运行方式，大多数人使用 npm 脚本来简化这个过程。
- en: npm scripts
  id: totrans-531
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: npm 脚本
- en: 'To save your server start command (`node index.js`) as an npm script, open
    package.json and add a new property under `scripts` called `start`:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你的服务器启动命令 (`node index.js`) 保存为 npm 脚本，请打开 package.json 并在 `scripts` 下添加一个名为
    `start` 的新属性：
- en: '[PRE63]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now you can run your application by typing `npm start`. If you see an error
    because port 3000 is already being used on your machine, you can use a different
    port by running `PORT=3001 npm start`. People use npm scripts for all kinds of
    things: building client-side bundles, running tests, and generating documentation.
    You can put anything you like in there; it’s basically a mini-script invocation
    tool.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过输入 `npm start` 来运行你的应用程序。如果你看到错误，因为你的机器上端口 3000 已经被使用，你可以通过运行 `PORT=3001
    npm start` 使用不同的端口。人们使用 npm 脚本做各种事情：构建客户端包、运行测试和生成文档。你可以放任何你喜欢的东西在那里；它基本上是一个迷你脚本调用工具。
- en: 3.1.2\. Comparing other platforms
  id: totrans-535
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.2\. 比较其他平台
- en: 'For comparison, the equivalent PHP Hello World application is shown here:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较，这里展示了等效的 PHP Hello World 应用程序：
- en: '[PRE64]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'It fits on one line and is easy to understand, so what benefits does the more
    complex Node example have? The difference is in terms of programming paradigm:
    with PHP, your application is a *page*; in Node, it’s a server. The Node example
    has complete control over the request and response, so you can do all kinds of
    things without configuring a server. If you want to use HTTP compression or URL
    redirection, you can implement these features as part of your application logic.
    You don’t need to separate HTTP and application logic; they become part of your
    application.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 它适合一行，易于理解，那么更复杂的 Node 示例有什么好处呢？区别在于编程范式：在 PHP 中，你的应用程序是一个 *页面*；在 Node 中，它是一个服务器。Node
    示例对请求和响应有完全的控制权，因此你可以做各种事情而无需配置服务器。如果你想使用 HTTP 压缩或 URL 重定向，你可以将这些功能作为应用程序逻辑的一部分来实现。你不需要将
    HTTP 和应用程序逻辑分开；它们成为你应用程序的一部分。
- en: Instead of having a separate HTTP server configuration, you can keep it in the
    same place, and that means the same directory. This makes Node applications easy
    to deploy and manage.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要一个单独的 HTTP 服务器配置，你可以将其放在同一个地方，这意味着同一个目录。这使得 Node 应用程序易于部署和管理。
- en: Another feature that makes Node applications easy to deploy is npm. Because
    dependencies are installed per project, you don’t get clashes between projects
    on the same system.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使 Node 应用程序易于部署的功能是 npm。因为依赖项是按项目安装的，所以你不会在同一系统上的项目之间遇到冲突。
- en: 3.1.3\. What’s next?
  id: totrans-541
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.1.3\. 接下来是什么？
- en: Now that you have the hang of creating projects with `npm init` and installing
    dependencies with `npm install --save`, you can create new projects quickly. This
    is great, because it means you can try out ideas without messing up other projects.
    If there’s a hot new web framework you want to try, then create a new directory,
    run `npm init`, and install the module from npm.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了使用 `npm init` 创建项目和用 `npm install --save` 安装依赖项，你可以快速创建新项目。这很好，因为它意味着你可以尝试新想法而不会弄乱其他项目。如果你想尝试一个热门的新网络框架，那么创建一个新的目录，运行
    `npm init`，然后从 npm 安装模块。
- en: 'With all of this in place, you’re ready to start writing code. At this stage,
    you can add JavaScript files to your project and load modules that you’ve installed
    with `npm --save` by using `require`. Let’s focus on what most web developers
    would do next: add some RESTful routes. This will help you define your application’s
    API and determine what database models are needed.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些准备工作就绪后，你就可以开始编写代码了。在这个阶段，你可以将 JavaScript 文件添加到你的项目中，并使用 `require` 加载你用
    `npm --save` 安装的模块。让我们专注于大多数网络开发者接下来会做的事情：添加一些 RESTful 路由。这将帮助你定义应用程序的 API 并确定需要哪些数据库模型。
- en: 3.2\. Building a RESTful web service
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 构建 RESTful 网络服务
- en: Your application will be a RESTful web service that allows articles to be created
    and saved in a similar way to Instapaper or Pocket. It’ll use a module that was
    inspired by the original Readability service ([www.readability.com](http://www.readability.com))
    to turn messy web pages into elegant articles that you can read later.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序将是一个 RESTful 网络服务，允许以类似 Instapaper 或 Pocket 的方式创建和保存文章。它将使用一个受原始 Readability
    服务（[www.readability.com](http://www.readability.com)）启发的模块，将混乱的网页转换为优雅的文章，你可以稍后阅读。
- en: 'When designing a RESTful service, you need to think about which operations
    you need and map them to routes in Express. In this case, you need to be able
    to save articles, fetch them so they can be read, fetch a list of all of them,
    and delete articles you no longer want. That maps to these routes:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计 RESTful 服务时，你需要考虑你需要哪些操作，并将它们映射到 Express 的路由中。在这种情况下，你需要能够保存文章、获取它们以便阅读、获取所有文章的列表以及删除不再需要的文章。这对应以下路由：
- en: '`POST /articles`—Create a new article'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /articles`—创建一篇新文章'
- en: '`GET /articles/:id`—Get a single article'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /articles/:id`—获取单个文章'
- en: '`GET /articles`—Get all articles'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /articles`—获取所有文章'
- en: '`DELETE /articles/:id`—Delete an article'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE /articles/:id`—删除一篇文章'
- en: Before getting into issues such as databases and web interfaces, let’s focus
    on creating RESTful resources with Express. You can use cURL to make requests
    to a sample application to get the hang of it, and then move on to more complicated
    operations such as storing data to make it like a real web application.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及数据库和网页界面的问题之前，让我们专注于使用 Express 创建 RESTful 资源。你可以使用 cURL 向示例应用程序发出请求，以熟悉它，然后进行更复杂的操作，例如存储数据，使其更像一个真正的网络应用程序。
- en: The following listing is a simple Express app that implements these routes by
    using a JavaScript array to store the articles.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表是一个简单的 Express 应用程序，它通过使用 JavaScript 数组存储文章来实现这些路由。
- en: Listing 3.1\. RESTful routes example
  id: totrans-553
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.1\. RESTful 路由示例
- en: '![](Images/ch03ex01-0.jpg)'
  id: totrans-554
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch03ex01-0.jpg)'
- en: '![](Images/ch03ex01-1.jpg)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch03ex01-1.jpg)'
- en: 'Save this listing as i`ndex.js` and you should be able to run it with `node
    index.js`. To use this example, follow these steps:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 将此列表保存为`i`ndex.js`，然后您应该能够使用`node index.js`运行它。要使用此示例，请按照以下步骤操作：
- en: '[PRE65]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Creating new Node projects is explored in more detail in [chapter 2](kindle_split_012.xhtml#ch02).
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](kindle_split_012.xhtml#ch02)中更详细地探讨了创建新的Node项目。
- en: '|  |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Running the examples and making changes**'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行示例和进行更改**'
- en: To run these examples, make sure you restart the server after editing the code
    each time. You can do this by pressing Ctrl-C to end the Node process and then
    type `node index.js` to start it again.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些示例，每次编辑代码后请确保重新启动服务器。您可以通过按Ctrl-C结束Node进程，然后输入`node index.js`再次启动它来做到这一点。
- en: The examples are presented in snippets, so you should be able to combine them
    sequentially to produce a working app. If you can’t get it running, try downloading
    the book’s source code from [https://github.com/alexyoung/nodejsinaction](https://github.com/alexyoung/nodejsinaction).
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 示例以代码片段的形式呈现，因此您应该能够按顺序组合它们以生成一个可工作的应用程序。如果您无法运行它，请尝试从[https://github.com/alexyoung/nodejsinaction](https://github.com/alexyoung/nodejsinaction)下载本书的源代码。
- en: '|  |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[Listing 3.1](#ch03ex01) has a built-in array of sample data that’s used to
    respond with JSON for all articles ![](Images/circ1.jpg) by using the Express
    `res.send` method. Express will automatically convert the array to a valid JSON
    response, so it’s perfect for making quick REST APIs.'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表3.1](#ch03ex01) 包含一个内置的样本数据数组，该数组用于通过Express的`res.send`方法以JSON格式响应所有文章！[](Images/circ1.jpg)。Express会自动将数组转换为有效的JSON响应，因此非常适合快速创建REST
    API。'
- en: This example can also respond with a single article by using the same principle
    ![](Images/circ3.jpg). You can even delete an article ![](Images/circ4.jpg) by
    using the standard JavaScript `delete` keyword and a numerical ID specified in
    the URL. You can get values from the URL by putting them in the route string (`/articles/:id`)
    and then getting the value with `req.params.id`.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还可以使用相同的原则响应单个文章！[](Images/circ3.jpg)。您甚至可以使用标准的JavaScript `delete` 关键字和一个在URL中指定的数字ID来删除文章！[](Images/circ4.jpg)。您可以通过将它们放入路由字符串（`/articles/:id`）并在其中获取值来从URL中获取值，即`req.params.id`。
- en: '[Listing 3.1](#ch03ex01) can’t create articles ![](Images/circ2.jpg), because
    for that it needs a request body parser; you’ll look at this in the next section.
    First, let’s look at how you can use this example with cURL ([http://curl.haxx.se](http://curl.haxx.se)).'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表3.1](#ch03ex01) 不能创建文章！[](Images/circ2.jpg)，因为为此它需要一个请求体解析器；您将在下一节中了解这一点。首先，让我们看看如何使用cURL（[http://curl.haxx.se](http://curl.haxx.se)）使用此示例。'
- en: 'After the example is running with `node index.js`, you can make requests to
    it with a browser or cURL. To fetch one article, run the following snippet:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在`node index.js`示例运行后，您可以使用浏览器或cURL向其发送请求。要获取一篇文章，请运行以下代码片段：
- en: '[PRE66]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To fetch all articles, you need to make a request to /articles:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有文章，您需要向/articles 发送请求：
- en: '[PRE67]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'And you can even delete an article:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以删除一篇文章：
- en: '[PRE68]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: But why did we say you couldn’t create articles? The main reason is that implementing
    a POST request requires *body parsing*. Express used to come with a built-in body
    parser, but there are so many ways to implement it that the developers opted to
    make it a separate dependency.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么我们说您不能创建文章呢？主要原因是在实现POST请求时需要*解析请求体*。Express曾经附带一个内置的请求体解析器，但由于有太多的实现方式，开发者选择将其作为一个单独的依赖项。
- en: A body parser knows how to accept MIME-encoded (*Multipurpose Internet Mail
    Extensions*) POST request bodies and turn them into data you can use in your code.
    Usually, you get JSON data that’s easy to work with. Whenever you’ve submitted
    a form on a website, a body parser has been involved somewhere in the server-side
    software.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 请求体解析器知道如何接受MIME编码的（*多用途互联网邮件扩展*）POST请求体，并将它们转换为可以在您的代码中使用的数据。通常，您会得到易于处理的JSON数据。每当您在网站上提交表单时，请求体解析器就会在服务器端软件的某个地方发挥作用。
- en: 'To add the officially supported body parser, run the following npm command:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加官方支持的请求体解析器，请运行以下npm命令：
- en: '[PRE69]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now load the body parser in your application, near the top of the file, as shown
    in the following listing. If you’re following along, you can save this to the
    same folder as [listing 3.1](#ch03ex01) (listing3_1), but we’ve also saved it
    in its own folder in the book’s source code (ch03-what-is-a-node-web-app/listing3_2).
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在文件的顶部附近加载 body parser，如下所示。如果你在跟随，你可以将其保存到与 [listing 3.1](#ch03ex01) (listing3_1)
    相同的文件夹中，但我们也在书籍的源代码中保存了它（ch03-what-is-a-node-web-app/listing3_2）。
- en: Listing 3.2\. Adding a body parser
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2\. 添加 body parser
- en: '![](Images/03lis02_alt.jpg)'
  id: totrans-579
  prefs: []
  type: TYPE_IMG
  zh: '![Images/03lis02_alt.jpg]'
- en: 'This adds two useful features: JSON body parsing ![](Images/circ1.jpg) and
    form-encoded bodies ![](Images/circ2.jpg). It also adds a basic implementation
    for creating articles: if you make a POST request with a field called `title`,
    a new article will be added to the articles array! Here’s the cURL command:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 这增加了两个有用的功能：JSON 主体解析 ![Images/circ1.jpg] 和表单编码的主体 ![Images/circ2.jpg]。它还提供了一个创建文章的基本实现：如果你发送一个名为
    `title` 的字段的 POST 请求，一个新的文章将被添加到文章数组中！以下是 cURL 命令：
- en: '[PRE70]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now you’re not too far away from building a real web application. You need
    just two more things: a way to save data permanently in a database, and a way
    to generate the readable version of articles found on the web.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你离构建一个真正的网络应用程序不远了。你只需要两样东西：一种在数据库中永久保存数据的方法，以及一种生成网络上找到的文章的可读版本的方法。
- en: 3.3\. Adding a database
  id: totrans-583
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3\. 添加数据库
- en: 'There’s no predefined way to add a database to a Node application, but the
    process usually involves the following steps:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 没有预定义的方法可以将数据库添加到 Node 应用程序中，但这个过程通常涉及以下步骤：
- en: Decide on the database you want to use.
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 决定你想要使用的数据库。
- en: Look at the popular modules on npm that implement a driver or object--relational
    mapping (ORM).
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看 npm 上实现驱动程序或对象关系映射 (ORM) 的流行模块。
- en: Add the module to your project with `npm -save`.
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `npm -save` 将模块添加到你的项目中。
- en: Create models that wrap database access with a JavaScript API.
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建封装数据库访问的 JavaScript API 的模型。
- en: Add the models to your Express routes.
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模型添加到你的 Express 路由中。
- en: 'Before adding a database, let’s continue focusing on Express by designing the
    route-handling code from step 5\. The HTTP route handlers in the Express part
    of the application will make simple calls to the database models. Here’s an example:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加数据库之前，让我们继续关注 Express，通过设计步骤 5 中的路由处理代码来继续关注 Express。应用程序 Express 部分的 HTTP
    路由处理程序将对数据库模型进行简单的调用。以下是一个示例：
- en: '[PRE71]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here the HTTP route is for getting all articles, so the model method could be
    something like `Article.all`. This will vary depending on your database API; typical
    examples are `Article.find({}, cb)`,^([[1](#ch00fn01)]) and `Article.fetchAll().then(cb)`.^([[2](#ch00fn02)])
    Note that in these examples, `cb` is an abbreviation of *callback*.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，HTTP 路由是用于获取所有文章的，因此模型方法可能是 `Article.all`。这取决于你的数据库 API；典型的例子是 `Article.find({},
    cb)`，^([[1](#ch00fn01)]) 和 `Article.fetchAll().then(cb)`。^([[2](#ch00fn02)]) 注意，在这些例子中，`cb`
    是 *callback* 的缩写。
- en: ¹
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-594
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Mongoose: [http://mongoosejs.com](http://mongoosejs.com)'
  id: totrans-595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Mongoose: [http://mongoosejs.com](http://mongoosejs.com)'
- en: ²
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Bookshelf.js [http://bookshelfjs.org](http://bookshelfjs.org)
  id: totrans-598
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Bookshelf.js [http://bookshelfjs.org](http://bookshelfjs.org)
- en: Given the amazing number of databases out there, how do you decide which one
    to use? Read on for the reasons that we’re going with SQLite for this example.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到有如此多的数据库，你如何决定使用哪一个？继续阅读，了解我们为什么在这个例子中使用 SQLite 的原因。
- en: '|  |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Which database?**'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择哪个数据库？**'
- en: 'For our project, we’re going to use SQLite ([www.sqlite.org](http://www.sqlite.org)),
    with the popular sqlite3 module ([http://npmjs.com/package/sqlite3](http://npmjs.com/package/sqlite3)).
    SQLite is convenient because it’s an in-process database: you don’t need to install
    a server that runs in the background on your system. Any data that you add is
    written to a file that’s kept after your application is stopped and started again,
    so it’s a good way to get started with databases.'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们将使用 SQLite ([www.sqlite.org](http://www.sqlite.org))，以及流行的 sqlite3
    模块 ([http://npmjs.com/package/sqlite3](http://npmjs.com/package/sqlite3))。SQLite
    很方便，因为它是一个进程内数据库：你不需要在你的系统上安装一个在后台运行的服务器。你添加的任何数据都会写入一个文件，该文件在应用程序停止和重新启动后仍然保留，因此它是开始使用数据库的好方法。
- en: '|  |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.3.1\. Making your own model API
  id: totrans-604
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.1\. 创建自己的模型 API
- en: 'Articles should be created, retrieved, and deleted. Therefore, you need the
    following methods for an `Article` model class:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 文章应该被创建、检索和删除。因此，你需要以下方法来为 `Article` 模型类提供支持：
- en: '`Article.all(cb)`—Return all articles.'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Article.all(cb)`—返回所有文章。'
- en: '`Article.find(id, cb)`—Given an ID, find the corresponding article.'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Article.find(id, cb)`—给定一个 ID，找到相应的文章。'
- en: '`Article.create({ title, content }, cb)`—Create an article with a title and
    content.'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Article.create({ title, content }, cb)`—创建一个具有标题和内容的文章。'
- en: '`Article.delete(id, cb)`—Delete an article by ID.'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Article.delete(id, cb)`—通过 ID 删除文章。'
- en: You can implement all of this with the sqlite3 module. This module allows you
    to fetch multiple rows of results with `db.all`, and single rows with `db.get`.
    First you need a database connection.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 sqlite3 模块实现所有这些功能。此模块允许您使用 `db.all` 获取多行结果，使用 `db.get` 获取单行。首先您需要一个数据库连接。
- en: The following listing shows how to do each of these things with SQLite in Node.
    This code should be saved as `db.js` in the same folder as the code from [listing
    3.1](#ch03ex01).
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何在 Node 中使用 SQLite 实现这些功能。此代码应保存为同一文件夹中的 `db.js` 文件。Node 将加载该模块![图片](Images/circ1.jpg)，然后使用它来获取每篇文章![图片](Images/circ2.jpg)，查找特定文章![图片](Images/circ3.jpg)，以及删除文章![图片](Images/circ4.jpg)。
- en: Listing 3.3\. An `Article` model
  id: totrans-612
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.3\. `Article` 模型
- en: '![](Images/ch03ex03-0.jpg)'
  id: totrans-613
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch03ex03-0.jpg)'
- en: '![](Images/ch03ex03-1.jpg)'
  id: totrans-614
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch03ex03-1.jpg)'
- en: In this example, an object is created called `Article` that can create, fetch,
    and delete data by using standard SQL and the sqlite3 module. First, a database
    file is opened by using `sqlite3.Database` ![](Images/circ1.jpg), and then an
    articles table is created ![](Images/circ2.jpg). The `IF NOT EXISTS` SQL syntax
    is useful here because it means you can rerun the code without accidentally deleting
    and re-creating the articles table.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，创建了一个名为 `Article` 的对象，它可以使用标准 SQL 和 sqlite3 模块创建、获取和删除数据。首先，使用 `sqlite3.Database`
    打开数据库文件![图片](Images/circ1.jpg)，然后创建一个文章表![图片](Images/circ2.jpg)。`IF NOT EXISTS`
    SQL 语法在这里很有用，因为它意味着您可以重新运行代码，而不会意外删除和重新创建文章表。
- en: When the database and tables are ready, the application is ready to make queries.
    To fetch all articles, you use the sqlite3 `all` method ![](Images/circ3.jpg).
    To fetch a specific article, use the question mark query syntax with a value ![](Images/circ4.jpg);
    the sqlite3 module will insert the ID into the query. Finally, you can insert
    and delete data by using the `run` method ![](Images/circ5.jpg).
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库和表就绪时，应用程序就绪以进行查询。要获取所有文章，您使用 sqlite3 的 `all` 方法![图片](Images/circ3.jpg)。要获取特定文章，使用带值的问号查询语法![图片](Images/circ4.jpg)；sqlite3
    模块将 ID 插入查询中。最后，您可以使用 `run` 方法插入和删除数据![图片](Images/circ5.jpg)。
- en: For this example to work, you need to have installed the sqlite3 module with
    `npm install --save sqlite3`. It’s version 3.1.8 at the time of writing.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此示例正常工作，您需要使用 `npm install --save sqlite3` 安装 sqlite3 模块。在编写时，它的版本是 3.1.8。
- en: Now that the basic database functionality is ready, you need to add it to the
    HTTP routes from [listing 3.2](#ch03ex02).
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基本数据库功能已经就绪，您需要将其添加到来自[列表 3.2](#ch03ex02)的 HTTP 路由中。
- en: The next listing shows how to add each method except for POST. (You’ll deal
    with that separately, because it needs to use the readability module, which you
    haven’t yet set up.)
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 下一列表展示了如何添加除 POST 之外的所有方法。（您将单独处理 POST，因为它需要使用您尚未设置的易读性模块。）
- en: Listing 3.4\. Adding the `Article` model to the HTTP routes
  id: totrans-620
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.4\. 将 `Article` 模型添加到 HTTP 路由
- en: '![](Images/ch03ex04-0.jpg)'
  id: totrans-621
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch03ex04-0.jpg)'
- en: '![](Images/ch03ex04-1.jpg)'
  id: totrans-622
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch03ex04-1.jpg)'
- en: '[Listing 3.4](#ch03ex04) is written assuming that you’ve saved [listing 3.3](#ch03ex03)
    as db.js in the same directory. Node will load that module ![](Images/circ1.jpg)
    and then use it to fetch each article ![](Images/circ2.jpg), find a specific article
    ![](Images/circ3.jpg), and delete an article ![](Images/circ4.jpg).'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3.4](#ch03ex04) 假设您已将 [列表 3.3](#ch03ex03) 保存为 db.js 文件在同一目录下。Node 将加载该模块![图片](Images/circ1.jpg)，然后使用它来获取每篇文章![图片](Images/circ2.jpg)，查找特定文章![图片](Images/circ3.jpg)，以及删除文章![图片](Images/circ4.jpg)。'
- en: The final thing to do is add support for creating articles. To do this, you
    need to be able to download articles and process them with the magic readability
    algorithm. What you need is a module from npm.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是添加创建文章的支持。为此，您需要能够下载文章并使用神奇的易读性算法处理它们。您需要的是 npm 中的一个模块。
- en: 3.3.2\. Making articles readable and saving them for later
  id: totrans-625
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.3.2\. 使文章可读并保存以备后用
- en: Now that you’ve built a RESTful API and data can be persisted to a database,
    you should add code that converts web pages into simplified “reader view” versions.
    You won’t implement this yourself; instead, you can use a module from npm.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经构建了一个 RESTful API，并且数据可以持久化到数据库中，您应该添加将网页转换为简化的“阅读视图”版本的代码。您不需要自己实现这一功能；相反，您可以使用
    npm 中的一个模块。
- en: 'If you search npm for *readability*, you’ll find quite a few modules. Let’s
    try using node-readability (which is at version 1.0.1 at the time of this writing).
    Install it with `npm install node-readability --save`. The module provides an
    asynchronous function that downloads a URL and turns the HTML into a simplified
    representation. The following snippet shows how node-readability is used; if you
    want to try it, add the snippet to index.js in addition to [listing 3.5](#ch03ex05):'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 npm 中搜索 *readability*，您会发现相当多的模块。让我们尝试使用 node-readability（在撰写本文时版本为 1.0.1）。使用
    `npm install node-readability --save` 安装它。该模块提供了一个异步函数，它下载一个 URL 并将 HTML 转换为简化表示。以下代码片段显示了如何使用
    node-readability；如果您想尝试它，请将代码片段添加到 index.js 中，除了 [列表 3.5](#ch03ex05)：
- en: '[PRE72]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The node-readability module can be used with your database class to save articles
    with the `Article.create` method:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 node-readability 模块与您的数据库类一起使用，通过 `Article.create` 方法保存文章：
- en: '[PRE73]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: To use this in the application, open the index.js file and add a new `app.post`
    route handler that downloads and saves articles. Combining this with everything
    you learned about HTTP POST in Express and the body parser gives the example in
    the following listing.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用程序中使用此功能，打开 index.js 文件并添加一个新的 `app.post` 路由处理程序，用于下载和保存文章。结合您在 Express
    中学到的关于 HTTP POST 和 body parser 的所有知识，以下列表提供了示例。
- en: Listing 3.5\. Generating readable articles and saving them
  id: totrans-632
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.5\. 生成可读文章并保存
- en: '![](Images/03lis05_alt.jpg)'
  id: totrans-633
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03lis05_alt.jpg)'
- en: Here you first get the URL from the POST body ![](Images/circ1.jpg) and then
    use the node-readability module to get the URL ![](Images/circ2.jpg). You save
    the article by using your `Article` model class. If an error occurs, you pass
    handling along the Express middleware stack ![](Images/circ3.jpg); otherwise,
    a JSON representation of the article is sent back to the client.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您首先从 POST 主体中获取 URL ![Images/circ1.jpg]，然后使用 node-readability 模块获取 URL ![Images/circ2.jpg]。您通过使用您的
    `Article` 模型类来保存文章。如果发生错误，您将错误处理传递给 Express 中间件堆栈 ![Images/circ3.jpg]；否则，将文章的
    JSON 表示发送回客户端。
- en: 'You can make a POST request that will work with this example by using the `--data`
    option:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 `--data` 选项来发送一个 POST 请求，使其与这个示例一起工作：
- en: '[PRE74]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Over the course of the preceding section, you added a database module, created
    a JavaScript API that wraps around it, and tied it in to the RESTful HTTP API.
    That’s a lot of work, and it will form the bulk of your efforts as a server-side
    developer. You’ll learn more about databases later in this book as you look at
    MongoDB and Redis.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，您添加了一个数据库模块，创建了一个围绕它的 JavaScript API，并将其绑定到 RESTful HTTP API。这是一项大量工作，它将成为您作为后端开发人员努力的主要部分。随着您在本书中查看
    MongoDB 和 Redis，您将在本书的后面部分了解更多关于数据库的内容。
- en: Now that you can save articles and programmatically fetch them, you’ll add a
    web interface so you can read articles as well.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您不仅可以保存文章，还可以以编程方式检索它们，因此您将添加一个网络界面，以便您可以阅读文章。
- en: 3.4\. Adding a user interface
  id: totrans-639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4\. 添加用户界面
- en: Adding an interface to an Express project involves several things. The first
    is the use of a template engine; we’ll show you how to install one and render
    templates shortly. Your application should also serve static files, such as CSS.
    Before rendering templates and writing any CSS, you need to know how to make the
    router handlers from the previous examples respond with both JSON and HTML when
    necessary.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Express 项目中添加界面涉及几个方面。首先是使用模板引擎；我们将很快向您展示如何安装一个并渲染模板。您的应用程序还应提供静态文件，例如 CSS。在渲染模板和编写任何
    CSS 之前，您需要知道如何使之前示例中的路由处理程序在必要时同时响应 JSON 和 HTML。
- en: 3.4.1\. Supporting multiple formats
  id: totrans-641
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.1\. 支持多种格式
- en: So far you’ve used `res.send()` to send JavaScript objects back to the client.
    You used cURL to make requests, and in this case JSON is convenient because it’s
    easy to read in the console. But to really use the application, it needs to support
    HTML as well. How can you support both?
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经使用 `res.send()` 来向客户端发送 JavaScript 对象。您使用 cURL 来发送请求，在这种情况下 JSON 很方便，因为它在控制台中易于阅读。但为了真正使用应用程序，它还需要支持
    HTML。您如何支持两者？
- en: 'The basic technique is to use the `res.format` method provided by Express.
    It allows your application to respond with the right format based on the request.
    To use it, provide a list of formats with functions that respond the desired way:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 基本技术是使用 Express 提供的 `res.format` 方法。它允许您的应用程序根据请求响应正确的格式。要使用它，提供一个包含响应所需方式的函数的格式列表：
- en: '[PRE75]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In this snippet, `res.render` will render the articles.ejs template in the views
    folder. But for this to work, you need to install a template engine and create
    some templates.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`res.render` 将会在 views 文件夹中渲染 articles.ejs 模板。但为了使其工作，你需要安装一个模板引擎并创建一些模板。
- en: 3.4.2\. Rendering templates
  id: totrans-646
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.2\. 渲染模板
- en: 'Many template engines are available, and a simple one that’s easy to learn
    is EJS (Embedded JavaScript). Install the EJS module from npm (EJS is at version
    2.3.1 at the time of writing):'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的模板引擎有很多，其中一种简单且易于学习的是 EJS（嵌入式 JavaScript）。从 npm 安装 EJS 模块（在写作时 EJS 版本为 2.3.1）：
- en: '[PRE76]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now `res.render` can render HTML files formatted with EJS. If you replace `res.send
    (articles)` in the `app.get('/articles')` route handler from [listing 3.4](#ch03ex04),
    visiting http://localhost:3000/articles in a browser should attempt to render
    articles.ejs.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `res.render` 可以渲染格式化过的 EJS HTML 文件。如果你将 [列表 3.4](#ch03ex04) 中的 `app.get('/articles')`
    路由处理器的 `res.send (articles)` 替换掉，在浏览器中访问 http://localhost:3000/articles 应该会尝试渲染
    articles.ejs。
- en: Next you need to create the articles.ejs template in a views folder. The next
    listing shows a full template that you can use.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要在 views 文件夹中创建 articles.ejs 模板。下面的列表显示了一个你可以使用的完整模板。
- en: Listing 3.6\. `Article` list template
  id: totrans-651
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.6\. `文章`列表模板
- en: '![](Images/03lis06_alt.jpg)'
  id: totrans-652
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03lis06_alt.jpg)'
- en: The article list template uses a header ![](Images/circ1.jpg) and footer template
    that are included as snippets in the following code examples. This is to avoid
    duplicating the header and footer in every template. The article list is iterated
    over ![](Images/circ2.jpg) by using a standard Java-Script `forEach` loop, and
    then the article IDs and titles are injected into the template by using the EJS
    `<%= value %>` syntax ![](Images/circ3.jpg).
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 文章列表模板使用了一个头部 ![](Images/circ1.jpg) 和页脚模板，这些模板作为代码示例中的片段包含在内。这是为了避免在每个模板中重复头部和页脚。文章列表通过使用标准的
    Java-Script `forEach` 循环进行迭代，然后使用 EJS `<%= value %>` 语法将文章 ID 和标题注入到模板中 ![](Images/circ2.jpg)。
- en: 'Here’s an example header template, saved as views/head.ejs:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例头部模板，保存为 views/head.ejs：
- en: '[PRE77]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'And this is a corresponding footer (saved as views/foot.ejs):'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对应的页脚（保存为 views/foot.ejs）：
- en: '[PRE78]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `res.format` method can be used for displaying specific articles as well.
    This is where things start to get interesting, because for this application to
    make sense, articles should look clean and easy to read.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.format` 方法也可以用来显示特定的文章。从这里开始，事情开始变得有趣，因为为了让这个应用程序有意义，文章应该看起来整洁且易于阅读。'
- en: 3.4.3\. Using npm for client-side dependencies
  id: totrans-659
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.4.3\. 使用 npm 管理客户端依赖
- en: 'With the templates in place, the next step is to add some style. Rather than
    creating a style sheet, it’s easier to reuse existing styles, and you can even
    do this with npm! The popular Bootstrap ([http://getbootstrap.com/](http://getbootstrap.com/))
    client-side framework is available on npm ([www.npmjs.com/package/bootstrap](http://www.npmjs.com/package/bootstrap)),
    so add it to this project:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 模板就绪后，下一步是添加一些样式。与其创建样式表，不如重用现有的样式，你甚至可以使用 npm 来这样做！流行的 Bootstrap ([http://getbootstrap.com/](http://getbootstrap.com/))
    客户端框架可在 npm ([www.npmjs.com/package/bootstrap](http://www.npmjs.com/package/bootstrap))
    上找到，因此将其添加到这个项目中：
- en: '[PRE79]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: If you look at node_modules/bootstrap/, you’ll see the source for the Bootstrap
    project. Then, in the dist/css folder, you’ll find the CSS files that come with
    Bootstrap. To use this in your project, you need to be able to serve static files.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 node_modules/bootstrap/，你会看到 Bootstrap 项目的源代码。然后，在 dist/css 文件夹中，你会找到
    Bootstrap 伴随的 CSS 文件。要在你的项目中使用这些文件，你需要能够提供静态文件服务。
- en: Serving static files
  id: totrans-663
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: When you need to send client-side JavaScript, images, and CSS back to the browser,
    Express has some built-in middleware called `express.static`. To use it, you point
    it at a directory that contains static files, and those files will then be available
    to the browser.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要将客户端 JavaScript、图像和 CSS 发送到浏览器时，Express 有一些内置的中间件称为 `express.static`。要使用它，你需要将其指向包含静态文件的目录，然后这些文件将可供浏览器访问。
- en: 'Near the top of the main Express app file (index.js), there are some lines
    that load the middleware required by the project:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 在主 Express 应用程序文件（index.js）的顶部附近，有一些加载项目所需中间件的代码行：
- en: '[PRE80]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To load Bootstrap’s CSS, use `express.static` to register the file at the right
    URL:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载 Bootstrap 的 CSS，使用 `express.static` 在正确的 URL 上注册文件：
- en: '[PRE81]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now you can add /css/bootstrap.css to your templates to get some cool Bootstrap
    styles. Here’s what views/head.ejs should look like:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在模板中添加 /css/bootstrap.css 以获取一些酷炫的 Bootstrap 样式。以下 views/head.ejs 应该看起来像这样：
- en: '[PRE82]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This is only Bootstrap’s CSS; Bootstrap also comes with other files, including
    icons, fonts, and jQuery plugins. You could add more of these files to your project,
    or use a tool to bundle them all up so loading them is easier.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 Bootstrap 的 CSS；Bootstrap 还附带其他文件，包括图标、字体和 jQuery 插件。您可以将这些文件添加到您的项目中，或者使用工具将它们全部打包起来，以便更容易加载。
- en: Doing more with npm and client-side development
  id: totrans-672
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 npm 和客户端开发做更多的事情
- en: The previous example is a simple use of a library intended for browsers through
    npm. Web developers typically download Bootstrap’s files and then add them to
    their project manually, particularly web designers who work on simpler static
    sites.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子是使用 npm 通过浏览器库的简单示例。Web 开发者通常会下载 Bootstrap 的文件，然后手动将它们添加到他们的项目中，尤其是那些从事简单静态网站设计的网页设计师。
- en: But modern front-end developers use npm for both downloading libraries and loading
    them in client-side JavaScript. With tools such as Browserify ([http://browserify.org/](http://browserify.org/))
    and webpack ([http://webpack.github.io/](http://webpack.github.io/)), you get
    all the power of npm installation and `require` for loading dependencies. Imagine
    being able to type `const React = require('react')` in not just Node code, but
    code for front-end development as well! This is beyond the scope of this chapter,
    but it gives you a hint of the power you can unlock by combining techniques from
    Node programming with front-end development.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 但现代前端开发者使用 npm 下载库并在客户端 JavaScript 中加载它们。借助 Browserify ([http://browserify.org/](http://browserify.org/))
    和 webpack ([http://webpack.github.io/](http://webpack.github.io/)) 等工具，您将获得 npm
    安装和 `require` 加载依赖项的所有功能。想象一下，您不仅可以在 Node 代码中，还可以在前端开发代码中键入 `const React = require('react')`！这超出了本章的范围，但它为您展示了通过结合
    Node 编程和前端开发的技术可以解锁的强大功能。
- en: 3.5\. Summary
  id: totrans-675
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5. 摘要
- en: You can quickly build a Node web application from scratch with `npm init` and
    Express.
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `npm init` 和 Express 快速从头开始构建一个 Node 网络应用程序。
- en: The command to install a dependency is `npm install`.
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装依赖项的命令是 `npm install`。
- en: Express allows you to make web applications with RESTful APIs.
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express 允许您使用 RESTful API 创建网络应用程序。
- en: Selecting the right database and database module requires some up-front investigation
    and depends on your requirements.
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择合适的数据库和数据库模块需要一些前期调查，并取决于您的需求。
- en: SQLite is handy for small projects.
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 对于小型项目来说很方便。
- en: EJS is an easy way to render templates in Express.
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EJS 是在 Express 中渲染模板的一种简单方法。
- en: Express supports lots of template engines, including Pug and Mustache.
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express 支持许多模板引擎，包括 Pug 和 Mustache。
