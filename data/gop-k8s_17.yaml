- en: appendix B. Setting up GitOps tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 B. 设置 GitOps 工具
- en: This appendix will go over step-by-step instructions to set up the tools required
    for the tutorials in part 3.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录将逐步说明设置第 3 部分教程所需工具的步骤。
- en: B.1 Installing Argo CD
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.1 安装 Argo CD
- en: 'Argo CD supports several installation methods. You might use the official Kustomize-based
    installation, the community-maintained Helm chart,^([1](#pgfId-1104541)) or even
    the Argo CD operator^([2](#pgfId-1104545)) to manage your Argo CD deployments.
    The simplest possible installation method requires using only a single YAML file.
    Go ahead and use the following commands to install Argo CD into your minikube
    cluster:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD 支持多种安装方法。您可能使用基于 Kustomize 的官方安装、社区维护的 Helm 图表^([1](#pgfId-1104541))，甚至
    Argo CD 操作员^([2](#pgfId-1104545)) 来管理您的 Argo CD 部署。最简单的安装方法只需要使用单个 YAML 文件。请继续使用以下命令将
    Argo CD 安装到您的 minikube 集群中：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command installs all Argo CD components with the default settings that
    work for most users out of the box. For security reasons, the Argo CD UI and API
    are not exposed outside of the cluster by default. It is totally safe to open
    full access on minikube.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令使用适用于大多数用户的默认设置安装所有 Argo CD 组件。出于安全原因，Argo CD UI 和 API 默认情况下不会在集群外部暴露。在 minikube
    上完全打开访问权限是绝对安全的。
- en: 'Enable load balancer access^([3](#pgfId-1104551)) in your minikube cluster
    by running the following command in a separate terminal:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在单独的终端中运行以下命令，在您的 minikube 集群中启用负载均衡器访问^([3](#pgfId-1104551))：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use the following command to open access to the `argocd-server` service and
    get the access URL:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令打开对 `argocd-server` 服务的访问并获取访问 URL：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Argo CD provides both a web-based user interface and a command-line interface
    (CLI). To simplify the instructions, we are going to use the CLI tool in this
    tutorial. Let’s go ahead and install the CLI tool. You might use the following
    command to install Argo CD CLI on Mac or follow the official getting-started instructions^([4](#pgfId-1104564))
    to install the CLI on your platform:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD 提供了基于 Web 的用户界面和命令行界面 (CLI)。为了简化说明，我们将在此教程中使用 CLI 工具。让我们继续安装 CLI 工具。您可以使用以下命令在
    Mac 上安装 Argo CD CLI，或者遵循官方的入门指南^([4](#pgfId-1104564)) 在您的平台上安装 CLI：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As soon as Argo CD is installed, it has a preconfigured admin user. The initial
    admin password is autogenerated to be the Pod name of the Argo CD API server that
    can be retrieved using this command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Argo CD，它就有一个预配置的管理员用户。初始管理员密码是自动生成的，是 Argo CD API 服务器 Pod 名称，可以使用此命令检索：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Use the following command to get the Argo CD server URL and update the generated
    password using the Argo CD CLI:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令获取 Argo CD 服务器 URL 并使用 Argo CD CLI 更新生成的密码：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The <ARGOCD_SERVER-HOSTNAME>:<PORT> is a minikube API and service port that
    should be obtained from the Argo CD URL. The URL might be retrieved using the
    following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ARGOCD_SERVER-HOSTNAME>:<PORT>` 是 minikube API 和服务端口，应从 Argo CD URL 获取。您可以使用以下命令检索
    URL：'
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The command returns the HTTP service URL. Make sure to remove http:// and use
    only the hostname and the port to log in using the Argo CD CLI.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 命令返回 HTTP 服务 URL。请确保删除 http://，并仅使用主机名和端口号使用 Argo CD CLI 登录。
- en: Finally, log in to the Argo CD user interface. Please open the Argo CD URL in
    the browser and log in using the admin username and your password. You are ready
    to go!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，登录到 Argo CD 用户界面。请在浏览器中打开 Argo CD URL，并使用管理员用户名和您的密码登录。您现在可以开始了！
- en: B.2 Installing Jenkins X
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.2 安装 Jenkins X
- en: The Jenkins X CLI depends on [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
    ^([5](#pgfId-1104586)) and Helm^([6](#pgfId-1104592)) and will do its best to
    install those tools. However, the number of possible permutations of what we have
    on our laptops is close to infinite, so you’re better off installing those tools
    yourself.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins X CLI 依赖于 [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
    ^([5](#pgfId-1104586)) 和 Helm^([6](#pgfId-1104592))，并将尽力安装这些工具。然而，我们笔记本电脑上可能存在的所有可能排列组合接近无限，因此您最好自己安装这些工具。
- en: Note At the time of this writing, February 2021, Jenkins X does not yet support
    Helm v3+. Make sure that you’re using Helm CLI v2+.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在撰写本文时，2021 年 2 月，Jenkins X 还不支持 Helm v3+。请确保您正在使用 Helm CLI v2+。
- en: B.2.1 Prerequisites
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.2.1 前提条件
- en: You can use (almost) any Kubernetes cluster, but it needs to be publicly accessible.
    The main reason for that lies in GitHub triggers. Jenkins X relies heavily on
    GitOps principles. Most of the events will be triggered by GitHub webhooks. If
    your cluster cannot be accessed from GitHub, you won’t be able to trigger those
    events, and you will have difficulty following the examples.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用（几乎）任何Kubernetes集群，但它需要是公开可访问的。这样做的主要原因在于GitHub触发器。Jenkins X严重依赖于GitOps原则。大部分事件将由GitHub
    webhook触发。如果您的集群无法从GitHub访问，您将无法触发这些事件，并且您将难以跟随示例进行操作。
- en: Now, that poses two significant issues. You might prefer to practice locally
    using minikube or Docker for Desktop, but neither of the two is accessible from
    outside your laptop. You might have a corporate cluster that is inaccessible from
    the outside world. In those cases, we suggest you use a service from AWS, GCP,
    or somewhere else. Finally, we’ll perform some GitHub operations using the command
    `hub`. Install it if you don’t have it already.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这提出了两个重大问题。您可能更喜欢在本地使用minikube或Docker for Desktop进行练习，但这两个工具都无法从您的笔记本电脑外部访问。您可能有一个无法从外部访问的企业集群。在这些情况下，我们建议您使用AWS、GCP或其他地方的服务。最后，我们将使用命令`hub`执行一些GitHub操作。如果您还没有安装，请安装它。
- en: Note Please refer to appendix A for more information on configuring AWS or a
    GCP Kubernetes cluster.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意请参考附录A以获取有关配置AWS或GCP Kubernetes集群的更多信息。
- en: 'For your convenience, the list of all the tools we’ll use is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了您的方便，我们将使用的所有工具列表如下：
- en: Git
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: kubectl
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubectl
- en: Helm^([7](#pgfId-1104612))
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm^([7](#pgfId-1104612))
- en: AWS CLI
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CLI
- en: '`eksctl`^([8](#pgfId-1104618)) (if using AWS EKS)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eksctl`^([8](#pgfId-1104618))（如果使用AWS EKS）'
- en: '`gcloud` (if using Google GKE)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcloud`（如果使用Google GKE）'
- en: '`hub`^([9](#pgfId-1104624))'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hub`^([9](#pgfId-1104624))'
- en: 'Now let’s install the Jenkins X CLI:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们安装Jenkins X CLI：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: B.2.2 Installing Jenkins X in a Kubernetes cluster
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.2.2 在Kubernetes集群中安装Jenkins X
- en: How can we install Jenkins X in a better way than how we’re used to installing
    software? Jenkins X configuration should be defined as code and reside in a Git
    repository, and that’s what the community created for us. It maintains a GitHub
    repository that contains the structure of the definition of the Jenkins X platform,
    together with a pipeline that will install it, as well as a requirements file
    that we can use to tweak it to our specific needs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何以比我们通常安装软件更好的方式安装Jenkins X？Jenkins X的配置应该被定义为代码并存储在Git仓库中，这正是社区为我们创建的。它维护一个GitHub仓库，其中包含Jenkins
    X平台定义的结构，以及一个将安装它的管道，以及一个我们可以用它来调整以满足特定需求的requirements文件。
- en: Note You can also refer to the Jenkins X site^([10](#pgfId-1104637)) for setting
    up Jenkins X in your Kubernetes cluster.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意您还可以参考Jenkins X网站^([10](#pgfId-1104637))来了解如何在您的Kubernetes集群中设置Jenkins X。
- en: 'Let’s take a look at the repository:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个仓库：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once you see the repo in your browser, you will first create a fork under your
    GitHub account. We’ll explore the files in the repo a bit later.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在浏览器中看到仓库，您首先需要在您的GitHub账户下创建一个分支。我们稍后会探索仓库中的文件。
- en: 'Next, we’ll define a variable `CLUSTER_NAME` that will, as you can guess, hold
    the name of the cluster we created a short while ago. In the commands that follow,
    please replace the first occurrence of [...] with the name of the cluster and
    the second with your GitHub user:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义一个变量`CLUSTER_NAME`，它将，正如您所猜到的，保存我们刚刚创建的集群的名称。在随后的命令中，请将[...]的第一个出现替换为集群名称，第二个替换为您的GitHub用户：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After we fork the boot repo and we know how our cluster is called, we can clone
    the repository with a proper name that will reflect the naming scheme of our soon-to-be-installed
    Jenkins X:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们分支boot仓库并且知道我们的集群名称后，我们可以使用一个合适的名称克隆仓库，该名称将反映我们即将安装的Jenkins X的命名方案：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The key file that contains (almost) all the parameters that can be used to
    customize the setup is jx-requirements.yml. Let’s take a look at it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 包含（几乎）所有可用于自定义设置的参数的关键文件是jx-requirements.yml。让我们看看它：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, that file contains values in a format that resembles the requirements.yaml
    file used with Helm charts. It is split into a few sections.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，该文件包含的值格式类似于与Helm图表一起使用的requirements.yaml文件。它被分为几个部分。
- en: First, there is a group of values that define our cluster. You should be able
    to figure out what it represents by looking at the variables inside it. It probably
    won’t take you more than a few moments to see that we have to change at least
    some of those values, so that’s what we’ll do next.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一组值定义了我们的集群。您应该能够通过查看其中的变量来了解它代表什么。您可能不会花费超过几分钟的时间就能看出，我们至少需要更改其中的一些值，所以这就是我们接下来要做的。
- en: 'Open jx-requirements.yml in your favorite editor and change the following values:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在您最喜欢的编辑器中打开 jx-requirements.yml 并更改以下值：
- en: Set `cluster.clusterName` to the name of your cluster. It should be the same
    as the name of the environment variable `CLUSTER_NAME`. If you already forgot
    it, execute `echo $CLUSTER_NAME`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `cluster.clusterName` 设置为您的集群名称。它应该与环境变量 `CLUSTER_NAME` 的名称相同。如果您已经忘记了，请执行
    `echo $CLUSTER_NAME`。
- en: Set `cluster.environmentGitOwner` to your GitHub user. It should be the same
    as the one we previously declared as the environment variable `$GH_USER`.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `cluster.environmentGitOwner` 设置为您的 GitHub 用户。它应该与之前声明的环境变量 `$GH_USER` 相同。
- en: Set `cluster.project` to the name of your GKE project, only if that’s where
    your Kubernetes cluster is running. Otherwise, leave that value intact (empty).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅当您的 Kubernetes 集群运行在 GKE 上时，将 `cluster.project` 设置为您的 GKE 项目名称。否则，保持该值不变（为空）。
- en: Set `cluster.provider` to `gke` or to `eks` or to any other provider if you
    decided that you are brave and want to try currently unsupported platforms. Or
    things may have changed since the writing of this chapter, and your provider is
    indeed supported now.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `cluster.provider` 设置为 `gke` 或 `eks` 或任何其他提供者，如果您决定您很勇敢并想尝试目前不受支持的平台。或者，自本章编写以来，事情可能已经改变，并且您的提供者现在确实受到支持。
- en: Set `cluster.zone` to whichever zone your cluster is running in. If you’re running
    a regional cluster (as you should), then the value should be the region, not the
    zone. If, for example, you used our Gist to create a GKE cluster, the value should
    be `us-east1-b`. Similarly, the one for EKS is `us-east-1`.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `cluster.zone` 设置为您的集群正在运行的区域。如果您正在运行区域集群（您应该这样做），则值应该是区域，而不是区域。例如，如果您使用我们的
    Gist 创建了 GKE 集群，则值应该是 `us-east1-b`。类似地，EKS 的值是 `us-east-1`。
- en: We’re finished with the `cluster` section, and the next in line is the `gitops`
    value. It instructs the system how to treat the boot process. It doesn’t make
    sense to change it to false, so we’ll leave it as is (true).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了 `cluster` 部分，下一个是 `gitops` 值。它指导系统如何处理引导过程。将其更改为 `false` 没有意义，所以我们将保持它不变（true）。
- en: The next section contains the list of the environments that we’re already familiar
    with. The keys are the suffixes, and the final names will be a combination of
    `environment-` with the name of the cluster followed by the key. We’ll leave them
    intact.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分包含我们已经熟悉的环境的列表。键是后缀，最终名称将是 `environment-` 与集群名称的组合，后面跟着键。我们将保持它们不变。
- en: The `ingress` section defines the parameters related to external access to the
    cluster (domain, TLS, and so on).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`ingress` 部分定义了与集群外部访问相关的参数（域名、TLS 等）。'
- en: The `kaniko` value should be self-explanatory. When set to `true`, the system
    will build container images using `kaniko` instead of, let’s say, Docker. That
    is a much better choice since Docker cannot run in a container and, as such, poses
    a significant security risk (mounted sockets are evil), and it messes with the
    Kubernetes scheduler given that it bypasses its API. In any case, `kaniko` is
    the only supported way to build container images when using Tekton, so we’ll leave
    it as is (true).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`kaniko` 值应该是显而易见的。当设置为 `true` 时，系统将使用 `kaniko` 而不是，比如说，Docker 来构建容器镜像。这是一个更好的选择，因为
    Docker 不能在容器中运行，因此具有重大的安全风险（挂载套接字是邪恶的），并且它破坏了 Kubernetes 调度程序，因为它绕过了其 API。无论如何，`kaniko`
    是使用 Tekton 构建容器镜像时唯一受支持的方式，所以我们将保持它不变（true）。'
- en: Next, we have `secretStorage` currently set to `local`. The whole platform will
    be defined in this repository, except for Secrets (such as passwords). Pushing
    them to Git would be childish, so Jenkins X can store the Secrets in different
    locations. If you changed it to `local`, that location is your laptop. While that
    is better than a Git repository, you can probably imagine why that is not the
    right solution. Keeping Secrets locally complicates cooperation (they exist only
    on your laptop), is volatile, and is only slightly more secure than Git. A much
    better place for Secrets is HashiCorp Vault. It is the most commonly used solution
    for Secret management in Kubernetes (and beyond), and Jenkins X supports it out
    of the box. If you have a vault setup, you can set the value of `secretStorage`
    to `vault`. Otherwise, you can leave the default value `local`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`secretStorage`当前设置为`local`。整个平台将在该仓库中定义，除了机密信息（如密码）。将它们推送到Git将是幼稚的，因此Jenkins
    X可以在不同的位置存储机密信息。如果你将其更改为`local`，那么该位置就是你的笔记本电脑。虽然这比Git仓库要好，但你可能可以想象为什么这不是正确的解决方案。将机密信息本地化会复杂化合作（它们只存在于你的笔记本电脑上），是易变的，并且仅比Git稍微安全一些。机密信息的一个更好的地方是HashiCorp
    Vault。它是Kubernetes（及其之外）中最常用的机密管理解决方案，Jenkins X默认支持它。如果你已经设置了Vault，可以将`secretStorage`的值设置为`vault`。否则，你可以保留默认值`local`。
- en: Below the `secretStorage` value is the whole section that defines storage for
    logs, reports, and repositories. If enabled, those artifacts will be stored on
    a network drive. As you already know, containers and nodes are short lived, and
    if we want to preserve any of those, we need to store them elsewhere. That does
    not necessarily mean that network drives are the best place, but rather that’s
    what comes out of the box. Later on, you might choose to change that and, let’s
    say, ship logs to a central database like Elasticsearch, Papertrail, Cloudwatch,
    Stackdriver, and so on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`secretStorage`值下方是整个部分，它定义了日志、报告和仓库的存储。如果启用，这些工件将存储在网络驱动器上。正如你所知道的那样，容器和节点是短暂的，如果我们想要保留任何这些，我们需要将它们存储在其他地方。这并不一定意味着网络驱动器是最好的地方，但这是默认的设置。稍后，你可能选择更改这一点，比如将日志发送到中央数据库，如Elasticsearch、Papertrail、Cloudwatch、Stackdriver等。
- en: 'For now, we’ll keep it simple and enable network storage for all three types
    of artifacts:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将保持简单，并为所有三种类型的工件启用网络存储：
- en: Set the value of `storage.logs.enabled` to `true`.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`storage.logs.enabled`的值设置为`true`。
- en: Set the value of `storage.reports.enabled` to `true`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`storage.reports.enabled`的值设置为`true`。
- en: Set the value of `storage.repository.enabled` to `true`.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`storage.repository.enabled`的值设置为`true`。
- en: The `versionStream` section defines the repository that contains versions of
    all the packages (charts) used by Jenkins X. You might choose to fork that repository
    and control versions yourself. Before you jump into doing just that, please note
    that Jenkins X versioning is quite complex, given that many packages are involved.
    Leave it be unless you have a very good reason to take over control of the Jenkins
    X versioning and you’re ready to maintain it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`versionStream`部分定义了包含Jenkins X所使用的所有包（图表）版本的仓库。你可能选择分叉该仓库并自行控制版本。在你跳入这样做之前，请注意Jenkins
    X的版本控制相当复杂，因为涉及许多包。除非你有很好的理由接管Jenkins X的版本控制并且准备好维护它，否则请保持现状。'
- en: As you already know, Prow only supports GitHub. If that’s not your Git provider,
    Prow is a no-go. As an alternative, you could set it up in Jenkins, but that’s
    not the right solution either. Jenkins (without X) is not going to be supported
    for long, given that the future is in Tekton. It was used in the first generation
    of Jenkins X only because it was a good starting point and because it supports
    almost anything we can imagine. But the community has embraced Tekton as the only
    pipeline engine, and that means that static Jenkins is fading away and that it
    is used mostly as a transition solution for those accustomed to the “traditional”
    Jenkins.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知道的那样，Prow仅支持GitHub。如果你的Git提供商不是GitHub，那么Prow就不适用。作为一个替代方案，你可以在Jenkins中设置它，但这也不是正确的解决方案。鉴于未来在Tekton，Jenkins（没有X）将不会得到长期支持。它仅在第一代Jenkins
    X中被使用，因为它是一个好的起点，并且几乎支持我们所能想象的一切。但社区已经接受Tekton作为唯一的管道引擎，这意味着静态Jenkins正在逐渐消失，并且它主要被用作那些习惯于“传统”Jenkins的人的过渡解决方案。
- en: So, what can you do if Prow is not a choice if you do not use GitHub, and Jenkins’
    days are numbered? To make things more complicated, even Prow will be deprecated
    sometime in the future (or past, depending when you read this). It will be replaced
    with Lighthouse, which, at least at the beginning, will provide similar functionality
    as Prow. Its primary advantage when compared with Prow is that Lighthouse will
    (or already does) support all major Git providers (such as GitHub, GitHub Enterprise,
    Bitbucket Server, Bitbucket Cloud, GitLab, and so on). At some moment, the default
    value of `webhook` will be `lighthouse`. But, at the time of this writing (February
    2021), that’s not the case since Lighthouse is not yet stable and production ready.
    It will be soon. In any case, we’ll keep Prow as our webhook (for now).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你不使用GitHub，Prow又不是一个选择，而Jenkins的日子又屈指可数，你该怎么办？更复杂的是，Prow也将在未来的某个时刻（或者过去，取决于你阅读这篇文章的时间）被弃用。它将被Lighthouse取代，至少在开始时，它将提供与Prow相似的功能。与Prow相比，它的主要优势是Lighthouse将（或已经）支持所有主要的Git提供商（例如GitHub、GitHub
    Enterprise、Bitbucket Server、Bitbucket Cloud、GitLab等等）。在某个时刻，`webhook`的默认值将是`lighthouse`。但是，在撰写本文时（2021年2月），情况并非如此，因为Lighthouse尚未稳定且尚未准备好投入生产。它很快就会准备好。无论如何，我们目前将继续使用Prow作为我们的webhook。
- en: 'Only execute the following commands if you are using EKS. They will add additional
    information related to Vault, namely, the IAM user that has sufficient permissions
    to interact with it. Make sure to replace `[...]` with your IAM user that has
    sufficient permissions (being admin always works):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在使用EKS时才执行以下命令。它们将添加与Vault相关的附加信息，即具有足够权限与之交互的IAM用户。确保用你的具有足够权限的IAM用户（总是作为管理员）替换`[...]`：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Only execute the following commands if you are using EKS. The jx-requirements.yaml
    file contains a zone entry, and for AWS we need a region. This command will replace
    one with the other:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在使用EKS时才执行以下命令。jx-requirements.yaml文件包含一个区域条目，对于AWS，我们需要一个区域。此命令将替换一个为另一个：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s take a peek at how jx-requirements.yml looks now:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现在的jx-requirements.yml文件看起来如何：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, you might be worried that we missed some of the values. For example, we
    did not specify a domain. Does that mean that our cluster will not be accessible
    from outside? We also did not specify the URL for storage. Will Jenkins X ignore
    it in that case?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能担心我们遗漏了一些值。例如，我们没有指定域名。这意味着我们的集群将无法从外部访问吗？我们也没有指定存储的URL。在这种情况下，Jenkins
    X会忽略它吗？
- en: The truth is that we specified only the things we know. For example, if you
    created a cluster using our Gist, there is no Ingress, so there is no external
    load balancer that it was supposed to create. As a result, we do not yet know
    the IP through which we can access the cluster, and we cannot generate a .nip.io
    domain. Similarly, we did not create storage. If we did, we could have entered
    addresses into URL fields.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是，我们只指定了我们知道的事情。例如，如果你使用我们的Gist创建了集群，那么就没有Ingress，因此也就没有它本应创建的外部负载均衡器。结果，我们还不知道可以通过哪个IP地址访问集群，也无法生成.nip.io域名。同样，我们也没有创建存储。如果我们创建了，我们就可以在URL字段中输入地址。
- en: Those are only a few examples of the unknowns. We specified what we know, and
    we’ll let Jenkins X `boot` figure out the unknowns. Or, to be more precise, we’ll
    let `boot` create the resources that are missing and thus convert the unknowns
    into knowns.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是未知因素的一小部分。我们指定了我们知道的内容，我们将让Jenkins X的`boot`来找出未知因素。或者，更准确地说，我们将让`boot`创建缺少的资源，从而将未知因素转化为已知因素。
- en: 'Let’s install Jenkins X:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装Jenkins X：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now we need to answer quite a few questions. In the past, we tried to avoid
    answering questions by specifying all answers as arguments to commands we were
    executing. That way, we had a documented method for doing things that do not end
    up in a Git repository. Someone else could reproduce what we did by running the
    same commands. This time, however, there is no need to avoid questions since everything
    we’ll do will be stored in a Git repository.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要回答很多问题。过去，我们试图通过指定所有答案作为我们执行的命令的参数来避免回答问题。这样，我们就有了记录在案的方法来做事情，而这些事情最终并没有进入Git仓库。其他人可以通过运行相同的命令来重现我们所做的一切。然而，这一次，我们不需要避免提问，因为我们将要做的所有事情都将存储在Git仓库中。
- en: The first input is asking for a comma-separated list of Git provider usernames
    of approvers for the Development environment repository. That will create the
    list of users who can approve pull requests to the Development repository managed
    by Jenkins X `boot`. For now, type your GitHub user and hit the Enter key.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个输入要求输入逗号分隔的Git提供者用户名列表，这些用户名是开发环境存储库的审批者。这将创建一个用户列表，这些用户可以批准由Jenkins X `boot`管理的开发存储库的拉取请求。现在，输入你的GitHub用户名并按Enter键。
- en: We can see that, after a while, we are presented with two warnings stating that
    TLS is not enabled for Vault and webhooks. If we specified a “real” domain, `boot`
    would install Let’s Encrypt and generate certificates. But, since we couldn’t
    be sure that you have a domain at hand, we did not specify it, and, as a result,
    we will not get certificates. While that would be unacceptable in production,
    it is quite OK as an exercise.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，过了一会儿，我们收到了两条警告，指出Vault和webhooks没有启用TLS。如果我们指定了一个“真实”的域名，`boot`将安装Let’s
    Encrypt并生成证书。但由于我们无法确定你手头是否有域名，我们没有指定它，因此我们不会得到证书。虽然这在生产环境中是不可接受的，但作为一个练习来说，这完全没问题。
- en: As a result of those warnings, `boot` is asking us whether we wish to continue.
    Type `y` and press the Enter key to continue.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于那些警告，`boot`正在询问我们是否希望继续。输入`y`并按Enter键继续。
- en: 'Given that Jenkins X creates multiple releases a day, the chances are that
    you do not have the latest version of `jx`. If that’s the case, `boot` will ask
    if you would like to upgrade to the `jx` version. Press the Enter key to use the
    default answer, `Y`. As a result, `boot` will upgrade the CLI, but that will abort
    the pipeline. That’s OK. No harm done. All we have to do is repeat the process
    but, this time, with the latest version of `jx`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Jenkins X每天都会创建多个版本，所以你很可能没有`jx`的最新版本。如果是这种情况，`boot`会询问你是否想要升级到`jx`版本。按Enter键使用默认答案`Y`。结果，`boot`将升级CLI，但会终止管道。这没关系。没有造成损害。我们只需要重复这个过程，但这次使用`jx`的最新版本：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The process starts again. We’ll skip commenting on the first few questions from
    `jx boot` and continue without TLS. The answers are the same as before (`y` in
    both cases).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 流程再次开始。我们将跳过对`jx boot`前几个问题的注释，并继续不使用TLS。答案与之前相同（两种情况下都是`y`）。
- en: The next set of questions is related to long-term storage for logs, reports,
    and repositories. Press the Enter key for all three questions, and `boot` will
    create buckets with autogenerated unique names.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的一组问题与日志、报告和存储库的长期存储有关。对于所有三个问题都按Enter键，`boot`将创建具有自动生成的唯一名称的存储桶。
- en: From now on, the process will create the Secrets and install CRDs (CustomResourceDefinitions)
    that provide custom resources specific to Jenkins X. Then, it’ll install the NGINX
    Ingress Controller (unless your cluster already has one) and set the domain to
    .nip.io since we did not specify one. Further on, it will install `cert-manager`,
    which will provide Let’s Encrypt certificates. Or, to be more precise, it will
    provide the certificates if we specified a domain. Nevertheless, it’s installed
    just in case we change our minds and choose to update the platform by changing
    the domain and enabling TLS later on.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，这个过程将创建机密并安装CRDs（CustomResourceDefinitions），这些CRDs提供特定于Jenkins X的自定义资源。然后，它将安装NGINX
    Ingress Controller（除非你的集群已经有一个），并将域名设置为.nip.io，因为我们没有指定一个。进一步来说，它将安装`cert-manager`，这将提供Let’s
    Encrypt证书。或者，更准确地说，如果指定了域名，它将提供证书。无论如何，它已经安装好了，以防我们改变主意，选择通过更改域名和稍后启用TLS来更新平台。
- en: The next in line is Vault. `boot` will install it and attempt to populate it
    with Secrets. But, since it does not know them just yet, the process will ask
    us another round of questions. The first one in this group is the admin username.
    Feel free to press the Enter key to accept the default value, admin. After that
    comes the admin password. Type whatever you’d like to use (we won’t need it today).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是Vault。`boot`将安装它并尝试用机密填充它。但由于它还不知道它们，这个过程将再次询问我们。这一组中的第一个问题是管理员用户名。请随意按Enter键接受默认值admin。之后是管理员密码。输入你想要使用的任何密码（我们今天不需要它）。
- en: The process will need to know how to access our GitHub repositories, so it asks
    us for the Git username, email address, and token. You can use your GitHub username
    and email for the first two questions. As for the token,^([11](#pgfId-1104793))
    you’ll need to create a new one in GitHub and grant full repo access. Finally,
    the next question related to Secrets is HMAC token. Feel free to press the Enter
    key, and the process will create it for you.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程需要知道如何访问我们的 GitHub 仓库，因此它会询问我们的 Git 用户名、电子邮件地址和令牌。您可以使用您的 GitHub 用户名和电子邮件回答前两个问题。至于令牌，^([11](#pgfId-1104793))，您需要在
    GitHub 中创建一个新的，并授予完整的仓库访问权限。最后，与 Secrets 相关的下一个问题是 HMAC 令牌。请随意按 Enter 键，过程将为您创建它。
- en: 'Finally comes the last question. Do you want to configure an external Docker
    registry? Press the Enter key to use the default answer (N), and `boot` will create
    it inside the cluster or, as in case of most cloud providers, use the registry
    provided as a service. In the case of GKE, that would be GCR; for EKS, that’s
    ECR. In any case, by not configuring an external Docker registry, `boot` will
    use whatever makes the most sense for a given provider:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题。您想配置一个外部的 Docker 仓库吗？按 Enter 键使用默认答案（N），`boot` 将在集群内部创建它，或者在大多数云服务提供商的情况下，使用作为服务提供的仓库。在
    GKE 的情况下，那就是 GCR；对于 EKS，那就是 ECR。在任何情况下，如果不配置外部 Docker 仓库，`boot` 将使用对特定提供商最有意义的选项：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The rest of the process will install and configure all the components of the
    platform. We won’t go into all of them since they are the same as those we used
    before. What matters is that the system will be fully operational a while later.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的过程将安装和配置平台的全部组件。我们不会详细介绍它们，因为它们与我们之前使用的相同。重要的是，系统将在一段时间后完全运行。
- en: The last step will verify the installation. You might see a few warnings during
    this last step of the process. Don’t be alarmed. `boot` is most likely impatient.
    Over time, you’ll see the number of running Pods increasing and those that are
    pending decreasing, until all the Pods are running.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步将验证安装。在过程的最后一步，您可能会看到一些警告。不要惊慌。`boot` 可能有些不耐烦。随着时间的推移，您会看到正在运行的 Pods 数量增加，而挂起的
    Pods 数量减少，直到所有 Pods 都在运行。
- en: 'That’s it. Jenkins X is now up and running. We have the whole definition of
    the platform with complete configuration (except for Secrets) stored in a Git
    repository:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。Jenkins X 现在已经启动并运行。我们已经将平台的完整定义（除了 Secrets）存储在 Git 仓库中：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: B.3 Installing Flux
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.3 安装 Flux
- en: Flux consists of a CLI client and daemon that run inside of the managed Kubernetes
    cluster. This section explains how to install the Flux CLI only. The daemon installation
    requires you to specify the Git repository with access credentials and is covered
    in chapter 11.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 由一个 CLI 客户端和运行在托管 Kubernetes 集群内部的守护进程组成。本节将解释如何安装 Flux CLI。守护进程的安装需要您指定带有访问凭证的
    Git 仓库，这部分内容在第 11 章中介绍。
- en: B.3.1 Installing CLI client
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.3.1 安装 CLI 客户端
- en: The Flux distribution includes the CLI client named `fluxctl`. `fluxctl` automates
    the Flux daemon installation and allows you to get information about Kubernetes
    resources controlled by the Flux daemon.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 分发包括名为 `fluxctl` 的 CLI 客户端。`fluxctl` 自动化 Flux 守护进程的安装，并允许您获取由 Flux 守护进程控制的
    Kubernetes 资源的信息。
- en: Use one of following commands to install the fluxctl in Mac, Linux, and Windows.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令之一在 Mac、Linux 和 Windows 上安装 fluxctl。
- en: 'macOS:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'macOS:'
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Linux:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 'Linux:'
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Windows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'Windows:'
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Find more information about `fluxctl` installation details in the official
    installation instructions: [https://docs.fluxcd.io/en/latest/references/fluxctl/.](https://docs.fluxcd.io/en/latest/references/fluxctl/)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在官方安装说明中查找有关 `fluxctl` 安装细节的更多信息：[https://docs.fluxcd.io/en/latest/references/fluxctl/](https://docs.fluxcd.io/en/latest/references/fluxctl/)
- en: '* * *'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1.[https://github.com/argoproj/argo-helm/tree/master/charts/argo-cd](https://github.com/argoproj/argo-helm/tree/master/charts/argo-cd).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 1.[https://github.com/argoproj/argo-helm/tree/master/charts/argo-cd](https://github.com/argoproj/argo-helm/tree/master/charts/argo-cd).
- en: 2.[https://github.com/argoproj-labs/argocd-operator](https://github.com/argoproj-labs/argocd-operator).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 2.[https://github.com/argoproj-labs/argocd-operator](https://github.com/argoproj-labs/argocd-operator).
- en: 3.[https://minikube.sigs.k8s.io/docs/handbook/accessing/#loadbalancer-access](https://minikube.sigs.k8s.io/docs/handbook/accessing/#loadbalancer-access).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 3.[https://minikube.sigs.k8s.io/docs/handbook/accessing/#loadbalancer-access](https://minikube.sigs.k8s.io/docs/handbook/accessing/#loadbalancer-access).
- en: 4.[https://argoproj.github.io/argo-cd/cli_installation/#download-with-curl](https://argoproj.github.io/argo-cd/cli_installation/#download-with-curl).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 4.[https://argoproj.github.io/argo-cd/cli_installation/#download-with-curl](https://argoproj.github.io/argo-cd/cli_installation/#download-with-curl).
- en: 5.[https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 5.[https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/).
- en: 6.[https://docs.helm.sh/using_helm/#installing-helm](https://docs.helm.sh/using_helm/#installing-helm).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 6.[https://docs.helm.sh/using_helm/#installing-helm](https://docs.helm.sh/using_helm/#installing-helm).
- en: 7.[https://docs.helm.sh/using_helm/#installing-helm](https://docs.helm.sh/using_helm/#installing-helm).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 7.[https://docs.helm.sh/using_helm/#installing-helm](https://docs.helm.sh/using_helm/#installing-helm).
- en: 8.[https://github.com/weaveworks/eksctl](https://github.com/weaveworks/eksctl).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 8.[https://github.com/weaveworks/eksctl](https://github.com/weaveworks/eksctl).
- en: 9.[https://hub.github.com/](https://hub.github.com/).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 9.[https://hub.github.com/](https://hub.github.com/).
- en: 10.[https://jenkins-x.io/docs/](https://jenkins-x.io/docs/).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 10.[https://jenkins-x.io/docs/](https://jenkins-x.io/docs/).
- en: 11.[https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token](https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 11.[https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token](https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token).
