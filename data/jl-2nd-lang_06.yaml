- en: 5 Working with text
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 处理文本
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: Representing text with the String type
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用String类型表示文本
- en: Formatting text with lpad and rpad
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用lpad和rpad格式化文本
- en: Reading text from a keyboard or file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从键盘或文件中读取文本
- en: Writing text to the screen or a file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文本写入屏幕或文件
- en: Creating a simple interactive program
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的交互式程序
- en: This chapter will focus on practical aspects of working with text in Julia,
    such as how to show text on the screen and read or write it to a file. You will
    also look at a simple interactive application where the user writes responses
    to questions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍在Julia中处理文本的实际方面，例如如何在屏幕上显示文本以及如何读取或写入文件。你还将查看一个简单的交互式应用程序，其中用户对问题进行响应。
- en: However, first I will focus on different ways of displaying text on the screen,
    revisiting your pizza sales and sine table examples. The tables you created before
    were not very readable. How about creating a neat display like the one in figure
    5.1?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，首先我将关注在屏幕上显示文本的不同方式，重新审视你的比萨饼销售和正弦表示例。你之前创建的表格不太易读。如何创建一个像图5.1中那样的整洁显示？
- en: '![05-01](../Images/05-01.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![05-01](../Images/05-01.png)'
- en: Figure 5.1 Neatly formatted display of a cosine and sine table
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 使用Unix终端窗口中的对齐和颜色格式化显示余弦和正弦表
- en: Here sine and cosine values are neatly arranged in separate columns. Likewise,
    would it not be better to neatly organize information about pizza sales into clearly
    separated columns, as seen in figure 5.2?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，正弦和余弦值被整洁地排列在单独的列中。同样，将比萨饼销售信息整洁地组织到清晰分隔的列中，如图5.2所示会更好吗？
- en: '![05-02](../Images/05-02.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![05-02](../Images/05-02.png)'
- en: Figure 5.2 Formatted display of pizza sales using alignment and colors in a
    Unix terminal window
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 使用对齐和颜色在Unix终端窗口中格式化显示比萨饼销售情况
- en: You will use the printstyled function for coloring your text and the rpad and
    lpad functions for formatting the output. You will use the ^ operator to repeat
    characters. Next you will use the open function to allow you to use print and
    println for writing text output to files. To read and process input you will use
    the readline, split, and parse functions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用printstyled函数来着色文本，使用rpad和lpad函数来格式化输出。你将使用^运算符来重复字符。接下来，你将使用open函数来允许你使用print和println将文本输出写入文件。为了读取和处理输入，你将使用readline、split和parse函数。
- en: 5.1 Making a pretty pizza sales table
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 制作一个漂亮的比萨饼销售表
- en: You will start by looking at the final result, the code you want to write, and
    then working your way backward to explain how you got there. The code should not
    be entirely alien, but there are some new concepts I will explain.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从查看最终结果，即你想要编写的代码开始，然后逆向工作来解释你是如何到达那里的。代码不应该完全陌生，但我会解释一些新概念。
- en: Listing 5.1 Creating a pretty table of pizza sales
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1 创建一个漂亮的比萨饼销售表
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You have new functions—printstyled, rpad, and lpad—which need further exploration
    and explanation. To get the print_pizzatable function to work, you also need the
    *accessor* functions you defined in chapter 4\. All of these functions take a
    pizza tuple, such as ("bbq chicken", 'L', 20.75), as an argument and return one
    of the elements in the tuple.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你有新的函数——printstyled、rpad和lpad，需要进一步探索和解释。为了让print_pizzatable函数正常工作，你还需要在第4章中定义的*访问器*函数。所有这些函数都接受一个比萨饼元组，例如("bbq
    chicken", 'L', 20.75)，作为参数，并返回元组中的一个元素。
- en: Listing 5.2 Pizza tuple accessor functions
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.2 比萨饼元组访问器函数
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I will cover each function used inside print_pizzatable in more detail with
    some simple examples. I only briefly covered print and println in past chapters,
    so let’s cover the details.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我将更详细地介绍print_pizzatable中使用的每个函数，并附上一些简单的示例。我在过去的章节中只是简要介绍了print和println，所以让我们来详细讲解。
- en: 5.1.1 Print, println, and printstyled
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 打印、println和printstyled
- en: 'These are versatile functions that can be used to write text to your screen
    or even files or a network connection (see chapter 18 for greater detail). Let’s
    look at some simple examples to demonstrate how these functions work:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是多功能函数，可以用来将文本写入你的屏幕或文件，甚至网络连接（详见第18章以获取更多细节）。让我们看看一些简单的示例来展示这些函数是如何工作的：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Huh? Are they not doing the exact same thing? No, but it isn’t easy to tell
    with this example. Instead you will use a semicolon ; to separate statements on
    a single line. That will help make the difference clearer:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯？它们不是在做完全相同的事情吗？不，但在这个例子中并不容易看出。相反，你将使用分号 ; 来分隔单行上的语句。这将有助于使差异更清晰：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code shows you that println is just short for print, with a newline character
    \n added to the end. Julia, like many other languages, allows you to express nonvisible
    control characters, like a newline, by using a backslash with different letter
    combinations. Table 5.1 shows some of the more common control characters you can
    use in Julia to influence how text is written to a Unix terminal window.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显示 println 只是一个简写，它将一个换行字符 \n 添加到末尾。Julia，像许多其他语言一样，允许你通过使用带有不同字母组合的反斜杠来表示不可见的控制字符，如换行。表
    5.1 展示了你在 Julia 中可以使用的、用于影响文本写入 Unix 终端窗口的一些更常见的控制字符。
- en: Table 5.1 Escape sequences to write common control characters used in Unix terminals
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1 Unix 终端中使用的常见控制字符的转义序列
- en: '| Escape sequence | Hex value | Effect |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 转义序列 | 十六进制值 | 效果 |'
- en: '| \n | 0x0A | Newline |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| \n | 0x0A | 换行 |'
- en: '| \t | 0x09 | Horizontal tab |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| \t | 0x09 | 水平制表符 |'
- en: '| \v | 0x0B | Vertical tab |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| \v | 0x0B | 垂直制表符 |'
- en: '| \r | 0x0D | Carriage return |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| \r | 0x0D | 光标返回 |'
- en: '| \b | 0x08 | Backspace |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| \b | 0x08 | 退格 |'
- en: '| \\ | 0x5C | Backslash |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| \\ | 0x5C | 反斜杠 |'
- en: '| \" | 0x22 | Double quotation marks |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| \" | 0x22 | 双引号 |'
- en: 'The double quotation mark is not a control character, but since you use it
    to mark the start and end a string, you need to use an escape sequence to represent
    it. But what is the utility of knowing the hex value? You can use this directly
    to create characters. Here, a new line is created with the 0x0a hex value:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号不是一个控制字符，但既然你用它来标记字符串的开始和结束，你需要使用转义序列来表示它。但知道十六进制值有什么用？你可以直接使用它来创建字符。在这里，使用
    0x0a 十六进制值创建了一个新行：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s look at more examples of the effect of using these different escape sequences
    combined with regular text:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用这些不同的转义序列与常规文本结合使用的一些更多示例效果：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ This uses a vertical tab \v as opposed to the more widely known horizontal
    tab \t.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这使用的是垂直制表符 \v，而不是更广为人知的水平制表符 \t。
- en: ❷ The carriage return moves the cursor to the start of the line. Hence the word,
    world, overwrites hello, written initially.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 光标返回将光标移动到行的开头。因此，单词 "world" 覆盖了最初写入的 "hello"。
- en: This requires some context. Why do characters in your text strings cause the
    cursor to move around? It has to do with the history of the text printing system
    you have today. When the Unix operating system was first developed, there were
    no electronic displays, like the ones you use today. Instead, computer users used
    electro-mechanical devices called *teletypes* (figure 5.3). A teletype is very
    similar to an old-fashioned typewriter in operation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一些上下文。为什么你的文本字符串中的字符会导致光标移动？这与你今天使用的文本打印系统的历史有关。当 Unix 操作系统最初开发时，没有像你现在使用的这样的电子显示器。相反，计算机用户使用了一种称为
    *电传打字机* 的电磁机械设备（图 5.3）。电传打字机在操作上与老式的打字机非常相似。
- en: '![05-03](../Images/05-03.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![05-03](../Images/05-03.png)'
- en: Figure 5.3 Teletype Type 68D from Siemens (Norsk Teknisk Museum)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 西门子 Teletype Type 68D（挪威技术博物馆）
- en: These also served as your screen. If the computer wanted to give you some information,
    it had to send characters to your typewriter, which would cause it to print the
    characters sent onto paper. This created a need for control characters, meaning
    characters that bossed around your teletype, telling it to create a new line and
    move the caret down or back.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备也充当了你的屏幕。如果计算机想要给你一些信息，它必须将字符发送到你的打字机，这将导致它将发送的字符打印到纸上。这产生了对控制字符的需求，即控制你的电传打字机的字符，告诉它创建新行或将光标向下或向后移动。
- en: The terminal applications you use today are simulators of these old teletypes.
    This was so programs written to work with teletypes could still work. Unix commands
    such as ls, cp, cat, and echo have no idea they are running on modern computers
    with electronic displays. As far as they are concerned, they are interacting with
    a good old teletype.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你今天使用的终端应用程序是这些旧式电传打字机的模拟器。这样，为电传打字机编写的程序仍然可以工作。Unix 命令如 ls、cp、cat 和 echo 对它们运行在现代计算机上的电子显示器一无所知。就它们而言，它们正在与一台好用的旧式电传打字机交互。
- en: 'Eventually, these paper-based terminals were replaced by electronic terminals.
    At this point one expanded the control characters with new ones to represent colors.
    For instance, when an electronic terminal would receive the escape sequence \u001b[33m
    it would switch to writing yellow letters. If it got \u001b[31m, it would write
    red letters. So to write hello world in yellow letters, you can write the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这些基于纸张的终端被电子终端所取代。在此阶段，通过添加新的控制字符来扩展控制字符以表示颜色。例如，当电子终端接收到转义序列\u001b[33m时，它会切换到以黄色字母书写。如果接收到\u001b[31m，它会以红色字母书写。因此，要使用黄色字母打印hello
    world，您可以编写以下代码：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, remembering these escape sequences for different colors is cumbersome.
    Thus, Julia provides the printstyled function, which lets you specify a color
    to use by name. The color is specified using the *keyword argument* color:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，记住这些不同颜色的转义序列是繁琐的。因此，Julia提供了printstyled函数，允许您通过名称指定要使用的颜色。颜色通过*关键字参数* color指定：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This statement produces hello world in cyan color. You can look up the help
    for printstyled to get overview of what colors you can use. Just move the text
    cursor to the beginning of the line (Ctrl-A) and press ? to go into help mode:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句以青色打印出“hello world”。您可以通过查看printstyled的帮助来了解可以使用哪些颜色。只需将文本光标移至行首（Ctrl-A）并按?键进入帮助模式：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'All the colors are given as *symbols*. A symbol is very similar to a text string.
    It is often used for text strings, which only matter to programmers and not users
    of your program. You can programmatically create symbol objects:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有颜色都表示为*符号*。符号与文本字符串非常相似。它通常用于文本字符串，这些字符串对程序员很重要，但对程序的用户来说并不重要。您可以通过编程方式创建符号对象：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 5.1.2 Printing multiple elements
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 打印多个元素
- en: 'All the print functions are quite versatile in what they allow you to print
    and how many elements you can print:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有打印函数在允许您打印的内容和可以打印的元素数量方面都非常灵活：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Numbers and Boolean values get converted to text strings when passed as arguments
    to the various print functions. It is worth knowing that the string function works
    exactly the same way, except it returns a String instead of printing to the screen:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当将数字和布尔值作为参数传递给各种打印函数时，它们会被转换为文本字符串。了解字符串函数以完全相同的方式工作，除了它返回一个字符串而不是打印到屏幕上：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This allows you to use a single println statement to display information about
    one pizza. Notice the use of accessor functions defined earlier:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您使用单个println语句显示有关一个披萨的信息。注意使用之前定义的访问器函数：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 5.1.3 Printing multiple pizzas
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 打印多个披萨
- en: You can use this functionality to write out a simple table regarding pizza sales.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此功能编写有关披萨销售的简单表格。
- en: Listing 5.3 Primitive pizza table printing
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 基本披萨表格打印
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The problem with this code is that the name, size, and price columns don’t
    get aligned, but end up like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的问题在于名称、尺寸和价格列没有对齐，最终变成这样：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To perform alignment you need to add left padding and right padding using the
    lpad and rpad functions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行对齐，您需要使用lpad和rpad函数添加左侧填充和右侧填充。
- en: 5.1.4 Align with lpad and rpad
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.4 使用lpad和rpad对齐
- en: With the Julia padding functions you can specify that a text string should always
    be of a given length. If the text you supply is smaller, it will get padded with
    a chosen character. If no character is specified, the padding character defaults
    to space.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Julia的填充函数，您可以指定文本字符串应始终具有给定的长度。如果您提供的文本较小，它将使用所选字符进行填充。如果没有指定字符，填充字符默认为空格。
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Padding on the left
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 左侧填充
- en: ❷ Right-side padding
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 右侧填充
- en: First, you pad with the - character on the left side, until the whole string
    is 6 characters long. The second example is identical, except you pad on the right
    side with the - character.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您使用-字符在左侧填充，直到整个字符串长度为6个字符。第二个示例与第一个示例相同，只是您使用-字符在右侧填充。
- en: 'With lpad and rpad you can define how wide each column in your table should
    be and add padding, such as spaces, wherever the supplied text string is shorter.
    In this example, you’ll keep it simple and check what width the widest strings
    in each column would be:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用lpad和rpad，您可以定义表格中每列的宽度，并在提供的文本字符串较短的地方添加填充，例如空格。在这个例子中，您将保持简单，并检查每列中最宽的字符串的宽度：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Width for pizza name column
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 披萨名称列的宽度
- en: ❷ Width for size column
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 尺寸列的宽度
- en: ❸ Width for price column
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 价格列的宽度
- en: Let’s modify the initial code to use padding. You could just paste this code
    into your terminal or store it in a file you load into the terminal with, for
    example, include. Notice in the code that you don’t specify the padding character.
    If you don’t specify, it will default to a space.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改初始代码以使用填充。你可以直接将此代码粘贴到你的终端中，或者将其存储在一个文件中，然后用例如 include 命令将其加载到终端中。注意在代码中你没有指定填充字符。如果你没有指定，它将默认为空格。
- en: Listing 5.4 Simple aligned pizza table
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.4 简单对齐披萨表
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ You use cyan color for the header describing each column.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 你使用青色来描述每一列标题的颜色。
- en: ❷ Numbers are padded on the left, so the decimals align.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 数字在左侧填充，因此小数对齐。
- en: 'You can test this in the terminal:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在终端中测试这个：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice how the points are not aligned. There are many ways to solve that, but
    in the next example with trigonometric tables, you will make sure each number
    has the same number of decimals after the point.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意小数点没有对齐。有许多方法可以解决这个问题，但在下一个关于三角函数表的例子中，你将确保每个数字后面都有相同数量的小数。
- en: 5.1.5 Adding lines
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.5 添加线条
- en: 'Adding separating lines is actually quite simple. You simply use the symbol
    for a long vertical line: ''│'':'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 添加分隔线实际上非常简单。你只需使用长垂直线的符号：'│'：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is Julia’s way of telling you that this character is represented by the
    hexadecimal value 0x2502. Thus, you could get this character in two different
    ways:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Julia 告诉你这个字符由十六进制值 0x2502 表示的方式。因此，你可以通过两种不同的方式得到这个字符：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In fact, there are many useful characters for making tables:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，有许多有用的字符可以用来制作表格：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To draw lines, it is useful to know how to easily repeat characters. In Julia,
    the exponent ^ operator is used to repeat characters:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制线条，了解如何轻松重复字符是有用的。在 Julia 中，指数运算符 ^ 用于重复字符：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 5.2 Printing a trigonometric table
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 打印三角函数表
- en: 'You can reuse what you’ve learned to create a trigonometry table. This code
    uses many of the same functions as you have seen already: print, printstyled,
    lpad, and rpad. Don’t try to run this function yet; I am just giving you an overview.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用你学到的知识来创建一个三角函数表。此代码使用了你之前已经看到的一些相同函数：print、printstyled、lpad 和 rpad。不要尝试运行此函数；我只是在给你一个概述。
- en: Listing 5.5 Creating a trigometric table
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.5 创建三角函数表
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Write out the header for each column of numbers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为数字的每一列写出标题。
- en: ❷ Write out row of trig values for each angle.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为每个角度写出三角值的一行。
- en: 'There are not a lot of new ideas in this code; I covered the core logic in
    chapter 3\. However, numbers need special handling to align the decimal point.
    You need an equal number of digits after the point on every number, and you don’t
    want numbers that are too long. If you use the results as they are, you get way
    too many digits:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中并没有太多新的想法；我在第 3 章中已经介绍了核心逻辑。然而，数字需要特殊处理以对齐小数点。你需要每个数字后面都有相同数量的数字，而且你不想数字太长。如果你直接使用这些结果，你会得到太多的数字：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Instead you want something like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 而你想要的是这样的：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To achieve this, you have a helper function you can see in the main code listing:
    format.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你有一个辅助函数，你可以在主代码列表中看到它：format。
- en: Listing 5.6 Helper function for formating numbers
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6 格式化数字的辅助函数
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Round down to three decimals.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 四舍五入到三位小数。
- en: ❷ If you have a negative number you must allow for an extra character for the
    - sign.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果你有一个负数，你必须为负号留出额外的字符。
- en: 'n stores the maximum character width of a number. I am basically using a worst-case
    scenario, such as a negative number to get the maximum characters needed for the
    number string:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: n 存储数字的最大字符宽度。我基本上使用了一个最坏的情况，比如负数，以获取数字字符串所需的最多字符：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can see in the preceding example that when you use negative numbers you
    must allow more characters. Later you will print with lpad using spaces, which
    means the total width doesn’t change, whether the number is negative or not:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的例子中看到，当你使用负数时，你必须允许更多的字符。稍后你将使用 lpad 和空格打印，这意味着无论数字是正数还是负数，总宽度都不会改变：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 5.3 Reading and writing pizza sales to CSV files
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 读取和写入披萨销售到 CSV 文件
- en: 'The data you have been dealing with thus far is in table format, which is exactly
    what a spreadsheet application has been designed to deal with. A very common file
    format for exchanging data between various types of spreadsheet applications and
    scientific applications is called CSV, which is short for *comma separated values*.
    You will implement a store_pizzatable function to write pizza data in CSV format
    to a file and a load_pizzatable function to read the same CSV file. The following
    is an example of the pizza data CSV file format both functions will work with:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止处理的数据是以表格格式存在的，这正是电子表格应用程序设计来处理的内容。在各类电子表格应用程序和科学应用程序之间交换数据的一种非常常见的文件格式被称为
    CSV，它是“逗号分隔值”的缩写。你将实现一个 store_pizzatable 函数，用于将比萨饼数据以 CSV 格式写入文件，以及一个 load_pizzatable
    函数用于读取相同的 CSV 文件。以下是一个示例，展示了这两个函数都将处理的比萨饼数据 CSV 文件格式：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first line is referred to as the *header*. It gives a name to each column
    in the file. For each row you separate each value with a comma. Figure 5.4 is
    an example of loading such a CSV file into Apple Numbers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行被称为“标题”。它为文件中的每一列命名。对于每一行，你使用逗号分隔每个值。图 5.4 展示了将此类 CSV 文件加载到 Apple Numbers
    中的示例。
- en: '![05-04](../Images/05-04.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![05-04](../Images/05-04.png)'
- en: Figure 5.4 Pizza sales data loaded into the Apple Numbers spreadsheet application
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 将比萨饼销售数据加载到 Apple Numbers 电子表格应用程序中
- en: Say you produce lots of useful calculations you want to share, examine in a
    table, or plot graphically; exporting to CSV format helps. Julia already has built-in
    functions for this and very good external libraries, such as CSV.jl at csv.juliadata.org.
    However, your focus will be on learning the basics of reading and writing to files;
    thus you will not be using external packages or functions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你产生了大量想要分享、在表格中检查或图形化表示的有用计算；导出为 CSV 格式有助于此。Julia 已经内置了用于此目的的函数，以及非常好的外部库，如
    CSV.jl 在 csv.juliadata.org。然而，你的重点将放在学习文件读取和写入的基本知识上；因此，你将不会使用外部包或函数。
- en: 5.3.1 Writing pizza sales to a file
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 将比萨饼销售数据写入文件
- en: You will define a simple function, store_pizzatable, which outputs pizza sales
    data as comma separated values.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你将定义一个简单的函数，名为 store_pizzatable，该函数以逗号分隔值的形式输出比萨饼销售数据。
- en: Listing 5.7 Function for exporting pizza sales data as comma separated values
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.7 导出比萨饼销售数据为逗号分隔值的函数
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Write out the CSV header.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 写出 CSV 标题。
- en: ❷ A line for each pizza sold
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每售出一款比萨饼就写一行
- en: 'This function should look familiar to you. What is new is that the println
    function is taking a new first argument named io. This presents some common pitfalls,
    so let me use this function incorrectly at first:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数对你来说应该很熟悉。新的地方在于 println 函数接受一个新的第一个参数，名为 io。这带来了一些常见的陷阱，所以让我首先错误地使用这个函数：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is predictable. It just writes out the io object as a regular text string.
    But if the first argument is of a special type—not a string, not a number, and
    not a Boolean but an IO object, then you alter where the print and println functions
    write their output.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可预测的。它只是将 io 对象作为常规文本字符串写出来。但如果第一个参数是特殊类型——不是字符串，不是数字，也不是布尔值，而是一个 IO 对象，那么你将改变
    print 和 println 函数输出结果的位置。
- en: 'println("hello") is actually short for println(stdout, "hello"). What is stdout?
    It is short for *standard out*, which represents a destination for your printing.
    stdout represents the default destination for anything printed. The default is
    your terminal window; however, the destination could be a file or even a network
    connection. You can try using stdout instead of the string "--->", although the
    result will be rather boring:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: println("hello") 实际上是 println(stdout, "hello") 的简写。什么是 stdout？它是“标准输出”的缩写，代表了打印的目的地。stdout
    代表了打印任何内容的默认目的地；默认情况下是你的终端窗口；然而，目的地可以是文件，甚至是网络连接。你可以尝试使用 stdout 而不是字符串"--->"，尽管结果可能相当无聊：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It gets more interesting when you provide a file as a destination. To do that
    you need to create an IO object representing a file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你提供一个文件作为目的地时，事情会变得更有趣。为了做到这一点，你需要创建一个表示文件的 IO 对象。
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Open the file pizza-sales.csv. The second argument, w, tells Julia you want
    to open it for writing. Hence, the file will be created if it doesn’t already
    exist.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打开文件 pizza-sales.csv。第二个参数 w 告诉 Julia 你想要以写入模式打开它。因此，如果文件不存在，它将被创建。
- en: ❷ Use the io object to write pizza sales data to the open file.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 io 对象将比萨饼销售数据写入打开的文件。
- en: ❸ The connection to the file has to be closed when you are done. Reading and
    writing to a file can be buffered. Hence, unless you close, not all data will
    have necessarily been written yet.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当你完成时，必须关闭与文件的连接。读写文件可以是缓冲的。因此，除非你关闭，否则不一定所有数据都已经写入。
- en: 'You can go into shell mode by writing a semicolon ; at the beginning of the
    line. Whenever you want to go back to the Julia mode, you can press Backspace
    at the start of the line. Go into shell mode, and look at the file you created
    by using the Unix cat command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在行首写分号;进入shell模式。无论何时你想回到Julia模式，你都可以在行首按Backspace键。进入shell模式，并使用Unix cat命令查看你创建的文件：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 5.3.2 Reading pizza sales from a file
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 从文件中读取披萨销售数据
- en: You may commonly download a CSV file from the internet that you want to read
    from. Statistical data for anything from school results to unemployment numbers
    to GDP per capita can be downloaded as a CSV file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能经常从互联网上下载CSV文件，你想要从中读取。从学校成绩到失业率到人均GDP的统计数据都可以下载为CSV文件。
- en: 'You can open the pizza-sales.csv file and try to read from it. There are lots
    of clever ways of doing this, which I will cover in greater detail in chapter
    17\. This example keeps it simple using the readline function; it reads one line
    at a time:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以打开pizza-sales.csv文件并尝试从中读取。有许多巧妙的方法可以做到这一点，我将在第17章中更详细地介绍。这个示例使用readline函数保持简单；它一次读取一行：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The source it reads from doesn’t need to be a file. As we discussed earlier,
    your terminal window is treated as an IO object called stdout. There is a corresponding
    IO object representing your keyboard called stdin. This gives you a way of reading
    keyboard inputs:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 读取数据的来源不一定是文件。正如我们之前讨论的，你的终端窗口被视为一个名为stdout的IO对象。还有一个代表你的键盘的IO对象，称为stdin。这为你提供了一种读取键盘输入的方法：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ The text you wrote, which got captured by readline
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 你输入的文本，被readline捕获
- en: ❷ The value stored in s. Notice the use of quotation marks to indicate this
    value is a string.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 存储在s中的值。注意，这里使用引号来表示这个值是一个字符串。
- en: To get a feel for how it works, it is best to try another example. You will
    make a simple application that utilizes this shortly.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解其工作原理，最好是尝试另一个示例。你将很快制作一个简单应用程序，利用这个功能。
- en: 'Anyway, let’s get back to the pizzas. How do you turn a comma-separated string
    into a pizza tuple or array? For this you can use the split function. It allows
    you to split a string into multiple parts and collect the parts into an array:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，让我们回到披萨的话题。你如何将逗号分隔的字符串转换成披萨元组或数组？为此，你可以使用split函数。这个函数允许你将字符串分割成多个部分，并将这些部分收集到一个数组中：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There are, however, a number of problems with treating this as a pizza. Say
    you want to add a value-added tax of 25%. That will not work:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将它们视为披萨存在一些问题。比如说，你想添加25%的增值税。这是行不通的：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This problem exists because the price, p, isn’t actually a number but a string
    (or, more specifically, a substring, but let’s not get bogged down in details):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题存在是因为价格p实际上不是一个数字，而是一个字符串（或者更具体地说，是一个子字符串，但让我们不要陷入细节）：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This applies to anything you read from a file; Julia will treat it as text.
    It cannot know that you might want part of the file to be represented as numbers,
    Boolean values, or something else. However Julia has a function called parse,
    which allows you to convert a text string to anything else. In the following snippet
    you can see the conversion to a number:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于从文件中读取的任何内容；Julia会将它视为文本。它无法知道你可能希望文件的一部分以数字、布尔值或其他形式表示。然而，Julia有一个名为parse的函数，它允许你将文本字符串转换为其他任何形式。在下面的代码片段中，你可以看到将文本转换为数字的示例：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here the number 42 is parsed twice. In the first case it is turned into a integer,
    while in the second case it is turned into a floating-point number. Thus the same
    text can be interpreted in many different ways. It is your choice how to interpret
    it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数字42被解析了两次。在第一种情况下，它被转换成整数，而在第二种情况下，它被转换成浮点数。因此，相同的文本可以以许多不同的方式被解释。如何解释它取决于你。
- en: There are also entirely different text strings that can be interpreted as the
    same object. For example, both "true" and "1" can be parsed as the Boolean value
    true. With these building blocks you can put together a pizza loading function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些完全不同的文本字符串可以被解释为相同的对象。例如，“true”和“1”都可以被解析为布尔值true。有了这些构建块，你可以构建一个披萨加载函数。
- en: Listing 5.8 Loading pizza sales data
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.8 加载披萨销售数据
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ A place to store a list of pizzas
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 存储披萨列表的地方
- en: ❷ Skip the header name, size, price.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 跳过标题名称、大小、价格。
- en: ❸ eof is short for end of file. This function will be true when there is nothing
    more to read.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ eof是文件结束的缩写。当没有更多内容可读时，此函数将为真。
- en: ❹ Turn the price text string into an actual number with parse.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用parse将价格文本字符串转换为实际数字。
- en: ❺ Add an entry to your list of pizzas. Notice sz[1]; this is your way of turning
    a string such as "M" into the character 'M'.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在您的披萨列表中添加一个条目。注意sz[1]；这是您将字符串“M”转换为字符'M'的方法。
- en: 'If you try this function in the REPL you should get a result similar to this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在REPL中尝试此函数，您应该得到一个类似于以下的结果：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 5.4 Interacting with the user
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 与用户交互
- en: Let’s make an interactive application demonstrating the utility of being able
    to read user input through stdin. This one was inspired by a simple application
    I made to help my children practice their multiplication tables (figure 5.5).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个交互式应用程序，演示通过stdin读取用户输入的实用性。这个应用程序是受一个简单应用程序的启发，该应用程序帮助我的孩子们练习乘法表（图5.5）。
- en: '![05-05](../Images/05-05.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![05-05](../Images/05-05.png)'
- en: Figure 5.5 Running the multiplication testing application
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 运行乘法测试应用程序
- en: The app repeatedly asks the user to multiply two numbers and checks the answer.
    At the end you get a summary of how many correct answers you got. Let’s look at
    the implementation of the practice function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序会反复要求用户乘以两个数字并检查答案。最后，您会得到一个关于您正确回答次数的总结。让我们看看练习函数的实现。
- en: 'Listing 5.9 Practice multiplication: Asks user to write n answers'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.9 练习乘法：要求用户写出n个答案
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ Keep track of how many answers the user got right.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 跟踪用户正确回答的次数。
- en: ❷ Random numbers in the range 2 to 9
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 范围在2到9之间的随机数
- en: ❸ Convert the number the user wrote to an integer.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将用户输入的数字转换为整数。
- en: ❹ Check if the user got the answer right.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查用户是否回答正确。
- en: 'You can start this program by invoking the practice function from the REPL.
    Say you want to practice on eight different multiplications. You would write the
    following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从REPL调用练习函数来启动此程序。假设您想练习八种不同的乘法。您会写下以下内容：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Whenever you deal with more complex functions you are trying to understand,
    you can explore how they work by simply copying and pasting lines of code like
    this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当您处理更复杂的函数并试图理解它们时，您可以通过简单地复制和粘贴像这样的代码行来探索它们的工作原理：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The benefit is that you can see the value of every expression. This allows
    you to see how a value gets transformed in multiple steps. For example, you can
    explore why comparing the answer directly doesn’t work:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 优点是您可以看到每个表达式的值。这允许您看到值是如何在多个步骤中转换的。例如，您可以探索为什么直接比较答案不起作用：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To cement your understanding you can experiment with improving this program.
    Here are some ideas: Time yourself. Record how long you spend answering the questions.
    You can use the time() function for this purpose. Record the time before asking
    questions and after you are done. Look at the difference. You might want to round
    to nearest second with the round() function. Use the Julia help system to see
    how to best use these functions.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了巩固您的理解，您可以尝试改进这个程序。以下是一些想法：计时。记录您回答问题所花费的时间。您可以使用time()函数来完成此目的。记录提问前后的时间，看看差异。您可能希望使用round()函数将时间四舍五入到最接近的秒。使用Julia的帮助系统查看如何最好地使用这些函数。
- en: You might also want to provide the range used with rand as an argument to the
    practice function. There might be a particular range of numbers you want to practice
    more on. It could also be fun experimenting with creating nice tables using the
    ─,├, ┤, and ┼ symbols.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可能希望将rand使用的范围作为参数传递给练习函数。您可能想要练习特定范围的数字。尝试使用──、├、┤和┼符号创建漂亮的表格也可能很有趣。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: print, println, and printstyled can all be used to send text to a destination
    such as a terminal window or a file.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: print、println和printstyled都可以用来将文本发送到目的地，如终端窗口或文件。
- en: In a terminal, one can use special control character sequences to write colored
    text. printstyled simplifies this task, so you only have to remember the names
    of different colors.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端中，可以使用特殊的控制字符序列来编写彩色文本。printstyled简化了这个任务，因此您只需记住不同颜色的名称。
- en: To write to files or read from them, you need to open them. When you are done,
    you need to close them.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要写入文件或从文件中读取，您需要打开它们。当您完成时，您需要关闭它们。
- en: While reading a file, you can check if you are done with eof.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在读取文件时，您可以检查是否完成eof。
- en: The lpad and rpad functions help you align text in columns. This is done by
    padding with a chosen character either on the left or right side until the desired
    string width is achieved.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lpad 和 rpad 函数可以帮助您在列中对齐文本。这是通过在左侧或右侧填充所选字符来完成的，直到达到所需的字符串宽度。
- en: Text can be written or read from IO objects. IO objects are placeholders for
    real physical things, such as files on a hard drive, a keyboard, a network connection,
    or a terminal window—or even a teletype.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本可以写入或从 IO 对象中读取。IO 对象是真实物理事物的占位符，例如硬盘上的文件、键盘、网络连接或终端窗口——甚至电传打字机。
- en: Text strings can be converted to a variety of objects using the parse function.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 parse 函数可以将文本字符串转换为各种对象。
