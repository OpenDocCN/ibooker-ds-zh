- en: Chapter 10\. Twisted networking
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 10 章\. Twisted 网络编程
- en: '|  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: '*Writing networked programs in Python*'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用 Python 编写网络程序*'
- en: '*Designing multiplayer games (including testing them on your friends)*'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设计多人游戏（包括在朋友身上测试它们)*'
- en: '*Issues you’ll encounter when writing asynchronous programs*'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写异步程序时可能遇到的问题*'
- en: '|  |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this chapter, we’ll be revisiting the adventure game you wrote in [chapter
    6](kindle_split_014.html#ch06) and extending it so you can log in and play it
    with other people via the internet. Normally these games are referred to as MUDs,
    which stands for Multi-User Dungeon. Depending on the person creating them, MUDs
    can range from fantasy hack-and-slash to science fiction, and players can compete
    or cooperate to earn treasure, points, or fame.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾你在 [第 6 章](kindle_split_014.html#ch06) 中编写的冒险游戏，并扩展它，以便你可以通过互联网登录并与其他人一起玩。通常这些游戏被称为
    MUD，代表多人地下城。根据创建它们的人，MUD 可以从幻想的砍杀到科幻，玩家可以竞争或合作以获得宝藏、分数或名声。
- en: To get you started quickly, we’ll use a framework called Twisted, which contains
    libraries for working with many different networking protocols and servers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你快速入门，我们将使用一个名为 Twisted 的框架，它包含了许多不同网络协议和服务器的工作库。
- en: Installing Twisted
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Twisted
- en: The first step is to install Twisted and get a test application running. Twisted
    comes with installers for Windows and Macintosh, which are available from the
    Twisted homepage at [http://twistedmatrix.com/](http://twistedmatrix.com/). Some
    versions of MacOS ship with Twisted already installed, in which case it’s easier
    to use that version. If you’re using Linux, there should be packages available
    through your package manager.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是安装 Twisted 并运行一个测试应用程序。Twisted 提供了 Windows 和 Macintosh 的安装程序，可以从 Twisted
    主页 [http://twistedmatrix.com/](http://twistedmatrix.com/) 获取。某些版本的 MacOS 已经预装了
    Twisted，在这种情况下，使用该版本会更简单。如果你使用 Linux，应该可以通过你的包管理器获取到相应的软件包。
- en: The installer will pop up a window as it compiles things, but once you see the
    window on the right in [figure 10.1](#ch10fig01), Twisted is installed!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译东西时，安装程序会弹出一个窗口，但一旦你在 [图 10.1](#ch10fig01) 中看到右侧的窗口，Twisted 就已安装！
- en: '![](f0321-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0321-01.jpg)'
- en: Figure 10.1\. Installing Twisted on Windows
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.1\. 在 Windows 上安装 Twisted
- en: '![](10fig01_alt.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig01_alt.jpg)'
- en: The only other thing you need is a Telnet application. Most operating systems
    come with one built-in, and there are many free ones you can download. I normally
    use an SSH terminal program called PuTTY, which is available for Windows.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个 Telnet 应用程序。大多数操作系统都内置了一个，你也可以下载许多免费的版本。我通常使用一个名为 PuTTY 的 SSH 终端程序，它适用于
    Windows。
- en: Your first application
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的第一个应用程序
- en: You’ll start by writing a simple chat server. The idea is that people will be
    able to log into it via a program called Telnet and send each other messages.
    It’s a little more complex than “Hello World!” but you can extend this program
    and use it in your game later on in this chapter. Open a new file, and save it
    as something like chat_server.py.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从编写一个简单的聊天服务器开始。想法是人们可以通过一个名为 Telnet 的程序登录并互相发送消息。这比“Hello World!”要复杂一些，但你可以在本章后面扩展这个程序并在游戏中使用它。打开一个新文件，并将其保存为类似
    chat_server.py 的名称。
- en: 'Let’s start with the first part of your application: the protocol for the chat
    server. In Twisted terminology, a *protocol* refers to the part of your application
    that handles the low-level details: opening connections, receiving data, and closing
    connections when you’re finished. You can do this in Twisted by subclassing its
    existing networking classes. The next listing shows a simple chat client, which
    you’ll build on when you write your game in later sections.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从应用程序的第一部分开始：聊天服务器的协议。在 Twisted 术语中，*协议* 指的是处理低级别细节的部分：打开连接、接收数据以及完成时关闭连接。你可以在
    Twisted 中通过继承其现有的网络类来实现这一点。下面的列表显示了一个简单的聊天客户端，你将在本章后面的部分编写游戏时在此基础上构建。
- en: Listing 10.1\. A simple chat-server protocol
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1\. 简单聊天服务器协议
- en: '![](10list01_alt.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10list01_alt.jpg)'
- en: '![](f0322-01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0322-01.jpg)'
- en: For your chat server, you use Twisted’s *StatefulTelnetProtocol* ![](one.jpg).
    It takes care of the low-level line-parsing code, which means you can write your
    code at the level of individual lines and not have to worry about whether you
    have a complete line or not.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的聊天服务器，你将使用 Twisted 的 *StatefulTelnetProtocol* ![图片](one.jpg)。它负责处理低级别的行解析代码，这意味着你可以在单个行的级别编写代码，而无需担心是否有一行完整的代码。
- en: You’re customizing the protocol by overriding the built-in *connectionMade*
    method ![](two.jpg). This will called by for each connection the first time it’s
    made.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过覆盖内置的 *connectionMade* 方法 ![two.jpg]来自定义协议。这将对于每个连接在第一次建立时被调用。
- en: You’re taking care of a bit of housekeeping here—storing the client’s IP address
    and informing everyone who’s already connected of the new connection ![](three.jpg).
    You also store the new connection so you can send it broadcast messages in the
    future.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里负责一些家务管理——存储客户的IP地址，并通知所有已经连接的人新的连接 ![three.jpg]。你还会存储新的连接，以便将来可以发送广播消息。
- en: The Telnet protocol class provides the *lineReceived* method ![](four.jpg),
    which gets called whenever a complete line is ready for you to use (that is, whenever
    the person at the other end presses the return key). In your chat server, all
    you need to do is send whatever’s been typed to everyone else who’s connected
    to the server. The only tricky thing you need to do is to remove any line feeds;
    otherwise, your lines will overwrite each other when you print them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet协议类提供了 *lineReceived* 方法 ![four.jpg]，每当准备好供你使用的一整行时（即，当另一端的人按下回车键时）就会被调用。在你的聊天服务器中，你需要做的就是将输入的内容发送给所有连接到服务器的其他人。唯一需要小心的是移除任何换行符；否则，当你打印时，你的行会相互覆盖。
- en: If the connection is lost for some reason—either the client disconnects, or
    is disconnected by you—*connectionLost* will be called so you can tidy things
    up ![](five.jpg). In this case, you don’t really need to do much, just remove
    the client from the list of connections so you don’t send them any more messages.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因连接丢失——无论是客户端断开连接，还是你将其断开——将调用 *connectionLost* 方法，以便你可以整理一下 ![five.jpg]。在这种情况下，你实际上不需要做太多，只需将客户端从连接列表中移除，这样你就不会向他们发送更多消息。
- en: To make the code easier to follow, I’ve created the *msg_all* and *msg_me* methods,
    which will send out a message to everyone and just you, respectively ![](six.jpg).
    *msg_all* takes a *sender* attribute, which you can use to let people know who
    the message is coming from.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码更容易理解，我创建了 *msg_all* 和 *msg_me* 方法，分别向所有人发送消息和仅向你发送消息 ![six.jpg]。*msg_all*
    方法接受一个 *sender* 属性，你可以用它来告知人们消息的来源。
- en: '|  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '*Factory* is a programming term for something that creates a class for you
    to use. It’s another way to hide some of the complexity of a library from the
    programmers who make use of it.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*Factory* 是一个编程术语，指的是为你创建一个类的东西。这是隐藏库复杂性的另一种方式，让使用它的程序员不必担心。'
- en: '|  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'That takes care of how you want your program to behave. Now, how do you link
    it to Twisted? You use what Twisted refers to as a Factory, which is responsible
    for handling connections and creating new instances of *ChatProtocol* for each
    one. You can think of the Factory as a switchboard operator: as people connect
    to your server, the Factory creates new protocols and links them together, similar
    to [figure 10.2](#ch10fig02).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了你的程序应该如何表现的问题。现在，你是如何将其链接到Twisted的呢？你使用Twisted所称为的Factory，它负责处理连接并为每个连接创建新的
    *ChatProtocol* 实例。你可以将Factory想象成一个交换机操作员：当人们连接到你的服务器时，Factory创建新的协议并将它们连接起来，类似于
    [图10.2](#ch10fig02)。
- en: Figure 10.2\. A Factory creating protocols
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2\. 工厂创建协议
- en: '![](10fig02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![10fig02.jpg]'
- en: So how do you do this in Twisted? Easy! Add a factory class, as shown in the
    next listing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么在Twisted中如何做到这一点呢？很简单！添加一个工厂类，如下一列表所示。
- en: Listing 10.2\. Connecting your protocol
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.2\. 连接到你的协议
- en: '![](10list02_alt.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![10list02_alt.jpg]'
- en: '![](f0324-01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![f0324-01.jpg]'
- en: A Factory is object-oriented terminology for something that creates instances
    of another class ![](one.jpg). In this case, it will create instances of *ChatProtocol*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Factory 是面向对象术语，指的是创建另一个类的实例的东西 ![one.jpg]。在这种情况下，它将创建 *ChatProtocol* 的实例。
- en: The *ChatFactory* is the natural place to store data that is shared among all
    of the *ChatProtocol* instances. The *send-ToAll* method is responsible for sending
    a message to each of the clients specified in the clients list ![](two.jpg). As
    you saw in [listing 10.1](#ch010list1), the client protocols are responsible for
    updating this list whenever they connect or disconnect.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*ChatFactory* 是存储所有 *ChatProtocol* 实例之间共享数据的自然位置。*send-ToAll* 方法负责向客户端列表中指定的每个客户端发送消息
    ![two.jpg]。正如你在 [代码列表10.1](#ch010list1) 中看到的，客户端协议负责在它们连接或断开时更新此列表。'
- en: The final step is to let Twisted know about your new protocol and Factory. You
    do this by creating an instance of *ChatFactory*, binding it to a particular port
    with the *listenTCP* method, and then starting Twisted with a call to its main
    loop, *reactor.run()* ![](three.jpg). Here you use 4242 as the port to listen
    to—it doesn’t matter too much which one you use, as long as it’s above 1024 so
    it doesn’t interfere with existing network applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是让Twisted了解你的新协议和Factory。你通过创建一个*ChatFactory*实例，使用*listenTCP*方法将其绑定到特定的端口，然后通过调用其主循环*reactor.run()*来启动Twisted来完成此操作
    ![图片](three.jpg)。在这里，你使用4242作为监听端口——你使用哪个端口并不重要，只要它大于1024，以免干扰现有的网络应用程序。
- en: If you save the program and run it, you should see the message “Chat server
    running!” If you connect to your computer via Telnet on port 4242 (usually by
    typing *telnet localhost 4242*), then you should see something like [figure 10.3](#ch10fig03).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保存程序并运行它，你应该会看到消息“聊天服务器正在运行！”如果你通过Telnet在端口4242（通常通过输入*telnet localhost 4242*）连接到你的计算机，那么你应该会看到类似[图10.3](#ch10fig03)的内容。
- en: Figure 10.3\. Your chat server is running.
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.3\. 你的聊天服务器正在运行。
- en: '![](10fig03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10fig03.jpg)'
- en: '![](f0325-01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0325-01.jpg)'
- en: It may not seem like much, but you’ve already got the basic functionality of
    the MUD server going. If you’d like to explore the chat server further, there’s
    a more fully featured version included with the source code, available from [http://manning.com/HelloPython/](http://manning.com/HelloPython/).
    That version adds commands to change your name and see who else is connected,
    as well as limit some common sorts of misbehavior and allow you to remove anyone
    who’s behaving badly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来不多，但你已经让MUD服务器的基本功能开始运行了。如果你想进一步探索聊天服务器，源代码中包含了一个功能更完整的版本，可在[http://manning.com/HelloPython/](http://manning.com/HelloPython/)找到。该版本添加了更改你的名字和查看谁还连接的命令，以及限制一些常见的错误行为并允许你移除行为不良的人。
- en: First steps with your MUD
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MUD的初步步骤
- en: Now you’re ready to start connecting your adventure game to the network. You’ll
    base it on the chat server, but instead of only broadcasting what’s typed to everyone
    who’s connected, you’ll feed it directly into the adventure game. This is a common
    way to get things done when programming—find two programs (or functions or libraries)
    that do separate parts of what you need, and then “glue” them together.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已准备好将你的冒险游戏连接到网络。你将基于聊天服务器，但不是仅仅向所有连接的人广播输入的内容，而是直接将其输入到冒险游戏中。在编程时，这是一种常见的方法——找到两个程序（或函数或库）分别完成你需要的一部分，然后将它们“粘合”在一起。
- en: The basic gist is that you’ll have multiple players logged in at once, all trying
    to execute commands (such as “get sword”) at the same time. This could potentially
    cause problems for the server because you’re mixing real-time Twisted code with
    the one-step-at-a-time of your adventure game. You’ll head off most of the issues
    by queuing up player commands and updating your game’s state once per second.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你将同时有多个玩家登录，他们都在尝试同时执行命令（例如“拿剑”）。这可能会给服务器带来问题，因为你将实时Twisted代码与你的冒险游戏的一步一步操作混合在一起。你将通过排队玩家命令并每秒更新一次游戏状态来解决大部分问题。
- en: Let’s get started. Copy your adventure code from [chapter 6](kindle_split_014.html#ch06)
    into a new folder, along with the chat-server code you just created. You’ll probably
    also want to rename chat_server.py to something like mud_server.py, to help keep
    things straight, and rename your classes and variables as in the next listing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。将你的冒险代码从[第6章](kindle_split_014.html#ch06)复制到一个新文件夹中，连同你刚刚创建的聊天服务器代码。你可能还想将chat_server.py重命名为类似mud_server.py的东西，以帮助保持事物清晰，并按下一列表中的方式重命名你的类和变量。
- en: Listing 10.3\. Updating your chat protocol
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.3\. 更新你的聊天协议
- en: '![](10list03_alt.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](10list03_alt.jpg)'
- en: The first step is to import the *Game* and *Player* classes into your code ![](one.jpg).
    I’ve also changed the name of the protocol so it’s obvious what you’re trying
    to write.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将*Game*和*Player*类导入到你的代码中 ![图片](one.jpg)。我还更改了协议的名称，使其明显表明你正在尝试编写什么。
- en: '![](f0327-01.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0327-01.jpg)'
- en: Next, you give a nice, friendly start when someone first connects to your MUD
    ![](three.jpg).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当有人首次连接到你的MUD时，你给出一个友好、亲切的起始信息 ![图片](three.jpg)。
- en: Now you’ll start to do the real work. But it turns out to not be that hard.
    I’ve assumed the game will keep track of its players somehow, and added a new
    player object to the game’s list of players ![](four.jpg). To make it possible
    for you to talk to the player from within the game, I’ve also added the protocol
    to the player. You’ll see how that works in a minute.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将开始进行真正的开发工作。但事实上并不难。我假设游戏将以某种方式跟踪其玩家，并在游戏玩家的列表中添加了一个新的玩家对象 ![four.jpg](#)。为了使您能够在游戏中与玩家交谈，我还将协议添加到玩家中。您将在下一分钟看到它是如何工作的。
- en: 'You’ll still need to handle the case where a player disconnects from the server
    ![](five.jpg). But, again, it’s straightforward: remove them from the game’s list
    of players, and delete them.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然需要处理玩家从服务器断开连接的情况 ![five.jpg](#)。但，再次强调，这是直截了当的：从游戏玩家的列表中移除他们，并删除他们。
- en: Once players are connected, they’ll want to type commands, like “go north” and
    “attack orc” ![](two.jpg). First, you sanitize the input you’ve received (in testing,
    I found that different Telnet programs can send different weird characters). When
    it’s trimmed down to only printable characters, you assume the player has a list
    of commands waiting to be executed, and push this one to the end.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦玩家连接，他们就会想要输入命令，比如“向北走”和“攻击兽人” ![two.jpg](#)。首先，您需要对收到的输入进行清理（在测试中，我发现不同的Telnet程序可以发送不同的奇怪字符）。当它被缩减到只有可打印字符时，您假设玩家有一个等待执行的命令列表，并将这个命令推到最后。
- en: Your protocol is done, but what about the Factory and the rest of it? It turns
    out that you don’t need to do too much to your Factory—just change a few lines.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您的协议已经完成，但工厂和其他部分呢？结果是，您不需要对工厂做太多——只需更改几行。
- en: Listing 10.4\. Updating your chat Factory
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.4\. 更新您的聊天工厂
- en: '![](10list04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![10list04.jpg](#)'
- en: You don’t need to do too much to update your Factory ![](two.jpg)—change its
    protocol and rename it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要做太多来更新您的工厂 ![two.jpg](#) ——更改其协议并重命名它。
- en: '![](f0328-01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![f0328-01.jpg](#)'
- en: You’ll need a *Game* object, too, so you create it here ![](three.jpg). You
    don’t want to use the old *run* method, though, because it still handles things
    the old way.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要一个 *Game* 对象，因此在这里创建它 ![three.jpg](#)。不过，您不想使用旧的 *run* 方法，因为它仍然以旧的方式处理事情。
- en: The design calls for you to run a game update once per second. Because you’re
    using Twisted’s event loop (that’s the *reactor.run()* part), you’ll need to use
    Twisted’s *task.LoopingCall* to call the game’s update method ![](one.jpg), *run_one_tick*,
    which you’ll also create shortly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 设计要求您每秒运行一次游戏更新。因为您正在使用Twisted的事件循环（即 *reactor.run()* 部分），您需要使用Twisted的 *task.LoopingCall*
    来调用游戏的更新方法 ![one.jpg](#)，*run_one_tick*，您也将很快创建它。
- en: That should be all you need to do to the network code for now. You’ve made a
    few assumptions about how the game code will work, but often this is easier than
    jumping back and forth between the *Game* and *Mud-Protocol* classes and trying
    to fit it all together. Now that your protocol is written, you have to make *Game*
    and *Player* play along, too.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，您可能需要做的网络代码就这些了。您对游戏代码的工作方式做了一些假设，但通常这比在 *Game* 和 *Mud-Protocol* 类之间跳来跳去并试图将其全部组合起来要容易。现在，您的协议已经编写完成，您还需要让
    *Game* 和 *Player* 一起参与。
- en: Listing 10.5\. Changing your game code to work with the new interface
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.5\. 将您的游戏代码修改为与新接口兼容
- en: '![](10list05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![10list05.jpg](#)'
- en: The single-player version of the adventure game had one player, but you’ll potentially
    have many, so you’ll make it a list instead ![](one.jpg). You’re also giving the
    starting cave a sensible name.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 冒险游戏的单人版本只有一个玩家，但您可能会有很多玩家，所以您将其改为列表 ![one.jpg](#)。您还为起始洞穴取了一个合理的名字。
- en: '![](two.jpg) is the main loop you called from the networking part of your code.
    You should be able to follow what it’s doing from the names—get input for each
    *Player* object (including monsters), run the update, and then send the results
    back.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![two.jpg](#) 是您从代码的网络部分调用的主循环。您应该能够从名称中了解它在做什么——为每个 *Player* 对象（包括怪物）获取输入，运行更新，然后将结果发送回去。'
- en: 'You already have methods for getting input and processing orders, but you’ll
    need something to send back the results of each player’s actions ![](three.jpg).
    To do that, you’ll make another assumption: that each *Player* object knows how
    to send results back to the player.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经有了获取输入和处理命令的方法，但您需要某种东西来发送每个玩家的行动结果 ![three.jpg](#)。为此，您将做出另一个假设：每个 *Player*
    对象都知道如何将结果发送回玩家。
- en: Now you have only two assumptions left to fill in, and they’re both in the *Player*
    class. The first is that *Player* will have a list of pending commands, and the
    second is that it will have a way to send the results of any commands or events
    back to the player. The other thing you need to do is make sure the *Player* class
    reads from the list of pending commands, rather than using *raw_input*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只剩下两个假设需要填写，它们都在 *Player* 类中。第一个是 *Player* 将会有一个待处理命令列表，第二个是它将有一种方式将任何命令或事件的结果发送回玩家。你需要做的另一件事是确保
    *Player* 类从待处理命令列表中读取，而不是使用 *raw_input*。
- en: Listing 10.6\. Changing the `Player` code
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.6\. 修改 `Player` 代码
- en: '![](ch010list6-0.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](ch010list6-0.jpg)'
- en: '![](ch010list6-1.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](ch010list6-1.jpg)'
- en: '![](f0331-01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](f0331-01.jpg)'
- en: You start by creating your list of pending commands and the result that needs
    to be sent back to the player ![](one.jpg). They’re just lists, and when they’re
    in use they’ll have a list of strings.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先创建你的待处理命令列表和需要发送回玩家的结果 ![](one.jpg)。它们只是列表，当它们在使用时，将包含字符串列表。
- en: You can’t use *raw_input* any more, so you need to read your next command from
    *self.input_list*![](two.jpg). *pop* removes the command for you so you don’t
    have to worry about removing it from the list later. *pop* called on an empty
    list raises an exception, so you check for that case and assume the command is
    blank if there’s nothing there.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能再使用 *raw_input* 了，所以你需要从 *self.input_list* 中读取你的下一个命令 ![](two.jpg)。*pop*
    会为你移除命令，这样你就不必担心稍后从列表中移除它。在空列表上调用 *pop* 会引发异常，所以你需要检查这种情况，并假设如果没有内容则命令为空。
- en: 'To send the results of a player’s actions ![](three.jpg), you use the *self.connection*
    object that you set up in mudserver.py. Note that even if the player isn’t doing
    anything, other players and monsters are, so you have two separate sections: one
    for the results of your actions and another for events.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送玩家行动的结果 ![](three.jpg)，你使用在 mudserver.py 中设置的 *self.connection* 对象。请注意，即使玩家没有进行任何操作，其他玩家和怪物却在行动，所以你有两个独立的部分：一个用于你行动的结果，另一个用于事件。
- en: In the old version of the game, when the player died, the game ended. That’s
    no longer the case, so you’ll need to gracefully handle the situation where a
    player dies ![](four.jpg). To do that, you make the player drop whatever they’re
    carrying, send them a message, and drop the connection. If you extend your game,
    you might want to make the player keep their items. Alternatively, you can allow
    other players to “get sword from Anthony” if you’re feeling mean.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏的老版本中，当玩家死亡时，游戏结束。现在情况不再是这样，所以你需要优雅地处理玩家死亡的情况 ![](four.jpg)。为此，你让玩家放下他们携带的任何物品，发送一条消息，并断开连接。如果你扩展你的游戏，你可能想让玩家保留他们的物品。或者，如果你觉得残忍，你可以允许其他玩家“从安东尼那里得到剑”。
- en: Monsters don’t connect over the network and don’t have the *self. connection*
    object, so the default *send_results* from the *Player* class won’t work. They
    don’t need to know the results of their actions, so you’ll stub out their version
    of *send_results* and return immediately ![](five.jpg).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 怪物不会通过网络连接，也没有 *self.connection* 对象，所以 *Player* 类的默认 *send_results* 不会起作用。它们不需要知道它们行动的结果，所以你需要模拟它们的
    *send_results* 版本并立即返回 ![](five.jpg)。
- en: The previous adventure game looked at the player’s name to figure out whether
    to attack them. Now that you have multiple players, who probably all have different
    names, you’ll need to be a bit more discerning ![](six.jpg). A better way is to
    examine the class of the object the monster is looking at, using the *__class__*
    method. That will return the class, which you can compare to *player.Player*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的冒险游戏通过查看玩家的名字来判断是否攻击他们。现在你有多个玩家，他们可能都有不同的名字，你需要更加细致 ![](six.jpg)。更好的方法是检查怪物正在查看的对象的类，使用
    *__class__* 方法。这将返回类，你可以将其与 *player.Player* 进行比较。
- en: '|  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'This works so well because your game has only one point of communication with
    the player: the commands the player types and the responses the game returns.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为你的游戏与玩家之间只有一个通信点：玩家输入的命令和游戏返回的响应。
- en: '|  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: That should be all you need to do. Now, when you run your server and connect
    via Telnet, you’ll see your familiar adventure-game prompt, and you can run around
    the server collecting loot and slaying monsters. Go ahead and bask in the adventure
    and glory.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该就是你需要做的全部。现在，当你运行你的服务器并通过 Telnet 连接时，你会看到你熟悉的冒险游戏提示，你可以四处跑动在服务器上收集战利品和击败怪物。尽情享受冒险和荣耀吧。
- en: Well, sort of. Although the game works, and you can explore and do everything
    you need to, there are a few more things to take care of before your game is playable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，差不多吧。虽然游戏可以运行，你也可以探索和做你需要做的所有事情，但在你的游戏可玩之前，还有一些事情需要处理。
- en: Making the game more fun
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使游戏更有趣
- en: 'I made the previous code available to some of my friends online and got feedback
    from them. They raised two major issues: the monster was too hard to beat, and
    there wasn’t enough interaction between the players. Normally, in an adventure
    game like this, you’ll be able to change your name and description, talk to other
    players, look at their description, and so on.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我将之前的代码发布到网上给一些朋友看，并从他们那里得到了反馈。他们提出了两个主要问题：怪物太难打败，玩家之间的互动不足。通常，在这种冒险游戏中，你将能够更改你的名字和描述，与其他玩家交谈，查看他们的描述，等等。
- en: '![](f0332-01.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片6](f0332-01.jpg)'
- en: Bad monster!
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 坏怪物！
- en: The problem with combat is pretty obvious once you run into the orc for the
    first time. You’re limited to the actions you type in—but the monsters react at
    computer speed. The next figure shows what I mean.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你第一次遇到兽人，战斗的问题就非常明显了。你的行动受限于你输入的内容——但怪物以计算机的速度反应。下一张图显示了我是怎么想的。
- en: The solution that most MUDs use is what’s known as an *angry list*. Rather than
    attacking things directly, the game maintains a list of monsters and other players
    you’re angry at. If you’re not explicitly doing anything else, and there’s something
    present that’s on your angry list, then you’ll attack it. If something attacks
    you, then it will go on your angry list, too, so you’ll at least put up a token
    defense. Let’s look at how you can implement the angry list in your game.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数MUD游戏所采用的解决方案被称为*愤怒列表*。而不是直接攻击事物，游戏会维护一个你愤怒的怪物和其他玩家的列表。如果你没有明确地做其他任何事情，而且你的愤怒列表中存在某个目标，那么你会攻击它。如果有人攻击你，那么它也会进入你的愤怒列表，这样你至少会进行象征性的防御。让我们看看如何在你的游戏中实现愤怒列表。
- en: Figure 10.4\. Bad monster! No beating on the player!
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4\. 坏怪物！不要打玩家！
- en: '![](10fig04_alt.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片8](10fig04_alt.jpg)'
- en: Listing 10.7\. Angry lists
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.7\. 愤怒列表
- en: '![](ch010list7-0.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片4](ch010list7-0.jpg)'
- en: '![](ch010list7-1.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](ch010list7-1.jpg)'
- en: '![](f0334-01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](f0334-01.jpg)'
- en: Both players and monsters will need a way to remember who they’re angry at.
    You’ll make it a list ![](one.jpg), because you’re not expecting it to grow too
    large.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家和怪物都需要一种记住他们愤怒的对象的方法。你将把它做成一个列表 ![图片5](one.jpg)，因为你不期望它变得太大。
- en: Next, you’ll modify your *update* method. If your *input* attribute is blank,
    you know that the player (or monster) hasn’t entered any commands, and you can
    go ahead and attack if necessary. You build a list of all the things you’re angry
    at that are present, and then attack one of them ![](two.jpg).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将修改你的*update*方法。如果你的*input*属性为空，你知道玩家（或怪物）没有输入任何命令，并且如果需要，你可以继续攻击。你构建一个列表，列出所有你愤怒的且当前存在的目标，然后攻击其中一个
    ![图片11](two.jpg)。
- en: If a player or monster is dead, they shouldn’t keep attacking, so you clear
    their angry list ![](three.jpg).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家或怪物死了，他们不应该继续攻击，所以你会清除他们的愤怒列表 ![图片7](three.jpg)。
- en: The players will also need a way to stop attacking things (maybe they’re friends
    again). The *stop* command will remove an attacker from the list of things that
    the player is angry at ![](four.jpg).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家还需要一种停止攻击事物的办法（也许他们又成为了朋友）。*停止*命令将从玩家愤怒的列表中移除攻击者 ![图片3](four.jpg)。
- en: The final major thing you’ll do is make the *attack* command modify the angry
    lists of both the attacker and attacked ![](five.jpg). Now, when something gets
    attacked, it will automatically fight back. Note how you build your result before
    you do the attack. That way, if the target dies, you won’t see “You attack the
    dead orc.” *do_attack* is the mechanism from your old *attack* attribute with
    a different name.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要做的最后一件大事是让*攻击*命令修改攻击者和被攻击者的愤怒列表 ![图片9](five.jpg)。现在，当某物被攻击时，它会自动反击。注意你在攻击之前是如何构建你的结果的。这样，如果目标死亡，你不会看到“你攻击了死去的兽人。”
    *do_attack* 是从你的旧*attack*属性中来的机制，只是名字不同。
- en: The final, final thing is to add *stop* to your list of commands ![](six.jpg)—other-wise
    you won’t be able to use it!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后的事情是向你的命令列表中添加*停止*命令 ![图片10](six.jpg)——否则你将无法使用它！
- en: Now the player should have half a chance against the orc. If the orc beats the
    player now, the player will at least feel that they haven’t been completely robbed
    by the game. If you pick up the sword, you’ll find it helps a lot, which is what
    you want. There are plenty of other opportunities for improving the combat system,
    but you need to deal with a more pressing problem, instead.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家应该有半成的机会对抗兽人。如果兽人现在打败了玩家，玩家至少会感到他们没有被游戏完全欺骗。如果你拿起剑，你会发现它非常有帮助，这正是你想要的。还有很多其他改进战斗系统的机会，但你需要处理一个更紧迫的问题。
- en: Back to the chat server
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回聊天服务器
- en: The second problem is that players can’t interact with each other. This is often
    a big draw when it comes to a multiplayer game—players will come for the game
    but stay for the company. Fortunately, making your game more social is easy to
    do. You’ll add a few extra commands to the *Player* class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是玩家不能互相互动。当涉及到多人游戏时，这通常是一个很大的吸引力——玩家会为了游戏而来，但会为了陪伴而留下。幸运的是，让你的游戏更具社交性是很容易做到的。你将在
    *Player* 类中添加一些额外的命令。
- en: Listing 10.8\. Social gaming
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.8\. 社交游戏
- en: '![](ch010list8-0.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch010list8-0.jpg)'
- en: '![](ch010list8-1.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch010list8-1.jpg)'
- en: If a player is completely new to the game, you need to give them at least half
    an idea of what they can do. You’ll make “help” output some helpful instructions
    ![](one.jpg). The full help text I added is in the *source* code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家对游戏完全陌生，你需要至少给他们一半的想法，了解他们可以做什么。你将使“帮助”输出一些有用的说明 ![图片](one.jpg)。我添加的完整帮助文本在
    *源代码* 中。
- en: 'Another easy win is to let players customize their appearance by changing their
    name and description ![](two.jpg). Rather than being “player #4,” the player can
    now be “Grognir, Slayer of Orcs.”'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '另一个容易的胜利是让玩家通过更改他们的名字和描述来自定义他们的外观 ![图片](two.jpg)。玩家现在可以不再是“玩家 #4”，而是“Grognir，兽人杀手”。'
- en: Of course, the description’s not much good if other players can’t see it ![](three.jpg).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果其他玩家看不到描述，那么描述就没有什么用了 ![图片](three.jpg)。
- en: '![](f0336-01.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0336-01.jpg)'
- en: 'You’ll also need to add to most important case of all: a *say* command, so
    your players can talk to each other ![](four.jpg). All this command needs to do
    is send what you’ve typed to every other object in the current room. This simple
    change will allow players to interact on a human level, which will in turn help
    keep them coming back.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要添加最重要的命令之一：一个 *say* 命令，这样你的玩家就可以互相交谈 ![图片](four.jpg)。这个命令需要做的只是将你输入的内容发送到当前房间中的每个其他对象。这个简单的改变将允许玩家在人类层面上进行互动，这反过来又可以帮助他们继续回来。
- en: One of the issues you’ll run into is that with the new commands, the old *find_handler*
    method will sometimes call the wrong thing. For example, both the *player* and
    the *location* have a *look* method, and which one is correct will depend on the
    context. Additionally, some of the commands you’ve just added only apply to the
    players themselves, and you shouldn’t look for an object to apply them to. The
    following listing has an updated version that is a lot more explicit about which
    objects it should look at.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你会遇到的一个问题是，随着新命令的出现，旧的 *find_handler* 方法有时会调用错误的东西。例如，*player* 和 *location*
    都有一个 *look* 方法，哪个是正确的将取决于上下文。此外，你刚刚添加的一些命令只适用于玩家本身，你不应该寻找对象来应用它们。以下列表有一个更新的版本，它对应该查看哪些对象要明确得多。
- en: Listing 10.9\. Updating `find_handler`
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.9\. 更新 `find_handler`
- en: '![](ch010list9-0.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch010list9-0.jpg)'
- en: '![](ch010list9-1.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch010list9-1.jpg)'
- en: '![](f0338-01.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0338-01.jpg)'
- en: Let’s pay close attention to word choice. Some verbs don’t apply to nouns, or
    else they implicitly apply to the player ![](one.jpg).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们密切关注词汇选择。有些动词不适用于名词，或者它们隐含地适用于玩家 ![图片](one.jpg)。
- en: There are a few special-case commands ![](two.jpg) that you can’t handle with
    your current system. You could rewrite the entire handler, but it’s easier to
    catch those commands and explicitly convert them to something you *can* handle.
    Of course, if it becomes more than a handful of conversions, then you’ll have
    to rethink things; but it will do for now.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个特殊情况的命令 ![图片](two.jpg) 你无法用你当前的系统处理。你可以重写整个处理器，但更容易捕捉这些命令并将它们明确转换为你可以处理的东西。当然，如果转换变得超过几个，那么你将不得不重新思考事情；但现在这就可以了。
- en: So that you can see how you look, you’ll add a *self* object, too ![](three.jpg).
    “Look self” should return your description as it appears to other people.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你看到你看起来怎么样，你也会添加一个 *self* 对象 ![图片](three.jpg)。“查看 self” 应该返回你呈现给其他人的描述。
- en: '![](four.jpg) is another improvement to make things easier for the new player.
    Rather than have one error message when things go wrong, you’ll have one for a
    command you don’t understand, and another when you can’t find what the player’s
    looking for.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![](four.jpg)是另一个改进，使新玩家更容易。当事情出错时，你将有一个错误信息，一个是你不理解的命令，另一个是你找不到玩家在寻找的东西时。'
- en: Now your players can chat to each other and compliment each other on their fine
    threads.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的玩家可以互相聊天，并赞美他们出色的线程。
- en: Finally, what would social gaming be without the opportunity to be antisocial,
    too? Most MUDs have the option to shout, which works much like speaking, except
    that everyone connected can hear you.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果没有反社会的机会，社交游戏会是什么样子？大多数MUDs都有喊叫的选项，这和说话很像，只是连接的每个人都能听到你。
- en: Listing 10.10\. Antisocial gaming
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.10\. 反社会游戏
- en: '![](ch10list10-0.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10list10-0.jpg)'
- en: '![](ch10list10-1.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10list10-1.jpg)'
- en: First, you’ll convert the text to uppercase ![](one.jpg), SO THAT IT LOOKS A
    LOT MORE LIKE SHOUTING!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将文本转换为大写！[](one.jpg)，这样它看起来就更多像是在喊叫！
- en: '![](f0339-01.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](f0339-01.jpg)'
- en: Now you need to visit each cave in turn—but there doesn’t seem to be any way
    to find out what the caves are. For now, you’ll assume you have access to the
    game’s list of caves ![](two.jpg).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要依次访问每个洞穴——但似乎没有找到洞穴的方法。目前，你将假设你能够访问游戏的洞穴列表！[](two.jpg)。
- en: This is pretty much the same as when players talk to each other ![](three.jpg).
    Merging the two together—for example, by pushing the code into the location class—is
    left as an exercise for the reader.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上和玩家互相交谈时的情况一样！将两者合并——例如，通过将代码推入位置类——留给读者作为练习。
- en: Now you need to give your *Player* class access to the caves list from the game
    ![](four.jpg) by making it a variable you pass in from the game when you create
    a player or monster. Then, update each place where you create an instance of a
    player or monster ![](five.jpg), so it now knows about the *game* object and can
    tell where all the caves are.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要通过在创建玩家或怪物时将其作为变量从游戏传递进来，给你的*Player*类访问游戏中的洞穴列表的权限！[](four.jpg)。然后，更新创建玩家或怪物实例的每个地方！[](five.jpg)，这样它现在就知道了*game*对象，并能告诉所有洞穴的位置。
- en: There! That’s a few more rough edges smoothed off your game. There’s plenty
    left to do, but you won’t be writing any new features for the game now. Instead,
    you’ll focus on making the infrastructure around the game a bit more robust, so
    players won’t be put off by having all their hard work disappear.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧！你已经平滑掉了一些游戏的粗糙边缘。还有很多事情要做，但现在你不会为游戏编写任何新功能。相反，你将专注于使游戏的基础设施更加稳健，这样玩家就不会因为所有辛勤工作都消失而感到沮丧。
- en: Making your life easier
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使你的生活更轻松
- en: If you only want to write the game for your friends, you can probably stop here;
    they can connect and play your game, after all. Currently, though, there are still
    a few issues that will make your life harder than it needs to be. Anyone can log
    on as anyone else, so the game isn’t particularly secure; and the game doesn’t
    save any progress, so every time you restart the game server, the player will
    have to start over from scratch.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想为你的朋友编写游戏，你可能可以在这里停止；毕竟，他们可以连接并玩你的游戏。然而，目前还有一些问题会使你的生活比必要的更艰难。任何人都可以以任何人的身份登录，所以游戏并不特别安全；而且游戏不保存任何进度，所以每次你重新启动游戏服务器时，玩家都必须从头开始。
- en: Let’s fix that. You’ll add usernames and passwords to the game, as well as a
    mechanism to allow new players to register. Once you know who’s logged on, you
    can save the players’ progress every so often, and also when they quit the game.
    You’ll need to learn a bit more about Twisted, though, because you’ll be digging
    into the guts of one of its Telnet classes. But don’t worry; it’s straightforward
    once you get the hang of it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决这个问题。你需要在游戏中添加用户名和密码，以及一个允许新玩家注册的机制。一旦你知道谁登录了，你就可以不时地保存玩家的进度，以及他们在退出游戏时。但是，你还需要更多地了解Twisted，因为你将深入挖掘其Telnet类的一个核心。不过，别担心；一旦你掌握了诀窍，它就很简单了。
- en: Exploring unfamiliar code
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 探索不熟悉的代码
- en: 'Twisted is a large codebase and has a huge number of modules to help you network
    your application. That’s great, because it means you don’t have to write your
    own code to handle the networking in your application, but it raises a related
    problem: you must have at least a basic understanding of how everything fits together
    before you can make use of all that great code.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Twisted是一个大型代码库，拥有大量的模块来帮助你网络化你的应用程序。这很好，因为它意味着你不需要编写自己的代码来处理应用程序中的网络，但它也引发了一个相关问题：在能够利用所有这些优秀代码之前，你必须至少对它们如何组合在一起有一个基本的了解。
- en: Ideally, the documentation for libraries like Twisted would be 100% up-to-date
    and cover everything you need to do with a nice, gentle introduction—but this
    isn’t always the case. Often, you’ll be able to find something close, but then
    you’ll need to piece together how the code works with some guessing, experimentation,
    and detective work.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，像Twisted这样的库的文档应该是100%最新的，并涵盖你需要做的所有事情，有一个优雅的、温和的介绍——但这并不总是如此。通常，你可能会找到一些接近的内容，但之后你需要通过一些猜测、实验和侦探工作来拼凑代码的工作方式。
- en: It sounds hard, but in practice it’s usually pretty easy. The trick is not to
    get too overwhelmed, and to use *all* the resources at your disposal. Here are
    some ideas on how you can get a grip on a large codebase and make it work in your
    application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很难，但在实践中通常相当简单。关键是不要过于不知所措，并使用你所能利用的所有资源。以下是一些关于如何掌握大型代码库并在你的应用程序中使用它的想法。
- en: '![](f0341-01.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0341-01.jpg)'
- en: Find an Example
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查找一个示例
- en: Searching for “twisted tutorial” online gives you a number of starting points,
    and you can also add “telnet” or “telnet protocol” into the mix. As you learn
    more about Twisted, you’ll find other keywords or method names that will help
    you narrow down what you’re looking for. You can also start with a working example
    that sort of does what you need, and then tweak it until it covers exactly what
    you need it to do.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在网上搜索“twisted教程”会给你提供一些起点，你还可以在搜索中加入“telnet”或“telnet协议”。随着你对Twisted了解的深入，你会发现其他关键词或方法名，这些可以帮助你缩小搜索范围。你也可以从一个类似你需要的功能的示例开始，然后调整它，直到它完全满足你的需求。
- en: The Twisted Documentation
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 扭曲的文档
- en: There’s reasonably comprehensive documentation available in the Conch section
    of the main Twisted site, [http://twistedmatrix.com/documents/](http://twistedmatrix.com/documents/),
    but it doesn’t cover all of what you need to do. There are some simple examples
    of SSH and Telnet servers, which you can skim through to get an idea of how everything
    fits together.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Twisted主站点的Conch部分提供了相当全面的文档，[http://twistedmatrix.com/documents/](http://twistedmatrix.com/documents/)，但它并没有涵盖你需要做的所有事情。有一些简单的SSH和Telnet服务器示例，你可以快速浏览以了解一切是如何组合在一起的。
- en: The Twisted API Docs
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Twisted API文档
- en: 'Detailed, automatically generated documentation is available for the entire
    Twisted codebase, which you can see at [http://twistedmatrix.com/documents/current/api/](http://twistedmatrix.com/documents/current/api/).
    Don’t let the sheer number of packages put you off—we’ll focus on the Telnet one:
    [http://twistedmatrix.com/documents/current/api/twisted.conch.telnet.html](http://twistedmatrix.com/documents/current/api/twisted.conch.telnet.html).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 详细且自动生成的文档适用于整个Twisted代码库，你可以在[http://twistedmatrix.com/documents/current/api/](http://twistedmatrix.com/documents/current/api/)中查看。不要让包的数量让你却步——我们将专注于Telnet包：[http://twistedmatrix.com/documents/current/api/twisted.conch.telnet.html](http://twistedmatrix.com/documents/current/api/twisted.conch.telnet.html)。
- en: The Twisted Code
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Twisted代码
- en: You can also read most of the Twisted code directly. The Windows version of
    Python stores its libraries at C:\Python26\Lib\site-packages\twisted; under Linux,
    it will be somewhere like /usr/lib/python2.6/ dist-packages/twisted; and under
    Mac, it’s usually at /Developer/SDKs/ MacOSX10.6.sdk/System/Library/Frameworks/Python.framework/
    Versions/2.5/Extras/lib/python/twisted. All the Twisted code is stored there,
    and you can open the files and read the code to find out exactly what a method
    does.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以直接阅读Twisted的大部分代码。Windows版本的Python将它的库存储在C:\Python26\Lib\site-packages\twisted；在Linux下，它可能位于类似/usr/lib/python2.6/dist-packages/twisted的位置；在Mac下，通常在/Developer/SDKs/MacOSX10.6.sdk/System/Library/Frameworks/Python.framework/Versions/2.5/Extras/lib/python/twisted。所有的Twisted代码都存储在那里，你可以打开文件并阅读代码，以了解一个方法的确切功能。
- en: Introspection
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 反省
- en: If a library doesn’t have API documentation, all is not lost. You can still
    create instances of classes and use *dir()*, *help()*, and *method.__doc__*to
    find out what they do. If you have a one-off method you need to know about, this
    can often be easier than reading the code or documentation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图书馆没有API文档，也并非全无希望。你仍然可以通过创建类的实例和使用 *dir()*, *help()*, 以及 *method.__doc__*
    来了解它们的功能。如果你需要了解某个一次性方法，这通常比阅读代码或文档要简单。
- en: In practice, none of these sources will cover all the details you need to know
    when writing your program, so you’ll end up using a combination of them going
    back and forth as you learn new parts or run into problems.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些资源中的任何一个都不会涵盖你编写程序时需要了解的所有细节，所以你将结合使用它们，在学习新部分或遇到问题时来回切换。
- en: Putting it all together
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: Let’s get started putting together your login system. From a quick scan of Twisted’s
    *Telnet* module, it looks like the best starting point is the *AuthenticatingTelnetProtocol*
    class. You’ll get that working with your code, then make it register new players,
    and finally make the game able to save player data.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建你的登录系统。快速浏览Twisted的 *Telnet* 模块后，看起来最佳的起点是 *AuthenticatingTelnetProtocol*
    类。你将使用你的代码来实现它，然后让它注册新玩家，最后让游戏能够保存玩家数据。
- en: To start with, I looked at the Twisted documentation and the API reference for
    *AuthenticatingTelnetProtocol*. It sort of made sense, but from the methods and
    classes it’s hard to see how to tie everything together. The protocol needs a
    *Portal*, which in turn depends on a *Realm*, an *Avatar*, and a *PasswordChecker*.
    Hmm, confusing. It looks like it’s time to try to find an example of how the classes
    fit together.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我查阅了Twisted文档和 *AuthenticatingTelnetProtocol* 的API参考。它似乎有些道理，但从方法和类中很难看出如何将它们全部联系起来。协议需要一个
    *Portal*，而它又依赖于 *Realm*，*Avatar* 和 *PasswordChecker*。嗯，有点复杂。看起来是时候尝试找到一个类如何组合在一起的例子了。
- en: '![](f0342-01.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](f0342-01.jpg)'
- en: 'There are a few different searches you could try: “twisted telnet,” “twisted
    telnet example,” and so on, but I didn’t find much until I put in some terms from
    the code. The search “twisted telnet TelnetProtocol example” led me to [www.mail-archive.com/twisted-python@twistedmatrix.com/msg01490.html](http://www.mail-archive.com/twisted-python@twistedmatrix.com/msg01490.html),
    which, if you follow it through to the end, gives you some example code that is
    enough to see how the classes work together.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试几种不同的搜索： “twisted telnet”，“twisted telnet example”，等等，但我没有找到太多信息，直到我输入了一些代码中的术语。搜索“twisted
    telnet TelnetProtocol example”将我带到了 [www.mail-archive.com/twisted-python@twistedmatrix.com/msg01490.html](http://www.mail-archive.com/twisted-python@twistedmatrix.com/msg01490.html)，如果你跟到底，你会得到一些示例代码，足以看到类是如何一起工作的。
- en: 'The basic gist is something like this: set up a *Realm* class, along with a
    *Portal* to get into it. The docs don’t say whether it’s a *magic* portal, but
    it should do. A *Portal* controls access to your *Realm*, using one or more password
    *Checker*s, via a *TelnetTransport*. Of course, the *Authenticating-TelnetProtocol*
    only handles authentication, so you’ll need to hand off to another protocol like
    your *MudProtocol* once you’re logged in.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思路是这样的：设置一个 *Realm* 类，以及一个进入它的 *Portal*。文档没有说明它是否是一个 *magic* portal，但应该可以。*Portal*
    通过一个或多个密码 *Checker*，通过 *TelnetTransport* 控制对 *Realm* 的访问。当然，*Authenticating-TelnetProtocol*
    只处理认证，所以一旦登录，你需要将控制权交给另一个协议，比如你的 *MudProtocol*。
- en: Got all that? No, me neither. I had to draw a picture to see how it all worked,
    and without the example I probably would’ve been lost. [Figure 10.5](#ch10fig05)
    shows what I came up with.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 理解了吗？不，我也没有。我不得不画一张图来弄清楚它是如何工作的，没有示例代码，我可能就会迷失方向。[图10.5](#ch10fig05) 展示了我得出的结果。
- en: Figure 10.5\. The Twisted class structure
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.5. Twisted类结构
- en: '![](10fig05.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig05.jpg)'
- en: Using the diagram and the example code, you can get a simple login going. The
    following listing shows how I changed the mudserver.py file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用图表和示例代码，你可以启动一个简单的登录。以下列表显示了我是如何修改 mudserver.py 文件的。
- en: Listing 10.11\. Mudserver.py
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.11. Mudserver.py
- en: '![](ch10list11-0.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10list11-0.jpg)'
- en: '![](ch10list11-1.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10list11-1.jpg)'
- en: To start, you’ll import all the bits of Twisted you need ![](one.jpg). There
    are a lot, but think of it as code you don’t have to write.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要导入Twisted中你需要的所有部分 ![](one.jpg)。虽然有很多，但你可以将其视为你不需要编写的代码。
- en: 'The *Realm* is the core class that represents your game’s login ![](two.jpg).
    You only need to override one method: the one to get an *Avatar*. *Avatar*s are
    instances of the *MudProtocol* and represent the player’s login. Notice that you
    set the player’s name so you have access to it in *MudProtocol*, and set *state*
    to *"Command"*; otherwise, you’ll get logged out right away.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*Realm* 是表示你的游戏登录的核心类 ![two.jpg](https://example.org/two.jpg)。你只需要重写一个方法：获取一个
    *Avatar*。*Avatar* 是 *MudProtocol* 的实例，代表玩家的登录。请注意，你设置了玩家的名字，这样你就可以在 *MudProtocol*
    中访问它，并将 *state* 设置为 *"Command"*；否则，你将立即被注销。'
- en: '|  |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The “code that you don’t have to write” part is important. It’s easy to overestimate
    how hard it is to learn how existing code works, and underestimate how hard it
    is to write new code that’s as well tested.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: “你不必编写的代码”这部分很重要。人们很容易高估学习现有代码的难度，而低估编写经过良好测试的新代码的难度。
- en: '|  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: While you’re figuring out how everything works, it’s perfectly fine to print
    out things to the screen to try and work out what each object does ![](three.jpg).
    You can use what you learn to search online, or through the code to find out what
    else uses these classes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在弄清楚一切是如何工作的同时，将一些信息打印到屏幕上以尝试弄清楚每个对象的功能是完全正常的 ![three.jpg](https://example.org/three.jpg)。你可以使用你所学到的知识在网上搜索，或者通过代码来查找使用这些类的其他内容。
- en: Most of *MudProtocol* is unchanged, but you’ll need to know your player’s username
    and password for later ![](four.jpg), when you start saving to a file. The *Realm*
    has already given you the username, so you can use that to get the password from
    the checker. The other thing you change is the *connectionLost* method—if you
    lose the connection to the player, you want to clean up properly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分的 *MudProtocol* 都没有改变，但你将需要知道玩家的用户名和密码，以便在稍后 ![four.jpg](https://example.org/four.jpg)
    开始将数据保存到文件时使用。*Realm* 已经为你提供了用户名，因此你可以使用它从 checker 中获取密码。你还需要更改的另一件事是 *connectionLost*
    方法——如果你失去了与玩家的连接，你想要正确地清理。
- en: '![](f0346-01.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![f0346-01.jpg](https://example.org/f0346-01.jpg)'
- en: Now we’re into the section where you set the code in motion. The first thing
    to do is create a *Realm* and then attach a *Portal* and *Checker*s to it. Once
    you’ve done that, you can insert usernames and passwords into your checker ![](five.jpg).
    *InMemory..DontUse* is fine for your purposes, even though, in theory, it’s insecure
    and you’re not supposed to use it. There’s also a file-based checker available,
    but it doesn’t support saving new users back to the file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进入了设置代码运行的章节。首先要做的是创建一个 *Realm*，然后将其与一个 *Portal* 和 *Checker* 相关联。一旦完成这些，你就可以将用户名和密码插入到你的
    checker 中 ![five.jpg](https://example.org/five.jpg)。*InMemory..DontUse* 对于你的目的来说是可以的，尽管在理论上它是不安全的，你不应该使用它。还有一个基于文件的
    checker，但它不支持将新用户保存回文件。
- en: Now that you’re using *TelnetTransport* and your *Realm* to control things,
    you don’t need a custom Factory, and you won’t need to manually track the clients
    in the factory any more ![](six.jpg). The *TelnetTransport* will use *AuthenticatingTelnetProtocol*
    to handle usernames and passwords, but once that’s done it will hand off to the
    *Realm* to get the final protocol.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你正在使用 *TelnetTransport* 和你的 *Realm* 来控制事物，你不需要自定义 Factory，而且你也不再需要手动在工厂中跟踪客户端
    ![six.jpg](https://example.org/six.jpg)。*TelnetTransport* 将使用 *AuthenticatingTelnetProtocol*
    来处理用户名和密码，但一旦完成，它将转交给 *Realm* 来获取最终的协议。
- en: One last thing is that Twisted uses Python’s log facility. To see what it’s
    up to, you can add this line ![](seven.jpg), which will redirect the logging to
    *sys.stdout*—that is, print it on the screen.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情是，Twisted 使用 Python 的日志功能。要查看它在做什么，你可以添加这一行 ![seven.jpg](https://example.org/seven.jpg)，这将把日志重定向到
    *sys.stdout*——也就是说，打印到屏幕上。
- en: What does all this give you? Well, if you run your server now and try to connect
    to it, you should be presented with a login request instead of a password, similar
    to what’s shown in [figure 10.6](#ch10fig06). If you enter the username and password
    that are in the script, you should connect to the game.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些给你带来了什么？好吧，如果你现在运行你的服务器并尝试连接到它，你应该会看到一个登录请求而不是密码，类似于图 10.6 中所示。[图 10.6](#ch10fig06)。如果你输入脚本中存在的用户名和密码，你应该可以连接到游戏。
- en: Figure 10.6\. Logging in to your game
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.6\. 登录到你的游戏
- en: '![](10fig06.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![10fig06.jpg](https://example.org/10fig06.jpg)'
- en: That’s not all you need to do, though. Remember that you want to allow players
    to register their own username and password. For that you’ll have to learn a bit
    more about Twisted.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你还需要做更多的事情。记住，你想要允许玩家注册自己的用户名和密码。为此，你需要学习更多关于 Twisted 的知识。
- en: Write your own state machine
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写你自己的状态机
- en: What you’re going to do in this section is create a subclass of the class you’ve
    been using so far, which is *AuthenticatingTelnetProtocol*. It’s what generates
    the *User-name:* and *Password:* prompts in the login. What you’d like instead
    is a prompt that asks the player whether they want to log in or register a new
    account. If it’s a registration, then it still asks you for a username and password,
    but creates the account instead of checking whether it exists.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将要创建一个类的子类，该类是你迄今为止一直在使用的 *AuthenticatingTelnetProtocol*。它是生成登录时 *User-name:*
    和 *Password:* 提示的类。你想要的提示是询问玩家他们是否想要登录或注册新账户。如果是注册，它仍然会要求你输入用户名和密码，但会创建账户而不是检查它是否存在。
- en: '![](f0347-01.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](f0347-01.jpg)'
- en: Let’s first take a look at *AuthenticatingTelnetProtocol*, to see how it’s done.
    You can find the Telnet module on your computer at C:\Python26\Lib\site-packages\twisted\conch\telnet.py,
    or somewhere like /usr/lib/python2.6/ site-packages/twisted/conch/telnet.py if
    you’re using Linux or MacOS X. If you open that file and scroll to the bottom,
    you’ll find the class you’re looking for; it’s also shown in [listing 10.12](#ch10list12).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 *AuthenticatingTelnetProtocol*，看看它是如何实现的。你可以在你的计算机上找到 Telnet 模块，位置在 C:\Python26\Lib\site-packages\twisted\conch\telnet.py，或者如果你使用
    Linux 或 MacOS X，可能在 /usr/lib/python2.6/ site-packages/twisted/conch/telnet.py。如果你打开该文件并滚动到最底部，你会找到你正在寻找的类；它也在
    [列表 10.12](#ch10list12) 中显示。
- en: Listing 10.12\. Twisted’s `AuthenticatingTelnetProtocol` class
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.12\. Twisted 的 `AuthenticatingTelnetProtocol` 类
- en: '![](ch10list12-0.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10list12-0.jpg)'
- en: '![](ch10list12-1.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10list12-1.jpg)'
- en: All the *Telnet* classes we’ve looked at so far are state machines—there are
    multiple steps involved in logging in, and the next one depends on the input you
    get. You’re initially in the *"User"* state, which means input is fed to the *telnet_User*
    method ![](one.jpg). Each method returns a string, which determines the next state.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所查看的所有 *Telnet* 类都是状态机——登录涉及多个步骤，下一个步骤取决于你获得的输入。你最初处于 *"User"* 状态，这意味着输入被馈送到
    *telnet_User* 方法！[](one.jpg)。每个方法返回一个字符串，该字符串确定下一个状态。
- en: '![](f0348-01.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](f0348-01.jpg)'
- en: 'There are a few other methods: *connectionMade* and *connectionLost*, but you
    don’t need to deal with them in this case ![](two.jpg).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种其他方法：*connectionMade* 和 *connectionLost*，但在这个情况下你不需要处理它们！[](two.jpg)。
- en: The first line (after the initial greeting) goes to *telnet_User* and sets the
    username within the instance ![](three.jpg). The *transport.will()* call tells
    the local client that the server (that is, you) will be responsible for echoing
    anything the user types—but in this case, it’s the password, so you don’t. Then
    *"Password"* is returned, so the next line goes to *telnet_Password*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行（在初始问候之后）发送到 *telnet_User* 并在实例中设置用户名！[](three.jpg)。*transport.will()* 调用告诉本地客户端服务器（即你）将负责回显用户输入的任何内容——但在这种情况下，是密码，所以你不需要。然后返回
    *"Password"*，所以下一行发送到 *telnet_Password*。
- en: Now that you have the password, you can compare it with what you have for that
    username in the portal’s password checker ![](four.jpg).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了密码，你可以将其与门户密码检查器中为该用户名存储的内容进行比较！[](four.jpg)。
- en: 'Twisted has a mechanism called a *Deferred*, that helps to speed up the server
    ![](five.jpg). A password checker might look at a file on disk, or connect to
    a different server to see whether the password is correct. If it waits for the
    result (normally known a *blocking*), nobody else will be able to do anything
    until the disk or remote server responds. Deferred objects are a way to say “When
    we get a response, handle it with this function” and then continue with other
    tasks. There are two possibilities: a callback and an error back.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Twisted 有一个称为 *Deferred* 的机制，有助于加快服务器速度！[](five.jpg)。密码检查器可能会查看磁盘上的文件，或者连接到不同的服务器以查看密码是否正确。如果它等待结果（通常称为
    *blocking*），那么在磁盘或远程服务器响应之前，其他人将无法做任何事情。Deferred 对象是一种表示“当我们得到响应时，用这个函数处理它”然后继续其他任务的方式。有两种可能性：回调和错误回传。
- en: If the checker responds that the password is right ![](six.jpg), you can go
    ahead and do the rest of the login, which means storing some values, setting your
    state to *"Command"*, and switching out your protocol for the final one.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检查器响应密码正确！[](six.jpg)，你可以继续进行登录的其余部分，这意味着存储一些值，将你的状态设置为 *"Command"*，并切换你的协议到最后一个。
- en: If the checker tells you the password or the username is wrong ![](seven.jpg),
    then you can tell the user off and switch back to the *"User"* state. The user
    will need to type in the username and password again—and you the user will get
    it right this time.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检查器告诉你密码或用户名错误 ![](seven.jpg)，那么你可以责备用户并切换回 *"User"* 状态。用户将需要再次输入用户名和密码——而且这次你会输入正确。
- en: How can you subclass *AuthenticatingTelnetProtocol*? The answer is to add some
    new states so there’s a registration branch as well as the normal login one, similar
    to the flowchart in [figure 10.7](#ch10fig07).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何子类化 *AuthenticatingTelnetProtocol*？答案是添加一些新状态，以便有一个注册分支以及正常的登录分支，类似于 [图 10.7](#ch10fig07)
    中的流程图。
- en: Figure 10.7\. The states in `RegisteringTelnet-Protocol`
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.7\. `RegisteringTelnet-Protocol` 中的状态
- en: '![](10fig07.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](10fig07.jpg)'
- en: The next listing adds a new protocol with three extra states—*"Welcome"*, *"NewUserName"*,
    and *"New Password"*—along with methods to handle each of them.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表添加了一个新的协议，包含三个额外的状态—*"Welcome"*、*"NewUserName"* 和 *"New Password"*—以及处理每个状态的方法。
- en: Listing 10.13\. `RegisteringTelnetProtocol`
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.13\. `RegisteringTelnetProtocol`
- en: '![](ch10list13-0.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10list13-0.jpg)'
- en: '![](ch10list13-1.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](ch10list13-1.jpg)'
- en: Welcoming the user to the server ![](one.jpg) is pretty much the same as the
    previous example, only with different values. You’re prompting the user to enter
    *R* to register or *L* to login.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎用户连接到服务器 ![](one.jpg) 与上一个例子几乎相同，只是有不同的值。你提示用户输入 *R* 进行注册或 *L* 进行登录。
- en: '![](f0351-01.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](f0351-01.jpg)'
- en: 'Because your previous state was *"Welcome"*, the first method is *telnet_Welcome*.
    The code is straightforward: *R* sets the state to *"NewUser-Name"*, *L* to *"User"*,
    and anything else will kick them back to *"Welcome"*![](two.jpg). *telnet_NewUserName*
    is the same as *telnet_User*, too ![](three.jpg). It prompts slightly differently
    and passes to a different state: *"NewPassword"* instead of *"Password"*.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你的上一个状态是 *"Welcome"*，第一个方法是 *telnet_Welcome*。代码很简单：*R* 将状态设置为 *"NewUser-Name"*，*L*
    为 *"User"*，其他任何操作都会将他们踢回 *"Welcome"*![](two.jpg)。*telnet_NewUserName* 与 *telnet_User*
    相同 ![](three.jpg)。它提示的方式略有不同，并传递到不同的状态："NewPassword"* 而不是 *"Password"*。
- en: Of course, you can’t have two Gandalfs or Conans running around your server,
    so you need to check that the username doesn’t already exist on the server ![](four.jpg).
    If it does, you kick the user back to *"Welcome"*. Pick something more original!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不能有两个甘道夫或康纳在服务器周围跑来跑去，所以你需要检查用户名是否已经在服务器上存在 ![](four.jpg)。如果存在，将用户踢回 *"Welcome"*。选择一个更有创意的名字！
- en: Now that the player has passed all the hurdles you’ve set, you should probably
    add the player to the server ![](five.jpg). To make life easier for the player,
    you also automatically log the player in.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家已经通过了你设置的障碍后，你可能会想将玩家添加到服务器 ![](five.jpg)。为了使玩家更容易，你还会自动登录玩家。
- en: The last bit didn’t add the user, it only pretended to. ![](six.jpg) will do
    the trick. You’re calling each of your checkers in turn and calling their *addUser*
    method. Note that this won’t work if you use the file-based checker, *twisted.cred.FilePasswordDB*—or
    at least not permanently, because it won’t write the players back to the file.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分并没有添加用户，只是假装添加了。![](six.jpg) 将会起作用。你依次调用你的检查器，并调用它们的 *addUser* 方法。注意，如果你使用基于文件的检查器，*twisted.cred.FilePasswordDB*，这不会起作用——至少不会永久起作用，因为它不会将玩家写回文件。
- en: If the login raises an error, you should return to the initial *"Welcome"* state
    ![](seven.jpg), rather than to *"User"*, so the user can register instead if the
    user can’t remember their username (or if you’ve deleted it for some reason).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果登录引发错误，你应该返回初始的 *"Welcome"* 状态 ![](seven.jpg)，而不是 *"User"*，这样用户就可以在忘记用户名（或者由于某些原因你删除了它）时进行注册。
- en: Finally, you need to update your factory’s protocol so it uses *Registering-TelnetProtocol*
    instead of the old *AuthenticatingTelnetProtocol* ![](eight.jpg).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要更新你工厂的协议，使其使用 *Registering-TelnetProtocol* 而不是旧的 *AuthenticatingTelnetProtocol*
    ![](eight.jpg)。
- en: Awesome! Now you won’t have to enter usernames and passwords for everyone who
    wants to check out your cool new game. In practice, this will mean you’ll get
    more players, because it sets the bar to entry much lower, and the players won’t
    have to wait around for you to check your email. The next step, if you’re interested,
    is to include a password-reset or -retrieval mechanism, so the players (if they’ve
    set their email address in-game) can be sent their password if they forget it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你不必为想要体验你酷炫新游戏的每个人输入用户名和密码。在实践中，这意味着你会得到更多的玩家，因为这将降低进入门槛，玩家不必等待你检查电子邮件。如果你感兴趣，下一步是包括一个密码重置或检索机制，这样玩家（如果他们在游戏中设置了电子邮件地址）就可以在忘记密码时收到他们的密码。
- en: Making your world permanent
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使你的世界永久化
- en: 'You have a few more pressing concerns now: players can register and log in,
    but if you restart the server for some reason (say, to add a new feature), then
    they lose all their progress and have to reregister! You don’t have to save *everything*,
    though—what you’ll do is save only the players and their items and restart all
    the monsters from scratch. This is common practice in most MUDs, so the monsters,
    puzzles, and stories reset each night.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你还有一些更紧迫的问题：玩家可以注册和登录，但如果由于某种原因（比如，为了添加新功能）重新启动服务器，那么他们就会失去所有进度并需要重新注册！虽然你不必保存
    *一切*，但你将只保存玩家及其物品，并从零开始重新启动所有怪物。这在大多数MUD中是常见做法，因此怪物、谜题和故事每晚都会重置。
- en: '|  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: One of the other reasons to implement saving is that it breaks the player’s
    suspension of disbelief if everything suddenly vanishes. You want the player to
    believe on some level that the world you’re creating is real, and real worlds
    don’t disappear in a puff of virtual smoke.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 实现保存的另一个原因是，如果一切突然消失，这会打破玩家的信念。你希望玩家在某种程度上相信你创造的世界是真实的，而真实的世界不会在虚拟烟雾中消失。
- en: '|  |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing 10.14\. Loading players
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.14\. 加载玩家
- en: '![](10list14_alt.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![10list14_alt.jpg](10list14_alt.jpg)'
- en: You don’t need to store every player, because you’re only interested in players’
    data—what they’ve called themselves, how they look and which items they’re carrying.
    You’ll put that information into the store ![](one.jpg) so you can call it out
    at will.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要存储每个玩家，因为你只对玩家的数据感兴趣——他们叫什么名字，他们看起来如何，他们携带哪些物品。你将把那些信息放入存储！![one.jpg](one.jpg)，这样你就可以随意调用它。
- en: The next thing you’ll do is figure out how you’re going to call the code you’ll
    use to load the player store ![](two.jpg). I think you’ll be alright if you create
    a method.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，你需要想清楚如何命名用于加载玩家存储的代码！![two.jpg](two.jpg)。我认为如果你创建一个方法，应该没问题。
- en: The method to load the player store ![](three.jpg) turns out to be pretty simple.
    Check to see if the file exists—if it does, then open it and load the *player_store*
    from it using Pickle.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 加载玩家存储的方法！![three.jpg](three.jpg)实际上非常简单。检查文件是否存在——如果存在，则打开它，并使用Pickle从其中加载
    *player_store*。
- en: Easy! Of course, you’re not done yet—that only loads the player store. Now you
    need to work out what goes in the store, and save it to a file.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单！当然，你还没有完成——这只是为了加载玩家存储。现在你需要确定存储中应该包含什么，并将其保存到文件中。
- en: Listing 10.15\. Saving players
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.15\. 保存玩家
- en: '![](10list15_alt.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![10list15_alt.jpg](10list15_alt.jpg)'
- en: You add each player to the player store in typical object-oriented fashion—by
    calling *player.save* to find out what should be stored for each player ![](one.jpg).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你会以典型的面向对象方式将每个玩家添加到玩家存储中——通过调用 *player.save* 来找出每个玩家应该存储什么！![one.jpg](one.jpg)。
- en: Once you’ve refreshed the store, you can go ahead and save it to disk ![](two.jpg),
    ready for the next time you start the game.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你刷新了存储，你就可以继续将其保存到磁盘上！![two.jpg](two.jpg)，以便下次启动游戏时使用。
- en: All the *player.save* method needs to do is make a dictionary of all of the
    player’s data and return it ![](three.jpg).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*player.save* 方法需要做的只是创建一个包含所有玩家数据的字典，并返回它！![three.jpg](three.jpg)。'
- en: Now your *game.save* method should be working, and you can load from it. The
    last step is to trigger *game.save* at appropriate points and make sure the players
    are loaded with all their data when they log in.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的 *game.save* 方法应该可以正常工作，你可以从中加载。最后一步是在适当的位置触发 *game.save*，并确保玩家在登录时携带所有数据。
- en: Listing 10.16\. Updating the server
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.16\. 更新服务器
- en: '![](ch10list16-0.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![ch10list16-0.jpg](ch10list16-0.jpg)'
- en: '![](ch10list16-1.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![ch10list16-1.jpg](ch10list16-1.jpg)'
- en: Loading the player is much the same as saving it ![](one.jpg), only the other
    way around. Rather than dump your state into a dictionary, you update the state
    from one.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 加载玩家与保存它！![one.jpg](one.jpg)非常相似，只是方向相反。你不需要将状态倒入字典，而是从另一个状态更新状态。
- en: Rather than have the players die whenever they quit, they’ll now save themselves
    and exit nicely ![](two.jpg). For this game you only have one sword and one coin
    to share among all the players, so you’ll drop all your items; but that’s not
    normal practice for an adventure game.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是让玩家在退出时死亡，他们现在会保存自己并优雅地退出 ![two.jpg](two.jpg)。对于这个游戏，你只有一把剑和一个金币要与其他所有玩家共享，所以你会丢弃所有物品；但这不是冒险游戏的正常做法。
- en: To save everything ![](three.jpg), you’ll set up another periodic function using
    Twisted.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存一切 ![three.jpg](three.jpg)，你需要使用 Twisted 设置另一个周期性函数。
- en: The players can change their passwords in game, so it makes sense to refresh
    the server’s password list along with saving the game ![](four.jpg). You do this
    right after the call to *game.save()*, so you know *game.player_store* is as fresh
    as possible.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以在游戏中更改他们的密码，因此随着游戏的保存刷新服务器的密码列表是有意义的 ![four.jpg](four.jpg)。你会在调用 *game.save()*
    之后立即这样做，这样你就知道 *game.player_store* 是尽可能新鲜的。
- en: '![](f0355-01.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![f0355-01.jpg](f0355-01.jpg)'
- en: 'Note that there’s a bug in this code: when a player changes their name, the
    old name isn’t removed. You’ll want to either update the name-changing code in
    *Player* to delete the old name from both the portals and *player_store*, or else
    disable the name-changing code. Disallowing name changes is probably the best
    option, because it also discourages bad behavior.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码中有一个错误：当玩家更改他们的名字时，旧名字不会被删除。你将想要更新 *Player* 中的名字更改代码以从门户和 *player_store*
    中删除旧名字，或者禁用名字更改代码。禁止名字更改可能是最好的选择，因为它也阻止了不良行为。
- en: Once your function is complete, you only call it when you start up, and every
    minute or so after that ![](five.jpg). I’ve picked 60 seconds as a reasonable
    timeframe, but you might find that a longer or shorter span works better for you.
    In practice, it will be a tradeoff between the load on the server when the game
    is saved, and the risk of losing your players’ stuff.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的函数完成，你只需在启动时调用它，之后每分钟或大约如此调用一次 ![five.jpg](five.jpg)。我选择了60秒作为一个合理的时间框架，但你可能会发现更长或更短的时间间隔更适合你。实际上，这将在游戏保存时服务器的负载和失去玩家物品的风险之间进行权衡。
- en: That should be it. Now you have a stable base for your future development, and
    you don’t have to worry about players not being able to log in, or having to respond
    to everyone who wants to log in.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在你有一个稳定的未来开发基础，你不必担心玩家无法登录，或必须回应所有想要登录的人。
- en: Where to from here?
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: 'Your MUD is working and feature complete, but you’ve only scratched the surface
    of what you could do. One way to find out what needs to be done is to invite some
    of your friends to play—make sure they know it’s a work in progress—and ask them
    for suggestions and bug fixes. If you don’t have any friends who are into MUDs,
    the following is a list of some ideas you could try:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 MUD 正在运行且功能完整，但你只是触及了你可以做到的表面。了解需要做什么的一种方法是将一些朋友邀请来玩——确保他们知道这是一个正在进行的项目——并征求他们的建议和错误修复。如果你没有对
    MUD 感兴趣的朋友，以下是一些你可以尝试的想法：
- en: Make the orc respawn once you’ve killed it (in a different location), or add
    different monsters. They might have different attacks, take more or fewer hits
    to kill, and drop different sorts of treasure.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杀死它（在另一个位置）后让兽人重生，或者添加不同的怪物。它们可能有不同的攻击方式，需要更多或更少的攻击才能杀死，并掉落不同类型的宝藏。
- en: Saving the cave layout as well as the players’ info will help players identify
    it more strongly as an actual place. Also, most MUDs will let you log in as a
    “wizard” and extend the game while you’re playing it, adding rooms or monsters.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存洞穴布局以及玩家信息将帮助玩家更强烈地将其视为一个实际的地方。此外，大多数 MUD 都允许你以“巫师”的身份登录并在游戏过程中扩展游戏，添加房间或怪物。
- en: Different items, armor, and weapons can add an extra level of interest, as players
    explore or save up their gold for new ones.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的物品、盔甲和武器可以为玩家探索或存钱购买新物品增添额外的兴趣。
- en: '![](f0356-01.jpg)'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![f0356-01.jpg](f0356-01.jpg)'
- en: Let the players gain experience and levels, with higher-level characters being
    tougher and more powerful. Different character classes and statistics (strength,
    intelligence, dexterity, and so on) can help players identify with the game and
    make it more enjoyable.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让玩家获得经验和等级，高级角色更难对付且更强大。不同的角色类别和统计数据（力量、智力、敏捷等）可以帮助玩家认同游戏并使其更加有趣。
- en: A number of open source MUDs are available, in several languages; download them
    and see how they work. Most of the core components will be similar, so you’ll
    know what to look for when you’re trying to make sense of them.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多开源的MUD游戏可供选择，它们使用了几种不同的语言；下载它们并看看它们是如何工作的。大多数核心组件将是相似的，所以当你试图理解它们时，你会知道该寻找什么。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to add networking to a game and about the issues
    you need to deal with in networked environments. You started with a simple chat
    server and learned about Twisted’s *Protocol* and *Server* classes, before creating
    a similar setup so you could play your game over Telnet. Because Twisted is asynchronous
    (does lots of things simultaneously), you also needed to learn how to use Twisted’s
    *task.LoopingCall* for your game loop.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何将网络功能添加到游戏中，以及在网络环境中需要处理的问题。你从一个简单的聊天服务器开始，学习了Twisted的*协议*和*服务器*类，然后创建了一个类似的设置，以便你可以在Telnet上玩游戏。因为Twisted是异步的（同时做很多事情），你还需要学习如何使用Twisted的*task.LoopingCall*来实现你的游戏循环。
- en: Once you’d done that, you opened your game for testing and discovered a few
    issues with the game play in the new environment. To fix these, you added some
    new features, such as angry lists, talking to other players, and commands to change
    player names and descriptions.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了这些，你就对你的游戏进行了测试，并发现了在新环境中游戏玩法的一些问题。为了修复这些问题，你添加了一些新功能，例如愤怒列表、与其他玩家交谈，以及更改玩家名称和描述的命令。
- en: Finally, you set up a system so new players could log into your system without
    you having to add them to a list of users. You learned a bit more about the details
    of Twisted, particularly its Telnet implementation, but also about how it interfaces
    with *Protocol*s, *Server*s, and also *Deferred*s—one of Twisted’s lower-level
    features.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你设置了一个系统，新玩家可以登录到你的系统，而无需你将他们添加到用户列表中。你对Twisted的细节了解得更多了一些，特别是它的Telnet实现，但也了解了它是如何与*协议*、*服务器*以及*延迟*（Twisted的较低级功能之一）交互的。
