- en: 2 Graph thinking with GraphQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 使用 GraphQL 进行图思维
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Describing the requirements of our business review application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述我们业务审查应用的需求
- en: Translating requirements into GraphQL type definitions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将需求转换为 GraphQL 类型定义
- en: Implementing resolver functions for data fetching for these type definitions,
    using a naive approach
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一种简单的方法实现这些类型定义的数据获取解析函数
- en: Using Apollo Server to combine our type definitions and resolvers and serve
    a GraphQL endpoint
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Apollo Server 结合我们的类型定义和解析器来提供 GraphQL 端点
- en: Querying our GraphQL endpoint with Apollo Studio
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Apollo Studio 查询我们的 GraphQL 端点
- en: In this chapter, we will design a GraphQL API for a business review application.
    First, we will define the requirements of this application; then, we will describe
    a GraphQL API that addresses these requirements following a GraphQL-first development
    approach. We then explore how to implement the data fetching logic for this API.
    Finally, we explore how to combine our GraphQL type definitions and resolver functions
    to serve a GraphQL API using Apollo Server and to query it, using Apollo Studio.
    When building APIs, it is often useful to understand the data domain and the common
    access patterns—in other words, what are the problems to be solved by the API?
    The GraphQL-first development approach allows us to build APIs by first considering
    the data domain and defining a GraphQL schema describing that domain, which then
    serves as a blueprint for implementing the API.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为业务审查应用设计一个 GraphQL API。首先，我们将定义此应用的需求；然后，我们将描述一个遵循 GraphQL-first 开发方法的
    GraphQL API，以解决这些需求。然后，我们将探讨如何实现此 API 的数据获取逻辑。最后，我们将探讨如何结合我们的 GraphQL 类型定义和解析函数，使用
    Apollo Server 提供GraphQL API，并使用 Apollo Studio 进行查询。在构建 API 时，了解数据域和常见的访问模式通常很有用——换句话说，API
    要解决什么问题？GraphQL-first 开发方法允许我们在定义 GraphQL 类型定义后并行实现后端和前端系统。
- en: GraphQL-first development
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL-first 开发
- en: The GraphQL-first development paradigm is an approach for building applications
    that is driven by the GraphQL API design. The process begins by describing GraphQL
    type definitions synthesized from business requirements. These type definitions
    then become the basis for the API implementation, database data-fetching code,
    and client application code. GraphQL-first development is a powerful approach
    because it allows for parallel implementation of the backend and frontend systems
    once the GraphQL type definitions have been defined.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL-first 开发范式是一种以 GraphQL API 设计为驱动力的应用程序构建方法。该过程从描述由业务需求综合而成的 GraphQL
    类型定义开始。然后，这些类型定义成为 API 实现、数据库数据获取代码和客户端应用程序代码的基础。GraphQL-first 开发是一种强大的方法，因为它允许在定义
    GraphQL 类型定义后并行实现后端和前端系统。
- en: 2.1 Your application data is a graph
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 您的应用数据是一个图
- en: A *graph* is a fundamental data structure that is composed of nodes (the entities
    or objects) and relationships that connect nodes. Graphs are an intuitive model
    that can be used to represent many different domains. Often, when we go through
    the exercise of producing a data model by examining the business requirements
    of a domain, we end up drawing a diagram of the objects and arrows showing how
    they are connected. This is a graph!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图* 是由节点（实体或对象）和连接节点的边组成的基本数据结构。图是一个直观的模型，可以用来表示许多不同的领域。通常，当我们通过检查一个领域的业务需求来生成数据模型时，我们最终会绘制一个显示对象及其连接方式的图表。这就是图！'
- en: Let’s go through this process for our business reviews application. The requirements
    for our application are
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过我们的业务审查应用的过程。我们应用的需求是
- en: As a user, I want to search for a list of businesses by category, location,
    and name.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为用户，我想通过类别、位置和名称搜索企业列表。
- en: As a user, I want to view details for each business (name, description, address,
    photos, etc.).
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为用户，我想查看每个企业的详细信息（名称、描述、地址、照片等）。
- en: As a user, I want to view reviews for each business, including a summary for
    each business, and rank my search by favorably reviewed businesses.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为用户，我想查看每个企业的评论，包括每个企业的摘要，并按好评企业进行搜索排序。
- en: As a user, I want to create a review for a business.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为用户，我想为一家企业创建评论。
- en: As a user, I want to connect my friends and users who have tastes that I like,
    so I can follow my friends’ reviews.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为用户，我想连接我喜欢的口味的朋友和用户，这样我就可以关注我朋友的评论。
- en: As a user, I want to receive personalized recommendations based on reviews I
    have previously written and my social network.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为用户，我希望根据我之前写过的评论和我的社交网络收到个性化的推荐。
- en: Now that we’ve identified the requirements for our application, let’s think
    about the data requirements for this application and the data model that describes
    it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了我们应用程序的需求，让我们考虑这个应用程序的数据需求及其描述的数据模型。
- en: First, what are the entities? These will become nodes in our graph. I can think
    of users, businesses, reviews, and photos as entities that we need to think about
    (see figure 2.1).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，什么是实体？这些将成为我们图中的节点。我可以将用户、企业、评论和照片视为我们需要考虑的实体（见图2.1）。
- en: '![CH02_F01_Lyon](../../OEBPS/Images/CH02_F01_Lyon.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F01_Lyon](../../OEBPS/Images/CH02_F01_Lyon.png)'
- en: Figure 2.1 Entities become nodes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 实体成为节点。
- en: 'Next, how are those entities connected? These connections are modeled as relationships
    between the entities, and what we’ve described is a graph (see figure 2.2). Let’s
    add the following relationships:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这些实体是如何连接的？这些连接被建模为实体之间的关系，而我们所描述的是一个图（见图2.2）。让我们添加以下关系：
- en: Users write reviews.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户撰写评论。
- en: Reviews are connected to a business.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评论与一个企业相连。
- en: Users upload photos.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户上传照片。
- en: Photos are tagged to businesses.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 照片被标记到企业上。
- en: '![CH02_F02_Lyon](../../OEBPS/Images/CH02_F02_Lyon.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F02_Lyon](../../OEBPS/Images/CH02_F02_Lyon.png)'
- en: Figure 2.2 Adding relationships to connect nodes
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 添加关系以连接节点
- en: Now that we’ve described the data requirements of our application as a graph,
    we can start to think about how to build a GraphQL API to enable us to work with
    this data graph.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将我们应用程序的数据需求描述为一个图，我们可以开始考虑如何构建一个GraphQL API，使我们能够与这个数据图一起工作。
- en: 2.2 Graphs in GraphQL
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 GraphQL中的图
- en: GraphQL models our business domain as a graph. With GraphQL, we define this
    graph model by creating a GraphQL schema, which we do by writing GraphQL type
    definitions. In the schema, we define types of nodes, the fields available on
    each node, and how they are connected by relationships. The most common way of
    creating a GraphQL schema is by using the GraphQL schema definition language (SDL).
    In this section, we take the requirements of our application and create a GraphQL
    schema that models our business review domain in GraphQL using GraphQL type definitions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL将我们的业务领域建模为一个图。使用GraphQL，我们通过创建一个GraphQL模式来定义这个图模型，我们通过编写GraphQL类型定义来实现这一点。在模式中，我们定义了节点的类型、每个节点上可用的字段以及它们通过关系如何连接。创建GraphQL模式最常见的方式是使用GraphQL模式定义语言（SDL）。在本节中，我们根据我们应用程序的需求创建一个GraphQL模式，使用GraphQL类型定义在GraphQL中建模我们的业务审查领域。
- en: '2.2.1 API modeling with type definitions: GraphQL-first development'
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 使用类型定义进行API建模：GraphQL-first开发
- en: Having translated our business requirements into the graph data model necessary
    for our application, we can now formally write our GraphQL type definitions, using
    the GraphQL schema definition language. With the GraphQL SDL, we define the types,
    the fields on each type, and how they are connected. The GraphQL SDL representation
    of our data is just another representation of the graph data model we described
    in the previous section. Our GraphQL type definitions will become the specification
    for the API and guide the rest of our implementation. This process is known as
    *GraphQL-first development*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在将我们的业务需求翻译成我们应用程序所需的图数据模型之后，我们现在可以正式编写我们的GraphQL类型定义，使用GraphQL模式定义语言。使用GraphQL
    SDL，我们定义类型、每种类型上的字段以及它们是如何连接的。我们数据的GraphQL SDL表示只是我们之前章节中描述的图数据模型的另一种表示。我们的GraphQL类型定义将成为API的规范，并指导我们其余的实现。这个过程被称为*GraphQL-first开发*。
- en: Other ways of representing GraphQL types
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 表示GraphQL类型的其他方式
- en: The SDL is not the only way to create our type definitions. Each GraphQL implementation
    (e.g., graphql.js, the reference implementation used by most Node.js JavaScript
    GraphQL projects) also exposes a programmatic API to represent GraphQL type definitions.
    In fact, when the SDL is parsed, it is this object representation that is created
    internally for working with the GraphQL schema. This approach of constructing
    GraphQL types can be used by the API developer as well and is often the better
    option when programmatically generating GraphQL types, such as when generating
    types from existing classes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: SDL不是创建我们的类型定义的唯一方式。每个GraphQL实现（例如，graphql.js，大多数Node.js JavaScript GraphQL项目使用的参考实现）也提供了一个程序化API来表示GraphQL类型定义。实际上，当SDL被解析时，内部会创建这个对象表示来与GraphQL模式一起工作。这种构建GraphQL类型的方法也可以由API开发者使用，并且在程序化生成GraphQL类型时通常是更好的选择，例如从现有类生成类型时。
- en: Since GraphQL services can be implemented in any language, a programming- language-specific
    syntax is not relevant for all GraphQL implementations; therefore, the programming-language-agnostic
    GraphQL SDL is used to define GraphQL types. In chapter 1, we introduced the basic
    syntax of the GraphQL Schema Definition Language, using a simple movie and actor
    GraphQL schema. Using the syntax introduced in that example, let’s create GraphQL
    type definitions for our business reviews application, based on the requirements
    we created in the previous section of this chapter, as shown in the following
    listing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GraphQL服务可以用任何语言实现，因此特定于编程语言的语法对于所有GraphQL实现并不相关；因此，使用无语言特定的GraphQL SDL来定义GraphQL类型。在第1章中，我们介绍了GraphQL模式定义语言的语法，使用了一个简单的电影和演员GraphQL模式。使用该示例中介绍的语法，让我们根据本章前一部分创建的业务审查应用的要求，创建GraphQL类型定义，如下所示。
- en: Listing 2.1 GraphQL type definitions for our business review application
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 我们业务审查应用的GraphQL类型定义
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Each type of object or entity in our graph becomes a GraphQL type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们图中的每种对象或实体类型都成为GraphQL类型。
- en: ❷ Each type should have some field that uniquely identifies that object.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每种类型都应该有一些字段可以唯一标识该对象。
- en: ❸ Fields can be references to other types—in this case, a one-to-many relationship.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 字段可以是其他类型的引用——在这种情况下，一对一关系。
- en: ❹ Connection references can also represent one-to-one relationships.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 连接引用也可以表示一对一关系。
- en: Note that the entities we identified become GraphQL types, the properties of
    the entities become fields on the types, and the connections or relationships
    connecting the types are defined as fields that reference other types. Each type
    contains fields, which can be scalar types, objects, or lists.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们识别的实体成为GraphQL类型，实体的属性成为类型上的字段，连接类型或连接类型的关系定义为引用其他类型的字段。每种类型都包含字段，这些字段可以是标量类型、对象或列表。
- en: Each type should have some field that uniquely identifies that object. ID is
    a special GraphQL scalar used to represent this unique field. Internally, we treat
    ID fields as strings. The exclamation ! indicates this field is required; we cannot
    have a User object in our GraphQL API without a value for the userId field. The
    brackets [] here indicate this is a one-to-many relationship; one User can create
    zero or more reviews and a Review can be written by only one User. To represent
    one-to-one relationships, we simply leave off the brackets, indicating this is
    not an array field.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型都应该有一些字段可以唯一标识该对象。ID是用于表示此唯一字段的特殊GraphQL标量。内部，我们将ID字段视为字符串。感叹号!表示此字段是必需的；在我们的GraphQL
    API中，如果没有userId字段的值，则不能有User对象。这里的中括号[]表示这是一对多关系；一个User可以创建零个或多个评论，而一个Review只能由一个User编写。要表示一对一关系，我们只需省略中括号，表示这不是数组字段。
- en: Built-in GraphQL types
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 内置GraphQL类型
- en: 'The following built-in types are supported by the GraphQL schema language:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL模式语言支持以下内置类型：
- en: String
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Int
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整型
- en: Float
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数
- en: Boolean
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔型
- en: ID
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ID
- en: By default, every type is nullable, meaning null is a valid value for the field.
    Use an exclamation point ! to indicate a type is non-nullable. For example, Int!
    is a non-nullable integer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个类型都是可空的，这意味着null是该字段的有效值。使用感叹号!来表示类型不可空。例如，Int!是不可空的整数。
- en: To indicate a list type, use square brackets []. For example, [Int] is a list
    of integers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示列表类型，使用方括号[]。例如，[Int]表示整数列表。
- en: 'Brackets and exclamations can be combined. For example, [String!] is a list
    of non-nullable strings: every item in the list must have a String value, but
    the list itself can be null, while [String]! is a non-nullable list of nullable
    strings.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号和感叹号可以组合使用。例如，[String!] 是一个非空字符串列表：列表中的每个项目都必须有一个字符串值，但列表本身可以是null，而 [String]!
    是一个非空的可空字符串列表。
- en: Now that we have our type definitions, we need to define the entry points for
    our API. The entry points for read operations are defined in a special type called
    the Query type. Entry points for write operations are defined in a special type
    called the Mutation type. In this chapter, we focus only on queries. Mutations
    will be covered in chapter 4, where we will update data in a database. In addition
    to the Query and Mutation types, there is a third special GraphQL type that defines
    entry points, called Subscription .Subscriptions are GraphQL’s event-publishing
    functionality and are beyond the scope of this book.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的类型定义，我们需要定义我们API的入口点。读取操作的入口点定义在一个特殊类型中，称为查询类型。写入操作的入口点定义在另一个特殊类型中，称为突变类型。在本章中，我们只关注查询。突变将在第4章中介绍，我们将更新数据库中的数据。除了查询和突变类型之外，还有一个第三种特殊的GraphQL类型，用于定义入口点，称为订阅。订阅是GraphQL的事件发布功能，超出了本书的范围。
- en: The entry points for our API should map to the client requirements of our application.
    In other words, ask yourself, “What operations does the client need to complete?”
    These needs should guide what Query and Mutation fields we define. Let’s first
    focus on read-only requirements in the next listing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们API的入口点应该映射到我们应用程序的客户端需求。换句话说，问问自己，“客户端需要完成哪些操作？”这些需求应该指导我们定义哪些查询和突变字段。让我们首先关注下一列表中的只读需求。
- en: Listing 2.2 Query fields as API entry points
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2 查询字段作为API入口点
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we’ve created our GraphQL type definitions, we can construct some GraphQL
    queries that might be used by our application. Consider the query that our application
    might need to issue to populate a search results page, based on a user-provided
    search string, as shown in the following listing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的GraphQL类型定义，我们可以构建一些可能被我们的应用程序使用的GraphQL查询。考虑以下列表中显示的应用程序可能需要发出以填充搜索结果页面的查询，基于用户提供的搜索字符串。
- en: Listing 2.3 GraphQL query to search for businesses and reviews
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3 搜索商业和评论的GraphQL查询
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this query, we can search for “Library” businesses, view the businesses
    that are a match, and see the business details necessary for the search results,
    as well as all the reviews for the business and the user who wrote them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个查询，我们可以搜索“图书馆”商业，查看匹配的商业，并查看搜索结果所需的商业详情，以及所有评论及其作者。
- en: This is great, but there are a few issues with this query. What happens if we
    have many matches for “Library” businesses? What if a given business has thousands
    of reviews? Our client application will be overwhelmed with data to render. Also,
    we probably don’t want to show business results in just any order; we should allow
    the search results to be ordered by name, in either ascending or descending order.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但这个查询有几个问题。如果我们有很多“图书馆”商业的匹配项会发生什么？如果某个特定的商业有数千条评论会发生什么？我们的客户端应用程序将不堪重负，需要渲染大量数据。此外，我们可能不想以任何顺序显示商业结果；我们应该允许搜索结果按名称排序，无论是升序还是降序。
- en: Adding pagination and ordering to our API
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将分页和排序添加到我们的API
- en: GraphQL does not have semantics for filtering, pagination, or ordering out of
    the box; instead, it is up to the API designer to add these to the GraphQL schema
    as they deem necessary and relevant for the requirements of the application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL没有内置的过滤、分页或排序语义；相反，API设计者需要根据应用程序的需求和相关性将这些添加到GraphQL模式中。
- en: For pagination, we will add a first (think limit) argument to our API to allow
    the client to specify the number of objects to be returned. We do this both at
    the root Query field and for any relationship fields—those describing a one-to-many
    relationship. In addition, an offset argument (think skip), which specifies the
    number of records to skip before returning results, allows the client to implement
    pagination.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分页，我们将在我们的API中添加一个first（想想限制）参数，允许客户端指定要返回的对象数量。我们在根查询字段和任何关系字段（描述一对一关系的字段）中都这样做。此外，一个offset参数（想想跳过），它指定在返回结果之前要跳过的记录数，允许客户端实现分页。
- en: Arguments vs. fields
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 参数与字段
- en: It is important to understand the distinction between arguments and fields.
    For example, first and offset are arguments, whereas name and address are fields.
    Arguments appear inside parentheses after a field name and are passed to resolver
    functions. Fields appear inside braces after an object name and represent attributes
    of an object. Fields can be thought of as holding values, while arguments are
    used more as selectors and are passed in GraphQL operations.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 理解参数和字段之间的区别很重要。例如，first和offset是参数，而name和address是字段。参数出现在字段名后面的括号内，并传递给解析函数。字段出现在对象名后面的花括号内，代表对象的属性。字段可以被视为持有值，而参数更多地用作选择器，并在GraphQL操作中传递。
- en: Listing 2.4 Updated query and business type definitions with first and offset
    arguments
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 更新后的查询和业务类型定义，包含first和offset参数
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Here we add first and offset arguments to the reviews field on the Business
    type. This means we can control pagination on the nested connected Review objects
    for each business returned in our query.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在此处，我们将first和offset参数添加到Business类型的reviews字段上。这意味着我们可以控制查询中每个返回的业务的嵌套连接Review对象的分页。
- en: ❷ Here we add the first and offset arguments to the allBusinesses field, allowing
    the client to specify skip and limit values for the query, controlling the number
    and offset of the businesses returned. Note that we assign default values, and
    if not specified, the value of 10 and offset of 0 will be assigned first, ensuring
    we receive the first 10 results.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在此处，我们将first和offset参数添加到allBusinesses字段中，允许客户端指定查询的跳过和限制值，控制返回的业务数量和偏移量。请注意，我们分配了默认值，如果没有指定，则默认值为10和偏移量为0，确保我们接收前10个结果。
- en: ❸ There is no need to add first and offset arguments to the userById field because
    it is guaranteed to return at most one result.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 由于用户ID字段保证最多返回一个结果，因此无需向用户ID字段添加first和offset参数。
- en: Pagination options
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 分页选项
- en: There are several patterns for implementing pagination in GraphQL. Here we focus
    on a fairly simple first/offset pattern. Other options include numbered pages
    and cursor-based pagination, such as Relay Cursor Connections. Cursor-based pagination
    using the Relay Cursor Connection specification is covered in chapter 9.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在GraphQL中实现分页有几种模式。我们在此关注一种相当简单的前/偏移模式。其他选项包括编号页面和基于游标的分页，如Relay Cursor Connections。使用Relay
    Cursor Connection规范实现的基于游标的分页在第9章中介绍。
- en: That solves pagination for us, but what about ordering? This is needed when
    showing search results—we want to present the user with the businesses in an order
    that makes sense. To accomplish this, we will add an ordering enum that will enumerate
    the options for ordering fields of type [Business] in our GraphQL API.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就解决了分页问题，但排序怎么办？在显示搜索结果时，这是必需的——我们希望以有意义的顺序向用户展示业务。为了实现这一点，我们将添加一个排序枚举，该枚举将列出我们的GraphQL
    API中类型为[Business]的字段排序选项。
- en: Listing 2.5 Business ordering enum
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5 Business排序枚举
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ enum is a built-in GraphQL type that is restricted to a set of allowed values.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ enum是GraphQL的一个内置类型，它限制为一系列允许的值。
- en: '❷ We add two enum options for each field on which we want to support ordering:
    one field for ascending ordering, ending in _asc, and another field for descending
    ordering, ending in _desc.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们为每个我们希望支持排序的字段添加两个枚举选项：一个用于升序排序的字段，以_asc结尾，另一个用于降序排序的字段，以_desc结尾。
- en: Typically, the convention is to set enums in uppercase (e.g., NAME_ASC); however,
    since in this case our enum values describe field names, we make an exception
    and keep the naming of the enums consistent with our field names. Now, we need
    to add this field as an optional argument to our Query field for searching for
    businesses, as shown in the next listing.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，枚举的约定是大写（例如，NAME_ASC）；然而，由于在此情况下我们的枚举值描述了字段名称，我们做出例外，并保持枚举的命名与我们的字段名称一致。现在，我们需要将此字段作为可选参数添加到我们的查询字段中，以便搜索业务，如下一列表所示。
- en: Listing 2.6 Adding ordering for business search results
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.6 为业务搜索结果添加排序
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Here we’ve added the orderBy argument to the businessBySearchTerm field, which
    is of type BusinessOrdering.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们已将orderBy参数添加到businessBySearchTerm字段中，该字段类型为BusinessOrdering。
- en: Now, we are ready to use our new pagination and ordering arguments. In the next
    listing, let’s update our earlier query, in which we were searching for businesses
    with “Library” in the name to return only the top five rated businesses and two
    reviews for each business.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用我们新的分页和排序参数。在下一列表中，让我们更新我们之前的查询，其中我们正在搜索名称中包含“Library”的业务，以仅返回评分最高的五个业务以及每个业务的两个评论。
- en: Listing 2.7 GraphQL query to search for businesses and reviews
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.7 查询商业和评论的GraphQL查询
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Typically, when using argument values in our application queries, we want to
    use variables with values that can be substituted at query time, so we don’t end
    up constructing query strings in our application. Instead, we want to pass our
    parameterized GraphQL query string and an object with the variable values. We
    can do this in GraphQL by first declaring the variables we plan to use as well
    as their type, and then including them in the query, prefixed by the $ character.
    The following listing shows how our query would look using GraphQL variables.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当在应用程序查询中使用参数值时，我们希望使用在查询时可以替换的变量值，这样我们就不需要在应用程序中构建查询字符串。相反，我们希望传递参数化的GraphQL查询字符串和一个包含变量值的对象。我们可以在GraphQL中通过首先声明我们计划使用的变量及其类型，然后在查询中包含它们，并在前面加上$字符来实现这一点。以下列表显示了使用GraphQL变量的查询外观。
- en: Listing 2.8 GraphQL query to search for businesses and reviews using pagination
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8 使用分页搜索商业和评论的GraphQL查询
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that this query now includes some additional information, along with our
    GraphQL variable declaration. We are explicitly specifying the GraphQL *operation
    type* and *operation name*. The operation type is query, mutation, or subscription.
    Previously, we used a shorthand that excluded the operation type and treated query
    as the default operation type. We’ll cover mutation types later in the book. The
    operation type is not required, unless specifying an operation name or variable
    definitions, or using a type other than query.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个查询现在包含了一些附加信息，以及我们的GraphQL变量声明。我们明确指定了GraphQL的*操作类型*和*操作名称*。操作类型是查询、突变或订阅。之前，我们使用了一种简写，排除了操作类型，并将查询视为默认操作类型。我们将在本书的后面部分介绍突变类型。除非指定操作名称或变量定义，或使用除查询之外的类型，否则操作类型不是必需的。
- en: 'The other additional piece of information here is the operation name—in this
    case, businessSearch. The operation name is an explicit name for the operation
    that can be helpful for debugging and logging. It can be much easier to find queries
    using the operation name while looking through logs when there is a problem or
    when troubleshooting. Along with the GraphQL query, we would also pass an object
    that contains the variable values:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里提供的另一项附加信息是操作名称——在本例中为businessSearch。操作名称是对操作的明确命名，有助于调试和日志记录。当有问题或进行故障排除时，使用操作名称查找查询会更容易。除了GraphQL查询外，我们还会传递一个包含变量值的对象：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Of course, we don’t have a way to query our nonexistent API at this point, so
    let’s fix that by implementing some resolvers for data fetching!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们目前还没有查询我们不存在的API的方法，所以让我们通过实现一些用于数据获取的解析器来解决这个问题！
- en: 2.2.2 Resolving data with resolvers
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 使用解析器解析数据
- en: Following our GraphQL-first development approach, the next step we need to complete
    is implementing the code to actually fetch this data from the data layer. We do
    this by writing functions called *resolvers*, which contain logic for how to resolve
    data from the data layer. Resolvers are standalone functions with the purpose
    of fetching data for a single field of a GraphQL type, and they can be thought
    of as the primary unit of execution in a GraphQL service. Resolvers are called
    in a nested fashion, starting with the root-level resolver (a field on the query,
    mutation, or subscription types) in a depth-first execution, until all requested
    fields have been resolved. Data resolved in a previous resolver is passed on to
    nested resolvers via the obj parameter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们的GraphQL优先开发方法，下一步我们需要完成的是实现从数据层实际获取这些数据的代码。我们通过编写称为*解析器*的函数来完成此操作，这些函数包含从数据层解析数据的逻辑。解析器是具有从GraphQL类型单个字段获取数据目的的独立函数，它们可以被视为GraphQL服务中的主要执行单元。解析器以嵌套方式调用，从根级解析器（查询、突变或订阅类型上的字段）开始，以深度优先执行，直到所有请求的字段都已解析。先前解析的数据通过obj参数传递给嵌套解析器。
- en: You can think of resolvers as functions that go alongside the GraphQL type definitions
    defined in SDL and, effectively, make the GraphQL schema executable. A GraphQL
    schema must have resolver functions for all fields (a default resolver is used
    for any resolver functions not explicitly defined), so a collection of resolver
    functions corresponds to the type definitions and is known as a resolver map.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将解析器视为与在 SDL 中定义的 GraphQL 类型定义一起使用的函数，并且实际上使 GraphQL 模式可执行。GraphQL 模式必须为所有字段提供解析器函数（对于未明确定义的任何解析器函数，将使用默认解析器），因此解析器函数集合对应于类型定义，并被称为解析器映射。
- en: The resolver function signature
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器函数签名
- en: 'Each resolver function receives four arguments:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个解析器函数接收四个参数：
- en: obj—The previously resolved object. Not used for a root query field resolver.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: obj—之前解析的对象。对于根查询字段解析器不使用。
- en: args—The arguments for the field used in the GraphQL query.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: args—在 GraphQL 查询中使用的字段的参数。
- en: context—An object that can hold contextual data, such as authorization information
    or a database connection.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: context—一个可以包含上下文数据（如授权信息或数据库连接）的对象。
- en: info—The GraphQLResolveInfo object contains a version of the GraphQL query as
    well as the full GraphQL schema and other metadata about the query and schema.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: info—GraphQLResolveInfo 对象包含 GraphQL 查询的版本以及完整的 GraphQL 模式和其他有关查询和模式的元数据。
- en: 'Valid results returned by resolver functions include the following, depending
    on the GraphQL type definition of the field being resolved:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器函数返回的有效结果取决于正在解析的字段的 GraphQL 类型定义：
- en: A scalar or object value
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标量或对象值
- en: An array
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数组
- en: A promise
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个承诺
- en: undefined or null
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: undefined 或 null
- en: Default resolvers
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 默认解析器
- en: 'If a resolver is not provided for a field requested in a GraphQL query, then
    a default resolver will be called, passing in the data resolved so far (the obj
    mentioned previously). This default resolver will return a property from the obj
    parameter with the field name. For example, a default resolver for the name field
    on the Business type would look something like the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 GraphQL 查询中请求的字段没有提供解析器，则将调用默认解析器，传入已解析的数据（前面提到的 obj）。此默认解析器将返回 obj 参数的属性。例如，Business
    类型上 name 字段的默认解析器可能如下代码所示：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 2.2.3 Our first resolver
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.3 我们的第一个解析器
- en: Let’s implement resolvers for the type definitions we’ve created (see listing
    2.9). The first thing we need is some data to return, so let’s create some static
    data that will represent our data layer. We’ll simply create some object literals
    and store these in an object called db, which we can think of as a mock for a
    database that we would query in our resolver functions. We will inject this db
    object with our fake data into the context object, ensuring it is available in
    each resolver.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现我们创建的类型定义的解析器（参见列表 2.9）。我们首先需要一些要返回的数据，因此让我们创建一些代表我们的数据层的静态数据。我们将简单地创建一些对象字面量，并将这些存储在一个名为
    db 的对象中，我们可以将其视为在解析器函数中查询的数据库的模拟。我们将通过将我们的假数据注入到上下文对象中，确保它在每个解析器中可用。
- en: Listing 2.9 Sample data for businesses, reviews, and users representing our
    data layer
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.9 代表我们的数据层的业务、评论和用户示例数据
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ll assume these objects are passed to the resolvers in the context object
    like we would pass a database connection object.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设这些对象会像传递数据库连接对象一样传递到上下文对象中的解析器。
- en: Mocking GraphQL data
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟 GraphQL 数据
- en: 'Rather than creating a static object to use as an example, we could use the
    mocking functionality of Apollo Server to create resolvers that return mocked
    data. This mocking functionality is useful for testing UI and frontend code and
    enabling frontend and backend teams to work concurrently. We can be sure this
    data is relevant because it uses schema introspection and the GraphQL type system
    to ensure the mocked data is the same form as we’ve defined in our GraphQL type
    definitions. Learn more about data mocking with Apollo Server in the documentation:
    [http://mng.bz/Pnlw](http://mng.bz/Pnlw).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是创建一个静态对象作为示例，我们可以使用 Apollo Server 的模拟功能来创建返回模拟数据的解析器。这种模拟功能对于测试 UI 和前端代码以及使前端和后端团队能够并行工作非常有用。我们可以确信这些数据是相关的，因为它们使用模式内省和
    GraphQL 类型系统来确保模拟数据与我们定义在 GraphQL 类型定义中的形式相同。有关使用 Apollo Server 进行数据模拟的更多信息，请参阅文档：[http://mng.bz/Pnlw](http://mng.bz/Pnlw)。
- en: Based on our GraphQL type definitions, our initial resolver map would look like
    the following listing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的 GraphQL 类型定义，我们的初始解析器映射将如下所示。
- en: Listing 2.10 Resolver map skeleton
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.10 解析器映射骨架
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that we don’t need to bother implementing trivial resolvers that will be
    handled by the default resolver, such as Business.name. Let’s start by implementing
    the allBusinesses resolver (see listing 2.11). This resolver simply fetches all
    businesses from our data layer and returns them, without worrying about pagination
    or ordering. Remember that for this example, our data layer consists of a nested
    object exposed via the context object in each resolver. (We’ll cover how to actually
    inject this object in the next section.)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要麻烦实现那些将由默认解析器处理的平凡解析器，例如Business.name。让我们首先实现allBusinesses解析器（见列表2.11）。这个解析器简单地从我们的数据层获取所有企业并返回它们，无需担心分页或排序。记住，在这个例子中，我们的数据层由每个解析器通过上下文对象公开的嵌套对象组成。（我们将在下一节中介绍如何实际注入此对象。）
- en: 'Listing 2.11 Root-level resolver: allBusinesses'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.11 根级别解析器：allBusinesses
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ We are resolving a field on the Query type, so this resolver is a function
    under the Query key in our resolver map.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们正在解析Query类型上的字段，所以这个解析器是我们解析器映射中Query键下的一个函数。
- en: ❷ Here we see the standard signature for resolver functions. obj will be empty
    here, since this is the root level resolver—no data has been resolved yet. args
    will also be an empty object, since this field does not accept any arguments.
    context, however, will contain our static data object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这里我们看到解析器函数的标准签名。obj在这里将是空的，因为这是根级别解析器——还没有解析任何数据。args也将是一个空对象，因为这个字段不接受任何参数。然而，context将包含我们的静态数据对象。
- en: ❸ We return the businesses array on the db object, accessed via the context
    object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们通过上下文对象返回db对象上的businesses数组。
- en: Now that we have our first resolver function implemented, let’s see how we can
    combine our GraphQL type definitions and resolvers to serve a GraphQL API, using
    Apollo Server.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了第一个解析器函数，让我们看看如何结合我们的GraphQL类型定义和解析器来使用Apollo Server提供GraphQL API。
- en: 2.3 Combining type definitions and resolvers with Apollo Server
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 使用Apollo Server结合类型定义和解析器
- en: 'We’ve created our GraphQL type definitions and our first resolver function
    to query our data layer, so now it’s time to put them together and spin up a GraphQL
    server with Apollo Server. Apollo Server is available as an npm package, so let’s
    install that with npm:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了我们的GraphQL类型定义和第一个解析器函数来查询我们的数据层，所以现在是时候将它们组合起来，并使用Apollo Server启动一个GraphQL服务器。Apollo
    Server作为一个npm包可用，所以让我们用npm安装它：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 2.3.1 Using Apollo Server
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 使用Apollo Server
- en: In the next listing, we create index.js, which will use the type definitions
    and resolvers we previously defined as well as Apollo Server to serve a GraphQL
    API based on these type definitions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个列表中，我们创建index.js，它将使用我们之前定义的类型定义和解析器以及Apollo Server来根据这些类型定义提供GraphQL API。
- en: Listing 2.12 index.js GraphQL server created with Apollo Server
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.12 index.js 使用Apollo Server创建的GraphQL服务器
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Import ApolloServer from the package we just installed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从我们刚刚安装的包中导入ApolloServer。
- en: ❷ Create a server instance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个服务器实例。
- en: ❸ We pass in our type definitions that we defined above.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们传递了我们上面定义的类型定义。
- en: ❹ Our resolvers were defined previously.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们之前已经定义了解析器。
- en: ❺ db is our mock data object and is injected into the context. This object will
    be available in each resolver.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ db是我们模拟的数据对象，并注入到上下文中。此对象将在每个解析器中可用。
- en: ❻ Here we start the server and begin listening for incoming GraphQL requests.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 这里我们启动服务器并开始监听传入的GraphQL请求。
- en: 2.3.2 Apollo Studio
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 Apollo Studio
- en: By default, Apollo Server will serve the GraphQL endpoint for POST requests,
    but for a GET request from a web browser at the same URL (http://localhost:4000,
    in our case), Apollo Server will redirect to the Apollo Studio in-browser tool
    (see figure 2.3).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Apollo Server将为POST请求提供GraphQL端点，但对于来自同一URL（在我们的例子中是http://localhost:4000）的GET请求，Apollo
    Server将重定向到浏览器中的Apollo Studio工具（见图2.3）。
- en: '![CH02_F03_Lyon](../../OEBPS/Images/CH02_F03_Lyon.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F03_Lyon](../../OEBPS/Images/CH02_F03_Lyon.png)'
- en: Figure 2.3 Querying with Apollo Studio
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 使用Apollo Studio进行查询
- en: 'Apollo Studio can be used to view the type definitions and schema of the GraphQL
    API as well as execute queries and mutations and view the results. So far, the
    only Query field resolver we’ve implemented is allBusinesses. Let’s test that
    by running the following query in Apollo Studio:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Apollo Studio可用于查看GraphQL API的类型定义和模式，以及执行查询和突变并查看结果。到目前为止，我们唯一实现的查询字段解析器是allBusinesses。让我们通过在Apollo
    Studio中运行以下查询来测试它：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will result in a call to the Query field resolver allBusinesses, which
    will return the businesses object from our mocked database. Then, since we are
    requesting just the name field on the Business type, the default resolver for
    name will be used to return the name of each business (see figure 2.4).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致调用 Query 字段解析器 allBusinesses，它将返回我们模拟数据库中的企业对象。然后，由于我们请求的是 Business 类型上的名称字段，将使用名称的默认解析器来返回每个企业的名称（见图
    2.4）。
- en: '![CH02_F04_Lyon](../../OEBPS/Images/CH02_F04_Lyon.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F04_Lyon](../../OEBPS/Images/CH02_F04_Lyon.png)'
- en: Figure 2.4 A simple query, using Apollo Studio
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 使用 Apollo Studio 的简单查询
- en: If you experiment by adjusting the query in Apollo Studio, you can see pretty
    quickly that we need to implement the rest of our resolvers. Let’s return to our
    resolver map skeleton and complete the resolvers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过在 Apollo Studio 中调整查询进行实验，你很快就会看到我们需要实现剩余的解析器。让我们回到我们的解析器映射骨架，并完成解析器的实现。
- en: 2.3.3 Implementing resolvers
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 实现解析器
- en: We’ve created some fake data to work with and have written our first resolver,
    allBusinesses, which simply returns all the businesses in our mock database. Now,
    it’s time to implement more complex resolvers, such as businessBySearchTerm, which
    will allow us to filter results based on a user’s search term, and array resolvers,
    such as Business.reviews, that will be responsible for resolving connections between
    businesses and reviews.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一些假数据来工作，并编写了我们的第一个解析器，allBusinesses，它简单地返回我们模拟数据库中的所有企业。现在，是时候实现更复杂的解析器了，比如
    businessBySearchTerm，这将允许我们根据用户的搜索词过滤结果，以及数组解析器，如 Business.reviews，它将负责解析企业和评论之间的连接。
- en: 'Root-level resolver: businessBySearchTerm'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 根级解析器：businessBySearchTerm
- en: 'Root-level resolvers are those that map to the entry points for our API. Looking
    back at our GraphQL type definitions, we have the following entry points, as defined
    in the Query type:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 根级解析器是与我们的 API 入口点相对应的解析器。回顾我们的 GraphQL 类型定义，我们有以下入口点，如 Query 类型中定义的：
- en: '[PRE16]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We already implemented the allBusinesses root-level resolver in the previous
    section. That example was fairly simple, since we didn’t have to deal with any
    arguments. Now let’s implement the businessesBySearchTerm resolver, which takes
    a search string, ordering, and pagination arguments, as shown in the next listing.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一节中实现了 allBusinesses 根级解析器。那个例子相当简单，因为我们不需要处理任何参数。现在让我们实现 businessesBySearchTerm
    解析器，它接受一个搜索字符串、排序和分页参数，如下一列表所示。
- en: 'Listing 2.13 Root-level resolver: businessBySearchTerm'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.13 根级解析器：businessBySearchTerm
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Since this is a root-level resolver, the obj parameter will be empty, but
    we will make use of the args object, which will contain the GraphQL query arguments—in
    this case, orderBy, search, first, and offset. Since our type definitions made
    use of default values for orderBy, first, and offset, and search is a required
    field, we can be sure these values will be defined.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 由于这是一个根级解析器，obj 参数将为空，但我们将利用 args 对象，它将包含 GraphQL 查询参数——在这种情况下，orderBy、search、first
    和 offset。由于我们的类型定义使用了 orderBy、first 和 offset 的默认值，并且 search 是一个必填字段，我们可以确信这些值将被定义。
- en: ❷ Here we define a comparator function to use for ordering, making use of our
    BusinessOrdering enum. We split the orderBy value on underscore to identify the
    field name and direction of ordering (e.g., name_asc means we will order by the
    name field in ascending order).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在这里，我们定义了一个比较函数来用于排序，利用我们的 BusinessOrdering 枚举。我们将 orderBy 值根据下划线分割以识别字段名和排序方向（例如，name_asc
    表示我们将按名称字段升序排序）。
- en: ❸ Here we filter for businesses, where the name property contains the search
    term passed in the GraphQL query.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们根据包含在 GraphQL 查询中传递的搜索词的名称属性过滤企业。
- en: ❹ We make use of the slice function to implement first/offset pagination.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们使用 slice 函数来实现 first/offset 分页。
- en: ❺ Here we apply our compare function to order the results according to the value
    specified in the orderBy argument. If no orderBy argument is specified, then name_asc
    will be used, since it is specified as the default value in the GraphQL type definitions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在这里，我们将我们的比较函数应用于结果，根据 orderBy 参数指定的值进行排序。如果没有指定 orderBy 参数，则将使用 name_asc，因为它在
    GraphQL 类型定义中指定为默认值。
- en: 'Array resolver: Business.reviews'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 数组解析器：Business.reviews
- en: Our previous root-level resolvers returned arrays of objects, but we can also
    return arrays of objects from resolvers for non-root-level resolvers if the field
    is a list field (e.g., Business.reviews, which is of type [Review], or a list
    of Review objects). With non-root level resolvers, the obj parameter will include
    any previously resolved data. For example, if we first execute the Query.businessBySearchTerm
    resolver to fetch businesses, the results of that resolver will be passed to the
    Business.reviews resolver. Let’s make use of that data to implement the Business.reviews
    resolver in the next listing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的根级解析器返回了对象的数组，但我们也可以从非根级解析器返回对象的数组，如果字段是列表字段（例如，Business.reviews，它是Review类型，或者Review对象的列表）。在非根级解析器中，obj参数将包括之前解析的数据。例如，如果我们首先执行Query.businessBySearchTerm解析器来获取企业，该解析器的结果将被传递给Business.reviews解析器。让我们利用这些数据来实现下一个列表中的Business.reviews解析器。
- en: Listing 2.14 Root-level resolver
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.14 根级解析器
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Scalar resolver: Business.avgStars'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 标量解析器：Business.avgStars
- en: We talked about default resolvers that simply return an object property with
    the same name as the field from the obj parameter, but there are cases when we
    need to implement resolvers that return scalar values and the default resolver
    is not used. Aggregations are a good example of that. The Business.avgStars field
    is an aggregation field, and we need to find all reviews for a particular business
    and then calculate the average of the stars for these reviews, returning a single
    scalar value.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了默认解析器，它只是返回与obj参数中字段同名的对象属性，但有些情况下我们需要实现返回标量值的解析器，而默认解析器没有被使用。聚合就是一个很好的例子。Business.avgStars字段是一个聚合字段，我们需要找到特定企业的所有评论，然后计算这些评论的星级平均值，返回一个单一的标量值。
- en: Listing 2.15 Scalar field resolver
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.15 标量字段解析器
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Object resolver: Review.user'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对象解析器：Review.user
- en: So far, we’ve seen resolvers that return scalar values and arrays; now, let’s
    implement a resolver that returns a single object, as the next listing shows.
    In our type definitions, a Review is connected to a single User, which means that
    Review.user is an object field, not a list field.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了返回标量和数组的解析器；现在，让我们实现一个返回单个对象的解析器，如下面的列表所示。在我们的类型定义中，一个评论与一个用户相关联，这意味着Review.user是一个对象字段，而不是列表字段。
- en: Listing 2.16 Object field resolver resolver
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.16 对象字段解析器解析器
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: And with that last resolver implementation, we can now return to querying our
    GraphQL API using Apollo Studio.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个解析器实现之后，我们现在可以使用Apollo Studio返回查询我们的GraphQL API。
- en: 2.3.4 Querying using Apollo Studio
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 使用Apollo Studio进行查询
- en: Now that we’ve implemented the rest of our resolver functions, let’s return
    to Apollo Studio by opening http://localhost:4000/ in a web browser. First, let’s
    search for businesses using the search term “Library” (see figure 2.5).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了其余的解析器函数，让我们通过在网页浏览器中打开http://localhost:4000/返回Apollo Studio。首先，让我们使用搜索词“Library”搜索企业（见图2.5）。
- en: '![CH02_F05_Lyon](../../OEBPS/Images/CH02_F05_Lyon.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F05_Lyon](../../OEBPS/Images/CH02_F05_Lyon.png)'
- en: Figure 2.5 Querying for businesses by search term
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 通过搜索词查询企业
- en: And now let’s retrieve reviews for each business matching our search results
    (see figure 2.6).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检索与我们的搜索结果匹配的每个企业的评论（见图2.6）。
- en: '![CH02_F06_Lyon](../../OEBPS/Images/CH02_F06_Lyon.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F06_Lyon](../../OEBPS/Images/CH02_F06_Lyon.png)'
- en: Figure 2.6 Adding business reviews to the query
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 向查询添加企业评论
- en: 'You can find the code for the completed example GraphQL API in this book’s
    GitHub repository: [http://mng.bz/J2jo](http://mng.bz/J2jo). In the next chapter,
    we will introduce the Neo4j graph database and learn how to model, store, and
    query data using the Cypher query language.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub仓库中找到完成示例GraphQL API的代码：[http://mng.bz/J2jo](http://mng.bz/J2jo)。在下一章中，我们将介绍Neo4j图形数据库，并学习如何使用Cypher查询语言建模、存储和查询数据。
- en: 2.4 Exercises
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 练习
- en: Consider some of the other requirements of our business reviews application
    that we didn’t implement. Can you write GraphQL queries to address these requirements?
    What are the results?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑我们业务评论应用中我们没有实现的一些其他要求。你能编写GraphQL查询来满足这些要求吗？结果是什么？
- en: What other fields should make use of pagination and ordering in our API? Update
    the type definitions to include the appropriate ordering and pagination fields
    and update the resolvers to handle these pagination arguments.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们API中哪些其他字段应该使用分页和排序？更新类型定义以包括适当的排序和分页字段，并更新解析器以处理这些分页参数。
- en: Implement the root-level resolver for usersById.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现usersById的根级解析器。
- en: Our example GraphQL API conspicuously lacks business categories. Update the
    sample data, GraphQL type definitions, and resolvers to take advantage of business
    categories. Consider how you would model categories in the API, given that searching
    by category was specifically identified as a business requirement.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的示例 GraphQL API 明显缺少业务类别。更新示例数据、GraphQL 类型定义和解析器，以利用业务类别。考虑在 API 中如何建模类别，鉴于按类别搜索已被明确标识为业务需求。
- en: 'You can find solutions to the exercises as well as code samples in the GitHub
    repository for this book: [github.com/johnymontana/fullstack-graphql-book](https://github.com/johnymontana/fullstack-graphql-book).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的 GitHub 仓库中找到练习的解决方案以及代码示例：[github.com/johnymontana/fullstack-graphql-book](https://github.com/johnymontana/fullstack-graphql-book)。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: API data modeling can be approached using the business requirements of the application.
    When done this way—mapping out the mental model of the data—a graph is created,
    nodes are the entities, and relationships connect them.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用应用程序的业务需求来处理 API 数据建模。以这种方式完成时——绘制数据的心理模型——会创建一个图，节点是实体，关系将它们连接起来。
- en: GraphQL type definitions are used to define the data, relationships, and entry
    points of a GraphQL API. Type definitions can be defined using the Schema Definition
    Language (SDL), a language-agnostic notation for specifying GraphQL types. In
    addition to the built-in GraphQL types (ID, String, Int, Float, Bool, etc.), custom
    user-defined scalars and types can be defined as well.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 类型定义用于定义 GraphQL API 的数据、关系和入口点。类型定义可以使用模式定义语言（Schema Definition Language，SDL）来定义，SDL
    是一种与语言无关的表示法，用于指定 GraphQL 类型。除了内置的 GraphQL 类型（ID、String、Int、Float、Bool 等）之外，还可以定义自定义的用户定义标量和类型。
- en: Resolvers are functions that contain the data-fetching logic for a GraphQL API.
    Resolvers are called in a nested fashion, depending on what fields have been requested
    in the GraphQL query. Each resolver is passed a context object, which can contain
    database connections or other helper objects for accessing data.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析器是包含 GraphQL API 数据获取逻辑的函数。解析器根据 GraphQL 查询中请求的字段以嵌套方式调用。每个解析器都会传递一个上下文对象，该对象可以包含数据库连接或其他辅助对象，用于访问数据。
- en: Apollo Server is used to combine GraphQL type definitions and resolvers into
    an executable GraphQL schema and serve the GraphQL API.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apollo Server 用于将 GraphQL 类型定义和解析器组合成一个可执行的 GraphQL 模式，并服务于 GraphQL API。
- en: Apollo Studio can be used for viewing the schema of a GraphQL API as well as
    for executing queries and viewing the results.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apollo Studio 可以用于查看 GraphQL API 的模式，以及执行查询并查看结果。
