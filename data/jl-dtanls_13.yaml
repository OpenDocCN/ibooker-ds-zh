- en: 11 Converting and grouping data frames
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 转换和分组数据框
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Converting data frames to other Julia types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据框转换为其他 Julia 类型
- en: Writing type-stable code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写类型稳定的代码
- en: Understanding type piracy
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类型盗用
- en: Grouping data frame objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组数据框对象
- en: Working with grouped data frames
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与分组数据框一起工作
- en: In chapter 10, we reviewed various ways that DataFrame objects can be constructed
    from different data sources. In this chapter, we discuss the reverse process and
    show how you can create other objects from a data frame (recall from chapter 9
    that a data frame can be a DataFrame or its view, that is, a SubDataFrame). You
    might want to perform such an operation in two scenarios.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10章中，我们回顾了从不同数据源构建 DataFrame 对象的各种方法。在本章中，我们讨论了相反的过程，并展示了如何从数据框创建其他对象（回想第9章，数据框可以是
    DataFrame 或其视图，即 SubDataFrame）。你可能想在两种情况下执行此类操作。
- en: In the first scenario, you need to perform analytical tasks provided by functions
    that do not accept a data frame as input, but instead accept another type, so
    you’d need to convert a data frame to the expected target format. An example is
    conversion of a data frame to a matrix that you want to use later in linear algebra
    operations.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，你需要执行由不接受数据框作为输入但接受其他类型的函数提供的分析任务，因此你需要将数据框转换为预期的目标格式。一个例子是将数据框转换为矩阵，你打算在后续的线性代数操作中使用。
- en: In the second scenario, you want to change the way the data stored in the data
    frame is interpreted. The most important operation of this kind is grouping a
    data frame. You can group a data frame by using the groupby function on it to
    produce the GroupedDataFrame object. Both dplyr in R and pandas in Python also
    have grouping functionality. The most important application of grouped objects
    is making it possible for users to perform split-apply-combine transformations
    (see [www.jstatsoft.org/article/view/v040i01](https://www.jstatsoft.org/article/view/v040i01)).
    This data analysis task is performed often. We will discuss these operations in
    the remaining chapters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，你想要改变数据框中存储的数据的解释方式。此类操作中最重要的是分组数据框。你可以通过在数据框上使用 groupby 函数来分组数据框，从而产生
    GroupedDataFrame 对象。R 中的 dplyr 和 Python 中的 pandas 也都有分组功能。分组对象最重要的应用是使用户能够执行 split-apply-combine
    转换（参见 [www.jstatsoft.org/article/view/v040i01](https://www.jstatsoft.org/article/view/v040i01)）。这种数据分析任务经常执行。我们将在剩余的章节中讨论这些操作。
- en: However, GroupedDataFrame objects are more functional than just a support for
    split-apply-combine. They also make it possible for you to efficiently perform
    such operations as group iteration, lookup, reordering, and subsetting. All these
    tasks are often performed in practice; let’s look at a few examples.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，GroupedDataFrame 对象不仅支持 split-apply-combine，而且还能让你高效地执行诸如分组迭代、查找、重新排序和子集化等操作。所有这些任务在实践中都经常执行；让我们看看一些例子。
- en: 'Assume you have a large database of students in a university. You want to efficiently
    perform the following operations after grouping students by field of study (by
    *efficiently*, I mean without having to scan or move the source data, as it might
    be large):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个大学中学生的庞大数据库。你希望在按研究领域（按*高效*，即无需扫描或移动源数据，因为它可能很大）对学生进行分组后，高效地执行以下操作：
- en: Finding all students of mathematics (without having to perform a full table
    scan)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找所有数学专业的学生（无需执行完整表扫描）
- en: Arranging fields of studies by the number of students enrolled in them (without
    having to sort the source data frame)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按注册学生的数量对研究领域进行排序（无需对源数据框进行排序）
- en: Removing all fields of study with fewer than 10 students (without changing the
    source data frame)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除所有学生人数少于10个的研究领域（无需更改源数据框）
- en: 'You can perform these tasks by using GroupedDataFrame objects. We will discuss
    how to do them in this chapter. I divided this chapter into two sections:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 GroupedDataFrame 对象执行这些任务。我们将在本章中讨论如何执行它们。我将本章分为两个部分：
- en: Section 11.1 shows how to convert a data frame to values of other types that
    are often used in Julia.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第11.1节展示了如何将数据框转换为 Julia 中常用其他类型的值。
- en: Section 11.2 explains how to create a GroupedDataFrame from a source data frame
    using the groupby function, as well as how to work with it.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第11.2节解释了如何使用 groupby 函数从一个源数据框创建 GroupedDataFrame，以及如何使用它。
- en: 'While discussing how to convert a data frame object to other types, we examine
    two important concepts that you need to learn when working with Julia: *type stability*
    of code and *type piracy*. I explain both topics in section 11.1.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何将数据框对象转换为其他类型时，我们考察了您在处理Julia时需要学习的两个重要概念：代码的*类型稳定性*和*类型盗用*。我在第11.1节中解释了这两个主题。
- en: 11.1 Converting a data frame to other value types
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 将数据框转换为其他值类型
- en: In this section, you’ll learn how to convert a data frame into other value types.
    This operation is often needed when you have a function that does not accept a
    data frame as its argument, but you have data you want to pass to this function
    stored in a data frame.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何将数据框转换为其他值类型。当您有一个不接受数据框作为其参数的函数，但您有存储在数据框中的数据要传递给这个函数时，这种操作通常很需要。
- en: 'The most frequently encountered target types to which data frame objects get
    converted are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框对象最常遇到的目标类型转换如下：
- en: Matrix
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩阵
- en: NamedTuple of vectors
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量的命名元组
- en: Vector of NamedTuple
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名元组的向量
- en: Iterator of columns of a data frame
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据框列的迭代器
- en: Iterator of rows of a data frame
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据框行的迭代器
- en: 'In the examples of conversions, we will use the walk data frame we created
    in chapter 10\. Therefore, we first need to read it in from the walk.bin file
    by using the deserialize function:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换的示例中，我们将使用我们在第10章中创建的walk数据框。因此，我们首先需要使用deserialize函数从walk.bin文件中读取它：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A note on the meaning of conversion in Julia
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Julia中转换含义的说明
- en: In this chapter, I have used *convert* several times, meaning to take an object
    of one type and create an object of another type from it. For instance, I say
    that we convert a data frame to a NamedTuple of vectors. This meaning is consistent
    with an intuitive understanding of this word and is often encountered in practice.
    That is why I decided to use it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我多次使用了*转换*，意味着从一个类型的对象创建另一个类型的对象。例如，我说我们将数据框转换为向量的命名元组。这个含义与对这个词的直观理解一致，并且在实践中经常遇到。这就是我决定使用它的原因。
- en: 'However, in Julia, if we want to be precise, *conversion* has a narrower meaning.
    Julia defines the convert function, and Julia language purists might argue that
    conversion happens only if you use this function either explicitly or implicitly.
    An implicit use of the convert function happens when you perform an assignment
    of a value to an array. Consider the following operation:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Julia中，如果我们想精确一点，*转换*的含义更窄。Julia定义了convert函数，Julia语言的纯粹主义者可能会争论说，只有在使用这个函数时才会发生转换，无论是显式还是隐式。当您将一个值赋给数组时，就会发生convert函数的隐式使用。考虑以下操作：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The x variable is a vector of Float64. However, in the x[1] = 1 operation, we
    assign an integer to the first element of this vector. As you can see, the 1 integer
    gets implicitly converted to 1.0 float without us asking for it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: x变量是一个Float64的向量。然而，在x[1] = 1操作中，我们将一个整数赋值给这个向量的第一个元素。正如您所看到的，1这个整数在未要求的情况下被隐式地转换为1.0浮点数。
- en: Therefore, strictly speaking, conversion of an object to a type is different
    from construction of a value of this type. If you would like to learn more about
    the details of the distinction between conversion and construction, refer to the
    Julia Manual ([http://mng.bz/K0Z4](http://mng.bz/K0Z4)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，严格来说，将对象转换为一种类型与构造这种类型的值是不同的。如果您想了解更多关于转换和构造之间区别的细节，请参阅Julia手册([http://mng.bz/K0Z4](http://mng.bz/K0Z4))。
- en: In this book, for convenience and where this does not introduce ambiguity, I
    use the term *convert* in a loose sense (meaning we create a new object of a certain
    type, either when the convert method is invoked or when a type constructor is
    used).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，为了方便起见，并且当这不会引起歧义时，我使用*转换*这个术语（意味着我们在调用转换方法或使用类型构造函数时创建一个特定类型的新的对象）。
- en: 11.1.1 Conversion to a matrix
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.1 转换为矩阵
- en: In this section, you will learn how to convert a data frame to a matrix. You
    might need to perform this conversion if, for example, your data frame contains
    numeric values only, and you want to process them using linear algebra functions
    to check if the columns of a matrix are linearly independent.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何将数据框转换为矩阵。例如，如果您的数据框只包含数值，并且您想使用线性代数函数处理这些数值以检查矩阵的列是否线性无关，您可能需要执行这种转换。
- en: 'To convert a data frame to a matrix, pass it to a Matrix constructor:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据框转换为矩阵，可以通过传递给矩阵构造函数来实现：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The appropriate element type of the resulting matrix will automatically be
    detected. Optionally, you could specify it yourself by passing it as a parameter
    to the constructor:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的矩阵的适当元素类型将自动检测。你可以选择自己指定它，通过将其作为参数传递给构造函数：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Although passing the element type of a matrix is possible, it is rarely needed.
    Typically, it is better to rely on automatic type detection as it ensures that
    the operation will succeed. If you pass an incorrect element type to the constructor,
    you will get an error:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以传递矩阵的元素类型，但很少需要这样做。通常，最好依赖于自动类型检测，因为它确保操作将成功。如果你向构造函数传递了错误的元素类型，你会得到一个错误：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The conversion to a matrix allocates new memory for the resulting matrix, but
    apart from this, it is quite fast. It is useful when, in your analyses, you need
    to pass a matrix to a function. Let’s look at an example. If you pass a matrix
    to the plot function from Plots.jl, it draws several lines on a single plot. However,
    passing a data frame to the plot function is not supported:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 转换到矩阵为结果矩阵分配了新的内存，但除此之外，它相当快。当你在分析中需要将矩阵传递给函数时很有用。让我们看看一个例子。如果你将矩阵传递给Plots.jl的plot函数，它会在单个图表上绘制几条线。然而，将数据帧传递给plot函数是不支持的：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Instead, you can plot Matrix(walk):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以绘制Matrix(walk)：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Figure 11.1 shows the resulting plot. We have drawn two series of data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1显示了生成的图表。我们画了两系列数据。
- en: '![CH11_F01_Kaminski2](../Images/CH11_F01_Kaminski2.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![CH11_F01_Kaminski2](../Images/CH11_F01_Kaminski2.png)'
- en: Figure 11.1 Visualization of the walk data frame using two series of data. Note
    that we have moved the legend to the top-left corner of the plot (by default,
    the legend is shown in the top-right corner and would overlap with the graph).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 使用两系列数据可视化walk数据帧。请注意，我们已经将图例移动到图表的右上角（默认情况下，图例显示在右上角，会与图表重叠）。
- en: We have used two keyword arguments of the plot function here. The first is labels,
    which accepts a one-row matrix of series labels—in our case, ["x" "y"]. Note that
    it is not a vector (which would be written as ["x", "y"]). We have only put space
    between "x" and "y". The second keyword argument is legend, which allows us to
    specify the legend location. In this case, I have chosen to put it in the top-left
    corner of the plot.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了plot函数的两个关键字参数。第一个是labels，它接受一个包含系列标签的单行矩阵——在我们的例子中，["x" "y"]。请注意，它不是一个向量（将写作["x",
    "y"]）。我们只是在"x"和"y"之间放置了空格。第二个关键字参数是legend，它允许我们指定图例的位置。在这种情况下，我选择将其放在图表的右上角。
- en: 11.1.2 Conversion to a named tuple of vectors
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.2 向量命名元组的转换
- en: In this section, you will learn how to convert a data frame to a named tuple
    of vectors. This is sometimes done in practice because it can improve the performance
    of your code. In this section, you will see an example of when doing this might
    help. Additionally, such a conversion is cheap.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何将数据帧转换为向量的命名元组。在实践中，有时会这样做，因为它可以提高代码的性能。在本节中，你将看到一个例子，说明这样做可能有所帮助。此外，这种转换成本很低。
- en: 'The conversion itself is simple. Just call the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 转换本身很简单。只需调用以下：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The operation does not copy the vectors stored in the source data frame and
    retains column names. Recall that conversion to a matrix, which we discussed in
    section 11.1.1, loses information about column names in the source data frame
    and allocates new memory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作不会复制源数据帧中存储的向量，并保留列名。回想一下，我们在11.1.1节中讨论的矩阵转换会丢失源数据帧中的列名信息，并分配新的内存。
- en: 'At this point, you can see that DataFrame and a NamedTuple of vectors seem
    similar. Both store data in columns and support column names. Let’s discuss the
    most important reasons why both are useful and when they should be used. Understanding
    this topic is one of the fundamental pieces of advanced knowledge of working with
    tabular data in Julia. It is related to two key features that differentiate DataFrame
    from a NamedTuple of vectors:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以看到DataFrame和向量的NamedTuple看起来很相似。两者都在列中存储数据，并支持列名。让我们讨论为什么两者都很有用以及何时应该使用它们。理解这个主题是Julia中处理表格数据的高级知识的基本组成部分之一。它与区分DataFrame和向量NamedTuple的两个关键特性有关：
- en: DataFrame is a type-unstable object, while a NamedTuple of vectors is type stable.
    This distinction is related to the performance of both container types.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataFrame是一个类型不稳定的对象，而向量的NamedTuple是类型稳定的。这种区别与这两种容器类型的性能有关。
- en: DataFrame is a type defined in the DataFrames.jl package, while the NamedTuple
    type is defined in Julia without loading any packages. Maintainers of the DataFrames.jl
    package have much greater flexibility in defining the behavior of DataFrame objects.
    This distinction is related to *type piracy*.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DataFrame 是在 DataFrames.jl 包中定义的类型，而 NamedTuple 类型是在 Julia 中定义的，无需加载任何包。DataFrames.jl
    包的维护者有更大的灵活性来定义 DataFrame 对象的行为。这种区别与 *类型盗用* 相关。
- en: Next, we will first discuss the type stability issue and then the type piracy
    issue.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将首先讨论类型稳定性问题，然后是类型盗用问题。
- en: Type stability in Julia
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 中的类型稳定性
- en: We say that some Julia code is *type stable* if Julia can determine the types
    of all variables used in this code at compile time. If this condition is met,
    Julia code can be executed quickly. Otherwise, it might be slow.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说，如果 Julia 能够在编译时确定该代码中所有变量的类型，那么这段 Julia 代码就是 *类型稳定的*。如果满足这个条件，Julia 代码可以快速执行。否则，它可能运行缓慢。
- en: I explain the consequence of type stability with an example of the DataFrame
    object, as this is the core topic of this book. If you would like to learn more
    about related performance considerations, see the “Performance Tips” section of
    the Julia Manual ([http://mng.bz/9Vda](http://mng.bz/9Vda)).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过 DataFrame 对象的例子解释了类型稳定性的后果，因为这是本书的核心主题。如果你想了解更多关于相关性能考虑的内容，请参阅 Julia 手册中的“性能提示”部分
    ([http://mng.bz/9Vda](http://mng.bz/9Vda))。
- en: From the point of view of the Julia compiler, every column of a DataFrame is
    an AbstractVector. If you extract a column from a data frame, the compiler is
    not able to infer its concrete type. As a consequence, the operations on that
    column will be slow.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Julia 编译器的角度来看，DataFrame 的每一列都是一个 AbstractVector。如果你从一个数据框中提取一列，编译器无法推断其具体类型。因此，对该列的操作将会缓慢。
- en: 'Here is an example. We want to manually compute a sum of elements of a single
    column of a data frame. In the example, when I write the 1_000_000 literal, Julia
    ignores the underscores, which makes it easier to read this number:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子。我们想要手动计算数据框单列元素的总和。在示例中，当我写下 1_000_000 这个字面量时，Julia 忽略了下划线，这使得阅读这个数字更容易：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Assumes we sum integers
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 假设我们求和整数
- en: ❷ Assumes the table has the property x that is its column
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 假设表具有 x 是其列的性质
- en: 'We see that the operation has made a lot of allocations, but assessing whether
    the time is good or bad is initially hard. However, let’s create a NamedTuple
    of vectors from our df data frame and benchmark its performance:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到操作进行了大量的分配，但评估时间是否良好或糟糕最初是困难的。然而，让我们从我们的 df 数据框中创建一个向量 NamedTuple 并对其性能进行基准测试：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We see no allocations and a much faster execution time, so running this code
    on the df data frame is not a good choice from a performance perspective.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到没有分配，并且执行时间快得多，因此从性能角度来看，在 df 数据框上运行此代码不是一个好的选择。
- en: What is the difference between the df and tab objects? As I have said, all columns
    of a DataFrame are seen by the compiler as AbstractVector. Since AbstractVector
    is an abstract container (recall the discussion of the difference between abstract
    versus concrete types in chapter 3), the Julia compiler does not know the actual
    memory layout of a value having this type and is forced to use generic (and thus
    slow) code that handles it. In the tab object, the Julia compiler knows that column
    x has the Vector{Int64} type. This type is concrete, so Julia can generate optimal
    machine code for doing the computations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: df 和 tab 对象之间的区别是什么？正如我所说的，DataFrame 的所有列在编译器看来都是 AbstractVector。由于 AbstractVector
    是一个抽象容器（回想一下第 3 章中关于抽象类型与具体类型之间区别的讨论），Julia 编译器不知道具有这种类型的值的实际内存布局，因此被迫使用通用的（因此较慢的）代码来处理它。在
    tab 对象中，Julia 编译器知道列 x 的类型是 Vector{Int64}。这是一个具体类型，因此 Julia 可以生成用于执行计算的优化机器代码。
- en: 'This can be confirmed by running the @code_warntype macro on the mysum(df)
    function call:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在 mysum(df) 函数调用上运行 @code_warntype 宏来确认：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The @code_warntype macro tells us how the compiler sees our function call. You
    do not need to understand all the details of this printout. It is enough to check
    that the compiler gets a proper idea of which data types it is processing. In
    general, if something is problematic, you will see it highlighted in red (bold
    in this book). We can see that the column x of our data frame is seen as AbstractVector,
    which is printed in red, and you have several Any values also printed in red.
    This is a signal that the code will not run fast.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '@code_warntype 宏告诉我们编译器如何看待我们的函数调用。您不需要理解这个打印输出的所有细节。只需检查编译器是否对正在处理的数据类型有一个恰当的理解即可。一般来说，如果有问题，您会看到它以红色突出显示（本书中为粗体）。我们可以看到，我们的数据框的列
    x 被视为 AbstractVector，并以红色打印，您还有几个 Any 值也被打印为红色。这是一个信号，表明代码将无法快速运行。'
- en: 'Let’s check the @code_warntype macro call on the mysum(tab) object:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 mysum(tab) 对象上的 @code_warntype 宏调用：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This time, nothing is printed in red, and we see that Julia identifies types
    of all values. This means that we can expect mysum(tab) to be executed fast.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，没有红色打印的内容，我们看到 Julia 识别了所有值的类型。这意味着我们可以期待 mysum(tab) 能够快速执行。
- en: 'Why is it possible for Julia to do proper type inference on the tab object?
    The reason is that names and types of the columns stored in it are encoded in
    its type:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 Julia 能够对 tab 对象进行正确的类型推断？原因是存储在其中的列的名称和类型编码在其类型中：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have just seen a benefit of this fact: the operations working with the tab
    object are fast. However, downsides must exist, as DataFrames.jl developers decided
    not to make the DataFrame object type stable. There are two problems:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了这个事实的好处：与 tab 对象一起工作的操作是快速的。然而，必须存在一些缺点，因为 DataFrames.jl 开发者决定不使 DataFrame
    对象类型稳定。有两个问题：
- en: Since column names and types are part of the tab object’s type definition, they
    cannot be changed dynamically. You cannot add, remove, change the type of, or
    rename columns of a NamedTuple of vectors (as you learned in chapter 4, NamedTuple
    is immutable).
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于列名和类型是 tab 对象类型定义的一部分，它们不能动态更改。您不能添加、删除、更改类型或重命名向量的 NamedTuple 的列（如您在第 4 章中学到的，NamedTuple
    是不可变的）。
- en: Compiling a NamedTuple of vectors that contains many columns is expensive. As
    a rule of thumb, over 1,000 columns is problematic, and you should avoid such
    operations.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译包含许多列的向量 NamedTuple 是昂贵的。一般来说，超过 1,000 列是问题，您应该避免此类操作。
- en: Exercise 11.1 Measure the time required to create a data frame having 1 row
    and 10,000 columns consisting of only 1s. Use the matrix created by ones(1, 10_000)
    as a source, along with automatic column names. Next, measure the time required
    to create a NamedTuple of vectors from this data frame.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 11.1 测量创建一个包含 1 行和 10,000 列（仅包含 1s）的数据框所需的时间。使用由 ones(1, 10_000) 创建的矩阵作为源，并带有自动列名。接下来，测量从该数据框创建向量
    NamedTuple 所需的时间。
- en: 'For these reasons, the design of the DataFrame object starts to make sense;
    it is much more flexible and Julia-compiler-friendly than a NamedTuple of vectors.
    However, there is one issue: how to overcome type instability of objects having
    a DataFrame type.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，DataFrame 对象的设计开始变得有意义；它比向量的 NamedTuple 更灵活，也更符合 Julia 编译器的风格。然而，有一个问题：如何克服具有
    DataFrame 类型的对象的类型不稳定性。
- en: 'We can use one simple trick, called a *function-barrier method* ([http://mng.bz/jAXy](http://mng.bz/jAXy)),
    to accomplish this. Extracting a column from a data frame within a function is
    slow, but if you pass this extracted column next to another function, the compiler
    will properly identify the column type in this inner function, and things will
    be fast. You can think of it as follows: every time you enter a function, the
    compiler performs a type check of its arguments. Here is an example of solving
    the type instability problem of the mysum function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个简单的技巧，称为 *函数屏障方法* ([http://mng.bz/jAXy](http://mng.bz/jAXy)) 来实现这一点。在函数内部从数据框中提取列是缓慢的，但如果您将提取的列传递给另一个函数旁边，编译器将正确地识别这个内部函数中的列类型，这样就会变得快速。您可以这样想：每次您进入一个函数，编译器都会对其参数执行类型检查。以下是一个解决
    mysum 函数类型不稳定性问题的示例：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have a very fast execution time now, like mysum(tab). We see only one allocation.
    It is related to the table.x operation, which is type unstable. However, once
    we are inside the barrier_mysum2 function, everything is type stable as the Julia
    compiler correctly identifies the type of its argument x. It is crucial to understand
    that the type of table.x is not known in the mysum2 function, but once it gets
    passed to the barrier_mysum2 function, it becomes known inside it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有非常快的执行时间，就像mysum(tab)。我们看到只有一个分配。它与table.x操作相关，这是一个类型不稳定的操作。然而，一旦我们进入barrier_mysum2函数内部，一切就都是类型稳定的，因为Julia编译器正确地识别了其参数x的类型。理解table.x的类型在mysum2函数中是未知的，但一旦它传递给barrier_mysum2函数，它就在函数内部变得已知，这一点至关重要。
- en: As you can see, the solution is relatively simple. For many operations that
    we will discuss in the remaining chapters, DataFrames.jl automatically creates
    such kernel functions, so in practice, most of the time, you do not even have
    to think about it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，解决方案相对简单。对于我们在剩余章节中将要讨论的许多操作，DataFrames.jl会自动创建这样的内核函数，所以在实践中，大多数时候你甚至不需要考虑它。
- en: In summary, the design of the DataFrame object combined with the functionalities
    built into DataFrames.jl bring you the flexibility of mutating and low compilation
    cost of the DataFrame object, as well as fast execution time of computations by
    using the function-barrier method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，DataFrame对象的设计与DataFrames.jl中内置的功能相结合，为您带来了DataFrame对象的修改灵活性和低编译成本，以及通过使用函数屏障方法计算的高执行速度。
- en: Nevertheless, sometimes the standard methods provided by DataFrames.jl do not
    give you the expected performance (these cases are rare in my experience). Then
    you might want to create a temporary NamedTuple of vectors for analysis of your
    data if you have a data frame with only a few columns and you know you do not
    want to mutate it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，有时DataFrames.jl提供的标准方法并不能给你预期的性能（在我的经验中，这些情况很少见）。然后，如果你有一个只有几个列的数据框，并且你知道你不想修改它，你可能想创建一个临时的向量NamedTuple来分析你的数据。
- en: Type piracy in Julia
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中的类型盗用
- en: The second reason we need a special DataFrame type is related to *type piracy*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要特殊DataFrame类型的第二个原因与**类型盗用**相关。
- en: Note You can skip this section on the first reading of this book, as this topic
    is a bit more advanced. However, understanding type piracy is essential if you
    want to create a Julia package on your own in the future.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以在第一次阅读这本书时跳过这一节，因为这个主题稍微复杂一些。然而，如果你想在将来自己创建Julia包，理解类型盗用是至关重要的。
- en: The Julia manual defines *type piracy* as *the practice of extending or redefining
    methods in Base or other packages on types that you have not defined* ([http://mng.bz/WMEx](http://mng.bz/WMEx)).
    I explain what this means and the potential consequences through examples.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Julia手册将**类型盗用**定义为**在您未定义的类型上扩展或重新定义Base或其他包中的方法的实践**([http://mng.bz/WMEx](http://mng.bz/WMEx))。我通过示例解释了这意味着什么以及可能产生的后果。
- en: As you have seen in this chapter, the DataFrame type supports many standard
    functions defined in Base Julia, including push!, append!, vcat, unique, and unique!.
    DataFrames.jl developers can safely define methods for these functions for the
    DataFrame type since it is defined in DataFrames.jl. There is no risk that we
    will break existing code by making our custom definitions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章中看到的，DataFrame类型支持许多在Base Julia中定义的标准函数，包括push!、append!、vcat、unique和unique!。由于DataFrame类型在DataFrames.jl中定义，DataFrames.jl的开发者可以安全地为这些函数为DataFrame类型定义方法。我们通过自定义定义破坏现有代码的风险为零。
- en: 'Now imagine we start to define a special method for unique on a NamedTuple
    of vectors. Remember that running unique on a data frame object de-duplicates
    its rows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们开始为向量NamedTuple上的unique定义一个特殊方法。记住，在数据框对象上运行unique会去重其行：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now check what happens if we run unique on a NamedTuple of vectors:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在检查如果我们对一个向量NamedTuple运行unique会发生什么：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Instead of de-duplicating rows, we get unique columns of tab. This is the default
    behavior of unique when it is passed a NamedTuple built into Base Julia. Therefore,
    we must not create a custom unique definition for a NamedTuple of vectors, even
    if we want to, because it could break existing code that relies on the way unique
    works by default on NamedTuple objects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是去重行，而是得到tab的唯一列。这是unique在传递给Base Julia内置的NamedTuple时的默认行为。因此，我们绝对不能为向量的NamedTuple创建一个自定义的unique定义，即使我们想这么做，因为这可能会破坏依赖于unique在NamedTuple对象上默认工作方式的现有代码。
- en: In conclusion, since we define our own DataFrame type, we are free to define
    the way functions work on it in any way we like (even functions from Base Julia).
    On the other hand, if you have a type and a function defined in Base Julia, you
    are not allowed to do this, as this would be type piracy. DataFrames.jl developers
    can define the behavior of values of the DataFrame type in the way that is most
    user-friendly without being constrained by the default behaviors defined in Base
    Julia.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，由于我们定义了自己的DataFrame类型，我们可以自由地以任何我们喜欢的方式定义函数在其上的工作方式（甚至可以是从Base Julia来的函数）。另一方面，如果你在Base
    Julia中定义了一个类型和一个函数，你不允许这样做，因为这将是类型盗用。DataFrames.jl的开发者可以以最用户友好的方式定义DataFrame类型值的行为了，而不受Base
    Julia中定义的默认行为的约束。
- en: Selected packages that offer type-stable table-like objects
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 提供类型稳定表格对象的选定包
- en: The Julia ecosystem has several implementations of table-like types that are
    type stable, as opposed to the DataFrame type defined in DataFrames.jl. Here is
    a list of selected packages that provide such functionality.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Julia生态系统中有几种类型稳定的表格类型实现，与DataFrames.jl中定义的DataFrame类型相反。以下是一个提供此类功能的选定包列表。
- en: The TypedTables.jl package provides the Table type. To the user, a Table presents
    itself as an array of named tuples. Each row of the table is represented as a
    NamedTuple. Internally, a Table stores a named tuple of arrays and is a convenient
    structure for column-based storage of tabular data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: TypedTables.jl包提供了Table类型。对于用户来说，Table呈现为一个命名元组的数组。表格的每一行都表示为一个命名元组。内部，Table存储一个数组的命名元组，并且是列存储表格数据的方便结构。
- en: Another similar package is TupleVectors.jl, which defines the TupleVector type.
    Again, to the user, it looks like a vector of named tuples, but it is stored internally
    as a NamedTuple of vectors. An interesting feature of this package is that it
    supports column nesting; see [https://github.com/cscherrer/TupleVectors.jl](https://github.com/cscherrer/TupleVectors.jl)
    for details.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类似的包是TupleVectors.jl，它定义了TupleVector类型。同样，对于用户来说，它看起来像是一个命名元组的向量，但它在内部存储为一个向量命名元组。这个包的一个有趣特性是它支持列嵌套；有关详细信息，请参阅[https://github.com/cscherrer/TupleVectors.jl](https://github.com/cscherrer/TupleVectors.jl)。
- en: Finally, the StructArrays.jl package provides the StructArray type. This type
    is an AbstractArray whose elements are any struct objects, like, for example,
    NamedTuple (see chapter 4 for a discussion of struct types). However, its internal
    memory layout is column based (each field of the struct is stored in a separate
    Array).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，StructArrays.jl包提供了StructArray类型。这种类型是一个AbstractArray，其元素可以是任何结构对象，例如命名元组（参见第4章中关于结构类型的讨论）。然而，它的内部内存布局是基于列的（结构中的每个字段都存储在一个单独的Array中）。
- en: Which package should you pick for your data analysis? In my experience, DataFrames.jl
    will most often be the best choice. It is currently the most feature-rich package.
    Also, a benefit of DataFrame being type unstable is that you can effortlessly
    process very wide tables and can mutate tables in place. However, you might hit
    a performance bottleneck when working with DataFrames.jl. It might happen, for
    example, when you process millions of tables containing very few rows and columns.
    In such a case, you can consider using a NamedTuple of vectors (recall from this
    section that you can use Tables.columntable to create it from a data frame) or
    using one of the packages I have listed (TypedTables.jl, TupleVectors.jl, or StructArrays.jl)
    to improve the execution speed of your code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该选择哪个包来进行数据分析？根据我的经验，DataFrames.jl通常会是最优选择。它目前是功能最丰富的包。此外，DataFrame类型不稳定的一个好处是你可以轻松处理非常宽的表格，并且可以在原地修改表格。然而，当使用DataFrames.jl处理包含非常少行和列的数百万个表格时，你可能会遇到性能瓶颈。在这种情况下，你可以考虑使用向量的命名元组（回想一下本节中提到的，你可以使用Tables.columntable从数据框创建它）或者使用我列出的其中一个包（TypedTables.jl,
    TupleVectors.jl或StructArrays.jl）来提高你代码的执行速度。
- en: 11.1.3 Other common conversions
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1.3 其他常见转换
- en: I’ll finish this section by summarizing some more common conversions that are
    often used in practice. Apart from conversion to a Matrix and to a NamedTuple
    of vectors that we already discussed, I list other common conversions in table
    11.1\. In the following subsections, I discuss them, also explaining when and
    why you might want to use them. In the examples, we will keep using the walk data
    frame that we deserialized at the beginning of this section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '我将通过总结一些在实践中被广泛使用的更常见的转换来结束本节。除了我们已讨论的转换为矩阵和向量NamedTuple之外，我在表11.1中列出了其他常见的转换。在以下小节中，我将讨论它们，并解释何时以及为什么你可能想使用它们。在示例中，我们将继续使用本节开头反序列化的walk数据框。 '
- en: Table 11.1 Selected conversion methods of data frame objects. In all example
    code, I assume that df is a data frame.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.1 数据框对象选择的转换方法。在所有示例代码中，我假设df是一个数据框。
- en: '| Output value | Meaning | Example code | Allocates memory for data | Type
    stable |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 输出值 | 含义 | 示例代码 | 分配数据内存 | 类型稳定 |'
- en: '| Matrix | Columns of the matrix are columns of data. | Matrix(df) | Yes |
    Yes or no |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 矩阵 | 矩阵的列是数据列。 | Matrix(df) | 是 | 是或否 |'
- en: '| NamedTuple of vectors | Each element of the named tuple is a column of data.
    | Tables.columntable(df) | No | Yes |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 向量NamedTuple | 命名元组的每个元素是数据的一列。 | Tables.columntable(df) | 否 | 是 |'
- en: '| Vector of NamedTuple | Each element of the vector is one row of data. | Tables.rowtable(df)
    | Yes | Yes |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 向量行数据 | 向量的每个元素是一行数据。 | Tables.rowtable(df) | 是 | 是 |'
- en: '| Iterator of NamedTuple | Each iterated element is one row of data. | Tables.namedtupleiterator(df)
    | No | Yes |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| NamedTuple迭代器 | 每个迭代的元素是一行数据。 | Tables.namedtupleiterator(df) | 否 | 是 |'
- en: '| Collection of DataFrameRow | Each element of the collection is one row of
    data. | eachrow(df) | No | No |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| DataFrameRow集合 | 集合的每个元素是一行数据。 | eachrow(df) | 否 | 否 |'
- en: '| Collection of data frame columns | Each element of the collection is one
    column of data. | eachcol(df) | No | No |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 数据框列集合 | 集合的每个元素是一列数据。 | eachcol(df) | 否 | 否 |'
- en: '| Vector of data frame columns | Each element of the vector is one column of
    data. | identity.(eachcol(df)) | No | Yes or no |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 数据框列向量 | 向量的每个元素是一列数据。 | identity.(eachcol(df)) | 否 | 是或否 |'
- en: Vector of NamedTuple
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: NamedTuple向量
- en: 'We start with creating a Vector of NamedTuple. This conversion is useful if
    you later want to process the data row by row:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建NamedTuple向量开始。这种转换在稍后按行处理数据时很有用：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The benefit of this object is that it is type stable and can be worked with
    later, just like any other vector. The downside is that for wide tables, it is
    expensive to compile and allocates memory.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象的优点是它是类型稳定的，可以像其他任何向量一样稍后进行处理。缺点是对于宽表，编译成本很高，并且会分配内存。
- en: Iterator of NamedTuple
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: NamedTuple迭代器
- en: 'If you want to avoid memory allocation, use an iterator of NamedTuple. The
    downside is that you cannot work with this object as you can with vectors. You
    can only iterate it:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想避免内存分配，请使用NamedTuple的迭代器。缺点是，你不能像处理向量那样处理这个对象。你只能迭代它：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Type-unstable iterators of rows and columns of a data frame
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框行和列的类型不稳定迭代器
- en: 'If we accept that we work with type-unstable collections, we can call eachrow
    and eachcol to get iterable and indexable objects producing rows (as DataFrameRow)
    and columns (as vectors) from the source data frame, respectively:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们接受处理类型不稳定的集合，我们可以调用eachrow和eachcol来获取可迭代和可索引的对象，分别从源数据框中生成行（作为DataFrameRow）和列（作为向量）：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Collections produced by eachrow and eachcol, called with a data frame argument,
    do not copy data and have a low compilation cost at the expense of being slower
    because the compiler can’t generate optimal code when working with them. This
    issue is especially important for eachrow if we work with a data frame that has
    millions of rows. To efficiently handle such cases, the nonallocating Tables.namedtupleiterator
    function was introduced (you must remember not to pass to it very wide tables,
    as then its compilation cost gets very high).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据框参数调用eachrow和eachcol产生的集合，不复制数据，编译成本低，但速度较慢，因为编译器在处理它们时无法生成最优代码。这个问题对于处理具有数百万行数据的数据框的eachrow尤为重要。为了有效地处理这种情况，引入了非分配的Tables.namedtupleiterator函数（你必须记住不要向它传递非常宽的表，因为这样它的编译成本会非常高）。
- en: Vector of vectors
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 向量向量
- en: 'The last conversion option we will discuss is a vector of data frame columns
    created with identity.(eachcol(df)), as shown in table 6.1\. You might be wondering
    why we are broadcasting the identity function over columns of a data frame. This
    operation achieves two goals: it changes the DataFrameColumns collection returned
    by the eachcol function to a Vector, and if columns of the passed data frame have
    the same type, this type will be correctly identified as an element type of the
    returned vector. Therefore, for a cost of allocating the outer vector (which should
    typically be low), the returned value will be fast to work with later:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的最后一种转换选项是使用identity函数创建的data frame列向量（eachcol(df)），如表6.1所示。你可能想知道为什么我们要将identity函数广播到data
    frame的列上。这个操作实现了两个目标：它将eachcol函数返回的DataFrameColumns集合转换为Vector，并且如果传递的data frame的列具有相同的类型，这个类型将被正确地识别为返回向量的元素类型。因此，以分配外部向量的代价（这通常应该是很低的），返回的值将便于后续操作：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, you see that the element type of the produced vector is correctly
    identified as Vector{Int64}, as all columns of the passed data frame have the
    same element type.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以看到生成的向量的元素类型被正确地识别为Vector{Int64}，因为传递的data frame的所有列都具有相同的元素类型。
- en: 'Note that this would not hold if we passed a data frame having heterogeneous
    column types:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们传递一个具有异构列类型的data frame，则这种情况可能不成立：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This time, the element type of the produced vector is Vector (which is not a
    concrete type, as explained in chapter 5). Therefore, code that worked later with
    a value having the Vector{Vector} type would not be type stable. For this reason,
    table 6.1 indicates that identity.(eachcol(df))can be type stable or not, depending
    on which types have columns stored in the source data frame.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，生成的向量的元素类型是Vector（如第5章所述，这不是一个具体类型）。因此，后来与具有Vector{Vector}类型的值一起工作的代码将不会是类型稳定的。因此，表6.1表明identity.(eachcol(df))可以是类型稳定的，也可以不是，这取决于源data
    frame中存储的列的类型。
- en: 11.2 Grouping data frame objects
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 数据框对象分组
- en: In this section, we discuss how to create a GroupedDataFrame object from a data
    frame and work with it. The GroupedDataFrame object is a wrapper around a source
    data frame and is useful when you want to perform operations on your data in groups.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何从data frame创建GroupedDataFrame对象并与之交互。GroupedDataFrame对象是源data frame的包装器，当你在组内对数据进行操作时非常有用。
- en: As discussed in the introduction to this chapter, grouping data is the first
    step in performing split-apply-combine transformations. These transformations
    are useful if you want to work with grouped data by performing such operations
    as group lookup or group reordering. In this section, we concentrate on how to
    work with GroupedDataFrame objects directly, while in the remaining chapters,
    you will learn how to use them to perform split-apply-combine transformations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言中所述，分组数据是执行split-apply-combine转换的第一步。如果你想要通过执行如分组查找或分组重排等操作来处理分组数据，这些转换非常有用。在本节中，我们将集中讨论如何直接处理GroupedDataFrame对象，而在接下来的章节中，你将学习如何使用它们来执行split-apply-combine转换。
- en: 11.2.1 Preparing the source data frame
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 准备源数据框
- en: 'In this section, we will create a data frame that we will use in the examples
    of data frame grouping. I have chosen the data set that I use in the JuliaAcademy
    course on DataFrames.jl ([https://github.com/JuliaAcademy/DataFrames](https://github.com/JuliaAcademy/DataFrames)).
    It shows the amount of rainfall in two towns over several days of 2020\. It has
    only 10 rows so that it will be easier to understand the consequences of operations
    we perform. We start by reading in the data into a DataFrame:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个数据框，我们将在数据框分组的示例中使用它。我选择了我在JuliaAcademy的DataFrames.jl课程中使用的数据集（[https://github.com/JuliaAcademy/DataFrames](https://github.com/JuliaAcademy/DataFrames)）。它显示了2020年几个城镇的降雨量。它只有10行，这样我们就可以更容易地理解我们执行的操作的后果。我们首先将数据读入DataFrame：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This time, we store the source CSV data in a raw_data string. Next, we use the
    IOBuffer function on it to create an in-memory file-like object that can be read
    in by the CSV.read function. Note that if we (incorrectly, in this case) had passed
    a string to the CSV.read function as a first argument, the function would treat
    the argument as a filename, which is not what we want.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将源CSV数据存储在raw_data字符串中。接下来，我们使用IOBuffer函数处理它，以创建一个内存中的文件-like对象，该对象可以被CSV.read函数读取。请注意，如果我们（在这种情况下，不正确地）将字符串传递给CSV.read函数作为第一个参数，该函数会将该参数视为文件名，这并不是我们想要的。
- en: The rainfall_df data frame that we created stores information about the rainfall
    in millimeters in two cities (Olecko and Ełk) for several days in November 2020.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 `rainfall_df` 数据框存储了两个城市（Olecko和Ełk）在2020年11月几天内的降雨量（以毫米为单位）的信息。
- en: 11.2.2 Grouping a data frame
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 对数据框进行分组
- en: 'In this section, you will learn how to group a data frame by using the groupby
    function. We start our analysis by grouping the data by city name and storing
    the result in the gdf_city GroupedDataFrame:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用 `groupby` 函数对数据框进行分组。我们通过按城市名称对数据进行分组并存储结果在 `gdf_city` 分组数据框中开始我们的分析：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When we print the gdf_city object, we first get the information that it consists
    of two groups and that the grouping key is the column city. Then the contents
    of the first and last group are displayed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印 `gdf_city` 对象时，我们首先得到它由两个组组成的信息，以及分组键是列 `city`。然后显示第一组和最后一组的内 容。
- en: 'You can pass any column selector (we discussed column selectors in chapter
    9) to specify the columns used to group your data frame. For example, to group
    the rainfall_df data frame on all columns except rainfall, write this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将任何列选择器（我们在第9章中讨论了列选择器）传递给 `groupby` 函数，以指定用于分组数据框的列。例如，要按除降雨量之外的所有列对 `rainfall_df`
    数据框进行分组，请编写以下代码：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This time, our data is split into 10 groups by unique combinations of values
    stored in the city and date columns.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们的数据根据存储在 `city` 和 `date` 列中的唯一值组合分成10组。
- en: Available options during grouping of a data frame
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在对数据框进行分组时可用选项
- en: The groupby function has two keyword arguments, sort and skipmissing, that you
    can optionally pass to change the way the resulting GroupedDataFrame is created.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby` 函数有两个关键字参数，`sort` 和 `skipmissing`，您可以可选地传递这些参数以更改创建结果 `GroupedDataFrame`
    的方式。'
- en: The sort keyword argument defines the order of groups in the returned GroupedDataFrame.
    By default (sort=nothing), this order is undefined. In this case, you ask groupby
    to group the data by using the fastest algorithm that it supports. Use this option
    if you care about grouping operation speed when working with large data frames.
    If you pass sort=true, groups are ordered according to the values of the grouping
    columns. If you pass sort=false, groups are created in the order of their appearance
    in the source data frame.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort` 关键字参数定义了返回的 `GroupedDataFrame` 中组的顺序。默认情况下（`sort=nothing`），此顺序是未定义的。在这种情况下，您要求
    `groupby` 使用它支持的最快算法对数据进行分组。如果您在处理大型数据框时关心分组操作的速度，请使用此选项。如果您传递 `sort=true`，则组将根据分组列的值进行排序。如果您传递
    `sort=false`，则组将按照它们在源数据框中出现的顺序创建。'
- en: The skipmissing keyword argument takes Boolean values. By default, it is set
    to false, which means that all groups present in the source data frame are kept
    in the result. If you pass skipmissing=true instead, groups with missing values
    in one of the grouping columns will be dropped from the result.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`skipmissing` 关键字参数接受布尔值。默认情况下，它设置为 `false`，这意味着在结果中保留源数据框中出现的所有组。如果您传递 `skipmissing=true`，则具有分组列中缺失值的组将从结果中删除。'
- en: 11.2.3 Getting group keys of a grouped data frame
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3 获取分组数据框的组键
- en: In this section, you will learn how to check the grouping keys corresponding
    to each group in a GroupedDataFrame. This information is useful when you want
    to learn what groups your GroupedDataFrame stores.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何检查与 `GroupedDataFrame` 中每个组对应的分组键。当您想了解您的 `GroupedDataFrame` 存储了哪些组时，这些信息很有用。
- en: 'When you work with large GroupedDataFrame objects, it is often hard to understand
    which groups it holds. For example, we know that gdf_city_date has 10 groups,
    but we do not see all of them since this would take too much space. To get this
    information, you can use the keys function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当您处理大型 `GroupedDataFrame` 对象时，通常很难理解它包含哪些组。例如，我们知道 `gdf_city_date` 有10个组，但由于这会占用太多空间，我们看不到所有这些组。要获取此信息，您可以使用
    `keys` 函数：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The keys function returns a vector storing GroupKey objects that behave like
    named tuples holding the values of the grouping columns for a given group. You
    can easily convert the GroupKey object to a tuple, named tuple, or dictionary
    if you wanted to later use such objects in your code. Here is an example of such
    a conversion for the first group:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys` 函数返回一个存储 `GroupKey` 对象的向量，这些对象的行为类似于命名元组，用于保存给定组中分组列的值。如果您想在代码中稍后使用此类对象，可以轻松地将
    `GroupKey` 对象转换为元组、命名元组或字典。以下是对第一个组进行此类转换的示例：'
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 11.2.4 Indexing a grouped data frame with a single value
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.4 使用单个值索引分组数据框
- en: In this section, you will learn how to use indexing to get a single group from
    a grouped data frame. This is a fundamental operation you need to learn for working
    with GroupedDataFrame objects.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用索引从一个分组数据框中获取单个组。这是你需要学习的基本操作，以便与 GroupedDataFrame 对象一起工作。
- en: You now know how to get information about group keys for a GroupedDataFrame.
    Let’s turn to getting the data stored in the groups. Fortunately, this is easy
    since GroupedDataFrame objects support indexing, just like vectors.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道了如何获取 GroupedDataFrame 的组键信息。让我们转向获取存储在组中的数据。幸运的是，这很容易，因为 GroupedDataFrame
    对象支持索引，就像向量一样。
- en: Importantly, you can index into a GroupedDataFrame by using normal vector indexing
    with integers, but you also can pass a GroupKey, Tuple, NamedTuple, or dictionary
    to select the group you would like to pick.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，你可以使用正常的向量索引整数来索引 GroupedDataFrame，但你也可以传递一个 GroupKey、Tuple、NamedTuple
    或字典来选择你想要选择的组。
- en: 'Let’s look at an example. The following are equivalent ways to extract the
    first group from our gdf_city_date object:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。以下是从我们的 gdf_city_date 对象中提取第一个组的不同等效方法：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Lookup using an integer
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用整数进行查找
- en: ❷ Lookup using a GroupKey
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 GroupKey 进行查找
- en: ❸ Lookup using a tuple
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用元组进行查找
- en: ❹ Lookup using a named tuple
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用命名元组进行查找
- en: ❺ Lookup using a dictionary
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用字典进行查找
- en: In all five indexing scenarios in the code, we obtain a data frame that stores
    rows from our original rainfall_df data frame. The returned object is a SubDataFrame,
    which means, as you learned in chapter 9, that this is a view. This design choice
    was made to ensure that getting a single group from a GroupedDataFrame is fast,
    as it does not involve copying the source data.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中的所有五个索引场景中，我们获得了一个存储来自我们原始 rainfall_df 数据框的行的数据框。返回的对象是一个子数据框，这意味着，正如你在第
    9 章中学到的，这是一个视图。这个设计选择是为了确保从 GroupedDataFrame 中获取单个组是快速的，因为它不涉及复制源数据。
- en: 'To see one more example of group lookup, let’s extract a group corresponding
    to the city Olecko from the gdf_city object (recall that gdf_city is grouped by
    a single column, city):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到更多关于组查找的例子，让我们从 gdf_city 对象中提取与城市 Olecko 对应的组（回想一下，gdf_city 是按单个列 city 分组的）：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Indexing using a tuple
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用元组进行索引
- en: ❷ Indexing using a named tuple
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用命名元组进行索引
- en: As you can see, it is easy to look up a concrete group when you know which key
    values you are interested in.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当你知道你感兴趣的关键值时，查找具体的组很容易。
- en: You might ask why it is required to pass values identifying groups in collections
    like Tuple or NamedTuple. In general, you can group a data frame by multiple columns,
    so DataFrames.jl needs to accept collections of values to identify groups. As
    we discussed, the only exception is passing an integer as an index, in which case
    it is interpreted as a group number.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问为什么在像 Tuple 或 NamedTuple 这样的集合中传递标识组的值是必需的。一般来说，你可以通过多个列对数据框进行分组，所以 DataFrames.jl
    需要接受值集合来标识组。正如我们讨论的那样，唯一的例外是传递一个整数作为索引，在这种情况下，它被解释为组号。
- en: 11.2.5 Comparing performance of indexing methods
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.5 比较索引方法性能
- en: In this section, we compare the speed of the indexing methods discussed in section
    11.2.4\. But before we continue, let’s look at a simple benchmark comparing the
    lookup speed in a large grouped data frame. In all the following lines, I suppress
    printing of the values produced by the expressions to make the timing results
    easier to follow.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们比较了第 11.2.4 节中讨论的索引方法的速度。但在我们继续之前，让我们看看一个简单的基准，比较在一个大型分组数据框中的查找速度。在所有以下行中，我抑制了表达式产生的值的打印，以便更容易地跟踪计时结果。
- en: warning These tests were run on a machine with 32 GB of RAM. If you have less
    RAM and would like to reproduce these tests, please decrease the number of rows
    in the bench_df data frame to, for example, 10^7.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：这些测试是在一个拥有 32 GB RAM 的机器上运行的。如果您有更少的 RAM 并且想重现这些测试，请将 bench_df 数据框中的行数减少到，例如，10^7。
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Timing of creation of a grouped data frame
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 分组数据框创建的计时
- en: ❷ Timing of lookup using an integer
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用整数进行查找的计时
- en: ❸ Timing of lookup using a GroupKey
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 GroupKey 进行查找的计时
- en: ❹ Timing of lookup using a tuple
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用元组进行查找的计时
- en: ❺ Timing of lookup using a named tuple
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用命名元组进行查找的计时
- en: ❻ Timing of lookup using a dictionary
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 使用字典进行查找的计时
- en: 'I have the following comments about these benchmarks:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我有以下关于这些基准的评论：
- en: When grouping by integer column, the groupby operation for 100 million rows
    is performed in several hundred milliseconds, which I consider fast.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当按整数列分组时，对 1 亿行进行的分组操作在几百毫秒内完成，我认为这是很快的。
- en: All indexing operations are performed on the order of several hundreds of nanoseconds,
    which should be fast enough in most practical applications.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有索引操作都在数百纳秒的顺序上执行，这在大多数实际应用中应该足够快。
- en: Integer indexing is fastest, followed by GroupKey indexing and Tuple indexing.
    Next is NamedTuple indexing, which is more expensive than tuple indexing because
    it additionally checks column names. Using dictionary indexing is slowest as dictionaries
    are mutable, and working with mutable objects is usually slower than with immutable
    objects in Julia.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数索引速度最快，其次是GroupKey索引和元组索引。接下来是命名元组索引，它比元组索引更昂贵，因为它还需要检查列名。使用字典索引是最慢的，因为字典是可变的，而在Julia中，与不可变对象相比，处理可变对象通常更慢。
- en: Although not visible in these benchmarks, if you use Tuple, NamedTuple, or dictionary
    indexing, then the first time you perform the lookup, it is slower than consecutive
    operations. To make the amortized cost of Tuple, NamedTuple, or dictionary lookup
    low, DataFrames.jl lazily creates a helper data structure inside a GroupedDataFrame
    object. This operation is done lazily because in situations when you would perform
    lookup using only integers or GroupKeys, such a helper data structure is not needed,
    so DataFrames.jl avoids its creation by default.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然这些基准测试中看不到，但如果你使用元组、命名元组或字典索引，那么在第一次执行查找时，它比连续操作要慢。为了使元组、命名元组或字典查找的平均成本降低，DataFrames.jl在GroupedDataFrame对象内部懒惰地创建一个辅助数据结构。这个操作是懒惰执行的，因为在你会仅使用整数或GroupKeys执行查找的情况下，这样的辅助数据结构是不需要的，所以DataFrames.jl默认避免其创建。
- en: 11.2.6 Indexing a grouped data frame with multiple values
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.6 使用多个值索引分组数据帧
- en: In this section, you will use indexing to select several groups from a GroupDataFrame.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将使用索引从GroupDataFrame中选择几个组。
- en: 'You now know that to perform a single group lookup in a GroupDataFrame object,
    you need to index it with a single value. As a natural extension of this rule,
    if you pass multiple values when indexing a GroupedDataFrame, you get a GroupedDataFrame
    with only the selected groups kept. Here are two examples:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在知道，要在GroupDataFrame对象中执行单个组查找，你需要用单个值索引它。作为此规则的天然扩展，如果你在索引GroupedDataFrame时传递多个值，你将得到一个只保留所选组的GroupedDataFrame。以下有两个例子：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Changes the order of groups in the gdf_city grouped data frame
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 改变gdf_city分组数据帧中组的顺序
- en: ❷ Creates a grouped data frame having a single group
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个包含单个组的分组数据帧
- en: As you can see, the indexing rules are the same as you would expect them to
    be after learning general indexing rules in Julia. For example, passing a one-element
    vector as an index in the gdf_city[[1]] expression returns a grouped data frame
    with a single group. This example uses integer numbers to index into a grouped
    data frame, but could have also used vectors of GroupKey, Tuple, NamedTuple, or
    dictionary.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，索引规则与你学习Julia中的一般索引规则后预期的相同。例如，在gdf_city[[1]]表达式中传递一个单元素向量作为索引，返回一个包含单个组的分组数据帧。这个例子使用整数来索引分组数据帧，但也可以使用GroupKey、元组、命名元组或字典的向量。
- en: Let me highlight here, again, that GroupedDataFrame indexing does not involve
    copying of the source data stored in the rainfall_df data frame, so all such operations
    are fast.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我在这里再次强调，GroupedDataFrame索引不涉及复制存储在rainfall_df数据帧中的源数据，因此所有这些操作都很快。
- en: 'In summary, using GroupedDataFrame indexing, you can easily perform the following
    three operations that are often useful when preparing data for further manipulation:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，使用GroupedDataFrame索引，你可以轻松执行以下三个在准备数据以进行进一步操作时通常很有用的操作：
- en: Group lookup, returning a data frame if you pass a single group index when indexing
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组查找，当索引时传递单个组索引时返回数据帧
- en: Reordering of groups, returning a grouped data frame if you pass a permutation
    of group indices when indexing
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组重排序，当索引时传递组索引的排列时返回分组数据帧
- en: Subsetting of groups, returning a grouped data frame if you pass a vector of
    a subset of group indices when indexing
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组子集，当索引时传递分组索引的子集向量时返回分组数据帧
- en: 11.2.7 Iterating a grouped data frame
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.7 迭代分组数据帧
- en: In this section, I will show you how to iterate groups of a GroupedDataFrame.
    This operation is useful if you want to perform the same operation on all groups
    of a GroupedDataFrame.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向你展示如何迭代GroupedDataFrame的组。如果你想在GroupedDataFrame的所有组上执行相同的操作，这个操作非常有用。
- en: 'Since GroupedDataFrame objects support indexing, it is natural to expect that
    they also follow the iteration interface discussed in chapter 10\. Indeed, this
    is the case, and such iteration produces data frames representing consecutive
    groups. You can therefore use it in a comprehension. Here is an example showing
    how to determine the number of rows in each group of the gdf_city grouped data
    frame:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `GroupedDataFrame` 对象支持索引，因此自然地期望它们也遵循第10章中讨论的迭代接口。确实如此，这种迭代会产生表示连续组的DataFrame。因此，你可以在理解中使用它。以下是一个示例，说明如何确定
    `gdf_city` 分组DataFrame中每个组的行数：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'While this iteration is often useful, it has one problem. When iterating the
    values, we do not see which keys correspond to them. We can resolve this issue
    by wrapping the gdf_city object with the pairs function. This function returns
    an iterator of GroupKey and data frame pairs. Here is a simple example printing
    these pairs:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种迭代通常很有用，但它有一个问题。在迭代值时，我们看不到哪些键对应于它们。我们可以通过将 `gdf_city` 对象包装在 `pairs` 函数中来解决这个问题。这个函数返回一个GroupKey和DataFrame对的迭代器。以下是一个简单的示例，打印这些对：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let’s now use the pairs function to produce a dictionary mapping each city
    name to the number of rows of observations for this city:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 `pairs` 函数生成一个映射每个城市名称到该城市观测行数的字典：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This time, the code is a bit more complex, so I’ll explain it step by step (you
    learned all this syntax in part 1). The (key, df) in pairs(gdf_city) part of our
    code performs destructuring of the Pair object, and in each iteration assigns
    the first element, which is a GroupKey, to the key variable, and assigns the second
    element, which is a data frame, to the df variable. The key.city part extracts
    the city name from the GroupKey object.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，代码稍微复杂一些，所以我将一步一步地解释它（你已经在第1部分学习了所有这些语法）。在 `pairs(gdf_city)` 的代码部分中，`(key,
    df)` 执行了Pair对象的解构，并在每次迭代中将第一个元素（一个GroupKey）分配给 `key` 变量，将第二个元素（一个DataFrame）分配给
    `df` 变量。`key.city` 部分从GroupKey对象中提取城市名称。
- en: The nrow(df) function produces the number of rows in a data frame representing
    a given group. Finally, we feed the iterator of key.city => nrow(df) pairs to
    the dictionary constructor.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`nrow(df)` 函数生成表示给定组的DataFrame中的行数。最后，我们将 key.city => nrow(df) 对的迭代器传递给字典构造函数。'
- en: The pairs function
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`pairs` 函数'
- en: In this section, we used the pairs function to produce key => value pairs when
    iterating GroupedDataFrame objects.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用 `pairs` 函数在迭代 `GroupedDataFrame` 对象时生成键 => 值对。
- en: The pairs function can also be used with different collections. For example,
    if you pass a Vector to it, you get an iterator of element index => element value
    pairs. The general rule is that the pairs function returns an iterator over key
    => value pairs for any collection that maps a set of keys to a set of values.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`pairs` 函数也可以与不同的集合一起使用。例如，如果你向它传递一个向量，你将得到一个元素索引 => 元素值对的迭代器。一般规则是，`pairs`
    函数返回任何将一组键映射到一组值的集合上的键 => 值对的迭代器。'
- en: 'Now you know all the fundamental concepts related to working with grouped data
    frames. In the remaining chapters, you will learn to use grouped data frames to
    perform split-apply-combine operations. However, since the example of counting
    the number of observations per group is a simple split-apply-combine operation,
    I’ll show you how you could have performed it by using the combine function (we
    will discuss this in detail in the remaining chapters):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了与处理分组DataFrame相关的所有基本概念。在接下来的章节中，你将学习如何使用分组DataFrame执行拆分-应用-组合操作。然而，由于按组计数观测数是一个简单的拆分-应用-组合操作，我将向你展示你可以如何通过使用
    `combine` 函数来完成它（我们将在接下来的章节中详细讨论）：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In my opinion, this code has the following advantages over the manual aggregation
    of a grouped data frame into a dictionary that we performed earlier:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，这段代码与我们在之前手动将分组DataFrame聚合到字典中的方法相比有以下优点：
- en: It is shorter and easier to read.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它更短，更容易阅读。
- en: It produces a data frame, so we could use other functionalities of the DataFrames.jl
    package if we wanted to further process this data.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它生成一个DataFrame，因此如果我们想进一步处理这些数据，我们可以使用 DataFrames.jl 包的其他功能。
- en: 'Exercise 11.2 Using the gdf_city grouped data frame, compute the mean temperature
    in each city by using the mean function from the Statistics module. Store the
    result as a dictionary in which keys are city names and values are corresponding
    mean temperatures. Compare your result with the output of the following call:
    combine(gdf_city, :rainfall => mean). We will discuss the exact syntax of such
    expressions in chapters 12 and 13.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 练习11.2 使用gdf_city分组数据框，通过使用Statistics模块中的mean函数计算每个城市的平均温度。将结果存储为字典，其中键是城市名称，值是对应的平均温度。将您的结果与以下调用的输出进行比较：combine(gdf_city,
    :rainfall => mean)。我们将在第12章和第13章中讨论此类表达式的确切语法。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You can easily convert a data frame to a wide variety of other types. Some of
    the most common conversions are to a Matrix, NamedTuple of vectors, and Vector
    of NamedTuple. Such conversions are commonly needed when you have a function that
    does not accept a DataFrame but requires a value of another type as an input.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以轻松地将数据框转换为多种其他类型。最常见的转换之一是转换为矩阵、向量的命名元组以及命名元组的向量。当您有一个不接受DataFrame但需要一个其他类型值作为输入的函数时，这种转换通常需要。
- en: We call Julia code type stable if Julia can infer during compilation the types
    of all used variables. Type-stable code is typically faster than type-unstable
    code.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们称Julia代码为类型稳定的，如果Julia在编译期间可以推断出所有使用变量的类型。类型稳定的代码通常比类型不稳定的代码快。
- en: The DataFrame object and the objects returned by the eachrow and eachcol functions
    called on a data frame are not type stable. This has benefits, as it does not
    incur significant compilation time and allows changing columns of a data frame.
    However, it also has the downside that the function-barrier method needs to be
    used to ensure that operations on data stored in them are fast.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据框上调用eachrow和eachcol函数返回的DataFrame对象及其类型是不稳定的。这有其好处，因为它不会产生显著的编译时间，并允许更改数据框的列。然而，这也带来一个缺点，即需要使用函数屏障方法来确保对存储在其中的数据进行操作时速度快。
- en: Type piracy in Julia happens if you extend or redefine methods in Base Julia
    or other packages on types that you have not defined. Writing code that does type
    piracy is discouraged, as it can break existing code.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在您未定义的类型上扩展或重新定义Base Julia或其他包中的方法，则Julia中会发生类型盗用。编写进行类型盗用的代码是不被鼓励的，因为它可能会破坏现有代码。
- en: You can create an iterator of data frame columns by using the eachcol function.
    It is used when you want to iteratively perform operations on consecutive columns
    of a data frame.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用eachcol函数创建数据框列的迭代器。当您想对数据框的连续列迭代执行操作时，会使用它。
- en: You can create an iterator of data frame rows by using the eachrow function
    or Tables.namedtupleiterator function. They are used when you want to iteratively
    perform operations on consecutive rows of a data frame.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用eachrow函数或Tables.namedtupleiterator函数创建数据框行的迭代器。当您想对数据框的连续行迭代执行操作时，会使用它们。
- en: You can create GroupedDataFrame objects from a data frame by using the groupby
    function. Grouped data frames are useful when you want to process your data frame
    grouped by values stored in one or more columns of the data frame. Such processing
    of data is often needed in practice, for example, when performing split-apply-combine
    operations.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过使用groupby函数从数据框创建GroupedDataFrame对象。当您想按数据框中一个或多个列中存储的值对数据进行分组处理时，分组数据框非常有用。这种数据处理在实际情况中经常需要，例如，在执行split-apply-combine操作时。
- en: GroupedDataFrame objects are indexable and iterable. You can easily perform
    group lookup and reorder or subset groups in a grouped data frame. These operations
    are needed when you analyze data stored in GroupedDataFrame.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GroupedDataFrame对象是可索引和可迭代的。您可以轻松执行分组查找、重新排序或子集分组数据框中的组。当您分析存储在GroupedDataFrame中的数据时，需要这些操作。
- en: You can index into GroupedDataFrame objects by using an integer value, GroupKey,
    Tuple, NamedTuple, or dictionary. Having such a wide selection of possibilities
    is useful as it allows you to choose the one that corresponds best to your needs.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用整数值、GroupKey、元组、命名元组或字典来索引GroupedDataFrame对象。这种广泛的选择是有用的，因为它允许您选择最适合您需求的一个。
- en: Indexing of GroupedDataFrame objects is fast because source data stored in the
    parent data frame is not copied when such an operation is performed. Therefore,
    you can efficiently work with grouped data frames that have even a very large
    number of groups.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于在执行此类操作时，存储在父数据框中的源数据不会被复制，因此GroupedDataFrame对象的索引速度快。因此，您可以高效地处理具有大量组的分组数据框。
