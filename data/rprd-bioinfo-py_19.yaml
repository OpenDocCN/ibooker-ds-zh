- en: 'Chapter 17\. DNA Synthesizer: Creating Synthetic Data with Markov Chains'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章\. DNA合成器：使用马尔可夫链创建合成数据
- en: A Markov chain is a model for representing a sequence of possibilities found
    in a given dataset. It is a machine learning (ML) algorithm because it discovers
    or learns patterns from input data. In this exercise, I’ll show how to use Markov
    chains trained on a set of DNA sequences to generate novel DNA sequences.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫链是用于表示给定数据集中可能性序列的模型。它是一种机器学习（ML）算法，因为它能从输入数据中发现或学习模式。在这个练习中，我将展示如何使用训练在一组DNA序列上的马尔可夫链来生成新的DNA序列。
- en: 'In this exercise, you will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将：
- en: Read some number of input sequence files to find all the unique k-mers for a
    given *k*.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取一些输入序列文件以找出给定*k*的所有唯一k-mer。
- en: Create a Markov chain using these k-mers to produce some number of novel sequences
    of lengths bounded by a minimum and maximum.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这些k-mer创建马尔可夫链来生成长度受最小和最大限制的一些新序列。
- en: Learn about generators.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习生成器。
- en: Use a random seed to replicate random selections.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用随机种子复制随机选择。
- en: Understanding Markov Chains
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解马尔可夫链
- en: In Claude Shannon’s [“A Mathematical Theory of Communication”](https://oreil.ly/8Gka4)
    (1948), the author describes a *Markoff process* that is surprisingly similar
    to graphs and the finite state diagrams I’ve been using to illustrate regular
    expressions. Shannon describes this process as “a finite number of possible *states*
    of a system” and “a set of transition probabilities” that one state will lead
    to another.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在克劳德·香农的[《通信的数学理论》](https://oreil.ly/8Gka4)（1948年）中，作者描述了一种意外类似于我一直用来说明正则表达式的图和有限状态图的*马尔可夫过程*。香农将这一过程描述为“系统的有限数量可能的*状态*”和“一组转移概率”，其中一个状态将导致另一个状态。
- en: 'For one example of a Markov process, Shannon describes a system for generating
    strings of text by randomly selecting from the 26 letters of the English alphabet
    and a space. In a “zero-order approximation,” each character has an equal probability
    of being chosen. This process generates strings where letter combinations like
    *bz* and *qr* might appear as frequently as *st* and *qu*. An examination of actual
    English words, however, would show that the latter two are orders of magnitude
    more common than the first two:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于马尔可夫过程的一个例子，香农描述了一个系统，通过从英语字母表的26个字母和一个空格中随机选择来生成文本字符串。在“零阶近似”中，每个字符被选择的概率相等。这个过程生成的字符串中，像*bz*和*qr*这样的字母组合可能与*st*和*qu*一样频繁出现。然而，实际的英语单词表明，后两者比前两者常见得多：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To more accurately model the possible transition from one letter to another,
    Shannon introduces a “first-order approximation…obtained by choosing successive
    letters independently but each letter having the same probability that it has
    in the natural language.” For this model, I need to train the selection process
    on representative texts of English. Shannon notes that the letter *e* has a probability
    of 0.12, reflecting the frequency of its use in English words, whereas *w*, being
    much less frequently used, has a probability of 0.02, as shown in [Figure 17-1](#fig_17.1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更准确地模拟从一个字母到另一个字母的可能过渡，香农引入了一个“一阶近似…通过选择连续的字母独立进行，但每个字母的选择概率与其在自然语言中的使用概率相同”。对于这个模型，我需要在代表性的英语文本上训练选择过程。香农指出，字母*e*的使用概率为0.12，反映了它在英语单词中的使用频率，而使用频率较低的*w*的概率为0.02，如[图17-1](#fig_17.1)所示。
- en: '![mpfb 1701](assets/mpfb_1701.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 1701](assets/mpfb_1701.png)'
- en: Figure 17-1\. A finite state diagram that includes the probability of moving
    from any character in English to the letters “e” or “w”
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 17-1\. 一个有限状态图，包括从英语中任意字符移动到字母“e”或“w”的概率
- en: Shannon goes on to describe a “second-order approximation” where subsequent
    letters are “chosen in accordance with the frequencies with which the various
    letters follow the first one.” This relates to k-mers that I used several times
    in [Part I](part01.html#part_one). In linguistics, these are called *N-grams*.
    For instance, what possible 3-mers could be created given the 2-mer *th*? The
    letters *e* or *r* would be rather likely, whereas *z* would be impossible as
    no English word contains the sequence *thz*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 香农继续描述了一个“二阶近似”，其中后续字母“根据各字母跟随第一个字母的频率选择”。这与我在[第一部分](part01.html#part_one)中多次使用的k-mer相关。在语言学中，这些被称为*N-gram*。例如，给定2-mer
    *th*，可能出现的3-mer是字母*e*或*r*，而*z*是不可能的，因为没有英语单词包含序列*thz*。
- en: 'I can perform a rough estimation of how often I can find these patterns. I
    find approximately 236K English words using **`wc -l`** to count the lines of
    my system dictionary:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以粗略估算我能找到这些模式的频率。我使用 **`wc -l`** 命令来计算系统字典中约有 236K 个英语单词的行数：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To find the frequency of the substrings, I need to account for the fact that
    some words may have the pattern twice. For instance, here are a few words that
    have more than one occurrence of the pattern *the*:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出子字符串的频率，我需要考虑到某些单词可能具有两次模式的情况。例如，以下是一些包含多个 *the* 模式的单词：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'I can use `grep -io` to search in a case-insensitive fashion (`-i`) for the
    strings *thr* and *the*, while the `-o` flag tells `grep` to return *only* the
    matching strings, which will reveal all the matches in each word. I find that
    *thr* occurs 1,270 times, while *the* occurs 3,593 times:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用 `grep -io` 命令以不区分大小写 (`-i`) 的方式搜索 *thr* 和 *the* 字符串，同时 `-o` 标志告诉 `grep`
    仅返回匹配的字符串，这将显示每个单词中的所有匹配项。我发现 *thr* 出现了 1,270 次，而 *the* 出现了 3,593 次：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Dividing these numbers by the total number of words leads to a frequency of
    0.005 for *thr* and 0.015 for *the*, as shown in [Figure 17-2](#fig_17.2).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些数字除以总单词数会得出 *thr* 的频率为 0.005，*the* 的频率为 0.015，如图 [17-2](#fig_17.2) 所示。
- en: '![mpfb 1702](assets/mpfb_1702.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![mpfb 1702](assets/mpfb_1702.png)'
- en: Figure 17-2\. A finite state diagram showing the probability of moving from
    “th” to either an “r” or an “e”
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 17-2\. 显示从“th”到“r”或“e”的有限状态图中的移动概率
- en: I can apply these ideas to generate novel DNA sequences by reading some sample
    sequences and noting the ordering of the bases at the level of some k-mer like
    10 base pairs (bp). It’s important to note that different training texts will
    affect the model. For instance, English words and spellings have changed over
    time, so training on older English texts like *Beowulf* and *Canterbury Tales*
    will yield different results than articles from modern newspapers. This is the
    *learning* part of machine learning. Many ML algorithms are designed to find patterns
    from some sets of data to apply to another set. In the case of this program, the
    generated sequences will bear some resemblance in composition to the input sequences.
    Running the program with the human genome as training data will produce different
    results than using a viral metagenome from an oceanic hydrothermal flume.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以应用这些思想通过阅读一些样本序列并注意到一些 k-mer（如 10 个碱基对）的碱基排序来生成新的 DNA 序列。重要的是要注意，不同的训练文本将会影响模型。例如，英语单词和拼写随时间的推移而改变，因此在旧英语文本（如
    *Beowulf* 和 *Canterbury Tales*）上进行训练将产生与现代报纸文章不同的结果。这是机器学习中的 *学习* 部分。许多机器学习算法旨在从某些数据集中找到模式并应用于另一个数据集。在这个程序的情况下，生成的序列在组成上将与输入序列有些相似。使用人类基因组作为训练数据将产生与使用来自海洋热液喷口的病毒元基因组不同的结果。
- en: Getting Started
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门指南
- en: 'You should work in the *17_synth* directory containing the inputs and tests
    for this program. Start by copying the solution to the program `synth.py`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在包含此程序输入和测试的 *17_synth* 目录中工作。首先将解决方案复制到 `synth.py` 程序：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This program has a large number of parameters. Run the help to see them:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序有大量参数。运行帮助命令以查看它们：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-1)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-1)'
- en: The only required parameter is one or more input files.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要的参数是一个或多个输入文件。
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-2)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-2)'
- en: The output filename will default to *out.fa*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件名将默认为 *out.fa*。
- en: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-3)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-3)'
- en: The input format should be either *fasta* or *fastq* and defaults to the first.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输入格式应为 *fasta* 或 *fastq*，默认为第一个。
- en: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-4)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-4)'
- en: The default number of sequences generated will be 100.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 默认生成的序列数将为 100。
- en: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-5)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-5)'
- en: The default maximum sequence length is 75 bp.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的最大序列长度为 75 bp。
- en: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-6)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-6)'
- en: The default minimum sequence length is 50 bp.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的最小序列长度为 50 bp。
- en: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-7)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-7)'
- en: The default k-mer length is 10 bp.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 k-mer 长度是`10 bp`。
- en: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-8)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO1-8)'
- en: The default random seed is the `None` value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的随机种子是值为`None`。
- en: 'As usual, I create an `Args` class to represent these parameters. I use the
    following `typing` imports. Note the `Dict` is used later in the program:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我创建一个`Args`类来表示这些参数。我使用以下`typing`导入。注意后面程序中使用了`Dict`：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-1)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-1)'
- en: The input `files` will be a list of open filehandles.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的`files` 将是一个打开文件句柄的列表。
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-2)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-2)'
- en: The `outfile` will be an open filehandle.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`outfile` 将是一个打开的文件句柄。'
- en: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-3)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-3)'
- en: The `file_format` of the input files is a string.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件的`file_format` 是一个字符串。
- en: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-4)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-4)'
- en: The number of sequences to generate (`num`) is an integer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成的序列数（`num`）是一个整数。
- en: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-5)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-5)'
- en: The `min_len` is an integer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`min_len` 是一个整数。'
- en: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-6)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-6)'
- en: The `max_len` is an integer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`max_len` 是一个整数。'
- en: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-7)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-7)'
- en: The `k` for k-mer length is an integer.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`k` 表示 k-mer 长度为整数。'
- en: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-8)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO2-8)'
- en: The random seed can either be the value `None` or an integer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 随机种子可以是值为`None`或整数。
- en: 'Here is how I define the program’s parameters:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我定义程序参数的方式：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-1)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-1)'
- en: The `type` restricts the values to readable text files, and the `nargs` requires
    one or more values.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 限制为可读的文本文件，`nargs` 要求一个或多个值。'
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-2)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-2)'
- en: The `type` restricts the value to a writable text file, and the default filename
    will be *out.fa*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 限制为可写的文本文件，文件名默认为*out.fa*。'
- en: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-3)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-3)'
- en: The `choices` restrict the values to either `fasta` or `fastq`, and the default
    will be `fasta`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`choices` 限制为`fasta`或`fastq`，默认为`fasta`。'
- en: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-4)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-4)'
- en: The `type` restricts this to a valid integer value, and the default is `100`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 限制为有效的整数值，默认为`100`。'
- en: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-5)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-5)'
- en: The `type` restricts this to a valid integer value, and the default is `75`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 限制为有效的整数值，默认为`75`。'
- en: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-6)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-6)'
- en: The `type` restricts this to a valid integer value, and the default is `50`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 限制为有效的整数值，默认为`50`。'
- en: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-7)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-7)'
- en: The `type` restricts this to a valid integer value, and the default is `10`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 限制为有效的整数值，默认为`10`。'
- en: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-8)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO3-8)'
- en: The `type` restricts this to a valid integer value, and the default is `None`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 限制为有效的整数值，默认为`None`。'
- en: It might seem a little odd that the `seed` has `type=int` but has a default
    of `None` because `None` is not an integer. What I’m saying is that if the user
    provides any value for the seed, it must be a valid integer; otherwise, the value
    will be `None`. This is also reflected in the `Args.seed` definition as an `Optional[int]`,
    which means the value can either be `int` or `None`. Note that this is equivalent
    to `typing.Union[int, None]`, the union of the `int` type and `None` value.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`seed`的`type=int`但默认为`None`可能看起来有点奇怪，因为`None`不是整数。我想说的是，如果用户提供种子的任何值，它必须是有效的整数；否则，值将为`None`。这也反映在`Args.seed`的定义中，作为`Optional[int]`，这意味着该值可以是`int`或`None`。请注意，这相当于`typing.Union[int,
    None]`，即`int`类型和`None`值的联合。'
- en: Understanding Random Seeds
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解随机种子
- en: 'There is an element of randomness to this program as you generate the sequences.
    I can start with Shannon’s zero-order implementation where I select each base
    independently at random. I can use the `random.choice()` function to select one
    base:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序有一定的随机性，因为你生成序列。我可以从Shannon的零阶实现开始，选择每个碱基的基础独立随机。我可以使用`random.choice()`函数选择一个碱基：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If I wanted to generate a 10-bp sequence, I could use a list comprehension
    with the `range()` function, like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想生成一个10-bp序列，我可以使用带有`range()`函数的列表推导，就像这样：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'I could further select a random sequence length between some minimum and maximum
    length using the `random.randint()` function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以进一步使用`random.randint()`函数在一定范围内选择随机序列长度：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you execute the preceding code on your computer, it’s highly unlikely you
    will see the same output as shown. Fortunately, these selections are only pseudorandom
    as they are produced deterministically by a random number generator (RNG). Truly
    random, unreproducible choices would make testing this program impossible.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在你的计算机上执行上述代码，你几乎不可能看到与所示相同的输出。幸运的是，这些选择只是伪随机的，因为它们是由随机数生成器(RNG)确定性地产生的。真正的随机、不可重现的选择会使得测试这个程序变得不可能。
- en: 'I can use a *seed* or initial value to force the pseudorandom selections to
    be predictable. If you read **`help(random.seed)`**, you’ll see that the “supported
    seed types are `None`, `int`, `float`, `str`, `bytes`, and `bytearray`.” For instance,
    I can seed using an integer:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用*seed*或初始值来强制伪随机选择可预测。如果你阅读**`help(random.seed)`**，你会看到“支持的种子类型包括`None`、`int`、`float`、`str`、`bytes`和`bytearray`。”例如，我可以使用整数作为种子：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'I can also use a string:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我也可以使用字符串：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you execute the preceding code, you should get the exact output shown. By
    default, the random seed is `None`, which you’ll notice is the default for the
    program. This is the same as not setting the seed at all, so when the program
    runs with the default it will act in a pseudorandom manner. When testing, I can
    provide a value that will produce a known result to verify that the program works
    correctly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行上述代码，你应该得到与所示完全相同的输出。默认情况下，随机种子为`None`，你会注意到这是程序的默认值。这与不设置种子相同，因此当程序使用默认值运行时，它将以伪随机方式运行。在测试时，我可以提供一个值，以产生已知结果，以验证程序是否正常工作。
- en: 'Note that I have forced the user to provide an integer value. Although I find
    using integers to be convenient, you can seed using strings, numbers, or bytes
    when writing your own programs. Just remember that the integer `4` and the string
    `''4''` are two different values and will produce different results:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我已经强制用户提供一个整数值。虽然使用整数很方便，但在编写自己的程序时，你可以使用字符串、数字或字节进行种子化。只需记住整数`4`和字符串`'4'`是两个不同的值，会产生不同的结果：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO4-1)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO4-1)'
- en: Seed using the integer value `4`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用整数值`4`作为种子。
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO4-2)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO4-2)'
- en: Seed using the string value `'4'`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串值`'4'`作为种子。
- en: 'The random seed affects every call to `random` functions from that point forward.
    This creates a *global* change to your program, and so should be viewed with extreme
    caution. Typically, I will set the random seed in my program immediately after
    validating the arguments:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 随机种子影响从那一点开始的每次对`random`函数的调用。这会对你的程序造成*全局*变化，因此应该极度谨慎地看待。通常情况下，在验证参数后我会立即在我的程序中设置随机种子：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the seed is the default value of `None`, this will not affect the `random`
    functions. If the user has provided a seed value, then all subsequent `random`
    calls will be affected.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果种子是默认值`None`，这不会影响`random`函数。如果用户提供了一个种子值，那么所有随后的`random`调用都会受到影响。
- en: Reading the Training Files
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取训练文件
- en: The first step in my program is to read the training files. Due to how I defined
    this argument with `argparse`, the process of validating the input files has been
    handled, and I know I will have a `List[TextIO]` which is a list of open filehandles.
    I will use `Bio.SeqIO.parse()`, as in previous chapters, to read the sequences.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我程序的第一步是读取训练文件。由于我用`argparse`定义了这个参数，处理验证输入文件的过程已经完成，我知道我将得到一个`List[TextIO]`，即打开文件句柄的列表。我将使用`Bio.SeqIO.parse()`，与前几章类似，来读取序列。
- en: 'From the training files, I want to produce a dictionary that describes the
    weighted possible bases that can follow each k-mer. I think it’s helpful to use
    a type alias to define a couple of new types to describe this. First, I want a
    dictionary that maps a base like *T* to a floating-point value between 0 and 1
    to describe the probability of choosing this base. I’ll call it a `WeightedChoice`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从训练文件中，我希望生成一个描述每个k-mer后续可能基的加权概率的字典。我认为使用类型别名来定义几种新类型来描述这一点很有帮助。首先，我想要一个字典，将像*T*这样的碱基映射到一个介于0和1之间的浮点值，以描述选择该碱基的概率。我将其称为`WeightedChoice`：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For instance, in the sequence *ACGTACGC*, the 3-mer *ACG* is followed by either
    *T* or *C* with equal likelihood. I represent this like so:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在序列*ACGTACGC*中，3-mer *ACG*后跟等可能的*T*或*C*。我将其表示如下：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, I want a type that maps the k-mer *ACG* to the choices. I’ll call this
    a `Chain` as it represents the Markov chain:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我想要一个类型，将k-mer *ACG*映射到选择。我将其称为`Chain`，因为它表示马尔可夫链：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It would look like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像这样：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Each k-mer from the sequences in the input file will have a dictionary of weighted
    options for use in selecting the next base. Here is how I use it to define a function
    to read the training files:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件中的每个k-mer将有一个加权选项的字典，用于选择下一个碱基。这是我用来定义读取训练文件函数的方式：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO5-1)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO5-1)'
- en: The function accepts a list of filehandles, the file format of the files, and
    the size of the k-mers to read. It returns the type `Chain`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受文件句柄列表、文件的格式以及要读取的k-mer大小。它返回类型`Chain`。
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO5-2)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO5-2)'
- en: Use `pass` to do nothing and return `None` for now.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pass`来什么都不做，并暂时返回`None`。
- en: 'Since k-mers figure prominently in this solution, you may want to use the `find_kmers()`
    function from [Part I](part01.html#part_one). As a reminder, for a function with
    this signature:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于k-mers在这个解决方案中非常重要，您可能希望使用来自[第I部分](part01.html#part_one)的`find_kmers()`函数。作为提醒，对于具有此签名的函数：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'I would use the following test:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用以下测试：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'I think it’s helpful to see exactly what goes into this function and what I
    expect it to return. In the *tests/unit_test.py* file, you’ll find all the unit
    tests for this program. Here is the test for this function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为看到这个函数的具体内容和我的期望返回很有帮助。在*tests/unit_test.py*文件中，你会找到这个程序的所有单元测试。这是该函数的测试：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-1)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-1)'
- en: The function takes no arguments and returns `None`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 函数不接受任何参数并返回`None`。
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-2)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-2)'
- en: Define a mock filehandle containing a single sequence in FASTA format.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个包含单个序列的模拟文件句柄，其格式为FASTA。
- en: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-3)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-3)'
- en: Read the data in FASTA format and return the Markov chains for 4-mers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以FASTA格式读取数据并返回4-mers的马尔可夫链。
- en: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-4)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-4)'
- en: Define a mock filehandle containing a single sequence in FASTQ format.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个包含单个序列的模拟文件句柄，其格式为FASTQ。
- en: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-5)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO6-5)'
- en: Read the data in FASTQ format and return the Markov chains for 5-mers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 读取FASTQ格式的数据并返回5-mer的马尔可夫链。
- en: 'To help you better understand k-mers, I’ve included a program called `kmer_tiler.py`
    that will show you the overlapping k-mers in a given sequence. The first test
    in the preceding function checks that the 3-mer *ACG* is followed by either *T*
    or *C* with equal probability to create the 4-mers *ACGT* and *ACGC*. Looking
    at the output from `kmer_tiler.py`, I can see these two possibilities:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你更好地理解k-mer，我包含了一个叫做`kmer_tiler.py`的程序，它将展示给定序列中的重叠k-mer。前面函数中的第一个测试检查3-mer
    *ACG*后面是否跟着等概率的*T*或*C*，以创建4-mer *ACGT*和*ACGC*。通过查看`kmer_tiler.py`的输出，我可以看到这两种可能性：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO7-1)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO7-1)'
- en: '*ACG* followed by *T*.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*ACG*后面跟着*T*。'
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO7-2)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO7-2)'
- en: '*ACG* followed by *C*.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*ACG*后面跟着*C*。'
- en: Using this information, I can create Shannon’s second-order approximation. For
    instance, if I randomly select the 3-mer *ACG* to start generating a new sequence,
    I can add either *T* or *C* with equal probability. Given this training data,
    I could never append either *A* or *G*, as these patterns never occur.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些信息，我可以创建香农的二阶近似。例如，如果我随机选择3-mer *ACG*来开始生成新的序列，我可以等概率地添加*T*或*C*。根据这些训练数据，我永远不会添加*A*或*G*，因为这些模式从未出现过。
- en: This is a tricky function to write, so let me give you some pointers. First,
    you need to find all the k-mers in all the sequences in all the files. For each
    k-mer, you need to find all the possible endings for a sequence of length `k -
    1`. That is, if `k` is `4`, you first find all the 4-mers and then note how the
    leading 3-mer can be completed with the last base.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个难以编写的函数，所以让我给你一些提示。首先，你需要在所有文件的所有序列中找到所有的k-mer。对于每个k-mer，你需要找到长度为`k - 1`的序列中所有可能的末端。也就是说，如果`k`是`4`，你首先找到所有的4-mer，然后注意如何用最后一个碱基完成前面的3-mer。
- en: 'I used `collections.Counter()` and ended up with an interim data structure
    that looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了`collections.Counter()`，得到了一个类似这样的中间数据结构：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since the input files are all DNA sequences, each k-mer can have at most four
    possible choices. The key to the Markov chain is in giving these values weights,
    so next, I need to divide each option by the total number of options. In the case
    of *ACG*, there are two possible values each occurring once, so they each get
    a weight of 1/2 or 0.5. The data structure I return from this function looks like
    the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于输入文件都是DNA序列，每个k-mer最多可能有四种选择。马尔可夫链的关键在于给这些值赋权重，因此接下来我需要将每个选项除以总选项数。例如在*ACG*的情况下，有两个可能的值，每个值出现一次，因此它们的权重为1/2或0.5。从这个函数返回的数据结构如下所示：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: I recommend you first focus on writing a function that passes this test.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你首先专注于编写通过这个测试的函数。
- en: Generating the Sequences
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成序列
- en: 'Next, I recommend you concentrate on using the `Chain` to generate new sequences.
    Here is a stub for your function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我建议你专注于使用`Chain`来生成新的序列。以下是你函数的桩代码：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO8-1)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO8-1)'
- en: The function accepts the `Chain`, the size of the k-mers, and the minimum and
    maximum sequence length. It might or might not return a new sequence as a string,
    for reasons I’ll explain shortly.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受`Chain`、k-mer的大小以及序列的最小和最大长度。它可能会或可能不会返回一个新的序列字符串，原因我稍后会解释。
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO8-2)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO8-2)'
- en: For now, return the empty string.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，暂时返回空字符串。
- en: When stubbing a function, I interchange `pass` with returning some dummy value.
    Here I use the empty string since the function returns a `str`. The point is only
    to create a function that Python parses and which I can use for testing. At this
    point, I *expect* the function to fail.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当写桩代码时，我会用`pass`替换成返回一些虚拟值。在这里，我使用空字符串，因为函数返回一个`str`。重点是创建一个Python可以解析的函数，我可以用来测试。此时，我*期望*函数会失败。
- en: 'Here is the test I wrote for this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我为此编写的测试：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-1)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-1)'
- en: The function accepts no arguments and returns `None`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数不接受任何参数，并返回`None`。
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-2)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-2)'
- en: This is the data structure returned by the `read_training()` function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`read_training()`函数返回的数据结构。
- en: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-3)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-3)'
- en: Save the current global state of the `random` module.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 保存当前全局状态的`random`模块。
- en: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-4)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-4)'
- en: Set the seed to a known value of `1`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将种子设置为已知值`1`。
- en: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-5)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-5)'
- en: Verify that the proper sequence is generated.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 验证生成适当的序列。
- en: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-6)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-6)'
- en: Set the seed to a different known value of `2`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将种子设置为已知值`2`。
- en: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-7)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-7)'
- en: Verify that the proper sequence is generated.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 验证生成适当的序列。
- en: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-8)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO9-8)'
- en: Restore the `random` module to any previous state.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复`random`模块到任意之前的状态。
- en: As noted before, calling `random.seed()` globally modifies the state of the
    `random` module. I use `random.getstate()` to save the current state before modifying
    and then restore that state when the testing is finished.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，全局调用`random.seed()`会修改`random`模块的状态。我使用`random.getstate()`保存修改前的当前状态，并在测试完成后恢复该状态。
- en: 'This is a tricky function to write, so I’ll give you some direction. You will
    first randomly select the length of the sequence to generate, and the `random.randint()`
    function will do just that. Note that the upper and lower bounds are inclusive:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这个函数很棘手，所以我会给你一些指导。你首先会随机选择要生成的序列长度，`random.randint()`函数正好能做到这一点。请注意上下限都是包含的：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, you should initialize the sequence using one of the keys from the Markov
    `Chain` structure. Note the need to coerce the `list(chain.keys())` to avoid the
    error “`dict_keys` object is not subscriptable”:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你应该使用马尔可夫`Chain`结构的一个键来初始化序列。请注意需要强制转换`list(chain.keys())`以避免出现错误“`dict_keys`
    object is not subscriptable”：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'I decided to set up a loop with the condition that the length of the sequence
    is less than the chosen sequence length. While inside the loop, I will keep appending
    bases. To select each new base, I need to get the last `k - 1` bases of the ever-growing
    sequence, which I can do using a list slice and negative indexing. Here’s one
    pass through the loop:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定设置一个循环，条件是序列长度小于所选序列长度。在循环内部，我将不断追加碱基。要选择每个新的碱基，我需要获取不断增长的序列的最后`k - 1`个碱基，可以使用列表切片和负索引来实现。以下是循环的一个执行过程：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If this previous value occurs in the given chain, then I can select the next
    base using the `random.choices()` function. If you read **`help(random.choices)`**,
    you will see that this function accepts a `population` from which to select, `weights`
    to consider when making the selection, and a `k` for the number of choices to
    return. The keys of the chain for a given k-mer are the population:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前一个值在给定的链中出现，那么可以使用`random.choices()`函数选择下一个碱基。如果你阅读**`help(random.choices)`**，你会发现该函数接受一个`population`来选择，考虑`weights`以进行选择，并且`k`用于返回选择的数量。对于给定k-mer的链的键是population：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The values of the chain are the weights:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 链的值是权重：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note the need to coerce the keys and values using `list()`, and that `random.choices()`
    always returns a `list` even when you ask for just one, so you’ll need to select
    the first value:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意需要使用`list()`强制转换键和值，并且`random.choices()`在请求一个值时始终返回一个列表，因此你需要选择第一个值：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'I can append this to the sequence:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以将其追加到序列中：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The loop repeats until either the sequence is the correct length or I select
    a previous value that does not exist in the chain. The next time through the loop,
    the `prev` 3-mer will be *CGT*, as these are the last three bases in `seq`. It
    happens that *CGT* is a key in the chain, but you may sometimes find that there
    is no way to continue the sequence because the next k-mer doesn’t exist in the
    chain. In this case, you can exit your loop and return `None` from the function.
    This is why the `gen_seq()` function signature returns an `Optional[str]`; I don’t
    want my function to return sequences that are too short. I recommend that you
    not move on until this function passes the unit test.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 循环重复，直到序列达到正确的长度或选择了链中不存在的先前值。下一次循环时，`prev` 3-mer 将是 *CGT*，因为这些是`seq`中的最后三个碱基。碰巧
    *CGT* 是链中的一个键，但有时您可能会发现由于链中不存在下一个 k-mer，无法继续序列。在这种情况下，您可以退出循环，并从函数返回`None`。这就是为什么`gen_seq()`函数签名返回`Optional[str]`的原因；我不希望我的函数返回过短的序列。建议您在此函数通过单元测试之前不要继续进行。
- en: Structuring the Program
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序结构
- en: 'Once you can read the training files and generate a new sequence using the
    Markov chain algorithm, you are ready to print the new sequences to the output
    file. Here is a general outline of how my program works:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦能够读取训练文件并使用马尔可夫链算法生成新序列，即可将新序列打印到输出文件中。以下是我的程序的一般概述：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note that the program will only generate FASTA output, and each sequence should
    be numbered from 1 as the ID. That is, your output file should look something
    like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，程序仅会生成FASTA输出，每个序列的ID应从1开始编号。也就是说，您的输出文件应如下所示：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The test suite is pretty large as there are so many options to check. I recommend
    you run **`make test`** or read the *Makefile* to see the longer command to ensure
    that you are properly running all the unit and integration tests.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于要检查的选项很多，测试套件相当大。建议您运行 **`make test`** 或查阅 *Makefile* 以查看更长的命令，确保正确运行所有单元测试和集成测试。
- en: Solution
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'I have just one solution for this program as it’s complicated enough. I’ll
    start with my function to read the training files, which requires you to import
    `defaultdict()` and `Counter()` from the `collections` module:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个复杂的程序，我只有一个解决方案。我将从读取训练文件的函数开始，这需要您从 `collections` 模块导入 `defaultdict()`
    和 `Counter()`：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-1)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-1)'
- en: Initialize a dictionary to hold the Markov chains.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化一个字典以保存马尔可夫链。
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-2)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-2)'
- en: Iterate through each filehandle.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历每个文件句柄。
- en: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-3)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-3)'
- en: Iterate through each sequence in the filehandle.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历文件句柄中的每个序列。
- en: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-4)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-4)'
- en: Iterate through each k-mer in the sequence.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历序列中的每个 k-mer。
- en: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-5)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-5)'
- en: Use the prefix of the k-mer as the key into the Markov chain, and add to the
    count of the final base.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将 k-mer 的前缀用作马尔可夫链中的键，并将最终碱基的计数加一。
- en: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-6)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-6)'
- en: Define a function that will turn the counts into weighted values.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个将计数转换为加权值的函数。
- en: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-7)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-7)'
- en: Find the total number of bases.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 查找碱基的总数。
- en: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-8)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-8)'
- en: Divide the frequencies of each base by the total.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个碱基的频率除以总数。
- en: '[![9](assets/9.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-9)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO10-9)'
- en: Use a dictionary comprehension to convert the raw counts into weights.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典推导将原始计数转换为权重。
- en: 'This uses the `find_kmers()` function from [Part I](part01.html#part_one),
    which is:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了[第一部分](part01.html#part_one)中的 `find_kmers()` 函数，其定义如下：
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO11-1)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO11-1)'
- en: The number of k-mers is the length of the sequence minus `k` plus 1.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: k-mer的数量是序列长度减去`k`加1。
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO11-2)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO11-2)'
- en: Use a list comprehension to select all the k-mers from the sequence.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表推导从序列中选择所有k-mer。
- en: 'Here is how I wrote the `gen_seq()` function to generate a single sequence:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我编写的`gen_seq()`函数来生成单个序列的方式：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-1)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-1)'
- en: Initialize the sequence to a random choice from the keys of the chain.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将序列初始化为链中键的随机选择。
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-2)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-2)'
- en: Select a length for the sequence.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 选择序列的长度。
- en: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-3)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-3)'
- en: Execute a loop while the length of the sequence is less than the desired length.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在序列长度小于期望长度时执行循环。
- en: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-4)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-4)'
- en: Select the last `k - 1` bases.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最后`k - 1`个碱基。
- en: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-5)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-5)'
- en: Attempt to get a list of choices for this k-mer.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试获取此k-mer的选择列表。
- en: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-6)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-6)'
- en: Randomly choose the next base using the weighted choices.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用加权选择随机选择下一个碱基。
- en: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-7)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-7)'
- en: If we cannot find this k-mer in the chain, exit the loop.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在链中找不到这个k-mer，退出循环。
- en: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-8)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO12-8)'
- en: Return the new sequence if it is long enough; otherwise return `None`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新序列足够长，则返回新序列；否则返回`None`。
- en: 'To integrate all these, here is my `main()` function:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成所有这些，这是我的`main()`函数：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-1)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-1)'
- en: Set the random seed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 设置随机种子。
- en: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-2)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-2)'
- en: Read the training files in the given format using the given size `k`. This may
    fail if the sequences are shorter than `k`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用给定大小`k`读取以给定格式的训练文件。如果序列比`k`短，可能会失败。
- en: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-3)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-3)'
- en: Create a generator to produce the sequences.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 创建生成器以生成序列。
- en: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-4)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-4)'
- en: Use `filter()` with a predicate of `None` to remove falsey elements from the
    `seqs` generator. Use `enumerate()` to iterate through the index positions and
    sequences starting at 1 instead of 0.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`filter()`和谓词`None`从`seqs`生成器中移除虚假元素。使用`enumerate()`从索引位置1开始而不是0迭代位置和序列。
- en: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-5)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-5)'
- en: Print the sequence in FASTA format using the index position as the ID.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用索引位置打印FASTA格式的序列。
- en: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-6)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-6)'
- en: Break out of the loop if enough sequences have been generated.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已生成足够的序列，则退出循环。
- en: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-7)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-7)'
- en: Print the final status.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 打印最终状态。
- en: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-8)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_dna_synthesizer__creating_synthetic_data_with_markov_chains_CO13-8)'
- en: Let the user know why no sequences could be generated.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让用户知道为什么无法生成序列。
- en: 'I’d like to take a moment to explain the generator in the preceding code. I
    use the `range()` function to generate the desired number of sequences. I could
    have used a list comprehension like so:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我想花点时间解释上述代码中的生成器。我使用 `range()` 函数生成所需数量的序列。我本可以像这样使用列表推导式：
- en: '[PRE41]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'A list comprehension will force the creation of all the sequences before moving
    to the next line. If I were creating millions of sequences, the program would
    block here and likely use a large amount of memory to store all the sequences.
    If I replace the square brackets `[]` of the list comprehension with parentheses
    `()`, then it becomes a lazy generator:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式会在继续下一行之前强制创建所有序列。如果我要创建数百万个序列，程序会在这里阻塞，并且可能会使用大量内存来存储所有序列。如果我用圆括号 `()`
    替换列表推导式中的方括号 `[]`，那么它就变成了一个惰性生成器：
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: I can still treat this like a list by iterating over the values, but these values
    are only produced as needed. That means the line of code to create the generator
    executes almost immediately and moves on to the `for` loop. Additionally, the
    program only uses the memory needed to produce the next sequence.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然可以像遍历值列表一样处理它，但这些值只在需要时产生。这意味着创建生成器的代码行几乎立即执行并继续到 `for` 循环。此外，程序仅使用生成下一个序列所需的内存。
- en: 'One small problem with using `range()` and the number of sequences is that
    I know the `gen_seq()` function may sometimes return `None` to indicate that random
    choices lead down a chain that didn’t produce a long enough sequence. I need the
    generator to run with no upper limit, and I’ll write code to stop requesting sequences
    when enough have been generated. I can use `itertools.count()` to create an infinite
    sequence, and I use `filter()` with a predicate of `None` to remove falsey elements:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `range()` 和序列的数量存在一个小问题，即我知道 `gen_seq()` 函数有时可能返回 `None` 来指示随机选择导致未能生成足够长的序列。我需要生成器无上限地运行，并在生成足够多的序列后停止请求序列。我可以使用
    `itertools.count()` 创建无限序列，并使用带有 `None` 谓词的 `filter()` 来移除假值元素：
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'I can run the final program to create an output file using the defaults:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以运行最终程序来使用默认设置创建输出文件：
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And then I can use `seqmagique.py` from [Chapter 15](ch15.html#ch15) to verify
    that it generated the correct number of sequences in the expected ranges:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我可以使用来自[第 15 章](ch15.html#ch15)的 `seqmagique.py` 验证它是否在预期范围内生成了正确数量的序列：
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Flippin’ sweet.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很棒。
- en: Going Further
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入探讨
- en: Add a sequence `--type` option to produce either DNA or RNA.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 `--type` 选项来生成 DNA 或 RNA 序列。
- en: Expand the program to handle paired-end sequences where the forward and reverse
    reads are in two separate files.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展程序以处理前端和反向读取分别存储在两个文件中的成对端序列。
- en: Now that you understand Markov chains, you might be interested to see how they
    are used elsewhere in bioinformatics. For instance, the [HMMER](http://hmmer.org)
    tool uses hidden Markov models to find homologs in sequence databases and to create
    sequence alignments.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了马尔可夫链，你可能会对看到它们在生物信息学中的其他用途感兴趣。例如，[HMMER](http://hmmer.org) 工具使用隐藏的马尔可夫模型在序列数据库中找到同源物并创建序列比对。
- en: Review
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习
- en: 'Key points from this chapter:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的关键点：
- en: Random seeds are used to replicate pseudorandom selections.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用随机种子来复制伪随机选择。
- en: Markov chains can be used to encode the probabilities that a node in a graph
    can move to another node or state.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 马尔可夫链可用于编码图中一个节点移动到另一个节点或状态的概率。
- en: A list comprehension can be made into a lazy generator by replacing the square
    brackets with parentheses.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过用圆括号替换方括号，可以将列表推导式转换为惰性生成器。
