- en: 12 Integrating data fetching with Suspense
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 将数据获取与Suspense集成
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖了
- en: Wrapping promises to access their status
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装承诺以访问其状态
- en: Throwing promises and errors when fetching data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在获取数据时抛出承诺和错误
- en: Using `Suspense` components to specify fallback UI when loading data and images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Suspense`组件在加载数据和图像时指定回退UI
- en: Fetching data and resources as early as possible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽早获取数据和资源
- en: Recovering from errors when using error boundaries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用错误边界恢复错误
- en: The React team has a mission to maintain and develop a product that makes it
    as easy as possible for developers to create great user experiences. In addition
    to writing comprehensive documentation, providing intuitive and instructive developer
    tools, authoring descriptive and easily actionable error messages, and ensuring
    incremental upgrade paths, the team wants React to make it easy to provide fast-loading,
    responsive, and scalable applications. Concurrent Mode and Suspense offer ways
    to improve the user experience, orchestrating the loading of code and resources,
    enabling simpler, intentional loading states, and prioritizing updates that let
    users get on with their work or play.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: React团队有一个使命，即维护和开发一个产品，使开发者尽可能容易地创建出色的用户体验。除了编写全面的文档、提供直观且富有教育意义的开发者工具、编写描述性且易于操作的错误消息以及确保增量升级路径外，该团队希望React能够使提供快速加载、响应和可扩展的应用程序变得容易。并发模式和Suspense提供了改善用户体验的方法，协调代码和资源的加载，实现更简单、有意的加载状态，并优先处理允许用户继续工作或玩耍的更新。
- en: But the React team doesn’t want hooking into Concurrent Mode to be a burden
    on developers; they want as many of the benefits as possible to be automatic and
    any new APIs to be intuitive and in step with existing mindsets. So, Concurrent
    Mode is still flagged as experimental as the APIs are tested and tweaked. Hopefully,
    we won’t be kept in suspense for much longer! [*No! We agreed, no suspense jokes—ed*]
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但React团队不希望并发模式的挂钩成为开发者的负担；他们希望尽可能多的好处是自动的，任何新的API都是直观的，并与现有思维模式保持一致。因此，并发模式仍然被标记为实验性，因为API正在测试和调整。希望我们不会悬而未决太久！[*不！我们同意，不要开关于悬而未决的玩笑——编辑*]
- en: We’ll get into more of the philosophy and promise of Concurrent Mode in chapter
    13\. This chapter’s a bit of a bridge between the stable, production use of lazy
    components and Suspense from chapter 11 and the tentative APIs of deferred rendering,
    transitions, and `SuspenseList` components in chapter 13\. Here we use the ideas
    about thrown promises to consider what data fetching with Suspense might look
    like. The code examples are not for production but offer an insight into what
    library authors might need to consider in order to work well with Concurrent Mode
    and Suspense.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13章中，我们将深入探讨并发模式的哲学和承诺。本章是第11章中稳定的生产使用懒加载组件和Suspense与第13章中延迟渲染、过渡和`SuspenseList`组件的试验性API之间的桥梁。在这里，我们使用关于抛出承诺的想法来考虑使用Suspense进行数据获取可能的样子。代码示例不是用于生产，但可以提供关于库作者为了与并发模式和Suspense良好协作可能需要考虑的内容的见解。
- en: 12.1 Data fetching with Suspense
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 使用Suspense进行数据获取
- en: 'In chapter 11, we saw that `Suspense` components show fallback UI when they
    catch a thrown promise. There, we were lazy-loading components, and React coordinated
    the throwing of promises via the `lazy` function and dynamic imports:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11章中，我们看到了当`Suspense`组件捕获抛出的承诺时，它们会显示回退UI。在那里，我们正在懒加载组件，React通过`lazy`函数和动态导入协调承诺的抛出：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When trying to render the lazy component, React first checks the component’s
    status; if the dynamically imported component has loaded, React goes ahead and
    renders it, but if it’s pending, React throws the dynamic import promise. If the
    promise is rejected, we need an error boundary to catch the error and show appropriate
    fallback UI:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试渲染懒加载组件时，React首先检查组件的状态；如果动态导入的组件已加载，React将直接渲染它，但如果它是挂起的，React将抛出动态导入的承诺。如果承诺被拒绝，我们需要错误边界来捕获错误并显示适当的回退UI：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On reaching the `LazyCalendar` component, React can use the loaded component,
    throw an existing pending promise, or start the dynamic import and throw the new
    pending promise.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当到达`LazyCalendar`组件时，React可以使用已加载的组件、抛出一个现有的挂起承诺，或者开始动态导入并抛出一个新的挂起承诺。
- en: We want something similar for components that load data from a server. Say we
    have a `Message` component that loads and displays a message. In figure 12.1,
    the `Message` component has loaded the message “Hello Data!” and is displaying
    it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望对于从服务器加载数据的组件也有类似的功能。比如说我们有一个`Message`组件，它加载并显示一个消息。在图12.1中，`Message`组件已经加载了消息“Hello
    Data!”并正在显示它。
- en: '![](../Images/12-1.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-1.png)'
- en: Figure 12.1 The `Message` component loads a message and displays it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 `Message`组件加载一个消息并显示它。
- en: While data is loading, we want to use a `Suspense` component to display a fallback
    like the one in figure 12.2 which says, “Loading message . . . ”.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据正在加载时，我们希望使用`Suspense`组件显示一个回退，就像图12.2中的那样，上面写着“正在加载消息...”。
- en: '![](../Images/12-2.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-2.png)'
- en: Figure 12.2 While the data is loading, a `Suspense` component displays a fallback
    message.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 数据正在加载时，`Suspense`组件显示一个回退消息。
- en: And if there’s an error, we want an `ErrorBoundary` component to display a fallback
    like the one in figure 12.3, which says, “Oops!”
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现错误，我们希望`ErrorBoundary`组件显示一个回退，就像图12.3中的那样，上面写着“哎呀！”
- en: '![](../Images/12-3.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-3.png)'
- en: Figure 12.3 If there’s an error, an `ErrorBoundary` component displays an error
    message.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 如果有错误，`ErrorBoundary`组件显示一个错误消息。
- en: 'The JSX to match our expectations will be something like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 符合我们预期的JSX将类似于以下内容：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: But while we have the `lazy` function for lazy components, there is no stable,
    built-in mechanism for components that are loading data. (There is a `react-cache`
    package, but it’s experimental and unstable.)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，尽管我们有`lazy`函数用于懒加载组件，但没有稳定、内置的机制用于正在加载数据的组件。（有一个`react-cache`包，但它处于实验性且不稳定的状态。）
- en: Maybe we can come up with a way of loading data that throws promises or errors
    as appropriate. In doing so, we’ll gain a little insight into some of the steps
    that data-fetching libraries will need to implement, but it’s just an insight
    and definitely not a recommendation for production code. (Once Concurrent Mode
    and data-fetching strategies for React have settled, and battle-testing has defeated
    real-world issues and edge cases, look to the libraries like Relay, Apollo, and
    React Query for efficient, flexible, fully integrated data fetching.) Take a look
    at the following listing for our `Message` component. It includes a speculative
    `getMessageOrThrow` function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能可以想出一个方法来加载数据，根据需要抛出承诺或错误。这样做，我们将对数据获取库需要实现的一些步骤有一些了解，但这只是一个了解，绝对不是对生产代码的建议。（一旦并发模式和React的数据获取策略确定下来，并且实战测试击败了现实世界的问题和边缘情况，可以查看像Relay、Apollo和React
    Query这样的库，它们提供高效、灵活、完全集成的数据获取。）看看以下关于我们的`Message`组件的列表。它包括一个假设的`getMessageOrThrow`函数。
- en: Listing 12.1 The `Message` component calls a function to retrieve data
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12.1 `Message`组件调用一个函数来检索数据
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Call a function that returns data or throws a promise or error.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用一个返回数据或抛出承诺或错误的函数。
- en: ❷ Include the data in the UI.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在UI中包含数据。
- en: We want the `getMessageOrThrow` function to return the data if it’s available.
    If there’s a promise that hasn’t yet resolved to our data, the function should
    throw it. If the promise has been rejected, the function should throw an error.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望`getMessageOrThrow`函数在数据可用时返回数据。如果有一个尚未解决为我们数据的承诺，该函数应该抛出它。如果承诺已被拒绝，该函数应该抛出一个错误。
- en: The problem is, if there’s a promise for our data (like the one the browser’s
    fetch API returns, for example), we don’t have a way of checking its status. Is
    it pending? Has it resolved? Has it been rejected? We need to wrap the promise
    in code that’ll report its status.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，如果有一个我们的数据承诺（例如浏览器fetch API返回的承诺），我们没有检查其状态的方法。它是挂起的吗？它已经解决了吗？它已经被拒绝了？我们需要在代码中包装承诺，以报告其状态。
- en: 12.1.1 Upgrading promises to include their status
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.1 将承诺升级以包含其状态
- en: To work with `Suspense` and `ErrorBoundary` components, we need to use the status
    of a promise to dictate our actions. Table 12.1 matches the status with the required
    action.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要与`Suspense`和`ErrorBoundary`组件一起工作，我们需要使用承诺的状态来决定我们的行动。表12.1将状态与所需行动相匹配。
- en: Table 12.1 The action for each promise status
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.1 每个承诺状态的行动
- en: '| Status of promise | Action |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 承诺状态 | 行动 |'
- en: '| Pending | Throw the promise. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 进行中 | 抛出承诺。 |'
- en: '| Resolved | Return the resolved value—our data. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 已解决 | 返回已解决的价值——我们的数据。 |'
- en: '| Rejected | Throw the rejection error. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 拒绝 | 抛出拒绝错误。 |'
- en: 'The promise won’t report its own status, so we want some kind of `checkStatus`
    function that returns the current status of the promise and its resolved value
    or rejection error if available. Something like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺不会报告自己的状态，因此我们想要某种`checkStatus`函数，该函数返回承诺的当前状态以及可用的已解析值或拒绝错误。类似于以下内容：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or, because we’ll never get `data` and `error` at the same time, something
    like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，因为我们永远不会同时得到`data`和`error`，所以类似于以下内容：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’d then be able to use conditionals like `if` `(status` `===` `"pending")`
    to decide whether to throw promises or errors or to return values.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够使用条件语句如`if`(status `===` `"pending")`来决定是否抛出承诺或错误或返回值。
- en: The following listing shows a `getStatusChecker` function that takes a promise
    and returns a function that gives us access to the promise’s status.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个`getStatusChecker`函数，它接受一个承诺并返回一个函数，该函数让我们能够访问承诺的状态。
- en: Listing 12.2 Getting a function to access the status of a promise
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.2 获取访问承诺状态的函数
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Pass in the promise whose status we want to track.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 传递我们想要跟踪状态的承诺。
- en: ❷ Set up a variable to hold the status of the promise.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置一个变量来保存承诺的状态。
- en: ❸ Set up a variable for the resolved value or rejection error.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为已解析值或拒绝错误设置一个变量。
- en: ❹ On success, assign the resolved value to result.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在成功时，将已解析值赋值给结果。
- en: ❺ On error, assign the rejection error to result.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在出错时，将拒绝错误赋值给结果。
- en: ❻ Return a function to access the current status and result.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 返回一个函数来访问当前状态和结果。
- en: 'Using the `getStatusChecker` function, we can get the `checkStatus` function
    we need to track the status of a promise and react accordingly. For example, if
    we have a `fetchMessage` function that returns a promise and loads message data,
    we could get a status-tracking function like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`getStatusChecker`函数，我们可以获取我们需要来跟踪承诺状态并相应反应的`checkStatus`函数。例如，如果我们有一个`fetchMessage`函数返回一个承诺并加载消息数据，我们可以得到一个状态跟踪函数如下：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Okay, that’s great; we have a promise-status-tracking function. To integrate
    with Suspense, we need our data-fetching function to use that promise status to
    either return data, throw a promise, or throw an error.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那太好了；我们有一个承诺状态跟踪函数。为了与Suspense集成，我们需要我们的数据获取函数使用该承诺状态来返回数据、抛出承诺或抛出错误。
- en: 12.1.2 Using the promise status to integrate with Suspense
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.2 使用承诺状态与Suspense集成
- en: 'Here’s our `Message` component again:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的`Message`组件再次出现：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We want to be able to call a data-fetching function—in this case, `getMessageOrThrow`—that
    automatically integrates with Suspense by throwing promises or errors as appropriate
    or returns our data after it’s loaded. The following listing shows the `makeThrower`
    function that takes a promise and returns just such a function, one that uses
    the promise’s status to act appropriately.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够调用一个数据获取函数——在这个例子中，是`getMessageOrThrow`——该函数能够通过适当地抛出承诺或错误或在其加载后返回我们的数据来自动与Suspense集成。以下列表显示了`makeThrower`函数，它接受一个承诺并返回这样一个函数，该函数使用承诺的状态来适当地行动。
- en: Listing 12.3 Returning a data-fetching function that throws as appropriate
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.3 返回一个根据需要抛出异常的数据获取函数
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Pass in the data-fetching promise.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将数据获取的承诺传递进来。
- en: ❷ Get a status-tracking function for the promise.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取一个用于跟踪承诺状态的功能。
- en: ❸ Return a function that can throw.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回一个可以抛出异常的函数。
- en: ❹ Get the latest status whenever the function is called.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 每次函数被调用时获取最新的状态。
- en: ❺ Use the status to throw or return.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用状态来抛出或返回。
- en: 'For the `Message` component, we’ll use `makeThrower` to transform the promise
    that the `fetchMessage` function returns into a data-fetching function that can
    throw promises or errors:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Message`组件，我们将使用`makeThrower`将`fetchMessage`函数返回的承诺转换成一个可以抛出承诺或错误的 数据获取函数：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: But when do we start fetching? Where do we put that line of code?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们何时开始获取？在哪里放置那行代码？
- en: 12.1.3 Fetching data as early as possible
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.3 尽早获取数据
- en: We don’t have to wait until a component has rendered to start loading the data
    it needs. We can kick off fetching outside the component, using the fetch promise
    to build a throw-ready data-access function that the component can use. Listing
    12.4 shows a full `App` example for our `Message` component. The browser executes
    the code when it loads, starting the data fetch. Once React renders `App` and
    then the nested `Message`, `Message` calls `getMessageOrThrow`, which accesses
    the existing promise.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必等到组件渲染完成才开始加载数据。我们可以在组件外部启动获取，使用 fetch 承诺构建一个可以抛出的数据访问函数，组件可以使用它。列表 12.4
    展示了 `Message` 组件的完整 `App` 示例。浏览器在加载时执行代码，开始数据获取。一旦 React 渲染 `App` 和嵌套的 `Message`，`Message`
    将调用 `getMessageOrThrow`，该函数访问现有的承诺。
- en: '*Live*: [https://t1lsy.csb.app](https://t1lsy.csb.app), *Code*: [https://codesandbox.io/s/suspensefordata-t1lsy](https://codesandbox.io/s/suspensefordata-t1lsy)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时演示*: [https://t1lsy.csb.app](https://t1lsy.csb.app), *代码*: [https://codesandbox.io/s/suspensefordata-t1lsy](https://codesandbox.io/s/suspensefordata-t1lsy)'
- en: Listing 12.4 Using the `Message` component
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.4 使用 `Message` 组件
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Start fetching as soon as possible.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 尽快开始获取。
- en: ❷ Access the data or throw an error or promise.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 访问数据或抛出错误或承诺。
- en: ❸ Use the data if available.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果有数据，则使用数据。
- en: ❹ Catch thrown errors.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 捕获抛出的错误。
- en: ❺ Catch thrown promises.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 捕获抛出的承诺。
- en: 'Our error boundary is the `ErrorBoundary` component from the `react-error-boundary`
    package, mentioned in chapter 11\. We specify its fallback by setting the `FallbackComponent`
    prop. The `fetchMessage` function accepts two arguments to help you test the `Suspense`
    and `ErrorBoundary` fallbacks: a `delay` in milliseconds and a `canError` Boolean
    to randomly cause errors. If you want the request to take three seconds and sometimes
    fail, then change the call to the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的错误边界是第 11 章中提到的 `react-error-boundary` 包中的 `ErrorBoundary` 组件。我们通过设置 `FallbackComponent`
    属性来指定其回退。`fetchMessage` 函数接受两个参数以帮助您测试 `Suspense` 和 `ErrorBoundary` 的回退：一个以毫秒为单位的
    `delay` 和一个表示随机引发错误的 `canError` 布尔值。如果您希望请求持续三秒并有时失败，则将调用更改为以下内容：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In listing 12.4, the `Message` component can call `getMessageOrThrow` because
    it’s in the same scope. That won’t always be the case, so you may want to pass
    the data-access function to `Message` as a prop. You may also want to load new
    data in response to a user action. Let’s see how to work with props and events
    to make the data-fetching more flexible.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 12.4 中，`Message` 组件可以调用 `getMessageOrThrow`，因为它处于相同的范围。这并不总是情况，因此您可能希望将数据访问函数作为属性传递给
    `Message`。您还可能希望根据用户操作加载新数据。让我们看看如何使用属性和事件使数据获取更加灵活。
- en: 12.1.4 Fetching new data
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.4 获取新数据
- en: Say we want to upgrade our `Message` component to include a Next button, as
    shown in figure 12.4.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要升级我们的 `Message` 组件以包括一个“下一步”按钮，如图 12.4 所示。
- en: '![](../Images/12-4.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-4.png)'
- en: Figure 12.4 The `Message` component now displays a Next button.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 `Message` 组件现在显示了一个“下一步”按钮。
- en: Clicking the Next button will load and display a new message. While the new
    message is loading, `Message` will *suspend* (the `getMessageOrThrow` function
    or its equivalent will throw its promise), and the `Suspense` component will show
    the “Loading message . . .” fallback UI from figure 12.2 again. Once the promise
    resolves, `Message` will display the newly loaded message, “Bonjour,” as shown
    in figure 12.5.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“下一步”按钮将加载并显示一条新消息。在新消息加载期间，`Message` 将 *挂起*（`getMessageOrThrow` 函数或其等效函数将抛出其承诺），`Suspense`
    组件将再次显示图 12.2 中的“加载消息...”回退 UI。一旦承诺解决，`Message` 将显示新加载的消息，“Bonjour”，如图 12.5 所示。
- en: '![](../Images/12-5.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-5.png)'
- en: Figure 12.5 Clicking the Next button loads a new message.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 点击“下一步”按钮加载一条新消息。
- en: For each new message that we load, we need a new promise and a new data-fetching
    function that can throw. In listing 12.6, we’ll update the `Message` component
    to accept the data-fetching function as a prop. First, listing 12.5 shows the
    `App` component managing the current data-fetching function in state and passing
    it to `Message`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们加载的每一条新消息，我们需要一个新的承诺和一个可以抛出错误的新数据获取函数。在列表 12.6 中，我们将更新 `Message` 组件以接受数据获取函数作为属性。首先，列表
    12.5 展示了 `App` 组件在状态中管理当前的数据获取函数并将其传递给 `Message`。
- en: '*Live*: [https://xue0l.csb.app](https://xue0l.csb.app), *Code*: [https://codesandbox.io/s/suspensefordata2-xue0l](https://codesandbox.io/s/suspensefordata2-xue0l)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时演示*: [https://xue0l.csb.app](https://xue0l.csb.app), *代码*: [https://codesandbox.io/s/suspensefordata2-xue0l](https://codesandbox.io/s/suspensefordata2-xue0l)'
- en: Listing 12.5 The `App` component holds the current `getMessage` function in
    state
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.5 `App` 组件持有当前的 `getMessage` 函数
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Fetch the first message straight away.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 立即获取第一条消息。
- en: ❷ Keep the current data-fetching function in state.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 保持当前的数据获取函数在状态中。
- en: ❸ Start fetching the next message.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 开始获取下一条消息。
- en: ❹ Get a data-fetching function that can throw the promise or error.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 获取一个可以抛出承诺或错误的 data-fetching 函数。
- en: ❺ Update the state to hold the latest data-fetching function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 更新状态以保存最新的数据获取函数。
- en: ❻ Pass the current data-fetching function to the Message component.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将当前的数据获取函数传递给 Message 组件。
- en: ❼ Give the Message component a way to request the next message.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 给 Message 组件一个请求下一条消息的方法。
- en: We pass `useState` an initialization function that returns the data-fetching
    function for the first message, `getFirstMessage`. Notice, we don’t call `getFirstMessage`;
    we return it, setting it as the initial state.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `useState` 传递一个初始化函数，该函数返回第一条消息的数据获取函数 `getFirstMessage`。注意，我们不是调用 `getFirstMessage`；我们返回它，将其设置为初始状态。
- en: '`App` also provides a `next` function for loading the next message and placing
    the new data-fetching function in state. The first thing the `next` function does
    is start fetching the next message:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`App` 还提供了一个 `next` 函数，用于加载下一条消息并将新的数据获取函数放入状态。`next` 函数的第一件事是开始获取下一条消息：'
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our API on CodeSandbox includes the `fetchNextMessage` function that requests
    the next message and returns a promise. To integrate with Suspense by throwing
    a pending promise, `next` needs to get a promise-throwing function for the data-fetching
    promise:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 CodeSandbox 上的 API 包含 `fetchNextMessage` 函数，该函数请求下一条消息并返回一个承诺。为了通过抛出挂起的承诺与
    Suspense 集成，`next` 需要获取一个用于数据获取承诺的抛出承诺的函数：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The final step is to update the state; it’s holding the current promise-throwing
    function. Both `useState` and the updater function it returns, `setGetMessage`
    in this case, accept a function as an argument. If you pass them a function, they
    call `useState` to get its initial state and `setGetMessage` to get the new state.
    Because the state value we’re trying to store is a function itself, we can’t pass
    it directly to these state-setting functions. We don’t do this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是更新状态；它持有当前的抛出承诺的函数。`useState` 和它返回的更新函数（在这种情况下为 `setGetMessage`），都接受一个函数作为参数。如果你向它们传递一个函数，它们会调用
    `useState` 来获取其初始状态，并调用 `setGetMessage` 来获取新状态。因为我们试图存储的状态值本身就是一个函数，所以我们不能直接将这些状态设置函数传递给它。我们不这样做：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And we don’t do this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不这样做：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Instead, we pass `useState` and `setGetMessage` functions that return the functions
    we want to set as state:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们传递 `useState` 和 `setGetMessage` 函数，这些函数返回我们想要设置为状态的函数：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And we use this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We don’t want to call `getNextMessage` here; we just want to set it as the new
    state value. Setting the state value causes `App` to re-render, passing `Message`
    the latest data-fetching function as the `getMessage` prop.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想在这里调用 `getNextMessage`；我们只想将其设置为新的状态值。设置状态值会导致 `App` 重新渲染，将最新的数据获取函数作为 `getMessage`
    prop 传递给 `Message`。
- en: The updated `Message` component is in the following listing. It shows the component
    accepting `getMessage` and `next` as props and includes the Next button in the
    UI.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的 `Message` 组件如下所示。它显示了组件接受 `getMessage` 和 `next` 作为 props，并在 UI 中包含 Next
    按钮。
- en: '*Live*: [https://xue0l.csb.app](https://xue0l.csb.app), *Code*: [https://codesandbox.io/s/suspensefordata2-xue0l](https://codesandbox.io/s/suspensefordata2-xue0l)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时*: [https://xue0l.csb.app](https://xue0l.csb.app)，*代码*: [https://codesandbox.io/s/suspensefordata2-xue0l](https://codesandbox.io/s/suspensefordata2-xue0l)'
- en: Listing 12.6 Pass `Message` props for data fetching
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.6 为数据获取传递 `Message` props
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Accept the data-fetching function and button handler as props.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 接受数据获取函数和按钮处理程序作为 props。
- en: ❷ Include a Next button in the UI.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在 UI 中包含一个 Next 按钮。
- en: '`Message` calls `getMessage`, which returns the new message data or throws.
    When a user clicks the Next button, `Message` calls `next`, starting to fetch
    the next message straightaway. And re-rendering straightaway. We’re using the
    *render-as-you-fetch* approach, specifying `Suspense` and `ErrorBoundary` fallbacks
    for React to render when components throw promises or errors.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message` 调用 `getMessage`，它返回新的消息数据或抛出异常。当用户点击 Next 按钮时，`Message` 调用 `next`，立即开始获取下一条消息。并且立即重新渲染。我们正在使用
    *render-as-you-fetch* 方法，为 React 指定 `Suspense` 和 `ErrorBoundary` 作为当组件抛出承诺或错误时的回退。'
- en: Speaking of errors, our `App` component is using the `ErrorBoundary` component
    from the `react-error-boundary` package. It has a few more tricks up its sleeve,
    including easy error recovery. Let’s cast our next spell.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 说到错误，我们的 `App` 组件正在使用来自 `react-error-boundary` 包的 `ErrorBoundary` 组件。它还有一些额外的技巧，包括简单的错误恢复。让我们施展下一个咒语。
- en: 12.1.5 Recovering from errors
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.5 从错误中恢复
- en: Figure 12.6 shows what we’re after; when an error occurs, we want to give users
    a Try Again button to click, to reset the error state and try rendering the app
    again.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 显示了我们想要的结果；当发生错误时，我们希望给用户提供一个可点击的重试按钮，以重置错误状态并再次尝试渲染应用程序。
- en: '![](../Images/12-6.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-6.png)'
- en: Figure 12.6 The `ErrorBoundary` component UI now includes a Try Again button
    to reset the error boundary and load the next message.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 `ErrorBoundary` 组件 UI 现在包括一个重试按钮，用于重置错误边界并加载下一条消息。
- en: 'In listing 12.5, we assigned the `ErrorFallback` component as the `FallbackComponent`
    prop for the `ErrorBoundary`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 12.5 中，我们将 `ErrorFallback` 组件分配为 `ErrorBoundary` 的 `FallbackComponent` 属性：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The following listing shows a new version of our `ErrorFallback` component.
    When `ErrorBoundary` catches an error and renders the fallback, it automatically
    passes a `resetErrorBoundary` function to `ErrorFallback`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了我们 `ErrorFallback` 组件的新版本。当 `ErrorBoundary` 捕获错误并渲染回退时，它会自动将 `resetErrorBoundary`
    函数传递给 `ErrorFallback`。
- en: '*Live*: [https://7i89e.csb.app/](https://7i89e.csb.app/), *Code*: [https://codesandbox.io/s/errorrecovery-7i89e](https://codesandbox.io/s/errorrecovery-7i89e)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时*: [https://7i89e.csb.app/](https://7i89e.csb.app/)，*代码*: [https://codesandbox.io/s/errorrecovery-7i89e](https://codesandbox.io/s/errorrecovery-7i89e)'
- en: Listing 12.7 Adding a button to `ErrorFallback`
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.7 向 `ErrorFallback` 添加按钮
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Receive the resetErrorBoundary function from ErrorBoundary as a prop.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 ErrorBoundary 作为属性接收 `resetErrorBoundary` 函数。
- en: ❷ Include a button that calls resetErrorBoundary.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 包含一个调用 `resetErrorBoundary` 的按钮。
- en: The `ErrorFallback` UI now includes a Try Again button that calls the `resetErrorBoundary`
    function to remove the error state and render the error boundary’s children rather
    than the error fallback UI. In addition to resetting the error state on the error
    boundary, `resetErrorBoundary` will also call any reset function that we assign
    to the error boundary’s `onReset` prop. In the following listing, we tell `ErrorBoundary`
    to call our `next` function and load the next message whenever we reset the boundary.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrorFallback` UI 现在包括一个重试按钮，该按钮调用 `resetErrorBoundary` 函数来移除错误状态并渲染错误边界的子组件，而不是错误回退
    UI。除了在错误边界上重置错误状态外，`resetErrorBoundary` 还会调用我们分配给错误边界的 `onReset` 属性的任何重置函数。在下面的列表中，我们告诉
    `ErrorBoundary` 在重置边界时调用我们的 `next` 函数并加载下一条消息。'
- en: '*Live*: [https://7i89e.csb.app/](https://7i89e.csb.app/), *Code*: [https://codesandbox.io/s/errorrecovery-7i89e](https://codesandbox.io/s/errorrecovery-7i89e)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时*: [https://7i89e.csb.app/](https://7i89e.csb.app/)，*代码*: [https://codesandbox.io/s/errorrecovery-7i89e](https://codesandbox.io/s/errorrecovery-7i89e)'
- en: Listing 12.8 Adding an `onReset` prop to `ErrorBoundary`
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.8 向 `ErrorBoundary` 添加 `onReset` 属性
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Include an onReset function that ErrorBoundary will call if reset.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含一个 `onReset` 函数，如果重置，ErrorBoundary 将会调用它。
- en: 'The error boundary now does something to try to shake the app’s error state:
    it tries to load the next message. Here are the steps it goes through when the
    `Message` component throws an error trying to load a message:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 错误边界现在尝试做一些事情来尝试消除应用程序的错误状态：它尝试加载下一条消息。以下是当 `Message` 组件在尝试加载消息时抛出错误时它所经历的步骤：
- en: The `Message` component throws an error.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Message` 组件抛出错误。'
- en: '`ErrorBoundary` catches the error and renders the `ErrorFallback` component,
    including the Try Again button.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ErrorBoundary` 捕获错误并渲染 `ErrorFallback` 组件，包括重试按钮。'
- en: The user clicks the Try Again button.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户点击重试按钮。
- en: The button calls `resetErrorBoundary`, removing the error state from the boundary.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮调用 `resetErrorBoundary`，从边界中移除错误状态。
- en: The error boundary re-renders its children and calls `next` to load the next
    message.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误边界重新渲染其子组件并调用 `next` 来加载下一条消息。
- en: 'Check out the GitHub repository for `react-error-boundary` to see the rest
    of its super-helpful error-related tricks: [https://github.com/bvaughn/react-error-boundary](https://github.com/bvaughn/react-error-boundary).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 查看GitHub上的 `react-error-boundary` 仓库以了解其其他超级有用的错误相关技巧：[https://github.com/bvaughn/react-error-boundary](https://github.com/bvaughn/react-error-boundary)。
- en: 12.1.6 Checking the React docs
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.6 检查 React 文档
- en: 'In our brief foray into one experimental way of integrating data fetching with
    Suspense, we created two key functions:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们简要探索将数据获取与 Suspense 集成的一种实验方法时，我们创建了两个关键函数：
- en: '`getStatusChecker`—Provides a window into the status of a promise'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getStatusChecker`—提供对承诺状态的窗口'
- en: '`makeThrower`—Upgrades a promise into one that returns data or that throws
    an error or promise'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`makeThrower`—将一个承诺升级为返回数据或抛出错误或承诺的承诺'
- en: We used `makeThrower` to create functions like `getMessageOrThrow` that the
    `Message` component used to get the latest message, throw an error, or throw a
    promise (suspend). We stored the data-fetching functions in state and passed them
    to children via props.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `makeThrower` 创建了 `getMessageOrThrow` 等函数，这些函数被 `Message` 组件用来获取最新消息、抛出错误或抛出承诺（挂起）。我们将数据获取函数存储在状态中并通过属性传递给子组件。
- en: 'The React docs also have an experimental, just for information, be careful—no,
    really be careful—example of integrating our own promises with Suspense, shown
    in the following listing, that does the job of our `getStatusChecker` and `makeThrower`
    functions in one `wrapPromise` function. Read the rationale behind the code in
    the docs: [http://mng.bz/JDBK](http://mng.bz/JDBK).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: React 文档还有一个实验性的、仅供信息参考的、请务必小心——真的要小心——示例，展示了如何将我们自己的承诺与 Suspense 集成，如下所示，这个示例完成了我们的
    `getStatusChecker` 和 `makeThrower` 函数在 `wrapPromise` 函数中的工作。在文档中阅读代码背后的理由：[http://mng.bz/JDBK](http://mng.bz/JDBK)。
- en: 'Code: [https://codesandbox.io/s/frosty-hermann-bztrp?file=/src/fakeApi.js](https://codesandbox.io/s/frosty-hermann-bztrp?file=/src/fakeApi.js)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 代码：[https://codesandbox.io/s/frosty-hermann-bztrp?file=/src/fakeApi.js](https://codesandbox.io/s/frosty-hermann-bztrp?file=/src/fakeApi.js)
- en: Listing 12.9 The `wrapPromise` function from the React docs examples
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.9 来自 React 文档示例的 `wrapPromise` 函数
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ The code is for interest rather than production use.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这段代码仅用于兴趣，而不是用于生产用途。
- en: ❷ The code names the wrapped promise a suspender.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 代码将包装的承诺命名为 suspender。
- en: ❸ The function returns an object with a read method.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 该函数返回一个具有读取方法的对象。
- en: The `wrapPromise` function doesn’t return a function directly; it returns an
    object with a `read` method. So, rather than assigning a *function* to a local
    variable, `getMessage`, like this
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrapPromise` 函数不是直接返回一个函数；它返回一个具有 `read` 方法的对象。因此，而不是将一个 *函数* 分配给一个局部变量，`getMessage`，如下所示'
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Assign the data-fetching function to getMessage.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将数据获取函数分配给 `getMessage`。
- en: ❷ Call getMessage to get data or throw.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用 `getMessage` 来获取数据或抛出。
- en: 'we assign an *object* to a local variable, `messageResource`, like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个 *对象* 分配给一个局部变量，`messageResource`，如下所示：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Assign the object with data-fetching method to messageResource.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将具有数据获取方法的对象分配给 `messageResource`。
- en: ❷ Call the read method to get data or throw.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用读取方法来获取数据或抛出。
- en: Which approach is better? Well, I bet the React team thought carefully about
    its examples and considered many more scenarios in which the concept of a *resource*
    with a `read` method was found to be easier to think about and work with than
    directly storing, passing, and calling naked data-fetching functions. Having said
    that, I think our step-by-step exploration of the concepts and procedures involved
    in integrating data fetching with Suspense has been useful.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种方法更好？嗯，我敢打赌 React 团队对其示例进行了深思熟虑，并考虑了许多更多场景，在这些场景中，具有 `read` 方法的 *资源* 概念被发现比直接存储、传递和调用裸数据获取函数更容易思考和操作。话虽如此，我认为我们对将数据获取与
    Suspense 集成所涉及的概念和程序进行的逐步探索是有用的。
- en: Ultimately, this is all still theoretical and experimental and is highly likely
    to change. Unless you’re a data-fetching library author yourself, you’ll find
    the nitty-gritty details will be handled by the libraries you use. We’ve been
    using React Query for our data work; does it integrate with Suspense?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这些都仍然是理论性和实验性的，并且很可能会有所改变。除非你自己是数据获取库的作者，否则你会发现细节将由你使用的库来处理。我们一直在使用 React
    Query 进行我们的数据工作；它是否与 Suspense 集成？
- en: 12.2 Using Suspense and error boundaries with React Query
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 使用 React Query 和错误边界
- en: React Query provides an experimental config option to switch on Suspense for
    queries. Rather than returning status and error information, queries will throw
    promises and errors. You can find out more about the experimental Suspense integration
    in the React Query documentation ([http://mng.bz/w9A2](http://mng.bz/w9A2)).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: React Query 提供了一个实验性的配置选项来为查询启用 Suspense。而不是返回状态和错误信息，查询将抛出承诺和错误。你可以在 React
    Query 文档中了解更多关于实验性的 Suspense 集成的信息 ([http://mng.bz/w9A2](http://mng.bz/w9A2))。
- en: 'For the bookings app, we’ve been using the `status` value that `useQuery` returns
    to conditionally render loading spinners and error messages. All of our data-loading
    components have code like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于预订应用，我们一直在使用 `useQuery` 返回的 `status` 值来有条件地渲染加载指示器和错误消息。我们所有的数据加载组件都有如下代码：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ When loading data, assign status value to a local variable.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当加载数据时，将状态值分配给一个局部变量。
- en: ❷ Check status and return appropriate UI.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查状态并返回适当的 UI。
- en: But we’ve now seen how `Suspense` and `ErrorBoundary` components let us decouple
    the loading and error UI from individual components. The bookings app has page-level
    `Suspense` and `ErrorBoundary` components in place, so let’s switch over our queries
    to use the existing components.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们已经看到了 `Suspense` 和 `ErrorBoundary` 组件如何让我们将加载和错误 UI 与单个组件解耦。预订应用已经设置了页面级别的
    `Suspense` 和 `ErrorBoundary` 组件，所以让我们将查询切换到使用现有的组件。
- en: 'Branch: 1201-suspense-data, File: /src/components/Bookables/BookablesView.js'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1201-suspense-data，文件：/src/components/Bookables/BookablesView.js
- en: Listing 12.10 The `BookablesView` component with Suspense integration
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.10 带有 Suspense 集成的 `BookablesView` 组件
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Pass a config object with suspense set to true.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 传递一个将 suspense 设置为 true 的配置对象。
- en: ❷ Remove the status-checking code for loading and error states.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 删除加载和错误状态的检查代码。
- en: 'The updated `BookablesView` component passes a configuration option to `useQuery`
    when loading the bookables data:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的 `BookablesView` 组件在加载可预订数据时将配置选项传递给 `useQuery`：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That config option tells `useQuery` to suspend (throw a promise) when loading
    its initial data and to throw an error if something goes wrong.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置选项告诉 `useQuery` 在加载其初始数据时挂起（抛出一个承诺），如果出现问题则抛出错误。
- en: Challenge 12.1
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战 12.1
- en: 'Update the `BookingsPage` and `UsersList` components to use Suspense when loading
    their data. Remove any unnecessary loading and error state UI that’s embedded
    within the components. The current branch includes the changes: 1201-suspense-data.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `BookingsPage` 和 `UsersList` 组件，在加载数据时使用 Suspense。删除组件内嵌入的任何不必要的加载和错误状态 UI。当前分支包括这些更改：1201-suspense-data。
- en: 12.3 Loading images with Suspense
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 使用 Suspense 加载图像
- en: 'Suspense works great with lazily-loaded components and, at least tentatively,
    can be integrated with the promises that arise naturally when loading data. How
    about other resources like scripts and images, for example? The key is the promise:
    if we can wrap our requests in promises, we can (at least experimentally) work
    with Suspense and error boundaries to provide fallback UI. Let’s look at a scenario
    for integrating image loading with Suspense.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Suspense 与懒加载组件配合得很好，并且至少在试验性上可以与加载数据时自然出现的承诺集成。那么其他资源，比如脚本和图像，怎么办呢？关键是承诺：如果我们能将我们的请求包裹在承诺中，我们就可以（至少在实验上）与
    Suspense 和错误边界一起工作，以提供后备 UI。让我们看看一个将图像加载与 Suspense 集成的场景。
- en: Your boss is keen for you to make the Users page more useful, wanting you to
    include an avatar image for each user and, later, details of each user’s bookings
    and tasks. We’ll get to the bookings and tasks in the next chapter. Here, we aim
    to include an avatar image like the Japanese castle shown in figure 12.7.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您的老板希望您使用户页面更加有用，希望您为每个用户添加头像图片，稍后，再添加每个用户的预订和任务详情。我们将在下一章中介绍预订和任务。这里，我们旨在添加一个像图
    12.7 中所示的日本城堡的头像图片。
- en: '![](../Images/12-7.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-7.png)'
- en: Figure 12.7 The `UserDetails` component includes an avatar image for each user.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 `UserDetails` 组件为每个用户包含一个头像图片。
- en: 'The 1202-user-avatar branch of the GitHub repo includes separate components
    for the list of users and the details of the selected user, `UsersList` and `UserDetails`,
    with management of the selected user in the `UsersPage` component. The repo also
    has avatar images in the /public/img folder. `UsersPage` now passes `UserDetails`
    just the ID of the selected user, and the `UserDetails` component loads the user’s
    details and then renders the avatar as a standard `img` element:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 仓库的 1202-user-avatar 分支包括用户列表和所选用户详情的独立组件，分别是 `UsersList` 和 `UserDetails`，在
    `UsersPage` 组件中管理所选用户。仓库在 /public/img 文件夹中也有头像图片。`UsersPage` 现在只传递所选用户的 ID 给 `UserDetails`，然后
    `UserDetails` 组件加载用户的详细信息，并将头像渲染为标准的 `img` 元素：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Unfortunately, at slow network speeds and with large avatar image files, the
    images can take a while to load, leading to the poor user experience shown in
    figure 12.8, where the image (a butterfly on a flower) appears bit by bit. You
    can use your browser’s developer tools to throttle the network speed.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在慢速网络速度和大型头像图片文件的情况下，图像可能需要一段时间才能加载，导致图 12.8 中显示的糟糕用户体验，其中图像（一朵花上的蝴蝶）逐渐出现。您可以使用浏览器开发者工具来限制网络速度。
- en: '![](../Images/12-8.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-8.png)'
- en: Figure 12.8 When switching users, the avatar image might take a while to load,
    potentially resulting in a poor user experience. Here, only half of the image
    has loaded so far.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 当切换用户时，头像图片可能需要一段时间才能加载，可能会导致糟糕的用户体验。这里，图像只加载了一半。
- en: 'In this section, we explore a couple of ways of improving the user experience
    for slow-loading images within our user interface:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了几种提高用户界面中慢加载图像用户体验的方法：
- en: Using React Query and Suspense to provide an image-loading fallback
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Query 和 Suspense 提供图像加载回退
- en: Prefetching images and data with React Query
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Query 预加载图像和数据
- en: Together, the two approaches help provide users with a predictable user interface
    where, hopefully, slow-loading assets won’t call attention to themselves, degrading
    the experience of using the app.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法结合使用，有助于为用户提供一个可预测的用户界面，其中，希望慢加载的资产不会引起注意，从而降低使用应用时的体验。
- en: 12.3.1 Using React Query and Suspense to provide an image-loading fallback
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.1 使用 React Query 和 Suspense 提供图像加载回退
- en: We want to show some kind of fallback while images load, maybe a shared avatar
    placeholder with a small file size, like the head silhouette image shown in figure
    12.9.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在图像加载时显示某种回退，可能是一个具有小文件大小的共享头像占位符，就像图 12.9 中显示的头像轮廓图像。
- en: '![](../Images/12-9.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/12-9.png)'
- en: Figure 12.9 While the avatar image is loading, we can show a placeholder image
    that has a small file size and that could be loaded earlier.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 当头像图像加载时，我们可以显示一个具有小文件大小且可以提前加载的占位符图像。
- en: 'To integrate with Suspense, we need an image-loading process that throws a
    promise until the image is ready to use. We create the promise manually, around
    the DOM `HTMLImageElement` `Image` constructor like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 Suspense 集成，我们需要一个图像加载过程，直到图像准备好使用时才抛出 promise。我们手动创建这个 promise，类似于围绕 DOM
    `HTMLImageElement` `Image` 构造函数这样做：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Create a new image object.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新的图像对象。
- en: ❷ Resolve the promise when the image finishes loading.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当图像加载完成时解析 promise。
- en: ❸ Start loading the image by specifying its source.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过指定其源来开始加载图像。
- en: 'We then need an image-loading function that throws the promise while it’s pending:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个图像加载函数，在挂起时抛出 promise：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And, finally, a React component that calls the function, rendering the image
    after it has loaded:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个调用函数并渲染图像的 React 组件，在图像加载后显示：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Get the image object or throw a promise.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取图像对象或抛出一个 promise。
- en: ❷ Once the image is available, render a standard img element.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一旦图像可用，渲染一个标准的 img 元素。
- en: But we don’t want to be continually reloading the image on every render, so
    we need some kind of cache. Well, we already have one of those built into React
    Query. So, rather than building our own cache and throwing our own promises, let’s
    hook into React Query’s Suspense integration (not forgetting that it’s experimental).
    The following listing shows an `Img` component that throws pending promises until
    its image has loaded.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不想在每次渲染时不断重新加载图像，因此我们需要某种类型的缓存。嗯，我们已经在 React Query 中有一个这样的内置缓存。所以，我们不必构建自己的缓存和抛出自己的
    promise，而是连接到 React Query 的 Suspense 集成（不要忘记它是实验性的）。以下列表显示了一个抛出挂起 promise 直到图像加载的
    `Img` 组件。
- en: 'Branch: 1203-suspense-images, File: /src/components/Users/Avatar.js'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1203-suspense-images，文件：/src/components/Users/Avatar.js
- en: Listing 12.11 An `Img` component that uses React Query
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.11 使用 React Query 的 `Img` 组件
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Use React Query for caching, deduping, and throwing.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 React Query 进行缓存、去重和抛出。
- en: ❷ Use the image src as the query key.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用图像 src 作为查询键。
- en: ❸ Pass useQuery a function that creates an image-loading promise.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 向 useQuery 传递一个创建图像加载 promise 的函数。
- en: ❹ Throw pending promises and errors.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 抛出挂起的 promise 和错误。
- en: ❺ Return a standard img element after the image has loaded.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在图像加载完成后返回一个标准的 img 元素。
- en: Using multiple `Img` components with the same source won’t try to load the image
    multiple times; React Query will return the cached `Image` object. (The image
    itself will be cached by the browser.)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具有相同源的多 `Img` 组件不会尝试多次加载图像；React Query 将返回缓存的 `Image` 对象。（图像本身将由浏览器缓存。）
- en: In the bookings app, we want an `Avatar` component that uses Suspense to show
    a fallback while the image is loading. The following listing uses the `Img` component
    along with a `Suspense` component to achieve our goal.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在预订应用中，我们希望有一个使用 Suspense 来显示回退的 `Avatar` 组件，在图像加载时显示。以下列表使用 `Img` 组件以及一个 `Suspense`
    组件来实现我们的目标。
- en: 'Branch: 1203-suspense-images, File: /src/components/Users/Avatar.js'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1203-suspense-images，文件：/src/components/Users/Avatar.js
- en: Listing 12.12 An `Avatar` component that uses `Img` and `Suspense`
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.12 使用 `Img` 和 `Suspense` 的 `Avatar` 组件
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Specify fallbackSrc and src props.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 指定 fallbackSrc 和 src 属性。
- en: ❷ Use the fallbackSrc prop to show an image as a Suspense fallback.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 fallbackSrc 属性显示一个作为 Suspense 回退的图像。
- en: ❸ Use the Img component to integrate with the Suspense component.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 Img 组件与 Suspense 组件集成。
- en: The `UserDetails` component can now use an `Avatar` to show a fallback image
    until the desired image has loaded, as implemented in the following listing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserDetails` 组件现在可以使用 `Avatar` 来显示备用图像，直到所需的图像加载完成，如下面的列表所示。'
- en: 'Branch: 1203-suspense-images, File: /src/components/Users/UserDetails.js'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1203-suspense-images，文件：/src/components/Users/UserDetails.js
- en: Listing 12.13 Using the `Avatar` component in `UserDetails`
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.13 在 `UserDetails` 中使用 `Avatar` 组件
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Pass in the ID of the user to show.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 传入要显示的用户 ID。
- en: ❷ Load the data for the specified user.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 加载指定用户的图像数据。
- en: ❸ Show an avatar, specifying the image and fallback sources.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 显示一个头像，指定图像和备用源。
- en: We could even preload the fallback image by adding a `link` element with `rel=`
    `"prefetch"` to the page’s `head` element, or by imperatively preloading it in
    a parent component. Let’s look at preloading data and images now.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过在页面的 `head` 元素中添加一个带有 `rel="prefetch"` 的 `link` 元素，或者在父组件中强制预加载，来预加载备用图像。现在让我们看看如何预加载数据和图像。
- en: 12.3.2 Prefetching images and data with React Query
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.2 使用 React Query 预取图像和数据
- en: At the moment, the `UserDetails` component doesn’t render the `Avatar` until
    the user data has finished loading. We wait for the user data before requesting
    the image we need, creating a *waterfall*, as shown in figure 12.10.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`UserDetails` 组件在用户数据加载完成之前不会渲染 `Avatar`。我们在请求所需的图像之前等待用户数据，从而创建了一个 *瀑布效应*，如图
    12.10 所示。
- en: '![](../Images/12-10.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-10.png)'
- en: Figure 12.10 The Waterfall panel shows that the image for user 2 (user2.png)
    isn’t requested until the data for user 2 has finished loading.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10 水瀑布面板显示，用户 2 的图像（user2.png）在用户 2 的数据加载完成之前不会请求。
- en: 'The second row shows the data for user 2 loading. The third row shows the image
    for user 2, user2.png, loading. Here are the steps from click to image when we
    select a user in the users list:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行显示用户 2 的数据正在加载。第三行显示用户 2 的图像（user2.png）正在加载。以下是我们从点击到图像的步骤，当我们从用户列表中选择一个用户时：
- en: A user is selected.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户被选中。
- en: '`UserDetails` loads the user information, suspending until the data loads.'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UserDetails` 加载用户信息，挂起直到数据加载完成。'
- en: Once the data has loaded, `UserDetails` renders its UI, including the `Avatar`
    component.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦数据加载完成，`UserDetails` 组件渲染其 UI，包括 `Avatar` 组件。
- en: '`Avatar` renders the `Img` component, which requests the image and suspends
    until the image has loaded.'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Avatar` 组件渲染 `Img` 组件，该组件请求图像并在图像加载完成前挂起。'
- en: Once the image has loaded, `Img` renders its UI, an `img` element.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦图像加载完成，`Img` 组件渲染其 UI，一个 `img` 元素。
- en: The image doesn’t start loading until the user data has arrived. But the image
    filename is predictable. Can we start loading the image at the same time as the
    user information, as shown in the last two rows of figure 12.11?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图像只有在用户数据到达后才开始加载。但图像文件名是可以预测的。我们能否像图 12.11 的最后两行所示，在用户信息的同时开始加载图像？
- en: '![](../Images/12-11.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-11.png)'
- en: Figure 12.11 We want the user 2 image and data to load concurrently, as in the
    last two rows of the figure.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11 我们希望用户 2 的图像和数据能够并发加载，如图表中的最后两行所示。
- en: The user selection is managed in the `UsersPage` component by the `switchUser`
    function. To get the concurrent loading shown in figure 12.11, let’s get React
    Query to start fetching the user data and image at the same time. The following
    listing includes the two new `prefetchQuery` calls.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 用户选择由 `UsersPage` 组件中的 `switchUser` 函数管理。为了得到图 12.11 所示的并发加载效果，让我们让 React Query
    同时获取用户数据和图像。以下列表中包含了两个新的 `prefetchQuery` 调用。
- en: 'Branch: 1204-prefetch-query, File: /src/components/Users/UsersPage.js'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1204-prefetch-query，文件：/src/components/Users/UsersPage.js
- en: Listing 12.14 Preloading images and data on the Users page
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12.14 在用户页面预加载数据和图像
- en: '[PRE37]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Prefetch the user information.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 预取用户信息。
- en: ❷ Prefetch the user avatar image.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 预取用户头像图像。
- en: ❸ Render the user details, including the avatar.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 渲染用户详细信息，包括头像。
- en: By fetching data and images as early as possible, we don’t keep users waiting
    as long and reduce the chance of needing our fallback image. But switching to
    a new user still hits the visitor with a loading spinner (like the one in figure
    12.12) if they haven’t viewed that user before. Switching from the details panel
    to a loading spinner and back to the next details panel is not the smoothest experience.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通过尽早获取数据和图像，我们不会让用户等待太久，并减少了需要我们的后备图像的机会。但如果用户之前没有查看过该用户，切换到新用户仍然会在较慢的连接上给访客带来一个加载旋转器（如图12.12所示）。从详情面板切换到加载旋转器，然后再切换回下一个详情面板，并不是最流畅的体验。
- en: '![](../Images/12-12.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/12-12.png)'
- en: Figure 12.12 Switching to another user brings up a loading spinner on slower
    connections.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 切换到另一个用户在较慢的连接上会显示一个加载旋转器。
- en: 'Rather than the jarring experience of replacing the details with a spinner,
    it would be better if we could hold off, and switch straight from one set of user
    details to another, avoiding the *receded* loading state, the feeling of *going
    back* to a spinner. React’s Concurrent Mode promises to make such deferred transitions
    much easier, and you’ll see how in chapter 13 when we introduce our last two hooks:
    `useTransition` and `useDeferredValue`.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 与用旋转器替换详情的刺耳体验相比，如果我们能推迟，直接从一组用户详情切换到另一组，避免*退化的*加载状态，以及*返回*到旋转器的感受，那就更好了。React的并发模式承诺将使这种延迟转换变得容易得多，你将在第13章中看到，当我们介绍我们最后的两个钩子：`useTransition`和`useDeferredValue`时。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Experiment with data-fetching integration for Suspense but don’t use it in production
    code yet; it’s not stable and will probably change.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试Suspense的数据获取集成，但不要在生产代码中使用它；它还不稳定，可能会发生变化。
- en: When the time comes, use well-tested, reliable data-fetching libraries to manage
    Suspense integration for you.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当时候到来时，使用经过良好测试、可靠的数据库获取库来为您管理Suspense集成。
- en: 'To tentatively explore data fetching with Suspense, wrap promises with functions
    that can check their status:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了尝试使用Suspense进行数据获取，用可以检查其状态的函数包装承诺：
- en: '[PRE38]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To integrate with Suspense, data-fetching functions should throw pending promises
    and errors or return loaded data. Create a function to turn a data-fetching promise
    into one that throws as necessary:'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要与Suspense集成，数据获取函数应该抛出挂起的承诺和错误或返回已加载的数据。创建一个将数据获取承诺转换为必要时抛出的承诺的函数：
- en: '[PRE39]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Use the prepared data-fetching function within a component to get data for
    the UI or to throw as appropriate:'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组件中使用准备好的数据获取函数来获取UI数据或适当地抛出：
- en: '[PRE40]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Start loading data as early as possible, maybe in event handlers.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽早开始加载数据，也许在事件处理程序中。
- en: Provide ways for users to recover the app from error states. Libraries like
    `react-error-boundary` can help.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供让用户从错误状态中恢复应用的方法。像`react-error-boundary`这样的库可以提供帮助。
- en: Check out the React docs and its linked examples to gain further insight into
    these techniques and to see their use of resources with `read` methods ([http://
    mng.bz/q9AJ](http://mng.bz/q9AJ)).
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查阅React文档及其链接示例，以深入了解这些技术及其使用`read`方法的资源（[http:// mng.bz/q9AJ](http://mng.bz/q9AJ)）。
- en: Use similar promise-wrangling techniques to load other resources like images
    or scripts.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类似的承诺处理技术来加载其他资源，如图像或脚本。
- en: Harness libraries like React Query (in Suspense mode) to manage caching and
    multiple requests when fetching data or images.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用像React Query（在Suspense模式下）这样的库来管理数据或图像获取时的缓存和多个请求。
- en: Load resources earlier by calling React Query’s `queryClient.prefetchQuery`
    method.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用React Query的`queryClient.prefetchQuery`方法来尽早加载资源。
- en: Avoid waterfalls, whereby later data-fetches wait for previous ones before starting,
    if possible.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能，避免瀑布式，即后续的数据获取在开始之前等待之前的数据获取。
