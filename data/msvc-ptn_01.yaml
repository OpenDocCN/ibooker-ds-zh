- en: Chapter 2\. Decomposition strategies
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章. 分解策略
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding software architecture and why it’s important
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解软件架构及其重要性
- en: Decomposing an application into services by applying the decomposition patterns
    Decompose by business capability and Decompose by subdomain
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过应用分解模式“按业务能力分解”和“按子域分解”将应用程序分解为服务
- en: Using the bounded context concept from domain-driven design (DDD) to untangle
    data and make decomposition easier
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用领域驱动设计（DDD）中的边界上下文概念来解开数据并使分解更容易
- en: Sometimes you have to be careful what you wish for. After an intense lobbying
    effort, Mary had finally convinced the business that migrating to a microservice
    architecture was the right thing to do. Feeling a mixture of excitement and some
    trepidation, Mary had a morning-long meeting with her architects to discuss where
    to begin. During the discussion, it became apparent that some aspects of the Microservice
    architecture pattern language, such as deployment and service discovery, were
    new and unfamiliar, yet straightforward. The key challenge, which is the essence
    of the microservice architecture, is the functional decomposition of the application
    into services. The first and most important aspect of the architecture is, therefore,
    the definition of the services. As they stood around the whiteboard, the FTGO
    team wondered exactly how to do that!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你必须小心你所期望的。经过一番激烈的游说努力，玛丽最终说服了公司，迁移到微服务架构是正确的做法。感到既兴奋又有些紧张，玛丽与她的建筑师们进行了一整天的会议，讨论从哪里开始。在讨论中，很明显，微服务架构模式语言的一些方面，如部署和服务发现，虽然新颖且不熟悉，但却是直接的。关键挑战，即微服务架构的本质，是将应用程序分解为服务。因此，架构的第一个也是最重要的方面是定义服务。当他们围在白板旁时，FTGO团队想知道究竟该如何做！
- en: In this chapter, you’ll learn how to define a microservice architecture for
    an application. I describe strategies for decomposing an application into services.
    You’ll learn that services are organized around business concerns rather than
    technical concerns. I also show how to use ideas from domain-driven design (DDD)
    to eliminate god classes, which are classes that are used throughout an application
    and cause tangled dependencies that prevent decomposition.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何为应用程序定义微服务架构。我描述了将应用程序分解为服务的策略。你将了解到服务是围绕业务关注点而不是技术关注点组织的。我还展示了如何使用领域驱动设计（DDD）中的思想来消除神级类，这些类在整个应用程序中使用并导致纠缠的依赖关系，从而阻碍了分解。
- en: I begin this chapter by defining the microservice architecture in terms of software
    architecture concepts. After that, I describe a process for defining a microservice
    architecture for an application starting from its requirements. I discuss strategies
    for decomposing an application into a collection of services, obstacles to it,
    and how to overcome them. Let’s start by examining the concept of software architecture.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先通过软件架构概念来定义微服务架构。之后，我描述了一个从应用需求出发定义微服务架构的过程。我讨论了将应用程序分解为服务集合的策略、面临的障碍以及如何克服它们。让我们先来考察一下软件架构的概念。
- en: 2.1\. What is the microservice architecture exactly?
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1. 精确来说，微服务架构是什么？
- en: '[Chapter 1](kindle_split_009.xhtml#ch01) describes how the key idea of the
    microservice architecture is functional decomposition. Instead of developing one
    large application, you structure the application as a set of services. On one
    hand, describing the microservice architecture as a kind of functional decomposition
    is useful. But on the other hand, it leaves several questions unanswered, including
    how does the microservice architecture relate to the broader concepts of software
    architecture? What’s a service? And how important is the size of a service?'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[第一章](kindle_split_009.xhtml#ch01)描述了微服务架构的关键思想是功能分解。不是开发一个大型的应用程序，而是将应用程序结构化为一系列服务。一方面，将微服务架构描述为一种功能分解是有用的。但另一方面，它也留下了一些未解决的问题，包括微服务架构如何与更广泛的软件架构概念相关？什么是服务？以及服务的大小有多重要？'
- en: In order to answer those questions, we need to take a step back and look at
    what is meant by *software architecture*. The architecture of a software application
    is its high-level structure, which consists of constituent parts and the dependencies
    between those parts. As you’ll see in this section, an application’s architecture
    is multidimensional, so there are multiple ways to describe it. The reason architecture
    is important is because it determines the application’s software quality attributes
    or *-ilities*. Traditionally, the goal of architecture has been scalability, reliability,
    and security. But today it’s important that the architecture also enables the
    rapid and safe delivery of software. You’ll learn that the microservice architecture
    is an architecture style that gives an application high maintainability, testability,
    and deployability.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这些问题，我们需要退后一步，看看“软件架构”的含义。软件应用程序的架构是其高级结构，它由组成部分及其之间的依赖关系组成。正如你将在本节中看到的，应用程序的架构是多维的，因此有多种描述它的方法。架构之所以重要，是因为它决定了应用程序的软件质量属性或“-ilities”。传统上，架构的目标是可扩展性、可靠性和安全性。但今天，架构还必须能够实现软件的快速和安全交付。你将了解到微服务架构是一种提供高可维护性、可测试性和可部署性的架构风格。
- en: I begin this section by describing the concept of *software architecture* and
    why it’s important. Next, I discuss the idea of an architectural style. Then I
    define the microservice architecture as a particular architectural style. Let’s
    start by looking at the concept of software architecture.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我从这个部分开始，描述了“软件架构”的概念以及为什么它很重要。接下来，我讨论了架构风格的想法。然后，我将微服务架构定义为一种特定的架构风格。让我们先从软件架构的概念开始看起。
- en: 2.1.1\. What is software architecture and why does it matter?
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1\. 什么是软件架构以及为什么它很重要？
- en: 'Architecture is clearly important. There are at least two conferences dedicated
    to the topic: O’Reilly Software Architecture Conference ([https://conferences.oreilly.com/software-architecture](https://conferences.oreilly.com/software-architecture))
    and the SATURN conference ([https://resources.sei.cmu.edu/news-events/events/saturn/](https://resources.sei.cmu.edu/news-events/events/saturn/)).
    Many developers have the goal of becoming an architect. But what is architecture
    and why does it matter?'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 架构显然很重要。至少有两个会议致力于这个主题：O’Reilly 软件架构会议([https://conferences.oreilly.com/software-architecture](https://conferences.oreilly.com/software-architecture))和
    SATURN 会议([https://resources.sei.cmu.edu/news-events/events/saturn/](https://resources.sei.cmu.edu/news-events/events/saturn/))。许多开发者的目标是成为一名架构师。但什么是架构以及为什么它很重要？
- en: To answer that question, I first define what is meant by the term *software
    architecture*. After that, I discuss how an application’s architecture is multidimensional
    and is best described using a collection of views or blueprints. I then describe
    that software architecture matters because of its impact on the application’s
    software quality attributes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，我首先定义了“软件架构”这个术语的含义。之后，我讨论了应用程序的架构是多维的，并且最好使用一系列视图或蓝图来描述。然后，我说明了软件架构之所以重要，是因为它对应用程序的软件质量属性有影响。
- en: A definition of software architecture
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 软件架构的定义
- en: 'There are numerous definitions of software architecture. For example, see [https://en.wikiquote.org/wiki/Software_architecture](https://en.wikiquote.org/wiki/Software_architecture)
    to read some of them. My favorite definition comes from Len Bass and colleagues
    at the Software Engineering Institute ([www.sei.cmu.edu](http://www.sei.cmu.edu)),
    who played a key role in establishing software architecture as a discipline. They
    define software architecture as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构有许多定义。例如，可以查看[https://en.wikiquote.org/wiki/Software_architecture](https://en.wikiquote.org/wiki/Software_architecture)来阅读一些定义。我最喜欢的定义来自软件工程研究所的
    Len Bass 和同事们([www.sei.cmu.edu](http://www.sei.cmu.edu))，他们在建立软件架构作为一门学科中发挥了关键作用。他们如下定义软件架构：
- en: '*The software architecture of a computing system is the set of structures needed
    to reason about the system, which comprise software elements, relations among
    them, and properties of both.*'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*计算系统的软件架构是用于推理系统的结构集合，它包括软件元素、它们之间的关系以及它们的属性。*'
- en: ''
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Documenting Software Architectures by Bass et al.*'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*《软件架构文档：Bass 等人著》*'
- en: 'That’s obviously a quite abstract definition. But its essence is that an application’s
    architecture is its decomposition into parts (the elements) and the relationships
    (the relations) between those parts. Decomposition is important for a couple of
    reasons:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一个相当抽象的定义。但其本质是，一个应用程序的架构是其分解成部分（元素）以及这些部分之间的关系（关系）。分解之所以重要，有几个原因：
- en: It facilitates the division of labor and knowledge. It enables multiple people
    (or multiple teams) with possibly specialized knowledge to work productively together
    on an application.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它促进了劳动力和知识的分工。它使得具有可能专门知识的多个人（或多个团队）能够高效地共同工作在一个应用程序上。
- en: It defines how the software elements interact.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了软件元素如何交互。
- en: It’s the decomposition into parts and the relationships between those parts
    that determine the application’s *-ilities*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 是将应用分解成部分以及这些部分之间的关系决定了应用的*可用性*。
- en: The 4+1 view model of software architecture
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 软件架构的4+1视图模型
- en: More concretely, an application’s architecture can be viewed from multiple perspectives,
    in the same way that a building’s architecture can be viewed from structural,
    plumbing, electrical, and other perspectives. Phillip Krutchen wrote a classic
    paper describing the 4+1 view model of software architecture, “Architectural Blueprints—The
    ‘4+1’ View Model of Software Architecture” ([www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf](http://www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf)).
    The 4+1 model, shown in [Figure 2.1](#ch02fig01), defines four different views
    of a software architecture. Each describes a particular aspect of the architecture
    and consists of a particular set of software elements and relationships between
    them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，一个应用程序的架构可以从多个角度来审视，就像一座建筑的架构可以从结构、管道、电气和其他角度来审视一样。菲利普·克鲁滕（Phillip Krutchen）撰写了一篇经典论文，描述了软件架构的4+1视图模型，“架构蓝图——软件架构的‘4+1’视图模型”（[www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf](http://www.cs.ubc.ca/~gregor/teaching/papers/4+1view-architecture.pdf)）。4+1模型，如图2.1所示，定义了软件架构的四个不同视图。每个视图都描述了架构的特定方面，并包含一组特定的软件元素及其之间的关系。
- en: Figure 2.1\. The 4+1 view model describes an application’s architecture using
    four views, along with scenarios that show how the elements within each view collaborate
    to handle requests.
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.1\. 4+1视图模型使用四个视图来描述应用程序的架构，以及场景展示了每个视图中的元素如何协作来处理请求。
- en: '![](Images/02fig01_alt.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig01_alt.jpg)'
- en: 'The purpose of each view is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图的目的如下：
- en: '***Logical view*—** The software elements that are created by developers. In
    object-oriented languages, these elements are classes and packages. The relations
    between them are the relationships between classes and packages, including inheritance,
    associations, and depends-on.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***逻辑视图*—** 开发者创建的软件元素。在面向对象的语言中，这些元素是类和包。它们之间的关系包括类和包之间的关系，包括继承、关联和依赖。'
- en: '***Implementation view*—** The output of the build system. This view consists
    of modules, which represent packaged code, and components, which are executable
    or deployable units consisting of one or more modules. In Java, a module is a
    JAR file, and a component is typically a WAR file or an executable JAR file. The
    relations between them include dependency relationships between modules and composition
    relationships between components and modules.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***实现视图*—** 构建系统的输出。这个视图由模块组成，代表打包的代码，以及组件，它们是由一个或多个模块组成的可执行或可部署单元。在Java中，模块是一个JAR文件，组件通常是WAR文件或可执行JAR文件。它们之间的关系包括模块之间的依赖关系和组件与模块之间的组合关系。'
- en: '***Process view*—** The components at runtime. Each element is a process, and
    the relations between processes represent interprocess communication.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***过程视图*—** 运行时的组件。每个元素是一个进程，进程之间的关系代表进程间通信。'
- en: '***Deployment*—** How the processes are mapped to machines. The elements in
    this view consist of (physical or virtual) machines and the processes. The relations
    between machines represent networking. This view also describes the relationship
    between processes and machines.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***部署*—** 过程是如何映射到机器上的。这个视图中的元素包括（物理或虚拟）机器和过程。机器之间的关系代表网络。这个视图还描述了过程和机器之间的关系。'
- en: In addition to these four views, there are the scenarios—the +1 in the 4+1 model—that
    animate views. Each scenario describes how the various architectural components
    within a particular view collaborate in order to handle a request. A scenario
    in the logical view, for example, shows how the classes collaborate. Similarly,
    a scenario in the process view shows how the processes collaborate.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这四个视图之外，还有场景——4+1模型中的+1，它们使视图生动起来。每个场景描述了特定视图中各种架构组件如何协作来处理请求。例如，逻辑视图中的场景显示了类如何协作。同样，过程视图中的场景显示了进程如何协作。
- en: The 4+1 view model is an excellent way to describe an applications’s architecture.
    Each view describes an important aspect of the architecture, and the scenarios
    illustrate how the elements of a view collaborate. Let’s now look at why architecture
    is important.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 4+1视图模型是描述应用程序架构的绝佳方式。每个视图都描述了架构的一个重要方面，而场景说明了视图元素如何协作。现在让我们看看为什么架构很重要。
- en: Why architecture matters
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为什么架构很重要
- en: An application has two categories of requirements. The first category includes
    the *functional* requirements, which define what the application must do. They’re
    usually in the form of use cases or user stories. Architecture has very little
    to do with the functional requirements. You can implement functional requirements
    with almost any architecture, even a big ball of mud.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序有两个要求类别。第一个类别包括*功能性*要求，这些要求定义了应用程序必须做什么。它们通常以用例或用户故事的形式出现。架构与功能性要求几乎没有关系。你可以用几乎任何架构来实现功能性要求，甚至是一个大泥球。
- en: 'Architecture is important because it enables an application to satisfy the
    second category of requirements: its *quality of service* requirements. These
    are also known as *quality attributes* and are the so-called *-ilities*. The quality
    of service requirements define the runtime qualities such as scalability and reliability.
    They also define development time qualities including maintainability, testability,
    and deployability. The architecture you choose for your application determines
    how well it meets these quality requirements.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 架构之所以重要，是因为它使应用程序能够满足第二类要求：其*服务质量*要求。这些也被称为*质量属性*，也就是所谓的*-ilities*。服务质量要求定义了运行时质量，如可伸缩性和可靠性。它们还定义了开发时间质量，包括可维护性、可测试性和可部署性。你为应用程序选择的架构决定了它如何满足这些质量要求。
- en: 2.1.2\. Overview of architectural styles
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.2\. 架构风格概述
- en: 'In the physical world, a building’s architecture often follows a particular
    style, such as Victorian, American Craftsman, or Art Deco. Each style is a package
    of design decisions that constrains a building’s features and building materials.
    The concept of architectural style also applies to software. David Garlan and
    Mary Shaw (An Introduction to Software Architecture, January 1994, [https://www.cs.cmu.edu/afs/cs/project/able/ftp/intro_softarch/intro_softarch.pdf](https://www.cs.cmu.edu/afs/cs/project/able/ftp/intro_softarch/intro_softarch.pdf)),
    pioneers in the discipline of software architecture, define an architectural style
    as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理世界中，一座建筑物的架构通常遵循特定的风格，例如维多利亚式、美国手工艺人或装饰艺术。每种风格都是一组设计决策的集合，限制了建筑物的功能和建筑材料。建筑风格的概念也适用于软件。大卫·加兰和玛丽·肖（《软件架构导论》，1994年1月，[https://www.cs.cmu.edu/afs/cs/project/able/ftp/intro_softarch/intro_softarch.pdf](https://www.cs.cmu.edu/afs/cs/project/able/ftp/intro_softarch/intro_softarch.pdf)），软件架构领域的先驱，将架构风格定义为以下内容：
- en: '*An architectural style, then, defines a family of such systems in terms of
    a pattern of structural organization. More specifically, an architectural style
    determines the vocabulary of components and connectors that can be used in instances
    of that style, together with a set of constraints on how they can be combined.*'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，*架构风格*定义了一组这样的系统，通过结构组织的模式。更具体地说，一个架构风格决定了在该风格实例中可以使用的组件和连接器的词汇，以及它们如何组合的一组约束。
- en: A particular architectural style provides a limited palette of elements (components)
    and relations (connectors) from which you can define a view of your application’s
    architecture. An application typically uses a combination of architectural styles.
    For example, later in this section I describe how the monolithic architecture
    is an architectural style that structures the implementation view as a single
    (executable/deployable) component. The microservice architecture structures an
    application as a set of loosely coupled services.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 特定的架构风格提供了一组有限的元素（组件）和关系（连接器），您可以从这些元素中定义应用程序架构的视图。应用程序通常使用多种架构风格的组合。例如，在本节的后面部分，我将描述单体架构是如何作为一种架构风格，将实现视图结构化为单个（可执行/可部署）组件的。微服务架构将应用程序结构化为一组松散耦合的服务。
- en: The layered architectural style
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分层架构风格
- en: The classic example of an architectural style is the layered architecture. A
    *layered architecture* organizes software elements into layers. Each layer has
    a well-defined set of responsibilities. A layered architecture also constraints
    the dependencies between the layers. A layer can only depend on either the layer
    immediately below it (if strict layering) or any of the layers below it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 架构风格的经典例子是分层架构。*分层架构*将软件元素组织成层。每一层都有一个定义良好的责任集。分层架构还限制了层之间的依赖关系。一层只能依赖于它下面的层（如果严格分层）或任何下面的层。
- en: 'You can apply the layered architecture to any of the four views discussed earlier.
    The popular three-tier architecture is the layered architecture applied to the
    logical view. It organizes the application’s classes into the following tiers
    or layers:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将分层架构应用于前面讨论的任何四个视图。流行的三层架构是将分层架构应用于逻辑视图。它将应用程序的类组织成以下层或层：
- en: '***Presentation layer*—** Contains code that implements the user interface
    or external APIs'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***表示层*—** 包含实现用户界面或外部API的代码'
- en: '***Business logic layer*—** Contains the business logic'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***业务逻辑层*—** 包含业务逻辑'
- en: '***Persistence layer*—** Implements the logic of interacting with the database'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***持久层*—** 实现与数据库交互的逻辑'
- en: 'The layered architecture is a great example of an architectural style, but
    it does have some significant drawbacks:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 分层架构是架构风格的一个很好的例子，但它确实有一些显著的缺点：
- en: '***Single presentation layer*—** It doesn’t represent the fact that an application
    is likely to be invoked by more than just a single system.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***单一表示层*—** 它没有反映出应用程序可能不仅仅被单个系统调用的现实。'
- en: '***Single persistence layer*—** It doesn’t represent the fact that an application
    is likely to interact with more than just a single database.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***单一持久层*—** 它没有反映出应用程序可能不仅仅与单个数据库交互的事实。'
- en: '***Defines the business logic layer as depending on the persistence layer*—**
    In theory, this dependency prevents you from testing the business logic without
    the database.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***将业务逻辑层定义为依赖于持久层*—** 理论上，这种依赖关系阻止了您在没有数据库的情况下测试业务逻辑。'
- en: Also, the layered architecture misrepresents the dependencies in a well-designed
    application. The business logic typically defines an interface or a repository
    of interfaces that define data access methods. The persistence tier defines DAO
    classes that implement the repository interfaces. In other words, the dependencies
    are the reverse of what’s depicted by a layered architecture.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，分层架构错误地表示了设计良好的应用程序中的依赖关系。业务逻辑通常定义了一个接口或接口的存储库，这些接口定义了数据访问方法。持久层定义了实现存储库接口的DAO类。换句话说，依赖关系与分层架构所描述的相反。
- en: 'Let’s look at an alternative architecture that overcomes these drawbacks: the
    hexagonal architecture.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一种克服这些缺点的替代架构：六边形架构。
- en: About the hexagonal architecture style
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关于六边形架构风格
- en: '*Hexagonal architecture* is an alternative to the layered architectural style.
    As [figure 2.2](#ch02fig02) shows, the hexagonal architecture style organizes
    the logical view in a way that places the business logic at the center. Instead
    of the presentation layer, the application has one or more *inbound adapters*
    that handle requests from the outside by invoking the business logic. Similarly,
    instead of a data persistence tier, the application has one or more *outbound
    adapters* that are invoked by the business logic and invoke external applications.
    A key characteristic and benefit of this architecture is that the business logic
    doesn’t depend on the adapters. Instead, they depend upon it.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**六边形架构**是分层架构风格的替代方案。如图2.2所示，六边形架构风格以将业务逻辑置于中心的方式组织逻辑视图。与表示层不同，应用程序有一个或多个**入站适配器**，通过调用业务逻辑来处理来自外部的请求。同样，与数据持久层不同，应用程序有一个或多个由业务逻辑调用并调用外部应用程序的**出站适配器**。这种架构的关键特征和好处是业务逻辑不依赖于适配器。相反，它们依赖于它。'
- en: Figure 2.2\. An example of a hexagonal architecture, which consists of the business
    logic and one or more adapters that communicate with external systems. The business
    logic has one or more ports. Inbound adapters, which handled requests from external
    systems, invoke an inbound port. An outbound adapter implements an outbound port,
    and invokes an external system.
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2\. 一个六边形架构的例子，它由业务逻辑和一个或多个与外部系统通信的适配器组成。业务逻辑有一个或多个端口。入站适配器，处理来自外部系统的请求，调用入站端口。出站适配器实现出站端口，并调用外部系统。
- en: '![](Images/02fig02_alt.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2的替代文本](Images/02fig02_alt.jpg)'
- en: 'The business logic has one or more ports. A *port* defines a set of operations
    and is how the business logic interacts with what’s outside of it. In Java, for
    example, a port is often a Java interface. There are two kinds of ports: inbound
    and outbound ports. An inbound port is an API exposed by the business logic, which
    enables it to be invoked by external applications. An example of an inbound port
    is a service interface, which defines a service’s public methods. An outbound
    port is how the business logic invokes external systems. An example of an output
    port is a repository interface, which defines a collection of data access operations.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑有一个或多个端口。一个**端口**定义了一组操作，并且是业务逻辑如何与它之外的内容交互的方式。例如，在Java中，一个端口通常是一个Java接口。端口有两种类型：入站端口和出站端口。入站端口是业务逻辑暴露的API，它使得外部应用程序能够调用它。一个入站端口的例子是服务接口，它定义了一个服务的公共方法。出站端口是业务逻辑调用外部系统的方式。一个出站端口的例子是存储库接口，它定义了一组数据访问操作。
- en: 'Surrounding the business logic are adapters. As with ports, there are two types
    of adapters: inbound and outbound. An inbound adapter handles requests from the
    outside world by invoking an inbound port. An example of an inbound adapter is
    a Spring MVC Controller that implements either a set of REST endpoints or a set
    of web pages. Another example is a message broker client that subscribes to messages.
    Multiple inbound adapters can invoke the same inbound port.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕业务逻辑的是适配器。与端口一样，适配器有两种类型：入站和出站。入站适配器通过调用入站端口来处理来自外部世界的请求。一个入站适配器的例子是实现了REST端点或一组网页的Spring
    MVC控制器。另一个例子是订阅消息的消息代理客户端。多个入站适配器可以调用相同的入站端口。
- en: An outbound adapter implements an outbound port and handles requests from the
    business logic by invoking an external application or service. An example of an
    outbound adapter is a *data access object* (DAO) class that implements operations
    for accessing a database. Another example would be a proxy class that invokes
    a remote service. Outbound adapters can also publish events.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 出站适配器实现出站端口，并通过调用外部应用程序或服务来处理来自业务逻辑的请求。一个出站适配器的例子是实现访问数据库操作的**数据访问对象**（DAO）类。另一个例子是调用远程服务的代理类。出站适配器还可以发布事件。
- en: An important benefit of the hexagonal architectural style is that it decouples
    the business logic from the presentation and data access logic in the adapters.
    The business logic doesn’t depend on either the presentation logic or the data
    access logic. Because of this decoupling, it’s much easier to test the business
    logic in isolation. Another benefit is that it more accurately reflects the architecture
    of a modern application. The business logic can be invoked via multiple adapters,
    each of which implements a particular API or UI. The business logic can also invoke
    multiple adapters, each one of which invokes a different external system. Hexagonal
    architecture is a great way to describe the architecture of each service in a
    microservice architecture.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构风格的一个重要优点是它将业务逻辑从适配器中的表示逻辑和数据访问逻辑解耦。业务逻辑不依赖于表示逻辑或数据访问逻辑。由于这种解耦，单独测试业务逻辑变得更加容易。另一个优点是它更准确地反映了现代应用程序的架构。业务逻辑可以通过多个适配器调用，每个适配器实现特定的API或UI。业务逻辑也可以调用多个适配器，每个适配器调用不同的外部系统。六边形架构是描述微服务架构中每个服务架构的绝佳方式。
- en: The layered and hexagonal architectures are both examples of architectural styles.
    Each defines the building blocks of an architecture and imposes constraints on
    the relationships between them. The hexagonal architecture and the layered architecture,
    in the form of a three-tier architecture, organize the logical view. Let’s now
    define the microservice architecture as an architectural style that organizes
    the implementation view.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构和六边形架构都是架构风格的例子。每个都定义了架构的构建块并对它们之间的关系施加约束。六边形架构和层次架构，以三层架构的形式，组织逻辑视图。现在让我们将微服务架构定义为一种组织实现视图的架构风格。
- en: 2.1.3\. The microservice architecture is an architectural style
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.3. 微服务架构是一种架构风格
- en: 'I’ve discussed the 4+1 view model and architectural styles, so I can now define
    monolithic and microservice architecture. They’re both architectural styles. Monolithic
    architecture is an architectural style that structures the implementation view
    as a single component: a single executable or WAR file. This definition says nothing
    about the other views. A monolithic application can, for example, have a logical
    view that’s organized along the lines of a hexagonal architecture.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经讨论了4+1视图模型和架构风格，因此我现在可以定义单体和微服务架构。它们都是架构风格。单体架构是一种将实现视图结构化为单个组件的架构风格：一个单一的执行文件或WAR文件。这个定义对其他视图没有说任何东西。例如，单体应用程序可以有逻辑视图，该视图按照六边形架构组织。
- en: '|  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Monolithic architecture**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：单体架构**'
- en: Structure the application as a single executable/deployable component. See [http://microservices.io/patterns/monolithic.html](http://microservices.io/patterns/monolithic.html).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序结构化为一个单一的可执行/可部署组件。请参阅[http://microservices.io/patterns/monolithic.html](http://microservices.io/patterns/monolithic.html)。
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The microservice architecture is also an architectural style. It structures
    the implementation view as a set of multiple components: executables or WAR files.
    The components are services, and the connectors are the communication protocols
    that enable those services to collaborate. Each service has its own logical view
    architecture, which is typically a hexagonal architecture. [Figure 2.3](#ch02fig03)
    shows a possible microservice architecture for the FTGO application. The services
    in this architecture correspond to business capabilities, such as Order management
    and Restaurant management.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构也是一种架构风格。它将实现视图结构化为多个组件：可执行文件或WAR文件。这些组件是服务，连接器是使这些服务能够协作的通信协议。每个服务都有自己的逻辑视图架构，这通常是六边形架构。[图2.3](#ch02fig03)展示了FTGO应用程序的可能微服务架构。该架构中的服务对应于业务能力，例如订单管理和餐厅管理。
- en: '|  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Pattern: Microservice architecture**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：微服务架构**'
- en: Structure the application as a collection of loosely coupled, independently
    deployable services. See [http://microservices.io/patterns/microservices.html](http://microservices.io/patterns/microservices.html).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序结构化为一组松散耦合、独立部署的服务。请参阅[http://microservices.io/patterns/microservices.html](http://microservices.io/patterns/microservices.html)。
- en: '|  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 2.3\. A possible microservice architecture for the FTGO application.
    It consists of numerous services.
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.3. FTGO应用程序的可能微服务架构。它由众多服务组成。
- en: '![](Images/02fig03_alt.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig03_alt.jpg)'
- en: Later in this chapter, I describe what is meant by *business capability*. The
    connectors between services are implemented using interprocess communication mechanisms
    such as REST APIs and asynchronous messaging. [Chapter 3](kindle_split_011.xhtml#ch03)
    discusses interprocess communication in more detail.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我将描述“业务能力”的含义。服务之间的连接器是通过使用诸如REST API和异步消息等进程间通信机制来实现的。[第3章](kindle_split_011.xhtml#ch03)更详细地讨论了进程间通信。
- en: A key constraint imposed by the microservice architecture is that the services
    are loosely coupled. Consequently, there are restrictions on how the services
    collaborate. In order to explain those restrictions, I’ll attempt to define the
    term *service*, describe what it means to be loosely coupled, and tell you why
    this matters.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构强加的一个关键约束是服务之间的松散耦合。因此，对服务如何协作有一些限制。为了解释这些限制，我将尝试定义“服务”这个术语，描述松散耦合的含义，并告诉你这为什么很重要。
- en: What is a service?
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 什么是服务？
- en: 'A *service* is a standalone, independently deployable software component that
    implements some useful functionality. [Figure 2.4](#ch02fig04) shows the external
    view of a service, which in this example is the `Order Service`. A service has
    an API that provides its clients access to its functionality. There are two types
    of operations: commands and queries. The API consists of commands, queries, and
    events. A command, such as `createOrder()`, performs actions and updates data.
    A query, such as `findOrderById()`, retrieves data. A service also publishes events,
    such as `OrderCreated`, which are consumed by its clients.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: “服务”是一个独立、可独立部署的软件组件，它实现了某些有用的功能。[图2.4](#ch02fig04)显示了服务的外部视图，在这个例子中是“订单服务”。服务有一个API，它为客户端提供了对其功能的访问。有两种类型的操作：命令和查询。API由命令、查询和事件组成。例如，`createOrder()`这样的命令执行操作并更新数据。例如，`findOrderById()`这样的查询检索数据。服务还发布事件，如`OrderCreated`，这些事件被其客户端消费。
- en: 'Figure 2.4\. A service has an API that encapsulates the implementation. The
    API defines operations, which are invoked by clients. There are two types of operations:
    commands update data, and queries retrieve data. When its data changes, a service
    publishes events that clients can subscribe to.'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4。服务有一个封装其实现的API。API定义了操作，这些操作由客户端调用。有两种类型的操作：命令更新数据，查询检索数据。当其数据发生变化时，服务会发布事件，客户端可以订阅这些事件。
- en: '![](Images/02fig04_alt.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig04_alt.jpg)'
- en: A service’s API encapsulates its internal implementation. Unlike in a monolith,
    a developer can’t write code that bypasses its API. As a result, the microservice
    architecture enforces the application’s modularity.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的API封装了其内部实现。与单体架构不同，开发者不能编写绕过其API的代码。因此，微服务架构强制执行应用程序的模块化。
- en: Each service in a microservice architecture has its own architecture and, potentially,
    technology stack. But a typical service has a hexagonal architecture. Its API
    is implemented by adapters that interact with the service’s business logic. The
    operations adapter invokes the business logic, and the events adapter publishes
    events emitted by the business logic.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，每个服务都有自己的架构和，可能还有技术栈。但一个典型的服务具有六边形架构。它的API是通过与服务的业务逻辑交互的适配器来实现的。操作适配器调用业务逻辑，而事件适配器发布由业务逻辑发出的事件。
- en: Later in [chapter 12](kindle_split_020.xhtml#ch12), when I discuss deployment
    technologies, you’ll see that the implementation view of a service can take many
    forms. The component might be a standalone process, a web application or OSGI
    bundle running in a container, or a serverless cloud function. An essential requirement,
    however, is that a service has an API and is independently deployable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](kindle_split_020.xhtml#ch12)的后面部分，当我讨论部署技术时，你会看到服务的实现视图可以有多种形式。组件可能是一个独立进程、一个运行在容器中的Web应用或OSGI包，或者是一个无服务器云函数。然而，一个基本要求是服务必须有一个API并且可以独立部署。
- en: What is loose coupling?
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 什么是松散耦合？
- en: An important characteristic of the microservice architecture is that the services
    are loosely coupled ([https://en.wikipedia.org/wiki/Loose_coupling](https://en.wikipedia.org/wiki/Loose_coupling)).
    All interaction with a service happens via its API, which encapsulates its implementation
    details. This enables the implementation of the service to change without impacting
    its clients. Loosely coupled services are key to improving an application’s development
    time attributes, including its maintainability and testability. They are much
    easier to understand, change, and test.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的一个重要特征是服务之间松散耦合（[https://en.wikipedia.org/wiki/Loose_coupling](https://en.wikipedia.org/wiki/Loose_coupling)）。所有与服务的交互都通过其API进行，该API封装了其实现细节。这使得服务的实现可以改变，而不会影响其客户端。松散耦合的服务对于提高应用程序的开发时间属性至关重要，包括其可维护性和可测试性。它们更容易理解、更改和测试。
- en: The requirement for services to be loosely coupled and to collaborate only via
    APIs prohibits services from communicating via a database. You must treat a service’s
    persistent data like the fields of a class and keep them private. Keeping the
    data private enables a developer to change their service’s database schema without
    having to spend time coordinating with developers working on other services. Not
    sharing database tables also improves runtime isolation. It ensures, for example,
    that one service can’t hold database locks that block another service. Later on,
    though, you’ll learn that one downside of not sharing databases is that maintaining
    data consistency and querying across services are more complex.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 服务需要松散耦合并且只能通过API进行协作的要求禁止服务通过数据库进行通信。你必须像对待类的字段一样对待服务的持久数据，并保持其私有。保持数据私有使得开发者可以在不花费时间与其他服务上的开发者协调的情况下更改其服务的数据库模式。不共享数据库表还可以提高运行时隔离性。它确保，例如，一个服务不能持有阻止另一个服务的数据库锁。然而，稍后你将了解到不共享数据库的一个缺点是，维护数据一致性和跨服务查询变得更加复杂。
- en: The role of shared libraries
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 共享库的作用
- en: Developers often package functionality in a library (module) so that it can
    be reused by multiple applications without duplicating code. After all, where
    would we be today without Maven or npm repositories? You might be tempted to also
    use shared libraries in microservice architecture. On the surface, it looks like
    a good way to reduce code duplication in your services. But you need to ensure
    that you don’t accidentally introduce coupling between your services.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者经常将功能打包到库（模块）中，以便可以在不重复代码的情况下由多个应用程序重用。毕竟，如果没有Maven或npm仓库，我们今天会是什么样子？你可能会倾向于在微服务架构中也使用共享库。表面上，这似乎是一种减少服务中代码重复的好方法。但你需要确保你不会意外地在服务之间引入耦合。
- en: Imagine, for example, that multiple services need to update the `Order` business
    object. One approach is to package that functionality as a library that’s used
    by multiple services. On one hand, using a library eliminates code duplication.
    On the other hand, consider what happens when the requirements change in a way
    that affects the `Order` business object. You would need to simultaneously rebuild
    and redeploy those services. A much better approach would be to implement functionality
    that’s likely to change, such as `Order` management, as a service.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，例如，多个服务需要更新`订单`业务对象。一种方法是将该功能打包成一个库，供多个服务使用。一方面，使用库可以消除代码重复。另一方面，考虑一下当需求发生变化，影响`订单`业务对象时会发生什么。你需要同时重建和重新部署这些服务。一个更好的方法是将可能发生变化的功能，例如`订单`管理，实现为一个服务。
- en: You should strive to use libraries for functionality that’s unlikely to change.
    For example, in a typical application it makes no sense for every service to implement
    a generic `Money` class. Instead, you should create a library that’s used by the
    services.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该努力使用库来实现那些不太可能改变的功能。例如，在一个典型的应用中，每个服务实现一个通用的`货币`类是没有意义的。相反，你应该创建一个由服务使用的库。
- en: The size of a service is mostly unimportant
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 服务的规模大多并不重要
- en: One problem with the term *microservice* is that the first thing you hear is
    *micro*. This suggests that a service should be very small. This is also true
    of other size-based terms such as miniservice or nanoservice. In reality, size
    isn’t a useful metric.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: “微服务”这个术语的一个问题是，你首先听到的是“微”。这暗示服务应该非常小。其他基于大小的术语，如迷你服务或纳米服务，也是如此。实际上，大小并不是一个有用的指标。
- en: A much better goal is to define a well-designed service to be a service capable
    of being developed by a small team with minimal lead time and with minimal collaboration
    with other teams. In theory, a team might only be responsible for a single service,
    so that service is by no means *micro*. Conversely, if a service requires a large
    team or takes a long time to test, it probably makes sense to split the team and
    the service. Or if you constantly need to change a service because of changes
    to other services or if it’s triggering changes in other services, that’s a sign
    that it’s not loosely coupled. You might even have built a distributed monolith.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的目标是为一个设计良好的服务定义，使其成为一个能够由小型团队开发的服务，具有最短的前期准备时间和与其他团队的最小协作。从理论上讲，一个团队可能只负责一个服务，因此这个服务绝不算是*微服务*。相反，如果一个服务需要大型团队或花费很长时间进行测试，那么将团队和服务拆分可能是有意义的。或者，如果你因为其他服务的变更而不断需要更改服务，或者它正在触发其他服务的变更，那么这是一个迹象表明它不是松散耦合的。你甚至可能已经构建了一个分布式单体。
- en: The microservice architecture structures an application as a set of small, loosely
    coupled services. As a result, it improves the development time attributes—maintainability,
    testability, deployability, and so on—and enables an organization to develop better
    software faster. It also improves an application’s scalability, although that’s
    not the main goal. To develop a microservice architecture for your application,
    you need to identify the services and determine how they collaborate. Let’s look
    at how to do that.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构将应用程序结构化为一系列小型、松散耦合的服务。因此，它提高了开发时间属性——可维护性、可测试性、可部署性等——并使组织能够更快地开发更好的软件。它还提高了应用程序的可扩展性，尽管这并不是主要目标。为了为你的应用程序开发微服务架构，你需要确定服务并确定它们如何协作。让我们看看如何做到这一点。
- en: 2.2\. Defining an application’s microservice architecture
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2. 定义应用程序的微服务架构
- en: How should we define a microservice architecture? As with any software development
    effort, the starting points are the written requirements, hopefully domain experts,
    and perhaps an existing application. Like much of software development, defining
    an architecture is more art than science. This section describes a simple, three-step
    process, shown in [figure 2.5](#ch02fig05), for defining an application’s architecture.
    It’s important to remember, though, that it’s not a process you can follow mechanically.
    It’s likely to be iterative and involve a lot of creativity.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何定义微服务架构？与任何软件开发工作一样，起点是书面需求，希望有领域专家，也许还有一个现有的应用程序。像许多软件开发一样，定义架构更多的是艺术而不是科学。本节描述了一个简单、三步的过程，如[图2.5](#ch02fig05)所示，用于定义应用程序的架构。然而，重要的是要记住，这不是一个可以机械遵循的过程。它很可能是迭代的，并且需要大量的创造力。
- en: Figure 2.5\. A three-step process for defining an application’s microservice
    architecture
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.5. 定义应用程序微服务架构的三步流程
- en: '![](Images/02fig05_alt.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5的替代文本](Images/02fig05_alt.jpg)'
- en: An application exists to handle requests, so the first step in defining its
    architecture is to distill the application’s requirements into the key requests.
    But instead of describing the requests in terms of specific IPC technologies such
    as REST or messaging, I use the more abstract notion of system operation. A *system
    operation* is an abstraction of a request that the application must handle. It’s
    either a command, which updates data, or a query, which retrieves data. The behavior
    of each command is defined in terms of an abstract domain model, which is also
    derived from the requirements. The system operations become the architectural
    scenarios that illustrate how the services collaborate.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序存在是为了处理请求，因此定义其架构的第一步是将应用程序的需求提炼为关键请求。但我不使用特定的IPC技术（如REST或消息传递）来描述请求，而是使用更抽象的系统操作概念。一个*系统操作*是应用程序必须处理的一个请求的抽象。它要么是一个更新数据的命令，要么是一个检索数据的查询。每个命令的行为都是用抽象领域模型来定义的，该模型也是从需求中派生出来的。系统操作成为说明服务如何协作的架构场景。
- en: The second step in the process is to determine the decomposition into services.
    There are several strategies to choose from. One strategy, which has its origins
    in the discipline of business architecture, is to define services corresponding
    to business capabilities. Another strategy is to organize services around domain-driven
    design subdomains. The end result is services that are organized around business
    concepts rather than technical concepts.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 流程的第二步是确定服务的分解。有几种策略可供选择。一种策略，其起源在于业务架构学科，是定义与业务能力相对应的服务。另一种策略是围绕领域驱动设计子域组织服务。最终结果是服务围绕业务概念而不是技术概念组织。
- en: The third step in defining the application’s architecture is to determine each
    service’s API. To do that, you assign each system operation identified in the
    first step to a service. A service might implement an operation entirely by itself.
    Alternatively, it might need to collaborate with other services. In that case,
    you determine how the services collaborate, which typically requires services
    to support additional operations. You’ll also need to decide which of the IPC
    mechanisms I describe in [chapter 3](kindle_split_011.xhtml#ch03) to implement
    each service’s API.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 定义应用程序架构的第三步是确定每个服务的API。要做到这一点，你需要将第一步中识别出的每个系统操作分配给一个服务。一个服务可能完全自行实现一个操作。或者，它可能需要与其他服务协作。在这种情况下，你需要确定服务如何协作，这通常需要服务支持额外的操作。你还需要决定实现每个服务API的IPC机制，我在[第3章](kindle_split_011.xhtml#ch03)中描述了这些机制。
- en: There are several obstacles to decomposition. The first is network latency.
    You might discover that a particular decomposition would be impractical due to
    too many round-trips between services. Another obstacle to decomposition is that
    synchronous communication between services reduces availability. You might need
    to use the concept of self-contained services, described in [chapter 3](kindle_split_011.xhtml#ch03).
    The third obstacle is the requirement to maintain data consistency across services.
    You’ll typically need to use sagas, discussed in [chapter 4](kindle_split_012.xhtml#ch04).
    The fourth and final obstacle to decomposition is so-called god classes, which
    are used throughout an application. Fortunately, you can use concepts from domain-driven
    design to eliminate god classes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 分解存在几个障碍。第一个是网络延迟。你可能会发现，由于服务之间往返次数过多，某种分解可能不切实际。分解的另一个障碍是服务之间的同步通信会降低可用性。你可能需要使用[第3章](kindle_split_011.xhtml#ch03)中描述的自包含服务概念。第三个障碍是在服务之间维护数据一致性的要求。你通常需要使用在第4章[中讨论的](kindle_split_012.xhtml#ch04)的sagas。分解的第四个和最后一个障碍是所谓的神级类，这些类在整个应用程序中使用。幸运的是，你可以使用领域驱动设计中的概念来消除神级类。
- en: This section first describes how to identity an application’s operations. After
    that, we’ll look at strategies and guidelines for decomposing an application into
    services, and at obstacles to decomposition and how to address them. Finally,
    I’ll describe how to define each service’s API.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本节首先描述如何识别应用程序的操作。之后，我们将探讨将应用程序分解为服务的策略和指南，以及分解的障碍以及如何解决它们。最后，我将描述如何定义每个服务的API。
- en: 2.2.1\. Identifying the system operations
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1. 识别系统操作
- en: The first step in defining an application’s architecture is to define the system
    operations. The starting point is the application’s requirements, including user
    stories and their associated user scenarios (note that these are different from
    the architectural scenarios). The system operations are identified and defined
    using the two-step process shown in [figure 2.6](#ch02fig06). This process is
    inspired by the object-oriented design process covered in Craig Larman’s book
    *Applying UML and Patterns* (Prentice Hall, 2004) (see [www.craiglarman.com/wiki/index.php?title=Book_Applying_UML_and_Patterns](http://www.craiglarman.com/wiki/index.php?title=Book_Applying_UML_and_Patterns)
    for details). The first step creates the high-level domain model consisting of
    the key classes that provide a vocabulary with which to describe the system operations.
    The second step identifies the system operations and describes each one’s behavior
    in terms of the domain model.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 定义应用程序架构的第一步是定义系统操作。起点是应用程序的要求，包括用户故事及其相关的用户场景（注意，这些与架构场景不同）。系统操作是通过图2.6中所示的两步过程来识别和定义的。这个过程受到了Craig
    Larman在其书籍《应用UML和模式》（Prentice Hall，2004）中涵盖的面向对象设计过程的影响（有关详细信息，请参阅[www.craiglarman.com/wiki/index.php?title=Book_Applying_UML_and_Patterns](http://www.craiglarman.com/wiki/index.php?title=Book_Applying_UML_and_Patterns)）。第一步创建了由关键类组成的高级领域模型，这些类提供了一个词汇表，可以用来描述系统操作。第二步识别系统操作，并描述每个操作的行为，用领域模型来表述。
- en: Figure 2.6\. System operations are derived from the application’s requirements
    using a two-step process. The first step is to create a high-level domain model.
    The second step is to define the system operations, which are defined in terms
    of the domain model.
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.6。系统操作是通过一个两步过程从应用程序的要求中推导出来的。第一步是创建一个高级领域模型。第二步是定义系统操作，这些操作是用领域模型来定义的。
- en: '![](Images/02fig06_alt.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6](Images/02fig06_alt.jpg)'
- en: The domain model is derived primarily from the nouns of the user stories, and
    the system operations are derived mostly from the verbs. You could also define
    the domain model using a technique called Event Storming, which I talk about in
    [chapter 5](kindle_split_013.xhtml#ch05). The behavior of each system operation
    is described in terms of its effect on one or more domain objects and the relationships
    between them. A system operation can create, update, or delete domain objects,
    as well as create or destroy relationships between them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型主要来源于用户故事中的名词，系统操作主要来源于动词。你也可以使用一种称为事件风暴的技术来定义领域模型，我在第5章中提到了这种技术。[第5章](kindle_split_013.xhtml#ch05)。每个系统操作的行为都是用其对一个或多个领域对象及其之间关系的影响来描述的。系统操作可以创建、更新或删除领域对象，以及创建或破坏它们之间的关系。
- en: Let’s look at how to define a high-level domain model. After that I’ll define
    the system operations in terms of the domain model.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何定义一个高级领域模型。之后，我将根据领域模型来定义系统操作。
- en: Creating a high-level domain model
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建高级领域模型
- en: The first step in the process of defining the system operations is to sketch
    a high-level domain model for the application. Note that this domain model is
    much simpler than what will ultimately be implemented. The application won’t even
    have a single domain model because, as you’ll soon learn, each service has its
    own domain model. Despite being a drastic simplification, a high-level domain
    model is useful at this stage because it defines the vocabulary for describing
    the behavior of the system operations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 定义系统操作的过程的第一步是为应用程序绘制一个高级领域模型。请注意，这个领域模型最终实现起来要简单得多。应用程序甚至不会有一个单独的领域模型，因为，正如你很快就会学到的，每个服务都有自己的领域模型。尽管这是一个极端的简化，但在这个阶段，高级领域模型是有用的，因为它定义了描述系统操作行为的词汇。
- en: 'A domain model is created using standard techniques such as analyzing the nouns
    in the stories and scenarios and talking to the domain experts. Consider, for
    example, the `Place Order` story. We can expand that story into numerous user
    scenarios including this one:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 领域模型是通过使用标准技术创建的，例如分析故事和场景中的名词以及与领域专家交谈。以`Place Order`故事为例。我们可以将这个故事扩展到包括以下用户场景：
- en: '[PRE0]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The nouns in this user scenario hint at the existence of various classes, including
    `Consumer`, `Order`, `Restaurant`, and `CreditCard`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个用户场景中的名词暗示了各种类的存在，包括`Consumer`、`Order`、`Restaurant`和`CreditCard`。
- en: 'Similarly, the `Accept Order` story can be expanded into a scenario such as
    this one:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`Accept Order`故事可以扩展到如下场景：
- en: '[PRE1]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This scenario suggests the existence of `Courier` and `Delivery` classes. The
    end result after a few iterations of analysis will be a domain model that consists,
    unsurprisingly, of those classes and others, such as `MenuItem` and `Address`.
    [Figure 2.7](#ch02fig07) is a class diagram that shows the key classes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景暗示了存在`Courier`和`Delivery`类。经过几轮分析后的最终结果将是一个领域模型，不出所料，它由那些类和其他类组成，例如`MenuItem`和`Address`。[图2.7](#ch02fig07)是一个显示关键类的类图。
- en: Figure 2.7\. The key classes in the FTGO domain model
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.7\. FTGO领域模型中的关键类
- en: '![](Images/02fig07_alt.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig07_alt.jpg)'
- en: 'The responsibilities of each class are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类的职责如下：
- en: '**`Consumer`—** A consumer who places orders.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Consumer`—** 下订单的消费者。'
- en: '**`Order`—** An order placed by a consumer. It describes the order and tracks
    its status.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Order`—** 消费者下的一单。它描述了订单并跟踪其状态。'
- en: '**`OrderLineItem`—** A line item of an `Order`.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`OrderLineItem`—** 订单的行项目。'
- en: '**`DeliveryInfo`—** The time and place to deliver an order.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`DeliveryInfo`—** 交付订单的时间和地点。'
- en: '**`Restaurant`—** A restaurant that prepares orders for delivery to consumers.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Restaurant`—** 为消费者准备订单以供交付的餐厅。'
- en: '**`MenuItem`—** An item on the restaurant’s menu.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`MenuItem`—** 餐厅菜单上的项目。'
- en: '**`Courier`—** A courier who deliver orders to consumers. It tracks the availability
    of the courier and their current location.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Courier`—** 将订单交付给消费者的快递员。它跟踪快递员的可用性和当前位置。'
- en: '**`Address`—** The address of a `Consumer` or a `Restaurant`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Address`—** 消费者或餐厅的地址。'
- en: '**`Location`—** The latitude and longitude of a `Courier`.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Location`—** 快递员的纬度和经度。'
- en: A class diagram such as the one in [figure 2.7](#ch02fig07) illustrates one
    aspect of an application’s architecture. But it isn’t much more than a pretty
    picture without the scenarios to animate it. The next step is to define the system
    operations, which correspond to architectural scenarios.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图2.7](#ch02fig07)所示的类图说明了应用程序架构的一个方面。但没有场景来激活它，它不过是一幅漂亮的图片。下一步是定义系统操作，这些操作对应于架构场景。
- en: Defining system operations
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义系统操作
- en: Once you’ve defined a high-level domain model, the next step is to identify
    the requests that the application must handle. The details of the UI are beyond
    the scope of this book, but you can imagine that in each user scenario, the UI
    will make requests to the backend business logic to retrieve and update data.
    FTGO is primarily a web application, which means that most requests are HTTP-based,
    but it’s possible that some clients might use messaging. Instead of committing
    to a specific protocol, therefore, it makes sense to use the more abstract notion
    of a system operation to represent requests.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了高级领域模型，下一步就是确定应用程序必须处理的请求。UI的细节超出了本书的范围，但你可以想象在每个用户场景中，UI将向后端业务逻辑发出请求以检索和更新数据。FTGO主要是一个Web应用程序，这意味着大多数请求都是基于HTTP的，但某些客户端可能使用消息。因此，而不是承诺特定的协议，使用更抽象的系统操作概念来表示请求是有意义的。
- en: 'There are two types of system operations:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 系统操作有两种类型：
- en: '***Commands*—** System operations that create, update, and delete data'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***命令*—** 创建、更新和删除数据的系统操作'
- en: '***Queries*—** System operations that read (query) data'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***查询*—** 读取（查询）数据的系统操作'
- en: Ultimately, these system operations will correspond to REST, RPC, or messaging
    endpoints, but for now thinking of them abstractly is useful. Let’s first identify
    some commands.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这些系统操作将对应于REST、RPC或消息端点，但就目前而言，抽象地思考它们是有用的。让我们首先确定一些命令。
- en: A good starting point for identifying system commands is to analyze the verbs
    in the user stories and scenarios. Consider, for example, the `Place Order` story.
    It clearly suggests that the system must provide a `Create Order` operation. Many
    other stories individually map directly to system commands. [Table 2.1](#ch02table01)
    lists some of the key system commands.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 识别系统命令的一个好起点是分析用户故事和场景中的动词。例如，考虑`Place Order`故事。它清楚地表明系统必须提供`Create Order`操作。许多其他故事单独直接映射到系统命令。[表2.1](#ch02table01)列出了一些关键系统命令。
- en: Table 2.1\. Key system commands for the FTGO application
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.1\. FTGO应用程序的关键系统命令
- en: '| Actor | Story | Command | Description |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 行动者 | 故事 | 命令 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Consumer | Create Order | createOrder() | Creates an order |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 消费者 | 创建订单 | createOrder() | 创建订单 |'
- en: '| Restaurant | Accept Order | acceptOrder() | Indicates that the restaurant
    has accepted the order and is committed to preparing it by the indicated time
    |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 餐厅 | 接受订单 | acceptOrder() | 表示餐厅已接受订单，并承诺在指定时间内准备订单 |'
- en: '| Restaurant | Order Ready for Pickup | noteOrderReadyForPickup() | Indicates
    that the order is ready for pickup |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 餐厅 | 订单准备就绪 | noteOrderReadyForPickup() | 表示订单已准备就绪，可以取货 |'
- en: '| Courier | Update Location | noteUpdatedLocation() | Updates the current location
    of the courier |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 快递员 | 更新位置 | noteUpdatedLocation() | 更新快递员当前的位置 |'
- en: '| Courier | Delivery picked up | noteDeliveryPickedUp() | Indicates that the
    courier has picked up the order |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 快递员 | 取货完成 | noteDeliveryPickedUp() | 表示快递员已取走订单 |'
- en: '| Courier | Delivery delivered | noteDeliveryDelivered() | Indicates that the
    courier has delivered the order |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 快递员 | 送货完成 | noteDeliveryDelivered() | 表示快递员已投递订单 |'
- en: 'A command has a specification that defines its parameters, return value, and
    behavior in terms of the domain model classes. The behavior specification consists
    of preconditions that must be true when the operation is invoked, and post-conditions
    that are true after the operation is invoked. Here, for example, is the specification
    of the `createOrder()` system operation:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一个命令有一个规范，该规范定义了其参数、返回值以及从领域模型类角度的行为。行为规范包括在操作调用时必须为真的前置条件，以及在操作调用后为真的后置条件。例如，以下是`createOrder()`系统操作的规范：
- en: '| Operation | createOrder (consumer id, payment method, delivery address, delivery
    time, restaurant id, order line items) |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | createOrder (消费者ID, 支付方式, 送货地址, 送货时间, 餐厅ID, 订单行项目) |'
- en: '| Returns | orderId, ... |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 返回值 | orderId, ... |'
- en: '| Preconditions |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 前置条件 |'
- en: The consumer exists and can place orders.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者存在并且可以下单。
- en: The line items correspond to the restaurant’s menu items.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行项目对应于餐厅的菜单项。
- en: The delivery address and time can be serviced by the restaurant.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 餐厅可以提供送货地址和时间服务。
- en: '|'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Post-conditions |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 后置条件 |'
- en: The consumer’s credit card was authorized for the order total.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者的信用卡已授权支付订单总额。
- en: An order was created in the PENDING_ACCEPTANCE state.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已创建一个处于**待接受**状态的订单。
- en: '|'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The preconditions mirror the *givens* in the `Place Order` user scenario described
    earlier. The post-conditions mirror the *thens* from the scenario. When a system
    operation is invoked it will verify the preconditions and perform the actions
    required to make the post-conditions true.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 前置条件反映了之前描述的“Place Order”用户场景中的**已知条件**。后置条件反映了场景中的**结果**。当系统操作被调用时，它将验证前置条件并执行使后置条件为真的所需操作。
- en: 'Here’s the specification of the `acceptOrder()` system operation:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`acceptOrder()`系统操作的规范：
- en: '| Operation | acceptOrder(restaurantId, orderId, readyByTime) |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | acceptOrder(restaurantId, orderId, readyByTime) |'
- en: '| Returns | — |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 返回值 | — |'
- en: '| Preconditions |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 前置条件 |'
- en: The order.status is PENDING_ACCEPTANCE.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单状态为**待接受**。
- en: A courier is available to deliver the order.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有快递员可以投递订单。
- en: '|'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Post-conditions |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 后置条件 |'
- en: The order.status was changed to ACCEPTED.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单状态已更改为**接受**。
- en: The order.readyByTime was changed to the readyByTime.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单的`readyByTime`被更改为`readyByTime`。
- en: The courier was assigned to deliver the order.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快递员被分配去投递订单。
- en: '|'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Its pre- and post-conditions mirror the user scenario from earlier.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 其前置条件和后置条件与之前用户场景中的内容相匹配。
- en: Most of the architecturally relevant system operations are commands. Sometimes,
    though, queries, which retrieve data, are also important.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数与架构相关的系统操作都是命令。尽管如此，有时查询，即检索数据，也非常重要。
- en: 'Besides implementing commands, an application must also implement queries.
    The queries provide the UI with the information a user needs to make decisions.
    At this stage, we don’t have a particular UI design for FTGO application in mind,
    but consider, for example, the flow when a consumer places an order:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实现命令之外，应用程序还必须实现查询。查询为UI提供用户做出决策所需的信息。在这个阶段，我们还没有FTGO应用程序的特定UI设计，但考虑例如消费者下单时的流程：
- en: User enters delivery address and time.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户输入送货地址和时间。
- en: System displays available restaurants.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统显示可用的餐厅。
- en: User selects restaurant.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户选择餐厅。
- en: System displays menu.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统显示菜单。
- en: User selects item and checks out.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户选择商品并结账。
- en: System creates order.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统创建订单。
- en: 'This user scenario suggests the following queries:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此用户场景建议以下查询：
- en: '**`findAvailableRestaurants(deliveryAddress, deliveryTime)`—** Retrieves the
    restaurants that can deliver to the specified delivery address at the specified
    time'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`findAvailableRestaurants(deliveryAddress, deliveryTime)`—** 获取在指定时间可以送达到指定送货地址的餐厅'
- en: '**`findRestaurantMenu(id)`—** Retrieves information about a restaurant including
    the menu items'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`findRestaurantMenu(id)`—** 获取关于餐厅的信息，包括菜单项目'
- en: Of the two queries, `findAvailableRestaurants()` is probably the most architecturally
    significant. It’s a complex query involving geosearch. The geosearch component
    of the query consists of finding all points—restaurants—that are near a location—the
    delivery address. It also filters out those restaurants that are closed when the
    order needs to be prepared and picked up. Moreover, performance is critical, because
    this query is executed whenever a consumer wants to place an order.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个查询中，`findAvailableRestaurants()` 可能是架构上最重要的查询。它是一个复杂的查询，涉及地理搜索。查询的地理搜索组件包括找到所有靠近一个位置——送货地址的餐厅。它还会过滤掉那些在订单需要准备和取货时已关闭的餐厅。此外，性能至关重要，因为这个查询是在消费者想要下单时执行的。
- en: The high-level domain model and the system operations capture what the application
    does. They help drive the definition of the application’s architecture. The behavior
    of each system operation is described in terms of the domain model. Each important
    system operation represents an architecturally significant scenario that’s part
    of the description of the architecture.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 高级领域模型和系统操作描述了应用程序的功能。它们有助于推动应用程序架构的定义。每个系统操作的行为都是用领域模型来描述的。每个重要的系统操作代表了一个架构上重要的场景，这是架构描述的一部分。
- en: 'Once the system operations have been defined, the next step is to identify
    the application’s services. As mentioned earlier, there isn’t a mechanical process
    to follow. There are, however, various decomposition strategies that you can use.
    Each one attacks the problem from a different perspective and uses its own terminology.
    But with all strategies, the end result is the same: an architecture consisting
    of services that are primarily organized around business rather than technical
    concepts.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了系统操作，下一步就是确定应用程序的服务。如前所述，没有机械的过程可以遵循。然而，有各种分解策略可以使用。每个策略都从不同的角度攻击问题，并使用自己的术语。但所有策略的最终结果都是相同的：一个由服务组成的架构，这些服务主要是围绕业务而不是技术概念组织的。
- en: Let’s look at the first strategy, which defines services corresponding to business
    capabilities.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一种策略，它定义了与业务能力相对应的服务。
- en: 2.2.2\. Defining services by applying the Decompose by business capability pattern
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2\. 通过应用按业务能力分解模式定义服务
- en: One strategy for creating a microservice architecture is to decompose by business
    capability. A concept from business architecture modeling, a *business capability*
    is something that a business does in order to generate value. The set of capabilities
    for a given business depends on the kind of business. For example, the capabilities
    of an insurance company typically include Underwriting, Claims management, Billing,
    Compliance, and so on. The capabilities of an online store include Order management,
    Inventory management, Shipping, and so on.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建微服务架构的一种策略是按业务能力进行分解。这是来自业务架构建模的一个概念，*业务能力*是指为了创造价值而进行的业务活动。给定业务的业务能力集合取决于业务类型。例如，保险公司的能力通常包括承保、索赔管理、计费、合规性等。在线商店的能力包括订单管理、库存管理、运输等。
- en: '|  |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Pattern: Decompose by business capability**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：按业务能力分解**'
- en: Define services corresponding to business capabilities. See [http://microservices.io/patterns/decomposition/decompose-by-business-capability.html](http://microservices.io/patterns/decomposition/decompose-by-business-capability.html).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 定义与业务能力相对应的服务。请参阅[http://microservices.io/patterns/decomposition/decompose-by-business-capability.html](http://microservices.io/patterns/decomposition/decompose-by-business-capability.html)。
- en: '|  |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Business capabilities define what an organization does
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 业务能力定义了一个组织做什么
- en: An organization’s business capabilities capture *what* an organization’s business
    is. They’re generally stable, as opposed to *how* an organization conducts its
    business, which changes over time, sometimes dramatically. That’s especially true
    today, with the rapidly growing use of technology to automate many business processes.
    For example, it wasn’t that long ago that you deposited checks at your bank by
    handing them to a teller. It then became possible to deposit checks using an ATM.
    Today you can conveniently deposit most checks using your smartphone. As you can
    see, the Deposit check business capability has remained stable, but the manner
    in which it’s done has drastically changed.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组织的业务能力捕捉了组织的业务“是什么”。它们通常是稳定的，与组织如何开展业务相对，后者会随着时间的推移而变化，有时变化很大。这在今天尤其如此，随着技术自动化许多业务过程的快速增长。例如，不久前，你还需要把支票交给银行柜员来存款。后来，可以使用自动柜员机存款。如今，你可以方便地使用智能手机存款。正如你所看到的，存款支票业务能力保持稳定，但执行方式发生了巨大变化。
- en: Identifying business capabilities
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 识别业务能力
- en: An organization’s business capabilities are identified by analyzing the organization’s
    purpose, structure, and business processes. Each business capability can be thought
    of as a service, except it’s business-oriented rather than technical. Its specification
    consists of various components, including inputs, outputs, and service-level agreements.
    For example, the input to an Insurance underwriting capability is the consumer’s
    application, and the outputs include approval and price.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组织的业务能力是通过分析组织的宗旨、结构和业务流程来识别的。每个业务能力都可以被视为一种服务，只不过它是面向业务的而不是技术性的。其规范包括各种组件，包括输入、输出和服务级别协议。例如，保险承保能力的输入是消费者的申请，输出包括批准和价格。
- en: A business capability is often focused on a particular business object. For
    example, the Claim business object is the focus of the Claim management capability.
    A capability can often be decomposed into sub-capabilities. For example, the Claim
    management capability has several sub-capabilities, including Claim information
    management, Claim review, and Claim payment management.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 业务能力通常专注于特定的业务对象。例如，索赔业务对象是索赔管理能力的焦点。能力通常可以分解为子能力。例如，索赔管理能力有几个子能力，包括索赔信息管理、索赔审查和索赔付款管理。
- en: 'It is not difficult to imagine that the business capabilities for FTGO include
    the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 想象FTGO的业务能力包括以下内容并不困难：
- en: Supplier management
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应商管理
- en: '***Courier management*—** Managing courier information'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***快递管理*—** 管理快递信息'
- en: '***Restaurant information management*—** Managing restaurant menus and other
    information, including location and open hours'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***餐厅信息管理*—** 管理餐厅菜单和其他信息，包括位置和营业时间'
- en: Consumer management—Managing information about consumers
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者管理—管理消费者信息
- en: Order taking and fulfillment
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单接收和履行
- en: '***Order management*—** Enabling consumers to create and manage orders'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***订单管理*—** 允许消费者创建和管理订单'
- en: '***Restaurant order management*—** Managing the preparation of orders at a
    restaurant'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***餐厅订单管理*—** 管理餐厅订单的准备工作'
- en: Logistics
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物流
- en: '***Courier availability management*—** Managing the real-time availability
    of couriers to delivery orders'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***快递可用性管理*—** 管理快递员对配送订单的实时可用性'
- en: '***Delivery management*—** Delivering orders to consumers'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***配送管理*—** 向消费者配送订单'
- en: Accounting
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会计
- en: '***Consumer accounting*—** Managing billing of consumers'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***消费者会计*—** 管理消费者的账单'
- en: '***Restaurant accounting*—** Managing payments to restaurants'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***餐厅会计*—** 管理对餐厅的付款'
- en: '***Courier accounting*—** Managing payments to couriers'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***快递会计*—** 管理对快递员的付款'
- en: '...'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '...'
- en: The top-level capabilities include Supplier management, Consumer management,
    Order taking and fulfillment, and Accounting. There will likely be many other
    top-level capabilities, including marketing-related capabilities. Most top-level
    capabilities are decomposed into sub-capabilities. For example, Order taking and
    fulfillment is decomposed into five sub-capabilities.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最高层的能力包括供应商管理、消费者管理、订单接收和履行以及会计。可能还会有许多其他最高层能力，包括与营销相关的能力。大多数最高层能力都被分解为子能力。例如，订单接收和履行被分解为五个子能力。
- en: 'On interesting aspect of this capability hierarchy is that there are three
    restaurant-related capabilities: Restaurant information management, Restaurant
    order management, and Restaurant accounting. That’s because they represent three
    very different aspects of restaurant operations.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个能力层次结构的一个有趣方面是，有三个与餐厅相关的功能：餐厅信息管理、餐厅订单管理和餐厅会计。这是因为它们代表了餐厅运营的三个非常不同的方面。
- en: Next we’ll look at how to use business capabilities to define services.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何使用业务能力来定义服务。
- en: From business capabilities to services
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从业务能力到服务
- en: Once you’ve identified the business capabilities, you then define a service
    for each capability or group of related capabilities. [Figure 2.8](#ch02fig08)
    shows the mapping from capabilities to services for the FTGO application. Some
    top-level capabilities, such as the Accounting capability, are mapped to services.
    In other cases, sub-capabilities are mapped to services.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了业务能力，然后为每个能力或相关能力组定义一个服务。[图2.8](#ch02fig08)显示了FTGO应用程序从能力到服务的映射。一些顶级能力，如会计能力，映射到服务。在其他情况下，子能力映射到服务。
- en: Figure 2.8\. Mapping FTGO business capabilities to services. Capabilities at
    various levels of the capability hierarchy are mapped to services.
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.8\. 将FTGO业务能力映射到服务。能力层次结构的不同级别的能力映射到服务。
- en: '![](Images/02fig08_alt.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8](Images/02fig08_alt.jpg)'
- en: 'The decision of which level of the capability hierarchy to map to services,
    because is somewhat subjective. My justification for this particular mapping is
    as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 决定将能力层次结构的哪个级别映射到服务，因为这是主观的。我对这种特定映射的合理性如下：
- en: I mapped the sub-capabilities of Supplier management to two services, because
    Restaurants and Couriers are very different types of suppliers.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将供应商管理的子能力映射到两个服务，因为餐厅和快递员是两种非常不同的供应商类型。
- en: I mapped the Order taking and fulfillment capability to three services that
    are each responsible for different phases of the process. I combined the Courier
    availability management and Delivery management capabilities and mapped them to
    a single service because they’re deeply intertwined.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将订单接收和履约能力映射到三个服务，每个服务负责流程的不同阶段。我将快递员可用性管理和配送管理能力合并，并将它们映射到单个服务，因为它们紧密相连。
- en: I mapped the Accounting capability to its own service, because the different
    types of accounting seem similar.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将会计能力映射到其自己的服务，因为不同类型的会计看起来很相似。
- en: Later on, it may make sense to separate payments (of Restaurants and Couriers)
    and billing (of Consumers).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将支付（餐厅和快递员的支付）和账单（消费者的账单）分开可能是有意义的。
- en: A key benefit of organizing services around capabilities is that because they’re
    stable, the resulting architecture will also be relatively stable. The individual
    components of the architecture may evolve as the *how* aspect of the business
    changes, but the architecture remains unchanged.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将服务组织在能力周围的一个关键好处是，因为它们是稳定的，所以产生的架构也将相对稳定。随着业务“如何”方面的变化，架构的各个组成部分可能会发展，但架构保持不变。
- en: Having said that, it’s important to remember that the services shown in [figure
    2.8](#ch02fig08) are merely the first attempt at defining the architecture. They
    may evolve over time as we learn more about the application domain. In particular,
    an important step in the architecture definition process is investigating how
    the services collaborate in each of the key architectural services. You might,
    for example, discover that a particular decomposition is inefficient due to excessive
    interprocess communication and that you must combine services. Conversely, a service
    might grow in complexity to the point where it becomes worthwhile to split it
    into multiple services. What’s more, in [section 2.2.5](#ch02lev2sec8), I describe
    several obstacles to decomposition that might cause you to revisit your decision.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，重要的是要记住，[图2.8](#ch02fig08)中所示的服务仅仅是定义架构的第一次尝试。随着时间的推移，随着我们对应用领域的了解更多，它们可能会发生变化。特别是，在架构定义过程中，调查服务如何在每个关键架构服务中协作是一个重要步骤。例如，你可能会发现，由于进程间通信过多，某种特定的分解效率低下，你必须合并服务。相反，一个服务可能会变得复杂到值得将其拆分为多个服务。更重要的是，在[第2.2.5节](#ch02lev2sec8)中，我描述了可能导致你重新考虑决定的几个分解障碍。
- en: Let’s take a look at another way to decompose an application that is based on
    domain-driven design.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看另一种基于领域驱动设计的应用分解方法。
- en: 2.2.3\. Defining services by applying the Decompose by sub-domain pattern
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.3\. 通过应用按子域分解模式定义服务
- en: 'DDD, as described in the excellent book Domain-driven design by Eric Evans
    (Addison-Wesley Professional, 2003), is an approach for building complex software
    applications that is centered on the development of an object-oriented domain
    model. A *domain mode* captures knowledge about a domain in a form that can be
    used to solve problems within that domain. It defines the vocabulary used by the
    team, what DDD calls the *Ubiquitous Language*. The domain model is closely mirrored
    in the design and implementation of the application. DDD has two concepts that
    are incredibly useful when applying the microservice architecture: subdomains
    and bounded contexts.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在埃里克·埃文斯（Eric Evans）所著的优秀书籍《领域驱动设计》（Domain-driven design，Addison-Wesley Professional，2003年）中所描述的，DDD是一种构建复杂软件应用程序的方法，该方法以面向对象领域模型的发展为中心。*领域模型*以可以用于解决该领域内问题的形式捕捉关于领域的知识。它定义了团队使用的词汇，DDD称之为*通用语言*。领域模型在应用程序的设计和实现中紧密对应。DDD有两个在应用微服务架构时非常有用的概念：子域和边界上下文。
- en: '|  |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Pattern: Decompose by subdomain**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式：按子域分解**'
- en: Define services corresponding to DDD subdomains. See [http://microservices.io/patterns/decomposition/decompose-by-subdomain.html](http://microservices.io/patterns/decomposition/decompose-by-subdomain.html).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 定义与DDD子域对应的服务的定义。参见[http://microservices.io/patterns/decomposition/decompose-by-subdomain.html](http://microservices.io/patterns/decomposition/decompose-by-subdomain.html)。
- en: '|  |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: DDD is quite different than the traditional approach to enterprise modeling,
    which creates a single model for the entire enterprise. In such a model there
    would be, for example, a single definition of each business entity, such as customer,
    order, and so on. The problem with this kind of modeling is that getting different
    parts of an organization to agree on a single model is a monumental task. Also,
    it means that from the perspective of a given part of the organization, the model
    is overly complex for their needs. Moreover, the domain model can be confusing
    because different parts of the organization might use either the same term for
    different concepts or different terms for the same concept. DDD avoids these problems
    by defining multiple domain models, each with an explicit scope.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: DDD与传统的企业建模方法大不相同，后者为整个企业创建一个单一模型。在这种模型中，例如，每个业务实体（如客户、订单等）都有一个单一的定义。这种建模的问题在于，让组织的不同部分就一个单一模型达成一致是一项艰巨的任务。此外，从组织某个部分的角度来看，该模型对于他们的需求来说过于复杂。此外，领域模型可能会令人困惑，因为组织的不同部分可能会使用相同的术语来表示不同的概念，或者使用不同的术语来表示相同的概念。DDD通过定义多个领域模型来避免这些问题，每个模型都有一个明确的范围。
- en: 'DDD defines a separate domain model for each subdomain. A subdomain is a part
    of the *domain*, DDD’s term for the application’s problem space. Subdomains are
    identified using the same approach as identifying business capabilities: analyze
    the business and identify the different areas of expertise. The end result is
    very likely to be subdomains that are similar to the business capabilities. The
    examples of subdomains in FTGO include Order taking, Order management, Kitchen
    management, Delivery, and Financials. As you can see, these subdomains are very
    similar to the business capabilities described earlier.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: DDD为每个子域定义一个单独的领域模型。子域是*领域*的一部分，DDD术语，指的是应用程序的问题空间。子域是通过与识别业务能力相同的方法来识别的：分析业务并识别不同的专业领域。最终结果很可能产生与业务能力相似的子域。FTGO中子域的例子包括订单处理、订单管理、厨房管理、配送和财务。正如你所看到的，这些子域与前面描述的业务能力非常相似。
- en: DDD calls the scope of a domain model a *bounded context*. A bounded context
    includes the code artifacts that implement the model. When using the microservice
    architecture, each bounded context is a service or possibly a set of services.
    We can create a microservice architecture by applying DDD and defining a service
    for each subdomain. [Figure 2.9](#ch02fig09) shows how the subdomains map to services,
    each with its own domain model.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: DDD将领域模型的范围称为*边界上下文*。边界上下文包括实现该模型的代码工件。当使用微服务架构时，每个边界上下文都是一个服务或可能是一组服务。我们可以通过应用DDD并为每个子域定义一个服务来创建微服务架构。[图2.9](#ch02fig09)显示了子域如何映射到服务，每个服务都有自己的领域模型。
- en: 'Figure 2.9\. From subdomains to services: each subdomain of the FTGO application
    domain is mapped to a service, which has its own domain model.'
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.9\. 从子域到服务：FTGO应用域的每个子域都映射到一个服务，该服务有自己的领域模型。
- en: '![](Images/02fig09_alt.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig09_alt.jpg)'
- en: DDD and the microservice architecture are in almost perfect alignment. The DDD
    concept of subdomains and bounded contexts maps nicely to services within a microservice
    architecture. Also, the microservice architecture’s concept of autonomous teams
    owning services is completely aligned with the DDD’s concept of each domain model
    being owned and developed by a single team. Even better, as I describe later in
    this section, the concept of a subdomain with its own domain model is a great
    way to eliminate god classes and thereby make decomposition easier.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: DDD和微服务架构几乎完美地一致。DDD的子域和边界上下文的概念很好地映射到微服务架构中的服务。此外，微服务架构中拥有服务的自主团队的概念与DDD中每个领域模型由单一团队拥有和开发的概念完全一致。更好的是，正如我在本节后面描述的，具有自己领域模型的子域的概念是消除上帝类并因此使分解更容易的绝佳方式。
- en: Decompose by subdomain and Decompose by business capability are the two main
    patterns for defining an application’s microservice architecture. There are, however,
    some useful guidelines for decomposition that have their roots in object-oriented
    design. Let’s take a look at them.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过子域分解和通过业务能力分解是定义应用程序微服务架构的两个主要模式。然而，有一些有用的分解指南，其根源在于面向对象设计。让我们来看看它们。
- en: 2.2.4\. Decomposition guidelines
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.4\. 分解指南
- en: So far in this chapter, we’ve looked at the main ways to define a microservice
    architecture. We can also adapt and use a couple of principles from object-oriented
    design when applying the microservice architecture pattern. These principles were
    created by Robert C. Martin and described in his classic book *Designing Object
    Oriented C++ Applications Using The Booch Method* (Prentice Hall, 1995). The first
    principle is the Single Responsibility Principle (SRP), for defining the responsibilities
    of a class. The second principle is the Common Closure Principle (CCP), for organizing
    classes into packages. Let’s take a look at these principles and see how they
    can be applied to the microservice architecture.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经探讨了定义微服务架构的主要方法。我们还可以在应用微服务架构模式时，采用和利用面向对象设计的一些原则。这些原则是由罗伯特·C·马丁创建的，并在他的经典著作《使用Booch方法设计面向对象C++应用程序》（Prentice
    Hall，1995年）中描述。第一个原则是单一职责原则（SRP），用于定义类的职责。第二个原则是共同封闭原则（CCP），用于将类组织到包中。让我们来看看这些原则，并了解它们如何应用于微服务架构。
- en: Single Responsibility Principle
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: 'One of the main goals of software architecture and design is determining the
    responsibilities of each software element. The Single Responsibility Principle
    is as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构和设计的主要目标之一是确定每个软件元素的职责。单一职责原则如下：
- en: '*A class should have only one reason to change.*'
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*一个类应该只有一个变化的原因。*'
- en: ''
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Robert C. Martin*'
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*罗伯特·C·马丁*'
- en: Each responsibility that a class has is a potential reason for that class to
    change. If a class has multiple responsibilities that change independently, the
    class won’t be stable. By following the SRP, you define classes that each have
    a single responsibility and hence a single reason for change.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 类所拥有的每个职责都是该类可能发生变化的潜在原因。如果一个类有多个独立变化的职责，那么该类将不会稳定。通过遵循SRP，你可以定义每个类只有一个职责和因此只有一个变化原因的类。
- en: We can apply SRP when defining a microservice architecture and create small,
    cohesive services that each have a single responsibility. This will reduce the
    size of the services and increase their stability. The new FTGO architecture is
    an example of SRP in action. Each aspect of getting food to a consumer—order taking,
    order preparation, and delivery—is the responsibility of a separate service.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在定义微服务架构时应用SRP，创建小型、内聚的服务，每个服务只有一个职责。这将减少服务的大小并增加其稳定性。新的FTGO架构是SRP应用的例子。将食物送到消费者手中的每个方面——订单接收、订单准备和配送——都是独立服务的职责。
- en: Common Closure Principle
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 共同封闭原则
- en: 'The other useful principle is the Common Closure Principle:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的原则是共同封闭原则：
- en: '*The classes in a package should be closed together against the same kinds
    of changes. A change that affects a package affects all the classes in that package.*'
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*包中的类应该对同一类变化进行封闭。影响包的变化会影响该包中的所有类。*'
- en: ''
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Robert C. Martin*'
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*罗伯特·C·马丁*'
- en: The idea is that if two classes change in lockstep because of the same underlying
    reason, then they belong in the same package. Perhaps, for example, those classes
    implement a different aspect of a particular business rule. The goal is that when
    that business rule changes, developers only need to change code in a small number
    of packages (ideally only one). Adhering to the CCP significantly improves the
    maintainability of an application.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是，如果两个类因为相同的基本原因而同步更改，那么它们属于同一个包。例如，这些类可能实现了特定业务规则的不同方面。目标是当该业务规则更改时，开发者只需更改少量包中的代码（理想情况下只有一个包）。遵循CCP显著提高了应用程序的可维护性。
- en: We can apply CCP when creating a microservice architecture and package components
    that change for the same reason into the same service. Doing this will minimize
    the number of services that need to be changed and deployed when some requirement
    changes. Ideally, a change will only affect a single team and a single service.
    CCP is the antidote to the distributed monolith anti-pattern.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建微服务架构时，我们可以应用CCP（共同原因原则），将因相同原因而更改的组件打包到同一个服务中。这样做将最小化在需求变更时需要更改和部署的服务数量。理想情况下，一个变更只会影响一个团队和一个服务。CCP是分布式单体反模式的解药。
- en: SRP and CCP are 2 of the 11 principles developed by Bob Martin. They’re particularly
    useful when developing a microservice architecture. The remaining nine principles
    are used when designing classes and packages. For more information about SRP,
    CCP, and the other OOD principles, see the article “The Principles of Object Oriented
    Design” on Bob Martin’s website ([http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod)).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: SRP和CCP是Bob Martin开发的11个原则中的两个。它们在开发微服务架构时特别有用。其余的九个原则用于设计类和包。有关SRP、CCP和其他面向对象设计原则的更多信息，请参阅Bob
    Martin的网站上的文章“面向对象设计的原则”（[http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod))。
- en: Decomposition by business capability and by subdomain along with SRP and CCP
    are good techniques for decomposing an application into services. In order to
    apply them and successfully develop a microservice architecture, you must solve
    some transaction management and interprocess communication issues.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过业务能力和子域进行分解，以及SRP（单一责任原则）和CCP，是分解应用程序为服务的好方法。为了应用它们并成功开发微服务架构，你必须解决一些事务管理和进程间通信问题。
- en: 2.2.5\. Obstacles to decomposing an application into services
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.5. 将应用程序分解为服务的障碍
- en: 'On the surface, the strategy of creating a microservice architecture by defining
    services corresponding to business capabilities or subdomains looks straightforward.
    You may, however, encounter several obstacles:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，通过定义对应于业务能力或子域的服务来创建微服务架构的策略看起来很简单。然而，你可能会遇到几个障碍：
- en: Network latency
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络延迟
- en: Reduced availability due to synchronous communication
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于同步通信而降低的可用性
- en: Maintaining data consistency across services
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务之间保持数据一致性
- en: Obtaining a consistent view of the data
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取数据的一致视图
- en: God classes preventing decomposition
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻碍分解的上帝类
- en: Let’s take a look at each obstacle, starting with network latency.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一审视每个障碍，从网络延迟开始。
- en: Network latency
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 网络延迟
- en: '*Network latency* is an ever-present concern in a distributed system. You might
    discover that a particular decomposition into services results in a large number
    of round-trips between two services. Sometimes, you can reduce the latency to
    an acceptable amount by implementing a batch API for fetching multiple objects
    in a single round trip. But in other situations, the solution is to combine services,
    replacing expensive IPC with language-level method or function calls.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*网络延迟*是分布式系统中一个始终存在的担忧。你可能会发现，将应用程序分解为服务的方式会导致两个服务之间的大量往返。有时，通过实现批量API以在一次往返中检索多个对象，你可以将延迟减少到可接受的程度。但在其他情况下，解决方案是合并服务，用语言级别的调用或方法调用替换昂贵的进程间通信（IPC）。'
- en: Synchronous interprocess communication reduces availability
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 同步进程间通信降低可用性
- en: Another problem is how to implement interservice communication in a way that
    doesn’t reduce availability. For example, the most straightforward way to implement
    the `createOrder()` operation is for the `Order Service` to synchronously invoke
    the other services using REST. The drawback of using a protocol like REST is that
    it reduces the availability of the `Order Service`. It won’t be able to create
    an order if any of those other services are unavailable. Sometimes this is a worthwhile
    trade-off, but in [chapter 3](kindle_split_011.xhtml#ch03) you’ll learn that using
    asynchronous messaging, which eliminates tight coupling and improves availability,
    is often a better choice.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是如何以不降低可用性的方式实现服务间的通信。例如，实现`createOrder()`操作最直接的方式是`Order Service`通过REST同步调用其他服务。使用像REST这样的协议的缺点是它会降低`Order
    Service`的可用性。如果那些其他服务中的任何一个不可用，它将无法创建订单。有时这是一个值得的权衡，但在[第3章](kindle_split_011.xhtml#ch03)中你将了解到，使用异步消息传递，这可以消除紧密耦合并提高可用性，通常是一个更好的选择。
- en: Maintaining data consistency across services
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 维护服务间的数据一致性
- en: Another challenge is maintaining data consistency across services. Some system
    operations need to update data in multiple services. For example, when a restaurant
    accepts an order, updates must occur in both the `Kitchen Service` and the `Delivery
    Service`. The `Kitchen Service` changes the status of the `Ticket`. The `Delivery
    Service` schedules delivery of the order. Both of these updates must be done atomically.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个挑战是维护服务间的数据一致性。一些系统操作需要在多个服务中更新数据。例如，当餐馆接受订单时，必须在`Kitchen Service`和`Delivery
    Service`中更新。`Kitchen Service`更改`Ticket`的状态。`Delivery Service`安排订单的配送。这两个更新都必须原子性地完成。
- en: The traditional solution is to use a two-phase, commit-based, distributed transaction
    management mechanism. But as you’ll see in [chapter 4](kindle_split_012.xhtml#ch04),
    this is not a good choice for modern applications, and you must use a very different
    approach to transaction management, a saga. A *saga* is a sequence of local transactions
    that are coordinated using messaging. Sagas are more complex than traditional
    ACID transactions but they work well in many situations. One limitation of sagas
    is that they are eventually consistent. If you need to update some data atomically,
    then it must reside within a single service, which can be an obstacle to decomposition.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的解决方案是使用基于两阶段提交的分布式事务管理机制。但正如你将在[第4章](kindle_split_012.xhtml#ch04)中看到的，这并不是现代应用的正确选择，你必须使用一种非常不同的方法来管理事务，即叙事法。*叙事法*是一系列使用消息协调的本地事务。叙事法比传统的ACID事务更复杂，但在许多情况下工作得很好。叙事法的一个局限性是它们最终是一致的。如果你需要原子性地更新某些数据，那么这些数据必须位于单个服务中，这可能会成为分解的障碍。
- en: Obtaining a consistent view of the data
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 获取数据的一致视图
- en: Another obstacle to decomposition is the inability to obtain a truly consistent
    view of data across multiple databases. In a monolithic application, the properties
    of ACID transactions guarantee that a query will return a consistent view of the
    database. In contrast, in a microservice architecture, even though each service’s
    database is consistent, you can’t obtain a globally consistent view of the data.
    If you need a consistent view of some data, then it must reside in a single service,
    which can prevent decomposition. Fortunately, in practice this is rarely a problem.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 分解的另一个障碍是无法在多个数据库中获取数据的真正一致视图。在单体应用中，ACID事务的特性保证了查询将返回数据库的一致视图。相比之下，在微服务架构中，尽管每个服务的数据库都是一致的，但你无法获得数据的全局一致视图。如果你需要某些数据的一致视图，那么这些数据必须位于单个服务中，这可能会阻止分解。幸运的是，在实践中这很少成为问题。
- en: God classes prevent decomposition
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: God类阻止了分解
- en: 'Another obstacle to decomposition is the existence of so-called god classes.
    *God classes* are the bloated classes that are used throughout an application
    ([http://wiki.c2.com/?GodClass](http://wiki.c2.com/?GodClass)). A god class typically
    implements business logic for many different aspects of the application. It normally
    has a large number of fields mapped to a database table with many columns. Most
    applications have at least one of these classes, each representing a concept that’s
    central to the domain: accounts in banking, orders in e-commerce, policies in
    insurance, and so on. Because a god class bundles together state and behavior
    for many different aspects of an application, it’s an insurmountable obstacle
    to splitting any business logic that uses it into services.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 分解的另一个障碍是所谓的“上帝类”的存在。*上帝类*是那些在整个应用程序中使用的臃肿类([http://wiki.c2.com/?GodClass](http://wiki.c2.com/?GodClass))。一个上帝类通常为应用程序的许多不同方面实现业务逻辑。它通常具有大量字段映射到具有许多列的数据库表。大多数应用程序至少有一个这样的类，每个类代表一个对领域至关重要的概念：银行中的账户、电子商务中的订单、保险中的政策等等。由于上帝类将应用程序许多不同方面的状态和行为捆绑在一起，因此它是将使用它的任何业务逻辑拆分为服务的一个不可逾越的障碍。
- en: The `Order` class is a great example of a god class in the FTGO application.
    That’s not surprising—after all, the purpose of FTGO is to deliver food orders
    to customers. Most parts of the system involve orders. If the FTGO application
    had a single domain model, the `Order` class would be a very large class. It would
    have state and behavior corresponding to many different parts of the application.
    [Figure 2.10](#ch02fig10) shows the structure of this class that would be created
    using traditional modeling techniques.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order`类是FTGO应用程序中上帝类的绝佳例子。这并不令人惊讶——毕竟，FTGO的目的是将食品订单交付给客户。系统的许多部分都涉及订单。如果FTGO应用程序有一个单一的领域模型，`Order`类将是一个非常庞大的类。它将具有与应用程序许多不同部分相对应的状态和行为。[图2.10](#ch02fig10)显示了使用传统建模技术创建的这个类的结构。'
- en: Figure 2.10\. The `Order` god class is bloated with numerous responsibilities.
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.10。`Order`上帝类因承担众多职责而变得臃肿。
- en: '![](Images/02fig10_alt.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/02fig10_alt.jpg)'
- en: As you can see, the `Order` class has fields and methods corresponding to order
    processing, restaurant order management, delivery, and payments. This class also
    has a complex state model, due to the fact that one model has to describe state
    transitions from disparate parts of the application. In its current form, this
    class makes it extremely difficult to split code into services.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`Order`类具有与订单处理、餐厅订单管理、配送和支付相对应的字段和方法。这个类也具有复杂的状态模型，因为一个模型必须描述来自应用程序不同部分的状态转换。在其当前形式下，这个类使得将代码拆分为服务变得极其困难。
- en: One solution is to package the `Order` class into a library and create a central
    `Order` database. All services that process orders use this library and access
    the access database. The trouble with this approach is that it violates one of
    the key principles of the microservice architecture and results in undesirable,
    tight coupling. For example, any change to the `Order` schema requires the teams
    to update their code in lockstep.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是将`Order`类打包成一个库，并创建一个中央`Order`数据库。所有处理订单的服务都使用这个库并访问这个数据库。这种方法的问题在于它违反了微服务架构的一个关键原则，并导致了不希望的紧密耦合。例如，对`Order`模式的任何更改都需要团队同步更新他们的代码。
- en: Another solution is to encapsulate the `Order` database in an `Order Service`,
    which is invoked by the other services to retrieve and update orders. The problem
    with that design is that the `Order Service` would be a data service with an anemic
    domain model containing little or no business logic. Neither of these options
    is appealing, but fortunately, DDD provides a solution.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是将`Order`数据库封装在`Order Service`中，其他服务通过调用它来检索和更新订单。这种设计的问题在于`Order Service`将是一个数据服务，包含贫血的领域模型，其中包含很少或没有业务逻辑。这两种选择都不吸引人，但幸运的是，DDD提供了一个解决方案。
- en: 'A much better approach is to apply DDD and treat each service as a separate
    subdomain with its own domain model. This means that each of the services in the
    FTGO application that has anything to do with orders has its own domain model
    with its version of the `Order` class. A great example of the benefit of multiple
    domain models is the `Delivery Service`. Its view of an `Order`, shown in [figure
    2.11](#ch02fig11), is extremely simple: pickup address, pickup time, delivery
    address, and delivery time. Moreover, rather than call it an `Order`, the `Delivery
    Service` uses the more appropriate name of `Delivery`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是应用DDD，并将每个服务视为一个具有自己领域模型的独立子域。这意味着FTGO应用程序中与订单有关的每个服务都有自己的领域模型，以及自己的`Order`类版本。多个领域模型的好处的一个很好的例子是`Delivery
    Service`。它对`Order`的视图，如图[2.11](#ch02fig11)所示，非常简单：取货地址、取货时间、配送地址和配送时间。此外，它不是将其称为`Order`，而是使用更合适的名称`Delivery`。
- en: Figure 2.11\. The `Delivery Service` domain model
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.11\. `Delivery Service`领域模型
- en: '![](Images/02fig11_alt.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig11_alt.jpg)'
- en: The `Delivery Service` isn’t interested in any of the other attributes of an
    order.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delivery Service`对订单的任何其他属性都不感兴趣。'
- en: The `Kitchen Service` also has a much simpler view of an order. Its version
    of an `Order` is called a `Ticket`. As [figure 2.12](#ch02fig12) shows, a `Ticket`
    simply consist of a status, the `requestedDeliveryTime`, a `prepareByTime`, and
    a list of line items that tell the restaurant what to prepare. It’s unconcerned
    with the consumer, payment, delivery, and so on.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kitchen Service`对订单有一个更为简单的视图。它版本的`Order`被称为`Ticket`。如图[2.12](#ch02fig12)所示，`Ticket`仅包含状态、`requestedDeliveryTime`、`prepareByTime`以及一个列表，告诉餐厅需要准备什么。它与消费者、支付、配送等无关。'
- en: Figure 2.12\. The `Kitchen Service` domain model
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.12\. `Kitchen Service`领域模型
- en: '![](Images/02fig12_alt.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig12_alt.jpg)'
- en: The `Order` service has the most complex view of an order, shown in [figure
    2.13](#ch02fig13). Even though it has quite a few fields and methods, it’s still
    much simpler than the original version.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order`服务对订单有最复杂的视图，如图[2.13](#ch02fig13)所示。尽管它有很多字段和方法，但它仍然比原始版本简单得多。'
- en: Figure 2.13\. The `Order Service` domain model
  id: totrans-295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.13\. `Order Service`领域模型
- en: '![](Images/02fig13_alt.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02fig13_alt.jpg)'
- en: The `Order` class in each domain model represents different aspects of the same
    `Order` business entity. The FTGO application must maintain consistency between
    these different objects in different services. For example, once the `Order Service`
    has authorized the consumer’s credit card, it must trigger the creation of the
    `Ticket` in the `Kitchen Service`. Similarly, if the restaurant rejects the order
    via the `Kitchen Service`, it must be cancelled in the `Order Service` service,
    and the customer credited in the billing service. In [chapter 4](kindle_split_012.xhtml#ch04),
    you’ll learn how to maintain consistency between services, using the previously
    mentioned event-driven mechanism sagas.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 每个领域模型中的`Order`类代表同一`Order`业务实体的不同方面。FTGO应用程序必须在不同的服务中保持这些不同对象的一致性。例如，一旦`Order
    Service`授权了消费者的信用卡，它就必须在`Kitchen Service`中触发创建`Ticket`。同样，如果餐厅通过`Kitchen Service`拒绝订单，它必须在`Order
    Service`服务中取消，并在计费服务中向客户退款。在第[4章](kindle_split_012.xhtml#ch04)中，你将学习如何使用之前提到的基于事件的机制sagas在服务之间保持一致性。
- en: As well as creating technical challenges, having multiple domain models also
    impacts the implementation of the user experience. An application must translate
    between the user experience, which is its own domain model, and the domain models
    of each of the services. In the FTGO application, for example, the `Order` status
    displayed to a consumer is derived from `Order` information stored in multiple
    services. This translation is often handled by the API gateway, discussed in [chapter
    8](kindle_split_016.xhtml#ch08). Despite these challenges, it’s essential that
    you identify and eliminate god classes when defining a microservice architecture.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有多个领域模型不仅带来了技术挑战，还影响了用户体验的实现。应用程序必须在用户体验（它自己的领域模型）和每个服务的领域模型之间进行转换。例如，在FTGO应用程序中，显示给消费者的`Order`状态是从多个服务中存储的`Order`信息派生出来的。这种转换通常由API网关处理，这在第[8章](kindle_split_016.xhtml#ch08)中讨论过。尽管存在这些挑战，但在定义微服务架构时，识别和消除上帝类是至关重要的。
- en: We’ll now look at how to define the service APIs.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨如何定义服务API。
- en: 2.2.6\. Defining service APIs
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.6\. 定义服务API
- en: 'So far, we have a list of system operations and a list of a potential services.
    The next step is to define each service’s API: its operations and events. A service
    API operation exists for one of two reasons: some operations correspond to system
    operations. They are invoked by external clients and perhaps by other services.
    The other operations exist to support collaboration between services. These operations
    are only invoked by other services.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个系统操作列表和一个潜在的服务列表。下一步是定义每个服务的API：它的操作和事件。服务API操作存在有两个原因之一：一些操作对应于系统操作。它们被外部客户端和其他服务调用。其他操作存在是为了支持服务间的协作。这些操作只被其他服务调用。
- en: A service publishes events primarily to enable it to collaborate with other
    services. [Chapter 4](kindle_split_012.xhtml#ch04) describes how events can be
    used to implement sagas, which maintain data consistency across services. And
    [chapter 7](kindle_split_015.xhtml#ch07) discusses how events can be used to update
    CQRS views, which support efficient querying. An application can also use events
    to notify external clients. For example, it could use WebSockets to deliver events
    to a browser.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 服务主要发布事件是为了能够与其他服务协作。[第4章](kindle_split_012.xhtml#ch04)描述了如何使用事件来实现传奇，以在服务之间保持数据一致性。而[第7章](kindle_split_015.xhtml#ch07)讨论了如何使用事件来更新CQRS视图，以支持高效查询。应用程序还可以使用事件来通知外部客户端。例如，它可以使用WebSockets将事件发送到浏览器。
- en: The starting point for defining the service APIs is to map each system operation
    to a service. After that, we decide whether a service needs to collaborate with
    others to implement a system operation. If collaboration is required, we then
    determine what APIs those other services must provide in order to support the
    collaboration. Let’s begin by looking at how to assign system operations to services.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 定义服务API的起点是将每个系统操作映射到服务。之后，我们决定一个服务是否需要与其他服务协作以实现系统操作。如果需要协作，我们接着确定那些其他服务必须提供哪些API以支持协作。让我们首先看看如何将系统操作分配给服务。
- en: Assigning system operations to services
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将系统操作分配给服务
- en: The first step is to decide which service is the initial entry point for a request.
    Many system operations neatly map to a service, but sometimes the mapping is less
    obvious. Consider, for example, the `noteUpdatedLocation()` operation, which updates
    the courier location. On one hand, because it’s related to couriers, this operation
    should be assigned to the `Courier` service. On the other hand, it’s the `Delivery
    Service` that needs the courier location. In this case, assigning an operation
    to a service that needs the information provided by the operation is a better
    choice. In other situations, it might make sense to assign an operation to the
    service that has the information necessary to handle it.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是决定哪个服务是请求的初始入口点。许多系统操作可以很好地映射到服务，但有时映射并不明显。例如，考虑`noteUpdatedLocation()`操作，它更新快递员的位置。一方面，因为它与快递员相关，这个操作应该分配给`Courier`服务。另一方面，`Delivery
    Service`需要快递员的位置。在这种情况下，将操作分配给需要操作提供的信息的服务是一个更好的选择。在其他情况下，将操作分配给具有处理所需信息的服务可能更有意义。
- en: '[Table 2.2](#ch02table02) shows which services in the FTGO application are
    responsible for which operations.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '[表2.2](#ch02table02)显示了FTGO应用程序中哪些服务负责哪些操作。'
- en: Table 2.2\. Mapping system operations to services in the FTGO application
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.2\. FTGO应用程序中系统操作到服务的映射
- en: '| Service | Operations |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 服务 | 操作 |'
- en: '| --- | --- |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Consumer Service | createConsumer() |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 消费者服务 | createConsumer() |'
- en: '| Order Service | createOrder() |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 订单服务 | createOrder() |'
- en: '| Restaurant Service | findAvailableRestaurants() |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 餐厅服务 | findAvailableRestaurants() |'
- en: '| Kitchen Service |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 厨房服务 |'
- en: acceptOrder()
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: acceptOrder()
- en: noteOrderReadyForPickup()
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: noteOrderReadyForPickup()
- en: '|'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Delivery Service |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 配送服务 |'
- en: noteUpdatedLocation()
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: noteUpdatedLocation()
- en: noteDeliveryPickedUp()
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: noteDeliveryPickedUp()
- en: noteDeliveryDelivered()
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: noteDeliveryDelivered()
- en: '|'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: After having assigned operations to services, the next step is to decide how
    the services collaborate in order to handle each system operation.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在将操作分配给服务之后，下一步是决定服务如何协作以处理每个系统操作。
- en: Determining the APIs required to support collaboration between services
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 确定支持服务间协作所需的API
- en: 'Some system operations are handled entirely by a single service. For example,
    in the FTGO application, the `Consumer Service` handles the `createConsumer()`
    operation entirely by itself. But other system operations span multiple services.
    The data needed to handle one of these requests might, for instance, be scattered
    around multiple services. For example, in order to implement the `createOrder()`
    operation, the `Order Service` must invoke the following services in order to
    verify its preconditions and make the post-conditions become true:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 一些系统操作完全由单个服务处理。例如，在 FTGO 应用中，`消费者服务`完全自行处理`createConsumer()`操作。但其他系统操作跨越多个服务。处理这些请求所需的数据可能分散在多个服务中。例如，为了实现`createOrder()`操作，`订单服务`必须调用以下服务以验证其先决条件并使后置条件成立：
- en: '**`Consumer Service`—** Verify that the consumer can place an order and obtain
    their payment information.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`消费者服务`—** 验证消费者能否下单并获取他们的支付信息。'
- en: '**`Restaurant Service`—** Validate the order line items, verify that the delivery
    address/time is within the restaurant’s service area, verify order minimum is
    met, and obtain prices for the order line items.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`餐厅服务`—** 验证订单行项目，确认配送地址/时间在餐厅的服务区域内，验证订单最低金额是否满足，并获取订单行项目的价格。'
- en: '**`Kitchen Service`—** Create the `Ticket`.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`厨房服务`—** 创建`票据`。'
- en: '**`Accounting Service`—** Authorize the consumer’s credit card.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`会计服务`—** 授权消费者的信用卡。'
- en: Similarly, in order to implement the `acceptOrder()` system operation, the `Kitchen
    Service` must invoke the `Delivery Service` to schedule a courier to deliver the
    order. [Table 2.3](#ch02table03) shows the services, their revised APIs, and their
    collaborators. In order to fully define the service APIs, you need to analyze
    each system operation and determine what collaboration is required.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了实现`acceptOrder()`系统操作，`厨房服务`必须调用`配送服务`来安排快递员配送订单。[表 2.3](#ch02table03)
    显示了服务、它们的修订版 API 和它们的合作伙伴。为了完全定义服务 API，您需要分析每个系统操作并确定所需的协作。
- en: Table 2.3\. The services, their revised APIs, and their collaborators
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 2.3\. 服务、它们的修订版 API 和它们的合作伙伴
- en: '| Service | Operations | Collaborators |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 服务 | 操作 | 合作伙伴 |'
- en: '| --- | --- | --- |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Consumer Service | verifyConsumerDetails() | — |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 消费者服务 | verifyConsumerDetails() | — |'
- en: '| Order Service | createOrder() |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 订单服务 | createOrder() |'
- en: Consumer Service verifyConsumerDetails()
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者服务 verifyConsumerDetails()
- en: Restaurant Service verifyOrderDetails()
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 餐厅服务 verifyOrderDetails()
- en: Kitchen Service createTicket()
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 厨房服务 createTicket()
- en: Accounting Service authorizeCard()
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会计服务 authorizeCard()
- en: '|'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Restaurant Service |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 餐厅服务 |'
- en: findAvailableRestaurants()
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: findAvailableRestaurants()
- en: verifyOrderDetails()
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: verifyOrderDetails()
- en: '| — |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| — |'
- en: '| Kitchen Service |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 厨房服务 |'
- en: createTicket()
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: createTicket()
- en: acceptOrder()
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: acceptOrder()
- en: noteOrderReadyForPickup()
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: noteOrderReadyForPickup()
- en: '|'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Delivery Service scheduleDelivery()
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配送服务 scheduleDelivery()
- en: '|'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Delivery Service |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 配送服务 |'
- en: scheduleDelivery()
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: scheduleDelivery()
- en: noteUpdatedLocation()
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: noteUpdatedLocation()
- en: noteDeliveryPickedUp()
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: noteDeliveryPickedUp()
- en: noteDeliveryDelivered()
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: noteDeliveryDelivered()
- en: '| — |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| — |'
- en: '| Accounting Service |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 会计服务 |'
- en: authorizeCard()
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: authorizeCard()
- en: '| — |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| — |'
- en: So far, we’ve identified the services and the operations that each service implements.
    But it’s important to remember that the architecture we’ve sketched out is very
    abstract. We’ve not selected any specific IPC technology. Moreover, even though
    the term *operation* suggests some kind of synchronous request/response-based
    IPC mechanism, you’ll see that asynchronous messaging plays a significant role.
    Throughout this book I describe architecture and design concepts that influence
    how these services collaborate.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经确定了服务和每个服务实现的操作。但重要的是要记住，我们勾勒出的架构非常抽象。我们尚未选择任何特定的 IPC 技术。此外，尽管术语*操作*暗示了一种基于同步请求/响应的
    IPC 机制，但您会发现异步消息发挥着重要作用。在这本书的整个过程中，我描述了影响这些服务协作的架构和设计概念。
- en: '[Chapter 3](kindle_split_011.xhtml#ch03) describes specific IPC technologies,
    including synchronous communication mechanisms such as REST, and asynchronous
    messaging using a message broker. I discuss how synchronous communication can
    impact availability and introduce the concept of a self-contained service, which
    doesn’t invoke other services synchronously. One way to implement a self-contained
    service is to use the CQRS pattern, covered in [chapter 7](kindle_split_015.xhtml#ch07).
    The `Order Service` could, for example, maintain a replica of the data owned by
    the `Restaurant Service` in order to eliminate the need for it to synchronously
    invoke the `Restaurant Service` to validate an order. It keeps the replica up-to-date
    by subscribing to events published by the `Restaurant Service` whenever it updates
    its data.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](kindle_split_011.xhtml#ch03)描述了特定的IPC技术，包括同步通信机制，如REST，以及使用消息代理的异步消息。我讨论了同步通信如何影响可用性，并引入了自包含服务的概念，这种服务不会同步调用其他服务。实现自包含服务的一种方法是通过CQRS模式，这在[第7章](kindle_split_015.xhtml#ch07)中有介绍。例如，`Order
    Service`可以维护`Restaurant Service`拥有的数据的副本，以消除同步调用`Restaurant Service`验证订单的需求。它通过订阅`Restaurant
    Service`发布的事件来保持副本的更新，每当`Restaurant Service`更新其数据时。'
- en: '[Chapter 4](kindle_split_012.xhtml#ch04) introduces the saga concept and how
    it uses asynchronous messaging for coordinating the services that participate
    in the saga. As well as reliably updating data scattered across multiple services,
    a saga is also a way to implement a self-contained service. For example, I describe
    how the `createOrder()` operation is implemented using a saga, which invokes services
    such as the `Consumer Service`, `Kitchen Service`, and `Accounting Service` using
    asynchronous messaging.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](kindle_split_012.xhtml#ch04)介绍了叙事概念及其如何使用异步消息来协调参与叙事的服务。叙事不仅能够可靠地更新分散在多个服务中的数据，而且也是一种实现自包含服务的方式。例如，我描述了如何使用叙事来实现`createOrder()`操作，通过异步消息调用诸如`Consumer
    Service`、`Kitchen Service`和`Accounting Service`等服务。'
- en: '[Chapter 8](kindle_split_016.xhtml#ch08) describes the concept of an API gateway,
    which exposes an API to external clients. An API gateway might implement a query
    operation using the API composition pattern, described in [chapter 7](kindle_split_015.xhtml#ch07),
    rather than simply route it to the service. Logic in the API gateway gathers the
    data needed by the query by calling multiple services and combining the results.
    In this situation, the system operation is assigned to the API gateway rather
    than a service. The services need to implement the query operations needed by
    the API gateway.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](kindle_split_016.xhtml#ch08)描述了API网关的概念，它向外部客户端公开API。API网关可能会使用[第7章](kindle_split_015.xhtml#ch07)中描述的API组合模式来实现查询操作，而不是简单地将其路由到服务。API网关中的逻辑通过调用多个服务并组合结果来收集查询所需的数据。在这种情况下，系统操作分配给API网关而不是服务。服务需要实现API网关所需的查询操作。'
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Architecture determines your application’s *-ilities*, including maintainability,
    testability, and deployability, which directly impact development velocity.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构决定了你的应用程序的*可*性，包括可维护性、可测试性和可部署性，这些直接影响开发速度。
- en: The microservice architecture is an architecture style that gives an application
    high maintainability, testability, and deployability.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构是一种架构风格，它为应用程序提供了高度的维护性、可测试性和可部署性。
- en: Services in a microservice architecture are organized around business concerns—business
    capabilities or subdomains—rather than technical concerns.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构中的服务是围绕业务关注点——业务能力或子域——而不是技术关注点组织的。
- en: 'There are two patterns for decomposition:'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解有两种模式：
- en: Decompose by business capability, which has its origins in business architecture
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按业务能力分解，其起源在于业务架构
- en: Decompose by subdomain, based on concepts from domain-driven design
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按子域分解，基于领域驱动设计的概念
- en: You can eliminate god classes, which cause tangled dependencies that prevent
    decomposition, by applying DDD and defining a separate domain model for each service.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过应用领域驱动设计（DDD）并为每个服务定义一个单独的领域模型，你可以消除导致依赖纠缠的上帝类，从而实现分解。
