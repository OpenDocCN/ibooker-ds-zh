- en: appendix. Monkey-patching functions and modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录. 修补函数和模块
- en: In chapter 3, I introduced various stubbing techniques that I called “accepted,”
    in that they are usually considered safe for both the maintainability and readability
    of the code and the tests that they guide us to write. In this appendix, I’ll
    describe a few of the less accepted and less safe ways in which we can fake whole
    modules in our tests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我介绍了各种我称之为“可接受”的模拟技术，因为它们通常被认为对代码的可维护性和可读性以及它们引导我们编写的测试都是安全的。在本附录中，我将描述一些不太被接受且不太安全的方法，我们可以用它们在测试中模拟整个模块。
- en: A.1 An obligatory warning
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.1 必须的警告
- en: I have good news and bad news about global patching and stubbing out functions
    and modules. Yes, you can do it—I’ll show you several ways to accomplish this.
    Is it a great idea? I’m not convinced. The costs of maintaining your tests with
    the techniques I’ll show you tend to be, from my experience, worse than maintaining
    code that is well parameterized or has proper seams built in.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 关于全局修补和模拟函数和模块，我有好消息和坏消息。是的，你可以做到这一点——我将向你展示几种实现这一目标的方法。这是一个好主意吗？我并不确信。根据我的经验，使用我将展示的技术来维护测试的成本往往比维护参数化良好或具有适当接口的代码的成本要高。
- en: However, there might be special times when you need to use these techniques.
    Such times include, but are not limited to, faking dependencies in code that you
    do not own and cannot change, and sometimes when using immediately executable
    functions or modules. Another case is when a module exposes only functions without
    objects, which limits the faking options quite a bit.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能存在一些特殊时刻，你需要使用这些技术。这些时刻包括但不限于，在无法拥有和更改的代码中模拟依赖项，有时在使用立即执行的函数或模块时，以及当模块只暴露函数而没有对象时，这大大限制了模拟选项。
- en: Try to avoid using the techniques I describe in this appendix as much as you
    can. If you can find a way to write your tests or refactor your code so you don’t
    need these approaches, use that way. If all else fails, the techniques in this
    appendix are a necessary evil. If you must use them, try to minimize how much
    you use them. Your tests will suffer and will become more fragile and harder to
    read.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能避免使用我在附录中描述的技术。如果你能找到一种方法来编写测试或重构代码，使其不需要这些方法，请使用那种方法。如果所有其他方法都失败了，附录中的技术是一种必要的恶。如果你必须使用它们，尽量减少使用它们的程度。你的测试将受到影响，变得更为脆弱且难以阅读。
- en: Let’s dive in.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨。
- en: A.2 Monkey-patching functions, globals, and possible issues
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.2 修补函数、全局变量和可能的问题
- en: Monkey-patching refers to the act of changing the behavior of a running program
    instance at run time. I first encountered the term when I was working in Ruby,
    where monkey-patching is very common. In JavaScript, it’s just as easy to “patch”
    a function at run time.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Monkey-patching 指的是在运行时更改正在运行的程序实例的行为。我第一次遇到这个术语是在我从事Ruby开发工作时，在那里monkey-patching非常常见。在JavaScript中，在运行时“修补”一个函数同样简单。
- en: In chapter 3 we looked at the issue of time management in our tests and code.
    With monkey-patching, we could look at any function, global or local, and replace
    it (for a specific JavaScript scope) with a different implementation. If we wanted
    to patch time, we could monkey-patch the global `Date.now` so that any code from
    that point on would be affected by this change, both production and test code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们探讨了测试和代码中的时间管理问题。通过monkey-patching，我们可以查看任何函数，无论是全局的还是局部的，并将其（对于特定的JavaScript作用域）替换为不同的实现。如果我们想修补时间，我们可以修补全局的
    `Date.now`，这样从那时起的所有代码都会受到影响，包括生产代码和测试代码。
- en: Listing A.1 shows a test that does this for the original production code that
    uses `Date.now` directly. It fakes the global `Date.now` function to control time
    during the test.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.1 展示了一个测试，它为直接使用 `Date.now` 的原始生产代码执行了这一操作。它模拟全局 `Date.now` 函数以在测试期间控制时间。
- en: Listing A.1 Issues in faking the global `Date.now()`
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.1 模拟全局 `Date.now()` 的问题
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Saving the original Date.now
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 保存原始的 Date.now
- en: ❷ Replacing Date.now with a custom date
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用自定义日期替换 Date.now
- en: ❸ Restoring the original Date.now
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 恢复原始的 Date.now
- en: In this listing, we’re replacing the global `Date.now` with a custom date. Because
    this is a global function, other tests can be affected by it, so we clean up after
    ourselves at the end of the test by restoring the original `Date.now` to its rightful
    place.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们正在用自定义日期替换全局 `Date.now`。由于这是一个全局函数，其他测试可能会受到影响，因此我们在测试结束时清理，将原始的 `Date.now`
    恢复到其正确的位置。
- en: There are several major issues in a test like this. First, these asserts throw
    exceptions when they fail, which means if they fail, the restoration of the original
    `Date.now` might never be executed, and other tests will suffer a “dirty” global
    time that might affect them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的测试存在几个主要问题。首先，这些断言在失败时抛出异常，这意味着如果它们失败，原始 `Date.now` 的恢复可能永远不会执行，其他测试将遭受“脏”的全局时间，这可能会影响它们。
- en: It’s also cumbersome to save the time function and then put it back. It’s making
    its mark on the test and making it longer and harder to read, plus harder to write.
    It’s easy to forget to reset the global state.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 保存时间函数然后再将其恢复也很麻烦。这给测试留下了痕迹，使得测试变得更长、更难阅读，而且编写起来也更困难。很容易忘记重置全局状态。
- en: Finally, we’ve impaired parallelism. Jest seems to handle this well, as it creates
    a separate set of dependencies for each test file, but with other frameworks that
    might run tests in parallel, there could be a race condition. Multiple tests can
    change or expect the global time to have a certain value. When running in parallel,
    these tests can collide and create race conditions in the global state and affect
    each other. It’s not required in our case, but if you wanted to eliminate uncertainty,
    Jest allows you to run the Jest command line with the extra `--runInBand` command-line
    parameter to avoid parallelism.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们损害了并行性。Jest似乎处理得很好，因为它为每个测试文件创建了一组独立的依赖关系，但与其他可能并行运行测试的框架相比，可能会出现竞争条件。多个测试可以更改或期望全局时间具有某个值。当并行运行时，这些测试可能会发生冲突，并在全局状态中创建竞争条件，相互影响。在我们的情况下这不是必需的，但如果你想消除不确定性，Jest允许你使用额外的
    `--runInBand` 命令行参数来避免并行性。
- en: We can avoid some of these issues by resorting to the `beforeEach()` and `afterEach()`
    helper functions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `beforeEach()` 和 `afterEach()` 辅助函数来避免一些这些问题。
- en: Listing A.2 Resorting to `beforeEach()` and `afterEach()`
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.2 使用 `beforeEach()` 和 `afterEach()`
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Saving the original Date.now
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 保存原始的 Date.now
- en: ❷ Restoring the original Date.now
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 恢复原始的 Date.now
- en: Listing A.2 solves some of our issues but not all of them. The good part is
    that we don’t need to remember to save and reset `Date.now` anymore, because `beforeEach()`
    and `afterEach()` will take care of it. It’s also now easier to read the tests.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.2 解决了我们的一些问题，但不是全部。好处是，我们不再需要记住保存和重置 `Date.now`，因为 `beforeEach()` 和 `afterEach()`
    会处理它。现在阅读测试也更简单了。
- en: But we still have a potential major issue with parallel tests. Jest is smart
    enough to run parallel tests only per file, which means the tests in this spec
    file will run linearly, but this behavior is not guaranteed for tests in other
    files. Any one of the parallel tests might have their own `beforeEach()` and `afterEach()`
    that reset global state and might affect our tests without realizing it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们仍然存在一个潜在的重大问题，即并行测试。Jest足够智能，只按文件并行运行测试，这意味着这个规范文件中的测试将线性运行，但其他文件中的测试行为没有保证。任何一个并行测试都可能有自己的
    `beforeEach()` 和 `afterEach()` 来重置全局状态，可能会在不经意间影响我们的测试。
- en: I’m not a fan of faking global objects (i.e., “singletons” in most typed languages)
    when I can help it. There are always strings attached—extra coding, extra maintenance,
    extra test fragility, or affecting other tests indirectly and worrying about cleaning
    up all the time are some reasons why. Most of the time, the code comes out better
    when I factor seams into the design of the code under test instead of around it
    in an implicit manner, such as what we just did.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我能帮忙时，我不是很喜欢伪造全局对象（即在大多数类型语言中的“单例”）。总有附加条件——额外的编码、额外的维护、额外的测试脆弱性，或者间接影响其他测试并担心一直清理都是一些原因。大多数时候，当我把接口因素融入到待测试代码的设计中，而不是以隐式方式围绕它时，代码会更好。就像我们刚才做的那样。
- en: Especially when considering that more and more frameworks might start to copy
    Jest’s features and run tests in parallel, global fakes become more and more dangerous.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是考虑到越来越多的框架可能会开始复制Jest的功能并并行运行测试，全局伪造变得越来越危险。
- en: A.2.1 Monkey-patching a function the Jest way
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.1 以Jest的方式猴子补丁一个函数
- en: 'To make the picture more complete, Jest also supports the idea of monkey-patching
    through the use of two functions that work in tandem: `spyOn` and `mockImplementation`.
    Here’s `spyOn`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使画面更完整，Jest还支持通过使用两个协同工作的函数来实现猴子补丁的想法：`spyOn` 和 `mockImplementation`。以下是 `spyOn`：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`spyOn` takes as parameters the scope and the function that requires tracking.
    Note that we need to use a string as a parameter here, which is not really refactoring-friendly—it’s
    easy to miss if we rename that function.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`spyOn` 以作用域和需要跟踪的函数作为参数。请注意，我们在这里需要使用一个字符串作为参数，这并不真的有利于重构——如果我们重命名那个函数，很容易就会错过它。'
- en: A.2.2 Jest spies
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.2 Jest 间谍
- en: The word “spy” has a slightly more interesting shade of grey to it than the
    terms we’ve encountered so far in this book, which is why I don’t like to use
    it too much (or at all) if I can help it. Unfortunately, this word is a major
    part of Jest’s API, so let’s make sure we understand it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: “spy” 这个词比我们在本书中遇到的其他术语要稍微有趣一些，这也是为什么如果可能的话，我不太喜欢过多（或根本不）使用它。不幸的是，这个词是 Jest
    API 的一个重要部分，所以让我们确保我们理解它。
- en: '*xUnit Test Patterns* (Addison-Wesley, 2007), by Gerard Meszaros, says this
    in its discussion of spies: “Use a Test Double to capture the indirect output
    calls made to another component by the system under test (SUT) for later verification
    by the test.” The only difference between a spy and a fake or test double is that
    a spy is calling the *real* implementation of the function underneath, and it
    only tracks the inputs to and outputs from that function, which we can later verify
    through the test. Fakes and test doubles don’t use the real implementation of
    a function.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*xUnit 测试模式*（Addison-Wesley，2007），由 Gerard Meszaros 编著，在其关于间谍的讨论中提到：“使用测试双用来捕获系统（SUT）对另一个组件进行的间接输出调用，以便稍后由测试进行验证。”间谍与存根或测试双重的唯一区别在于，间谍是调用函数底层的真实实现，并且它只跟踪该函数的输入和输出，我们可以通过测试稍后验证这些输入和输出。存根和测试双重不使用函数的真实实现。'
- en: 'My refined definition of a *spy* is pretty close: The act of wrapping a *unit
    of work* with an invisible tracking layer on the *entry points* and *exit points*
    without changing the underlying functionality, for the purpose of tracking its
    inputs and outputs during testing.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我对“间谍”的改进定义非常接近：在测试期间，通过在“工作单元”的“入口点”和“出口点”上添加一个不可见的跟踪层，而不改变其底层功能，以跟踪其输入和输出。
- en: A.2.3 spyOn with mockImplementation()
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.2.3 使用 `mockImplementation()` 的 `spyOn`
- en: This “tracking without changing functionality” behavior that is inherent to
    spies also explains why just using `spyOn` won’t be enough for us to fake `Date.now`.
    It’s only meant for tracking, not faking.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍固有的这种“跟踪而不改变功能”的行为也解释了为什么仅仅使用 `spyOn` 并不足以让我们伪造 `Date.now`。它仅用于跟踪，而不是伪造。
- en: 'To actually *fake* the `Date.now` function and turn it into a *stub*, we’ll
    use the confusingly named `mockImplementation` to replace the underlying unit
    of work’s functionality:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际伪造 `Date.now` 函数并将其转换为存根，我们将使用令人困惑的命名 `mockImplementation` 来替换底层工作单元的功能：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Too much “mock”
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: “mock” 过多
- en: If I were in a position to decide on a new name for `mockImplementation,` I’d
    name it `fakeImplementation`, because it can easily be used to create either stubs
    that return data or mocks that verify the data being sent into them as parameters.
    The word “mock” is used far too often in our industry to signify anything that
    isn’t real, when the distinction could help us make less brittle tests. “Mock”
    in the name immediately implies that this is something we’ll verify against later
    on, at least when I look at it, and given how I treat the ideas of mocks versus
    stubs in this book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我能决定为 `mockImplementation` 起一个新的名字，我会叫它 `fakeImplementation`，因为它可以很容易地用来创建返回数据的存根或验证传入参数的模拟。在我们的行业中，“mock”
    这个词被过度使用，用来表示任何不真实的东西，而区分这一点可以帮助我们编写更稳健的测试。“mock” 在名称中立即暗示了这是我们稍后会验证的东西，至少当我看的时候，考虑到我在本书中对待模拟和存根的观点。
- en: Jest is littered with overuse of the word “mock,” especially when comparing
    its API to an isolation framework such as Sinon.js, which uses naming that is
    less surprising and avoids using “mock” where it’s not necessary.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 中“mock”这个词的使用过于频繁，尤其是在将其 API 与 Sinon.js 这样的隔离框架进行比较时，Sinon.js 使用的是不那么令人惊讶的命名方式，并且避免了在不必要的地方使用“mock”。
- en: Here’s how the `spyOn` and `mockImplementation` combo looks in our code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在我们的代码中看到 `spyOn` 和 `mockImplementation` 组合的示例。
- en: Listing A.3 Using `jest.SpyOn()` to monkey-patch `Date.now()`
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.3 使用 `jest.SpyOn()` 来 monkey-patch `Date.now()`
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see that the last piece of the puzzle in the code is inside `afterEach()`.
    We use another function called `jest`.`restoreAllMocks`, which is Jest’s way of
    resetting any global state that has been spied on to its original implementation
    with no extra fake layers around it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到代码中最后一部分是在`afterEach()`中。我们使用另一个名为`jest.restoreAllMocks`的函数，这是Jest重置任何被监视的全局状态到其原始实现的方式，没有围绕它的额外模拟层。
- en: Note that even though we are using a spy, we’re not verifying that the function
    was actually called. Doing that would mean we’re using it as a mock object, which
    we are not. We’re merely using it as a stub. With Jest, we have to go through
    a “spy” to stub stuff out.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们使用了监视器，但我们并没有验证函数是否实际上被调用。那样做意味着我们将其用作模拟对象，而我们并不是。我们只是将其用作存根。在Jest中，我们必须通过“监视器”来存根东西。
- en: All of the advantages and disadvantages I’ve listed before still apply here.
    I prefer using parameters when it makes sense, instead of using global functions
    or variables.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前列出的所有优缺点在这里仍然适用。当有道理时，我更喜欢使用参数，而不是使用全局函数或变量。
- en: A.3 Ignoring a whole module with Jest is simple
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.3 使用Jest忽略整个模块很简单
- en: Of all the techniques mentioned in this appendix, this is the safest because
    it does not deal with the internal workings of the unit under test. It just ignores
    things in a broad manner.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中提到的所有技术中，这是最安全的，因为它不涉及被测试单元的内部工作原理。它只是以广泛的方式忽略事物。
- en: If we don’t care about the module at all during our tests, and we just want
    to get it out of the way of our scenario without getting any fake data back from
    it, a simple call to `jest.mock('module` `path')` at the top of the test file
    will do just fine, without too much fuss.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在测试过程中根本不关心模块，我们只想让它从我们的场景中移除，而不从它那里获取任何模拟数据，那么在测试文件顶部简单调用`jest.mock('module
    path')`就足够了，无需太多麻烦。
- en: The next section helps if you want to simulate custom data in each test from
    a fake module, which makes us go through more hoops.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分有助于你从模拟模块中模拟每个测试的定制数据，这让我们不得不跳过更多的圈子。
- en: A.4 Faking module behavior in each test
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A.4 在每个测试中模拟模块行为
- en: Faking a module basically means faking a global object that gets loaded whenever
    `import` or `require` is used for the first time by the code under test. Depending
    on the test framework we’re using, the module might be cached internally or through
    the standard Node.js `require.cache` mechanism. Since this only happens once,
    when our test imports the system under test, we have a bit of an issue when we’re
    trying to fake different behavior or data for different tests in the same file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟模块基本上意味着模拟一个全局对象，当被测试代码首次使用`import`或`require`时，该对象会被加载。根据我们使用的测试框架，模块可能通过内部缓存或通过标准的Node.js
    `require.cache`机制进行缓存。由于这只会发生一次，当我们尝试在同一个文件中对不同测试进行不同行为或数据的模拟时，我们就会遇到一些问题。
- en: 'To fake custom behavior for our fake module, we need to take care of the following
    in our tests: clean up the required module from memory, replace it, re-require
    it, and get the code under test to use the new module instead of the original
    one by requiring our code under test again. That’s quite a bit. I call this pattern
    Clear-Fake-Require-Act (CFRA):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟我们模拟模块的定制行为，我们需要在我们的测试中注意以下事项：从内存中清理所需的模块，替换它，重新导入它，并通过再次导入我们的被测试代码来让被测试代码使用新的模块而不是原始模块。这相当多。我称这种模式为Clear-Fake-Require-Act
    (CFRA)：
- en: '*Clear*—Before each test, clear all the cached or required modules in the test
    runner’s memory.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*清晰*—在每次测试之前，清除测试运行器内存中所有缓存的或必需的模块。'
- en: 'During the arrange part of the test:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试的安排部分：
- en: '*Fake*—Fake the module that will be required by the `require` action invoked
    by the test code.'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*模拟*—模拟将被测试代码中`require`动作调用的模块。'
- en: '*Require*—Require the code under test just before invoking it.'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*导入*—在调用之前导入被测试代码。'
- en: '*Act*—Invoke the entry point.'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*行动*—调用入口点。'
- en: If we forget any of these steps, or perform them in the wrong order, or not
    at the right point in the test’s life cycle, there’ll be a lot of question marks
    when we execute the test and things seem not to be faking correctly. Worse, they
    might *sometimes* work correctly. Shudder.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记了这些步骤，或者以错误的顺序执行它们，或者在测试的生命周期中不正确的点执行，当我们执行测试时，会出现很多问号，事情似乎没有正确模拟。更糟糕的是，它们*有时*可能工作正确。令人毛骨悚然。
- en: Let’s look at a real example, starting with the following code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个真实示例，从以下代码开始。
- en: Listing A.4 Code under test with a dependency
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.4 带有依赖关系的测试代码
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ The dependency to fake
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 模拟的依赖项
- en: The first line contains the dependency we need to break in our test. It’s the
    `getAllMachines` function, being destructured from `my-data-module`. Because we
    are using the function detached from its parent module, we can’t just fake functions
    on the parent module and expect our tests to pass. We have to get the *destructured*
    function to get a fake function during the destructuring process, and that’s where
    the tricky part comes in.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包含我们在测试中需要断开依赖的函数`getAllMachines`，它是从`my-data-module`解构出来的。因为我们使用的是与其父模块分离的函数，所以我们不能仅仅伪造父模块上的函数并期望测试通过。我们必须在解构过程中获取解构的函数，以便在解构过程中获得伪造的函数，这就是难点所在。
- en: A.4.1 Stubbing a module with vanilla require.cache
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.1 使用纯`require.cache`伪造模块
- en: Before we use Jest and other frameworks to fake a whole module, let’s see how
    we can achieve this effect and explore what’s going on in the various frameworks.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用Jest和其他框架伪造整个模块之前，让我们看看我们如何实现这种效果，并探索各种框架中发生的事情。
- en: You can use the CFRA pattern without using any framework by using `require.cache`
    directly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接使用`require.cache`而不使用任何框架来使用CFRA模式。
- en: Listing A.5 Stubbing with `require.cache`
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.5 使用`require.cache`伪造
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Clear
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 清除
- en: ❷ Fake
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 伪造
- en: ❸ Require
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 需要
- en: ❹ Act
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 执行
- en: Unfortunately, this code will not work with Jest, because Jest ignores `require.cache`
    and implements its own caching algorithm internally. To execute this test, run
    it directly through the Node.js command line. You’ll see that I’ve implemented
    my own little `check()` function, so that I don’t use Jest’s API. This test will
    work just fine when using a framework such as Jasmine.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这段代码与Jest不兼容，因为Jest忽略`require.cache`并内部实现了自己的缓存算法。要执行此测试，请直接通过Node.js命令行运行它。你会看到我实现了一个小小的`check()`函数，这样我就不用使用Jest的API。当使用Jasmine等框架时，这个测试将正常工作。
- en: Remember this line in our code under test?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们被测试代码中的这一行？
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our tests need to *execute* this destructuring every time we want to return
    a fake value. That means we’ll need to execute a require or import of the unit
    under test from our test code, not at the top of the file, but somewhere in the
    middle of our test execution. You can see where this happens in the following
    part of listing A.5:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试需要在想要返回伪造值时执行这种解构。这意味着我们需要在我们的测试代码中执行被测试单元的require或import，而不是在文件顶部，而是在测试执行的中间部分。你可以在A.5列表的以下部分看到这是如何发生的：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is because of this destructuring code pattern that modules are not just objects
    with properties, for which normal monkey-patching techniques can be used. We need
    to jump through more hoops.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这种解构代码模式，模块不仅仅是具有属性的普通对象，可以使用正常的猴子补丁技术。我们需要跳过更多的障碍。
- en: 'Let’s map the four CFRA steps to the code in listing A.5:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将四个CFRA步骤映射到A.5列表中的代码：
- en: '*Clear*—This is part of the `fakeDataFromModule` function, which is invoked
    during the test.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*清除*—这是在测试期间调用的`fakeDataFromModule`函数的一部分。'
- en: '*Fake*—we are telling `require.cache`’s dictionary entry to return a custom
    object that seems to represent what a module looks like, but which has a custom
    implementation that returns `fakeData`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*伪造*—我们正在告诉`require.cache`的字典条目返回一个看似代表模块外观的自定义对象，但实际上它有一个自定义实现，返回`fakeData`。'
- en: '*Require*—We are requiring the code under test as part of the `requireAndCall_
    findRecentlyRebooted()` function, which is invoked during the test.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*需要*—我们在`requireAndCall_findRecentlyRebooted()`函数中作为部分要求被测试的代码，该函数在测试期间被调用。'
- en: '*ACT*—This is part of the same `requireAndCall_findRecentlyRebooted()` function
    that is invoked by the test.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ACT*—这是由测试调用的同一个`requireAndCall_findRecentlyRebooted()`函数的一部分。'
- en: Notice that we do not use `beforeEach()` for this test. We are doing everything
    directly from the test, because each test will fake its own data from the module.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有在这个测试中使用`beforeEach()`。我们直接从测试中做所有事情，因为每个测试都会从模块中伪造自己的数据。
- en: A.4.2 Stubbing custom module data with Jest is complicated
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.2 使用Jest伪造自定义模块数据很复杂
- en: We’ve seen the “vanilla” way of stubbing custom module data. That’s not usually
    how you’d do it if you’re using Jest, though. Jest contains several confusingly
    and very closely named functions that deal with clearing and faking modules, including
    `mock`, `doMock`, `genMockFromModule`, `resetAllMocks`, `clearAllMocks`, `restoreAllMocks`,
    `resetModules` and more. Yay!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了伪造自定义模块数据的“纯”方法。但如果你使用Jest，这通常不是你会这样做的方式。Jest包含几个名称相似且非常接近的函数，它们处理清除和伪造模块，包括`mock`、`doMock`、`genMockFromModule`、`resetAllMocks`、`clearAllMocks`、`restoreAllMocks`、`resetModules`等。太棒了！
- en: The code I’ll recommend here feels the cleanest and simplest of all of Jest’s
    APIs in terms of readability and maintainability. I do cover other variations
    on it in the GitHub repository at [https://github.com/royosherove/aout3-samples](https://github.com/royosherove/aout3-samples)
    and under the “other-variations” folder at [http://mng.bz/Jddo](http://mng.bz/Jddo).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我将推荐的代码在可读性和可维护性方面是 Jest 所有 API 中最干净、最简单的。我在 GitHub 仓库 [https://github.com/royosherove/aout3-samples](https://github.com/royosherove/aout3-samples)
    以及在 “other-variations” 文件夹 [http://mng.bz/Jddo](http://mng.bz/Jddo) 中涵盖了它的其他变体。
- en: 'This is the common pattern for faking a module with Jest:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 Jest 模拟模块的常见模式：
- en: Require the module you’d like to fake in your own tests.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的测试中引入你想要模拟的模块。
- en: Stub out the module above the tests with `jest.mock(modulename)`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试上方模块中使用 `jest.mock(modulename)` 熄灭。
- en: In each test, tell Jest to override the behavior of one of the functions in
    that module by using `[modulename].function.mockImplementation()` or `mockImplementationOnce()`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试中，告诉 Jest 通过使用 `[modulename].function.mockImplementation()` 或 `mockImplementationOnce()`
    来覆盖该模块中某个函数的行为。
- en: The following is what it might look like.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例。
- en: Listing A.6 Stubbing a module with Jest
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.6 使用 Jest 存根模块
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here’s how you can approach each part of CFRA with Jest.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可以如何使用 Jest 接近 CFRA 的每个部分的示例。
- en: '| Clear | `jest.resetAllMocks` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 清除 | `jest.resetAllMocks` |'
- en: '| Fake | `jest.mock()+[fake].mockImplementation()` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 模拟 | `jest.mock()+[fake].mockImplementation()` |'
- en: '| Require | Regularly at the top of the file |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 需要 | 定期在文件顶部 |'
- en: '| Act | Regularly |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 行动 | 定期 |'
- en: The `jest.mock` and `jest.resetAllMocks` methods are all about faking the module
    and resetting the fake implementation to an empty one. Note that the module is
    still fake after `resetAllMocks`. Only its behavior is reset to the default fake
    implementation. Calling it without telling it what to return will yield weird
    errors.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`jest.mock` 和 `jest.resetAllMocks` 方法都是关于模拟模块并将模拟实现重置为空的。注意，在 `resetAllMocks`
    之后模块仍然是模拟的。只有其行为被重置为默认的模拟实现。不指定返回值而调用它将产生奇怪的错误。'
- en: With the `FromModule` method, we replace the default implementation with a function
    that returns our hardcoded values in each test.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `FromModule` 方法，我们在每个测试中用返回我们硬编码值的函数替换默认实现。
- en: We could have used `mockImplementationOnce()` to do mocking, instead of the
    `fakeDataFromModule()` method, but I find that this can create very brittle tests.
    With stubs, we normally shouldn’t care how many times they return the fake values.
    If we did care how many times they were called, we would use them as *mock* objects,
    and that’s the subject of chapter 4.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用 `mockImplementationOnce()` 来进行模拟，而不是使用 `fakeDataFromModule()` 方法，但我发现这可能会创建非常脆弱的测试。使用存根时，我们通常不需要关心它们返回模拟值多少次。如果我们关心它们被调用的次数，我们会将它们用作
    *模拟* 对象，这是第 4 章的主题。
- en: A.4.3 Avoid Jest’s manual mocks
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.3 避免使用 Jest 的手动模拟
- en: 'Jest contains the idea of *manual mocks*, but don’t use them if you can help
    it. This technique requires you to put a special __mocks__ folder in your tests
    that contain hardcoded fake module code, with a naming convention based on the
    module’s name. This will work, but the maintainability costs are too high when
    you want to control the fake data. The readability costs are too high as well,
    as it increases scroll fatigue to an unneeded level, requiring us to switch between
    multiple files to understand a test. You can read more about manual mocks in the
    Jest documentation: [https://jestjs.io/docs/en/manual-mocks.html](https://jestjs.io/docs/en/manual-mocks.html).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 包含了 *手动模拟* 的概念，但如果可能的话，不要使用它们。这项技术要求你在测试中放置一个特殊的 __mocks__ 文件夹，其中包含基于模块名称的硬编码的模拟模块代码。这会起作用，但当你想要控制模拟数据时，维护成本会很高。可读性成本也很高，因为它将滚动疲劳增加到不必要的水平，需要我们在多个文件之间切换以理解测试。你可以在
    Jest 文档中了解更多关于手动模拟的信息：[https://jestjs.io/docs/en/manual-mocks.html](https://jestjs.io/docs/en/manual-mocks.html)。
- en: A.4.4 Stubbing a module with Sinon.js
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.4 使用 Sinon.js 存根模块
- en: For comparison, and so that you can see that the pattern of CFRA repeats in
    other frameworks, here’s an implementation of the same test with Sinon.js—a framework
    dedicated to creating stubs.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较，并且让你看到 CFRA 的模式在其他框架中重复出现，这里是一个使用 Sinon.js（一个专门用于创建存根的框架）实现相同测试的示例。
- en: Listing A.7 Stubbing a module with Sinon.js
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 A.7 使用 Sinon.js 存根模块
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let’s map the relevant parts with Sinon.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 Sinon 将相关部分映射出来。
- en: '| Clear | Before each test:`jest.resetModules + re-require fake module` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 清除 | 在每个测试之前：`jest.resetModules + 重新要求模拟模块` |'
- en: '| Fake | Before each test:`sinon.stub(module,''function'')``.returns(fakeData)`
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 模拟 | 在每次测试前:`sinon.stub(module,''function'')` `.returns(fakeData)` |'
- en: '| Require (module under test) | Before invoking the entry point |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 需求（待测试模块） | 在调用入口点之前 |'
- en: '| Act | After re-requiring the module under test |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 行动 | 在重新要求待测试模块后 |'
- en: A.4.5 Stubbing a module with testdouble
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A.4.5 使用testdouble模拟模块
- en: Testdouble is another isolation framework that can easily be used to stub things
    out. Due to the refactoring already done in previous tests, the code changes are
    minimal.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Testdouble是另一个可以轻松用于模拟事物的隔离框架。由于之前的测试中已经完成的重构，代码更改很小。
- en: Listing A.8 Stubbing a module with testdouble
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表A.8 使用testdouble模拟模块
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here are the important parts with testdouble.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了使用testdouble的重要部分。
- en: '| Clear | Before each test:`jest.resetModules + require(''testdouble'');``require(''testdouble-jest'')``(td,
    jest);` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 清晰 | 在每次测试前:`jest.resetModules + require(''testdouble'');` `require(''testdouble-jest'')`
    `(td, jest);` |'
- en: '| Fake | Before each test:`Td.replace(module, fake object)` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 模拟 | 在每次测试前:`Td.replace(module, fake object)` |'
- en: '| Require (module under test) | Before invoking the entry point |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 需求（待测试模块） | 在调用入口点之前 |'
- en: '| Act | After re-requiring the module under test |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 行动 | 在重新要求待测试模块后 |'
- en: The test implementation is exactly the same as with the Sinon example. We’re
    also using `testdouble-jest`, as it connects to the Jest module replacement facility.
    This is not needed if we’re using a different test framework.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 测试实现与Sinon示例完全相同。我们也在使用`testdouble-jest`，因为它连接到Jest模块替换功能。如果我们使用不同的测试框架，则不需要这样做。
- en: These techniques *will* work, but I recommend staying away from them unless
    there’s absolutely no other way. There is almost always another way, and you can
    see many of those in chapter 3.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术*会*起作用，但我建议除非绝对没有其他方法，否则请远离它们。几乎总是有另一种方法，你可以在第3章中看到其中许多。
