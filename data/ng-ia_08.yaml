- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Forms
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 表单
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Creating forms using Angular’s forms libraries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular的表单库创建表单
- en: Deciding between using Reactive or Template forms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用响应式表单或模板表单之间做出决定
- en: Validating forms with custom logic
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义逻辑验证表单
- en: Accessing data and watching input changes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问数据和观察输入变化
- en: Submitting form data and handling errors gracefully
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交表单数据并优雅地处理错误
- en: Creating custom form controls
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义表单控件
- en: Just about every application uses forms in some way, if only to do something
    simple like log in or manage settings. HTML comes with a number of form elements
    by default, such as inputs, selects, and buttons, and Angular provides a way to
    use these native elements and add some power to them. We’ve used forms in several
    previous examples, but in this chapter we’ll dig into them much more completely.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个应用程序都以某种方式使用表单，即使只是做一些简单的事情，比如登录或管理设置。HTML默认提供了一些表单元素，如输入、选择和按钮，Angular提供了一种方法来使用这些原生元素并为其添加一些功能。我们在之前的几个例子中使用了表单，但在本章中，我们将更深入地探讨它们。
- en: 'Angular provides two approaches to building forms: *reactive forms* and *template
    forms*. I’ll discuss the differences at length shortly, though they’re largely
    in whether you define the form in your controller or in the template. You’re not
    limited to choosing only one or the other form, but typically applications will
    try to remain consistent with one of them.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了两种构建表单的方法：*响应式表单*和*模板表单*。我将在稍后详细讨论它们之间的区别，尽管它们主要在于你是在控制器中还是在模板中定义表单。你不必局限于只选择其中一种表单，但通常应用程序会尝试保持与其中之一的一致性。
- en: With template forms, we’ll see how to describe your forms primarily using the
    NgModel directive, which is used to define the form structure. With reactive forms,
    you declare the form structure yourself in the controller, and the template renders
    it out.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板表单时，我们将看到如何主要使用NgModel指令来描述你的表单，该指令用于定义表单结构。使用响应式表单时，你自己在控制器中声明表单结构，然后模板将其渲染出来。
- en: As complex as forms can become, the basics are fairly standard in all areas.
    There are form controls (fields that hold values like inputs, selects, and so
    on), and there are form buttons (like Save, Cancel, or Reset). The same holds
    true when working with forms in Angular—the basics remain consistent regardless
    of how complex the form becomes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管表单可能变得非常复杂，但所有领域的基本原则都是相当标准的。有表单控件（如输入、选择等字段，它们持有值），还有表单按钮（如保存、取消或重置）。当在Angular中处理表单时，基本原则保持一致，无论表单变得多么复杂。
- en: There are often situations where a form requires the use of additional third-party
    components to help, such as a date picker or range slider. Browsers may implement
    some newer form controls, but they’re rarely standard, and other browsers might
    not support them at all. Although we’re not going to focus on creating custom
    components that act like form controls, there are many great libraries that provide
    you additional features, or you can certainly build your own custom form controls
    by reviewing the documentation. I personally avoid creating these unless absolutely
    necessary, which it rarely is.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 经常会有这样的情况，表单需要使用额外的第三方组件来帮助，例如日期选择器或范围滑块。浏览器可能实现了一些新的表单控件，但它们很少是标准的，其他浏览器可能根本不支持它们。尽管我们不会专注于创建类似表单控件的自定义组件，但有许多优秀的库提供了额外的功能，或者你可以通过查阅文档来构建自己的自定义表单控件。我个人只有在绝对必要时才会创建这些组件，这种情况很少发生。
- en: 9.1 Setting up the chapter example
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 设置本章示例
- en: We’re going to build a new application that helps us manage invoices and customers.
    Imagine you’re a freelancer or small business owner and you have customers to
    manage. This application would be a good tool for keeping track of sending invoices
    and making sure you get paid (which is pretty important, right?).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个新的应用程序，帮助我们管理发票和客户。想象一下，你是一名自由职业者或小型企业主，你需要管理客户。这个应用程序将是一个很好的工具，用于跟踪发送发票并确保你得到支付（这很重要，对吧？）。
- en: The forms themselves are intentionally not complex, but they do demonstrate
    most of the needs for forms succinctly. You can take the examples you see in this
    chapter and translate them into larger, more complex forms without having to learn
    additional concepts. The only difference tends to be the scale.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 表单本身故意不复杂，但它们确实简洁地展示了表单的大部分需求。你可以将本章中看到的示例转换为更大的、更复杂的表单，而无需学习额外的概念。唯一的区别通常在于规模。
- en: The application is also designed for the mobile form factor, which is a nice
    little twist from our previous examples. It uses the Covalent UI library, from
    Teradata, which extends the concepts and Angular Material Design library. If you
    weren’t aware, mobile browsers tend to have the best support for the latest HTML5
    input types, such as search or number fields, which we will use for our example.
    I recommend using Chrome for this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序还针对移动设备形态进行了设计，这与我们之前的示例形成了一个很好的小转折。它使用来自Teradata的Covalent UI库，该库扩展了Angular
    Material Design库的概念。如果您不知道，移动浏览器通常对最新的HTML5输入类型（如搜索或数字字段）的支持最好，这些我们将用于我们的示例。我建议您在本章中使用Chrome。
- en: Chrome has a useful device emulator in the developer tools, as shown in [figure
    9.1](#figure9.1), and I suggest that you use it while you’re building and using
    this application. It allows you to emulate the dimensions of various mobile devices
    and get a sense of how your application would look on those sizes. It doesn’t
    really emulate the device in a true way, but it does provide an easy way to preview.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome的开发者工具中有一个有用的设备模拟器，如图9.1所示，我建议您在构建和使用此应用程序时使用它。它允许您模拟各种移动设备的尺寸，并了解您的应用程序在这些尺寸上的外观。它并不真正以真实的方式模拟设备，但它确实提供了一个方便的预览方式。
- en: '![c09-1.png](image_fi/293313c09/c09-1.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![c09-1.png](image_fi/293313c09/c09-1.png)'
- en: '[**Figure 9.1**](#figureanchor9.1) Use device tools in Chrome developer tools
    to simulate mobile devices.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图9.1**](#figureanchor9.1) 使用Chrome开发者工具中的设备工具模拟移动设备。'
- en: 'Like other examples, this one is available on GitHub, and you can get the source
    code by cloning the repo. Make sure to check out the right tag when we start so
    you can code along, or look at the latest master for the final version:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如其他示例一样，这个示例也托管在GitHub上，您可以通过克隆仓库来获取源代码。确保我们在开始时检查正确的标签，这样您就可以一起编码，或者查看最新的master分支以获取最终版本：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Otherwise, you can download the archived files from [https://github.com/angular-in-action/invoice/archive/start.zip](https://github.com/angular-in-action/invoice/archive/start.zip)
    and unzip the files.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您可以从[https://github.com/angular-in-action/invoice/archive/start.zip](https://github.com/angular-in-action/invoice/archive/start.zip)下载存档文件，并解压这些文件。
- en: When you start the application, you’ll notice a number of services and components
    are there already. I’ve provided the majority of the code ahead of time so we
    can focus on the key features for forms. Even the form components are there, with
    standard HTML forms in place. They don’t currently do anything when you try to
    save them, which is what we’ll be updating and implementing in this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启动应用程序时，您会注意到已经存在许多服务和组件。我提前提供了大部分代码，这样我们就可以专注于表单的关键功能。即使表单组件也存在，它们使用了标准的HTML表单。当您尝试保存它们时，它们目前不会执行任何操作，这正是我们将在本章中更新和实现的内容。
- en: 'You’ll need `npm install` for all the dependencies, and then you run `ng serve`
    to start the local development server. That isn’t all, though. This app has a
    local API server that we need to run also. You’ll need to open another terminal
    session and run the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要运行`npm install`来安装所有依赖项，然后运行`ng serve`来启动本地开发服务器。但这还不是全部。此应用程序还有一个本地API服务器，我们同样需要运行。您需要打开另一个终端会话并运行以下命令：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will start up a local server that provides our app data. As you save and
    edit records, the data will persist into a local file called db.json, which is
    important for our app.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个本地服务器，提供我们的应用程序数据。当您保存和编辑记录时，数据将持久保存在名为db.json的本地文件中，这对于我们的应用程序很重要。
- en: There may be a few warnings in the browser console when you run the example—you
    can safely ignore those. They refer to features that aren’t necessary for the
    chapter example.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行示例时，浏览器控制台可能会有一些警告——您可以安全地忽略这些警告。它们指的是本章示例中不需要的功能。
- en: Now, before we get into the forms, let’s review the rest of the app.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们进入表单之前，让我们回顾一下应用程序的其余部分。
- en: 9.1.1 Review the app before starting
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 在开始之前回顾应用程序
- en: There are six routable views in this application. Let’s talk briefly about some
    of the ones that don’t contain forms. We’ll focus only on two of the routes in
    the chapter; we’ll build one of the forms with template-driven forms and the other
    with a reactive form. Let’s take a look at several of the screens of the application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序中有六个可路由视图。让我们简要地谈谈其中一些不包含表单的视图。我们将专注于本章中的两个路由；我们将使用模板驱动表单构建其中一个表单，另一个使用响应式表单。让我们看看应用程序的几个屏幕。
- en: Figure 9.2 shows some of the screens for the application, such as the list,
    detail, and form views. There are two list views, one for customers and one for
    invoices. These are both fairly simple in that they load a list from the API and
    render it. They also include a button that will take you to a form to create a
    new record. You can see these two in the Invoices and Customers components.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2展示了应用程序的一些屏幕，例如列表、详细和表单视图。有两个列表视图，一个用于客户，一个用于发票。这两个列表视图都相当简单，因为它们从API加载一个列表并渲染它。它们还包括一个按钮，可以带您进入表单以创建新记录。您可以在发票和客户组件中看到这两个视图。
- en: '![c09-2.png](image_fi/293313c09/c09-2.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![c09-2.png](image_fi/293313c09/c09-2.png)'
- en: '**Figure 9.2** Invoicing application screens, emulated in a mobile device size.
    From left to right: list of invoices, list of customers, invoice detail view,
    and customer form.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**图9.2** 仿制在移动设备大小的发票应用程序屏幕。从左到右：发票列表、客户列表、发票详细视图和客户表单。'
- en: The two detail views for a customer and invoice are also quite similar in that
    they simply show the relevant data for a given record. There is a button that
    allows you to edit that record as well. You can preview these in the Invoice and
    Customer components.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 客户和发票的详细视图也非常相似，因为它们只是显示给定记录的相关数据。还有一个按钮允许您编辑该记录。您可以在发票和客户组件中预览这些视图。
- en: Finally, the two views we’ll work on are the form views. The customer or invoice
    form will let you create or edit an existing record, and the form fields needed
    are already provided with standard HTML. We’ll be updating these forms and the
    controllers to handle the save, delete, and cancel events. These can be found
    in the InvoiceForm and CustomerForm components.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将要工作的两个视图是表单视图。客户或发票表单将允许您创建或编辑现有记录，所需的表单字段已经通过标准HTML提供。我们将更新这些表单和控制器以处理保存、删除和取消事件。这些可以在InvoiceForm和CustomerForm组件中找到。
- en: Inside of the components you’ll see a few new things. The `TdLoading` directive
    is a feature from the Covalent library to display a loading indicator while data
    is being loaded. The `MdInput` directive will make an input Material Design–compliant.
    There are several other elements that start with `Md-`, which are all from the
    Material Design library and are UI components for structure or controls. It’s
    best to review the Covalent and Material Design documentation for additional questions
    you may have about the use of these tools. Please note the specific version being
    used in the package.json file and make sure you’re looking it up correctly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件内部，您会看到一些新内容。`TdLoading`指令是Covalent库中的一个功能，用于在加载数据时显示加载指示器。`MdInput`指令将使输入符合Material
    Design规范。还有几个以`Md-`开头的其他元素，它们都是来自Material Design库的UI组件，用于结构或控件。最好查阅Covalent和Material
    Design文档，以解决您可能对这些工具的使用有疑问的问题。请注意package.json文件中使用的特定版本，并确保您正确地查找它。
- en: There are also services for the customers and invoices APIs. You may want to
    review them as a way to extend one service to create another. Both the Invoices
    and Customers services extend the Rest service, which implements the basic API
    calls needed. The specialized instances (Invoices and Customers) provide a single
    property that’s used by the Rest service to construct URLs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户和发票API也有服务。您可能想审查它们，作为扩展一个服务以创建另一个服务的方法。发票和客户服务都扩展了Rest服务，该服务实现了所需的API调用。特殊实例（发票和客户）提供了一个属性，该属性由Rest服务用于构造URL。
- en: All right, let’s create the customer form using the template-driven approach.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们使用模板驱动方法创建客户表单。
- en: 9.2 Template-driven forms
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 模板驱动表单
- en: We’ve already used template-driven forms in several of our examples, and the
    key marker is when you see the `NgModel` directive on a form control. AngularJS
    developers will be familiar with the patterns described in this section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的几个示例中使用了模板驱动表单，关键标志是您在表单控件上看到`NgModel`指令。AngularJS开发者将熟悉本节中描述的模式。
- en: Template forms are named primarily because the form controls are defined in
    the template of the component. In this case, you can think of the template as
    having the final say about what is part of the form or not. For example, if you
    have an `input` element in the page that is part of the form that is wired up
    into the form controls, then it will also be defined in the controller.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 模板表单之所以得名，主要是因为表单控件是在组件的模板中定义的。在这种情况下，您可以将模板视为最终决定哪些内容是表单的一部分。例如，如果您在页面上有一个作为表单一部分并连接到表单控件的`input`元素，那么它也将由控制器定义。
- en: The primary goal of a form is to be able to synchronize the data in the view
    with data in the controller so it can be submitted to be handled. Secondary goals
    are to perform tasks like validation, notify about errors, and handle other events
    like cancel.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表单的主要目标是能够同步视图中的数据与控制器中的数据，以便可以提交进行处理。次要目标是执行验证、通知错误以及处理取消等其他事件。
- en: Because the form is primarily defined in the template layer, it also means that
    validation errors are managed primarily through the template. We’ll look at how
    to add validation and alert the user about invalid fields.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因为表单形式主要定义在模板层，这也意味着验证错误主要是通过模板来管理的。我们将探讨如何添加验证并提醒用户关于无效字段。
- en: In [figure 9.3](#figure9.3) you can see the customer form that we’ll be building
    in this section. The three fields will be part of the form data and will allow
    us to capture the input for processing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图9.3](#figure9.3) 中，你可以看到我们将在此部分构建的客户表单。这三个字段将是表单数据的一部分，并允许我们捕获输入以进行处理。
- en: To get started, we need to start working with our form controls and wire them
    up so that they bind the model between both the controller and the template using
    `NgModel`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要开始处理我们的表单控件并将它们连接起来，以便使用 `NgModel` 在控制器和模板之间绑定模型。
- en: 9.2.1 Binding model data to inputs with NgModel
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 使用 NgModel 将模型数据绑定到输入
- en: 'Let’s take a single form control to begin with and see what it takes to turn
    it into something Angular can use. In the CustomerForm component, you should see
    this input:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从单个表单控件开始，看看将其转换为 Angular 可以使用的内容需要什么。在 CustomerForm 组件中，你应该看到这个输入：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![c09-3.png](image_fi/293313c09/c09-3.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![c09-3.png](image_fi/293313c09/c09-3.png)'
- en: '[**Figure 9.3**](#figureanchor9.3) Customer form with three fields to bind
    data to'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图9.3**](#figureanchor9.3) 客户表单，包含三个字段以绑定数据'
- en: 'Right now it’s just a normal form element (with the `MdInput` to make it Material
    Design), but by adding the `NgModel` directive we can turn it into an Angular
    form control. In the process, we can also remove the `value` attribute, as it’s
    no longer needed:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 目前它只是一个普通的表单元素（使用 `MdInput` 使其成为 Material Design），但通过添加 `NgModel` 指令，我们可以将其转换为
    Angular 表单控件。在这个过程中，我们还可以删除 `value` 属性，因为它不再需要：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `NgModel` directive is part of the Forms module and will ensure that the
    value of the form control is set based on the `customer` property value from the
    controller. But it also sets the value into the controller when it’s changed in
    the view. If you look at the controller, there is no such property, and `NgModel`
    will create it for you.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgModel` 指令是表单模块的一部分，并确保表单控件的值基于控制器中的 `customer` 属性值设置。但是，当它在视图中更改时，它也会将其值设置到控制器中。如果你查看控制器，将没有这样的属性，`NgModel`
    将为你创建它。'
- en: You should recall the `[()]` syntax from earlier chapters, but to refresh your
    memory, it’s a way of doing two-way data binding in Angular. That means the controller
    will now have a property called `customer`, and if the view or controller changes
    that value, the other will instantly be updated as well. AngularJS developers
    will know this concept well, and it exists in Angular as well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记得之前章节中的 `[()]` 语法，但为了刷新你的记忆，它是在 Angular 中进行双向数据绑定的一种方式。这意味着控制器现在将有一个名为 `customer`
    的属性，如果视图或控制器更改该值，另一个也会立即更新。AngularJS 开发者会很好地了解这个概念，它也存在于 Angular 中。
- en: Let’s go ahead and wire up all of the form controls with `NgModel`. In the CustomerForm
    template, we’ll need to modify the existing form controls, as you see bolded in
    the following listing. Open src/app/customer-form/customer-form.component.html
    and update it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用 `NgModel` 将所有表单控件连接起来。在 CustomerForm 模板中，我们需要修改现有的表单控件，如下所示。打开 src/app/customer-form/customer-form.component.html
    并更新它。
- en: '**Listing 9.1** CustomerForm using NgModel'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表9.1** 使用 NgModel 的 CustomerForm'
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In these form controls, we now have them wired up to do two-way binding using
    `NgModel`. Notice that we’re also setting the model values as part of the `customer`
    property, so the data is stored in one object. Except for a form that has only
    one control, it’s highly recommended to always use models like this. It will help
    us later to have all the customer data stored on the same object instead of on
    different properties of the controller.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些表单控件中，我们现在使用 `NgModel` 来实现双向绑定。请注意，我们还将模型值设置为 `customer` 属性的一部分，因此数据存储在一个对象中。除了只有一个控件的表单外，强烈建议始终使用此类模型。这有助于我们稍后能够将所有客户数据存储在同一个对象上，而不是控制器的不同属性中。
- en: So far, this won’t change anything significant about our form that you can see,
    but it will be adding new properties to the customer model as you change the input
    values behind the scenes. If you watch the customer interpolation binding, you
    will see that as values are changed in the form inputs, the model is updated.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这不会对我们的表单产生任何显著的可见变化，但它会在后台更改输入值时向客户模型添加新属性。如果你观察客户插值绑定，你会看到当表单输入中的值发生变化时，模型也会更新。
- en: There are a couple of notes to make about using `NgModel`. First, you always
    use it with the two-way binding syntax—it doesn’t work otherwise. Second, inputs
    should always have a name when using `NgModel`, because it requires that information
    internally. Last, you notice the `value` attribute was omitted because `NgModel`
    will overwrite it and it’s best to just leave it off.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NgModel` 有几点需要注意。首先，你始终使用双向绑定语法与之一起使用——否则它不起作用。其次，使用 `NgModel` 时，输入应该始终有一个名称，因为它需要内部信息。最后，你注意到省略了
    `value` 属性，因为 `NgModel` 会覆盖它，所以最好将其省略。
- en: Save these changes and then go to the customer’s list, select one, and click
    the edit icon in the bottom right to view the form. You should ensure there are
    no errors by looking at the browser console as well, in case you typed something
    incorrectly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这些更改，然后转到客户列表，选择一个，点击右下角的编辑图标以查看表单。你还应该检查浏览器控制台，以确保没有输入错误。
- en: This is great, because our primary object is largely complete. We simply add
    `NgModel`, and our form elements are now being tracked in both the template and
    controller as changes are made. The next step is to start validating these form
    fields. Using the power of `NgModel`, we can track the validity of a form field
    and report meaningful errors to the user.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，因为我们的主要对象基本上已经完成。我们只需添加 `NgModel`，当进行更改时，我们的表单元素现在在模板和控制器中都被跟踪。下一步是开始验证这些表单字段。利用
    `NgModel` 的力量，我们可以跟踪表单字段的验证状态，并向用户报告有意义的错误。
- en: 9.2.2 Validating form controls with NgModel
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 使用 NgModel 验证表单控件
- en: HTML already provides some built-in form validations that can be put onto form
    elements, such as `required` or `minlength`. Angular works with these attributes
    and automatically will validate inputs based on them.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 已经提供了一些内置的表单验证，可以添加到表单元素中，例如 `required` 或 `minlength`。Angular 与这些属性一起工作，并且会自动根据它们验证输入。
- en: 'Let’s take the example of our customer name input field. All we need to do
    is add the additional `required` attribute to validate the input to force validation
    for this field:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以我们的客户姓名输入字段为例。我们所需做的只是添加额外的 `required` 属性来验证输入，强制对此字段进行验证：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the form control has an invalid value, we can also inspect the state of
    a field and render out messages about what is incorrect, as shown in [figure 9.4](#figure9.4).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单控件具有无效值时，我们还可以检查字段的状态，并显示关于错误的提示信息，如图 9.4 所示。
- en: '![c09-4.png](image_fi/293313c09/c09-4.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![c09-4.png](image_fi/293313c09/c09-4.png)'
- en: '[**Figure 9.4**](#figureanchor9.4) Customer form with validation errors'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 9.4**](#figureanchor9.4)  带有验证错误的客户表单'
- en: It’s time to set up the validation for all the fields and also to look at how
    to access the state of those fields. Update the CustomerForm template snippet
    as you see bolded in the following listing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候为所有字段设置验证，并查看如何访问这些字段的状态了。根据以下列表中加粗的内容更新 CustomerForm 模板片段。
- en: '**Listing 9.2** CustomerForm validating fields with NgModel'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 9.2**  使用 NgModel 验证 CustomerForm 字段'
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The form controls now each have a required attribute and a local template variable.
    The phone number also has a `minlength` attribute, because we expect a phone number
    to be at least seven digits. We’ve used local template variables in the component
    chapter to access values from other controllers inside of the template, and that’s
    precisely the same thing here. For example, `#name="ngModel"` is a way to define
    the template variable `name` to be a reference to the `NgModel` result, which
    is the form control data. Remember, template variables are only valid within the
    template they’re defined in, so you can’t reach them from your controller.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在表单控件每个都带有 `required` 属性和本地模板变量。电话号码还有一个 `minlength` 属性，因为我们期望电话号码至少有七个数字。我们在组件章节中使用了本地模板变量来访问模板中其他控制器中的值，这里也是同样的情况。例如，`#name="ngModel"`
    是将模板变量 `name` 定义为对 `NgModel` 结果的引用的方式，即表单控件数据。记住，模板变量仅在定义它们的模板内有效，因此你无法从控制器中访问它们。
- en: This form control data is a FormControl type from Angular, which you can view
    in the API docs to see more about what it can do for you. It has a number of properties,
    such as `valid`, `invalid`, `pristine`, and `dirty`. These are Boolean values
    that you can easily use to determine whether something is true or false. See [table
    9.1](#table9.1) for the most useful form control properties.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此表单控件数据是Angular中的FormControl类型，您可以在API文档中查看以了解更多关于它能为您做什么的信息。它有许多属性，例如`valid`、`invalid`、`pristine`和`dirty`。这些是布尔值，您可以使用它们轻松地确定某事是真是假。参见[表9.1](#table9.1)以了解最有用的表单控件属性。
- en: '[**Table 9.1**](#tableanchor9.1) Form control validation properties'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[**表9.1**](#tableanchor9.1) 表单控件验证属性'
- en: '| **Property** | **Meaning** |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **含义** |'
- en: '| --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `valid` | The form control is valid for all validations. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `valid` | 表单控件对所有验证都是有效的。 |'
- en: '| `invalid` | The form control has at least one invalid validation. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `invalid` | 表单控件至少有一个无效的验证。 |'
- en: '| `disabled` | The form control is disabled and can’t be interacted with. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `disabled` | 表单控件被禁用，无法与之交互。 |'
- en: '| `enabled` | The form control is enabled and can be clicked or edited. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `enabled` | 表单控件处于启用状态，可以点击或编辑。 |'
- en: '| `errors` | An object that either contains keys with validations that are
    `invalid`, or null when all are `valid`. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `errors` | 一个对象，要么包含有无效验证的键，要么当所有验证都有效时为null。 |'
- en: '| `pristine` | The form control has not yet been changed by the user. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `pristine` | 表单控件尚未被用户更改。 |'
- en: '| `dirty` | The form control has been changed by the user. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `dirty` | 表单控件已被用户更改。 |'
- en: '| `touched` | The form control has been in focus, and then focus has left the
    field. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `touched` | 表单控件曾获得焦点，然后焦点离开了该字段。 |'
- en: '| `untouched` | The form control has not been in focus. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `untouched` | 表单控件尚未获得焦点。 |'
- en: The `MdError` element is from the Material Design library and shows a little
    validation error when the `NgIf` is true. For example, `*ngIf="email.touched &&
    email.invalid"` will show the error when the form control is `invalid`, and the
    user has left focus on that field. (As a side note, if the value was loaded from
    a database but was `invalid`, the preceding validation would fail, so you should
    consider the needs of your application.) This is nice because the error doesn’t
    appear immediately, but only when the user tries to leave the field with an invalid
    value. You can use different combinations of the properties in [table 9.1](#table9.1)
    to determine when to show a validation error. When you’re creating a new item,
    all the required fields will be `invalid`, but it won’t show validation errors
    until the user has tried to edit them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`MdError` 元素来自Material Design库，当`NgIf`为真时显示一个小的验证错误。例如，`*ngIf="email.touched
    && email.invalid"`会在表单控件无效且用户离开该字段焦点时显示错误。（作为旁注，如果值是从数据库加载的但无效，则前面的验证将失败，因此您应该考虑您应用程序的需求。）这很好，因为错误不会立即出现，而只有在用户尝试用无效值离开字段时才会出现。您可以使用[表9.1](#table9.1)中属性的不同的组合来确定何时显示验证错误。当您创建新项目时，所有必填字段都将无效，但只有在用户尝试编辑它们之前不会显示验证错误。'
- en: 'Notice how the validation message for the phone number has two different validations:
    `required` and `minlength`. We’re then able to look at the control’s error object
    to determine whether a specific validation failed and show the appropriate message.
    In this case, if the user leaves it blank, it will prompt it to say the field
    is required, but if the user only inputs four characters, it will show that it
    expects at least seven digits.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意电话号码的验证消息有两个不同的验证：`required`和`minlength`。然后我们能够查看控件的错误对象，以确定是否特定的验证失败，并显示适当的消息。在这种情况下，如果用户留空，它会提示该字段是必填的，但如果用户只输入了四个字符，它会显示至少需要七个数字。
- en: It’s also useful to note that Angular will apply various CSS classes to a form
    control based on its validation state. They mirror the properties in [table 9.1](#table9.1),
    but have the ``ng- prefix. For example, an invalid form control will have the
    `ng-invalid` class applied. This is useful if you want to craft your own styling
    for valid or invalid controls without any special work. We’re not doing that here,
    but you could certainly take advantage of them. Some Angular UI libraries may
    come with support for them out of the box.``
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，Angular 会根据表单控件的验证状态应用各种 CSS 类。这些类与 [表 9.1](#table9.1) 中的属性相对应，但前面带有
    ``ng- 前缀。例如，一个无效的表单控件将应用 `ng-invalid` 类。如果你想在没有任何特殊工作的情况下为有效或无效的控件定制样式，这将非常有用。我们在这里没有这样做，但你当然可以利用这一点。一些
    Angular UI 库可能自带对这些类的支持。``
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
