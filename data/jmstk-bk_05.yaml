- en: 4 Building a documentation site
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 构建文档网站
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Understanding the needs of a typical documentation site
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解典型文档网站的需求
- en: Choosing a headless CMS for managing documentation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为管理文档选择无头 CMS
- en: Choosing a static site generator for a documentation site
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为文档网站选择静态网站生成器
- en: Installing and configuring Hugo
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置 Hugo
- en: Setting up Netlify CMS open editing and modeling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Netlify CMS 开放编辑和建模
- en: Configuring Netlify and GitHub for user authentication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Netlify 和 GitHub 以进行用户身份验证
- en: Editing content in Netlify CMS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Netlify CMS 中编辑内容
- en: The Jamstack has always excelled at content-focused sites, even from the early
    days of static site generators. Static HTML and CSS is perfect for displaying
    content quickly and efficiently; thus, content sites lend themselves to pre-rendering
    using Jamstack tools. This is why documentation sites have been one of the most
    obvious use cases for the Jamstack.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Jamstack 在内容为中心的网站上一直表现出色，甚至从静态网站生成器的早期阶段开始就是这样。静态 HTML 和 CSS 完美地适用于快速高效地显示内容；因此，内容网站非常适合使用
    Jamstack 工具进行预渲染。这就是为什么文档网站一直是 Jamstack 最明显的用例之一。
- en: 'Documentation sites have always generally had additional advantages to using
    the Jamstack:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 文档网站在始终具有使用 Jamstack 的额外优势：
- en: The ability to version file-based content easily via source control
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过源控制轻松地对基于文件的内容进行版本控制
- en: A means of accepting contributions and corrections via processes like a GitHub
    pull request
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过如 GitHub 拉取请求等流程接受贡献和修正的方式
- en: The fact that, in many cases, the authors were technically adept with these
    sorts of development tools
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事实上，在许多情况下，作者对这些开发工具的技术能力很强
- en: The biggest disadvantage of choosing the Jamstack for a documentation site had
    typically been that the tools for editing content were not advanced enough to
    meet the needs of content authors and editors. However, the tools, services, and
    libraries available for documentation sites (or content-focused sites in general)
    using the Jamstack have improved tremendously in recent years. The benefits still
    apply, but modern Jamstack tools make site content easier to edit and contributions
    easier to accept—even from folks who may be unfamiliar with code. In this chapter,
    we’ll explore the options available to you for developing documentation sites
    using the Jamstack and walk through how to build a documentation site.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 Jamstack 作为文档网站的最大缺点通常是编辑内容所需的工具不够先进，无法满足内容作者和编辑的需求。然而，近年来，用于文档网站（或一般以内容为中心的网站）的
    Jamstack 工具、服务和库已经得到了极大的改进。这些好处仍然适用，但现代 Jamstack 工具使得网站内容的编辑更加容易，接受贡献也更加方便——甚至对于那些可能不熟悉代码的人来说也是如此。在本章中，我们将探讨您使用
    Jamstack 开发文档网站可用的选项，并介绍如何构建一个文档网站。
- en: 4.1 Requirements of a documentation site
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1 文档网站的需求
- en: 'There’s obviously no single kind of documentation site. For example, there
    is technical documentation, like software documentation or API documentation,
    and end-user documentation, like user manuals. The requirements for each of these
    may differ, but they also share some commonalities:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，没有一种单一的文档网站类型。例如，有技术文档，如软件文档或 API 文档，以及最终用户文档，如用户手册。这些需求可能有所不同，但它们也有一些共同点：
- en: Documentation sites tend to have multiple, and often numerous, contributors.
    In the case of project or policy documentation, contributors might exclusively
    be company employees. However, in a software world increasingly dominated by open
    source, many documentation sites often have a large number of external contributors.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档网站往往有多个，通常是众多的贡献者。在项目或政策文档的情况下，贡献者可能仅限于公司员工。然而，在开源日益主导的软件世界中，许多文档网站通常有大量的外部贡献者。
- en: Contributors may have varying degrees of technical expertise when it comes to
    editing the site’s content.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贡献者编辑网站内容时可能具有不同程度的技术专长。
- en: Documentation sites are designed to be optimized for fast and easy access to
    information, favoring simple and straightforward features and design.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档网站旨在优化快速轻松地访问信息，优先考虑简单直接的功能和设计。
- en: The layout and design are geared toward readability over style.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局和设计侧重于可读性而非风格。
- en: Outside of things like comments or runnable examples, many documentation sites
    do not include complex, dynamic functionality.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了评论或可运行的示例之外，许多文档网站不包括复杂或动态的功能。
- en: Many documentation sites have a lot of content, but that content can change
    relatively infrequently. A typical site may receive periodic major updates with
    occasional minor ones in between.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多文档网站有很多内容，但这些内容相对不经常改变。一个典型的网站可能会定期进行重大更新，偶尔之间会有一些小更新。
- en: 4.1.1 The example site requirements
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 示例网站需求
- en: We’re going to build technical documentation for an esoteric programming language
    called LOLCODE ([http://www.lolcode.org/](http://www.lolcode.org/)) (see figure
    4.1). LOLCODE is intended to be a humorous take on a programming language that
    is based on lolspeak, a form of grammatically incorrect language associated with
    internet memes of cats. The docs are based on the LOLCODE specification ([http://mng.bz/RE7D](http://mng.bz/RE7D)),
    written by Justin Meza.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为一种名为LOLCODE的冷门编程语言构建技术文档（[http://www.lolcode.org/](http://www.lolcode.org/)）（见图4.1）。LOLCODE旨在对基于lolspeak（一种与猫的互联网迷因相关的语法错误语言）的编程语言进行幽默的诠释。这些文档基于Justin
    Meza编写的LOLCODE规范（[http://mng.bz/RE7D](http://mng.bz/RE7D)）。
- en: '![CH04_F01_Camden2](Images/CH04_F01_Camden2.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F01_Camden2](Images/CH04_F01_Camden2.png)'
- en: Figure 4.1 The [lolcode.org](http://www.lolcode.org/) site showing the LOLCODE
    language, installation details, and links to the specifications that we’ll use
    for our example documentation site
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 展示LOLCODE语言、安装细节以及我们将用于示例文档网站的规范链接的[lolcode.org](http://www.lolcode.org/)网站
- en: As the adoption of LOLCODE inevitably expands, I expect this site to get rather
    large, so optimizing for build speed will be a priority. Since this is an open
    source language, I’d also like to enable easy contributions from third-party authors.
    Though I anticipate that most contributors will have a high degree of technical
    expertise, they may not be experts in building Jamstack sites. Nonetheless, I
    want to encourage contributions by enabling them to contribute without requiring
    that they go through the Git workflow of manually forking, installing locally,
    updating, and then creating a pull request.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 随着LOLCODE的采用不可避免地扩大，我预计这个网站会变得相当大，因此优化构建速度将成为一个重点。由于这是一个开源语言，我还希望能够使第三方作者能够轻松贡献。尽管我预计大多数贡献者都将具有高度的技术专长，但他们可能不是构建Jamstack网站方面的专家。尽管如此，我仍希望通过使他们能够不经过手动分叉、本地安装、更新然后创建拉取请求的Git工作流程来鼓励贡献。
- en: Now that we understand the needs of our docs site, let’s look at the tools we
    have available to meet these requirements.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了我们文档网站的需求，让我们来看看我们有哪些工具可以满足这些需求。
- en: 4.2 Choosing the right tools
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2 选择合适的工具
- en: Our requirements aren’t particularly complex. We need the ability to generate
    potentially many content pages for an extensive documentation, and we need the
    ability for third-party content contributors to edit content without requiring
    a deep technical knowledge of how the site is built. To accomplish this, we’re
    going to need the right static site generator and a headless content management
    system (CMS). The CMS will provide the editing interface that will allow content
    contributors to more easily write and edit content on the site.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的需求并不特别复杂。我们需要能够为广泛的文档生成可能很多的内容页面，并且我们需要第三方内容贡献者能够编辑内容，而无需深入了解网站是如何构建的。为了实现这一点，我们需要一个合适的静态网站生成器和无头内容管理系统（CMS）。CMS将提供编辑界面，使内容贡献者能够更轻松地在网站上编写和编辑内容。
- en: 4.2.1 What is a headless CMS?
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 什么是无头CMS？
- en: We’ve talked a lot about static site generators but not about headless CMSs.
    *Headless CMSs* are a relatively new concept. The name derives from the idea that
    they decouple the backend (i.e., the actual content editing and management tools
    that the CMS provides) from the “head” (i.e., the frontend of the application,
    in this case, a website).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了很多关于静态网站生成器的内容，但还没有讨论无头CMS。*无头CMS*是一个相对较新的概念。这个名字来源于它们将后端（即CMS提供的实际内容编辑和管理工具）与“头部”（即应用程序的前端，在这种情况下是一个网站）解耦的想法。
- en: Traditional CMSs were created almost exclusively to manage web page content.
    Because of this, the management of the content was tied to its display. For example,
    in a typical WordPress site, the backend content management is provided by WordPress,
    but the frontend website is also built in (i.e., tightly coupled with) WordPress.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的内容管理系统（CMS）几乎完全是为了管理网页内容而创建的。正因为如此，内容的管理与其显示方式紧密相连。例如，在一个典型的WordPress网站上，后端的内容管理由WordPress提供，但前端网站也是基于WordPress构建的（即，与WordPress紧密耦合）。
- en: This tight coupling means that content is not reusable. A headline on the home
    page might also appear on a landing page, but updating one instance will not update
    the other. Since the content is intended for the web, it cannot easily be reused
    in things like a mobile app.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种紧密耦合意味着内容不可重用。主页上的标题也可能出现在着陆页上，但更新一个实例不会更新另一个实例。由于内容是为网络设计的，因此它不能轻易地用于像移动应用这样的东西。
- en: A traditional CMS also isn’t designed for the Jamstack. Pages on the frontend
    of a traditional CMS are server-rendered and unable to take advantage of the improved
    speed and security the Jamstack architecture offers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的CMS也不是为Jamstack设计的。传统CMS的前端页面是服务器端渲染的，无法利用Jamstack架构提供的改进速度和安全性能。
- en: 'Headless CMSs solve these problems by providing the backend content editing
    and management tools, untethered from a frontend site. There is a fast-growing
    list of headless CMS options available, but they fall under two different categories
    that determine how the frontend site accesses the content:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 无头CMS通过提供与前端网站解耦的后端内容编辑和管理工具来解决这些问题。目前有越来越多的无头CMS选项可供选择，但它们分为两个不同的类别，这些类别决定了前端网站如何访问内容：
- en: '*API-based headless CMS*—Your content is stored by the CMS provider and is
    accessible by your website, mobile app, or other application via an API. Since
    content in an API-based headless CMS is not tied to physical files, they are able
    to easily handle reuse of content objects and more easily manage complex relationships
    between content objects or even embedding content objects within content blocks.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于API的无头CMS*—您的内容由CMS提供商存储，并通过API由您的网站、移动应用或其他应用程序访问。由于基于API的无头CMS中的内容与物理文件无关，它们能够轻松处理内容对象的重复使用，并更容易管理内容对象之间或内容块内内容对象的复杂关系。'
- en: '*Git-based headless CMS*—These CMSs do not store your content. Instead, content
    is maintained in a Git repository, often as Markdown for long-form content and
    YAML or JSON for data. The CMS is essentially a layer of tooling for managing
    the content via a web interface that is easy to understand for content editors
    who may be uncomfortable manually editing the file-based content.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于Git的无头CMS*—这些CMS不存储您的内容。相反，内容存储在Git仓库中，通常作为Markdown用于长篇内容，以及YAML或JSON用于数据。CMS本质上是一层工具，通过易于理解的内容编辑器通过Web界面管理内容，这些编辑器可能不习惯手动编辑基于文件的内容。'
- en: 'NOTE For a more in-depth look at the pros and cons of Git-based versus API-based
    headless CMSs, see this detailed post by Bejamas: [http://mng.bz/2j19](https://bejamas.io/blog/git-based-cms-vs-api-first-cms/).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要深入了解基于Git和基于API的无头CMS的优缺点，请参阅Bejamas的这篇详细文章：[http://mng.bz/2j19](https://bejamas.io/blog/git-based-cms-vs-api-first-cms/)。
- en: One of the benefits of a Git-based CMS for our example use case is that it still
    allows a Git-based editing workflow and version histories that track changes,
    which can be publicly accessible via GitHub or other Git project hosting providers.
    This can be ideal for a technical documentation project, particularly for an open
    source project, as in our case. Therefore, our example project will use a Git-based
    solution.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例用例，基于Git的CMS的一个好处是它仍然允许基于Git的编辑工作流程和版本历史记录，这些历史记录可以跟踪更改，并且可以通过GitHub或其他Git项目托管提供商公开访问。这对于技术文档项目来说可能是理想的，尤其是对于开源项目，正如我们的案例一样。因此，我们的示例项目将使用基于Git的解决方案。
- en: 4.2.2 Headless CMS options
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 无头CMS选项
- en: Now that we’ve determined a Git-based solution is our choice, let’s look at
    some the options available.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定基于Git的解决方案是我们的选择，让我们来看看可用的选项。
- en: Forestry
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Forestry
- en: Forestry ([forestry.io](https://forestry.io/)) is a commercial Git-based CMS
    solution. It comes with built-in support for all of the most popular static site
    generators and integrates with most of the major static hosting providers (figure
    4.2). At the time of this writing, it offers a free account that supports up to
    five editors, though free sites are automatically archived after three months
    of inactivity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Forestry ([forestry.io](https://forestry.io/)) 是一个商业化的基于Git的CMS解决方案。它内置了对所有最流行的静态站点生成器的支持，并与大多数主要的静态托管提供商集成（图4.2）。在撰写本文时，它提供免费账户，支持多达五个编辑器，尽管免费网站在三个月不活跃后会自动存档。
- en: '![CH04_F02_Camden2](Images/CH04_F02_Camden2.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F02_Camden2](Images/CH04_F02_Camden2.png)'
- en: Figure 4.2 Editing a content page using Forestry’s what-you-see-is-what-you-get
    (WYSIWYG) page editor
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 使用Forestry的所见即所得（WYSIWYG）页面编辑器编辑内容页面
- en: Publii
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Publii
- en: Publii ([https://getpublii.com/](https://getpublii.com/)), shown in figure 4.3,
    is different from the other options in that it is an installable, open source
    desktop application rather than a web-based interface. It offers several options
    for editing content, including a WYSIWYG editor, a block editor similar to the
    new “Gutenberg” interface on WordPress, and a straight Markdown editor. Publii
    doesn’t just provide the editing tools like other Git-based CMSs, but also serves
    as the static site generator, which supports a wide variety of hosting options.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Publii ([https://getpublii.com/](https://getpublii.com/))，如图 4.3 所示，与其他选项不同，它是一个可安装的开源桌面应用程序，而不是基于网络的界面。它提供了多种编辑内容的选择，包括
    WYSIWYG 编辑器、类似于 WordPress 新“Gutenberg”界面的块编辑器以及直接的 Markdown 编辑器。Publii 不仅提供与其他基于
    Git 的 CMS 一样的编辑工具，还充当静态站点生成器，支持广泛的托管选项。
- en: '![CH04_F03_Camden2](Images/CH04_F03_Camden2.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F03_Camden2](Images/CH04_F03_Camden2.png)'
- en: 'Figure 4.3 Publii’s desktop application interface offers several options for
    editing content: a WYSIWYG editor, a block editor similar to the new “Gutenberg”
    interface on WordPress, and straight Markdown source editing.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 Publii 的桌面应用程序界面提供了多种编辑内容的选择：WYSIWYG 编辑器、类似于 WordPress 新“Gutenberg”界面的块编辑器以及直接的
    Markdown 源代码编辑。
- en: Prose
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Prose
- en: Prose ([http://prose.io/](http://prose.io/)), shown in figure 4.4, is also a
    unique option. It is a completely free tool that hooks into your GitHub account,
    giving you access to a web-based editor for any file in any repository connected
    to your account. While code and data files can be edited using the Prose editor,
    its focus is on offering a better editing experience for Markdown content with
    metadata (typically called front matter). It does provide a simple Markdown preview
    but not a true WYSIWYG experience.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Prose ([http://prose.io/](http://prose.io/))，如图 4.4 所示，也是一个独特的选项。这是一个完全免费的工具，可以连接到您的
    GitHub 账户，为您提供访问任何与您的账户关联的存储库中任何文件的基于网络的编辑器。虽然可以使用 Prose 编辑器编辑代码和数据文件，但其重点是提供带有元数据（通常称为前端元数据）的
    Markdown 内容的更好的编辑体验。它确实提供了一个简单的 Markdown 预览，但不是真正的 WYSIWYG 体验。
- en: '![CH04_F04_Camden2](Images/CH04_F04_Camden2.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F04_Camden2](Images/CH04_F04_Camden2.png)'
- en: Figure 4.4 Prose provides a Markdown editor with simple preview capabilities
    and front matter metadata editing for any Markdown file in any repository within
    your GitHub account.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 Prose 为您 GitHub 账户中的任何存储库中的任何 Markdown 文件提供了带有简单预览功能和前端元数据编辑的 Markdown
    编辑器。
- en: Netlify CMS
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Netlify CMS
- en: Netlify CMS ([https://www.netlifycms.org/](https://www.netlifycms.org/)), shown
    in figure 4.5, is an open source content management tool. One of its differentiators
    is the ability to configure it to work with just about any static site generator.
    It was built by and is largely maintained by Netlify, so some features work out-of-the-box
    with Netlify’s hosting, but it can be configured to work with other providers
    as well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Netlify CMS ([https://www.netlifycms.org/](https://www.netlifycms.org/))，如图
    4.5 所示，是一个开源的内容管理系统工具。其独特之处在于能够配置它以与几乎所有静态站点生成器协同工作。它由 Netlify 构建，并由 Netlify 主要维护，因此一些功能与
    Netlify 的托管服务无缝集成，但它也可以配置与其他提供商一起工作。
- en: '![CH04_F05_Camden2](Images/CH04_F05_Camden2.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F05_Camden2](Images/CH04_F05_Camden2.png)'
- en: Figure 4.5 Netlify CMS has a variety of advanced widgets for editing both the
    long-form Markdown content of a post as well as the front matter metadata.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 Netlify CMS 提供了多种高级小部件，用于编辑帖子的长格式 Markdown 内容以及前端元数据。
- en: 4.2.3 Why Netlify CMS?
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 为什么选择 Netlify CMS？
- en: 'Our project is going to be a technical documentation for the esoteric programming
    language LOLCODE. For this project, we’re going to use Netlify CMS. There are
    a number of reasons this is a good choice:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目将是一个关于神秘编程语言 LOLCODE 的技术文档。对于这个项目，我们将使用 Netlify CMS。选择 Netlify CMS 的原因有很多：
- en: Netlify CMS is a liberally licensed open source project (it uses an MIT license).
    This means we can make our entire documentation project open source without worrying
    about license restrictions.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netlify CMS 是一个自由许可的开源项目（它使用 MIT 许可证）。这意味着我们可以将整个文档项目开源，而无需担心许可限制。
- en: Netlify CMS has an open authoring feature that allows us to give anyone with
    a GitHub account access to make contributions to the documentation. The users
    will have full access to the content management system, but their contributions
    will be automatically submitted as pull requests on their behalf, meaning the
    changes will not affect the site until we have accepted them.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netlify CMS有一个开放作者功能，允许我们给任何拥有GitHub账户的人访问权限，以便他们对文档做出贡献。用户将完全访问内容管理系统，但他们的贡献将自动以他们的名义提交为拉取请求，这意味着更改不会影响网站，直到我们接受它们。
- en: There is no limit to the number of users who are allowed to make a contribution
    and no costs associated with the number of users.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有限制允许做出贡献的用户数量，也没有与用户数量相关的成本。
- en: 4.2.4 Static site generator (SSG) options
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 静态站点生成器（SSG）选项
- en: 'Any SSG can work for a documentation site. That being said, there are actually
    a number of SSGs that are specifically geared toward documentation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 任何SSG都可以用于文档站点。尽管如此，实际上有许多SSG是专门针对文档的：
- en: '*[Docsify](https://github.com/docsifyjs/docsify)* ([https://docsify.js.org](https://docsify.js.org))—A
    Javascript-based SSG that serves documentation as a single-page application (SPA).
    Docsify differs from other solutions in that it does not generate static HTML
    files but instead parses the Markdown content at runtime in the browser, meaning
    the application does not need to rebuild to reflect changes or new content.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*[Docsify](https://github.com/docsifyjs/docsify)* ([https://docsify.js.org](https://docsify.js.org))—一个基于JavaScript的SSG，将文档作为单页应用（SPA）提供服务。Docsify与其他解决方案的不同之处在于它不会生成静态HTML文件，而是在浏览器运行时解析Markdown内容，这意味着应用程序不需要重建以反映更改或新内容。'
- en: '*Slate* ([https://github.com/slatedocs/slate](https://github.com/slatedocs/slate))—A
    Ruby-based solution built on the Middleman SSG under the covers that is designed
    specifically for creating API docs. It also runs as a SPA that supports code examples
    in multiple languages, allowing the user to switch to the language tab that is
    relevant to them.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Slate* ([https://github.com/slatedocs/slate](https://github.com/slatedocs/slate))—一个基于Ruby的解决方案，它是在Middleman
    SSG的基础上构建的，专门用于创建API文档。它还作为一个支持多种语言代码示例的单页应用（SPA）运行，允许用户切换到与他们相关的语言标签。'
- en: '*MkDocs* ([https://www.mkdocs.org/](https://www.mkdocs.org/))—A Python-based
    solution that emphasizes its speed when generating a large number of pages. It
    offers many themes, including a lot of community-built themes.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MkDocs* ([https://www.mkdocs.org/](https://www.mkdocs.org/))—一个基于Python的解决方案，强调在生成大量页面时的速度。它提供了许多主题，包括许多社区构建的主题。'
- en: '*Docusaurus* ([https://docusaurus.io/](https://docusaurus.io/))—A JavaScript-based
    static site generator that uses React, Docusaurus comes with a lot of documentation-focused
    features and layouts out of the box, including things like documentation versioning
    and internationalization (i18n).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Docusaurus* ([https://docusaurus.io/](https://docusaurus.io/))—一个基于JavaScript的静态站点生成器，使用React，Docusaurus自带许多文档相关的功能和布局，包括文档版本控制和国际化（i18n）等功能。'
- en: '*Hugo* ([https://gohugo.io/](https://gohugo.io/))—A popular Go-based SSG that
    is also focused on an extremely fast build process, including built-in asset management.
    While it isn’t documentation specific, Hugo has a large community of users with
    a lot of community-built themes, many of them specifically designed for documentation.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Hugo* ([https://gohugo.io/](https://gohugo.io/))—一个流行的基于Go的SSG，也专注于极快的构建过程，包括内置的资产管理。虽然它不是专门的文档解决方案，但Hugo有一个庞大的用户社区，拥有大量的社区构建的主题，其中许多是为文档特别设计的。'
- en: 4.2.5 Why Hugo?
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.5 为什么选择Hugo？
- en: We’re going to use Hugo for our LOLCODE technical documentation project. It
    will handle our growing volume of content easily while keeping build times down.
    Hugo is installed via a binary, meaning there’s no complicated environment required
    for contributors who wish to run the project locally. It also has extensive and
    detailed documentation as well as a large number of community posts, making it
    easy to find solutions to any potential problems we may encounter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Hugo来处理我们的LOLCODE技术文档项目。它将轻松处理我们不断增长的内容量，同时保持构建时间短。Hugo通过二进制文件安装，这意味着希望在本地上运行项目的贡献者不需要复杂的环境。它还拥有详尽和详细的文档以及大量的社区帖子，这使得我们能够轻松找到解决可能遇到任何潜在问题的解决方案。
- en: 'Even though it isn’t a documentation-specific solution, Hugo has a significant
    number of community themes that offer designs and features targeted to documentation
    sites. Some examples include the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它不是一个专门的文档解决方案，Hugo也有大量的社区主题，这些主题提供针对文档站点的设计和功能。以下是一些例子：
- en: Ace Documentation is a Bootstrap-based docs theme.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ace Documentation 是基于 Bootstrap 的文档主题。
- en: DocuAPI is geared toward multilingual API documentation.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DocuAPI 针对多语言 API 文档设计。
- en: Dot is aimed at documentation in the form of a support center or knowledge base.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dot 旨在用于支持中心或知识库形式的文档。
- en: Hugo Book is a minimalist book-style theme with features like built-in search.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hugo Book 是一个具有内置搜索功能的极简主义书籍风格主题。
- en: Techdoc is also a minimalist book-style theme.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Techdoc 也是一个极简主义书籍风格主题。
- en: Kraiklyn is designed for creating single-page documentation.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kraiklyn 是为创建单页文档而设计的。
- en: For our example, we’ll choose the Hugo Book theme. I chose this not for any
    technical reason but because I think the simple, clean layout it provides works
    well for the sort of language documentation we are creating.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将选择 Hugo Book 主题。我选择这个主题并不是出于任何技术原因，而是因为我认为它提供的简单、干净的布局非常适合我们正在创建的语言文档。
- en: 4.3 Building the example site
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3 构建示例站点
- en: Let’s get started building our documentation site. We’ll begin by installing
    Hugo and getting our theme set up and then configure the site to work with Netlify
    CMS.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建我们的文档站点。我们将从安装 Hugo 和设置主题开始，然后配置站点以与 Netlify CMS 一起工作。
- en: 4.3.1 Installing Hugo
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 安装 Hugo
- en: There are a number of ways to install Hugo, including simply downloading the
    binary. While that is a method that works across all supported platforms (MacOS,
    Windows, and Linux), it has some complications in that you’ll want to place it
    on your path so that it can easily be called from any location with just the hugo
    command-line command (rather than the full path to the binary). It’s important
    to note that if you choose the binary install or already have Hugo installed,
    you need the extended version of Hugo version 0.68 or higher.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Hugo 有多种方式，包括简单地下载二进制文件。虽然这种方法适用于所有支持的平台（MacOS、Windows 和 Linux），但它有一些复杂性，因为你可能希望将其放置在路径上，以便只需使用
    hugo 命令行命令（而不是二进制文件的完整路径）即可轻松调用。需要注意的是，如果你选择二进制安装或已经安装了 Hugo，你需要 Hugo 0.68 或更高版本的扩展版。
- en: It is preferable to use a package manager to install Hugo.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包管理器安装 Hugo 是更好的选择。
- en: Installing on MacOS or Linux
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MacOS 或 Linux 上安装
- en: 'You can use Homebrew to install Hugo on MacOS or Linux:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Homebrew 在 MacOS 或 Linux 上安装 Hugo：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Installing on Windows
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上安装
- en: 'You can use Chocolatey to install Hugo on Windows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Chocolatey 在 Windows 上安装 Hugo：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Confirming your installation
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 确认安装
- en: 'Confirm that your Hugo installation worked properly:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 确认你的 Hugo 安装工作正常：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This should return something like the following (note that the version will
    have changed since this writing):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回以下类似的内容（请注意，版本号自本文撰写以来可能已更改）：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 4.3.2 Creating a new Hugo site
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 创建新的 Hugo 网站
- en: We’re going to build a technical documentation site for the LOLCODE esoteric
    language using Hugo as our static site generator, Netlify CMS as our Git-based
    headless CMS, and Hugo Book as our site’s theme. The first step will be to generate
    a new site skeleton for our site using Hugo.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划使用 Hugo 作为我们的静态站点生成器，Netlify CMS 作为基于 Git 的无头 CMS，以及 Hugo Book 作为我们的站点主题，来构建
    LOLCODE 稀有语言的科技文档网站。第一步将是使用 Hugo 为我们的网站生成一个新的站点骨架。
- en: 'To create a new site using Hugo, use the new site command followed by a name
    for the directory you want the site to be created in:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Hugo 创建新站点，请使用 new site 命令后跟你想要站点创建的目录名称：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will create a skeleton for a Hugo site with the following contents:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含以下内容的 Hugo 站点骨架：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, the skeleton has no default content or theme. For the most
    part, Hugo generates only the directory structure and a basic configuration file.
    Here’s what each of these files and folders are used for:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，骨架中没有默认内容或主题。大部分情况下，Hugo 只会生成目录结构和基本的配置文件。以下是这些文件和文件夹的用途：
- en: In Hugo, archetypes represent the different content types in your application.
    These are templates for the front matter (i.e., metadata) of the different types
    of content your site will contain. For example, you may have a post archetype
    for blog posts that define the front matter a blog post will contain. While it
    isn’t necessary that you create an archetype for all your content, doing so allows
    you to use the hugo new command with that type to generate a new page with the
    correct settings for that content type. So, if we had a post type, we could enter
    the command hugo new post/my-new-post.md to create a blog post with the name “my-new-post.”
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Hugo 中，架构体（archetypes）代表应用程序中的不同内容类型。这些是网站将包含的不同类型内容的元数据（即元数据）模板。例如，你可能有一个用于博客文章的架构体，它定义了博客文章将包含的元数据。虽然不是必须为所有内容创建架构体，但这样做允许你使用
    hugo new 命令与该类型一起生成具有正确设置的新的页面。所以，如果我们有一个帖子类型，我们可以输入命令 hugo new post/my-new-post.md
    来创建一个名为“my-new-post”的博客文章。
- en: All content for a Hugo site exists within the content folder. This can be in
    any directory structure within that folder. When the site is generated, a page
    will be created for every content item within the content folder. For example,
    a Markdown file at /content/posts/my-new-post.md will generate a page at /posts/
    my-new-post/ within the site.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hugo 网站的全部内容都存在于内容文件夹中。这些内容可以位于该文件夹内的任何目录结构中。当网站生成时，内容文件夹中的每个内容项都会创建一个页面。例如，位于
    /content/posts/my-new-post.md 的 Markdown 文件将在网站中生成一个位于 /posts/my-new-post/ 的页面。
- en: The data folder contains all data files (YAML, TOML, or JSON). Hugo makes these
    available to the site within the .Site.Data object. For instance, a data file
    of authors.yaml would be available as .Site.Data.Authors.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据文件夹包含所有数据文件（YAML、TOML 或 JSON）。Hugo 通过 .Site.Data 对象将这些文件提供给网站。例如，一个 authors.yaml
    的数据文件将作为 .Site.Data.Authors 可用。
- en: The layouts folder contains all the layout templates that Hugo will use to generate
    the pages. Typically, this folder is used on a site that does not have a theme
    installed. If both exist, Hugo will use the more specific file in layouts first
    (we’ll use this to our advantage later). Hugo layouts are written using the Go
    template language to generate markup.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局文件夹包含 Hugo 将用于生成页面的所有布局模板。通常，这个文件夹用于没有安装主题的网站。如果两者都存在，Hugo 将首先使用布局中的更具体文件（我们稍后会利用这一点）。Hugo
    布局使用 Go 模板语言编写以生成标记。
- en: The static folder contains any files that should be moved to the site without
    processing. These are often assets like images, JavaScript, or stylesheets that
    you do not want Hugo to modify. Everything from the static folder will be placed
    in the site root. For example, if you have a /static/images folder filled with
    the site’s images, those will end up in just /images on the site. To show you
    what I mean, download the LOLCODE logo and save it in /static/images (the resulting
    file should be /static/images/logo.png).
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态文件夹包含所有应该直接移动到网站中而不需要处理的文件。这些通常是图像、JavaScript 或样式表等资产，你不想让 Hugo 修改。静态文件夹中的所有内容都将放置在网站根目录下。例如，如果你有一个
    /static/images 文件夹，里面装满了网站的图像，那么这些图像最终会出现在网站的 /images 下。为了说明这一点，请下载 LOLCODE 标志并保存到
    /static/images（生成的文件应该是 /static/images/logo.png）。
- en: The themes folder is where you would place third-party themes that you download.
    You can find a ton of these at [themes.gohugo.io](https://themes.gohugo.io/).
    You can also create your own theme in this directory. To set the site’s theme,
    you’ll need to define a theme variable in Hugo’s config.toml (we’ll look at this
    in a moment).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题文件夹是放置你下载的第三方主题的地方。你可以在 [themes.gohugo.io](https://themes.gohugo.io/) 找到大量这些主题。你还可以在这个目录中创建自己的主题。要设置网站的主题，你需要在
    Hugo 的 config.toml 中定义一个主题变量（我们稍后会看到这一点）。
- en: The config.toml is Hugo’s configuration file, written in TOML. The base configuration
    Hugo provides includes just a baseUrl, languageCode, and title.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: config.toml 是 Hugo 的配置文件，使用 TOML 编写。Hugo 提供的基本配置包括 baseUrl、languageCode 和 title。
- en: Let’s go ahead and drop in some default content for our docs site. I have provided
    a zip file containing the Markdown content for the sample site in the book’s GitHub
    repository at [http://mng.bz/1jRy](https://github.com/cfjedimaster/the-jamstack-book/blob/master/chapter4/Content.zip).
    Download that zip and extract it to the /content folder of your new site. You
    should now have /content/ _index.md, which is the home page, and /content/docs,
    which will contain a number of Markdown files with the site documentation.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们先为我们的文档网站添加一些默认内容。我已经提供了一个包含书中示例网站 Markdown 内容的 zip 文件，位于书籍 GitHub 仓库的 [http://mng.bz/1jRy](https://github.com/cfjedimaster/the-jamstack-book/blob/master/chapter4/Content.zip)。下载这个
    zip 文件并将其解压到您新网站的内容文件夹 /content 中。现在您应该有 /content/_index.md，这是主页，以及 /content/docs，它将包含一些带有网站文档的
    Markdown 文件。
- en: 4.3.3 Setting up the Hugo Book theme
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 设置 Hugo Book 主题
- en: 'We’re going to install the Hugo Book theme as a submodule. Before we can do
    that, we’ll need to ensure our new project is initialized as a Git repository.
    Using the terminal/ command line at the root of your project directory, initialize
    a new repository:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装 Hugo Book 主题作为一个子模块。在我们能够这样做之前，我们需要确保我们的新项目被初始化为一个 Git 仓库。使用项目目录根部的终端/命令行，初始化一个新的仓库：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, let’s add hugo-book as a submodule. Installing the theme this way will
    allow us to keep our project up to date if any changes are made to the theme in
    the GitHub repository:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将 hugo-book 添加为一个子模块。以这种方式安装主题将允许我们在 GitHub 仓库中的主题有任何更改时保持我们的项目更新：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, let’s configure Hugo to use the newly installed theme. We’re going
    to open the config.toml in the root folder of the project and make the following
    changes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们配置 Hugo 以使用新安装的主题。我们将打开项目根目录中的 config.toml 并进行以下更改：
- en: Change the title to “LOLCODE Documentation.”
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将标题更改为“LOLCODE 文档。”
- en: Add a theme variable to set the theme to “book.”
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个主题变量来设置主题为“book”。
- en: Add additional Hugo Book configuration. The theme provides an extensive amount
    of configuration options, but we’ll just add the ability to search using the BookSearch
    parameter.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加额外的 Hugo Book 配置。该主题提供了大量的配置选项，但我们只会添加使用 BookSearch 参数进行搜索的能力。
- en: 'Here’s what the finished configuration file looks like:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完成后的配置文件的样子：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For now, we’re leaving the baseURL value alone. This value represents the hostname
    and path to the root of the site and can be used in Hugo layout code. Once we’ve
    deployed our site to Netlify, we can update this, but for now it won’t impact
    our project.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们保持 baseURL 值不变。此值代表站点的主机名和根路径，可以在 Hugo 布局代码中使用。一旦我们将网站部署到 Netlify，我们可以更新它，但现在它不会影响我们的项目。
- en: Now we’re ready to test our site. Just as a reminder, be sure you downloaded
    the LOLCODE logo and saved it in /static/images. From the terminal/command line,
    run hugo serve from within the project’s root folder to launch Hugo’s local web
    server. This will build your site and make the page viewable at http://localhost:1313\.
    If you open the site in your browser, it should look like figure 4.6.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好测试我们的网站。提醒一下，确保你已经下载了 LOLCODE 标志并将其保存在 /static/images 中。从项目根目录的终端/命令行运行
    hugo serve 以启动 Hugo 的本地网络服务器。这将构建您的网站并在 http://localhost:1313 上使页面可查看。如果您在浏览器中打开网站，它应该看起来像图
    4.6。
- en: '![CH04_F06_Camden2](Images/CH04_F06_Camden2.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F06_Camden2](Images/CH04_F06_Camden2.png)'
- en: Figure 4.6 The LOLCODE documentation site running on our local Hugo web server
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 在我们的本地 Hugo 网络服务器上运行的 LOLCODE 文档网站
- en: Feel free to browse around or even search. You’ll see that we now have a fully
    functional documentation site. We could choose to leave it as-is and simply maintain
    content in GitHub, but, as we noted earlier, we want to include a CMS and allow
    third-party contributors access. Let’s do that.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 随意浏览或搜索。你会发现我们现在有一个完全功能的文档网站。我们可以选择让它保持原样，并在 GitHub 上简单地维护内容，但正如我们之前提到的，我们想要包含一个
    CMS 并允许第三方贡献者访问。让我们这么做。
- en: 4.3.4 Installing Netlify CMS
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.4 安装 Netlify CMS
- en: Now that we have content and a functioning site, we can enable it to be edited
    with Netlify CMS. Before we do that, we need to ensure we’ve published our project
    on GitHub. Please do this if you have not already.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了内容和功能网站，我们可以启用它使用 Netlify CMS 进行编辑。在我们这样做之前，我们需要确保我们已经将我们的项目发布在 GitHub
    上。如果您还没有这样做，请执行此操作。
- en: 'There is no installer for Netlify CMS. Instead, you create the admin and add
    the necessary files into it. Here are the steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Netlify CMS 没有安装程序。相反，你创建管理员并添加必要的文件到其中。以下是步骤：
- en: Create a folder named admin. Since this is Hugo, we need to place it within
    the static directory (i.e., /static/admin) because we do not want the files to
    be processed by Hugo.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 admin 的文件夹。由于这是 Hugo，我们需要将其放置在静态目录中（即 /static/admin），因为我们不希望文件被 Hugo
    处理。
- en: 'Add an index.html within /static/admin that will load the script that runs
    the CMS admin. We’ll use the code supplied by the Netlify CMS docs:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 /static/admin 中添加一个 index.html 文件，该文件将加载运行 CMS 管理员的脚本。我们将使用 Netlify CMS 文档中提供的代码：
- en: '[PRE9]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a config.yml within /static/admin that will contain the Netlify CMS
    configuration. This will eventually contain our full content model definition,
    but for now we’ll add only the base configuration information that we need (note
    that you will need to replace remotesynth/lolcode-docs with your GitHub repository
    information):'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 /static/admin 中创建一个 config.yml 文件，该文件将包含 Netlify CMS 的配置。这最终将包含我们的完整内容模型定义，但现阶段我们只添加所需的基配置信息（注意：您需要将
    remotesynth/lolcode-docs 替换为您自己的 GitHub 仓库信息）：
- en: '[PRE10]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s review what’s in this configuration file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个配置文件中有什么内容：
- en: Setting publish_mode to editorial_workflow creates a draft, review, and approve
    workflow for content. Without setting this, content would be automatically published
    on save. The editorial workflow is a requirement of enabling open authoring.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 publish_mode 设置为 editorial_workflow 会为内容创建一个草稿、审核和批准的工作流程。如果不设置此选项，内容将在保存时自动发布。编辑工作流程是启用开放撰写的必要条件。
- en: The media_folder defines the folder within the site source where images and
    other media files can be uploaded. The public_folder then defines the path to
    the media_folder within the published site.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: media_folder 定义了网站源中可以上传图片和其他媒体文件的文件夹。然后 public_folder 定义了发布网站中 media_folder
    的路径。
- en: The backend section defines the repository details that Netlify CMS uses as
    the site’s backend. The default is Git Gateway, which is an open source API that
    proxies requests between users on your site and the Git repository. This works
    with Netlify Identity, Netlify’s authentication solution, out of the box. However,
    for open authoring in Netlify CMS we must use GitHub, which uses GitHub’s OAuth
    authentication to allow users access. We then define the branch and the repository
    for the site (the sample code points to my repository, so make sure the repository
    reflects your GitHub repository). Finally, we set open_authoring to true to allow
    external contributors without needing to invite them.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端部分定义了 Netlify CMS 使用的作为网站后端的仓库细节。默认是 Git Gateway，这是一个开源 API，它代理了您网站上的用户和 Git
    仓库之间的请求。它与 Netlify Identity（Netlify 的身份验证解决方案）无缝配合。然而，为了在 Netlify CMS 中实现开放撰写，我们必须使用
    GitHub，它使用 GitHub 的 OAuth 身份验证允许用户访问。然后我们定义网站的分支和仓库（示例代码指向我的仓库，所以请确保仓库反映了您的 GitHub
    仓库）。最后，我们将 open_authoring 设置为 true 以允许外部贡献者，而无需邀请他们。
- en: 'We’ve configured the basic settings for Netlify CMS, but it’s not going to
    work just yet for two reasons: we have not modeled any content for Netlify CMS,
    so it does not know anything about what it is editing, and we have not set up
    either Netlify or GitHub to allow users to authenticate.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经配置了 Netlify CMS 的基本设置，但暂时还不能使用，原因有两个：我们尚未为 Netlify CMS 模型任何内容，因此它不知道正在编辑的内容是什么，并且我们尚未设置
    Netlify 或 GitHub 以允许用户进行身份验证。
- en: 4.3.5 Modeling content in Netlify CMS
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.5 在 Netlify CMS 中建模内容
- en: Before it can begin editing your content, Netlify CMS needs to understand its
    structure. It does this by defining collections and fields within the config.yml.
    Depending on the complexity of your site, modeling content for Netlify CMS can
    become a pretty involved task. Luckily, our documentation site’s content is pretty
    straightforward.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编辑内容之前，Netlify CMS 需要了解其结构。它通过在 config.yml 中定义集合和字段来实现这一点。根据您网站复杂性的不同，为 Netlify
    CMS 建模内容可能是一项相当复杂的工作。幸运的是，我们的文档网站的内容相当简单。
- en: Collections
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 集合
- en: 'A collection is a content type in Netlify CMS. This can represent a single
    page, a group of pages with common attributes, or a data file (i.e., YAML, TOML,
    or JSON). There are two collection types in Netlify CMS:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是 Netlify CMS 中的内容类型。这可以代表单个页面、具有共同属性的页面组或数据文件（例如 YAML、TOML 或 JSON）。Netlify
    CMS 中有两种集合类型：
- en: A *folder collection* represents a group of content files that all reside within
    a single folder. It is important to note that, as of this writing, Netlify CMS
    does not support subfolders, meaning that if you had /content/docs/topic-one and
    /content/ docs/topic-two, they could not all be defined using the /docs folder
    and would require three separate collection definitions.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件夹集合*代表一组内容文件，这些文件都位于单个文件夹中。重要的是要注意，截至本文撰写时，Netlify CMS不支持子文件夹，这意味着如果你有/content/docs/topic-one和/content/docs/topic-two，它们不能都使用/docs文件夹定义，并且需要三个单独的集合定义。'
- en: 'A *files collection* represents one or more single files: a page (or pages)
    in Markdown or HTML or a data file (or files) in YAML, TOML, or JSON. When referencing
    a page in Markdown or HTML, you’d typically use the file type for a specialized
    page that does not share attributes with any other of the site’s pages, for example,
    the site’s home page.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件集合*代表一个或多个单个文件：Markdown或HTML中的一个页面（或多个页面），或者YAML、TOML或JSON中的一个数据文件（或多个文件）。当在Markdown或HTML中引用页面时，通常使用特定页面的文件类型，该页面不与其他任何网站页面共享属性，例如网站的主页。'
- en: 'Our documentation site has two content types, one representing the home page,
    which is a file type, and one representing the docs, which is a folder type. Place
    this beneath the backend configuration block right after the line containing open_authoring:
    true:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的文档站点有两种内容类型，一种代表主页，它是一个文件类型，另一种代表文档，它是一个文件夹类型。将此置于后端配置块下方，紧接在包含open_authoring:
    true的行之后：'
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s explore what we’ve configured so far:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索到目前为止我们已经配置了什么：
- en: Every collection must be given a name that is a unique identifier of the collection
    within Netlify CMS. You can use any name you choose, but you should avoid spaces
    or special characters other than dashes or underscores. Meanwhile, the label defines
    how the collection will be displayed to the user within the CMS. You can label
    it however you like.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个集合都必须有一个名称，该名称是Netlify CMS中集合的唯一标识符。你可以使用任何你选择的名称，但你应该避免使用空格或除破折号或下划线之外的特殊字符。同时，标签定义了在CMS中向用户显示集合的方式。你可以随意命名它。
- en: A folder collection represents a single folder with multiple files. Users will
    have the ability to create new pages (create is set to true), and these new pages
    will be Markdown with a file extension of md. The slug field defines how Netlify
    CMS will generate new file names. In our case, we are saying to generate a URL-safe
    version of the content’s title (this means our field definition must contain a
    title field).
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件夹集合代表一个包含多个文件的单一文件夹。用户将能够创建新页面（创建设置为true），并且这些新页面将以md文件扩展名的Markdown格式。slug字段定义了Netlify
    CMS将如何生成新文件名。在我们的例子中，我们说的是生成内容标题的安全URL版本（这意味着我们的字段定义必须包含一个标题字段）。
- en: A files collection must define the different specific files it contains. There
    can be multiple, and each can define their own fields (we’ll discuss this shortly).
    This means that each file in a files collection does not need to share properties,
    but the collection is a way of grouping them together from an editing perspective.
    Our documentation site has only one file representing the home page.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件集合必须定义它包含的不同特定文件。可以有多个，并且每个都可以定义自己的字段（我们将在稍后讨论这一点）。这意味着文件集合中的每个文件不需要共享属性，但集合是从编辑角度将它们分组在一起的一种方式。我们的文档站点只有一个文件代表主页。
- en: Our configuration touches on only a small fraction of the options available
    to you. Check the documentation for a full list of collection configuration options
    ([http://mng.bz/7W9m](http://mng.bz/7W9m)).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的配置仅触及了您可用的选项中的一小部分。请查看文档以获取完整的集合配置选项列表（[http://mng.bz/7W9m](http://mng.bz/7W9m)）。
- en: Fields
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 字段
- en: Fields represent the different data properties (metadata) on a content object.
    For example, a blog post might have a title and a date property, among others,
    that need to be defined as fields within Netlify CMS.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 字段表示内容对象上的不同数据属性（元数据）。例如，一篇博客文章可能有一个标题和日期属性，以及其他需要在Netlify CMS中定义为字段的属性。
- en: Each field is represented by a *widget*. A widget in Netlify CMS determines
    how this particular field will be edited. For example, a text widget would be
    an HTML textarea field, a boolean widget would be a toggle switch, and an image
    widget would be a file picker. Netlify CMS comes with 16 default widgets that
    cover most use cases, but you can define your own custom widgets as well.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字段都由一个*小部件*表示。Netlify CMS中的小部件决定了如何编辑特定字段。例如，文本小部件将是一个HTML文本区域字段，布尔小部件将是一个切换开关，图像小部件将是一个文件选择器。Netlify
    CMS自带16个默认小部件，涵盖了大多数用例，但您也可以定义自己的自定义小部件。
- en: 'Each field we define in our content model has the following common properties:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在内容模型中定义的每个字段都具有以下常见属性：
- en: A widget property that defines which widget will be used for this field in the
    CMS user interface.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个小部件属性，用于定义在CMS用户界面中用于此字段的哪个小部件。
- en: A name that is the field name within Netlify CMS and should be unique within
    this group of fields. You can name it anything, but avoid spaces or special characters
    other than dashes or underscores.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名称，这是Netlify CMS中的字段名称，并且在这个字段组中应该是唯一的。您可以将其命名为任何内容，但请避免使用空格或除破折号或下划线之外的特殊字符。
- en: A required attribute to specify if the field is required. If this isn’t included,
    the default is true.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个必填属性，用于指定字段是否必填。如果不包括此属性，则默认为true。
- en: A hint field that defines text that will appear in a tool tip when the widget
    is displayed in the CMS user interface. This is optional and can be used to offer
    additional help or context to the user for entering values.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个提示字段，用于定义当小部件在CMS用户界面中显示时将出现在工具提示中的文本。这是可选的，可以用来为用户提供额外的帮助或上下文，以便输入值。
- en: A pattern field that can define a regular expression (regex) pattern for validating
    the input and an error message to display when the validation fails. This is optional.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模式字段，可以定义用于验证输入的正则表达式（regex）模式，以及当验证失败时显示的错误消息。这是可选的。
- en: In addition, each type of widget can have widget-specific configuration properties.
    Check the documentation for the full list of options ([https://www.netlifycms.org/docs/widgets/](https://www.netlifycms.org/docs/widgets/)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每种类型的小部件都可以有特定于小部件的配置属性。请查阅文档以获取完整选项列表（[https://www.netlifycms.org/docs/widgets/](https://www.netlifycms.org/docs/widgets/))。
- en: Our field definitions are all fairly straightforward, as the content model for
    our documentation isn’t particularly complex. Here’s the full complete configuration
    file with collections and fields (be sure to update the repo with your own GitHub
    repository).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的字段定义都很简单，因为我们的文档内容模型并不特别复杂。以下是包含集合和字段的完整配置文件（请确保使用您自己的GitHub存储库更新存储库）。
- en: Listing 4.1 The completed Netlify CMS configuration file (/static/admin/config.yml)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 完成的Netlify CMS配置文件（/static/admin/config.yml）
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the configuration in place, we should be able to run hugo serve from the
    command line and then navigate to http://localhost:1313/admin and see a login
    for the admin interface.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 配置就绪后，我们应该能够从命令行运行hugo serve，然后导航到http://localhost:1313/admin，并看到管理员界面的登录界面。
- en: Clicking Login with GitHub will not yet work (figure 4.7), as we have not configured
    Netlify or GitHub for authentication. Let’s do that next.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 点击使用GitHub登录目前还不能工作（图4.7），因为我们还没有为Netlify或GitHub配置身份验证。让我们接下来进行配置。
- en: '![CH04_F07_Camden2](Images/CH04_F07_Camden2.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F07_Camden2](Images/CH04_F07_Camden2.png)'
- en: Figure 4.7 The Netlify CMS login at /admin using GitHub for user authentication
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 使用GitHub进行用户身份验证的Netlify CMS登录页面/admin
- en: 4.3.6 Deploying to Netlify
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.6 部署到Netlify
- en: It is possible to use Netlify CMS without deploying to Netlify, but since Netlify
    created the project, it has the most straightforward path when it comes to enabling
    the authentication that will allow users access to editing the content via the
    CMS. We’ll look at deployment in depth in a later chapter, but for now we’ll cover
    the basics needed to allow users in our Netlify CMS admin.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Netlify CMS而不部署到Netlify，但由于Netlify创建了项目，因此在启用允许用户通过CMS编辑内容的身份验证方面，它具有最直接的路径。我们将在后面的章节中深入探讨部署，但现在是时候介绍允许我们的Netlify
    CMS管理员中的用户的基本内容了。
- en: First, make sure you’ve published your project to GitHub. Again, Netlify CMS
    allows for other Git hosting providers, but we’ll be using GitHub for authentication,
    so publishing there is a requirement in this scenario. Since the repository will
    be editable by third parties, be sure to make the repo public.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请确保您已将项目发布到GitHub。再次强调，Netlify CMS允许使用其他Git托管提供商，但我们将使用GitHub进行身份验证，因此在这种情况下，发布到那里是必需的。由于存储库将由第三方编辑，请确保将存储库设置为公开。
- en: You’ll need to create an account on Netlify if you don’t already have one. Netlify
    offers a generous free plan that will enable you to complete this tutorial. Once
    you’ve created your Netlify account, click the New Site from Git, choose GitHub,
    and then locate your published repository. If this is your first time using Netlify,
    you will need to walk through some authorization steps to allow Netlify access
    to your GitHub repositories, as shown in figure 4.8.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有账户，你需要创建一个Netlify账户。Netlify提供了一个慷慨的免费计划，这将使你能够完成这个教程。一旦你创建了Netlify账户，点击“从Git新建站点”，选择GitHub，然后定位你的已发布仓库。如果你是第一次使用Netlify，你需要完成一些授权步骤，以允许Netlify访问你的GitHub仓库，如图4.8所示。
- en: '![CH04_F08_Camden2](Images/CH04_F08_Camden2.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F08_Camden2](Images/CH04_F08_Camden2.png)'
- en: Figure 4.8 Creating a new site from a GitHub repository in Netlify
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 在Netlify中从GitHub仓库创建新站点
- en: 'Netlify does a good job of picking up on which static site generator we’re
    using and the default settings for it. However, I have frequently run into issues
    when using a recent build of Hugo, so I find it best to set an environment variable
    that matches the Hugo version you are running locally. From the command line,
    type hugo version to see what version you are running. For example, mine returns
    the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Netlify在识别我们使用的静态站点生成器及其默认设置方面做得很好。然而，我经常在使用Hugo的最新构建时遇到问题，所以我发现设置一个与本地运行的Hugo版本匹配的环境变量是最好的。从命令行输入hugo
    version以查看你正在运行的版本。例如，我的返回以下内容：
- en: '[PRE13]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Click on the Show advanced button in the deploy settings step of the setup,
    as seen in figure 4.9.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置步骤的部署设置中，点击如图4.9所示的“显示高级”按钮。
- en: '![CH04_F09_Camden2](Images/CH04_F09_Camden2.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F09_Camden2](Images/CH04_F09_Camden2.png)'
- en: Figure 4.9 The default deploy settings when creating a Hugo site in Netlify
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 在Netlify中创建Hugo站点时的默认部署设置
- en: Click the New Variable button and then add a variable named HUGO_VERSION with
    a value of the version number that is returned by running hugo version. For example,
    in my case, the version is 0.74.3, which I’ve entered in figure 4.10.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“新建变量”按钮，然后添加一个名为HUGO_VERSION的变量，其值为运行hugo version命令返回的版本号。例如，在我的情况下，版本是0.74.3，我已经在图4.10中输入了它。
- en: '![CH04_F10_Camden2](Images/CH04_F10_Camden2.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F10_Camden2](Images/CH04_F10_Camden2.png)'
- en: Figure 4.10 Setting the Hugo version variable in Netlify’s deploy settings setup
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 在Netlify的部署设置中设置Hugo版本变量
- en: Finally, click on Deploy Site. After a few minutes, your site should be deployed.
    Grab the URL that Netlify generated for your site (this can be found in the Site
    overview page in the Netlify dashboard). Let’s fix the baseURL value in the config.toml
    file in the root of the project by setting its value to the URL on Netlify. For
    example, mine is [https://clever-thompson-493f7c.netlify.app/](https://clever-thompson-493f7c.netlify.app/).
    This will fix any missing stylesheets you may see on the site when it is initially
    deployed. We’ll also need the URL for configuring authentication in GitHub.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，点击“部署站点”。几分钟后，你的站点应该已经部署完成。获取Netlify为你生成的站点URL（可以在Netlify仪表板的“站点概览”页面找到）。让我们通过将配置文件config.toml中根目录下的baseURL值设置为Netlify上的URL来修复它。例如，我的URL是[https://clever-thompson-493f7c.netlify.app/](https://clever-thompson-493f7c.netlify.app/)。这将修复在站点最初部署时可能看到的任何缺失样式表。我们还需要GitHub中配置身份验证的URL。
- en: 4.3.7 Configuring GitHub for authentication
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.7 配置GitHub以进行身份验证
- en: Before we can set up authentication in Netlify, we’ll need to set up an OAuth
    application in GitHub. To do this, go to Settings > Developer Settings > OAuth
    Apps and click the button that reads either Register a new application or New
    OAuth App or visit [https://github.com/settings/applications/new](https://github.com/settings/applications/new).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在Netlify上设置身份验证之前，我们需要在GitHub中设置一个OAuth应用程序。为此，转到设置 > 开发者设置 > OAuth应用，并点击显示为“注册新应用程序”或“新建OAuth应用”的按钮，或者访问[https://github.com/settings/applications/new](https://github.com/settings/applications/new)。
- en: We need to give our new OAuth App a name; it can be anything you want. In the
    Homepage URL field, place the URL of your Netlify site (which we received in the
    prior section). The description can also be anything you want. Finally, the authorization
    callback URL needs to be https://api.netlify.com/auth/done. You can see these
    settings in figure 4.11.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为我们新的OAuth应用命名；可以是任何你想要的名称。在主页URL字段中，放置你的Netlify站点URL（我们在上一节中收到）。描述也可以是任何你想要的。最后，授权回调URL需要是https://api.netlify.com/auth/done。你可以在图4.11中看到这些设置。
- en: '![CH04_F11_Camden2](Images/CH04_F11_Camden2.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F11_Camden2](Images/CH04_F11_Camden2.png)'
- en: Figure 4.11 Setting up a new OAuth app in GitHub that can be used with Netlify’s
    authentication
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 在 GitHub 中设置新的 OAuth 应用程序，该应用程序可用于 Netlify 的身份验证
- en: After you click Register application, we’re given a client ID and client secret
    for our OAuth application. We will need these to set up Netlify.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 点击注册应用程序后，我们将获得我们的 OAuth 应用程序的客户端 ID 和客户端密钥。我们需要这些信息来设置 Netlify。
- en: 4.3.8 Configuring Netlify for authentication
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.8 配置 Netlify 以进行身份验证
- en: In our Netlify dashboard for our new site, we need to go to Site Settings >
    Access Control > OAuth. Click the Install Provider button.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们新网站的 Netlify 控制台中，我们需要转到网站设置 > 访问控制 > OAuth。点击安装提供者按钮。
- en: As seen in figure 4.12, the provider should be GitHub and, in the client ID
    and secret fields, place the client ID and client secret we received from our
    GitHub OAuth application. Lastly, click Install.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 4.12 所示，提供者应为 GitHub，并在客户端 ID 和密钥字段中填写我们从 GitHub OAuth 应用程序收到的客户端 ID 和客户端密钥。最后，点击安装。
- en: '![CH04_F12_Camden2](Images/CH04_F12_Camden2.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F12_Camden2](Images/CH04_F12_Camden2.png)'
- en: Figure 4.12 Adding an OAuth provider in Netlify. The client ID and secret come
    from the OAuth application we created in GitHub.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 在 Netlify 中添加 OAuth 提供者。客户端 ID 和密钥来自我们在 GitHub 中创建的 OAuth 应用程序。
- en: 4.3.9 Editing content as an admin
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.9 作为管理员编辑内容
- en: We’re now ready to access the content admin on our documentation site (be sure
    you’ve pushed any changes we’ve made to GitHub first). The admin is available
    at /admin. For instance, the URL of my Netlify site is [https://clever-thompson-493f7c.netlify.app/](https://clever-thompson-493f7c.netlify.app/),
    so the URL for my Netlify CMS admin will be [https://clever-thompson-493f7c.netlify.app/admin](https://clever-thompson-493f7c.netlify.app/admin).
    Before moving on, be sure that you have your GitHub repository set for the value
    of repo in the Netlify CMS configuration (/admin/config.yml).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已准备好访问我们的文档网站上的内容管理员（请确保您已将我们已做的任何更改推送到 GitHub）。管理员在 /admin 下可用。例如，我的 Netlify
    网站的 URL 是 [https://clever-thompson-493f7c.netlify.app/](https://clever-thompson-493f7c.netlify.app/)，因此我的
    Netlify CMS 管理员 URL 将是 [https://clever-thompson-493f7c.netlify.app/admin](https://clever-thompson-493f7c.netlify.app/admin)。在继续之前，请确保您已将
    GitHub 仓库设置为 Netlify CMS 配置中 repo 的值 (/admin/config.yml)。
- en: Click the Login with GitHub button, and we receive the authorization window
    for GitHub based on the GitHub OAuth app we created, as seen in figure 4.13.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“使用 GitHub 登录”按钮，我们将收到基于我们创建的 GitHub OAuth 应用的 GitHub 授权窗口，如图 4.13 所示。
- en: '![CH04_F13_Camden2](Images/CH04_F13_Camden2.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F13_Camden2](Images/CH04_F13_Camden2.png)'
- en: Figure 4.13 The GitHub authorization window is displayed the first time you
    click Login with GitHub and displays the information we entered when creating
    our GitHub OAuth app.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 第一次点击“使用 GitHub 登录”时显示的 GitHub 授权窗口，显示了我们在创建 GitHub OAuth 应用程序时输入的信息。
- en: Once we click Authorize, we’re logged in and taken to the Netlify CMS editing
    dashboard, which you can see in figure 4.14.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 点击授权后，我们将登录并进入 Netlify CMS 编辑仪表板，如图 4.14 所示。
- en: '![CH04_F14_Camden2](Images/CH04_F14_Camden2.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F14_Camden2](Images/CH04_F14_Camden2.png)'
- en: Figure 4.14 The Netlify CMS dashboard after logging in. The collections are
    the ones we defined in the Netlify CMS configuration.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 登录后的 Netlify CMS 仪表板。集合是我们已在 Netlify CMS 配置中定义的。
- en: 'By default, we’re in the Contents tab that shows the content collections we
    defined earlier in the config.yml configuration file: Pages and Docs. The Pages
    collection is selected by default. You may recall that this collection had only
    one content item defined, which is the home page content. You cannot add new pages
    into the Pages collection.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们处于内容标签页，该标签页显示了我们在 config.yml 配置文件中先前定义的内容集合：页面和文档。默认选中页面集合。你可能还记得，这个集合只定义了一个内容项，即主页内容。你不能向页面集合中添加新页面。
- en: When we click the Docs collection, we see a full list of documentation pages
    as well as a button to create a new docs page. Feel free to click one to edit
    it. The editing page is shown in figure 4.15.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击文档集合时，我们会看到一个完整的文档页面列表以及创建新文档页面的按钮。请随意点击一个进行编辑。编辑页面如图 4.15 所示。
- en: '![CH04_F15_Camden2](Images/CH04_F15_Camden2.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F15_Camden2](Images/CH04_F15_Camden2.png)'
- en: Figure 4.15 Editing one of the Docs pages in Netlify CMS. We can see the widgets
    for all the content properties we defined in the fields in the config.yaml.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 在 Netlify CMS 中编辑 Docs 页面之一。我们可以看到所有在 config.yaml 字段中定义的内容属性的小部件。
- en: Each of the widgets on the left-hand side of the page represents the properties
    we defined earlier for the docs content type in the config.yml configuration file.
    The content field offers a WYSIWYG-style editing interface for Markdown content.
    The right side of the page offers a preview of the content being edited.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 页面左侧的每个小部件都代表我们在 config.yml 配置文件中为文档内容类型定义的属性。内容字段提供了一个所见即所得风格的 Markdown 内容编辑界面。页面的右侧提供了一个正在编辑的内容的预览。
- en: Go ahead and make some changes to the content. Once you’ve made changes, click
    the Save button. Since we are using an editorial workflow, the document will be
    saved as a draft in the workflow. We can change the status to In Review or Ready.
    We’ll need to set the status to Ready before we can publish our changes to the
    page.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试对内容进行一些更改。一旦您进行了更改，点击“保存”按钮。由于我们使用的是编辑流程，文档将作为草稿保存在工作流程中。我们可以将状态更改为“待审阅”或“就绪”。在我们可以将更改发布到页面之前，我们需要将状态设置为“就绪”。
- en: In addition, by using Netlify’s deploy previews feature, we can preview our
    changes on the site before we publish. In the top bar of the page, we’ll see a
    “Check for preview” link. Clicking that link will take us to the link for the
    deploy preview of our changes from Netlify, which may take a few seconds. Clicking
    View Preview will open the deploy preview of the site and will include our changes
    so that we can review them before publishing.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过使用 Netlify 的部署预览功能，我们可以在发布之前预览网站上的更改。在页面顶部的工具栏中，我们将看到一个“检查预览”链接。点击该链接将带我们到
    Netlify 的更改部署预览链接，这可能需要几秒钟。点击“查看预览”将打开网站的部署预览，并将包括我们的更改，以便我们在发布之前进行审查。
- en: When you are ready, change the status to Ready, click Publish, and choose Publish
    Now. This will commit the changes to our GitHub repository, which will then trigger
    a build of our Netlify site and publish the changes to our live site.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当您准备好时，将状态更改为“就绪”，点击“发布”，并选择“立即发布”。这将把更改提交到我们的 GitHub 仓库，然后触发我们的 Netlify 网站的构建并发布更改到我们的实时网站。
- en: 4.3.10 The open authoring workflow
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.10 开放式作者工作流程
- en: The flow for our external users will be slightly different. Let’s explore what
    this looks like. You don’t need to follow along with this part, as it would require
    a secondary GitHub account.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们外部用户的工作流程将略有不同。让我们来看看这会是什么样子。您不需要跟随这一部分，因为这需要第二个 GitHub 账户。
- en: Once they log in with GitHub and authorize our GitHub OAuth app, they will be
    asked to fork the repository as seen in figure 4.16\. Clicking Don’t fork the
    repo at this point will exit the process, and the user will be unable to make
    any edits.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦他们使用 GitHub 登录并授权我们的 GitHub OAuth 应用，他们将被要求分叉仓库，如图 4.16 所示。在此处点击“不分叉仓库”将退出流程，用户将无法进行任何编辑。
- en: '![CH04_F16_Camden2](Images/CH04_F16_Camden2.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F16_Camden2](Images/CH04_F16_Camden2.png)'
- en: Figure 4.16 External users will be asked to fork the repo in order to get access
    to the Netlify CMS admin and submit edits to the site.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 外部用户将被要求分叉仓库以获取访问 Netlify CMS 管理员权限并提交对网站的编辑。
- en: Clicking Fork the repo will automatically create a fork of our repository on
    the user’s account. This is where all of the changes the user makes will be kept.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“分叉仓库”将自动在用户的账户上创建我们仓库的分叉。这是用户所做的所有更改将被保存的地方。
- en: Once the user forks the repo, the Netlify CMS admin will be identical to the
    one we used to edit our site earlier. However, when they make changes to the site,
    they do not have the option to set the status to Ready or any of the Publish options.
    Instead, they will only have the option to set the status to In Review. Doing
    so will automatically submit a pull request to our main repo that contains the
    changes the user made, as you can see in figure 4.17.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户分叉了仓库，Netlify CMS 管理员将与我们之前用来编辑网站的相同。然而，当他们对网站进行更改时，他们没有将状态设置为“就绪”或任何发布选项的选项。相反，他们只能将状态设置为“待审阅”。这样做将自动向我们的主仓库提交包含用户所做的更改的拉取请求，如图
    4.17 所示。
- en: '![CH04_F17_Camden2](Images/CH04_F17_Camden2.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F17_Camden2](Images/CH04_F17_Camden2.png)'
- en: Figure 4.17 When a third-party contributor sets a change as In R eview, a pull
    request is automatically submitted on the primary GitHub repository. To accept
    the change, we can merge the pull request.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 当第三方贡献者将更改设置为“待审阅”时，主 GitHub 仓库将自动提交拉取请求。为了接受更改，我们可以合并拉取请求。
- en: To accept the user’s change into our site, we need to merge the pull request.
    This updates our GitHub repository, triggers an update on our Netlify site, and
    publishes the changes to our live site.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将用户的更改合并到我们的网站上，我们需要合并拉取请求。这将更新我们的GitHub仓库，触发我们Netlify网站的更新，并将更改发布到我们的实时网站上。
- en: 4.3.11 Simplifying the open authoring workflow
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.11 简化开放作者工作流程
- en: Before we finish, let’s make one last edit to our site. Right now, any external
    author wishing to contribute to the docs needs to know to go to /admin and log
    in. Contributions would be much more likely if we were to give users quick links
    for adding or editing content from within the documentation itself. To do this,
    we’ll make a small change to the template.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成之前，让我们对我们的网站进行最后一次编辑。目前，任何希望为文档做出贡献的外部作者都需要知道去 /admin 登录。如果我们能在文档内部提供快速链接来添加或编辑内容，那么贡献的可能性会更大。为此，我们将对模板进行一些小的修改。
- en: We are relying on the Hugo-Book theme for our layout and have installed this
    as a Git submodule. Thus, we cannot change the Hugo-Book code directly. Nonetheless,
    Hugo has a lookup order for theme templates that takes the most specific match
    first. This means that we can place files in the /layouts folder that can override
    the template files in the /themes folder. This will make more sense when we see
    how this works in practice.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们依赖于Hugo-Book主题进行布局，并将其作为Git子模块安装。因此，我们无法直接更改Hugo-Book代码。尽管如此，Hugo有一个查找顺序，用于主题模板，它首先查找最具体的匹配项。这意味着我们可以将文件放置在
    /layouts 文件夹中，以覆盖 /themes 文件夹中的模板文件。当我们看到它在实际中的应用时，这会更有意义。
- en: The Hugo-Book theme has layout files that are specifically intended to inject
    content at certain points in the template output, such as before or after the
    content. You can see these files in /themes/book/layouts/partials/docs/inject.
    Let’s add the links at the end of each content page via the content-after.html
    template.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Hugo-Book 主题有布局文件，这些文件专门用于在模板输出中的特定点注入内容，例如在内容之前或之后。您可以在 /themes/book/layouts/partials/docs/inject
    中看到这些文件。让我们通过 content-after.html 模板在每个内容页面的末尾添加链接。
- en: 'To override this template, create a file in your /layouts folder with the same
    directory structure and name: /layouts/partials/docs/inject/content-after.html.
    Since Hugo considers a file in /layouts more specific than the one in /themes,
    by creating a file of the exact same path, Hugo will use it in place of the theme
    file.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖此模板，在您的 /layouts 文件夹中创建一个具有相同目录结构和名称的文件：/layouts/partials/docs/inject/content-after.html。由于Hugo认为
    /layouts 中的文件比 /themes 中的文件更具体，通过创建一个完全相同的路径文件，Hugo将使用它来替代主题文件。
- en: 'Place the following template code inside the file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下模板代码放置在文件中：
- en: '[PRE14]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let’s look at what this template code is doing. First, it checks to see if we
    are on the home page by checking a variable Hugo provides called .RelPermalink
    that contains the relative path of the current page. The function ne in Hugo means
    “not equal,” so we are checking that the relative path is not equal to “/.” We
    do this so as not to offer edit links on the home page. Second, we assemble a
    URL to the admin based on the current page. Finally, we use that URL to add an
    Edit this Page link, which will take them directly into editing the content for
    the page they are currently viewing. We also include an Add a New Page link that
    directly links to creating a new docs page.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个模板代码在做什么。首先，它通过检查Hugo提供的名为 .RelPermalink 的变量来查看我们是否在主页上，该变量包含当前页面的相对路径。在Hugo中，函数
    ne 表示“不等于”，因此我们检查相对路径是否不等于“/”。我们这样做是为了不在主页上提供编辑链接。其次，我们根据当前页面组装一个指向管理员的URL。最后，我们使用该URL添加一个“编辑此页”链接，这将直接带他们进入编辑当前查看的页面内容。我们还包含了一个“添加新页面”链接，该链接直接链接到创建新的文档页面。
- en: After committing and pushing this page to our repository or running it locally,
    we should see these new links added to any Docs page on our site, such as the
    one shown in figure 4.18.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在将此页面提交并推送到我们的仓库或本地运行后，我们应该看到这些新链接添加到我们网站上的任何文档页面，例如图4.18中所示。
- en: '![CH04_F18_Camden2](Images/CH04_F18_Camden2.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![CH04_F18_Camden2](Images/CH04_F18_Camden2.png)'
- en: Figure 4.18 Once we’ve added our template code, Docs pages will have Edit this
    Page and Add a New Page links.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18 一旦我们添加了模板代码，文档页面将会有“编辑此页”和“添加新页面”链接。
- en: 4.4 What’s next?
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4 接下来是什么？
- en: As we’ve seen, the Jamstack can be a powerful solution for documentation sites.
    An open source solution like Netlify CMS offers the ability to use a Git-based
    workflow while still allowing content editors an easy-to-use WYSIWYG editing experience,
    and even allowing third-party contributions—something that isn’t easy with a non-Jamstack
    solution.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Jamstack可以成为文档网站的一个强大解决方案。像Netlify CMS这样的开源解决方案允许使用基于Git的工作流程，同时仍然让内容编辑者享受到易于使用的所见即所得编辑体验，甚至允许第三方贡献——这在非Jamstack解决方案中并不容易实现。
- en: While the editor experience of Netlify CMS is full-featured, some may feel that
    it lacks the polish of some non-Jamstack tools like WordPress. It’s worth keeping
    in mind that there are many alternatives that offer a different editing user experience.
    If you’re looking for a more WordPress-like experience, be sure to explore the
    API-based headless CMS options like Contentful, Sanity, or AgilityCMS, or even
    services like Stackbit.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Netlify CMS的编辑体验功能齐全，但有些人可能觉得它缺乏一些非Jamstack工具（如WordPress）的打磨。值得记住的是，有许多提供不同编辑用户体验的替代方案。如果你在寻找更类似WordPress的体验，务必探索基于API的无头CMS选项，如Contentful、Sanity或AgilityCMS，或者甚至服务如Stackbit。
- en: As we have shown, the Jamstack is an excellent solution for content-focused
    sites like documentation, but you may be wondering if it can handle a site with
    more complex and dynamic user interaction. In the next chapter, we’ll look at
    just such an example as we build an e-commerce site using Jamstack tools.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所展示的，Jamstack是内容导向网站（如文档网站）的一个优秀解决方案，但你可能想知道它是否能够处理具有更复杂和动态用户交互的网站。在下一章中，我们将通过使用Jamstack工具构建电子商务网站来探讨这样一个例子。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Documentation sites have been and continue to be a perfect use case for the
    Jamstack, as they are heavily focused on content and can benefit from things like
    versioning that are a core part of a Jamstack workflow.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档网站一直是并且继续是Jamstack的一个完美用例，因为它们高度关注内容，并可以从版本控制等Jamstack工作流程的核心功能中受益。
- en: A headless CMS is a content management system that offers content editing tools
    that are independent of the site’s frontend display. An API-based headless CMS
    makes the content available to the frontend via an API, while a Git-based headless
    CMS edits content directly in the site’s Git repository.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无头CMS是一种内容管理系统，它提供的内容编辑工具与网站的客户端显示独立。基于API的无头CMS通过API将内容提供给前端，而基于Git的无头CMS则直接在网站的Git仓库中编辑内容。
- en: Netlify CMS is an open source, Git-based headless CMS created and maintained
    by Netlify, which offers the option of an open-authoring workflow. This can allow
    external contributors the option to edit and submit changes to the site’s content.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netlify CMS是由Netlify创建和维护的开源、基于Git的无头CMS，它提供了开放作者工作流程的选项。这可以让外部贡献者有机会编辑和提交网站内容的更改。
- en: There are a lot of documentation-specific static site generators. While Hugo,
    a Go-based static site generator, is not documentation-specific, it is often a
    favored tool for these types of projects due to its build speed and a large number
    of available templates for documentation.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有很多针对文档的特定静态网站生成器。虽然基于Go的静态网站生成器Hugo不是针对文档的，但由于其构建速度和大量可用的文档模板，它通常是这些类型项目的首选工具。
- en: Netlify CMS is configured via YAML and must have a model of the content on the
    site that the CMS will be able to edit. We configured Netlify CMS for the basic
    documentation content model used by our LOLCODE technical documentation site.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netlify CMS通过YAML进行配置，并且必须有一个内容模型，该模型是CMS能够编辑的网站上的内容。我们为我们的LOLCODE技术文档网站使用的基礎文档内容模型配置了Netlify
    CMS。
- en: Open authoring on Netlify CMS allows third-party contributors to have access
    to the CMS to make content contributions. We configured Netlify and GitHub for
    authentication to allow third parties to sign in to our CMS using open authoring.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netlify CMS上的开放作者允许第三方贡献者访问CMS以进行内容贡献。我们配置了Netlify和GitHub进行身份验证，允许第三方使用开放作者登录我们的CMS。
- en: Netlify’s admin interface uses widgets to enable easy editing of the page’s
    metadata (front matter) and content. Markdown editing uses a WYSIWYG-style editing
    interface. The CMS user experience of both the site owner and third-party authors
    is nearly identical, other than the ability to mark updates as Ready and publish
    them, which is reserved for the site owner.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netlify的管理界面使用小部件来简化对页面元数据（前文）和内容的编辑。Markdown编辑使用所见即所得风格的编辑界面。网站所有者和第三方作者的CMS用户体验几乎相同，除了标记更新为“就绪”并发布，这项功能仅限于网站所有者。
