- en: Part 4\. Everyday Java
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四部分\. 每日Java
- en: The fourth part of this book explores various new features in Java 8 and Java
    9 centered around making it easier and more reliable to code your projects. We
    start with two APIs introduced in Java 8.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书第四部分探讨了Java 8和Java 9中围绕使项目编码更容易和更可靠的多种新特性。我们首先介绍Java 8中引入的两个API。
- en: '[Chapter 11](kindle_split_024.xhtml#ch11) covers the `java.util.Optional` class,
    which allows you to both design better APIs and reduce `null` pointer exceptions.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第11章](kindle_split_024.xhtml#ch11)介绍了`java.util.Optional`类，它允许你设计更好的API并减少`null`指针异常。'
- en: '[Chapter 12](kindle_split_025.xhtml#ch12) explores the Date and Time API, which
    greatly improves the previous error-prone APIs for working with dates and time.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第12章](kindle_split_025.xhtml#ch12)探讨了日期和时间API，它极大地改进了之前处理日期和时间的易出错API。'
- en: Then we explain Java 8 and Java 9 enhancements for writing big systems and enabling
    them to evolve.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们解释了Java 8和Java 9在编写大型系统以及使它们能够进化的增强功能。
- en: In [chapter 13](kindle_split_026.xhtml#ch13), you’ll learn what default methods
    are, how you can use them to evolve APIs in a compatible way, some practical usage
    patterns, and rules for using default methods effectively.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](kindle_split_026.xhtml#ch13)中，你将了解默认方法是什么，如何以兼容的方式使用它们来进化API，一些实用的使用模式，以及有效使用默认方法的规则。
- en: '[Chapter 14](kindle_split_027.xhtml#ch14) is new for this second edition and
    explores the Java Module System—a major enhancement in Java 9 that enables huge
    systems to be modularized in a documented and enforceable way, rather than being
    “only a haphazard collection of packages.”'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[第14章](kindle_split_027.xhtml#ch14)是第二版新增的内容，探讨了Java模块系统——Java 9中的一个主要增强功能，它使大型系统能够以文档化和可执行的方式模块化，而不是“仅仅是一堆杂乱无章的包。”'
- en: Chapter 11\. Using Optional as a better alternative to null
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11章\. 使用Optional作为null的更好替代方案
- en: '*This chapter covers*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: What’s wrong with `null` references and why you should avoid them
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`引用有什么问题，为什么你应该避免它们'
- en: 'From `null` to `Optional`: rewriting your domain model in a null-safe way'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`null`到`Optional`：以安全的方式重写你的领域模型
- en: 'Putting optionals to work: removing null checks from your code'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可选用于实际工作：从你的代码中移除null检查
- en: Different ways to read the value possibly contained in an optional
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取可能包含在可选中的值的多种方式
- en: Rethinking programming given potentially missing values
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到可能缺失的值重新思考编程
- en: Raise your hand if you ever got a `NullPointerException` during your life as
    a Java developer. Keep it up if this `Exception` is the one you encounter most
    frequently. Unfortunately, we can’t see you at this moment, but we believe that
    there’s a high probability that your hand is raised now. We also guess that you
    may be thinking something like “Yes, I agree. `NullPointerException`s are a pain
    for any Java developer, novice, or expert. But there’s not much we can do about
    them, because this is the price we pay to use such a convenient, and maybe unavoidable,
    construct as `null` references.” This feeling is common in the (imperative) programming
    world; nevertheless, it may not be the whole truth and is more likely a bias with
    solid historical roots.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你作为Java开发者的一生中曾经遇到过`NullPointerException`，请举手。如果这个`Exception`是你最常遇到的，请继续举手。不幸的是，我们此刻无法看到你，但我们相信你很可能已经举起了手。我们也猜测你可能正在想：“是的，我同意。`NullPointerException`s对于任何Java开发者，无论是新手还是专家来说都是一种痛苦。但我们对此无能为力，因为这是我们为了使用这样方便且可能不可避免的构造`null`引用而付出的代价。”这种感受在（命令式）编程世界中很常见；然而，这可能不是全部真相，更可能是一种有深厚历史根源的偏见。
- en: British computer scientist Tony Hoare introduced `null` references back in 1965
    while designing ALGOL W, one of the first typed programming languages with heap-allocated
    records, later saying that he did so “simply because it was so easy to implement.”
    Despite his goal “to ensure that all use of references could be absolutely safe,
    with checking performed automatically by the compiler,” he decided to make an
    exception for `null` references because he thought that they were the most convenient
    way to model *the absence of a value*. After many years, he regretted this decision,
    calling it “my billion-dollar mistake.” We’ve all seen the effect. We examine
    a field of an object, perhaps to determine whether its value is one of two expected
    forms, only to find that we’re examining not an object but a `null` pointer that
    promptly raises that annoying `NullPointerException`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 英国计算机科学家托尼·霍尔（Tony Hoare）在1965年设计ALGOL W时引入了`null`引用，这是第一种具有堆分配记录的类型化编程语言，后来他说他这样做“仅仅因为它很容易实现。”尽管他的目标是“确保所有引用的使用都能绝对安全，由编译器自动进行检查”，但他决定对`null`引用做出例外，因为他认为这是建模*值缺失*最方便的方式。多年以后，他后悔了这个决定，称其为“我的十亿美元的错误。”我们都看到了它的效果。我们检查一个对象字段，可能是为了确定其值是否是两种预期形式之一，结果却发现我们检查的不是对象，而是一个`null`指针，它立即引发那个讨厌的`NullPointerException`。
- en: In reality, Hoare’s statement could underestimate the costs incurred by millions
    of developers fixing bugs caused by `null` references in the past 50 years. Indeed,
    the vast majority of the languages^([[1](#ch11fn01)]) created in recent decades,
    including Java, have been built with the same design decision, maybe for reasons
    of compatibility with older languages or (more probably), as Hoare states, “simply
    because it was so easy to implement.” We start by showing you a simple example
    of the problems with `null`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，霍尔的声明可能低估了过去50年中数百万开发者因`null`引用导致的错误所造成的成本。确实，近几十年来创建的大多数语言，包括Java，都是基于相同的设计决策构建的，可能是因为与旧语言兼容的原因，或者（更有可能的是），正如霍尔所说，“仅仅因为它很容易实现。”我们首先向你展示一个关于`null`问题的简单示例。
- en: ¹
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notable exceptions include most typed functional languages, such as Haskell
    and ML. These languages include *algebraic data types* that allow data types to
    be expressed succinctly, including explicit specification of whether special values
    such as `null` are to be included on a type-by-type basis.
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 值得注意的是，大多数类型化函数式语言，如Haskell和ML，不包括在内。这些语言包括*代数数据类型*，允许简洁地表达数据类型，包括对特殊值（如`null`）是否要在类型级别上显式指定的明确说明。
- en: 11.1\. How do you model the absence of a value?
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1. 如何建模值的缺失？
- en: Imagine that you have the following nested object structure for a person who
    owns a car and has car insurance in the following listing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个如下嵌套的对象结构，用于表示一个拥有汽车并购买汽车保险的人。
- en: Listing 11.1\. The `Person`/`Car`/`Insurance` data model
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.1. `Person`/`Car`/`Insurance`数据模型
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What’s problematic with the following code?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码有什么问题？
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code looks pretty reasonable, but many people don’t own a car, so what’s
    the result of calling the method `getCar`? A common unfortunate practice is to
    return the `null` reference to indicate the absence of a value (here, to indicate
    the absence of a car). As a consequence, the call to `getInsurance` returns the
    insurance of a `null` reference, which results in a `NullPointerException` at
    runtime and stops your program from running further. But that’s not all. What
    if `person` was `null`? What if the method `getInsurance` returned `null` too?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来相当合理，但许多人并不拥有汽车，那么调用`getCar`方法的结果是什么？一个常见的令人遗憾的做法是返回`null`引用来表示值的缺失（在这里，表示汽车的缺失）。因此，调用`getInsurance`方法返回了`null`引用的保险，这导致在运行时抛出`NullPointerException`，并停止程序进一步运行。但不仅如此。如果`person`是`null`呢？如果`getInsurance`方法也返回`null`呢？
- en: 11.1.1\. Reducing NullPointerExceptions with defensive checking
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.1. 通过防御性检查减少`NullPointerException`
- en: What can you do to avoid running into an unexpected `NullPointerException`?
    Typically, you can add `null` checks where necessary (and sometimes, in an excess
    of defensive programming, even where not necessary) and often with different styles.
    A first attempt to write a method preventing a `NullPointerException` is shown
    in the following listing.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你能做些什么来避免遇到意外的`NullPointerException`？通常，你可以在必要时添加`null`检查（有时，在过度防御性编程的情况下，甚至在不必要的地方）并且通常以不同的风格。以下列表展示了防止`NullPointerException`的一个方法尝试。
- en: 'Listing 11.2\. `Null`-safe attempt 1: deep doubts'
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.2. `Null`-安全尝试1：深重的疑虑
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Each null check increases the nesting level of the remaining part of
    the invocation chain.**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 每次对 `null` 的检查都会增加调用链剩余部分的嵌套级别。**'
- en: This method performs a `null` check every time it dereferences a variable, returning
    the string `"Unknown"` if any of the variables traversed in this dereferencing
    chain is a `null` value. The only exception to this rule is that you’re not checking
    to see whether the name of the insurance company is `null` because (like any other
    company) you *know* it must have a name. Note that you can avoid this last check
    only because of your knowledge of the business domain, but that fact isn’t reflected
    in the Java classes modeling your data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法在每次解引用变量时都会进行 `null` 检查，如果在这个解引用链中遍历的任何变量是 `null` 值，则返回字符串 `"Unknown"`。这个规则的唯一例外是，你不会检查保险公司名称是否为
    `null`，因为（就像任何其他公司一样）你 *知道* 它必须有一个名称。请注意，你之所以能够避免这个最后的检查，仅仅是因为你对业务领域的了解，但这个事实并没有反映在建模数据的
    Java 类中。
- en: 'We labeled the method in [listing 11.2](#ch11ex02) “deep doubts” because it
    shows a recurring pattern: every time you doubt that a variable could be `null`,
    you’re obliged to add a further nested `if` block, increasing the indentation
    level of the code. This technique clearly scales poorly and compromises readability,
    so maybe you’d like to attempt another solution. Try to avoid this problem by
    doing something different as shown in the next listing.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个方法在 [列表 11.2](#ch11ex02) 中标记为“深疑虑”，因为它展示了一个反复出现的模式：每次你怀疑一个变量可能是 `null`
    时，你都必须添加一个额外的嵌套 `if` 块，增加代码的缩进级别。这种技术显然扩展性不好，并损害了可读性，所以你可能想尝试另一种解决方案。尝试通过在下一个列表中展示的不同方法来避免这个问题。
- en: 'Listing 11.3\. `Null`-safe attempt 2: too many exits'
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.3\. `Null`-安全尝试 2：退出点过多
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Each null check adds a further exit point.**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 每次对 `null` 的检查都会增加一个额外的退出点。**'
- en: 'In this second attempt, you try to avoid the deeply nested `if` blocks, adopting
    a different strategy: every time you meet a `null` variable, you return the string
    `"Unknown"`. Nevertheless, this solution is also far from ideal; now the method
    has four distinct exit points, making it hard to maintain. Even worse, the default
    value to be returned in case of a `null`, the string `"Unknown"`, is repeated
    in three places—and (we hope) not misspelled! (You may want to extract the repeated
    string into a constant to prevent this problem, of course.)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次尝试中，你试图避免深层嵌套的 `if` 块，采用不同的策略：每次遇到 `null` 变量时，你返回字符串 `"Unknown"`。然而，这个解决方案也远非理想；现在方法有四个不同的退出点，这使得维护变得困难。更糟糕的是，在
    `null` 的情况下要返回的默认值，即字符串 `"Unknown"`，在三个地方被重复——（我们希望）没有拼写错误！（你当然可能想要将重复的字符串提取到一个常量中，以防止这个问题。）
- en: Furthermore, the process is error-prone. What if you forget to check whether
    one property could be `null`? We argue in this chapter that using `null` to represent
    the absence of a value is the wrong approach. What you need is a better way to
    model the absence and presence of a value.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个过程是容易出错的。如果你忘记检查某个属性是否可能是 `null` 会怎样？我们在本章中论证，使用 `null` 来表示值的缺失是错误的方法。你需要的是更好地建模值的存在和缺失的方法。
- en: 11.1.2\. Problems with null
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.2\. `null` 的问题
- en: 'To recap our discussion so far, the use of `null` references in Java causes
    both theoretical and practical problems:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们到目前为止的讨论，Java 中 `null` 引用的使用既引起理论问题，也引起实际问题：
- en: '***It’s a source of error.*** `NullPointerException` is by far the most common
    exception in Java.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***这是一个错误来源。*** `NullPointerException` 是 Java 中最常见的一种异常。'
- en: '***It bloats your code.*** It worsens readability by making it necessary to
    fill your code with `null` checks that are often deeply nested.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***它膨胀了你的代码。*** 它通过使代码必须填充 `null` 检查（这些检查通常是深层嵌套的）来降低可读性。'
- en: '***It’s meaningless.*** It doesn’t have any semantic meaning, and in particular,
    it represents the wrong way to model the absence of a value in a statically typed
    language.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***它是无意义的。*** 它没有任何语义意义，特别是在静态类型语言中，它代表了错误地建模值缺失的方式。'
- en: '***It breaks Java philosophy.*** Java always hides pointers from developers
    except in one case: the `null` pointer.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***它违背了 Java 的哲学。*** Java 总是除了一个情况外隐藏指针给开发者：`null` 指针。'
- en: '***It creates a hole in the type system.*** `null` carries no type or other
    information, so it can be assigned to any reference type. This situation is a
    problem because when `null` is propagated to another part of the system, you have
    no idea what that `null` was initially supposed to be.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***它破坏了类型系统。*** `null` 不携带任何类型或其他信息，因此它可以分配给任何引用类型。这种情况是一个问题，因为当 `null` 被传播到系统的另一部分时，你不知道那个
    `null` 初始时应该是什么。'
- en: To provide some context for other solutions, in the next section we briefly
    look at what other programming languages have to offer.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为其他解决方案提供一些背景，在下一节中，我们将简要地看看其他编程语言能提供什么。
- en: 11.1.3\. What are the alternatives to null in other languages?
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.3. 其他语言中null的替代方案有哪些？
- en: 'In recent years, languages such as Groovy worked around this problem by introducing
    a *safe navigation operator*, represented by `?.`, to safely navigate potentially
    `null` values. To understand how this process works, consider the following Groovy
    code, which retrieves the name of the insurance company used by a given person
    to insure a car:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，像Groovy这样的语言通过引入一个表示为`?.`的**安全导航操作符**来解决这个问题，以安全地导航可能为`null`的值。为了理解这个过程是如何工作的，考虑以下Groovy代码，它检索一个给定的人用来为汽车投保的保险公司的名称：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What this statement does should be clear. A person may not have a car, and you
    tend to model this possibility by assigning a `null` to the car reference of the
    `Person` object. Similarly, a `car` may not be insured. The Groovy safe navigation
    operator allows you to safely navigate these potentially `null` references without
    throwing a `NullPointer-Exception` by propagating the `null` reference through
    the invocations chain, returning a `null` in the event that any value in the chain
    is a `null`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句所做的事情应该是清晰的。一个人可能没有车，你通常会通过将`Person`对象的汽车引用赋值为`null`来模拟这种可能性。同样，一辆车可能没有被投保。Groovy的安全导航操作符允许你安全地导航这些可能为`null`的引用，而不会通过调用链传播`null`引用，在链中的任何值是`null`的情况下返回`null`。
- en: A similar feature was proposed and then discarded for Java 7\. Somehow, though,
    we don’t seem to miss a safe navigation operator in Java. The first temptation
    of all Java developers when confronted with a `NullPointerException` is to fix
    it quickly by adding an `if` statement, checking that a value isn’t `null` before
    invoking a method on it. If you solve this problem in this way, without wondering
    whether it’s correct for your algorithm or your data model to present a `null`
    value in that specific situation, you’re not fixing a bug but hiding it, making
    its discovery and remedy far more difficult for whoever will be called to work
    on it next time (likely you in the next week or month). You’re sweeping the dirt
    under the carpet. Groovy’s null-safe dereferencing operator is only a bigger and
    more powerful broom for making this mistake without worrying too much about its
    consequences.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的功能曾提出并被废弃用于Java 7。然而，我们似乎并不缺少Java中的安全导航操作符。所有Java开发者面对`NullPointerException`时的第一个冲动是快速修复它，通过添加一个`if`语句，在调用方法之前检查值是否不是`null`。如果你以这种方式解决这个问题，而不考虑它是否适合你的算法或数据模型在那种特定情况下呈现`null`值，你并没有修复一个错误，而是在隐藏它，使得下次被叫来工作的人（很可能是你下周或下个月）发现和修复它变得更加困难。你是在把脏东西扫到地毯下。Groovy的null安全解引用操作符只是更大、更强大的扫帚，让你在不必过于担心其后果的情况下犯这个错误。
- en: Other functional languages, such as Haskell and Scala, take a different view.
    Haskell includes a `Maybe` type, which essentially encapsulates an optional value.
    A value of type `Maybe` can contain a value of a given type or nothing. Haskell
    no concept of a `null` reference. Scala has a similar construct called `Option[T]`
    to encapsulate the presence or absence of a value of type `T`, which we discuss
    in [chapter 20](kindle_split_035.xhtml#ch20). Then you have to explicitly check
    whether a value is present or not using operations available on the `Option` type,
    which enforces the idea of “`null` checking.” You can no longer forget to check
    for `null`—because checking is enforced by the type system.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 其他函数式语言，如Haskell和Scala，持有不同的观点。Haskell包含一个`Maybe`类型，它本质上封装了一个可选值。`Maybe`类型的值可以包含给定类型的值或无值。Haskell没有`null`引用的概念。Scala有一个类似的构造，称为`Option[T]`，用于封装类型`T`的值的呈现或缺失，我们将在[第20章](kindle_split_035.xhtml#ch20)中讨论。然后你必须显式地检查值是否存在，这需要使用`Option`类型上的操作，这强制执行了“`null`检查”的概念。你不能再忘记检查`null`——因为检查是由类型系统强制执行的。
- en: Okay, we’ve diverged a bit, and all this sounds fairly abstract. You may wonder
    about Java 8\. Java 8 takes inspiration from this idea of an optional value by
    introducing a new class called `java.util.Optional<T>`! In this chapter, we show
    the advantages of using this class to model potentially absent values instead
    of assigning a `null` reference to them. We also clarify how this migration from
    `null`s to `Optional`s requires you to rethink the way you deal with optional
    values in your domain model. Finally, we explore the features of this new `Optional`
    class and provide a few practical examples showing how to use it effectively.
    Ultimately, you learn how to design better APIs in which users can tell whether
    to expect an optional value by reading the signature of a method.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们有点偏离主题了，所有这些都听起来相当抽象。你可能想知道 Java 8。Java 8 通过引入一个名为 `java.util.Optional<T>`
    的新类来从这种可选值的想法中汲取灵感！在本章中，我们展示了使用此类来建模可能缺失的值而不是将 `null` 引用分配给它们的优点。我们还阐明了从 `null`
    迁移到 `Optional` 需要你重新思考你在领域模型中处理可选值的方式。最后，我们探讨了这种新 `Optional` 类的功能，并提供了一些实际示例，展示了如何有效地使用它。最终，你将学习如何设计更好的
    API，用户可以通过阅读方法的签名来判断是否可以期望一个可选值。
- en: 11.2\. Introducing the Optional class
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2\. 引入 `Optional` 类
- en: Java 8 introduces a new class called `java.util.Optional<T>` that’s inspired
    by Haskell and Scala. The class encapsulates an optional value. If you know that
    a person may not have a car, for example, the `car` variable inside the `Person`
    class shouldn’t be declared type `Car` and assigned to a `null` reference when
    the person doesn’t own a car; instead, it should be type `Optional<Car>`, as illustrated
    in [figure 11.1](#ch11fig01).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 引入了一个名为 `java.util.Optional<T>` 的新类，它受到了 Haskell 和 Scala 的启发。该类封装了一个可选值。例如，如果你知道一个人可能没有汽车，那么
    `Person` 类内部的 `car` 变量不应该声明为 `Car` 类型，并在这个人没有汽车时分配一个 `null` 引用；相反，它应该声明为 `Optional<Car>`
    类型，如图 11.1 所示。
- en: Figure 11.1\. An optional `Car`
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.1\. 一个可选的 `Car`
- en: '![](Images/11fig01.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片 11.1](Images/11fig01.jpg)'
- en: When a value is present, the `Optional` class wraps it. Conversely, the absence
    of a value is modeled with an empty optional returned by the method `Optional.empty`.
    This static factory method returns a special singleton instance of the `Optional`
    class. You may wonder about the difference between a `null` reference and `Optional.empty()`.
    Semantically, they could be seen as the same thing, but in practice, the difference
    is huge. Trying to dereference a `null` invariably causes a `NullPointerException`,
    whereas `Optional.empty()` is a valid, workable object of type `Optional` that
    can be invoked in useful ways. You’ll soon see how.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在值时，`Optional` 类会将其包装起来。相反，值的缺失通过方法 `Optional.empty()` 返回的空 `Optional` 来建模。这个静态工厂方法返回
    `Optional` 类的特殊单例实例。你可能想知道 `null` 引用和 `Optional.empty()` 之间的区别。从语义上看，它们可能被视为相同的东西，但在实践中，区别很大。尝试取消引用
    `null` 总是会导致 `NullPointerException`，而 `Optional.empty()` 是一个有效的、可工作的 `Optional`
    类型的对象，可以用有用的方式调用。你很快就会看到这一点。
- en: An important, practical semantic difference in using `Optional`s instead of
    `null`s is that in the first case, declaring a variable of type `Optional<Car>`
    instead of `Car` clearly signals that a missing value is permitted there. Conversely,
    always using the type `Car` and possibly assigning a `null` reference to a variable
    of that type implies that you don’t have any help, other than your knowledge of
    the business model, in understanding whether the `null` belongs to the valid domain
    of that given variable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Optional` 而不是 `null` 的一个重要、实用的语义区别在于，在前者的情况下，声明一个 `Optional<Car>` 类型的变量而不是
    `Car` 类型，清楚地表明那里允许缺失的值。相反，始终使用 `Car` 类型，并可能将 `null` 引用分配给该类型的变量，意味着除了你对业务模型的知识之外，你没有其他帮助来理解
    `null` 是否属于该给定变量的有效域。
- en: With this act in mind, you can rework the original model from [listing 11.1](#ch11ex01),
    using the `Optional` class as shown in the following listing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，你可以重新设计 [列表 11.1](#ch11ex01) 中的原始模型，如下所示使用 `Optional` 类。
- en: Listing 11.4\. Redefining the `Person`/`Car`/`Insurance` data model by using
    `Optional`
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.4\. 通过使用 `Optional` 重新定义 `Person`/`Car`/`Insurance` 数据模型
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* A person may not own a car, so you declare this field Optional.**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个人可能没有汽车，因此你可以将此字段标记为可选。**'
- en: '***2* A car may not be insured, so you declare this field Optional.**'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 汽车可能没有保险，因此你可以将此字段标记为可选。**'
- en: '***3* An insurance company must have a name.**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 保险公司必须有一个名称。**'
- en: Note how the use of the `Optional` class enriches the semantics of your model.
    The fact that a person references an `Optional<Car>`, and a car references an
    `Optional <Insurance>`, makes it explicit in the domain that a person *may* or
    *may not* own a car, and that car *may* or *may not* be insured.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Optional`类的使用如何丰富了你的模型的语义。一个人引用`Optional<Car>`，一辆车引用`Optional<Insurance>`，这在领域中明确表示一个人*可能*或*可能不*拥有一辆车，以及这辆车*可能*或*可能不*被保险。
- en: At the same time, the fact that the name of the insurance company is declared
    of type `String` instead of `Optional<String>` makes it evident that an insurance
    company must have a name. This way, you know for certain whether you’ll get a
    `NullPointer-Exception` when dereferencing the name of an insurance company; you
    don’t have to add a `null` check, because doing so will hide the problem instead
    of fixing it. An insurance company must have a name, so if you find one without
    a name, you’ll have to work out what’s wrong in your data instead of adding a
    piece of code to cover up this circumstance. Consistently using `Optional` values
    creates a clear distinction between a missing value that’s planned for and a value
    that’s absent only because of a bug in your algorithm or a problem in your data.
    It’s important to note that the intention of the `Optional` class isn’t to replace
    every single `null` reference. Instead, its purpose is to help you design more-comprehensible
    APIs so that by reading the signature of a method, you can tell whether to expect
    an optional value. You’re forced to actively unwrap an optional to deal with the
    absence of a value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，保险公司名称被声明为`String`类型而不是`Optional<String>`类型的事实表明，保险公司必须有一个名称。这样，你就可以确定在解引用保险公司名称时是否会得到`NullPointer-Exception`；你不需要添加`null`检查，因为这样做会隐藏问题而不是解决问题。保险公司必须有一个名称，所以如果你发现一个没有名称的保险公司，你必须找出你的数据中有什么问题，而不是添加一段代码来掩盖这种情况。一致地使用`Optional`值可以在计划中缺失的值和仅因为你的算法或数据中的问题而缺失的值之间创建一个清晰的区分。重要的是要注意，`Optional`类的意图并不是要替换每一个`null`引用。相反，它的目的是帮助你设计更易于理解的API，这样通过阅读方法的签名，你可以知道是否期望一个可选值。你必须主动解包可选值来处理值的缺失。
- en: 11.3\. Patterns for adopting Optionals
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3. 采用Optional的模式
- en: So far, so good; you’ve learned how to employ optionals in types to clarify
    your domain model, and you’ve seen the advantages of this process over representing
    missing values with `null` references. How can you use optionals now? More specifically,
    how can you use a value wrapped in an optional?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利；你已经学会了如何在类型中使用可选来澄清你的领域模型，你也看到了这种方法相对于用`null`引用表示缺失值的优点。你现在如何使用可选？更具体地说，你如何使用一个被可选包裹的值？
- en: 11.3.1\. Creating Optional objects
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.1. 创建Optional对象
- en: The first step before working with `Optional` is learning how to create optional
    objects! You can create them in several ways.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`Optional`之前的第一步是学习如何创建可选对象！你可以通过几种方式创建它们。
- en: Empty optional
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 空的Optional
- en: 'As mentioned earlier, you can get hold of an empty optional object by using
    the static factory method `Optional.empty`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你可以通过使用静态工厂方法`Optional.empty`获取一个空的可选对象：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Optional from a non-null value
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从非`null`值创建Optional
- en: 'You can also create an optional from a non-null value with the static factory
    method `Optional.of`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用静态工厂方法`Optional.of`从一个非`null`值创建一个可选对象：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If `car` were `null`, a `NullPointerException` would be thrown immediately (rather
    than getting a latent error when you try to access properties of the car).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`car`是`null`，会立即抛出`NullPointerException`（而不是在你尝试访问汽车的属性时得到潜在的错误）。
- en: Optional from null
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从`null`创建Optional
- en: 'Finally, by using the static factory method `Optional.ofNullable`, you can
    create an `Optional` object that may hold a `null` value:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过使用静态工厂方法`Optional.ofNullable`，你可以创建一个可能包含`null`值的`Optional`对象：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If `car` were `null`, the resulting `Optional` object would be empty.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`car`是`null`，生成的`Optional`对象将是空的。
- en: You might imagine that we’ll continue by investigating how to get a value out
    of an optional. A `get` method does precisely this, and we talk more about it
    later. But `get` raises an exception when the optional is empty, so using it in
    an ill-disciplined manner effectively re-creates all the maintenance problems
    caused by using `null`. Instead, we start by looking at ways of using optional
    values that avoid explicit tests, inspired by similar operations on streams.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想象我们会继续研究如何从一个可选对象中获取值。`get`方法正是这样做的，我们稍后会详细讨论。但是，当可选对象为空时，`get`会抛出异常，所以以不严谨的方式使用它实际上会重新创建使用`null`时引起的所有维护问题。相反，我们首先看看使用可选值的方法，这些方法避免了显式的测试，并受到流上类似操作的启发。
- en: 11.3.2\. Extracting and transforming values from Optionals with map
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.2\. 使用map从可选对象中提取和转换值
- en: 'A common pattern is to extract information from an object. You may want to
    extract the name from an insurance company, for example. You need to check whether
    `insurance` is `null` before extracting the name as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的模式是从对象中提取信息。例如，你可能想从一个保险公司中提取名称。在提取名称之前，你需要检查`insurance`是否为`null`，如下所示：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`Optional` supports a `map` method for this pattern, which works as follows
    (from here on, we use the model presented in [listing 11.4](#ch11ex04)):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional`支持一个`map`方法来实现这种模式，其工作方式如下（从现在开始，我们使用[列表11.4](#ch11ex04)中提出的模型）：'
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method is conceptually similar to the `map` method of Stream you saw in
    [chapters 4](kindle_split_015.xhtml#ch04) and [5](kindle_split_016.xhtml#ch05).
    The `map` operation applies the provided function to each element of a stream.
    You could also think of an `Optional` object as being a particular collection
    of data, containing at most a single element. If the `Optional` contains a value,
    the function passed as argument to `map` transforms that value. If the `Optional`
    is empty, nothing happens. [Figure 11.2](#ch11fig02) illustrates this similarity,
    showing what happens when you pass a function that transforms a square into a
    triangle to the `map` methods of both a stream of square and an optional of square.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在概念上与你在第4章和第5章中看到的Stream的`map`方法相似。`map`操作将提供的函数应用于流中的每个元素。你也可以将`Optional`对象视为特定数据集合，最多包含一个元素。如果`Optional`包含一个值，则`map`方法传递的函数会转换该值。如果`Optional`为空，则不执行任何操作。[图11.2](#ch11fig02)说明了这种相似性，展示了当你将一个将正方形转换为三角形的函数传递给正方形流和正方形可选对象的`map`方法时会发生什么。
- en: Figure 11.2\. Comparing the `map` methods of `Stream`s and `Optional`s
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.2\. 比较`Stream`和`Optional`的`map`方法
- en: '![](Images/11fig02_alt.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig02_alt.jpg)'
- en: This idea looks useful, but how can you use it to rewrite the code in [listing
    11.1](#ch11ex01),
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法看起来很有用，但你如何使用它来重写[列表11.1](#ch11ex01)中的代码？
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: which chains several method calls, in a safe way?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如何以安全的方式链式调用多个方法？
- en: The answer is to use another method supported by `Optional` called `flatMap`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是使用`Optional`支持的另一个方法，称为`flatMap`。
- en: 11.3.3\. Chaining Optional objects with flatMap
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.3\. 使用flatMap链式连接可选对象
- en: 'Because you’ve learned how to use `map`, your first reaction may be to use
    `map` to rewrite the code as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你已经学会了如何使用`map`，你的第一个反应可能是使用`map`重写代码如下：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Unfortunately, this code doesn’t compile. Why? The variable `optPerson` is of
    type `Optional<Person>`, so it’s perfectly fine to call the `map` method. But
    `getCar` returns an object of type `Optional<Car>` (as presented in [listing 11.4](#ch11ex04)),
    which means that the result of the `map` operation is an object of type `Optional<Optional<Car>>`.
    As a result, the call to `getInsurance` is invalid because the outermost optional
    contains as its value another optional, which of course doesn’t support the `getInsurance`
    method. [Figure 11.3](#ch11fig03) illustrates the nested optional structure you’d
    get.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这段代码无法编译。为什么？变量`optPerson`的类型是`Optional<Person>`，所以调用`map`方法是完全可行的。但是`getCar`返回一个类型为`Optional<Car>`的对象（如[列表11.4](#ch11ex04)所示），这意味着`map`操作的结果是一个类型为`Optional<Optional<Car>>`的对象。因此，调用`getInsurance`是无效的，因为最外层的可选对象包含另一个可选对象作为其值，这当然不支持`getInsurance`方法。[图11.3](#ch11fig03)说明了你将得到的嵌套可选结构。
- en: Figure 11.3\. A two-level optional
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.3\. 二级可选对象
- en: '![](Images/11fig03.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig03.jpg)'
- en: 'How can you solve this problem? Again, you can look at a pattern you’ve used
    previously with streams: the `flatMap` method. With streams, the `flatMap` method
    takes a function as an argument and returns another stream. This function is applied
    to each element of a stream, resulting in a stream of streams. But `flatMap` has
    the effect of replacing each generated stream with the contents of that stream.
    In other words, all the separate streams that are generated by the function get
    amalgamated or flattened into a single stream. What you want here is something
    similar, but you want to flatten a two-level optional into one.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你该如何解决这个问题？再次，你可以看看你之前在流中使用过的模式：`flatMap` 方法。在流中，`flatMap` 方法接受一个函数作为参数，并返回另一个流。这个函数应用于流中的每个元素，结果产生一个流中的流。但
    `flatMap` 有将每个生成的流替换为其内容的效应。换句话说，所有由该函数生成的单独的流都被合并或展平成一个单一的流。你在这里想要的类似的东西，但你想要展平一个两级的
    `Optional` 到一个级别。
- en: As [figure 11.2](#ch11fig02) does for the `map` method, [figure 11.4](#ch11fig04)
    illustrates the similarities between the `flatMap` methods of the `Stream` and
    `Optional` classes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 [图 11.2](#ch11fig02) 对 `map` 方法所做的那样，[图 11.4](#ch11fig04) 阐述了 `Stream` 和
    `Optional` 类的 `flatMap` 方法的相似性。
- en: Figure 11.4\. Comparing the `flatMap` methods of `Stream` and `Optional`
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.4\. 比较 `Stream` 和 `Optional` 的 `flatMap` 方法
- en: '![](Images/11fig04_alt.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig04_alt.jpg)'
- en: Here, the function passed to the stream’s `flatMap` method transforms each square
    into another stream containing two triangles. Then the result of a simple `map`
    is a stream containing three other streams, each with two triangles, but the `flatMap`
    method flattens this two-level stream into a single stream containing six triangles
    in total. In the same way, the function passed to the optional’s `flatMap` method
    transforms the square contained in the original optional into an optional containing
    a triangle. If this function were passed to the `map` method, the result would
    be an optional containing another optional that in turn contains a triangle, but
    the `flatMap` method flattens this two-level optional into a single optional containing
    a triangle.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，传递给流 `flatMap` 方法的函数将每个正方形转换成包含两个三角形的另一个流。然后简单 `map` 的结果是包含三个其他流的流，每个流包含两个三角形，但
    `flatMap` 方法将这个两级的流展平成一个包含总共六个三角形的单一流。同样，传递给 `Optional` 的 `flatMap` 方法的函数将原始 `Optional`
    中的正方形转换成一个包含三角形的 `Optional`。如果这个函数传递给 `map` 方法，结果将是一个包含另一个包含三角形的 `Optional` 的
    `Optional`，但 `flatMap` 方法将这个两级的 `Optional` 展平成一个包含三角形的单一 `Optional`。
- en: Finding a car’s insurance company name with optionals
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 `Optional` 查找汽车的保险公司名称
- en: Now that you know the theory of the `map` and `flatMap` methods of `Optional`,
    you’re ready to put them into practice. The ugly attempts made in [listings 11.2](#ch11ex02)
    and [11.3](#ch11ex03) can be rewritten by using the optional-based data model
    of [listing 11.4](#ch11ex04) as follows.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 `Optional` 的 `map` 和 `flatMap` 方法的理论，你就可以将它们付诸实践。在 [列表 11.2](#ch11ex02)
    和 [11.3](#ch11ex03) 中做出的丑陋尝试可以通过使用 [列表 11.4](#ch11ex04) 中的基于 `Optional` 的数据模型来重写，如下所示。
- en: Listing 11.5\. Finding a car’s insurance company name with `Optionals`
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.5\. 使用 `Optional` 查找汽车的保险公司名称
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* A default value if the resulting Optional is empty**'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果结果 `Optional` 为空，则提供一个默认值**'
- en: Comparing [listing 11.5](#ch11ex05) with the two former attempts shows the advantages
    of using optionals when dealing with potentially missing values. This time, you
    can obtain what you want with an easily comprehensible statement instead of increasing
    the code complexity with conditional branches.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将 [列表 11.5](#ch11ex05) 与前两种尝试进行比较，显示了在处理可能缺失的值时使用 `Optional` 的优势。这次，你可以用一个容易理解的表达式来获得你想要的结果，而不是通过条件分支来增加代码的复杂性。
- en: In implementation terms, first note that you modify the signature of the `getCar-InsuranceName`
    method from [listings 11.2](#ch11ex02) and [11.3](#ch11ex03). We explicitly said
    that there could be a case in which a nonexistent `Person` is passed to this method,
    such as when that `Person` is retrieved from a database via an identifier, and
    you want to model the possibility that no `Person` exists in your data for the
    given identifier. You model this additional requirement by changing the type of
    the method’s argument from `Person` to `Optional<Person>`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现方面，首先请注意，你修改了 `getCar-InsuranceName` 方法的签名，如 [列表 11.2](#ch11ex02) 和 [11.3](#ch11ex03)
    所示。我们明确指出，可能存在一种情况，即传递给此方法的 `Person` 不存在，例如当通过标识符从数据库中检索 `Person` 时，你想要模拟给定标识符在数据中不存在
    `Person` 的可能性。你通过将方法参数的类型从 `Person` 更改为 `Optional<Person>` 来模拟这个额外需求。
- en: 'Once again, this approach allows you to make explicit through the type system
    something that otherwise would remain implicit in your knowledge of the domain
    model: the first purpose of a language, even a programming language, is communication.
    Declaring a method to take an optional as an argument or to return an optional
    as a result documents to your colleagues—and all future users of your method—that
    it can take an empty value or give an empty value as a result.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这种方法允许你通过类型系统明确表达出在领域模型知识中原本可能保持隐含的内容：语言的第一要务，即使是编程语言，也是沟通。将一个方法声明为接受一个可选参数或返回一个可选结果，这样就可以向你的同事以及所有未来的方法使用者表明，它可以接受一个空值或返回一个空值。
- en: Person/Car/Insurance dereferencing chain using optionals
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用可选进行 Person/Car/Insurance 解引用链
- en: Starting with this `Optional<Person>`, the `Car` from the `Person`, the `Insurance`
    from the `Car`, and the `String` containing the insurance company name from the
    `Insurance` are dereferenced with a combination of the `map` and `flatMap` methods
    introduced earlier in this chapter. [Figure 11.5](#ch11fig05) illustrates this
    pipeline of operations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个 `Optional<Person>` 开始，`Person` 中的 `Car`，`Car` 中的 `Insurance`，以及 `Insurance`
    中包含的保险公司名称的 `String`，都通过本章前面引入的 `map` 和 `flatMap` 方法组合进行解引用。[图 11.5](#ch11fig05)
    展示了这个操作流程。
- en: Figure 11.5\. The `Person/Car/Insurance` dereferencing chain using optionals
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.5\. 使用可选进行 Person/Car/Insurance 解引用链
- en: '![](Images/11fig05_alt.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片 11.5](Images/11fig05_alt.jpg)'
- en: Here, you begin with the optional that wraps the `Person` and invokes `flat-Map(Person::getCar)`
    on it. As we said, you can logically think of this invocation as something that
    happens in two steps. In step 1, a `Function` is applied to the `Person` inside
    the optional to transform it. In this case, the `Function` is expressed with a
    method reference invoking the method `getCar` on that `Person`. Because that method
    returns an `Optional<Car>`, the `Person` inside the optional is transformed into
    an instance of that type, resulting in a two-level optional that’s flattened as
    part of the `flatMap` operation. From a theoretical point of view, you can think
    of this flattening operation as the operation that combines two nested optionals,
    resulting in an empty optional if at least one of them is empty. What happens
    in reality is that if you invoke `flatMap` on an empty optional, nothing is changed,
    and the empty optional is returned as is. Conversely, if the optional wraps a
    `Person`, the `Function` passed to the `flatMap` method is applied to that `Person`.
    Because the value produced by that `Function` application is already an optional,
    the `flatMap` method can return it as is.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你从包裹 `Person` 的可选开始，并对其调用 `flatMap(Person::getCar)`。正如我们所说的，你可以逻辑上认为这个调用分为两个步骤。在步骤
    1 中，一个 `Function` 被应用于可选内的 `Person` 以进行转换。在这种情况下，`Function` 通过一个方法引用来调用该 `Person`
    的 `getCar` 方法。因为该方法返回一个 `Optional<Car>`，所以可选内的 `Person` 被转换成该类型的一个实例，从而在 `flatMap`
    操作中形成一个两级的可选，该可选被扁平化。从理论角度来看，你可以将这个扁平化操作视为组合两个嵌套可选的操作，如果至少有一个为空，则结果为空可选。在现实中，如果你在空可选上调用
    `flatMap`，则没有任何变化，空可选按原样返回。相反，如果可选包裹了一个 `Person`，则传递给 `flatMap` 方法的 `Function`
    被应用于该 `Person`。因为该 `Function` 应用产生的值已经是可选，所以 `flatMap` 方法可以按原样返回它。
- en: 'The second step is similar to the first one, transforming the `Optional<Car>`
    into an `Optional<Insurance>`. Step 3 turns the `Optional<Insurance>` into an
    `Optional <String>`: because the `Insurance.getName()` method returns a `String`.
    In this case, a `flatMap` isn’t necessary.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步与第一步类似，将 `Optional<Car>` 转换为 `Optional<Insurance>`。第 3 步将 `Optional<Insurance>`
    转换为 `Optional<String>`：因为 `Insurance.getName()` 方法返回一个 `String`。在这种情况下，不需要 `flatMap`。
- en: At this point the resulting optional will be empty if any of the methods in
    this invocation chain returns an empty optional or otherwise contains the desired
    insurance company name. How do you read that value? After all, you’ll end up getting
    an `Optional<String>` that may or may not contain the name of the insurance company.
    In [listing 11.5](#ch11ex05), we used another method called `orElse`, which provides
    a default value in case the optional is empty. Many methods provide default actions
    or unwrap an optional. In the next section, we look at those methods in detail.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果这个调用链中的任何方法返回一个空的 `Optional` 或包含所需的保险公司名称，那么生成的 `Optional` 将是空的。你如何读取这个值？毕竟，你最终会得到一个可能包含或不包含保险公司名称的
    `Optional<String>`。在 [列表 11.5](#ch11ex05) 中，我们使用了另一个名为 `orElse` 的方法，它会在 `Optional`
    为空时提供一个默认值。许多方法提供了默认操作或解包 `Optional`。在下一节中，我们将详细探讨这些方法。
- en: '|  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Using optionals in a domain model and why they’re not serializable**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**在领域模型中使用可选类型及其不可序列化的原因**'
- en: In [listing 11.4](#ch11ex04), we showed how to use `Optional`s in your domain
    model to mark with a specific type the values that are allowed to be missing or
    remain undefined. The designers of the `Optional` class, however, developed it
    based on different assumptions and with a different use case in mind. In particular,
    Java language architect Brian Goetz clearly stated that the purpose of `Optional`
    is to support the optional-return idiom only.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 11.4](#ch11ex04) 中，我们展示了如何在领域模型中使用 `Optional` 来标记允许缺失或保持未定义的特定类型的值。然而，`Optional`
    类的设计者基于不同的假设和不同的使用场景来开发它。特别是，Java 语言架构师 Brian Goetz 明确表示，`Optional` 的目的是仅支持可选返回语法的习惯用法。
- en: 'Because the `Optional` class wasn’t intended for use as a field type, it doesn’t
    implement the `Serializable` interface. For this reason, using `Optional`s in
    your domain model could break applications with tools or frameworks that require
    a serializable model to work. Nevertheless, we believe that we’ve showed you why
    using `Optional`s as a proper type in your domain is a good idea, especially when
    you have to traverse a graph of objects that potentially aren’t present. Alternatively,
    if you need to have a serializable domain model, we suggest that you at least
    provide a method allowing access to any possibly missing value as an optional,
    as in the following example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Optional` 类并非旨在用作字段类型，它没有实现 `Serializable` 接口。因此，在领域模型中使用 `Optional` 可能会破坏需要序列化模型才能工作的工具或框架的应用程序。尽管如此，我们相信我们已经向你展示了为什么在领域中使用
    `Optional` 作为适当类型是一个好主意，尤其是在你需要遍历可能不存在对象的图时。或者，如果你需要一个可序列化的领域模型，我们建议你至少提供一个方法，允许以可选形式访问任何可能缺失的值，如下例所示：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 11.3.4\. Manipulating a stream of optionals
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '|'
- en: '![](Images/java.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/java.jpg)'
- en: 'The `Optional`’s `stream()` method, introduced in Java 9, allows you to convert
    an `Optional` with a value to a `Stream` containing only that value or an empty
    `Optional` to an equally empty `Stream`. This technique can be particularly convenient
    in a common case: when you have a `Stream` of `Optional` and need to transform
    it into another `Stream` containing only the values present in the nonempty `Optional`
    of the original `Stream`. In this section, we demonstrate with another practical
    example why you could find yourself having to deal with a `Stream` of `Optional`
    and how to perform this operation.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 中引入的 `Optional` 类的 `stream()` 方法允许你将包含值的 `Optional` 转换为只包含该值的 `Stream`，或者将一个空的
    `Optional` 转换为同样空的 `Stream`。这种技术在某些常见情况下特别方便：当你有一个 `Optional` 的 `Stream`，需要将其转换成另一个只包含原始
    `Stream` 中非空 `Optional` 的值的 `Stream` 时。在本节中，我们通过另一个实际例子来展示为什么你可能需要处理一个 `Optional`
    的 `Stream`，以及如何执行这个操作。
- en: The example in [listing 11.6](#ch11ex06) uses the `Person`/`Car`/`Insurance`
    domain model defined in [listing 11.4](#ch11ex04), Suppose that you’re required
    to implement a method that’s passed with a `List<Person>` and that should return
    a `Set<String>` containing all the distinct names of the insurance companies used
    by the people in that list who own a car.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11.6](#ch11ex06) 中的示例使用了在 [列表 11.4](#ch11ex04) 中定义的 `Person`/`Car`/`Insurance`
    领域模型，假设你需要实现一个方法，该方法接收一个 `List<Person>` 并返回一个包含列表中拥有汽车的人所使用的所有不同保险公司名称的 `Set<String>`。'
- en: Listing 11.6\. Finding distinct insurance company names used by a list of `persons`
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.6\. 找出由人员列表使用的不同保险公司名称
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Convert the list of persons into a Stream of Optional<Car> with the cars
    eventually owned by them.**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将人员列表转换为包含他们最终拥有的汽车的 Optional<Car> Stream。**'
- en: '***2* FlatMap each Optional<Car> into the corresponding Optional<Insurance>.**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将每个 Optional<Car> 平铺映射到相应的 Optional<Insurance>。**'
- en: '***3* Map each Optional<Insurance> into the Optional<String> containing the
    corresponding name.**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将每个 Optional<Insurance> 映射到包含相应名称的 Optional<String>。**'
- en: '***4* Transform the Stream<Optional<String>> into a Stream<String> containing
    only the present names.**'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将 Stream<Optional<String>> 转换为只包含现有名称的 Stream<String>。**'
- en: '***5* Collect the result Strings into a Set to obtain only the distinct values.**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将结果字符串收集到集合中，以获得唯一的值。**'
- en: Often, manipulating the elements of a `Stream` results in a long chain of transformations,
    filters, and other operations, but this case has an additional complication because
    each element is also wrapped into an `Optional`. Remember that you modeled the
    fact that a person may not have a car by making its `getCar()` method return an
    `Optional<Car>` instead of a simple `Car`. So, after the first `map` transformation,
    you obtain a `Stream<Optional<Car>>`. At this point, the two subsequent `map`s
    allow you to transform each `Optional<Car>` into an `Optional<Insurance>` and
    then each of them into an `Optional<String>` as you did in [listing 11.5](#ch11ex05)
    for a single element instead of a `Stream`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，操作 `Stream` 的元素会导致一系列长链的转换、过滤和其他操作，但这个案例有一个额外的复杂性，因为每个元素也被包装进了一个 `Optional`。记住，你通过使
    `getCar()` 方法返回 `Optional<Car>` 而不是简单的 `Car` 来模拟一个人可能没有车的事实。因此，在第一次 `map` 转换之后，你得到了一个
    `Stream<Optional<Car>>`。在这个时候，接下来的两个 `map` 转换允许你将每个 `Optional<Car>` 转换为 `Optional<Insurance>`，然后再将它们转换为
    `Optional<String>`，就像你在 [列表 11.5](#ch11ex05) 中对一个单独的元素所做的那样，而不是一个 `Stream`。
- en: 'At the end of these three transformations, you obtain a `Stream<Optional<String>>`
    in which some of these `Optional`s may be empty because a person doesn’t own a
    car or because the car isn’t insured. The use of `Optional`s allows you to perform
    these operations in a completely null-safe way even in case of missing values,
    but now you have the problem of getting rid of the empty `Optional`s and unwrapping
    the values contained in the remaining ones before collecting the results into
    a `Set`. You could have obtained this result with a `filter` followed by a `map`,
    of course, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个转换结束时，你得到了一个 `Stream<Optional<String>>`，其中一些 `Optional` 可能是空的，因为一个人没有车或者车没有保险。`Optional`
    的使用允许你在缺失值的情况下以完全无空安全的方式执行这些操作，但现在你面临的问题是，在将结果收集到集合之前，需要去除空的 `Optional` 并展开剩余的
    `Optional` 中包含的值。当然，你可以通过一个 `filter` 后跟一个 `map` 来获得这个结果，如下所示：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As anticipated in [listing 11.6](#ch11ex06), however, it’s possible to achieve
    the same result in a single operation instead of two by using the `stream()` method
    of the `Optional` class. Indeed, this method transforms each `Optional` into a
    `Stream` with zero or one elements, depending on whether the transformed `Optional`
    is empty. For this reason, a reference to that method can be seen as a function
    from a single element of the `Stream` to another `Stream` and then passed to the
    `flatMap` method invoked on the original `Stream`. As you’ve already learned,
    in this way each element is converted to a `Stream` and then the two-level `Stream`
    of `Stream`s is flattened into a single-level one. This trick allows you to unwrap
    the `Optional`s containing a value and skip the empty ones in only one step.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如[列表11.6](#ch11ex06)中预期的，使用`Optional`类的`stream()`方法可以在一个操作中实现相同的结果，而不是两个操作。实际上，此方法将每个`Optional`转换为一个包含零个或一个元素的`Stream`，具体取决于转换后的`Optional`是否为空。因此，对该方法的引用可以被视为一个从`Stream`的单个元素到另一个`Stream`的函数，然后传递给在原始`Stream`上调用的`flatMap`方法。正如你已经学到的，这样每个元素都会被转换为一个`Stream`，然后两级的`Stream`流被展平为单级。这个技巧允许你在一步中展开包含值的`Optional`并跳过空的`Optional`。
- en: 11.3.5\. Default actions and unwrapping an Optional
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.5\. 默认操作和展开Optional
- en: 'In [section 11.3.3](#ch11lev2sec6), you decided to read an `Optional` value
    using the `orElse` method, which allows you to also provide a default value that
    will be returned in the case of an empty optional. The `Optional` class provides
    several instance methods to read the value contained by an `Optional` instance:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11.3.3节](#ch11lev2sec6)中，你决定使用`orElse`方法来读取一个`Optional`值，该方法还允许你在空`Optional`的情况下返回一个默认值。`Optional`类提供了几个实例方法来读取`Optional`实例中包含的值：
- en: '`get()` is the simplest but also the least safe of these methods. It returns
    the wrapped value if one is present and throws a `NoSuchElementException` otherwise.
    For this reason, using this method is almost always a bad idea unless you’re sure
    that the optional contains a value. In addition, this method isn’t much of an
    improvement on nested `null` checks.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`是这些方法中最简单但也是最不安全的。如果存在包装的值，则返回该值，否则抛出`NoSuchElementException`。因此，除非你确定`Optional`包含一个值，否则几乎总是不建议使用此方法。此外，此方法在嵌套`null`检查方面并没有太大的改进。'
- en: '`orElse(T other)` is the method used in [listing 11.5](#ch11ex05), and as we
    noted there, it allows you to provide a default value when the optional doesn’t
    contain a value.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElse(T other)`是[列表11.5](#ch11ex05)中使用的的方法，正如我们之前提到的，它允许你在`Optional`不包含值时提供一个默认值。'
- en: '`orElseGet(Supplier<? extends T> other)` is the lazy counterpart of the `orElse`
    method, because the supplier is invoked only if the optional contains no value.
    You should use this method when the default value is time-consuming to create
    (to gain efficiency) or you want the supplier to be invoked only if the optional
    is empty (when using `orElseGet` is vital).'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElseGet(Supplier<? extends T> other)`是`orElse`方法的懒加载对应物，因为只有在`Optional`不包含值时才会调用供应商。你应该在默认值创建耗时（为了提高效率）或你希望供应商仅在`Optional`为空时被调用时使用此方法（当使用`orElseGet`时至关重要）。'
- en: '`or(Supplier<? extends Optional<? extends T>> supplier)` is similar to the
    former `orElseGet` method, but it doesn’t unwrap the value inside the `Optional`,
    if present. In practice, this method (introduced with Java 9) doesn’t perform
    any action and returns the `Optional` as it is when it contains a value, but lazily
    provides a different `Optional` when the original one is empty.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or(Supplier<? extends Optional<? extends T>> supplier)`与之前的`orElseGet`方法类似，但它不会展开`Optional`内部的值（如果存在）。实际上，此方法（从Java
    9引入）不执行任何操作，当`Optional`包含值时按原样返回`Optional`，但当原始`Optional`为空时，它将延迟提供一个不同的`Optional`。'
- en: '`orElseThrow(Supplier<? extends X> exceptionSupplier)` is similar to the `get`
    method in that it throws an exception when the `optional` is empty, but it allows
    you to choose the type of exception that you want to throw.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orElseThrow(Supplier<? extends X> exceptionSupplier)`与`get`方法类似，当`optional`为空时抛出异常，但它允许你选择要抛出的异常类型。'
- en: '`ifPresent(Consumer<? super T> consumer)` lets you execute the action given
    as argument if a value is present; otherwise, no action is taken.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifPresent(Consumer<? super T> consumer)`允许你在存在值时执行作为参数给出的操作；否则，不执行任何操作。'
- en: 'Java 9 introduced an additional instance method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9引入了一个额外的实例方法：
- en: '`ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)`. This differs
    from `ifPresent` by taking a `Runnable` that gives an empty-based action to be
    executed when the `Optional` is empty.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifPresentOrElse(Consumer<? super T> action, Runnable emptyAction)`。这与`ifPresent`不同，它接受一个`Runnable`，当`Optional`为空时执行基于空的操作。'
- en: 11.3.6\. Combining two Optionals
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.6. 组合两个可选对象
- en: 'Now suppose that you have a method that, given a `Person` and a `Car`, queries
    some external services and implements some complex business logic to find the
    insurance company that offers the cheapest policy for that combination:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设您有一个方法，给定一个`Person`和一个`Car`，查询一些外部服务并实现一些复杂的业务逻辑来找到为该组合提供最便宜保单的保险公司：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Also suppose that you want to develop a null-safe version of this method, taking
    two optionals as arguments and returning an `Optional<Insurance>` that will be
    empty if at least one of the values passed in to it is also empty. The `Optional`
    class also provides an `isPresent` method that returns `true` if the optional
    contains a value, so your first attempt could be to implement this method as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，假设您想开发一个null安全的版本的方法，该方法接受两个可选参数，并返回一个`Optional<Insurance>`，如果传递给它的值中至少有一个为空，则该值将为空。`Optional`类还提供了一个`isPresent`方法，当可选包含值时返回`true`，因此您的第一次尝试可能是如下实现此方法：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method has the advantage of making clear in its signature that both the
    `Person` and the `Car` values passed to it could be missing and that for this
    reason, it couldn’t return any value. Unfortunately, its implementation resembles
    too closely the `null` checks that you’d write if the method took as arguments
    a `Person` and a `Car`, both of which could be `null`. Is there a better, more
    idiomatic way to implement this method by using the features of the `Optional`
    class? Take a few minutes to go through quiz 11.1, and try to find an elegant
    solution.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优势在于，在其签名中清楚地表明传递给它的`Person`和`Car`值都可能缺失，因此它不能返回任何值。不幸的是，它的实现与如果方法以`Person`和`Car`作为参数，这两个参数都可能为`null`时编写的`null`检查非常相似。有没有一种更好的、更符合习惯的方法来实现这个方法，使用`Optional`类的功能？花几分钟时间通过练习11.1，并尝试找到一个优雅的解决方案。
- en: '|  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quiz 11.1: Combining two optionals without unwrapping them**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习11.1：在不展开的情况下组合两个可选对象**'
- en: Using a combination of the `map` and `flatMap` methods you learned in this section,
    rewrite the implementation of the former `nullSafeFindCheapestInsurance()` method
    in a single statement.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您在本节中学到的`map`和`flatMap`方法的组合，将前一个`nullSafeFindCheapestInsurance()`方法的实现重写为一个语句。
- en: '**Answer:**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: 'You can implement that method in a single statement and without using any conditional
    constructs like the ternary operator as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在一个语句中实现该方法，并且不使用任何条件结构，如三元运算符，如下所示：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, you invoke a `flatMap` on the first optional, so if this optional is empty,
    the lambda expression passed to it won’t be executed, and this invocation will
    return an empty optional. Conversely, if the person is present, `flatMap` uses
    it as the input to a `Function` returning an `Optional<Insurance>` as required
    by the `flatMap` method. The body of this function invokes a `map` on the second
    optional, so if it doesn’t contain any `Car`, the `Function` returns an empty
    optional, and so does the whole `nullSafeFindCheapestInsurance` method. Finally,
    if both the `Person` and the `Car` are present, the lambda expression passed as
    an argument to the `map` method can safely invoke the original `findCheapestInsurance`
    method with them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您在第一个可选对象上调用`flatMap`，所以如果这个可选对象为空，传递给它的lambda表达式将不会执行，并且这个调用将返回一个空的可选对象。相反，如果存在人，`flatMap`将其用作`Function`的输入，该`Function`返回一个`Optional<Insurance>`，这是`flatMap`方法所要求的。这个函数的主体在第二个可选对象上调用`map`，所以如果它不包含任何`Car`，则`Function`返回一个空的可选对象，整个`nullSafeFindCheapestInsurance`方法也是如此。最后，如果`Person`和`Car`都存在，传递给`map`方法的lambda表达式可以安全地调用原始的`findCheapestInsurance`方法。
- en: '|  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The analogies between the `Optional` class and the `Stream` interface aren’t
    limited to the `map` and `flatMap` methods. A third method, `filter`, behaves
    in a similar fashion on both classes, and we explore it next.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional`类和`Stream`接口之间的类比不仅限于`map`和`flatMap`方法。第三个方法`filter`在两个类上都有类似的行为，我们将在下一节中探讨它。'
- en: 11.3.7\. Rejecting certain values with filter
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.7. 使用filter拒绝某些值
- en: 'Often, you need to call a method on an object to check some property. You may
    need to check whether the insurance’s name is equal to `CambridgeInsurance`, for
    example. To do so in a safe way, first check whether the reference that points
    to an `Insurance` object is `null` and then call the `getName` method, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您需要在一个对象上调用一个方法来检查某个属性。例如，您可能需要检查保险公司的名称是否等于 `CambridgeInsurance`。为了安全地这样做，首先检查指向
    `Insurance` 对象的引用是否为 `null`，然后调用 `getName` 方法，如下所示：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can rewrite this pattern by using the `filter` method on an `Optional`
    object, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `Optional` 对象上的 `filter` 方法重写此模式，如下所示：
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `filter` method takes a predicate as an argument. If a value is present
    in the `Optional` object, and that value matches the predicate, the `filter` method
    returns that value; otherwise, it returns an empty `Optional` object. If you remember
    that you can think of an optional as being a stream containing at most a single
    element, the behavior of this method should be clear. If the optional is already
    empty, it doesn’t have any effect; otherwise, it applies the predicate to the
    value contained in the optional. If this application returns `true`, the optional
    returns unchanged; otherwise, the value is filtered away, leaving the optional
    empty. You can test your understanding of how the `filter` method works by working
    through quiz 11.2.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter` 方法接受一个谓词作为参数。如果 `Optional` 对象中存在值，并且该值与谓词匹配，则 `filter` 方法返回该值；否则，它返回一个空的
    `Optional` 对象。如果您还记得，您可以将 Optional 视为一个最多包含一个元素的流，那么这个方法的行为应该是清晰的。如果 Optional
    已经为空，则它没有任何效果；否则，它将谓词应用于 Optional 中包含的值。如果此应用返回 `true`，则 Optional 保持不变；否则，值被过滤掉，留下空的
    Optional。您可以通过完成练习 11.2 来测试您对 `filter` 方法工作的理解。'
- en: '|  |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quiz 11.2: Filtering an optional**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 11.2：过滤可选值**'
- en: Supposing that the `Person` class of your `Person`/`Car`/`Insurance` model also
    has a method `getAge` to access the age of the person, modify the `getCarInsuranceName`
    method in [listing 11.5](#ch11ex05) by using the signature
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的 `Person`/`Car`/`Insurance` 模型的 `Person` 类也有一个 `getAge` 方法来访问人员的年龄，通过使用以下签名修改
    [代码列表 11.5](#ch11ex05) 中的 `getCarInsuranceName` 方法：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: so that the insurance company name is returned *only* if the person has an age
    greater than or equal to the `minAge` argument.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以便仅在人员年龄大于或等于 `minAge` 参数时返回保险公司名称。
- en: '**Answer:**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: 'You can filter the `Optional<Person>`, to remove any contained person whose
    age fails to be at least the `minAge` argument, by encoding this condition in
    a predicate passed to the `filter` method as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将此条件编码在传递给 `filter` 方法的谓词中，来过滤 `Optional<Person>`，以删除任何年龄不足 `minAge` 参数的包含人员：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the next section, we investigate the remaining features of the `Optional`
    class and provide more practical examples of various techniques you could use
    to reimplement the code you write to manage missing values.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将研究 `Optional` 类的其余功能，并提供更多实际示例，说明您可以使用各种技术重新实现您编写的代码以管理缺失值。
- en: '[Table 11.1](#ch11table01) summarizes the methods of the `Optional` class.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 11.1](#ch11table01) 总结了 `Optional` 类的方法。'
- en: Table 11.1\. The methods of the `Optional` class
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 11.1\. `Optional` 类的方法
- en: '| Method | Description |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| empty | Returns an empty Optional instance |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| empty | 返回一个空的 Optional 实例 |'
- en: '| filter | If the value is present and matches the given predicate, returns
    this Optional; otherwise, returns the empty one |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| filter | 如果存在值且与给定的谓词匹配，则返回此 Optional；否则，返回空的 |'
- en: '| flatMap | If a value is present, returns the Optional resulting from the
    application of the provided mapping function to it; otherwise, returns the empty
    Optional |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| flatMap | 如果存在值，则返回应用提供的映射函数后的 Optional；否则，返回空的 Optional |'
- en: '| get | Returns the value wrapped by this Optional if present; otherwise, throws
    a NoSuchElementException |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| get | 如果存在，则返回此 Optional 包装的值；否则，抛出 NoSuchElementException |'
- en: '| ifPresent | If a value is present, invokes the specified consumer with the
    value; otherwise, does nothing |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| ifPresent | 如果存在值，则使用指定的消费者调用该值；否则，不执行任何操作 |'
- en: '| ifPresentOrElse | If a value is present, performs an action with the value
    as input; otherwise, performs a different action with no input |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| ifPresentOrElse | 如果存在值，则使用该值作为输入执行操作；否则，使用无输入执行不同的操作 |'
- en: '| isPresent | Returns true if a value is present; otherwise, returns false
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| isPresent | 如果存在值，则返回 true；否则，返回 false |'
- en: '| map | If a value is present, applies the provided mapping function to it
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| map | 如果存在值，则应用提供的映射函数到它上 |'
- en: '| of | Returns an Optional wrapping the given value or throws a NullPointer-Exception
    if this value is null |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| of | 返回一个包装给定值的Optional，如果此值为null则抛出NullPointer-Exception |'
- en: '| ofNullable | Returns an Optional wrapping the given value or the empty Optional
    if this value is null |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| ofNullable | 返回一个包装给定值的Optional，如果此值为null则返回空的Optional |'
- en: '| or | If the value is present, returns the same Optional; otherwise, returns
    another Optional produced by the supplying function |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| or | 如果值存在，则返回相同的Optional；否则，返回由供应函数产生的另一个Optional |'
- en: '| orElse | Returns the value if present; otherwise, returns the given default
    value |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| orElse | 如果存在值，则返回该值；否则，返回给定的默认值 |'
- en: '| orElseGet | Returns the value if present; otherwise, returns the one provided
    by the given Supplier |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| orElseGet | 如果存在值，则返回该值；否则，返回由给定的Supplier提供的值 |'
- en: '| orElseThrow | Returns the value if present; otherwise, throws the exception
    created by the given Supplier |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| orElseThrow | 如果存在值，则返回该值；否则，抛出由给定的Supplier创建的异常 |'
- en: '| stream | If a value is present, returns a Stream containing only it; otherwise,
    returns an empty Stream |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| stream | 如果存在值，则返回只包含该值的Stream；否则，返回一个空的Stream |'
- en: 11.4\. Practical examples of using Optional
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4\. 使用Optional的实用示例
- en: As you’ve learned, effective use of the new `Optional` class implies a complete
    rethink of how you deal with potentially missing values. This rethink involves
    not only the code you write, but also (and possibly even more important) how you
    interact with native Java APIs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所学的，有效使用新的`Optional`类意味着对如何处理可能缺失的值的完全重新思考。这种重新思考不仅涉及你编写的代码，而且还涉及（可能甚至更重要）你与原生Java
    API的交互。
- en: Indeed, we believe that many of those APIs would have been written differently
    if the `Optional` class had been available when they were developed. For backward-compatibility
    reasons, old Java APIs can’t be changed to make proper use of optionals, but all
    is not lost. You can fix, or at least work around, this issue by adding to your
    code small utility methods that allow you to benefit from the power of optionals.
    You see how to do this with a couple of practical examples.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们相信，如果当时在开发这些API时就有`Optional`类，那么其中许多API可能会被编写得不同。出于向后兼容性的原因，旧的Java API不能被修改以正确使用optionals，但并非一切都已失去。你可以通过向你的代码中添加小的实用方法来修复，或者至少解决这个问题，这些方法允许你从optionals的力量中受益。你可以通过几个实际示例看到如何做到这一点。
- en: 11.4.1\. Wrapping a potentially null value in an Optional
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.1\. 将可能为null的值包装在Optional中
- en: An existing Java API almost always returns a `null` to signal that the required
    value is absent or that the computation to obtain it failed for some reason. The
    `get` method of a `Map` returns `null` as its value if it contains no mapping
    for the requested key, for example. But for the reasons we listed earlier, in
    most cases like this one, you prefer for these methods to return an optional.
    You can’t modify the signature of these methods, but you can easily wrap the value
    they return with an optional. Continuing with the `Map` example, and supposing
    that you have a `Map<String, Object>`, accessing the value indexed by `key` with
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一个现有的Java API几乎总是返回`null`来表示所需值不存在或由于某些原因获取它的计算失败。例如，`Map`的`get`方法在没有为请求的键包含映射时返回`null`作为其值。但是，由于我们之前列出的原因，在这种情况下的大多数情况下，你更希望这些方法返回一个optional。你不能修改这些方法的签名，但你很容易用optional包装它们返回的值。继续使用`Map`示例，假设你有一个`Map<String,
    Object>`，通过以下方式访问由`key`索引的值
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'returns `null` if there’s no value in the `map` associated with the `String
    "key"`. You can improve such code by wrapping in an optional the value returned
    by the `map`. You can either add an ugly `if-then-else` that adds to code complexity,
    or you can use the method `Optional.ofNullable` that we discussed earlier:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与`String "key"`关联的`map`中没有值，则返回`null`。你可以通过将`map`返回的值包装在optional中来改进这样的代码。你可以添加一个丑陋的`if-then-else`来增加代码复杂性，或者你可以使用我们之前讨论过的`Optional.ofNullable`方法：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can use this method every time you want to safely transform a value that
    could be `null` into an optional.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在每次想要安全地将可能为`null`的值转换为optional时使用此方法。
- en: 11.4.2\. Exceptions vs. Optional
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.2\. 异常与Optional的比较
- en: Throwing an exception is another common alternative in the Java API to returning
    a `null` when a value can’t be provided. A typical example is the conversion of
    `String` into an `int` provided by the `Integer.parseInt(String)` static method.
    In this case, if the `String` doesn’t contain a parseable integer, this method
    throws a `NumberFormat-Exception`. Once again, the net effect is that the code
    signals an invalid argument if a `String` doesn’t represent an integer, the only
    difference being that this time, you have to check it with a `try/catch` block
    instead of using an `if` condition to control whether a value isn’t `null`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常是 Java API 中在无法提供值时返回 `null` 的另一种常见替代方案。一个典型的例子是 `Integer.parseInt(String)`
    静态方法提供的将 `String` 转换为 `int` 的操作。在这种情况下，如果 `String` 不包含可解析的整数，则此方法会抛出 `NumberFormatException`。再次强调，最终效果是代码在
    `String` 不表示整数时发出无效参数的信号，唯一的区别是这次您必须使用 `try/catch` 块而不是使用 `if` 条件来控制值是否不是 `null`。
- en: You could also model the invalid value caused by nonconvertible `String`s with
    an empty optional, so you prefer that `parseInt` returns an optional. You can’t
    change the original Java method, but nothing prevents you from implementing a
    tiny utility method, wrapping it, and returning an optional as desired, as shown
    in the following listing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用空的可选值来模拟由不可转换的 `String` 引起的无效值，因此您更倾向于让 `parseInt` 返回一个可选值。您不能更改原始的 Java
    方法，但没有任何东西阻止您实现一个微小的实用方法，将其包装起来，并按需返回一个可选值，如下面的列表所示。
- en: Listing 11.7\. Converting a `String` to an `Integer` returning an optional
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.7\. 将 `String` 转换为 `Integer` 并返回一个可选值
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* If the String can be converted to an Integer, return an optional containing
    it.**'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果字符串可以被转换为整数，则返回包含它的可选值。**'
- en: '***2* Otherwise, return an empty optional.**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 否则，返回一个空的可选值。**'
- en: Our suggestion is to collect several similar methods in a utility class, which
    you can call `OptionalUtility`. From then on, you’ll always be allowed to convert
    a `String` to an `Optional<Integer>` by using this `OptionalUtility.stringToInt`
    method. You can forget that you encapsulated the ugly `try/catch` logic in it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的建议是将几个类似的方法收集到一个实用类中，您可以将其称为 `OptionalUtility`。从那时起，您将始终可以使用 `OptionalUtility.stringToInt`
    方法将 `String` 转换为 `Optional<Integer>`。您可以忘记您在其中封装了丑陋的 `try/catch` 逻辑。
- en: 11.4.3\. Primitive optionals and why you shouldn’t use them
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.3\. 原始可选值及其不应使用的原因
- en: Note that like streams, optionals also have primitive counterparts—`OptionalInt`,
    `Optional-Long`, and `OptionalDouble`—so the method in [listing 11.7](#ch11ex07)
    could have returned `Optional-Int` instead of `Optional<Integer>`. In [chapter
    5](kindle_split_016.xhtml#ch05), we encouraged the use of primitive streams (especially
    when they could contain a huge number of elements) for performance reasons, but
    because an `Optional` can have at most a single value, that justification doesn’t
    apply here.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与流一样，可选值也有其原始对应物——`OptionalInt`、`Optional-Long` 和 `OptionalDouble`——因此 [列表
    11.7](#ch11ex07) 中的方法可以返回 `Optional-Int` 而不是 `Optional<Integer>`。在 [第 5 章](kindle_split_016.xhtml#ch05)
    中，我们出于性能原因鼓励使用原始流（特别是当它们可能包含大量元素时），但鉴于 `Optional` 最多只能有一个值，这种理由在这里不适用。
- en: We discourage using primitive optionals because they lack the `map`, `flatMap`,
    and `filter` methods, which (as you saw in [section 11.2](#ch11lev1sec2)) are
    the most useful methods of the `Optional` class. Moreover, as happens for streams,
    an optional can’t be composed with its primitive counterpart, so if the method
    of [listing 11.7](#ch11ex07) returned `OptionalInt`, you couldn’t pass it as a
    method reference to the `flatMap` method of another optional.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不鼓励使用原始的可选值，因为它们缺少 `map`、`flatMap` 和 `filter` 方法，这些方法（正如您在 [第 11.2 节](#ch11lev1sec2)
    中所看到的）是 `Optional` 类最有用的方法。此外，就像流一样，可选值不能与其原始对应物组合，因此如果 [列表 11.7](#ch11ex07) 中的方法返回
    `OptionalInt`，您就不能将其作为方法引用传递给另一个可选值的 `flatMap` 方法。
- en: 11.4.4\. Putting it all together
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.4\. 整合所有内容
- en: 'In this section, we demonstrate how the methods of the `Optional` class that
    we’ve presented so far can be used together in a more compelling use case. Suppose
    that you have some `Properties` that are passed as configuration arguments to
    your program. For the purpose of this example and to test the code you’ll develop,
    create some sample `Properties` as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了我们迄今为止所介绍的 `Optional` 类的方法如何在一个更有说服力的用例中一起使用。假设您有一些 `Properties`，它们作为配置参数传递给您的程序。为了本例的目的，以及测试您将要开发的代码，请按照以下方式创建一些示例
    `Properties`：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Also suppose that your program needs to read a value from these `Properties`
    and interpret it as a duration in seconds. Because a duration has to be a positive
    (>0) number, you’ll want a method with the signature
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的程序需要从这些 `Properties` 中读取一个值并将其解释为秒数。因为持续时间必须是一个正数（>0），您将需要一个具有以下签名的 `Properties`：
- en: '[PRE28]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'so that when the value of a given property is a `String` representing a positive
    integer, the method returns that integer, but it returns zero in all other cases.
    To clarify this requirement, formalize it with a few JUnit assertions:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当给定属性的值为表示正整数的 `String` 时，该方法返回该整数，但在所有其他情况下返回零。为了明确这一要求，使用几个 JUnit 断言对其进行形式化：
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'These assertions reflect the original requirement: the `readDuration` method
    returns `5` for the property `"a"` because the value of this property is a `String`
    that’s convertible in a positive number, and the method returns `0` for `"b"`
    because it isn’t a number, returns `0` for `"c"` because it’s a number but is
    negative, and returns `0` for `"d"` because a property with that name doesn’t
    exist. Try to implement the method that satisfies this requirement in imperative
    style, as shown in the next listing.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这些断言反映了原始要求：`readDuration` 方法对于属性 `"a"` 返回 `5`，因为该属性的值是一个可以转换为正数的 `String`，对于
    `"b"` 返回 `0`，因为它不是数字，对于 `"c"` 返回 `0`，因为它是数字但为负数，对于 `"d"` 返回 `0`，因为不存在具有该名称的属性。尝试实现满足此要求的方法，如下一个列表所示。
- en: Listing 11.8\. Reading duration from a property imperatively
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.8\. 命令式地从属性中读取持续时间
- en: '[PRE30]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* Make sure that a property exists with the required name.**'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 确保存在具有所需名称的属性。**'
- en: '***2* Try to convert the String property to a number.**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 尝试将字符串属性转换为数字。**'
- en: '***3* Check whether the resulting number is positive.**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 检查生成的数字是否为正数。**'
- en: '***4* Return 0 if any of the conditions fails.**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果任何条件失败，则返回 0。**'
- en: As you might expect, the resulting implementation is convoluted and not readable,
    presenting multiple nested conditions coded as both `if` statements and a `try`/`catch`
    block. Take a few minutes to figure out in quiz 11.3 how you can achieve the same
    result by using what you’ve learned in this chapter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期的那样，生成的实现是复杂的且不可读的，它以 `if` 语句和 `try`/`catch` 块的形式呈现了多个嵌套条件。花几分钟时间在 11.3
    号测验中找出您如何使用本章学到的知识达到相同的结果。
- en: Note the common style in using optionals and streams; both are reminiscent of
    a database query in which several operations are chained together.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用 optionals 和 streams 的常见风格；两者都让人联想到数据库查询，其中多个操作被链接在一起。
- en: '|  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quiz 11.3: Reading duration from a property by using an Optional**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**测验 11.3：使用 Optional 从属性中读取持续时间**'
- en: Using the features of the `Optional` class and the utility method of [listing
    11.7](#ch11ex07), try to reimplement the imperative method of [listing 11.8](#ch11ex08)
    with a single fluent statement.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Optional` 类的功能和 [列表 11.7](#ch11ex07) 中的实用方法，尝试使用单个流畅语句重新实现 [列表 11.8](#ch11ex08)
    中的命令式方法。
- en: '**Answer:**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: 'Because the value returned by the `Properties.getProperty(String)` method is
    a `null` when the required property doesn’t exist, it’s convenient to turn this
    value into an optional with the `ofNullable` factory method. Then you can convert
    the `Optional<String>` to an `Optional<Integer>`, passing to its `flatMap` method
    a reference to the `OptionalUtility.stringToInt` method developed in [listing
    11.7](#ch11ex07). Finally, you can easily filter away the negative number. In
    this way, if any of these operations returns an empty optional, the method returns
    the `0` that’s passed as the default value to the `orElse` method; otherwise,
    it returns the positive integer contained in the optional. This description is
    implemented as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `Properties.getProperty(String)` 方法返回的值在所需的属性不存在时为 `null`，所以使用 `ofNullable`
    工厂方法将此值转换为 `Optional` 是方便的。然后，您可以将 `Optional<String>` 转换为 `Optional<Integer>`，将其
    `flatMap` 方法传递到在 [列表 11.7](#ch11ex07) 中开发的 `OptionalUtility.stringToInt` 方法。最后，您可以轻松过滤掉负数。这样，如果这些操作中的任何一个返回一个空的
    `Optional`，则方法返回传递给 `orElse` 方法的默认值 `0`；否则，它返回 `Optional` 中包含的正整数。此描述的实现如下：
- en: '[PRE31]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: '`null` references were historically introduced in programming languages to
    signal the absence of a value.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null` 引用在编程语言中历史上被引入，用于表示值的缺失。'
- en: Java 8 introduced the class `java.util.Optional<T>` to model the presence or
    absence of a value.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8 引入了 `java.util.Optional<T>` 类来表示值的呈现或缺失。
- en: You can create `Optional` objects with the static factory methods `Optional.empty`,
    `Optional.of`, and `Optional.ofNullable`.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用静态工厂方法 `Optional.empty`、`Optional.of` 和 `Optional.ofNullable` 创建 `Optional`
    对象。
- en: The `Optional` class supports many methods—such as `map`, `flatMap`, and `filter`—that
    are conceptually similar to the methods of a stream.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional` 类支持许多方法——例如 `map`、`flatMap` 和 `filter`——这些方法在概念上与流的方法相似。'
- en: Using `Optional` forces you to actively unwrap an optional to deal with the
    absence of a value; as a result, you protect your code against unintended `null`
    pointer exceptions.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Optional` 强迫您主动解包可选对象以处理值的缺失；因此，您保护了您的代码免受意外的 `null` 指针异常。
- en: Using `Optional` can help you design better APIs in which, by reading the signature
    of a method, users can tell whether to expect an optional value.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Optional` 可以帮助您设计更好的 API，用户可以通过阅读方法的签名来判断是否期望一个可选值。
- en: Chapter 12\. New Date and Time API
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 12 章。新的日期和时间 API
- en: '*This chapter covers*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Why we needed a new date and time library, introduced in Java 8
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们需要一个新的日期和时间库，这个库在 Java 8 中引入
- en: Representing date and time for both humans and machines
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为人类和机器表示日期和时间
- en: Defining an amount of time
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一段时间
- en: Manipulating, formatting, and parsing dates
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作、格式化和解析日期
- en: Dealing with different time zones and calendars
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理不同的时区和日历
- en: The Java API includes many useful components to help you build complex applications.
    Unfortunately, the Java API isn’t always perfect. We believe that the majority
    of experienced Java developers will agree that date and time support before Java
    8 was far from ideal. Don’t worry, though; Java 8 introduces a brand-new Date
    and Time API to tackle this issue.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Java API 包含许多有用的组件，可以帮助您构建复杂的应用程序。不幸的是，Java API 并非总是完美的。我们相信，大多数经验丰富的 Java 开发者都会同意，在
    Java 8 之前，日期和时间支持远非理想。不过，别担心；Java 8 引入了一个全新的日期和时间 API 来解决这个问题。
- en: 'In Java 1.0, the only support for date and time was the `java.util.Date` class.
    Despite its name, this class doesn’t represent a date, but a point in time with
    millisecond precision. Even worse, the usability of this class is harmed by some
    nebulous design decisions such as the choice of its offsets: the years start from
    1900, whereas the months start at index 0\. If you wanted to represent the release
    date of Java 9, which is 21 September 2017, you’d have to create an instance of
    `Date` as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 1.0 中，对日期和时间的唯一支持是 `java.util.Date` 类。尽管它的名字叫日期，但这个类并不代表一个日期，而是一个以毫秒精度的时间点。更糟糕的是，一些模糊的设计决策，如它的偏移选择，损害了这个类的可用性：年份从
    1900 年开始，而月份从索引 0 开始。如果你想表示 Java 9 的发布日期，即 2017 年 9 月 21 日，你必须创建一个 `Date` 实例，如下所示：
- en: '[PRE32]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Printing this date produces, for the authors:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 打印这个日期对作者来说：
- en: '[PRE33]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Not very intuitive, is it? Moreover, even the `String` returned by the `toString`
    method of the `Date` class could be quite misleading. It also includes the JVM’s
    default time zone, CET, which is Central Europe Time in our case. Indeed, the
    `Date` class itself merely inserts the JVM default time zone!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很直观，对吧？此外，即使是 `Date` 类的 `toString` 方法返回的 `String` 也可能相当误导。它还包括 JVM 的默认时区
    CET，在我们的情况下是中欧时间。实际上，`Date` 类本身只是插入 JVM 默认时区！
- en: The problems and limitations of the `Date` class were immediately clear when
    Java 1.0 came out, but it was also clear that the problems couldn’t be fixed without
    breaking its backward compatibility. As a consequence, in Java 1.1 many methods
    of the `Date` class were deprecated, and the class was replaced by the alternative
    `java.util.Calendar` class. Unfortunately, `Calendar` has similar problems and
    design flaws that lead to error-prone code. Months also start at index 0\. (At
    least `Calendar` got rid of the 1900 offset for the year.) Worse, the presence
    of *both* the `Date` and `Calendar` classes increases confusion among developers.
    (Which one should you use?) In addition, features such as `DateFormat`, used to
    format and parse dates or time in a language-independent manner, work only with
    the `Date` class.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Java 1.0 发布时，`Date` 类的问题和局限性立即变得明显，但也很清楚，如果不破坏其向后兼容性，这些问题是无法修复的。因此，在 Java
    1.1 中，`Date` 类的许多方法都被弃用，并被替代的 `java.util.Calendar` 类所取代。不幸的是，`Calendar` 类也存在类似的问题和设计缺陷，这会导致容易出错的代码。月份也从索引
    0 开始。（至少 `Calendar` 去掉了年份的 1900 偏移。）更糟糕的是，`Date` 和 `Calendar` 类的存在增加了开发者之间的混淆。（你应该使用哪一个？）此外，像
    `DateFormat` 这样的功能，用于以语言无关的方式格式化和解析日期或时间，只能与 `Date` 类一起使用。
- en: The `DateFormat` comes with its own set of problems. It isn’t thread-safe, for
    example, which means that if two threads try to parse a date by using the same
    formatter at the same time, you may receive unpredictable results.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateFormat` 带有自己的问题集。例如，它不是线程安全的，这意味着如果有两个线程同时尝试使用相同的格式化器解析日期，你可能会收到不可预测的结果。'
- en: Finally, both `Date` and `Calendar` are mutable classes. What does it mean to
    mutate the 21st of September 2017 to the 25th of October? This design choice can
    lead you into a maintenance nightmare, as you’ll learn in more detail in [chapter
    18](kindle_split_033.xhtml#ch18), which is about functional programming.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Date` 和 `Calendar` 都是可变类。将 2017 年 9 月 21 日修改为 10 月 25 日意味着什么？这个设计选择可能会导致维护噩梦，正如你将在第
    18 章（关于函数式编程）中更详细地了解的那样。
- en: The consequence is that all these flaws and inconsistencies have encouraged
    the use of third-party date and time libraries, such as Joda-Time. For these reasons,
    Oracle decided to provide high-quality date and time support in the native Java
    API. As a result, Java 8 integrates many of the Joda-Time features in the `java.time`
    package.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，所有这些缺陷和不一致性都鼓励了使用第三方日期和时间库，例如 Joda-Time。出于这些原因，Oracle 决定在原生 Java API 中提供高质量的日期和时间支持。因此，Java
    8 在 `java.time` 包中集成了许多 Joda-Time 功能。
- en: In this chapter, we explore the features introduced by the new Date and Time
    API. We start with basic use cases such as creating dates and times that are suitable
    to be used by both humans and machines. Then we gradually explore more-advanced
    applications of the new Date and Time API, such as manipulating, parsing, and
    printing date-time objects, and working with different time zones and alternative
    calendars.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了新日期和时间 API 引入的功能。我们首先从基本用例开始，例如创建既适合人类使用也适合机器使用的时间和日期。然后我们逐步探索新日期和时间
    API 的更高级应用，例如操作、解析和打印日期时间对象，以及处理不同的时区和替代日历。
- en: 12.1\. LocalDate, LocalTime, LocalDateTime, Instant, Duration, and Period
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1\. LocalDate、LocalTime、LocalDateTime、Instant、Duration 和 Period
- en: 'We start by exploring how to create simple dates and intervals. The `java.time`
    package includes many new classes to help you: `LocalDate`, `LocalTime`, `LocalDateTime`,
    `Instant`, `Duration`, and `Period`.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先探索如何创建简单的日期和间隔。`java.time` 包包含许多新类来帮助你：`LocalDate`、`LocalTime`、`LocalDateTime`、`Instant`、`Duration`
    和 `Period`。
- en: 12.1.1\. Working with LocalDate and LocalTime
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.1\. 使用 LocalDate 和 LocalTime
- en: The class `LocalDate` probably is the first one you’ll come across when you
    start using the new Date and Time API. An instance of this class is an immutable
    object representing a plain date without the time of day. In particular, it doesn’t
    carry any information about the time zone.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用新的日期和时间 API 时，`LocalDate` 类可能是你遇到的第一个类。这个类的实例是一个不可变对象，代表一个没有一天中的时间的纯日期。特别是，它不携带任何时区信息。
- en: You can create a `LocalDate` instance by using the `of` static factory method.
    A `LocalDate` instance provides many methods to read its most commonly used values
    (year, month, day of the week, and so on), as shown in the following listing.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `of` 静态工厂方法创建一个 `LocalDate` 实例。`LocalDate` 实例提供了许多方法来读取其最常用的值（年、月、星期几等），如下所示。
- en: Listing 12.1\. Creating a `LocalDate` and reading its values
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.1\. 创建 `LocalDate` 并读取其值
- en: '[PRE34]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* 2017-09-21**'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 2017-09-21**'
- en: '***2* 2017**'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 2017**'
- en: '***3* SEPTEMBER**'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 九月**'
- en: '***4* 21**'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 21**'
- en: '***5* THURSDAY**'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 星期四**'
- en: '***6* 30 (days in September)**'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 30 (九月的天数)**'
- en: '***7* false (not a leap year)**'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* false (非闰年)**'
- en: 'It’s also possible to obtain the current date from the system clock by using
    the `now` factory method:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用 `now` 工厂方法从系统时钟获取当前日期：
- en: '[PRE35]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All the other date-time classes that we investigate in the remaining part of
    this chapter provide a similar factory method. You can also access the same information
    by passing a `TemporalField` to the `get` method. The `TemporalField` is an interface
    defining how to access the value of a specific field of a temporal object. The
    `ChronoField` enumeration implements this interface, so you can conveniently use
    an element of that enumeration with the `get` method, as shown in the next listing.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余部分中我们调查的所有其他日期时间类都提供了一个类似的工厂方法。你还可以通过传递一个 `TemporalField` 到 `get` 方法来访问相同的信息。`TemporalField`
    是一个定义如何访问时间对象特定字段值的接口。`ChronoField` 枚举实现了这个接口，因此你可以方便地使用该枚举的一个元素与 `get` 方法一起使用，如下所示。
- en: Listing 12.2\. Reading `LocalDate` values by using a `TemporalField`
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.2\. 使用 `TemporalField` 读取 `LocalDate` 值
- en: '[PRE36]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You could use the built-in `getYear()`, `getMonthValue()`, and `getDayOfMonth()`
    methods in a more-readable form to access the information as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用内置的 `getYear()`、`getMonthValue()` 和 `getDayOfMonth()` 方法以更易读的形式访问信息，如下所示：
- en: '[PRE37]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Similarly, the time of day, such as 13:45:20, is represented by the `LocalTime`
    class. You can create instances of `LocalTime` by using two overloaded static
    factory methods named `of`. The first one accepts an hour and a minute, and the
    second one also accepts a second. Like the `LocalDate` class, the `LocalTime`
    class provides some getter methods to access its values, as shown in the following
    listing.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一天中的时间，如 13:45:20，由 `LocalTime` 类表示。您可以通过使用名为 `of` 的两个重载的静态工厂方法来创建 `LocalTime`
    的实例。第一个接受小时和分钟，第二个也接受秒。与 `LocalDate` 类一样，`LocalTime` 类提供了一些获取器方法来访问其值，如下面的列表所示。
- en: Listing 12.3\. Creating a `LocalTime` and reading its values
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.3\. 创建 `LocalTime` 并读取其值
- en: '[PRE38]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* 13:45:20**'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 13:45:20**'
- en: '***2* 13**'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 13**'
- en: '***3* 45**'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 45**'
- en: '***4* 20**'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 20**'
- en: 'You can create both `LocalDate` and `LocalTime` by parsing a `String` representing
    them. To achieve this task, use their `parse` static methods:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过解析表示它们的字符串来创建 `LocalDate` 和 `LocalTime`。为了完成这个任务，请使用它们的 `parse` 静态方法：
- en: '[PRE39]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It’s possible to pass a `DateTimeFormatter` to the `parse` method. An instance
    of this class specifies how to format a date and/or a time object. It’s intended
    to be a replacement for the old `java.util.DateFormat` that we mentioned earlier.
    We show in more detail how you can use a `DateTimeFormatter` in [section 12.2.2](#ch12lev2sec6).
    Also note that both these `parse` methods throw a `DateTimeParseException`, which
    extends `RuntimeException` in case the `String` argument can’t be parsed as a
    valid `LocalDate` or `LocalTime`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 `DateTimeFormatter` 传递给 `parse` 方法。这个类的实例指定了如何格式化日期和/或时间对象。它旨在替代我们之前提到的旧的
    `java.util.DateFormat`。我们将在 [第 12.2.2 节](#ch12lev2sec6) 中更详细地展示如何使用 `DateTimeFormatter`。此外，请注意，这两个
    `parse` 方法都会抛出 `DateTimeParseException`，它扩展了 `RuntimeException`，如果字符串参数不能解析为有效的
    `LocalDate` 或 `LocalTime`。
- en: 12.1.2\. Combining a date and a time
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.2\. 组合日期和时间
- en: The composite class called `LocalDateTime` pairs a `LocalDate` and a `LocalTime`.
    It represents both a date and a time without a time zone and can be created directly
    or by combining a date and time, as shown in the following listing.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为 `LocalDateTime` 的组合类将 `LocalDate` 和 `LocalTime` 配对。它表示一个没有时区的日期和时间，可以直接创建或通过组合日期和时间来创建，如下面的列表所示。
- en: Listing 12.4\. Creating a `LocalDateTime` directly or by combining a date and
    a time
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.4\. 直接创建 `LocalDateTime` 或通过组合日期和时间
- en: '[PRE40]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Note that it’s possible to create a `LocalDateTime` by passing a time to a
    `LocalDate` or a date to a `LocalTime`, using their `atTime` or `atDate` methods,
    respectively. You can also extract the `LocalDate` or `LocalTime` component from
    a `LocalDateTime` by using the `toLocalDate` and `toLocalTime` methods:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可以通过将时间传递给 `LocalDate` 或日期传递给 `LocalTime` 来创建 `LocalDateTime`，分别使用它们的 `atTime`
    或 `atDate` 方法。您还可以通过使用 `toLocalDate` 和 `toLocalTime` 方法从 `LocalDateTime` 中提取 `LocalDate`
    或 `LocalTime` 组件：
- en: '[PRE41]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* 2017-09-21**'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 2017-09-21**'
- en: '***2* 13:45:20**'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 13:45:20**'
- en: '12.1.3\. Instant: a date and time for machines'
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.3\. Instant：机器的日期和时间
- en: As humans, we’re used to thinking of dates and time in terms of weeks, days,
    hours, and minutes. Nonetheless, this representation isn’t easy for a computer
    to deal with. From a machine point of view, the most natural format to model time
    is a single large number representing a point on a continuous timeline. This approach
    is used by the new `java.time.Instant` class, which represents the number of seconds
    passed since the Unix epoch time, set by convention to midnight of January 1,
    1970 UTC.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 作为人类，我们习惯于用周、天、小时和分钟来思考日期和时间。然而，这种表示方式对计算机来说并不容易处理。从机器的角度来看，最自然的格式是表示连续时间线上一个点的单一大数。这种方法被新的
    `java.time.Instant` 类所采用，它表示自 Unix 纪元时间以来经过的秒数，按照惯例设置为 1970 年 1 月 1 日午夜 UTC。
- en: 'You can create an instance of this class by passing the number of seconds to
    its `ofEpochSecond` static factory method. In addition, the `Instant` class supports
    nanosecond precision. A supplementary overloaded version of the `ofEpochSecond`
    static factory method accepts a second argument that’s a nanosecond adjustment
    to the passed number of seconds. This overloaded version adjusts the nanosecond
    argument, ensuring that the stored nanosecond fraction is between 0 and 999,999,999\.
    As a result, the following invocations of the `ofEpochSecond` factory method return
    exactly the same `Instant`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过传递秒数给其`ofEpochSecond`静态工厂方法来创建此类的实例。此外，`Instant`类支持纳秒精度。`ofEpochSecond`静态工厂方法的补充重载版本接受一个纳秒调整参数，该参数是对传递的秒数的调整。这个重载版本调整纳秒参数，确保存储的纳秒分数在0到999,999,999之间。因此，以下对`ofEpochSecond`工厂方法的调用返回完全相同的`Instant`：
- en: '[PRE42]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1* One billion nanoseconds (1 second) after 2 seconds**'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在2秒后1亿纳秒（1秒）**'
- en: '***2* One billion nanoseconds (1 second) before 4 seconds**'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在4秒前1亿纳秒（1秒）**'
- en: As you’ve already seen for `LocalDate` and the other human-readable date-time
    classes, the `Instant` class supports another static factory method named `now`,
    which allows you to capture a timestamp of the current moment. It’s important
    to reinforce that an `Instant` is intended for use only by a machine. It consists
    of a number of seconds and nanoseconds. As a consequence, it doesn’t provide any
    ability to handle units of time that are meaningful to humans. A statement like
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如您已经看到，对于`LocalDate`和其他可读日期时间类，`Instant`类支持另一个名为`now`的静态工厂方法，它允许您捕获当前时刻的时间戳。重要的是要强调，`Instant`仅适用于机器使用。它由若干秒和纳秒组成。因此，它不提供处理对人类有意义的任何时间单位的任何能力。例如，以下语句
- en: '[PRE43]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'throws an exception like this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 会抛出如下异常：
- en: '[PRE44]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: But you can work with `Instant`s by using the `Duration` and `Period` classes,
    which we look at next.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 但您可以使用`Duration`和`Period`类来处理`Instant`，我们将在下一节中探讨。
- en: 12.1.4\. Defining a Duration or a Period
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.4\. 定义一个Duration或Period
- en: 'All the classes you’ve seen so far implement the `Temporal` interface, which
    defines how to read and manipulate the values of an object modeling a generic
    point in time. We’ve shown you a few ways to create different `Temporal` instances.
    The next natural step is creating a duration between two temporal objects. The
    `between` static factory method of the `Duration` class serves exactly this purpose.
    You can create a duration between two `LocalTime`s, two `LocalDateTime`s, or two
    `Instant`s as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 您迄今为止看到的所有类都实现了`Temporal`接口，该接口定义了如何读取和操作表示通用时间点的对象的值。我们已经向您展示了创建不同`Temporal`实例的几种方法。下一步自然的步骤是创建两个时间对象之间的持续时间。`Duration`类的`between`静态工厂方法正好用于此目的。您可以根据以下方式创建两个`LocalTime`、两个`LocalDateTime`或两个`Instant`之间的持续时间：
- en: '[PRE45]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Because `LocalDateTime` and `Instant` are made for different purposes, one to
    be used by humans and the other by machines, you’re not allowed to mix them. If
    you try to create a duration between them, you’ll only obtain a `DateTimeException`.
    Moreover, because the `Duration` class is used to represent an amount of time
    measured in seconds and eventually nanoseconds, you can’t pass a `LocalDate` to
    the `between` method.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`LocalDateTime`和`Instant`是为不同的目的而设计的，一个用于人类，另一个用于机器，因此不允许将它们混合使用。如果您尝试在这两者之间创建持续时间，您将只能获得`DateTimeException`。此外，因为`Duration`类用于表示以秒和最终纳秒为单位的时间量，因此您不能将`LocalDate`传递给`between`方法。
- en: 'When you need to model an amount of time in terms of years, months, and days,
    you can use the `Period` class. You can find out the difference between two `LocalDate`s
    with the `between` factory method of that class:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要用年、月和日来表示时间量时，您可以使用`Period`类。您可以使用该类的`between`工厂方法找出两个`LocalDate`之间的差异：
- en: '[PRE46]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Finally, the `Duration` and `Period` classes have other convenient factory methods
    to create instances of them directly, without defining them as the difference
    between two temporal objects, as shown in the following listing.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Duration`和`Period`类还有其他方便的工厂方法，可以直接创建它们的实例，而无需将它们定义为两个时间对象的差，如下所示。
- en: Listing 12.5\. Creating `Duration`s and `Period`s
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.5\. 创建`Duration`和`Period`
- en: '[PRE47]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `Duration` and `Period` classes share many similar methods, which [table
    12.1](#ch12table01) lists.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`Duration`和`Period`类共享许多类似的方法，[表12.1](#ch12table01)中列出了这些方法。'
- en: Table 12.1\. The common methods of date-time classes representing an interval
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表12.1\. 表示时间间隔的日期时间类的常用方法
- en: '| Method | Static | Description |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| Method | Static | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| between | Yes | Creates an interval between two points in time |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| between | Yes | 在两个时间点之间创建时间间隔 |'
- en: '| from | Yes | Creates an interval from a temporal unit |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| from | Yes | 从时间单位创建时间间隔 |'
- en: '| of | Yes | Creates an instance of this interval from its constituent parts
    |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| of | Yes | 从其组成部分创建此时间间隔的实例 |'
- en: '| parse | Yes | Creates an instance of this interval from a String |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| parse | Yes | 从字符串创建此时间间隔的实例 |'
- en: '| addTo | No | Creates a copy of this interval, adding to it the specified
    temporal object |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| addTo | No | 创建此时间间隔的副本，并添加指定的时态对象 |'
- en: '| get | No | Reads part of the state of this interval |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| get | No | 读取此时间间隔的部分状态 |'
- en: '| isNegative | No | Checks whether this interval is negative, excluding zero
    |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| isNegative | No | 检查此时间间隔是否为负数，不包括零 |'
- en: '| isZero | No | Checks whether this interval is zero-length |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| isZero | No | 检查此时间间隔是否为零长度 |'
- en: '| minus | No | Creates a copy of this interval with an amount of time subtracted
    |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| minus | No | 创建此时间间隔的副本，并减去一定的时间量 |'
- en: '| multipliedBy | No | Creates a copy of this interval multiplied by the given
    scalar |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| multipliedBy | No | 创建此时间间隔的副本，并将其乘以给定的标量 |'
- en: '| negated | No | Creates a copy of this interval with the length negated |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| negated | No | 创建此时间间隔的副本，其长度取反 |'
- en: '| plus | No | Creates a copy of this interval with an amount of time added
    |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| plus | No | 创建此时间间隔的副本，并添加一定的时间量 |'
- en: '| subtractFrom | No | Subtracts this interval from the specified temporal object
    |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| subtractFrom | No | 从指定的时态对象中减去此时间间隔 |'
- en: All the classes we’ve investigated so far are immutable, which is a great design
    choice to allow a more functional programming style, ensure thread safety, and
    preserve the consistency of the domain model. Nevertheless, the new Date and Time
    API offers some handy methods for creating modified versions of those objects.
    You may want to add three days to an existing `LocalDate` instance, for example,
    and we explore how to do this in the next section. In addition, we explore how
    to create a date-time formatter from a given pattern, such as dd/MM/yyyy, or even
    programmatically, as well as how to use this formatter for both parsing and printing
    a date.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止调查的所有类都是不可变的，这是一个很好的设计选择，允许更函数式编程风格，确保线程安全，并保持领域模型的一致性。尽管如此，新的日期和时间 API
    提供了一些方便的方法来创建这些对象的修改版本。例如，您可能想要将三个天添加到现有的 `LocalDate` 实例中，我们将在下一节中探讨如何做到这一点。此外，我们还将探讨如何从给定的模式（如
    dd/MM/yyyy）或甚至以编程方式创建日期时间格式化器，以及如何使用此格式化器进行日期的解析和打印。
- en: 12.2\. Manipulating, parsing, and formatting dates
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2\. 操作、解析和格式化日期
- en: The most immediate and easiest way to create a modified version of an existing
    `LocalDate` is to change one of its attributes, using one of its `withAttribute`
    methods. Note that all the methods return a new object with the modified attribute,
    as shown in [listing 12.6](#ch12ex06); they don’t mutate the existing object!
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 创建现有 `LocalDate` 的修改版本最直接和最简单的方法是更改其属性之一，使用其 `withAttribute` 方法之一。请注意，所有这些方法都返回一个具有修改后属性的新对象，如[列表
    12.6](#ch12ex06)所示；它们不会修改现有对象！
- en: Listing 12.6\. Manipulating the attributes of a `LocalDate` in an absolute way
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.6\. 以绝对方式操作 `LocalDate` 的属性
- en: '[PRE48]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* 2017-09-21**'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 2017-09-21**'
- en: '***2* 2011-09-21**'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 2011-09-21**'
- en: '***3* 2011-09-25**'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 2011-09-25**'
- en: '***4* 2011-02-25**'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 2011-02-25**'
- en: You can do the same thing with the more generic `with` method, taking a `TemporalField`
    as the first argument, as in the last statement of [listing 12.6](#ch12ex06).
    This last `with` method is the dual of the `get` method used in [listing 12.2](#ch12ex02).
    Both of these methods are declared in the `Temporal` interface implemented by
    all the classes, such as `LocalDate`, `LocalTime`, `LocalDateTime`, and `Instant`,
    of the Date and Time API. More precisely, the `get` and `with` methods let you
    respectively read and modify^([[1](#ch12fn01)]) fields of a `Temporal` object.
    They throw an `UnsupportedTemporalTypeException` if the requested field isn’t
    supported by the specific `Temporal`, such as a `ChronoField.MONTH_OF_YEAR` on
    an `Instant` or a `ChronoField.NANO_OF_SECOND` on a `LocalDate`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用更通用的 `with` 方法做同样的事情，将 `TemporalField` 作为第一个参数，如[列表12.6](#ch12ex06)的最后一条语句所示。这个最后的
    `with` 方法是[列表12.2](#ch12ex02)中使用的 `get` 方法的对偶。这两个方法都声明在所有类（如 `LocalDate`、`LocalTime`、`LocalDateTime`
    和 `Instant`）实现的 `Temporal` 接口中，这些类属于日期和时间API。更确切地说，`get` 和 `with` 方法分别允许您读取和修改
    `Temporal` 对象的字段。如果请求的字段不支持特定的 `Temporal`，则抛出 `UnsupportedTemporalTypeException`，例如在
    `Instant` 上的 `ChronoField.MONTH_OF_YEAR` 或在 `LocalDate` 上的 `ChronoField.NANO_OF_SECOND`。
- en: ¹
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Remember that such ‘`with`’ methods don’t modify the existing `Temporal` object
    but create a copy with the specific field updated. This process is called a *functional
    update* (see [chapter 19](kindle_split_034.xhtml#ch19)).
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 记住，这样的“`with`”方法不会修改现有的 `Temporal` 对象，而是创建一个具有特定字段更新的副本。这个过程被称为*功能更新*（见[第19章](kindle_split_034.xhtml#ch19)）。
- en: It’s even possible to manipulate a `LocalDate` in a declarative manner. You
    can add or subtract a given amount of time, for example, as shown in [listing
    12.7](#ch12ex07).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以以声明方式操作 `LocalDate`。例如，您可以添加或减去给定的时间量，如[列表12.7](#ch12ex07)所示。
- en: Listing 12.7\. Manipulating the attributes of a `LocalDate` in a relative way
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.7\. 以相对方式操作 `LocalDate` 的属性
- en: '[PRE49]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1* 2017-09-21**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 2017-09-21**'
- en: '***2* 2017-09-28**'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 2017-09-28**'
- en: '***3* 2011-09-28**'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 2011-09-28**'
- en: '***4* 2012-03-28**'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 2012-03-28**'
- en: Similarly to what we’ve explained about the `with` and `get` methods, the generic
    `plus` method used in the last statement of [listing 12.7](#ch12ex07), together
    with the analogous `minus` method, is declared in the `Temporal` interface. These
    methods allow you to move a `Temporal` back or forward a given amount of time,
    defined by a number plus a `TemporalUnit`, where the `ChronoUnit` enumeration
    offers a convenient implementation of the `TemporalUnit` interface.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前解释的 `with` 和 `get` 方法类似，用于[列表12.7](#ch12ex07)最后一条语句的通用 `plus` 方法，以及相应的
    `minus` 方法，都在 `Temporal` 接口中声明。这些方法允许您将 `Temporal` 向前或向后移动给定的时间量，该时间量由一个数字加上 `TemporalUnit`
    定义，其中 `ChronoUnit` 枚举提供了对 `TemporalUnit` 接口的方便实现。
- en: As you may have anticipated, all the date-time classes representing a point
    in time such as `LocalDate`, `LocalTime`, `LocalDateTime`, and `Instant` have
    many methods in common. [Table 12.2](#ch12table02) summarizes these methods.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预料的，所有代表时间点的日期时间类，如 `LocalDate`、`LocalTime`、`LocalDateTime` 和 `Instant`，都有许多共同的方法。[表12.2](#ch12table02)
    总结了这些方法。
- en: Table 12.2\. The common methods of date-time classes representing a point in
    time
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表12.2\. 代表时间点的日期时间类的常用方法
- en: '| Method | Static | Description |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 静态 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| from | Yes | Creates an instance of this class from the passed temporal object
    |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| from | 是 | 从传递的时间对象创建此类的实例 |'
- en: '| now | Yes | Creates a temporal object from the system clock |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| now | 是 | 从系统时钟创建时间对象 |'
- en: '| of | Yes | Creates an instance of this temporal object from its constituent
    parts |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| of | 是 | 从其组成部分创建此时间对象的实例 |'
- en: '| parse | Yes | Creates an instance of this temporal object from a String |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| parse | 是 | 从字符串创建此时间对象的实例 |'
- en: '| atOffset | No | Combines this temporal object with a zone offset |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| atOffset | 否 | 将此时间对象与区域偏移量结合 |'
- en: '| atZone | No | Combines this temporal object with a time zone |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| atZone | 否 | 将此时间对象与时区结合 |'
- en: '| format | No | Converts this temporal object to a String by using the specified
    formatter (not available for Instant) |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| format | 否 | 使用指定的格式化程序将此时间对象转换为字符串（对于 `Instant` 不可用） |'
- en: '| get | No | Reads part of the state of this temporal object |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| get | 否 | 读取此时间对象的部分状态 |'
- en: '| minus | No | Creates a copy of this temporal object with an amount of time
    subtracted |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| minus | 否 | 创建此时间对象的副本，并减去一定的时间量 |'
- en: '| plus | No | Creates a copy of this temporal object with an amount of time
    added |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| plus | 否 | 创建此时间对象的副本，并添加一定的时间量 |'
- en: '| with | No | Creates a copy of this temporal object with part of the state
    changed |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| with | 无 | 创建一个部分状态已更改的此时间对象的副本 |'
- en: Check what you’ve learned up to now about manipulating dates with quiz 12.1.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 通过练习 12.1 检查你到目前为止关于操作日期所学的知识。
- en: '|  |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quiz 12.1: Manipulating a `LocalDate`**'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 12.1：操作 `LocalDate`**'
- en: What will the value of the date variable be after the following manipulations?
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下操作之后，日期变量的值将会是多少？
- en: '[PRE50]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '**Answer:**'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: '[PRE51]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As you’ve seen, you can manipulate the date both in an absolute way and in a
    relative way. You can also concatenate more manipulations in a single statement,
    because every change creates a new `LocalDate` object, and the subsequent invocation
    manipulates the object created by the former one. Finally, the last statement
    in this code snippet has no observable effect because as usual, it creates a new
    `LocalDate` instance, but we’re not assigning this new value to any variable.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，你可以以绝对方式或相对方式操作日期。你还可以在单个语句中连接多个操作，因为每次更改都会创建一个新的 `LocalDate` 对象，后续调用将操作前一个调用创建的对象。最后，这段代码片段中的最后一个语句没有可观察的效果，因为像往常一样，它创建了一个新的
    `LocalDate` 实例，但我们没有将这个新值赋给任何变量。
- en: '|  |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 12.2.1\. Working with TemporalAdjusters
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.1\. 使用 `TemporalAdjusters`
- en: All the date manipulations you’ve seen so far are relatively straightforward.
    Sometimes, though, you need to perform advanced operations, such as adjusting
    a date to the next Sunday, the next working day, or the last day of the month.
    In such cases, you can pass to an overloaded version of the `with` method a `TemporalAdjuster`
    that provides a more customizable way to define the manipulation needed to operate
    on a specific date. The Date and Time API already provides many predefined `TemporalAdjuster`s
    for the most common use cases. You can access them by using the static factory
    methods contained in the `TemporalAdjusters` class, as shown in [listing 12.8](#ch12ex08).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止看到的所有日期操作都比较直接。然而，有时你需要执行更高级的操作，例如将日期调整到下一个星期日、下一个工作日或月底的最后一天。在这种情况下，你可以向
    `with` 方法的重载版本传递一个 `TemporalAdjuster`，它提供了一种更可定制的定义所需操作的方式来操作特定日期。日期和时间 API 已经为最常见的用例提供了许多预定义的
    `TemporalAdjuster`。你可以通过使用 `TemporalAdjusters` 类中包含的静态工厂方法来访问它们，如 [列表 12.8](#ch12ex08)
    所示。
- en: Listing 12.8\. Using the predefined `TemporalAdjusters`
  id: totrans-394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.8\. 使用预定义的 `TemporalAdjusters`
- en: '[PRE52]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* 2014-03-18**'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 2014-03-18**'
- en: '***2* 2014-03-23**'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 2014-03-23**'
- en: '***3* 2014-03-31**'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 2014-03-31**'
- en: '[Table 12.3](#ch12table03) lists the `TemporalAdjuster`s that you can create
    with these factory methods.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 12.3](#ch12table03) 列出了你可以使用这些工厂方法创建的 `TemporalAdjuster`。'
- en: Table 12.3\. The factory methods of the `TemporalAdjusters` class
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 12.3\. `TemporalAdjusters` 类的工厂方法
- en: '| Method | Description |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| dayOfWeekInMonth | Creates a new date in the same month with the ordinal
    day of week. (Negative numbers count backward from the end of the month.) |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| dayOfWeekInMonth | 创建一个新的日期，与当前月份的序数星期相同的日期。（负数从月底开始计数。）|'
- en: '| firstDayOfMonth | Creates a new date set to the first day of the current
    month. |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| firstDayOfMonth | 创建一个新的日期，设置为当前月份的第一天。|'
- en: '| firstDayOfNextMonth | Creates a new date set to the first day of the next
    month. |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| firstDayOfNextMonth | 创建一个新的日期，设置为下一个月的第一天。|'
- en: '| firstDayOfNextYear | Creates a new date set to the first day of the next
    year. |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| firstDayOfNextYear | 创建一个新的日期，设置为下一年度的第一天。|'
- en: '| firstDayOfYear | Creates a new date set to the first day of the current year.
    |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| firstDayOfYear | 创建一个新的日期，设置为当前年份的第一天。|'
- en: '| firstInMonth | Creates a new date in the same month with the first matching
    day of the week. |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| firstInMonth | 创建一个新的日期，与当前月份的第一匹配星期相同的日期。|'
- en: '| lastDayOfMonth | Creates a new date set to the last day of the current month.
    |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| lastDayOfMonth | 创建一个新的日期，设置为当前月份的最后一天。|'
- en: '| lastDayOfNextMonth | Creates a new date set to the last day of the next month.
    |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| lastDayOfNextMonth | 创建一个新的日期，设置为下一个月的最后一天。|'
- en: '| lastDayOfNextYear | Creates a new date set to the last day of the next year.
    |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| lastDayOfNextYear | 创建一个新的日期，设置为下一年度的最后一天。|'
- en: '| lastDayOfYear | Creates a new date set to the last day of the current year.
    |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| lastDayOfYear | 创建一个新的日期，设置为当前年份的最后一天。|'
- en: '| lastInMonth | Creates a new date in the same month with the last matching
    day of the week. |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| lastInMonth | 创建一个新的日期，与当前月份的最后匹配星期相同的日期。|'
- en: '| next previous | Creates a new date set to the first occurrence of the specified
    day of week after/before the date being adjusted. |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| next previous | 创建一个新的日期，设置为调整日期之后/之前的指定星期的第一次出现。|'
- en: '| nextOrSame previousOrSame | Creates a new date set to the first occurrence
    of the specified day of week after/before the date being adjusted unless it’s
    already on that day, in which case the same object is returned. |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| nextOrSame previousOrSame | 在调整的日期之后/之前创建一个新的日期，设置为指定星期几的第一天，除非它已经在那天，在这种情况下返回相同的对象。
    |'
- en: As you can see, `TemporalAdjuster`s allow you to perform more-complex date manipulations
    that still read like the problem statement. Moreover, it’s relatively simple to
    create your own custom `TemporalAdjuster` implementation if you can’t find a predefined
    `TemporalAdjuster` that fits your needs. In fact, the `TemporalAdjuster` interface
    declares only a single method (which makes it a functional interface), defined
    as shown in the following listing.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`TemporalAdjuster`允许你执行更复杂的日期操作，同时仍然像问题陈述一样易于阅读。此外，如果你找不到适合你需求的预定义`TemporalAdjuster`，创建你自己的自定义`TemporalAdjuster`实现相对简单。实际上，`TemporalAdjuster`接口只声明了一个方法（这使得它成为一个函数式接口），定义如下所示。
- en: Listing 12.9\. The `TemporalAdjuster` interface
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.9. `TemporalAdjuster`接口
- en: '[PRE53]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This example means that an implementation of the `TemporalAdjuster` interface
    defines how to convert a `Temporal` object to another `Temporal`. You can think
    of a `TemporalAdjuster` as being like a `UnaryOperator<Temporal>`. Take a few
    minutes to practice what you’ve learned so far and implement your own `TemporalAdjuster`
    in quiz 12.2.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子意味着`TemporalAdjuster`接口的实现定义了如何将一个`Temporal`对象转换为另一个`Temporal`。你可以将`TemporalAdjuster`视为一个`UnaryOperator<Temporal>`。花几分钟时间练习你到目前为止所学的内容，并在练习12.2中实现你自己的`TemporalAdjuster`。
- en: '|  |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quiz 12.2: Implementing a custom `TemporalAdjuster`**'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习12.2：实现自定义的`TemporalAdjuster`**'
- en: Develop a class named `NextWorkingDay`, implementing the `TemporalAdjuster`
    interface that moves a date forward by one day but skips Saturdays and Sundays.
    Using
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 开发一个名为`NextWorkingDay`的类，实现`TemporalAdjuster`接口，该接口将日期向前移动一天，但跳过星期六和星期日。使用
- en: '[PRE54]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: should move the date to the next day, if this day is between Monday and Friday,
    but to the next Monday if it’s a Saturday or a Sunday.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 应该将日期移动到下一天，如果这一天是星期一到星期五，但如果这一天是星期六或星期日，则移动到下一个星期一。
- en: '**Answer:**'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: 'You can implement the `NextWorkingDay` adjuster as follows:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样实现`NextWorkingDay`调整器：
- en: '[PRE55]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Read the current day.**'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 读取当前日期。**'
- en: '***2* Normally add one day.**'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 通常添加一天。**'
- en: '***3* But add three days if today is a Friday.**'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 但如果今天是星期五，则添加三天。**'
- en: '***4* Add two days if today is a Saturday.**'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果今天是星期六，则添加两天。**'
- en: '***5* Return the modified date adding the right number of days.**'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 返回添加了正确天数后的修改日期。**'
- en: 'This `TemporalAdjuster` normally moves a date forward one day, except when
    today is a Friday or Saturday, in which case it advances the dates by three or
    two days, respectively. Note that because a `TemporalAdjuster` is a functional
    interface, you could pass the behavior of this adjuster in a lambda expression:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`TemporalAdjuster`通常将日期向前移动一天，除非今天是星期五或星期六，在这种情况下，分别将日期向前移动三天或两天。请注意，因为`TemporalAdjuster`是一个函数式接口，你可以通过lambda表达式传递这个调整器的行为：
- en: '[PRE56]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You’re likely to want to apply this manipulation to a date in several points
    of your code, and for this reason, we suggest encapsulating its logic in a proper
    class, as we did here. Do the same for all the manipulations you use frequently.
    You’ll end up with a small library of adjusters that you and your team can easily
    reuse in your codebase.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望在代码的几个地方应用这种操作，因此我们建议将它的逻辑封装在一个合适的类中，就像我们在这里做的那样。对于你经常使用的所有操作都这样做。最终，你将拥有一个小型的调整器库，你和你的团队可以轻松地在代码库中重用这些调整器。
- en: 'If you want to define the `TemporalAdjuster` with a lambda expression, it’s
    preferable to do so by using the `ofDateAdjuster` static factory of the `TemporalAdjusters`
    class, which accepts a `UnaryOperator<LocalDate>` as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用lambda表达式定义`TemporalAdjuster`，最好通过使用`TemporalAdjusters`类的`ofDateAdjuster`静态工厂方法来这样做，它接受一个`UnaryOperator<LocalDate>`，如下所示：
- en: '[PRE57]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '|  |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Another common operation that you may want to perform on your date and time
    objects is printing them in different formats specific to your business domain.
    Similarly, you may want to convert `String`s representing dates in those formats
    to actual date objects. In the next section, we demonstrate the mechanisms provided
    by the new Date and Time API to accomplish these tasks.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想在日期和时间对象上执行另一个常见操作，那就是以特定于你业务域的格式打印它们。同样，你可能还想将这些格式的日期`String`转换为实际的日期对象。在下一节中，我们将展示新日期和时间API提供的机制来完成这些任务。
- en: 12.2.2\. Printing and parsing date-time objects
  id: totrans-440
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.2.2\. 打印和解析日期时间对象
- en: 'Formatting and parsing are other relevant features for working with dates and
    times. The new `java.time.format` package is devoted to these purposes. The most
    important class of this package is `DateTimeFormatter`. The easiest way to create
    a formatter is through its static factory methods and constants. The constants
    such as `BASIC_ISO_DATE` and `ISO_LOCAL_DATE` are predefined instances of the
    `DateTimeFormatter` class. You can use all `DateTimeFormatter`s to create a `String`
    representing a given date or time in a specific format. Here, for example, we
    produce a `String` by using two different formatters:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化和解析是处理日期和时间的其他相关功能。新的 `java.time.format` 包致力于这些目的。该包中最重要的类是 `DateTimeFormatter`。创建格式化器的最简单方法是通过其静态工厂方法和常量。例如，`BASIC_ISO_DATE`
    和 `ISO_LOCAL_DATE` 这样的常量是 `DateTimeFormatter` 类的预定义实例。您可以使用所有 `DateTimeFormatter`
    创建表示给定日期或时间的特定格式的 `String`。例如，我们通过使用两个不同的格式化器生成一个 `String`：
- en: '[PRE58]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* 20140318**'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 20140318**'
- en: '***2* 2014-03-18**'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 2014-03-18**'
- en: 'You can also parse a `String` representing a date or a time in that format
    to re-create the date object itself. You can achieve this task by using the `parse`
    factory method provided by all the classes of the Date and Time API representing
    a point in time or an interval:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以解析表示日期或时间的 `String`，以重新创建日期对象本身。您可以通过使用代表时间点或区间的 Date 和 Time API 中所有类的 `parse`
    工厂方法来实现此任务：
- en: '[PRE59]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In comparison with the old `java.util.DateFormat` class, all the `DateTimeFormatter`
    instances are thread-safe. Therefore, you can create singleton formatters like
    the ones defined by the `DateTimeFormatter` constants and share them among multiple
    threads. The next listing shows how the `DateTimeFormatter` class also supports
    a static factory method that lets you create a formatter from a specific pattern.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 与旧的 `java.util.DateFormat` 类相比，所有的 `DateTimeFormatter` 实例都是线程安全的。因此，您可以创建单例格式化器，如由
    `DateTimeFormatter` 常量定义的格式化器，并在多个线程之间共享。下面的列表显示了 `DateTimeFormatter` 类还支持一个静态工厂方法，允许您从特定的模式创建格式化器。
- en: Listing 12.10\. Creating a `DateTimeFormatter` from a pattern
  id: totrans-448
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.10\. 从模式创建 `DateTimeFormatter`
- en: '[PRE60]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, the `LocalDate`’s `format` method produces a `String` representing the
    date with the requested pattern. Next, the static `parse` method re-creates the
    same date by parsing the generated `String`, using the same formatter. The `ofPattern`
    method also has an overloaded version that allows you to create a formatter for
    a given `Locale`, as shown in the following listing.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`LocalDate` 的 `format` 方法生成一个表示日期的 `String`，该日期符合请求的格式。接下来，静态 `parse` 方法通过解析生成的
    `String` 重新创建相同的日期，使用相同的格式化器。`ofPattern` 方法还有一个重载版本，允许您为给定的 `Locale` 创建格式化器，如下面的列表所示。
- en: Listing 12.11\. Creating a localized `DateTimeFormatter`
  id: totrans-451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.11\. 创建本地化的 `DateTimeFormatter`
- en: '[PRE61]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Finally, in case you need even more control, the `DateTimeFormatterBuilder`
    class lets you define complex formatters step by step by using meaningful methods.
    In addition, it provides you the ability to have case-insensitive parsing, lenient
    parsing (allowing the parser to use heuristics to interpret inputs that don’t
    precisely match the specified format), padding, and optional sections of the formatter.
    You can programmatically build the same `italianFormatter` we used in [listing
    12.11](#ch12ex11) through the `DateTime-FormatterBuilder`, for example, as shown
    in the following listing.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您需要更多的控制，`DateTimeFormatterBuilder` 类允许您通过使用有意义的步骤定义复杂的格式化器。此外，它还提供了不区分大小写的解析、宽松解析（允许解析器使用启发式方法来解释不精确匹配指定格式的输入）、填充和格式化器的可选部分的能力。您可以通过
    `DateTimeFormatterBuilder` 编程构建与 [列表 12.11](#ch12ex11) 中使用的相同的 `italianFormatter`，例如，如下面的列表所示。
- en: Listing 12.12\. Building a `DateTimeFormatter`
  id: totrans-454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.12\. 构建 `DateTimeFormatter`
- en: '[PRE62]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: So far, you’ve learned how to create, manipulate, format, and parse both points
    in time and intervals, but you haven’t seen how to deal with subtleties involving
    dates and time. You may need to deal with different time zones or alternative
    calendar systems. In the next sections, we explore these topics by using the new
    Date and Time API.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学习了如何创建、操作、格式化和解析时间点和区间，但您还没有看到如何处理涉及日期和时间的细微差别。您可能需要处理不同的时区或替代的日历系统。在接下来的几节中，我们将通过使用新的日期和时间
    API 探索这些主题。
- en: 12.3\. Working with different time zones and calendars
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3\. 与不同时区和日历一起工作
- en: None of the classes you’ve seen so far contain any information about time zones.
    Dealing with time zones is another important issue that’s been vastly simplified
    by the new Date and Time API. The new `java.time.ZoneId` class is the replacement
    for the old `java.util.TimeZone` class. It aims to better shield you from the
    complexities related to time zones, such as dealing with Daylight Saving Time
    (DST). Like the other classes of the Date and Time API, it’s immutable.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 您迄今为止看到的任何类都不包含任何关于时区的信息。处理时区是另一个重要的问题，新日期和时间 API 已经极大地简化了这个问题。新的 `java.time.ZoneId`
    类是旧 `java.util.TimeZone` 类的替代品。它的目标是更好地保护您免受与时区相关的复杂性的影响，例如处理夏令时（DST）。像日期和时间 API
    的其他类一样，它是不可变的。
- en: 12.3.1\. Using time zones
  id: totrans-459
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.1\. 使用时区
- en: 'A *time zone* is a set of rules corresponding to a region in which the standard
    time is the same. About 40 time zones are held in instances of the `ZoneRules`
    class. You can call `getRules()` on a `ZoneId` to obtain the rules for that time
    zone. A specific `ZoneId` is identified by a region ID, as in this example:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '*时区*是一组与标准时间相同的规则相对应的区域。大约有 40 个时区包含在 `ZoneRules` 类的实例中。您可以通过调用 `getRules()`
    在 `ZoneId` 上获取该时区的规则。特定的 `ZoneId` 通过区域 ID 来识别，如下例所示：'
- en: '[PRE63]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'All the region IDs are in the format `"{area}/{city}"`, and the set of available
    locations is the one supplied by the Internet Assigned Numbers Authority (IANA)
    Time Zone Database (see [https://www.iana.org/time-zones](https://www.iana.org/time-zones)).
    You can also convert an old `TimeZone` object to a `ZoneId` by using the new method
    `toZoneId`:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 所有区域 ID 都采用 `"{area}/{city}"` 的格式，可用的位置集合是由互联网名称与数字地址分配机构（IANA）时区数据库（见 [https://www.iana.org/time-zones](https://www.iana.org/time-zones)）提供的。您还可以通过使用新方法
    `toZoneId` 将旧的 `TimeZone` 对象转换为 `ZoneId`：
- en: '[PRE64]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: When you have a `ZoneId` object, you can combine it with a `LocalDate`, a `LocalDateTime`,
    or an `Instant` to transform it into `ZonedDateTime` instances, which represent
    points in time relative to the specified time zone, as shown in the following
    listing.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有一个 `ZoneId` 对象时，您可以将其与 `LocalDate`、`LocalDateTime` 或 `Instant` 结合，将其转换为 `ZonedDateTime`
    实例，这些实例表示相对于指定时区的时间点，如下所示。
- en: Listing 12.13\. Applying a time zone to a point in time
  id: totrans-465
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.13\. 将时区应用于时间点
- en: '[PRE65]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[Figure 12.1](#ch12fig01) illustrates the components of a `ZonedDateTime` to
    help you understand the differences among `LocalDate`, `LocalTime`, `LocalDateTime`,
    and `ZoneId`.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12.1](#ch12fig01) 展示了 `ZonedDateTime` 的组成部分，以帮助您理解 `LocalDate`、`LocalTime`、`LocalDateTime`
    和 `ZoneId` 之间的差异。'
- en: Figure 12.1\. Making sense of a `ZonedDateTime`
  id: totrans-468
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.1\. 理解 `ZonedDateTime`
- en: '![](Images/12fig01_alt.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig01_alt.jpg)'
- en: You can also convert a `LocalDateTime` to an `Instant` by using a `ZoneId:`
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过使用 `ZoneId:` 将 `LocalDateTime` 转换为 `Instant`。
- en: '[PRE66]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Or you can do it the other way around:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以反过来操作：
- en: '[PRE67]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Note that working with `Instant` is quite useful because you often have to
    work with legacy code that deals with the `Date` class. There, two methods were
    added to help inter-operate between the deprecated API and the new Date and Time
    API: `toInstant()` and the static method `fromInstant()`.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用 `Instant` 非常有用，因为您经常需要处理与 `Date` 类相关的遗留代码。在那里，添加了两个方法来帮助在已弃用的 API 和新的日期和时间
    API 之间进行互操作：`toInstant()` 和静态方法 `fromInstant()`。
- en: 12.3.2\. Fixed offset from UTC/Greenwich
  id: totrans-475
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.2\. 从 UTC/Greenwich 的固定偏移量
- en: 'Another common way to express a time zone is to use a fixed offset from UTC/Greenwich.
    You can use this notation to say, “New York is five hours behind London,” for
    example. In cases like this one, you can use the `ZoneOffset` class, a subclass
    of `ZoneId` that represents the difference between a time and the zero meridian
    of Greenwich, London, as follows:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 表达时区的另一种常见方式是使用相对于 UTC/Greenwich 的固定偏移量。例如，您可以使用这种表示法来说明，“纽约比伦敦晚五小时”。在这种情况下，您可以使用
    `ZoneOffset` 类，它是 `ZoneId` 的子类，表示时间与伦敦格林威治零子午线之间的差异，如下所示：
- en: '[PRE68]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The -05:00 offset indeed corresponds to U.S. Eastern Standard Time. Be aware,
    however, that a `ZoneOffset` defined this way doesn’t have any Daylight Saving
    Time management, and for this reason, it isn’t suggested in the majority of cases.
    Because a `ZoneOffset` is also a `ZoneId`, you can use it as shown in [listing
    12.13](#ch12ex13) earlier in this chapter. You can also create an `OffsetDateTime`,
    which represents a date-time with an offset from UTC/Greenwich in the ISO-8601
    calendar system:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: -05:00 的偏移量确实对应于美国东部标准时间。然而，请注意，以这种方式定义的 `ZoneOffset` 没有任何夏令时管理，因此在大多数情况下不建议使用。因为
    `ZoneOffset` 也是一个 `ZoneId`，你可以像在本书前面的 [清单 12.13](#ch12ex13) 中所示的那样使用它。你还可以创建一个
    `OffsetDateTime`，它表示 ISO-8601 日历系统中相对于 UTC/Greenwich 的日期时间：
- en: '[PRE69]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Another advanced feature supported by the new Date and Time API is support for
    non-ISO calendaring systems.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 新日期和时间 API 支持的另一个高级功能是对非 ISO 日历系统的支持。
- en: 12.3.3\. Using alternative calendar systems
  id: totrans-481
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.3\. 使用替代日历系统
- en: 'The ISO-8601 calendar system is the de facto world civil calendar system. But
    four additional calendar systems are provided in Java 8\. Each of these calendar
    systems has a dedicated date class: `ThaiBuddhistDate`, `MinguoDate`, `JapaneseDate`,
    and `HijrahDate`. All these classes, together with `LocalDate`, implement the
    `ChronoLocalDate` interface, which is intended to model a date in an arbitrary
    chronology. You can create an instance of one of these classes out of a `LocalDate`.
    More generally, you can create any other `Temporal` instance by using their `from`
    static factory methods as follows:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: ISO-8601 日历系统是事实上的世界公历系统。但 Java 8 提供了四种额外的日历系统。每个日历系统都有一个专门的日期类：`ThaiBuddhistDate`、`MinguoDate`、`JapaneseDate`
    和 `HijrahDate`。所有这些类，连同 `LocalDate`，都实现了 `ChronoLocalDate` 接口，该接口旨在表示任意历法中的日期。你可以从
    `LocalDate` 创建这些类中的一个实例。更普遍地说，你可以通过使用它们的 `from` 静态工厂方法创建任何其他 `Temporal` 实例，如下所示：
- en: '[PRE70]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Alternatively, you can explicitly create a calendar system for a specific `Locale`
    and create an instance of a date for that `Locale`. In the new Date and Time API,
    the `Chronology` interface models a calendar system, and you can obtain an instance
    of it by using its `ofLocale` static factory method:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以为特定的 `Locale` 显式创建一个日历系统，并为该 `Locale` 创建一个日期实例。在新日期和时间 API 中，`Chronology`
    接口表示一个日历系统，你可以通过使用它的 `ofLocale` 静态工厂方法来获取其实例：
- en: '[PRE71]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The designers of the Date and Time API advise using `LocalDate` instead of `Chrono-LocalDate`
    for most cases, because a developer could make assumptions in his code that unfortunately
    aren’t true in a multicalendar system. Such assumptions might include believing
    that the value of a day or month will never be higher than 31, that a year contains
    12 months, or even that a year has a fixed number of months. For these reasons,
    we recommend using `LocalDate` throughout your application, including all storage,
    manipulation, and interpretation of business rules, whereas you should employ
    `ChronoLocalDate` only when you need to localize the input or output of your program.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 日期和时间 API 的设计者建议在大多数情况下使用 `LocalDate` 而不是 `Chrono-LocalDate`，因为开发者可能会在代码中做出一些假设，而这些假设在多日历系统中不幸地并不成立。这些假设可能包括认为一天或一个月的值永远不会超过
    31，或者一年包含 12 个月，甚至一年有固定数量的月份。出于这些原因，我们建议在您的应用程序中始终使用 `LocalDate`，包括所有存储、操作和业务规则的解释，而您应该只在需要本地化程序输入或输出时使用
    `ChronoLocalDate`。
- en: Islamic calendar
  id: totrans-487
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 伊斯兰历
- en: Of the new calendars added to Java 8, the `HijrahDate` (Islamic calendar) seems
    to be the most complex because it can have variants. The Hijrah calendar system
    is based on lunar months. There are a variety of methods to determine a new month,
    such as a new moon that could be visible anywhere in the world or that must be
    visible first in Saudi Arabia. The `withVariant` method is used to choose the
    desired variant. Java 8 includes the Umm Al-Qura variant for `HijrahDate` as standard.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 8 中添加的新日历中，`HijrahDate`（伊斯兰历）似乎是最复杂的，因为它可能有变体。回历日历系统基于月相。有各种方法来确定新月份，例如新月在世界上任何地方都可以看到，或者必须首先在沙特阿拉伯看到。`withVariant`
    方法用于选择所需的变体。Java 8 将 Umm Al-Qura 变体作为标准包含在 `HijrahDate` 中。
- en: 'The following code illustrates an example of displaying the start and end dates
    of Ramadan for the current Islamic year in ISO date:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了显示当前伊斯兰年斋月开始和结束日期的示例：
- en: '[PRE72]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '***1* Get the current Hijrah date; then change it to have the first day of
    Ramadan, which is the ninth month.**'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取当前的回历日期；然后将其更改为具有斋月的第一天，即第九个月。**'
- en: '***2* IsoChronology.INSTANCE is a static instance of the IsoChronology class.**'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* IsoChronology.INSTANCE 是 IsoChronology 类的静态实例。**'
- en: '***3* Ramadan 1438 started on 2017-05-26 and ended on 2017-06-24.**'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 伊斯兰历1438年的斋月从2017年5月26日开始，到2017年6月24日结束。**'
- en: Summary
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The old `java.util.Date` class and all other classes used to model dates and
    times in Java before Java 8 have many inconsistencies and design flaws, including
    mutability and some poorly chosen offsets, defaults, and naming.
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧的 `java.util.Date` 类以及Java 8之前在Java中用于建模日期和时间的所有其他类都有许多不一致性和设计缺陷，包括可变性和一些选择不佳的偏移量、默认值和命名。
- en: All the date-time objects of the new Date and Time API are immutable.
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的日期和时间API中的所有日期时间对象都是不可变的。
- en: This new API provides two different time representations to manage the different
    needs of humans and machines when operating on it.
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个新的API提供了两种不同的时间表示，以管理人类和机器在操作它时的不同需求。
- en: You can manipulate date and time objects in both an absolute and relative manner,
    and the result of these manipulations is always a new instance, leaving the original
    one unchanged.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以以绝对和相对的方式操作日期和时间对象，这些操作的结果始终是一个新的实例，而原始对象保持不变。
- en: '`TemporalAdjuster`s allow you to manipulate a date in a more complex way than
    changing one of its values, and you can define and use your own custom date transformations.'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TemporalAdjuster`s 允许你以比更改其值更复杂的方式操作日期，并且你可以定义和使用你自己的自定义日期转换。'
- en: You can define a formatter to print and parse date-time objects in a specific
    format. These formatters can be created from a pattern or programmatically, and
    they’re all thread-safe.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以定义一个格式化程序来以特定格式打印和解析日期时间对象。这些格式化程序可以从模式或程序化创建，并且它们都是线程安全的。
- en: You can represent a time zone, relative to a specific region/location and as
    a fixed offset from UTC/Greenwich, and apply it to a date-time object to localize
    it.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以表示一个时区，相对于特定的区域/位置，以及相对于UTC/格林尼治的固定偏移量，并将其应用于日期时间对象以本地化它。
- en: You can use calendar systems different from the ISO-8601 standard system.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用与ISO-8601标准系统不同的日历系统。
- en: Chapter 13\. Default methods
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第13章\. 默认方法
- en: '*This chapter covers*'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: What default methods are
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认方法是什么
- en: Evolving APIs in a compatible way
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以兼容的方式发展API
- en: Usage patterns for default methods
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认方法的用法模式
- en: Resolution rules
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分辨规则
- en: Traditionally, a Java interface groups related methods together into a contract.
    Any (nonabstract) class that implements an interface *must* provide an implementation
    for each method defined by the interface or inherit the implementation from a
    superclass. But this requirement causes a problem when library designers need
    to update an interface to add a new method. Indeed, existing concrete classes
    (which may not be under the interface designers’ control) need to be modified
    to reflect the new interface contract. This situation is particularly problematic
    because the Java 8 API introduces many new methods on existing interfaces, such
    as the `sort` method on the `List` interface that you used in previous chapters.
    Imagine all the angry maintainers of alternative collection frameworks such as
    Guava and Apache Commons who now need to modify all the classes implementing the
    `List` interface to provide an implementation for the `sort` method too!
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，Java接口将相关方法组合在一起形成一个合同。任何（非抽象）实现接口的类*必须*为接口中定义的每个方法提供实现，或者从超类继承实现。但是，当库设计者需要更新接口以添加新方法时，这个要求会导致问题。确实，现有的具体类（可能不受接口设计者的控制）需要被修改以反映新的接口合同。这种情况尤其有问题，因为Java
    8 API在现有接口上引入了许多新方法，例如你在前几章中使用的 `List` 接口上的 `sort` 方法。想象一下，所有替代集合框架（如Guava和Apache
    Commons）的愤怒维护者现在需要修改实现 `List` 接口的所有类，以提供 `sort` 方法的实现！
- en: But don’t worry. Java 8 introduced a new mechanism to tackle this problem. It
    may sound surprising, but since Java 8 interfaces can declare methods with implementation
    code in two ways. First, Java 8 allowed *static methods* inside interfaces. Second,
    Java 8 introduced a new feature called *default methods* that allows you to provide
    a default implementation for methods in an interface. In other words, interfaces
    can now provide concrete implementation for methods. As a result, existing classes
    implementing an interface automatically inherit the default implementations if
    they don’t provide one explicitly, which allows you to evolve interfaces nonintrusively.
    You’ve been using several default methods all along. Two examples you’ve seen
    are `sort` in the `List` interface and `stream` in the `Collection` interface.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 但不必担心。Java 8 引入了一种新的机制来解决这个问题。这听起来可能有些令人惊讶，但自从 Java 8 以来，接口可以通过两种方式声明带有实现代码的方法。首先，Java
    8 允许接口内部存在静态方法。其次，Java 8 引入了一种名为默认方法的新特性，允许你为接口中的方法提供一个默认实现。换句话说，接口现在可以为方法提供具体实现。因此，如果现有类没有明确提供实现，它们将自动继承默认实现，这允许你以非侵入性的方式演进接口。你一直在使用多个默认方法。你看到的两个例子是
    `List` 接口中的 `sort` 和 `Collection` 接口中的 `stream`。
- en: 'The `sort` method in the `List` interface, which you saw in [chapter 1](kindle_split_011.xhtml#ch01),
    is new to Java 8 and is defined as follows:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第 1 章中看到的 `List` 接口中的 `sort` 方法是 Java 8 的新特性，其定义如下：
- en: '[PRE73]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Note the new `default` modifier before the return type. This modifier is how
    you can tell that a method is a default method. Here, the `sort` method calls
    the `Collections.sort` method to perform the sorting. Thanks to this new method,
    you can sort a list by calling the method directly:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 注意返回类型之前的新 `default` 修饰符。这就是你如何知道一个方法是默认方法的方式。在这里，`sort` 方法调用 `Collections.sort`
    方法来执行排序。多亏了这个新方法，你可以通过直接调用方法来对列表进行排序：
- en: '[PRE74]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '***1* sort is a default method in the List interface.**'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 排序是 List 接口中的一个默认方法。**'
- en: 'Something else is new in this code. Notice that you call the `Comparator.natural-Order`
    method. This new static method in the `Comparator` interface returns a `Comparator`
    object to sort the elements in natural order (the standard alphanumerical sort).
    The `stream` method in `Collection` you saw in [chapter 4](kindle_split_015.xhtml#ch04)
    looks like this:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中还有其他新内容。注意你调用了 `Comparator.naturalOrder` 方法。这个 `Comparator` 接口中的新静态方法返回一个
    `Comparator` 对象，用于按自然顺序（标准的字母数字排序）对元素进行排序。你在第 4 章中看到的 `Collection` 中的 `stream`
    方法如下所示：
- en: '[PRE75]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, the `stream` method, which you used extensively in previous chapters to
    process collections, calls the `StreamSupport.stream` method to return a stream.
    Notice how the body of the `stream` method is calling the method `spliterator`,
    which is also a default method of the `Collection` interface.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`stream` 方法，你在前几章中广泛使用它来处理集合，调用 `StreamSupport.stream` 方法来返回一个流。注意 `stream`
    方法的主体是如何调用 `spliterator` 方法的，而 `spliterator` 也是 `Collection` 接口的一个默认方法。
- en: Wow! Are interfaces like abstract classes now? Yes and no; there are fundamental
    differences, which we explain in this chapter. More important, why should you
    care about default methods? The main users of default methods are library designers.
    As we explain later, default methods were introduced to evolve libraries such
    as the Java API in a compatible way, as illustrated in [figure 13.1](#ch13fig01).
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！接口现在像抽象类一样了吗？是的，也不是；这里有一些根本性的区别，我们将在本章中解释。更重要的是，为什么你应该关心默认方法？默认方法的主要用户是库设计者。正如我们稍后解释的那样，默认方法的引入是为了以兼容的方式演进库，例如
    Java API，如图 13.1 所示。
- en: Figure 13.1\. Adding a method to an interface
  id: totrans-520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.1\. 向接口中添加方法
- en: '![](Images/13fig01_alt.jpg)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13fig01_alt.jpg)'
- en: In a nutshell, adding a method to an interface is the source of many problems;
    existing classes implementing the interface need to be changed to provide an implementation
    for the method. If you’re in control of the interface and all its implementations,
    the situation isn’t too bad. But this is often not the case—and it provides the
    motivation for default methods, which let classes inherit a default implementation
    from an interface automatically.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，向接口中添加方法会导致许多问题；实现该接口的现有类需要更改以提供该方法的实现。如果你控制着接口及其所有实现，那么情况并不太糟糕。但这种情况通常并不成立——这也正是默认方法产生的动机，默认方法允许类自动从接口继承默认实现。
- en: If you’re a library designer, this chapter is important because default methods
    provide a means of evolving interfaces without modifying existing implementations.
    Also, as we explain later in the chapter, default methods can help structure your
    programs by providing a flexible mechanism for multiple inheritance of behavior;
    a class can inherit default methods from several interfaces. Therefore, you may
    still be interested in finding out about default methods even if you’re not a
    library designer.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是库设计师，本章很重要，因为默认方法提供了一种在不修改现有实现的情况下演变接口的方法。此外，正如我们在本章后面解释的那样，默认方法可以通过提供一种灵活的多重继承行为机制来帮助结构化您的程序；一个类可以从多个接口继承默认方法。因此，即使您不是库设计师，您也可能对了解默认方法感兴趣。
- en: '|  |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Static methods and interfaces**'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态方法和接口**'
- en: A common pattern in Java is to define both an interface and a utility companion
    class defining many static methods for working with instances of the interface.
    `Collections` is a companion class to deal with `Collection` objects, for example.
    Now that static methods can exist inside interfaces, such utility classes in your
    code can go away, and their static methods can be moved inside an interface. These
    companion classes remain in the Java API to preserve backward compatibility.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，定义一个接口和一个定义了许多静态方法的实用伴随类是一个常见的模式。例如，`Collections`是一个伴随类，用于处理`Collection`对象。现在，静态方法可以存在于接口中，因此您代码中的此类实用类可以消失，它们的静态方法可以移动到接口内部。这些伴随类仍然保留在Java
    API中，以保持向后兼容性。
- en: '|  |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The chapter is structured as follows. First, we walk you through a use case
    of evolving an API and the problems that can arise. Then we explain what default
    methods are and discuss how you can use them to tackle the problems in the use
    case. Next, we show how you can create your own default methods to achieve a form
    of multiple inheritance in Java. We conclude with some more technical information
    about how the Java compiler resolves possible ambiguities when a class inherits
    several default methods with the same signature.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的结构如下。首先，我们带您了解一个API演变的使用案例以及可能出现的各种问题。然后，我们解释什么是默认方法，并讨论如何使用它们来解决使用案例中的问题。接下来，我们展示如何创建自己的默认方法，以在Java中实现一种多重继承的形式。最后，我们提供一些关于Java编译器如何解决一个类继承多个具有相同签名的默认方法时可能出现的歧义的技术信息。
- en: 13.1\. Evolving APIs
  id: totrans-529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1\. API的演变
- en: 'To understand why it’s difficult to evolve an API when it’s been published,
    suppose for the purpose of this section that you’re the designer of a popular
    Java drawing library. Your library contains a `Resizable` interface that defines
    many methods that a simple resizable shape must support: `setHeight`, `setWidth`,
    `getHeight`, `getWidth`, and `set-AbsoluteSize`. In addition, you provide several
    out-of-the-box implementations for it, such as `Square` and `Rectangle`. Because
    your library is so popular, you have some users who have created their own interesting
    implementations, such as `Ellipse`, using your `Resizable` interface.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解为什么在API发布后演变API很困难，假设为了本节的目的，您是一个流行的Java绘图库的设计师。您的库包含一个`Resizable`接口，该接口定义了许多简单可调整大小的形状必须支持的方法：`setHeight`、`setWidth`、`getHeight`、`getWidth`和`set-AbsoluteSize`。此外，您还提供了几个现成的实现，例如`Square`和`Rectangle`。由于您的库非常受欢迎，一些用户已经使用您的`Resizable`接口创建了他们自己的有趣实现，例如`Ellipse`。
- en: A few months after releasing your API, you realize that `Resizable` is missing
    some features. It would be nice, for example, if the interface had a `setRelativeSize`
    method that takes as argument a growth factor to resize a shape. You might add
    the `setRelativeSize` method to `Resizable` and update your implementations of
    `Square` and `Rectangle`. But not so fast! What about all your users who created
    their own implementations of the `Resizable` interface? Unfortunately, you don’t
    have access to and can’t change their classes that implement `Resizable`. This
    problem is the same one that Java library designers face when they need to evolve
    the Java API. In the next section, we look in detail at an example that shows
    the consequences of modifying an interface that’s already been published.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布您的API几个月后，您意识到`Resizable`缺少一些功能。例如，如果接口有一个接受增长因子作为参数以调整形状大小的`setRelativeSize`方法，那就很好了。您可能将`setRelativeSize`方法添加到`Resizable`中，并更新`Square`和`Rectangle`的实现。但不要这么快！那么，所有创建了`Resizable`接口自己实现的用户怎么办？不幸的是，您无法访问并更改实现`Resizable`的他们的类。这个问题与Java库设计者在需要进化Java
    API时面临的问题相同。在下一节中，我们将详细探讨一个示例，该示例展示了修改已发布的接口的后果。
- en: 13.1.1\. API version 1
  id: totrans-532
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.1\. API版本1
- en: 'The first version of your `Resizable` interface has the following methods:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`Resizable`接口的第一个版本具有以下方法：
- en: '[PRE76]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: User implementation
  id: totrans-535
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 用户实现
- en: 'One of your most loyal users decides to create his own implementation of `Resizable`
    called `Ellipse`:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 您最忠诚的用户决定创建他自己的`Resizable`实现，称为`Ellipse`：
- en: '[PRE77]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'He’s created a game that processes different types of `Resizable` shapes (including
    his own `Ellipse)`:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 他创建了一个游戏，该游戏处理不同类型的`Resizable`形状（包括他自己的`Ellipse`）：
- en: '[PRE78]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '***1* A list of shapes that are resizable**'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 可调整大小的形状列表**'
- en: '***2* Calling the setAbsoluteSize method on each shape**'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在每个形状上调用`setAbsoluteSize`方法**'
- en: 13.1.2\. API version 2
  id: totrans-542
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.1.2\. API版本2
- en: 'After your library has been in use for a few months, you receive many requests
    to update your implementations of `Resizable`: `Square`, `Rectangle`, and so on
    to support the `setRelativeSize` method. You come up with version 2 of your API,
    as shown here and illustrated in [figure 13.2](#ch13fig02):'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的库使用了几个月后，您收到了许多更新`Resizable`实现（如`Square`、`Rectangle`等）以支持`setRelativeSize`方法的请求。您推出了API的第二个版本，如图所示，并在[图13.2](#ch13fig02)中进行了说明。
- en: '[PRE79]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '***1* Adding a new method for API version 2**'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为API版本2添加新方法**'
- en: Figure 13.2\. Evolving an API by adding a method to `Resizable`. Recompiling
    the application produces errors because it depends on the `Resizable` interface.
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.2\. 通过向`Resizable`添加方法来演化API。重新编译应用程序会产生错误，因为它依赖于`Resizable`接口。
- en: '![](Images/13fig02_alt.jpg)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13fig02_alt.jpg)'
- en: Problems for your users
  id: totrans-548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 用户的问题
- en: 'This update of `Resizable` creates problems. First, the interface now demands
    an implementation of `setRelativeSize`, but the `Ellipse` implementation that
    your user created doesn’t implement the method `setRelativeSize`. Adding a new
    method to an interface is *binary compatible*, which means that existing class
    file implementations still run without the implementation of the new method if
    no attempt is made to recompile them. In this case, the game will still run (unless
    it’s recompiled) despite the addition of the `setRelativeSize` method to the `Resizable`
    interface. Nonetheless, the user could modify the method `Utils.paint` in his
    game to use the `set-RelativeSize` method because the `paint` method expects a
    list of `Resizable` objects as an argument. If an `Ellipse` object is passed,
    an error is thrown at runtime because the `setRelativeSize` method isn’t implemented:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resizable`的这次更新产生了问题。首先，接口现在要求实现`setRelativeSize`方法，但您的用户创建的`Ellipse`实现没有实现`setRelativeSize`方法。向接口添加新方法是**二进制兼容的**，这意味着如果未尝试重新编译它们，现有的类文件实现仍然可以运行。在这种情况下，即使向`Resizable`接口添加了`setRelativeSize`方法，游戏仍然可以运行（除非重新编译）。尽管如此，用户可以修改他游戏中`Utils.paint`方法的实现以使用`set-RelativeSize`方法，因为`paint`方法期望一个`Resizable`对象列表作为参数。如果传递了一个`Ellipse`对象，由于没有实现`setRelativeSize`方法，在运行时会抛出错误：'
- en: '[PRE80]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Second, if the user tries to rebuild his entire application (including `Ellipse`),
    he’ll get the following compile error:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，如果用户尝试重新构建他的整个应用程序（包括`Ellipse`），他将得到以下编译错误：
- en: '[PRE81]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Consequently, updating a published API creates backward incompatibilities, which
    is why evolving existing APIs, such as the official Java Collections API, causes
    problems for users of the APIs. You have alternatives to evolving an API, but
    they’re poor choices. You could create a separate version of your API and maintain
    both the old and the new versions, for example, but this option is inconvenient
    for several reasons. First, it’s more complex for you to maintain as a library
    designer. Second, your users may have to use both versions of your API in the
    same code base, which affects memory space and loading time because more class
    files are required for their projects.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更新已发布的API会创建向后不兼容性，这就是为什么演进现有的API，例如官方Java集合API，会给API的用户带来问题。您有演进API的替代方案，但它们的选择并不好。例如，您可以创建API的单独版本并维护旧版和新版，但这有几个不便之处。首先，对于库设计者来说，这更复杂。其次，您的用户可能必须在同一代码库中使用API的这两个版本，这会影响内存空间和加载时间，因为他们的项目需要更多的类文件。
- en: In this case, default methods come to the rescue. They let library designers
    evolve APIs without breaking existing code because classes that implement an updated
    interface automatically inherit a default implementation.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，默认方法就派上用场了。它们让库设计者可以在不破坏现有代码的情况下演进API，因为实现更新接口的类会自动继承默认实现。
- en: '|  |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Different types of compatibilities: binary, source, and behavioral**'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '**不同类型的兼容性：二进制、源和行为**'
- en: 'There are three main kinds of compatibility when introducing a change to a
    Java program: binary, source, and behavioral compatibilities (see [https://blogs.oracle.com/darcy/entry/kinds_of_compatibility](https://blogs.oracle.com/darcy/entry/kinds_of_compatibility)).
    You saw that adding a method to an interface is binary compatible but results
    in a compiler error if the class implementing the interface is recompiled. It’s
    good to know the different kinds of compatibilities, so in this sidebar, we examine
    them in detail.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在向Java程序引入更改时，主要有三种兼容性：二进制、源和行为兼容性（参见[https://blogs.oracle.com/darcy/entry/kinds_of_compatibility](https://blogs.oracle.com/darcy/entry/kinds_of_compatibility)）。您已经看到，向接口添加方法是二进制兼容的，但如果实现接口的类被重新编译，则会引发编译错误。了解不同类型的兼容性是很好的，因此在这个侧边栏中，我们将详细探讨它们。
- en: '*Binary compatibility* means that existing binaries running without errors
    continue to link (which involves verification, preparation, and resolution) without
    error after introducing a change. Adding a method to an interface is binary compatible,
    for example, because if it’s not called, existing methods of the interface can
    still run without problems.'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '*二进制兼容性*意味着现有的二进制文件在引入更改后继续无错误地链接（这涉及到验证、准备和解析），而不会出错。例如，向接口添加方法就是二进制兼容的，因为如果它没有被调用，接口的现有方法仍然可以正常运行而不会出现问题。'
- en: In its simplest form, *source compatibility* means that an existing program
    will still compile after introducing a change. Adding a method to an interface
    isn’t source compatible; existing implementations won’t recompile because they
    need to implement the new method.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，*源兼容性*意味着在引入更改后，现有的程序仍然可以编译。向接口添加方法不是源兼容的；现有的实现不会重新编译，因为它们需要实现新方法。
- en: Finally, *behavioral compatibility* means running a program after a change with
    the same input results in the same behavior. Adding a method to an interface is
    behavioral compatible because the method is never called in the program (or gets
    overridden by an implementation).
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*行为兼容性*意味着在更改后使用相同的输入运行程序会产生相同的行为。向接口添加方法是行为兼容的，因为该方法在程序中从未被调用（或被实现覆盖）。
- en: '|  |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 13.2\. Default methods in a nutshell
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2\. 简要介绍默认方法
- en: You’ve seen how adding methods to a published API disrupts existing implementations.
    *Default methods* are new in Java 8 to evolve APIs in a compatible way. Now an
    interface can contain method signatures for which an implementing class doesn’t
    provide an implementation. Who implements them? The missing method bodies are
    given as part of the interface (hence, default implementations) rather than in
    the implementing class.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了向已发布的API添加方法是如何破坏现有实现的。*默认方法*是Java 8中引入的，以便以兼容的方式演进API。现在，一个接口可以包含实现类没有提供实现的方法签名。谁来实现它们？缺失的方法体作为接口的一部分给出（因此，默认实现），而不是在实现类中。
- en: 'How do you recognize a default method? Simple: it starts with a `default` modifier
    and contains a body like a method declared in a class. In the context of a collection
    library, you could define an interface `Sized` with one abstract method `size`
    and a default method `isEmpty`, as follows:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 如何识别一个默认方法？简单：它以`default`修饰符开头，并包含一个体，就像在类中声明的类方法一样。在集合库的上下文中，你可以定义一个接口`Sized`，它有一个抽象方法`size`和一个默认方法`isEmpty`，如下所示：
- en: '[PRE82]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '***1* A default method**'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 默认方法**'
- en: Now any class that implements the `Sized` interface automatically inherits the
    implementation of `isEmpty`. Consequently, adding a method to an interface with
    a default implementation isn’t a source incompatibility.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何实现`Sized`接口的类都会自动继承`isEmpty`的实现。因此，向接口添加一个带有默认实现的方 法并不构成源不兼容。
- en: 'Now go back to the initial example of the Java drawing library and your game.
    Concretely, to evolve your library in a compatible way (which means that the users
    of your library don’t have to modify all their classes that implement `Resizable`),
    use a default method and provide a default implementation for `setRelativeSize`,
    as follows:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到Java绘图库和你的游戏的初始示例。具体来说，为了以兼容的方式（这意味着你的库的用户不需要修改所有实现`Resizable`的类）进化你的库，使用默认方法并为`setRelativeSize`提供一个默认实现，如下所示：
- en: '[PRE83]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Because interfaces can now have methods with implementation, does that mean
    multiple inheritance has arrived in Java? What happens if an implementing class
    also defines the same method signature or default methods can be overridden? Don’t
    worry about these issues for now; a few rules and mechanisms are available to
    help you deal with these issues. We explore them in detail in [section 13.4](#ch13lev1sec4).
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 因为接口现在可以有带有实现的方法，这意味着Java中的多重继承已经到来吗？如果一个实现类也定义了相同的方法签名或默认方法可以被覆盖会发生什么？现在不用担心这些问题；有一些规则和机制可以帮助你处理这些问题。我们将在[第13.4节](#ch13lev1sec4)中详细探讨它们。
- en: You may have guessed that default methods are used extensively in the Java 8
    API. You saw in the introduction of this chapter that the `stream` method in the
    `Collection` interface that we used extensively in previous chapters is a default
    method. The `sort` method in the `List` interface is also a default method. Many
    of the functional interfaces we presented in [chapter 3](kindle_split_013.xhtml#ch03)—such
    as `Predicate`, `Function`, and `Comparator`—also introduced new default methods,
    such as `Predicate.and` and `Function.andThen`. (Remember that a functional interface
    contains only one abstract method; default methods are nonabstract methods.)
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，默认方法在Java 8 API中被广泛使用。在本章的介绍中，你看到我们在前几章中广泛使用的`Collection`接口中的`stream`方法是一个默认方法。`List`接口中的`sort`方法也是一个默认方法。我们在[第3章](kindle_split_013.xhtml#ch03)中介绍的大多数功能接口（如`Predicate`、`Function`和`Comparator`）也引入了新的默认方法，如`Predicate.and`和`Function.andThen`。（记住，功能接口只包含一个抽象方法；默认方法是具体方法。）
- en: '|  |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Abstract classes vs. interfaces in Java 8**'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java 8中的抽象类与接口**'
- en: What’s the difference between an abstract class and an interface? Both can contain
    abstract methods and methods with a body.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类和接口之间的区别是什么？两者都可以包含抽象方法和有体方法。
- en: First, a class can extend only *from one* abstract class, but a class can implement
    *multiple* interfaces.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个类只能从**一个**抽象类扩展，但一个类可以实现**多个**接口。
- en: Second, an abstract class can enforce a common state through instance variables
    (fields). An interface can’t have instance variables.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，一个抽象类可以通过实例变量（字段）强制执行一个共同的状态。接口不能有实例变量。
- en: '|  |'
  id: totrans-577
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To put your knowledge of default methods to use, have a go at quiz 13.1.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你对默认方法的了解付诸实践，尝试一下第13.1题。
- en: '|  |'
  id: totrans-579
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quiz 13.1: removeIf**'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '**第13.1题：removeIf**'
- en: For this quiz, pretend that you’re one of the masters of the Java language and
    API. You’ve received many requests for a `removeIf` method to use on `ArrayList`,
    `Tree-Set`, `LinkedList`, and all other collections. The `removeIf` method should
    remove all elements from a collection that match a given predicate. Your task
    in this quiz is to figure out the best way to enhance the `Collections` API with
    this new method.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测验，假设你是Java语言和API的大师之一。你已经收到了许多在`ArrayList`、`TreeSet`、`LinkedList`和其他所有集合上使用`removeIf`方法的请求。`removeIf`方法应该从集合中移除所有匹配给定谓词的元素。在这个测验中，你的任务是找出增强`Collections`
    API的这种新方法的最佳方式。
- en: '**Answer:**'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: 'What’s the most disruptive way to enhance the `Collections` API? You could
    copy and paste the implementation of `removeIf` in each concrete class of the
    `Collections` API, but that solution would be a crime to the Java community. What
    else can you do? Well, all the `Collection` classes implement an interface called
    `java.util. Collection`. Great; can you add a method there? Yes. You’ve learned
    that default methods allow you to add implementations inside an interface in a
    source-compatible way. All classes that implement `Collection` (including classes
    from your users that aren’t part of the `Collections` API) can use the implementation
    of `removeIf`. The code solution for `removeIf` is as follows (which is roughly
    the implementation in the official Java 8 Collections API). This solution is a
    default method inside the `Collection` interface:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 如何最有效地增强 `Collections` API？您可以在 `Collections` API 的每个具体类中复制和粘贴 `removeIf` 的实现，但这种解决方案对
    Java 社区来说是一种犯罪。您还能做什么？嗯，所有的 `Collection` 类都实现了一个名为 `java.util.Collection` 的接口。很好；您可以在那里添加一个方法吗？是的。您已经了解到默认方法允许您以源兼容的方式在接口内部添加实现。所有实现
    `Collection` 的类（包括用户类，这些类不是 `Collections` API 的一部分）都可以使用 `removeIf` 的实现。`removeIf`
    的代码解决方案如下（这大致是官方 Java 8 Collections API 中的实现）。这个解决方案是 `Collection` 接口中的一个默认方法：
- en: '[PRE84]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '|  |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 13.3\. Usage patterns for default methods
  id: totrans-586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3\. 默认方法的用法模式
- en: 'You’ve seen that default methods can be useful for evolving a library in a
    compatible way. Can you do anything else with them? You can create your own interfaces
    that have default methods too. You may want to do this for two use cases that
    we explore in the following sections: optional methods and multiple inheritance
    of behavior.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到默认方法可以以兼容的方式演变库。您还能用它们做什么？您可以创建具有默认方法的自己的接口。您可能希望在下文探讨的两个用例中这样做：可选方法和行为的多继承。
- en: 13.3.1\. Optional methods
  id: totrans-588
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.1\. 可选方法
- en: You’re likely to have come across classes that implement an interface but leave
    empty some method implementations. Take the `Iterator` interface, for example,
    which defines `hasNext` and `next` but also the `remove` method. Before Java 8,
    `remove` was often ignored because users decided not to use that capability. As
    a result, many classes that implement `Iterator` have an empty implementation
    for `remove`, which results in unnecessary boilerplate code.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能遇到过实现接口但留空某些方法实现的类。以 `Iterator` 接口为例，它定义了 `hasNext` 和 `next` 方法，但也定义了 `remove`
    方法。在 Java 8 之前，`remove` 方法通常被忽略，因为用户决定不使用该功能。因此，许多实现 `Iterator` 的类都有 `remove`
    方法的空实现，这导致了不必要的样板代码。
- en: 'With default methods, you can provide a default implementation for such methods,
    so concrete classes don’t need to explicitly provide an empty implementation.
    The `Iterator` interface in Java 8 provides a default implementation for `remove`
    as follows:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认方法，您可以为此类方法提供默认实现，因此具体类不需要显式提供空实现。Java 8 中的 `Iterator` 接口提供了如下 `remove`
    方法的默认实现：
- en: '[PRE85]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Consequently, you can reduce boilerplate code. Any class that implements the
    `Iterator` interface no longer needs to declare an empty `remove` method to ignore
    it because now it has a default implementation.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以减少样板代码。任何实现 `Iterator` 接口的类不再需要声明一个空 `remove` 方法来忽略它，因为现在它已经有了默认实现。
- en: 13.3.2\. Multiple inheritance of behavior
  id: totrans-593
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.2\. 行为的多继承
- en: 'Default methods enable something elegant that wasn’t possible before: *multiple
    inheritance of behavior*, which is the ability of a class to reuse code from multiple
    places ([figure 13.3](#ch13fig03)).'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 默认方法使之前不可能的事情变得优雅：*行为的多继承*，即一个类能够从多个地方重用代码的能力（[图 13.3](#ch13fig03)）。
- en: Figure 13.3\. Single inheritance versus multiple inheritance
  id: totrans-595
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.3\. 单继承与多继承
- en: '![](Images/13fig03_alt.jpg)'
  id: totrans-596
  prefs: []
  type: TYPE_IMG
  zh: '![图片 13.3](Images/13fig03_alt.jpg)'
- en: 'Remember that classes in Java can inherit from only one other class, but classes
    have always been allowed to implement multiple interfaces. To confirm, here’s
    how the class `ArrayList` is defined in the Java API:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Java 中的类只能从另一个类继承，但类始终允许实现多个接口。为了确认，以下是 Java API 中 `ArrayList` 类的定义：
- en: '[PRE86]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '***1* Inherits from one class**'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从一个类继承**'
- en: '***2* Implements four interfaces**'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 实现四个接口**'
- en: Multiple inheritance of types
  id: totrans-601
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类型多继承
- en: 'Here, `ArrayList` is extending one class and directly implementing four interfaces.
    As a result, an `ArrayList` is a direct *subtype* of seven types: `AbstractList`,
    `List`, `RandomAccess`, `Cloneable`, `Serializable`, `Iterable`, and `Collection`.
    In a sense, you already have multiple inheritance of types.'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ArrayList` 扩展了一个类并直接实现了四个接口。因此，`ArrayList` 直接是七个类型的子类型：`AbstractList`、`List`、`RandomAccess`、`Cloneable`、`Serializable`、`Iterable`
    和 `Collection`。从某种意义上说，你已经有多种类型的多重继承。
- en: Because interface methods can have implementations in Java 8, classes can inherit
    behavior (implementation code) from multiple interfaces. In the next section,
    we explore an example to show how you can use this capability to your benefit.
    Keeping interfaces minimal and orthogonal lets you achieve great reuse and composition
    of behavior inside your code base.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Java 8 中接口方法可以有实现，类可以从多个接口继承行为（实现代码）。在下一节中，我们将通过一个示例来展示你如何利用这种能力来获得好处。保持接口最小化和正交性，让你在代码库中实现行为重用和组合。
- en: Minimal interfaces with orthogonal functionalities
  id: totrans-604
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 具有正交功能的接口最小化
- en: Suppose that you need to define several shapes with different characteristics
    for the game you’re creating. Some shapes should be resizable but not rotatable;
    some should be rotatable and movable but not resizable. How can you achieve great
    code reuse?
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要为创建的游戏定义具有不同特性的几个形状。一些形状应该是可调整大小的但不能旋转；一些应该是可旋转和可移动的但不能调整大小。你如何实现代码的重用？
- en: 'You can start by defining a stand-alone `Rotatable` interface with two abstract
    methods: `setRotationAngle` and `getRotationAngle`. The interface also declares
    a default `rotateBy` method that you can implement by using the `setRotationAngle`
    and `get-RotationAngle` methods as follows:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从定义一个独立的 `Rotatable` 接口开始，该接口有两个抽象方法：`setRotationAngle` 和 `getRotationAngle`。该接口还声明了一个默认的
    `rotateBy` 方法，你可以通过使用 `setRotationAngle` 和 `get-RotationAngle` 方法来实现，如下所示：
- en: '[PRE87]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '***1* A default implementation for the method rotateBy**'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* rotateBy 方法的默认实现**'
- en: This technique is somewhat related to the template design pattern, in which
    a skeleton algorithm is defined in terms of other methods that need to be implemented.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术某种程度上与模板设计模式相关，其中通过需要实现的其他方法来定义一个骨架算法。
- en: Now any class that implements `Rotatable` will need to provide an implementation
    for `setRotationAngle` and `getRotationAngle` but will inherit the default implementation
    of `rotateBy` for free.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何实现 `Rotatable` 的类都需要为 `setRotationAngle` 和 `getRotationAngle` 提供实现，但可以免费继承
    `rotateBy` 的默认实现。
- en: 'Similarly, you can define two interfaces that you saw earlier: `Moveable` and
    `Resizable`. Both interfaces contain default implementations. Here’s the code
    for `Moveable`:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以定义之前看到的两个接口：`Moveable` 和 `Resizable`。这两个接口都包含默认实现。以下是 `Moveable` 的代码：
- en: '[PRE88]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'And here’s the code for `Resizable`:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `Resizable` 的代码：
- en: '[PRE89]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Composing interfaces
  id: totrans-615
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 组合接口
- en: 'You can create different concrete classes for your game by composing these
    interfaces. Monsters, for example, can be moveable, rotatable, and resizable:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过组合这些接口来为你的游戏创建不同的具体类。例如，怪物可以是可移动的、可旋转的，也可以是可调整大小的：
- en: '[PRE90]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '***1* Needs to provide implementations for all abstract methods but not the
    default methods**'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 需要为所有抽象方法提供实现，但不需要为默认方法提供实现**'
- en: The `Monster` class automatically inherits the default methods from the `Rotatable`,
    `Moveable`, and `Resizable` interfaces. In this case, `Monster` inherits the implementations
    of `rotateBy`, `moveHorizontally`, `moveVertically`, and `setRelativeSize`.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '`Monster` 类自动从 `Rotatable`、`Moveable` 和 `Resizable` 接口继承默认方法。在这种情况下，`Monster`
    继承了 `rotateBy`、`moveHorizontally`、`moveVertically` 和 `setRelativeSize` 的实现。'
- en: 'Now you can call the different methods directly:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以直接调用不同的方法：
- en: '[PRE91]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '***1* Constructor internally sets the coordinates, height, width, and default
    angle.**'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 构造函数内部设置坐标、高度、宽度和默认角度。**'
- en: '***2* Calling rotateBy from Rotatable**'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从 Rotatable 调用 rotateBy**'
- en: '***3* Calling moveVertically from Moveable**'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 从 Moveable 调用 moveVertically**'
- en: Suppose that now you need to declare another class that’s moveable and rotatable
    but not resizable, such as the sun. You don’t need to copy and paste code; you
    can reuse the default implementations from the `Moveable` and `Rotatable` interfaces,
    as shown here.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在你需要声明另一个类，该类是可移动和可旋转的，但不能调整大小，例如太阳。你不需要复制和粘贴代码；你可以重用 `Moveable` 和 `Rotatable`
    接口中的默认实现，如下所示。
- en: '[PRE92]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '***1* Needs to provide implementations for all abstract methods but not the
    default methods**'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 需要为所有抽象方法提供实现，但不需要为默认方法提供实现**'
- en: '[Figure 13.4](#ch13fig04) illustrates the UML diagram of this scenario.'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13.4](#ch13fig04)展示了该场景的UML图。'
- en: Figure 13.4\. Multiple behavior composition
  id: totrans-629
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.4\. 多种行为组合
- en: '![](Images/13fig04_alt.jpg)'
  id: totrans-630
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13fig04_alt.jpg)'
- en: Here’s another advantage of defining simple interfaces with default implementations
    like the ones for your game. Suppose that you need to modify the implementation
    of `moveVertically` to make it more efficient. You can change its implementation
    directly in the `Moveable` interface, and all classes implementing it automatically
    inherit the code (provided that they didn’t implement the method themselves)!
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是定义简单接口（如你的游戏中的接口）并使用默认实现的另一个优点。假设你需要修改`moveVertically`的实现以使其更高效。你可以在`Moveable`接口中直接更改其实现，并且所有实现它的类都会自动继承代码（前提是它们没有自己实现该方法）！
- en: '|  |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Inheritance considered harmful**'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承被认为是有害的**'
- en: 'Inheritance shouldn’t be your answer to everything when it comes to reusing
    code. For Inheriting from a class that has 100 methods and fields to reuse one
    method is a bad idea, for example, because it adds unnecessary complexity. You’d
    be better off using *delegation*: create a method that calls directly the method
    of the class you need via a member variable. For this reason, you’ll sometimes
    find classes that are declared “final” intentionally: they can’t be inherited
    from to prevent this kind of antipattern or have their core behavior messed with.
    Note that sometimes, `final` classes have a place. `String` is final, for example,
    because you don’t want anybody to be able to interfere with such core functionality.'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码重用方面，继承不应该是你的唯一答案。例如，从一个有100个方法和字段可以重用的类继承一个方法是一个糟糕的想法，因为这会增加不必要的复杂性。你最好使用*委托*：通过成员变量直接调用所需类的方
    法来创建一个方法。因此，你有时会发现故意声明为“final”的类：它们不能被继承以防止这种反模式，或者它们的核心理念被破坏。请注意，有时“final”类有其位置。例如，“String”是final的，因为你不希望任何人能够干扰这种核心功能。
- en: The same idea applies to interfaces with default methods. By keeping your interface
    minimal, you can achieve greater composition because you can select only the implementations
    you need.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的想法也适用于具有默认方法的接口。通过保持你的接口最小化，你可以实现更大的组合，因为你只能选择你需要的实现。
- en: '|  |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You’ve seen that default methods are useful for many usage patterns. But here’s
    some food for thought: What if a class implements two interfaces that have the
    same default method signature? Which method is the class allowed to use? We explore
    this problem in the next section.'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到默认方法对许多使用模式很有用。但这里有一些值得思考的问题：如果一个类实现了两个具有相同默认方法签名的接口，会发生什么？类可以使用哪个方法？我们将在下一节中探讨这个问题。
- en: 13.4\. Resolution rules
  id: totrans-638
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4\. 解决规则
- en: 'As you know, in Java a class can extend only one parent class but implement
    multiple interfaces. With the introduction of default methods in Java 8, there’s
    the possibility of a class inheriting more than one method with the same signature.
    Which version of the method should be used? Such conflicts probably are quite
    rare in practice, but when they do occur, there must be rules that specify how
    to deal with the conflict. This section explains how the Java compiler resolves
    such potential conflicts. We aim to answer questions such as “In the code that
    follows, which `hello` method is `C` calling?” Note that the examples that follow
    are intended to explore problematic scenarios; such scenarios won’t necessarily
    happen frequently in practice:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，在Java中，一个类只能扩展一个父类，但可以实现多个接口。随着Java 8中默认方法的引入，一个类继承多个具有相同签名的方法的可能 性。应该使用哪个方法版本？在实践中，这种冲突可能非常罕见，但一旦发生，就必须有规则来指定如何处理冲突。本节解释了Java编译器如何解决这种潜在的冲突。我们的目标是回答诸如“在下面的代码中，`C`正在调用哪个`hello`方法？”等问题。请注意，以下示例旨在探索问题场景；这些场景在实践
    中不一定经常发生：
- en: '[PRE93]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '***1* What gets printed?**'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印的是什么？**'
- en: In addition, you may have heard of the diamond problem in C++ in which a class
    can inherit two methods with the same signature. Which one gets chosen? Java 8
    provides resolution rules to solve this issue too. Read on!
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能听说过C++中的菱形问题，其中一个类可以继承两个具有相同签名的方法。哪个会被选择？Java 8提供了解决这个问题的规则。继续阅读！
- en: 13.4.1\. Three resolution rules to know
  id: totrans-643
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.4.1\. 需要了解的三个解决规则
- en: 'You have three rules to follow when a class inherits a method with the same
    signature from multiple places (such as another class or interface):'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类从多个地方（例如另一个类或接口）继承具有相同签名的方法时，你需要遵循三个规则：
- en: Classes always win. A method declaration in the class or a superclass takes
    priority over any default method declaration.
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类总是获胜。类或超类中的方法声明优先于任何默认方法声明。
- en: 'Otherwise, subinterfaces win: the method with the same signature in the most
    specific default-providing interface is selected. (If `B` extends `A`, `B` is
    more specific than `A`.)'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，子接口获胜：在具有最具体默认提供接口中具有相同签名的那个方法被选中。（如果 `B` 扩展 `A`，则 `B` 比较具体。）
- en: Finally, if the choice is still ambiguous, the class inheriting from multiple
    interfaces has to explicitly select which default method implementation to use
    by overriding it and calling the desired method explicitly.
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果选择仍然模糊不清，从多个接口继承的类必须通过覆盖它并显式调用所需的方法来显式选择要使用哪个默认方法实现。
- en: We promise that these are the only rules you need to know! In the next section,
    we look at some examples.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保证这些是您需要知道的唯一规则！在下一节中，我们将查看一些例子。
- en: 13.4.2\. Most specific default-providing interface wins
  id: totrans-649
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.4.2\. 最具体默认提供接口获胜
- en: Here, you revisit the example from the beginning of this section in which `C`
    implements both `B` and `A`, which define a default method called `hello`. In
    addition, `B` extends `A`. [Figure 13.5](#ch13fig05) provides a UML diagram for
    the scenario.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你回顾了本节开头提到的例子，其中 `C` 实现了 `B` 和 `A`，它们定义了一个名为 `hello` 的默认方法。此外，`B` 扩展了 `A`。[图
    13.5](#ch13fig05) 为该场景提供了一个 UML 图。
- en: Figure 13.5\. The most specific default-providing interface wins.
  id: totrans-651
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.5\. 最具体的默认提供接口获胜。
- en: '![](Images/13fig05_alt.jpg)'
  id: totrans-652
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig05_alt.jpg)'
- en: Which declaration of the `hello` method will the compiler use? Rule 2 says that
    the method with the most specific default-providing interface is selected. Because
    `B` is more specific than `A`, the `hello` from `B` is selected. Consequently,
    the program prints `"Hello from B"`.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将使用哪个 `hello` 方法的声明？规则 2 表示具有最具体默认提供接口的方法被选中。因为 `B` 比较具体，所以选择了 `B` 的 `hello`。因此，程序打印
    `"Hello from B"`。
- en: 'Now consider what would happen if `C` were inheriting from `D` as follows (illustrated
    in [figure 13.6](#ch13fig06)):'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑如果 `C` 如下继承 `D` 会发生什么（如图 13.6 所示）：
- en: Figure 13.6\. Inheriting from a class and implementing two interfaces
  id: totrans-655
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.6\. 从类继承并实现两个接口
- en: '![](Images/13fig06_alt.jpg)'
  id: totrans-656
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig06_alt.jpg)'
- en: '[PRE94]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '***1* What gets printed?**'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 会打印什么？**'
- en: Rule 1 says that a method declaration in the class takes priority. But `D` doesn’t
    override `hello`; it implements interface `A`. Consequently, it has a default
    method from interface `A`. Rule 2 says that if there are no methods in the class
    or superclass, the method with the most specific default-providing interface is
    selected. The compiler, therefore, has a choice between the `hello` method from
    interface `A` and the `hello` method from interface `B`. Because `B` is more specific,
    the program prints `"Hello from B"` again.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 规则 1 表示类中的方法声明具有优先级。但 `D` 没有覆盖 `hello`；它实现了接口 `A`。因此，它有一个来自接口 `A` 的默认方法。规则 2
    表示如果没有类或超类中的方法，则选择具有最具体默认提供接口的方法。因此，编译器在接口 `A` 的 `hello` 方法和接口 `B` 的 `hello` 方法之间有选择。因为
    `B` 更具体，所以程序再次打印 `"Hello from B"`。
- en: To check your understanding of the resolution rules, try quiz 13.2.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检验你对解析规则的理解，尝试测验 13.2。
- en: '|  |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quiz 13.2: Remember the resolution rules**'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '**测验 13.2：记住解析规则**'
- en: For this quiz, reuse the preceding example, except that `D` explicitly overrides
    the `hello` method from `A`. What do you think will get printed?
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测验，重用前面的例子，除了 `D` 明确覆盖了 `A` 的 `hello` 方法。你认为会打印出什么？
- en: '[PRE95]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '**Answer:**'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: The program prints `"Hello from D"` because a method declaration from a superclass
    has priority, as stated by rule 1.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 程序打印 `"Hello from D"`，因为超类中的方法声明具有优先级，正如规则 1 所述。
- en: Note that if `D` were declared as follows,
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果 `D` 如下声明，
- en: '[PRE96]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: C would be forced to implement the method `hello` itself, even though default
    implementations exist elsewhere in the hierarchy.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在层次结构中的其他地方存在默认实现，`C` 也必须自己实现 `hello` 方法。
- en: '|  |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 13.4.3\. Conflicts and explicit disambiguation
  id: totrans-671
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.4.3\. 冲突和显式消除歧义
- en: 'The examples you’ve seen so far could be resolved by the first two resolution
    rules. Now suppose that `B` doesn’t extend `A` anymore (illustrated in [figure
    13.7](#ch13fig07)):'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止看到的例子可以通过前两个解析规则来解决。现在假设 `B` 不再扩展 `A`（如图 13.7 所示）：
- en: '[PRE97]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Figure 13.7\. Implementing two interfaces
  id: totrans-674
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.7\. 实现两个接口
- en: '![](Images/13fig07.jpg)'
  id: totrans-675
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig07.jpg)'
- en: 'Rule 2 doesn’t help you now because there’s no more-specific interface to select.
    Both `hello` methods from `A` and `B` could be valid options. Thus, the Java compiler
    produces a compile error because it doesn’t know which method is more suitable:
    `"Error: class C inherits unrelated defaults for hello() from types B and A."`'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '规则 2 现在无法帮助你，因为没有更具体的接口可以选择。`A` 和 `B` 的 `hello` 方法都可以是有效的选项。因此，Java 编译器产生了一个编译错误，因为它不知道哪个方法更适合：`"错误：类
    C 从类型 B 和 A 继承了不相关的 hello() 默认值。"` '
- en: Resolving the conflict
  id: totrans-677
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决冲突
- en: 'There aren’t many solutions to resolve the conflict between the two possible
    valid methods; you have to explicitly decide which method declaration you want
    `C` to use. To do so, you can override the `hello` method in class `C` and then,
    in its body, explicitly call the method you want to use. Java 8 introduces the
    new syntax `X.super.m(...)` where `X` is the superinterface whose method `m` you
    want to call. If you want `C` to use the default method from `B`, for example,
    the code looks like this:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 解决两个可能有效方法之间的冲突的解决方案并不多；你必须明确决定你希望 `C` 使用哪个方法声明。为此，你可以在类 `C` 中重写 `hello` 方法，然后在它的主体中明确调用你想要使用的方法。Java
    8 引入了新的语法 `X.super.m(...)`，其中 `X` 是你想要调用其方法 `m` 的超接口。如果你想 `C` 使用来自 `B` 的默认方法，例如，代码看起来是这样的：
- en: '[PRE98]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '***1* Explicitly choosing to call the method from interface B**'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 明确选择调用接口 B 的方法**'
- en: Have a go at quiz 13.3 to investigate a related tricky case.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试做 13.3 题的测验，以调查一个相关复杂的情况。
- en: '|  |'
  id: totrans-682
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quiz 13.3: Almost the same signature**'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '**测验 13.3：几乎相同的签名**'
- en: 'For this quiz, assume that interfaces `A` and `B` are declared as follows:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个测验，假设接口 `A` 和 `B` 被声明如下：
- en: '[PRE99]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Also assume that class `C` is declared as follows:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 还假设类 `C` 被声明如下：
- en: '[PRE100]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: What will the program print?
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将打印什么？
- en: '**Answer:**'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: '`C` can’t distinguish which method of `A` or `B` is more specific. For this
    reason, class `C` won’t compile.'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '`C` 无法区分 `A` 或 `B` 的哪个方法更具体。因此，类 `C` 将无法编译。'
- en: '|  |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 13.4.4\. Diamond problem
  id: totrans-692
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.4.4\. 钻石问题
- en: 'Finally, consider a scenario that sends shivers through the C++ community:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑一个让 C++ 社区感到寒心的场景：
- en: '[PRE101]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '***1* What gets printed?**'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印了什么？**'
- en: '[Figure 13.8](#ch13fig08) illustrates the UML diagram for this scenario. The
    problem is called a *diamond problem* because the diagram resembles a diamond.
    What default method declaration does `D` inherit: the one from `B` or the one
    from `C`? You have only one method declaration to choose. Only `A` declares a
    default method. Because the interface is a superinterface of `D`, the code prints
    `"Hello from A"`.'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13.8](#ch13fig08) 展示了此场景的 UML 图。这个问题被称为 *钻石问题*，因为图看起来像钻石。`D` 继承了哪个默认方法声明：来自
    `B` 的还是来自 `C` 的？你只有一个方法声明可以选择。只有 `A` 声明了默认方法。因为接口是 `D` 的超接口，所以代码将打印 `"来自 A 的问候"`。'
- en: Figure 13.8\. The diamond problem
  id: totrans-697
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.8\. 钻石问题
- en: '![](Images/13fig08_alt.jpg)'
  id: totrans-698
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig08_alt.jpg)'
- en: Now what happens if `B` also has a default `hello` method with the same signature?
    Rule 2 says that you select the most specific default-providing interface. Because
    `B` is more specific than `A`, the default method declaration from `B` is selected.
    If both `B` and `C` declare a `hello` method with the same signature, you have
    a conflict and need to solve it explicitly, as we showed earlier.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果 `B` 也有一个具有相同签名的默认 `hello` 方法会发生什么？规则 2 表示你选择最具体的默认提供接口。因为 `B` 比较具体于 `A`，所以选择了来自
    `B` 的默认方法声明。如果 `B` 和 `C` 都声明了一个具有相同签名的 `hello` 方法，你将有一个冲突，需要像我们之前展示的那样明确解决。
- en: 'As a side note, you may wonder what happens if you add an abstract `hello`
    method (one that’s not default) in interface `C` as follows (still no methods
    in `A` and `B`):'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，你可能想知道如果你在接口 `C` 中添加一个抽象的 `hello` 方法（一个非默认的方法）会发生什么（仍然没有在 `A` 和 `B` 中声明方法）：
- en: '[PRE102]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The new abstract `hello` method in `C` takes priority over the default `hello`
    method from interface `A` because `C` is more specific. Therefore, class `D` needs
    to provide an explicit implementation for `hello`; otherwise, the program won’t
    compile.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '`C` 语言中新的 `hello` 抽象方法比接口 `A` 中的默认 `hello` 方法具有优先级，因为 `C` 更具体。因此，类 `D` 需要为
    `hello` 方法提供一个显式的实现；否则，程序将无法编译。'
- en: '|  |'
  id: totrans-703
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**C++ diamond problem**'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '**C++ 钻石问题**'
- en: 'The diamond problem is more complicated in C++. First, C++ allows multiple
    inheritance of classes. By default, if a class `D` inherits from classes `B` and
    `C`, and classes `B` and `C` both inherit from `A`, class `D` has access to a
    copy of a `B` object and a copy of a `C` object. As a result, uses of methods
    from `A` have to be explicitly qualified: Are they coming from `B` or `C`? In
    addition, classes have state, so modifying member variables from `B` isn’t reflected
    in the copy of the `C` object.'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的菱形问题更为复杂。首先，C++ 允许类的多重继承。默认情况下，如果类 `D` 从类 `B` 和 `C` 继承，并且类 `B` 和 `C` 都从
    `A` 继承，类 `D` 将访问一个 `B` 对象的副本和一个 `C` 对象的副本。因此，使用 `A` 的方法必须显式地限定：它们是从 `B` 还是 `C`
    来的？此外，类具有状态，因此从 `B` 修改成员变量不会反映在 `C` 对象的副本中。
- en: '|  |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'You’ve seen that the default method’s resolution mechanism is simple if a class
    inherits from several methods with the same signature. Follow three rules systematically
    to solve all possible conflicts:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，如果一个类从多个具有相同签名的默认方法继承，默认方法的解析机制很简单。系统地遵循三个规则来解决所有可能的冲突：
- en: First, an explicit method declaration in the class or a superclass takes priority
    over any default method declaration.
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在类或超类中显式的方法声明优先于任何默认方法声明。
- en: Otherwise, the method with the same signature in the most specific default-providing
    interface is selected.
  id: totrans-709
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，将选择在最具特定性的默认提供接口中具有相同签名的那个方法。
- en: Finally, if there’s still a conflict, you have to explicitly override the default
    methods and choose which one your class should use.
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果仍然存在冲突，你必须显式地覆盖默认方法并选择你的类应该使用哪一个。
- en: Summary
  id: totrans-711
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Interfaces in Java 8 can have implementation code through default methods and
    static methods.
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 8 中的接口可以通过默认方法和静态方法具有实现代码。
- en: Default methods start with a `default` keyword and contain a body, as class
    methods do.
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认方法以 `default` 关键字开头，并包含一个主体，就像类方法一样。
- en: Adding an abstract method to a published interface is a source incompatibility.
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向已发布的接口添加抽象方法会导致源不兼容。
- en: Default methods help library designers evolve APIs in a backward-compatible
    way.
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认方法有助于库设计者以向后兼容的方式演进 API。
- en: Default methods can be used for creating optional methods and multiple inheritance
    of behavior.
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认方法可用于创建可选方法和行为的多重继承。
- en: Resolution rules exist to resolve conflicts when a class inherits from several
    default methods with the same signature.
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个类从多个具有相同签名的默认方法继承时，存在解决冲突的规则。
- en: A method declaration in the class or a superclass takes priority over any default
    method declaration. Otherwise, the method with the same signature in the most
    specific default-providing interface is selected.
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类或超类中的方法声明优先于任何默认方法声明。否则，将选择在最具特定性的默认提供接口中具有相同签名的那个方法。
- en: When two methods are equally specific, a class must explicitly override this
    method, such as to select which one to call.
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当两个方法具有相同的特定性时，一个类必须显式地覆盖此方法，例如选择调用哪一个。
- en: Chapter 14\. The Java Module System
  id: totrans-720
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 14 章。Java 模块系统
- en: '![](Images/java.jpg)'
  id: totrans-721
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/java.jpg)'
- en: '*This chapter covers*'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: The evolutionary forces causing Java to adopt a module system
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导致 Java 采用模块系统的进化力量
- en: 'The main structure: module declarations and requires and exports directives'
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要结构：模块声明和 requires 以及 exports 指令
- en: Automatic modules for legacy Java Archives (JARs)
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动模块化旧版 Java 归档 (JAR)
- en: Modularization and the JDK library
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化与 JDK 库
- en: Modules and Maven builds
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块和 Maven 构建
- en: A brief summary of module directives beyond simple `requires` and `exports`
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要总结除简单的 `requires` 和 `exports` 之外的其他模块指令
- en: The main and most-discussed new feature introduced with Java 9 is its module
    system. This feature was developed within project Jigsaw, and its development
    took almost a decade. This timeline is a good measure of both the importance of
    this addition and the difficulties that the Java development team met while implementing
    it. This chapter provides background on why you should care as a developer what
    a module system is, as well as an overview of what the new Java Module System
    is intended for and how you can benefit from it.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 9 一起引入的主要且最常讨论的新特性是其模块系统。该特性是在 Jigsaw 项目中开发的，其开发历时近十年。这个时间表是衡量这一新增功能重要性的良好指标，也是衡量
    Java 开发团队在实现它时所遇到的困难的良好指标。本章提供了背景信息，说明为什么作为开发者你应该关心模块系统是什么，以及新的 Java 模块系统旨在做什么以及你如何从中受益。
- en: Note that the Java Module System is a complex topic that merits a whole book.
    We recommend *The Java Module System* by Nicolai Parlog (Manning Publications,
    [https://www.manning.com/books/the-java-module-system](https://www.manning.com/books/the-java-module-system))
    for a comprehensive resource. In this chapter, we deliberately keep to the broad-brush
    picture so that you understand the main motivation and get a rapid overview of
    how to work with Java modules.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Java 模块系统是一个复杂的话题，值得一本书来专门讨论。我们推荐 Nicolai Parlog 的《Java 模块系统》（Manning Publications，[https://www.manning.com/books/the-java-module-system](https://www.manning.com/books/the-java-module-system)）作为全面资源的参考。在本章中，我们故意保持广泛的概述，以便你理解主要动机，并快速了解如何使用
    Java 模块。
- en: '14.1\. The driving force: reasoning about software'
  id: totrans-731
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1\. 驱动力：对软件进行推理
- en: 'Before you delve into the details of the Java Module System, it’s useful to
    understand some motivation and background to appreciate the goals set out by the
    Java language designers. What does modularity mean? What problem is the module
    system looking to address? This book has spent quite a lot of time discussing
    new language features that help us write code that reads closer to the problem
    statement and, as a result, is easier to understand and maintain. This concern
    is a low-level one, however. Ultimately, at a high level (software-architectural
    level), you want to work with a software project that’s easy to reason about because
    this makes you more productive when you introduce changes in your code base. In
    the following sections, we highlight two design principles that help produce software
    that’s easier to reason about: *separation of concerns* and *information hiding*.'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨 Java 模块系统的细节之前，了解一些动机和背景对于理解 Java 语言设计者设定的目标是有用的。模块化意味着什么？模块系统试图解决什么问题？本书花费了大量时间讨论新的语言特性，这些特性帮助我们编写更接近问题声明的代码，因此更容易理解和维护。然而，这种关注是低层次的。最终，在高层（软件架构层面），你希望与一个易于推理的软件项目合作，因为当你对你的代码库进行更改时，这会使你更有效率。在接下来的章节中，我们强调了两个有助于产生易于推理的软件的设计原则：*关注点分离*和*信息隐藏*。
- en: 14.1.1\. Separation of concerns
  id: totrans-733
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.1\. 关注点分离
- en: Separation of concerns (SoC) is a principle that promotes decomposing a computer
    program into distinct features. Suppose that you need to develop an accounting
    application that parses expenses in different formats, analyzes them, and provides
    summary reports to your customer. By applying SoC, you split parsing, analysis,
    and reporting into separate parts called *modules*—cohesive groups of code that
    have little overlap. In other words, a module groups classes, allowing you to
    express visibility relationships between classes in your application.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 关注点分离（SoC）是一个促进将计算机程序分解为不同特性的原则。假设你需要开发一个会计应用程序，该程序可以解析不同格式的费用，分析它们，并向客户提供总结报告。通过应用
    SoC，你将解析、分析和报告分解为称为 *模块* 的独立部分——具有很少重叠的代码集合。换句话说，模块将类分组，允许你表达应用程序中类之间的可见性关系。
- en: You might say, “Ah, but Java packages already group classes.” You’re right,
    but Java 9 modules give you finer-grained control of which classes can see which
    other classes and allow this control to be checked at compile time. In essence,
    Java packages don’t support modularity.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会说：“啊，但 Java 包已经将类分组。”你说得对，但 Java 9 模块让你能够更细粒度地控制哪些类可以看到哪些其他类，并允许在编译时检查这种控制。本质上，Java
    包不支持模块化。
- en: The SoC principle is useful at an architectural point of view (such as model
    versus view versus controller) and in a low-level approach (such as separating
    the business logic from the recovery mechanism). The benefits are
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: SoC 原则在架构观点（如模型与视图与控制器）和低级方法（如将业务逻辑与恢复机制分离）中都很有用。其好处包括
- en: Allowing work on individual parts in isolation, which helps team collaboration
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许独立工作于各个部分，这有助于团队协作
- en: Facilitating reuse of separate parts
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进独立部分的复用
- en: Easier maintenance of the overall system
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易维护整体系统
- en: 14.1.2\. Information hiding
  id: totrans-740
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.2\. 信息隐藏
- en: '*Information hiding* is a principle that encourages hiding implementation details.
    Why is this principle important? In the context of building software, requirements
    can change frequently. By hiding implementation details, you can reduce the chances
    that a local change will require cascading changes in other parts of your program.
    In other words, it’s a useful principle for managing and protecting your code.
    You often hear the term *encapsulation* used to indicate that a specific piece
    of code is so well isolated from the other parts of the application that changing
    its internal implementation won’t negatively affect them. In Java, you can get
    a compiler to check that *components within a class* are well encapsulated by
    using the `private` keyword appropriately. But until Java 9, there was no language
    structure to allow the compiler to check that *classes and packages were available
    only* for the intended purposes.'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '*信息隐藏*是一种鼓励隐藏实现细节的原则。为什么这个原则很重要？在构建软件的背景下，需求可能会频繁变化。通过隐藏实现细节，你可以减少局部更改导致程序其他部分级联更改的可能性。换句话说，这是一个有用的原则，用于管理和保护你的代码。你经常听到*封装*这个术语用来表示特定的代码片段与应用程序的其他部分隔离得很好，以至于更改其内部实现不会对其产生负面影响。在Java中，你可以通过适当地使用`private`关键字来让编译器检查*类内的组件*是否得到了良好的封装。但直到Java
    9之前，没有语言结构允许编译器检查*类和包仅对预期目的可用*。'
- en: 14.1.3\. Java software
  id: totrans-742
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.3\. Java软件
- en: These two principles are fundamental in any well-designed software. How do they
    fit with Java language features? Java is an object-oriented language, and you
    work with classes and interfaces. You make your code *modular* by grouping packages,
    classes, and interfaces that address a specific concern. In practice, reasoning
    about raw code is a bit abstract. As a result, tools such as UML diagrams (or,
    more simply, boxes and arrows) help you reason about your software by visually
    representing dependencies among parts of your code. [Figure 14.1](#ch14fig01)
    shows a UML diagram for an application managing a user profile that has been decomposed
    into three specific concerns.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个原则在任何设计良好的软件中都是基本的。它们如何与Java语言特性相匹配？Java是一种面向对象的语言，你使用类和接口。你通过将处理特定问题的包、类和接口分组来使你的代码*模块化*。在实践中，对原始代码进行推理有点抽象。因此，像UML图（或者更简单地说，方框和箭头）这样的工具通过直观地表示代码各部分之间的依赖关系来帮助你推理你的软件。[图14.1](#ch14fig01)显示了一个将应用程序管理用户配置文件分解为三个特定关注点的UML图。
- en: Figure 14.1\. Three separate concerns with dependencies
  id: totrans-744
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.1\. 具有依赖关系的三个独立关注点
- en: '![](Images/14fig01_alt.jpg)'
  id: totrans-745
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14fig01_alt.jpg)'
- en: 'What about information hiding? In Java, you’re familiar with using visibility
    modifiers to control access to methods, fields, and classes: public, protected,
    package-level, and private. As we clarify in the next section, however, their
    granularity isn’t fine enough in many cases, and you could be obliged to declare
    a method public even if you didn’t intend to make it accessible for end users.
    This concern wasn’t a huge one in the early days of Java, when applications and
    dependency chains were relatively small. Now that many Java applications are large,
    the problem is more important. Indeed, if you see a `public` field or method in
    a class, you probably feel entitled to use it (don’t you?), even though the designer
    may regard it as being only for private use among a few of his own classes!'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 关于信息隐藏，在Java中，你熟悉使用可见性修饰符来控制对方法、字段和类的访问：public、protected、包级别和private。然而，正如我们在下一节中将要阐明的，在许多情况下，它们的粒度还不够精细，你可能被迫声明一个方法为public，即使你并没有打算让它对最终用户可访问。在Java的早期，当应用程序和依赖链相对较小的时候，这个问题并不是很大。现在，随着许多Java应用程序变得庞大，这个问题变得更加重要。确实，如果你在一个类中看到一个`public`字段或方法，你可能觉得自己有权使用它（难道不是吗？），即使设计者可能认为它只适用于他自己的几个类中的私有使用！
- en: Now that you understand the benefits of modularization, you may wonder how supporting
    it causes changes in Java. We explain in the next section.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了模块化的好处，你可能想知道支持它如何导致Java发生变化。我们将在下一节中解释。
- en: 14.2\. Why the Java Module System was designed
  id: totrans-748
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2\. 为什么设计Java模块系统
- en: In this section, you learn why a new module system was designed for the Java
    language and compiler. First, we cover the limitations of modularity before Java
    9\. Next, we provide background about the JDK library and explain why modularizing
    it was important.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解为什么为Java语言和编译器设计了新的模块系统。首先，我们介绍Java 9之前的模块化限制。接下来，我们提供关于JDK库的背景信息，并解释为什么模块化它很重要。
- en: 14.2.1\. Modularity limitations
  id: totrans-750
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.1\. 模块化限制
- en: 'Unfortunately, the built-in support in Java to help produce modular software
    projects was somewhat limited before Java 9. Java has had three levels at which
    code was grouped: classes, packages, and JARs. For classes, Java has always had
    support for access modifiers and encapsulation. There was little encapsulation
    at the package and JAR levels, however.'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在 Java 9 之前，Java 内置的用于帮助生成模块化软件项目的支持有限。Java 有三个级别来分组代码：类、包和 JAR。对于类，Java
    一直支持访问修饰符和封装。然而，在包和 JAR 级别，封装很少。
- en: Limited Visibility Control
  id: totrans-752
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 有限的可见性控制
- en: As discussed in the previous section, Java provides access modifiers to support
    information hiding. These modifiers are public, protected, package-level, and
    private visibility. But what about controlling visibility *between* packages?
    Most applications have several packages defined to group various classes, but
    packages have limited support for visibility control. If you want classes and
    interfaces from one package to be visible to another package, you have to declare
    them as public. As a consequence, these classes and interfaces are accessible
    to everyone else as well. A typical occurrence of this problem is when you see
    companion packages with names that include the string `"impl"` to provide default
    implementations. In this case, because the code inside that package was defined
    as public, you have no way to prevent users from using these internal implementations.
    As a result, it becomes difficult to evolve your code without making breaking
    changes, because what you thought was for internal use only was used by a programmer
    temporarily to get something working and then frozen into the system. Worse, this
    situation is bad from a security point of view because you potentially increase
    the attack surface as more code is exposed to the risk of tampering.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Java 提供了访问修饰符来支持信息隐藏。这些修饰符是公共的、受保护的、包级别的和私有的可见性。但包之间的可见性控制怎么办？大多数应用程序定义了几个包来分组各种类，但包对可见性控制的支持有限。如果你想使一个包中的类和接口对另一个包可见，你必须将它们声明为公共的。因此，这些类和接口对每个人都是可访问的。这个问题的一个典型例子是，当你看到名称中包含字符串
    `"impl"` 的伴随包，以提供默认实现。在这种情况下，因为该包内的代码被定义为公共的，你无法阻止用户使用这些内部实现。结果，如果不进行破坏性更改，就很难演进你的代码，因为你认为仅供内部使用的代码被程序员临时用来使某物工作，然后被冻结到系统中。更糟糕的是，从安全角度来看，这种情况很糟糕，因为你可能增加了攻击面，因为更多的代码暴露在篡改的风险中。
- en: Class Path
  id: totrans-754
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 类路径
- en: Earlier in this chapter, we discussed the benefits of software written in a
    way that makes it simple to maintain and understand—in other words, easier to
    reason about. We also talked about separation of concerns and modeling dependencies
    between modules. Unfortunately, Java historically falls short in supporting these
    ideas when it comes to bundling and running an application. In fact, you have
    to ship all your compiled classes into one single flat JAR, which is made accessible
    from the class path.^([[1](#ch14fn01)]) Then the JVM can dynamically locate and
    load classes from the class path as needed.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们讨论了编写易于维护和理解的软件的好处——换句话说，更容易推理。我们还讨论了关注点的分离以及模块之间的依赖建模。不幸的是，在打包和运行应用程序时，Java
    历史上在这些想法上的支持不足。事实上，你必须将所有编译后的类放入一个单一的扁平 JAR 文件中，然后通过类路径使其可访问.^([[1](#ch14fn01)])
    然后 JVM 可以根据需要动态定位和从类路径加载类。
- en: ¹
  id: totrans-756
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-757
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This spelling is used in Java documentation, but `classpath` is often used for
    arguments to programs.
  id: totrans-758
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种拼写用于 Java 文档中，但 `classpath` 通常用于程序的参数。
- en: Unfortunately, the combination of the class path and JARs has several downsides.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，类路径和 JAR 的组合有几个缺点。
- en: First, the class path has no notion of versioning for the same class. You can’t,
    for example, specify that the class JSONParser from a parsing library should belong
    to version 1.0 or version 2.0, so you can’t predict what will happen if the same
    library with two different versions is available on the class path. This situation
    is common in large applications, as you may have different versions of the same
    libraries used by different components of your application.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，类路径没有相同类的版本概念。例如，你不能指定解析库中的类 JSONParser 应属于版本 1.0 或版本 2.0，因此你无法预测如果类路径上有两个不同版本的相同库会发生什么。这种情况在大型应用程序中很常见，因为你可能使用不同版本的相同库来支持应用程序的不同组件。
- en: 'Second, the class path doesn’t support explicit dependencies; all the classes
    inside different JARs are merged into one bag of classes on the class path. In
    other words, the class path doesn’t let you declare explicitly that one JAR depends
    on a set of classes contained inside another JAR. This situation makes it difficult
    to reason about the class path and to ask questions such as:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，类路径不支持显式依赖项；不同 JAR 中的所有类都被合并到类路径上的一个类集合中。换句话说，类路径不允许你明确声明一个 JAR 依赖于另一个 JAR
    中包含的一组类。这种情况使得推理类路径和提出诸如：
- en: Is anything missing?
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何东西遗漏了吗？
- en: Are there any conflicts?
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有任何冲突吗？
- en: Build tools such as Maven and Gradle can help you solve this problem. Before
    Java 9, however, neither Java nor the JVM had any support for explicit dependencies.
    The issues combined are often referred to as JAR Hell or Class Path Hell. The
    direct consequence of these problems is that it’s common to have to keep adding
    and removing class files on the class path in a trial-and-error cycle, in the
    hope that the JVM will execute your application without throwing runtime exceptions
    such as `ClassNotFound-Exception`. Ideally, you’d like such problems to be discovered
    early in the development process. Using the Java 9 module system consistently
    enables all such errors to be detected at compile time.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 建设工具如 Maven 和 Gradle 可以帮助你解决这个问题。然而，在 Java 9 之前，Java 和 JVM 都没有对显式依赖项的支持。这些问题通常被称为
    JAR 地狱或类路径地狱。这些问题的直接后果是，在尝试和错误的过程中，通常需要不断在类路径上添加和删除类文件，希望 JVM 能够在没有抛出如 `ClassNotFound-Exception`
    等运行时异常的情况下执行你的应用程序。理想情况下，你希望这些问题在开发早期就被发现。一致地使用 Java 9 模块系统可以在编译时检测到所有这些错误。
- en: Encapsulation and Class Path Hell aren’t problems only for your software architecture,
    however. What about the JDK itself?
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 封装和类路径地狱不仅仅是你的软件架构的问题。那么 JDK 本身呢？
- en: 14.2.2\. Monolithic JDK
  id: totrans-766
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.2. 单一 JDK
- en: The *Java Development Kit* (JDK) is a collection of tools that lets you work
    with and run Java programs. Perhaps the most important tools you’re familiar with
    are `javac` to compile Java programs and `java` to load and run a Java application,
    along with the JDK library, which provides runtime support including input/output,
    collections, and streams. The first version was released in 1996\. It’s important
    to understand that like any software, the JDK has grown and increased considerably
    in size. Many technologies were added and later deprecated. CORBA is a good example.
    It doesn’t matter whether you’re using CORBA in your application or not; its classes
    are shipped with the JDK. This situation becomes problematic especially in applications
    that run on mobile or in the cloud and typically don’t need all the parts available
    in the JDK library.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java 开发工具包*（JDK）是一组工具，它允许你使用和运行 Java 程序。你可能最熟悉的工具是 `javac`，用于编译 Java 程序，以及
    `java`，用于加载和运行 Java 应用程序，还有 JDK 库，它提供了包括输入/输出、集合和流在内的运行时支持。第一个版本于 1996 年发布。重要的是要理解，就像任何软件一样，JDK
    已经增长并显著增加了大小。许多技术被添加，后来被弃用。CORBA 是一个很好的例子。无论你在应用程序中使用 CORBA 还是未使用，其类都包含在 JDK 中。这种情况在运行在移动设备或云上的应用程序中尤其成问题，这些应用程序通常不需要
    JDK 库中所有可用的部分。'
- en: How can you get away from this problem as a whole ecosystem? Java 8 introduced
    the notion of *compact profiles* as a step forward. Three profiles were introduced
    to have different memory footprints, depending on which parts of the JDK library
    you’re interested in. Compact profiles, however, provided only a short-term fix.
    Many internal APIs in the JDK aren’t meant for public use. Unfortunately, due
    to the poor encapsulation provided by the Java language, those APIs are commonly
    used. The class `sun.misc.Unsafe`, for example, is used by several libraries (including
    Spring, Netty, and Mockito) but was never intended to be made available outside
    the JDK internals. As a result, it’s extremely difficult to evolve these APIs
    without introducing incompatible changes.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 作为整个生态系统，你如何避免这个问题？Java 8 引入了 *紧凑配置文件* 的概念，作为向前迈出的一步。引入了三个配置文件，以便根据你感兴趣的 JDK
    库的不同部分具有不同的内存占用。然而，紧凑配置文件只提供了短期解决方案。JDK 中的许多内部 API 都不是为公共使用而设计的。不幸的是，由于 Java 语言提供的封装性较差，这些
    API 通常被广泛使用。例如，`sun.misc.Unsafe` 类被几个库（包括 Spring、Netty 和 Mockito）使用，但从未打算在 JDK
    内部之外提供。因此，在不引入不兼容更改的情况下，很难演进这些 API。
- en: All these problems provided the motivation for designing a Java Module System
    that also can be used to modularize the JDK itself. In a nutshell, new structuring
    constructs were required to allow you to choose what parts of the JDK you need
    and how to reason about the class path, and to provide stronger encapsulation
    to evolve the platform.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都为设计一个Java模块系统提供了动力，该系统也可以用来模块化JDK本身。简而言之，需要新的结构化构造来允许您选择需要JDK的哪些部分以及如何对类路径进行推理，并提供更强的封装以演进平台。
- en: 14.2.3\. Comparison with OSGi
  id: totrans-770
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.3. 与OSGi的比较
- en: This section compares Java 9 modules with OSGi. If you haven’t heard of OSGi,
    we suggest that you skip this section.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 本节比较了Java 9模块与OSGi。如果您还没有听说过OSGi，我们建议您跳过本节。
- en: Before the introduction of modules based on project Jigsaw into Java 9, Java
    already had a powerful module system, named OSGi, even if it wasn’t formally part
    of the Java platform. The Open Service Gateway initiative (OSGi) started in 2000
    and, until the arrival of Java 9, represented the de-facto standard for implementing
    a modular application on the JVM.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于项目Jigsaw的模块引入Java 9之前，Java已经有一个强大的模块系统，名为OSGi，即使它不是Java平台正式的一部分。开放服务网关倡议（OSGi）始于2000年，直到Java
    9的到来，它代表了在JVM上实现模块化应用程序的事实标准。
- en: In reality, OSGi and the new Java 9 Module System aren’t mutually exclusive;
    they can coexist in the same application. In fact, their features overlap only
    partially. OSGi has a much wider scope and provides many capabilities that aren’t
    available in Jigsaw.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，OSGi和新的Java 9模块系统并不是相互排斥的；它们可以在同一个应用程序中共存。事实上，它们的功能只是部分重叠。OSGi具有更广泛的范围，并提供了许多Jigsaw中不可用的功能。
- en: OSGi modules are called *bundles* and run inside a specific OSGi framework.
    Several certified OSGi framework implementations exist, but the two with the widest
    adoption are Apache Felix and Equinox (which is also used to run the Eclipse IDE).
    When running inside an OSGi framework, a single bundle can be remotely installed,
    started, stopped, updated, and uninstalled without a reboot. In other words, OSGi
    defines a clear life cycle for bundles made by the states listed in [table 14.1](#ch14table01).
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: OSGi模块被称为*bundles*，并在特定的OSGi框架中运行。存在几个认证的OSGi框架实现，但最广泛采用的两个是Apache Felix和Equinox（它也被用来运行Eclipse
    IDE）。当在OSGi框架中运行时，单个捆绑包可以远程安装、启动、停止、更新和卸载，而无需重启。换句话说，OSGi为捆绑包定义了一个清晰的周期，这些状态列在[表14.1](#ch14table01)中。
- en: Table 14.1\. Bundle states in OSGi
  id: totrans-775
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表14.1. OSGi中的捆绑包状态
- en: '| Bundle state | Description |'
  id: totrans-776
  prefs: []
  type: TYPE_TB
  zh: '| 捆绑包状态 | 描述 |'
- en: '| --- | --- |'
  id: totrans-777
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| INSTALLED | The bundle has been successfully installed. |'
  id: totrans-778
  prefs: []
  type: TYPE_TB
  zh: '| 已安装 | 该捆绑包已成功安装。 |'
- en: '| RESOLVED | All Java classes that the bundle needs are available. |'
  id: totrans-779
  prefs: []
  type: TYPE_TB
  zh: '| 解析中 | 捆绑包需要的所有Java类都可用。 |'
- en: '| STARTING | The bundle is being started, and the BundleActivator.start method
    has been called, but the start method hasn’t yet returned. |'
  id: totrans-780
  prefs: []
  type: TYPE_TB
  zh: '| 启动中 | 捆绑包正在启动，已调用BundleActivator.start方法，但启动方法尚未返回。 |'
- en: '| ACTIVE | The bundle has been successfully activated and is running. |'
  id: totrans-781
  prefs: []
  type: TYPE_TB
  zh: '| 活跃 | 该捆绑包已成功激活并正在运行。 |'
- en: '| STOPPING | The bundle is being stopped. The BundleActivator.stop method has
    been called, but the stop method hasn’t yet returned. |'
  id: totrans-782
  prefs: []
  type: TYPE_TB
  zh: '| 停止中 | 捆绑包正在停止。已调用BundleActivator.stop方法，但停止方法尚未返回。 |'
- en: '| UNINSTALLED | The bundle has been uninstalled. It can’t move into another
    state. |'
  id: totrans-783
  prefs: []
  type: TYPE_TB
  zh: '| 未安装 | 该捆绑包已被卸载。它不能移动到另一个状态。 |'
- en: The possibility of hot-swapping different subparts of your application without
    the need to restart it probably is the main advantage of OSGi over Jigsaw. Each
    bundle is defined through a text file describing which external packages are required
    by the bundle to work and which internal packages are publicly exported by the
    bundle and then made available to other bundles.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 无需重新启动应用程序即可热插拔不同的子部分，这可能是OSGi相对于Jigsaw的主要优势。每个捆绑包通过一个文本文件定义，该文件描述了捆绑包需要哪些外部包才能工作，以及捆绑包公开导出哪些内部包并将其提供给其他捆绑包。
- en: Another interesting characteristic of OSGi is that it allows different versions
    of the same bundle to be installed in the framework at the same time. The Java
    9 Module System doesn’t support version control because Jigsaw still uses one
    single class loader per application, whereas OSGi loads each bundle in its own
    class loader.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: OSGi的另一个有趣的特点是它允许在框架中同时安装同一捆绑包的不同版本。Java 9模块系统不支持版本控制，因为Jigsaw仍然为每个应用程序使用一个单独的类加载器，而OSGi为每个捆绑包加载其自己的类加载器。
- en: '14.3\. Java modules: the big picture'
  id: totrans-786
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3. Java模块：整体情况
- en: 'Java 9 provides a new unit of Java program structure: the *module*. A module
    is introduced with a new keyword^([[2](#ch14fn02)]) `module`, followed by its
    name and its body. Such a *module descriptor*^([[3](#ch14fn03)]) lives in a special
    file: `module-info.java`, which is compiled to `module-info.class`. The body of
    a module descriptor consists of clauses, of which the two most important are `requires`
    and `exports`. The former clause specifies what other modules your modules need
    to run, and `exports` specifies everything that your module wants to be visible
    for other modules to use. You learn about these clauses in more detail in later
    sections.'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9 提供了一个新的 Java 程序结构单元：*模块*。模块通过一个新的关键字 `module` 引入，后跟其名称和其主体。这样的 *模块描述符*
    生活在一个特殊的文件中：`module-info.java`，它被编译成 `module-info.class`。模块描述符的主体由子句组成，其中最重要的两个是
    `requires` 和 `exports`。前者子句指定了您的模块需要哪些其他模块来运行，而 `exports` 指定了您的模块希望对其他模块可见的所有内容。您将在后面的章节中详细了解这些子句。
- en: ²
  id: totrans-788
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-789
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Technically, Java 9 module-forming identifiers—such as `module, requires`, and
    `export`—are *restricted keywords*. You can still use them as identifiers elsewhere
    in your program (for backward compatibility), but they’re interpreted as keywords
    in a context where modules are allowed.
  id: totrans-790
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 技术上，Java 9 模块形成标识符（如 `module`、`requires` 和 `export`）是 *受限关键字*。您仍然可以在程序的其他地方使用它们作为标识符（为了向后兼容），但在允许模块的上下文中它们被解释为关键字。
- en: ³
  id: totrans-791
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-792
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Legally, the textual form is called a *module declaration*, and the binary form
    in `module-info.class` is referred to as a *module descriptor*.
  id: totrans-793
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 法律上，文本形式被称为 *模块声明*，而在 `module-info.class` 中的二进制形式被称为 *模块描述符*。
- en: A module descriptor describes and encapsulates one or more packages (and typically
    lives in the same folder as these packages), but in simple use cases, it exports
    (makes visible) only one of these packages.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 模块描述符描述并封装了一个或多个包（通常与这些包位于同一文件夹中），但在简单用例中，它只导出（使可见）这些包中的一个。
- en: The core structure of a Java module descriptor is shown in [figure 14.2](#ch14fig02).
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: Java 模块描述符的核心结构如图 [图 14.2](#ch14fig02) 所示。
- en: Figure 14.2\. Core structure of a Java module descriptor (`module-info.java`)
  id: totrans-796
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.2\. Java 模块描述符的核心结构 (`module-info.java`)
- en: '![](Images/14fig02_alt.jpg)'
  id: totrans-797
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14fig02_alt.jpg)'
- en: It is helpful to think of the `exports` and `requires` parts of a module as
    being respectively like the lugs (or tabs) and holes of a jigsaw puzzle (which
    is perhaps where the working name Project Jigsaw originated). [Figure 14.3](#ch14fig03)
    shows an example with several modules.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块的 `exports` 和 `requires` 部分想象成拼图（或许这就是 Project Jigsaw 这个工作名称的由来）的凸起（或标签）和凹槽是很有帮助的。[图
    14.3](#ch14fig03) 展示了几个模块的示例。
- en: Figure 14.3\. Jigsaw-puzzle-style example of a Java system built from four modules
    (A, B, C, D). Module A requires modules B and C to be present, and thereby gets
    access to the packages `pkgB` and `pkgC` (exported by modules B and C, respectively).
    Module C may similarly use package `pkgD`, which it has required from module C,
    but Module B can’t use `pkgD`.
  id: totrans-799
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.3\. 由四个模块（A、B、C、D）构建的 Java 系统的拼图风格示例。模块 A 需要模块 B 和 C 存在，从而获得对由模块 B 和 C
    分别导出的包 `pkgB` 和 `pkgC` 的访问。模块 C 可以类似地使用它从模块 C 所需的包 `pkgD`，但模块 B 不能使用 `pkgD`。
- en: '![](Images/14fig03_alt.jpg)'
  id: totrans-800
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14fig03_alt.jpg)'
- en: When you use tools such as Maven, much of the detail of module descriptions
    is handled by an IDE and is hidden from the user.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 Maven 等工具时，模块描述的许多细节由 IDE 处理，并从用户那里隐藏起来。
- en: Having said that, in the next section we explore these concepts in more detail
    based on examples.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在下一节中，我们将通过示例更详细地探讨这些概念。
- en: 14.4\. Developing an application with the Java Module System
  id: totrans-803
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4\. 使用 Java 模块系统开发应用程序
- en: In this section, you get an overview of the Java 9 Module System by building
    a simple modular application from the ground up. You learn how to structure, package,
    and launch a small modular application. This section doesn’t explain each topic
    in detail but shows you the big picture, so you can delve independently in more
    depth if needed.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将通过从头开始构建一个简单的模块化应用程序来概述 Java 9 模块系统。您将学习如何构建、打包和启动一个小型模块化应用程序。本节不会详细解释每个主题，而是展示整体情况，以便您在需要时可以独立深入探究。
- en: 14.4.1\. Setting up an application
  id: totrans-805
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.4.1\. 设置应用程序
- en: 'To get started with the Java Module System, you need an example project to
    write code for. Perhaps you’re traveling a lot, grocery shopping, or going out
    for coffee with your friends, and you have to deal with a lot of receipts. Nobody
    ever enjoyed managing expenses. To help yourself out, you write an application
    that can manage your expenses. The application needs to conduct several tasks:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Java模块系统，您需要一个示例项目来编写代码。也许您经常出差，去杂货店购物，或者和朋友们一起喝咖啡，您不得不处理大量的收据。没有人喜欢管理费用。为了帮助自己，您编写了一个可以管理费用的应用程序。该应用程序需要执行以下任务：
- en: Read a list of expenses from a file or a URL;
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件或URL读取费用列表；
- en: Parse the string representations of these expenses;
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析这些费用的字符串表示；
- en: Calculate statistics;
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算统计数据；
- en: Display a useful summary;
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示有用的摘要；
- en: Provide a main start-up and close-down coordinator for these tasks.
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为这些任务提供一个主要的启动和关闭协调器。
- en: You need to define different classes and interfaces to model the concepts in
    this application. First, a `Reader` interface lets you read serialized expenses
    from a source. You’ll have different implementations, such as `HttpReader` or
    `FileReader`, depending on the source. You also need a `Parser` interface to deserialize
    the JSON objects into a domain object `Expense` that you can manipulate in your
    Java application. Finally, you need a class `SummaryCalculator` to be responsible
    for calculating statistics, given a list of `Expense` objects, and to return `SummaryStatistics`
    objects.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要定义不同的类和接口来建模此应用程序中的概念。首先，一个`Reader`接口允许您从源读取序列化的费用。您将拥有不同的实现，例如`HttpReader`或`FileReader`，具体取决于源。您还需要一个`Parser`接口将JSON对象反序列化为可以在Java应用程序中操作的领域对象`Expense`。最后，您需要一个`SummaryCalculator`类来负责根据`Expense`对象列表计算统计数据，并返回`SummaryStatistics`对象。
- en: 'Now that you have a project, how do you modularize it by using the Java Module
    System? It’s clear that the project involves several concerns, which you want
    to separate:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有一个项目，您如何使用Java模块系统对其进行模块化？显然，项目涉及多个关注点，您希望将其分离：
- en: Reading data from different sources (`Reader`, `HttpReader`, `FileReader`)
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从不同的源读取数据（`Reader`，`HttpReader`，`FileReader`）
- en: Parsing the data from different formats (`Parser`, `JSONParser`, `ExpenseJSON-Parser`)
  id: totrans-815
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析来自不同格式的数据（`Parser`，`JSONParser`，`ExpenseJSON-Parser`）
- en: Representing domain objects (`Expense`)
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示领域对象（`Expense`）
- en: Calculating and returning statistics (`SummaryCalculator`, `SummaryStatistics`)
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算并返回统计数据（`SummaryCalculator`，`SummaryStatistics`）
- en: Coordinating the different concerns (`ExpensesApplication`)
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调不同的关注点（`ExpensesApplication`）
- en: 'Here, we’ll take a fine-grained approach for pedagogic reasons. You can group
    each concern into a separate module, as follows (and we discuss the module-naming
    scheme in more detail later):'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，出于教学目的，我们将采取细粒度方法。您可以将每个关注点分组到一个单独的模块中，如下所示（我们将在稍后更详细地讨论模块命名方案）：
- en: expenses.readers
  id: totrans-820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: expenses.readers
- en: expenses.readers.http
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: expenses.readers.http
- en: expenses.readers.file
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: expenses.readers.file
- en: expenses.parsers
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: expenses.parsers
- en: expenses.parsers.json
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: expenses.parsers.json
- en: expenses.model
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: expenses.model
- en: expenses.statistics
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: expenses.statistics
- en: expenses.application
  id: totrans-827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: expenses.application
- en: For this simple application, you adopt a fine-grained decomposition to exemplify
    the different parts of the module system. In practice, taking such a fine-grained
    approach for a simple project would result in a high up-front cost for the arguably
    limited benefit of properly encapsulating small parts of the project. As the project
    grows and more internal implementations are added, however, the encapsulation
    and reasoning benefits become more apparent. You could imagine the preceding list
    as being a list of packages, depending on your application boundaries. A module
    groups a series of packages. Perhaps each module has implementation-specific packages
    that you don’t want to expose to other modules. The `expenses.statistics` module,
    for example, may contain several packages for different implementations of experimental
    statistical methods. Later, you can decide which of these packages to release
    to users.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的应用程序，您采用细粒度分解来展示模块系统的不同部分。在实践中，对于一个简单的项目来说，采取这样的细粒度方法可能会带来高昂的前期成本，而收益可能有限，即正确封装项目的小部分。然而，随着项目的增长和更多内部实现的添加，封装和推理的好处变得更加明显。您可以想象前面的列表作为一个包列表，这取决于您的应用程序边界。一个模块将一系列包分组在一起。也许每个模块都有特定实现的包，您不希望将其暴露给其他模块。例如，`expenses.statistics`模块可能包含用于不同实验统计方法实现的几个包。稍后，您可以决定将这些包中的哪些发布给用户。
- en: 14.4.2\. Fine-grained and coarse-grained modularization
  id: totrans-829
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.4.2\. 精细和粗粒度模块化
- en: When you’re modularizing a system, you can choose the granularity. In the most
    fine-grained scheme, every package has its own module (as in the previous section);
    in the most coarse-grained scheme, a single module contains all the packages in
    your system. As noted in the previous section, the first schema increases the
    design cost for limited gains, and the second one loses all benefits of modularization.
    The best choice is a pragmatic decomposition of the system into modules along
    with a regular review process to ensure that an evolving software project remains
    sufficiently modularized that you can continue to reason about it and modify it.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对系统进行模块化时，可以选择粒度。在最精细的方案中，每个包都有自己的模块（如前一章所述）；在最粗粒度的方案中，单个模块包含系统中的所有包。如前所述，第一个方案增加了设计成本，但收益有限，第二个方案则失去了模块化的所有好处。最佳选择是将系统分解成模块，并辅以定期的审查过程，以确保不断发展的软件项目保持足够的模块化，这样您可以继续对其进行分析和修改。
- en: In short, modularization is the enemy of software rust.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，模块化是软件生锈的敌人。
- en: 14.4.3\. Java Module System basics
  id: totrans-832
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.4.3\. Java 模块系统基础
- en: 'Let’s begin with a basic modular application, which has only one module to
    support the main application. The project directory structure is as follows, with
    each level nested in a directory:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本的模块化应用程序开始，它只有一个模块来支持主应用程序。项目目录结构如下，每个级别嵌套在一个目录中：
- en: '[PRE103]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'You’ve noticed this mysterious `module-info.java` that was part of the project
    structure. This file is a module descriptor, as we explained earlier in the chapter,
    and it must be located at the root of the module’s source-code file hierarchy
    to let you specify the dependencies of your module and what you want to expose.
    For your expenses application, the top-level `module-info.java` file contains
    a module description that has a name but is otherwise empty because it neither
    depends on any other module nor exposes its functionality to other modules. You’ll
    learn about more-sophisticated features later, starting with [section 14.5](#ch14lev1sec5).
    The content of `module-info.java` is as follows:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经注意到了这个神秘的 `module-info.java` 文件，它是项目结构的一部分。此文件是一个模块描述符，正如我们在本章前面所解释的，它必须位于模块源代码文件层次结构的根目录，以便您可以指定模块的依赖关系以及您想要公开的内容。对于您的支出应用程序，顶层的
    `module-info.java` 文件包含一个模块描述，它有一个名称，但除此之外是空的，因为它既不依赖于任何其他模块，也不将其功能公开给其他模块。您将在稍后学习更复杂的特性，从第
    14.5 节开始。`module-info.java` 的内容如下：
- en: '[PRE104]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'How do you run a modular application? Take a look at some commands to understand
    the low-level parts. This code is automated by your IDE and build system but seeing
    what’s happening is useful. When you’re in the module source directory of your
    project, run the following commands:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 如何运行一个模块化应用程序？查看一些命令来了解底层部分。此代码由您的 IDE 和构建系统自动化，但了解正在发生的事情是有用的。当您处于项目模块源代码目录中时，请运行以下命令：
- en: '[PRE105]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'These commands produce output similar to the following, which shows which folders
    and class files are incorporated into the generated JAR (`expenses-application.jar`):'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令生成的输出类似于以下内容，显示了哪些文件夹和类文件被纳入生成的 JAR (`expenses-application.jar`)：
- en: '[PRE106]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Finally, you run the generated JAR as a modular application:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您以模块化应用程序的形式运行生成的 JAR：
- en: '[PRE107]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: You should be familiar with the first two steps, which represent a standard
    way to package a Java application into a JAR. The only new part is that the file
    `module-info.java` becomes part of the compilation step.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该熟悉前两个步骤，它们代表将 Java 应用程序打包成 JAR 的标准方式。唯一的新部分是文件 `module-info.java` 成为编译步骤的一部分。
- en: 'The `java` program, which runs Java `.class` files, has two new options:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Java `.class` 文件的 `java` 程序有两个新选项：
- en: '`--module-path`—This option specifies what modules are available to load. This
    option differs from the `--classpath` argument, which makes class files available.'
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--module-path`—此选项指定可加载的模块。此选项与 `--classpath` 参数不同，后者使类文件可用。'
- en: '`--module`—This option specifies the main module and class to run.'
  id: totrans-846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--module`—此选项指定要运行的主模块和类。'
- en: A module’s declaration doesn’t include a version string. Addressing the version-selection
    problem wasn’t a specific design point for the Java 9 Module System, so versioning
    isn’t supported. The justification was that this problem is one for build tools
    and container applications to address.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的声明不包含版本字符串。解决版本选择问题并不是 Java 9 模块系统的特定设计点，因此不支持版本控制。理由是这个问题是构建工具和容器应用程序需要解决的问题。
- en: 14.5\. Working with several modules
  id: totrans-848
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5\. 与多个模块一起工作
- en: Now that you know how to set up a basic application with one module, you’re
    ready to do something a bit more realistic with multiple modules. You want your
    expense application to read expenses from a source. To this end, introduce a new
    module `expenses.readers` that encapsulates these responsibilities. The interaction
    between the two modules `expenses.application` and `expenses.readers` is specified
    by the Java 9 `exports` and `requires` clauses.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何使用一个模块设置基本的应用程序，你就可以使用多个模块做一些更实际的事情了。你希望你的支出应用程序能够从一个源读取支出。为此，引入一个新的模块
    `expenses.readers`，它封装了这些职责。两个模块 `expenses.application` 和 `expenses.readers` 之间的交互由
    Java 9 的 `exports` 和 `requires` 子句指定。
- en: 14.5.1\. The exports clause
  id: totrans-850
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.5.1\. `exports` 子句
- en: Here’s how we might declare the module `expenses.readers`. (Don’t worry about
    the syntax and concepts yet; we cover these topics later.)
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何声明模块 `expenses.readers` 的示例。（现在不用担心语法和概念；我们将在稍后介绍这些主题。）
- en: '[PRE108]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '***1* These are package names, not module names.**'
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这些是包名称，而不是模块名称。**'
- en: 'There’s one new thing: the `exports` clause, which makes the public types in
    specific packages available for use by other modules. By default, everything is
    encapsulated within a module. The module system takes a whitelist approach that
    helps you get strong encapsulation, as you need to explicitly decide what to make
    available for another module to use. (This approach prevents you from accidentally
    exporting some internal features that a hacker can exploit to compromise your
    systems several years later.)'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个新特性：`exports` 子句，它使得特定包中的公共类型可供其他模块使用。默认情况下，所有内容都被封装在一个模块中。模块系统采用白名单方法，这有助于你获得强大的封装，因为你需要明确决定什么可以供其他模块使用。（这种方法可以防止你意外地导出一些内部特性，黑客可以利用这些特性在几年后破坏你的系统。）
- en: 'The directory structure of the two-module version of your project now looks
    like this:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目两个模块版本的目录结构现在看起来是这样的：
- en: '[PRE109]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 14.5.2\. The requires clause
  id: totrans-857
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.5.2\. `requires` 子句
- en: 'Alternatively, you could have written `module-info.java` as follows:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以这样编写 `module-info.java`：
- en: '[PRE110]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '***1* This is a module name, not a package name.**'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这是一个模块名称，而不是包名称。**'
- en: '***2* This is a package name, not a module name.**'
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这是一个包名称，而不是模块名称。**'
- en: The new element is the `requires` clause, which lets you specify what the module
    depends on. By default, all modules depend on a platform module called `java.base`
    that includes the Java main packages such as `net`, `io`, and `util`. This module
    is always required by default, so you don’t need to say so explicitly. (This is
    similar to how saying `"class Foo { ... }"` in Java is equivalent to saying `"class
    Foo extends Object { ... }"`).
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 新的元素是 `requires` 子句，它允许你指定模块所依赖的内容。默认情况下，所有模块都依赖于一个名为 `java.base` 的平台模块，该模块包括
    `net`、`io` 和 `util` 等Java主包。这个模块默认总是需要的，所以你不需要明确地说明。（这类似于在 Java 中说 `"class Foo
    { ... }"` 等同于说 `"class Foo extends Object { ... }"`。）
- en: It becomes useful when you need to import modules other than `java.base`.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要导入除 `java.base` 之外的其他模块时，这变得很有用。
- en: The combination of the `requires` and `exports` clauses makes access control
    of classes more sophisticated in Java 9\. [Table 14.2](#ch14table02) summarizes
    the differences in visibility with the different access modifiers before and after
    Java 9.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '`requires` 和 `exports` 子句的组合使得 Java 9 中类的访问控制更加复杂。[表 14.2](#ch14table02) 总结了在
    Java 9 之前和之后不同访问修饰符下的可见性差异。'
- en: Table 14.2\. Java 9 provides finer control over class visibility
  id: totrans-865
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 14.2\. Java 9 提供了对类可见性的更精细控制
- en: '| Class visibility | Before Java 9 | After Java 9 |'
  id: totrans-866
  prefs: []
  type: TYPE_TB
  zh: '| 类可见性 | 在 Java 9 之前 | 在 Java 9 之后 |'
- en: '| --- | --- | --- |'
  id: totrans-867
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| All classes public to everyone | ![](Images/in01.jpg) | ![](Images/in01.jpg)
    (combination of exports and requires clauses) |'
  id: totrans-868
  prefs: []
  type: TYPE_TB
  zh: '| 对所有人公开的所有类 | ![](Images/in01.jpg) | ![](Images/in01.jpg)（`exports` 和 `requires`
    子句的组合）|'
- en: '| Limited number of classes public | ![](Images/in02.jpg) | ![](Images/in03.jpg)
    (combination of exports and requires clauses) |'
  id: totrans-869
  prefs: []
  type: TYPE_TB
  zh: '| 公共类数量有限 | ![](Images/in02.jpg) | ![](Images/in03.jpg)（`exports` 和 `requires`
    子句的组合）|'
- en: '| Public inside one module only | ![](Images/in02.jpg) | ![](Images/in04.jpg)
    (no exports clause) |'
  id: totrans-870
  prefs: []
  type: TYPE_TB
  zh: '| 仅在单个模块内部公开 | ![](Images/in02.jpg) | ![](Images/in04.jpg) (没有导出条款) |'
- en: '| Protected | ![](Images/in03.jpg) | ![](Images/in03.jpg) |'
  id: totrans-871
  prefs: []
  type: TYPE_TB
  zh: '| 受保护的 | ![](Images/in03.jpg) | ![](Images/in03.jpg) |'
- en: '| Package | ![](Images/in03.jpg) | ![](Images/in03.jpg) |'
  id: totrans-872
  prefs: []
  type: TYPE_TB
  zh: '| 包 | ![](Images/in03.jpg) | ![](Images/in03.jpg) |'
- en: '| Private | ![](Images/in03.jpg) | ![](Images/in03.jpg) |'
  id: totrans-873
  prefs: []
  type: TYPE_TB
  zh: '| 私有 | ![](Images/in03.jpg) | ![](Images/in03.jpg) |'
- en: 14.5.3\. Naming
  id: totrans-874
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.5.3\. 命名
- en: At this stage, it’s useful to comment on the naming convention for modules.
    We went for a short approach (for example, `expenses.application`) so as not to
    confuse the ideas of modules and packages. (A module can export multiple packages.)
    The recommended convention is different, however.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，对模块的命名约定进行评论是有用的。我们采用了简短的方法（例如，`expenses.application`），以免混淆模块和包的概念。（一个模块可以导出多个包。）然而，推荐的约定是不同的。
- en: Oracle recommends you name modules following the same reverse internet domain-name
    convention (for example, com.iteratrlearning.training) used for packages. Further,
    a module’s name should correspond to its principal exported API package, which
    should also follow that convention. If a module doesn’t have that package, or
    if for other reasons it requires a name that doesn’t correspond to one of its
    exported packages, it should start with the reversed form of an internet domain
    associated with its author.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle建议你按照与用于包的相同反向互联网域名约定（例如，com.iteratrlearning.training）来命名模块。此外，模块的名称应与其主要导出API包相对应，该包也应遵循该约定。如果一个模块没有该包，或者由于其他原因需要与它的导出包之一不对应的名称，它应该以与其作者相关的互联网域名的反向形式开头。
- en: Now that you’ve learned how to set up a project with multiple modules, how do
    you package and run it? We cover this topic in the next section.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何设置一个包含多个模块的项目，那么如何打包和运行它呢？我们将在下一节中介绍这个主题。
- en: 14.6\. Compiling and packaging
  id: totrans-878
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.6\. 编译和打包
- en: Now that you’re comfortable with setting a project and declaring a module, you’re
    ready to see how you can use build tools like Maven to compile your project. This
    section assumes that you’re familiar with Maven, which is one of the most common
    build tools in the Java ecosystem. Another popular building tool is Gradle, which
    we encourage you to explore if you haven’t heard of it.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了设置项目和声明模块，你就可以看到如何使用像Maven这样的构建工具来编译你的项目了。本节假设你熟悉Maven，它是Java生态系统中最常见的构建工具之一。另一个流行的构建工具是Gradle，如果你还没有听说过它，我们鼓励你探索一下。
- en: 'First, you need to introduce a `pom.xml` file for each module. In fact, each
    module can be compiled independently so that it behaves as a project on its own.
    You also need to add a `pom.xml` for the parent of all the modules to coordinate
    the build for the whole project. The overall structure now looks as follows:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要为每个模块引入一个`pom.xml`文件。实际上，每个模块都可以独立编译，使其表现得像一个独立的项目。你还需要为所有模块的父项目添加一个`pom.xml`，以协调整个项目的构建。现在的整体结构如下所示：
- en: '[PRE111]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Notice the three new `pom.xml` files and the Maven directory project structure.
    The module descriptor (`module-info.java`) needs to be located in the `src/main/java`
    directory. Maven will set up `javac` to use the appropriate module source path.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到三个新的`pom.xml`文件和Maven目录项目结构。模块描述符（`module-info.java`）需要位于`src/main/java`目录中。Maven将设置`javac`以使用适当的模块源路径。
- en: 'The `pom.xml` for the `expenses.readers` project looks like this:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '`expenses.readers`项目的`pom.xml`文件如下所示：'
- en: '[PRE112]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The important thing to note is that this code explicitly mentions the parent
    module to help in the build process. The parent is the artifact with the ID `expenses`.
    You need to define the parent in `pom.xml`, as you see shortly.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项是，此代码明确提到了父模块以帮助构建过程。父模块是ID为`expenses`的工件。你需要在`pom.xml`中定义父模块，正如你很快就会看到的。
- en: 'Next, you need to specify the `pom.xml` for the `expenses.application` module.
    This file is similar to the preceding one, but you have to add a dependency to
    the `expenses.readers` project, because `ExpensesApplication` requires the classes
    and interfaces that it contains to compile:'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要指定`expenses.application`模块的`pom.xml`。这个文件与前面的类似，但你必须添加对`expenses.readers`项目的依赖，因为`ExpensesApplication`需要它包含的类和接口来编译：
- en: '[PRE113]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Now that two modules, `expenses.application` and `expenses.readers`, have their
    own `pom.xml`, you can set up the global `pom.xml` to guide the build process.
    Maven supports projects that have multiple Maven modules with the special XML
    element `<module>`, which refers to the children’s artifact IDs. Here’s the complete
    definition, which refers to the two child modules `expenses.application` and `expenses.readers`:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有两个模块，`expenses.application` 和 `expenses.readers`，它们都有自己的 `pom.xml`，你可以设置全局的
    `pom.xml` 来指导构建过程。Maven 支持具有多个 Maven 模块的工程，使用特殊的 XML 元素 `<module>`，它引用子项目的 artifact
    IDs。以下是完整的定义，它引用了两个子模块 `expenses.application` 和 `expenses.readers`：
- en: '[PRE114]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Congratulations! Now you can run the command `mvn clean package` to generate
    the JARs for the modules in your project. This command generates
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在你可以运行命令 `mvn clean package` 来生成项目中模块的 JAR 文件。此命令生成
- en: '[PRE115]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'You can run your module application by including these two JARs on the module
    path as follows:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式在模块路径上包含这两个 JAR 来运行你的模块应用程序：
- en: '[PRE116]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: So far, you’ve learned about modules you created, and you’ve seen how to use
    `requires` to reference `java.base`. Real-world software, however, depends on
    external modules and libraries. How does that process work, and what if legacy
    libraries haven’t been updated with an explicit `module-info.java`? In the next
    section, we answer these questions by introducing automatic modules.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了关于你创建的模块，你也看到了如何使用 `requires` 来引用 `java.base`。然而，现实世界的软件依赖于外部模块和库。这个过程是如何工作的，如果遗留库没有使用显式的
    `module-info.java` 进行更新怎么办？在下一节中，我们将通过介绍自动模块来回答这些问题。
- en: 14.7\. Automatic modules
  id: totrans-895
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.7\. 自动模块
- en: 'You may decide that the implementation of your `HttpReader` is low-level; instead,
    you’d like to use a specialized library such as the `httpclient` from the Apache
    project. How do you incorporate that library into your project? You’ve learned
    about the `requires` clause, so try to add it in the `module-info.java` for the
    `expenses.readers` project. Run `mvn clean package` again to see what happens.
    Unfortunately, the result is bad news:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为你的 `HttpReader` 的实现是低级的；相反，你可能想使用来自 Apache 项目的专用库，比如 `httpclient`。你如何将这个库集成到你的项目中？你已经学习了
    `requires` 子句，所以尝试在 `expenses.readers` 项目的 `module-info.java` 中添加它。再次运行 `mvn clean
    package` 来查看结果。不幸的是，结果是坏消息：
- en: '[PRE117]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'You get this error because you also need to update your `pom.xml` to state
    the dependency. The maven compiler plugin puts all dependencies on the module
    path when you’re building a project that has a `module-info.java` so that the
    appropriate JARs are downloaded and recognized in your project, as follows:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到这个错误是因为你还需要更新你的 `pom.xml` 来声明依赖。当你构建具有 `module-info.java` 的项目时，maven 编译器插件会将所有依赖项放在模块路径上，以便在项目中下载和识别适当的
    JAR，如下所示：
- en: '[PRE118]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Now running `mvn clean package` builds the project correctly. Notice something
    interesting, though: the library `httpclient` isn’t a Java module. It’s an external
    library that you want to use as a module, but it hasn’t yet been modularized.
    Java turns the appropriate JAR into a so-called automatic module. Any JAR on the
    module path without a `module-info` file becomes an automatic module. Automatic
    modules implicitly export all their packages. A name for this automatic module
    is invented automatically, derived from the JAR name. You have a few ways to derive
    the name, but the easiest way is to use the `jar` tool with the `--describe-module`
    argument:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 `mvn clean package` 可以正确构建项目。不过，要注意一个有趣的现象：库 `httpclient` 不是一个 Java 模块。它是一个你希望作为模块使用的外部库，但它还没有被模块化。Java
    将适当的 JAR 转换为所谓的自动模块。模块路径上的任何没有 `module-info` 文件的 JAR 都成为自动模块。这个自动模块隐式导出所有其包。这个自动模块的名称是自动生成的，从
    JAR 名称派生而来。你有几种方法可以派生名称，但最简单的方法是使用带有 `--describe-module` 参数的 `jar` 工具：
- en: '[PRE119]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: In this case, the name is `httpclient`.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，名称是 `httpclient`。
- en: 'The final step is running the application and adding the `httpclient` JAR to
    the module path:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是运行应用程序并将 `httpclient` JAR 添加到模块路径中：
- en: '[PRE120]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '|  |'
  id: totrans-905
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-906
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: There’s a project ([https://github.com/moditect/moditect](https://github.com/moditect/moditect))
    to provide better support for the Java 9 Module System within Maven, such as to
    generate `module-info` files automatically.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个项目([https://github.com/moditect/moditect](https://github.com/moditect/moditect))旨在为
    Maven 中的 Java 9 模块系统提供更好的支持，例如自动生成 `module-info` 文件。
- en: '|  |'
  id: totrans-908
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 14.8\. Module declaration and clauses
  id: totrans-909
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.8\. 模块声明和子句
- en: The Java Module System is a large beast. As we mentioned earlier, we recommend
    that you read a dedicated book on the topic if you’d like to go further. Nonetheless,
    this section gives you a brief overview of other keywords available in the module
    declaration language to give you an idea of what’s possible.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: Java模块系统是一个庞大的系统。正如我们之前提到的，如果你想要深入了解这个主题，我们建议你阅读一本关于该主题的专著。尽管如此，本节为你提供了一个关于模块声明语言中可用其他关键字的大致概述，以帮助你了解可能实现的功能。
- en: 'As you learned in the earlier sections, you declare a module by using the `module`
    directive. Here, it has the name `com.iteratrlearning.application`:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在前面的章节中学到的，你通过使用`module`指令来声明一个模块。在这里，它的名字是`com.iteratrlearning.application`：
- en: '[PRE121]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: What can go inside the module declaration? You’ve learned about the `requires`
    and `exports` clauses, but there are other clauses, including `requires-transitive`,
    `exports-to`, `open`, `opens`, `uses`, and `provides`. We look at these clauses
    in turn in the following sections.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 模块声明中可以包含什么内容？你已经了解了`requires`和`exports`子句，但还有其他子句，包括`requires-transitive`、`exports-to`、`open`、`opens`、`uses`和`provides`。我们将在以下章节逐一介绍这些子句。
- en: 14.8.1\. requires
  id: totrans-914
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.8.1\. requires
- en: The `requires` clause lets you specify that your module depends on another module
    at both compile time and runtime. The module `com.iteratrlearning.application`,
    for example, depends on the module `com.iteratrlearning.ui:`
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '`requires`子句允许你在编译时和运行时指定你的模块依赖于另一个模块。例如，模块`com.iteratrlearning.application`依赖于模块`com.iteratrlearning.ui:`。'
- en: '[PRE122]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The result is that only public types that were exported by `com.iteratrlearning.ui`
    are available for `com.iteratrlearning.application` to use.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，只有由`com.iteratrlearning.ui`导出的公共类型才对`com.iteratrlearning.application`可用。
- en: 14.8.2\. exports
  id: totrans-918
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.8.2\. exports
- en: The `exports` clause makes the public types in specific packages available for
    use by other modules. By default, no package is exported. You gain strong encapsulation
    by making explicit what packages should be exported. In the following example,
    the packages `com.iteratrlearning.ui.panels` and `com.iteratrlearning.ui.widgets`
    are exported. (Note that `exports` takes a *package name* as an argument and that
    `requires` takes a *module name*, despite the similar naming schemes.)
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: '`exports`子句使特定包中的公共类型可供其他模块使用。默认情况下，没有包被导出。通过明确指定应该导出哪些包，你可以获得强大的封装性。在以下示例中，导出了包`com.iteratrlearning.ui.panels`和`com.iteratrlearning.ui.widgets`。（注意，`exports`接受一个*包名*作为参数，而`requires`接受一个*模块名*，尽管它们有相似的命名方案。）'
- en: '[PRE123]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 14.8.3\. requires transitive
  id: totrans-921
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.8.3\. requires transitive
- en: 'You can specify that a module can use the public types required by another
    module. You can modify the `requires` clause, for example, to `requires`-`transitive`
    inside the declaration of the module `com.iteratrlearning.ui`:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定一个模块可以使用另一个模块所需的公共类型。例如，你可以在模块`com.iteratrlearning.ui`的声明中修改`requires`子句，将其设置为`requires`-`transitive`：
- en: '[PRE124]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The result is that the module `com.iteratrlearning.application` has access to
    the public types exported by `com.iteratrlearning.core.` Transitivity is useful
    when the module required (here, `com.iteratrlearning.ui`) returns types from another
    module required by this module (`com.iteratrlearning.core`). It would be annoying
    to re-declare `requires com.iteratrlearning.core` inside the module `com.iteratrlearning.application`.
    This problem is solved by `transitive`. Now any module that depends on `com.iteratrlearning.ui`
    automatically reads the `com.iteratrlearning.core` module.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，模块`com.iteratrlearning.application`可以访问由`com.iteratrlearning.core.`导出的公共类型。当所需的模块（这里为`com.iteratrlearning.ui`）返回由该模块（`com.iteratrlearning.core`）所需的另一个模块的类型时，传递性是有用的。在模块`com.iteratrlearning.application`内部重新声明`requires
    com.iteratrlearning.core`会非常麻烦。这个问题通过`transitive`得到了解决。现在，任何依赖于`com.iteratrlearning.ui`的模块都会自动读取`com.iteratrlearning.core`模块。
- en: 14.8.4\. exports to
  id: totrans-925
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.8.4\. exports to
- en: 'You have a further level of visibility control, in that you can restrict the
    allowed users of a particular export by using the `exports to` construct. As you
    saw in [section 14.8.2](#ch14lev2sec14), you can restrict the allowed users of
    `com.iteratrlearning.ui.widgets` to `com .iteratrlearning.ui.widgetuser` by adjusting
    the module declaration like so:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 你有进一步的可见性控制级别，可以通过使用`exports to`结构来限制特定导出的允许用户。正如你在[第14.8.2节](#ch14lev2sec14)中看到的，你可以通过调整模块声明来限制`com.iteratrlearning.ui.widgets`的允许用户为`com
    .iteratrlearning.ui.widgetuser`：
- en: '[PRE125]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 14.8.5\. open and opens
  id: totrans-928
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.8.5\. open 和 opens
- en: 'Using the `open` qualifier on module declaration gives other modules reflective
    access to all its packages. The `open` qualifier has no effect on module visibility
    except for allowing reflective access, as in this example:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块声明中使用 `open` 限定符，允许其他模块以反射方式访问其所有包。`open` 限定符除了允许反射访问之外，对模块可见性没有影响，正如以下示例所示：
- en: '[PRE126]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Before Java 9, you could inspect the private state of objects by using reflection.
    In other words, nothing was truly encapsulated. Object-relational mapping (ORM)
    tools such as Hibernate often use this capability to access and modify state directly.
    In Java 9, reflection is no longer allowed by default. The `open` clause in the
    preceding code serves to allow that behavior when it’s needed.
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 9 之前，你可以通过反射检查对象的私有状态。换句话说，没有什么真正是封装的。对象关系映射（ORM）工具，如 Hibernate，经常使用这种能力直接访问和修改状态。在
    Java 9 中，默认不再允许使用反射。前面代码中的 `open` 子句用于在需要时允许这种行为。
- en: Instead of opening a whole module to reflection, you can use an `opens` clause
    within a module declaration to open its packages individually, as required. You
    can also use the `to` qualifier in the `opens-to` variant to limit the modules
    allowed to perform reflective access, analogous to how `exports-to` limits the
    modules allowed to `require` an exported package.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以不打开整个模块以供反射，而可以在模块声明中使用 `opens` 子句单独打开其包，按需进行。你还可以在 `opens-to` 变体的 `to` 限定符中使用，以限制允许执行反射访问的模块，类似于
    `exports-to` 限制允许 `require` 导出包的模块。
- en: 14.8.6\. uses and provides
  id: totrans-933
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.8.6. 使用和提供
- en: If you’re familiar with services and `ServiceLoader`, the Java Module System
    allows you to specify a module as a service provider using the `provides` clause
    and a service consumer using the `uses` clause. This topic is advanced, however,
    and beyond the scope of this chapter. If you’re interested in combining modules
    and service loaders, we recommend that you read a comprehensive resource such
    as *The Java Module System*, by Nicolai Parlog (Manning Publications), mentioned
    earlier in this chapter.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉服务和 `ServiceLoader`，Java 模块系统允许你使用 `provides` 子句指定模块作为服务提供者，使用 `uses` 子句指定服务消费者。然而，这个主题是高级的，超出了本章的范围。如果你对结合模块和服务加载器感兴趣，我们建议你阅读前面章节中提到的由
    Nicolai Parlog（Manning Publications）所著的全面资源《Java 模块系统》。
- en: 14.9\. A bigger example and where to learn more
  id: totrans-935
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.9. 一个更大的示例以及如何了解更多
- en: 'You can get a flavor of the module system from the following example, taken
    from Oracle’s Java documentation. This example shows a module declaration using
    most of the features discussed in this chapter. The example isn’t meant to frighten
    you (the vast majority of module statements are simple exports and requires),
    but it gives you a look at some richer features:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从以下示例中感受到模块系统的风味，该示例取自 Oracle 的 Java 文档。此示例展示了使用本章讨论的大多数特性的模块声明。这个例子并不是为了吓唬你（绝大多数模块语句都是简单的导出和需求），但它让你看到了一些更丰富的特性：
- en: '[PRE127]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: This chapter discussed the need for the new Java Module System and provided
    a gentle introduction to its main features. We didn’t cover many features, including
    service loaders, additional module descriptor clauses, and tools for working with
    modules such as `jdeps` and `jlink`. If you’re a Java EE developer, it’s important
    to keep in mind when migrating your applications to Java 9 that several packages
    relevant to EE aren’t loaded by default in the modularized Java 9 Virtual Machine.
    The JAXB API classes, for example, are now considered to be Java EE APIs and are
    no longer available in the default class path in Java SE 9\. You need to explicitly
    add modules of interest by using the `--add-modules` command-line switch to keep
    compatibility. To add `java.xml.bind`, for example, you need to specify `--add-modules
    java.xml.bind`.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了引入新的 Java 模块系统的必要性，并对其主要特性进行了温和的介绍。我们没有涵盖许多特性，包括服务加载器、额外的模块描述符子句以及用于处理模块的工具，如
    `jdeps` 和 `jlink`。如果你是 Java EE 开发者，在将你的应用程序迁移到 Java 9 时，重要的是要记住，与 EE 相关的几个包在模块化的
    Java 9 虚拟机中默认不加载。例如，JAXB API 类现在被认为是 Java EE API，并且不再在 Java SE 9 的默认类路径中可用。你需要通过使用
    `--add-modules` 命令行开关显式添加感兴趣的模块以保持兼容性。例如，要添加 `java.xml.bind`，你需要指定 `--add-modules
    java.xml.bind`。
- en: As we noted earlier, doing the Java Module System justice would require a whole
    book, not a single chapter. To explore the details in greater depth, we suggest
    a book such as *The Java Module System*, by Nicolai Parlog (Manning Publications),
    mentioned earlier in this chapter.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，要公正地对待Java模块系统，需要一本书，而不仅仅是一章。为了更深入地探讨细节，我们建议阅读之前在本章中提到的Nicolai Parlog（Manning
    Publications）所著的《The Java Module System》一书。
- en: Summary
  id: totrans-940
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Separation of concerns and information hiding are two important principles to
    help construct software that you can reason about.
  id: totrans-941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点分离和信息隐藏是两个重要的原则，有助于构建你可以推理的软件。
- en: Before Java 9, you made code modular by introducing packages, classes, and interfaces
    that have a specific concern, but these elements weren’t rich enough for effective
    encapsulation.
  id: totrans-942
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java 9之前，你通过引入具有特定关注点的包、类和接口来使代码模块化，但这些元素对于有效的封装还不够丰富。
- en: The Class Path Hell problem makes it hard to reason about the dependencies of
    an application.
  id: totrans-943
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类路径地狱问题使得推理应用程序的依赖变得困难。
- en: Before Java 9, the JDK was monolithic, resulting in high maintenance costs and
    restricted evolution.
  id: totrans-944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java 9之前，JDK是单一的，这导致了高昂的维护成本和受限的进化。
- en: Java 9 introduced a new module system in which a `module-info.java` file names
    a module and specifies its dependencies (`requires`) and public API (`exports`).
  id: totrans-945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 9引入了一个新的模块系统，其中`module-info.java`文件命名了一个模块并指定了其依赖（`requires`）和公共API（`exports`）。
- en: The `requires` clause lets you specify dependencies on other modules.
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requires`子句允许你指定对其他模块的依赖。'
- en: The `exports` clause makes the public types of specific packages in a module
    available for use by other modules.
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exports`子句使得模块中特定包的公共类型对其他模块可用。'
- en: The prefered naming convention for a module follows the reverse internet domain-name
    convention.
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的推荐命名约定遵循反向互联网域名约定。
- en: Any JAR on the module path without a `module-info` file becomes an automatic
    module.
  id: totrans-949
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块路径上的任何没有`module-info`文件的JAR都成为自动模块。
- en: Automatic modules implicitly export all their packages.
  id: totrans-950
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动模块隐式导出它们所有的包。
- en: Maven supports applications structured with the Java 9 Module System.
  id: totrans-951
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven支持使用Java 9模块系统构建的应用程序。
