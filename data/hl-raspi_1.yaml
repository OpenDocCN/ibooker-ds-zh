- en: Part 2\. Playing with Python
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 2 部分\. 与 Python 玩耍
- en: 'Minecraft, Pac-Man, and Super Mario Brothers are great games, and they were
    all created by programmers like you. You’ll have to gain more skills to make games
    like those, but you can create some basic games pretty quickly. All these games
    have the game player interact with the computer. The computer is programmed with
    *logic*: instructions that control how the game reacts to the player’s choices.
    The game is constantly responding to input from the user, whether it is a button
    press or a key press.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Minecraft、Pac-Man 和超级马里奥兄弟都是优秀的游戏，它们都是由像您这样的程序员创造的。您将需要获得更多技能才能制作出那样的游戏，但您可以快速创建一些基本游戏。所有这些游戏都让游戏玩家与计算机互动。计算机被编程为具有
    *逻辑*：控制游戏如何对玩家的选择做出反应的指令。游戏不断响应用户的输入，无论是按钮点击还是按键。
- en: Games are a good way to learn programming because they combine creativity, fun,
    and logical thinking into one project. Games are also interactive, requiring the
    user to make choices and the computer to respond to those choices. The goal is
    to make the game entertaining, so you’ll use your creativity and imagination to
    add magic to your games. You decide how you want to program your game and how
    it responds!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏是学习编程的好方法，因为它们将创造力、乐趣和逻辑思维结合到一个项目中。游戏也是交互式的，需要用户做出选择，并使计算机对这些选择做出响应。目标是使游戏有趣，因此您将使用您的创造力和想象力为您的游戏增添魔力。您决定如何编程您的游戏以及它如何响应！
- en: 'In [part 2](#part02), you’ll build your own interactive games using Python
    and your Raspberry Pi. You’ll start in [chapter 3](kindle_split_012.html#ch03)
    by making a program that creates ridiculous sentences. You’ll learn to use Python
    to ask users to enter information, store the information in variables, and make
    your Pi respond. [Chapter 4](kindle_split_013.html#ch04) dives into how you can
    create a guessing game that makes your Pi more intelligent: it will make simple
    decisions based on the player’s choices. You’ll also see how to use Python to
    make your Raspberry Pi repeat some instructions over and over again. In [chapter
    5](kindle_split_014.html#ch05), you’ll don a helmet and headlamp and descend into
    an underground cave. You’ll create a text-based game where the player can choose
    where to go; based on their choices, they may find riches or face an untimely
    demise.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 部分](#part02) 中，您将使用 Python 和您的 Raspberry Pi 创建自己的交互式游戏。您将从 [第 3 章](kindle_split_012.html#ch03)
    开始，制作一个创建荒谬句子的程序。您将学习如何使用 Python 请求用户输入信息，将信息存储在变量中，并使您的 Pi 响应。[第 4 章](kindle_split_013.html#ch04)
    将深入探讨如何创建一个使您的 Pi 更智能的猜谜游戏：它将根据玩家的选择做出简单的决定。您还将了解如何使用 Python 使您的 Raspberry Pi
    反复执行某些指令。[第 5 章](kindle_split_014.html#ch05) 中，您将戴上头盔和头灯，进入地下洞穴。您将创建一个基于文本的游戏，玩家可以选择去哪里；根据他们的选择，他们可能会找到财富或面临不幸的死亡。
- en: 'Chapter 3\. Silly Sentence Generator 3000: creating interactive programs'
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 章\. 荒谬句子生成器 3000：创建交互式程序
- en: '**In this chapter, you’ll see how you can use Python to**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**在本章中，您将了解如何使用 Python** '
- en: '*Create a welcome message for a game*'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为游戏创建一个欢迎信息*'
- en: '*Add notes to your code*'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在您的代码中添加注释*'
- en: '*Ask users to input (or type in) information and save it using variables*'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*请求用户输入（或键入）信息并使用变量保存它*'
- en: '*Join strings*'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*连接字符串*'
- en: '*Display information back to the user based on that information*'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*根据该信息将信息显示回用户*'
- en: Visit a website, start up a game system, or open a mobile application, and it
    will probably ask you to enter a name and email address and create a password.
    These are all computer programs, and once you’re logged in, they may display special
    messages at the top of the screen saying things like “Welcome, Aaron” (or whatever
    your name is). Some programs are very sophisticated, remembering the games you’ve
    played, the badges you’ve earned, the balance in your account, or the products
    you’ve viewed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 访问一个网站、启动游戏系统或打开移动应用程序，它可能会要求您输入姓名和电子邮件地址并创建密码。这些都是计算机程序，一旦您登录，它们可能会在屏幕顶部显示特殊消息，例如“欢迎，Aaron”（或您的名字）。一些程序非常复杂，会记住您玩过的游戏、获得的徽章、账户余额或查看过的产品。
- en: iTunes, Netflix, Facebook, and Gmail are all sites that use computer programs
    that ask you for information, save information, and interact with you based on
    that information. In this chapter, you’ll see how to do this with Python by creating
    a ridiculously fun word game called Silly Sentence Generator 3000.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: iTunes、Netflix、Facebook 和 Gmail 都是使用计算机程序来询问您信息、保存信息并根据这些信息与您互动的网站。在本章中，您将了解如何使用
    Python 创建一个荒谬有趣的单词游戏，名为 Silly Sentence Generator 3000。
- en: Creating a welcome message
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建欢迎信息
- en: In Silly Sentence Generator 3000, the game player (that’ll be you) is asked
    to enter words such as nouns, verbs, adjectives, and so on. You’ll store the words
    as variables and then use them to create ridiculous, nonsensical sentences.^([[1](#ch03fn01)])
    [Figure 3.1](#ch03fig01) shows an example of what the finished program looks like.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Silly Sentence Generator 3000 中，游戏玩家（也就是你）被要求输入诸如名词、动词、形容词等单词。你将把这些单词存储为变量，然后使用它们来创建荒谬、不合逻辑的句子。[图
    3.1](#ch03fig01) 展示了完成程序的一个示例。
- en: ¹
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is similar to the game Mad Libs, if you’ve ever played it.
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你曾经玩过疯狂填词游戏，这很相似。
- en: Figure 3.1\. Silly Sentence Generator 3000 asks the user to enter their name
    and some words, and then it creates a silly sentence from those words.
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.1\. Silly Sentence Generator 3000 要求用户输入他们的名字和一些单词，然后从这些单词中创建一个荒谬的句子。
- en: '![](03fig01_alt.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![03fig01_alt.jpg]'
- en: Think about the program like a machine that takes a set of inputs and then creates
    an output. You’re going to put together the machine by creating the instructions
    that drive it. Conceptually, this “machine” might look something like [figure
    3.2](#ch03fig02). Change the words you put in, and you’ll get a completely different
    result. That’s part of what makes games so much fun!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 把程序想象成一个接收一组输入并创建输出的机器。你将通过创建驱动它的指令来组装这个机器。从概念上讲，这个“机器”可能看起来像[图 3.2](#ch03fig02)。改变你输入的单词，你会得到一个完全不同的结果。这就是游戏如此有趣的一部分原因！
- en: Figure 3.2\. An interactive game lets you put in information, and then it creates
    an output.
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.2\. 一个交互式游戏让你输入信息，然后创建输出。
- en: '![](03fig02_alt.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![03fig02_alt.jpg]'
- en: Let’s see how to create this game. Once you create it, you can change it and
    add to it however you like.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建这个游戏。一旦创建，你可以随意修改和添加。
- en: Starting a new program
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 开始一个新的程序
- en: If you open a game, one of the first things you see is a main menu or title
    screen. Let’s use what you know about displaying text on the screen to make your
    program display a title for your game. You start by opening IDLE and creating
    a new program. Open IDLE for Python 3 by clicking the Menu button and selecting
    Programming > Python 3 on your Raspberry Pi’s desktop (see [figure 3.3](#ch03fig03)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开一个游戏，你看到的第一件事可能是一个主菜单或标题屏幕。让我们利用你关于在屏幕上显示文本的知识来让你的程序显示一个游戏标题。你首先打开 IDLE
    并创建一个新的程序。通过点击菜单按钮，在树莓派的桌面上选择编程 > Python 3 来打开 IDLE for Python 3（见[图 3.3](#ch03fig03)）。
- en: Figure 3.3\. Select Menu-->Programming-->Python 3 to open the Python Shell on
    your Raspberry Pi.
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.3\. 选择菜单 --> 编程 --> Python 3 以在树莓派上打开 Python Shell。
- en: '![](03fig03_alt.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![03fig03_alt.jpg]'
- en: Give your Raspberry Pi a few seconds to open IDLE. After IDLE opens, you’ll
    see the Python Shell (see [figure 3.4](#ch03fig04)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 给你的树莓派一点时间来打开 IDLE。IDLE 打开后，你会看到 Python Shell（见[图 3.4](#ch03fig04)）。
- en: Figure 3.4\. The Python Shell
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.4\. Python Shell
- en: '![](03fig04_alt.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![03fig04_alt.jpg]'
- en: Press Ctrl-N or choose File > New Window to open the IDLE text editor. You’ll
    see a blank window, ready for you to start typing in your program (see [figure
    3.5](#ch03fig05)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 Ctrl-N 或选择文件 > 新建窗口以打开 IDLE 文本编辑器。你会看到一个空白窗口，准备好让你开始输入你的程序（见[图 3.5](#ch03fig05)）。
- en: Figure 3.5\. The IDLE text editor is where you can type in your Python program.
    You can also edit, save, and run programs using the menu options.
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.5\. IDLE 文本编辑器是你可以输入你的 Python 程序的地方。你也可以使用菜单选项来编辑、保存和运行程序。
- en: '![](03fig05_alt.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![03fig05_alt.jpg]'
- en: 'Using the `print` function you learned about in [chapter 2](kindle_split_010.html#ch02),
    let’s make a title screen:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你在[第 2 章](kindle_split_010.html#ch02)中学到的 `print` 函数，让我们制作一个标题屏幕：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Excellent. Feel free to elaborate on the welcome message and the artwork with
    different characters. Before you go much further, you should save the program.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 极好。请随意详细说明欢迎信息和不同角色的艺术作品。在你继续之前，你应该保存程序。
- en: Saving the program
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 保存程序
- en: Save the program by selecting File > Save or pressing Ctrl-S. This will open
    a window asking where you want to save the program and what to name it. Let’s
    name it SillySentence (see [figure 3.6](#ch03fig06)). By default, IDLE saves your
    file to your /home/pi folder. Let’s use that folder.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择文件 > 保存或按 Ctrl-S 来保存程序。这将打开一个窗口询问你想要将程序保存到哪个位置以及如何命名它。让我们命名为 SillySentence（见[图
    3.6](#ch03fig06)）。默认情况下，IDLE 将你的文件保存到 /home/pi 文件夹。让我们使用那个文件夹。
- en: Figure 3.6\. Save your file as SillySentence. This stores the file on your Raspberry
    Pi in your /home/pi folder so you can run the program and make changes to it.
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.6\. 将您的文件保存为 SillySentence。这样会将文件存储在您的 Raspberry Pi 的 /home/pi 文件夹中，以便您运行程序并对其进行修改。
- en: '![](03fig06.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig06.jpg)'
- en: Click Save, and the file will be saved as SillySentence.py (the .py file extension
    is automatically appended by IDLE). After you save the file, the title at the
    top of the text editor window will show the filename and file location, as you
    can see in [figure 3.7](#ch03fig07).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 点击保存，文件将保存为 SillySentence.py（.py 文件扩展名由 IDLE 自动添加）。保存文件后，文本编辑器窗口顶部的标题将显示文件名和文件位置，如[图
    3.7](#ch03fig07)所示。
- en: Figure 3.7\. The first three lines of your program use the `print` function
    to create a welcome message for the Silly Sentence Generator 3000 program.
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.7\. 您的程序的前三行使用 `print` 函数创建 Silly Sentence Generator 3000 程序的欢迎信息。
- en: '![](03fig07_alt.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig07_alt.jpg)'
- en: Guess the output. What do you think you’ll get when you run the program?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 猜测输出。您认为运行程序时会得到什么？
- en: Let’s try it. Click Run > Run Module (or press the keyboard shortcut F5). Python
    will read each line of your program and execute the commands. The commands print
    a line of * characters, the welcome message, and another line of * characters
    to the screen (see [figure 3.8](#ch03fig08)).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试。点击运行 > 运行模块（或按键盘快捷键 F5）。Python 将读取您程序的每一行并执行命令。这些命令在屏幕上打印一行 * 字符，欢迎信息，以及另一行
    * 字符（见[图 3.8](#ch03fig08)）。
- en: Figure 3.8\. Running the program SillySentence.py displays a welcome message
    on the screen.
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.8\. 运行程序 SillySentence.py 在屏幕上显示一条欢迎信息。
- en: '![](03fig08_alt.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig08_alt.jpg)'
- en: Excellent! Now you have a proper welcome message for your game. The next thing
    you need to do is gather some input from your game player. Some games use button
    presses, but you’ll use the keyboard for this game.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在您为您的游戏有了合适的欢迎信息。接下来，您需要从游戏玩家那里收集一些输入。一些游戏使用按钮点击，但您将在这个游戏中使用键盘。
- en: '|  |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Running programs from the command line**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**从命令行运行程序**'
- en: 'Another way to run a program is from the Raspbian command line. You can access
    the command line using the Terminal application found under Menu-->Accessories.
    A window will open with this prompt:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序的另一种方式是从 Raspbian 命令行。您可以通过在菜单中找到的终端应用程序访问命令行，即菜单-->附件。一个窗口将打开，显示以下提示：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](072fig01_alt.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](072fig01_alt.jpg)'
- en: To run the Silly Sentence program at the command line, enter
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要在命令行中运行 Silly Sentence 程序，请输入
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The next figure shows this command and the result. Notice that you get the same
    output at the command line.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图显示了此命令及其结果。请注意，您在命令行中得到了相同的输出。
- en: '![](073fig01_alt.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](073fig01_alt.jpg)'
- en: The command line is another option for running Python programs. In [part 3](kindle_split_015.html#part03)
    of this book, you’ll see that some programs require you to run them from the command
    line because you must run them as the superuser on your Raspberry Pi.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行是运行 Python 程序的另一种选项。在这本书的[第 3 部分](kindle_split_015.html#part03)中，您将看到一些程序需要您从命令行运行它们，因为您必须在
    Raspberry Pi 上以超级用户身份运行它们。
- en: '|  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Adding notes in your code
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在您的代码中添加注释
- en: 'Imagine a comic book without words. You’d have a hard time understanding what
    was happening from just the pictures. Maybe you could figure it out if you studied
    the comic long enough, but words are important for understanding a story. Lines
    of code can be like a comic book without words: you know something is happening,
    but you might not be able to tell what without guessing.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一本没有文字的漫画书。仅从图片中，您可能很难理解正在发生的事情。也许如果您足够长时间地研究这本漫画，您可能能够弄清楚，但文字对于理解故事非常重要。代码行可能就像一本没有文字的漫画书：您知道正在发生某事，但您可能无法不猜测就能知道。
- en: That’s why programmers invented the idea of adding comments. *Comments* are
    notes in the code that explain what’s happening. They’re as much for you as for
    other people who may read your code. You can use comments to explain why you wrote
    the program and how parts of the program work.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，程序员发明了添加注释的想法。*注释* 是代码中的注释，用于解释正在发生的事情。它们既是为了您，也是为了可能阅读您代码的其他人。您可以使用注释来解释您为什么编写这个程序以及程序的部分是如何工作的。
- en: Using hashtags for comments
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用标签进行注释
- en: You add a comment by starting the line with a hashtag (`#`) and a space and
    then typing in your comment text. Let’s add comments to the beginning of Silly
    Sentence Generator 3000 to explain the program’s title, its purpose, and who wrote
    it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在行首添加一个标签（`#`）和一个空格，然后输入您的注释文本来添加注释。让我们在 Silly Sentence Generator 3000
    的开头添加注释，以解释程序标题、其目的以及谁编写了它。
- en: Listing 3.1\. Adding notes to your program
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.1\. 给您的程序添加注释
- en: '![](074fig01_alt.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](074fig01_alt.jpg)'
- en: Comments are helpful to the humans reading the code. But Python ignores comments
    when it runs your program. You can check this by saving your program and running
    it again; you’ll see that you get the same result as before.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注释对阅读代码的人类很有帮助。但 Python 在运行您的程序时会忽略注释。您可以通过保存您的程序并再次运行它来检查这一点；您会发现您得到的结果与之前相同。
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Easter egg: the Zen of Python**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**Easter egg：Python 的禅意**'
- en: Python has a hidden surprise regarding Python style. In computer programs, these
    surprises are sometimes called *Easter eggs*. You can find the egg by typing `import
    this` in the Python Shell and pressing Enter. A beautiful poem called “The Zen
    of Python” will appear on your screen.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在 Python 风格方面有一个隐藏的惊喜。在计算机程序中，这些惊喜有时被称为 *Easter eggs*。您可以通过在 Python Shell
    中输入 `import this` 并按 Enter 键来找到这个蛋。屏幕上会出现一首名为“Python 的禅意”的美丽诗歌。
- en: '![](074fig02_alt.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](074fig02_alt.jpg)'
- en: 'The poem emphasizes the philosophy of Python. Some of it talks about advanced
    topics, but many lines discuss a way of coding that is meant for anyone who uses
    Python. The seventh line captures a great idea in Python: “Readability counts.”
    It’s better to write programs using simple instructions that are easy to read
    than to try to mash together steps in complicated, long lines of code. Try taking
    some deep meditational Python breaths before getting back to your project.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 诗歌强调了 Python 的哲学。其中一些谈论了高级主题，但许多行讨论了适用于任何使用 Python 的人的编码方式。第七行捕捉了 Python 中的一个伟大想法：“可读性很重要。”使用简单、易于阅读的指令编写程序，比试图将步骤混合在复杂、长的代码行中要好。在回到您的项目之前，尝试做一些深度的冥想
    Python 呼吸。
- en: '|  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Python’s creator, Guido van Rossum, said that code is read more often than it’s
    written.^([[2](#ch03fn02)]) Readability is an extremely important part of programming
    and is a guiding principle in the style of Python programs. Comments are an important
    way to keep your code easy to read and understand.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的创造者 Guido van Rossum 表示，代码的阅读频率比写作频率更高。[^2](#ch03fn02) 可读性是编程中极其重要的部分，也是
    Python 程序风格的一个指导原则。注释是保持代码易于阅读和理解的重要方式。
- en: ²
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Check out the resource *PEP 8—the Style Guide for Python*, written by Python’s
    creators: [http://legacy.python.org/dev/peps/pep-0008](http://legacy.python.org/dev/peps/pep-0008).
    A wonderful section called “A Foolish Consistency Is the Hobgoblin of Little Minds”
    talks about the importance of readable code.'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看由 Python 创造者编写的资源 *PEP 8——Python 风格指南*：[http://legacy.python.org/dev/peps/pep-0008](http://legacy.python.org/dev/peps/pep-0008)。一个名为“愚蠢的一致性是小智者的妖怪”的精彩部分讨论了可读代码的重要性。
- en: Comments are your new friend, and they will make your code easy to read. You’ll
    keep using them to add notes to your code as you collect information from your
    game player (or user) and create a silly sentence.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是您的新朋友，它们会使您的代码易于阅读。您将在收集游戏玩家（或用户）的信息并创建一个愚蠢的句子时继续使用它们来为代码添加注释。
- en: Getting and storing information
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取和存储信息
- en: To gather input from users, you can use the `input` function. Let’s add a line
    of code in your program that will ask the user for their information and store
    that information in a variable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要从用户那里获取输入，您可以使用 `input` 函数。让我们在您的程序中添加一行代码，询问用户他们的信息并将该信息存储在变量中。
- en: Listing 3.2\. Gathering input from the player
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2\. 从玩家那里收集输入
- en: '![](075fig01_alt.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](075fig01_alt.jpg)'
- en: When you use the `input` function, it displays a prompt and awaits the user’s
    reply. After the user enters something and presses Enter, the information is stored
    in the variable on the left side of the equals sign.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 `input` 函数时，它会显示一个提示并等待用户的回复。用户输入一些内容并按 Enter 键后，信息将存储在等号左侧的变量中。
- en: In the IDLE editor, `input` shows up in purple highlighting, indicating that
    it’s the name of a function in Python. Let’s look closely at the `input` function
    to see how it works (see [figure 3.9](#ch03fig09)).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IDLE 编辑器中，`input` 以紫色高亮显示，表示它是 Python 中一个函数的名称。让我们仔细看看 `input` 函数，看看它是如何工作的（参见[图
    3.9](#ch03fig09)）。
- en: Figure 3.9\. The `input` function displays a prompt to the user. The prompt
    “Please enter your name:” tells the user what you want them to type in or enter.
    In this case, you’re asking for their name.
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.9\. `input` 函数向用户显示提示信息。提示信息“请输入您的名字:”告诉用户您希望他们输入或输入的内容。在这种情况下，您是在询问他们的名字。
- en: '![](03fig09.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig09.jpg)'
- en: On the right side of the equals sign, the `input` function is called, and you
    open a set of parentheses. You can give the `input` function a string that acts
    as the prompt. This is the message that is displayed on the screen and that says
    to the user, “Hey you, please type something in”—only more nicely! Make sure your
    string starts and ends with quotation marks (`""`).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在等号右边，调用`input`函数，并打开一组括号。你可以给`input`函数一个字符串作为提示。这是显示在屏幕上的消息，告诉用户“嘿，请输入一些内容”——但更加礼貌！确保你的字符串以引号（`""`）开头和结尾。
- en: 'Run the program by pressing F5 or selecting Run > Run Module. The program displays
    the welcome message and then an input prompt with a blinking cursor. Python is
    waiting for your input: it needs you to type something in and press Enter.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按F5或选择运行 > 运行模块来运行程序。程序显示欢迎消息，然后显示带有闪烁光标的输入提示。Python正在等待你的输入：它需要你输入一些内容并按Enter键。
- en: On the left side of the equals sign is the name of a variable in which the information
    will be stored. When you type something in and press Enter, the value of what
    you typed is stored in the variable `player_name` as a string.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在等号左边是存储信息的变量的名字。当你输入一些内容并按Enter键时，你输入的值的值将作为字符串存储在变量`player_name`中。
- en: '|  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Python 2.X
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Python 2.X
- en: The `input` function was previously `raw_input` in Python 2.X.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`input`函数在Python 2.X中是`raw_input`。'
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Joining strings
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接字符串
- en: As in other apps and websites, you want the user to feel welcome, so let’s use
    their name and give them a proper greeting. A nice message to display on the screen
    might be
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他应用程序和网站一样，你希望用户感到受欢迎，所以让我们使用他们的名字并给予他们适当的问候。屏幕上显示的友好消息可能是
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To create a personal feel, you’ll create just such a message that joins the
    user’s name with some words welcoming them. You use the plus (`+`) symbol to join
    strings:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了营造个人化的感觉，你需要创建一条将用户的名字与一些欢迎词结合在一起的消息。你使用加号（`+`）符号来连接字符串：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If `player_name` equals “Melissa”, the message is equal to
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`player_name`等于“Melissa”，则消息等于
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Add this to your program, and display the message to the screen using `print`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将此添加到你的程序中，并使用`print`将消息显示在屏幕上。
- en: Listing 3.3\. Using `+` to join strings
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.3\. 使用`+`连接字符串
- en: '![](077fig01_alt.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](077fig01_alt.jpg)'
- en: The program has the user input their name, which is stored in the variable p`layer_name`.
    On the next line, a message is made by joining strings. The message is displayed
    on the screen to create a personalized start for the game.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 程序让用户输入他们的名字，这个名字存储在变量p`layer_name`中。在下一行，通过连接字符串创建了一条消息。这条消息显示在屏幕上，为游戏创建个性化的开始。
- en: '|  |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**More tools for strings: string methods**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**更多字符串工具：字符串方法**'
- en: 'To make life easier, Python includes some built-in tools for working with strings.
    These tools are similar to the functions you saw earlier, but they’re called *methods*.
    Here is an example of a method that capitalizes the first letter of a string:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让生活更简单，Python包含了一些用于处理字符串的内置工具。这些工具与之前看到的函数类似，但它们被称为*方法*。以下是一个将字符串的第一个字母大写的示例方法：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `capitalize` method converts “jOHn” to “John”.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`capitalize`方法将“jOHn”转换为“John”。'
- en: 'Python has a whole set of built-in methods. One method for strings is the `lower`
    method, which converts a string to all lowercase:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一整套内置的方法。字符串的一个方法是`lower`方法，它将字符串转换为全部小写：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This makes “RABBIT” turn into “rabbit”.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得“RABBIT”变成了“rabbit”。
- en: 'Another method, `upper`, makes all the letters uppercase:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方法，`upper`，将所有字母转换为大写：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `upper` method is great for shouting things. It makes “king Arthur” into
    “KING ARTHUR”.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`upper`方法非常适合大声喊叫。它将“king Arthur”转换为“KING ARTHUR”。'
- en: These methods can save you time^([[a](#ch03fn01a)]) and make it easier for you
    to get things done.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法可以节省你的时间^([[a](#ch03fn01a)])，并使你更容易完成任务。
- en: ^a
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You can learn more about the available string methods in the online Python
    documentation: [http://mng.bz/9z49](http://mng.bz/9z49).'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以在在线Python文档中了解更多关于可用字符串方法的信息：[http://mng.bz/9z49](http://mng.bz/9z49)。
- en: '**Methods vs. functions**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法与函数**'
- en: Methods are a type of function, but they use *dot notation*. This means you
    put a period (`.`) after the item and then the name of the method. If your item
    was “John Cleese” and the method you wanted to use was `lower`, you’d write
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是一种函数类型，但它们使用*点符号*。这意味着你在项目后面放一个点（`.`），然后是方法的名字。如果你的项目是“John Cleese”并且你想使用的方法是`lower`，你会写成
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Parentheses go after the method name. You put in the parentheses any inputs
    required by the method. You can check the Python documentation online to see what
    is required.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 括号跟在方法名后面。你需要在括号中放入方法所需的所有输入。你可以在网上查看Python文档，看看需要什么。
- en: 'Some methods don’t require any inputs, like the string methods `capitalize`,
    `upper`, and `lower`. But some methods, like `count`, require inputs. Imagine
    that you had a set of test answers with `T` for true and `F` for false, and you
    wanted to count the number of true answers. You could use `count`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方法不需要任何输入，比如字符串方法`capitalize`、`upper`和`lower`。但有些方法，比如`count`，需要输入。想象一下，你有一套测试答案，用`T`代表正确，用`F`代表错误，你想要计算正确答案的数量。你可以使用`count`：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There were 12 true answers on the test.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 测试中有12个正确答案。
- en: '|  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s go further and add more inputs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，添加更多的输入。
- en: Using more than one input
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用多个输入
- en: 'You have a wonderful start to your game. Now you need to gather multiple inputs
    from the player. Let’s start by asking the player for a noun—the name of a famous
    person:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你的游戏开始了，这是一个美好的开始。现在你需要从玩家那里收集多个输入。让我们先请玩家给出一个名词——一个著名人物的名称：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, you should get a few more words:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你应该再获取一些单词：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With these multiple inputs, your code should now look like the following listing.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些多个输入，你的代码现在应该看起来像以下列表。
- en: Listing 3.4\. Collecting multiple items from the player
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.4。从玩家那里收集多个项目
- en: '![](079fig01_alt.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](079fig01_alt.jpg)'
- en: You use the `input` function multiple times to collect a set of words from the
    user. Each word is stored in a variable on the left side of the equals sign. Try
    to use names for variables that make sense; it’ll be easier to remember what you
    stored in them later.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你多次使用`input`函数从用户那里收集一组单词。每个单词都存储在等号左边的变量中。尽量使用有意义的变量名；这样以后更容易记住你存储了什么。
- en: Building the sentence
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建句子
- en: 'Now let’s create the sentence for your Silly Sentence Generator 3000 by joining
    the words using `+`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用`+`来连接单词来为你的“愚蠢句子生成器3000”创建句子：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let’s take a closer look at this line of code in [figure 3.10](#ch03fig10) to
    see what’s happening.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看[图3.10](#ch03fig10)中的这一行代码，看看发生了什么。
- en: Figure 3.10\. `silly-sentence` is created by joining a set of strings. The strings
    are a combination of strings you enter with quotation marks around them and strings
    collected from the game player that are stored in variables. The parentheses are
    needed because the code is too long to fit on a single line.
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.10。`silly-sentence`是通过连接一系列字符串创建的。这些字符串是你输入的，并用引号括起来的字符串，以及从游戏玩家那里收集并存储在变量中的字符串的组合。括号是必需的，因为代码太长，无法放在一行中。
- en: '![](03fig10_alt.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](03fig10_alt.jpg)'
- en: On the right side of the equals sign, the parentheses enclose the strings that
    are being joined to create a sentence. They’re joined (or *concatenated*) using
    the `+` operator. Because the line is so long, you can use a set of parentheses
    to break it over two lines. Python recommends limiting all lines to no longer
    than 79 characters so the code can be easily read. Looking at the left side of
    the equals sign, you’ll see that the resulting string is stored in a variable
    named `silly_sentence`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在等号右边，括号括住了要连接以创建句子的字符串。它们使用`+`运算符连接（或*连接*）。因为这一行代码太长，你可以使用一组括号将其分成两行。Python建议将所有行限制在不超过79个字符，这样代码就可以很容易地阅读。查看等号左边，你会看到结果字符串存储在名为`silly_sentence`的变量中。
- en: What’s especially awesome is that this code will create a different sentence
    each time a user enters different words. Because you used variables and the variables
    are storing the input from the user, it’s truly a Silly Sentence Generator!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其令人兴奋的是，这段代码会在用户输入不同的单词时创建不同的句子。因为你使用了变量，并且变量存储了用户的输入，所以这真是一个愚蠢的句子生成器！
- en: Troubleshooting
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 故障排除
- en: When typing code, it’s easy to make mistakes, called *bugs*. Boo to bugs. To
    track them down and fix them, you *debug* your code. Yay for debugging. You may
    forget to close a set of quotation marks, you may leave out a parenthesis, or
    you may misspell a word. Let’s look at some common errors you might make and how
    to fix them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，很容易犯错误，称为*错误*。讨厌错误。为了追踪并修复它们，你需要*调试*你的代码。调试万岁。你可能忘记关闭一组引号，你可能遗漏了一个括号，或者你可能拼错了单词。让我们看看你可能犯的一些常见错误以及如何修复它们。
- en: 'In the last section, you used the `+` to join strings and variables that were
    storing strings. Look at this code, which has an error:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个部分，你使用了`+`来连接字符串和存储字符串的变量。看看这个有错误的代码：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Do you see the problem? The first string (`"The`) is missing the closing quotation
    mark (`"The "`). If you were to run this program, Python would output an error
    (see [figure 3.11](#ch03fig11)). Add the closing quotation mark to the string
    that is missing it, and then save your program and run it again.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到问题了吗？第一个字符串（`"The"”）缺少关闭引号（`"The "`）。如果你运行这个程序，Python会输出错误（见[图3.11](#ch03fig11)）。给缺少关闭引号的字符串添加关闭引号，然后保存你的程序并再次运行。
- en: Figure 3.11\. If you forget to close a set of quotation marks around a string,
    you’ll receive an error from Python when you try to run your program. Python will
    highlight in red the line with the error. Check each of the strings to find and
    fix the error.
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.11。如果你忘记关闭字符串周围的引号，当你尝试运行程序时，Python会给你错误。Python会在红色中突出显示有错误的行。检查每个字符串以找到并修复错误。
- en: '![](03fig11_alt.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig11_alt.jpg)'
- en: Another common error you might make is to misspell the name of a variable or
    use different capitalization. Here’s the same line of code, but this time there
    is a misspelled variable and one variable with incorrect capitalization. Can you
    spot them?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能犯的另一个常见错误是拼写变量名错误或使用不同的首字母大小写。这是相同的一行代码，但这次有一个拼写错误的变量和一个大小写错误的变量。你能找到它们吗？
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first one is `adjectve1`, which should be `adjective1` (the `i` is missing).
    The second error is `Famous_person`, which should be `famous_person` (the `F`
    should be lowercase). The error you’ll see if you run this program is shown in
    [figure 3.12](#ch03fig12).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`adjectve1`，应该是`adjective1`（缺少`i`）。第二个错误是`Famous_person`，应该是`famous_person`（`F`应该小写）。如果你运行这个程序，你会看到的错误显示在[图3.12](#ch03fig12)中。
- en: 'Figure 3.12\. A common mistake in programming is to misspell the name of a
    variable or use incorrect capitalization. The error displayed says there is a
    problem on line 25 of the program. The type of error is `NameError: name ''adjectve1
    '' is not defined`.'
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '图3.12。编程中的一个常见错误是拼写变量名错误或使用不正确的大小写。显示的错误说程序的第25行有问题。错误类型是`NameError: name ''adjectve1
    '' is not defined`。'
- en: '![](03fig12_alt.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig12_alt.jpg)'
- en: '|  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: The spelling and capitalization of a variable must always be the same. If you
    call a variable `my_number` and then later type `my_nomber` or `My_number`, Python
    will give you an error.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的拼写和大小写必须始终相同。如果你将变量命名为`my_number`，然后后来输入`my_nomber`或`My_number`，Python会给你一个错误。
- en: '|  |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Correct the error by fixing the spelling of `adjectve1` so it’s `adjective1`.
    After fixing it, you’ll still receive an error, but this time because of the capitalization
    of `Famous_person` (`NameError: name ''Famous_person'' is not defined`). Change
    the capitalization of `Famous_person` to `famous_person`. Once you’ve made the
    corrections, save the program and run it again.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '通过修正`adjectve1`的拼写使其变为`adjective1`来纠正错误。修正后，你仍然会收到错误，但这次是因为`Famous_person`的大小写错误（`NameError:
    name ''Famous_person'' is not defined`）。将`Famous_person`的大小写更改为`famous_person`。一旦你进行了修正，保存程序并再次运行。'
- en: You’ve debugged your program. Superb job!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经调试了你的程序。做得好！
- en: 'Completing the program: displaying the silly sentence'
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成程序：显示愚蠢的句子
- en: You’ve made your silly sentence, and you want Python to show it to the player.
    Use the `print` statement to print it out, but like your welcome message, let’s
    add some pizzazz to it!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经制作了你的愚蠢句子，并希望Python将其显示给玩家。使用`print`语句打印它，但像你的欢迎信息一样，让我们给它添加一些活力！
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Guess what it does? It prints a row of * characters (asterisks) across the screen
    48 times. Then it displays the sentence and prints another row of * symbols 48
    times. Try other characters or patterns of characters to see what looks good to
    you!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜它做什么？它在屏幕上打印一排*字符（星号）48次。然后显示句子，并再次打印一排*符号48次。尝试其他字符或字符模式，看看哪个看起来对你来说更好！
- en: 'It looks pretty good, but you can do a bit better. Test your program by running
    it, and you’ll notice the number of symbols doesn’t match the length of the sentence.
    You’ve programmed it to display exactly 48 asterisks—no more, no less. Instead,
    let’s update those lines to repeat the symbol to match the length of the silly
    sentence. You’ll use another built-in Python function called `len`, which calculates
    the length of a string and returns a number telling you the number of characters:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来相当不错，但你可以做得更好。通过运行程序来测试你的程序，你会注意到符号的数量与句子的长度不匹配。你编程使其显示正好48个星号——不多也不少。相反，让我们更新这些行，使符号重复以匹配愚蠢句子的长度。你将使用另一个内置的Python函数`len`，它计算字符串的长度并返回一个数字，告诉你字符的数量：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That’s better! Let’s look at the code all together (see [figure 3.13](#ch03fig13)).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了！让我们一起看看代码（见[图 3.13](#ch03fig13)）。
- en: Figure 3.13\. Silly Sentence Generator 3000 is a fun program that shows how
    programs can collect information from users, interact with them, and provide a
    more personal feel.
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.13\. Silly Sentence Generator 3000 是一个有趣的程序，展示了程序如何从用户那里收集信息，与他们互动，并提供更个性化的体验。
- en: '![](03fig13_alt.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![03fig13_alt.jpg](03fig13_alt.jpg)'
- en: You’ve completed your program. Let’s do some final testing to see what it can
    do! See [figure 3.14](#ch03fig14) for an example of the game’s output.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了你的程序。让我们进行一些最后的测试，看看它能做什么！见[图 3.14](#ch03fig14)以查看游戏的输出示例。
- en: Figure 3.14\. The Silly Sentence Generator 3000 makes some absurd sentences
    based on words you enter.
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.14\. Silly Sentence Generator 3000 基于你输入的单词生成一些荒谬的句子。
- en: '![](03fig14_alt.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![03fig14_alt.jpg](03fig14_alt.jpg)'
- en: Fantastic! Feel free to update the code to add more adjectives, verbs, or nouns.
    You’ve learned how to get input from a computer user and interact with them by
    displaying a message to the screen.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你可以自由地更新代码以添加更多的形容词、动词或名词。你已经学会了如何从计算机用户那里获取输入，并通过在屏幕上显示消息与他们互动。
- en: 'Fruit Picker Extra: Minecraft Pi'
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水果采摘器额外功能：Minecraft Pi
- en: 'In this Fruit Picker Extra, you’ll explore another unique feature of the Pi:
    it has its own version of Minecraft. Thanks to a collaboration between Mojang,
    the makers of Minecraft, and the Raspberry Pi Foundation, a free, slimmed-down
    version of Minecraft is available on the Raspberry Pi. Since September 2014, this
    version, called Minecraft Pi, is automatically installed with the Raspbian operating
    system.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个水果采摘器额外功能中，你将探索 Pi 的另一个独特功能：它有自己的 Minecraft 版本。多亏了 Minecraft 制造商 Mojang 和
    Raspberry Pi 基金会的合作，Raspberry Pi 上提供了一款免费、精简版的 Minecraft。自 2014 年 9 月以来，这个版本被称为
    Minecraft Pi，并自动与 Raspbian 操作系统一起安装。
- en: What’s Minecraft?
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 什么是 Minecraft？
- en: Minecraft is a game that takes place in a 3D virtual world made of blocks. At
    the most basic level, you run around mining (digging blocks by hitting them) and
    crafting things (combining items in the game to make new items). You can also
    build things in this virtual world using different types of blocks.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Minecraft 是一个发生在由方块组成的 3D 虚拟世界中的游戏。在最基本层面上，你四处跑动采矿（通过击打方块来挖掘）和制作物品（在游戏中组合物品以制作新物品）。你还可以在这个虚拟世界中使用不同类型的方块来建造东西。
- en: Launching Minecraft Pi
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启动 Minecraft Pi
- en: Look for a Minecraft Pi icon under Menu > Games (see [figure 3.15](#ch03fig15)).
    If you got your Pi before September 2014, see the [chapter 6](kindle_split_016.html#ch06)
    sidebar “[Updating your Pi](kindle_split_016.html#ch06sb04)” to learn how to update
    Raspbian.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在菜单>游戏下寻找 Minecraft Pi 图标（见[图 3.15](#ch03fig15)）。如果你在 2014 年 9 月之前获得了 Pi，请参阅[第
    6 章](kindle_split_016.html#ch06)侧边栏“[更新你的 Pi](kindle_split_016.html#ch06sb04)”以了解如何更新
    Raspbian。
- en: Figure 3.15\. Minecraft Pi is a slimmed-down, free version of Minecraft that’s
    based on Minecraft Pocket Edition. It’s limited compared to the full version but
    still oodles of fun!
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.15\. Minecraft Pi 是基于 Minecraft Pocket Edition 的精简版免费 Minecraft。与完整版本相比，它有所限制，但仍然非常有趣！
- en: '![](03fig15.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![03fig15.jpg](03fig15.jpg)'
- en: Click the Minecraft Pi icon to open the game. A Minecraft window will open (see
    [figure 3.16](#ch03fig16)). It’s a little quirky—you’ll see a black window behind
    the Minecraft window—but this is normal.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 Minecraft Pi 图标以打开游戏。一个 Minecraft 窗口将会打开（见[图 3.16](#ch03fig16)）。它有点古怪——你会在
    Minecraft 窗口后面看到一个黑色窗口，但这很正常。
- en: Figure 3.16\. The Minecraft Pi main screen allows you to start a singleplayer
    game or join a multiplayer game. The multiplayer option lets you connect to someone
    else’s world, but you’ll need to be on the same network.
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.16\. Minecraft Pi 主屏幕允许你开始单人游戏或加入多人游戏。多人选项允许你连接到其他人的世界，但你需要在同一网络中。
- en: '![](03fig16_alt.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![03fig16_alt.jpg](03fig16_alt.jpg)'
- en: Click Start Game to begin to play. Next, click Create New to create a new world.
    After it’s done loading, you’ll find yourself in a blocky world (see [figure 3.17](#ch03fig17)).
    Each world is different, so you may see trees, water, dirt, or any number of environments.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“开始游戏”开始游戏。接下来，点击“创建新游戏”创建一个新的世界。加载完成后，你将发现自己在一个方块世界中（见[图 3.17](#ch03fig17)）。每个世界都不同，所以你可能看到树木、水、泥土或任何数量的环境。
- en: Figure 3.17\. Each Minecraft world is made of blocks but is different. You might
    find yourself in a forest or in a desert. The bottom of the screen shows you the
    items in your inventory. Use the mouse scroll wheel to select different items,
    or press the numbers 1–9 on your keyboard.
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.17\. 每个Minecraft世界都是由方块组成，但各不相同。你可能会发现自己在一个森林里或沙漠中。屏幕底部显示了你背包中的物品。使用鼠标滚轮选择不同的物品，或者按键盘上的数字
    1-9。
- en: '![](03fig17_alt.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig17_alt.jpg)'
- en: 'In Minecraft, you’re a player who can walk around using the following controls:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在Minecraft中，你是一个可以使用以下控制键四处走动的玩家：
- en: '***W*** —Move forward.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***W*** —向前移动。'
- en: '***A*** —Move left.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***A*** —向左移动。'
- en: '***S*** —Move backward.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***S*** —向后移动。'
- en: '***D*** —Move right.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***D*** —向右移动。'
- en: '***Spacebar*** —Jump.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***空格键*** —跳跃。'
- en: '***Mouse movement*** —Look around or turn.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***鼠标移动*** —四处查看或转身。'
- en: '***Escape*** —Exit the game.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Escape*** —退出游戏。'
- en: 'In addition to the basics, here are some other moves you may need:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本操作外，这里还有一些你可能需要的其他动作：
- en: '***Double spacebar*** —Fly up in the air (double-tap the space bar and then
    hold it down to fly up). Press the left Shift key to move down. If you’re flying,
    double-tap the spacebar to fall back to the ground.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***空格键两次*** —飞到空中（双击空格键然后按住以飞起）。按左Shift键向下移动。如果你在飞行，双击空格键以回到地面。'
- en: '***E*** —Show the game inventory of blocks and items you can use (it’s limited
    compared to the full version of the game). Drag items you want to the small squares
    at the bottom of the screen. Press Escape to hide the inventory screen.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***E*** —显示你可以使用的方块和物品的游戏库存（与游戏的完整版本相比有限）。将你想要的物品拖到屏幕底部的下方小方块中。按Esc键隐藏库存屏幕。'
- en: '***Scroll wheel or the number 1–9 keys*** —Select something from one of your
    player inventory spots at the bottom of the screen. The item selected is in your
    hand for you to use.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***滚轮或数字1-9键*** —从屏幕底部底部的玩家库存位置中选择一个物品。选中的物品现在在你的手中供你使用。'
- en: Once you get the hang of moving around, use the mouse left click to dig or break
    blocks. Use the mouse right click to place a block or use the tool in your hand.
    When you’re ready to leave, press Escape to exit the game.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了移动的方法，使用鼠标左键来挖掘或破坏方块。使用鼠标右键放置方块或使用手中的工具。当你准备离开时，按Esc键退出游戏。
- en: '|  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: To exit Minecraft Pi, press Escape > Quit to Title, and then click the X in
    the corner to close the window.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出Minecraft Pi，按Esc > 退出到标题，然后点击角落的X来关闭窗口。
- en: '|  |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Python programming interface to Minecraft Pi
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Python编程接口到Minecraft Pi
- en: Minecraft Pi has a fun inventory of materials and tools—even a sword! What’s
    even better is that there is a Python programming interface for Minecraft Pi.
    Head over to the Raspberry Pi Foundation website to learn more about how to use
    Python to interact with Minecraft Pi.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Minecraft Pi有一个有趣的材料和工具库存——甚至还有一把剑！更好的是，Minecraft Pi有一个Python编程接口。前往Raspberry
    Pi基金会网站了解更多关于如何使用Python与Minecraft Pi交互的信息。
- en: Explore the world, dig an underground base, or build a tree house. What will
    you do?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 探索世界，挖掘地下基地，或建造一个树屋。你将做什么？
- en: '![](common03.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](common03.jpg)'
- en: Challenges
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战
- en: Try these challenges to see if you can use the `input` function and strings
    to create something fun and interactive.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些挑战，看看你是否可以使用`input`函数和字符串创建一些有趣且交互式的项目。
- en: Knight’s Tale Creator 3000
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 骑士故事创造者3000
- en: 'In this challenge, try to use what you’ve learned about input (gathering text)
    and output (displaying text) to create a Knight’s Tale Generator. Here is a story
    template for you to use:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个挑战中，尝试使用你关于输入（收集文本）和输出（显示文本）的知识来创建一个骑士故事生成器。这里有一个你可以使用的模板故事：
- en: '*There was a brave knight, [player_name], who was sent on a quest to vanquish
    the [adjective] evildoer, [famous_person]. Riding on his/her trusty [animal],
    the brave [player_name] traveled to the faraway land of [vacation_place]. [player_name]
    battled valiantly against [famous_person]’s army using his [sharp_thing] until
    he defeated them. Emerging victorious, [player_name] exclaimed, “[exclamation]!!!”
    I claim the land of [vacation_place] in the name of Python.*'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*曾经有一位勇敢的骑士，[player_name]，被派去消灭[adjective]的恶棍，[famous_person]。骑着他/她的可靠的[animal]，勇敢的[player_name]穿越到遥远的[travel_place]。[player_name]使用他的[sharp_thing]勇敢地与[famous_person]的军队战斗，直到击败他们。胜利归来，[player_name]大声喊道，“[exclamation]!!!”我代表Python声称[travel_place]的土地。*'
- en: The words in brackets are meant to be variables that you’ll create in your program;
    you’ll need to have the player input those words. Remember to use `+` to join
    the strings to create a unique knight’s tale, and then print the tale to the screen.
    Good luck!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中的单词是为了在程序中创建的变量；你需要让玩家输入这些单词。记得使用`+`来连接字符串，创建一个独特的骑士故事，然后将故事打印到屏幕上。祝你好运！
- en: Subliminal messages
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 潜意识信息
- en: A *subliminal message* is a hidden message that tries to get people to think
    of something you want them to think about. Often used in TV commercials, it’s
    a great technique to try with friends and parents to get something you want.^([[3](#ch03fn03)])
    In this challenge, try to create a message that is hidden in a large display of
    characters. The message should be constructed by asking for the person’s name,
    the name of something they want, and a pattern of letters, numbers, and symbols.
    In your program, you should create a message that says, “You really want to buy
    [player_name] a [thing]”, and hide it within a pattern of characters. [Figure
    3.18](#ch03fig18) shows an example.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*潜意识信息*是一种隐藏的信息，试图让人们思考你希望他们思考的事情。常用于电视广告，这是一种与朋友和父母尝试以获得你想要的东西的绝佳技巧.^([[3](#ch03fn03)])
    在这个挑战中，尝试创建一个隐藏在大量字符显示中的信息。信息应该通过询问人的名字、他们想要的东西的名字和字母、数字和符号的模式来构建。在你的程序中，你应该创建一个信息，说“你真的很想给[玩家名字]买一个[东西]”，并将其隐藏在一个字符模式中。[图3.18](#ch03fig18)显示了示例。'
- en: ³
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use subliminal messaging at your own risk (send Ryan pizza!). If people know
    you’re trying to manipulate their minds, they may retaliate with subliminal messaging
    of their own.
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在自己的风险下使用潜意识信息（给瑞恩送披萨！）。如果人们知道你试图操纵他们的思想，他们可能会用他们自己的潜意识信息进行反击。
- en: Figure 3.18\. The subliminal-message challenge is about hiding a secret message
    in a bunch of characters on the screen. Can you see the hidden message?
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.18\. 潜意识信息挑战是在屏幕上的一堆字符中隐藏一个秘密信息。你能看到隐藏的信息吗？
- en: '![](03fig18_alt.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig18_alt.jpg)'
- en: In this example, the hidden message is, “You really want to buy Ryan a burrito.”
    Be sneaky, and see if you can find a way to create and hide a subliminal message!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，隐藏的信息是，“你真的很想给瑞恩买一个玉米卷。”要狡猾一点，看看你能否找到一种方法来创建和隐藏一个潜意识信息！
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, you learned how to write interactive programs that get information
    from a person and provide entertaining responses:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何编写交互式程序，从一个人那里获取信息并提供娱乐性回应：
- en: 'Use the `input` function to collect text input from a person. Use it with a
    variable and an equals sign to store the information that a person types in. Here’s
    an example of asking the user to tell you their favorite color and saving it to
    a variable called `favorite_color`:'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`input`函数从一个人那里收集文本输入。使用变量和等号来存储人们输入的信息。以下是一个要求用户告诉你他们最喜欢的颜色并将其保存到名为`favorite_color`的变量中的示例：
- en: '[PRE18]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add notes to your programs by starting a line with a hashtag (`#`) and a space:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在行首添加一个井号（`#`）和一个空格来为你的程序添加注释：
- en: '[PRE19]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Join strings using `+`.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`+`来连接字符串。
- en: 'Use parentheses when you need to join strings that are longer than a single
    line:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要连接超过单行的字符串时，请使用括号：
- en: '[PRE20]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The game you created uses the same ideas to collect information from users and
    interact with them in the same way they see every day on websites, mobile apps,
    and games.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的游戏使用相同的思想从用户那里收集信息，并以他们每天在网站、移动应用和游戏中看到的方式与他们互动。
- en: 'Chapter 4\. Norwegian Blue parrot game: adding logic to programs'
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章. 挪威蓝鹦鹉游戏：为程序添加逻辑
- en: '**In this chapter, you’ll learn how to create Python programs that**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**在本章中，你将学习如何创建Python程序，**'
- en: '*Display an introduction*'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示一个介绍*'
- en: '*Collect input from the user*'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从用户那里收集输入*'
- en: '*Use* `if` *statements to respond to users in different ways*'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用* `if` *语句以不同的方式对用户做出响应*'
- en: '*Use* `while` *loops to repeat things over and over*'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用* `while` *循环来重复做某事*'
- en: '*Use Python code libraries to generate random numbers*'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Python代码库生成随机数*'
- en: Open a popular game, such as Minecraft, or think about a robot, like the Mars
    rover. Both are computer programs. What do they have in common? They both have
    the ability to take input and do something with it. What they do depends on the
    input they’re given. In a game, if you press Forward and fall off a ledge, your
    character falls and dies. If it’s your only life, then you’re taken to the Game
    Over screen. Similarly, the Mars rover might be instructed to go to a certain
    location, but if it detects a large rock in its way, it will stop or attempt to
    drive around the obstacle.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个流行的游戏，如Minecraft，或者想想一个机器人，如火星漫游车。两者都是计算机程序。它们有什么共同点？它们都有从输入中获取信息并对其进行处理的的能力。它们所做的事情取决于它们所接收的输入。在游戏中，如果你按前进并从悬崖上掉下来，你的角色就会掉下来死去。如果你只剩下一条命，那么你就会被带到游戏结束屏幕。同样，火星漫游车可能会被指示前往某个位置，但如果它检测到前方有一个大石头，它就会停止或尝试绕过障碍物。
- en: The logic of how games work or how the rover moves is programmed into them.
    But how do you create that logic in your programs? You’ll learn how by making
    a simple guessing game about a special parrot, the Norwegian Blue.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的工作逻辑或漫游车移动的逻辑被编程进去。但您如何在程序中创建这种逻辑呢？您将通过制作一个关于特殊鹦鹉——挪威蓝鹦鹉的简单猜年龄游戏来学习如何做到这一点。
- en: Displaying the game introduction
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示游戏介绍
- en: The Norwegian Blue parrot is a fictitious parrot that is the subject of one
    of the most famous comedy sketches from Monty Python.^([[1](#ch04fn01)]) Your
    game is about pretending you’re visiting a pet shop that has a Norwegian Blue
    parrot for sale. The shop owner challenges you to guess the age of the parrot
    (see [figure 4.1](#ch04fig01)). If you guess correctly, then you get to take home
    the parrot for free.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 挪威蓝鹦鹉是一种虚构的鹦鹉，是蒙提·派森最著名的喜剧片段之一的主旨。[^([1](#ch04fn01))] 您的游戏是假装您正在参观一个出售挪威蓝鹦鹉的宠物店。店主挑战您猜测鹦鹉的年龄（见[图
    4.1](#ch04fig01))。如果您猜对了，那么您可以免费带回家这只鹦鹉。
- en: ¹
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If you haven’t seen it, check out this Wikipedia page, which has an audio recording
    of the comedy sketch: [http://en.wikipedia.org/wiki/Dead_Parrot_sketch](http://en.wikipedia.org/wiki/Dead_Parrot_sketch).'
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您还没有看过，请查看这个维基百科页面，其中包含了这个喜剧片段的音频录音：[http://zh.wikipedia.org/wiki/Dead_Parrot_sketch](http://zh.wikipedia.org/wiki/Dead_Parrot_sketch)。
- en: Figure 4.1\. The Norwegian Blue parrot has beautiful plumage and makes a great
    subject for a guessing game.
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.1\. 挪威蓝鹦鹉有着美丽的羽毛，是猜年龄游戏的绝佳主题。
- en: '![](04fig01.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![04fig01.jpg]'
- en: Each time the game is played, the program selects a different random number
    between 1 and 20 as the age of the parrot. The game player gets five chances to
    guess the parrot’s age. If the player guesses correctly, the game displays a funny
    message congratulating them on winning their new parrot. If the player makes a
    wrong guess, then the program displays a good-hearted insult, as if it were offended
    by the player’s guess. If the player doesn’t guess within five tries, they lose,
    and the pet shop owner lets them know the parrot’s true age (see [figure 4.2](#ch04fig02)).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 每次玩游戏时，程序都会选择一个介于 1 和 20 之间的不同随机数作为鹦鹉的年龄。游戏玩家有五次机会猜测鹦鹉的年龄。如果玩家猜对了，游戏会显示一条有趣的祝贺信息，恭喜他们赢得了他们新鹦鹉。如果玩家猜错了，程序会显示一条善意的侮辱，就像它对玩家的猜测感到冒犯一样。如果玩家在五次尝试内没有猜对，他们就会输，宠物店老板会告诉他们鹦鹉的真实年龄（见[图
    4.2](#ch04fig02)）。
- en: Figure 4.2\. The game logic can be expressed in words. The question marks symbolize
    when the game needs logic to make a decision. This diagram also shows what code
    needs to be repeated because the player gets five guesses. Each decision has a
    simple True/False or Yes/No answer.
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.2\. 游戏逻辑可以用文字表达。问号表示游戏需要逻辑来做出决定。此图还显示了需要重复的代码，因为玩家有五次猜测机会。每个决定都有简单的真/假或是/否答案。
- en: '![](04fig02.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![04fig02.jpg]'
- en: When this game is completed, you’ll be able to play it. The output will look
    like [figure 4.3](#ch04fig03). In the example, the player guessed four times incorrectly;
    but on their fifth try, they guessed correctly. They won, and the shop owner gave
    them the parrot.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个游戏完成时，您将能够玩它。输出将类似于[图 4.3](#ch04fig03)。在示例中，玩家前四次猜测都不正确；但在第五次尝试时，他们猜对了。他们赢了，店主给了他们这只鹦鹉。
- en: Figure 4.3\. The Norwegian Blue Guessing Game is about trying to guess the age
    of a bird in a pet shop.
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.3\. 挪威蓝鸟猜年龄游戏是关于尝试猜测宠物店里一只鸟的年龄。
- en: '![](04fig03_alt.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![04fig03_alt.jpg]'
- en: Creating the game welcome message and instructions
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建游戏欢迎信息和说明
- en: Let’s start by opening IDLE for Python 3 and creating a new program. Open IDLE
    by clicking the Python 3 icon under Menu > Programming on your Raspberry Pi desktop
    (see [figure 4.4](#ch04fig04)).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开 Python 3 的 IDLE 并创建一个新的程序开始。通过点击您的树莓派桌面上的菜单 > 编程下的 Python 3 图标来打开 IDLE（见[图
    4.4](#ch04fig04)）。
- en: Figure 4.4\. Click the Python 3 icon to open IDLE’s Python 3 Shell on your Raspberry
    Pi.
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.4\. 点击 Python 3 图标，在您的树莓派上打开 IDLE 的 Python 3 Shell。
- en: '![](04fig04_alt.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![04fig04_alt.jpg]'
- en: Give your Raspberry Pi a few seconds to open IDLE. You’ll see the Python Shell.
    Press Ctrl-N or File > New Window to open the IDLE text editor. You’ll see a blank
    window, ready for you to start typing in the program.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 给您的树莓派几秒钟的时间来打开 IDLE。您将看到 Python Shell。按 Ctrl-N 或文件 > 新窗口来打开 IDLE 文本编辑器。您将看到一个空白窗口，准备好让您开始输入程序。
- en: Let’s type in a few comments at the top of the program in the text editor. Start
    each line with a hash tag (#) and a space.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在文本编辑器的程序顶部输入一些注释。每行以一个井号(#)和一个空格开始。
- en: Listing 4.1\. Creating comments at the top of your new program
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.1。在你的新程序顶部创建注释
- en: '[PRE21]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Change the words to whatever you’d like. Comments are notes for you and whoever
    you might share your program with, so make them read the way you want. Remember
    to avoid going off the screen with your comments—keep each line pretty short.
    No more than 79 characters per line is good style; this ensures that your beautiful
    Python programs fit in the window and don’t require the user to scroll or resize
    the window.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 将单词改为你喜欢的。注释是你和可能与你分享程序的人的笔记，所以让它们以你想要的方式阅读。记住，避免注释超出屏幕——保持每行不要太长。每行不超过79个字符是良好的风格；这确保了你的美丽Python程序可以适应窗口，并且不需要用户滚动或调整窗口大小。
- en: '|  |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can keep track of which line and column your cursor is on by using the
    cursor-location information (see [figure 4.5](#ch04fig05)). It’s displayed in
    the bottom-right corner of the text editor. The letters *Col* stand for column:
    this shows the number of characters your cursor is from the left side of the screen.
    The left side is 0, the middle is 40, the right side is 80, and so forth.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用光标位置信息来跟踪你的光标所在的行和列（见图4.5）。它显示在文本编辑器的右下角。字母*Col*代表列：这显示了光标从屏幕左侧的距离。左侧是0，中间是40，右侧是80，以此类推。
- en: Figure 4.5\. Once you’ve saved the file, the top of the window displays the
    filename and the location where the file is stored on your Raspberry Pi (/home/pi/NorwegianBlue.py).
    The cursor location is always shown at the bottom right of the window.
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.5。一旦保存了文件，窗口顶部将显示文件名和文件存储在Raspberry Pi上的位置（/home/pi/NorwegianBlue.py）。光标位置始终显示在窗口的右下角。
- en: '![](04fig05_alt.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig05_alt.jpg)'
- en: '|  |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The program in the IDLE text editor now contains several lines of comments.
    Before you go further, save your work: press Ctrl-S to save the program. A window
    will pop up in which you can name and choose a location in which to save the file.
    In the File Name text box, type in the name of the file: name it `NorwegianBlue`.
    When you click the Save button, the file will be saved as NorwegianBlue.py (the
    .py extension is automatically added by IDLE), and it will be stored on your Pi’s
    SD memory card in the /home/pi folder.^([[2](#ch04fn02)]) Once the program is
    saved, the text editor displays the location of the file and the filename along
    the top of the window (see [figure 4.5](#ch04fig05)).'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDLE文本编辑器中的程序现在包含几行注释。在你继续之前，保存你的工作：按Ctrl-S保存程序。将弹出一个窗口，你可以命名并选择保存文件的位置。在文件名文本框中，输入文件名：命名为`NorwegianBlue`。当你点击保存按钮时，文件将以NorwegianBlue.py（.py扩展名由IDLE自动添加）保存，并存储在Pi的SD内存卡上的/home/pi文件夹中.^([[2](#ch04fn02)])
    程序保存后，文本编辑器将在窗口顶部显示文件位置和文件名（见图4.5）。
- en: ²
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can create a new folder in which to store your Python program. You create
    a folder by opening the Raspbian File Manager application and selecting File >
    Create New > Folder. Like your shoes, you’ll want to remember where you stored
    your programs so you don’t have to spend a lot of time looking for them.
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以在新文件夹中创建一个用于存储你的Python程序。通过打开Raspbian文件管理器应用程序并选择文件 > 创建新 > 文件夹来创建文件夹。就像你的鞋子一样，你想要记住你存储程序的地方，这样你就不必花太多时间寻找它们。
- en: Next you need to let the user know the name of your game and the instructions
    for playing it. Use Python’s built-in `print` function to write a few lines of
    code that display a title on the screen.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要让用户知道你的游戏名称和玩法说明。使用Python的内置`print`函数编写几行代码，在屏幕上显示标题。
- en: Listing 4.2\. Making the title display on the screen
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.2。在屏幕上显示标题
- en: '![](097fig01_alt.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图片](097fig01_alt.jpg)'
- en: After they see the title, your game players need to know what to do. You should
    set the scene for the game and give them instructions. Let’s create a variable
    called `instructions` and store in it the sentences describing how to play the
    game. As in Silly Sentence Generator 3000 from [chapter 3](kindle_split_012.html#ch03),
    this variable will contain a string of characters a few sentences long.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家看到标题后，你需要让他们知道接下来要做什么。你应该为游戏设置场景并提供说明。让我们创建一个名为`instructions`的变量，并存储描述如何玩游戏的句子。就像在第3章的Silly
    Sentence Generator 3000中一样，这个变量将包含几个句子长度的字符字符串。
- en: Rather than enter a super-long string all on one line, you want to use a neater
    way to keep the string on the screen and limit it to not more than 79 characters
    across (remember, good Python style is to keep text on the screen). In Python,
    you can use string literals to do this.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你不想在一行中输入一个超级长的字符串，你希望使用一种更整洁的方式来保持字符串在屏幕上，并且限制其宽度不超过 79 个字符（记住，好的 Python 风格是保持文本在屏幕上）。在
    Python 中，你可以使用字符串字面量来做这件事。
- en: '|  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: '*String literals* are strings that can hold multiple lines of text and that
    appear exactly as you typed them in the text editor when they’re displayed on
    the screen. String literals keep the spaces between lines and characters. To make
    one, start and end a string with triple double quotes (`"""`) or triple single
    quotes (`''''''`).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串字面量* 是可以包含多行文本并且当它们在屏幕上显示时，会精确地按照你在文本编辑器中输入的样子显示的字符串。字符串字面量保留了行与字符之间的空格。要创建一个字符串字面量，你可以用三个双引号(`"""`)或三个单引号(`''''''`)开始和结束字符串。'
- en: '|  |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Let’s add instructions to your program after the program’s comments. You’ll
    use a string literal for the instructions and then print it to the display.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在程序的注释之后添加一些说明。你将使用字符串字面量来编写说明，并将其打印到显示设备上。
- en: Listing 4.3\. String literals that hold multiple lines of text
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3\. 包含多行文本的字符串字面量
- en: '![](097fig02_alt.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](097fig02_alt.jpg)'
- en: String literals give you the ability to display a string exactly as you type
    it in the text editor. Think of it as a “what you see is what you get” way of
    creating strings.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量让你能够以你输入文本编辑器中的样子精确地显示字符串。把它想象成一种“所见即所得”的创建字符串的方式。
- en: '|  |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Getting expressive with ASCII art**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**用 ASCII art 表达**'
- en: Before desktop operating systems (OSs) and games had high-end graphics, computers
    had limited display capabilities. Computer users and programmers invented a new
    type of art called *ASCII art* that uses text characters to make images.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面操作系统（OS）和游戏拥有高端图形之前，计算机的显示能力有限。计算机用户和程序员发明了一种新的艺术形式，称为 *ASCII art*，它使用文本字符来制作图像。
- en: ASCII is a way of storing characters as binary numbers. For example, the letter
    *A* is represented as 1000001\. Later encodings had many more characters to support
    more languages, but the name *ASCII art* stuck. ASCII art uses the set of 95 ASCII
    characters (letters, numbers, and symbols) in cleverly designed patterns to represent
    images.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII 是一种将字符存储为二进制数字的方式。例如，字母 *A* 被表示为 1000001。后来的编码支持了更多的字符，以支持更多的语言，但 *ASCII
    art* 这个名字保留了下来。ASCII art 使用精心设计的图案中的 95 个 ASCII 字符（字母、数字和符号）来表示图像。
- en: 'Here is an example of ASCII art for your game title that is made by creating
    a string literal and printing it to the screen. Craft your own ASCII art using
    a bit of imagination and trial and error:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，展示了如何通过创建一个字符串字面量并将其打印到屏幕上来制作游戏标题的 ASCII art。用一点想象力和试错法来制作你自己的 ASCII
    art：
- en: '[PRE22]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Sometimes it helps to blur your eyes a bit to see if the image looks like what
    you want. Get creative, and think how you can use uppercase and lowercase letters
    to create effects, like using a *U* to represent feathers on the parrot’s wing
    or *W* for the parrot’s claws.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，稍微模糊一下你的眼睛，看看图像是否看起来像你想要的样子，会有所帮助。发挥创意，想想你如何可以使用大写和小写字母来创造效果，比如用*U*来代表鹦鹉翅膀上的羽毛，或者用*W*来代表鹦鹉的爪子。
- en: 'Try these ASCII art sites for fun:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些 ASCII art 网站，享受乐趣：
- en: '***[www.chris.com/ascii](http://www.chris.com/ascii)*** —A huge collection
    of ASCII art, sorted by topics'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***[www.chris.com/ascii](http://www.chris.com/ascii)*** —一个按主题分类的 ASCII art
    大集合'
- en: '***[http://patorjk.com/software/taag](http://patorjk.com/software/taag)***
    —A text-to-ASCII art generator (TAAG). You type in words, and it automatically
    creates ASCII art for you.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***[http://patorjk.com/software/taag](http://patorjk.com/software/taag)***
    —一个文本到 ASCII art 生成器 (TAAG)。你输入文字，它会自动为你创建 ASCII art。'
- en: '***[http://picascii.com](http://picascii.com)*** —A tool that converts pictures
    to ASCII art'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***[http://picascii.com](http://picascii.com)*** —一个将图片转换为 ASCII art 的工具'
- en: See if you can make some ASCII art for the title screen of your game that’s
    even better than this. Have fun with it!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能制作一些比这更好的 ASCII art 作为你游戏标题屏幕。享受这个过程吧！
- en: '|  |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: It’s always a good idea to test your programs often to catch any mistakes. Test
    your program now, and see what you get. The title and instructions should display
    nicely on the screen.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 经常测试你的程序总是一个好主意，以捕捉任何错误。现在测试你的程序，看看你得到了什么。标题和说明应该会很好地显示在屏幕上。
- en: A common mistake you might make when typing in this code would be to forget
    some of the quotation marks at the beginning or end of the strings. If you do,
    [figure 4.6](#ch04fig06) shows an example of the error you’ll receive in Python.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入此代码时，你可能会犯的一个常见错误是忘记在字符串开头或结尾处的一些引号。如果你这样做，[图 4.6](#ch04fig06) 展示了你在 Python
    中会收到的错误示例。
- en: Figure 4.6\. Python will display an error if you forget starting or ending quotation
    marks. The line with the error will be highlighted in your program. Fix the program
    by adding the missing quotation marks, and then save and run the program.
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.6\. 如果你忘记了开始或结束引号，Python 会显示错误。有错误的行将在你的程序中高亮显示。通过添加缺失的引号修复程序，然后保存并运行程序。
- en: '![](04fig06_alt.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig06_alt.jpg)'
- en: A similar mistake you might make is forgetting to start your string literals
    with a triple quotation mark. In this case, Python will give you a syntax error
    message (see [figure 4.7](#ch04fig07)).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会犯的另一个类似错误是忘记以三重引号开始你的字符串字面量。在这种情况下，Python 会给你一个语法错误消息（见[图 4.7](#ch04fig07)）。
- en: Figure 4.7\. A string literal must start and end with a set of triple quotation
    marks. If you forget, Python will tell you that you have a syntax error. Add the
    missing triple quotes to fix the error.
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.7\. 字符串字面量必须以一组三个引号开始和结束。如果你忘记了，Python 会告诉你你有语法错误。添加缺失的三重引号以修复错误。
- en: '![](04fig07_alt.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig07_alt.jpg)'
- en: It’s easy to fix this error by making sure there are triple quotation marks
    at the beginning and end of the string literal. Use the highlighting shown in
    the IDLE text editor to figure out which line is causing the problem.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 通过确保字符串字面量开头和结尾有三个引号，可以轻松修复这个错误。使用 IDLE 文本编辑器中显示的高亮来找出导致问题的那一行。
- en: Collecting input from the player
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从玩家那里收集输入
- en: Your game has a proper introduction; now let’s start interacting with the player.
    Games, websites, and apps are all about causing interactions, whether it’s to
    create some fun or help you buy something online. Contrast that with the last
    movie you watched. Movies don’t have any interaction—they’re always the same.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你的游戏有一个合适的介绍；现在让我们开始与玩家互动。游戏、网站和应用程序都是关于引起互动的，无论是为了创造一些乐趣还是帮助你在线购买东西。这与你最近看过的电影形成对比。电影没有互动——它们总是相同的。
- en: A computer program’s ability to accept input and respond to that input is special.
    In text-based games like the one you’re creating, this interaction occurs through
    the keyboard. Players type in answers or make choices, and the game responds.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序接受输入并响应输入的能力是特殊的。在像你正在创建的基于文本的游戏中，这种交互通过键盘发生。玩家输入答案或做出选择，游戏就会做出响应。
- en: For this game, you want to ask the game player to guess the age of the parrot.
    The program knows the parrot’s age and checks whether each of the player’s guesses
    matches it. To make this work, you have to give the program the age of the parrot
    (it’s stored in a variable). This gives you something akin to god-like powers
    as the programmer—as the game’s maker, you can decide what the value is. Let’s
    create a variable and set it to a value that you pick. One great thing about being
    a computer programmer is that only you know the parrot’s true age.^([[3](#ch04fn03)])
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个游戏，你希望让游戏玩家猜测鹦鹉的年龄。程序知道鹦鹉的年龄，并检查玩家的每个猜测是否与之匹配。为了使这起作用，你必须给程序提供鹦鹉的年龄（它存储在一个变量中）。这给了你作为程序员类似神一样的力量——作为游戏的制作者，你可以决定这个值是多少。让我们创建一个变量并将其设置为你要选择的值。作为计算机程序员的一个很好的事情是，只有你知道鹦鹉的真实年龄.^([[3](#ch04fn03)])
- en: ³
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And anyone else who is reading this book! Later you’ll make the game use a random
    number so even you don’t know the parrot’s age.
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何其他正在阅读这本书的人！稍后你将让游戏使用一个随机数，即使你也不知道鹦鹉的年龄。
- en: Let’s make the parrot old. Create a variable named `parrot_age`, and assign
    it a value of 19.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让鹦鹉变老。创建一个名为 `parrot_age` 的变量，并将其赋值为 19。
- en: Listing 4.4\. Creating an age for the parrot
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4\. 为鹦鹉创建一个年龄
- en: '![](102fig01_alt.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](102fig01_alt.jpg)'
- en: 'Notice that in the comments you include a `TODO` note: this tells you that
    you have an item to do later.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在注释中包含了一个 `TODO` 备注：这告诉你你有一个稍后要完成的项。
- en: '|  |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use `TODO`s in your comments as reminders of areas of your program that are
    left unfinished or need further improvement. Comments are your friend, and they’re
    there to help you. Use them however you need them!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的注释中使用 `TODO` 作为提醒，指出程序中未完成或需要进一步改进的区域。注释是你的朋友，它们在那里帮助你。根据需要使用它们！
- en: '|  |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Next let’s get the user’s first guess. Use Python’s `input` function (like you
    did in [chapter 2](kindle_split_010.html#ch02)) to collect input from the user
    and store it in a variable named `guess`. Give the `input` function a message
    that clearly prompts the game player to enter an appropriate value. You don’t
    want them typing in 50 when you’re expecting a number between 1 and 20\. In this
    case, you want them to guess a number from 1 to 20.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们获取用户的第一次猜测。使用 Python 的 `input` 函数（就像你在[第 2 章](kindle_split_010.html#ch02)中做的那样）从用户那里收集输入并存储在一个名为
    `guess` 的变量中。给 `input` 函数一个清晰的消息，提示游戏玩家输入适当的值。当你期望他们在 1 到 20 之间输入一个数字时，你不想他们输入
    50。在这种情况下，你希望他们猜测一个 1 到 20 之间的数字。
- en: Listing 4.5\. Getting a guess and storing it in a variable
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.5\. 获取猜测并将其存储在变量中
- en: '![](102fig02_alt.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图片](102fig02_alt.jpg)'
- en: 'After gathering input from the user, you need to convert the value from a string
    (for example, “5”) into an integer (simply the integer 5). By default, anything
    input by the game player is stored as a string (even if what they type in is a
    number). [Figure 4.8](#ch04fig08) shows this graphically: you’re gathering input
    from the user and then converting it to an integer. The `int` function takes the
    value in the `guess` variable, converts it to an integer, and then stores it back
    in the `guess` variable.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在从用户那里收集输入后，你需要将值从字符串（例如，“5”）转换为整数（简单地是整数 5）。默认情况下，游戏玩家输入的任何内容都存储为字符串（即使他们输入的是数字）。[图
    4.8](#ch04fig08) 以图形方式显示了这一点：你从用户那里收集输入，然后将其转换为整数。`int` 函数将 `guess` 变量的值转换为整数，然后将其存储回
    `guess` 变量。
- en: Figure 4.8\. The `input` function gathers text typed in by the user; then the
    text is stored in a variable as a string data type. You take the value of the
    variable (“5”), convert it to an integer (5), and store it as the variable.
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.8\. `input` 函数收集用户输入的文本；然后文本以字符串数据类型存储。你取变量的值（“5”），将其转换为整数（5），并存储为变量。
- en: '![](04fig08_alt.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig08_alt.jpg)'
- en: 'One of the perils of working with people is they can type in whatever they
    want. If someone typed in “one” instead of “1”, you’d see an error like this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 与人合作的一个危险是，他们可以输入他们想要的任何东西。如果有人输入“one”而不是“1”，你会看到这样的错误：
- en: '[PRE23]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This error is saying you haven’t given the `int` function a valid string that
    is a number it can convert to an integer.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误表示你没有给 `int` 函数提供一个有效的字符串，该字符串可以转换为整数。
- en: If you compare the logic you want to create in your code with the program so
    far, you can see that you’ve checked off a couple of parts (see [figure 4.9](#ch04fig09)).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将你想要在代码中创建的逻辑与目前的程序进行比较，你会发现你已经完成了几个部分（见[图 4.9](#ch04fig09)）。
- en: Figure 4.9\. On the left is the logic you want to create. On the right is your
    code. So far, you’ve welcomed the user and given them the game instructions. You’ve
    also added code to collect their guess.
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.9\. 左边是你想要创建的逻辑。右边是你的代码。到目前为止，你已经欢迎了用户，并给出了游戏说明。你还添加了收集他们猜测的代码。
- en: '![](04fig09_alt.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig09_alt.jpg)'
- en: Fabulous! Test the program again to make sure it’s working. It’ll now ask you
    to enter a guess. In the next section, you’ll see how to test whether the guess
    is correct.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！再次测试程序以确保它正在正常工作。现在它将要求你输入一个猜测。在下一节中，你将看到如何测试猜测是否正确。
- en: Using if statements to respond to users in different ways
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 if 语句以不同方式响应用户
- en: When you wake up for breakfast, you might walk into the kitchen and look around
    to see what there is to eat. You use logic to pick your breakfast. If your favorite
    food is in the kitchen, you’ll eat it. For example, if your favorite food is chocolate
    chip muffins, and there are some in the kitchen, then you’ll eat them. If there
    aren’t, you might have a bowl of cereal. In this example, you apply simple logic—you
    use reasoning to make a decision.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当你醒来吃早餐时，你可能会走进厨房四处看看有什么可以吃的。你使用逻辑来选择你的早餐。如果你的最爱食物在厨房里，你就会吃它。例如，如果你的最爱食物是巧克力芯片松饼，厨房里有，那么你就会吃它们。如果没有，你可能会吃一碗谷物。在这个例子中，你应用了简单的逻辑——你使用推理来做决定。
- en: Computer programs use similar logic to interact with users and the world around
    them. The interactions are based on a set of rules that you (the programmer) write.
    One of the ways we as programmers can create this logic is with something called
    the `if` statement.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序使用类似的逻辑与用户和周围的世界交互。这些交互基于你（程序员）编写的一组规则。我们作为程序员创建这种逻辑的一种方法是通过称为 `if` 语句的东西。
- en: 'In your game, you want to test whether the player’s guess matches (is equal
    to) the parrot’s age. The logic you want to create in your code is as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的游戏中，你想要测试玩家的猜测是否与（等于）鹦鹉的年龄匹配。你想要在代码中创建的逻辑如下：
- en: If the player’s guess is equal to the parrot’s age, congratulate them and give
    them the Norwegian Blue to take home. End the game.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家的猜测等于鹦鹉的年龄，祝贺他们，并给他们一只挪威蓝鸟带回家。结束游戏。
- en: Else (if the player’s guess isn’t equal to the parrot’s age) display a mildly
    insulting message that they’re wrong. If it’s not their last guess, let them guess
    again. If it’s their last guess, end the game.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则（如果玩家的猜测不等于鹦鹉的年龄），显示一条轻微侮辱性的消息，告诉他们猜错了。如果这不是他们的最后一次猜测，让他们再猜一次。如果是他们的最后一次猜测，结束游戏。
- en: Let’s use an `if` statement in the program to create the logic you need.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在程序中使用`if`语句来创建你需要的逻辑。
- en: Listing 4.6\. Adding logic to the game with an `if` statement
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.6\. 使用`if`语句给游戏添加逻辑
- en: '![](105fig01_alt.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](105fig01_alt.jpg)'
- en: Let’s take a close look at how the `if` statement works and how it gives you
    a way to create logic in your programs (see [figure 4.10](#ch04fig10)).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看`if`语句是如何工作的，以及它是如何给你在程序中创建逻辑的方法（参见[图4.10](#ch04fig10)）。
- en: Figure 4.10\. The `if` statement can control the flow of your programs. This
    example shows how an `if` statement can be used to display one message if `guess`
    is equal to the parrot’s age or a different message if they aren’t equal.
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.10\. `if`语句可以控制程序的流程。这个例子展示了如何使用`if`语句在`guess`等于鹦鹉的年龄时显示一条消息，如果不等于，则显示不同的消息。
- en: '![](04fig10_alt.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig10_alt.jpg)'
- en: The keyword `if` is followed by `guess == parrot_age`, and the line ends with
    a colon (`:`). `guess == parrot_age` is the condition that is being tested. The
    double equals sign (`==`) is a special operator that checks the equality of `guess`
    and `parrot_age`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`if`后面跟着`guess == parrot_age`，并且行以冒号（`:`）结束。`guess == parrot_age`是要测试的条件。双等号（`==`）是一个特殊运算符，用于检查`guess`和`parrot_age`的相等性。
- en: '|  |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make sure you don’t use a single equals sign when testing equality. Single equals
    signs are used to assign (or store) values into variables.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你在测试相等性时不要使用单个等号。单个等号用于将值赋给（或存储）变量。
- en: '|  |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If they’re equals, the `if` condition is evaluated as True, and Python will
    execute the indented commands after it. In this case, you’re printing a message:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们相等，`if`条件将被评估为真，Python将执行其后的缩进命令。在这种情况下，你将打印一条消息：
- en: '[PRE24]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the guess is wrong (`guess == parrot_age` is False), then Python will do
    the `else` part. The statements to be executed for the `else` part are indented
    four spaces. In this case, if the guess is wrong, the program displays this on
    the screen:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果猜测错误（`guess == parrot_age`为假），那么Python将执行`else`部分。`else`部分要执行的语句缩进四个空格。在这种情况下，如果猜测错误，程序将在屏幕上显示以下内容：
- en: '[PRE25]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you examine the code and think back to the logic you want to create, you
    can see how the `if` statement lets you check whether the guess is correct (see
    [figure 4.11](#ch04fig11)).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查代码并回想一下你想要创建的逻辑，你可以看到`if`语句是如何让你检查猜测是否正确的（参见[图4.11](#ch04fig11)）。
- en: Figure 4.11\. The logic you want to create is shown in the code. You use the
    `if` statement to check whether the player’s guess is correct.
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.11\. 你想要创建的逻辑在代码中显示。你使用`if`语句来检查玩家的猜测是否正确。
- en: '![](04fig11_alt.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](04fig11_alt.jpg)'
- en: You’ve seen how the `if` statement can make a program make a decision. It’s
    an easy way to control programs by checking whether something is True or False.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了`if`语句如何让程序做出决策。这是一个通过检查某事是否为真或假来控制程序的一种简单方法。
- en: '|  |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**There is no “Ummm... maybe”**'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有“嗯...也许”**'
- en: The `if` statement uses something called *Boolean logic*. In Boolean logic,
    the answer must always be True or False. There is no “Ummmm... maybe.” It’s always
    either True or False.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句使用一种称为*布尔逻辑*的东西。在布尔逻辑中，答案必须始终是真或假。没有“嗯...也许”。它总是要么是真要么是假。'
- en: 'Boolean logic has its own set of operations for comparisons. These comparisons
    should be familiar from math class, such as less than (`<`) and greater than (`>`).
    Here is a table of some of the common comparisons you may need to use with your
    `if` statements:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔逻辑有一套自己的比较操作。这些比较在数学课上应该很熟悉，例如小于（`<`）和大于（`>`）。以下是一个表格，列出了你可能需要在你的`if`语句中使用的一些常见比较：
- en: '| Comparison operation | Definition |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| 比较操作 | 定义 |'
- en: '| --- | --- |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| == | Equal |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| == | 等于 |'
- en: '| != | Not equal |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| != | 不等于 |'
- en: '| < | Less than |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| < | 小于 |'
- en: '| <= | Less than or equal |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| <= | 小于或等于 |'
- en: '| > | Greater than |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| > | 大于 |'
- en: '| >= | Greater than or equal |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| >= | 大于等于 |'
- en: For this game, you’re using the equality comparison to check whether two values
    are equal to each other.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个游戏，你使用相等比较来检查两个值是否相等。
- en: If you need to reverse the logic in a comparison, you can use the `not` operator.
    The `not` operator changes a True to False or a False to True. If `x` is True,
    then `not x` is False.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要反转比较中的逻辑，可以使用 `not` 操作符。`not` 操作符将 True 变为 False 或将 False 变为 True。如果 `x`
    是 True，那么 `not x` 就是 False。
- en: Keep these comparison operators in mind. No matter which one you use, Python
    analyzes the comparison and returns either a True or False answer.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这些比较运算符。无论你使用哪一个，Python 都会分析比较并返回 True 或 False 的答案。
- en: '|  |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Practicing if statements
  id: totrans-380
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习 `if` 语句
- en: Trying more examples of `if` statements will help you get used to the logic
    and how to write them. Let’s do an example that checks to see whether a secret
    password is correct. If it is, the code should grant the person access; otherwise
    it should deny them access.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更多 `if` 语句的例子将帮助你熟悉逻辑和如何编写它们。让我们做一个例子，检查一个秘密密码是否正确。如果是，代码应该允许该人访问；否则，应该拒绝访问。
- en: Listing 4.7\. Using an `if` statement to check a password
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.7\. 使用 `if` 语句检查密码
- en: '![](109fig01_alt.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12](109fig01_alt.jpg)'
- en: Python’s `if` statements are a powerful tool for creating programs that respond
    the way you want them to. You now have the ability to make logic so your programs
    react and respond based on interacting with a user. This is the first step in
    adding a bit of artificial intelligence to your programs. Fabulous job!
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `if` 语句是创建能够按你希望的方式响应的程序的有力工具。你现在有了创建逻辑的能力，让你的程序根据与用户的交互来反应和响应。这是在程序中添加一点人工智能的第一步。做得太棒了！
- en: One of the most common mistakes when working with `if` statements is forgetting
    to put the colon (`:`) at the end. [Figure 4.12](#ch04fig12) is an example of
    an `if` statement missing the colon.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `if` 语句时最常见的错误之一是忘记在末尾放置冒号 (`:`)。[图 4.12](#ch04fig12) 是一个缺少冒号的 `if` 语句的例子。
- en: Figure 4.12\. A missing colon at the end of an `if` statement will create a
    syntax error. Python highlights where the error is located. Add a colon at the
    end of the line to fix the problem.
  id: totrans-386
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.12\. 在 `if` 语句的末尾缺少冒号将会创建一个语法错误。Python 会突出显示错误所在的位置。在行末添加一个冒号来修复问题。
- en: '![](04fig12.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12](04fig12.jpg)'
- en: Errors are common when writing programs. Try to remember to add a colon at the
    end of your `if` statements. If Python throws a syntax error box and highlights
    a space at the end of an `if` statement, you know what you’ve done.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 编写程序时，错误是常见的。尽量记住在 `if` 语句的末尾添加冒号。如果 Python 抛出一个语法错误框并突出显示 `if` 语句末尾的空格，你就知道你做了什么。
- en: Using while loops to repeat things
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `while` 循环重复事物
- en: You have input from the user, but you need a way to let the user repeatedly
    guess the parrot’s age. You might get bored repeating something over and over
    again, but computers will happily repeat something as many times as you want.
    The repeating parts of programs are called *loops*.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经从用户那里获得了输入，但你需要一种方式让用户反复猜测鹦鹉的年龄。你可能觉得反复做同样的事情会感到无聊，但计算机会乐意重复你想要的次数。程序的重复部分被称为
    *循环*。
- en: 'In the case of your guessing game, you’re giving the game player five tries
    to guess the parrot’s age. Python has several types of loops: you’ll use the `while`
    loop. A `while` loop repeats over and over until a certain condition or circumstance
    is no longer true. What it repeats is for you to decide. Each time through the
    loop, before the program repeats the instructions you gave it, it checks that
    condition.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的猜测游戏中，你给游戏玩家五次机会猜测鹦鹉的年龄。Python 有几种类型的循环：你将使用 `while` 循环。`while` 循环会重复执行，直到某个条件或情况不再为真。重复什么由你决定。每次通过循环时，在程序重复你给出的指令之前，它会检查那个条件。
- en: Let’s look at how you can use a `while` loop with your `if` statement to give
    the user only five guesses. To help, you’ll create a variable named `number_of_guesses`
    to keep track of the guesses.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `while` 循环与 `if` 语句结合，只给用户五次猜测的机会。为了帮助，你将创建一个名为 `number_of_guesses`
    的变量来跟踪猜测次数。
- en: Listing 4.8\. Using a `while` loop to repeat instructions
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.8\. 使用 `while` 循环重复指令
- en: '![](ch04ex08-0.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12](ch04ex08-0.jpg)'
- en: '![](ch04ex08-1.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12](ch04ex08-1.jpg)'
- en: Notice how you have to rearrange the code in the program a bit. First you start
    the `while` loop, and then you ask the user to input their guess. Also notice
    that the code to repeat in the `while` loop is indented (shifted over four spaces).
    Let’s take a closer look at the key elements of the `while` loop (see [figure
    4.13](#ch04fig13)).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你如何必须稍微调整程序中的代码。首先，你开始`while`循环，然后要求用户输入他们的猜测。还要注意，`while`循环中要重复的代码是缩进的（向右移动四个空格）。让我们更仔细地看看`while`循环的关键元素（见图4.13）。
- en: Figure 4.13\. Think of the logic you’re trying to create, and then translate
    it into your code. When you need to repeat something, you can use a `while` loop.
    When you need to check whether something is True or False, you can use an `if`
    statement.
  id: totrans-397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.13。思考你想要创建的逻辑，然后将其翻译成你的代码。当你需要重复某些内容时，可以使用`while`循环。当你需要检查某个条件是否为真或假时，可以使用`if`语句。
- en: '![](04fig13_alt.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![图4.13的替代图片](04fig13_alt.jpg)'
- en: 'There is a special thing about a `while` loop: you must indent all the code
    that you want the loop to repeat (like you did for `if` statements). Each line
    should be indented four spaces from the left (you measure this from where you
    type the *w* in `while`). Similarly, you stop indenting code when you want the
    `while` loop to end. Code that isn’t indented is outside the `while` loop and
    is only run after the `while` loop finishes.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环有一个特殊之处：你必须缩进所有你想要循环重复的代码（就像你在`if`语句中做的那样）。每一行应该从左边缩进四个空格（从你输入`while`中的`w`的位置开始测量）。同样，当你想要`while`循环结束时，停止缩进代码。没有缩进的代码位于`while`循环之外，并且只有在`while`循环完成后才会执行。'
- en: '|  |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: The IDLE text editor automatically indents the loop text for you. Indentation
    is used in Python to group code together.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE文本编辑器会自动为你缩进循环文本。在Python中，缩进用于将代码分组。
- en: '|  |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Notice that you create a variable named `number_of_guesses` that helps keep
    track of how many guesses have been made. It starts with a value of 0; after each
    guess, the value increases by one. When it reaches a value of 5, if the last guess
    is incorrect, the game should end. As long as the number of guesses is less than
    five, the program will check the guess entered by the player to see if it’s correct.
    If a guess is correct, the game should congratulate the player, break out of the
    loop, and end.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你创建了一个名为`number_of_guesses`的变量，它有助于跟踪已经进行了多少次猜测。它从0开始；每次猜测后，值增加1。当它达到5的值时，如果最后一次猜测是错误的，游戏应该结束。只要猜测次数少于五次，程序将检查玩家输入的猜测是否正确。如果猜测正确，游戏应该恭喜玩家，跳出循环，并结束。
- en: A closer look at while loops
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 深入了解`while`循环
- en: '`while` loops run a set of instructions or code repeatedly, but only *while*
    the condition of the `while` loop is True. This is useful when you want to have
    something repeat but need a switch that signifies when it should stop. A very
    common use of `while` loops is in games. A loop makes it so the user can play
    the game again and again until they say they don’t want to play anymore.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环会重复执行一系列指令或代码，但只有在`while`循环的条件为真时才会这样做。当你想要重复某些内容但需要一个表示何时停止的开关时，这非常有用。`while`循环的一个非常常见的用途是在游戏中。循环使得用户可以反复玩游戏，直到他们表示不想再玩了。'
- en: The while loop in [figure 4.14](#ch04fig14) counts from 0 to 99\. Let’s look
    more closely at its parts.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.14](#ch04fig14)中的`while`循环从0计数到99。让我们更仔细地看看它的各个部分。'
- en: Figure 4.14\. You can use a `while` loop to repeatedly perform a task. Code
    that is part of the loop is indented four spaces. In this case, this `while` loop
    displays the numbers from 0 to 99; when completed, it prints the message, “I finished
    counting!” Typically, the condition should be such that code in the loop can make
    it False and thus end the loop.
  id: totrans-408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.14。你可以使用`while`循环重复执行任务。循环中的代码缩进四个空格。在这种情况下，这个`while`循环显示从0到99的数字；完成后，它会打印消息，“我完成计数了！”通常，条件应该是这样的，循环中的代码可以使其变为假，从而结束循环。
- en: '![](04fig14_alt.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![图4.14的替代图片](04fig14_alt.jpg)'
- en: Like an `if` statement, a `while` loop has an expression that must be either
    True or False. The example in [figure 4.14](#ch04fig14) uses `count < 100`. The
    line ends with a colon (`:`), and subsequent lines that belong with the loop should
    be indented four spaces. In a `while` loop, you can use any other commands you
    would normally use in Python. To signify the end of the loop, stop indenting statements.
    Notice that the `print("I finished counting!")` isn’t indented, so it’s only printed
    once, after the counting is complete. Python reads the indentation to know when
    you want your loop to start and end.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 和`if`语句一样，`while`循环有一个表达式，它必须是True或False。[图4.14](#ch04fig14)中的例子使用了`count <
    100`。这一行以冒号（`:`）结束，属于循环的后续行应该缩进四个空格。在`while`循环中，你可以使用你通常在Python中使用的任何其他命令。为了表示循环的结束，停止缩进语句。注意，`print("I
    finished counting!")`没有缩进，所以它只会在计数完成后打印一次。Python通过缩进来知道你想要你的循环从哪里开始和结束。
- en: '|  |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can use `if` statements in `while` loops. In your game, you use an `if`
    statement in a `while` loop. Sounds fancy, but you want to check whether the player’s
    guess is correct, and you need to do this repeatedly to give them their five guesses.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`while`循环中使用`if`语句。在你的游戏中，你在一个`while`循环中使用`if`语句。听起来很复杂，但你需要检查玩家的猜测是否正确，并且你需要重复这样做以给他们提供五次猜测机会。
- en: '|  |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Using loops can save you from writing a lot of code. They let you order a computer
    to repeat a series of commands many times. The commands only need to be written
    once in the loop.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 使用循环可以让你避免编写大量的代码。它们让你可以命令计算机重复执行一系列命令多次。命令只需要在循环中写一次。
- en: Breaking out of a while loop
  id: totrans-416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 跳出`while`循环
- en: Sometimes you need to take a break to eat some food or grab a drink. Python
    has a `break` command that lets you break out of a `while` loop early. In this
    example, you want your loop to repeat if the player’s last guess was incorrect.
    If the player guesses the parrot’s age correctly, then you want to break out of
    the loop—even though you haven’t reached the fifth guess, you want to stop looping
    because the player got the answer right.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要休息一下，吃点东西或者喝点饮料。Python有一个`break`命令，它允许你提前跳出`while`循环。在这个例子中，你想要循环重复，如果玩家的最后一次猜测是错误的。如果玩家正确猜出鹦鹉的年龄，那么你想要跳出循环——即使你没有达到第五次猜测，你想要停止循环，因为玩家已经得到了正确答案。
- en: Let’s modify the previous example of counting to 99 so it breaks out of the
    loop when it reaches the number 77\. You’ll use an `if` statement to do this.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前的计数例子，将其改为99，这样当它达到数字77时就会跳出循环。你可以使用一个`if`语句来完成这个操作。
- en: Listing 4.9\. Breaking out of a loop
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.9\. 跳出循环
- en: '![](114fig01_alt.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![](114fig01_alt.jpg)'
- en: Practicing while loops
  id: totrans-421
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习`while`循环
- en: 'Let’s try another example of using a `while` loop to get the hang of how to
    write them: a `while` loop that asks your favorite color. See if you can figure
    out what this program does.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一个使用`while`循环的例子，以熟悉如何编写它们：一个询问你最喜欢的颜色的`while`循环。看看你是否能弄清楚这个程序做了什么。
- en: Listing 4.10\. Favorite colors
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.10\. 最喜欢的颜色
- en: '[PRE26]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This example asks you for your favorite color; if you type in `blue`, it says,
    “Me too! What a coincidence!” and ends. If you don’t input `blue`, the program
    will keep asking you for your favorite color over and over again (until you say
    it’s blue).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子要求你输入你最喜欢的颜色；如果你输入`blue`，它会说，“我也是！真巧！”然后结束。如果你没有输入`blue`，程序会不断地要求你输入你最喜欢的颜色（直到你说它是蓝色）。
- en: Suppose your loop doesn’t produce the output you expect. Maybe the guessing
    game gives you six guesses instead of five. This is when you try to find the problem
    and fix it—a process also called *troubleshooting*. Fixing errors in `while` loops
    can be tricky because there may be many commands in the loop. The commands execute
    quickly, so it can be hard to see what is happening. One troubleshooting technique
    you can use is to add a `print` function in the loop and use it to print out the
    value of a variable such as the counter each time through the loop.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的循环没有产生你预期的输出。也许猜谜游戏给你六次猜测而不是五次。这就是你尝试找出问题并修复它的时候——这个过程也被称为*故障排除*。在`while`循环中修复错误可能很棘手，因为循环中可能有多个命令。命令执行得很快，所以很难看到发生了什么。你可以使用的一种故障排除技术是在循环中添加一个`print`函数，并在每次循环迭代时使用它来打印变量的值，例如计数器。
- en: 'In this example, you might add this line in your loop:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可能会在循环中添加这一行：
- en: '[PRE27]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This prints out the value stored in the `number_of_guesses` variable each time
    the code goes through the loop. You can see whether the counter is incrementing
    as you expect and whether it’s starting with the right number.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在代码每次通过循环时打印出存储在 `number_of_guesses` 变量中的值。您可以看到计数器是否如您预期的那样递增，以及它是否从正确的数字开始。
- en: Using Python code libraries to generate random numbers
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Python 代码库生成随机数
- en: You program should be working great. The player gets five guesses, and if they
    guess the age of the parrot correctly, they win! One exciting part about games
    is their unpredictability—you never know when you might win or lose. Your next
    task is to have the program pick a random number for the Norwegian Blue’s age.
    This will make it more thrilling because even you won’t know the answer!
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 您的程序应该运行得很好。玩家有五次猜测机会，如果他们正确猜出鹦鹉的年龄，他们就会赢！游戏的一个令人兴奋的部分是其不可预测性——您永远不知道您什么时候会赢或输。您的下一个任务是让程序随机选择挪威蓝鹦鹉的年龄。这将使其更加刺激，因为即使您也不知道答案！
- en: If you’ve ever tried to fix a broken bike, toaster, or car, you probably needed
    some tools. Bare hands are good for many things, but they probably weren’t enough
    for the job. Similarly, in Python, the standard tools (your bare hands) aren’t
    enough. Sometimes you need to get a toolbox and take out a big hammer, soldering
    iron, or screwdriver.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经尝试修理过一辆坏自行车、烤面包机或汽车，您可能需要一些工具。赤手空拳可以做好多事情，但可能不足以完成这项工作。同样，在 Python 中，标准工具（您的赤手空拳）也不够用。有时您需要拿一个工具箱，拿出一把大锤、烙铁或螺丝刀。
- en: 'Python has toolboxes as well. These toolboxes are also called *modules*. Each
    toolbox (module) contains different sets of tools (methods) that are useful for
    specific jobs. Here are some examples of common Python modules:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: Python 也有工具箱。这些工具箱也称为 *模块*。每个工具箱（模块）都包含不同集合的工具（方法），这些工具对特定工作很有用。以下是一些常见的 Python
    模块示例：
- en: '`datetime` provides useful tools for getting the current time and date and
    formatting them nicely.'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`datetime` 提供了获取当前时间和日期以及格式化它们的实用工具。'
- en: '`random` gives you the ability to create random numbers.'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`random` 给您创建随机数的能力。'
- en: '`math` supports a larger set of mathematical functions.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`math` 支持更广泛的数学函数。'
- en: '`fileinput` supports reading information from files.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileinput` 支持从文件中读取信息。'
- en: 'Before you can use these toolboxes, you must first carry them into the room,
    like you might grab a toolbox of bike tools to fix a bike. To bring in a toolbox,
    you use the `import` command:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以使用这些工具箱之前，您必须首先将它们带入房间，就像您可能会拿起一个自行车工具箱来修理自行车一样。要引入一个工具箱，您使用 `import` 命令：
- en: '[PRE28]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can add this line anywhere in a program before you need to use it to create
    a random number. Add it right after the comments at the beginning of your game
    program. This brings in the toolbox at the beginning of the program and makes
    it easier for other people who read your code to see what toolboxes (or modules)
    you’re using. What the line is actually doing is loading the toolbox into Python’s
    memory so you can use the tools in your program.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在程序中的任何地方添加此行，在您需要使用它来创建随机数之前。在您的游戏程序开头的注释之后添加它。这将在程序开始时引入工具箱，使其他阅读您代码的人更容易看到您正在使用哪些工具箱（或模块）。这一行实际上是在将工具箱加载到
    Python 的内存中，以便您可以在程序中使用这些工具。
- en: 'Now that you’ve added the toolbox, you can use a tool called `randint` to generate
    a random number between 1 and 20\. This code replaces the line `parrot_age = 19`:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经添加了工具箱，您可以使用一个名为 `randint` 的工具来生成介于 1 和 20 之间的随机数。此代码替换了 `parrot_age =
    19` 这一行：
- en: '[PRE29]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Notice that you enter the name of the toolbox, put a period or dot (`.`), and
    then put the name of the tool you want to use. This particular tool, `randint`,
    needs you to give it two numbers: the lower and upper numbers that the random
    integer should be between. If you wanted a number between 1 and 100, you’d write'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您输入工具箱的名称，然后放一个点（`.`），然后放您想要使用的工具的名称。这个特定的工具 `randint` 需要您提供两个数字：随机整数应该介于的下限和上限。如果您想要一个介于
    1 和 100 之间的数字，您会写
- en: '[PRE30]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With these two lines of code added, the complete code listing should match the
    code in [figure 4.15](#ch04fig15).
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这两行代码后，完整的代码列表应与图 4.15 中的代码相匹配。[图 4.15](#ch04fig15)。
- en: Figure 4.15\. To randomly select a number, you need to import the `random` library
    and use the `randint` function to select a random integer between 1 and 20.
  id: totrans-446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.15。要随机选择一个数字，您需要导入 `random` 库并使用 `randint` 函数来选择介于 1 和 20 之间的随机整数。
- en: '![](04fig15_alt.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![04fig15_alt.jpg](04fig15_alt.jpg)'
- en: Outstanding! You’ve made a Norwegian Blue Guessing Game and learned how to create
    logic in your programs using both `if` statements and `while` loops.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你已经制作了一个挪威蓝猜测游戏，并学会了如何使用 `if` 语句和 `while` 循环在你的程序中创建逻辑。
- en: 'Fruit Picker Extra: Scratch'
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 果实采摘者额外：Scratch
- en: Have you been wondering why your Pi has an icon that is a picture of a cat head?
    That is the icon for Scratch. Developed by the Massachusetts Institute of Technology
    (MIT) to help teach programming, Scratch is a simple program you can use to create
    animations and games on your Raspberry Pi. Scratch is also its own easy-to-use
    programming language that is based on dragging and dropping program blocks.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否好奇为什么你的 Pi 有一个猫头图片的图标？那是 Scratch 的图标。麻省理工学院（MIT）开发 Scratch 是为了帮助教授编程，Scratch
    是一个简单的程序，你可以用它来在你的 Raspberry Pi 上创建动画和游戏。Scratch 还是一种基于拖放程序块的简单易用的编程语言。
- en: Open Scratch by clicking Menu > Programming > Scratch on your Raspbian desktop.
    When Scratch opens, you’ll see a cat in a white square. [Figure 4.16](#ch04fig16)
    shows an overview of the Scratch interface.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击菜单 > 编程 > Scratch 在你的 Raspbian 桌面上打开 Scratch。当 Scratch 打开时，你会看到一个白色方块中的猫。[图
    4.16](#ch04fig16) 展示了 Scratch 界面的概述。
- en: Figure 4.16\. The Scratch interface is divided into an area for sprites to move
    around and a script area. You can create programs for your sprite by dragging
    blocks and connecting them in the script area.
  id: totrans-452
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.16。Scratch 界面分为精灵移动的区域和脚本区域。你可以在脚本区域通过拖放块并连接它们来为你的精灵创建程序。
- en: '![](04fig16_alt.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![图片](04fig16_alt.jpg)'
- en: Scratch can do many things, and we won’t explain them all. You can learn more
    about how to create projects with Scratch by clicking Help > Help Pages. The help
    tells you how to use each block and provides some tutorials.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: Scratch 可以做很多事情，我们不会解释所有内容。你可以通过点击帮助 > 帮助页面来了解更多关于如何使用 Scratch 创建项目的信息。帮助信息告诉你如何使用每个块，并提供了一些教程。
- en: Do you have an idea for a project? As in Python, you can make programs that
    ask for input, display messages, generate random numbers, and use `if` statements
    and loops. You might add a dog sprite and make it sing like a human when you click
    it. Or try creating a Scratch version of your favorite classic videogame.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有项目的想法？就像在 Python 中一样，你可以编写程序来请求输入、显示消息、生成随机数，并使用 `if` 语句和循环。你可能添加一个狗精灵，并在点击它时让它像人一样唱歌。或者尝试创建你最喜欢的经典电子游戏的
    Scratch 版本。
- en: '![](common03.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![图片](common03.jpg)'
- en: Challenges
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战
- en: Let’s play Rock, Paper, Scissors! For this challenge, try to create the classic
    game.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们玩石头、剪刀、布！对于这个挑战，尝试创建经典游戏。
- en: 'Rock, Paper, Scissors is played with your hands. Each person simultaneously
    makes one of three shapes with their hand: the shape of a rock, a piece of paper,
    or a pair of scissors. If two people make the same shape, it’s a tie. The three
    game shapes interact with each other like this:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 石头、剪刀、布是用手玩的。每个人同时用他们的手做出三种形状之一：石头的形状、一张纸或一把剪刀。如果两个人做出相同的形状，则为平局。三种游戏形状相互作用如下：
- en: Rock beats scissors.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 石头胜剪刀。
- en: Paper beats rock.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布胜石头。
- en: Scissors beats paper.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剪刀胜布。
- en: 'Let’s plan how to attack this challenge. Here are some of the key elements:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计划如何应对这个挑战。以下是一些关键要素：
- en: Use a `while` loop to repeatedly ask the player to choose rock, paper, or scissors.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `while` 循环反复要求玩家选择石头、布或剪刀。
- en: 'Create a list of choices:'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个选择列表：
- en: '[PRE31]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Use the `random` library to have the computer randomly choose among the three
    choices (“Rock”, “Paper”, and “Scissors”).
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `random` 库让计算机在三个选择（“石头”，“布”和“剪刀”）之间随机选择。
- en: 'Remember, `randint` selects a random integer. You can select and store the
    random choice in a variable:'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，`randint` 选择一个随机整数。你可以选择并将随机选择存储在变量中：
- en: '[PRE32]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can select different items in the list by using a number representing where
    the item is in the list. This number is called a *list index*. In this case, there
    are three items in the list. The first item has an index of 0, the second item
    has an index of 1, and the third item has an index of 2\. To display the second
    item in the list, you write `print(choices[1])`; the code displays “Paper” on
    the screen.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用表示列表中项目位置的数字来选择列表中的不同项。这个数字被称为 *列表索引*。在这种情况下，列表中有三个项目。第一个项目的索引为 0，第二个项目的索引为
    1，第三个项目的索引为 2。要显示列表中的第二个项目，你写下 `print(choices[1])`；代码会在屏幕上显示“布”。
- en: Use an `if` statement to compare the player’s choice to the computer’s choice
    and let the player know who won.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `if` 语句比较玩家的选择和计算机的选择，并让玩家知道谁赢了。
- en: Ask the player if they want to play again. If so, the loop should repeat; if
    not, the game should end.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 询问玩家是否想要再玩一次。如果是，循环应该重复；如果不是，游戏应该结束。
- en: See if you can come up with a program! See [appendix C](kindle_split_021.html#app03)
    for solutions.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 看看您是否能想出一个程序！参见[附录 C](kindle_split_021.html#app03)以获取解决方案。
- en: Summary
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you’ve learned some new techniques for working with text in
    Python and a few foundational elements for creating logic in your programs:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学习了在 Python 中处理文本的一些新技巧以及创建程序逻辑的一些基础元素：
- en: You can make Python print things just how you want them. String literals allow
    you to create text that spans multiple lines. Use them to make text appear the
    same way you typed it in your programs.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以让 Python 按照您想要的方式打印内容。字符串字面量允许您创建跨越多行的文本。使用它们来使文本以与您在程序中输入的方式相同的方式显示。
- en: You can write intelligent code that can make decisions. `if` statements add
    logic to programs by responding only if a certain condition is True. You can combine
    `if` with `else` statements to make a program do something different if the condition
    is False.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以编写能够做出决定的智能代码。`if` 语句通过仅在特定条件为 True 时做出响应来向程序添加逻辑。您可以将 `if` 与 `else` 语句结合使用，使程序在条件为
    False 时执行不同的操作。
- en: You don’t have to type things repeatedly—you can make Python repeat them for
    you. w`hile` loops can be used to repeat things over and over, as long as a certain
    condition is True. The `break` command lets you exit a `while` loop if you need
    to.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不必重复输入内容——您可以让 Python 为您重复它们。`while` 循环可以用来重复某些内容，只要某个条件为 True。`break` 命令允许您在需要时退出
    `while` 循环。
- en: You can use modules (toolboxes) to access more powerful tools to use in your
    programs. The `random` module has a tool that generates random integers.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用模块（工具箱）来访问更多强大的工具，以便在您的程序中使用。`random` 模块有一个生成随机整数的工具。
- en: Chapter 5\. Raspi’s Cave Adventure
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 5 章\. 拉斯皮洞穴冒险
- en: '**In this chapter, you’ll create a game to learn new programming techniques:**'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '**在本章中，您将创建一个游戏来学习新的编程技术：**'
- en: '*Drawing flow diagrams to map out complex programs*'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制流程图以映射复杂程序*'
- en: '*Using Boolean operators to check input from users*'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用布尔运算符检查用户输入*'
- en: '*Making code for multiple choices using* `if`*,* `elif`*, and* `else` *statements*'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用* `if`*,* `elif`*, 和* `else` *语句制作多选代码*'
- en: '*Creating and using your own functions to organize code and avoid repeating
    code*'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建和使用您自己的函数来组织代码并避免重复代码*'
- en: '*Nesting* `if`*/*`else` *statements to create games with complex logic*'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*嵌套* `if`*/*`else` *语句以创建具有复杂逻辑的游戏*'
- en: Like a great book, a game can create an entire imaginary world in your mind.
    One of the most exciting aspects of games is when you feel like you’re inside
    the game. This doesn’t require virtual-reality goggles or high-definition graphics.
    You can create this immersive feeling even in a completely text-based game by
    connecting with the player’s imagination and creating a world where they can make
    decisions and determine their own fate. To create games with imaginary worlds,
    you often have to generate a sense of depth by having the user move from room
    to room or scene to scene. The game should allow the user to choose their own
    path and introduce elements of surprise. Finally, you should also have some great
    descriptions that make the player feel like they’re in the room.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一本好书一样，一个游戏可以在您的脑海中创造一个完整的虚构世界。游戏中最令人兴奋的方面之一就是您感觉就像身处游戏之中。这不需要虚拟现实眼镜或高清晰度图形。您可以通过与玩家的想象力建立联系，并创造一个他们可以做出决定并决定自己命运的世界，即使在完全基于文本的游戏中也能创造出这种沉浸感。要创建具有虚构世界的游戏，您通常需要通过让用户从一个房间移动到另一个房间或从一个场景移动到另一个场景来产生深度感。游戏应该允许用户选择自己的路径并引入惊喜元素。最后，您还应该有一些出色的描述，让玩家感觉他们就在房间里。
- en: In this chapter, you’ll create just such a game, based on exploring an underground
    cavern. Along the way, the player will have to make choices, and if they make
    a wrong decision, the game is over. If they make the right decision, they’ll find
    untold treasures of gold, rubies, and diamonds!
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将创建这样一个游戏，基于探索地下洞穴。在这个过程中，玩家将不得不做出选择，如果他们做出错误的决定，游戏就结束了。如果他们做出正确的决定，他们将找到无法计数的黄金、红宝石和钻石！
- en: 'Project introduction: Raspi’s Cave Adventure'
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目介绍：拉斯皮洞穴冒险
- en: 'The game is set in medieval days: a time of stone castles, knights with swords,
    and (some say) mythical beasts that breathe fire. Your main character is a young
    boy named Raspi.^([[1](#ch05fn01)]) One day Raspi is out gathering firewood and
    gets lost in the forest. He stumbles upon the entrance to a cave. He peers in
    the entrance and finds that the cave splits into a left tunnel and a right tunnel.
    He remembers a folk tale his grandmother used to tell of a mysterious cave in
    this very forest that holds enormous treasures. It’s said the treasure is guarded
    by a ferocious fire-breathing dragon. Raspi can’t resist the temptation to explore
    the cave; although he knows he should turn back, he walks slowly into the dark
    cavern. This is the start of your next project: Raspi’s Cave Adventure.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏设定在中世纪：一个石头城堡、骑士和剑的时代，以及（有人说）喷火的神话生物。你的主要角色是一个名叫Raspi的年轻男孩。[^([1](#ch05fn01))]
    一天，Raspi外出砍柴时在森林中迷了路。他偶然发现了洞穴的入口。他朝入口看去，发现洞穴分为一个左隧道和一个右隧道。他记得他祖母曾经讲述的一个民间故事，说的是这个森林里有一个神秘的洞穴，里面藏有巨大的宝藏。据说宝藏被一只凶猛的喷火龙守护着。Raspi无法抗拒探索洞穴的诱惑；尽管他知道他应该回头，但他慢慢地走进了黑暗的洞穴。这是你下一个项目的开始：Raspi的洞穴冒险。
- en: ¹
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because this is your game, feel free to make Raspi a girl or a boy.
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因为这是你的游戏，你可以自由地让Raspi成为女孩或男孩。
- en: The game can have many different outcomes, depending on the path the player
    chooses for Raspi. A short sample of the program’s output is shown in [figure
    5.1](#ch05fig01).
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏可以有多种不同的结果，这取决于玩家为Raspi选择的路径。程序输出的一个简短示例显示在[图5.1](#ch05fig01)中。
- en: Figure 5.1\. Raspi’s Cave Adventure requires the player to make decisions about
    which way to go. Based on their choices, the player will meet different fates.
  id: totrans-495
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1。Raspi的洞穴冒险要求玩家决定走哪条路。根据他们的选择，玩家将遇到不同的命运。
- en: '![](05fig01_alt.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![05fig01_alt.jpg](05fig01_alt.jpg)'
- en: Let’s look at a map of the cave to see where the treasure is and also where
    the dragon lives! Because you’re the game designer and developer, you’ll use this
    as a guide to write the code creating the game logic (see [figure 5.2](#ch05fig02)).
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看洞穴的地图，看看宝藏在哪里，龙也住在哪里！因为你是游戏设计师和开发者，你将使用这个作为指南来编写创建游戏逻辑的代码（见[图5.2](#ch05fig02))。
- en: Figure 5.2\. This map of the cave system shows that Raspi will need to make
    many choices. If he makes the wrong ones, it’s game over! But if he makes the
    correct choices, he’ll find the legendary treasure!
  id: totrans-498
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.2。这张洞穴系统的地图显示Raspi将需要做出许多选择。如果他做出了错误的选择，游戏就结束了！但如果他做出了正确的选择，他将找到传说中的宝藏！
- en: '![](05fig02_alt.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![05fig02_alt.jpg](05fig02_alt.jpg)'
- en: Let’s examine the different paths and choices Raspi has in the cave and his
    possible fates. After Raspi enters the entrance to the cave, he can choose to
    go left or right.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Raspi在洞穴中可以选择的不同路径和选择以及他可能的命运。当Raspi进入洞穴的入口后，他可以选择向左或向右走。
- en: Left cave
  id: totrans-501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 左边洞穴
- en: If Raspi goes into the left cave, he’ll find himself near an underground river.
    He’ll need to decide whether to take a boat down the river, swim down the river,
    or walk along the side of the river. If Raspi decides to take the boat, he’ll
    soon learn that it has a hole in it, and he’ll sink (game over). Should Raspi
    choose to avoid the river and walk along its edge, he’ll quickly become distracted
    by his thoughts, trip on a rock, and hit his head (game over). If Raspi is adventurous
    and decides to swim in the river, he’ll make it to the other side and find a hidden
    treasure room filled with riches!
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Raspi进入左边的洞穴，他会发现自己靠近一条地下河流。他需要决定是乘船顺流而下，还是游泳顺流而下，或者沿着河岸行走。如果Raspi决定乘船，他很快就会知道船上有洞，他会沉下去（游戏结束）。如果Raspi选择避开河流并沿着河岸行走，他很快就会被他的思绪分心，踩在石头上，撞到头上（游戏结束）。如果Raspi富有冒险精神并决定在河中游泳，他将到达对岸，并发现一个藏有丰富宝藏的隐藏宝库！
- en: Right cave
  id: totrans-503
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 右边洞穴
- en: 'If Raspi decides to go into the right cave, he’ll need to decide whether to
    climb down into a hole using a rope or walk toward what appears to be a torch.
    After walking toward the torch, Raspi will enter a cave full of crystals. The
    crystal cave sounds promising, but unfortunately a crystal will fall from the
    ceiling, ending Raspi’s life (game over). Alternatively, if Raspi uses the rope
    and goes down the hole, he’ll find himself in the dragon’s lair with a final choice:
    whether to fight the dragon or go into a dark room. If Raspi fights the dragon,
    the dragon will eat him; but if Raspi heads toward the dark room, he’ll discover
    that it’s filled with thousands of gold coins, rubies, and diamonds. Raspi is
    rich and very much alive!'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Raspi决定进入右边的洞穴，他需要决定是使用绳子爬进洞里还是走向看起来像火炬的东西。在走向火炬之后，Raspi将进入一个满是晶体的洞穴。晶体洞穴听起来很有希望，但不幸的是，一个晶体将从天花板落下，结束Raspi的生命（游戏结束）。或者，如果Raspi使用绳子并从洞里下去，他会在龙穴中发现自己，面临最后的抉择：是和龙战斗还是进入一个黑暗的房间。如果Raspi和龙战斗，龙会吃掉他；但如果Raspi走向黑暗的房间，他会发现里面装满了成千上万的金币、红宝石和钻石。Raspi变得富有，而且非常健康！
- en: Hey wait, you need a plan (flow diagrams)
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嘿，等等，你需要一个计划（流程图）
- en: Your goal is to create a program that allows the player to make multiple decisions.
    You have a map of the cave; now you need to make that map into a diagram that
    can guide you as you write the code for the game. Much as you did in [chapter
    2](kindle_split_010.html#ch02), you’ll lay out the logic of the game and then
    write the code to create that logic.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标是创建一个允许玩家做出多个决策的程序。你有一张洞穴地图；现在你需要将这张地图变成一个可以指导你编写游戏代码的图表。就像你在[第2章](kindle_split_010.html#ch02)中所做的那样，你将布置游戏的逻辑，然后编写代码来创建这种逻辑。
- en: You can make a map that also functions as a flow diagram. You can visualize
    the set of decisions and the outcome of each decision. [Figure 5.3](#ch05fig03)
    shows the map of the cave as a flow diagram.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以制作一个既是一张地图又是一个流程图的图表。你可以可视化决策集和每个决策的结果。[图5.3](#ch05fig03)显示了洞穴地图作为流程图。
- en: Figure 5.3\. The flow diagram for Raspi’s Cave Adventure shows the various decisions
    the player can make and their outcomes. It’s a map of the logic of the game, and
    it can guide you as you program that logic.
  id: totrans-508
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3\. Raspi的洞穴冒险流程图显示了玩家可以做出的各种决策及其结果。它是游戏逻辑的地图，可以在你编程逻辑时为你提供指导。
- en: '![](05fig03_alt.jpg)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig03_alt.jpg)'
- en: Each decision in the diagram is represented by a diamond shape. Inside the diamond
    is the question at hand. Outside the diamond are arrows representing the possible
    choices available and the result of each choice. Sometimes choices lead to other
    choices (other diamonds). Other times, a choice leads to winning the game or game
    over!
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中的每个决策都由一个菱形形状表示。菱形内部是当前的问题。菱形外部是表示可能选择及其结果的箭头。有时选择会引出其他选择（其他菱形）。有时，一个选择会导致赢得游戏或游戏结束！
- en: Flow diagrams follow a few simple rules (see [figure 5.4](#ch05fig04)). You
    can construct one for any set of decisions, including those used by games, robots,
    and apps.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 流程图遵循一些简单的规则（见[图5.4](#ch05fig04)）。你可以为任何决策集构建一个流程图，包括游戏、机器人和应用程序中使用的决策集。
- en: Figure 5.4\. Flow diagrams are ways to visually show the logic of a program.
    They represent decisions, choices, and activities using diamonds, arrows, and
    boxes. This example shows a flow diagram for a program that turns on a light if
    a button is pressed.
  id: totrans-512
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.4\. 流程图是展示程序逻辑的视觉方式。它们使用菱形、箭头和方框来表示决策、选择和活动。这个例子展示了一个当按钮被按下时打开灯的程序流程图。
- en: '![](05fig04.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig04.jpg)'
- en: 'A flow diagram is a great way to organize your thoughts and break down complex
    problems into a series of simple steps. Remember the Python way: simple is better
    than complex.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 流程图是组织思路和将复杂问题分解成一系列简单步骤的绝佳方式。记住Python的方式：简单比复杂好。
- en: Which way should Raspi go? (checking input)
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Raspi该走哪条路呢？（检查输入）
- en: With your diagram in hand, the first bit of logic is the user choosing whether
    to go left or right. Let’s display text to tell the player what they see in the
    cave, and then prompt them to enter a choice. You prompt the user and collect
    information with the `input` function.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 拿着你的图表，第一部分的逻辑是用户选择是向左走还是向右走。让我们显示文本来告诉玩家他们在洞穴中看到的东西，然后提示他们输入一个选择。你使用`input`函数提示用户并收集信息。
- en: Listing 5.1\. Choosing the left or right cave
  id: totrans-517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.1\. 选择左边的洞穴或右边的洞穴
- en: '![](126fig01_alt.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![图片](126fig01_alt.jpg)'
- en: This example uses the `input` function and then an `if`/`else` statement to
    create the logic you want. The code asks the user to make a choice by typing `L`
    or `R`. The `if` statement checks whether the user’s choice equals “L”. If True,
    then the code displays a message that the player entered the left cave. If their
    choice isn’t equal to L (if that condition is False), then the program moves to
    the `else` statement and displays a message that the player entered the right
    cave.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用 `input` 函数和 `if`/`else` 语句来创建所需的逻辑。代码要求用户通过输入 `L` 或 `R` 来做出选择。`if` 语句检查用户的选项是否等于“L”。如果是
    True，则代码显示玩家进入了左洞。如果他们的选择不等于 L（如果该条件为 False），则程序转到 `else` 语句并显示玩家进入了右洞。
- en: Handling unexpected input
  id: totrans-520
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理意外输入
- en: 'Users often do unexpected things. As a programmer, one thing you have to be
    thinking about is what happens if the user does something you don’t expect. The
    person playing your game can type in whatever they want. Let’s examine some different
    possibilities and see what would happen:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 用户经常做一些意外的事情。作为一名程序员，你必须思考的一件事是，如果用户做了你预料之外的事情会发生什么。玩你的游戏的人可以输入他们想要的任何内容。让我们检查一些不同的可能性，看看会发生什么：
- en: What if the user types in `l` (lowercase `L`)? If the user types in `l`, the
    program checks (evaluates) whether “l” is equal to “L”. Because these two strings
    are different, this condition is False. The program will execute the `else` statement
    and display a message that the user entered the right cave.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入 `l`（小写的 `L`）会怎样？如果用户输入 `l`，程序将检查（评估）“l”是否等于“L”。因为这两个字符串不同，这个条件是 False。程序将执行
    `else` 语句并显示用户输入了右洞的消息。
- en: What if the user types in `left`? If the user types in `left`, the program evaluates
    whether “left” is equal to “L”. Because these two strings are different, this
    condition is False. The program will execute the `else` statement and display
    a message that the user entered the right cave.
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入 `left` 会怎样？如果用户输入 `left`，程序将评估“left”是否等于“L”。因为这两个字符串不同，这个条件是 False。程序将执行
    `else` 语句并显示用户输入了右洞的消息。
- en: What if the user types in something like `44992` or `banana` just to be silly?
    The program checks whether “44992” or “banana” is equal to “L”. Because neither
    of these equals “L”, this condition is False. The program will execute the `else`
    statement and display a message that the user entered the right cave.
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入类似 `44992` 或 `banana` 这样愚蠢的内容会怎样？程序检查“44992”或“banana”是否等于“L”。因为这两个都不等于“L”，这个条件是
    False。程序将执行 `else` 语句并显示用户输入了右洞的消息。
- en: What if the user enters anything except `L`? You guessed it; they will see a
    message that they entered the right cave.
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入除 `L` 之外的内容会怎样？你猜对了；他们将看到一条消息，表明他们输入了右洞。
- en: 'This isn’t ideal. Let’s improve the code as follows:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不理想。让我们按如下方式改进代码：
- en: '**1**.  Permit the user to enter `L` or `l` as well as `Left` or `left` to
    enter the left cave.'
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  允许用户输入 `L` 或 `l`，以及 `Left` 或 `left` 来进入左洞。'
- en: '**2**.  Permit the user to enter `R` or `r` as well as `Right` or `right` to
    enter the right cave.'
  id: totrans-528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  允许用户输入 `R` 或 `r`，以及 `Right` 或 `right` 来进入右洞。'
- en: '**3**.  Take care of anything else by having the game scold the user for entering
    the wrong thing and end the game in a humorous way. Maybe a stalactite could fall
    from the ceiling or a cave spider could bite them!'
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  通过让游戏对用户输入错误的内容进行斥责并以幽默的方式结束游戏来处理其他任何问题。也许天花板上的钟乳石会掉下来，或者洞穴蜘蛛会咬他们！'
- en: To create this behavior, you need to introduce the Boolean `or` operator. You
    also need to convert the input information to all uppercase letters using Python’s
    `upper()` method. Finally, to handle all three possible outcomes, you’ll use a
    new `if`/`elif`/`else` statement (see [listing 5.2](#ch05ex02)).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这种行为，你需要引入布尔 `or` 运算符。你还需要使用 Python 的 `upper()` 方法将输入信息转换为大写字母。最后，为了处理所有三种可能的结果，你将使用一个新的
    `if`/`elif`/`else` 语句（见 [列表 5.2](#ch05ex02)）。
- en: '|  |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Methods**'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法**'
- en: '*Methods* are functions that only work on specific types of Python things,
    which programmers call *objects*. In this example, `.upper()` is only able to
    work on strings, so it’s called a *string method*. Methods are called differently
    than other functions. Methods use *dot notation*, which means you type the name
    of the thing (object) and then put a dot (`.`) and the method.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法* 是仅对特定类型的 Python 对象（程序员称之为 *对象*）起作用的函数。在这个例子中，`.upper()` 只能作用于字符串，因此被称为
    *字符串方法*。方法的调用方式与其他函数不同。方法使用 *点表示法*，这意味着你输入对象（对象）的名称，然后输入一个点（`.`）和方法。'
- en: 'Here are some examples:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例：
- en: '`"Left".upper()` produces “LEFT”.'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Left".upper()`产生“LEFT”。'
- en: '`"riGHt".lower()` makes “right”.'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"riGHt".lower()`变为“right”。'
- en: '|  |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Here’s the updated code to apply these new ways to avoid errors in user input.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是更新后的代码，以应用这些新方法来避免用户输入错误。
- en: Listing 5.2\. Improving the code for the player’s choice
  id: totrans-539
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.2.改进玩家选择的代码
- en: '![](128fig01_alt.jpg)'
  id: totrans-540
  prefs: []
  type: TYPE_IMG
  zh: '![图片](128fig01_alt.jpg)'
- en: The `upper()` method converts the input text to all uppercase. If the user enters
    `LEFT`, `LeFt`, `left`, or `Left`, the string is converted to “LEFT”.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '`upper()`方法将输入文本转换为大写。如果用户输入`LEFT`、`LeFt`、`left`或`Left`，字符串将被转换为“LEFT”。'
- en: 'The Boolean or operator: checking whether either one is True'
  id: totrans-542
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 布尔或运算符：检查任一是否为真
- en: The `or` operator checks whether one condition or another condition is True.
    This gives your code more flexibility—it’s able to accept more than one input
    and still proceed. If either one is True, the `if` statement is True, and Python
    does whatever is indented under the `if` statement.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '`or`运算符检查是否有一个条件或另一个条件为真。这使你的代码更具灵活性——它能够接受多个输入并继续执行。如果任一为真，则`if`语句为真，Python会执行`if`语句下缩进的任何操作。'
- en: elif is short for else if
  id: totrans-544
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`elif`是`else if`的缩写。'
- en: The `elif` statement is short for `else if`. It checks whether another condition
    is True. Think of it like a multiple-choice question. If the user doesn’t enter
    `L` or `Left`, the program moves on to the next option. If the user doesn’t enter
    `R` or `r`, the program moves to the `else` statement and drops a stalactite on
    their head. Game over! Take a closer look at the `if`/`elif`/`else` statement
    in [figure 5.5](#ch05fig05) to see how to make one.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '`elif`语句是`else if`的缩写。它检查另一个条件是否为真。把它想象成一个多项选择题。如果用户没有输入`L`或`Left`，程序就会转到下一个选项。如果用户没有输入`R`或`r`，程序就会转到`else`语句，并在他们的头上掉下一块钟乳石。游戏结束！更仔细地看看[图5.5](#ch05fig05)中的`if`/`elif`/`else`语句，看看如何创建一个。'
- en: Figure 5.5\. The `if` statement can come in many flavors. This is an `if` statement
    with two `elif`s and an `else`. It creates logic in the code that can do many
    different things depending on the user’s input. In this case, you’re having a
    player guess the age of a parrot. The program will tell them if their guess is
    too low, too high, correct, or invalid.
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.5.`if`语句可以有多种形式。这是一个带有两个`elif`和一个`else`的`if`语句。它创建了代码中的逻辑，可以根据用户的输入执行许多不同的事情。在这种情况下，你让玩家猜测鹦鹉的年龄。程序会告诉他们他们的猜测是太高、太低、正确还是无效。
- en: '![](05fig05_alt.jpg)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig05_alt.jpg)'
- en: Notice that you can have more than one `elif` statement. In fact, you can have
    as many as you want. With the `if`/`elif` statement, you can create the logic
    needed for your cave.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以有多个`elif`语句。实际上，你可以有任意多个。使用`if`/`elif`语句，你可以创建你的洞穴所需的逻辑。
- en: '|  |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Boolean logic operators: `and`, `or`, and `not`**'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '**布尔逻辑运算符：`and`、`or`和`not`**'
- en: 'Python has a complete set of Boolean operators that you can use to make expressions:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一套完整的布尔运算符，你可以用来构造表达式：
- en: '`or` is used when you want the expression to be True if either of the operands
    is True.'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你希望表达式在任一操作数为真时为真时，使用`or`。
- en: '`and` is used when you want the expression to be True only if both operands
    are True.'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你希望表达式仅在两个操作数都为真时为真时，使用`and`。
- en: '`not` is used to change an operand from True to False or False to True.'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not`用于将操作数从真变为假或从假变为真。'
- en: Let’s look at a few examples using these operators.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用这些运算符的一些示例。
- en: '**`and` OPERATOR**'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '**`and`运算符**'
- en: 'Pretend you want to create a program giving you access to the system only if
    your name *and* password are *both* correct. You could write this using the `and`
    operator:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要创建一个程序，只有当你的用户名和密码*都*正确时，才能访问系统。你可以使用`and`运算符来编写这个程序：
- en: '[PRE33]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Only if both `name` and `password` are correct will the program grant you access.
    Try creating one yourself!
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当`name`和`password`都正确时，程序才会授予你访问权限。试着创建一个自己的吧！
- en: '**`or` OPERATOR**'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**`or`运算符**'
- en: 'Next let’s imagine you want to create a program giving someone a free pizza
    if their age is under 20 *or* they have a coupon. Let’s assume you have a variable
    `age` that is the age of the person and another variable `coupon` that already
    holds a value of True or False. Using the `or` operator, you create this logic
    like so:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们想象你想要创建一个程序，如果某人的年龄小于20岁或他们有优惠券，就会免费送他们披萨。假设你有一个变量`age`，它是人的年龄，另一个变量`coupon`已经持有真或假的值。使用`or`运算符，你可以创建如下逻辑：
- en: '[PRE34]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If *either* is True, the user gets a pizza. If *both* are True, they get a pizza.
    If *neither* is True, then no free pizza!
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*任一*为真，用户就会得到披萨。如果*两者*都为真，他们就会得到披萨。如果*两者*都不为真，那么就没有免费的披萨！
- en: '**`not` OPERATOR**'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '**`not` 运算符**'
- en: 'Finally, let’s say you have a variable `is_absent` that is equal to True or
    False. `is_absent` tells you whether a student is present or absent. To print
    a “Welcome to school!” message if a student is *not* absent, you can use the `not`
    operator:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，假设你有一个等于 True 或 False 的变量 `is_absent`。`is_absent` 告诉你学生是否在场。如果你想要打印一个“欢迎来到学校！”的消息，如果学生没有缺席，你可以使用
    `not` 运算符：
- en: '[PRE35]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `not` operator changes a variable or statement that is True to False and
    a False one to True. It helps you create conditional statements (`if` statements)
    that make more sense when you read the code. As you can see, the Boolean operators
    give you many different options for creating logical expressions.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '`not` 运算符将一个为 True 的变量或语句转换为 False，将一个为 False 的转换为 True。它帮助你创建当你阅读代码时更有意义的条件语句（`if`
    语句）。正如你所见，布尔运算符为你提供了创建逻辑表达式的多种不同选项。'
- en: '|  |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Time to go spelunking (a fancy word for exploring caves) with your new knowledge
    of `if`/`elif`/`else` and Boolean operators!
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候用你新学的 `if`/`elif`/`else` 和布尔运算符去洞穴探险（这是一个探索洞穴的时髦词）了！
- en: Turning flow diagrams into code
  id: totrans-570
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将流程图转换为代码
- en: 'For now, let’s concentrate on building a program for the left cave. The player
    has entered the left cave and needs to make their next choice. Looking at the
    map and the flow diagram, the next thing your player encounters is an underground
    stream. The player sees a boat and must choose among three options:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们集中精力为左边的洞穴编写一个程序。玩家已经进入了左边的洞穴，需要做出下一步的选择。查看地图和流程图，玩家接下来遇到的是一条地下溪流。玩家看到一艘船，必须在三个选项中进行选择：
- en: Keep walking along the side of the river.
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿着河岸继续前行。
- en: Climb into the boat.
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登上船。
- en: Swim in the river.
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在河里游泳。
- en: Each of these will be an `if` or `elif` statement in your code. But wait! There’s
    a fourth possible outcome—that they don’t enter one of the three choices. You’ll
    make this the `else` statement. [Figure 5.6](#ch05fig06) shows the left cave flow
    diagram and the code that creates the logic you need.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都将是你的代码中的 `if` 或 `elif` 语句。但是等等！还有一个第四种可能的结果——他们没有选择这三个选项之一。你将这个作为 `else`
    语句。![图 5.6](#ch05fig06) 显示了左边的洞穴流程图和创建所需逻辑的代码。
- en: Figure 5.6\. The left cave has a stream inside it, and the user has three choices
    of what to do next. In the code, you create an `if` statement followed by two
    `elif` statements to cover each of the options. The `else` statement is used to
    control what happens if the user inputs something other than one of the three
    choices.
  id: totrans-576
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.6。左边的洞穴内部有一条溪流，用户有三个下一步行动的选择。在代码中，你创建一个 `if` 语句，后面跟着两个 `elif` 语句，以涵盖每个选项。`else`
    语句用于控制如果用户输入了除了三个选项之外的任何内容会发生什么。
- en: '![](05fig06_alt.jpg)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig06_alt.jpg)'
- en: You display a few words about what Raspi sees inside the left cave. You ask
    the user to choose what to do next. Then, once you’ve gathered this input, you
    evaluate that information and respond accordingly. Notice that each of the possible
    choices appears in an `if` or `elif` statement and is indented under the left
    cave `if` statement. The user has to choose whether to keep walking (`W`), use
    the boat (`B`), or swim (`S`). For each case, the program should display information
    as you designed it in your flow diagram.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 你显示一些关于 Raspberry Pi 在左边的洞穴内看到的内容的文字。你要求用户选择下一步要做什么。然后，一旦你收集了这些输入，你就评估这些信息并相应地做出回应。注意，每个可能的选项都出现在一个
    `if` 或 `elif` 语句中，并且缩进在左边的洞穴 `if` 语句之下。用户必须选择是继续前行（`W`）、使用船（`B`）还是游泳（`S`）。对于每种情况，程序应该显示你根据流程图设计的信息。
- en: '|  |'
  id: totrans-579
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This isn’t only for caves**'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '**这不仅仅适用于洞穴**'
- en: 'Boolean operators and `if`/`elif`/`else` statements are great for when your
    program needs multiple options or choices. Let’s see if you can create a program
    that has four possible options: A, B, C, and none of the above. The following
    snippet shows an example of using `elif` statements to create these four possible
    outcomes. In this example, you’re pretending that a person is on a game show and
    picking a door with a prize behind it:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算符和 `if`/`elif`/`else` 语句非常适合当你的程序需要多个选项或选择时。看看你能否创建一个有四个可能选项的程序：A、B、C 和以上皆非。以下代码片段展示了使用
    `elif` 语句创建这四种可能结果的一个示例。在这个例子中，你假装一个人在参加一个游戏节目，选择一个后面有奖品背后的门：
- en: '[PRE36]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Creating programs with choices based on logic is a powerful programming skill.
    By combining simple choices, you can create complex programs.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 基于逻辑创建带有选择的程序是一种强大的编程技能。通过组合简单的选择，你可以创建复杂的程序。
- en: '|  |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Excellent work! You’ve created the left cave logic for Raspi’s Cave Adventure.
    Let’s add more decisions.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的工作！你已经为Raspi的洞穴冒险创建了左侧洞穴的逻辑。让我们添加更多的决策。
- en: Simplify! Making your own functions
  id: totrans-586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化！创建自己的函数
- en: Yikes! The code for the left cave is starting to look long (and kind of ugly
    and hard to read), and you still have the right cave to go. How can you simplify
    your program?
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！左侧洞穴的代码开始看起来很长（而且有点丑陋和难以阅读），你还有右侧洞穴要处理。你如何简化你的程序？
- en: The answer is *functions*. This time you aren’t going to call a built-in Python
    function—you’ll make your own!
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是*函数*。这次你不会调用内置的Python函数——你将创建自己的函数！
- en: Functions are like mini programs that you can create to organize or simplify
    your code. When you have long programs, you can take logical chunks of code (code
    that all goes together) and put them in a function. Once you’ve created (or defined)
    a function, you can call (or use) the function in your code.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 函数就像你可以创建的小型程序，用于组织或简化你的代码。当你有很长的程序时，你可以将逻辑代码块（所有代码都放在一起）放入函数中。一旦你创建（或定义）了一个函数，你就可以在代码中调用（或使用）该函数。
- en: '|  |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-591
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Functions should always be defined at the top of a program. The definition of
    a function must come before it’s called (or used).
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应该始终在程序顶部定义。函数的定义必须在其被调用（或使用）之前。
- en: '|  |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s see how this works by making (or defining) two functions for the left
    cave.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过为左侧洞穴创建（或定义）两个函数来看看这是如何工作的。
- en: Listing 5.3\. Creating functions for the left cave
  id: totrans-595
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.3\. 为左侧洞穴创建函数
- en: '![](134fig01_alt.jpg)'
  id: totrans-596
  prefs: []
  type: TYPE_IMG
  zh: '![图134的替代](134fig01_alt.jpg)'
- en: 'Before moving on, let’s look more closely at how you can make your own functions
    (see [figure 5.7](#ch05fig07)). You’ve created two functions: `left_cave` and
    `wrong_answer`. Let’s rewrite the cave program to use (or call) those functions.
    Whenever you call a function, it’s as if the code is all in that spot, but you’ve
    hidden it.'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们更仔细地看看你如何创建自己的函数（见[图5.7](#ch05fig07)）。你已经创建了两个函数：`left_cave`和`wrong_answer`。让我们重写洞穴程序以使用（或调用）这些函数。每次你调用一个函数时，就好像代码都在那个地方，但你将其隐藏了。
- en: Figure 5.7\. Functions simplify your code and can reduce repetition. Use the
    `def` keyword to create a new function, and indent the function code under it.
    If you need a function to return a value, include a `return` statement in the
    function.
  id: totrans-598
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.7\. 函数简化你的代码并可以减少重复。使用`def`关键字创建一个新函数，并在其下缩进函数代码。如果你需要一个函数返回一个值，请在函数中包含一个`return`语句。
- en: '![](05fig07_alt.jpg)'
  id: totrans-599
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7的替代](05fig07_alt.jpg)'
- en: 'Some functions need to return something; others don’t. You might have a function
    that prints something to the screen or plays a sound; those types of functions
    don’t need to return anything. In the example code, the `wrong_answer()` function
    is a good example. You call the function like this:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数需要返回某些内容；而另一些则不需要。你可能有一个打印屏幕或播放声音的函数；这些类型的函数不需要返回任何内容。在示例代码中，`wrong_answer()`函数是一个很好的例子。你可以这样调用函数：
- en: '[PRE37]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Alternatively, when a function returns something and you want to store that
    information, you write it like this:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，当函数返回某些内容并且你想存储这些信息时，你可以这样写：
- en: '[PRE38]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This takes whatever information is returned by calling the `left_cave()` function
    and stores it in a variable named `choice`. [Listing 5.4](#ch05ex04) shows how
    you can simplify the program by calling the `left_cave()` and `wrong_answer()`
    functions.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 这将存储调用`left_cave()`函数返回的任何信息，并将其存储在名为`choice`的变量中。[列表5.4](#ch05ex04)显示了如何通过调用`left_cave()`和`wrong_answer()`函数来简化程序。
- en: Listing 5.4\. Using the new functions to simplify your code
  id: totrans-605
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.4\. 使用新函数简化你的代码
- en: '![](ch05ex04-0.jpg)'
  id: totrans-606
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7的替代](ch05ex04-0.jpg)'
- en: '![](ch05ex04-1.jpg)'
  id: totrans-607
  prefs: []
  type: TYPE_IMG
  zh: '![图5.7的替代](ch05ex04-1.jpg)'
- en: Amazing! The resulting code is easier to read, and you avoid repeating code.
    Notice that you call the `wrong_answer()` function twice. This saves you from
    having to write those lines of code twice. Also, if you ever want to change the
    ending for a wrong answer, you only have to change it in one place (in the function).
    In addition to helping you organize your code, the ability to reuse functions
    is one of their key features. You haven’t changed the functionality of your program,
    but by using functions, you’ve made it easier to read and simplified it.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！生成的代码更容易阅读，你避免了代码重复。注意，你调用了`wrong_answer()`函数两次。这让你不必两次编写这些代码行。此外，如果你想要更改错误答案的结尾，你只需在一个地方更改（在函数中）。除了帮助你组织代码外，能够重用函数是它们的关键特性之一。你没有改变程序的功能，但通过使用函数，你使代码更容易阅读并简化了它。
- en: '|  |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Definition
  id: totrans-610
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: '*Refactoring* is a programming technique that focuses on reorganizing and simplifying
    code in a program. Refactoring makes the code easier to read and less complex.'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '*重构* 是一种编程技术，它专注于重新组织和简化程序中的代码。重构使代码更容易阅读且更简单。'
- en: '|  |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Passing parameters: functions with inputs**'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '**传递参数：具有输入的函数**'
- en: 'You’ve looked at two different functions so far: one that doesn’t return anything
    and one that does. Functions have another feature in addition to their ability
    to return something—they can also receive information. Think of it as input to
    a function. In programming speak, you say that the function has a *parameter*
    or *parameters*. Let’s see how this works with an example. Suppose you have a
    guessing game, and you want to create a function that prints a message to the
    screen telling the player if their guess is too high, too low, or spot on:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了两个不同的函数：一个不返回任何内容，另一个返回内容。除了能够返回某些内容的能力之外，函数还具有另一个特性——它们也可以接收信息。将其视为函数的输入。在编程术语中，你说该函数有一个
    *参数* 或 *参数*。让我们通过一个例子来看看这是如何工作的。假设你有一个猜谜游戏，你想创建一个函数，该函数会在屏幕上打印一条消息，告诉玩家他们的猜测是太高、太低还是准确无误：
- en: '[PRE39]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this case, the `def` statement has the name of your function (`check_guess`).
    Inside the parentheses are two parameters separated by a comma: these are inputs
    to the function. The first input or parameter is `guess`. This is a guess the
    user has made. The second is `answer`, which is the number the user is trying
    to guess. The function then compares `guess` and `answer` and tells the user whether
    they were right or guessed too low or too high. The great thing about this function
    is that it can work with any numeric guess and answer (1 to 10, 1 to 1,000,000).
    By using parameters, you make the code more flexible.'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`def` 语句具有你的函数名称（`check_guess`）。在括号内是两个用逗号分隔的参数：这些是函数的输入。第一个输入或参数是 `guess`。这是用户所做的猜测。第二个是
    `answer`，这是用户试图猜测的数字。然后函数比较 `guess` 和 `answer` 并告诉用户他们是否正确或猜测得太低或太高。这个函数的伟大之处在于它可以与任何数值猜测和答案（1
    到 10，1 到 1,000,000）一起工作。通过使用参数，你使代码更加灵活。
- en: '|  |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The best way to learn about functions is by doing. Here are some functions
    dos:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 了解函数的最佳方式是通过实践。以下是一些函数的要点：
- en: Use a simple name that describes the function.
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个描述函数的简单名称。
- en: Put comments about your function inside the function.
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部添加关于你的函数的注释。
- en: Return values when you want to use them in a program.
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想在程序中使用它们时返回值。
- en: 'And here are some functions don’ts:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些函数的禁忌：
- en: Use complex names.
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用复杂的名称。
- en: Create functions with only one line of code.
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建只有一行代码的函数。
- en: Forget to put a colon at the end of the `def` statement.
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忘记在 `def` 语句的末尾放置冒号。
- en: Forget to call the function in your main program.
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的主程序中忘记调用函数。
- en: Fantastic programming! You’re achieving the Zen of Python by simplifying your
    code with functions.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的编程！你通过使用函数简化代码，正在实现 Python 的禅意。
- en: Finishing the left cave
  id: totrans-629
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 完成左侧洞穴
- en: 'To complete the left cave, you need to add code for Raspi’s choices: walking
    along the river’s edge, taking the boat, or swimming (the winning ending). You’ll
    make each of these choices its own function to help organize your code and keep
    it uncluttered. You can call the functions in the main program, shown in the next
    listing.'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成左侧洞穴，你需要为 Raspi 的选择添加代码：沿着河岸行走、乘船或游泳（获胜的结局）。你将使每个选择都成为自己的函数，以帮助组织你的代码并保持其整洁。你可以在主程序中调用这些函数，如下一列表所示。
- en: Listing 5.5\. Calling functions for each of the left cave choices
  id: totrans-631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5\. 为左侧洞穴选择调用函数
- en: '![](ch05ex05-0.jpg)'
  id: totrans-632
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex05-0.jpg)'
- en: '![](ch05ex05-1.jpg)'
  id: totrans-633
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex05-1.jpg)'
- en: See the source code for [chapter 5](#ch05) for examples of each of these functions
    (`walk()`, `boat()`, and `swim()`). They follow a structure similar to the `left_cave()`
    and `wrong_answer()` functions. Feel free to make up your own descriptions of
    what happens to Raspi or change the outcomes to how you would like them.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [第 5 章](#ch05) 的源代码，以了解这些函数（`walk()`、`boat()` 和 `swim()`）的示例。它们的结构类似于 `left_cave()`
    和 `wrong_answer()` 函数。你可以自由地编写关于 Raspi 发生的事情的描述，或者将结果更改为你希望的方式。
- en: Exploring the right cave
  id: totrans-635
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 探索右侧洞穴
- en: 'In this game, Raspi has two initial cave choices: left or right. Programming
    the right cave is similar to the left cave. Once again, you’ll use the map and
    flow diagram as your guides. Let’s add the logic for the right cave, which starts
    with the user finding a hole in the ground (see [figure 5.8](#ch05fig08)).'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，Raspi 有两个初始洞穴选择：左或右。编程右洞穴与左洞穴类似。再次使用地图和流程图作为你的指南。让我们添加右洞穴的逻辑，它从用户在地面上找到一个洞开始（见[图
    5.8](#ch05fig08)）。
- en: Figure 5.8\. The right cave consists of a series of decisions. One wrong move,
    and certain death awaits Raspi. If the user makes the right choices, Raspi will
    find the treasure. The code uses `if`/`elif`/`else` statements and functions.
    See the code files for [chapter 5](#ch05) for examples of the functions.
  id: totrans-637
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.8\. 右洞穴由一系列决策组成。一步走错，Raspi 就会面临死亡。如果用户做出正确的选择，Raspi 将找到宝藏。代码使用 `if`/`elif`/`else`
    语句和函数。请参阅[第 5 章](#ch05)的代码文件以获取函数的示例。
- en: '![](05fig08_alt.jpg)'
  id: totrans-638
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8_替代](05fig08_alt.jpg)'
- en: The right cave uses logic similar to that of the left cave. You’ll use `if`,
    `elif`, and `else` statements to handle all the possible choices. As with the
    left cave, notice that you indent the `if`/`elif`/`else` statements under the
    other `if` statements to create the logic you desire. *Nesting* is the name given
    to indenting one set of `if` statements inside another. The technique of nesting
    `if` statements is useful when you have logic that you want executed only if a
    prior condition is True. In this case, you only want to give the user the choice
    of fighting the dragon if they have already decided to climb down into the hole
    using the rope. The logic now matches the flow diagram for the game.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 右洞穴使用与左洞穴类似的逻辑。你将使用 `if`、`elif` 和 `else` 语句来处理所有可能的选择。与左洞穴一样，请注意，你将在其他 `if`
    语句下缩进 `if`/`elif`/`else` 语句以创建你想要的逻辑。*嵌套*是指在一组 `if` 语句内部缩进另一组。当你的逻辑需要在先前的条件为真时才执行时，嵌套
    `if` 语句的技术很有用。在这种情况下，你只想在用户已经决定使用绳子爬进洞中时才给用户选择与龙战斗的机会。现在的逻辑与游戏的流程图相匹配。
- en: Let’s take another look at nesting using a different example. Imagine that you
    want to write a program that displays a secret message after you enter the correct
    secret name (“Tim”) and correct secret password (“raspberrypi”). If the secret
    name is guessed correctly, then the user has to guess the secret password (see
    [figure 5.9](#ch05fig09)) to see the secret message.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过另一个不同的例子再次看看嵌套。想象一下，你想编写一个程序，在输入正确的秘密名称（“Tim”）和正确的秘密密码（“raspberrypi”）后显示一个秘密信息。如果秘密名称猜对了，那么用户必须猜测秘密密码（见[图
    5.9](#ch05fig09)）才能看到秘密信息。
- en: Figure 5.9\. if statements can be nested within other `if` statements. In this
    case, the user is only prompted to guess the password if they first guess the
    secret name correctly. Python uses indentation to figure out what statements belong
    together and which `if` statements are nested within other ones.
  id: totrans-641
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.9\. `if` 语句可以嵌套在其他 `if` 语句中。在这种情况下，只有当用户首先正确猜出秘密名称时，才会提示用户猜测密码。Python 使用缩进来确定哪些语句属于一组，以及哪些
    `if` 语句嵌套在其他语句中。
- en: '![](05fig09_alt.jpg)'
  id: totrans-642
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9_替代](05fig09_alt.jpg)'
- en: If the password is correct, the user has to enter their favorite color. If the
    color is red, the program will display the secret message (see [figure 5.9](#ch05fig09)).
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 如果密码正确，用户必须输入他们最喜欢的颜色。如果颜色是红色，程序将显示秘密信息（见[图 5.9](#ch05fig09)）。
- en: Troubleshooting
  id: totrans-644
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 故障排除
- en: A common error when creating `if`/`elif`/`else` statements is forgetting to
    include the colon at the end of the `if` statement. In this case, when you run
    the program, you’ll see a message pop up in IDLE saying “invalid syntax”, and
    the Python text editor will highlight the end of the line in red (see [figure
    5.10](#ch05fig10)). You can fix this error by adding a colon at the end of the
    `if` statement.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `if`/`elif`/`else` 语句时常见的错误是忘记在 `if` 语句末尾包含冒号。在这种情况下，当你运行程序时，你会在 IDLE 中看到一个弹出消息说“无效语法”，Python
    文本编辑器会将行尾突出显示为红色（见[图 5.10](#ch05fig10)）。你可以通过在 `if` 语句末尾添加冒号来修复这个错误。
- en: Figure 5.10\. Highlighting by IDLE when there is invalid syntax due to a missing
    colon (`:`) at the end of an `if` statement
  id: totrans-646
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.10\. 当 `if` 语句末尾缺少冒号（`:`）导致无效语法时，IDLE 会突出显示
- en: '![](05fig10.jpg)'
  id: totrans-647
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10](05fig10.jpg)'
- en: Another error is forgetting to put a colon at the end of the `def` statement
    when creating your own function. In this case, you’ll see the same message (“invalid
    syntax”) and red highlighting at the end of the line missing the colon.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个错误是在创建自己的函数时忘记在`def`语句的末尾放置冒号。在这种情况下，你会在缺少冒号的行末看到相同的消息（“无效语法”）和红色高亮。
- en: Finally, a third common error is using a single equals sign (`=`) when comparing
    two values in an `if` statement. Python will highlight the offending equals sign
    as shown in [figure 5.11](#ch05fig11). Remember, you need to use a double equals
    sign (`==`) to test the equality of two values. This returns True (if the values
    are equal) or False (if they’re not). The single equals sign (`=`) is used to
    assign a value to a variable, like `x = 7`.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第三个常见的错误是在`if`语句中比较两个值时使用单个等号（`=`）。Python会突出显示错误等号，如图[图5.11](#ch05fig11)所示。记住，你需要使用双等号（`==`）来测试两个值的相等性。这返回True（如果值相等）或False（如果它们不相等）。单个等号（`=`）用于将值赋给变量，例如`x
    = 7`。
- en: Figure 5.11\. Highlighting by IDLE when there is only one equals sign
  id: totrans-650
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.11\. 当只有一个等号时，IDLE的突出显示
- en: '![](05fig11.jpg)'
  id: totrans-651
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig11.jpg)'
- en: Fix this error by replacing the single equals sign (`=`) with double equals
    signs (`==`). As you can see, small problems can cause programs to have errors.
    If you get really stuck, ask a friend to look at your code, or post your code
    to a forum and ask for help. You’d be surprised by how helpful other programmers
    are!
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将单个等号（`=`）替换为双等号（`==`）来修复这个错误。正如你所看到的，小问题可能导致程序出现错误。如果你真的遇到了困难，请让朋友查看你的代码，或者将你的代码发布到论坛并寻求帮助。你会惊讶于其他程序员是多么有帮助！
- en: 'Fruit Picker Extra: playing video'
  id: totrans-653
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水果采摘者额外功能：播放视频
- en: In addition to displaying text, as in the cave adventure game, the Raspberry
    Pi can output sound, show images, and play videos. Let’s see how you can play
    a video on your Raspberry Pi. See [appendix A](kindle_split_019.html#app01) to
    learn how to set up your Raspberry Pi’s Wi-Fi adapter. There are many different
    video player apps you can use on your Pi, but a great one is OMXPlayer. It was
    created specifically for the Raspberry Pi and comes preinstalled with Raspbian.
    We’ll explore the audio (or sound) playback capabilities of OMXPlayer in [chapter
    8](kindle_split_018.html#ch08).
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 除了显示文本，就像洞穴冒险游戏一样，Raspberry Pi还可以输出声音，显示图像，播放视频。让我们看看如何在你的Raspberry Pi上播放视频。参见[附录A](kindle_split_019.html#app01)了解如何设置你的Raspberry
    Pi的Wi-Fi适配器。你可以在Pi上使用许多不同的视频播放器应用程序，但OMXPlayer是一个很好的选择。它是专门为Raspberry Pi创建的，并预安装在Raspbian中。我们将在[第8章](kindle_split_018.html#ch08)中探索OMXPlayer的音频（或声音）播放功能。
- en: To show off your Pi’s capability, let’s play a high-definition demo video from
    a movie called *Big Buck Bunny.*^([[2](#ch05fn02)]) It’s about 10 seconds long
    and has no sound. Open LXTerminal, and at the prompt enter
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示你的Pi的能力，让我们播放一部名为*Big Buck Bunny*的电影的高清演示视频。^([[2](#ch05fn02)]) 它大约10秒长，没有声音。打开LXTerminal，在提示符下输入
- en: ²
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-657
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is a video developed to test video playback and display.
  id: totrans-658
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是一个开发用于测试视频播放和显示的视频。
- en: '[PRE40]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You should see a silent video play for about 10 seconds. Enjoy it! If you know
    of a video file on the web (.mp4 or H.264 format), OMXPlayer can play it as long
    as you have a good internet connection. For example, to watch the trailer for
    another video called *Sintel*, make sure you’re connected to the internet and
    type in
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个无声的视频播放大约10秒钟。享受它！如果你在网上知道一个视频文件（.mp4或H.264格式），只要你有良好的互联网连接，OMXPlayer就可以播放它。例如，要观看另一部名为*Sintel*的视频预告片，请确保你已连接到互联网，并输入
- en: '[PRE41]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Why not open movies in a web browser? Because OMXPlayer can play them much more
    easily—it was designed to use the Pi’s graphics processing unit (GPU) for playing
    videos. This means most of your Pi’s resources are available to do other things.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不在网络浏览器中打开电影呢？因为OMXPlayer可以更容易地播放它们——它被设计为使用Pi的图形处理单元（GPU）来播放视频。这意味着你Pi的大部分资源都可以用于其他事情。
- en: 'Live streaming: exploring from your Pi'
  id: totrans-663
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 直播流：从你的Pi探索
- en: You’ve been pretending to explore a cave. Now let’s see if you can use your
    Pi to explore the ocean or space by live-streaming videos from web cameras. You
    can turn your Pi into a way to see the sharks and sea turtles by connecting to
    a live stream coming from the Monterey Bay Aquarium in California. Or maybe you
    want to see what the Earth looks like from the International Space Station right
    now.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 你一直在假装探索洞穴。现在让我们看看你是否可以使用你的Pi通过从网络摄像头直播视频来探索海洋或太空。你可以通过连接到来自加利福尼亚蒙特雷湾水族馆的实时流来将你的Pi变成一种可以看到鲨鱼和海龟的方式。或者，也许你现在想看看地球从国际空间站看起来是什么样子。
- en: 'With a few steps, you can configure your Pi to play live-streaming videos.
    First you need a small utility called Livestreamer that can take live video streams
    and output them for OMXPlayer to play, just like your test video. Let’s make sure
    you have the Python package installer. Make sure you have a working internet connection,
    and then open the Raspbian command line using the Linux Terminal (select Menu-->Accessories-->Terminal),
    and install the software:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几个步骤，你可以配置你的Pi来播放直播视频。首先，你需要一个名为Livestreamer的小工具，它可以接收直播视频流并将其输出给OMXPlayer播放，就像你的测试视频一样。让我们确保你有Python包安装器。确保你有工作的互联网连接，然后使用Linux终端（选择菜单-->附件-->终端）打开Raspbian命令行，并安装软件：
- en: '[PRE42]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'After it finishes, install Livestreamer:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，安装Livestreamer：
- en: '[PRE43]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now you need a link to a live stream of video. Livestreamer will work with
    many of the most popular live-streaming sites. For this example, you’ll use Ustream,
    but you could also use YouTube Live and many others. If you go to the Ustream
    website,^([[3](#ch05fn03)]) you can find links to live-stream videos. Here are
    few different ones found on the site:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要一个指向视频直播流的链接。Livestreamer可以与许多最受欢迎的直播网站一起工作。在这个例子中，你将使用Ustream，但你也可以使用YouTube
    Live和其他许多网站。如果你访问Ustream网站，^([[3](#ch05fn03)])，你可以找到直播视频的链接。以下是网站上找到的几个不同链接：
- en: ³
  id: totrans-670
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-671
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explore the UStream live-streaming videos at [www.ustream.tv/explore/all](http://www.ustream.tv/explore/all).
  id: totrans-672
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在[www.ustream.tv/explore/all](http://www.ustream.tv/explore/all)探索UStream的直播视频。
- en: 'Watch sharks and turtles at the Monterey Bay Aquarium: [www.ustream.tv/channel/9600798](http://www.ustream.tv/channel/9600798).'
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在蒙特雷湾水族馆观看鲨鱼和海龟：[www.ustream.tv/channel/9600798](http://www.ustream.tv/channel/9600798).
- en: 'Check out the sea life living in the kelp beds at the Monterey Bay Aquarium:
    [www.ustream.tv/channel/9948292](http://www.ustream.tv/channel/9948292).'
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看蒙特雷湾水族馆中生活在海藻床上的海洋生物：[www.ustream.tv/channel/9948292](http://www.ustream.tv/channel/9948292).
- en: 'See the view from the International Space Station (it may appear dark if the
    Space Station is in the shadow of the Earth): [www.ustream.tv/channel/9408562](http://www.ustream.tv/channel/9408562).'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看国际空间站的视角（如果空间站在地球的阴影中，它可能看起来很暗）：[www.ustream.tv/channel/9408562](http://www.ustream.tv/channel/9408562).
- en: '|  |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-677
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: These links may change over time. You can get the latest links by searching
    the Ustream website.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 这些链接可能会随时间变化。你可以通过搜索Ustream网站来获取最新的链接。
- en: '|  |'
  id: totrans-679
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’ll need an internet connection for the next couple steps. You need to figure
    out the video resolutions available. For the Monterey Bay Aquarium live stream,
    enter
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 你在接下来的几个步骤中需要一个互联网连接。你需要确定可用的视频分辨率。对于蒙特雷湾水族馆的直播流，输入
- en: '[PRE44]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: A few messages appear, and at the bottom are the supported stream resolution(s).
    For this live stream, you should see a response that says
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 出现了一些消息，底部是支持的流分辨率。对于这个直播流，你应该看到一个响应，表明
- en: '[PRE45]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This means `mobile_240p` is the only available resolution for the video stream.
    This is a low-resolution stream, but it’s still fun to watch. Tell Livestreamer
    to send the video to OMXPlayer with this command:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`mobile_240p`是视频流的唯一可用分辨率。这是一个低分辨率的流，但观看起来仍然很有趣。告诉Livestreamer使用以下命令将视频发送到OMXPlayer：
- en: '[PRE46]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Great! You should see a video open after a few seconds. It will be low resolution,
    but sit back and watch the amazing live view of fish, including sharks (see [figure
    5.12](#ch05fig12))!
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！几秒钟后你应该会看到一个视频打开。它将是低分辨率，但请坐下来观看令人惊叹的现场鱼群直播，包括鲨鱼（见[图5.12](#ch05fig12)）！
- en: Figure 5.12\. The Pi’s monitor is a live stream from an aquarium. Check out
    that shark! By using Livestreamer and OMXPlayer, you can stream live video from
    exotic places, like water holes in Africa and the International Space Station.
  id: totrans-687
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.12\. Pi的显示器是一个来自水族馆的实时流。看看那只鲨鱼！通过使用Livestreamer和OMXPlayer，你可以从非洲的水坑和国际空间站等异国他乡的地方直播视频。
- en: '![](05fig12_alt.jpg)'
  id: totrans-688
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig12_alt.jpg)'
- en: '|  |'
  id: totrans-689
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-690
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that you have to type in `mobile_240p`. You’ll type in one of the supported
    resolutions from the previous step.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你必须输入`mobile_240p`。你将输入上一步中支持的分辨率之一。
- en: '|  |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Press Ctrl-C to stop Livestreamer and OMXPlayer. Enjoy exploring the world from
    your Pi!
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 按下Ctrl-C停止Livestreamer和OMXPlayer。享受从你的Pi上探索世界吧！
- en: '![](common03.jpg)'
  id: totrans-694
  prefs: []
  type: TYPE_IMG
  zh: '![](common03.jpg)'
- en: Challenges
  id: totrans-695
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挑战
- en: These challenges focus on making improvements to the Raspi’s Cave Adventure
    game. If you get stuck, check [appendix C](kindle_split_021.html#app03) for hints
    and solutions.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 这些挑战集中在改进Raspi的洞穴冒险游戏。如果你遇到困难，请查看[附录C](kindle_split_021.html#app03)以获取提示和解决方案。
- en: Introducing dramatic pauses
  id: totrans-697
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 介绍戏剧性的停顿
- en: This first challenge is to include some drama in the game by adding two-second
    pauses between the `print` and `input` statements throughout Raspi’s Cave Adventure.
    This will create anticipation about what will happen next and give the player
    more time to read the messages before responding.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个挑战是在 Raspi 的洞穴冒险游戏中通过在 `print` 和 `input` 语句之间添加两秒的暂停来增加一些戏剧性。这将创造对接下来会发生什么的期待，并给玩家更多的时间在回答之前阅读信息。
- en: 'Here are some clues for how to accomplish this. First, Python has a built-in
    `time` module that provides some useful functions for working with time. At the
    top of the program, you need to add an `import` statement to use this built-in
    Python toolbox:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些如何完成这个任务的提示。首先，Python 有一个内置的 `time` 模块，它提供了一些用于处理时间的有用函数。在程序顶部，你需要添加一个
    `import` 语句来使用这个内置的 Python 工具箱：
- en: '[PRE47]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once you’ve imported the `time` module, you can call the `sleep` function in
    the program:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你导入了 `time` 模块，你可以在程序中调用 `sleep` 函数：
- en: '[PRE48]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This example code makes the program pause for 1 second. It takes the form `time.sleep(seconds)`,
    where `seconds` is the number of seconds you want the program to pause. For example,
    if you wanted to display a message, wait 3 seconds, and then display another message,
    you’d write
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例代码使程序暂停 1 秒。它采用 `time.sleep(seconds)` 的形式，其中 `seconds` 是程序需要暂停的秒数。例如，如果你想显示一条消息，等待
    3 秒，然后显示另一条消息，你会写
- en: '[PRE49]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Go ahead and try to create some drama. If you get stuck, check [appendix C](kindle_split_021.html#app03)
    or review the code files.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创造一些戏剧性。如果你卡住了，请查阅[附录 C](kindle_split_021.html#app03)或回顾代码文件。
- en: Random demise
  id: totrans-706
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 随机死亡
- en: 'Games are always more interesting when they have an element of unpredictability.
    Try to add some surprises to your game by improving the `wrong_answer` function
    to randomly display a message from a set of possible ways your player could meet
    their demise. Here are a couple of examples to get you started:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏具有不可预测性元素时，游戏总是更有趣。尝试通过改进 `wrong_answer` 函数，随机显示玩家可能遇到死亡的一组可能方式的消息来给你的游戏增加一些惊喜。以下是一些开始时的例子：
- en: Raspi sees a rock on the ground and picks it up. He feels a sharp pinch and
    drops the rock. He realizes it wasn’t a rock but a poisonous spider as he collapses
    to the ground.
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspi 看到地上有一块石头，就把它捡起来。他感到一阵剧痛，然后扔掉了石头。当他倒在地上时，他意识到那不是石头，而是一只有毒的蜘蛛。
- en: Standing in the cave, Raspi sees a small rabbit approach. Raspi gets a bad feeling
    about this rabbit. Suddenly the rabbit attacks him, biting his neck.
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 站在洞穴里，Raspi 看到一个小兔子靠近。Raspi 对这只兔子有一种不好的感觉。突然，兔子攻击了他，咬住了他的脖子。
- en: 'Hint: Create `if`/`elif`/`else` statements with different endings, and then
    use the `random` module to select from the possible endings.'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：创建具有不同结尾的 `if`/`elif`/`else` 语句，然后使用 `random` 模块从可能的结果中选择。
- en: Play again?
  id: totrans-711
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 再玩一次？
- en: 'Modify the game so that no matter how it ends, the user is always given the
    option to play again. Hint: Create a variable `play_again` that is initially set
    to “Y”. You’ll also need to add a `while` loop to your game that will make the
    game repeat as long as `play_again` is equal to “Y”.'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 修改游戏，使其无论以何种方式结束，用户都始终有再次玩的机会。提示：创建一个初始设置为“Y”的变量 `play_again`。你还需要在你的游戏中添加一个
    `while` 循环，使游戏在 `play_again` 等于“Y”时重复。
- en: Scream!
  id: totrans-713
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 喊叫！
- en: 'If you have a set of headphones or your Pi is connected to a TV with built-in
    speakers via an HDMI cable, you should be able to play sounds and hear them. Let’s
    look at a simple program to play a sound on your Pi:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一副耳机或者你的 Pi 通过 HDMI 线连接到带有内置扬声器的电视，你应该能够播放声音并听到它们。让我们看看一个简单的程序，在 Pi 上播放声音：
- en: '[PRE50]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Test the program, and you should hear a scream. Now see how you can integrate
    the scream or other sounds into Raspi’s Cave Adventure. You can find more sounds
    on your Pi in the Scratch folder: /usr/share/scratch/Media/Sounds/.'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 测试程序，你应该会听到尖叫。现在看看你如何将尖叫或其他声音整合到 Raspi 的洞穴冒险中。你可以在 Pi 的 Scratch 文件夹中找到更多声音：/usr/share/scratch/Media/Sounds/。
- en: '|  |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-718
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: OMXPlayer works best with sound files ending in .mp3\. Only some files ending
    in .wav will work. We’ll talk more about sound files and the OMXPlayer in [chapter
    8](kindle_split_018.html#ch08).
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: OMXPlayer 与以 .mp3 结尾的声音文件配合得最好。只有一些以 .wav 结尾的文件才能工作。我们将在第 8 章中更多地讨论声音文件和 OMXPlayer。[第
    8 章](kindle_split_018.html#ch08)。
- en: '|  |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: See [appendix C](kindle_split_021.html#app03) if you need help solving these!
    Good luck!
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要帮助解决这些问题，请参阅[附录 C](kindle_split_021.html#app03)！祝你好运！
- en: Summary
  id: totrans-722
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'You can create engaging programs by putting logic and instructions together
    into more complex programs:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将逻辑和指令组合到更复杂的程序中，你可以创建引人入胜的程序：
- en: Use flow diagrams to map out complex programs before you begin.
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始之前，使用流程图来规划复杂的程序。
- en: Create flexible programs that can handle unexpected input through the use of
    Boolean operators.
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用布尔运算符创建灵活的程序，以便处理意外的输入。
- en: Build programs with multiple choices and outcomes using `if`, `elif`, and `else`
    statements. Chain together multiple `elif` statements to create as many choices
    as you need.
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `if`、`elif` 和 `else` 语句构建具有多个选择和结果的程序。通过链式连接多个 `elif` 语句来创建所需数量的选择。
- en: When you have logic embedded within logic, nest `if` statements to create decisions
    that depend on prior choices or conditions.
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当逻辑中嵌套逻辑时，通过嵌套 `if` 语句来创建依赖于先前选择或条件的决策。
- en: Organize your code and cut down on repetition by defining your own functions
    and then calling them in your program.
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定义自己的函数并在程序中调用它们来组织代码并减少重复。
