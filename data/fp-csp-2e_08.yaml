- en: 6 Patterns in functional programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 函数式编程中的模式
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: 'The core functions: `Return`, `Map`, `Bind`, `Where`, and `ForEach`'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心函数：`Return`、`Map`、`Bind`、`Where`和`ForEach`
- en: Introducing functors and monads
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍函子和单子
- en: Working at different levels of abstraction
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的抽象级别上工作
- en: 'A pattern is a solution that can be applied to solve a variety of problems.
    The patterns we’ll discuss in this chapter are simply functions: functions that
    are so ubiquitous when coding functionally that they can be seen as the *core
    functions* of FP.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 模式是一种可以应用于解决各种问题的解决方案。在本章中我们将讨论的模式仅仅是函数：在函数式编程中，这些函数非常普遍，以至于它们可以被视为FP的*核心函数*。
- en: You’re probably familiar with some of these functions like `Where` and `Select`
    (which is equivalent to `Map`), having used them with `IEnumerable`. But you’ll
    see that the same operations can be applied to other structures, hence establishing
    a pattern. I’ll illustrate this with `Option` in this chapter; other structures
    will follow in coming chapters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉其中的一些函数，如`Where`和`Select`（它等同于`Map`），因为你在使用`IEnumerable`时使用过它们。但你会看到相同的操作可以应用于其他结构，从而建立一种模式。我将在本章中用`Option`来说明这一点；其他结构将在接下来的章节中介绍。
- en: As usual, I suggest you type along in the REPL and see how these core functions
    can be used. (You’ll need to import the `LaYumba.Functional` library as shown
    in the sidebar “Using the `LaYumba.Functional` library in the REPL” in chapter
    5.)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我建议你在REPL中输入代码并查看这些核心函数如何使用。（你需要导入第5章侧边栏中显示的`LaYumba.Functional`库。）
- en: 6.1 Applying a function to a structure’s inner values
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 将函数应用于结构内部值
- en: The first core function we’ll look at is `Map`. It takes a structure and a function
    and applies the function to the inner value(s) of the structure.[¹](#pgfId-1119312)
    Let’s start with the familiar case in which the structure in question is an `IEnumerable`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看的核心函数是`Map`。它接受一个结构和函数，并将函数应用于结构的内部值。[¹](#pgfId-1119312) 让我们从熟悉的案例开始，其中涉及的结构是一个`IEnumerable`。
- en: 6.1.1 Mapping a function onto a sequence
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 将函数映射到序列
- en: An implementation of `Map` for `IEnumerable` can be written as follows.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable`的`Map`实现可以写成如下。'
- en: Listing 6.1 Applying a function to each element of the given `IEnumerable`
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.1 将函数应用于给定的`IEnumerable`中的每个元素
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`Map` maps a list of `T`’s to a list of `R`’s by applying a function `T` `→`
    `R` to each element in the source list. Notice that in this implementation, the
    results are packaged into an `IEnumerable` as a result of using the `yield return`
    statement.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`通过将函数`T` `→` `R`应用于源列表中的每个元素，将`T`类型的列表映射到`R`类型的列表。请注意，在这个实现中，结果是通过使用`yield
    return`语句包装到`IEnumerable`中的。'
- en: NOTE In FP, it’s normal to use variable names like `t` for a value of type `T`,
    `ts` for a collection of `T`’s, and `f` (`g`, `h`, and so on) for a function.
    You can use more descriptive names when coding for more specific scenarios, but
    when a function is as general as `Map`, where you really know nothing about the
    value `t` or the function `f`, variables have correspondingly general names.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：在FP中，使用像`t`这样的变量名来表示类型`T`的值，`ts`来表示`T`的集合，以及`f`（`g`、`h`等）来表示函数是很常见的。在为更具体的场景编码时，你可以使用更具描述性的名称，但当函数像`Map`这样非常通用时，你实际上对值`t`或函数`f`一无所知，变量名就相应地更通用。
- en: Graphically, `Map` can be illustrated as in figure 6.1.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图形上，`Map`可以如图6.1所示。
- en: '![](Images/CH06_F01_Buonanno2.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH06_F01_Buonanno2.png)'
- en: Figure 6.1 Mapping a function over an `IEnumerable`. This operation yields a
    list containing the result of applying the given function to each item in the
    source list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 在`IEnumerable`上映射一个函数。这个操作产生一个包含将给定函数应用于源列表中每个项的结果的列表。
- en: 'Let’s look at a simple usage:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的用法：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Maybe you recognized that this is exactly the behavior you get when you call
    LINQ’s `Select` method. Indeed, `Map` can be defined in terms of `Select`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你已经意识到，这正是当你调用LINQ的`Select`方法时得到的行为。确实，`Map`可以用`Select`来定义：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is potentially more efficient because LINQ’s implementation of `Select`
    is optimized for some specific implementations of `IEnumerable`. The point is
    that I’m going to use the name `Map` rather than `Select` because `Map` is the
    standard terminology in FP, but you should consider `Map` and `Select` synonyms.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能更有效，因为LINQ的`Select`实现针对某些特定的`IEnumerable`实现进行了优化。重点是，我将使用`Map`这个名字而不是`Select`，因为`Map`是FP中的标准术语，但你应该将`Map`和`Select`视为同义词。
- en: 6.1.2 Mapping a function onto an Option
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 将函数映射到Option
- en: 'Now let’s see how `Map` can be defined for a different structure: `Option`.
    Just like mapping a function onto a list abstracts away how the list is structured
    or implemented, how many items it contains, and how the function is applied to
    each element, similarly for an `Option` we want to apply a function to its inner
    value, without the need to know about the state or the implementation details
    of `Option`. The signature of `Map` for `IEnumerable` is'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何为不同的结构定义`Map`：`Option`。就像将函数映射到列表抽象化了列表的结构或实现方式、包含的项目数量以及函数如何应用到每个元素上一样，对于`Option`，我们希望将函数应用到其内部值上，而不需要了解`Option`的状态或实现细节。`IEnumerable`的`Map`签名是
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To get the signature of `Map` for `Option`, let’s simply follow the pattern
    and replace `IEnumerable` with `Option`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`Option`的`Map`签名，我们只需遵循模式，将`IEnumerable`替换为`Option`：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This signature says that `Map` is given
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个签名表明`Map`是给定的
- en: An `Option` that *may* contain a `T`
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可能包含`T`的`Option`
- en: A function from `T` to `R`
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个从`T`到`R`的函数
- en: 'It must return an `Option` that *may* contain an `R`. Can you think of an implementation?
    Let’s see:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须返回一个可能包含`R`的`Option`。你能想到一个实现吗？让我们看看：
- en: 'If the given `Option` is `None`, then there is no `T` available and no way
    to compute an `R`: all you can do is return `None`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给定的`Option`是`None`，那么就没有`T`可用，也无法计算出一个`R`：你能做的只是返回`None`。
- en: On the other hand, if the `Option` is `Some`, then its inner value is a `T`,
    so you can apply the given function to it, obtaining an `R`, which you can then
    wrap in a `Some`.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，如果`Option`是`Some`，那么它的内部值是一个`T`，因此你可以将给定的函数应用到它上面，得到一个`R`，然后你可以将其包裹在一个`Some`中。
- en: Hence, we can define `Map` as the following listing demonstrates. This is also
    represented in figure 6.2.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以定义`Map`，如下列所示。这也在图6.2中表示。
- en: Listing 6.2 Definition of `Map` for `Option`
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.2 `Option`的`Map`定义
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](Images/CH06_F02_Buonanno2.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH06_F02_Buonanno2.png)'
- en: Figure 6.2 Mapping a function over an `Option`
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 在`Option`上映射函数
- en: 'Intuitively, it can be useful to think of `Option` as a special kind of list
    that can either be empty (`None`) or contain exactly one value (`Some`). If you
    look at it in this light, it becomes clear that the implementations of `Map` for
    `Option` and `IEnumerable` are consistent: the given function gets applied to
    *all* inner values of the structure. Let’s look at a simple example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地讲，将`Option`视为一种特殊的列表，它可以是空的（`None`）或者恰好包含一个值（`Some`）。如果你从这个角度来看，就会变得很明显，`Option`和`IEnumerable`的`Map`实现是一致的：给定的函数会被应用到结构的所有内部值上。让我们看看一个简单的例子：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s a real-life analogy: you have a lovely old aunt whose specialty is making
    apple pies (figure 6.3). She hates to go shopping, but boy, does she love baking
    pies (single responsibility principle).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个现实生活中的类比：你有一个可爱的老阿姨，她擅长做苹果派（图6.3）。她讨厌购物，但天哪，她喜欢做派（单一职责原则）。
- en: '![](Images/CH06_F03_Buonanno2.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH06_F03_Buonanno2.png)'
- en: Figure 6.3 Your aunt bakes the pie, but only if the apples are in the basket!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 你阿姨烤派，但只有当篮子里有苹果时！
- en: You often drop a basket of apples outside her door on your way to work, and
    in the evening, you’ll find a basket of freshly made pies! Your aunt also has
    a sense of humor, so if you get smart and leave an empty basket by her door, you’ll
    find an empty basket in return.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常在上班的路上在她家门口放下一个装满苹果的篮子，晚上你会发现一个装满新鲜派饼的篮子！你的阿姨也很有幽默感，所以如果你机灵地在她家门口留一个空篮子，你也会得到一个空篮子作为回报。
- en: 'In this analogy, the basket represents `Option`. The apples are its inner value,
    and your aunt’s cooking skills are the function that gets applied to the apples.
    `Map` is the process of unboxing the apples, giving them to your aunt for processing,
    and reboxing the baked pie. Here’s how this example would play out in code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类比中，篮子代表`Option`。苹果是其内部值，你阿姨的烹饪技巧是应用到苹果上的函数。`Map`是将苹果取出，交给阿姨处理，然后重新装进烤好的派的过程。以下是这个例子在代码中的实现方式：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 6.1.3 How Option raises the level of abstraction
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 选项如何提高抽象级别
- en: A really important thing to realize is that `Option` abstracts away the question
    of whether a value is present or not. If you directly apply a function to a value,
    you have to somehow ensure that the value is available. Instead, if you `Map`
    that function onto an `Option`, you don’t really care whether the value is there
    or not—`Map` applies the function or not, as appropriate.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常重要的事情是要意识到`Option`抽象了值是否存在的问题。如果你直接对一个值应用一个函数，你必须确保该值可用。相反，如果你将那个函数`Map`到`Option`上，你实际上并不关心值是否存在——`Map`根据情况应用函数或不应用。
- en: 'This may not be fully clear at this point, but it will become so as you proceed
    through the book. For now, let’s see if I can illustrate this idea. In chapter
    4, we defined a function that would calculate `Risk` based on `Age` as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上可能还不完全清楚，但随着你继续阅读本书，它将变得清晰。现在，让我们看看我能否说明这个想法。在第4章中，我们定义了一个函数，该函数根据`Age`来计算`Risk`，如下所示：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, assume you’re doing a survey where people volunteer some personal information
    and receive some statistics. Survey takers are modeled with a `Subject` class
    defined as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你正在进行一项调查，人们自愿提供一些个人信息并接收一些统计数据。调查参与者由以下定义的`Subject`类来模拟：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Some fields like `Age` are modeled as optional because survey takers can choose
    whether or not to disclose this information. This is how you’d compute the `Risk`
    of a particular `Subject`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字段如`Age`被建模为可选的，因为调查参与者可以选择是否披露此信息。这就是你计算特定`Subject`的`Risk`的方式：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Because `Risk` is based on the subject’s age, which is optional, the computed
    `Risk` is also optional. You don’t have to worry about whether the `Age` is there
    or not; instead, you can map the function that computes risk regardless, and allow
    the optionality to propagate by returning the result as an `Option`. Next, let’s
    look at `Map` in a more general light.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Risk`是基于主题的年龄，而年龄是可选的，所以计算出的`Risk`也是可选的。你不必担心`Age`是否存在；相反，你可以映射计算风险的函数，并通过返回结果作为`Option`来允许可选性传播。接下来，让我们更一般地看看`Map`。
- en: 6.1.4 Introducing functors
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.4 函子的介绍
- en: You’ve seen that `Map` is a function that follows a precise pattern, and that
    it’s used to apply a function to the inner value(s) of a structure such as an
    `IEnumerable` or an `Option`. It can be defined for many other data structures
    including sets, dictionaries, trees, and more.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到`Map`是一个遵循精确模式的函数，并且它用于将函数应用到结构如`IEnumerable`或`Option`的内部值上。它可以定义许多其他数据结构，包括集合、字典、树等。
- en: 'Let’s generalize the pattern. Let `C<T>` indicate a generic *container* that
    wraps some inner value(s) of type `T`. Then the signature of `Map` can be generalized
    as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们推广这个模式。让`C<T>`表示一个泛型*容器*，它封装了类型为`T`的一些内部值。然后`Map`的签名可以推广如下：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`Map` can be defined as a function that takes a container `C<T>` and a function
    *f* of type `(T` `→` `R)`. It returns a container `C<R>` that wraps the value(s)
    resulting from applying *f* to the container’s inner value(s).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`可以被定义为一个函数，它接受一个容器`C<T>`和一个类型为`(T → R)`的函数*f*。它返回一个容器`C<R>`，该容器封装了将*f*应用到容器内部值的结果。'
- en: In FP, a type for which such a `Map` function is defined is called a *functor*.[²](#pgfId-1119450)
    `IEnumerable` and `Option` are functors, as you’ve just seen, and you’ll meet
    many more in the book.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，为这种`Map`函数定义类型的类型被称为*函子*。[²](#pgfId-1119450) `IEnumerable`和`Option`是函子，正如你所看到的，你将在书中遇到更多。
- en: For practical purposes, we can say that anything that has a reasonable implementation
    of `Map` is a functor. But what’s a reasonable implementation? Essentially, `Map`
    should apply a function to the container’s inner value(s) and, equally important,
    it should do *nothing else*—`Map` should have no side effects.[³](#pgfId-1119455)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际应用来说，我们可以认为任何具有合理`Map`实现的类型都是一种函子。但什么是合理的实现呢？本质上，`Map`应该将一个函数应用到容器内部的值上，并且同样重要的是，它不应该做其他任何事情——`Map`不应该有副作用。[³](#pgfId-1119455)
- en: Why is functor not an interface?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么函子不是一个接口？
- en: 'If both `Option` and `IEnumerable` support the `Map` operation, why are we
    not capturing this with an interface? Indeed, it would be nice to do so, but unfortunately,
    it’s not possible in C#. To illustrate why, let’s try to define such an interface:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Option`和`IEnumerable`都支持`Map`操作，为什么我们不通过接口来捕获这一点？确实，这样做会很不错，但不幸的是，在C#中这是不可能的。为了说明原因，让我们尝试定义这样一个接口：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This doesn’t compile: we can’t use `F<>` as a type variable because unlike
    `T`, it doesn’t indicate a type but rather a *kind*: a type that’s, in turn, parameterized
    with a generic type. And it’s not enough for `Map` to return a `Functor`. It must
    return a functor of the same kind as the current instance.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这无法编译：我们无法使用 `F<>` 作为类型变量，因为与 `T` 不同，它不表示一个类型，而是一个 *类型类别*：一个反过来参数化泛型类型的类型。而且，`Map`
    只需返回一个 `Functor` 是不够的。它必须返回与当前实例相同类别的函子。
- en: Other languages (including Haskell and Scala) support so-called *higher-kinded
    types*, so it’s possible to represent these more general interfaces with *type
    classes*, but in C# (and even F#), we must content ourselves with a lesser level
    of abstraction and follow a pattern-based approach.^a
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言（包括 Haskell 和 Scala）支持所谓的 *高阶类型类别*，因此可以使用 *类型类* 来表示这些更通用的接口，但在 C#（甚至 F#）中，我们必须满足于较低层次的抽象，并遵循基于模式的途径.^a
- en: ^a It’s possible to use the C# type system creatively and find a representation
    analogous to type classes, but the resulting code is rather intricate and, therefore,
    not suitable for the intent of this book.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ^a 有可能在 C# 类型系统中创造性地使用，并找到类似于类型类的表示，但生成的代码相当复杂，因此不适合本书的意图。
- en: 6.2 Performing side effects with ForEach
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 使用 ForEach 执行副作用
- en: 'In chapter 4, we discussed the dichotomy between `Func` and `Action`. We have
    this problem again with `Map`: `Map` takes a `Func`, so what do we do if we want
    to perform an `Action` for each value in a given structure? You may know that
    `List<T>` has a `ForEach` method that takes an `Action<T>`, which it invokes for
    each item in the list:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 章中，我们讨论了 `Func` 和 `Action` 之间的二分法。我们再次遇到这个问题，与 `Map` 相关：`Map` 接受一个 `Func`，如果我们想在给定的结构中为每个值执行一个
    `Action`，我们该怎么办？你可能知道 `List<T>` 有一个 `ForEach` 方法，它接受一个 `Action<T>` 并为列表中的每个项目调用它：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is essentially what we want. Let’s generalize this so we can call `ForEach`
    on any `IEnumerable`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是我们想要的。让我们将其推广，以便我们可以在任何 `IEnumerable` 上调用 `ForEach`：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The code changes the `Action` to a `Unit`-returning function and then relies
    on the implementation of `Map`. This only creates a lazily evaluated sequence
    of `Unit`s. Here we actually want the side effects to be performed; hence, the
    call to `ToImmutableList`. The usage is, unsurprisingly, like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将 `Action` 转换为返回 `Unit` 的函数，然后依赖于 `Map` 的实现。这仅创建了一个 `Unit` 的惰性评估序列。实际上，我们希望执行副作用；因此，调用了
    `ToImmutableList`。使用方法出人意料地简单：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, let’s see the definition of `ForEach` for `Option`. This is defined trivially
    in terms of `Map`, using the `ToFunc` function that converts an `Action` into
    a `Func`:[⁴](#pgfId-1119502)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `Option` 的 `ForEach` 定义。这是在 `Map` 的基础上定义的，使用将 `Action` 转换为 `Func` 的
    `ToFunc` 函数：[⁴](#pgfId-1119502)
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `ForEach` name can be slightly counterintuitive—remember, an `Option` has
    at most one inner value, so the given action is invoked exactly once (if the `Option`
    is `Some`) or never (if it’s `None`). Here’s an example of using `ForEach` to
    apply an `Action` to an `Option`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForEach` 的名称可能有些令人费解——记住，`Option` 至多有一个内部值，所以给定的操作恰好调用一次（如果 `Option` 是 `Some`），或者永远不会调用（如果它是
    `None`）。以下是一个使用 `ForEach` 将 `Action` 应用到 `Option` 的示例：'
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, remember from chapter 3 that we should aim to separate pure logic
    from side effects. We should use `Map` for logic and `ForEach` for side effects,
    so it would be preferable to rewrite the preceding code as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，记住第 3 章的内容，我们应该旨在将纯逻辑与副作用分离。我们应该使用 `Map` 进行逻辑，使用 `ForEach` 进行副作用，因此最好将前面的代码重写如下：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'TIP Make the scope of the `Action` that you apply with `ForEach` as small as
    possible: use `Map` for data transformations and `ForEach` for side effects. This
    follows the general FP idea of avoiding side effects if possible and isolating
    them otherwise.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 尽量使使用 `ForEach` 应用的 `Action` 的作用域尽可能小：使用 `Map` 进行数据转换，使用 `ForEach` 进行副作用。这遵循了通用
    FP 理念，即尽可能避免副作用，否则将其隔离。
- en: 'Take a moment to experiment in the REPL and see that `Map` and `ForEach` can
    be used with both `IEnumerable` and `Option`. Here’s an example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL 中花点时间进行实验，看看 `Map` 和 `ForEach` 可以与 `IEnumerable` 和 `Option` 一起使用。以下是一个示例：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that you can use the same patterns, whether you’re working with `Option`
    or `IEnumerable`. Isn’t that nice? You can now view both `Option` and `IEnumerable`
    as *specialized containers*, and you have a set of core functions that allow you
    to interact with them. If you’re presented with a new kind of container, and `Map`
    or `ForEach` are defined, you’ll probably have a good idea of what they do because
    you recognize the pattern.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，无论你是处理`Option`还是`IEnumerable`，都可以使用相同的模式。这不是很好吗？现在你可以将`Option`和`IEnumerable`视为*特殊容器*，并且有一组核心函数允许你与之交互。如果你遇到一种新的容器类型，并且定义了`Map`或`ForEach`，你可能会对它们的作用有一个很好的了解，因为你可以识别出这种模式。
- en: 'NOTE In the preceding code, I used `LaYumba.Functional.String`, a class that
    exposes some commonly used functionality of `System.String` through static methods.
    This allows me to refer to `String.ToUpper` as a function without the need to
    specify the instance on which the `ToUpper` instance method acts as in: `s =>
    s.ToUpper()`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在前面的代码中，我使用了`LaYumba.Functional.String`类，它通过静态方法公开了一些常用的`System.String`功能。这允许我将`String.ToUpper`作为一个函数来引用，而无需指定`ToUpper`实例方法所作用的实例，如下所示：`s
    => s.ToUpper()`。
- en: In summary, `ForEach` is similar to `Map`, but it takes an `Action` rather than
    a function, so it’s used to perform side effects. Let’s move on to the next core
    function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`ForEach`与`Map`类似，但它接受一个`Action`而不是函数，因此它用于执行副作用。让我们继续介绍下一个核心函数。
- en: 6.3 Chaining functions with Bind
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 使用`Bind`链式调用函数
- en: '`Bind` is another important function, similar to `Map` but slightly more complex.
    I’ll introduce the need for `Bind` with an example.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bind`是另一个重要的函数，类似于`Map`，但稍微复杂一些。我将通过一个例子来介绍`Bind`的需求。'
- en: 'Suppose you want a simple program that reads the user’s age from the console
    and prints out some related message. You also want error handling: the age should
    be valid!'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要一个简单的程序，该程序从控制台读取用户的年龄并打印出一些相关消息。你还需要错误处理：年龄应该是有效的！
- en: 'Remember, in the last chapter, we defined `Int.Parse` to parse a string as
    an `int`. We also defined `Age.Create`, a smart constructor that creates an `Age`
    instance from the given `int`. Both functions return an `Option`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在上一章中，我们定义了`Int.Parse`来解析字符串为`int`。我们还定义了`Age.Create`，一个智能构造函数，它可以从给定的`int`创建一个`Age`实例。这两个函数都返回`Option`：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s see what happens if we combine them with `Map`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们用`Map`组合它们会发生什么：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, we have a problem! We end up with a nested value: `Option`
    of `Option` of `Age`. . . . How are we going to work with that?'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们遇到了一个问题！我们最终得到了一个嵌套的值：`Option`的`Option`的`Age`……我们该如何处理这个嵌套值呢？
- en: 6.3.1 Combining Option-returning functions
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 组合返回`Option`的函数
- en: 'It’s in such scenarios that `Bind` is handy. For `Option`, this is the signature
    of `Bind`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Bind`非常有用。对于`Option`，这是`Bind`的签名：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`Bind` takes an `Option` and an `Option`-returning function and applies the
    function to the inner value of the `Option`. The following listing shows the implementation.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bind`接受一个`Option`和一个返回`Option`的函数，并将该函数应用于`Option`的内部值。下面的列表显示了实现。'
- en: Listing 6.3 Implementation of `Bind` and `Map` for `Option`
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3 `Option`的`Bind`和`Map`实现
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ `Bind` takes an `Option`-returning function.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `Bind`接受一个返回`Option`的函数。
- en: ❷ `Map` takes a regular function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `Map`接受一个普通函数。
- en: The preceding listing replicates the definition of `Map` so that you can see
    how similar these are. Simply put, the `None` case always returns `None` so that
    the given function won’t be applied. The `Some` case does apply the function;
    however, unlike `Map`, there’s no need to package the result into an `Option`
    because `f` already returns an `Option`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表复制了`Map`的定义，以便你可以看到它们是多么相似。简单来说，`None`情况总是返回`None`，这样就不会应用给定的函数。`Some`情况确实应用了函数；然而，与`Map`不同，没有必要将结果打包进一个`Option`，因为`f`已经返回了一个`Option`。
- en: Now let’s see how we can put `Bind` to work in the example of parsing a string
    representing a person’s age. The following listing shows this representation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何在解析表示一个人年龄的字符串的例子中应用`Bind`。下面的列表显示了这种表示。
- en: Listing 6.4 Using `Bind` to compose two functions that return an `Option`
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.4 使用`Bind`组合返回`Option`的两个函数
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The function `parseAge` uses `Bind` to combine `Int.Parse` (which returns an
    `Option<int>`) and `Age.Create` (which returns an `Option<Age>`). As a result,
    `parseAge` combines the check that the string represents a valid integer and the
    check that the integer is a valid age value.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `parseAge` 使用 `Bind` 来组合 `Int.Parse`（它返回一个 `Option<int>`）和 `Age.Create`（它返回一个
    `Option<Age>`）。因此，`parseAge` 结合了检查字符串是否表示有效整数的检查，以及检查整数是否是有效年龄值的检查。
- en: 'Let’s now see this in the context of a simple program that reads an age from
    the console and prints out a related message:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个简单的程序，它从控制台读取年龄并打印出相关消息的上下文：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Recursively calls itself as long as parsing the `age` fails
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 递归调用自身，直到解析 `age` 失败
- en: ❷ Combines parsing a `string` as an `int` and creating an `Age` from the `int`
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将解析 `string` 为 `int` 和从 `int` 创建 `Age` 结合起来
- en: 'Here’s a sample interaction with this program (user inputs are shown in bold):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个程序的一个示例交互（用户输入以粗体显示）：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now let’s see how `Bind` works with `IEnumerable`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 `Bind` 与 `IEnumerable` 的结合方式。
- en: 6.3.2 Flattening nested lists with Bind
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 使用 `Bind` 平铺嵌套列表
- en: You’ve just seen how you can use `Bind` to avoid having nested `Option`s. The
    same idea applies to lists. But what are nested lists? Two-dimensional lists!
    We need a function that will apply a list-returning function to a list. But rather
    than returning a two-dimensional list, it should flatten the result into a one-dimensional
    list.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚看到了如何使用 `Bind` 来避免嵌套 `Option`。同样的想法也适用于列表。但嵌套列表是什么？二维列表！我们需要一个函数，它将对列表应用返回列表的函数。但与其返回一个二维列表，它应该将结果平铺成一个一维列表。
- en: 'Remember that `Map` loops over a given `IEnumerable` and applies a function
    to each element. `Bind` is similar, but with a nested loop because applying the
    *bound* function also yields an `IEnumerable`. The resulting list is flattened
    to a one-dimensional list. It’s probably easier to see this in code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 `Map` 会遍历给定的 `IEnumerable` 并对每个元素应用一个函数。`Bind` 类似于 `Map`，但有一个嵌套循环，因为应用 *绑定*
    函数也会产生一个 `IEnumerable`。结果列表被平铺成一个一维列表。这可能在代码中更容易理解：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you’re intimately familiar with LINQ, you’ll recognize that this implementation
    is virtually identical to `SelectMany`. For `IEnumerable`, `Bind` and `SelectMany`
    are identical. Again, in this book, I’ll use the name `Bind` because it’s standard
    in FP-speak.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你非常熟悉 LINQ，你会认识到这个实现几乎与 `SelectMany` 相同。对于 `IEnumerable`，`Bind` 和 `SelectMany`
    是相同的。再次强调，在这本书中，我将使用 `Bind` 这个名字，因为在函数式编程中它是标准的。
- en: 'Let’s see it in action with an example. Suppose you have a list of neighbors,
    and each neighbor has a list of pets. You want a list of all pets in the neighborhood:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来看看它的实际应用。假设你有一个邻居列表，每个邻居都有一个宠物列表。你想要一个包含社区中所有宠物的列表：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice how using `Map` yields a nested `IEnumerable`, whereas `Bind` yields
    a flat `IEnumerable`. (Also notice that, whichever way you look at the results
    of the preceding example, `Bind` doesn’t necessarily yield more items than `Map`
    does, which does make the choice of the name `SelectMany` seem rather odd.) Figure
    6.4 shows a graphical representation of `Bind` for `IEnumerable`, particularized
    to the types and data in the neighborhood example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到使用 `Map` 会产生嵌套的 `IEnumerable`，而 `Bind` 则产生平铺的 `IEnumerable`。（也请注意，无论从哪个角度看前面示例的结果，`Bind`
    并不一定比 `Map` 产生更多的项目，这确实使得选择 `SelectMany` 这个名字看起来相当奇怪。）图 6.4 展示了 `Bind` 在 `IEnumerable`
    上的图形表示，特别针对邻域示例中的类型和数据。
- en: '![](Images/CH06_F04_Buonanno2.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH06_F04_Buonanno2.png)'
- en: Figure 6.4 `Bind` takes a source list and a function returning a list for each
    item of the source list. It returns a flat list, whereas `Map` returns a list
    of lists.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 `Bind` 接受一个源列表和一个为源列表的每个项目返回列表的函数。它返回一个平铺的列表，而 `Map` 返回一个列表的列表。
- en: As you can see, each function application yields an `IEnumerable`, and then
    the results for all applications are flattened into a single `IEnumerable`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每次函数应用都会产生一个 `IEnumerable`，然后所有应用的结果都被平铺成一个单一的 `IEnumerable`。
- en: 6.3.3 Actually, it’s called a monad
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.3 实际上，它被称为单子
- en: 'Let’s now generalize the pattern for `Bind`. If we use `C<T>` to indicate some
    structure that contains value(s) of type `T`, then `Bind` takes an instance of
    the container and a function with signature `(T` `→` `C<R>)` and returns a `C<R>`.
    The signature of `Bind` is always in this form:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来泛化 `Bind` 的模式。如果我们用 `C<T>` 来表示包含类型 `T` 的值的一些结构，那么 `Bind` 就会接受容器的一个实例和一个具有签名
    `(T → C<R>)` 的函数，并返回一个 `C<R>`。`Bind` 的签名始终是这个形式：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You saw that, for all practical purposes, functors are types for which a suitable
    `Map` function is defined, enabling you to apply a function to the functor’s inner
    value(s). Similarly, *monads* are types for which a `Bind` function is defined,
    enabling you to effectively combine two (or more) monad-returning functions without
    ending up with a nested structure. You’ll sometimes hear people talk of *monadic
    bind* to clarify that they’re not just talking about some function called `Bind`,
    but about *the* `Bind` function that allows the type to be treated as a monad.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到，在所有实际用途中，函子是定义了合适的 `Map` 函数的类型，使你能够将函数应用于函子的内部值。同样，*单子* 是定义了 `Bind` 函数的类型，使你能够有效地组合两个（或更多）返回单子的函数，而不会得到嵌套结构。有时你会听到人们谈论
    *单子绑定* 来澄清他们不仅仅是在谈论某个名为 `Bind` 的函数，而是在谈论 *那个* 允许类型被视为单子的 `Bind` 函数。
- en: 6.3.4 The Return function
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.4 `Return` 函数
- en: In addition to the `Bind` function, monads must also have a `Return` function
    that *lifts* or *wraps* a normal value `T` into a monadic value `C<T>`. Somewhat
    confusingly, the `Return` function is usually not called “Return” but takes on
    a different name, depending on the structure in question. For `Option`, this is
    the `Some` function we defined in chapter 5.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `Bind` 函数外，单子还必须有一个 `Return` 函数，该函数可以将普通值 `T` 提升或包装成单子值 `C<T>`。有些令人困惑的是，`Return`
    函数通常不被称为“Return”，而是根据所讨论的结构采用不同的名称。对于 `Option`，这就是我们在第 5 章中定义的 `Some` 函数。
- en: 'What’s the `Return` function for `IEnumerable`? Because there are many implementations
    of `IEnumerable`, there are many possible ways to create an `IEnumerable`. In
    my functional library, I have a suitable `Return` function for `IEnumerable` called
    `List`. To stick with functional principles, `List` returns an immutable list:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable` 的 `Return` 函数是什么？因为有许多 `IEnumerable` 的实现，所以有创建 `IEnumerable`
    的许多可能方法。在我的函数式库中，我有一个适合 `IEnumerable` 的 `Return` 函数，称为 `List`。为了坚持函数式原则，`List`
    返回一个不可变列表：'
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `List` function doesn’t only satisfy the requirement of the `Return` function,
    allowing us to raise a simple `T` into an `IEnumerable<T>`. It also, thanks to
    the `params` arguments, gives us a nice shorthand syntax for initializing lists:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`List` 函数不仅满足 `Return` 函数的要求，允许我们将简单的 `T` 提升到 `IEnumerable<T>`。此外，多亏了 `params`
    参数，它还为我们提供了初始化列表的简洁语法：'
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To summarize, a monad is a type `M<T>` for which the following functions are
    defined:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，单子是一个类型 `M<T>`，对于该类型，定义了以下函数：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There are certain properties that `Bind` and `Return` must observe for the type
    to be considered a “proper” monad; these are called the *monad laws*. To avoid
    overloading this chapter with theory, I’ll postpone a discussion of the monad
    laws until section 10.3.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类型被视为“正确”的单子，`Bind` 和 `Return` 必须遵守某些属性；这些被称为 *单子定律*。为了避免在本章中过度加载理论，我将把对单子定律的讨论推迟到第
    10.3 节。
- en: Suffice it to say, `Return` should only do the *minimal* amount of work required
    to lift a `T` into a `M<T>` and nothing else. It should be as dumb as possible.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`Return` 应仅执行将 `T` 提升到 `M<T>` 所需的最小工作量，而无需做其他事情。它应该尽可能简单。
- en: 6.3.5 Relationship between functors and monads
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.5 函子和单子之间的关系
- en: I said that functors are types for which `Map` is defined, whereas monads are
    types for which `Return` and `Bind` are defined. You’ve also seen that both `Option`
    and `IEnumerable` are functors *and* monads because all these functions are defined.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我说过，函子是定义了 `Map` 的类型，而单子是定义了 `Return` 和 `Bind` 的类型。你也看到了，`Option` 和 `IEnumerable`
    都是函子 *和* 单子，因为这些函数都定义了。
- en: 'Two questions naturally arise: Is every monad also a functor? Is every functor
    also a monad? To answer the first question, let’s take another look at the signatures
    of the core functions we''ve seen so far:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 自然会产生两个问题：每个单子也是函子吗？每个函子也是单子吗？为了回答第一个问题，让我们再次看看我们迄今为止看到的核心函数的签名：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you have an implementation of `Bind` and `Return`, you can implement `Map`
    in terms of these: the function `T` `→` `R` that `Map` takes as input can be turned
    into a function of type `T` `→` `C<R>` by composing it with `Return`. This function
    can, in turn, be given as input to `Bind`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个 `Bind` 和 `Return` 的实现，你可以用这些实现来编写 `Map`：`Map` 作为输入接受的函数 `T` `→` `R` 可以通过与
    `Return` 组合变成一个类型为 `T` `→` `C<R>` 的函数。这个函数反过来可以给 `Bind` 作为输入。
- en: To convince yourself of this, I propose in the exercises that you implement
    `Map` in terms of `Bind` and `Return`. Although the implementation is correct,
    it may be suboptimal, so normally, `Map` is given its own implementation that
    doesn’t rely on `Bind`. Still, this means that every monad is also a functor.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您确信这一点，我在练习中建议您用 `Bind` 和 `Return` 来实现 `Map`。尽管实现是正确的，但它可能不是最优的，所以通常，`Map`会有自己的实现，不依赖于`Bind`。然而，这意味着每个单子也是一个函子。
- en: 'As for the second question, it turns out that the answer is *no*: not every
    functor is a monad. `Bind` can’t be defined in terms of `Map`, so having an implementation
    of `Map` gives you no guarantee that a `Bind` function can be defined. For example,
    some kinds of trees support `Map` but not `Bind`. On the other hand, for most
    of the types we’ll discuss in this book, both `Map` and `Bind` can be defined.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 关于第二个问题，答案是*否*：并非每个函子都是单子。`Bind`不能在`Map`的术语下定义，因此拥有`Map`的实现并不能保证可以定义`Bind`函数。例如，某些类型的树支持`Map`但不支持`Bind`。另一方面，对于本书中我们将讨论的大多数类型，`Map`和`Bind`都可以定义。
- en: 6.4 Filtering values with Where
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 使用 Where 过滤值
- en: In chapter 2, you saw several uses of `Where` to filter the values of an `IEnumerable`.
    It turns out that `Where` can also be defined for `Option` as the following listing
    illustrates.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，您看到了使用`Where`来过滤`IEnumerable`值的几个示例。实际上，`Where`也可以为`Option`定义，如下所示。
- en: Listing 6.5 Filtering the inner value of an `Option`
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.5 过滤 `Option` 的内部值
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Given an `Option` and a predicate, you get back `Some` if the given `Option`
    is `Some`, *and* its inner value satisfies the given predicate; otherwise, you
    get `None`. Again, if you think of `Option` as a list with at most one item, this
    makes sense. Here’s a simple usage:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个`Option`和一个谓词，如果给定的`Option`是`Some`，并且其内部值满足给定的谓词，则返回`Some`；否则，返回`None`。再次强调，如果您将`Option`视为最多只有一个元素的列表，这就有意义了。以下是一个简单的用法：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here we use `Int.Parse` (defined in section 5.4.1) that returns an `Option`,
    signaling whether the string has been correctly parsed as an `int`. We then use
    `Where` to additionally enforce that the value be positive.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`Int.Parse`（在5.4.1节中定义），它返回一个`Option`，表示字符串是否已正确解析为`int`。然后我们使用`Where`来额外确保值是正数。
- en: This concludes our initial exploration of the core functions. You’ll see a couple
    more as you progress through the book, but the functions described up to this
    point can take you a surprisingly long way, as you’ll see in the next chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对核心函数的初步探索。在您继续阅读本书的过程中，您将看到更多，但到目前为止描述的函数可以带您走很长的路，您将在下一章中看到这一点。
- en: The many names of the core functions
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 核心函数的许多名称
- en: One of the hurdles of learning FP is that the same construct is given different
    names in different languages or libraries. This is true of the core functions,
    so I’ve included the following table to help you make sense of these synonyms
    when you encounter them elsewhere.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 学习函数式编程的一个难点是，相同的结构在不同的语言或库中具有不同的名称。这一点对于核心函数来说也是正确的，因此我包括以下表格，以帮助您在其他地方遇到这些同义词时理解它们。
- en: '| LaYumba.Functional | LINQ | Common synonyms |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| LaYumba.Functional | LINQ | 常见同义词 |'
- en: '| --- | --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Map` | `Select` | `fMap, Project, Lift` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `Map` | `Select` | `fMap, Project, Lift` |'
- en: '| `Bind` | `SelectMany` | `FlatMap, Chain, Collect, Then` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `Bind` | `SelectMany` | `FlatMap, Chain, Collect, Then` |'
- en: '| `Where` | `Where` | `Filter` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `Where` | `Where` | `Filter` |'
- en: '| `ForEach` | `n/a` | `Iter` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `ForEach` | `n/a` | `Iter` |'
- en: '| `Return` | `n/a` | `Pure` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `Return` | `n/a` | `Pure` |'
- en: When writing this book and the `LaYumba.Functional` library, I had to decide
    which names to choose for these functions, and these choices are necessarily somewhat
    arbitrary. `ForEach` and `Where` are good names and standard in .NET, but `Select`
    and `SelectMany` would be poor names if used for functors or monads other than
    `IEnumerable`. I chose to use `Map` and `Bind`, which are more general, shorter,
    and standard in the FP literature.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本书和`LaYumba.Functional`库时，我必须决定为这些函数选择哪些名称，这些选择必然是有些任意的。`ForEach`和`Where`是好的名称，并且在.NET中是标准的，但如果用于`IEnumerable`之外的函子或单子，`Select`和`SelectMany`将是不好的名称。我选择使用`Map`和`Bind`，它们更通用、更简短，并且在函数式编程文献中是标准的。
- en: 6.5 Combining Option and IEnumerable with Bind
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 使用 Bind 结合 Option 和 IEnumerable
- en: 'I’ve mentioned that one way to look at `Option` is as a special case of a list
    that can either be empty (`None`) or contain exactly one value (`Some`). You can
    express this in code by making it possible to convert an `Option` into an `IEnumerable`
    as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到过，看待 `Option` 的方法之一是将其视为一个特殊的列表，可以是空的 (`None`) 或恰好包含一个值 (`Some`)。你可以通过以下方式在代码中表达这一点，使得可以将
    `Option` 转换为 `IEnumerable`：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If the `Option` is `Some`, the resulting `IEnumerable` yields one item; if it’s
    `None`, it yields no items. Functions that map between functors, such as `AsEnumerable`,
    are called *natural transformations* and are quite useful in practice.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Option` 是 `Some`，则 resulting `IEnumerable` 产生一个项目；如果它是 `None`，则不产生任何项目。在函子之间映射的函数，如
    `AsEnumerable`，被称为 *自然变换*，在实践上非常有用。
- en: '`IEnumerable` is often used to store data, and `Option` skips a computation
    when a value isn’t present, so their intent is usually different. Still, there
    are some cases in which it’s useful to combine them. In some scenarios, you end
    up with an `IEnumerable<Option<T>>` (or vice versa, an `Option<IEnumerable<T>>`)
    and want to flatten it into an `IEnumerable<T>`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable` 通常用于存储数据，而 `Option` 在值不存在时跳过计算，因此它们的意图通常不同。尽管如此，在某些情况下，将它们结合起来是有用的。在某些场景中，你最终会得到一个
    `IEnumerable<Option<T>>`（或反之，`Option<IEnumerable<T>>`），并希望将其展平为 `IEnumerable<T>`。'
- en: 'For example, let’s go back to the example of a survey, where each participant
    is modeled as a `Subject`. Because it’s optional for participants to disclose
    their age, we model `Subject.Age` as an `Option<Age>`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们回到调查的例子，其中每个参与者都被模拟为 `Subject`。由于参与者披露年龄是可选的，我们模型 `Subject.Age` 为 `Option<Age>`：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ This person did not disclose their age.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这个人没有披露他们的年龄。
- en: 'You have the details of your participants stored in an `IEnumerable<Subject>`.
    Now suppose you need to compute the average age of the participants. How can you
    go about that? You can start by selecting all the values for `Age`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你存储了参与者的详细信息在一个 `IEnumerable<Subject>` 中。现在假设你需要计算参与者的平均年龄。你该如何着手呢？你可以从选择所有
    `Age` 的值开始：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you use `Map` to select the age of the survey takers, you get a list of
    options. And because an `Option` can be viewed as a list, `optionalAges` can be
    viewed as a list of lists. To translate this intuition into code, let’s add some
    overloads to `Bind` that convert the `Option` into an `IEnumerable`, so that `Bind`
    can be applied as though we were flattening a nested `IEnumerable`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `Map` 来选择调查者的年龄，你会得到一个选项列表。由于一个 `Option` 可以被视为一个列表，因此 `optionalAges` 可以被视为列表的列表。为了将这种直觉转化为代码，让我们给
    `Bind` 添加一些重载，将 `Option` 转换为 `IEnumerable`，这样 `Bind` 就可以像我们在展平嵌套的 `IEnumerable`
    一样应用：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Even though according to FP theory `Bind` should only work on one type of container,
    the fact that an `Option` can always be *promoted* to the more general `IEnumerable`
    makes these overloads valid and quite useful in practice:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管根据 FP 理论 `Bind` 应该只作用于一种容器类型，但 `Option` 总是可以 *提升* 到更通用的 `IEnumerable`，这使得这些重载在实践上是有效且非常有用的：
- en: We can use the first overload to get an `IEnumerable<T>`, where `Map` would
    give us an `IEnumerable<Option<T>>` as in the current survey example.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用第一个重载来获取 `IEnumerable<T>`，其中 `Map` 会给我们一个 `IEnumerable<Option<T>>`，就像当前的调查示例一样。
- en: We can use the second overload to get an `IEnumerable<T>`, where `Map` would
    give us an `Option<IEnumerable<T>>`.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用第二个重载来获取 `IEnumerable<T>`，其中 `Map` 会给我们一个 `Option<IEnumerable<T>>`。
- en: 'In the survey scenario, we can now use `Bind` to filter out all the `None`s
    and get a list of all the ages that were actually given:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查场景中，我们现在可以使用 `Bind` 过滤掉所有的 `None` 并获取所有实际给出的年龄列表：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This allows us to take advantage of the flattening nature of `Bind` to filter
    out all the `None` cases. The preceding output shows the results of calling both
    `Map` and `Bind` so that you can compare the results.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们利用 `Bind` 的展平特性来过滤掉所有的 `None` 情况。前面的输出显示了调用 `Map` 和 `Bind` 的结果，以便你可以比较结果。
- en: 6.6 Coding at different levels of abstraction
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 在不同抽象级别上进行编码
- en: '*Abstraction* (in English, not in OOP) means that specific features of different
    concrete things are removed in order for a general, common feature to emerge:
    a concept. For example, when you say, “You’ll see a row of houses,” or “Put your
    ducks in a row,” the *row* concept removes anything that makes ducks differ from
    houses and only captures their spatial disposition.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*抽象*（在英语中，不是在面向对象编程中）意味着为了使一个普遍的、共同的特征出现，需要移除不同具体事物的特定特征：一个概念。例如，当你说你“会看到一排房子”或“把你的鸭子排成一排”时，*排*这个概念移除了使鸭子与房子不同的任何东西，只捕捉了它们的空間排列。'
- en: 'Types like `IEnumerable` and `Option` have such a conceptual abstraction at
    their core: all specific features of their inner value(s) are abstracted away.
    These types only capture the ability to enumerate the values or the possible absence
    of a value, respectively. The same can be said for most generic types. Let’s try
    to generalize this so that what you’ve learned for `Option` can help you understand
    other constructs that you’ll see later in the book (and in other libraries).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 像`IEnumerable`和`Option`这样的类型在其核心具有这样的概念抽象：它们内部值的所有特定特征都被抽象掉了。这些类型只捕获了枚举值或值可能不存在的能力。对于大多数泛型类型来说，情况也是如此。让我们尝试概括这一点，以便你所学的
    `Option` 可以帮助你理解书中（以及在其他库中）稍后看到的其他构造。
- en: 6.6.1 Regular vs. elevated values
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.1 常规与提升价值
- en: 'When you’re dealing with a type like, say, `IEnumerable<int>` or `Option<Employee>`,
    you’re coding at a higher level of abstraction than when dealing with a non-generic
    type like `int` or `Employee`. Let’s divide the world of values we deal with into
    two categories:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理像 `IEnumerable<int>` 或 `Option<Employee>` 这样的类型时，你编写的代码比处理像 `int` 或 `Employee`
    这样的非泛型类型时处于更高的抽象层次。让我们将我们处理的价值世界分为两类：
- en: '*Regular values*, which we’ll call `T`. `String`, `int`, `Neighbor`, or `DayOfWeek`,
    are all examples of regular values.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*常规值*，我们将称之为 `T`。`String`、`int`、`Neighbor` 或 `DayOfWeek` 都是常规值的例子。'
- en: '*Elevated values*, which we’ll call `A<T>`*.* `Option<int>`, `IEnumerable<string>`,
    `Func<Neighbor>`, or `Task<bool>`, are all examples of elevated values.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提升的价值*，我们将称之为 `A<T>`*。* `Option<int>`、`IEnumerable<string>`、`Func<Neighbor>`
    或 `Task<bool>` 都是提升价值的例子。'
- en: 'Here, elevated values imply an abstraction of the corresponding regular types.[⁵](#pgfId-1119879)
    These abstractions are constructs that enable us to better work with and represent
    operations on the underlying types. More technically put, an *abstraction* is
    a way to add an effect to the underlying type.[⁶](#pgfId-1119883) Let’s look at
    some examples:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，提升价值意味着对相应常规类型的抽象。[⁵](#pgfId-1119879) 这些抽象是使我们能够更好地处理和表示底层类型上的操作的构造。更技术地说，一个
    *抽象* 是向底层类型添加效果的一种方式。[⁶](#pgfId-1119883) 让我们看看一些例子：
- en: '`Option` adds the effect of *optionality*, which is not a `T` but the *possibility*
    of a `T`.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Option` 添加了 *可选项* 的效果，这不仅仅是一个 `T`，而是 `T` 的 *可能性*。'
- en: '`IEnumerable` adds the effect of *aggregation*, which is not a `T` or two but
    a *sequence* of `T`’s.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IEnumerable` 添加了 *聚合* 的效果，这不仅仅是一个 `T` 或两个，而是一个 `T` 的 *序列*。'
- en: '`Func` adds the effect of *laziness*, which is not a `T` but a *computation*
    that can be evaluated to obtain a `T`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Func` 添加了 *惰性* 的效果，这不仅仅是一个 `T`，而是一个可以评估以获得 `T` 的 *计算*。'
- en: '`Task` adds the effect of *asynchrony*, which is not a `T` but a *promise*
    that at some point you’ll get a `T`.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task` 添加了 *异步性* 的效果，这不仅仅是一个 `T`，而是一个 *承诺*，在某个时刻你会得到一个 `T`。'
- en: As you can see from the preceding examples, things that are very different in
    nature can be considered abstractions, so there’s little point in trying to fit
    the concept into a box. It’s more interesting to see how these abstractions can
    be put to work.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的例子所示，本质上非常不同的东西可以被认为是抽象，所以试图将这个概念放入一个框中是没有什么意义的。更有趣的是看看这些抽象如何被运用。
- en: Coming back to regular versus elevated values, you can visualize these different
    kinds of values as in figure 6.5\. This diagram shows an example of a regular
    type, `int`, with some sample values and the corresponding abstraction `A<int>`,
    where `A` could be an arbitrary abstraction. The arrows that take a regular value
    and wrap it in a corresponding `A` represent the `Return` function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 回到常规与提升价值，你可以将这些不同类型的值可视化如图 6.5 所示。这个图显示了常规类型 `int` 的一个示例，以及一些样本值和相应的抽象 `A<int>`，其中
    `A` 可以是任意抽象。将常规值取走并包裹在相应的 `A` 中的箭头代表 `Return` 函数。
- en: '![](Images/CH06_F05_Buonanno2.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH06_F05_Buonanno2.png)'
- en: Figure 6.5 `Return` lifts a regular into an elevated value.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 `Return` 将常规值提升为提升价值。
- en: 6.6.2 Crossing levels of abstraction
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.2 跨越抽象层次
- en: Now that we have this classification of types, we can classify functions accordingly.
    We have functions that remain within the same level of abstraction and functions
    that cross between levels of abstraction, as illustrated in figure 6.6.[⁷](#pgfId-1119903)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这种类型的分类，我们可以相应地分类函数。我们有保持在同一抽象层次上的函数，也有跨越抽象层次之间的函数，如图 6.6 所示。[⁷](#pgfId-1119903)
- en: '![](Images/CH06_F06_Buonanno2.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH06_F06_Buonanno2.png)'
- en: Figure 6.6 Functions classified in relation to levels of abstractions
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 按抽象层次分类的函数
- en: Let’s look at a few examples. The function `(int i) => i.ToString()` has signature
    `int` `→` `string`, so it maps one regular type to another and is clearly of the
    first kind.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个例子。函数 `(int i) => i.ToString()` 的签名是 `int` `→` `string`，因此它将一个常规类型映射到另一个类型，显然属于第一种类型。
- en: The `Int.Parse` function we’ve been using has type `string` `→` `Option<int>`,
    so it’s an upward-crossing function—the third kind. Scott Wlaschin calls these
    *world-crossing* functions because they go from the *world* of normal values `T`
    to the world of *elevated* values `E<T>` (extraterrestrial?).[⁸](#pgfId-1119914)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用的 `Int.Parse` 函数的类型是 `string` `→` `Option<int>`，因此它是一个向上交叉函数——第三种类型。斯科特·沃尔申将这些称为
    *世界交叉* 函数，因为它们从 *世界* 中的正常值 `T` 转到提升值 `E<T>` 的世界（外星？）。[⁸](#pgfId-1119914)
- en: The `Return` function, which for any abstraction `A` has type `T` `→` `A<T>`,
    is a special case of an upward-crossing function that does nothing other than
    upward crossing. That’s why I show `Return` as a vertical upward arrow and any
    other upward-crossing function as a diagonal arrow.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`Return` 函数，对于任何抽象 `A`，其类型为 `T` `→` `A<T>`，是一个特殊的向上交叉函数，除了向上交叉之外不做任何事情。这就是为什么我将
    `Return` 显示为垂直向上箭头，而任何其他向上交叉函数都显示为斜线箭头。'
- en: 'Functions of the second kind remain within the abstraction. For instance, the
    following function is a clear match:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型的函数保持在抽象内部。例如，以下函数是一个明显的匹配：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Its signature is in the form `A<T>` `→` `A<R>`. But we should also include in
    this category any function in which we start with an `A<T>`, have some additional
    arguments, and ultimately end up with an `A<R>`. That is, any function whose application
    keeps us within the abstraction; its signature will be in the form `(A<T>, ...)`
    `→` `A<R>`. This includes many HOFs we’ve looked at, such as `Map`, `Bind`, `Where`,
    `OrderBy`, and others.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 它的签名形式是 `A<T>` `→` `A<R>`。但我们也应该将任何以 `A<T>` 开始，有额外的参数，并最终以 `A<R>` 结束的函数包含在这个类别中。也就是说，任何应用保持在我们抽象内部的函数；它的签名将是
    `(A<T>, ...)` `→` `A<R>`。这包括我们查看过的许多 HOF（高阶函数），如 `Map`、`Bind`、`Where`、`OrderBy`
    等。
- en: Finally, downward-crossing functions, in which we start with an elevated value
    and end up with a regular value, include `Average`, `Sum`, and `Count` for `IEnumerable`
    and `Match` for `Option`. Notice that, given an abstraction `A`, it’s not always
    possible to define a downward counterpart to `Return`; there is often no vertical
    downward arrow. You can always lift an `int` into an `Option<int>`, but you can’t
    *lower* an `Option<int>` to an `int`. What if it’s `None`? Similarly, you can
    wrap a single `Employee` into an `IEnumerable<Employee>`, but there’s no obvious
    way to reduce an `IEnumerable<Employee>` to a single `Employee`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，向下交叉函数，其中我们从一个提升值开始，最终得到一个常规值，包括 `IEnumerable` 的 `Average`、`Sum` 和 `Count`，以及
    `Option` 的 `Match`。请注意，给定一个抽象 `A`，并不总是可能定义一个与 `Return` 相对应的向下函数；通常没有垂直向下箭头。你总是可以将
    `int` 提升到 `Option<int>`，但你不能 *降低* `Option<int>` 到 `int`。如果它是 `None` 呢？同样，你可以将单个
    `Employee` 包装到 `IEnumerable<Employee>` 中，但没有任何明显的方法可以将 `IEnumerable<Employee>`
    减少到单个 `Employee`。
- en: 6.6.3 Map vs. Bind, revisited
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.3 Map vs. Bind，再次回顾
- en: Let’s see how we can use this classification to better understand the difference
    between `Map` and `Bind`. `Map` takes an elevated value `A<T>` and a *regular*
    function `T` `→` `R`, and returns an elevated value of type `A<R>`, as figure
    6.7 illustrates.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用这种分类来更好地理解 `Map` 和 `Bind` 之间的区别。`Map` 接受一个提升值 `A<T>` 和一个 *常规* 函数
    `T` `→` `R`，并返回一个类型为 `A<R>` 的提升值，如图 6.7 所示。
- en: '![](Images/CH06_F07_Buonanno2.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH06_F07_Buonanno2.png)'
- en: Figure 6.7 `Map` in terms of regular vs. elevated values
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 以常规值和提升值来解释 `Map`
- en: '`Bind` also takes an elevated value `A<T>`, but then an *upward-crossing* function
    of type `T` `→` `A<R>`, and returns an elevated value of type `A<R>`, as figure
    6.8 illustrates.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bind` 也接受一个提升值 `A<T>`，然后是一个类型为 `T` `→` `A<R>` 的 *向上交叉* 函数，并返回一个类型为 `A<R>`
    的提升值，如图 6.8 所示。'
- en: '![](Images/CH06_F08_Buonanno2.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH06_F08_Buonanno2.png)'
- en: Figure 6.8 `Bind` in terms of regular vs. elevated values
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 以常规值和提升值来解释 `Bind`
- en: The main difference is that `Map` takes a regular function, while `Bind` takes
    an upward-crossing function. If you use `Map` with an upward-crossing function
    of type `T` `→` `A<R>`, you’ll end up with a nested value of type `A<A<R>>`. This
    is usually not the desired effect, and you should probably use `Bind` instead.
    Notice that both `Map` and `Bind` are in themselves functions that operate on
    elevated values because they both take an `A<T>` and yield an `A<R>`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于 `Map` 接受一个常规函数，而 `Bind` 接受一个向上交叉函数。如果你使用类型为 `T` `→` `A<R>` 的向上交叉函数与 `Map`
    一起使用，你最终会得到一个嵌套的 `A<A<R>>` 类型的值。这通常不是期望的效果，你可能应该使用 `Bind`。请注意，`Map` 和 `Bind` 本身都是操作提升值的函数，因为它们都接受一个
    `A<T>` 并产生一个 `A<R>`。
- en: 6.6.4 Working at the right level of abstraction
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.4 在正确的抽象级别上工作
- en: 'This idea of working at different levels of abstraction is important. If you
    always deal with regular values, you’ll probably be stuck with low-level operations,
    such as `for` loops, `null` checks, and so on. Working at such a low level of
    abstraction is inefficient and error-prone. There’s a definite sweet spot when
    working within one abstraction, as in the following snippet (from chapter 1):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同抽象级别上工作的这个想法很重要。如果你总是处理常规值，你可能会陷入低级操作，如 `for` 循环、`null` 检查等。在如此低的抽象级别上工作既低效又容易出错。在同一个抽象级别内工作确实有一个明确的最佳点，如下面的代码片段（来自第1章）所示：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Once you’ve used `Range` to go from regular values to an `IEnumerable<int>`,
    all following computations stay within the `IEnumerable` abstraction. That is,
    staying within one abstraction gives you the ability to nicely compose several
    operations—something we’ll delve into in the next chapter.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用 `Range` 将常规值转换为 `IEnumerable<int>`，所有后续的计算都保持在 `IEnumerable` 抽象内部。也就是说，保持在同一个抽象级别可以让你很好地组合多个操作——我们将在下一章深入探讨这一点。
- en: There’s also the danger of going too deep if you’re dealing with values in the
    form `A<B<C<D<T>>>>`, where each level adds an abstraction and it’s difficult
    to deal with the deeply buried `T`. This is something I’ll address in chapter
    17.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处理的是形式为 `A<B<C<D<T>>>>` 的值，其中每个级别都添加了一个抽象，并且难以处理深深埋藏的 `T`，这也存在风险。这一点我将在第17章中讨论。
- en: In this chapter, you’ve seen the implementation of some core functions for working
    with `Option` and `IEnumerable`. Although the implementations are simple, you’ve
    seen how this has given us a rich API for working with `Option`, just as you’re
    used to with `IEnumerable`. Several common operations can be defined for both
    `Option` and `IEnumerable`—patterns that apply to different kinds of structures.
    With this API in place and a better understanding of the core functions of FP,
    you’re ready to tackle more complex scenarios.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了一些用于处理 `Option` 和 `IEnumerable` 的核心函数的实现。尽管实现很简单，但你已经看到了这如何为我们提供了一个丰富的
    API 来处理 `Option`，就像你习惯于处理 `IEnumerable` 一样。可以为 `Option` 和 `IEnumerable` 定义一些常见操作——适用于不同类型结构的模式。有了这个
    API 和对 FP 核心函数的更好理解，你就可以处理更复杂的情况了。
- en: Exercises
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Implement `Map` for `ISet<T>` and `IDictionary<K, T>`. (Tip: start by writing
    down the signature in arrow notation.)'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `ISet<T>` 和 `IDictionary<K, T>` 的 `Map`。（提示：首先用箭头符号写下签名。）
- en: Implement `Map` for `Option` and `IEnumerable` in terms of `Bind` and `Return`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据 `Bind` 和 `Return` 实现 `Option` 和 `IEnumerable` 的 `Map`。
- en: Use `Bind` and an `Option`-returning `Lookup` function as defined in section
    5.4.2 to implement `GetWorkPermit` (shown in the following code snippet). Then
    enrich the implementation so that `GetWorkPermit` returns `None` if the work permit
    has expired.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Bind` 和第5.4.2节中定义的返回 `Option` 的 `Lookup` 函数来实现 `GetWorkPermit`（如下代码片段所示）。然后丰富实现，使
    `GetWorkPermit` 在工作许可证过期时返回 `None`。
- en: 'Use `Bind` to implement `AverageYearsWorkedAtTheCompany` (shown in the following
    code snippet). Only employees who have left should be included:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Bind` 来实现 `AverageYearsWorkedAtTheCompany`（如下代码片段所示）。只应包括已离职的员工：
- en: '[PRE43]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Structures like `Option<T>` and `IEnumerable<T>` can be seen as containers or
    abstractions, allowing you to work more effectively with the underlying values
    of type `T`.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于 `Option<T>` 和 `IEnumerable<T>` 的结构可以被视为容器或抽象，使你能够更有效地处理类型 `T` 的底层值。
- en: You can distinguish between regular values (say, `T`) and elevated values (like
    `Option<T>` or `IEnumerable<T>`).
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以区分常规值（例如，`T`）和提升值（如 `Option<T>` 或 `IEnumerable<T>`）。
- en: The core functions of FP that allow you to work effectively with elevated values
    include
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你有效地处理提升值的 FP 核心函数包括
- en: '`Return`, which takes a regular value and lifts it into an elevated value'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Return`，它将常规值提升到高值'
- en: '`Map`, which applies a function to the inner value(s) of a structure and returns
    a new structure wrapping the result'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map`，将函数应用于结构内的值并返回一个新结构，该结构包装了结果'
- en: '`ForEach`, a side-effecting variant of `Map`, which takes an action that it
    performs for each of the container’s inner values'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForEach`，是`Map`的副作用变体，它接受一个动作，并为容器内的每个内部值执行该动作'
- en: '`Bind`, which maps an `Option`-returning function onto an `Option` and flattens
    the result to avoid producing a nested `Option`, similarly for `IEnumerable` and
    other structures'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bind`，将返回`Option`的函数映射到`Option`上，并将结果扁平化以避免产生嵌套的`Option`，类似地对于`IEnumerable`和其他结构'
- en: '`Where`, which filters the inner value(s) of a structure according to a given
    predicate'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Where`，根据给定的谓词过滤结构内的值'
- en: Types for which `Map` is defined are called *functors*. Types for which `Return`
    and `Bind` are defined are called *monads*.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`Map`有定义的类型称为*functor*。对于`Return`和`Bind`有定义的类型称为*monad*。
- en: '* * *'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ The *inner value(s)* are also known as *bound values.*
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 内部值也被称为绑定值。
- en: ² Unfortunately, the term *functor* has different connotations depending on
    the context. In mathematics, it identifies the function that is being mapped;
    in programming, it’s the container over which you can map the function.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ² 不幸的是，术语“functor”在不同的语境中有不同的含义。在数学中，它标识了被映射的函数；在编程中，它是你可以映射函数的容器。
- en: ³ This is not the official definition, but it’s essentially equivalent.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 这不是官方定义，但本质上等价。
- en: '⁴ You might ask yourself, “Why not just add an overload for `Map` that takes
    an `Action`?” The problem is that in this case, the compiler fails to resolve
    to the right overload when we call `Map` without specifying its generic arguments.
    The reason for this is fairly technical: overload resolution doesn’t take into
    account output parameters, so it can’t distinguish between `Func<T, R>` and `Action<T>`
    when it comes to overload resolution. The price to pay for such an overload would
    be to always specify generic arguments when calling `Map`, again causing noise.
    In short, the best solution is to introduce a dedicated `ForEach` method.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ 你可能会问自己，“为什么不直接为`Map`添加一个接受`Action`的重载？”问题在于在这种情况下，当我们调用`Map`而不指定其泛型参数时，编译器无法解析到正确的重载。原因相当技术性：重载解析不考虑输出参数，因此在重载解析时无法区分`Func<T,
    R>`和`Action<T>`。这种重载的代价是调用`Map`时必须始终指定泛型参数，这又会引起噪音。简而言之，最好的解决方案是引入一个专门的`ForEach`方法。
- en: ⁵ Other authors refer to elevated values as wrapped, amplified values, and so
    on.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ⁵ 其他作者将高值称为包裹值、放大值等。
- en: ⁶ In this context, *effect* has a completely different meaning and shouldn’t
    be confused with *side effect*. This is unfortunate, but standard, terminology.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ⁶ 在这个语境中，“效果”有完全不同的含义，不应与“副作用”混淆。这是不幸的，但却是标准的术语。
- en: ⁷ This classification isn’t exhaustive because you can envisage more categories
    where the application of a function would cause you to jump by several levels
    of abstraction or would take you from one type of abstraction to another. But
    these are probably the most usual kinds of functions you’ll encounter, so the
    classification is still useful.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ⁷ 这种分类并不全面，因为你可以设想更多类别，在这些类别中，应用函数会导致你跳过几个抽象级别，或者从一个抽象类型跳到另一个抽象类型。但这些都可能是你遇到的最常见的函数类型，所以这种分类仍然是有用的。
- en: '⁸ See Scott’s “Understanding map and apply” article here: [http://fsharpforfunandprofit.com/posts/elevated-world](http://fsharpforfunandprofit.com/posts/elevated-world).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ⁸ 请参阅斯科特的“理解map和apply”文章，链接在此：[http://fsharpforfunandprofit.com/posts/elevated-world](http://fsharpforfunandprofit.com/posts/elevated-world)。
