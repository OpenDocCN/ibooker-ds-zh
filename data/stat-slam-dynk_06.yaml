- en: 6 More wrangling and visualizing data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 更多数据处理和可视化
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Subsetting data sets
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据集的子集化
- en: Separating and joining data sets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离和连接数据集
- en: Renaming and converting variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的重命名和转换
- en: Sorting data and returning cumulative sums
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序数据和返回累积总和
- en: Transforming data sets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换数据集
- en: Indexing records
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录索引
- en: Converting `sqldf` code to `dplyr`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`sqldf`代码转换为`dplyr`
- en: Creating and customizing bar charts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和自定义条形图
- en: According to conventional wisdom, no doubt influenced by late-game bias where
    the final plays in a close game create the most indelible memories, NBA games
    are won in the fourth quarter. In other words, teams that win the fourth quarter
    and play best down the stretch, regardless of what might have happened over the
    first three quarters, will usually be victorious. This suggests that the last
    12 minutes of an NBA game are more significant than the first 36 minutes (NBA
    games are 48 minutes in duration divided into four 12-minute quarters).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据传统智慧，无疑受到比赛后期偏见的影响，即一场接近的比赛中的最后几秒创造最难以忘怀的记忆，NBA比赛是在第四节赢得的。换句话说，无论前三节发生了什么，赢得第四节并发挥最佳水平的队伍通常都会获胜。这表明NBA比赛的最后12分钟比前36分钟（NBA比赛时长为48分钟，分为四个12分钟的季度）更重要。
- en: Our hypothesis is that this conventional wisdom is false. We’ll examine almost
    every NBA regular season game over two contiguous seasons and then plot how winning
    teams fared in the fourth quarter versus the other three quarters. Along the way,
    we’ll demonstrate a ton of data wrangling techniques that will serve you well
    in your professional or academic careers, such as changing layouts by reshaping
    whole data sets and sorting vectors, extracting records that meet logical criteria,
    selecting or deselecting columns by name, grouping and summarizing data, renaming
    existing variables and creating new ones, and joining data sets vertically and
    horizontally. And with our `ggplot2` bar charts, we’ll demonstrate how to skillfully
    display results by highlighting some and de-emphasizing others.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的假设是这种传统智慧是错误的。我们将检查两个连续赛季中几乎每一场NBA常规赛，然后绘制获胜队伍在第四节与其他三个季度相比的表现。在这个过程中，我们将展示大量数据处理技术，这些技术将在你的职业或学术生涯中大有裨益，例如通过重塑整个数据集和排序向量来更改布局，提取符合逻辑标准的记录，通过名称选择或取消选择列，对数据进行分组和汇总，重命名现有变量并创建新的变量，以及垂直和水平地连接数据集。而且，通过我们的`ggplot2`条形图，我们将展示如何巧妙地通过突出显示一些内容并淡化其他内容来展示结果。
- en: 6.1 Loading packages
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 加载包
- en: 'We start by loading the three packages we’ll need to wrangle, query, and visualize
    data in ways that are above and beyond the capabilities of base R. We make a series
    of calls to the `library()` function and pass our required packages as arguments.
    All of these packages should be familiar to you by now:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先加载三个我们将需要的包，以超越基础R的能力进行数据处理、查询和可视化。我们通过一系列对`library()`函数的调用，并将所需的包作为参数传递。现在这些包应该对你来说都很熟悉：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Due to all the data wrangling ahead of us, when not relying on base R, we’ll
    be calling `dplyr` and `tidyr` functions way more frequently than other packaged
    functions. Once more, `dplyr` and `tidyr` are part of the `tidyverse` package.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们面前有大量的数据处理工作，如果不依赖基础R，我们将比其他包装函数更频繁地调用`dplyr`和`tidyr`函数。再次强调，`dplyr`和`tidyr`是`tidyverse`包的一部分。
- en: 6.2 Importing data
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 导入数据
- en: We have two .csv files to import, both of which were downloaded from the website
    [www.bigdataball.com](https://www.bigdataball.com/). The first file, set to nba1819,
    contains box score data for every regular season and postseason game from the
    2018-19 season; the second file, set to nba1920, contains similar box score data
    for every regular season and postseason game from the 2019-20 season.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个.csv文件需要导入，这两个文件都是从网站[www.bigdataball.com](https://www.bigdataball.com/)下载的。第一个文件，设置为nba1819，包含2018-19赛季每个常规赛和季后赛比赛的得分数据；第二个文件，设置为nba1920，包含2019-20赛季每个常规赛和季后赛比赛的类似得分数据。
- en: 'We call the `read_csv()` function twice from the `readr` package, which is
    part of the `tidyverse`, to import these two files one at a time:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`tidyverse`包中的`readr`包调用两次`read_csv()`函数，以逐个导入这两个文件：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Box score data is mostly a combination of team-level and player-level basic
    statistics, such as the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 比赛得分数据主要是团队层面和球员层面的基本统计数据的组合，如下所示：
- en: Total points scored
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总得分
- en: Points scored per quarter
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每节得分
- en: Shots attempted and made
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试和命中的投篮
- en: Free throws attempted and made
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试和命中的罚球
- en: Offensive and defensive rebounds
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进攻和防守篮板
- en: Assists
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 助攻
- en: Turnovers
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 犯规
- en: Starting lineups for both teams
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两队的首发阵容
- en: Game-level attributes are also included; for example, the date of the game and
    where it was played, the names of the officials assigned to call the game, and
    opening and closing odds. We’ll need only *some* of this data for our analysis.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 包括比赛级别的属性；例如，比赛的日期和比赛地点，被分配来叫比赛官员的名字，以及开盘和收盘赔率。我们只需要分析中的一些数据。
- en: 'The `dim()` function from base R returns the dimension—that is, the number
    of rows and columns—in the nba1819 and nba1920 data sets:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 基础R中的`dim()`函数返回维度——即行数和列数——在nba1819和nba1920数据集中：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Both data sets have 57 columns, or variables. But nba1920 has fewer rows, or
    observations, than nba1819 because COVID-19 truncated the 2019-20 season; fewer
    games translates to fewer rows of data, of course.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个数据集都有57列，或变量。但与nba1819相比，nba1920有更少的行，或观测值，因为COVID-19缩短了2019-20赛季；当然，比赛越少，数据行就越少。
- en: 6.3 Wrangling data
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 数据整理
- en: At the start, most of our data wrangling operations will be around subsetting
    data (including or excluding observations that meet or fail to meet some logical
    criteria, or reducing the width of whole data sets by removing variables that
    won’t factor into our analysis) and combining, or joining, a pair of data sets
    into one object. Ultimately, we need data sources that can be cast into a series
    of complementary `ggplot2` visualizations that display quarter-by-quarter results
    in whole numbers and percentages. We’re a long way from doing that with our two
    .csv files as is.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，我们的大部分数据处理操作将围绕数据子集（包括或排除满足或未满足某些逻辑标准的观测值，或通过删除不会影响我们分析的因素的变量来减少整个数据集的宽度）以及合并或连接一对数据集到一个对象。最终，我们需要能够转换成一系列互补的`ggplot2`可视化数据源，这些可视化可以按季度显示整数和百分比结果。我们离用我们两个.csv文件做到这一点还有很长的路要走。
- en: 6.3.1 Subsetting data sets
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 数据子集
- en: We start by subsetting the nba1819 data set by calling the `filter()` function
    from the `dplyr` package so that nba1819 only includes observations where the
    variable `DATASET` equals `NBA 2018-2019 Regular Season` *and* the variable `MIN`
    (short for minutes) equals `240`. This subsequently reduces the nba1819 data set
    to only regular season games that ended in regulation (240 is the product of 48
    minutes times five players on the floor); or, put differently, we’re excluding
    regular season games that went into overtime and all playoff games.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过调用`dplyr`包中的`filter()`函数来对nba1819数据集进行子集化，以便nba1819只包含变量`DATASET`等于`NBA
    2018-2019 Regular Season`并且变量`MIN`（简称分钟数）等于`240`的观测值。这随后将nba1819数据集缩减到只有常规赛比赛，这些比赛以常规时间结束（240是48分钟乘以场上的五名球员的结果）；或者换句话说，我们排除了进入加时赛的常规赛比赛和所有季后赛比赛。
- en: There is a base R equivalent to the `dplyr filter()` function, which is the
    `subset()` function—they operate similarly and return the same results. But if
    and when you’re working with larger data sets, you might find that the `filter()`
    function provides a performance bump over `subset()`. Remember that R differentiates
    the `=` versus `==` operators; the former is an assignment operator, whereas the
    latter is an equal to operator. In addition, when filtering nba1819 where the
    variable `DATASET` equals `NBA 2018-2019 Regular Season` *and* (`&`) where the
    variable `MIN` equals `240`, we’re instructing R to subset our data where *both*
    conditions are met, not just one or the other.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: R语言中有一个与`dplyr filter()`函数等价的基函数，即`subset()`函数——它们操作类似，并返回相同的结果。但如果你在处理更大的数据集时，可能会发现`filter()`函数在性能上优于`subset()`。记住，R区分`=`和`==`运算符；前者是赋值运算符，而后者是等于运算符。此外，当过滤nba1819数据集，其中变量`DATASET`等于`NBA
    2018-2019 Regular Season`并且变量`MIN`（代表分钟数）等于`240`时，我们是在指示R对满足这两个条件的数据子集进行操作，而不仅仅是其中一个或另一个。
- en: 'We then call the `dim()` function to check the new dimension of nba1819:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后调用`dim()`函数来检查nba1819的新维度：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The nba1819 data set was 2,624 rows long when imported and now has a length
    of 2,326 rows.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 导入时，nba1819数据集有2,624行，现在长度为2,326行。
- en: 'With respect to the 2019-20 NBA season, where play was temporarily suspended
    due to the COVID-19 pandemic and then resumed (for most teams, not all) at a neutral
    site in Orlando, we subset the nba1920 data set to only include regular season
    games before the suspension of play that also ended in regulation. We therefore
    subset nba1920 so that the variable `GAME_ID` is equal to or less than `21900973`
    *and* the variable `MIN` equals `240`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于2019-20赛季的NBA，由于COVID-19大流行而暂时暂停比赛，然后在奥兰多一个中立场地（对于大多数球队，不是所有球队）恢复（对于大多数球队，不是所有球队），我们将nba1920数据集子集化，只包括暂停比赛之前的常规赛比赛，这些比赛也以常规时间结束。因此，我们将nba1920子集化，使得变量`GAME_ID`等于或小于`21900973`，并且变量`MIN`等于`240`：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then make another call to the `dim()` function, which, of course, returns
    the new dimension of the nba1920 data set. It now has a length of 1,820 rows,
    whereas it originally contained 2,286 observations:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们再次调用`dim()`函数，当然，它会返回nba1920数据集的新维度。现在它有1,820行，而最初它包含了2,286个观测值：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let’s now demonstrate some joining techniques.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将演示一些合并技术。
- en: 6.3.2 Joining data sets
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 数据集合并
- en: Base R and `dplyr` functions are available for combining two or more data sets
    into one object. While `dplyr` functions might perform best against larger data
    sets or when working with smaller machines, base R and `dplyr` functions otherwise
    operate alike and return equal results. Here, we’ll call one base R function and
    then one `dplyr` function for the purposes of joining data sets, mixed with other
    data wrangling operations.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基础R和`dplyr`函数可用于将两个或多个数据集合并成一个对象。虽然`dplyr`函数可能在处理大型数据集或在小型机器上工作时表现最佳，但基础R和`dplyr`函数在其他情况下操作类似，并返回相同的结果。在这里，我们将调用一个基础R函数，然后调用一个`dplyr`函数来合并数据集，同时混合其他数据处理操作。
- en: That being said, we first call the `rbind()` function from base R to row-bind
    the nba1819 and nba1920 data sets into a new object called nbadf1\. This works
    because both data sets have the same width and the same variable names; any differences
    would cause R to throw an error. The variables do *not* need to be in the same
    order for this operation to be successful.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们首先调用基础R中的`rbind()`函数，将nba1819和nba1920数据集行绑定到一个名为nbadf1的新对象中。这是因为两个数据集具有相同的宽度和相同的变量名；任何差异都会导致R抛出错误。变量不需要按相同的顺序排列，此操作才能成功。
- en: 'The `dim()` function is called immediately afterward to return the dimension
    of our new object:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着调用`dim()`函数来返回我们新对象的维度：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We see that nbadf1 contains 57 variables and 4,146 observations, comprising
    2,326 observations from nba1819 and 1,820 from nba1920.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到nbadf1包含57个变量和4,146个观测值，包括来自nba1819的2,326个观测值和来自nba1920的1,820个观测值。
- en: 'Then, we subset our new working data set by calling the `select()` function
    from the `dplyr` package to retain just the 16 variables positioned between `DATASET`
    and `MIN`; another call to the `dim()` function confirms that the width of nbadf1
    has, in fact, been reduced from 57 columns to just 16\. The semicolon in our code
    tells R to accept every variable from `DATASET` through `MIN`, which is a much
    better alternative than calling out all 16 variables:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们通过调用`dplyr`包中的`select()`函数来对新的工作数据集进行子集化，只保留位于`DATASET`和`MIN`之间的16个变量；再次调用`dim()`函数确认nbadf1的宽度实际上已经从57列减少到仅16列。我们代码中的分号告诉R接受从`DATASET`到`MIN`之间的所有变量，这比列出所有16个变量要好得多：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we split nbadf1 into equal halves by calling the `dplyr filter()` function
    twice: once where the variable `VENUE` equals `R` for road, and those observations
    are thrown into a data set called road, and then where `VENUE` instead equals
    `H` for home, and those observations are thrown into a data set called home. (Unless
    there are extenuating circumstances, NBA games—regular season and postseason—are
    *never* played at neutral sites. Regardless, teams are always designated as road
    or home.) Both calls are shown here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过两次调用`dplyr filter()`函数将nbadf1分成相等的两半：一次是变量`VENUE`等于`R`（客场），这些观测值被放入一个名为road的数据集中，然后是`VENUE`等于`H`（主场），这些观测值被放入一个名为home的数据集中。（除非有特殊情况，NBA比赛——常规赛和季后赛——永远不会在中立场地进行。无论如何，球队总是被指定为客场或主场。）两个调用都显示在这里：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `dim()` function returns like dimensions for both objects, which is a good
    thing because there should be an equal number of road and home observations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`dim()`函数为两个对象返回相同的维度，这是好事，因为应该有相等数量的客场和主场观测值。'
- en: 'Our road and home data sets are about to be merged horizontally, but we first
    need to give them unique variable names. The `rename()` function from the `dplyr`
    package allows us to rename variables where the variable name on the left side
    of the assignment operator is the new variable name, and the variable name on
    the right side of the assignment operator is the old, or existing, variable name:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将合并客场和主场的横向数据集，但首先我们需要给它们赋予唯一的变量名。`dplyr`包中的`rename()`函数允许我们重命名变量，其中赋值运算符左侧的变量名是新变量名，右侧的变量名是旧变量名或现有变量名：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Most of the new variable names were appended with either the letter R or the
    letter H to distinguish road and home on otherwise like variables. The three exceptions
    to this are the variables now named `dataset`, `ID`, and `date`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数新的变量名都附加了字母R或H来区分客场和主场，否则变量是相同的。有三个例外，现在命名为`dataset`、`ID`和`date`的变量。
- en: We then perform a left join on road and home by calling the `dplyr left_join()`
    function to merge the two data sets by matching rows; we specifically match road
    and home by the variables `dataset`, `ID`, and `date`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用`dplyr left_join()`函数在客场和主场之间执行左连接，通过匹配行来合并两个数据集；我们特别通过变量`dataset`、`ID`和`date`来匹配客场和主场。
- en: 'We then immediately call the `dim()` function to again check the dimension
    of our working data set, called nbadf2; nbadf2 contains 2,073 rows (half of 4,146)
    and 29 variables (16 from the road data set and another 16 from the home data
    set, minus the common variables `dataset`, `ID`, and `date`):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们立即调用`dim()`函数再次检查工作数据集nbadf2的维度；nbadf2包含2,073行（4,146行的一半）和29个变量（16个来自客场数据集，另外16个来自主场数据集，减去共同的变量`dataset`、`ID`和`date`）：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Again, we call the `dplyr select()` function to remove unnecessary or duplicate
    variables (notice the minus sign that precedes the base R `c()` function); and
    again, we call the `dim()` function to return the row and column counts. As a
    reminder, the `c()` function is called when we need to create a vector or concatenate
    multiple objects into a single vector:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们调用`dplyr select()`函数来删除不必要的或重复的变量（注意在基础R `c()`函数之前的前导减号）；再次，我们调用`dim()`函数来返回行和列计数。提醒一下，当我们需要创建向量或将多个对象连接成一个向量时，会调用`c()`函数：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We now have the data set nbadf2 containing 2,073 rows and 17 columns.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了包含2,073行和17列的数据集nbadf2。
- en: 'Next, we convert five of the remaining nbadf2 variables to factor variables
    by making successive calls to the base R `as.factor()` function. This is a good
    practice when your variables are categorical or ordinal and have a fixed set of
    possible values:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过连续调用基础R的`as.factor()`函数将nbadf2剩余的五个变量转换为因子变量。当你的变量是分类的或有序的，并且有一个固定的可能值集合时，这是一个好的做法：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we make a call to the `dplyr glimpse()` function to return a transposed
    snapshot of the nbadf2 data set:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`dplyr glimpse()`函数来返回nbadf2数据集的转置快照：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here’s a variable-by-variable breakdown of nbadf2:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是nbadf2变量按变量分解的说明：
- en: '`dataset`—Equals `NBA 2018-2019 Regular Season` or `NBA 2019-2020 Regular Season`.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dataset`—等于`NBA 2018-2019常规赛季`或`NBA 2019-2020常规赛季`。'
- en: '`ID`**—**A unique identifier for each game that increments by one in chronological
    order.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ID`**—**为每场比赛提供一个唯一的标识符，按时间顺序递增。'
- en: '`date`**—**The date on which a game was played in *MM/DD/YY* format.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`**—**表示比赛进行的日期，格式为*MM/DD/YY*。'
- en: '`teamR`**—**The road, or visiting, team where, for instance, `Golden State`
    equals `Golden State Warriors` and `Boston` equals `Boston Celtics.`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`teamR`**—**表示客场或访问球队，例如`Golden State`等于`Golden State Warriors`，`Boston`等于`Boston
    Celtics`。'
- en: '`venueR`**—**Always equals `R`, which is short for road.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`venueR`**—**始终等于`R`，这是客场（road）的简称。'
- en: '`Q1R`**—**Equals the number of points scored by the road team in the first
    quarter.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q1R`**—**等于第一季度客场球队所得的分数。'
- en: '`Q2R`**—**Equals the number of points scored by the road team in the second
    quarter.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q2R`**—**等于第二季度客场球队所得的分数。'
- en: '`Q3R`**—**Equals the number of points scored by the road team in the third
    quarter.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q3R`**—**等于第三季度客场球队所得的分数。'
- en: '`Q4R`**—**Equals the number of points scored by the road team in the fourth
    quarter.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q4R`**—**等于第四季度客场球队所得的分数。'
- en: '`FR`**—**Equals the total number of points scored by the road team for an entire
    game. Because we previously removed overtime games from our data set, `FR` *always*
    equals the sum of the previous four variables.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FR`**—**等于整个比赛期间客场球队所得的总分数。因为我们之前从数据集中移除了加时赛，所以`FR`*总是*等于前四个变量的总和。'
- en: '`teamH`**—**The home team in the same format as the variable `teamR`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`teamH`**—**与变量`teamR`相同的格式。'
- en: '`venueH`**—**Always equals `H`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`venueH`**—**始终等于`H`。'
- en: '`Q1H`**—**Equals the number of points scored by the home team in the first
    quarter.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q1H`**—**等于主队在第一节得到的分数。'
- en: '`Q2H`**—**Equals the number of points scored by the home team in the second
    quarter.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q2H`**—**等于主队在第二节得到的分数。'
- en: '`Q3H`**—**Equals the number of points scored by the home team in the third
    quarter.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q3H`**—**等于主队在第三节得到的分数。'
- en: '`Q4H`**—**Equals the number of points scored by the home team in the fourth
    quarter.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Q4H`**—**等于主队在第四节得到的分数。'
- en: '`FH`**—**Equals the total number of points scored by the home team for an entire
    game; also equals the sum of the previous four variables.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FH`**—**等于主队在整个比赛中得到的总分数；也等于前四个变量的总和。'
- en: With our data sets successfully wrangled and joined, we’re ready to start doing
    some analysis.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功整理和合并我们的数据集后，我们准备开始进行一些分析。
- en: 6.4 Analysis
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 分析
- en: 'Our analysis effort will be a three-pronged attack:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的分析工作将是一个三管齐下的攻击：
- en: First, we’ll compute and visualize quarter-by-quarter results versus end-of-game
    results to determine if winning teams were more successful in the fourth quarter
    versus the first, second, and third quarters.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将计算并可视化每节与比赛结束时的结果，以确定获胜队伍在第四节相对于第一、第二和第三节是否更成功。
- en: Second, we’ll subset our data set on the six most successful teams over the
    2018-19 and 2019-20 NBA regular seasons and again on the six least successful
    teams and then compute and visualize their winning percentages when winning one
    quarter versus the other, broken down by playing on the road versus at home.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们将数据集子集化到2018-19和2019-20 NBA常规赛中最成功的六支球队和最不成功的六支球队，然后计算并可视化它们在一节获胜与另一节获胜时的胜率，按客场与主场的比赛进行细分。
- en: Third, we’ll reduce our data set to include only those games that were tied
    at halftime and then compare third- and fourth-quarter results versus end-of-game
    results.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，我们将数据集缩减到只包括半场平局的游戏，然后比较第三、四节的结果与比赛结束时的结果。
- en: We’ll find that the preponderance of the evidence supports the idea that games
    are most often *not* won in the fourth quarter but rather most often in the third
    quarter, thereby confirming our hypothesis.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会发现，大量证据支持这样一个观点：比赛通常不是在第四节赢得，而是在第三节赢得，从而证实了我们的假设。
- en: 6.4.1 First quarter
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.1 第一节
- en: 'Our first action is to create a new data set, nbadf3, by calling the `filter()`
    function to subset the nbadf2 data set where the variables `Q1R` and `Q1H` aren’t
    equal; basically, we’re subsetting nbadf2 by eliminating observations, or games,
    where the score was tied at the end of the first quarter. The `NOT` `(!)` operator
    evaluates `!TRUE` statements as `FALSE` and `!FALSE` statements as `TRUE`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是创建一个新的数据集，nbadf3，通过调用`filter()`函数来对nbadf2数据集进行子集化，其中变量`Q1R`和`Q1H`不相等；基本上，我们通过消除观察值或比赛来子集化nbadf2，这些观察值或比赛在第一节结束时得分持平。`NOT`
    `(!)`运算符将`!TRUE`语句评估为`FALSE`，将`!FALSE`语句评估为`TRUE`：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The nbadf3 data set has 1,990 rows.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: nbadf3数据集有1,990行。
- en: 'In the following chunk of code, we call a pair of `dplyr` functions, `mutate``()`
    and `case_when``()`, to create a new nbadf3 variable called `Q1vF` that will be
    populated with one of four values based on conditional logic:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们调用了一对`dplyr`函数，`mutate()`和`case_when()`，来创建一个新的名为`Q1vF`的变量，该变量将根据条件逻辑填充四个值之一：
- en: When the home team scores more first-quarter points than the road team *and*
    then wins the game, `Q1vF` will equal `HH`.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当主队在第一节得到的分数多于客队并且随后赢得比赛时，`Q1vF`将等于`HH`。
- en: When the road team scores more first-quarter points than the home team *and*
    then wins the game, `Q1vF` will equal `RR`.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当客队在第一节得到的分数多于主队并且随后赢得比赛时，`Q1vF`将等于`RR`。
- en: When the home team scores more first-quarter points than the road team, but
    then the road team wins the game, `Q1vF` will equal `HR`.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当主队在第一节得到的分数多于客队，但随后客队赢得比赛时，`Q1vF`将等于`HR`。
- en: When the road team scores more first-quarter points than the home team, but
    then the home team wins the game, `Q1vF` will equal `RH`.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当客队在第一节得到的分数多于主队，但随后主队赢得比赛时，`Q1vF`将等于`RH`。
- en: 'Our new variable is then converted to a factor:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将我们的新变量转换为因子：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then create a tibble that is more involved than other tibbles we’ve created
    in previous chapters:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个比之前章节中创建的其他tibble更复杂的数据框：
- en: We start by calling the `count()` function from the `dplyr` package; it tallies
    the number of observations in nbadf3 for each of the four levels in the derived
    variable `Q1vF` and pipes the same to a pair of other `dplyr` functions, `arrange``()`
    and `desc``()`, to stack the results in a variable called `n` and to sort them
    in descending order.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先调用来自 `dplyr` 包的 `count()` 函数；它计算 `nbadf3` 中每个 `Q1vF` 导出变量四个级别的观测数，并将相同的结果传递给一对其他
    `dplyr` 函数，`arrange()` 和 `desc()`，以便将结果堆叠在名为 `n` 的变量中，并按降序排序。
- en: Our new object is then piped to a series of calls to the `mutate()` function
    to create three additional tbl1 variables. Our first call to `mutate()` creates
    a variable called `pct_total`, which is equal to `n` divided by the nbadf3 row
    count and then multiplied by 100.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将新对象传递给一系列对 `mutate()` 函数的调用，以创建三个额外的 tbl1 变量。我们第一次调用 `mutate()` 创建了一个名为
    `pct_total` 的变量，该变量等于 `n` 除以 nbadf3 行数，然后乘以 100。
- en: Our second call to `mutate()` creates a variable called `cum_n`, which equals
    the cumulative sum of `n`; `cumsum``()` is a built-in function that returns a
    vector of cumulative sums derived from the raw data in another vector. For instance,
    if we have a vector containing the numerals 1, 2, and 3, `cumsum()` would return
    1, 3, and 6.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们第二次调用 `mutate()` 创建了一个名为 `cum_n` 的变量，该变量等于 `n` 的累积和；`cumsum()` 是一个内置函数，它返回从另一个向量中的原始数据派生的累积和向量。例如，如果我们有一个包含数字
    1、2 和 3 的向量，`cumsum()` 将返回 1、3 和 6。
- en: Our third and final call to `mutate()` creates a variable called `cum_pct_total`,
    which converts the values in `cum_n` to a percentage against the total record
    count in the nbadf3 data set.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们对 `mutate()` 的第三次也是最后一次调用创建了一个名为 `cum_pct_total` 的变量，该变量将 `cum_n` 中的值转换为相对于
    nbadf3 数据集中总记录数的百分比。
- en: The variables `pct_total` and `cum_pct_total` are then formatted by calling
    the base R `round()` function so that only two digits to the right of the decimal
    point are returned.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，通过调用基础 R 的 `round()` 函数，将 `pct_total` 和 `cum_pct_total` 变量格式化，以便只返回小数点后两位数字。
- en: 'The end result is a tibble with four rows and five columns:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是包含四行五列的 tibble。
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To check or reconcile our results, we then make a series of calls to the `sqldf()`
    function from the `sqldf` package. `SELECT` and `COUNT(*)` return the nbadf3 record
    counts that equal the variable `n` from tbl1:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查或协调我们的结果，我们随后对 `sqldf()` 函数进行了一系列调用，该函数来自 `sqldf` 包。`SELECT` 和 `COUNT(*)`
    返回与 tbl1 中的变量 `n` 相等的 nbadf3 记录计数：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'By substituting the pipe operator in lieu of `FROM` and passing the `sqldf()
    WHERE` clause to the `count()` function, we can easily convert our `SELECT` statements
    to `dplyr` code. But note that `dplyr` uses `&`, whereas `sqldf()` uses `AND`,
    and `dplyr` returns counts for `TRUE` and `FALSE` observations, whereas `sqldf()`
    only returns the record count that actually satisfies the logic:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用管道运算符代替 `FROM` 并将 `sqldf()` 的 `WHERE` 子句传递给 `count()` 函数，我们可以轻松地将我们的 `SELECT`
    语句转换为 `dplyr` 代码。但请注意，`dplyr` 使用 `&`，而 `sqldf()` 使用 `AND`，并且 `dplyr` 为 `TRUE`
    和 `FALSE` 观测返回计数，而 `sqldf()` 只返回实际满足逻辑的记录计数：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Thankfully, everything checks either way.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，无论如何检查都是正确的。
- en: Let’s now visualize our results with a pair of complementary `ggplot2` bar charts.
    The first of these, plot1a, displays the number of wins. Remember, these are regular
    season wins between the 2018-19 and 2019-20 seasons, minus games played in Orlando,
    games that went into overtime, and games that ended in a first-quarter tie between
    the four factors from our derived variable `Q1vF`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用一对互补的 `ggplot2` 条形图来可视化我们的结果。其中第一个，plot1a，显示了获胜次数。记住，这些是2018-19赛季和2019-20赛季之间的常规赛季获胜次数，减去在奥兰多进行的比赛、进入加时赛的比赛以及来自我们导出变量
    `Q1vF` 的四个因素之间的首节平局比赛。
- en: Our second visualization, plot1b, returns more or less the same view, except
    winning percentages are substituted for wins. Thus, we have similar looks between
    plot1a and plot1b, with like results from different, yet complementary, measures.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个可视化，plot1b，几乎返回相同的视图，只是用获胜百分比代替了获胜次数。因此，plot1a 和 plot1b 之间有相似的外观，从不同的、但互补的度量中获得了类似的结果。
- en: 'A few additional points are warranted:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调几点：
- en: In both plots, we call the base R `reorder()` function to sort the `Q1vF` factors
    in descending order by the tbl1 variables `n` (in the case of plot1a) and `pct_total`
    (in the case of plot1b). Note the minus operator that precedes the variable names;
    without this, the results would be sorted in ascending order.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个图表中，我们调用基础R的`reorder()`函数，按`tbl1`变量`n`（在plot1a的情况下）和`pct_total`（在plot1b的情况下）的降序对`Q1vF`因子进行排序。注意变量名前面的负号；如果没有这个负号，结果将按升序排序。
- en: A custom color and fill scheme is added to emphasize results where the same
    team won the first quarter and won the game while simultaneously de-emphasizing
    the opposite results; we’ve chosen a bright color for the one and a light gray
    for the other.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个自定义的颜色和填充方案来强调在第一季度赢得比赛并且赢得比赛的队伍，同时降低相反结果的重要性；我们为前者选择了明亮的颜色，为后者选择了浅灰色。
- en: Labels affixed atop the bars tie back to the y-axis variables and are formatted
    with a bold font.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栏状图顶部的标签与y轴变量相关联，并使用粗体字体格式化。
- en: Winning percentages might be off by a tenth of a percent due to rounding.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于四舍五入，胜率可能相差十分之一。
- en: 'The code for both visualizations follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 两个可视化的代码如下：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Our two visualizations are then paired side by side into a single object (see
    figure 6.1), which is made possible by calling the `plot_layout()` function from
    the `patchwork` package.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将两个可视化并排配对成一个单一的对象（见图6.1），这是通过调用`patchwork`包中的`plot_layout()`函数实现的。
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![CH06_F01_Sutton](../../OEBPS/Images/CH06_F01_Sutton.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F01_Sutton](../../OEBPS/Images/CH06_F01_Sutton.png)'
- en: Figure 6.1 Teams that win the first quarter and then proceed to win the same
    game just over two-thirds of the time
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1第一季度赢得比赛的队伍有超过三分之二的时间赢得相同的比赛
- en: Teams that won the first quarter subsequently won the game almost 67% of the
    time (equals 39.35% + 27.64% from plot1b). Home teams that won the first quarter
    had an overall winning percentage equal to almost 73% (equals 783 / 783 + 292
    from plot1a); road teams, on the other hand, won about 60% of the time after winning
    the first quarter (equals 550 / 550 + 365 from plot1a).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一季度赢得比赛的公司随后有大约67%的时间赢得比赛（等于plot1b中的39.35% + 27.64%）。在第一季度赢得比赛的主队整体胜率几乎等于73%（等于783
    / 783 + 292来自plot1a）；另一方面，客场队在赢得第一季度比赛后有大约60%的时间获胜（等于550 / 550 + 365来自plot1a）。
- en: 6.4.2 Second quarter
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.2 第二季度
- en: 'Next, we repeat this exercise in full, except now our purpose is to compare
    second-quarter results to final scores. We call the `filter()` function to create
    a new object called nbadf4 that equals the nbadf2 data set, minus any observations
    where the road and home teams scored the same number of second-quarter points:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再次进行完整的练习，但现在我们的目的是比较第二季度结果和最终得分。我们调用`filter()`函数创建一个新的对象nbadf4，它等于nbadf2数据集，减去任何客场队和主队在第二季度得分相同的观测值：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We then call the `mutate``()` and `case_when()` functions to create a new nbadf4
    variable called `Q2vF`, which is a second-quarter version of the derived variable
    `Q1vF` we previously created and then appended to nbadf3\. Our new variable is
    then converted to a factor by calling the `as.factor()` function from base R:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后调用`mutate()`和`case_when()`函数来创建一个新的变量`Q2vF`，这个变量是之前创建并附加到`nbadf3`上的派生变量`Q1vF`的第二季度版本。然后，我们通过调用基础R中的`as.factor()`函数将新变量转换为因子：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the following code chunk, we create a tibble called tbl2, which is merely
    a second-quarter version of our first tibble, tbl1\. There are no differences
    between tbl1 and tbl2, except that we’ve substituted data sources (nbadf3 in favor
    of nbadf4) and derived variables (`Q1vF` swapped out for `Q2vF`):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们创建了一个名为tbl2的tibble，它只是我们第一个tibble，tbl1的第二季度版本。tbl1和tbl2之间没有区别，除了我们已经替换了数据源（用nbadf4代替nbadf3）和派生变量（用`Q2vF`替换`Q1vF`）：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we create a second pair of `ggplot2` bar charts and then bundle the
    two visualizations into a single graphical object (see figure 6.2):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建第二对`ggplot2`条形图，然后将两个可视化捆绑成一个单一的图形对象（见图6.2）：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![CH06_F02_Sutton](../../OEBPS/Images/CH06_F02_Sutton.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F02_Sutton](../../OEBPS/Images/CH06_F02_Sutton.png)'
- en: Figure 6.2 Teams that win the second quarter then proceed to win the same game
    just under 65% of the time, a figure slightly below what we previously saw with
    respect to first-quarter results.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2中赢得第二季度的队伍有大约65%的时间赢得相同的比赛，这个数字略低于我们之前看到的第一季度结果。
- en: Teams that won the second quarter subsequently won the same game almost 65%
    of the time, a figure more than two percentage points less than what we previously
    saw with respect to first-quarter results. Home teams that won the second quarter
    had an overall winning percentage of roughly 71%, versus 73% for home teams that
    won the first quarter; road teams won approximately 58% of the time after winning
    the second quarter, compared to a 60% winning percentage for road teams that won
    the first quarter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 赢得第二季度的球队随后赢得同一场比赛的比例几乎达到65%，这个数字比我们之前看到的第一季度结果低两个百分点以上。主场赢得第二季度的球队的整体获胜比例约为71%，而主场赢得第一季度的球队获胜比例为73%；客场赢得第二季度的球队获胜比例约为58%，而客场赢得第一季度的球队获胜比例为60%。
- en: 6.4.3 Third quarter
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.3 第三节
- en: 'Let’s now look at the third-quarter results versus end-of-game results. This
    time, our code has been consolidated into one chunk, ending with another pair
    of `ggplot2` bar charts (see figure 6.3):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来看看第三节结果与比赛结束结果。这次，我们的代码被合并成一个块，以另一对`ggplot2`条形图结束（见图6.3）：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![CH06_F03_Sutton](../../OEBPS/Images/CH06_F03_Sutton.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F03_Sutton](../../OEBPS/Images/CH06_F03_Sutton.png)'
- en: Figure 6.3 Teams that win the third quarter then proceed to win the same game
    more than 67% of the time, which is the highest winning percentage yet.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 赢得第三节的球队随后赢得同一场比赛的比例超过67%，这是迄今为止最高的获胜比例。
- en: 'Home and road teams that won the third quarter then won more than 67% of those
    same games—the highest figure yet. Home team performance is mostly responsible
    for these results: 74% of the time, when the home team won the third quarter,
    it then went on to win the same game, compared to just a 60% winning percentage
    for road teams.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 主场和客场赢得第三节的球队随后赢得了超过67%的相同比赛——这是迄今为止最高的数字。主场球队的表现主要对这些结果负责：74%的时间，当主场球队赢得第三节时，它随后赢得了同一场比赛，而客场球队的获胜比例仅为60%。
- en: 6.4.4 Fourth quarter
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.4 第四节
- en: 'We then run our end-of-quarter versus end-of-game results one more time, this
    time focusing on the fourth quarter. Our code has again been consolidated into
    a single chunk, and our results are again visualized in a pair of `ggplot2` bar
    charts packed into a single graphical representation of the data (see figure 6.4):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次运行了季度结束与比赛结束的结果，这次专注于第四节。我们的代码再次被合并成一个块，我们的结果再次通过一对`ggplot2`条形图可视化，这些图表被压缩在一个单一的数据图形表示中（见图6.4）：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![CH06_F04_Sutton](../../OEBPS/Images/CH06_F04_Sutton.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F04_Sutton](../../OEBPS/Images/CH06_F04_Sutton.png)'
- en: Figure 6.4 Teams that won the fourth quarter then proceeded to win the same
    game just under 66% of the time, which is the lowest winning percentage aside
    from our second-quarter results.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 赢得第四节的球队随后赢得同一场比赛的比例接近66%，这是除了我们第二季度结果之外最低的获胜比例。
- en: The winning team in the fourth quarter was also the game winner in nearly 66%
    of the applicable games in our data set. Home teams that won the fourth quarter
    also won about 72% of the time; road teams won approximately 58% of the games
    in which they scored the most points in the fourth quarter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四节获胜的球队在我们的数据集中也几乎在66%的相关比赛中赢得了比赛。主场赢得第四节的球队也大约有72%的时间获胜；客场球队在第四节得分最高的比赛中获胜的比例约为58%。
- en: It’s difficult, if not impossible, to say when games are won, especially if
    the choice is between one quarter versus another. Nevertheless, winning teams
    won the third quarter more than they won the fourth quarter, or any quarter for
    that matter, which, of course, is an affront to the conventional wisdom that games
    are won in the fourth quarter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要说何时赢得比赛，尤其是当选择是某一节对另一节时，这很困难，甚至可能不可能。尽管如此，获胜的球队赢得第三节比赛的比例高于赢得第四节比赛的比例，或者任何其他节比赛的比例，这当然是对传统观点的挑战，即比赛是在第四节赢得的。
- en: Our next analysis will focus on the best six and worst six teams over the 2018-19
    and 2019-20 regular seasons.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的分析将关注2018-19赛季和2019-20赛季常规赛中表现最佳和最差的六支球队。
- en: 6.4.5 Comparing best and worst teams
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.5 比较最佳和最差球队
- en: Let’s now do a deeper yet more focused dive by repeating our analysis on a data
    set that includes just the six teams that won the most regular season games between
    the 2018-19 and 2019-20 regular seasons (not including neutral-site games following
    the COVID-19 suspension of play). These six teams are the Milwaukee Bucks (116
    wins), Toronto Raptors (111), Denver Nuggets (100), Boston Celtics (97), Houston
    Rockets (97), and Los Angeles Clippers (97). We’ll then do the same analysis on
    a data set that just includes the six worst teams.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过在包括 2018-19 和 2019-20 赛季常规赛中赢得最多常规赛比赛的六个团队的数据集上重复我们的分析来做一个更深更专注的深入研究（不包括因
    COVID-19 停赛后的中立场地比赛）。这六个团队是密尔沃基雄鹿（116 胜），多伦多猛龙（111），丹佛掘金（100），波士顿凯尔特人（97），休斯顿火箭（97）和洛杉矶快船（97）。然后，我们将在仅包括这六个最差团队的数据集上执行相同的分析。
- en: Best 6
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳 6
- en: To make this happen, we first create a data set called nbadf7, a subset of nbadf3,
    by calling the `dplyr filter()` function to include only those observations where
    one of the six aforementioned teams was the designated road team. Whereas the
    `AND` `(&)` operator takes two or more logical values and returns `TRUE` only
    if all values are, in fact, `TRUE`, the `OR` `(|)` operator returns `TRUE` if
    at least one of the values is `TRUE`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，我们首先通过调用 `dplyr filter()` 函数创建一个名为 nbadf7 的数据集，它是 nbadf3 的一个子集，只包含上述六个团队中任一团队被指定为客场球队的观测。而
    `AND` `(&)` 运算符接受两个或多个逻辑值，只有当所有值实际上都是 `TRUE` 时才返回 `TRUE`，而 `OR` `(|)` 运算符如果至少有一个值是
    `TRUE` 就返回 `TRUE`。
- en: 'Then, we subset nbadf7 on those observations where the variable `Q1vF` equals
    `RR` or `RH`. The results are saved in a new object called nbadf8:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在那些变量 `Q1vF` 等于 `RR` 或 `RH` 的观测上对 nbadf7 进行子集化。结果保存在一个名为 nbadf8 的新对象中：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We then call the `count()` function to tally the number of observations in
    nbadf8 where `Q1vF` equals `RR` versus `RH` and then call the `arrange()` function
    to sort the results in descending order; the results are cast into a tibble called
    tbl5\. We then call the `mutate()` function to create a variable called `pct_total`,
    which computes the percentage of `n` against the total record count; that variable
    is subsequently reduced to include just two digits right of the decimal point:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用 `count()` 函数来统计 nbadf8 中 `Q1vF` 等于 `RR` 与 `RH` 的观测数量，然后调用 `arrange()`
    函数按降序排序结果；结果被转换成一个名为 tbl5 的 tibble。然后我们调用 `mutate()` 函数创建一个名为 `pct_total` 的变量，该变量计算
    `n` 与总记录数的百分比；该变量随后被缩减到只保留小数点后两位：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This exercise is repeated three times, first by substituting the second quarter
    in place of the first quarter by swapping out the variable `Q1vF` for `Q2vF`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习重复了三次，首先是通过将第二季度替换为第一季度，通过将变量 `Q1vF` 替换为 `Q2vF` 来实现的：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we replace the variable `Q2vF` with `Q3vF`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将变量 `Q2vF` 替换为 `Q3vF`：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we tally fourth-quarter results by inserting the variable `Q4vF` in
    lieu of `Q3vF`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过将变量 `Q4vF` 插入 `Q3vF` 的位置来统计第四季度的结果：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We next create a data set from scratch, which we’ll name df1, by calling the
    `data.frame()` function from base R to store results where the variables `Q1vF`,
    `Q2vF`, `Q3vF`, and `Q4vF` equal `RR`. We then call the base R `c()` function
    to add a pair of vectors to our data frame. Our first vector is a character string
    called `quarter` (note the use of quotation marks around the attributes), and
    our second vector is a numeric variable called `win_pct` (note the lack of quotation
    marks). Creating a data set from scratch only makes sense when the row and column
    counts are kept to a minimum by design; otherwise, an investment in automation
    should be in order:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来从头创建一个名为 df1 的数据集，通过调用基础 R 的 `data.frame()` 函数来存储变量 `Q1vF`、`Q2vF`、`Q3vF`
    和 `Q4vF` 等于 `RR` 的结果。然后我们调用基础 R 的 `c()` 函数向我们的数据框中添加一对向量。我们的第一个向量是一个名为 `quarter`
    的字符串（注意属性周围的引号），我们的第二个向量是一个名为 `win_pct` 的数值变量（注意没有引号）。从头创建数据集只有在设计上保持行和列计数最小的情况下才有意义；否则，应该进行自动化投资：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Our results are then visualized in a bar chart. We’ll temporarily hold our
    plot in memory and then print it as one object alongside another `ggplot2` bar
    chart:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将结果可视化在条形图中。我们将暂时将我们的绘图保存在内存中，然后将其作为单一对象与另一个 `ggplot2` 条形图一起打印：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s now see how these same teams performed at home:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这些相同的团队在主场的表现：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once again, we make a call to the `plot_layout()` function to pack our last
    two bar charts, `plot5` and `plot6`, into a single object (see figure 6.5):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们调用 `plot_layout()` 函数将最后两个条形图 `plot5` 和 `plot6` 打包成一个单一的对象（见图 6.5）：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![CH06_F05_Sutton](../../OEBPS/Images/CH06_F05_Sutton.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F05_Sutton](../../OEBPS/Images/CH06_F05_Sutton.png)'
- en: Figure 6.5 The NBA’s best teams over the 2018-19 and 2019-20 regular seasons
    won the third quarter more frequently than other quarters in games they went on
    to win. This was true for both road and home games.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 在2018-19和2019-20赛季常规赛中，NBA最优秀的球队在赢得比赛时比其他季度更频繁地赢得了第三季度。这在客场和主场的比赛中都适用。
- en: So the league’s best teams most often won the third quarter, on the road and
    at home, when winning the same game. At the same time, these teams were *least*
    successful in the fourth quarter when road and home results are combined.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，联赛中最优秀的球队在赢得比赛时，最常在客场和主场的第三季度获胜。同时，这些球队在第四季度，当客场和主场的成绩合并时，**最不成功**。
- en: Worst 6
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最差6队
- en: 'Now, what about the worst teams—do we see like or different results? We’ll
    next reuse our code and apply it to the worst six teams over the 2018-19 and 2019-20
    regular seasons. These teams are the Minnesota Timberwolves (55 wins), Phoenix
    Suns (53), Atlanta Hawks (49), Chicago Bulls (44), Cleveland Cavaliers (38), and
    New York Knicks (38). Results are summarized and visualized in another pair of
    `ggplot2` bar charts (see figure 6.6):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于最差的球队——我们是否看到了类似或不同的结果？接下来，我们将重用我们的代码，并将其应用于2018-19和2019-20赛季常规赛中最差的六支球队。这些球队是明尼苏达森林狼（55胜）、菲尼克斯太阳（53胜）、亚特兰大老鹰（49胜）、芝加哥公牛（44胜）、克利夫兰骑士（38胜）和纽约尼克斯（38胜）。结果被总结并在另一对`ggplot2`条形图中可视化（见图6.6）：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![CH06_F06_Sutton](../../OEBPS/Images/CH06_F06_Sutton.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F06_Sutton](../../OEBPS/Images/CH06_F06_Sutton.png)'
- en: Figure 6.6 The NBA’s worst teams over the 2018-19 and 2019-20 regular seasons.
    When they did manage to win, they most frequently won the first quarter when on
    the road and the fourth quarter when playing at home.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 在2018-19和2019-20赛季常规赛中，NBA最差的球队。当它们设法获胜时，最常在客场赢得第一季度，在主场赢得第四季度。
- en: When playing on the road, the NBA’s least successful teams most frequently won
    the first quarter when winning the same game. When playing at home instead, these
    same teams won the fourth quarter most frequently when also winning the game.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当在客场作战时，NBA最不成功的球队在赢得比赛时最常在第一季度获胜。当在主场作战时，这些球队在赢得比赛时最常在第四季度获胜。
- en: Most of the evidence so far suggests the *third* quarter matters most, in spite
    of these latest results; at a minimum, there is barely any evidence to otherwise
    suggest that fourth-quarter results are more significant than results over the
    first three quarters. Again, this finding further confirms our hypothesis. But
    let’s take one more look.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，大部分证据表明**第三季度**最为重要，尽管有这些最新的结果；至少，几乎没有证据表明第四季度的结果比前三个季度的结果更为显著。再次，这一发现进一步证实了我们的假设。但让我们再仔细看看。
- en: 6.4.6 Second-half results
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4.6 半场结果
- en: In our final analysis, we’ll investigate third- and fourth-quarter results against
    a data set that includes only those 2018-19 and 2019-20 regular season games that
    were tied at halftime. We’re therefore pairing the last two quarters against one
    another and, in the process, disregarding the first two quarters; in other words,
    in this final analysis, we’re examining the quarter thought to be decisive based
    on conventional wisdom (i.e., the fourth quarter) versus the one that, based on
    our analysis so far, *is* decisive (i.e., the third quarter).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最终分析中，我们将调查第三季度和第四季度的结果，数据集仅包括2018-19和2019-20赛季常规赛中半场平局的比赛。因此，我们将最后两个季度相互配对，在这个过程中，我们忽略了前两个季度；换句话说，在这个最终分析中，我们正在检查根据传统智慧认为是决定性的季度（即第四季度）与根据我们到目前为止的分析确实是决定性的季度（即第三季度）之间的比较。
- en: 'We therefore call the `dplyr filter()` function to subset the nbadf2 data set
    on those observations where the road and home teams scored the same number of
    points between quarters 1 and 2\. The results are cast into a new object called
    nbadf39:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们调用`dplyr filter()`函数对nbadf2数据集进行子集化，选取那些在第一和第二季度之间双方球队得分相同的观测值。结果被转换成一个新的对象，称为nbadf39：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We again call the `filter()` function, this time to subset nbadf39 on those
    observations where neither the third or fourth quarters ended with both the road
    and home teams scoring the same number of points. Therefore, the nbadf39 data
    set includes a winning team for every third and fourth quarter:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次调用`filter()`函数，这次是为了对nbadf39数据集进行子集化，选取那些第三季度或第四季度结束时双方球队得分相同的观测值。因此，nbadf39数据集包含了每个第三季度和第四季度的获胜球队：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By running the `dim()` function, we see that nbadf39 is just 61 rows long.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`dim()`函数，我们看到nbadf39只有61行。
- en: 'In the chunk of code that follows, we pipe the nbadf39 data set to a pair of
    `dplyr` functions: the `tally()` function counts the number of records in nbadf39
    for every result combination called out in the `group_by()` function.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码块中，我们将nbadf39数据集通过管道传递到一对`dplyr`函数：`tally()`函数计算nbadf39中`group_by()`函数中指定的每个结果组合的记录数。
- en: The arguments passed to the `group_by()` function map to every conceivable result
    combination between the third quarter, fourth quarter, and end of game. For instance,
    the first argument—where `Q3H` is greater than `Q3R`, `Q4H` is greater than `Q4R`,
    and `FH` is greater than `FR`—translates into the home team scoring more points
    than the road team in the third and fourth quarters and then winning the game.
    The last argument—where `Q3R` is less than `Q3H`, `Q4R` is greater than `Q4H`,
    and `FR` is greater than `FH`—translates into the home team outscoring the road
    team in the third quarter, the road team then outscoring the home team in the
    fourth quarter, and the road team winning the game.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`group_by()`函数的参数映射到第三季度、第四季度和比赛结束之间的所有可能的结果组合。例如，第一个参数——其中`Q3H`大于`Q3R`，`Q4H`大于`Q4R`，`FH`大于`FR`——表示主队在第三和第四季度得分超过客队，并且最终赢得比赛。最后一个参数——其中`Q3R`小于`Q3H`，`Q4R`大于`Q4H`，`FR`大于`FH`——表示主队在第三季度得分超过客队，客队在第四季度得分超过主队，并且客队赢得比赛。
- en: 'This might go without saying, but mathematically impossible result combinations
    for games tied at the half aren’t included. For example, it’s impossible for the
    road team to win the third and fourth quarters and then *not* win the game, so
    there’s no argument to the `group_by()` function to account for this scenario.
    The results are cast into a tibble called tbl21:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不用说，但对于半场平局的游戏，数学上不可能的结果组合不包括在内。例如，客队不可能赢得第三和第四季度，然后**不**赢得比赛，因此没有传递给`group_by()`函数的参数来考虑这种情况。结果被转换为一个名为tbl21的tibble：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These results aren’t formatted in a way that’s either quick or easy to decipher;
    therefore, we’ll run a series of data wrangling operations to produce a tibble
    that translates well into a simple table that’s much easier to interpret.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果没有以快速或易于解读的方式格式化；因此，我们将运行一系列数据处理操作，以生成一个可以很好地转换为简单表格的tibble，这样的表格更容易解释。
- en: For starters, we call the base R `colnames()` function to set, or essentially
    rename, the tbl21 columns. Note that between the `colnames()` and `c()` functions,
    we’re implementing a *full* replace of the tbl21 column names, so the length of
    the vector must equal the width of tbl21 to prevent R from throwing an error;
    thus, it’s *not* necessary to include the original and changed column names in
    our code as we did previously by calling the `rename()` function.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用基础R的`colnames()`函数来设置，或者说是重命名，tbl21的列。请注意，在`colnames()`和`c()`函数之间，我们正在实现tbl21列名的**完全**替换，因此向量的长度必须等于tbl21的宽度，以防止R抛出错误；因此，没有必要像我们之前通过调用`rename()`函数那样在我们的代码中包含原始和更改后的列名。
- en: 'The base R `head()` function, where `n = 1`, returns the new header information
    plus the first row of data in tbl21:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 基础R的`head()`函数，其中`n = 1`，返回tbl21的新标题信息以及数据的第一行：
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Avoid special characters and spaces
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用特殊字符和空格
- en: 'Do not use special characters or spaces when changing or creating variable
    names because, depending on the function that’s being called, R may throw an error.
    So, for instance, the column `HHH`—meaning the home team won the third quarter,
    fourth quarter, and game—should not instead be named anything resembling the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改或创建变量名时，不要使用特殊字符或空格，因为根据被调用的函数，R可能会抛出错误。所以，例如，表示主队在第三季度、第四季度和比赛中获胜的列`HHH`——不应该被命名为以下类似的内容：
- en: H_H_H
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: H_H_H
- en: H H H
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: H H H
- en: H-H-H
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: H-H-H
- en: H@H@H
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: H@H@H
- en: 'Most of our variables are logical data types, and our data wrangling operations
    will be made easier by converting logical variables to numeric. We do this by
    repeatedly calling the base R `as.numeric()` function:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大部分变量都是逻辑数据类型，通过将逻辑变量转换为数值，我们的数据处理操作将变得更加容易。我们通过反复调用基础R的`as.numeric()`函数来实现这一点：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Values that previously equaled `FALSE` now equal `0`, and values that previously
    equaled `TRUE` now equal `1`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 之前等于`FALSE`的值现在等于`0`，之前等于`TRUE`的值现在等于`1`。
- en: 'We then index the six values now equal to `1` by applying opening and closing
    square brackets so that they can be modified to equal the corresponding value
    from the count column instead. For instance, where variable `HHH` equals `1`—row
    6 and column 1—we change that so it equals 18 instead because tbl21 contains 18
    records where the home team won the third quarter, fourth quarter, and game:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过应用开闭方括号来索引现在等于`1`的六个值，以便它们可以被修改为等于计数列中的相应值。例如，当变量`HHH`等于`1`时——第6行和第1列——我们将它改为等于18，因为tbl21包含18条记录，其中主队在第三节、第四节和比赛中获胜：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Because there is then no further need for the count column, we call the `dplyr
    select()` function to subset tbl21 on just those variables from `HHH` to `HRR`,
    thereby excluding the count column:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不再需要计数列，我们调用`dplyr select()`函数来对tbl21进行子集化，仅包括从`HHH`到`HRR`的变量，从而排除计数列：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We then call the `tidyr pivot_longer()` function, which reshapes a data object
    from wide to long by converting columns to rows. The `pivot_longer()` function
    essentially requires that we call out the existing columns to be collapsed and
    the new columns to then be created, where the following are true:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`tidyr pivot_longer()`函数，该函数通过将列转换为行来将数据对象从宽格式转换为长格式。`pivot_longer()`函数本质上要求我们指出要折叠的现有列以及随后要创建的新列，以下条件是成立的：
- en: '`cols` equals the names of the columns to pivot.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cols`等于要旋转的列名。'
- en: '`names_to` equals the name of the new character column.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`names_to`等于新字符列的名称。'
- en: '`values_to` equals the name of the new values column.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values_to`等于新值列的名称。'
- en: 'The base R `head()` function returns the top six observations in tbl21\. There
    are now six rows for each result combination (e.g., `HHH`, HRH, etc.) under the
    result column, of which only one contains the actual record count:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 基础R的`head()`函数返回tbl21中的前六个观察结果。现在，每个结果组合（例如，`HHH`、`HRH`等）下都有六个行，其中只有一个是实际的记录计数：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'By calling the `filter()` function one more time and subsetting tbl21 where
    the variable count is greater than 0, we finally have a 6 × 2 tibble that can
    easily be analyzed:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过再次调用`filter()`函数并子集化tbl21，其中变量计数大于0，我们最终得到一个6×2的tibble，可以轻松分析：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Rather than visualizing these results, it actually might be more effective to
    throw them into a simple table (see table 6.1).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 与可视化这些结果相比，实际上可能更有效地将它们放入一个简单的表格中（见表6.1）。
- en: Table 6.1 Summary results for regular season games that were tied at halftime
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1 常规赛季比赛中半场平局的总结结果
- en: '| Results combination | Explanation | Count |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 结果组合 | 说明 | 计数 |'
- en: '| `HHH` | Home team won Q3Home team won Q4Home team won game | 18 |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `HHH` | 主队赢得第三节主队赢得第四节主队赢得比赛 | 18 |'
- en: '| `HRH` | Home team won Q3Road team won Q4Home team won game | 8 |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `HRH` | 主队赢得第三节客队赢得第四节主队赢得比赛 | 8 |'
- en: '| `RHH` | Road team won Q3Home team won Q4Home team won game | 8 |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `RHH` | 客队赢得第三节主队赢得第四节主队赢得比赛 | 8 |'
- en: '| `RRR` | Road team won Q3Road team won Q4Road team won game | 13 |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `RRR` | 客队赢得第三节客队赢得第四节客队赢得比赛 | 13 |'
- en: '| `RHR` | Road team won Q3Home team won Q4Road team won game | 8 |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `RHR` | 客队赢得第三节主队赢得第四节客队赢得比赛 | 8 |'
- en: '| `HRR` | Home team won Q3Road team won Q4Road team won game | 6 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `HRR` | 主队赢得第三节客队赢得第四节客队赢得比赛 | 6 |'
- en: 'The results are unremarkable because there’s nothing here to trigger any pivot
    from our previous conclusions. Not only are NBA games not usually won in the fourth
    quarter, but our analysis of the 2018-19 and 2019-20 regular seasons shows that
    the third quarter is most decisive:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 结果并不引人注目，因为这里没有什么可以触发我们之前结论的任何转换。不仅NBA比赛通常不在第四节获胜，而且我们对2018-19和2019-20赛季常规赛的分析显示，第三节是最关键的：
- en: Of the 61 observations, or games, in tbl21, the home team won 34 times and the
    road team won 27 times. This is actually very close to the home/road split we
    see across an entire regular season.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在tbl21中的61次观察，或者说比赛，主队赢了34次，客队赢了27次。这实际上非常接近整个常规赛中主客场胜负的分布。
- en: The home team won the third quarter 26 times and the fourth quarter 26 times
    in those games it also won.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在那些比赛中，主队在第三节和第四节各赢了26次。
- en: The road team won the third quarter 21 times and the fourth quarter 19 times
    in those games it then won.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在那些客队获胜的比赛中，客队在第三节赢了21次，在第四节赢了19次。
- en: Therefore, for games tied at halftime, neither the third nor the fourth quarter
    is predominant over the other.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，对于半场平局的游戏，第三节和第四节都不是主导的。
- en: In the next chapter, we’ll continue our in-game analyses by investigating a
    potential reason behind the NBA’s home-court advantage.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续进行游戏分析，探讨NBA主场优势背后的潜在原因。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: As with almost everything else in this book, there wasn’t an available data
    set ideally structured to support the breadth of analysis performed here. Thankfully,
    *any* data set can be wrangled *any* number of ways in R, from creating variables
    to renaming, converting, or removing them; from subsetting data sets to reshaping
    them or joining them with other data sets; and from slicing and dicing data to
    visualizing the same.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像这本书中的其他几乎所有内容一样，没有可用的数据集理想地结构化以支持这里所进行的广泛分析。幸运的是，在R中，*任何*数据集都可以以*任何*方式被处理；从创建变量到重命名、转换或删除它们；从子集数据集到重塑它们或与其他数据集合并；以及从切割和切片数据到可视化相同的数据。
- en: It’s not at all uncommon for data-driven analysis to debunk conventional wisdom
    that was never based on data, but instead on what merely appeared to be logical.
    But when that’s the case, you’ll actually need *more* data, not just some, to
    shift people’s mindsets.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据驱动的分析推翻那些从未基于数据而是基于看似合理的传统观点，这并不罕见。但如果是这种情况，你需要的是*更多*数据，而不仅仅是某些数据，才能改变人们的观念。
- en: In the meantime, there is no evidence to support the conventional wisdom that
    the fourth quarter matters more than the first three quarters.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时，没有证据支持传统观点，即第四季度比前三个季度更重要。
- en: If anything, the third quarter matters most; after all, winning teams, especially
    the league’s best teams, won the third quarter more than they won any other quarter,
    at least over the 2018-19 regular season and most of the 2019-20 regular season.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事实上，第三季度最为关键；毕竟，获胜的球队，尤其是联赛中的最佳球队，赢得第三季度的比赛次数比赢得其他任何季度的次数都要多，至少在2018-19赛季和2019-20赛季的大部分时间里是这样的。
- en: In an investigation into just those games that were tied at halftime, where
    the fourth quarter was then “competing” against the third quarter only, one quarter
    failed to stand out over the other. While this doesn’t further support our previous
    findings that the third quarter actually matters more than the fourth quarter,
    or any quarter, it does in fact further discredit the going-in alternative hypothesis.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调查那些半场结束时平局的比赛时，第四季度与第三季度“竞争”的情况，没有哪个季度比另一个季度更突出。虽然这并没有进一步支持我们之前的发现，即第三季度实际上比第四季度或任何其他季度都重要，但它确实进一步削弱了先入为主的替代假设。
