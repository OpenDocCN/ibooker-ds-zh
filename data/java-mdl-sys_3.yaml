- en: appendix A
  id: totrans-0
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附录A
- en: Classpath recap
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类路径概述
- en: A book discussing the module system of course focuses on the module path (see
    section 3.4). But the class path is still fully operational; and because you can
    use it side by side with the module path, it plays an important role during incremental
    modularizations. In other words, it still pays to know how it works.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一本讨论模块系统的书当然会关注模块路径（见第3.4节）。但类路径仍然完全有效；并且由于你可以与模块路径并行使用它，它在增量模块化期间发挥着重要作用。换句话说，了解它是如何工作的仍然是有价值的。
- en: Using the class path to load application JARs
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用类路径加载应用程序JAR文件
- en: 'Definition: Class path'
  id: totrans-4
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：类路径
- en: 'The class path is a concept related to the compiler and the virtual machine.
    They use it for the same purpose: to search the listed JARs for types that they
    require but that aren’t in the JDK. (It can also be used with class files, but
    you can ignore this case for the purpose of learning about the module system.)'
  id: totrans-5
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类路径是与编译器和虚拟机相关的一个概念。它们用于相同的目的：在列出的JAR文件中搜索它们所需的类型，但这些类型不在JDK中。（它也可以与类文件一起使用，但为了了解模块系统的目的，你可以忽略这种情况。）
- en: Let’s look at this book’s example ServiceMonitor application as an example.
    It consists of multiple subprojects and has a few dependencies. In this scenario,
    all subprojects except the last one, monitor, have already been built and are
    present in the `jars` directory.
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们以这本书的示例ServiceMonitor应用程序为例。它由多个子项目组成，并有一些依赖项。在这种情况下，除了最后一个项目monitor之外的所有子项目都已经构建并存在于`jars`目录中。
- en: The following listing shows how to compile, package, and launch the application
    using the class path. Except for the new variants of some of the command-line
    options (for example, using `--classpath`, not `-classpath`), these are exactly
    the same commands as before Java 9.
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 下面的列表显示了如何使用类路径编译、打包和启动应用程序。除了某些命令行选项的新变体（例如，使用`--classpath`而不是`-classpath`）之外，这些命令与Java
    9之前完全相同。
- en: Listing A.1 Compiling, packaging, and launching using the class path
  id: totrans-8
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表A.1 使用类路径编译、打包和启动
- en: '`javac` `--classpath "jars/*"` [`①`](part0031.html#filepos1974148)`-d monitor/target/classes`
    [`②`](part0031.html#filepos1974498)`${java-files}` [`③`](part0031.html#filepos1974833)
    `jar --create` `--file jars/monitor.jar` [`④`](part0031.html#filepos1975340)`-C
    monitor/target/classes .` [`②`](part0031.html#filepos1974498) `java` `--classpath
    "jars/*"` [`①`](part0031.html#filepos1974148)`monitor.Main` [`⑤`](part0031.html#filepos1975689)'
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`javac` `--classpath "jars/*"` [`①`](part0031.html#filepos1974148)`-d monitor/target/classes`
    [`②`](part0031.html#filepos1974498)`${java-files}` [`③`](part0031.html#filepos1974833)
    `jar --create` `--file jars/monitor.jar` [`④`](part0031.html#filepos1975340)`-C
    monitor/target/classes .` [`②`](part0031.html#filepos1974498) `java` `--classpath
    "jars/*"` [`①`](part0031.html#filepos1974148)`monitor.Main` [`⑤`](part0031.html#filepos1975689)'
- en: ①
  id: totrans-10
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Folder containing the dependencies as JARs
  id: totrans-11
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 包含依赖项的JAR文件文件夹
- en: ②
  id: totrans-12
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Folder for compiled classes
  id: totrans-13
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编译后的类文件夹
- en: ③
  id: totrans-14
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: Lists or finds all source files, in this case `monitor/src/main/java/monitor/Main.java
    and monitor/src/main/java/monitor/Monitor.java`
  id: totrans-15
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列出或找到所有源文件，在这种情况下是`monitor/src/main/java/monitor/Main.java`和`monitor/src/main/java/monitor/Monitor.java`
- en: ④
  id: totrans-16
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ④
- en: Names the new JAR file; puts it into jars
  id: totrans-17
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命名新的JAR文件；将其放入jars
- en: ⑤
  id: totrans-18
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⑤
- en: Class containing the application’s main method
  id: totrans-19
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 包含应用程序主方法的类
- en: 'Both the compiler and the runtime search the class path for the types they
    need. Which ones those are differ, though:'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编译器和运行时都会在类路径中搜索它们需要的类型。虽然这些类型可能不同：
- en: Compiler —The compiler requires types that the code under compilation refers
    to. These are a project’s direct dependencies, or more precisely those types in
    the direct dependencies that are referenced from a file under compilation.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器——编译器需要编译的代码所引用的类型。这些是一个项目的直接依赖项，或者更精确地说，是直接依赖项中从编译的文件中引用的类型。
- en: Virtual machine —The JVM requires all types that the executed bytecode refers
    to. In general, these are a project’s direct and indirect dependencies; but due
    to Java’s lazy approach to class loading, it can be considerably fewer than that.
    Only types referenced by the code that is actually running are required, meaning
    a dependency can be missing if the code using it isn’t executed. The JVM also
    allows code to search JARs for resources.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机——JVM需要所有执行的字节码所引用的类型。通常，这些是一个项目的直接和间接依赖项；但由于Java对类加载的懒惰处理，它可能比这少得多。只有实际运行的代码中引用的类型是必需的，这意味着如果使用它的代码没有执行，则可能缺少依赖项。JVM还允许代码在JAR文件中搜索资源。
- en: Both `javac` and `java` have command-line options `-classpath`, `-cp`, and,
    since Java 9, `--classpath`. They generally expect a list of files, but it’s possible
    to use paths and wildcards that then get extended to such a list.
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`javac` 和 `java` 都有命令行选项 `-classpath`、`-cp`，以及自 Java 9 以来新增的 `--classpath`。它们通常期望一个文件列表，但可以使用路径和通配符，然后这些会被扩展成相应的列表。'
- en: The class path since Java 9
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自 Java 9 以来，类路径
- en: ESSENTIAL INFO Regarding Java 9 (and later versions), it’s important to stress
    that the class path isn’t going away! It operates exactly as it did in earlier
    Java versions, and if applications that compiled on such a version didn’t do anything
    problematic (see chapters 6 and 7), they will continue to compile on Java 9 and
    beyond with the same commands.
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**关于 Java 9（及以后版本）的必要信息**，重要的是要强调类路径不会消失！它的工作方式与早期 Java 版本完全相同，如果在此版本上编译的应用程序没有进行任何有问题的操作（参见第
    6 章和第 7 章），它们将继续使用相同的命令在 Java 9 及以后的版本上编译。'
- en: Taking this backward compatibility into account, the question remains how the
    module system deals with types on the class path. In short, they all end up in
    the unnamed module, which the module system spins on the fly. This is a regular
    module, but it has some peculiarities, one of which is that it automatically reads
    all resolved modules. This is also true for modules that end up on the class path—they’ll
    be treated just like plain JARs, and their types will end up in the unnamed module
    as well, ignoring whatever their module declaration has to say. The unnamed module
    and modules on the class path are part of the migration story, which section 8.2
    tells in full detail.
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑到向后兼容性，问题仍然存在：模块系统如何处理类路径上的类型。简而言之，它们最终都会进入未命名的模块，模块系统会即时创建这个模块。这是一个常规模块，但它有一些特性，其中之一是它会自动读取所有已解析的模块。这也适用于最终进入类路径的模块——它们将被视为普通的
    JAR 文件，并且它们的类型也会进入未命名的模块，忽略模块声明中提到的任何内容。未命名的模块和类路径上的模块是迁移故事的一部分，第 8.2 节详细讲述了这一点。
