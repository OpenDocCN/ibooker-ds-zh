- en: 10 Working with symbolic expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用符号表达式进行工作
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Modeling algebraic expressions as data structures
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代数表达式建模为数据结构
- en: Writing code to analyze, transform, or evaluate algebraic expressions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写代码来分析、转换或评估代数表达式
- en: Finding the derivative of a function by manipulating the expression that defines
    it
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过操作定义函数的表达式来求函数的导数
- en: Writing a Python function to compute derivative formulas
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 Python 函数来计算导数公式
- en: Using the SymPy library to compute integral formulas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SymPy 库计算积分公式
- en: 'If you followed all of the code examples and did all the exercises in chapter
    8 and chapter 9, you already have a solid grasp of the two most important concepts
    in calculus: the derivative and the integral. First, you learned how to approximate
    the derivative of a function at a point by taking slopes of smaller and smaller
    secant lines. You then learned how to approximate an integral by estimating the
    area under a graph with skinny rectangles. Lastly, you learned how to do calculus
    with vectors by simply doing the relevant calculus operations in each coordinate.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经跟随着第 8 章和第 9 章中的所有代码示例并完成了所有练习，那么你已经对微积分中最重要的两个概念有了坚实的掌握：导数和积分。首先，你学习了如何通过取越来越小的割线斜率来近似函数在某点的导数。然后，你学习了如何通过估计图形下瘦长矩形的面积来近似积分。最后，你学习了如何通过在每个坐标中进行相关的微积分运算来用向量进行微积分。
- en: 'It might seem like an audacious claim, but I really do hope to have given you
    the most important concepts you’d learn in a year-long college calculus class
    in just a few chapters of this book. Here’s the catch: because we’re working in
    Python, I’m skipping the most laborious piece of a traditional calculus course,
    which is doing a lot of formula manipulation by hand. This kind of work enables
    you to take the formula for a function like *f*(*x*) = *x*³ and figure out an
    *exact* formula for its derivative, *f*''(*x*). In this case, there’s a simple
    answer, *f*''(*x*) = 3*x*², as shown in figure 10.1.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来像是一个大胆的声明，但我真的希望在这本书的几个章节中，你已经学到了在一年制的大学微积分课程中会学到的重要概念。这里的关键是：因为我们使用 Python，所以我跳过了传统微积分课程中最费力的部分，即通过手工进行大量的公式操作。这类工作使你能够对函数的公式，如
    *f*(*x*) = *x*³，找到一个导数 *f*'(*x*) 的确切公式。在这种情况下，有一个简单的答案，*f*'(*x*) = 3*x*²，如图 10.1
    所示。
- en: '![](../Images/CH10_F01_Orland.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F01_Orland.png)'
- en: Figure 10.1 The derivative of the function *f*(*x*) = *x*³ has an exact formula,
    namely *f*'(*x*) = 3x2.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 函数 *f*(*x*) = *x*³ 的导数有一个确切的公式，即 *f*'(*x*) = 3x²。
- en: There are infinitely many formulas you might want to know the derivative of,
    and you can’t memorize derivatives for all of them, so what you end up doing in
    a calculus class is learning a small set of rules and how to systematically apply
    them to transform a function into its derivative. By and large, this isn’t that
    useful of a skill for a programmer. If you want to know the exact formula for
    a derivative, you can use a specialized tool called a *computer algebra system*
    to compute it for you.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要知道无限多个公式的导数，而且你不可能记住所有这些公式的导数，所以在微积分课程中，你最终学到的是一组小规则以及如何系统地应用这些规则将一个函数转换为其导数。总的来说，这对程序员来说并不是一个非常有用的技能。如果你想知道导数的确切公式，你可以使用一个称为
    *计算机代数系统* 的专用工具来为你计算。
- en: 10.1 Finding an exact derivative with a computer algebra system
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.1 使用计算机代数系统求精确导数
- en: One of the most popular computer algebra systems is called *Mathematica*, and
    you can use its engine for free online at a website called Wolfram Alpha ([wolframalpha.com](http://www.wolframalpha.com)).
    In my experience, if you want an exact formula for a derivative for a program
    you’re writing, the best approach is to consult Wolfram Alpha. For instance, when
    we build a neural network in chapter 16, it will be useful to know the derivative
    of the function
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的计算机代数系统之一是 *Mathematica*，你可以在名为 Wolfram Alpha 的网站上免费在线使用其引擎（[wolframalpha.com](http://www.wolframalpha.com)）。根据我的经验，如果你想为正在编写的程序找到一个导数的确切公式，最好的方法是咨询
    Wolfram Alpha。例如，当我们第 16 章构建神经网络时，了解函数的导数将是有用的：
- en: '![](../Images/CH10_F01_Orland_EQ01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F01_Orland_EQ01.png)'
- en: To find a formula for the derivative of this function, you can simply go to
    [wolframalpha.com](http://www.wolframalpha.com) and enter the formula in the input
    box (figure 10.2). Mathematica has its own syntax for mathematical formulas, but
    Wolfram Alpha is impressively forgiving and understands most simple formulas that
    you enter (even in Python syntax!).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到这个函数导数的公式，你只需访问 [wolframalpha.com](http://www.wolframalpha.com) 并在输入框中输入公式（图
    10.2）。Mathematica 有自己的数学公式语法，但 Wolfram Alpha 令人印象深刻地宽容，并能理解你输入的大多数简单公式（甚至包括 Python
    语法！）。
- en: '![](../Images/CH10_F02_Orland.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F02_Orland.png)'
- en: Figure 10.2 Entering a function in the input box at wolframalpha.com
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 在 wolframalpha.com 的输入框中输入函数
- en: When you press Enter, the Mathematica engine powering Wolfram Alpha computes
    a number of facts about this function, including its derivative. If you scroll
    down, you’ll see a formula for the derivative of the function (figure 10.3).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按下 Enter 键时，Wolfram Alpha 后面的 Mathematica 引擎会计算关于这个函数的许多事实，包括它的导数。如果你向下滚动，你会看到一个关于函数导数的公式（图
    10.3）。
- en: '![](../Images/CH10_F03_Orland.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F03_Orland.png)'
- en: Figure 10.3 Wolfram Alpha reports a formula for the derivative of the function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 Wolfram Alpha 报告了该函数导数的公式。
- en: For our function *f*(*x*), its instantaneous rate of change at any value of
    *x* is given by
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的函数 *f*(*x*)，它在任何 *x* 值处的瞬时变化率由以下公式给出
- en: '![](../Images/CH10_F03_Orland_EQ02.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F03_Orland_EQ02.png)'
- en: If you understand the concept of a “derivative” and of an “instantaneous rate
    of change,” learning to punch formulas into Wolfram Alpha is a more important
    skill than any other single skill you’ll learn in a calculus class. I don’t mean
    to be cynical; there’s plenty to learn about the behavior of specific functions
    by taking their derivatives by hand. It’s just that in your life as a professional
    software developer, you’ll probably never need to figure out the formula for a
    derivative or integral when you have a free tool like Wolfram Alpha available.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你理解了“导数”和“瞬时变化率”的概念，学习如何在 Wolfram Alpha 中输入公式是一项比你在微积分课程中学到的任何其他单一技能都更重要的技能。我并不是要表现得愤世嫉俗；通过手动求导数，我们可以学到很多关于特定函数行为的知识。只是在你作为专业软件开发者的生活中，当你有像
    Wolfram Alpha 这样的免费工具可用时，你可能永远不需要去计算导数或积分的公式。
- en: That said, your inner nerd may be asking, “How does Wolfram Alpha do it?” It’s
    one thing to find a crude estimate of a derivative by taking approximate slopes
    of the graph at various points, but it’s another to produce an exact formula.
    Wolfram Alpha successfully interprets the formula you type in, transforms it with
    some algebraic manipulations, and outputs a new formula. This kind of approach,
    where you work with formulas themselves instead of numbers, is called *symbolic
    programming*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你内心的极客可能会问，“Wolfram Alpha 是如何做到的？”通过在各个点取图形的近似斜率来找到导数的粗略估计是一件事情，但生成一个精确公式则是另一回事。Wolfram
    Alpha 成功地解释了你输入的公式，通过一些代数操作对其进行转换，并输出一个新的公式。这种与公式本身而不是数字打交道的方法被称为 *符号编程*。
- en: The pragmatist in me wants to tell you to “just use Wolfram Alpha,” while the
    math enthusiast in me wants to teach you how to take derivatives and integrals
    by hand, so in this chapter I’m going to split the difference. We do some symbolic
    programming in Python to manipulate algebraic formulas directly and, ultimately,
    figure out the formulas for their derivatives. This gets you acquainted with the
    process of finding derivative formulas, while still letting the computer do most
    of the work for you.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我内心的实用主义者想告诉你“就使用 Wolfram Alpha 吧”，而我内心的数学爱好者则想教你如何手动求导数和积分，因此在本章中，我将折中处理。我们将在
    Python 中进行一些符号编程，直接操作代数公式，并最终找出它们的导数公式。这让你熟悉了寻找导数公式的过程，同时仍然让计算机为你做大部分工作。
- en: 10.1.1 Doing symbolic algebra in Python
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1.1 在 Python 中进行符号代数
- en: Let me start by showing you how we’ll represent and manipulate formulas in Python.
    Say we have a mathematical function like
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我先向你展示我们如何在 Python 中表示和操作公式。假设我们有一个数学函数，例如
- en: '*f*(*x*) = (3*x*² + *x*) sin(*x*)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*x*) = (3*x*² + *x*) sin(*x*)'
- en: 'The usual way to represent it in Python is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中表示它的常用方法是如下所示：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While this Python code makes it easy to evaluate the formula, it doesn’t give
    us a way to compute facts *about* the formula. For instance, we could ask
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段 Python 代码使得评估公式变得容易，但它并没有给我们提供计算关于公式的事实的方法。例如，我们可以询问
- en: Does the formula depend on the variable *x* ?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个公式是否依赖于变量 *x*？
- en: Does it contain a trigonometric function?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否包含三角函数？
- en: Does it involve the operation of division?
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否涉及到除法运算？
- en: We can look at these questions and quickly decide that the answers are yes,
    yes, and no. There’s no simple, reliable way to write a Python program to answer
    these questions for us. For instance, it’s difficult, if not impossible, to write
    a function `contains_division(f)` that takes the function *f* and returns true
    if it uses the operation of division in its definition.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速查看这些问题并决定答案：是、是、否。没有简单、可靠的方法来编写一个Python程序来为我们回答这些问题。例如，编写一个函数 `contains_division(f)`，它接受函数
    *f* 并返回如果它在定义中使用除法操作则返回true，是困难的，如果不是不可能的话。
- en: Here’s where this would come in handy. In order to invoke an algebraic rule,
    you need to know what operations are being applied and in what order. For instance,
    the function *f*(*x*) is a product of sin(*x*) with a sum, and there’s a well-known
    algebraic process for expanding a product of a sum as visualized in figure 10.4.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是这种技巧派上用场的地方。为了调用一个代数规则，你需要知道正在应用哪些操作以及它们的顺序。例如，函数 *f*(*x*) 是正弦(*x*)与和的乘积，如图10.4所示，有一个已知的代数过程可以展开和的乘积。
- en: '![](../Images/CH10_F04_Orland.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F04_Orland.png)'
- en: Figure 10.4 Because (3x2+x) sin(*x*) is a product of a sum, it can be expanded.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 因为 (3x2+x) sin(*x*) 是和的乘积，它可以被展开。
- en: Our strategy is to model algebraic expressions as data structures rather than
    translating them directly to Python code, and then they’re more amenable to manipulation.
    Once we can manipulate functions symbolically, we can automate the rules of calculus.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的策略是将代数表达式建模为数据结构，而不是直接将它们转换为Python代码，这样它们就更容易被操作。一旦我们能够对函数进行符号操作，我们就可以自动化微积分的规则。
- en: Most functions expressed by simple formulas also have simple formulas for their
    derivatives. For instance, the derivative of *x*³ is 3*x*², meaning at any value
    of x, the derivative of *f*(*x*) = *x*³ is given by 3*x*². By the time we’re done
    in this chapter, you’ll be able to write a Python function that takes an algebraic
    expression and gives you an expression for its derivative. Our data structure
    for an algebraic formula will be able to represent variables, numbers, sums, differences,
    products, quotients, powers, and special functions like sine and cosine. If you
    think about it, we can represent a huge variety of different formulas with that
    handful of building blocks, and our derivative will work on all of them (figure
    10.5).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用简单公式表示的函数也有它们导数的简单公式。例如，*x*³的导数是3*x*²，这意味着对于任何x的值，函数 *f*(*x*) = *x*³ 的导数由
    3*x*² 给出。到本章结束时，你将能够编写一个Python函数，它接受一个代数表达式并给出其导数表达式。我们的代数公式数据结构将能够表示变量、数字、和、差、积、商、幂以及正弦和余弦等特殊函数。如果你这么想，我们可以用那几个构建块表示大量不同的公式，并且我们的导数将适用于所有这些（图10.5）。
- en: '![](../Images/CH10_F05_Orland.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F05_Orland.png)'
- en: Figure 10.5 A goal is to write a derivative function in Python that takes an
    expression for a function and returns an expression for its derivative.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 目标是编写一个Python中的导数函数，它接受一个函数的表达式并返回其导数表达式。
- en: We’ll get started by modeling expressions as data structures instead of functions
    in Python code. Then, to warm up, we can do some simple computations with the
    data structures to do things like plugging in numbers for variables or expanding
    products of sums. After that, I’ll teach you some of the rules for taking derivatives
    of formulas, and we’ll write our own derivative function and perform them automatically
    on our symbolic data structures.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从将表达式建模为数据结构而不是Python代码中的函数开始。然后，为了热身，我们可以使用这些数据结构进行一些简单的计算，比如为变量插入数字或展开和的乘积。之后，我将教你一些求导公式的规则，我们将编写自己的导数函数并在我们的符号数据结构上自动执行这些操作。
- en: 10.2 Modeling algebraic expressions
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.2 建模代数表达式
- en: 'Let’s focus on the function *f*(*x*) = (3*x*² + *x*) sin(*x*) for a bit and
    see how we can break it down into pieces. This is a good example function because
    it contains a lot of different building blocks: a variable *x*, as well as numbers,
    addition, multiplication, a power, and a specially named function, sin(*x*). Once
    we have a strategy for breaking this function down into conceptual pieces, we
    can translate it into a Python data structure. This data structure is a *symbolic*
    representation of the function as opposed to a string representation like `"(3*x**2`
    `+` `x)` `*` `sin(*x*)"`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们集中关注一下函数 *f*(*x*) = (3*x*² + *x*) sin(*x*)，看看我们如何将其分解成片段。这是一个很好的示例函数，因为它包含了许多不同的构建块：变量
    *x*，以及数字、加法、乘法、幂次和一个特别命名的函数，sin(*x*)。一旦我们有了将这个函数分解成概念片段的策略，我们就可以将其翻译成 Python 数据结构。这个数据结构是函数的*符号*表示，而不是像
    `"(3*x**2` `+` `x)` `*` `sin(*x*)"` 这样的字符串表示。
- en: A first observation is that *f* is an arbitrary name for this function. For
    instance, the right-hand side of this equation expands the same way regardless
    of what we call it. Because of this, we can focus only on the expression that
    defines the function, which in this case is (3*x*² + *x*) sin(*x*). This is called
    an expression in contrast to an equation, which must contain an equals sign (=).
    An *expression* is a collection of mathematical symbols (numbers, letters, operations,
    and so on) combined in some valid ways. Our first goal, therefore, is to model
    these symbols and the valid means of composing this expression in Python.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个观察结果是，*f* 是这个函数的任意名称。例如，无论我们称其为什么，这个方程的右侧都以相同的方式展开。正因为如此，我们只需关注定义函数的表达式，在这种情况下是
    (3*x*² + *x*) sin(*x*)。这被称为表达式，与必须包含等号 (=) 的方程相对。*表达式* 是一些数学符号（数字、字母、运算符等）以某些有效方式组合而成的集合。因此，我们的第一个目标是通过
    Python 模拟这些符号和组合这个表达式的有效方式。
- en: 10.2.1 Breaking an expression into pieces
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 将表达式分解成片段
- en: We can start to model algebraic expressions by breaking them up into smaller
    expressions. There is only one meaningful way to break up the expression (3*x*²
    + *x*) sin(*x*). Namely, it’s the product of (3*x*² + *x*) and sin(*x*) as shown
    in figure 10.6.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将代数表达式分解成更小的表达式来开始模拟代数表达式。分解表达式 (3*x*² + *x*) sin(*x*) 只有一种有意义的分解方式。也就是说，它是
    (3*x*² + *x*) 和 sin(*x*) 的乘积，如图 10.6 所示。
- en: '![](../Images/CH10_F06_Orland.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F06_Orland.png)'
- en: Figure 10.6 A meaningful way to break up an algebraic expression into two smaller
    expressions
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 以有意义的方式将代数表达式分解成两个更小的表达式
- en: By contrast, we can’t split this expression around the plus sign. We could make
    sense of the expressions on either side of the plus sign if we tried, but the
    result is not equivalent to the original expression (figure 10.7).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，我们不能在加号周围拆分这个表达式。如果我们尝试，我们可以理解加号两边的表达式，但结果并不等同于原始表达式（图 10.7）。
- en: '![](../Images/CH10_F07_Orland.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F07_Orland.png)'
- en: Figure 10.7 It doesn’t make sense to split the expression up around the plus
    sign because the original expression is not the sum of 3*x*² and *x* · sin(*x*).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 在加号周围拆分表达式没有意义，因为原始表达式不是 3*x*² 和 *x* · sin(*x*) 的和。
- en: 'If we look at the expression 3*x*² + *x*, it can be broken up into a sum: 3*x*²
    and *x*. Likewise, the conventional order of operations tells us that 3*x*² is
    the product of 3 and *x*², not 3*x* raised to the power of 2.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看表达式 3*x*² + *x*，它可以分解成一个和：3*x*² 和 *x*。同样，传统的运算顺序告诉我们，3*x*² 是 3 和 *x*² 的乘积，而不是
    3*x* 的平方。
- en: In this chapter, we’ll think of operations like multiplication and addition
    as ways to take two (or more) algebraic expressions and stick them together side
    by side to make a new, bigger algebraic expression. Likewise, operators are valid
    places to break up an existing algebraic expression into smaller ones.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把乘法、加法等操作视为将两个（或更多）代数表达式并排放置以形成一个新的大代数表达式的方式。同样，运算符是拆分现有代数表达式为更小表达式的有效位置。
- en: 'In the terminology of functional programming, functions combining smaller objects
    into bigger ones like this are often called *combinators*. Here are some of the
    combinators implied in our expression:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程的术语中，将较小的对象组合成较大的对象，如这种函数通常被称为 *组合子*。以下是我们表达式中隐含的一些组合子：
- en: 3*x*² is the *product* of the expressions 3 and *x*².
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3*x*² 是表达式 3 和 *x*² 的*乘积*。
- en: '*x*² is a *power:* one expression *x* raised to the power of another expression
    2.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x*² 是一个*幂次*：一个表达式 *x* 被提升到另一个表达式 2 的幂次。'
- en: The expression sin(*x*) is a *function application*. Given the expression sin
    and the expression *x*, we can build a new expression sin(*x*).
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式 sin(*x*) 是一个 *函数应用*。给定表达式 sin 和表达式 *x*，我们可以构建一个新的表达式 sin(*x*)。
- en: A variable *x*, a number 2, or a function named sin can’t be broken down further.
    To distinguish these from combinators, we call them *elements*. The lesson here
    is that while (3*x*² + *x*) sin(*x*) is just a bunch of symbols printed on this
    page, the symbols are combined in certain ways to convey some mathematical meaning.
    To bring this concept home, we can visualize how this expression is built from
    its underlying elements.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 *x*、数字 2 或名为 sin 的函数不能进一步分解。为了区分这些与组合符，我们称它们为 *元素*。这里的教训是，虽然 (3*x*² + *x*)
    sin(*x*) 只是在这一页上打印的一堆符号，但这些符号以某种方式组合起来以传达某些数学意义。为了使这个概念更加清晰，我们可以可视化这个表达式是如何从其基本元素构建而成的。
- en: 10.2.2 Building an expression tree
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 构建表达式树
- en: The elements 3, *x*, 2, and sin, along with the combinators of adding, multiplying,
    raising to a power, and applying a function are sufficient to rebuild the whole
    of the expression (3*x*² + *x*) sin(*x*). Let’s go through the steps and draw
    the structure we’ll end up building. One of the first constructions we can put
    together is *x*², which combines *x* and 2 with the power combinator (figure 10.8).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 元素 3、*x*、2 和 sin，以及加法、乘法、幂运算和函数应用的组合符足够重建整个表达式 (3*x*² + *x*) sin(*x*)。让我们一步一步地走，绘制我们将要构建的结构。我们可以构建的第一个结构之一是
    *x*²，它使用幂组合符将 *x* 和 2 结合起来（图 10.8）。
- en: '![](../Images/CH10_F08_Orland.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F08_Orland.png)'
- en: Figure 10.8 Combining *x* and 2 with the power combinator to represent the bigger
    expression x2
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 使用幂组合符将 *x* 和 2 结合起来表示更大的表达式 x²
- en: A good next step is to combine *x*² with the number 3 via the product combinator
    to get the expression 3*x*² (figure 10.9).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的下一步是将 *x*² 与数字 3 通过乘法组合符结合，得到表达式 3*x*²（图 10.9）。
- en: '![](../Images/CH10_F09_Orland.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F09_Orland.png)'
- en: Figure 10.9 Combining the number 3 with a power to model the product 3x2
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 使用幂将数字 3 与一个幂结合来表示乘积 3x2
- en: 'This construction is two layers deep: one expression that inputs to the product
    combinator is itself a combinator. As we add more of the terms of the expression,
    it gets even deeper. The next step is adding the element *x* to 3*x*² using the
    sum combinator (figure 10.10), which represents the operation of addition.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构有两层深度：输入到乘法组合符的表达式本身就是一个组合符。当我们添加更多表达式的项时，它变得更深。下一步是使用加法组合符将元素 *x* 添加到 3*x*²
    中（图 10.10），这代表了加法操作。
- en: '![](../Images/CH10_F10_Orland.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F10_Orland.png)'
- en: Figure 10.10 Combining the expression 3x2 with the element *x* and the sum combinator
    to get 3*x*² + *x*
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 使用表达式 3x²、元素 *x* 和加法组合符得到 3*x*² + *x*
- en: Finally, we need to use the function application combinator to apply sin to
    *x* and then the product combinator to combine sin(*x*) with what we’ve built
    thus far (figure 10.11).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要使用函数应用组合符将 sin 应用到 *x* 上，然后使用乘法组合符将 sin(*x*) 与我们迄今为止构建的内容结合起来（图 10.11）。
- en: '![](../Images/CH10_F11_Orland.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F11_Orland.png)'
- en: Figure 10.11 A completed picture showing how to build (3x2 + *x*) sin(*x*) from
    elements and combinators
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 一个完成的图，展示了如何从元素和组合符构建 (3x2 + *x*) sin(*x*)
- en: 'You may recognize the structure we’ve built as a *tree*. The root of the tree
    is the product combinator with two branches coming out of it: `Sum` and `Apply`.
    Each combinator appearing further down the tree adds additional branches, until
    you reach the elements that are leaves and have no branches. Any algebraic expression
    built with numbers, variables, and named functions as elements and operations
    that are combinators correspond to a distinctive tree that reveals its structure.
    The next thing we can do is to build the same tree in Python.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认出我们构建的结构是一个 *树*。树的根是乘法组合符，从中伸出两个分支：`Sum` 和 `Apply`。树中出现的每个组合符都会添加额外的分支，直到你达到没有分支的叶子元素。任何使用数字、变量和命名函数作为元素以及操作符为组合符的代数表达式都对应于一个独特的树，揭示了其结构。接下来，我们可以用
    Python 构建相同的树。
- en: 10.2.3 Translating the expression tree to Python
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3 将表达式树转换为 Python
- en: When we’ve built this tree in Python, we’ll have achieved our goal of representing
    the expression as a data structure. I’ll use Python classes covered in appendix
    B to represent each kind of element and each combinator. As we go, we’ll revise
    these classes to give them more and more functionality. You can follow the walk-through
    Jupyter notebook for chapter 10 if you want to follow the text, or you can skip
    to a more complete implementation in the Python script file expressions.py.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Python中构建这个树时，我们就实现了将表达式表示为数据结构的目标。我将使用附录B中介绍的Python类来表示每种元素和每个组合器。随着我们的进行，我们将修改这些类，使它们具有更多的功能。如果你想跟随文本，可以查看第10章的Jupyter笔记本，或者你可以跳到Python脚本文件expressions.py中的更完整的实现。
- en: 'In our implementation, we model combinators as containers that hold all of
    their inputs. For instance, a power *x* to the 2, or *x*², has two pieces of data:
    the *base* *x* and the power 2\. Here’s a Python class that’s designed to represent
    a power expression:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，我们将组合器建模为包含所有输入的容器。例如，一个幂 *x* 的 2，或 *x*²，有两块数据：基数 *x* 和幂 2\. 这里是一个设计用来表示幂表达式的Python类：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We could then write `Power("x",2)` to represent the expression *x*². But rather
    than using raw strings and numbers, I’ll create special classes to represent numbers
    and variables. For example,
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以写 `Power("x",2)` 来表示表达式 *x*²。但而不是使用原始字符串和数字，我将创建特殊的类来表示数字和变量。例如，
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This might seem like unnecessary overhead, but it will be useful to be able
    to distinguish `Variable("x")`, which means the letter *x* considered as a variable
    from the string `"x"`, which is merely a string. Using these three classes, we
    can model the expression *x*² as
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是多余的负担，但能够区分 `Variable("x")`，这意味着将字母 *x* 作为变量考虑，与字符串 `"x"`，它仅仅是一个字符串，是有用的。使用这三个类，我们可以将表达式
    *x*² 建模为
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Each of our combinators can be implemented as an appropriately named class
    that stores the data of whatever expressions it combines. For instance, a product
    combinator can be a class that stores two expressions that are meant to be multiplied
    together:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个我们的组合器都可以实现为一个具有适当名称的类，该类存储它组合的任何表达式的数据。例如，一个乘积组合器可以是一个存储要相乘的两个表达式的类：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The product 3*x*² can be expressed using this combinator:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个组合器可以表示乘积 3*x*²
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After introducing the rest of the classes we need, we can model the original
    expression as well as an infinite list of other possibilities. (Note that we allow
    any number of input expressions for the `Sum` combinator, and we could have done
    this for the Product combinator as well. I restricted the Product combinator to
    two inputs to keep our code simpler when we start calculating derivatives in section
    10.3.)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了我们需要的其余类之后，我们可以模拟原始表达式以及无限多的其他可能性。（注意，我们允许 `Sum` 组合器有任意数量的输入表达式，我们也可以为 `Product`
    组合器做同样的事情。我限制 `Product` 组合器的输入为两个，以使我们在第10.3节开始计算导数时代码更简单。）
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Allows a Sum of any number of terms so we can add two or more expressions
    together
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 允许任何数量的项之和，因此我们可以将两个或多个表达式相加
- en: ❷ Stores a string that is the function’s name (like “sin”)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 存储一个字符串，它是函数的名称（例如“sin”）
- en: ❸ Stores a function and the argument it is applied to
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 存储一个函数及其应用到的参数
- en: ❹ I use extra whitespace to make the structure of the expression clearer to
    see.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我使用额外的空白来使表达式的结构更清晰可见。
- en: This is a faithful representation of the original expression (3*x*² + *x*) sin(*x*).
    By that I mean, we could look at this Python object and see that it describes
    the algebraic expression and not a different one. For another expression like
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对原始表达式（3*x*² + *x*）sin(*x*)的忠实呈现。我的意思是，我们可以查看这个Python对象，并看到它描述的是代数表达式，而不是另一个表达式。对于另一个表达式，例如
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'we can read it carefully and see that it represents a different expression:
    cos(*x*³ + −5). In the exercises that follow, you can practice translating some
    algebraic expressions to Python and vice versa. You’ll see it can be tedious to
    type out the whole representation of an expression. The good news is that once
    you get it encoded in Python, the manual work is over. In the next section, we
    see how to write Python functions to automatically work with our expressions.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以仔细阅读它，并看到它代表了一个不同的表达式：cos(*x*³ + −5)。在接下来的练习中，你可以练习将一些代数表达式翻译成Python，反之亦然。你会发现，输入整个表达式的表示可能会很繁琐。好消息是，一旦你在Python中将其编码，手动工作就结束了。在下一节中，我们将看到如何编写Python函数来自动处理我们的表达式。
- en: 10.2.4 Exercises
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.4 练习
- en: '| **Exercise 10.1**: You may have met the natural logarithm, a special mathematical
    function written ln(*x*). Draw the expression ln(*yz*) as a tree built from the
    elements and combinators described in the previous section.**Solution**: The outermost
    combinator is an Apply. The function being applied is ln, the natural logarithm,
    and the argument is *yz*. In turn, *yz* is a power with base *y* and exponent
    *z*. The result looks like this:![](../Images/CH10_F11_Orland_UN01.png) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **练习 10.1**: 你可能已经遇到过自然对数，这是一个特殊的数学函数，写作 ln(*x*)。将表达式 ln(*yz*) 绘制成由前一小节描述的元素和组合器构成的树。**解答**：最外层的组合器是一个
    Apply。被应用的是 ln 函数，即自然对数，参数是 *yz*。反过来，*yz* 是一个以 *y* 为底，*z* 为指数的幂。结果看起来像这样：![](../Images/CH10_F11_Orland_UN01.png)
    |'
- en: '| **Exercise 10.2**: Translate the expression from the previous exercise to
    Python code, given that the natural logarithm is calculated by the Python function
    `math.log`. Write it both as a Python function and as a data structure built from
    elements and combinators. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **练习 10.2**: 在自然对数由 Python 函数 `math.log` 计算的情况下，将前一个练习中的表达式翻译成 Python 代码。请将其作为
    Python 函数和由元素和组合器构建的数据结构写出。|'
- en: '| **Solution**: You can think of ln(*yz*) as a function of two variables *y*
    and *z*. It translates directly to Python, where ln is called `log` :'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '| **解答**：你可以将 ln(*yz*) 视为两个变量 *y* 和 *z* 的函数。它可以直接翻译成 Python，其中 ln 被称为 `log`：'
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The expression tree is built like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式树是这样构建的：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 10.3**: What is the expression represented by `Product(Number(3),
    Sum(Variable("y"),Variable("z")))` ?**Solution**: This expression represents 3
    · (*y* + *z*). Notice that the parentheses are necessary because of the order
    of operations. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **练习 10.3**: 表达式 `Product(Number(3), Sum(Variable("y"),Variable("z")))` 表示的是什么？**解答**：这个表达式表示
    3 · (*y* + *z*)。注意，由于运算顺序，括号是必要的。|'
- en: '| **Exercise 10.4**: Implement a `Quotient` combinator representing one expression
    divided by another. How do you represent the following expression?![](../Images/CH10_F11_Orland_UN01_EQ04.png)**Solution**:
    A `Quotient` combinator needs to store two expressions: the top expression is
    called the *numerator* and the bottom is called the *denominator* :'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 10.4**: 实现一个表示一个表达式除以另一个表达式的 `Quotient` 组合器。如何表示以下表达式？！[](../Images/CH10_F11_Orland_UN01_EQ04.png)**解答**：`Quotient`
    组合器需要存储两个表达式：上面的表达式称为**分子**，下面的称为**分母**：'
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The sample expression is the quotient of the sum *a* + *b* with the number
    2:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 样本表达式是和 *a* + *b* 与数字 2 的商：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 10.5**: Implement a `Difference` combinator representing one expression
    subtracted from another. How can you represent the expression *b*² − 4 *ac* ?**Solution**:
    The `Difference` combinator needs to store two expressions, and it represents
    the second subtracted from the first:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 10.5**: 实现一个表示一个表达式从另一个表达式中减去的 `Difference` 组合器。如何表示表达式 *b*² − 4 *ac*？**解答**：`Difference`
    组合器需要存储两个表达式，它表示第二个表达式从第一个表达式中减去：'
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The expression *b*² − 4 *ac* is the difference of the expressions *b*² and
    4 *ac* and is represented as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 *b*² − 4 *ac* 是表达式 *b*² 和 4 *ac* 的差，表示如下：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 10.6**: Implement a `Negative` combinator representing the negation
    of an expression. For example, the negation of *x*² + *y* is −(*x*² + *y*). Represent
    the latter expression in code using your new combinator.**Solution**: The `Negative`
    combinator is a class that holds one expression:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 10.6**: 实现一个表示表达式取反的 `Negative` 组合器。例如，*x*² + *y* 的取反是 −(*x*² + *y*)。使用你新创建的组合器以代码形式表示后者表达式。**解答**：`Negative`
    组合器是一个包含一个表达式的类：'
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To negate *x*² + *y*, we pass it to the `Negative` constructor:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要对 *x*² + *y* 取反，我们将其传递给 `Negative` 构造器：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 10.7**: Add a function called `Sqrt` that represents a square
    root and use it to encode the following formula:![](../Images/CH10_F11_Orland_UN01_EQ05.png)
    **Solution**: To save some typing, we can name our variables and square root function
    up front:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 10.7**: 添加一个名为 `Sqrt` 的函数来表示平方根，并使用它来编码以下公式：![](../Images/CH10_F11_Orland_UN01_EQ05.png)
    **解答**：为了节省一些打字，我们可以在一开始就命名我们的变量和平方根函数：'
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then it’s just a matter of translating the algebraic expression into the appropriate
    structure of elements and combinators. At the highest level, you can see this
    is a quotient of a sum (on top) and a product (on the bottom):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后只需将代数表达式翻译成适当的元素和组合器的结构。在最高级别上，你可以看到这是一个和（在上面）与积（在下面）的商：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 10.8−Mini Project**: Create an abstract base class called `Expression`
    and make all of the elements and combinators inherit from it. For instance, `class
    Variable()` would become `class Variable(Expression)`. Then overload the Python
    arithmetic operations `+`, -, `*`, and `/` so that they produce `Expression` objects.
    For instance, the code `2*Variable("x")+3` should yield `[cos(x)%20%5C%2C%20dx%250">](https://www.codecogs.com/eqnedit.php?latex=%5Cint%20%5C%3Cspan%20class=)Sum(Product(Number(2),Variable("x")),Number(3))`.**Solution**:
    See the file expressions.py in the source code for this chapter. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **练习 10.8-迷你项目**：创建一个抽象基类 `Expression` 并使所有元素和组合子从它继承。例如，`class Variable()`
    将变为 `class Variable(Expression)`。然后重载 Python 算术运算 `+`，`-`，`*` 和 `/`，以便它们产生 `Expression`
    对象。例如，代码 `2*Variable("x")+3` 应该产生 `[cos(x)%20%5C%2C%20dx%250">](https://www.codecogs.com/eqnedit.php?latex=%5Cint%20%5C%3Cspan%20class=)Sum(Product(Number(2),Variable("x")),Number(3))`。**解决方案**：请参阅本章源代码中的
    `expressions.py` 文件。|'
- en: 10.3 Putting a symbolic expression to work
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.3 将符号表达式投入应用
- en: 'For the function we’ve studied so far, *f*(*x*) = (3*x*² + *x*) sin(*x*), we
    wrote a Python function that computes it:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们迄今为止研究过的函数，*f*(*x*) = (3*x*² + *x*) sin(*x*)，我们编写了一个 Python 函数来计算它：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As an entity in Python, this function is only good for one thing: returning
    an output value for a given input value *x*. The value *f* in Python does not
    make it particularly easy to programmatically answer the questions we asked at
    the beginning of the chapter: whether *f* depends on its input, whether *f* contains
    a trigonometric function, or what the body of *f* would look like if it were expanded
    algebraically. In this section, we see that once we translate the expression into
    a Python data structure built from elements and combinators, we can answer all
    of these questions and more!'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Python 中的一个实体，这个函数只适用于一件事：对于给定的输入值 *x* 返回一个输出值。Python 中的 *f* 并没有使其特别容易以编程方式回答我们在本章开头提出的问题：*f*
    是否依赖于其输入，*f* 是否包含三角函数，或者如果 *f* 以代数方式展开，其主体会是什么样子。在本节中，我们看到一旦我们将表达式翻译成由元素和组合子构成的
    Python 数据结构，我们就可以回答所有这些问题以及更多！
- en: 10.3.1 Finding all the variables in an expression
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 在表达式中查找所有变量
- en: Let’s write a function that takes an expression and returns a list of distinct
    variables that appear in it. For instance, *h*(*z*) = 2*z* + 3 is defined using
    the input variable *z*, while the definition of *g*(*x*) = 7 contains no variables.
    We can write a Python function, `distinct_variables`, that takes an expression
    (meaning any of our elements or combinators) and returns a Python set containing
    the variables.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个函数，它接受一个表达式并返回其中出现的所有不同变量的列表。例如，*h*(*z*) = 2*z* + 3 使用输入变量 *z* 定义，而 *g*(*x*)
    = 7 的定义不包含任何变量。我们可以编写一个 Python 函数，`distinct_variables`，它接受一个表达式（意味着我们的任何元素或组合子）并返回一个包含变量的
    Python 集合。
- en: 'If our expression is an element, like *z* or 7, the answer is clear. An expression
    that is just a variable contains one distinct variable, while an expression that
    is just a number contains no variables at all. We expect our function to behave
    accordingly:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的表达式是一个元素，如 *z* 或 7，答案很明确。仅包含变量的表达式包含一个不同的变量，而仅包含数字的表达式则不包含任何变量。我们期望我们的函数按预期行为：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The situation is more complicated when the expression is built from some combinators
    like *y* · *z* + *x^z* . It’s easy for a human to read all the variables, *y*,
    *z*, and *x*, but how do we extract these from the expression in Python? This
    is actually a Sum combinator representing the sum of *y* · *z* and *x^z* . The
    first expression in the sum contains *y* and *z*, while the second has *x* and
    *z*. The sum then contains all of the variables in these two expressions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当表达式由一些组合子如 *y* · *z* + *x^z* 构成时，情况变得更加复杂。人类阅读所有变量，*y*，*z* 和 *x*，很容易，但我们在 Python
    中如何从表达式中提取这些变量呢？这实际上是一个表示 *y* · *z* 和 *x^z* 之和的 Sum 组合子。求和中的第一个表达式包含 *y* 和 *z*，而第二个包含
    *x* 和 *z*。求和包含了这两个表达式中的所有变量。
- en: 'This suggests we should use a recursive solution: the `distinct_variables`
    for a combinator are the collected `distinct_variables` for each of the expressions
    it contains. The end of the line has the variables and numbers, which obviously
    contain either one or zero variables. To implement the `distinct_variables` function,
    we need to handle the case of every element and combinator that make up a valid
    expression:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们应该使用递归解决方案：组合子的 `distinct_variables` 是它包含的每个表达式的 `distinct_variables` 的收集。行尾的变量和数字显然包含一个或零个变量。为了实现
    `distinct_variables` 函数，我们需要处理构成有效表达式的每个元素和组合子的情况：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code looks hairy, but it is just a long if/else statement with one line
    for each possible element or combinator. Arguably, it would be better coding style
    to add a `distinct_variables` method to each element and combinator class, but
    that makes it harder to see the logic in a single code listing. As expected, our
    `f_expression` contains only the variable *x* :'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来很复杂，但实际上它只是一个长if/else语句，每个可能的元素或组合器对应一行。可以说，给每个元素和组合器类添加一个`distinct_variables`方法会是一个更好的编码风格，但这会使单个代码列表中的逻辑更难理解。正如预期的那样，我们的`f_expression`只包含变量*x*：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you’re familiar with the tree data structure, you’ll recognize this as a
    recursive traversal of the expression tree. By the time this function completes,
    it has called `distinct_variables` on every expression contained in the target
    expression, which are all of the nodes in the tree. That ensures that we see every
    variable and that we get the correct answers that we expect. In the exercises
    at the end of this section, you can use a similar approach to find all of the
    numbers or all of the functions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉树形数据结构，你会认出这是对表达式树的递归遍历。当这个函数完成时，它已经对目标表达式中的每个表达式调用了`distinct_variables`，这些表达式是树中的所有节点。这确保了我们看到每个变量，并且得到我们预期的正确答案。在本节末尾的练习中，你可以使用类似的方法找到所有的数字或所有的函数。
- en: 10.3.2 Evaluating an expression
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 评估表达式
- en: Now, we’ve got two representations of the same mathematical function *f*(*x*
    ). One is the Python function `f`, which is good for evaluating the function at
    a given input value of *x*. The new one is this tree data structure that describes
    the structure of the expression defining *f*(*x*). It turns out the latter representation
    has the best of both worlds; we can use it to evaluate *f*(*x*) as well, with
    only a little more work.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了同一个数学函数*f*(*x*)的两种表示形式。一个是Python函数`f`，它适用于评估给定输入值*x*的函数。新的一个是这个描述定义*f*(*x*)的表达式结构的树形数据结构。结果是后者表示形式兼具两者之长；我们可以用它来评估*f*(*x*)，只需做一点额外的工作。
- en: Mechanically, evaluating a function *f*(*x*) at, say, *x* = 5 means plugging
    in the value of 5 for *x* everywhere and then doing the arithmetic to find the
    result. If the expression were just *f*(*x*) = *x*, plugging in *x* = 5 would
    tell us *f*(5) = 5\. Another simple example would be *g*(*x*) = 7, where plugging
    in 5 in place of *x* has no effect; there are no appearances of *x* on the right-hand
    side, so the result of *g*(5) is just 7.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从机械的角度来看，在*x* = 5这样的值上评估函数*f*(*x*)意味着将5的值插入*x*的所有地方，然后进行算术运算以找到结果。如果表达式只是*f*(*x*)
    = *x*，插入*x* = 5会告诉我们*f*(5) = 5。另一个简单的例子是*g*(*x*) = 7，其中用5替换*x*没有任何影响；在等式右边没有*x*的出现，所以*g*(5)的结果只是7。
- en: The code to evaluate an expression in Python is similar to the code we just
    wrote to find all variables. Instead of looking at the set of variables that appear
    in each subexpression, we need to evaluate each subexpression, then the combinators
    tell us how to combine these results to get the value of the whole expression.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中评估表达式的代码与我们刚刚编写的用于查找所有变量的代码类似。我们需要评估每个子表达式，而不是查看每个子表达式中出现的变量集合，然后组合器告诉我们如何将这些结果组合起来得到整个表达式的值。
- en: The starting data we need is what values to plug-in and which variables these
    replace. An expression with two different variables like *z*(*x*, *y*) = 2*xy*³
    will need two values to get a result; for instance, *x* = 3 and *y* = 2\. In computer
    science terminology, these are called *variable bindings*. With these, we can
    evaluate the subexpression *y*³ as (2)³, which equals 8\. Another subexpression
    is 2*x*, which evaluates to 2 · (3) = 6\. These two are combined with the Product
    combinator, so the value of the whole expression is the product of 6 and 8, or
    48.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要起始数据是插入哪些值以及哪些变量来替换。像*z*(*x*, *y*) = 2*xy*³这样的两个不同变量的表达式需要两个值来得到结果；例如，*x*
    = 3和*y* = 2。在计算机科学术语中，这些被称为*变量绑定*。有了这些，我们可以评估子表达式*y*³为(2)³，等于8。另一个子表达式是2*x*，它评估为2
    · (3) = 6。这两个子表达式通过乘法组合器组合在一起，所以整个表达式的值是6和8的乘积，即48。
- en: 'As we translate this procedure into Python code, I’m going to show you a slightly
    different style than in the previous example. Rather than having a separate evaluate
    function, we can add an `evaluate` method to each class representing an expression.
    To enforce this, we can create an abstract `Expression` base class with an abstract
    `evaluate` method and have each kind of expression inherit from it. If you need
    a review of abstract base classes in Python, take a moment to review the work
    we did with the `Vector` class in chapter 6 or the overview in appendix B. Here’s
    an `Expression` base class, complete with an `evaluate` method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将此过程转换为 Python 代码时，我将向您展示与上一个示例略有不同的风格。我们不需要一个单独的 `evaluate` 函数，而是可以为每个表示表达式的类添加一个
    `evaluate` 方法。为了强制执行这一点，我们可以创建一个具有抽象 `evaluate` 方法的抽象 `Expression` 基类，并让每种表达式都从它继承。如果您需要回顾
    Python 中的抽象基类，请花点时间回顾第 6 章中我们与 `Vector` 类一起完成的工作，或者在附录 B 中的概述。以下是一个包含 `evaluate`
    方法的 `Expression` 基类：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Because an expression can contain more than one variable, I set it up so you
    can pass in the variable bindings as keyword arguments. For instance, the bindings
    `{"x":3,"y":2}` mean substitute 3 for *x* and 2 for *y*. This gives us some nice
    syntactic sugar when evaluating an expression. If *z* represents the expression
    2*xy*³, then once we’re done, we’ll be able to execute the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个表达式可以包含多个变量，我设置了这样的结构，您可以通过关键字参数传递变量绑定。例如，绑定 `{"x":3,"y":2}` 表示用 3 替换 *x*，用
    2 替换 *y*。这在评估表达式时提供了一些语法糖。如果 *z* 代表表达式 2*xy*³，那么一旦我们完成，我们就能执行以下操作：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So far, we’ve only an abstract class. Now we need to have all of our expression
    classes inherit from `Expression`. For example, a `Number` instance is a valid
    expression as a number on its own, like 7\. Regardless of the variable bindings
    provided, a number evaluates to itself:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只有一个抽象类。现在我们需要让所有的表达式类都从 `Expression` 继承。例如，一个 `Number` 实例作为一个单独的数字（如
    7）是一个有效的表达式。无论提供的变量绑定如何，数字都会评估为自身：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For instance, evaluating `Number(7).evaluate(x=3,y=6,q=−15)`, or any other evaluation
    for that matter, returns the underlying number 7.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，评估 `Number(7).evaluate(x=3,y=6,q=−15)` 或任何其他评估，都会返回基础数字 7。
- en: 'Handling variables is also simple. If we’re looking at the expression `Variable("x")`,
    we only need to consult the bindings and see what number the variable *x* is set
    to. When we’re done, we should be able to run `Variable("x").evaluate(x=5)` and
    get 5 as a result. If we can’t find a binding for *x*, then we can’t complete
    the evaluation, and we need to raise an exception. Here’s the updated definition
    of the `Variable` class:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 处理变量也很简单。如果我们查看表达式 `Variable("x")`，我们只需要查看绑定，看看变量 *x* 被设置为哪个数字。当我们完成时，我们应该能够运行
    `Variable("x").evaluate(x=5)` 并得到 5 作为结果。如果我们找不到 *x* 的绑定，那么我们无法完成评估，并需要引发异常。以下是
    `Variable` 类的更新定义：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With these elements handled, we need to turn our attention to the combinators.
    (Note that we won’t consider a `Function` object an `Expression` on its own because
    a function like sine is not a standalone expression. It can only be evaluated
    when it’s given an argument in the context of an `Apply` combinator.) For a combinator
    like `Product`, the rule to evaluate it is simple: evaluate both expressions contained
    in the product and then multiply the results together. No substitution needs to
    be performed in the product, but we’ll pass the bindings along to both subexpressions
    in case either contains a `Variable` :'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这些元素后，我们需要将注意力转向组合子。请注意，我们不会将 `Function` 对象视为单独的 `Expression`，因为像正弦这样的函数不是一个独立的表达式。它只能在
    `Apply` 组合子提供的参数上下文中进行评估。）对于像 `Product` 这样的组合子，评估它的规则很简单：评估产品中包含的两个表达式，然后将结果相乘。在产品中不需要进行替换，但我们将绑定传递给两个子表达式，以防其中任何一个包含
    `Variable`：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With these three classes updated with evaluate methods, we can now evaluate
    any expression built from variables, numbers, and products. For instance,
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三个类更新了 `evaluate` 方法之后，我们现在可以评估由变量、数字和乘积构建的任何表达式。例如，
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Similarly, we can add an `evaluate` method to the `Sum`, `Power`, `Difference`,
    or `Quotient` combinators (as well as any other combinators you may have created
    as exercises). Once we evaluate their subexpressions, the name of the combinator
    tells us which operation we can use to get the overall result.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以为 `Sum`、`Power`、`Difference` 或 `Quotient` 组合子（以及您可能作为练习创建的任何其他组合子）添加
    `evaluate` 方法。一旦我们评估了它们的子表达式，组合子的名称就会告诉我们可以使用哪种操作来获得整体结果。
- en: 'The `Apply` combinator works a bit differently, so it deserves some special
    attention. We need to dynamically look at a function name like sin or sqrt and
    figure out how to compute its value. There are a few possible ways to do this,
    but I chose keeping a dictionary of known functions as data on the `Apply` class.
    As a first pass, we can make our evaluator aware of three named functions:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Apply`组合子的工作方式略有不同，因此值得特别注意。我们需要动态地查看像sin或sqrt这样的函数名，并找出如何计算其值。有几种可能的方法可以做到这一点，但我选择在`Apply`类上保留已知函数的字典作为数据。作为第一步，我们可以让我们的评估器意识到三个命名函数：'
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can practice writing the rest of the evaluate methods yourself or find
    them in the source code for this book. Once you get all of them fully implemented,
    you’ll be able to evaluate our `f_expression` from section 10.1.3:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自己练习编写其余的评估方法，或者在本书的源代码中找到它们。一旦你完全实现了所有这些，你将能够评估第10.1.3节中的`f_expression`：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The result here isn’t important, only the fact that it’s the same as what the
    ordinary Python function *f*(*x*) gives us:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的结果并不重要，重要的是它与普通Python函数*f*(*x*)给出的结果相同：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Equipped with the evaluate function, our `Expression` objects can do the same
    work as their corresponding ordinary Python functions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 配备了评估函数，我们的`Expression`对象可以执行与其对应的普通Python函数相同的工作。
- en: 10.3.3 Expanding an expression
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 展开一个表达式
- en: 'There are many other things we can do with our expression data structures.
    In the exercises, you can try your hand at building a few more Python functions
    that manipulate expressions in different ways. I’ll show you one more example
    for now, which I mentioned at the beginning of this chapter: expanding an expression.
    What I mean by this is taking any product or power of sums and carrying it out.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用我们的表达式数据结构做很多事情。在练习中，你可以尝试构建一些更多以不同方式操作表达式的Python函数。现在，我将展示一个例子，这是我在这章开头提到的：展开一个表达式。我的意思是从任何乘积或幂的和开始执行。
- en: 'The relevant rule of algebra is the *distributive* *property* of sums and products.
    This rule says that a product of the form (*a* + *b*) · *c* is equal to *ac* +
    *bc* and, similarly, that *x*(*y* *+* *z*) = *xy* + *xz*. For instance, our expression
    (3*x*² + *x*) sin(*x*) is equal to 3*x*² sin(*x*) + *x* sin(*x*), which is called
    the expanded form of the first product. You can use this rule several times to
    expand more complicated expressions, for instance:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 代数的相关规则是和与积的**分配律**。这个规则说明，形式为(*a* + *b*) · *c*的乘积等于*ac* + *bc*，同样，*x*(*y* *+*
    *z*) = *xy* + *xz*。例如，我们的表达式(3*x*² + *x*) sin(*x*)等于3*x*² sin(*x*) + *x* sin(*x*)，这就是第一个乘积的展开形式。你可以使用这个规则多次展开更复杂的表达式，例如：
- en: (*x* + *y*)³ = (*x* + *y*)(*x* + *y*)(*x* + *y*)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: (*x* + *y*)³ = (*x* + *y*)(*x* + *y*)(*x* + *y*)
- en: = *x*(*x* + *y*)(*x* + *y*) + *y*(*x* + *y*)(*x* + *y*)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: = *x*(*x* + *y*)(*x* + *y*) + *y*(*x* + *y*)(*x* + *y*)
- en: = *x*²(*x* + *y*) + *x**y*(*x* + *y*) + *y**x*(*x* + *y*) + *y*²(*x* + *y*)
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: = *x*²(*x* + *y*) + *x**y*(*x* + *y*) + *y**x*(*x* + *y*) + *y*²(*x* + *y*)
- en: = *x*³ + *x*²*y* + *x*²*y* + *x**y*² + *y**x*² + *y*²*x* + *y*²*x* + *y*³
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: = *x*³ + *x*²*y* + *x*²*y* + *x**y*² + *y**x*² + *y*²*x* + *y*²*x* + *y*³
- en: = *x*³ + 3*x*²*y* + 3*y*²*x* + *y*³
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: = *x*³ + 3*x*²*y* + 3*y*²*x* + *y*³
- en: As you can see, expanding a short expression like (*x* + *y*)³ can be a lot
    of writing. In addition to expanding this expression, I also simplified the result
    a bit, rewriting some products that would have looked like *xyx* or *xxy* as *x*²
    *y*, for instance. This is possible because order does not matter in multiplication.
    Then I further simplified by *combining* like terms, noting that there were three
    summed copies each of *x*² *y* and *y*² *x* and grouping those together into 3*x*²
    *y* and 3*y*² *x*. In the following example, we only look at how to do the expanding;
    you can implement the simplification as an exercise.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，展开一个短的表达式如(*x* + *y*)³可能需要很多写作。除了展开这个表达式外，我还稍微简化了结果，将看起来像*xyx*或*xxy*的乘积重写为*x*²
    *y*，例如。这是可能的，因为乘法中顺序并不重要。然后我进一步通过*合并*同类项来简化，注意到每个*x*² *y*和*y*² *x*各有三个加和，并将它们组合成3*x*²
    *y*和3*y*² *x*。在下面的例子中，我们只看如何进行展开；你可以将简化作为练习来实现。
- en: 'We can start by adding an abstract `expand` method to the `Expression` base
    class:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从向`Expression`基类添加一个抽象的`expand`方法开始：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If an expression is a variable or number, it is already expanded. For these
    cases, the `expand` method returns the object itself. For instance,
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个表达式是变量或数字，它已经展开。对于这些情况，`expand`方法返回对象本身。例如，
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Sums are already considered to be expanded expressions, but the individual
    terms of a sum cannot be expanded. For example, 5 + *a*(*x* + *y*) is a sum in
    which the first term 5 is fully expanded, but the second term *a*(*x* + *y*) is
    not. To expand a sum, we need to expand each of the terms and sum them:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 和已经被视为展开的表达式，但和的各个项不能展开。例如，5 + *a*(*x* + *y*) 是一个和，其中第一个项 5 已经完全展开，但第二个项 *a*(*x*
    + *y*) 没有展开。要展开一个和，我们需要展开每个项并将它们相加：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The same procedure works for function application. We can’t expand the `Apply`
    function itself, but we can expand its arguments. This would expand an expression
    like sin(*x*(*y* + *z*)) to sin(*xy* + *xz*):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的程序也适用于函数应用。我们无法展开 `Apply` 函数本身，但我们可以展开其参数。这将展开一个像 sin(*x*(*y* + *z*)) 这样的表达式到
    sin(*xy* + *xz*)：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The real work comes when we expand products or powers, where the structure
    of the expression changes completely. As an example, *a*(*b* + *c*) is a product
    of a variable with a sum of two variables, while its expanded form is *ab* + *ac*,
    the sum of two products of two variables each. To implement the distributive law,
    we have to handle three cases: the first term of the product might be a sum, the
    second term might be a sum, or neither of them might be sums. In the latter case,
    no expanding is necessary:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们展开乘积或幂时，表达式的结构会完全改变，这才是真正的挑战。例如，*a*(*b* + *c*) 是一个变量与两个变量的和的乘积，而其展开形式是 *ab*
    + *ac*，即两个变量的乘积之和。为了实现分配律，我们必须处理三种情况：乘积的第一个项可能是一个和，第二个项可能是一个和，或者两者都不是和。在后一种情况下，不需要展开：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Expands both terms of the product
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 展开乘积的两个项
- en: ❷ If the first term of the product is a Sum, it takes the product with each
    of its terms multiplied by the second term of the product, then calls expand on
    the result in case the second term of the product is also a Sum.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果乘积的第一个项是一个和，它将每个项与乘积的第二个项相乘，然后对结果调用 `expand` 方法，如果乘积的第二个项也是一个和。
- en: ❸ If the second term of the product is a Sum, it multiplies each of its terms
    by the first term of the product.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果乘积的第二个项是一个和，它将每个项乘以乘积的第一个项。
- en: ❹ Otherwise, neither term is a Sum, and the distributive property doesn’t need
    to be invoked.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 否则，两个项都不是和，不需要使用分配律。
- en: 'With all of these methods implemented, we can test the `expand` function. With
    an appropriate implementation of `__repr__`(see the exercises), we can see a string
    representation of the results clearly in Jupyter or in an interactive Python session.
    It correctly expands (*a* + *b*) (*x* + *y*) to *ax* + *ay* + *bx* + *by* :'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '实现了所有这些方法后，我们可以测试 `expand` 函数。通过适当的 `__repr__` 实现（见练习），我们可以在 Jupyter 或交互式 Python
    会话中清楚地看到结果字符串表示。它正确地将 (*a* + *b*) (*x* + *y*) 展开为 *ax* + *ay* + *bx* + *by* :'
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And our expression, (3*x*² + *x*) sin(*x*), expands correctly to 3*x*² sin(*x*)
    + *x* sin(*x*):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的表达式 (3*x*² + *x*) sin(*x*) 正确地展开为 3*x*² sin(*x*) + *x* sin(*x*):'
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At this point, we’ve written some Python functions that really do algebra for
    us, not just arithmetic. There are a lot of exciting applications of this type
    of programming (called *symbolic programming*, or more specifically, *computer
    algebra*), and we can’t afford to cover all of them in this book. You should try
    your hand at a few of the following exercises and then we move on to our most
    important example: finding the formulas for derivatives.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了一些 Python 函数，它们真正为我们做代数运算，而不仅仅是算术运算。这种类型的编程（称为 *符号编程*，或更具体地说，*计算机代数*）有很多令人兴奋的应用，我们无法在本书中涵盖所有这些应用。你应该尝试以下练习中的几个，然后我们继续到我们最重要的例子：求导数的公式。
- en: 10.3.4 Exercises
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.4 练习
- en: '| **Exercise 10.9**: Write a function `contains(expression,` `variable)` that
    checks whether the given expression contains any occurrence of the specified variable.**Solution**:
    You could easily check whether the variable appears in the result of `distinct_variables`,
    but here’s the implementation from scratch:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 10.9**：编写一个函数 `contains(expression, variable)`，该函数检查给定的表达式是否包含指定变量的任何出现。**解决方案**：你可以轻松地检查变量是否出现在
    `distinct_variables` 的结果中，但这里是从头开始实现的：'
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 10.10**: Write a `distinct_functions` function that takes an expression
    as an argument and returns the distinct, named functions (like sin or ln) that
    appear in the expression.**Solution**: The implementation looks a lot like the
    `distinct_variables` function from section 10.3.1:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 10.10**：编写一个 `distinct_functions` 函数，该函数接受一个表达式作为参数，并返回表达式中出现的不同、命名的函数（如
    sin 或 ln）。**解决方案**：实现看起来与第 10.3.1 节中的 `distinct_variables` 函数非常相似：'
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 10.11**: Write a function `contains_sum` that takes an expression
    and returns `True` if it contains a `Sum`, and `False` otherwise.**Solution**:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 10.11**：编写一个函数 `contains_sum`，它接受一个表达式并返回 `True` 如果它包含一个 `Sum`，否则返回
    `False`。**解决方案**：'
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 10.12-Mini Project**: Write a `__repr__` method on the `Expression`
    classes so that they appear legibly in an interactive session.**Solution**: See
    the walk-through notebook for chapter 10 or see appendix B for a discussion of
    `__repr__` and other special methods on Python classes. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **练习 10.12-迷你项目**：在 `Expression` 类上编写一个 `__repr__` 方法，以便在交互会话中清晰显示。**解决方案**：请参阅第
    10 章的教程笔记本或参阅附录 B 中对 `__repr__` 和 Python 类上的其他特殊方法的讨论。'
- en: '| **Exercise 10.13-Mini Project**: If you know how to encode equations using
    the LaTeX language, write a `_repr_latex_` method on the `Expression` classes
    that returns LaTeX code representing the given expression. You should see nicely
    typeset renderings of your expressions in Jupyter after adding the method:![](../Images/CH10_F11_Orland_UN02.png)Adding
    a `_repr_latex_` method causes Jupyter to render equations nicely in the REPL.**Solution**:
    See the walk-through notebook for chapter 10. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **练习 10.13-迷你项目**：如果你知道如何使用 LaTeX 语言编码方程，请在 `Expression` 类上编写一个 `_repr_latex_`
    方法，该方法返回表示给定表达式的 LaTeX 代码。在添加此方法后，你应该能在 Jupyter 中看到你表达式的精美排版渲染！![图片](../Images/CH10_F11_Orland_UN02.png)添加
    `_repr_latex_` 方法会导致 Jupyter 在 REPL 中以优美的形式渲染方程。**解决方案**：请参阅第 10 章的教程笔记本。'
- en: '| **Exercise 10.14-Mini Project**: Write a method to generate the Python code
    representing an expression. Use the Python `eval` function to turn this into an
    executable Python function. Compare the result with the evaluate method. For instance,
    `Power(Variable("x"),Number(2))` represents the expression *x*². This should produce
    the Python code `x**2`. Then use Python’s `eval` function to execute this code
    and show how it matches the result of the evaluate method.**Solution**: See the
    walk-through notebook for implementation. When complete, you can run the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 10.14-迷你项目**：编写一个方法来生成表示表达式的 Python 代码。使用 Python 的 `eval` 函数将其转换为可执行的
    Python 函数。将结果与评估方法进行比较。例如，`Power(Variable("x"),Number(2))` 表示表达式 *x*²。这应该生成 Python
    代码 `x**2`。然后使用 Python 的 `eval` 函数执行此代码，并展示它如何与评估方法的结果相匹配。**解决方案**：请参阅实现教程笔记本。完成后，你可以运行以下代码：'
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 10.4 Finding the derivative of a function
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.4 求函数的导数
- en: It might not seem obvious, but there is often a clean algebraic formula for
    the derivative of a function. For instance, if *f*(*x*) = *x*³, then its derivative
    *f*'(*x*), which measures the instantaneous rate of change in *f* at any point
    *x*, is given by *f*'(*x*) = 3*x*². If you know a formula like this, you can get
    an exact result such as *f*'(2) = 12 without the numerical issues associated with
    using small secant lines.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能看起来不明显，但函数的导数通常有一个干净代数公式。例如，如果 *f*(*x*) = *x*³，那么其导数 *f*(*x*)，它衡量的是在任意点
    *x* 处 *f* 的瞬时变化率，由 *f*(*x*) = 3*x*² 给出。如果你知道这样的公式，你可以得到一个精确的结果，例如 *f*'(2) = 12，而不需要使用小割线相关的数值问题。
- en: If you took calculus in high school or college, chances are you spent a lot
    of time learning and practicing how to find formulas for derivatives. It’s a straightforward
    task that doesn’t require much creativity, and it can be tedious. That’s why we’ll
    briefly spend time covering the rules and then focus on having Python do the rest
    of the work for us.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾在高中或大学学习过微积分，那么你很可能花了很多时间学习和练习如何找到导数的公式。这是一个不需要太多创造力的直接任务，可能会很繁琐。这就是为什么我们将简要地介绍规则，然后专注于让
    Python 为我们完成剩下的工作。
- en: 10.4.1 Derivatives of powers
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1 幂的导数
- en: 'Without knowing any calculus, you can find the derivative of a linear function
    of the form *f*(*x*) = *mx* + *b*. The slope of any secant on this line, no matter
    how small, is the same as the slope of the line *m* ; therefore, *f*''(*x*) doesn’t
    depend on *x*. Specifically, we can say *f*''(*x*) = *m*. This makes sense: a
    linear function *f*(*x*) changes at a constant rate with respect to its input
    *x*, so its derivative is a constant function. Also, the constant *b* has no effect
    on the slope of the line, so it doesn’t appear in the derivative (figure 10.12).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不知道任何微积分，你也可以找到形式为 *f*(*x*) = *mx* + *b* 的线性函数的导数。这条线上任何割线的斜率，无论多小，都与线的斜率
    *m* 相同；因此，*f*(*x*) 不依赖于 *x*。具体来说，我们可以得出 *f*(*x*) = *m*。这很有意义：线性函数 *f*(*x*) 相对于其输入
    *x* 的变化率是恒定的，因此其导数是一个常数函数。此外，常数 *b* 对线的斜率没有影响，因此它不会出现在导数中（图 10.12）。
- en: '![](../Images/CH10_F12_Orland.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F12_Orland.png)'
- en: Figure 10.12 The derivative of a linear function is a constant function.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 线性函数的导数是常数函数。
- en: It turns out the derivative of a quadratic function is a linear function. For
    instance, *q*(*x*) = *x*² has derivative *q*'(*x*) = 2*x*. This also makes sense
    if you plot the graph of *q*(*x*). The slope of *q*(*x*) starts negative, increases,
    and eventually becomes positive after *x* = 0\. The function *q*'(*x*) = 2*x*
    agrees with this qualitative description.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，二次函数的导数是一次函数。例如，*q*(*x*) = *x*²的导数是*q*'(*x*) = 2*x*。如果你绘制*q*(*x*)的图形，这也很有道理。*q*(*x*)的斜率开始是负的，然后增加，最终在*x*
    = 0后变成正的。函数*q*'(*x*) = 2*x*与这种定性描述相符。
- en: 'As another example, I showed you that *x*³ has derivative 3*x*². All of these
    facts are special cases of a general rule: when you take the derivative of a function
    *f*(*x*), which is a power of *x*, you get back a function that is *one lower*
    power. Specifically, figure 10.13 shows the derivative of a function of the form
    *axn* is *nax^n* ^(−1).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，我向你展示了*x*³的导数是3*x*²。所有这些事实都是一般规则的特例：当你对一个函数*f*(*x*)求导，该函数是*x*的幂时，你得到的是一个比原来低一级的幂的函数。具体来说，图10.13展示了形式为*axn*的函数的导数是*nax^n*的负一次方。
- en: '![](../Images/CH10_F13_Orland.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F13_Orland.png)'
- en: 'Figure 10.13 A general rule for derivatives of powers: taking the derivative
    of a function *f*(*x*), a power of x, returns a function that is one power lower.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 幂函数导数的一般规则：对一个函数*f*(*x*)求导，该函数是*x*的幂，得到的是一个比原来低一级的幂的函数。
- en: Let’s break this down for a specific example. If *g*(*x*) = 5*x*⁴, then this
    has the form *axn* with *a* = 5 and *n* = 4\. The derivative is *nax^n* ^(−1),
    which becomes 4 · 5 · *x*^(4−1) = 20*x*³. Like any other derivative we’ve covered
    in this chapter, you can double-check this by plotting it alongside the result
    from our numerical derivative function from chapter 9\. The graphs should coincide
    exactly.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个具体的例子来分析这个问题。如果*g*(*x*) = 5*x*⁴，那么这个函数的形式是*axn*，其中*a* = 5，*n* = 4。导数是*nax^n*的负一次方，这变成了4
    · 5 · *x*^(4−1) = 20*x*³。像本章中我们讨论的任何其他导数一样，你可以通过将图形与第9章中我们的数值导数函数的结果并排绘制来双重检查这个结果。图形应该完全一致。
- en: 'A linear function like *f*(*x*) is a power of *x* : *f*(*x*) = *mx*¹. The power
    rule applies here as well: *mx*¹ has a derivative 1 · *mx*⁰ because *x*⁰ = 1\.
    By geometric considerations, adding a constant *b* does not change the derivative;
    it moves the graph up and down, but it doesn’t change the slope.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 线性函数*f*(*x*)是*x*的幂：*f*(*x*) = *mx*¹。幂规则在这里同样适用：*mx*¹的导数是1 · *mx*⁰，因为*x*⁰ = 1。通过几何考虑，添加一个常数*b*不会改变导数；它会使图形上下移动，但不会改变斜率。
- en: 10.4.2 Derivatives of transformed functions
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2 变换函数的导数
- en: Adding a constant to a function never changes its derivative. For instance,
    the derivative of *x*^(100) is 100*x*^(99), and the derivative of *x*^(100) −
    *π* is also 100*x*^(99). But some modifications of a function *do* change the
    derivative. For example, if you put a negative sign in front of a function, the
    graph flips upside down and so does the graph of any secant line. If the slope
    of the secant line is *m* before the flip, it is − *m* after; the change in *x*
    is the same as before, but the change in *y* = *f*(*x*) is now in the opposite
    direction (figure 10.14).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 给函数添加一个常数永远不会改变它的导数。例如，*x*^(100)的导数是100*x*^(99)，而*x*^(100) − *π*的导数也是100*x*^(99)。但是，函数的一些修改确实会改变导数。例如，如果你在函数前加上一个负号，图形会翻转过来，任何割线的图形也会翻转。如果翻转前的割线斜率是*m*，翻转后就是-
    *m*；*x*的变化与之前相同，但*y* = *f*(*x*)的变化现在方向相反（图10.14）。
- en: '![](../Images/CH10_F14_Orland.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH10_F14_Orland.png)'
- en: Figure 10.14 For any secant line on *f*(*x*), the secant line on the same *x*
    interval of -*f*(*x*) has the opposite slope.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 对于*f*(*x*)上的任何割线，*f*(*x*)的同一*x*区间的割线具有相反的斜率。
- en: 'Because derivatives are determined by the slopes of secant lines, the derivative
    of a negative function -*f*(−*x*) is equal to the negative derivative -*f*''(*x*).
    This agrees with the formula we’ve already seen: if *f*(*x*) = −5*x*² then *a*
    = −5 and *f*''(*x*) = −10*x*(as compared to 5*x*², which has the derivative +10*x*).
    Another way to put this is that if you multiply a function by −1, then its derivative
    is multiplied by −1 as well.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因为导数是由割线的斜率决定的，所以负函数-*f*(−*x*)的导数等于负导数-*f*'(*x*)。这与我们之前看到的公式一致：如果*f*(*x*) =
    −5*x*²，那么*a* = −5，*f*'(*x*) = −10*x*（与导数为+10*x*的5*x*²相比）。另一种说法是，如果你将一个函数乘以-1，那么它的导数也会乘以-1。
- en: The same turns out to be true for any constant. If you multiply *f*(*x*) by
    4 to get 4*f*(*x*), figure 10.15 shows that this new function is four times steeper
    at every point and, therefore, its derivative is 4*f*'(*x*).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何常数也是如此。如果你将f(x)乘以4得到4f(x)，图10.15显示这个新函数在每一点上都变得四倍陡峭，因此它的导数是4f'(x)。
- en: '![](../Images/CH10_F15_Orland.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F15_Orland.png)'
- en: Figure 10.15 Multiplying a function by 4 makes every secant line four times
    steeper.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 将一个函数乘以4会使每条割线变得四倍陡峭。
- en: This agrees with the power rule for derivatives I showed you. Knowing the derivative
    of *x*² is 2*x*, you also know that the derivative of 10*x*² is 20*x*, the derivative
    of −3*x*² is −6*x*, and so on. We haven’t covered it yet, but if I tell you the
    derivative of sin(*x*) is cos(*x*), you’ll know right away that the derivative
    of 1.5 · sin(*x*) is 1.5 · cos(*x*).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我所展示的导数的幂规则一致。知道x²的导数是2x，你也知道10x²的导数是20x，−3x²的导数是−6x，等等。我们还没有涉及这一点，但如果我告诉你sin(x)的导数是cos(x)，你将立刻知道1.5
    · sin(x)的导数是1.5 · cos(x)。
- en: A final transformation that’s important is adding two functions together. If
    you look at the graph of *f*(*x*) + *g*(*x*) for any pair of functions *f* and
    *g* in figure 10.16, the vertical change for any secant line is the sum of the
    vertical changes in *f* and *g* on that interval.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的最终变换是将两个函数相加。如果你观察图10.16中任意一对函数f和g的f(x) + g(x)的图像，任何割线的垂直变化都是该区间内f和g的垂直变化的和。
- en: When we’re working with formulas, we can take the derivative of each term in
    a sum independently. If we know that the derivative of *x*² is 2*x*, and the derivative
    of *x*³ is 3*x*², then the derivative of *x*² + *x*³ is 2*x* + 3*x*². This rule
    gives a more precise reason why the derivative of *mx* + *b* is *m* ; the derivatives
    of the terms are *m* and 0, respectively, so the derivative of the whole formula
    is *m* + 0 = *m*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理公式时，我们可以独立地对和中的每一项求导。如果我们知道x²的导数是2x，x³的导数是3x²，那么x² + x³的导数是2x + 3x²。这个规则给出了为什么mx
    + b的导数是m的更精确的理由；项的导数分别是m和0，因此整个公式的导数是m + 0 = m。
- en: '![](../Images/CH10_F16_Orland.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F16_Orland.png)'
- en: Figure 10.16 The vertical change in *f*(*x*) on some *x* interval is the sum
    of the vertical change in *f*(*x*) and in *g*(*x*) on that interval.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 在某个x区间上f(x)的垂直变化是f(x)和g(x)在该区间的垂直变化的和。
- en: 10.4.3 Derivatives of some special functions
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.3 一些特殊函数的导数
- en: There are plenty of functions that can’t be written in the form *axn* or even
    as a sum of terms of this form. For example, trigonometric functions, exponential
    functions, and logarithms all need to be covered separately. In a calculus class,
    you learn how to figure out the derivatives of these functions from scratch, but
    that’s beyond the scope of this book. My goal is to show you how to take derivatives
    so that when you meet them in the wild, you’ll be able to solve the problem at
    hand. To that end, I give you a quick list of some other important derivative
    rules (table 10.1).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多函数不能写成ax^n的形式，甚至不能写成这种形式的项的和。例如，三角函数、指数函数和对数都需要单独考虑。在微积分课程中，你学习如何从头开始计算这些函数的导数，但这超出了本书的范围。我的目标是向你展示如何求导，这样当你遇到这些函数时，你将能够解决手头的问题。为此，我给你一个快速列表，其中包含一些其他重要的导数规则（表10.1）。
- en: Table 10.1 Some basic derivatives *(continued)*
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1 一些基本的导数（续）
- en: '| Function name | Formula | Derivative |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 函数名称 | 公式 | 导数 |'
- en: '| Sine | sin(*x*) | cos(*x*) |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 正弦 | sin(x) | cos(x) |'
- en: '| Cosine | cos(*x*) | −sin(*x*) |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 余弦 | cos(x) | −sin(x) |'
- en: '| Exponential | *e*^(*x*) | *e*^(*x*) |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 指数 | e^x | e^x |'
- en: '| Exponential (any base) | *a*^(*x*) | ln(*a*) · *a*^(*x*) |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 指数（任何底数） | a^x | ln(a) · a^x |'
- en: '| Natural logarithm | ln(*x*) | 1/*x* |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 自然对数 | ln(x) | 1/x |'
- en: '| Logarithm (any base) | log[*a*] *x* | 1/ln(*a*) · *x* |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 对数（任何底数） | log_a(x) | 1/ln(a) · x |'
- en: You can use this table along with the previous rules to figure out more complicated
    derivatives. For instance, let *f*(*x*) = 6*x* + 2 sin(*x*) + 5 *ex*. The derivative
    of the first term is 6, by the power rule from section 10.4.1\. The second term
    contains sin(*x*), whose derivative is cos(*x*), and the factor of two doubles
    the result, giving us 2 cos(*x*). Finally, *ex* is its own derivative (a very
    special case!), so the derivative of 5 *ex* is 5 *ex*. All together the derivative
    is *f*'(*x*) = 6 + 2 cos(*x*) + 5 *ex*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个表格以及之前的规则来找出更复杂的导数。例如，让 *f*(*x*) = 6*x* + 2 sin(*x*) + 5 *ex*。第一项的导数是
    6，根据第10.4.1节中的幂法则。第二项包含 sin(*x*)，其导数是 cos(*x*)，因子 2 将结果加倍，得到 2 cos(*x*)。最后，*ex*
    是它自己的导数（一个非常特殊的情况！），所以 5 *ex* 的导数是 5 *ex*。所有这些加在一起，导数是 *f*'(*x*) = 6 + 2 cos(*x*)
    + 5 *ex*。
- en: 'You have to be careful to *only* use the rules we’ve covered so far: the power
    law (section 10.4.1), the rules in the table 10.1, and the rules for sums and
    scalar multiples. If your function is *g*(*x*) = sin(sin(*x*)), you might be tempted
    to write *g*''(*x*) = cos(cos(*x*)), substituting in the derivative for sine in
    both of its appearances. But this is not correct! Nor can you infer that the derivative
    of the product *ex* cos(*x*) is − *ex* sin(*x*). When functions are combined in
    other ways than addition and subtraction, we need new rules to take their derivatives.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须小心，只使用我们之前提到的规则：幂法则（第10.4.1节）、表10.1中的规则以及和与标量乘法的规则。如果你的函数是 *g*(*x*) = sin(sin(*x*))，你可能会想写成
    *g*'(*x*) = cos(cos(*x*))，在两个出现的地方都代入正弦的导数。但这是不正确的！你也不能推断出乘积 *ex* cos(*x*) 的导数是
    − *ex* sin(*x*)。当函数以除了加法和减法以外的其他方式组合时，我们需要新的规则来求它们的导数。
- en: 10.4.4 Derivatives of products and compositions
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.4 乘积和复合函数的导数
- en: 'Let’s look at a product like *f*(*x*) = *x*² sin(*x*). This function can be
    written as a product of two other functions: *f*(*x*) = *g*(*x*) · *h*(*x*), where
    *g*(*x*) = *x*² and *h*(*x*) = sin(*x*). As I just warned you, *f*''(*x*) is *not*
    equal to *g*''(*x*) · *h*''(*x*) here. Fortunately, there’s another formula that
    is true, and it’s called the *product rule* for derivatives.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看像 *f*(*x*) = *x*² sin(*x*) 这样的乘积。这个函数可以写成两个其他函数的乘积：*f*(*x*) = *g*(*x*)
    · *h*(*x*)，其中 *g*(*x*) = *x*² 和 *h*(*x*) = sin(*x*)。正如我刚才警告你的，*f*'(*x*) 并不等于 *g*'(*x*)
    · *h*'(*x*)。幸运的是，还有一个正确的公式，它被称为**乘积法则**。
- en: 'The product rule If *f*(*x*) can be written as the product of two other functions
    *g* and *h* as in *f*(*x*) = *g*(*x*) · *h*(*x*), then the derivative of *f*(*x*)
    is given by:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 乘积法则 如果 *f*(*x*) 可以写成两个其他函数 *g* 和 *h* 的乘积，即 *f*(*x*) = *g*(*x*) · *h*(*x*)，那么
    *f*(*x*) 的导数由以下公式给出：
- en: '*f*''(*x*) = *g*''(*x*) · *h*(*x*) + *g*(*x*) · *h*''(*x*)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*''(*x*) = *g*''(*x*) · *h*(*x*) + *g*(*x*) · *h*''(*x*)'
- en: Let’s practice applying this rule to *f*(*x*) = *x*² sin(*x*). In this case,
    *g*(*x*) = *x*² and *h*(*x*) = sin(*x*), so *g*'(*x*) = 2*x* and *h*'(*x*) = cos(*x*)
    as I showed you previously. Plugging these into the product rule formula *f*'(*x*)
    = *g*'(*x*) · *h*(*x*) + *g*(*x*) · *h*'(*x*), we get *f*'(*x*) = 2*x* sin(*x*)
    + *x*² cos(*x*). That’s all there is to it!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们练习将这个规则应用到 *f*(*x*) = *x*² sin(*x*) 上。在这种情况下，*g*(*x*) = *x*² 和 *h*(*x*) =
    sin(*x*)，所以 *g*'(*x*) = 2*x* 和 *h*'(*x*) = cos(*x*)，正如我之前所展示的。将这些值代入乘积法则公式 *f*'(*x*)
    = *g*'(*x*) · *h*(*x*) + *g*(*x*) · *h*'(*x*)，我们得到 *f*'(*x*) = 2*x* sin(*x*) +
    *x*² cos(*x*)。这就是全部内容！
- en: You can see that this product rule is compatible with the power rule from section
    10.4.1\. If you rewrite *x*² as the product of *x* · *x*, the product rule tells
    you its derivative is 1 · *x* + *x* · 1 = 2*x*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这个乘积法则与第10.4.1节中的幂法则是兼容的。如果你将 *x*² 写成 *x* · *x* 的乘积，乘积法则会告诉你它的导数是 1 ·
    *x* + *x* · 1 = 2*x*。
- en: Another important rule tells us how to take derivatives of composed functions
    like ln(cos(*x*)). This function has the form *f*(*x*) = *g*(*h*(*x*)), where
    *g*(*x*) = ln(*x*) and *h*(*x*) = cos(*x*). We can’t just plug in the derivatives
    where we see the functions, getting −1/sin(*x*); the answer is a bit more complicated.
    The formula for the derivative of a function of the form *f*(*x*) = *g*(*h*(*x*))
    is called the *chain rule*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 另一条重要的规则告诉我们如何对像 ln(cos(*x*)) 这样的复合函数求导。这个函数的形式是 *f*(*x*) = *g*(*h*(*x*))，其中
    *g*(*x*) = ln(*x*) 和 *h*(*x*) = cos(*x*)。我们并不能简单地将导数代入我们看到的函数中，得到 −1/sin(*x*)；答案要复杂一些。形式为
    *f*(*x*) = *g*(*h*(*x*)) 的函数的导数公式被称为**链式法则**。
- en: 'The chain rule If *f*(*x*)is a composition of two functions, meaning it can
    be written in the form *f*(*x*) = *g*(*h*(*x*)) for some functions *g* and *h*,
    then the derivative of *f* is given by:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 链式法则 如果 *f*(*x*) 是两个函数的复合，意味着它可以写成 *f*(*x*) = *g*(*h*(*x*)) 的形式，对于某些函数 *g* 和
    *h*，那么 *f* 的导数由以下公式给出：
- en: '*f*''(*x*) = *h*''(*x*) · *g*''(*h*(*x*))'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*''(*x*) = *h*''(*x*) · *g*''(*h*(*x*))'
- en: 'In our case, *g*''(*x*) = 1/*x* and *h*''(*x*) = −sin(*x*) both read from table
    10.1\. Then plugging into the chain rule formula, we get the result:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，*g*'(*x*) = 1/*x* 和 *h*'(*x*) = −sin(*x*) 都是从表 10.1 中读取的。然后将它们代入链式法则公式，我们得到以下结果：
- en: '![](../Images/CH10_F16_Orland_EQ11.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH10_F16_Orland_EQ11.png)'
- en: You might remember that sin(*x*)/cos(*x*) = tan(*x*), so we could write even
    more concisely that the derivative of ln(cos(*x*)) = tan(*x*). I’ll give you a
    few more opportunities to practice the product and chain rule in the exercises,
    and you can also turn to any calculus book for abundant examples of calculating
    derivatives. You don’t need to take my word for these derivative rules; you should
    get a result that looks the same if you find a formula for the derivative or if
    you use the derivative function from chapter 9\. In the next section, I’ll show
    you how to turn the rules for derivatives into code.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得 sin(*x*)/cos(*x*) = tan(*x*)，因此我们可以更简洁地写出 ln(cos(*x*)) 的导数 = tan(*x*)。我会在练习中给你更多练习乘积和链式法则的机会，你也可以查阅任何微积分书籍，以获取计算导数的丰富示例。你不必相信我的话，如果你找到一个导数的公式或者使用第
    9 章中的导数函数，你应该得到相同的结果。在下一节中，我将向你展示如何将导数规则转换为代码。
- en: 10.4.5 Exercises
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.5 练习
- en: '| **Exercise 10.15**: Show that the derivative of *f*(*x*) = *x*⁵ is indeed
    *f*''(*x*) = 5*x*⁴ by plotting the numerical derivative (using the derivative
    function from chapter 8) alongside the symbolic derivative *f*''(*x*) = 5*x*⁴.**Solution**:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 10.15**：通过绘制数值导数（使用第 8 章中的导数函数）和符号导数 *f*''(*x*) = 5*x*⁴ 并排，来证明 *f*(*x*)
    = *x*⁵ 的导数确实是 *f*''(*x*) = 5*x*⁴。**解答**：'
- en: '[PRE42]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The two graphs overlap exactly.![](../Images/CH10_F16_Orland_UN03.png)The graph
    of 5x4 and the (numerical) derivative of x5 |
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 两个图完全重叠！[](../Images/CH10_F16_Orland_UN03.png)5x⁴ 的图像和 x⁵ 的（数值）导数 |
- en: '| **Exercise 10.16-Mini Project**: Let’s think again of the functions of one
    variable as a vector space as we did in chapter 6\. Explain why the rules for
    taking derivatives mean the derivative is a linear transformation of this vector
    space. (To be specific, you have to restrict your attention to the functions that
    have derivatives everywhere.)**Solution**: Thinking of functions *f* and *g* as
    vectors, we can add and multiply them by scalars. Remember that (*f* + *g*)(*x*)
    = *f*(*x*) + *g*(*x*) and (*c* · *f* )(*x*) = *c* · *f*(*x*). A *linear transformation*
    is one that preserves vector sums and scalar multiples.If we write the derivative
    as a function *D*, we can think of it as taking a function as an input and returning
    its derivative as an output. For instance, *Df* = *f*''. The derivative of a sum
    of two functions is the sum of the derivatives*D*(*f* + *g*) = *Df* + *Dg*The
    derivative of a function multiplied by a number *c* is *c* times the derivative
    of the original function:*D*(*c* · *f* ) = *c* · *Df*These two rules mean that
    *D* is a linear transformation. Note, in particular, that the derivative of a
    linear combination of functions is the same linear combination of their derivatives:*D*(*a*
    · *f* + *b* · *g*) = *a* · *Df* + *b* · *Dg* |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| **练习 10.16-迷你项目**：让我们再次将一元函数视为向量空间，就像我们在第 6 章中所做的那样。解释为什么求导数的规则意味着导数是这个向量空间的线性变换。（具体来说，你必须将注意力限制在处处有导数的函数上。）**解答**：将函数
    *f* 和 *g* 视为向量，我们可以将它们相加，并用标量乘以它们。记住，(*f* + *g*)(*x*) = *f*(*x*) + *g*(*x*) 和
    (*c* · *f* )(*x*) = *c* · *f*(*x*)。一个 *线性变换* 是一个保持向量加法和标量乘法的变换。如果我们把导数写成函数 *D*，我们可以把它看作是输入一个函数并返回其导数的输出。例如，*Df*
    = *f*''。两个函数和的导数是导数的和：*D*(*f* + *g*) = *Df* + *Dg* 函数乘以一个数 *c* 的导数是原始函数导数的 *c*
    倍：*D*(*c* · *f* ) = *c* · *Df* 这两个规则意味着 *D* 是一个线性变换。特别地，函数线性组合的导数与它们的导数的线性组合相同：*D*(*a*
    · *f* + *b* · *g*) = *a* · *Df* + *b* · *Dg* |'
- en: '| **Exercise 10.17-Mini Project**: Find a formula for the derivative of a quotient:
    *f*(*x*) / *g*(*x*).**Hint**: Use the fact that![](../Images/CH10_F16_Orland_UN03_EQ12.png)The
    power law holds for negative exponents; for instance, *x*^(−1) has the derivative
    − *x*^(−2) = −1/*x*².**Solution**: The derivative of *g*(*x*)^(−1) is − *g*(*x*)^(−2)
    · *g*''(*x*) by the chain rule or![](../Images/CH10_F16_Orland_UN03_EQ13.png)
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| **练习 10.17-迷你项目**：找到一个商的导数公式：*f*(*x*) / *g*(*x*)。**提示**：使用以下事实！[](../Images/CH10_F16_Orland_UN03_EQ12.png)幂法则对负指数也成立；例如，*x*^(−1)
    的导数是 − *x*^(−2) = −1/*x*²。**解答**：根据链式法则，*g*(*x*)^(−1) 的导数是 − *g*(*x*)^(−2) · *g*''(*x*)
    或！[](../Images/CH10_F16_Orland_UN03_EQ13.png) |'
- en: '| With this information, the derivative of the quotient *f*(*x*)/ *g*(*x*)
    is equal to the derivative of the product *f*(*x*)/ *g*(*x*)^(−1), which is given
    by the product rule:![](../Images/CH10_F16_Orland_UN03_EQ14.png)Multiplying the
    first term by *g*(*x*)/ *g*(*x*) gives both terms the same denominator, so we
    can add them:![](../Images/CH10_F16_Orland_UN03_EQ15.png) |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 利用这些信息，商 *f*(*x*)/ *g*(*x*) 的导数等于乘积 *f*(*x*)/ *g*(*x*)^(−1) 的导数，由乘积法则给出![图片](../Images/CH10_F16_Orland_UN03_EQ14.png)将第一项乘以
    *g*(*x*)/ *g*(*x*) 使得两项有相同的分母，因此我们可以将它们相加![图片](../Images/CH10_F16_Orland_UN03_EQ15.png)
    |'
- en: '| **Exercise 10.18**: What is the derivative of sin(*x*) · cos(*x*) · ln(*x*)?**Solution**:
    There are two products here, and fortunately, we can take the product rule in
    any order and get the same result. The derivative of sin(*x*) · cos(*x*) is sin(*x*)
    · −sin(*x*) + cos(*x*) · cos(*x*) = cos(*x*)² − sin(*x*)². The derivative of ln(*x*)
    is 1/*x*, so the product rule tells us that the derivative of the whole product
    is![](../Images/CH10_F16_Orland_UN03_EQ16.png) |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| **练习 10.18**: sin(*x*) · cos(*x*) · ln(*x*) 的导数是什么？**解答**: 这里有两个乘积，幸运的是，我们可以以任何顺序应用乘积法则，并得到相同的结果。sin(*x*)
    · cos(*x*) 的导数是 sin(*x*) · −sin(*x*) + cos(*x*) · cos(*x*) = cos(*x*)² − sin(*x*)²。ln(*x*)
    的导数是 1/*x*，所以乘积法则告诉我们整个乘积的导数是![图片](../Images/CH10_F16_Orland_UN03_EQ16.png) |'
- en: '| **Exercise 10.19**: Assume we know the derivatives of three functions *f*
    , *g*, and *h*, which are written *f*'', *g* '', and *h* ''. What is the derivative
    of *f*(*g*(*h*(*x*))) with respect to *x* ?**Solution**: We need to apply the
    chain rule twice here. One term is *f*''(*g*(*h*(*x*))), but we need to multiply
    it by the derivative of *g*(*h*(*x*)). That derivative is *g*''(*h*(*x*)) times
    the derivative of the inside function *h*(*x*). Because the derivative of *g*(*h*(*x*))
    is *h*''(*x*) · *g*''(*h*(*x*)), the derivative of *f*(*g*(*h*(*x*))) is *f*''(*x*)
    · *g*''(*h*(*x*)) · *f*''(*g*(*h*(*x*))). |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **练习 10.19**: 假设我们知道三个函数 *f*、*g* 和 *h* 的导数，分别写作 *f*''、*g* '' 和 *h* ''。*f*(*g*(*h*(*x*)))
    关于 *x* 的导数是什么？**解答**: 这里我们需要应用链式法则两次。一个项是 *f*''(*g*(*h*(*x*)))，但我们需要乘以 *g*(*h*(*x*))
    的导数。这个导数是 *g*''(*h*(*x*)) 乘以内函数 *h*(*x*) 的导数。因为 *g*(*h*(*x*)) 的导数是 *h*''(*x*)
    · *g*''(*h*(*x*))，所以 *f*(*g*(*h*(*x*))) 的导数是 *f*''(*x*) · *g*''(*h*(*x*)) · *f*''(*g*(*h*(*x*)))。
    |'
- en: 10.5 Taking derivatives automatically
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.5 自动求导
- en: Even though I taught you only a few rules for taking derivatives, you’re now
    prepared to handle any of an infinite collection of possible functions. As long
    as a function is built from sums, products, powers, compositions, trigonometric
    functions, and exponential functions, you are equipped to figure out its derivative
    using the chain rule, product rule, and so on.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我只教了你一些求导的规则，但你现在已经准备好处理无限多可能的函数了。只要函数是由和、积、幂、复合、三角函数和对数函数构成的，你就能够使用链式法则、乘积法则等来找出它的导数。
- en: This parallels the approach we used to build algebraic expressions in Python.
    Even though there are infinitely many possibilities, they are all formed from
    the same set of building blocks and a handful of predefined ways to assemble them
    together. To take derivatives automatically, we need to match each case of a representable
    expression, be it an element or combinator, with the appropriate rule for taking
    its derivative. The end result is a Python function that takes one expression
    and returns a new expression representing its derivative.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在 Python 中构建代数表达式所使用的方法相似。尽管可能性无限，但它们都是由相同的构建块和少量预定义的组装方式构成的。为了自动求导，我们需要将可表示的表达式的每一种情况（无论是元素还是组合器）与求导的适当规则相匹配。最终结果是
    Python 函数，它接受一个表达式并返回一个表示其导数的新表达式。
- en: 10.5.1 Implementing a derivative method for expressions
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.1 为表达式实现求导方法
- en: 'Once again, we can implement the derivative function as a method on each of
    the `Expression` classes. To enforce that they all have this method, we can add
    an abstract method to the abstract base class:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以将求导函数实现为 `Expression` 类中的方法。为了强制它们都具有这个方法，我们可以在抽象基类中添加一个抽象方法：
- en: '[PRE43]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The method needs to take a parameter, `var`, indicating which variable we’re
    taking a derivative with respect to. For instance, *f*(*y*) = *y*² would need
    a derivative taken with respect to *y*. As a trickier example, we’ve worked with
    expressions like *axn*, where *a* and *n* represent constants and only *x* is
    the variable. From this perspective, the derivative is *nax^n* ^(−1). However,
    if we think of this instead as a function of *a*, as in *f*(*a*) = *ax^n*, the
    derivative is *x^n* ^(−1), a constant to a constant power. We get yet another
    result if we consider it a function of *n* : if *f*(*n*) = *axn*, then *f*''(*n*)
    = *a* ln(*n*) *x^n* . To avoid confusion, we’ll consider all expressions as functions
    of the variable *x* in the following discussion.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法需要接受一个参数`var`，表示我们对哪个变量求导。例如，*f*(*y*) = *y*²就需要对*y*求导。作为一个更复杂的例子，我们处理过像*axn*这样的表达式，其中*a*和*n*代表常数，而*x*是变量。从这个角度来看，导数是*nax^n*的(-1)次方。然而，如果我们将其视为*a*的函数，例如*f*(*a*)
    = *ax^n*，那么导数是*x^n*的(-1)次方，这是一个常数乘以一个常数的幂。如果我们将其视为*n*的函数：如果*f*(*n*) = *axn*，那么*f*'(*n*)
    = *a* ln(*n*) *x^n*。为了避免混淆，在以下讨论中，我们将考虑所有表达式都是关于变量*x*的函数。
- en: 'As usual, our easiest examples are the elements: `Number` and `Variable` objects.
    For `Number`, the derivative is always the expression 0, regardless of the variable
    passed in:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，我们最容易的例子是元素：`Number`和`Variable`对象。对于`Number`，导数始终是表达式0，无论传入的变量是什么：
- en: '[PRE44]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we’re taking the derivative of *f*(*x*) = *x*, the result is *f*''(*x*)
    = 1, which is the slope of the line. Taking the derivative of *f*(*x*) = *c* should
    give us 0 as *c* represents a constant here, rather than the argument of the function
    *f* . For that reason, the derivative of a variable is 1 only if it’s the variable
    we’re taking the derivative with respect to; otherwise, the derivative is 0:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们求函数*f*(*x*) = *x*的导数，结果是*f*'(*x*) = 1，这是直线的斜率。求函数*f*(*x*) = *c*的导数应该给出0，因为在这里*c*代表一个常数，而不是函数*f*的参数。因此，只有当我们对所求导的变量进行求导时，变量的导数才是1；否则，导数是0：
- en: '[PRE45]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The easiest combinator to take derivatives of is Sum; the derivative of a `Sum`
    function is just the sum of the derivatives of its terms:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 求导最容易的组合器是Sum；`Sum`函数的导数只是其项的导数之和：
- en: '[PRE46]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'With these methods implemented, we can do some basic examples. For instance,
    the expression `Sum(Variable("x"),Variable("c"),Number(1))` represents *x* + *c*
    + 1, and thinking of that as a function of *x*, we can take its derivative with
    respect to *x* :'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了这些方法后，我们可以做一些基本的例子。例如，表达式`Sum(Variable("x"),Variable("c"),Number(1))`代表*x*
    + *c* + 1，将其视为*x*的函数，我们可以对其关于*x*求导：
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This correctly reports the derivative of *x* + *c* + 1 with respect to *x* as
    1 + 0 + 0, which is equal to 1\. This is a clunky way to report the result, but
    at least we got it right.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这正确地报告了*x* + *c* + 1关于*x*的导数是1 + 0 + 0，等于1。这是一种报告结果的方式，但至少我们得到了正确的结果。
- en: I encourage you to do the mini-project for writing a simplify method that gets
    rid of extraneous terms, like added zeros. We could add some logic to simplify
    expressions as we compute the derivatives, but it’s better to separate our concerns
    and focus on getting the derivative right for now. Keeping that in mind, let’s
    cover the rest of the combinators.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你进行一个迷你项目，编写一个简化方法，该方法可以消除多余的项，如添加的零。我们可以在计算导数时添加一些逻辑来简化表达式，但最好是将我们的关注点分开，并专注于现在正确地得到导数。记住这一点，让我们继续介绍其他组合器。
- en: 10.5.2 Implementing the product rule and chain rule
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.2 实现乘积法则和链式法则
- en: 'The product rule turns out to be the easiest of the remaining combinators to
    implement. Given the two expressions that make up a product, the derivative of
    the product is defined in terms of those expressions and their derivatives. Remember,
    if the product is *g*(*x*) · *h*(*x*), the derivative is *g*''(*x*) · *h*(*x*)
    + *g*(*x*) · *h*''(*x*). That translates to the following code, which returns
    the result as the sum of two products:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 乘积法则证明是剩余组合器中最容易实现的。给定构成乘积的两个表达式，乘积的导数定义为这些表达式及其导数。记住，如果乘积是*g*(*x*) · *h*(*x*)，那么导数是*g*'(*x*)
    · *h*(*x*) + *g*(*x*) · *h*'(*x*)。这转化为以下代码，它将结果作为两个乘积的和返回：
- en: '[PRE48]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Again, this gives us correct (albeit unsimplified) results. For instance, the
    derivative of *cx* with respect to *x* is
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这给我们带来了正确（尽管未简化）的结果。例如，*cx*关于*x*的导数是
- en: '[PRE49]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: That result represents 0 · *x* + *c* · 1, which is, of course, *c*.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 那个结果代表0 · *x* + *c* · 1，这当然是*c*。
- en: Now we’ve got the `Sum` and `Product` combinators handled, so let’s look at
    `Apply`. To handle a function application like sin(*x*²), we need to encode both
    the derivative of the sine function *and* the use of the chain rule because of
    the *x*² inside the parentheses.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们已经处理了 `Sum` 和 `Product` 组合子，所以让我们看看 `Apply`。要处理像 sin(*x*²) 这样的函数应用，我们需要编码正弦函数的导数以及由于括号内的
    *x*² 而使用的链式法则。 '
- en: 'First, let’s encode the derivatives of some of the special functions in terms
    of a placeholder variable unlikely to be confused with any we use in practice.
    The derivatives are stored as a dictionary mapping from function names to expressions
    giving their derivatives:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们用占位符变量来编码一些特殊函数的导数，这个占位符变量不太可能与我们实际使用的任何变量混淆。这些导数存储为一个字典，从函数名映射到表示其导数的表达式：
- en: '[PRE50]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ Creates a placeholder variable designed so that it’s not confused with any
    symbol (like *x* or y) that we might actually use
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个占位符变量，设计得使其不会与任何我们可能实际使用的符号（如 *x* 或 y）混淆
- en: ❷ Records that the derivative of sine is cosine, with cosine expressed as an
    expression using the placeholder variable
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 记录正弦的导数是余弦，余弦用占位符变量表示的表达式来表示
- en: 'The next step is to add the `derivative` method to the `Apply` class, looking
    up the correct derivative from the `_derivatives` dictionary and appropriately
    applying the chain rule. Remember that the derivative of *g*(*h*(*x*)) is *h*''(*x*)
    · *g*''(*h*(*x*)). If, for example, we’re looking at sin(*x*²), then *g*(*x*)
    = sin(*x*) and *h*(*x*) = *x*². We first go to the dictionary to get the derivative
    of sin, which we get back as cos with a placeholder value. We need to plug in
    *h*(*x*) = *x*² for the placeholder to get the *g*''(*h*(*x*)) term from the chain
    rule. This requires a substitute function, which replaces all instances of a variable
    with an expression (a mini-project from earlier in the chapter). If you didn’t
    do that mini-project, you can see the implementation in the source code. The derivative
    method for `Apply` looks like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为 `Apply` 类添加 `derivative` 方法，从 `_derivatives` 字典中查找正确的导数并适当地应用链式法则。记住，*g*(*h*(*x*))
    的导数是 *h*'(*x*) · *g*'(*h*(*x*))。例如，如果我们正在查看 sin(*x*²)，那么 *g*(*x*) = sin(*x*) 和
    *h*(*x*) = *x*²。我们首先去字典中获取 sin 的导数，我们得到的是余弦和一个占位符值。我们需要将 *h*(*x*) = *x*² 插入占位符以获取链式法则中的
    *g*'(*h*(*x*)) 项。这需要一个替换函数，该函数用表达式替换变量的所有实例（这是本章早期的一个小项目）。如果您没有完成那个小项目，您可以在源代码中查看实现。`Apply`
    的导数方法如下：
- en: '[PRE51]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ Returns h'(*x*) in h'(*x*) · g'(h(*x*)) of the chain rule formula
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回链式法则公式中的 h'(*x*) = h'(*x*) · g'(h(*x*))
- en: ❷ This is the g'(h(*x*)) of the chain rule formula, where the _derivatives dictionary
    looks up g' and h(*x*) is substituted in.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这是链式法则公式的 g'(h(*x*))，其中导数字典查找 g'，并将 h(*x*) 替换进去。
- en: For sin(*x*²), for example, we have
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于 sin(*x*²)，我们有
- en: '[PRE52]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Literally, that result translates to (2*x*¹) · cos(*x*²), which is a correct
    application of the chain rule.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这个结果可以翻译为 (2*x*¹) · cos(*x*²)，这是链式法则的正确应用。
- en: 10.5.3 Implementing the power rule
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.3 实现幂法则
- en: The last kind of expression we need to handle is the Power combinator. There
    are actually three derivative rules we need to include in the `derivative` method
    for the `Power` class. The first is the rule I called the power rule, which tells
    us that *x^n* has derivative *nx^n* ^(−1), when *n* is a constant. The second
    is the derivative of the function *ax*, where the base, *a*, is assumed to be
    constant while the exponent changes. This function has the derivative ln(*a*)
    · *a^x* with respect to *x*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '我们需要处理的最后一种表达式是 Power 组合子。实际上，我们需要在 `Power` 类的 `derivative` 方法中包含三个导数规则。第一个是称为幂法则的规则，它告诉我们当
    *n* 是常数时，*x^n* 的导数是 *nx^n* ^(−1)。第二个是函数 *ax* 的导数，其中基数 *a* 假设是常数，而指数变化。这个函数相对于
    *x* 的导数是 ln(*a*) · *a^x*。 '
- en: Finally, we need to handle the chain rule here because there could be an expression
    involved in either the base or the exponent, like sin(*x*)⁸ or 15^(cos(*x*)).
    There’s yet another case where *both* the base and the exponent are variables
    like *n^x* or ln(*x*)^(sin(*x*)). In all my years taking derivatives, I’ve never
    seen a real application where this case comes up, so I’ll skip it and raise an
    exception instead.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要处理这里的链式法则，因为可能涉及到基数或指数的表达式，如 sin(*x*)⁸ 或 15^(cos(*x*))。还有一种情况是基数和指数都是变量，如
    *n^x* 或 ln(*x*)^(sin(*x*))。在我多年的求导经历中，我从未见过一个实际应用中出现这种情况，所以我会跳过它，并抛出一个异常。
- en: 'Because *x^n* , *g*(*x*)^n, *a^x* , and *a*^(*g*(*x*)) are all represented
    in Python in the form `Power(expression1,` `expression2)`, we have to do some
    checks to find out what rule to use. If the exponent is a number, we use the *x^n*
    rule, but if the base is a number, we use the *a^x* rule. In both cases, I use
    the chain rule by default. After all, *x^n* is a special case of *f*(*x*)^(*n*),
    where *f*(*x*) = *x*. Here’s what the code looks like:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 *x^n*，*g*(*x*)^n，*a^x* 和 *a*^(*g*(*x*)) 在 Python 中都表示为 `Power(expression1,
    expression2)` 的形式，我们必须进行一些检查以确定使用哪个规则。如果指数是数字，我们使用 *x^n* 规则，但如果基数是数字，我们使用 *a^x*
    规则。在这两种情况下，我默认使用链式法则。毕竟，*x^n* 是 *f*(*x*)^(*n*) 的特例，其中 *f*(*x*) = *x*。以下是代码的示例：
- en: '[PRE53]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ❶ If the exponent is a number, uses the power rule
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果指数是数字，则使用幂规则
- en: ❷ The derivative of *f*(*x*)^n is *f*'(*x*) · *nf*(*x*)^(n−1), so here we multiply
    the factor of *f*'(*x*) according to the chain rule.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ *f*(*x*)^n 的导数是 *f*'(*x*) · *nf*(*x*)^(n−1)，因此我们根据链式法则乘以 *f*'(*x*) 的因子。
- en: ❸ Checks if the base is a number; if so, we use the exponential rule.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查基数是否为数字；如果是，我们使用指数规则。
- en: ❹ Multiplies in a factor of *f*'(*x*) if we’re trying to take the derivative
    of *a*^(*f*(*x*)), again according to the chain rule
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果我们试图对 *a*^(*f*(*x*)) 求导，则根据链式法则乘以 *f*'(*x*) 的因子
- en: 'In the final case, where neither the base or the exponent is a number, we raise
    an error. With that final combinator implemented, you have a complete derivative
    calculator! It can handle (nearly) any expression built out of your elements and
    combinators. If you test it on our original expression, (3*x*² + *x*) sin(*x*),
    you’ll get back the verbose, but correct, result of:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终情况下，如果基数或指数都不是数字，我们将引发一个错误。实现了这个最后的组合器后，你就有了一个完整的导数计算器！它可以处理（几乎）由你的元素和组合器构建的任何表达式。如果你用我们的原始表达式（3*x*²
    + *x*）sin(*x*）来测试它，你会得到如下详尽但正确的结果：
- en: 0 · *x*² + 3 · 1 · 2 · *x*¹ + 1 · sin(*x*) + (*e* · *x*² + *x*) · 1 · cos(*x*)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 0 · *x*² + 3 · 1 · 2 · *x*¹ + 1 · sin(*x*) + (*e* · *x*² + *x*) · 1 · cos(*x*)
- en: This reduces to (6*x* + 1) sin(*x*) + (3*x*² + *x*) cos(*x*) and shows a correct
    use of the product and the power rules. Coming into this chapter, you knew how
    to use Python to do arithmetic, then you learned how to have Python do algebra
    as well. Now, you can really say, you’re doing calculus in Python too! In the
    final section, I’ll tell you a bit about taking integrals symbolically in Python,
    using an off-the-shelf Python library called SymPy.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这简化为 (6*x* + 1) sin(*x*) + (3*x*² + *x*) cos(*x*)，并展示了正确使用乘积和幂规则。进入这一章之前，你已经知道如何使用
    Python 进行算术运算，然后你学习了如何让 Python 进行代数运算。现在，你真的可以说，你已经在 Python 中进行微积分了！在最后一节，我会告诉你一些关于在
    Python 中使用 SymPy 库进行符号积分的信息。
- en: 10.5.4 Exercises
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5.4 练习
- en: '| **Exercise 10.20**: Our code already handles the case where one expression
    making up a product is constant, meaning a product of the form *c* · *f*(*x*)
    or *f*(*x*) · *c* for some expression *f*(*x*). Either way, the derivative is
    *c* · *f*''(*x*). You don’t need the second term of the product rule, which is
    *f*(*x*) · 0 = 0\. Update the code taking the derivative of a product to handle
    this case directly, rather than expanding the product rule and including a zero
    term.**Solution**: We could check whether either expression in a product is an
    instance of the `Number` class. The more general approach is to see whether either
    term of the product contains the variable we’re taking the derivative with respect
    to. For instance, the derivative of (3 + sin(5^(*a*))) *f*(*x*) with respect to
    *x* doesn’t require the product rule because the first term contains no appearance
    of *x*. Therefore, its derivative (with respect to *x*) is 0\. We can use the
    `contains(expression, variable)` function from a previous exercise to do the check
    for us:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 10.20**：我们的代码已经处理了一个表达式构成乘积且为常数的情形，即形式为 *c* · *f*(*x*) 或 *f*(*x*) ·
    *c* 的乘积，对于某个表达式 *f*(*x*)。无论哪种方式，导数都是 *c* · *f*''(*x*)。你不需要乘积规则的第二项，即 *f*(*x*)
    · 0 = 0。更新代码以直接处理这种情况，而不是展开乘积规则并包含一个零项。**解决方案**：我们可以检查乘积中的任一表达式是否是 `Number` 类的实例。更通用的方法是查看乘积的任一项是否包含我们对它求导的变量。例如，对
    (3 + sin(5^(*a*))) *f*(*x*) 关于 *x* 的导数不需要乘积规则，因为第一项不包含 *x* 的任何出现。因此，其导数（关于 *x*）是
    0。我们可以使用之前练习中的 `contains(expression, variable)` 函数来为我们进行检查：'
- en: '[PRE54]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ❶ If the first expression has no dependence on the variable, returns the first
    expression times the derivative of the second❷ Otherwise, if the second expression
    has no dependence on the variable, returns the derivative of the first expression
    times the unmodified second expression❸ Otherwise, uses the general form of the
    product rule |
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果第一个表达式对变量没有依赖，则返回第一个表达式乘以第二个表达式的导数❷ 如果第二个表达式对变量没有依赖，则返回第一个表达式的导数乘以未修改的第二个表达式❸
    否则，使用乘积法则的一般形式 |
- en: '| **Exercise 10.21**: Add the square root function to the dictionary of known
    functions and take its derivative automatically.**Hint**: The square root of *x*
    is equal to *x*^(1/2).**Solution**: Using the power law, the derivative of the
    square root of *x* with respect to *x* is ½ · *x*^(−1/2), which can also be written
    as:![](../Images/CH10_F16_Orland_UN03_EQ18.png) |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| **练习 10.21**: 将平方根函数添加到已知函数字典中，并自动求其导数。**提示**: *x* 的平方根等于 *x*^(1/2)。**解答**:
    使用幂法则，*x* 的平方根相对于 *x* 的导数是 ½ · *x*^(−1/2)，也可以写成如下所示：![图片](../Images/CH10_F16_Orland_UN03_EQ18.png)
    |'
- en: '| We can encode that derivative formula as an expression like so:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '| 我们可以将那个导数公式编码成如下表达式：'
- en: '[PRE55]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '|'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 10.6 Integrating functions symbolically
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 10.6 符号积分函数
- en: The other calculus operation we learned about in the last two chapters is integration.
    While a derivative takes a function and returns a function describing its rate
    of change, an integral does the opposite−it reconstructs a function from its rate
    of change.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们学习过的另一种微积分运算是积分。虽然导数接受一个函数并返回描述其变化率的函数，但积分则相反−它从其变化率重建一个函数。
- en: 10.6.1 Integrals as antiderivatives
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6.1 积分作为原函数
- en: 'For instance, when *y* = *x*², the derivative tells us that the instantaneous
    rate of change in *y* with respect to *x* is 2*x*. If we started with 2*x*, the
    indefinite integral answers the question: what function of *x* has an instantaneous
    rate of change equal to 2*x* ? For this reason, indefinite integrals are also
    referred to as *antiderivatives.*'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当 *y* = *x*² 时，导数告诉我们 *y* 相对于 *x* 的瞬时变化率是 2*x*。如果我们从 2*x* 开始，不定积分回答的问题是：哪个
    *x* 的函数的瞬时变化率等于 2*x*？因此，不定积分也被称为 *原函数*。
- en: One possible answer for the indefinite integral of 2*x* with respect to *x*
    is *x*², but other possibilities are *x*² − 6 or *x*² + *π*. Because the derivative
    is 0 for any constant term, the indefinite integral doesn’t have a unique result.
    Remember, even if you know what a car’s speedometer reads for the entire trip,
    it won’t tell you where the car started or ended its journey. For that reason,
    we say that *x*² is *an* antiderivative of 2*x*, but not *the* antiderivative.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 2*x* 关于 *x* 的不定积分的一个可能答案是 *x*²，但其他可能性还有 *x*² − 6 或 *x*² + *π*。因为任何常数项的导数都是 0，所以不定积分没有唯一的结果。记住，即使你知道整个旅程中汽车的速度表读数，它也不会告诉你汽车是从哪里开始或结束旅程的。因此，我们说
    *x*² 是 2*x* 的 *一个* 原函数，但不是 *唯一的* 原函数。
- en: If we want to talk about *the* antiderivative or *the* indefinite integral,
    we have to add an unspecified constant, writing something like *x*² + *C*. The
    *C* is called the constant of integration, and it has some infamy in calculus
    classes; it seems like a technicality, but it’s important, and most teachers deduct
    points if students forget this.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要谈论 *不定积分* 或 *不定积分*，我们必须添加一个未指定的常数，写成类似 *x*² + *C* 的形式。*C* 被称为积分常数，在微积分课程中有些臭名昭著；它似乎是一个技术性细节，但很重要，如果学生忘记这一点，大多数老师都会扣分。
- en: Some integrals are obvious if you’ve practiced enough derivatives. For instance,
    the integral of cos(*x*) with respect to *x* is written
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经足够练习了导数，一些积分是显而易见的。例如，*x* 关于 cos(*x*) 的积分写成
- en: ∫ cos(*x*)*dx*
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ∫ cos(*x*)*dx*
- en: 'And the result is sin(*x*) + *C* because for any constant *C*, the derivative
    of sin(*x*) + *C* is cos(*x*). If you’ve got the power rule fresh in your head,
    you might be able to solve the integral:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 sin(*x*) + *C*，因为对于任何常数 *C*，sin(*x*) + *C* 的导数是 cos(*x*)。如果你对幂法则记忆犹新，你可能能够解决这个积分：
- en: ∫ 3*x*²*dx*
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ∫ 3*x*²*dx*
- en: The expression 3*x*² is what you get if you apply the power rule to *x*³, so
    the integral is
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将幂法则应用于 *x*³ 时，得到的表达式是 3*x*²，因此积分是
- en: ∫ 3*x*²*dx* = *x*³ + *C*
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ∫ 3*x*²*dx* = *x*³ + *C*
- en: There are some harder integrals like
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 有些积分比较难，例如
- en: ∫ tan(*x*)*dx*
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ∫ tan(*x*)*dx*
- en: which don’t have obvious solutions. You need to invoke more than one derivative
    rule in reverse to find the answer. A lot of time in calculus courses is dedicated
    to figuring out tricky integrals like this. What makes the situation worse is
    that some integrals are *impossible*. Famously, the function
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这些没有明显的解。你需要反向调用多个导数规则来找到答案。在微积分课程中，大量的时间都用于解决这类棘手的积分。使情况变得更糟的是，有些积分是*不可能的*。著名的是，函数
- en: '*f*(*x*) = *e*^(*x*²)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*x*) = *e*^(*x*²)'
- en: is one where it’s not possible to find a formula for its indefinite integral
    (at least without making up a new function to represent it). Rather than torture
    you with a bunch of rules for integration, let me show you how to use a pre-built
    library with an `integrate` function so Python can handle integrals for you.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个无法找到其不定积分公式（至少在没有创造一个新函数来表示它的情况下）的地方。与其让你忍受一大堆积分规则，不如让我展示如何使用一个带有`integrate`函数的预构建库，这样Python就可以为你处理积分了。
- en: 10.6.2 Introducing the SymPy library
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6.2 介绍SymPy库
- en: 'The SymPy (*Sym* bolic *Py* thon) library is an open source Python library
    for symbolic math. It has its own expression data structures, much like the ones
    we built, along with overloaded operators, making them look like ordinary Python
    code. Here you can see some SymPy code that looks like what we’ve been writing:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy（*Sym* bolic *Py* thon）库是一个开源的Python符号数学库。它有自己的表达式数据结构，就像我们构建的那样，以及重载运算符，使它们看起来像普通的Python代码。在这里，你可以看到一些看起来像我们一直在编写的SymPy代码：
- en: '[PRE56]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `Mul`, `Symbol`, and `Add` constructors replace our `Product`, `Variable`,
    and `Sum` constructors, but have similar results. SymPy also encourages you to
    use shorthand; for instance,
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mul`、`Symbol`和`Add`构造函数替换了我们的`Product`、`Variable`和`Sum`构造函数，但结果相似。SymPy还鼓励你使用缩写；例如，'
- en: '[PRE57]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'creates an equivalent expression data structure. You can see that it’s a data
    structure by our ability to substitute and take derivatives:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个等效的表达式数据结构。你可以通过我们的替换和求导能力看到它是一个数据结构：
- en: '[PRE58]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To be sure, SymPy is a much more robust library than the one we’ve built in
    this chapter. As you can see, the expressions are automatically simplified.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，SymPy是一个比我们在本章中构建的库更健壮的库。正如你所见，表达式会自动简化。
- en: 'The reason I’m introducing SymPy is to show you its powerful symbolic integration
    function. You can find the integral of an expression like 3*x*² like this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我介绍SymPy的原因是展示其强大的符号积分功能。你可以这样找到表达式3*x*²的积分：
- en: '[PRE59]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: That tells us that
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，
- en: ∫ 3*x*²*dx* = *x*³ + *C*
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ∫ 3*x*²*dx* = *x*³ + *C*
- en: In the next few chapters, we’ll continue putting derivatives and integrals to
    work.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几章中，我们将继续使用导数和积分。
- en: 10.6.3 Exercises
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6.3 练习
- en: '| **Exercise 10.22**: What is the integral of *f*(*x*) = 0? Confirm your answer
    with SymPy, remembering that SymPy does not automatically include a constant of
    integration.**Solution**: Another way of asking this question is what function
    has a derivative zero? Any constant valued function has a zero slope everywhere,
    so it has a derivative zero. The integral is∫ *f*(*x*)*dx* = ∫ *dx* = *C*In SymPy,
    the code `Integer(0)` gives you the number 0 as an expression, so the integral
    with respect to a variable *x* is'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习10.22**：*f*(*x*) = 0的积分是什么？用SymPy确认你的答案，记住SymPy不会自动包含积分常数。**解答**：另一种问这个问题的方式是询问什么函数的导数是零？任何常数值函数在所有地方都有一个零斜率，因此它有一个零导数。积分是∫
    *f*(*x*)*dx* = ∫ *dx* = *C*在SymPy中，代码`Integer(0)`给你一个作为表达式的数字0，所以对变量*x*的积分是'
- en: '[PRE60]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Zero, as a function, is one antiderivative of zero. Adding a constant of integration,
    we get 0 + *C* or just *C*, matching what we came up with. Any constant function
    is an antiderivative of the constant, zero function. |
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 零作为一个函数，是零的一个反导数。加上积分常数，我们得到0 + *C*或者就是*C*，这与我们得出的结果相符。任何常数函数都是常数零函数的反导数。|
- en: '| **Exercise 10.23**: What is the integral of *x* cos(*x*)?**Hint**: Look at
    the derivative of *x* sin(*x*). Confirm your answer with SymPy. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| **练习10.23**：*x* cos(*x*)的积分是什么？**提示**：看看*x* sin(*x*)的导数。用SymPy确认你的答案。|'
- en: '| **Solution**: Let’s start with the hint−the derivative of *x* sin(*x*) is
    sin(*x*) + *x* cos(*x*) by the product rule. That’s almost what we want, but for
    an extra sin(*x*) term. If we had a −sin(*x*) term appearing in the derivative,
    it would cancel this extra sin(*x*) out, and the derivative of cos(*x*) is −sin(*x*).
    That is, the derivative of *x* sin(*x*) + cos(*x*) is sin(*x*) + *x* cos(*x*)
    − sin(*x*) = *x* cos(*x*). This was the result we are looking for, so the integral
    is∫ *x* cos(*x*)*dx* = *x* sin(*x*) + cos(*x*) + *C*Our answer checks out in SymPy:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '| **解答**：让我们从提示开始−根据乘积法则，*x* sin(*x*) 的导数是 sin(*x*) + *x* cos(*x*)。这几乎是我们想要的，但多了一个
    sin(*x*) 项。如果我们有一个出现在导数中的 −sin(*x*) 项，它就会抵消这个额外的 sin(*x*)，而 cos(*x*) 的导数是 −sin(*x*)。也就是说，*x*
    sin(*x*) + cos(*x*) 的导数是 sin(*x*) + *x* cos(*x*) − sin(*x*) = *x* cos(*x*)。这是我们想要的结果，所以积分是∫
    *x* cos(*x*)*d*x* = *x* sin(*x*) + cos(*x*) + *C*。我们的答案在 SymPy 中得到了验证：'
- en: '[PRE61]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This approach of reverse engineering the derivative as one term of a product
    is called *integration by parts* and is a favorite trick of calculus teachers
    everywhere. |
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将导数作为乘积的一个项进行逆向工程的方法被称为*分部积分*，并且是所有微积分教师的喜爱技巧。|
- en: '| **Exercise 10.24**: What is the integral of *x*² ? Confirm your answer with
    SymPy.**Solution**: If *f*''(*x*) = *x*² then *f*(*x*) probably contains *x*³
    because the power law reduces powers by one. The derivative of *x*³ is 3*x*²,
    so we want a function that gives us a third of that result. What we want is *x*³/3,
    which has derivative *x*². In other words,∫ *x*²*dx* = *x*³/3 + *C*SymPy confirms
    this:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 10.24**：*x*² 的积分是什么？用 SymPy 验证你的答案。**解答**：如果 *f*(*x*) = *x*²，那么 *f*(*x*)
    可能包含 *x*³，因为幂律将幂次降低一个。*x*³ 的导数是 3*x*²，所以我们想要一个函数，它给出这个结果的三分之一。我们想要的是 *x*³/3，它的导数是
    *x*²。换句话说，∫ *x*²*d*x* = *x*³/3 + *C*。SymPy 验证了这一点：'
- en: '[PRE62]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '|'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Modeling algebraic expressions as data structures rather than as strings of
    code lets you write programs to answer more questions about the expressions.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代数表达式建模为数据结构而不是代码字符串，让你能够编写程序来回答更多关于这些表达式的问题。
- en: The natural way to model an algebraic expression in code is as a *tree*. The
    nodes of the tree can be divided into elements (variables and numbers) that are
    standalone expressions, and combinators (sums, products, and so on) that contain
    two or more expressions as subtrees.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码中建模代数表达式最自然的方式是将其视为一个*树*。树的节点可以分为元素（变量和数字）这些是独立的表达式，以及组合器（和、积等）这些包含两个或更多子表达式的组合。
- en: By recursively traversing an expression tree, you can answer questions about
    it, such as what variables it contains. You can also evaluate or simplify the
    expression, or translate it to another language.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过递归遍历表达式树，你可以回答关于它的问题，例如它包含哪些变量。你也可以评估或简化表达式，或者将其翻译成另一种语言。
- en: If you know the expression defining a function, there are a handful of rules
    you can apply to transform it into the expression for the derivative of the function.
    Among these are the product rule and the chain rule, which tell you how to take
    derivatives of products of expressions and compositions of functions, respectively.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你知道定义函数的表达式，你可以应用一些规则来将其转换成函数导数的表达式。其中包含乘积法则和链式法则，它们告诉你如何对表达式的乘积和函数的复合求导。
- en: If you program the derivative rule corresponding to each combinator in your
    Python expression tree, you get a Python function that automatically finds expressions
    for derivatives.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你为你的 Python 表达式树中的每个组合器编程相应的导数规则，你将得到一个 Python 函数，它可以自动找到导数的表达式。
- en: SymPy is a robust Python library for working with algebraic expressions in Python
    code. It has built-in simplification, substitution, and derivative functions.
    It also has a symbolic integration function that tells you the formula for the
    indefinite integral of a function.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SymPy 是一个强大的 Python 库，用于在 Python 代码中处理代数表达式。它具有内置的简化、替换和导数函数。它还有一个符号积分函数，可以告诉你函数不定积分的公式。
