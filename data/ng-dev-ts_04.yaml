- en: Chapter 5\. Dependency injection in Angular
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章\. Angular中的依赖注入
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Introducing dependency injection as a design pattern
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍依赖注入作为设计模式
- en: Understanding how Angular implements DI
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Angular如何实现DI
- en: Registering object providers and using injectors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册对象提供者和使用注入器
- en: Adding Angular Material UI components to ngAuction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Angular Material UI组件添加到ngAuction
- en: '[Chapter 4](kindle_split_013.xhtml#ch04) discussed the router, and now the
    ngAuction app knows how to navigate from the home view to the product-detail view.
    In this chapter, we’ll concentrate on how Angular automates the process of creating
    objects and assembling the application from its building blocks.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](kindle_split_013.xhtml#ch04)讨论了路由器，现在ngAuction应用程序知道如何从主页导航到产品详情页。在本章中，我们将专注于Angular如何自动化创建对象和从其构建块组装应用程序的过程。'
- en: An Angular application is a collection of components, directives, and services
    that may depend on each other. Although each component can explicitly instantiate
    its dependencies, Angular can do this job using its dependency injection (DI)
    mechanism.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Angular应用程序是一组组件、指令和服务，它们可能相互依赖。尽管每个组件都可以显式实例化其依赖项，但Angular可以使用其依赖注入（DI）机制来完成这项工作。
- en: We’ll start this chapter by identifying the problem that DI solves and reviewing
    the benefits of DI as a software engineering design pattern. Then we’ll go over
    the specifics of how Angular implements the DI pattern using an example `ProductComponent`
    that depends on a `ProductService`. You’ll see how to write an injectable service
    and how to inject it into another component.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，确定DI解决的问题，并回顾DI作为软件工程设计模式的优点。然后，我们将通过一个依赖于`ProductService`的示例`ProductComponent`来具体说明Angular如何实现DI模式。您将了解如何编写可注入的服务以及如何将其注入到另一个组件中。
- en: After that, you’ll see a sample application that demonstrates how Angular DI
    allows you to easily replace one component dependency with another by changing
    just one line of code. At the end of the chapter, we’ll go through a hands-on
    exercise to build the next version of ngAuction, which uses Angular Material UI
    components.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您将看到一个示例应用程序，演示了Angular DI如何通过仅更改一行代码来轻松地用一个组件依赖项替换另一个组件依赖项。在本章末尾，我们将通过一个实际操作练习来构建ngAuction的下一个版本，该版本使用Angular
    Material UI组件。
- en: '*Design patterns* are recommendations for solving certain common tasks. A given
    design pattern can be implemented differently depending on the software you use.
    In the first section, we’ll briefly introduce two design patterns: dependency
    injection and inversion of control (IoC).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*设计模式*是解决某些常见任务的推荐。给定设计模式可以根据您使用的软件以不同的方式实现。在第一部分，我们将简要介绍两种设计模式：依赖注入和控制反转（IoC）。'
- en: 5.1\. The dependency injection pattern
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1\. 依赖注入模式
- en: 'If you’ve ever written a function that takes an object as an argument, you
    already wrote a program that instantiates this object and *injects* it into the
    function. Imagine a fulfillment center that ships products. An application that
    keeps track of shipped products can create a `Product` object and invoke a function
    that creates and saves a shipment record:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经编写过一个接受对象作为参数的函数，那么您已经编写了一个实例化此对象并将其*注入*到函数中的程序。想象一个负责运输产品的配送中心。一个跟踪已运输产品的应用程序可以创建一个`Product`对象并调用一个创建并保存运输记录的函数：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `createShipment()` function depends on the existence of an instance of
    the `Product` object, meaning the `createShipment()` function has a dependency:
    `Product`. But the function itself doesn’t know how to create `Product`. The calling
    script should somehow create and give (think *inject*) this object as an argument
    to the function.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`createShipment()`函数依赖于`Product`对象实例的存在，这意味着`createShipment()`函数有一个依赖项：`Product`。但该函数本身并不知道如何创建`Product`。调用脚本应通过某种方式创建并（想象一下*注入*）将此对象作为参数传递给函数。'
- en: Technically, you’re decoupling the creation of the `Product` object from its
    use—but both of the preceding lines of code are located in the same script, so
    it’s not real decoupling. If you need to replace `Product` with `MockProduct`,
    it’s a small code change in this simple example.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，您正在将`Product`对象的创建与其使用解耦——但上述两行代码都位于同一脚本中，因此这不是真正的解耦。如果您需要将`Product`替换为`MockProduct`，在这个简单示例中只需进行少量代码更改。
- en: What if the `createShipment()` function had three dependencies (such as product,
    shipping company, and fulfillment center), and each of those dependencies had
    its own dependencies? In that case, creating a different set of objects for the
    `createShipment()` function would require many more manual code changes. Would
    it be possible to ask someone to create instances of dependencies (with their
    dependencies) for you?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`createShipment()`函数有三个依赖项（例如产品、运输公司和履约中心），并且每个依赖项都有自己的依赖项呢？在这种情况下，为`createShipment()`函数创建不同的对象集将需要更多的手动代码更改。是否有可能要求某人为你创建依赖项（及其依赖项）的实例？
- en: 'This is what the dependency injection pattern is about: if object A depends
    on an object identified by a token (a unique ID) B, object A won’t explicitly
    use the `new` operator to instantiate the object that B points at. Rather, it
    will have B *injected* from the operational environment.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是依赖注入模式的内容：如果对象A依赖于一个由标记（一个唯一的ID）标识的对象B，对象A不会显式地使用`new`操作符来实例化B指向的对象。相反，它将从操作环境中注入B。
- en: Object A just needs to declare, “I need an object known as B; could someone
    please give it to me?” Object A doesn’t request a specific object type (for example,
    `Product`) but rather delegates the responsibility of what to inject to token
    B. It seems that object A doesn’t want to be in control of creating instances
    and is ready to let the framework control this process, doesn’t it?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对象A只需要声明，“我需要一个名为B的对象；请有人给我提供它？”对象A不请求特定的对象类型（例如，`Product`），而是将注入的责任委托给标记B。看起来对象A不想控制创建实例，并准备好让框架控制这个过程，不是吗？
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The inversion of control pattern**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制反转模式**'
- en: Inversion of control is a more general pattern than DI. Rather than making your
    application use some API from a framework (or a software container), the framework
    creates and supplies the objects that the application needs. The IoC pattern can
    be implemented in different ways, and DI is one of the ways of providing the required
    objects. Angular plays the role of the IoC container and can provide the required
    objects according to your component declarations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 控制反转（Inversion of Control，IoC）比依赖注入（DI）更为通用。不是让你的应用程序使用框架（或软件容器）中的某个API，而是框架创建并供应应用程序需要的对象。IoC模式可以以不同的方式实现，DI是提供所需对象的一种方式。Angular扮演着IoC容器的角色，可以根据你的组件声明提供所需的对象。
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.2\. Benefits of DI in Angular apps
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2. Angular应用程序中DI的优点
- en: Before we explore the syntax of Angular DI implementation, let’s look at the
    benefits of having objects injected versus instantiating them with a `new` operator.
    Angular offers a mechanism that helps with registering and instantiating component
    dependencies. In short, DI helps you write code in a loosely coupled way and makes
    your code more testable and reusable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索Angular DI实现的语法之前，让我们看看使用注入对象而不是使用`new`操作符实例化对象的优点。Angular提供了一种机制，有助于注册和实例化组件依赖项。简而言之，DI帮助你以松耦合的方式编写代码，并使你的代码更具可测试性和可重用性。
- en: '|  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**What is injected in Angular**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**Angular中注入的内容**'
- en: In Angular, you inject services or constants. The *services* are instances of
    TypeScript classes that don’t have a UI and just implement the business logic
    of your app. *Constants* can be any value. Typically, you’ll be injecting either
    Angular services (such as `Router` or `ActivatedRoute`) or your own classes that
    communicate with servers. You’ll see an example of injecting a constant in [section
    5.6](#ch05lev1sec6). A service can be injected either in a component or in another
    service.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，你注入服务或常量。*服务*是TypeScript类的实例，没有UI，仅实现应用程序的业务逻辑。*常量*可以是任何值。通常，你会注入Angular服务（如`Router`或`ActivatedRoute`）或与服务器通信的自己的类。你将在[第5.6节](#ch05lev1sec6)中看到一个注入常量的例子。服务可以在组件或另一个服务中注入。
- en: '|  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.2.1\. Loose coupling and reusability
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1. 松耦合和可重用性
- en: Say you have a `ProductComponent` that gets product details using the `ProductService`
    class. Without DI, your `ProductComponent` needs to know how to instantiate the
    `ProductService` class. This can be done multiple ways such as by using `new`,
    calling `getInstance()` on a singleton object, or invoking some factory function
    `createProductService()`. In any case, `ProductComponent` becomes *tightly coupled*
    with `ProductService`, because replacing `ProductService` with another implementation
    of this service requires code changes in `ProductComponent`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个使用 `ProductService` 类获取产品详情的 `ProductComponent`。在没有 DI 的情况下，你的 `ProductComponent`
    需要知道如何实例化 `ProductService` 类。这可以通过多种方式完成，例如使用 `new`，在单例对象上调用 `getInstance()`，或者调用某个工厂函数
    `createProductService()`。在任何情况下，`ProductComponent` 都会与 `ProductService` 变得 *紧密耦合*，因为用这个服务的另一个实现替换
    `ProductService` 需要在 `ProductComponent` 中进行代码更改。
- en: If you need to reuse `ProductComponent` in another application that uses a different
    service to get product details, you must modify the code, as in `productService
    = new AnotherProductService()`. DI allows you to decouple application components
    and services by sparing them from knowing how to create their dependencies.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在另一个使用不同服务获取产品详情的应用中重用 `ProductComponent`，你必须修改代码，例如 `productService =
    new AnotherProductService()`。依赖注入（DI）允许你通过避免组件和服务知道如何创建它们的依赖项来解耦应用组件和服务。
- en: Angular documentation uses the concept of a *token*, which is an arbitrary key
    representing an object to be injected. You map tokens to values for DI by specifying
    providers. A *provider* is an instruction to Angular about *how* to create an
    instance of an object for future injection into a target component, service, or
    directive. Consider the following listing, a `ProductComponent` example that gets
    the `ProductService` injected.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 文档使用了 *token* 的概念，它是一个表示要注入的对象的任意键。通过指定提供者，你可以将 tokens 映射到值以进行 DI。*provider*
    是对 Angular 的一个指令，说明如何创建一个对象实例以供将来注入到目标组件、服务或指令中。考虑以下示例，一个 `ProductComponent` 的例子，它注入了
    `ProductService`。
- en: Listing 5.1\. `ProductService` injected into `ProductComponent`
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1\. `ProductService` 注入到 `ProductComponent`
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Specifies the ProductService token as a provider for injection**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 ProductService token 指定为一个注入提供者**'
- en: '***2* Injects the object represented by the ProductService token**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入由 ProductService token 表示的对象**'
- en: '***3* Uses the API of the injected object**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用注入对象的 API**'
- en: 'Often the token name matches the type of the object to be injected, so [listing
    5.1](#ch05ex01) is a shorthand for instructing Angular to provide a `ProductService`
    token using the class of the same name. The long version would look like this:
    `providers:[{provide: ProductService, useClass: ProductService}]`. You say to
    Angular, “If you see a class with a constructor that uses the `ProductService`
    token, inject the instance of the `ProductService` class.”'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '通常，token 的名称与要注入的对象的类型相匹配，所以 [列表 5.1](#ch05ex01) 是一个简写，指示 Angular 使用同名的类提供
    `ProductService` token。长版本看起来像这样：`providers:[{provide: ProductService, useClass:
    ProductService}]`。你对 Angular 说，“如果你看到一个构造函数使用 `ProductService` token 的类，注入 `ProductService`
    类的实例。”'
- en: Using the `provide` property of `@Component()` or `@NgModule`, you can map the
    same token to different values or objects (such as to emulate the functionality
    of `ProductService` while someone else is developing a real service class).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@Component()` 或 `@NgModule` 的 `provide` 属性，你可以将相同的 token 映射到不同的值或对象（例如，在其他人开发真实服务类的同时模拟
    `ProductService` 的功能）。
- en: '|  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You already used the `providers` property in [chapter 3](kindle_split_012.xhtml#ch03),
    section 3.1.2, but it was defined, not on the component, but on the module level
    in `@NgModule()`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在[第3章](kindle_split_012.xhtml#ch03)的第3.1.2节中使用了 `providers` 属性，但它是在 `@NgModule()`
    模块级别上定义的，而不是在组件级别上。
- en: '|  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that you’ve added the `providers` property to the `@Component()` decorator
    of `ProductComponent`, Angular’s DI module will know that it has to instantiate
    an object of type `ProductService`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将 `providers` 属性添加到 `ProductComponent` 的 `@Component()` 装饰器中，Angular 的
    DI 模块将知道它需要实例化一个 `ProductService` 类型的对象。
- en: The next question is, when is the instance of the service created? That depends
    on the decorator in which you specified the provider for this service. In [listing
    5.1](#ch05ex01), you specify the provider inside the `@Component()` decorator.
    This tells Angular to create an instance of `ProductService` when `ProductComponent`
    is created. If you specify `ProductService` in the `providers` property inside
    the `@NgModule()` decorator, then the service instance would be created on the
    app level as a singleton so all components could reuse it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是什么时候创建服务的实例？这取决于你为该服务指定的装饰器。在[列表 5.1](#ch05ex01)中，你是在`@Component()`装饰器内部指定提供者的。这告诉
    Angular 在创建`ProductComponent`时创建`ProductService`的实例。如果你在`@NgModule()`装饰器内部的`providers`属性中指定`ProductService`，那么服务实例将在应用级别上创建为一个单例，这样所有组件都可以重用它。
- en: '`ProductComponent` doesn’t need to know which concrete implementation of the
    `ProductService` type to use—it’ll use whatever object is specified as a provider.
    The reference to the `ProductService` object will be injected via the constructor
    argument, and there’s no need to explicitly instantiate `ProductService` in `ProductComponent`.
    Just use it as in [listing 5.1](#ch05ex01), which calls the service method `getProduct()`
    on the `ProductService` instance magically created by Angular.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductComponent`不需要知道要使用`ProductService`类型的具体实现——它将使用指定为提供者的任何对象。对`ProductService`对象的引用将通过构造函数参数注入，并且不需要在`ProductComponent`中显式实例化`ProductService`。只需像[列表
    5.1](#ch05ex01)中那样使用它，该列表调用由 Angular 魔法般创建的`ProductService`实例上的服务方法`getProduct()`。'
- en: 'If you need to reuse the same `ProductComponent` with a different implementation
    of the `ProductService` type, change the providers line, as in `providers: [{provide:
    ProductService, useClass: AnotherProductService}]`. You’ll see an example of changing
    an injectable service in [section 5.5](#ch05lev1sec5). Now Angular will instantiate
    `AnotherProductService`, but the code of `ProductComponent` that uses `ProductService`
    doesn’t require modification. In this example, using DI increases the reusability
    of `ProductComponent` and eliminates its tight coupling with `ProductService`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你需要使用`ProductService`类型的不同实现来重用相同的`ProductComponent`，请更改提供者行，如`providers:
    [{provide: ProductService, useClass: AnotherProductService}]`。你将在[第 5.5 节](#ch05lev1sec5)中看到一个更改可注入服务的例子。现在
    Angular 将实例化`AnotherProductService`，但使用`ProductService`的`ProductComponent`代码不需要修改。在这个例子中，使用依赖注入增加了`ProductComponent`的可重用性，并消除了它与`ProductService`的紧密耦合。'
- en: 5.2.2\. Testability
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2\. 可测试性
- en: DI increases the testability of your components in isolation. You can easily
    inject mock objects if you want to unit test your code. Say you need to add a
    login feature to your application. You can create a `LoginComponent` (to render
    ID and password fields) that uses a `LoginService`, which should connect to a
    certain authorization server and check the user’s privileges. While unit testing
    your `LoginComponent`, you don’t want your tests to fail because the authorization
    server is down.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入增加了你组件的独立可测试性。如果你想对你的代码进行单元测试，你可以轻松地注入模拟对象。比如说，你需要给你的应用程序添加一个登录功能。你可以创建一个`LoginComponent`（用于渲染
    ID 和密码字段），它使用一个`LoginService`，该服务应连接到某个授权服务器并检查用户的权限。在单元测试`LoginComponent`时，你不想因为授权服务器宕机而导致测试失败。
- en: In unit testing, we often use mock objects that mimic the behavior of real objects.
    With a DI framework, you can create a mock object, `MockLoginService`, that doesn’t
    connect to an authorization server but rather has hardcoded access privileges
    assigned to users with certain ID/password combinations. Using DI, you can write
    a single line that injects `MockLoginService` into your application’s login view
    without needing to wait until the authorization server is ready. Your tests will
    get an instance of `MockLoginService` injected into your application’s login view
    (as seen in [figure 5.1](#ch05fig01)), and your tests won’t fail because of issues
    that you can’t control.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试中，我们经常使用模拟对象来模仿真实对象的行为。使用依赖注入框架，你可以创建一个模拟对象`MockLoginService`，它不连接到授权服务器，而是为具有特定
    ID/密码组合的用户分配硬编码的访问权限。使用依赖注入，你可以写一行代码将`MockLoginService`注入到你的应用程序的登录视图中，而无需等待授权服务器就绪。你的测试将获得注入到你的应用程序登录视图中的`MockLoginService`实例（如图
    5.1 所示），并且你的测试不会因为无法控制的问题而失败。
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In the hands-on section of [chapter 14](kindle_split_023.xhtml#ch14), you’ll
    see how to unit test injectable services.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 14 章的实践部分[kindle_split_023.xhtml#ch14]，你会看到如何对可注入服务进行单元测试。
- en: '|  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 5.1\. DI in testing
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.1\. 测试中的依赖注入
- en: '![](Images/05fig01_alt.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig01_alt.jpg)'
- en: 5.3\. Injectors and providers
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3. 注入器和提供者
- en: Now that you’ve had a brief introduction to dependency injection as a general,
    software-engineering design pattern, let’s go over the specifics of implementing
    DI in Angular. In particular, we’ll go over such concepts as injectors and providers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对依赖注入作为一种通用的、软件工程设计模式有了简要的介绍，让我们来探讨在Angular中实现DI的具体细节。特别是，我们将讨论注入器和提供者等概念。
- en: Each component can have an `Injector` instance capable of injecting objects
    or primitive values into a component. Any Angular application has a root injector
    available to all of its modules. To let the injector know what to inject, you
    specify the provider. An injector will inject the object or value specified in
    the provider into the constructor of a component. Providers allow you to map a
    custom type (or a token) to a concrete implementation of this type (or value).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件都可以有一个`Injector`实例，该实例可以将对象或原始值注入到组件中。任何Angular应用程序都有一个根注入器，对所有模块都可用。为了让注入器知道要注入的内容，你指定提供者。注入器会将提供者中指定的对象或值注入到组件的构造函数中。提供者允许你将自定义类型（或令牌）映射到该类型的具体实现（或值）。
- en: '|  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注释
- en: Although eagerly loaded modules don’t have their own injectors, a lazy-loaded
    module has its own subroot injector that’s a direct child of the parent’s module
    injector. You’ll see an example of injection in a lazy-loaded module in [section
    5.7](#ch05lev1sec7).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管急切加载的模块没有自己的注入器，但延迟加载的模块有一个自己的子根注入器，它是父模块注入器的直接子节点。你将在[第5.7节](#ch05lev1sec7)中看到一个延迟加载模块的注入示例。
- en: '|  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: In Angular, you can inject a service into a class only via its constructor’s
    arguments. If you see a class with a no-argument constructor, it’s a guarantee
    that nothing is injected into this class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular中，你只能通过类的构造函数参数将服务注入到类中。如果你看到一个无参数构造函数的类，这保证这个类中没有注入任何内容。
- en: '|  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'We’ll be using `ProductComponent` and `ProductService` in several code samples
    in this chapter. If your application has a class implementing a particular type
    (such as `ProductService`), you can specify a provider object for this class on
    the application level in the `@NgModule()` decorator, like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的几个代码示例中使用`ProductComponent`和`ProductService`。如果你的应用程序有一个实现特定类型（如`ProductService`）的类，你可以在`@NgModule()`装饰器中在应用程序级别为该类指定提供者对象，如下所示：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When the token name is the same as the class name, you can use the shorter
    notation to specify the provider in the module:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当令牌名称与类名相同时，你可以使用简短表示法在模块中指定提供者：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `providers` line instructs the injector as follows: “When you need to construct
    an object that has an argument of type `ProductService`, create an instance of
    the registered class for injection into this object.” When Angular instantiates
    a component that has the `ProductService` token as an argument of the component’s
    constructor, it’ll either instantiate and inject `ProductService` or just reuse
    the existing instance and inject it. In this scenario, we’ll have a singleton
    instance of the service for the entire application.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`providers`行指示注入器如下：“当你需要构造一个具有`ProductService`类型参数的对象时，创建一个注册类的实例以注入到该对象中。”当Angular实例化一个将`ProductService`令牌作为组件构造函数参数的组件时，它将实例化和注入`ProductService`，或者只是重用现有实例并注入它。在这种情况下，我们将为整个应用程序拥有一个服务单例实例。'
- en: 'If you need to inject a different implementation for a particular token, use
    the longer notation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要为特定令牌注入不同的实现，请使用较长的表示法：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `providers` property can be specified in the `@Component()` annotation.
    The short notation of the `ProductService` provider in `@Component()` looks like
    this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`providers`属性可以在`@Component()`注解中指定。在`@Component()`中`ProductService`提供者的简短表示法如下：'
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can use the long notation for providers the same way as with modules. If
    a provider was specified at the component level, Angular will create and inject
    an instance of `ProductService` during component instantiation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用与模块相同的长期表示法为提供者指定。如果提供者在组件级别指定，Angular将在组件实例化期间创建并注入`ProductService`实例。
- en: Thanks to the provider, the injector knows what to inject; now you need to specify
    *where* to inject the service. With classes, it comes down to declaring a constructor
    argument specifying the token as its type. The preceding code snippet shows how
    to inject an object represented by the `ProductService` token. The constructor
    will remain the same regardless of which concrete implementation of `ProductService`
    is specified as a provider.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了提供者，注入器知道要注入什么；现在你需要指定*在哪里*注入服务。对于类，这归结为声明一个构造函数参数，指定令牌为其类型。前面的代码片段展示了如何注入由`ProductService`令牌表示的对象。构造函数将保持不变，无论指定为提供者的`ProductService`的具体实现是什么。
- en: 'The `providers` property is an array. You can specify multiple providers for
    different services if need be. Here’s an example of a single-element array that
    specifies the provider object for the `ProductService` token:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`providers`属性是一个数组。如果需要，你可以为不同的服务指定多个提供者。以下是一个指定`ProductService`令牌提供者对象的单元素数组的示例：'
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `provide` property maps the token to the method of instantiating the injectable
    object. This example instructs Angular to create an instance of the `MockProductService`
    class wherever the `ProductService` token is used as a constructor’s argument.
    Angular’s injector can use a class or a factory function for instantiation and
    injection. You can declare a provider using the following properties:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`provide`属性将令牌映射到实例化可注入对象的函数。此示例指示Angular在`ProductService`令牌作为构造函数参数使用的地方创建`MockProductService`类的实例。Angular的注入器可以使用类或工厂函数进行实例化和注入。你可以使用以下属性声明提供者：'
- en: '**`useClass`—** To map a token to a class, as shown in the preceding example'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`useClass`—** 将令牌映射到类，如前例所示'
- en: '**`useFactory`—** To map a token to a factory function that instantiates objects
    based on certain criteria'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`useFactory`—** 将令牌映射到工厂函数，该函数根据某些标准实例化对象'
- en: '**`useValue`—** To map a `string` or a special `InjectionToken` to an arbitrary
    value (non-class-based injection)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`useValue`—** 将`string`或特殊的`InjectionToken`映射到任意值（非基于类的注入）'
- en: How can you decide which of these properties to use in your code? In the next
    section, you’ll become familiar with the `useClass` property. [Section 5.6](#ch05lev1sec6)
    illustrates `useFactory` and `useValue`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何在代码中决定使用这些属性中的哪一个？在下一节中，你将熟悉`useClass`属性。[第5.6节](#ch05lev1sec6)说明了`useFactory`和`useValue`。
- en: 5.4\. A simple app with Angular DI
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4\. 一个简单的Angular DI应用程序
- en: Now that you’ve seen a number of code snippets related to Angular DI, let’s
    build a small application that will bring all the pieces together. This will prepare
    you to use DI in the ngAuction application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了许多与Angular DI相关的代码片段，让我们构建一个小型应用程序，将所有这些组件整合在一起。这将为你使用ngAuction应用程序中的DI做准备。
- en: 5.4.1\. Injecting a product service
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1\. 注入产品服务
- en: You’ll create a simple application that uses `ProductComponent` to render product
    details and `ProductService` to supply data about the product. If you use the
    downloadable code that comes with the book, this app is located in the directory
    di-samples/basic. In this section, you’ll build an application that produces the
    page shown in [figure 5.2](#ch05fig02).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建一个简单的应用程序，使用`ProductComponent`来渲染产品详情，并使用`ProductService`来提供产品数据。如果你使用书中提供的可下载代码，此应用程序位于di-samples/basic目录中。在本节中，你将构建一个生成[图5.2](#ch05fig02)中所示页面的应用程序。
- en: Figure 5.2\. A sample DI application
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.2\. 一个示例DI应用程序
- en: '![](Images/05fig02.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig02.jpg)'
- en: '`ProductComponent` can request the injection of the `ProductService` object
    by declaring the constructor argument with a type:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductComponent`可以通过声明构造函数参数的类型来请求注入`ProductService`对象：'
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Figure 5.3](#ch05fig03) shows a sample application that uses these components.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.3](#ch05fig03)展示了一个使用这些组件的示例应用程序。'
- en: Figure 5.3\. Injecting `ProductService` into `ProductComponent`
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3\. 将`ProductService`注入到`ProductComponent`
- en: '![](Images/05fig03_alt.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig03_alt.jpg)'
- en: The `AppModule` has a root, `AppComponent`, that includes `ProductComponent`,
    which is dependent on `ProductService`. Note the `import` and `export` statements.
    The class definition of `ProductService` starts with the `export` statement, to
    enable other components to access its content.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppModule`有一个根组件`AppComponent`，它包含`ProductComponent`，该组件依赖于`ProductService`。注意`import`和`export`语句。`ProductService`类的定义以`export`语句开始，以便其他组件可以访问其内容。'
- en: The `providers` attribute defined on the component level (refer to [figure 5.3](#ch05fig03))
    instructs Angular to provide an instance of the `ProductService` class when `ProductComponent`
    is created. `ProductService` may communicate with some server, requesting details
    for the product selected on the web page, but we’ll skip that part for now and
    concentrate on how this service can be injected into `ProductComponent`. The following
    listing implements the components from [figure 5.3](#ch05fig03), starting from
    the root component.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件级别上定义的 `providers` 属性（参见图 5.3）（#ch05fig03）指示 Angular 在创建 `ProductComponent`
    时提供 `ProductService` 类的一个实例。`ProductService` 可能会与某些服务器通信，请求网页上选择的产品详情，但我们现在将跳过这部分内容，专注于如何将此服务注入到
    `ProductComponent` 中。以下列表从根组件开始实现了 [图 5.3](#ch05fig03) 中的组件。
- en: Listing 5.2\. app.component.ts
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.2\. app.component.ts
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Including the <di-product-page> component into the template**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 <di-product-page> 组件添加到模板中**'
- en: Based on the `<di-product-page>` tag, you can guess that there’s a component
    with the selector having this value. This selector is declared in `ProductComponent`,
    whose dependency, `ProductService`, is injected via the constructor, as shown
    in the next listing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `<di-product-page>` 标签，你可以猜测有一个具有此值的选择器的组件。此选择器在 `ProductComponent` 中声明，其依赖项
    `ProductService` 通过构造函数注入，如下一列表所示。
- en: Listing 5.3\. product.component.ts
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.3\. product.component.ts
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Specifying the selector of this component**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 指定此组件的选择器**'
- en: '***2* The short notation of the providers property tells the injector to instantiate
    the ProductService class.**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* providers 属性的简写告诉注入器实例化 ProductService 类。**'
- en: '***3* Angular instantiates ProductService and injects it here.**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Angular 实例化了 ProductService 并将其注入此处。**'
- en: In [listing 5.3](#ch05ex03), you use the `ProductService` class as a token for
    a type with the same name, so you use a short notation without the need to explicitly
    map the `provide` and `useClass` properties. When specifying providers, you separate
    the token of the injectable object from its implementation. Although in this case,
    the name of the token is the same as the name of the type—`ProductService`—the
    code mapped to this token can be located in a class called `ProductService`, `OtherProductService`,
    or some other name. Replacing one implementation with another comes down to changing
    the `providers` line.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 5.3](#ch05ex03) 中，你使用 `ProductService` 类作为具有相同名称的类型的一个标记，因此你可以使用简写而不需要显式映射
    `provide` 和 `useClass` 属性。当指定提供者时，你将可注入对象的标记与其实现分开。尽管在这种情况下，标记的名称与类型的名称相同——`ProductService`——但映射到该标记的代码可以位于名为
    `ProductService`、`OtherProductService` 或其他名称的类中。用另一个实现替换一个实现归结为更改 `providers`
    行。
- en: The constructor of `ProductComponent` invokes `getProduct()` on the service
    and places a reference to the returned `Product` object in the `product` class
    variable, which is used in the HTML template. By using double curly braces, you
    bind the `title`, `description`, and `price` properties of the `Product` class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductComponent` 的构造函数在服务上调用 `getProduct()` 并将返回的 `Product` 对象的引用放置在 `product`
    类变量中，该变量用于 HTML 模板。通过使用双大括号，将 `Product` 类的 `title`、`description` 和 `price` 属性绑定。'
- en: 'The product-service.ts file includes the declaration of two classes: `Product`
    and `ProductService`, as you can see in the following listing.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: product-service.ts 文件包含了两个类的声明：`Product` 和 `ProductService`，如以下列表所示。
- en: Listing 5.4\. product-service.ts
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4\. product-service.ts
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* The Product class represents a product (a value object). It’s used outside
    of this script, so you export it.**'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Product 类代表一个产品（一个值对象）。它在此脚本之外使用，因此将其导出。**'
- en: '***2* For simplicity, the getProduct() method always returns the same product
    with hardcoded values.**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为了简单起见，getProduct() 方法总是返回具有硬编码值的相同产品。**'
- en: In a real-world application, the `getProduct()` method would have to get the
    product information from an external data source, such as by making an HTTP request
    to a remote server.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，`getProduct()` 方法必须从外部数据源获取产品信息，例如通过向远程服务器发出 HTTP 请求。
- en: 'To run this example, do `npm install` and run the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，请执行 `npm install` 并运行以下命令：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The browser will open the window, as shown earlier in [figure 5.2](#ch05fig02).
    The instance of `ProductService` is injected into `ProductComponent`, which renders
    product details provided by the service.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器将打开窗口，如图 5.2（#ch05fig02）中所示。`ProductService` 的实例被注入到 `ProductComponent` 中，该组件渲染服务提供的产品详情。
- en: In the next section, you’ll see a `ProductService` decorated with `@Injectable()`,
    which is required only when the service itself has its own dependencies. It instructs
    Angular to generate additional metadata for this service. The `@Injectable()`
    decorator isn’t needed in the example because `ProductService` doesn’t have any
    other dependencies injected into it, and Angular doesn’t need additional metadata
    to inject `ProductService` into components.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将看到装饰了 `@Injectable()` 的 `ProductService`，这仅在服务本身有依赖项时才需要。它指示 Angular
    为此服务生成额外的元数据。在示例中不需要 `@Injectable()` 装饰器，因为 `ProductService` 没有其他依赖项被注入，并且 Angular
    不需要额外的元数据来将 `ProductService` 注入到组件中。
- en: '|  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**An alternative DI syntax with @Inject()**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 @Inject() 的替代 DI 语法**'
- en: 'In our example, the provider maps a token to a class, and the syntax for injecting
    is simple: use the constructor argument’s type as a token, and Angular will generate
    the required metadata for the provided type:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，提供者将令牌映射到类，注入的语法很简单：使用构造函数参数的类型作为令牌，Angular 将为提供的类型生成所需的元数据：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There’s an alternative and more verbose syntax to specify the token using the
    decorator `@Inject()`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种替代的、更冗长的语法，可以使用装饰器 `@Inject()` 来指定令牌：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, you don’t specify the type of the constructor argument, but use
    the `@Inject()` decorator to instruct Angular to generate the metadata for the
    `ProductService`. With class-based injection, you don’t need to use this verbose
    syntax, but there are situations where you have to use `@Inject()`, and we’ll
    discuss this in [section 5.6.1](#ch05lev2sec5).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您不需要指定构造函数参数的类型，而是使用 `@Inject()` 装饰器来指示 Angular 为 `ProductService` 生成元数据。在基于类的注入中，您不需要使用这种冗长的语法，但有些情况下您必须使用
    `@Inject()`，我们将在 [5.6.1 节](#ch05lev2sec5) 中讨论这一点。
- en: '|  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.4.2\. Injecting the HttpClient service
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.2\. 注入 HttpClient 服务
- en: 'Often, a service will need to make an HTTP request to get necessary data. `ProductComponent`
    depends on `ProductService`, which is injected using the Angular DI mechanism.
    If `ProductService` needs to make an HTTP request, it’ll have an `HttpClient`
    object as its own dependency. `ProductService` will need to import the `HttpClient`
    object for injection; `@NgModule()` must import `HttpClientModule`, which defines
    `HttpClient` providers. The `ProductService` class should have a constructor for
    injecting the `HttpClient` object. [Figure 5.4](#ch05fig04) shows `ProductComponent`
    depending on `ProductService`, which has its own dependency: `HttpClient`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个服务需要通过 HTTP 请求获取必要的数据。`ProductComponent` 依赖于 `ProductService`，它使用 Angular
    DI 机制进行注入。如果 `ProductService` 需要执行 HTTP 请求，它将有一个 `HttpClient` 对象作为其依赖项。`ProductService`
    需要导入 `HttpClient` 对象以进行注入；`@NgModule()` 必须导入 `HttpClientModule`，它定义了 `HttpClient`
    提供者。`ProductService` 类应该有一个构造函数来注入 `HttpClient` 对象。[图 5.4](#ch05fig04) 显示 `ProductComponent`
    依赖于具有其自身依赖项的 `ProductService`：`HttpClient`。
- en: Figure 5.4\. A dependency can have its own dependency.
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.4\. 一个依赖项可以有自己的依赖项。
- en: '![](Images/05fig04_alt.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig04_alt.jpg)'
- en: The following listing illustrates the `HttpClient` object’s injection into `ProductService`
    and the retrieval of products from the products.json file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表说明了将 `HttpClient` 对象注入到 `ProductService` 以及从 products.json 文件中检索产品的过程。
- en: Listing 5.5\. Injecting `HttpClient` into `ProductService`
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5\. 将 `HttpClient` 注入到 `ProductService`
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Injecting HttpClient**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注入 HttpClient**'
- en: '***2* Using HTTP GET**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 HTTP GET**'
- en: '***3* Subscribing to the result of the HTTP request**'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 订阅 HTTP 请求的结果**'
- en: Because `ProductService` has its own injectable dependency, you need to decorate
    it with `@Injectable()`. Here, you inject a service into another service. The
    class constructor is the injection point, but where do you declare the provider
    for injecting the `HttpClient` type object? All the providers required to inject
    various flavors of `HttpClient` objects are declared in `HttpClientModule`. You
    just need to add it to your `AppModule`, as in the following listing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `ProductService` 有自己的可注入依赖项，所以您需要用 `@Injectable()` 装饰它。在这里，您将一个服务注入到另一个服务中。类构造函数是注入点，但您在哪里声明注入
    `HttpClient` 类型对象的提供者？所有必需的提供者都声明在 `HttpClientModule` 中。您只需将其添加到您的 `AppModule`
    中，如下所示。
- en: Listing 5.6\. Adding `HttpClientModule`
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.6\. 添加 `HttpClientModule`
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Imports HttpClientModule in the root module**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在根模块中导入 HttpClientModule**'
- en: '***2* Adds HttpClientModule to the imports section**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 HttpClientModule 添加到导入部分**'
- en: '|  |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '[Chapter 12](kindle_split_021.xhtml#ch12) explains how `HttpClient` works.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 12 章](kindle_split_021.xhtml#ch12) 解释了 `HttpClient` 的工作原理。'
- en: '|  |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Starting in Angular 6, the `@Injectable()` decorator allows you to specify the
    `provideIn` property, which may spare you from explicit declaration of the provider
    for the service. The following listing shows how you can instruct Angular to automatically
    create the module-level provider for `ProductService`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Angular 6 开始，`@Injectable()` 装饰器允许你指定 `provideIn` 属性，这可能让你免于显式声明服务的提供者。以下列表显示了如何指示
    Angular 自动创建模块级别的 `ProductService` 提供者。
- en: Listing 5.7\. Using `provideIn`
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.7\. 使用 `provideIn`
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that you’ve seen how to inject an object into a component, let’s look at
    what it takes to replace one implementation of a service with another, using Angular
    DI.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何将对象注入到组件中，让我们看看使用 Angular DI 替换一个服务实现为另一个实现需要什么。
- en: 5.5\. Switching injectables made easy
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5\. 简化注入服务切换
- en: Earlier in this chapter, we stated that the DI pattern allows you to decouple
    components from their dependencies. In the previous section, you decoupled `ProductComponent`
    from `ProductService`. Now let’s simulate another scenario.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早期，我们提到 DI 模式允许你将组件与其依赖项解耦。在前一节中，你将 `ProductComponent` 从 `ProductService`
    中解耦。现在让我们模拟另一个场景。
- en: 'Suppose you’ve started development with a `ProductService` that should get
    data from a remote server, but the server’s feed isn’t ready. Rather than modify
    the code in `ProductService` to introduce hardcoded data for testing, you’ll create
    another class: `MockProductService`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经开始使用一个 `ProductService` 进行开发，该服务应从远程服务器获取数据，但服务器的数据源尚未准备好。与其修改 `ProductService`
    中的代码以引入硬编码的数据进行测试，你将创建另一个类：`MockProductService`。
- en: To illustrate how easy it is to switch from one service to another, you’ll create
    a small application that uses two instances of `ProductComponent`. Initially,
    the first one will use `MockProductService` and the second, `ProductService`.
    Then, with a one-line change, you’ll make both of them use the same service. [Figure
    5.5](#ch05fig05) shows how the app renders two product components that use different
    implementations of `ProductService`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明从一种服务切换到另一种服务有多容易，你将创建一个小型应用程序，该应用程序使用两个 `ProductComponent` 实例。最初，第一个将使用
    `MockProductService`，第二个使用 `ProductService`。然后，通过一行更改，你将使它们都使用同一个服务。[图 5.5](#ch05fig05)
    显示了应用程序如何渲染使用 `ProductService` 不同实现的两个产品组件。
- en: Figure 5.5\. Two components and two products
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.5\. 两个组件和两个产品
- en: '![](Images/05fig05.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig05.jpg)'
- en: The iPhone 7 product is rendered by `Product1Component`, and the Samsung 7 is
    rendered by `Product2Component`. This application focuses on switching product
    services using Angular DI, so we’ve kept the components and services simple. The
    app that comes with this chapter has components and services in separate files,
    but we put all the relevant code in the following listing.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone 7 产品由 `Product1Component` 渲染，而 Samsung 7 由 `Product2Component` 渲染。这个应用程序专注于使用
    Angular DI 切换产品服务，因此我们保持了组件和服务简单。本章附带的应用程序中组件和服务位于单独的文件中，但我们把所有相关代码放在以下列表中。
- en: Listing 5.8\. Two products and two services
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.8\. 两个产品和两个服务
- en: '[PRE17]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Bad design**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 不良设计**'
- en: '***2* Since there is no provider declared on this component level, it’ll use
    the app-level provider.**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 由于在此组件级别没有声明提供者，它将使用应用级别的提供者。**'
- en: '***3* Declares a provider on the component level just for ProductComponent2**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 仅在组件级别为 ProductComponent2 声明提供者**'
- en: '***4* ProductComponent2 gets MockProductService because its provider was specified
    at the component level.**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* ProductComponent2 获取 MockProductService，因为其提供者在组件级别已指定。**'
- en: '***5* Browser renders two child components of AppComponent**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 浏览器渲染 AppComponent 的两个子组件**'
- en: '***6* Declares the app-level provider**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 声明应用级别的提供者**'
- en: '|  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: '[Listing 5.8](#ch05ex08) has two lines marked as bad design. Read the sidebar
    “Program to abstractions” for explanations.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.8](#ch05ex08) 中有两行被标记为不良设计。阅读“面向抽象编程”的侧边栏以获取解释。'
- en: '|  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If a component doesn’t need a specific `ProductService` implementation, there’s
    no need to explicitly declare a provider for it, as long as a provider was specified
    at the parent-component level or in `@NgModule()`. In [listing 5.8](#ch05ex08),
    `Product1Component` doesn’t declare its own provider for `ProductService`, and
    Angular will find one on the application level.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个组件不需要特定的 `ProductService` 实现，那么在父组件级别或 `@NgModule()` 中指定了提供者的情况下，就没有必要显式声明其提供者。在
    [列表 5.8](#ch05ex08) 中，`Product1Component` 没有声明自己的 `ProductService` 提供者，Angular
    将在应用级别找到它。
- en: But each component is free to override the `providers` declaration made at the
    app- or parent-component level, as in `Product2Component`. Each component has
    its own injector, and during the instantiation of `Product2Component`, this injector
    will see the component-level provider and will inject `MockProductService`. This
    injector won’t even check whether there’s a provider for the same token on the
    app level.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 但每个组件都可以自由覆盖在应用或父组件级别做出的`providers`声明，如`Product2Component`所示。每个组件都有自己的注入器，在`Product2Component`的实例化过程中，这个注入器将看到组件级别的提供者并将注入`MockProductService`。这个注入器甚至不会检查应用级别上是否有相同标记的提供者。
- en: If you decide that `Product2Component` should get an instance of `ProductService`
    injected, remove the `providers` line in its `@Component()` decorator.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定`Product2Component`应该获取`ProductService`的注入实例，请从其`@Component()`装饰器中移除`providers`行。
- en: From now on, wherever the `ProductService` type needs to be injected and no
    `providers` line is specified on the component level, Angular will instantiate
    and inject `ProductService`. Running the application after making the preceding
    change renders the components as shown in [figure 5.6](#ch05fig06).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，无论何时需要注入`ProductService`类型且在组件级别未指定`providers`行，Angular都会实例化并注入`ProductService`。在做出上述更改后运行应用程序，组件将呈现如图5.6所示。
- en: Figure 5.6\. Two components and one service
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.6\. 两个组件和一个服务
- en: '![](Images/05fig06.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig06.jpg)'
- en: 'To see this app in action, run the following command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用程序的实际运行情况，请运行以下命令：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Imagine that your application had dozens of components using `ProductService`.
    If each of them instantiated this service with a `new` operator, you’d need to
    make dozens of code changes. With Angular DI, you’re able to switch the service
    by changing one line in the `providers` declaration.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的应用程序有数十个使用`ProductService`的组件。如果每个组件都使用`new`运算符实例化此服务，你需要进行数十次代码更改。使用Angular
    DI，你能够通过更改`providers`声明中的一行来切换服务。
- en: '|  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Program to abstractions**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向抽象编程**'
- en: In object-oriented programming, it’s recommended to program to interfaces, or
    *abstractions*. Because the Angular DI module allows you to replace injectable
    objects, it would be nice if you could declare a `ProductService` interface and
    specify it as a provider. Then you’d write several concrete classes that implement
    this interface and switch them in the `providers` declaration as needed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，建议按照接口或*抽象*编程。因为Angular DI模块允许你替换可注入对象，所以如果你能声明一个`ProductService`接口并将其指定为提供者，那将很棒。然后你会编写几个实现此接口的具体类，并根据需要将它们切换到`providers`声明中。
- en: 'You can do this in Java, C#, PHP, and other object-oriented languages. The
    problem is that after transpiling the TypeScript code into JavaScript, the interfaces
    are removed, because JavaScript doesn’t support them. In other words, if `ProductService`
    were declared as an interface, the following constructor would be wrong, because
    the JavaScript code wouldn’t know anything about `ProductService`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Java、C#、PHP和其他面向对象的语言中这样做。问题是，在将TypeScript代码转换为JavaScript后，接口被移除了，因为JavaScript不支持它们。换句话说，如果`ProductService`被声明为接口，下面的构造函数将是错误的，因为JavaScript代码对`ProductService`一无所知：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'But TypeScript supports abstract classes, which can have some of the methods
    implemented, and some abstract—declared but not implemented. Then, you’d need
    to implement some concrete classes that extend the abstract ones and implement
    all abstract methods. For example, you can have the classes shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但TypeScript支持抽象类，其中可以有一些方法被实现，而有些则是抽象的——声明但未实现。然后，你需要实现一些具体的类，这些类扩展了抽象类并实现了所有抽象方法。例如，你可以有如下所示的类：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Declares an abstract class**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明一个抽象类**'
- en: '***2* Declares an abstract method**'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明一个抽象方法**'
- en: '***3* Creates the first concrete implementation of the abstract class**'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建抽象类的第一个具体实现**'
- en: '***4* Creates the second concrete implementation of the abstract class**'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建抽象类的第二个具体实现**'
- en: Note that If your abstract class doesn’t implement any methods (as in this case),
    you could use the keyword `implement` instead of `extend`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你的抽象类没有实现任何方法（如本例所示），你可以使用关键字`implement`而不是`extend`。
- en: 'The good news is that you can use the name of the abstract class in the constructors,
    and during the JavaScript code generation, Angular will use a specific concrete
    class based on the provider declaration. Having the classes `ProductService`,
    `MockProductService`, and `RealProductService` declared, as in this sidebar, will
    allow you to write something like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，你可以在构造函数中使用抽象类的名称，在 JavaScript 代码生成期间，Angular 将根据提供者声明使用特定的具体类。正如这个侧边栏中声明的
    `ProductService`、`MockProductService` 和 `RealProductService` 类一样，这将允许你编写如下内容：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, you use an abstraction both in the token and in the constructor’s argument.
    This wasn’t the case in [listing 5.8](#ch05ex08), where `ProductService` was a
    concrete implementation of certain functionality. Replacing the providers works
    the same way as described earlier, if you decide to switch from one concrete implementation
    of the service to another.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你同时在令牌和构造函数的参数中使用了抽象。在 [列表 5.8](#ch05ex08) 中，`ProductService` 是某些功能的具体实现，这种情况并不适用。如果你决定从服务的一个具体实现切换到另一个，替换提供者的方式与之前描述的方式相同。
- en: In [listing 5.8](#ch05ex08), you declared the `ProductService` and `MockProductService`
    classes as having methods with the same name, `getProducts()`. If you used the
    abstract-class approach, the TypeScript compiler would give you an error if you’d
    tried to implement a concrete class but would miss an implementation of one of
    the abstract methods. That’s why two lines in [listing 5.8](#ch05ex08) are flagged
    as bad design.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 5.8](#ch05ex08) 中，你将 `ProductService` 和 `MockProductService` 类声明为具有相同名称的方法
    `getProducts()`。如果你使用了抽象类方法，TypeScript 编译器会给出错误，如果你尝试实现一个具体类但遗漏了一个抽象方法的实现。这就是为什么
    [列表 5.8](#ch05ex08) 中的两行被标记为不良设计。
- en: '|  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: What if your component or module can’t map a token to a class but needs to apply
    some business logic to decide which class to instantiate? Furthermore, what if
    you want to inject just a primitive value and not an object?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的组件或模块无法将令牌映射到类，但需要应用一些业务逻辑来决定实例化哪个类呢？此外，如果你只想注入一个原始值而不是一个对象呢？
- en: 5.6\. Declaring providers with useFactory and useValue
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6\. 使用 useFactory 和 useValue 声明提供者
- en: In general, factory functions are used when you need to apply some application
    logic prior to instantiating an object. For example, you may need to decide which
    object to instantiate, or your object may have a constructor with arguments that
    you need to initialize before creating an instance. Let’s modify the app from
    the previous section to illustrate the use of factory and value providers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当需要在实例化对象之前应用一些应用逻辑时，会使用工厂函数。例如，你可能需要决定实例化哪个对象，或者你的对象可能有一个需要在你创建实例之前初始化的带有参数的构造函数。让我们修改上一节中的应用程序，以说明工厂和值提供者的使用。
- en: The following listing shows a modified version of `Product2Component`, which
    you can find in the factory directory of the di-samples app. It shows how you
    can write a factory function and use it as a provider for injectors. This factory
    function creates either `ProductService` or `MockProductService`, based on the
    `boolean` flag `isProd`, indicating whether to run in a production or dev environment,
    as shown in the following listing.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了 `Product2Component` 的修改版本，你可以在 di-samples 应用程序的工厂目录中找到它。它展示了如何编写一个工厂函数并将其用作注入器的提供者。这个工厂函数根据
    `boolean` 标志 `isProd` 创建 `ProductService` 或 `MockProductService`，该标志指示是否在生产或开发环境中运行，如下面的列表所示。
- en: Listing 5.9\. product.factory.ts
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.9\. product.factory.ts
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Injects the value of isProd into the factory function**'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 isProd 的值注入到工厂函数中**'
- en: '***2* Instantiates the service based on the value of isProd**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 根据 isProd 的值实例化服务**'
- en: You’ll use the `useFactory` property to specify the provider for the `ProductService`
    token. Because this factory requires an argument (a dependency), you need to tell
    Angular where to get the value for this argument, and you do that using a special
    property, `deps`, as shown in the following listing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 `useFactory` 属性来指定 `ProductService` 令牌的提供者。因为这个工厂函数需要一个参数（一个依赖项），你需要告诉
    Angular 从哪里获取这个参数的值，你可以使用一个特殊的属性 `deps` 来做到这一点，如下面的列表所示。
- en: Listing 5.10\. Specifying a factory function as a provider
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.10\. 将工厂函数指定为提供者
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* This function used for instantiating a service**'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 此函数用于实例化服务**'
- en: '***2* The dependency of this factory function**'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 此工厂函数的依赖项**'
- en: Here, you instruct Angular to inject a value specified by the `IS_PROD_ENVIRONMENT`
    token into your factory function. If a factory function has more than one argument,
    you list the corresponding tokens for them in the `deps` array.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你指示 Angular 向你的工厂函数注入由 `IS_PROD_ENVIRONMENT` 令牌指定的值。如果工厂函数有多个参数，你可以在 `deps`
    数组中列出相应的令牌。
- en: 'How do you provide a static value for a token represented by a string? You
    do it by using the `useValue` property. Here’s how you can associate the value
    `true` with the `IS_PROD_ENVIRONMENT` token:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如何为表示为字符串的令牌提供一个静态值？你可以通过使用 `useValue` 属性来实现。以下是如何将值 `true` 与 `IS_PROD_ENVIRONMENT`
    令牌关联起来的示例：
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that you map a string token to a hardcoded primitive value, which is not
    something you’d do in real-world apps. Let’s use the environment variables from
    the environment files generated by Angular CLI in the directory src/environments
    to find out whether your app runs in dev or production. This directory has two
    files: environment.prod.ts and environment.ts. Here’s the content from environment.prod.ts:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你将一个字符串令牌映射到一个硬编码的原始值，这在现实世界的应用程序中不是你通常会做的事情。让我们使用 Angular CLI 在 src/environments
    目录中生成的环境文件中的环境变量来找出你的应用程序是在开发模式还是生产模式下运行。此目录有两个文件：environment.prod.ts 和 environment.ts。以下是
    environment.prod.ts 的内容：
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The environment.ts file has similar content but assigns `false` to the `production`
    environment variable. If you’re not using the `--prod` option with `ng serve`
    or `ng build`, the environment variables defined in environment.ts are available
    in your app code. When you’re building bundles with `--prod`, the variables defined
    in environment.prod.ts can be used:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: environment.ts 文件有类似的内容，但将 `production` 环境变量赋值为 `false`。如果你没有使用 `ng serve` 或
    `ng build` 中的 `--prod` 选项，则 environment.ts 中定义的环境变量可以在你的应用程序代码中使用。当你使用 `--prod`
    构建包时，可以在 environment.prod.ts 中使用定义的变量：
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the environment files you can define as many variables as you need and access
    them in your application using *dot notation*, as in `environment.myOtherVar`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在环境文件中，你可以定义你需要的任何变量，并使用点符号在应用程序中访问它们，例如 `environment.myOtherVar`。
- en: The entire code of your app module that uses providers with both `useFactory`
    and `useValue` is shown in the following listing.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `useFactory` 和 `useValue` 的提供者的整个应用程序模块代码如下所示。
- en: Listing 5.11\. Providers with `useFactory` and `useValue`
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.11\. 使用 `useFactory` 和 `useValue` 的提供者
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Maps the productServiceFactory factory function to the ProductService
    token**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 productServiceFactory 工厂函数映射到 ProductService 令牌**'
- en: '***2* Specifies the argument to be injected into the factory function**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 指定要注入到工厂函数中的参数**'
- en: '***3* Maps the value from the environment file to the IS_PROD_ENVIRONMENT token**'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将环境文件中的值映射到 IS_PROD_ENVIRONMENT 令牌**'
- en: 'You can find the complete code of the app that implements `useFactory` and
    `useValue` as well as the environment variable `production` in the directory called
    factory of the di-samples project. First, run this app as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 di-samples 项目的 factory 目录中找到实现 `useFactory`、`useValue` 以及环境变量 `production`
    的应用程序的完整代码。首先，按照以下方式运行此应用程序：
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the dev environment, the factory function provides the `MockProductService`,
    and the browser renders two components showing Samsungs. Now, run the same app
    in production mode:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发环境中，工厂函数提供 `MockProductService`，浏览器渲染显示三星的两个组件。现在，以生产模式运行相同的应用程序：
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This time, the value of `environment.production` is `true`, the factory provides
    the `ProductService`, and the browser renders two iPhones.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`environment.production` 的值是 `true`，工厂提供了 `ProductService`，浏览器渲染了两个 iPhone。
- en: To recap, a provider can map a token to a class, a factory function, or an arbitrary
    value to let the injector know which objects or values to inject. The class or
    factory may have its own dependencies, so the providers should specify all of
    them. [Figure 5.7](#ch05fig07) illustrates the relationships between the providers
    and the injectors of the sample app.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，提供者可以将令牌映射到类、工厂函数或任意值，以便注入器知道要注入哪些对象或值。类或工厂可能有自己的依赖项，因此提供者应指定所有这些依赖项。[图
    5.7](#ch05fig07) 展示了提供者与示例应用程序的注入器之间的关系。
- en: Figure 5.7\. Injecting dependencies with dependencies
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.7\. 使用依赖注入依赖项
- en: '![](Images/05fig07.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig07.jpg)'
- en: It’s great that you can inject a value into a string token (such as `IS_PROD_ENVIRONMENT`),
    but this may potentially create a problem. What if your app uses someone else’s
    module that coincidentally also has a token `IS_PROD_ENVIRONMENT` but injects
    a value with different meaning there? You have a naming conflict here. With JavaScript
    strings, at any given time there will be only one location in memory allocated
    for `IS_PROD_ENVIRONMENT`, and you can’t be sure what value will be injected into
    it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将值注入到一个字符串令牌（如`IS_PROD_ENVIRONMENT`）中，这很棒，但这可能潜在地造成问题。如果你的应用使用了别人的模块，而这个模块恰好也有一个名为`IS_PROD_ENVIRONMENT`的令牌，但在这里注入了不同含义的值，会发生什么？这里存在一个命名冲突。使用JavaScript字符串，在任何给定时间，内存中只有一个位置分配给`IS_PROD_ENVIRONMENT`，你无法确定会注入什么值。
- en: 5.6.1\. Using InjectionToken
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.1\. 使用InjectionToken
- en: To avoid conflicts caused by using hardcoded strings as tokens, Angular offers
    an `InjectionToken` class that’s preferable to using strings. Imagine that you
    want to create a component that can get data from different servers (such as dev,
    production, and QA) and you want to inject the string with the server’s URL into
    a token named `BackendUrl`. Instead of injecting the URL string token, you should
    create an instance of `InjectionToken`, as shown in the next listing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免使用硬编码的字符串作为令牌引起的冲突，Angular提供了一个`InjectionToken`类，它比使用字符串更可取。想象一下，你想创建一个可以从不同的服务器（如开发、生产和质量保证）获取数据的组件，并且你想将服务器的URL字符串注入到名为`BackendUrl`的令牌中。而不是注入URL字符串令牌，你应该创建一个`InjectionToken`的实例，如下一列表所示。
- en: Listing 5.12\. Using `InjectionToken` instead of a string token
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.12\. 使用`InjectionToken`而不是字符串令牌
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* Instantiates InjectionToken**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 实例化InjectionToken**'
- en: '***2* Declares a provider for injecting the value into the token**'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明一个提供者以将值注入到令牌中**'
- en: '***3* Injects [http://myQAserver.com](http://myQAserver.com) into the BACKEND_URL
    token**'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将[http://myQAserver.com](http://myQAserver.com)注入到BACKEND_URL令牌中**'
- en: Here, you wrap the string `BackendUrl` into an instance of `InjectionToken`.
    Then, in the constructor of this component, instead of injecting a vague string
    type, you inject a `BACKEND_URL` that points at the concrete instance of `InjectionToken`.
    Even if the code of another module also has `new InjectionToken('BackendUrl')`,
    it’s going to be a different object.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将字符串`BackendUrl`包装成一个`InjectionToken`的实例。然后，在这个组件的构造函数中，而不是注入一个模糊的字符串类型，你注入一个指向`InjectionToken`具体实例的`BACKEND_URL`。即使另一个模块的代码也有`new
    InjectionToken('BackendUrl')`，它也将是不同的对象。
- en: '`BACKEND_URL` isn’t a type, so you can’t specify your instance of `InjectionToken`
    as a type of the constructor’s argument. You’d get a compilation error:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`BACKEND_URL`不是一个类型，所以你不能将你的`InjectionToken`实例指定为构造函数参数的类型。你会得到一个编译错误：'
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That’s why you didn’t specify the argument type of the `AppComponent` constructor
    but used the `@Inject(BACKEND_URL)` decorator instead to let Angular know which
    object to inject.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么你没有指定`AppComponent`构造函数的参数类型，而是使用`@Inject(BACKEND_URL)`装饰器来让Angular知道要注入哪个对象。
- en: '|  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You can’t inject TypeScript interfaces, because they have no representation
    in the transpiled JavaScript code.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能注入TypeScript接口，因为它们在转译的JavaScript代码中没有表示。
- en: '|  |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You know that providers can be defined on the component and module level, and
    that module-level providers can be used in the entire app. Things get complicated
    when your app has more than one module. Will the providers declared in the `@NgModule`
    of a feature module be available in the root module as well, or will they be hidden
    inside the feature module?
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道提供者可以在组件和模块级别定义，并且模块级别的提供者可以在整个应用中使用。当你的应用有多个模块时，事情会变得复杂。在功能模块的`@NgModule`中声明的提供者是否也会在根模块中可用，或者它们会被隐藏在功能模块内部？
- en: 5.6.2\. Dependency injection in a modularized app
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.2\. 模块化应用中的依赖注入
- en: Every root app module has its own injector. If you split your app into several
    eagerly loaded feature modules, they’ll reuse the injector from the root module,
    so if you declare a provider for `ProductService` in the root module, any other
    module can use it in DI.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 每个根应用模块都有自己的注入器。如果你将你的应用拆分为几个急切加载的功能模块，它们将重用根模块的注入器，所以如果你在根模块中声明了`ProductService`的提供者，任何其他模块都可以在DI中使用它。
- en: What if a provider was declared in a feature module—is it available for the
    app injector? The answer to this question depends on how you load the feature
    module.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在功能模块中声明了一个提供者——它是否对应用注入器可用？这个问题的答案取决于你如何加载功能模块。
- en: 'If a module is loaded eagerly, its providers can be used in the entire app,
    but each lazy-loaded module has its own injector that doesn’t expose providers.
    Providers declared in the `@NgModule()` decorator of a lazy-loaded module are
    available within such a module, but not to the entire application. Let’s consider
    two different scenarios: one with a lazy-loaded module and another with an eagerly
    loaded module.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模块是急速加载的，其提供者可以在整个应用程序中使用，但每个懒加载的模块都有自己的注入器，不暴露提供者。在懒加载模块的 `@NgModule()`
    装饰器中声明的提供者仅在该模块内可用，而不是整个应用程序。让我们考虑两种不同的场景：一个带有懒加载模块，另一个带有急速加载模块。
- en: 5.7\. Providers in lazy-loaded modules
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7\. 懒加载模块中的提供者
- en: In this section, you’ll experiment with the providers declared inside a lazy-loaded
    module. You’ll start with modifying the app from section 4.3 in [chapter 4](kindle_split_013.xhtml#ch04).
    This time, you’ll add an injectable `LuxuryService` and declare its provider in
    `LuxuryModule`. The `LuxuryService` will look like the following listing.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将实验懒加载模块内声明的提供者。你将从第 4.3 节的修改后的应用程序开始，该应用程序位于 [第 4 章](kindle_split_013.xhtml#ch04)。这次，你将添加一个可注入的
    `LuxuryService` 并在 `LuxuryModule` 中声明其提供者。`LuxuryService` 将类似于以下列表。
- en: Listing 5.13\. luxury.service.ts
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.13\. luxury.service.ts
- en: '[PRE32]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* This service has one method.**'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 此服务有一个方法。**'
- en: The `LuxuryModule` declares the provider for this service, as shown in the following
    listing.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`LuxuryModule` 声明了此服务的提供者，如下面的列表所示。'
- en: Listing 5.14\. luxury.module.ts
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.14\. luxury.module.ts
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* This module has one component.**'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 此模块有一个组件。**'
- en: '***2* Declares a provider for LuxuryService**'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 声明 LuxuryService 的提供者**'
- en: '***3* Exports the module to make it visible in other modules**'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 导出模块以使其在其他模块中可见**'
- en: The `LuxuryComponent` will use the service, as shown in the following listing.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`LuxuryComponent` 将使用此服务，如下面的列表所示。'
- en: Listing 5.15\. luxury.component.tss
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.15\. luxury.component.tss
- en: '[PRE34]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* Injects the LuxuryService**'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注入 LuxuryService**'
- en: '***2* Invokes a method on the LuxuryService**'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在 LuxuryService 上调用一个方法**'
- en: Remember, the `AppModule` lazy loads the `LuxuryModule`, as you can see in the
    next listing.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`AppModule` 懒加载 `LuxuryModule`，正如你可以在下一个列表中看到的那样。
- en: Listing 5.16\. The root module
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.16\. 根模块
- en: '[PRE35]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Specifies the module in quotes for lazy loading**'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用引号指定模块以进行懒加载**'
- en: Running this app will lazy load `LuxuryModule`, and `LuxuryComponent` will get
    `LuxuryService` injected and will invoke its API.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此应用程序将懒加载 `LuxuryModule`，`LuxuryComponent` 将注入 `LuxuryService` 并调用其 API。
- en: The following listing tries to inject `LuxuryService` into `HomeComponent` from
    the root module (both modules belong to the same project).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表尝试从根模块（这两个模块属于同一项目）将 `LuxuryService` 注入到 `HomeComponent` 中。
- en: Listing 5.17\. home.component.ts
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.17\. home.component.ts
- en: '[PRE36]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Injects LuxuryService into a component of another module**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 LuxuryService 注入到另一个模块的组件中**'
- en: You won’t get any compiler errors, but if you run this modified app, you’ll
    get the runtime error “No provider for LuxuryService!” The root module doesn’t
    have access to the providers declared in the lazy-loaded module, which has its
    own injector.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会得到任何编译器错误，但如果运行修改后的应用程序，你会得到运行时错误“没有 LuxuryService 提供者！”根模块无法访问懒加载模块中声明的提供者，该模块有自己的注入器。
- en: 5.8\. Providers in eagerly loaded modules
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8\. 在急速加载的模块中的提供者
- en: Let’s add a `ShippingModule` to the project described in the previous section,
    but this one will be loaded eagerly. Similar to `LuxuryModule`, `ShippingModule`
    will have one component and one injectable service called `ShippingService`. You
    want to see whether the root module can also use the `ShippingService` whose provider
    is declared in the eagerly loaded `ShippingModule`, shown in the following listing.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在上一节中描述的项目中添加一个 `ShippingModule`，但这个模块将被急速加载。类似于 `LuxuryModule`，`ShippingModule`
    将有一个组件和一个名为 `ShippingService` 的可注入服务。你想看看根模块是否也可以使用在急速加载的 `ShippingModule` 中声明的
    `ShippingService` 提供者，如下面的列表所示。
- en: Listing 5.18\. shipping.module.ts
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.18\. shipping.module.ts
- en: '[PRE37]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* Adds a route for a feature module**'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为功能模块添加路由**'
- en: '|  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'In [section 2.5.1](kindle_split_011.xhtml#ch02lev2sec1) in [chapter 2](kindle_split_011.xhtml#ch02),
    `ShippingModule` also included `exports: [ShippingComponent]` in the `@NgModule()`
    decorator. You had to export the `ShippingComponent` there because it was used
    in the `AppComponent` template located in `AppModule`. In this example, you use
    `ShippingComponent` only inside `ShippingModule`, so no export is needed.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '在 [第 2.5.1 节](kindle_split_011.xhtml#ch02lev2sec1) 中 [第 2 章](kindle_split_011.xhtml#ch02)，`ShippingModule`
    还在 `@NgModule()` 装饰器中包含了 `exports: [ShippingComponent]`。你必须在那里导出 `ShippingComponent`，因为它被用于位于
    `AppModule` 中的 `AppComponent` 模板。在这个例子中，你只在 `ShippingModule` 内部使用 `ShippingComponent`，因此不需要导出。'
- en: '|  |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '`ShippingComponent` gets `ShippingService` injected and will invoke its `getShippingItem()`
    method that returns a hardcoded text, “I’m the shipping service from the shipping
    module.”'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShippingComponent` 接收 `ShippingService` 注入，并将调用其 `getShippingItem()` 方法，该方法返回硬编码的文本，“我是来自运输模块的运输服务。”'
- en: Listing 5.19\. shipping.component.ts
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.19\. shipping.component.ts
- en: '[PRE38]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* Injects ShippingService**'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注入 ShippingService**'
- en: '***2* Uses ShippingService**'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 ShippingService**'
- en: '[Figure 5.8](#ch05fig08) shows the structure of the project and the content
    of the root `AppModule.` In line 17, you eagerly load `ShippingModule`, and in
    line 18, you lazy load `LuxuryModule`.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.8](#ch05fig08) 展示了项目的结构和根 `AppModule` 的内容。在第 17 行，你预加载了 `ShippingModule`，在第
    18 行，你懒加载了 `LuxuryModule`。'
- en: '|  |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'By the time you read this, the function in lines 9–11 may not be needed, and
    line 17 for eager loading the `ShippingModule` could look like this: `{path: ''shipping'',
    loadChildren: () => ShippingModule}`. But at the time of writing, using a function
    in line 17 results in errors during the AOT compilation.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '到你阅读这段内容的时候，第 9-11 行的函数可能不再需要，第 17 行的 `ShippingModule` 预加载可能看起来像这样：`{path:
    ''shipping'', loadChildren: () => ShippingModule}`。但在写作的时候，第 17 行使用函数会导致 AOT 编译时出错。'
- en: '|  |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 5.8\. An app module that uses feature modules
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.8\. 使用功能模块的应用模块
- en: '![](Images/05fig08_alt.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig08_alt.jpg)'
- en: 'To see this app in action, run the following command:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用程序的实际运行情况，请运行以下命令：
- en: '[PRE39]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Clicking the Shipping Details link shows the data returned by the `ShippingService`,
    as shown in [figure 5.9](#ch05fig09). `ShippingService` was injected into `ShippingComponent`
    even though you didn’t declare the provider for `ShippingService` in the root
    app module.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 点击运输详情链接会显示 `ShippingService` 返回的数据，如图 5.9 所示。即使你没有在根应用模块中声明 `ShippingService`
    的提供者，`ShippingService` 仍然被注入到 `ShippingComponent` 中。
- en: Figure 5.9\. Navigating to the shipping module
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.9\. 导航到运输模块
- en: '![](Images/05fig09_alt.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig09_alt.jpg)'
- en: This proves the fact that providers of eagerly loaded modules are merged with
    providers of the root module. In other words, Angular has a single injector for
    all eagerly loaded modules.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了这样一个事实：预加载模块的提供者与根模块的提供者合并。换句话说，Angular 为所有预加载模块有一个单一的注入器。
- en: '5.9\. Hands-on: Using Angular Material components in ngAuction'
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.9\. 实践：在 ngAuction 中使用 Angular Material 组件
- en: '|  |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Source code for this chapter can be found at [https://github.com/Farata/angulartypescript](https://github.com/Farata/angulartypescript)
    and [www.manning.com/books/angular-development-with-typescript-second-edition](http://www.manning.com/books/angular-development-with-typescript-second-edition).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在 [https://github.com/Farata/angulartypescript](https://github.com/Farata/angulartypescript)
    和 [www.manning.com/books/angular-development-with-typescript-second-edition](http://www.manning.com/books/angular-development-with-typescript-second-edition)
    找到。
- en: '|  |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In the hands-on section of [chapter 3](kindle_split_012.xhtml#ch03), you used
    DI in ngAuction. You added the `ProductService` provider in `@NgModule()`, and
    this service was injected into `HomeComponent` and `ProductDetailComponent`. In
    the final version of `ngAuction`, you’ll also inject `ProductService` into `SearchComponent`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](kindle_split_012.xhtml#ch03) 的实践部分，你在 ngAuction 中使用了依赖注入。你将 `ProductService`
    提供者添加到 `@NgModule()` 中，并且这个服务被注入到 `HomeComponent` 和 `ProductDetailComponent` 中。在
    `ngAuction` 的最终版本中，你也将 `ProductService` 注入到 `SearchComponent` 中。
- en: In this section, we won’t be focusing on DI but rather introducing you to the
    Angular Material library of modern-looking UI components. The goal is to replace
    the HTML elements on the landing page of ngAuction with Angular Material (AM)
    UI components. You’ll still keep the Bootstrap library in this version of ngAuction,
    but starting in [chapter 7](kindle_split_016.xhtml#ch07), you’ll do a complete
    rewrite of ngAuction so it’ll use only AM components.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不会专注于DI，而是向您介绍现代外观的UI组件Angular Material库。目标是替换ngAuction登录页面上的HTML元素，使用Angular
    Material (AM) UI组件。你仍然会在ngAuction的这个版本中保留Bootstrap库，但从第7章（[kindle_split_016.xhtml#ch07](kindle_split_016.xhtml#ch07)）开始，你将完全重写ngAuction，使其仅使用AM组件。
- en: You’ll use ngAuction from [chapter 3](kindle_split_012.xhtml#ch03) as a starting
    point, gradually replacing HTML elements with their AM counterparts, so the landing
    page will look as shown in [figure 5.10](#ch05fig10).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你将从第3章（[kindle_split_012.xhtml#ch03](kindle_split_012.xhtml#ch03)）中的ngAuction作为起点，逐步用AM对应元素替换HTML元素，这样登录页面看起来就像图5.10（[#ch05fig10](#ch05fig10)）中所示。
- en: Figure 5.10\. ngAuction with Angular Material components
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.10\. 带有Angular Material组件的ngAuction
- en: '![](Images/05fig10_alt.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/05fig10_alt.jpg)'
- en: 5.9.1\. A brief overview of the Angular Material library
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.9.1\. Angular Material库简要概述
- en: Angular Material is a library of UI components developed by Google, based on
    the Material Design guidelines that define the classic principles of good design
    and consistent user experience (see [https://material.io/guidelines](https://material.io/guidelines)).
    The guidelines provide suggestions for how the UI for a web or mobile app should
    be designed.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Angular Material是由Google开发的一个UI组件库，基于定义良好设计原则和一致用户体验的Material Design指南（参见[https://material.io/guidelines](https://material.io/guidelines)）。这些指南提供了关于如何设计Web或移动应用UI的建议。
- en: AM offers more than 30 UI components and four prebuilt themes. A *theme* is
    a collection of palettes, each of which defines different shades of colors that
    look good when used together (see [https://material.io/guidelines/style/color.html](https://material.io/guidelines/style/color.html)),
    as seen in [figure 5.11](#ch05fig11).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: AM提供了超过30个UI组件和四个预构建主题。*主题*是一组调色板，每个调色板定义了颜色的一系列阴影，当一起使用时看起来很好（参见[https://material.io/guidelines/style/color.html](https://material.io/guidelines/style/color.html)），如图5.11（[#ch05fig11](#ch05fig11)）所示。
- en: Figure 5.11\. Sample Material Design palettes
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.11\. 样例材料设计调色板
- en: '![](Images/05fig11_alt.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/05fig11_alt.jpg)'
- en: 'The color with the number 500 is a *primary* color for the palette. We’ll show
    you how to customize palettes in the hands-on section of [chapter 7](kindle_split_016.xhtml#ch07).
    At the time of writing, AM comes with four prebuilt themes: `deeppurple-amber`,
    `indigo-pink`, `pink-bluegrey`, and `purple-green`. One way to add a theme to
    your app is by using the `<link>` tag in your index.html:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 数字500的颜色是调板的主色。我们将在第7章（[kindle_split_016.xhtml#ch07](kindle_split_016.xhtml#ch07)）的动手实践部分向你展示如何自定义调色板。在撰写本文时，AM提供了四个预构建主题：`deeppurple-amber`、`indigo-pink`、`pink-bluegrey`和`purple-green`。向你的应用添加主题的一种方法是在index.html中使用`<link>`标签：
- en: '[PRE40]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Alternatively, you can add a theme to your global CSS file (styles.css) as
    follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以按照以下方式将主题添加到全局CSS文件（styles.css）中：
- en: '[PRE41]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Any app built with AM can specify the following colors for the UI components:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用AM构建的应用都可以为UI组件指定以下颜色：
- en: '**`primary`—** Main colors'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`primary`—** 主要颜色'
- en: '**`accent`—** Secondary colors'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`accent`—** 次要颜色'
- en: '**`warn`—** For errors and warnings'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`warn`—** 用于错误和警告'
- en: '**`foreground`—** For text and icons'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`foreground`—** 用于文本和图标'
- en: '**`background`—** For component backgrounds'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`background`—** 用于组件背景'
- en: While styling the UI of your app, for the most part you won’t be specifying
    the color names or codes as it’s done in regular CSS. You’ll be using one of the
    preceding keywords.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在为你的应用UI进行样式设计时，大部分情况下你不会指定颜色名称或代码，就像在常规CSS中做的那样。你将使用前面提到的关键字之一。
- en: '|  |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: In the hands-on section of [chapter 7](kindle_split_016.xhtml#ch07), you’ll
    start using the CSS extension SaaS for styling.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章（[kindle_split_016.xhtml#ch07](kindle_split_016.xhtml#ch07)）的动手实践部分，你将开始使用CSS扩展SaaS进行样式设计。
- en: '|  |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The following line shows how to add the AM toolbar component styled with the
    primary color for whatever theme is specified:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了如何添加带有指定主题主色的AM工具栏组件：
- en: '[PRE42]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Should you decide to switch to a different theme, there’s no need to change
    the preceding code—the `<mat-toolbar>` will use the primary color of the newly
    selected theme.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定切换到不同的主题，不需要更改前面的代码——`<mat-toolbar>`将使用新选择主题的主要颜色。
- en: AM components include input fields, radio buttons, checkboxes, buttons, date
    picker, toolbar, grid list, data table, and more. For the current list of components,
    refer to product documentation at [https://material.angular.io](https://material.angular.io).
    Some of the components are added to your component templates as tags, and some
    as directives. In any case, the AM component names begin with the prefix `mat-`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: AM 组件包括输入字段、单选按钮、复选框、按钮、日期选择器、工具栏、网格列表、数据表等。有关组件的当前列表，请参阅产品文档[https://material.angular.io](https://material.angular.io)。一些组件作为标签添加到组件模板中，一些作为指令。无论如何，AM
    组件的名称都以前缀 `mat-` 开头。
- en: The following listing shows how create a toolbar that contains a link and a
    button with an icon.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了如何创建一个包含链接和带图标的按钮的工具栏。
- en: Listing 5.20\. Creating a toolbar with Angular Material
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.20\. 使用 Angular Material 创建工具栏
- en: '[PRE43]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* AM toolbar of primary theme color**'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* AM 主题颜色为主色调的工具栏**'
- en: '***2* A button with an icon**'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 带有图标的按钮**'
- en: '***3* Places the Google Material icon more_vert on the button**'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将 Google Material 图标 more_vert 放置在按钮上**'
- en: Here, you use two AM tags, `<mat-toolbar>` and `<mat-icon>`, and one directive,
    `mat-icon-button`. Each AM component is packaged in a feature module, and you’ll
    need to import the modules for the required AM components in the `@NgModule()`
    decorator of your `AppModule`. You’ll see how to do this while giving a face lift
    to your ngAuction.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用了两个 AM 标签 `<mat-toolbar>` 和 `<mat-icon>`，以及一个指令 `mat-icon-button`。每个
    AM 组件都打包在一个功能模块中，你需要在 `AppModule` 的 `@NgModule()` 装饰器中导入所需的 AM 组件的模块。你将在对 ngAuction
    进行改观的同时看到如何这样做。
- en: '|  |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to build the new version of ngAuction on your computer, copy the
    directory chapter3/ngAuction into another location, run `npm install` there, and
    follow the instructions in the next sections.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在你的电脑上构建 ngAuction 的新版本，请将 chapter3/ngAuction 目录复制到另一个位置，在那里运行 `npm install`，并遵循下一节中的说明。
- en: '|  |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.9.2\. Adding the AM library to the project
  id: totrans-350
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.9.2\. 将 AM 库添加到项目中
- en: 'First, you need to install three modules required by the AM library by running
    the following commands in the project root directory:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要通过在项目根目录中运行以下命令来安装 AM 库所需的三个模块：
- en: '[PRE44]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In this version of ngAuction, you’ll use the prebuilt `indigo-pink` theme,
    so replace the content of the styles.css file with this line:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的 ngAuction 中，你将使用预构建的 `indigo-pink` 主题，所以用以下行替换 styles.css 文件的内容：
- en: '[PRE45]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|  |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Starting from Angular CLI 6, you can add the AM library to your project with
    one command: `ng add @angular/material`. This command will install the required
    packages and modify the code in several files of your app, so you have less typing
    to do. We didn’t use this command here because we want to keep all AM components
    used in this app in a separate feature module.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Angular CLI 6 开始，你可以使用一个命令将 AM 库添加到你的项目中：`ng add @angular/material`。此命令将安装所需的包并修改应用程序中几个文件的代码，因此你需要做的输入更少。我们没有使用此命令，因为我们想将在这个应用程序中使用的所有
    AM 组件保留在一个单独的功能模块中。
- en: '|  |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.9.3\. Adding a feature module with AM components
  id: totrans-359
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.9.3\. 添加带有 AM 组件的功能模块
- en: AM components are packaged as feature modules, and you should add only those
    modules that your app needs rather than adding the entire content of the AM library.
    You can either add the required modules to the root app module or create a separate
    module and list all required components there.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: AM 组件被打包为功能模块，你应该只添加你的应用程序需要的模块，而不是添加整个 AM 库的内容。你可以将所需的模块添加到根应用程序模块中，或者创建一个单独的模块并在其中列出所有所需的组件。
- en: 'In this version of ngAuction, you’ll keep the UI components for ngAuction in
    a separate module. Generate a new `AuctionMaterialModule` by running the following
    command:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的 ngAuction 中，你将保留 ngAuction 的 UI 组件在一个单独的模块中。通过运行以下命令生成一个新的 `AuctionMaterialModule`：
- en: '[PRE46]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This command will generate boilerplate of a feature module in the app/auction-material/auction-material.module.ts
    file. Modify the code of this file to look like the following listing.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在 app/auction-material/auction-material.module.ts 文件中生成功能模块的样板代码。修改此文件的代码，使其看起来像以下列表。
- en: Listing 5.21\. A feature module for AM UI components
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.21\. AM UI 组件的功能模块
- en: '[PRE47]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Imports only those AM modules that ngAuction needs**'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 只导入 ngAuction 需要的 AM 模块**'
- en: '***2* This module declares providers for animation services.**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 此模块声明了动画服务的提供者。**'
- en: '***3* This is a feature module, so import the CommonModule.**'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 这是一个功能模块，因此需要导入 CommonModule。**'
- en: '***4* Reexports the AM modules so they can be used in other modules of ngAuction**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 重新导出 AM 模块，以便它们可以在 ngAuction 的其他模块中使用**'
- en: Now, open app.module.ts (the root module of ngAuction) and add your `AuctionMaterialModule`
    feature module to the `imports` property of `@NgModule()`, as you see in the following
    listing.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开 app.module.ts（ngAuction 的根模块）并将您的 `AuctionMaterialModule` 功能模块添加到 `@NgModule()`
    的 `imports` 属性中，如以下列表所示。
- en: Listing 5.22\. Adding the AM feature module
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.22\. 添加 AM 功能模块
- en: '[PRE48]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* Adds the AM feature module to the root one**'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 AM 功能模块添加到根模块**'
- en: 'Now’s a good time to build and run ngAuction:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是构建和运行 ngAuction 的好时机：
- en: '[PRE49]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You won’t see any changes in the ngAuction UI just yet, but keep the dev server
    running so the appearance of the landing page will gradually change as you add
    more code in the next sections.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在还看不到 ngAuction UI 中的任何变化，但请保持开发服务器运行，以便在下一节添加更多代码时，登录页面的外观将逐渐改变。
- en: 5.9.4\. Modifying the appearance of NavbarComponent
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.9.4\. 修改 NavbarComponent 的外观
- en: 'The navbar component is a black bar with a menu. You’ll start by replacing
    the existing content of navbar.component.html to use `<mat-toolbar>`, which will
    eventually contain the menu of the auction. Remove the current content of this
    file and add an empty toolbar there:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 导航栏组件是一个带有菜单的黑色栏。您将首先替换 navbar.component.html 中的现有内容，以使用 `<mat-toolbar>`，它最终将包含拍卖的菜单。删除此文件中的当前内容，并在那里添加一个空工具栏：
- en: '[PRE50]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: While making changes, keep an eye on the UI of your running ngAuction—it has
    an empty blue toolbar now. You want the toolbar to contain the link to the home
    page and a pop-up menu that will be activated by a button click. The button should
    contain an icon with three vertical dots (see [figure 5.14](#ch05fig14)), and
    the directive `mat-icon-button` turns a regular button into a button that can
    contain `<mat-icon>`. For the image, you’ll use `more_vert`, which is the name
    of one of the Google material icons available for free at [https://material.io/icons](https://material.io/icons).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行更改时，请注意您正在运行的 ngAuction 的用户界面——现在它有一个空的蓝色工具栏。您希望工具栏包含指向主页的链接和一个通过按钮点击激活的弹出菜单。按钮应包含一个有三个垂直点的图标（见[图5.14](#ch05fig14)），并且指令
    `mat-icon-button` 将普通按钮转换为可以包含 `<mat-icon>` 的按钮。对于图像，您将使用 `more_vert`，这是在 [https://material.io/icons](https://material.io/icons)
    免费提供的 Google 物料图标之一。
- en: Add the link and the button by modifying the content of navbar.component.html
    to match the following listing.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改 navbar.component.html 的内容来添加链接和按钮，使其与以下列表匹配。
- en: Listing 5.23\. Adding a link and an icon button to the toolbar
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.23\. 向工具栏添加链接和图标按钮
- en: '[PRE51]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* Adds a link to navigate to a default route**'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加一个链接以导航到默认路由**'
- en: '***2* Adds a button that looks like three vertical dots**'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 添加一个看起来像三个垂直点的按钮**'
- en: Now the toolbar will look like [figure 5.12](#ch05fig12).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，工具栏将看起来像[图5.12](#ch05fig12)。
- en: Figure 5.12\. A toolbar with a broken icon
  id: totrans-387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.12\. 一个带有损坏图标的工具栏
- en: '![](Images/05fig12_alt.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig12_alt.jpg)'
- en: 'You specified the name of the icon `more_vert`, but didn’t add Google material
    icons to index.html. Add the following to the `<head>` section of index.html:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 您指定了图标名称 `more_vert`，但未将 Google 物料图标添加到 index.html 中。将以下内容添加到 index.html 的 `<head>`
    部分：
- en: '[PRE52]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now the `more_vert` icon is properly shown on the button, as shown in [figure
    5.13](#ch05fig13).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`more_vert` 图标已正确显示在按钮上，如图[图5.13](#ch05fig13)所示。
- en: Figure 5.13\. A toolbar with a fixed icon
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.13\. 一个带有固定图标的工具栏
- en: '![](Images/05fig13_alt.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig13_alt.jpg)'
- en: 'The next step is to push this button to the right side of the toolbar, regardless
    of screen width. You’ll add a `<div>` between the link and the button to fill
    the space. Add the following style to navbar.component.css:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将此按钮推到工具栏的右侧，无论屏幕宽度如何。您将在链接和按钮之间添加一个 `<div>` 来填充空间。将以下样式添加到 navbar.component.css：
- en: '[PRE53]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: By default, the toolbar has the CSS flexbox layout (see [https://css-tricks.com/snippets/css/a-guide-to-flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox)).
    The style `flex:1` translates to “Give the entire width to the HTML element.”
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，工具栏具有 CSS 弹性盒布局（见[https://css-tricks.com/snippets/css/a-guide-to-flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox)）。样式
    `flex:1` 表示“将整个宽度分配给 HTML 元素。”
- en: 'Place the `<div>` between the `<a>` and `<button>` tags in navbar.component.html:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在 navbar.component.html 中，在 `<a>` 和 `<button>` 标签之间放置 `<div>`：
- en: '[PRE54]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now the button is pushed all the way to the right, as shown in [figure 5.14](#ch05fig14).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按钮已经推到最右边，如图[图5.14](#ch05fig14)所示。
- en: Figure 5.14\. Pushing the button to the right
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.14\. 将按钮推到右边
- en: '![](Images/05fig14_alt.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig14_alt.jpg)'
- en: 'At this point, clicking the button doesn’t open a menu for two reasons:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，点击按钮不打开菜单有两个原因：
- en: You haven’t created a menu yet.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还没有创建菜单。
- en: You haven’t linked the menu to the button.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还没有将菜单链接到按钮。
- en: 'The ngAuction app from [chapter 3](kindle_split_012.xhtml#ch03) had three links:
    About, Services, and Contacts. Let’s turn them into a pop-up menu. Each menu item
    will have an icon (`<mat-icon>`) and text. In Angular Material, a menu is represented
    by `<mat-menu>`, which can contain one or more items, such as `<button mat-menu-item>`
    components.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 来自第 3 章 [chapter 3](kindle_split_012.xhtml#ch03) 的 ngAuction 应用程序有三个链接：关于、服务和联系。让我们将它们转换成一个弹出菜单。每个菜单项都将有一个图标（`<mat-icon>`）和文本。在
    Angular Material 中，菜单由 `<mat-menu>` 表示，它可以包含一个或多个项目，例如 `<button mat-menu-item>`
    组件。
- en: Add the code in the following listing right after the `</mat-toolbar>` tag in
    navbar.component.html.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下列表中的代码添加到 navbar.component.html 中的 `</mat-toolbar>` 标签之后。
- en: Listing 5.24\. Declaring items for a pop-up menu
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.24\. 声明弹出菜单的项目
- en: '[PRE55]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Uses the AM menu control**'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 AM 菜单控件**'
- en: '***2* First menu item**'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 第一菜单项**'
- en: '***3* Second menu item**'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 第二菜单项**'
- en: '***4* Third menu item**'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 第三菜单项**'
- en: 'Each `<mat-icon>` uses one of the Google Material icons (`info`, `settings`,
    and `contacts`). Note that you declare a local template variable, `#menu,` to
    reference this menu and assigned it to the AM `matMenu` directive. In itself,
    `<mat-menu>` doesn’t render anything until it’s attached to a component with the
    `matMenuTriggerFor` directive. To attach this menu to your toolbar button, bind
    the `menu` template variable to the `matMenuTriggerFor` directive. Update the
    button to look as follows:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `<mat-icon>` 使用 Google Material 图标中的一个（`info`、`settings` 和 `contacts`）。请注意，你声明了一个局部模板变量
    `#menu,` 来引用此菜单，并将其分配给 AM `matMenu` 指令。本身，`<mat-menu>` 不会渲染任何内容，直到它通过 `matMenuTriggerFor`
    指令附加到一个组件上。要将此菜单附加到你的工具栏按钮，将 `menu` 模板变量绑定到 `matMenuTriggerFor` 指令。更新按钮如下所示：
- en: '[PRE56]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '|  |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can replace `<button>` tags with `<a [routerLink]>` links.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用 `<a [routerLink]>` 链接替换 `<button>` 标签。
- en: '|  |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you click the toolbar button now, it’ll show the menu, as shown in [figure
    5.15](#ch05fig15).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在点击工具栏按钮，它将显示菜单，如图 5.15 [figure 5.15](#ch05fig15) 所示。
- en: Figure 5.15\. The toolbar menu
  id: totrans-420
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.15\. 工具栏菜单
- en: '![](Images/05fig15.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig15.jpg)'
- en: 5.9.5\. Modifying the SearchComponent UI
  id: totrans-422
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.9.5\. 修改 SearchComponent UI
- en: 'The `SearchComponent` template will contain a form with three controls: a text
    input, a number input, and a select dropdown, which will be implemented with the
    `matInput` directives (they should be placed inside `<mat-form-field>`) and `<mat-select>`.
    To make the Search button stand out, you’ll also add a `mat-raised-button` directive
    and the search icon to this button.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`SearchComponent` 模板将包含一个包含三个控件（一个文本输入、一个数字输入和一个选择下拉菜单）的表单，这些控件将使用 `matInput`
    指令（它们应放置在 `<mat-form-field>` 内部）和 `<mat-select>` 实现。为了使搜索按钮突出，你还将添加一个 `mat-raised-button`
    指令和搜索图标到这个按钮。'
- en: Modify the code in the search.component.html file to look like the following
    listing.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 search.component.html 文件中的代码，使其看起来如下所示。
- en: Listing 5.25\. search.component.html
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.25\. search.component.html
- en: '[PRE57]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '***1* Uses the template-driven Forms API**'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用模板驱动的表单 API**'
- en: '***2* First form field**'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 第一表单字段**'
- en: '***3* Second form field**'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 第二表单字段**'
- en: '***4* Third form field**'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 第三表单字段**'
- en: '***5* The form’s Submit button**'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 表单的提交按钮**'
- en: The `ngForm` and `ngModel` directives are parts of template-driven forms defined
    in the `FormModule` (described in [section 10.2.1](kindle_split_019.xhtml#ch10lev2sec1)
    of [chapter 10](kindle_split_019.xhtml#ch10)), and you need to add it to the `@NgModule()`
    decorator in `AppModule`, as shown in the following listing.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngForm` 和 `ngModel` 指令是定义在 `FormModule`（在第 10 章 [chapter 10](kindle_split_019.xhtml#ch10)
    的 10.2.1 节 [section 10.2.1](kindle_split_019.xhtml#ch10lev2sec1) 中描述）中的模板驱动表单的一部分，并且你需要将其添加到
    `AppModule` 中的 `@NgModule()` 装饰器中，如下面的列表所示。'
- en: Listing 5.26\. Adding support for the Forms API
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.26\. 添加对 Forms API 的支持
- en: '[PRE58]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* Adds support for the template-driven Forms API**'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加对模板驱动表单 API 的支持**'
- en: Let’s make sure the UI is properly rendered. For now, on smaller screens, it
    looks like [figure 5.16](#ch05fig16).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保 UI 正确渲染。目前，在小屏幕上，它看起来像 [figure 5.16](#ch05fig16)。
- en: Figure 5.16\. The search form with a misaligned button
  id: totrans-437
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.16\. 搜索表单中的按钮未对齐
- en: '![](Images/05fig16.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig16.jpg)'
- en: The `mat-form-field` components and the `mat-select` dropdown should occupy
    the entire width of the search component. You also want to add more space between
    the form controls.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`mat-form-field` 组件和 `mat-select` 下拉菜单应占据搜索组件的整个宽度。你还需要在表单控件之间添加更多空间。'
- en: Add the styles in the following listing to the search.component.css file.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下列表中的样式添加到 search.component.css 文件中。
- en: Listing 5.27\. A fragment of search.component.css
  id: totrans-441
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.27\. search.component.css 的片段
- en: '[PRE59]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`display: block;` tells the browser to render the search component as a standard
    `<div>`. Now the search form is well aligned, as shown in [figure 5.17](#ch05fig17).'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`display: block;` 告诉浏览器将搜索组件渲染为标准的 `<div>`。现在搜索表单已经很好地对齐，如[图 5.17](#ch05fig17)
    所示。'
- en: Figure 5.17\. The search form
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.17\. 搜索表单
- en: '![](Images/05fig17.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig17.jpg)'
- en: The Search button won’t perform search in this version of ngAuction, and the
    search form won’t do input validation either. You’ll fix this in [section 11.8](kindle_split_020.xhtml#ch11lev1sec8)
    in [chapter 11](kindle_split_020.xhtml#ch11) after we discuss the Angular Forms
    API.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的 ngAuction 中，搜索按钮不会执行搜索，搜索表单也不会进行输入验证。你将在[第 11 章的第 11.8 节](kindle_split_020.xhtml#ch11lev1sec8)中修复这个问题，在我们讨论
    Angular 表单 API 之后。
- en: 5.9.6\. Replacing the carousel with an image
  id: totrans-447
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.9.6\. 用图片替换轮播组件
- en: At the time of writing, Angular Material doesn’t have a carousel component.
    In a real-world project, you’d find the carousel component in one of the third-party
    libraries, such as the PrimeNG library ([www.primefaces.org/primeng/#/carousel](http://www.primefaces.org/primeng/#/carousel)),
    but in this version of ngAuction, you’ll replace the carousel with a static image.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Angular Material 还没有轮播组件。在实际项目中，你会在第三方库中找到轮播组件，例如 PrimeNG 库（[www.primefaces.org/primeng/#/carousel](http://www.primefaces.org/primeng/#/carousel)），但在
    ngAuction 的这个版本中，你将用静态图片替换轮播组件。
- en: 'Replace the content of carousel.component.html with the following code:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换 carousel.component.html 的内容：
- en: '[PRE60]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now the browser shows a gray rectangle in place of the carousel. You could have
    kept the Bootstrap carousel in place, but it’s not worth loading the entire Bootstrap
    library just for the carousel. The goal is to gradually switch to AM components.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，浏览器在轮播组件的位置显示一个灰色矩形。你本可以保留 Bootstrap 轮播组件，但仅仅为了轮播组件而加载整个 Bootstrap 库并不值得。目标是逐步切换到
    AM 组件。
- en: 5.9.7\. More fixes with spacing
  id: totrans-452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.9.7\. 使用间距进行更多修复
- en: 'Let’s put some space between the toolbar and other components by adding the
    following style to app.component.css:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向 app.component.css 添加以下样式，让我们在工具栏和其他组件之间添加一些空间：
- en: '[PRE61]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, add some space between the carousel and product items. Modify the home.component.css
    file to look like the following code (`display:block` is for rendering this custom
    component as a `<div>`):'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在轮播组件和产品项之间添加一些空间。修改 home.component.css 文件，使其看起来像以下代码（`display:block` 用于将此自定义组件渲染为
    `<div>`）：
- en: '[PRE62]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 5.9.8\. Using mat-card in ProductItemComponent
  id: totrans-457
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.9.8\. 在 ProductItemComponent 中使用 mat-card
- en: The next step is to display your products as tiles, and each `<nga-product-item>`
    will use the `<mat-card>` component. To render each product inside the card, modify
    the content of the product-item.component.htmlfile to look like the following
    listing.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将你的产品以瓷砖的形式显示，每个 `<nga-product-item>` 将使用 `<mat-card>` 组件。为了在卡片内渲染每个产品，修改
    product-item.component.html 文件的内容，使其看起来像以下列表。
- en: Listing 5.28\. product-item.component.html
  id: totrans-459
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.28\. product-item.component.html
- en: '[PRE63]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '***1* Defines the content of the AM <mat-card> component**'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义了 AM <mat-card> 组件的内容**'
- en: '***2* The product title goes on top.**'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 产品标题位于顶部。**'
- en: '***3* Product image**'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 产品图片**'
- en: '***4* Product description**'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 产品描述**'
- en: '***5* A link to navigate to product details**'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 一个链接用于导航到产品详情**'
- en: 5.9.9\. Adding styles to HomeComponent
  id: totrans-466
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.9.9\. 为 HomeComponent 添加样式
- en: Your `HomeComponent` hosts several instances of `ProductItemComponent`. Now
    let’s add more styles to home.component.css so the products are displayed nicely
    and aligned using the CSS style `flex`. Add the following listing’s styles to
    home.component.css.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `HomeComponent` 包含几个 `ProductItemComponent` 的实例。现在让我们向 home.component.css
    添加更多样式，以便以 CSS 风格 `flex` 显示并对齐产品。将以下列表的样式添加到 home.component.css 中。
- en: Listing 5.29\. home.component.css
  id: totrans-468
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.29\. home.component.css
- en: '[PRE64]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1* Uses CSS flexbox**'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 CSS flexbox**'
- en: '***2* Gives one third of the screen width plus a margin to each component**'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 每个组件分配屏幕宽度的三分之一加上边距**'
- en: Now the landing page of ngAuction has a more modern look, as shown earlier in
    [figure 5.10](#ch05fig10). Not only does it look better than the version of ngAuction
    from [chapter 3](kindle_split_012.xhtml#ch03), but its controls (the search form,
    the menu) provide fast and animated response to the user’s actions. Try to place
    the focus in one of the search fields, and you’ll see how the field prompt moves
    to the top. The button search also shows a ripple effect.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 现在ngAuction的着陆页看起来更现代，如之前在[图5.10](#ch05fig10)中所示。它不仅比[第3章](kindle_split_012.xhtml#ch03)中的ngAuction版本看起来更好，而且它的控件（搜索表单、菜单）对用户的操作提供了快速和动画响应。尝试将焦点放在搜索字段之一，你会看到字段提示如何移动到顶部。搜索按钮也显示了涟漪效果。
- en: You didn’t change the look of the product-detail page shown in [figure 3.16](kindle_split_012.xhtml#ch03fig16)
    in [chapter 3](kindle_split_012.xhtml#ch03). See if you can do that on your own.
    When all standard UI elements are replaced with AM components, you can remove
    the dependency on the Bootstrap library from both package.json and .angular-cli.json
    (or from angular.json, if you use Angular 6).
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 你没有改变[第3章](kindle_split_012.xhtml#ch03)中展示的[图3.16](kindle_split_012.xhtml#ch03fig16)的产品详情页的外观。看看你是否能自己做到这一点。当所有标准UI元素都被AM组件替换后，你可以从package.json和.angular-cli.json（或者如果你使用Angular
    6，从angular.json）中移除对Bootstrap库的依赖。
- en: Summary
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Providers register objects for future injection.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者注册对象以供将来注入。
- en: You can declare a provider that uses not only a class, but a function or a primitive
    value as well.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以声明一个提供者，它不仅可以使用一个类，还可以使用一个函数或原始值。
- en: Injectors form a hierarchy, and if Angular can’t find the provider for the requested
    type at the component level, it’ll try to find it by traversing parent injectors.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注射器形成了一个层次结构，如果Angular在组件级别找不到请求类型的提供者，它将尝试通过遍历父级注射器来找到它。
- en: A lazy-loaded module has its own injector, and providers declared inside lazy-loaded
    modules aren’t available in the root module.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒加载的模块有自己的注射器，并且声明在懒加载模块内部的提供者对根模块不可用。
- en: Angular Material offers a set of modern-looking UI components.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular Material提供了一套看起来现代的UI组件。
