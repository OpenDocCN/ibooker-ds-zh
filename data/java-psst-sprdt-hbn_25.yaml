- en: 19 Querying JPA with Querydsl
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19 使用 Querydsl 查询 JPA
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Introducing Querydsl
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Querydsl
- en: Creating a Querydsl application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Querydsl 应用程序
- en: Querying a database with Querydsl
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Querydsl 查询数据库
- en: Querying a database is essential to retrieve information that meets certain
    criteria. This chapter focuses on Querydsl, one of the alternatives for querying
    a database from Java programs. The “dsl” part of the Querydsl name refers to domain
    specific languages (DSLs), which are languages dedicated to particular application
    domains. For example, querying a database is such a domain.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 查询数据库对于检索符合特定标准的信息至关重要。本章重点介绍 Querydsl，这是从 Java 程序中查询数据库的替代方案之一。Querydsl 名称中的“dsl”部分指的是领域特定语言（DSLs），这些语言是针对特定应用领域的语言。例如，查询数据库就是这样一种领域。
- en: 'In this chapter we’ll examine the most important capabilities of Querydsl,
    and we’ll apply them in a Java persistence project. For comprehensive documentation
    of Querydsl, see its website: [http://querydsl.com/](http://querydsl.com/).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将检查 Querydsl 的最重要的功能，并将它们应用于一个 Java 持久化项目中。有关 Querydsl 的全面文档，请参阅其网站：[http://querydsl.com/](http://querydsl.com/)。
- en: 19.1 Introducing Querydsl
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.1 介绍 Querydsl
- en: There are various alternatives for querying a database from within Java programs.
    You can use SQL, as has been possible since the early days of JDBC. The drawbacks
    of this approach are the lack of portability (the queries are dependent on the
    database and the particular SQL dialect) and the lack of type safety and static
    query verification.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Java 程序内部查询数据库有多种替代方案。您可以使用 SQL，自从 JDBC 早期以来就可以这样做。这种方法的缺点是缺乏可移植性（查询依赖于数据库和特定的
    SQL 方言）以及缺乏类型安全和静态查询验证。
- en: JPQL (Jakarta Persistence Query Language) was a step forward, being an object-oriented
    query language that is independent of the database. This means there’s no lack
    of portability, but there’s still a lack of type safety and static query verification.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JPQL（Jakarta Persistence Query Language）是一个进步，它是一个面向对象的查询语言，与数据库无关。这意味着没有可移植性的缺乏，但仍然缺乏类型安全和静态查询验证。
- en: Spring Data allows us to create methods with the query builder mechanism and
    to annotate methods with JPQL and SQL queries (though these still have their previously
    mentioned drawbacks). The query builder mechanism also has the disadvantage of
    requiring the methods to be defined in advance, and their names are not statically
    checked at compile time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data 允许我们使用查询构建器机制创建方法，并使用 JPQL 和 SQL 查询注解方法（尽管这些仍然有之前提到的缺点）。查询构建器机制也有缺点，即需要预先定义方法，并且它们的名称在编译时不会进行静态检查。
- en: The Criteria API allows you to build type safe and portable queries using a
    Java API. While it solved the drawbacks of the previously presented alternatives,
    it ended up being extremely verbose and created code that was difficult to read.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Criteria API 允许您使用 Java API 构建类型安全和可移植的查询。虽然它解决了之前提出的替代方案的缺点，但它最终变得极其冗长，并创建了难以阅读的代码。
- en: Querydsl keeps the important ideas of type safety and portability. Furthermore,
    it reduces the verboseness of Criteria API, and the code it creates is much easier
    to read and understand than that built with Criteria API.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Querydsl 保留了类型安全和可移植性的重要思想。此外，它减少了 Criteria API 的冗长性，并且它创建的代码比使用 Criteria API
    创建的代码更容易阅读和理解。
- en: 19.2 Creating a Querydsl application
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.2 创建 Querydsl 应用程序
- en: We’ll start by creating a Querydsl application whose dependencies are managed
    by Maven. We’ll examine the steps involved, the dependencies that need to be added
    to the project, the entities that will be managed, and how to write queries with
    the help of Querydsl.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个由 Maven 管理依赖项的 Querydsl 应用程序。我们将检查涉及到的步骤，需要添加到项目中的依赖项，将要管理的实体，以及如何借助
    Querydsl 编写查询。
- en: Note To execute the examples from the source code, you’ll first need to run
    the Ch19.sql script.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 要执行源代码中的示例，您首先需要运行 Ch19.sql 脚本。
- en: 19.2.1 Configuring the Querydsl application
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.2.1 配置 Querydsl 应用程序
- en: 'We’ll add two dependencies in the Maven pom.xml file: `querydsl-jpa` and `querydsl
    -apt`. The `querydsl-jpa` dependency is needed to use the Querydsl API inside
    a JPA application. The `querydsl-apt` dependency is needed to process annotations
    from Java files before code compilation.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Maven pom.xml 文件中添加两个依赖项：`querydsl-jpa` 和 `querydsl-apt`。`querydsl-jpa`
    依赖项是需要在 JPA 应用程序中使用 Querydsl API 所必需的。`querydsl-apt` 依赖项是需要在代码编译之前处理 Java 文件中的注解所必需的。
- en: The APT in `querydsl-apt` stands for Annotation Processing Tool, and using it,
    the entities that are managed by the application will be replicated in the so-called
    Q-types (Q standing for “query”). This means that each `Entity` entity will have
    a corresponding `QEntity` that will be generated at build time, which Querydsl
    will use to query the database. Also, each field of the entity will be mirrored
    in the `QEntity` using the specific Querydsl classes. For example, `String` fields
    will be mirrored to `StringPath` fields, `Long` fields to `NumberPath<Long>` fields,
    `Integer` fields to `NumberPath<Integer>` fields, and so on.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`querydsl-apt` 中的 APT 代表注解处理工具，使用它，应用程序管理的实体将在所谓的 Q 类型（Q 代表“查询”）中进行复制。这意味着每个
    `Entity` 实体将有一个相应的 `QEntity`，它将在构建时生成，Querydsl 将使用它来查询数据库。此外，实体的每个字段都将使用特定的 Querydsl
    类在 `QEntity` 中进行镜像。例如，`String` 字段将镜像到 `StringPath` 字段，`Long` 字段到 `NumberPath<Long>`
    字段，`Integer` 字段到 `NumberPath<Integer>` 字段，依此类推。'
- en: The resulting Maven pom.xml file will have the dependencies shown in the following
    listing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 Maven pom.xml 文件将包含以下列表中显示的依赖项。
- en: Listing 19.1 The pom.xml Maven file
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.1 包含 APT 插件的 pom.xml Maven 文件
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The scope of the `querydsl-apt` dependency is specified as `provided`. This
    means that the dependency is needed only at build time when Maven generates the
    previously introduced Q-types. Then it is no longer needed, so it won’t be included
    in the application artifacts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`querydsl-apt` 依赖项的作用域指定为 `provided`。这意味着依赖项仅在构建时需要，当 Maven 生成之前引入的 Q 类型时。然后它就不再需要了，因此它不会包含在应用程序工件中。'
- en: To work with Querydsl we also need to include the Maven APT plugin in the Maven
    pom.xml file. This plugin will take care of generating the Q-types during the
    build process. As we are using JPA annotations in our project, the class that
    effectively does this is `com.querydsl.apt.jpa.JPAAnnotationProcessor`. If we
    were using the Hibernate API and annotations, we would have to use `com.querydsl.apt.hibernate
    .HibernateAnnotationProcessor` instead.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Querydsl，我们还需要在 Maven pom.xml 文件中包含 Maven APT 插件。此插件将在构建过程中负责生成 Q 类型。由于我们在项目中使用
    JPA 注解，实际执行此操作的类是 `com.querydsl.apt.jpa.JPAAnnotationProcessor`。如果我们使用 Hibernate
    API 和注解，则必须使用 `com.querydsl.apt.hibernate.HibernateAnnotationProcessor`。
- en: 'We’ll also have to indicate the output directory where the generated Q-types
    will reside: inside the `target` Maven folder. The pom.xml file with all this
    added is shown in the following listing.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须指出生成的 Q 类型将驻留的输出目录：在 `target` Maven 文件夹内。包含所有这些内容的 pom.xml 文件如下所示。
- en: Listing 19.2 The pom.xml Maven file with the APT plugin
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.2 包含 APT 插件的 pom.xml Maven 文件
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ⓐ The generated Q-types will be located in the target/generated-sources/java
    folder.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 生成的 Q 类型将位于 `target/generated-sources/java` 文件夹中。
- en: Ⓑ Use the `com.querydsl.apt.jpa.JPAAnnotationProcessor` class to generate Q-types.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 使用 `com.querydsl.apt.jpa.JPAAnnotationProcessor` 类生成 Q 类型。
- en: We’ll now move on to the standard configuration file for persistence units,
    in src/main/ resources/META-INF/persistence.xml. This file is shown in the following
    listing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转到持久化单元的标准配置文件，位于 src/main/resources/META-INF/persistence.xml。此文件如下所示。
- en: Listing 19.3 The persistence.xml configuration file
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.3 persistence.xml 配置文件
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Ⓐ The persistence.xml file configures the ch19.querydsl persistence unit.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ persistence.xml 文件配置了 ch19.querydsl 持久化单元。
- en: Ⓑ As JPA is only a specification, we need to indicate the vendor-specific `PersistenceProvider`
    implementation of the API. The persistence we define will be backed by a Hibernate
    provider.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 由于 JPA 只是一个规范，我们需要指出 API 的供应商特定 `PersistenceProvider` 实现。我们定义的持久化将由 Hibernate
    提供商支持。
- en: Ⓒ The JDBC properties—the driver.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ JDBC 属性——驱动程序。
- en: Ⓓ The URL of the database.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 数据库的 URL。
- en: Ⓔ The username.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 用户名。
- en: Ⓕ No password for access. The machine we are running the programs on has MySQL
    8 installed, and the access credentials are the ones from persistence.xml. You
    should modify the credentials to correspond to the ones on your machine.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 访问无密码。我们运行的程序所在的机器上已安装 MySQL 8，访问凭证来自 persistence.xml。您应修改凭证以与您机器上的凭证相匹配。
- en: Ⓖ The Hibernate dialect is MySQL8, as the database we’ll interact with is MySQL
    Release 8.0.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ Hibernate 方言是 MySQL8，因为我们将要交互的数据库是 MySQL Release 8.0。
- en: Ⓗ While executing, show the SQL code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓗ 执行时显示 SQL 代码。
- en: Ⓘ Hibernate will format the SQL nicely and generate comments in the SQL string
    so we know why Hibernate executed the SQL statement.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓘ Hibernate 将格式化 SQL 并在 SQL 字符串中生成注释，以便我们知道 Hibernate 执行 SQL 语句的原因。
- en: Ⓙ Every time the program is executed, the database will be created from scratch.
    This is ideal for automated testing when we want to work with a clean database
    for every test run.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓙ 每次程序执行时，数据库将从零开始创建。这对于自动化测试来说很理想，因为我们希望在每次测试运行时都使用一个干净的数据库。
- en: 19.2.2 Creating the entities
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.2.2 创建实体
- en: 'We’ll now create the classes that represent the entities of the application:
    `User`, `Bid`, and `Address`. The relationships between them will be of type one-to-many,
    many-to-one, or embedded.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建代表应用程序实体的类：`User`、`Bid`和`Address`。它们之间的关系将是单对多、多对一或内嵌类型。
- en: Listing 19.4 The `User` class
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.4 `User`类
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Ⓐ The ID field is an identifier generated by the `Constants.ID_GENERATOR` generator.
    For a review of generators, revisit chapter 5.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ ID字段是由`Constants.ID_GENERATOR`生成器生成的标识符。关于生成器的复习，请回顾第5章。
- en: Ⓑ The address does not have its own identity; it is embeddable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 地址没有自己的标识符；它是可嵌入的。
- en: Ⓒ There is a one-to-many relationship between `User` and `Bid`, which is mapped
    by the `user` field on the `Bid` side. `CascadeType.ALL` indicates that all operations
    will be propagated from the parent `User` to the child `Bid`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `User`和`Bid`之间存在一对一的关系，这由`Bid`侧的`user`字段映射。`CascadeType.ALL`表示所有操作都将从父`User`传播到子`Bid`。
- en: The `Address` class does not have its own persistence identity, and it will
    be embeddable.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Address`类没有自己的持久化标识符，它将是可嵌入的。'
- en: Listing 19.5 The `Address` class
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.5 `Address`类
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Bid` class will contain an `id` field having a similar generation strategy
    as for `User`. The relationship between `Bid` and `User` will be many-to-one,
    not optional, and the fetch type will be lazy.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bid`类将包含一个具有类似生成策略的`id`字段，就像`User`一样。`Bid`和`User`之间的关系将是多对一，非可选的，并且抓取类型将是懒加载。'
- en: Listing 19.6 The `Bid` class
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.6 `Bid`类
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `UserRepository` interface extends `JpaRepository<User,` `Long>`. It manages
    the `User` entity and has IDs of type `Long`. We’ll use this Spring Data JPA interface
    only to conveniently populate the database to test Querydsl on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserRepository`接口扩展了`JpaRepository<User, Long>`。它管理`User`实体，并具有`Long`类型的ID。我们只使用这个Spring
    Data JPA接口来方便地填充数据库以测试Querydsl。'
- en: Listing 19.7 The `UserRepository` interface
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.7 `UserRepository`接口
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 19.2.3 Creating the test data to query
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.2.3 创建查询所需的数据
- en: To populate and work with the database, we’ll need a `SpringDataConfiguration`
    class and a `GenerateUsers` class. We have used this approach repeatedly, so we’ll
    only quickly review the capabilities of these classes here.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了填充和操作数据库，我们需要一个`SpringDataConfiguration`类和一个`GenerateUsers`类。我们已经多次使用这种方法，所以在这里我们只简要回顾这些类的功能。
- en: Listing 19.8 The `SpringDataConfiguration` class
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.8 `SpringDataConfiguration`类
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Ⓐ The `@EnableJpaRepositories` annotation will scan the package of the annotated
    configuration class for Spring Data repositories.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `@EnableJpaRepositories`注解将扫描被注解配置类的包以查找Spring Data仓库。
- en: 'Ⓑ Create a data source bean to keep the JDBC properties: the driver, the URL
    of the database, the username, and the password.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 创建一个数据源bean来保存JDBC属性：驱动程序、数据库URL、用户名和密码。
- en: Ⓒ Create a transaction manager bean based on an entity manager factory. Every
    interaction with the database should occur within transaction boundaries, and
    Spring Data needs a transaction manager bean.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 基于实体管理器工厂创建一个事务管理器bean。每次与数据库的交互都应在事务边界内进行，Spring Data需要一个事务管理器bean。
- en: Ⓓ Create and configure a JPA vendor adapter bean, which is needed by JPA to
    interact with Hibernate.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 创建并配置一个JPA供应商适配器bean，这是JPA与Hibernate交互所需的。
- en: Ⓔ Create and configure a `LocalContainerEntityManagerFactoryBean`—this is a
    factory bean that produces an `EntityManagerFactory`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 创建并配置一个`LocalContainerEntityManagerFactoryBean`——这是一个工厂bean，它产生一个`EntityManagerFactory`。
- en: The `GenerateUsers` class contains the `generateUsers` method, which creates
    a list of users and their related bids.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateUsers`类包含`generateUsers`方法，该方法创建用户及其相关出价列表。'
- en: Listing 19.9 The `GenerateUsers` class
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.9 `GenerateUsers`类
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 19.3 Querying a database with Querydsl
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.3 使用Querydsl查询数据库
- en: As we mentioned previously, the Maven APT plugin will generate the Q-types during
    the build process. According to the provided configuration (see listing 19.2),
    these sources will be generated in the target/generated-sources/java folder (see
    figure 19.1). We’ll use these generated classes to query the database.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Maven APT插件将在构建过程中生成Q类型。根据提供的配置（参见列表19.2），这些源将在`target/generated-sources/java`文件夹中生成（参见图19.1）。我们将使用这些生成的类来查询数据库。
- en: '![](../../OEBPS/Images/CH19_F01_Tudose2.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH19_F01_Tudose2.png)'
- en: Figure 19.1 The generated Q-types in the `target` folder
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.1 在`target`文件夹中生成的Q类型
- en: First, though, we have to populate the database, and to do this, we’ll use the
    `User-Repository` interface. We’ll also use an `EntityManagerFactory` and the
    created `EntityManager` to start working with a `JPAQueryFactory` and a `JPAQuery`.
    We’ll need a `JPAQueryFactory` instance to work with queries, and it will be created
    by the constructor that takes an `EntityManager` argument. Then, `JPAQueryFactory`
    will create `JPAQuery` instances, to effectively query the database.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须填充数据库，为此，我们将使用`User-Repository`接口。我们还将使用`EntityManagerFactory`和创建的`EntityManager`来开始使用`JPAQueryFactory`和`JPAQuery`。我们需要一个`JPAQueryFactory`实例来处理查询，它将通过接受一个`EntityManager`参数的构造函数创建。然后，`JPAQueryFactory`将创建`JPAQuery`实例，以有效地查询数据库。
- en: We’ll extend the test using `SpringExtension`. This extension is used to integrate
    the Spring test context with the JUnit 5 Jupiter test.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`SpringExtension`扩展测试。这个扩展用于将Spring测试上下文与JUnit 5 Jupiter测试集成。
- en: Before executing the tests, we’ll populate the database with previously generated
    users and their corresponding bids. Before each test, we’ll create an `EntityManager`
    and start a transaction. Thus, every interaction with the database will occur
    within transaction boundaries. For the moment, we won’t execute queries from inside
    this class, but as tests and queries will be immediately added (starting with
    listing 19.11), we’ll name our class `QuerydslTest`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行测试之前，我们将使用之前生成的用户及其相应的出价填充数据库。在每次测试之前，我们将创建一个`EntityManager`并开始一个事务。因此，与数据库的每次交互都将发生在事务边界内。目前，我们不会在这个类内部执行查询，但随着测试和查询将立即添加（从列表19.11开始），我们将我们的类命名为`QuerydslTest`。
- en: Listing 19.10 The `QuerydslTest` class
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.10 `QuerydslTest`类
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Ⓐ Extend the test using `SpringExtension`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 使用`SpringExtension`扩展测试。
- en: Ⓑ JUnit will create only one instance of the test class for executing all tests,
    instead of one instance per test. This way we’ll be able to autowire the `UserRepository`
    field as an instance variable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ JUnit将为执行所有测试创建测试类的唯一实例，而不是每个测试一个实例。这样我们就能将`UserRepository`字段自动装配为实例变量。
- en: Ⓒ The Spring test context is configured using the beans defined in the previously
    presented `SpringDataConfiguration` class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ Spring测试上下文是通过之前展示的`SpringDataConfiguration`类中定义的bean进行配置的。
- en: Ⓓ A `UserRepository` bean is injected by Spring through autowiring. It will
    be used to easily populate and clean up the database.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 通过Spring的自动装配注入一个`UserRepository` bean。它将被用来轻松地填充和清理数据库。
- en: Ⓔ Initialize an `EntityManagerFactory` to talk to the database. This one will
    create the `EntityManager` that is needed by the `JPAQueryFactory`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 初始化一个`EntityManagerFactory`以与数据库通信。这个`EntityManagerFactory`将创建`JPAQueryFactory`所需的`EntityManager`。
- en: Ⓕ Declare the `EntityManager` and the `JPAQueryFactory` needed for the application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 声明应用程序所需的`EntityManager`和`JPAQueryFactory`。
- en: Ⓖ Populate the database with previously generated users and bids, to be used
    by the tests.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 使用之前生成的用户和出价填充数据库，供测试使用。
- en: Ⓗ Create a `JPAQueryFactory` by passing an `EntityManager` as an argument to
    its constructor.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓗ 通过将`EntityManager`作为参数传递给其构造函数来创建一个`JPAQueryFactory`。
- en: Ⓘ At the end of each test, commit the transaction and close the `EntityManager`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓘ 在每个测试结束时，提交事务并关闭`EntityManager`。
- en: Ⓙ At the end of the execution of all tests, clean up the database.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓙ 在所有测试执行结束时，清理数据库。
- en: 19.3.1 Filtering data
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3.1 数据过滤
- en: 'As previously discussed, the entities that are managed by the application will
    be replicated in the so-called Q-types. This means that each `Entity` entity will
    have a corresponding `QEntity` that will be generated at build time, which Querydsl
    will use to query the database. The Q-type classes generated by the Maven APT
    plugin each contain a static instance of their kind:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，应用程序管理的实体将在所谓的Q类型中进行复制。这意味着每个`Entity`实体将有一个相应的`QEntity`，它将在构建时生成，Querydsl将使用它来查询数据库。由Maven
    APT插件生成的Q类型类每个都包含其类型的静态实例：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These instances will be used to query the database. We’ll first get a `JPAQuery`
    instance by calling `queryFactory.selectFrom(user)`. Then we’ll use this `JPAQuery`
    instance to build the clauses of the query. We’ll use the `where` method to filter
    by a given `Predicate` and the `fetchOne` method to fetch a single element from
    the database. `fetchOne` returns `null` if no element to fulfill a condition is
    found, and it throws `NonUniqueResultException` if multiple elements that fulfill
    a condition are found.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实例将被用来查询数据库。我们首先通过调用 `queryFactory.selectFrom(user)` 获取一个 `JPAQuery` 实例。然后我们将使用这个
    `JPAQuery` 实例来构建查询的子句。我们将使用 `where` 方法通过给定的 `Predicate` 进行过滤，并使用 `fetchOne` 方法从数据库中获取单个元素。如果找不到满足条件的元素，`fetchOne`
    返回 `null`，如果找到多个满足条件的元素，则抛出 `NonUniqueResultException`。
- en: For example, to get the `User` with a given `username`, we’ll write the code
    in the following listing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了获取具有给定 `username` 的 `User`，我们将编写以下列表中的代码。
- en: Listing 19.11 Finding a `User` by `username`
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.11 通过 `username` 查找 `User`
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Ⓐ Start building the query using the `selectFrom` method belonging to the `JPAQueryFactory`
    class. This method will get the created Q-type instance `QUser.user` as an argument
    and will return a `JPAQuery`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 使用属于 `JPAQueryFactory` 类的 `selectFrom` 方法开始构建查询。此方法将获取创建的 Q 类型实例 `QUser.user`
    作为参数，并将返回一个 `JPAQuery`。
- en: Ⓑ The `where` method will filter by the given `Predicate` related to the `username`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `where` 方法将根据给定的与 `username` 相关的 `Predicate` 进行过滤。
- en: Ⓒ The `fetchOne` method will try to fetch a single element from the database.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `fetchOne` 方法将尝试从数据库中获取单个元素。
- en: Ⓓ Verify that the fetched data is the expected data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 验证获取的数据是预期的数据。
- en: 'The following SQL queries are generated by Hibernate:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 SQL 查询由 Hibernate 生成：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can filter by multiple `Predicate`s using methods such as `and` or `or`,
    which each receive a `Predicate`. For example, to filter by the `level` and `active`
    fields, we could write the following piece of code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `and` 或 `or` 等方法通过多个 `Predicate` 进行过滤，每个方法都接收一个 `Predicate`。例如，为了过滤 `level`
    和 `active` 字段，我们可以编写以下代码：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following SQL query is generated by Hibernate:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 SQL 查询由 Hibernate 生成：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 19.3.2 Ordering data
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3.2 排序数据
- en: To order data, we’ll use the `orderBy` method, which can receive multiple arguments
    representing the criteria to order by. For example, to get the `User` instances
    ordered by `username`, we’ll write the following code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了排序数据，我们将使用 `orderBy` 方法，它可以接收多个表示排序标准的参数。例如，为了按 `username` 排序 `User` 实例，我们将编写以下代码。
- en: Listing 19.12 Ordering `User` instances by `username`
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.12 按 `username` 排序 `User` 实例
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Ⓐ Start building the query using the `selectFrom` method belonging to the `JPAQueryFactory`
    class. This method will get the created Q-type instance `QUser.user` as an argument
    and will return a `JPAQuery`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 使用属于 `JPAQueryFactory` 类的 `selectFrom` 方法开始构建查询。此方法将获取创建的 Q 类型实例 `QUser.user`
    作为参数，并将返回一个 `JPAQuery`。
- en: Ⓑ Order the results by `username`, ascending. The `orderBy` method is overloaded
    and can receive multiple criteria to order by.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'Ⓑ 按 `username` 顺序排序结果。`orderBy` 方法是重载的，可以接收多个排序标准。 '
- en: Ⓒ The `fetch` method will fetch the list of `User` instances.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `fetch` 方法将获取 `User` 实例的列表。
- en: Ⓓ Verify that the fetched data is the expected data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 验证获取的数据是预期的数据。
- en: 'The following SQL query is generated by Hibernate:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 SQL 查询由 Hibernate 生成：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 19.3.3 Grouping data and working with aggregates
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3.3 分组数据和聚合操作
- en: To group data, we’ll use the `groupBy` method, which receives the expression
    to group by. Such a query will return a `List<Tuple>`. A `com.querydsl.core.Tuple`
    object is a key/value pair that contains the key to group by and its corresponding
    value. For example, the following code counts `Bid` instances grouped by `amount`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分组数据，我们将使用 `groupBy` 方法，它接收用于分组的表达式。此类查询将返回一个 `List<Tuple>`。`com.querydsl.core.Tuple`
    对象是一个包含用于分组的键及其对应值的键/值对。例如，以下代码按 `amount` 对 `Bid` 实例进行计数。
- en: Listing 19.13 Grouping bids by amount
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.13 按金额分组投标
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Ⓐ Keep the `count()` expression, as we’ll need it multiple times later when
    building the query.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 保持 `count()` 表达式，因为我们稍后构建查询时需要多次使用它。
- en: Ⓑ Return a `List<Tuple>`, the key/value pairs with the key to group by and its
    corresponding value.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 返回一个 `List<Tuple>`，包含用于分组的键/值对及其对应的值。
- en: Ⓒ Select the `amount` and the count of the same `amount`s from `Bid`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 从 `Bid` 中选择 `amount` 和相同 `amount` 的计数。
- en: Ⓓ Group by the `amount` value.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 按 `amount` 值进行分组。
- en: Ⓔ Order by the count of records having the same amount.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 按相同金额的记录数进行排序。
- en: Ⓕ Fetch the `List<Tuple>` objects.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 获取 `List<Tuple>` 对象。
- en: Ⓖ Verify that the fetched data is the expected data.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 验证检索到的数据是否符合预期。
- en: 'The following SQL query is generated by Hibernate:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下SQL查询由Hibernate生成：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To work with aggregation and get the maximum, minimum, and average values of
    the `Bid`s, we can use the `max`, `min``,` and `avg` methods, as in the following
    code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用聚合操作并获取`Bid`的最大值、最小值和平均值，我们可以使用`max`、`min`和`avg`方法，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following SQL queries are generated by Hibernate:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下SQL查询由Hibernate生成：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 19.3.4 Working with subqueries and joins
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3.4 使用子查询和连接
- en: To work with subqueries, we’ll create a subquery with the `JPAExpressions` static
    factory methods (such as `select`), and we’ll define the query parameters using
    methods such as `from` and `where`. We’ll pass the subquery to the `where` method
    of the main query. For example, the following listing selects the `User`s having
    `Bid`s with a given `amount`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用子查询，我们将使用`JPAExpressions`静态工厂方法（如`select`）创建子查询，并使用`from`和`where`等方法定义查询参数。我们将把子查询传递给主查询的`where`方法。例如，以下列表选择具有给定`amount`的`Bid`的`User`。
- en: Listing 19.14 Working with subqueries
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.14 使用子查询
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Ⓐ Start building the query using the `selectFrom` method belonging to the `JPAQueryFactory`
    class.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 使用属于`JPAQueryFactory`类的`selectFrom`方法开始构建查询。
- en: Ⓑ Pass the subquery as a parameter of the `where` method.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 将子查询作为`where`方法的参数传递。
- en: Ⓒ Create the subquery to get the `Bid`s having `amount` 120.00.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 创建子查询以获取`amount`为120.00的`Bid`。
- en: Ⓓ Fetch the result.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 检索结果。
- en: Ⓔ Create a similar query and subquery for the `Bid`s having `amount` 105.00.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 为`amount`为105.00的`Bid`创建类似的查询和子查询。
- en: Ⓕ Verify that the fetched data is as expected.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 验证检索到的数据是否符合预期。
- en: 'The following SQL query is generated by Hibernate:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下SQL查询由Hibernate生成：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To work with joins, we’ll use the methods `innerJoin`, `leftJoin`, and `outerJoin`
    to define the join, and we’ll use the `on` method to declare the condition (a
    `Predicate`) to join on.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用连接，我们将使用`innerJoin`、`leftJoin`和`outerJoin`方法来定义连接，并使用`on`方法来声明连接的条件（一个`Predicate`）。
- en: Listing 19.15 Working with joins
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.15 使用连接
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Ⓐ Start building the query using the `selectFrom` method belonging to the `JPAQueryFactory`
    class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 使用属于`JPAQueryFactory`类的`selectFrom`方法开始构建查询。
- en: Ⓑ Make the inner join to `Bid`s.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 将内部连接到`Bid`。
- en: Ⓒ Define the join on condition as a `Predicate` to have the `Bid` `amount` 120.00.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 将连接条件定义为`Predicate`以使`Bid`的`amount`为120.00。
- en: Ⓓ Fetch the result.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 检索结果。
- en: Ⓔ Create a similar join for the `Bid`s having `amount` 105.00.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 为`amount`为105.00的`Bid`创建类似的连接。
- en: Ⓕ Verify that the fetched data is as expected.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 验证检索到的数据是否符合预期。
- en: 'The following SQL query is generated by Hibernate:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下SQL查询由Hibernate生成：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 19.3.5 Updating entities
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3.5 更新实体
- en: To update the entities, we’ll use the `update` method of the `JPAQueryFactory`
    class, the `where` method to define the `Predicate` that will filter the entities
    to be updated (optional), the `set` method to define the changes to be made, and
    the `execute` method to effectively execute the update.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新实体，我们将使用`JPAQueryFactory`类的`update`方法，使用`where`方法定义将过滤要更新的实体的`Predicate`（可选），使用`set`方法定义要进行的更改，并使用`execute`方法有效地执行更新。
- en: Listing 19.16 Updating the information
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.16 更新信息
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Ⓐ Start building the query using the `update` method belonging to the `JPAQueryFactory`
    class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 使用属于`JPAQueryFactory`类的`update`方法开始构建查询。
- en: Ⓑ Define the `where` condition to update on (optional).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 定义更新时的`where`条件（可选）。
- en: Ⓒ Define the changes to be made to the entities with the `set` method.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 使用`set`方法定义对实体进行的更改。
- en: Ⓓ Effectively execute the update.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 有效地执行更新操作。
- en: Ⓔ Commit the transaction that was started in the `@BeforeEach` annotated method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 在`@BeforeEach`注解的方法中提交开始的交易。
- en: Ⓕ Start a new transaction that will be committed in the `@AfterEach` annotated
    method.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 在`@AfterEach`注解的方法中提交新的交易。
- en: Ⓖ Check the result of the update by fetching the modified entity.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 通过检索修改后的实体来检查更新结果。
- en: 'The following SQL query is generated by Hibernate:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下SQL查询由Hibernate生成：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 19.3.6 Deleting entities
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.3.6 删除实体
- en: To delete entities, we’ll use the `update` method of the `JPAQueryFactory` class,
    the `where` method to define the `Predicate` that will filter the entities to
    be deleted (optional), and the `execute` method to effectively execute the delete.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除实体，我们将使用`JPAQueryFactory`类的`update`方法，使用`where`方法定义将过滤要删除的实体的`Predicate`（可选），并使用`execute`方法有效地执行删除。
- en: There’s a big problem with Querydsl here. In the Querydsl reference documentation
    ([http://querydsl.com/static/querydsl/latest/reference/html/](http://querydsl.com/static/querydsl/latest/reference/html/)),
    section 2.1.11 on `DELETE` queries using JPA notes, “DML clauses in JPA don’t
    take JPA level cascade rules into account and don’t provide fine-grained second
    level cache interaction.” Therefore, the cascade attribute of the bids `@OneToMany`
    annotation in the `User` class is ignored; it is necessary to select a user and
    manually delete their bids before deleting it through a Querydsl delete query.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Querydsl 存在一个大问题。在 Querydsl 参考文档（[http://querydsl.com/static/querydsl/latest/reference/html/](http://querydsl.com/static/querydsl/latest/reference/html/)）中，关于使用
    JPA 的 `DELETE` 查询的第 2.1.11 节指出，“JPA 中的 DML 子句不考虑 JPA 级级联规则，并且不提供细粒度的二级缓存交互。” 因此，`User`
    类中 `@OneToMany` 注解的级联属性被忽略；在通过 Querydsl 删除查询删除之前，必须先选择用户并手动删除他们的出价。
- en: As an extra proof that the issue comes from Querydsl, if a user was to be deleted
    through a `userRepository.delete(burk);` instruction, the `@OneToMany` cascade
    attribute would be properly taken into account, and no manual handling of the
    user’s bids would be needed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外证据，如果用户要通过 `userRepository.delete(burk);` 指令被删除，`@OneToMany` 级联属性将被适当考虑，并且不需要手动处理用户的出价。
- en: Listing 19.17 Deleting the information
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.17 删除信息
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Ⓐ Find user `burk`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 查找用户 `burk`。
- en: Ⓑ Delete the bids belonging to the previously found user.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 删除属于之前找到用户的出价。
- en: Ⓒ Start building the query using the `delete` method belonging to the `JPAQueryFactory`
    class.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 使用属于 `JPAQueryFactory` 类的 `delete` 方法开始构建查询。
- en: Ⓓ Define the `where` condition to delete on (optional).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 定义要删除的 `where` 条件（可选）。
- en: Ⓔ Effectively execute the delete.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 有效地执行删除操作。
- en: Ⓕ Commit the transaction that was started in the `@BeforeEach` annotated method.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 在 `@BeforeEach` 注解的方法中提交开始的事务。
- en: Ⓖ Start a new transaction that will be committed in the `@AfterEach` annotated
    method. This is why in this listing a `commit` transaction appears before a `begin`
    transaction.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 在 `@AfterEach` 注解的方法中提交一个新的事务。这就是为什么在这个列表中，`commit` 事务出现在 `begin` 事务之前。
- en: Ⓗ Check the result of the delete by trying to fetch the entity. If the entity
    no longer exists, the `fetchOne` method will return `null`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓗ 通过尝试获取实体来检查删除的结果。如果实体不再存在，`fetchOne` 方法将返回 `null`。
- en: 'The following SQL query is generated by Hibernate:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 SQL 查询由 Hibernate 生成：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This query is not enough if the `User` has child `Bid`s that need to be deleted
    first. This reveals another problem specific to MySQL: when Hibernate creates
    the schema, no `ON` `DELETE` `CASCADE` clause is added when defining the foreign
    key constraint on the `user_id` column in the `bid` table. Otherwise, this single
    `DELETE` query would be sufficient regardless of Querydsl ignoring `@OneToMany`
    cascade attributes.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `User` 有需要先删除的子 `Bid`，则此查询不足。这揭示了 MySQL 的另一个特定问题：当 Hibernate 创建模式时，在 `bid`
    表的 `user_id` 列上定义外键约束时，没有添加 `ON DELETE CASCADE` 子句。否则，无论 Querydsl 是否忽略 `@OneToMany`
    级联属性，此单个 `DELETE` 查询都将是足够的。
- en: No insert capability is provided by the Querydsl API. For inserting entities,
    you may use an `EntityManager` (JPA), `Session` (Hibernate), or repository (Spring
    Data JPA).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Querydsl API 不提供插入功能。对于插入实体，您可以使用 `EntityManager`（JPA）、`Session`（Hibernate）或存储库（Spring
    Data JPA）。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Query alternatives such as SQL, JPQL, Criteria API, Spring Data have drawbacks:
    lack of portability, lack of type safety and static query verification, and verboseness.
    Querydsl addresses the important ideas of type safety and portability, and it
    reduces the verboseness.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL、JPQL、Criteria API、Spring Data 等查询替代方案有缺点：缺乏可移植性、缺乏类型安全和静态查询验证，以及冗长。Querydsl
    解决了类型安全和可移植性的重要思想，并减少了冗长。
- en: You can create a persistence application to use Querydsl, define its configuration
    and entities, and persist and query data.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以创建一个持久化应用程序来使用 Querydsl，定义其配置和实体，并持久化和查询数据。
- en: To work with Querydsl, its dependencies need to be added to the application.
    The Maven APT (Annotation Processing Tool) is required for the creation, at build
    time, of the Q-types that replicate the entities.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用 Querydsl，需要将其依赖项添加到应用程序中。Maven APT（注解处理工具）在构建时用于创建 Q 类型，这些类型复制了实体。
- en: You can work with the core Querydsl classes, `JPAQueryFactory` and `JPAQuery`,
    to build the queries to retrieve, update, and delete data.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用核心 Querydsl 类 `JPAQueryFactory` 和 `JPAQuery` 来构建查询，用于检索、更新和删除数据。
- en: You can create queries to filter, order, and group data and queries to execute
    joins, updates, and deletes.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以创建查询以筛选、排序和分组数据，以及执行连接、更新和删除操作。
