- en: '16 Building Docker images that run anywhere: Linux, Windows, Intel, and Arm'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16 构建在任何地方运行的Docker镜像：Linux、Windows、Intel和Arm
- en: There are dozens of try-it-now exercises in this book, and if you’ve used different
    machines to follow along, you’ll have seen that the exercises work in the same
    way on Mac, Windows, Linux, and Raspberry Pi. That’s not an accident--I’ve built
    every Docker image in this book as a multi-architecture image. Multi-arch images
    are built and pushed to registries with multiple variants, each targeting a different
    operating system or CPU architecture, but all using the same image name. When
    you use one of these images to run a container or to build another image, Docker
    pulls the matching variant for the CPU and OS on your machine. If you use the
    same image name on a different architecture, you’ll get a different image variant,
    but it will be the same app and it will work in the same way. It’s a super-easy
    workflow for the user, but it takes some effort for the image publisher.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中有数十个“现在就试”的练习，如果你使用不同的机器来跟随，你会发现这些练习在Mac、Windows、Linux和Raspberry Pi上工作方式相同。这不是偶然——我已经将本书中的每个Docker镜像构建为多架构镜像。多架构镜像以多种变体构建并推送到注册表，每种变体针对不同的操作系统或CPU架构，但都使用相同的镜像名称。当你使用这些镜像之一来运行容器或构建另一个镜像时，Docker会根据你机器上的CPU和OS拉取匹配的变体。如果你在不同的架构上使用相同的镜像名称，你会得到不同的镜像变体，但它将是相同的应用程序，并且将以相同的方式工作。这对用户来说是一个超级简单的流程，但对镜像发布者来说则需要一些努力。
- en: In this chapter you’ll learn the different ways to produce multi-arch builds,
    but if you’re thinking of skipping this one because you don’t use Windows or Arm,
    you should at least read the first section to learn why this is a game-changing
    option.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习到产生多架构构建的不同方法，但如果你因为不使用Windows或Arm而考虑跳过这一部分，至少应该阅读第一部分，了解为什么这是一个改变游戏规则的选择。
- en: 16.1 Why multi-architecture images are important
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1 为什么多架构镜像很重要
- en: Amazon Web Services provides different classes of compute for VMs that use Intel,
    AMD, or Arm processors. The Arm options (called A1 instances) are very nearly
    half the price of the Intel/AMD options. AWS has been the first major cloud to
    support Arm, but you can be sure that if the others start to lose workloads to
    AWS because of the savings from Arm CPUs, they’ll add support too. If you can
    take your application and run it at nearly half the price, why wouldn’t you? Well,
    because it’s hard to get apps built for Intel to run on Arm.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊网络服务为使用Intel、AMD或Arm处理器的虚拟机提供不同的计算类别。Arm选项（称为A1实例）的价格几乎比Intel/AMD选项便宜一半。AWS是第一个支持Arm的主要云服务提供商，但你可以确信，如果其他云服务提供商因为Arm
    CPU的节省而开始失去工作负载，他们也会添加支持。如果你可以将你的应用程序运行在几乎一半的价格上，你为什么不这样做呢？嗯，因为很难让为Intel构建的应用程序在Arm上运行。
- en: On the other end of the scale, IoT devices typically run Arm processors because
    they’re highly efficient on power consumption (hence the price reduction in the
    cloud), and it would be great to ship software to devices as container images
    too. But Arm CPU instructions are not compatible with the standard x64 instructions
    that Intel and AMD use. So to support Arm CPUs in the cloud or the edge (or in
    a datacenter full of Raspberry Pis) you need to use an application platform that
    can run on Arm, and you need to build your app using an Arm machine. That’s the
    hard part that Docker solves, both for production build farms and for the developer
    workflow. Docker Desktop supports emulation to build Docker images and run containers
    with the Arm architecture, even on Intel machines.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一端，物联网设备通常运行Arm处理器，因为它们在功耗上非常高效（因此云中的价格降低），如果能以容器镜像的形式将软件发送到设备上那就太好了。但是，Arm
    CPU指令与Intel和AMD使用的标准x64指令不兼容。因此，为了在云或边缘（或在充满Raspberry Pi的数据中心）支持Arm CPU，你需要使用一个可以在Arm上运行的应用程序平台，并且你需要使用Arm机器来构建你的应用程序。这就是Docker解决的问题，无论是对于生产构建农场还是对于开发者工作流程。Docker
    Desktop支持仿真来构建带有Arm架构的Docker镜像和运行容器，即使在Intel机器上也是如此。
- en: Try it now This one’s not for Docker Engine or PWD users I’m afraid, because
    the engine alone doesn’t have Arm emulation--that only comes with Docker Desktop.
    You can do this on Mac or Windows (in Linux container mode).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就试一试 这个可能不适合Docker Engine或PWD用户，因为仅Docker Engine本身没有Arm仿真——这只有在Docker Desktop中才有。你可以在Mac或Windows上这样做（在Linux容器模式下）。
- en: First you need to enable experimental mode from the whale icon settings--see
    figure 16.1.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要从鲸鱼图标设置中启用实验模式——参见图16.1。
- en: '![](../Images/16-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/16-1.jpg)'
- en: Figure 16.1 Enabling experimental mode unlocks features that are still under
    development.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 启用实验模式可以解锁仍在开发中的功能。
- en: 'Now open a terminal and build an image using Arm emulation:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开一个终端，使用Arm仿真构建一个图像：
- en: '` # switch to the exercises folder:` ` cd ch16/exercises` ` # build for 64-bit
    Arm:` ` docker build -t diamol/ch16-whoami:linux-arm64 --platform linux/arm64
    ./whoami` ` # check the architecture of the image:` ` docker image inspect diamol/ch16-whoami:linux-arm64
    -f ''{{.Os}}/{{.Architecture}}''` ` # and the native architecture of your engine:`
    ` docker info -f ''{{.OSType}}/{{.Architecture}}''`'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 切换到练习文件夹：` ` cd ch16/exercises` ` # 为64位Arm构建：` ` docker build -t diamol/ch16-whoami:linux-arm64
    --platform linux/arm64 ./whoami` ` # 检查图像的架构：` ` docker image inspect diamol/ch16-whoami:linux-arm64
    -f ''{{.Os}}/{{.Architecture}}''` ` # 以及您引擎的原生架构：` ` docker info -f ''{{.OSType}}/{{.Architecture}}''`'
- en: You’ll see that the image you built is targeted for the 64-bit Arm platform,
    even though your own machine is running on a 64-bit Intel or AMD machine. This
    image uses a multi-stage Dockerfile to compile and package a .NET Core application.
    The .NET Core platform runs on Arm, and the base images in the Dockerfile (for
    the SDK and the runtime) have Arm variants available. That’s all you need to support
    cross-platform builds.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到您构建的图像针对的是64位Arm平台，尽管您的机器正在运行64位Intel或AMD机器。此图像使用多阶段Dockerfile来编译和打包.NET
    Core应用程序。.NET Core平台在Arm上运行，Dockerfile中的基础镜像（对于SDK和运行时）有可用的Arm变体。这就是您需要支持跨平台构建的所有内容。
- en: You could push this image to a registry and run a container from it on a genuine
    Arm machine (like the Raspberry Pi or an A1 instance in AWS) and it will work
    just fine. You can see my output in figure 16.2, where I’ve built an Arm image
    from an Intel machine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此图像推送到注册表，并在真实的Arm机器（如Raspberry Pi或AWS中的A1实例）上运行容器，它将正常工作。您可以在图16.2中看到我的输出，我在其中从一个Intel机器构建了一个Arm图像。
- en: '![](../Images/16-2.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16-2.jpg)'
- en: Figure 16.2 Cross-platform support, building Arm images from Intel machines
    using emulation
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 跨平台支持，使用仿真在Intel机器上构建Arm图像
- en: Docker knows many things about your machine, including the operating system
    and the CPU architecture, and it will use those as a match when you try to pull
    images. Pulling an image is more than just downloading the layers--there’s also
    optimization to expand the compressed layers and get the image ready to run. That
    optimization only works if the image you want to use is a match for the architecture
    you’re running on, so if there’s no match, you’ll get an error--you can’t pull
    the image to even try and run a container.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Docker了解您机器的许多信息，包括操作系统和CPU架构，当您尝试拉取图像时，它将使用这些信息作为匹配项。拉取图像不仅仅是下载层——还包括优化以扩展压缩层并使图像准备好运行。这种优化仅在您想要使用的图像与您正在运行的架构匹配时才有效，因此如果没有匹配项，您将得到一个错误——您甚至无法拉取图像来尝试运行容器。
- en: 'try it now You can use any Docker Engine running Linux containers to verify
    this--try downloading a Microsoft Windows image:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看您可以使用运行Linux容器的任何Docker Engine来验证这一点——尝试下载一个Microsoft Windows图像：
- en: '` # pull the Windows Nano Server image:` ` docker image pull mcr.microsoft.com/windows/nanoserver:1809`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 拉取Windows Nano Server图像：` ` docker image pull mcr.microsoft.com/windows/nanoserver:1809`'
- en: You can see my output in figure 16.3--Docker gets the OS and CPU of the current
    engine, and checks to see if there’s a matching variant in the registry. There
    is no match, so the image isn’t pulled and I get an error.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在图16.3中看到我的输出——Docker获取当前引擎的操作系统和CPU，并检查注册表中是否有匹配的变体。没有匹配项，因此图像没有被拉取，我得到了一个错误。
- en: '![](../Images/16-3.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16-3.jpg)'
- en: Figure 16.3 You can’t pull an image from a registry if there’s no variant to
    match your OS and CPU.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 如果没有与您的操作系统和CPU相匹配的变体，您无法从注册表中拉取图像。
- en: The manifest list is the set of variants for the image. The Windows Nano Server
    image isn’t truly multi-architecture, it will only run on Windows containers--there
    are no Linux variants in the manifest list. The basic principle is that the architecture
    for the image has to match the architecture of the Engine, but there are a few
    nuances--Linux images can be pulled for non-matching CPU architectures, but containers
    will fail with an obscure “user process caused ‘exec format error’” message. Some
    Windows engines have an experimental feature called Linux Containers on Windows
    (LCOW), so they can run Linux containers (but complex apps will fail with even
    more obscure logs). It’s best to stick to the matching architecture for the engine,
    and multi-arch images let you tailor the image to each OS and CPU if you need
    to.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 清单列表是镜像的变体集合。Windows Nano Server镜像并不是真正的多架构，它只能在Windows容器上运行——清单列表中没有Linux变体。基本原理是镜像的架构必须与引擎的架构相匹配，但也有一些细微差别——Linux镜像可以用于不匹配的CPU架构，但容器将因一个神秘的“用户进程导致‘exec格式错误’”消息而失败。一些Windows引擎有一个名为Windows上的Linux容器（LCOW）的实验性功能，因此它们可以运行Linux容器（但复杂的应用程序将因更神秘的日志而失败）。最好坚持使用与引擎匹配的架构，而多架构镜像让您可以根据需要为每个操作系统和CPU定制镜像。
- en: 16.2 Building multi-arch images from one or more Dockerfiles
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2 从一个或多个Dockerfile构建多架构镜像
- en: 'There are two approaches to building multi-arch images. In the first you follow
    the example of the `whoami` app in this chapter’s exercises: write a multi-stage
    Dockerfile that compiles the app from source and packages it to run in a container.
    If the images you use for the SDK and runtime support all the architectures you
    want to support, you’re good to go.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 构建多架构镜像有两种方法。在第一种方法中，您遵循本章练习中`whoami`应用程序的例子：编写一个多阶段Dockerfile，从源代码编译应用程序并将其打包以在容器中运行。如果您使用的SDK和运行时镜像支持您想要支持的所有架构，那么您就可以开始了。
- en: The huge benefit of this approach is that you have a single Dockerfile and you
    build it on different machines to get the architectures you want to support. I
    use this approach to build my own golden images for the .NET Core stack; figure
    16.4 shows the approach for the SDK.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的巨大优势在于您只有一个Dockerfile，您可以在不同的机器上构建它以获得您想要支持的架构。我使用这种方法来构建自己的.NET Core堆栈的黄金镜像；图16.4显示了SDK的构建方法。
- en: '![](../Images/16-4.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图16-4](../Images/16-4.jpg)'
- en: Figure 16.4 Use a multi-stage Dockerfile based on multi-arch images to build
    your own multi-arch image
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4 使用基于多架构镜像的多阶段Dockerfile构建自己的多架构镜像
- en: You can’t follow this approach if your source image isn’t a multi-arch image,
    or it doesn’t support all the images you want to support. Most of the official
    images on Docker Hub are multi-arch, but they don’t all support every variation
    that you might want. In that case you’ll need different Dockerfiles, maybe one
    for Linux and one for Windows, or maybe additional ones for Arm 32-bit and 64-bit.
    This approach takes more management, because you have multiple Dockerfiles to
    maintain, but it gives you a lot more freedom to adapt behavior for each target
    architecture. I use this approach for my golden image for Maven (a tool to build
    Java apps)--figure 16.5 shows the stack.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的源镜像不是多架构镜像，或者它不支持您想要支持的所有镜像，您就不能遵循这种方法。Docker Hub上大多数官方镜像都是多架构的，但它们并不支持您可能想要的每一个变体。在这种情况下，您将需要不同的Dockerfile，可能是一个用于Linux和一个用于Windows，或者可能还需要额外的用于Arm
    32位和64位的Dockerfile。这种方法需要更多的管理，因为您有多个Dockerfile需要维护，但它为您提供了更多的自由来为每个目标架构调整行为。我使用这种方法为我的Maven（一个用于构建Java应用程序的工具）黄金镜像——图16.5显示了堆栈。
- en: 'In the exercises for this chapter, there’s a `folder-list` app that is very
    simple--it just prints some basic information about the runtime and then lists
    the contents of a folder. There are four Dockerfiles, one for each of the architectures
    supported in this book: Windows on Intel, Linux on Intel, Linux on 32-bit Arm,
    and Linux on 64-bit Arm. You can use Docker Desktop’s CPU emulation with Linux
    containers to build and test three of those.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的练习中，有一个名为`folder-list`的应用程序非常简单——它只是打印一些关于运行时的一些基本信息，然后列出文件夹的内容。这里有四个Dockerfile，每个对应本书中支持的架构：Intel上的Windows、Intel上的Linux、32位Arm上的Linux和64位Arm上的Linux。您可以使用Docker
    Desktop的Linux容器CPU模拟来构建和测试其中的三个。
- en: '![](../Images/16-5.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图16-5](../Images/16-5.jpg)'
- en: Figure 16.5 You can also build multi-arch images using Dockerfiles tailored
    for each architecture.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5 您还可以使用针对每个架构定制的Dockerfile构建多架构镜像。
- en: 'Try it now Build images for different platforms using the Dockerfile for each
    platform. Each Dockerfile is slightly different, so we can compare the results
    when we run containers:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 使用每个平台的 Dockerfile 为不同的平台构建镜像。每个 Dockerfile 都略有不同，所以我们可以比较运行容器时的结果：
- en: '` cd ./folder-list`  ` # build for the native architecture - Intel/AMD:` ` docker
    image build -t diamol/ch16-folder-list:linux-amd64 -f ./Dockerfile.linux-amd64
    .`  ` # build for Arm 64-bit:` ` docker image build -t diamol/ch16-folder-list:linux-arm64
    -f ./Dockerfile.linux-arm64 --platform linux/arm64 .`  ` # and for Arm 32-bit`
    ` docker image build -t diamol/ch16-folder-list:linux-arm -f ./Dockerfile.linux-arm
    --platform linux/arm .`  ` # run all the containers and verify the output:` ` docker
    container run diamol/ch16-folder-list:linux-amd64` ` docker container run diamol/ch16-folder-list:linux-arm64`
    ` docker container run diamol/ch16-folder-list:linux-arm`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ./folder-list`  ` # 为本地架构编译 - Intel/AMD:` ` docker image build -t diamol/ch16-folder-list:linux-amd64
    -f ./Dockerfile.linux-amd64 .`  ` # 为 Arm 64 位编译:` ` docker image build -t diamol/ch16-folder-list:linux-arm64
    -f ./Dockerfile.linux-arm64 --platform linux/arm64 .`  ` # 和 Arm 32 位` ` docker
    image build -t diamol/ch16-folder-list:linux-arm -f ./Dockerfile.linux-arm --platform
    linux/arm .`  ` # 运行所有容器并验证输出:` ` docker container run diamol/ch16-folder-list:linux-amd64`
    ` docker container run diamol/ch16-folder-list:linux-arm64` ` docker container
    run diamol/ch16-folder-list:linux-arm`'
- en: The containers print some simple text when they run--a hardcoded string stating
    the OS and architecture they should be using, followed by the actual OS and CPU
    reported by the operating system, and then a folder list containing a single file.
    You can see my output in figure 16.6\. Docker uses emulation where necessary,
    so it uses an Arm emulator when running the Arm-32 and Arm-64 Linux variants in
    this case.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在运行时打印一些简单的文本--一个硬编码的字符串，声明它们应该使用的操作系统和架构，然后是操作系统报告的实际操作系统和 CPU，接着是一个包含单个文件的文件夹列表。您可以在图
    16.6 中看到我的输出。Docker 在必要时使用仿真，所以在这种情况下，它使用 Arm 模拟器来运行 Arm-32 和 Arm-64 Linux 变体。
- en: '![](../Images/16-6.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16-6.jpg)'
- en: Figure 16.6 Images are built for a specific architecture but Docker Desktop
    supports emulation too.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.6 镜像是为特定架构构建的，但 Docker Desktop 也支持仿真。
- en: The Dockerfiles for the Linux variants are all very similar, except for the
    hardcoded string for the expected architecture. The Windows variant has the same
    behavior, but Windows has different commands to print the output. This is where
    multiple Dockerfiles for each architecture become useful; I can have completely
    different Dockerfile instructions but still get the same desired output. Listing
    16.1 compares the Dockerfile for the 64-bit Arm Linux version and the 64-bit Intel
    Windows version.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 变体的 Dockerfile 都非常相似，除了预期的架构的硬编码字符串。Windows 变体具有相同的行为，但 Windows 有不同的命令来打印输出。这就是为什么每个架构的多个
    Dockerfile 都很有用；我可以有完全不同的 Dockerfile 指令，但仍然得到相同期望的输出。列表 16.1 比较了 64 位 Arm Linux
    版本的 Dockerfile 和 64 位 Intel Windows 版本的 Dockerfile。
- en: Listing 16.1 Dockerfiles for Linux and Windows image variants
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16.1 Linux 和 Windows 镜像变体的 Dockerfile
- en: '` # linux` ` FROM diamol/base:linux-arm64`  ` WORKDIR /app` ` COPY file.txt
    .`  ` CMD echo "Built as: linux/arm64" && \` `       uname -a && \` `       ls
    /app` ` # windows` ``  # escape=` `` ` FROM diamol/base:windows-amd64`  ` WORKDIR
    /app` ` COPY file.txt .`  ``  CMD echo Built as: windows/amd64 && ` `` ``        echo
    %PROCESSOR_ARCHITECTURE% %PROCESSOR_IDENTIFIER% && ` `` `         dir /B C:\app`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '` # linux` ` FROM diamol/base:linux-arm64`  ` WORKDIR /app` ` COPY file.txt
    .`  ` CMD echo "Built as: linux/arm64" && \` `       uname -a && \` `       ls
    /app` ` # windows` ``  # escape=` `` ` FROM diamol/base:windows-amd64`  ` WORKDIR
    /app` ` COPY file.txt .`  ``  CMD echo Built as: windows/amd64 && ` `` ``        echo
    %PROCESSOR_ARCHITECTURE% %PROCESSOR_IDENTIFIER% && ` `` `         dir /B C:\app`'
- en: Each version starts with a different `FROM` image, which is specific to the
    target architecture rather than a multi-arch image. The Windows Dockerfile uses
    the `escape` keyword to change the line-break character, changing it to a backtick
    instead of the default backslash, so I can use backslashes in directory paths.
    There’s no Windows equivalent of the Linux `uname` command, so to print the CPU
    architecture I echo out some environment variables that Windows sets. The functionality
    is broadly the same, but I can take a different path to get there because this
    is a Windows-specific Dockerfile.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每个版本都从一个不同的 `FROM` 镜像开始，这个镜像针对的是目标架构，而不是多架构镜像。Windows Dockerfile 使用 `escape`
    关键字来更改换行符，将其更改为反引号而不是默认的反斜杠，这样我就可以在目录路径中使用反斜杠。Windows 没有与 Linux `uname` 命令等效的命令，所以为了打印
    CPU 架构，我输出了 Windows 设置的一些环境变量。功能大致相同，但我可以采取不同的路径来实现，因为这是一个特定于 Windows 的 Dockerfile。
- en: You typically need multiple Dockerfiles if you want to build a multi-arch version
    of a third-party app. The Prometheus and Grafana golden images for this book are
    good examples. The project team publishes multi-arch images for all the Linux
    variants I want to use, but not for Windows. So I have a Linux Dockerfile that
    is based on the project image and a Windows Dockerfile that installs the app from
    a web download. For your own apps it should be easy to have a single Dockerfile
    and avoid the extra maintenance, but you need to be careful that you only use
    a subset of OS commands that you know work in all the target architectures. It’s
    easy to accidentally include a command (like `uname` ) that doesn’t work on one
    architecture and end up with a broken variant.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要构建第三方应用的多架构版本，通常需要多个Dockerfile。本书中Prometheus和Grafana的黄金镜像就是很好的例子。项目团队发布了所有我想使用的Linux变体的多架构镜像，但没有为Windows发布。因此，我有一个基于项目镜像的Linux
    Dockerfile和一个从网络下载安装应用的Windows Dockerfile。对于你自己的应用，应该很容易有一个单一的Dockerfile并避免额外的维护，但你需要小心，只使用你知道在所有目标架构上都能工作的操作系统命令子集。很容易不小心包含一个在某个架构上不工作的命令（比如`uname`），最终导致一个损坏的版本。
- en: Try it now There’s one other Dockerfile for the folder-list app, which is an
    attempt at a multi-arch Dockerfile. It uses a multi-arch image as the base, but
    it mixes Linux and Windows commands, so the image it builds will fail on every
    architecture.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：对于文件夹列表应用程序，还有一个Dockerfile，它尝试创建一个多架构Dockerfile。它使用多架构镜像作为基础，但它混合了Linux和Windows命令，因此构建的镜像将在每个架构上都会失败。
- en: '` # build the multi-arch app:` ` docker image build -t diamol/ch16-folder-list
    .`  ` # and try to run it:` ` docker container run diamol/ch16-folder-list`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 构建多架构应用：` ` docker image build -t diamol/ch16-folder-list .`  ` # 尝试运行它：`
    ` docker container run diamol/ch16-folder-list`'
- en: You’ll find that the build completes successfully, so it looks like you have
    a good image, but the container will fail every time you run it. You can see my
    output in figure 16.7--I ran both Linux and Windows versions of the image, and
    both containers fail because the `CMD` instruction contains invalid commands.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现构建过程成功完成，看起来你有一个好的镜像，但每次运行容器时都会失败。你可以看到我在图16.7中的输出——我运行了镜像的Linux和Windows版本，但两个容器都失败了，因为`CMD`指令包含无效的命令。
- en: '![](../Images/16-7.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图16-7](../Images/16-7.jpg)'
- en: Figure 16.7 It’s easy to build a multi-arch image that fails at runtime on some
    platforms.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7 构建一个在部分平台上运行时失败的多架构镜像很容易。
- en: It’s important to bear this in mind, especially if you use complex startup scripts.
    `RUN` instructions will fail at build time if you use an unknown OS command, but
    `CMD` instructions aren’t verified, so you won’t know the image is broken until
    you try to run a container.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点很重要，尤其是如果你使用复杂的启动脚本。如果你使用未知的操作系统命令，`RUN`指令将在构建时失败，但`CMD`指令不会被验证，所以你不知道镜像已损坏，直到你尝试运行一个容器。
- en: One last thing here before we go on to push multi-arch images, and that’s to
    understand which architectures Docker supports, and the various strange codenames
    you’ll encounter when you start using them. Table 16.1 shows the major OS and
    architecture combinations and aliases for the CPU.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续推进多架构镜像之前，有一件最后的事情需要了解，那就是要明白Docker支持哪些架构，以及当你开始使用它们时可能会遇到的各个奇怪的代号。表16.1显示了主要的操作系统和CPU架构组合及其别名。
- en: Table 16.1 Architectures supported by Docker, with their code names
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 表16.1 Docker支持的架构及其代号
- en: '| OS | CPU | Word Length | CPU Name | CPU Aliases |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| OS | CPU | 字长 | CPU名称 | CPU别名 |'
- en: '| Windows | Intel/AMD | 64-bit | amd64 | x86_64 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| Windows | Intel/AMD | 64位 | amd64 | x86_64 |'
- en: '| Linux | Intel/AMD | 64-bit | amd64 | x86_64 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| Linux | Intel/AMD | 64位 | amd64 | x86_64 |'
- en: '| Linux | Arm | 64-bit | arm64 | aarch64, armv8 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| Linux | Arm | 64位 | arm64 | aarch64, armv8 |'
- en: '| Linux | Arm | 32-bit | arm | arm32v7, armv7, armhf |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| Linux | Arm | 32位 | arm | arm32v7, armv7, armhf |'
- en: Docker supports many more architectures, but these are the main ones you’ll
    find. The amd64 CPU type is the same instruction set in Intel and AMD machines
    that powers practically every desktop, server, and laptop computer (Docker also
    supports 32-bit Intel x86 processors). 32-bit and 64-bit Arm CPUs are found in
    phones, IoT devices, and single-board computers; the most famous is the Raspberry
    Pi, which was 32-bit up until the release of the Pi4, which is 64-bit. Mainframe
    users aren’t left out either--Docker supports IBM CPU architectures for Linux,
    so if you have an IBM Z, POWER, or PowerPC machine in your basement, you can migrate
    your mainframe apps to Docker containers too.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Docker支持许多其他架构，但这些都是您会发现的主要架构。amd64 CPU类型是Intel和AMD机器中相同的指令集，为几乎所有桌面、服务器和笔记本电脑提供动力（Docker还支持32位Intel
    x86处理器）。32位和64位Arm CPU存在于手机、物联网设备和单板计算机中；最著名的是树莓派，直到Pi4发布之前都是32位的，Pi4是64位的。大型机用户也不会被排除在外——Docker支持Linux的IBM
    CPU架构，所以如果您在地下室有一台IBM Z、POWER或PowerPC机器，您也可以将大型机应用程序迁移到Docker容器中。
- en: 16.3 Pushing multi-arch images to registries with manifests
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.3 将多架构图像推送到带有清单的注册表
- en: You can build Linux images for different CPU architectures using Docker Desktop,
    but they don’t become multi-arch images until you push them to a registry along
    with a manifest. The manifest is a piece of metadata that links multiple image
    variants to the same image tag. Manifests are generated using the Docker command
    line and pushed to a registry. The manifest contains a list of all the image variants,
    and they need to exist on the registry first, so the workflow is to create and
    push all the images, and then create and push the manifest.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Docker Desktop构建不同CPU架构的Linux图像，但它们只有在您将它们与清单一起推送到注册表时才成为多架构图像。清单是一块元数据，它将多个图像变体链接到相同的图像标签。清单使用Docker命令行生成并推送到注册表。清单包含所有图像变体的列表，它们需要首先存在于注册表中，因此工作流程是创建和推送所有图像，然后创建和推送清单。
- en: 'Try it now Push the image variants of the folder-list app you’ve built. First
    you’ll need to tag them with your Docker Hub ID so you can push them to your account--you
    don’t have permission to push to the diamol organization:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试吧！推送您构建的文件夹列表应用的图像变体。首先，您需要用您的Docker Hub ID标记它们，以便将它们推送到您的账户——您没有权限将图像推送到diamol组织：
- en: '` # store your Docker ID in a variable - on Windows:` ` $dockerId = ''<your-docker-hub-id>''` 
    ` # or on Linux:` ` dockerId=''<your-docker-hub-id>''`  ` # tag the images with
    your own account name:` ` docker image tag diamol/ch16-folder-list:linux-amd64
    "$dockerId/ch16-folder-list:linux-amd64"` ` docker image tag diamol/ch16-folder-list:linux-arm64
    "$dockerId/ch16-folder-list:linux-arm64"` ` docker image tag diamol/ch16-folder-list:linux-arm
    "$dockerId/ch16-folder-list:linux-arm"`  ` # and push to Docker Hub (this pushes
    all the tags for the image):` ` docker image push "$dockerId/ch16-folder-list"`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 将您的Docker ID存储在一个变量中 - 在Windows上：` ` $dockerId = ''<your-docker-hub-id>''` 
    ` # 或者Linux上：` ` dockerId=''<your-docker-hub-id>''`  ` # 使用您自己的账户名称标记图像：` ` docker
    image tag diamol/ch16-folder-list:linux-amd64 "$dockerId/ch16-folder-list:linux-amd64"`
    ` docker image tag diamol/ch16-folder-list:linux-arm64 "$dockerId/ch16-folder-list:linux-arm64"`
    ` docker image tag diamol/ch16-folder-list:linux-arm "$dockerId/ch16-folder-list:linux-arm"` 
    ` # 并推送到Docker Hub（这将推送图像的所有标签）:` ` docker image push "$dockerId/ch16-folder-list"`'
- en: You’ll see all your images get pushed to Docker Hub. Docker registries are architecture-agnostic--the
    image specification is the same for all architectures, and the registry stores
    them all in the same way. Registries do know which architecture an image was built
    for, and they provide that to the Docker Engine as a check before it pulls them.
    My output is in figure 16.8--the architecture for each image is stored in the
    image metadata. I’ve included it in the tags too, but that’s not a requirement.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到所有图像都推送到Docker Hub。Docker注册表与架构无关——图像规范对所有架构都是相同的，并且注册表以相同的方式存储它们。注册表知道图像是为哪个架构构建的，并在它们被拉取之前将其提供给Docker
    Engine作为检查。我的输出在图16.8中——每个图像的架构存储在图像元数据中。我也将其包含在标签中，但这不是必需的。
- en: '![](../Images/16-8.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16-8.jpg)'
- en: Figure 16.8 Pushing all the image variants is the first stage in making a multi-arch
    image available.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8 推送所有图像变体是使多架构图像可用的第一阶段。
- en: Managing Docker manifests is a feature of the command line, but it’s a new addition,
    so you need to enable experimental features. The CLI and the Docker Engine both
    support experimental features, but you have to explicitly opt-in to use them.
    Your engine may already be using them, but you need to enable them for the client
    too. You can do that in the settings on Docker Desktop, or on the command line
    for the Docker Engine.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 管理 Docker 清单是命令行的一个功能，但它是一个新功能，因此您需要启用实验性功能。CLI 和 Docker 引擎都支持实验性功能，但您必须明确选择才能使用它们。您的引擎可能已经在使用它们，但您还需要为客户端启用它们。您可以在
    Docker Desktop 的设置中这样做，或者对于 Docker 引擎在命令行上这样做。
- en: Try it now If you’re using Docker Desktop, open Settings from the whale menu
    and navigate to the Command Line section. Toggle the Enable Experimental Features
    flag, as in figure 16.9.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 如果您使用 Docker Desktop，从鲸鱼菜单打开设置，并导航到命令行部分。切换启用实验性功能标志，如图 16.9 所示。
- en: '![](../Images/16-9.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 16-9](../Images/16-9.jpg)'
- en: Figure 16.9 Enabling experimental features for the CLI unlocks the Docker manifest
    commands.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.9 启用 CLI 的实验性功能解锁了 Docker 清单命令。
- en: 'If you’re using Docker Community Engine (or Enterprise Engine), edit or create
    the CLI config file from your home directory: `~/.docker/config.json` . You just
    need one setting:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Docker Community Engine（或企业引擎），从您的家目录编辑或创建 CLI 配置文件：`~/.docker/config.json`。您只需要一个设置：
- en: '` { "experimental":"enabled" }`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '` { "experimental":"enabled" }`'
- en: Now that your CLI is in experimental mode, you’ve unlocked `docker` `manifest`
    commands that you can use to create manifests locally, push them to a registry,
    and also inspect existing manifests on a registry. Inspecting manifests is a great
    way to see what architectures an image supports without having to navigate the
    Docker Hub UI. You don’t need to have pulled any of the images locally--the command
    reads all the metadata from the registry.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的 CLI 处于实验模式，您已经解锁了 `docker` `manifest` 命令，您可以使用这些命令在本地创建清单，将它们推送到注册表，并且还可以检查注册表上现有的清单。检查清单是查看图像支持哪些架构的好方法，而无需导航
    Docker Hub UI。您不需要在本地拉取任何图像--该命令会从注册表中读取所有元数据。
- en: 'try it now Verify that your CLI is working for manifest commands by checking
    the published manifest of the base image for this book:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 通过检查本书基础图像的已发布清单来验证您的 CLI 是否适用于清单命令：
- en: '` docker manifest inspect diamol/base`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker manifest inspect diamol/base`'
- en: The `manifest` `inspect` command doesn’t have a filter argument--you can’t limit
    the output. It will show you all the image manifests for the image tag, so it
    works with single images as well as multi-arch images. In the output you see each
    image’s unique digest, along with the CPU architecture and operating system. My
    output is in figure 16.10\. I used the `jq` command to filter the output, but
    that’s just to make it easier to read; you don’t need to do that yourself.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`manifest` `inspect` 命令没有过滤器参数--您无法限制输出。它将显示所有图像清单，因此它适用于单个图像以及多架构图像。在输出中，您可以看到每个图像的唯一摘要，以及
    CPU 架构和操作系统。我的输出在图 16.10 中。我使用了 `jq` 命令来过滤输出，但这只是为了更容易阅读；您不需要自己这样做。'
- en: '![](../Images/16-10.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 16-10](../Images/16-10.jpg)'
- en: Figure 16.10 Multi-arch images have several manifests; each contains the architecture
    of the image.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.10 多架构图像有几个清单；每个清单都包含图像的架构。
- en: Now you can create the manifest, and just like images, it will exist on your
    local machine first and then you’ll push it up to the registry. Technically what
    you’re creating is a manifest list, which groups together a set of images under
    a single image tag. Every image already has its own manifest that you can inspect
    from the registry, but if multiple manifests are returned, you’ll have a multi-architecture
    image. Figure 16.11 shows the relationship between images, manifests, and manifest
    lists.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以创建清单，就像图像一样，它首先存在于您的本地机器上，然后您将其推送到注册表。从技术上讲，您正在创建的是一个清单列表，它将一组图像组合在单个图像标签下。每个图像都已经有一个清单，您可以从注册表中检查它，但如果返回多个清单，您将有一个多架构图像。图
    16.11 显示了图像、清单和清单列表之间的关系。
- en: '![](../Images/16-11.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 16-11](../Images/16-11.jpg)'
- en: Figure 16.11 Manifests and manifest lists exist on a Docker registry and contain
    metadata about images.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.11 清单和清单列表存在于 Docker 注册表中，并包含有关图像的元数据。
- en: You can think of a manifest list as a list of image tags, and the name of the
    manifest list as the name of the multi-arch image. The images you’ve built so
    far all have tags to identify the OS and CPU; you can create a manifest using
    the same image name without a tag, and that will be available as a multi-arch
    image using the default `latest` tag. You could also push your images with a tag
    that includes a version number in addition to the OS and CPU, and then the multi-arch
    tag would just be the version number.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将清单列表视为镜像标签列表，清单列表的名称即为多架构镜像的名称。你迄今为止构建的所有镜像都有标签来标识操作系统和 CPU；你可以使用不带标签的相同镜像名称创建清单，这将作为使用默认
    `latest` 标签的多架构镜像可用。你也可以使用包含版本号（除操作系统和 CPU 之外）的标签推送你的镜像，然后多架构标签将只是版本号。
- en: try it now Create a manifest to link all the Linux variants, and then push it
    to Docker Hub. The name of the manifest becomes the image tag of the multi-arch
    image.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 创建一个清单以链接所有 Linux 变体，并将其推送到 Docker Hub。清单的名称成为多架构镜像的镜像标签。
- en: '` # create a manifest with a name, followed by all the tags it lists:` ` docker
    manifest create "$dockerId/ch16-folder-list" "$dockerId/ch16-folder-list:linux-amd64"
    "$dockerId/ch16-folder-list:linux-arm64" "$dockerId/ch16-folder-list:linux-arm"` 
    ` # push the manifest to Docker Hub:` ` docker manifest push "$dockerId/ch16-folder-list"` 
    ` # now browse to your page on Docker Hub and check the image`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 创建一个包含名称和所有标签的清单：` ` docker manifest create "$dockerId/ch16-folder-list"
    "$dockerId/ch16-folder-list:linux-amd64" "$dockerId/ch16-folder-list:linux-arm64"
    "$dockerId/ch16-folder-list:linux-arm"`  ` # 将清单推送到 Docker Hub：` ` docker manifest
    push "$dockerId/ch16-folder-list"`  ` # 现在浏览到 Docker Hub 上的你的页面并检查镜像`'
- en: You’ll find when you browse to the image on Docker Hub that there’s a `latest`
    tag with multiple variants--the UI shows the OS and CPU architecture, and the
    digest that uniquely identifies each image. Anyone with a Linux Docker Engine
    can run a container from that image, and it will run the amd64 variant on an Intel
    or AMD machine, the arm64 variant on an AWS A1 machine or the latest Raspberry
    Pi, and the arm variant on older Pis. You can see my repo on Docker Hub in figure
    16.12.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你浏览到 Docker Hub 上的镜像时，你会发现有一个 `latest` 标签，包含多个变体——UI 显示操作系统和 CPU 架构，以及唯一标识每个镜像的摘要。任何拥有
    Linux Docker 引擎的人都可以从这个镜像运行容器，它将在英特尔或 AMD 机器上运行 amd64 变体，在 AWS A1 机器或最新的树莓派上运行
    arm64 变体，以及在较旧的 Pi 上运行 arm 变体。你可以在图 16.12 中看到我在 Docker Hub 上的仓库。
- en: '![](../Images/16-12.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16-12.jpg)'
- en: Figure 16.12 A multi-arch image has a single name but many variants. Docker
    Hub shows all the variants.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.12 多架构镜像具有单个名称但许多变体。Docker Hub 显示所有变体。
- en: These Arm images were built with emulation in Docker Desktop, and that’s only
    really viable for occasional builds. Emulation is slow, and not every instruction
    works in the same way under emulation as it does in a real CPU. If you want to
    support multi-arch images and you want builds to be fast and 100% accurate for
    the target CPU, you need a build farm. That’s what I have to build the images
    in this book--a handful of single-board computers with different CPU architectures,
    set up with all the operating systems I want to support. My Jenkins jobs connect
    to the Docker Engine on each machine to build an image variant for each architecture
    and push it to Docker Hub, and then the job creates and pushes the manifest.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 Arm 镜像是使用 Docker Desktop 中的模拟构建的，这仅适用于偶尔的构建。模拟很慢，并且不是每个指令在模拟中的工作方式都与在真实 CPU
    中相同。如果你想支持多架构镜像，并且希望构建快速且针对目标 CPU 100% 准确，你需要一个构建农场。这就是我在本书中构建镜像的原因——几块具有不同 CPU
    架构的单板计算机，配置了我要支持的所有操作系统。我的 Jenkins 作业连接到每台机器上的 Docker 引擎，为每个架构构建一个镜像变体并将其推送到 Docker
    Hub，然后作业创建并推送清单。
- en: 16.4 Building multi-arch images with Docker Buildx
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.4 使用 Docker Buildx 构建多架构镜像
- en: There’s another way to run a Docker build farm that is more efficient and far
    easier to use, and that’s with a new feature of Docker called Buildx. Buildx is
    an extended version of the Docker build commands, and it uses a new build engine
    that is heavily optimized to improve build performance. It still uses Dockerfiles
    as the input and produces images as the output, so you can use it as a straight
    replacement for `docker` `image` `build` . Buildx really shines for cross-platform
    builds, though, because it integrates with Docker contexts, and it can distribute
    builds across multiple servers with a single command.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Docker 构建农场还有另一种更高效且更易于使用的方法，那就是使用 Docker 的新功能 Buildx。Buildx 是 Docker 构建命令的扩展版本，它使用一个新的构建引擎，该引擎经过大量优化以提高构建性能。它仍然使用
    Dockerfile 作为输入并生成镜像作为输出，因此您可以使用它作为 `docker` `image` `build` 的直接替代品。Buildx 在跨平台构建方面表现尤为出色，因为它与
    Docker 上下文集成，并且可以通过单个命令在多个服务器之间分配构建。
- en: Buildx doesn’t work with Windows containers right now, and it only supports
    building from a single Dockerfile, so it won’t cover every scenario (I can’t use
    it for building the images for this book). But if you only need to support CPU
    variants for Linux, it works very nicely. You use Buildx to create and manage
    the build farm, as well as for building images.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Buildx 目前不支持 Windows 容器，并且它只支持从单个 Dockerfile 构建，因此它不会涵盖每个场景（我无法用它来构建这本书的镜像）。但如果您只需要支持
    Linux 的 CPU 变体，它工作得非常好。您可以使用 Buildx 创建和管理构建农场，以及构建镜像。
- en: We’ll walk through a full end-to-end example using Play with Docker so you can
    try out a real distributed build farm. The first step is to create a Docker context
    for each node in the build farm.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Play with Docker 进行一个完整的端到端示例，这样您就可以尝试一个真实的分布式构建农场。第一步是为构建农场中的每个节点创建一个
    Docker 上下文。
- en: 'Try it now Start by setting up your PWD session. Browse to *[https://play-with-docker.com](https://play-with-docker.com)*
    and add two instances to your session. We’ll use node1 for all commands. First
    store the IP address of node2 and verify the SSH connection; then create contexts
    for node1 and node2:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下，首先设置您的 PWD 会话。浏览到 *[https://play-with-docker.com](https://play-with-docker.com)*
    并将两个实例添加到您的会话中。我们将使用 node1 来执行所有命令。首先存储 node2 的 IP 地址并验证 SSH 连接；然后为 node1 和 node2
    创建上下文：
- en: '` # store the IP address of node2:` ` node2ip=<your-node-2-ip>`  ` # verify
    the ssh connection:` ` ssh $node2ip`  ` #then exit so you''re back in node1` ` exit` 
    ` # create a context for node1 using the local socket:` ` docker context create
    node1 --docker "host=unix:///var/run/docker.sock"`  ` # and a context for node2
    using SSH:` ` docker context create node2 --docker "host=ssh://root@$node2ip"` 
    ` # check the contexts are there:` ` docker context ls`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 存储 node2 的 IP 地址：` ` node2ip=<your-node-2-ip>`  ` # 验证 ssh 连接：` ` ssh $node2ip` 
    ` # 然后 exit 以返回到 node1` ` exit`  ` # 使用本地套接字为 node1 创建上下文：` ` docker context create
    node1 --docker "host=unix:///var/run/docker.sock"`  ` # 使用 SSH 为 node2 创建上下文：`
    ` docker context create node2 --docker "host=ssh://root@$node2ip"`  ` # 检查上下文是否存在：`
    ` docker context ls`'
- en: Those contexts are there to make the Buildx setup easier. You can see my output
    in figure 16.13--node1 is the client where I’ll run Buildx, so it uses the local
    channel, and it’s configured to connect to node2 over SSH.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些上下文是为了使 Buildx 设置更简单。您可以在图 16.13 中看到我的输出--node1 是我将运行 Buildx 的客户端，因此它使用本地通道，并且配置为通过
    SSH 连接到 node2。
- en: '![](../Images/16-13.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16-13.jpg)'
- en: Figure 16.13 Buildx can use Docker contexts to set up a build farm, so creating
    contexts is the first step.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.13 Buildx 可以使用 Docker 上下文来设置构建农场，因此创建上下文是第一步。
- en: Setting up your contexts is the first step in creating a build farm. In a real
    environment your automation server would be the Buildx client, so you’d create
    your Docker contexts in Jenkins (or whichever system you use). You’d have one
    or more machines for every architecture you want to support, and you’d create
    a Docker context for each of them. The machines don’t need to be clustered with
    Swarm or Kubernetes; they can be standalone machines just used for building images.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 设置您的上下文是创建构建农场的第一步。在实际环境中，您的自动化服务器将是 Buildx 客户端，因此您会在 Jenkins（或您使用的任何系统）中创建
    Docker 上下文。您将拥有一个或多个机器来支持您想要支持的每个架构，并且您将为它们中的每一个创建一个 Docker 上下文。这些机器不需要与 Swarm
    或 Kubernetes 集群；它们可以是仅用于构建镜像的独立机器。
- en: Next you need to install and configure Buildx. Buildx is a Docker CLI plugin--the
    client is already installed in Docker Desktop and the latest Docker CE releases
    (you can check by running `docker` `buildx` ). PWD doesn’t have Buildx, so we’ll
    need to manually install it and then set up a builder that uses both our nodes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要安装和配置 Buildx。Buildx 是一个 Docker CLI 插件——客户端已经安装在 Docker Desktop 和最新的 Docker
    CE 版本中（您可以通过运行 `docker buildx` 来检查）。PWD 没有Buildx，因此我们需要手动安装它，然后设置一个使用我们两个节点的构建器。
- en: 'Try it now Buildx is a Docker CLI plugin--to use it you need to download the
    binary and add it to your CLI plugins folder:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试 Buildx，这是一个 Docker CLI 插件——要使用它，您需要下载二进制文件并将其添加到您的 CLI 插件文件夹中：
- en: '` # download the latest Buildx binary:` ` wget -O ~/.docker/cli-plugins/docker-buildx
    https://github.com/docker/buildx/releases/download/v0.3.1/buildx-v0.3.1.linux-amd64` 
    ` # set the file to be executable:` ` chmod a+x ~/.docker/cli-plugins/docker-buildx` 
    ` # now the plugin is there, use it to create a builder using node1:` ` docker
    buildx create --use --name ch16 --platform linux/amd64 node1`  ` # and add node2
    to the builder:` ` docker buildx create --append --name ch16 --platform linux/386
    node2`  ` # check the builder setup:` ` docker buildx ls`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '` # 下载最新的 Buildx 二进制文件：` ` wget -O ~/.docker/cli-plugins/docker-buildx https://github.com/docker/buildx/releases/download/v0.3.1/buildx-v0.3.1.linux-amd64` 
    ` # 将文件设置为可执行：` ` chmod a+x ~/.docker/cli-plugins/docker-buildx`  ` # 现在插件已经安装，使用它通过
    node1 创建构建器：` ` docker buildx create --use --name ch16 --platform linux/amd64
    node1`  ` # 并将 node2 添加到构建器中：` ` docker buildx create --append --name ch16 --platform
    linux/386 node2`  ` # 检查构建器设置：` ` docker buildx ls`'
- en: Buildx is very flexible. It discovers potential build nodes using Docker context,
    and it connects to see which platforms they support. You create a builder and
    add nodes to it, and you can either let Buildx work out which platforms each node
    can build, or you can be specific and limit nodes to particular platforms. That’s
    what I’ve done here, so node1 will only build x64 images and node2 will only build
    386 images. You can see that in figure 16.14.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Buildx 非常灵活。它使用 Docker 上下文发现潜在的构建节点，并连接到它们以查看它们支持哪些平台。您创建一个构建器并将其节点添加到其中，您可以让
    Buildx 确定每个节点可以构建的平台，或者您可以具体指定并将节点限制在特定平台上。这就是我在这里所做的那样，所以 node1 将只构建 x64 镜像，而
    node2 将只构建 386 镜像。您可以在图 16.14 中看到这一点。
- en: '![](../Images/16-14.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.14](../Images/16-14.jpg)'
- en: Figure 16.14 Setting up a build farm is easy with Buildx; it uses Docker contexts
    to connect to engines.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Buildx 设置构建农场非常简单；它使用 Docker 上下文连接到引擎。
- en: Now the build farm is ready. It can build multi-arch images that can run as
    32-bit or 64-bit Intel Linux containers, as long as the Dockerfile it’s building
    uses images that support those two architectures. Buildx spins up builds concurrently
    across the builder nodes, sending them the Dockerfile and the folder with the
    Docker build context (which would normally contain your source code). You can
    clone the Git repository for this book in your PWD session and then build and
    push a multi-arch image for this exercise using a single Buildx command.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建农场已经准备好了。它可以构建可以以 32 位或 64 位 Intel Linux 容器运行的多架构镜像，只要构建的 Dockerfile 使用的镜像支持这两种架构。Buildx
    在构建节点上并发启动构建，将 Dockerfile 和包含 Docker 构建上下文的文件夹（通常包含您的源代码）发送给它们。您可以在 PWD 会话中克隆这本书的
    Git 仓库，然后使用单个 Buildx 命令构建和推送此练习的多架构镜像。
- en: 'Try it now Clone the source code and switch to a folder that contains a multi-arch
    Dockerfile for the folder-list app. Build and push multiple variants using Buildx:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试 Buildx。克隆源代码并切换到一个包含文件夹列表应用的多架构 Dockerfile 的文件夹。使用 Buildx 构建和推送多个变体：
- en: '` git clone https://github.com/sixeyed/diamol.git` ` cd diamol/ch16/exercises/folder-list-2/` 
    ` # store your Docker Hub ID and log in so Buildx can push images:` ` dockerId=<your-docker-id>`
    ` docker login -u $dockerId`  ` # use Buildx to build and push both variants using
    node1 and node2:` ` docker buildx build -t "$dockerId/ch16-folder-list-2" --platform
    linux/amd64,linux/386 --push .`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '` git clone https://github.com/sixeyed/diamol.git` ` cd diamol/ch16/exercises/folder-list-2/` 
    ` # 存储您的 Docker Hub ID 并登录，以便 Buildx 可以推送镜像：` ` dockerId=<your-docker-id>` ` docker
    login -u $dockerId`  ` # 使用 Buildx 通过 node1 和 node2 构建和推送两个变体：` ` docker buildx
    build -t "$dockerId/ch16-folder-list-2" --platform linux/amd64,linux/386 --push
    .`'
- en: The output from a Buildx build is impressive--it’s a great thing to have running
    when other people can see your screen. The client shows log lines from each builder
    node, and you get lots of fast output so it looks like you’re doing something
    immensely technical. Actually Buildx does all the work, and you’ll see from the
    output that it even pushes the images, creates the manifest, and pushes the manifest
    for you. Figure 16.15 shows the end of my build and the image tags on Docker Hub.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Buildx构建的输出令人印象深刻--当其他人可以看到你的屏幕时，让它运行是件好事。客户端显示了每个构建节点上的日志行，你得到了大量的快速输出，看起来你正在做一项非常技术性的工作。实际上，Buildx做了所有的工作，你将从输出中看到它甚至为你推送镜像、创建清单并推送清单。图16.15显示了构建的结束和Docker
    Hub上的镜像标签。
- en: '![](../Images/16-15.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/16-15.jpg)'
- en: Figure 16.15 Buildx distributes the Dockerfile and build context, collects logs,
    and pushes images.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.15 Buildx分发Dockerfile和构建上下文，收集日志，并推送镜像。
- en: Buildx makes these multi-arch builds very simple. You supply the nodes for each
    architecture you want to support, and Buildx can use them all, so your build commands
    don’t change whether you’re building for two architectures or 10\. There’s an
    interesting difference with Buildx images on Docker Hub--there are no individual
    image tags for the variants, there’s just the single multi-arch tag. Compare that
    to the previous section where we manually pushed the variants and then added the
    manifest--all the variants had their own tags on Docker Hub, and as you build
    and deploy more image versions, that can get hard for users to navigate. If you
    don’t need to support Windows containers, Buildx is the best way to build multi-arch
    images right now.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Buildx使这些多架构构建变得非常简单。你提供你想要支持的每个架构的节点，Buildx可以使用它们全部，所以无论你是在为两个架构还是十个架构构建，你的构建命令都不会改变。与Docker
    Hub上的Buildx镜像有一个有趣的不同之处--没有为变体设置单独的镜像标签，只有一个单一的多架构标签。与之前我们手动推送变体并添加清单的部分相比--所有变体在Docker
    Hub都有自己的标签，随着你构建和部署更多镜像版本，这可能会让用户难以导航。如果你不需要支持Windows容器，Buildx是目前构建多架构镜像的最佳方式。
- en: 16.5 Understanding where multi-arch images fit in your roadmap
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.5 理解多架构镜像在你的路线图中的位置
- en: Maybe you don’t need multi-arch images right now. That’s fine--thanks for reading
    through this chapter anyway. It’s definitely worth knowing how multi-arch images
    work, and how you can build your own, even if you don’t plan to do that yet, because
    they may well come onto your roadmap. You may take on a project that needs to
    support IoT devices, or you may need to cut cloud running costs, or maybe your
    customers are clamoring for Windows support. Figure 16.16 shows how projects can
    evolve with the need to support multi-arch images, adding more variants over years
    when the need arises.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你现在不需要多架构镜像。没关系--无论如何，感谢你阅读了这一章。了解多架构镜像的工作原理以及如何构建自己的镜像绝对值得，即使你现在还没有计划这么做，因为它们很可能出现在你的路线图中。你可能承担了一个需要支持物联网设备的项目，或者你可能需要削减云运行成本，或者也许你的客户迫切需要Windows支持。图16.16显示了项目如何随着支持多架构镜像的需求而发展，在需要时在多年内添加更多变体。
- en: '![](../Images/16-16.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/16-16.jpg)'
- en: Figure 16.16 Projects launch with Linux Intel support and add variants as they
    become popular.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.16 项目以Linux Intel支持启动，并随着其流行添加变体。
- en: 'You can future-proof yourself and make the switch to multi-arch images easy
    if you stick to two simple rules for all your Dockerfiles: always use multi-arch
    images in your `FROM` instructions, and don’t include any OS-specific commands
    in `RUN` or `CMD` instructions. If you need some complex deployment or startup
    logic, you could build that into a simple utility app using the same language
    as your application, and compile that in another stage of the build.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你坚持为所有Dockerfile遵循两个简单的规则，你可以确保自己的未来兼容性，并使多架构镜像的转换变得简单：在`FROM`指令中始终使用多架构镜像，不要在`RUN`或`CMD`指令中包含任何特定于操作系统的命令。如果你需要一些复杂的部署或启动逻辑，你可以使用与你的应用程序相同的语言构建一个简单的实用程序应用程序，并在构建的另一个阶段进行编译。
- en: All the official images on Docker Hub are multi-arch, so it’s a good idea to
    use those as your base images (or create your own golden base images using the
    official images). All the golden images for this book are multi-arch too, and
    if you’re looking for inspiration you can check the `images` folder in source
    for a large suite of examples. As a rough guide, all the modern application platforms
    support multi-arch (Go, Node.js, .NET Core, Java) and if you’re looking for a
    database, Postgres is the best multi-arch option I’ve found.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub上的所有官方镜像都是多架构的，所以使用这些作为你的基础镜像是一个好主意（或者你可以使用官方镜像创建自己的黄金基础镜像）。本书的所有黄金镜像也都是多架构的，如果你需要灵感，可以检查源代码中的`images`文件夹，那里有一系列大量的示例。作为一个粗略的指南，所有现代的应用平台都支持多架构（Go、Node.js、.NET
    Core、Java），如果你在寻找数据库，Postgres是我找到的最佳多架构选项。
- en: 'There aren’t any managed build services out there that support the full range
    of architectures--some support Linux and Windows, but if you also want Arm you’ll
    need to set that up yourself. You could run a fairly cheap build farm on AWS using
    Linux, Windows, and Arm VMs with Docker installed. If you need Linux and Windows
    but not Arm, you could use a managed service like Azure DevOps or GitHub Actions.
    The important thing is not to assume you’ll never need to support other architectures:
    follow best practices in your Dockerfiles to make multi-arch support easy, and
    know what steps you need to take to evolve your build pipeline if you do need
    to add multi-arch support.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有支持所有架构的托管构建服务——一些支持Linux和Windows，但如果你还需要Arm，你需要自己设置。你可以在AWS上运行一个相当便宜的构建农场，使用安装了Docker的Linux、Windows和Arm虚拟机。如果你需要Linux和Windows但不需要Arm，你可以使用像Azure
    DevOps或GitHub Actions这样的托管服务。重要的是不要假设你永远不会需要支持其他架构：遵循Dockerfile中的最佳实践，使多架构支持变得容易，并且知道如果你确实需要添加多架构支持，你需要采取哪些步骤来演进你的构建管道。
- en: 16.6 Lab
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.6 实验室
- en: 'This chapter’s lab asks you to fix up a Dockerfile so it can be used to produce
    multi-arch images. It’s the sort of thing you may come across if you have a Dockerfile
    that didn’t follow my best-practice suggestions--this Dockerfile is based on an
    image for a specific architecture, and it uses OS commands that are not portable.
    I’d like you to fix the Dockerfile in the lab folder for this chapter so it can
    build an image targeted for Linux on Intel or Arm, and Windows on Intel. There
    are lots of ways to solve this; these are just a couple of hints for you:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的实验要求你修复一个Dockerfile，使其能够用于生成多架构镜像。如果你有一个没有遵循我的最佳实践建议的Dockerfile，你可能会遇到这种情况——这个Dockerfile基于特定架构的镜像，并使用不兼容的操作系统命令。我希望你修复本章实验文件夹中的Dockerfile，使其能够构建针对Linux
    on Intel或Arm，以及Windows on Intel的镜像。解决这个问题有很多方法；这里只是给你提供一些建议：
- en: Some Dockerfile instructions are cross-platform, while equivalent OS commands
    in a `RUN` instruction may not be.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些Dockerfile指令是跨平台的，而`RUN`指令中的等效操作系统命令可能不是。
- en: Some Windows commands are the same as Linux, and in the golden base image for
    the book there are some aliases to make other Linux commands work in Windows.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些Windows命令与Linux相同，在本书的黄金基础镜像中，有一些别名使得其他Linux命令可以在Windows上运行。
- en: 'You’ll find my approach in the `Dockerfile.solution` file on GitHub for the
    chapter: *[https://github.com/sixeyed/diamol/blob/master/ch16/lab/README.md](https://github.com/sixeyed/diamol/blob/master/ch16/lab/README.md)*
    .'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到该章节的`Dockerfile.solution`文件，链接为：*[https://github.com/sixeyed/diamol/blob/master/ch16/lab/README.md](https://github.com/sixeyed/diamol/blob/master/ch16/lab/README.md)*。
