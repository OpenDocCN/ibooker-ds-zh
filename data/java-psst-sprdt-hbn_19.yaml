- en: 15 Working with Spring Data JDBC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15 使用Spring Data JDBC
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Starting a Spring Data JDBC project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始一个Spring Data JDBC项目
- en: Working with queries and query methods in Spring Data JDBC
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Spring Data JDBC中处理查询和查询方法
- en: Building relationships using Spring Data JDBC
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Data JDBC建立关系
- en: Modeling embedded entities with Spring Data JDBC
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Data JDBC建模嵌入式实体
- en: 'We introduced Spring Data in chapter 2: it’s an umbrella project containing
    many projects whose purpose is to simplify access to both relational and NoSQL
    databases by adhering to the Spring framework principles. In chapter 4, we looked
    in detail at the principles and capabilities of the Spring Data JPA project. The
    purpose of Spring Data JDBC is to efficiently deal with JDBC-based repositories.
    It is a younger project in the family, and it does not offer all the JPA capabilities,
    such as caching or lazy loading, resulting in a simpler and more limited ORM.
    However, it is growing and introducing new features with each version.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第二章介绍了Spring Data：它是一个包含许多项目的母项目，这些项目的目的是通过遵循Spring框架原则来简化对关系型数据库和NoSQL数据库的访问。在第四章中，我们详细探讨了Spring
    Data JPA项目的原则和能力。Spring Data JDBC的目的在于高效地处理基于JDBC的仓库。它是这个家族中的较新项目，并且它并不提供所有JPA功能，例如缓存或懒加载，因此它提供了一个更简单、更有限的ORM。然而，它正在不断发展，并在每个版本中引入新功能。
- en: Why would we need Spring Data JDBC, when we already have alternatives such as
    JPA, Hibernate, and Spring Data JPA? The truth is that object/relational mapping
    (ORM) makes projects complex, and you clearly saw this in the previous chapters.
    There are situations when we’ll want to eliminate this complexity and take the
    benefits of working with Spring, the most popular Java framework today. What alternatives
    do we have?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们已经有JPA、Hibernate和Spring Data JPA等替代方案时，为什么还需要Spring Data JDBC呢？事实是，对象/关系映射（ORM）使项目变得复杂，你已经在之前的章节中清楚地看到了这一点。有些情况下，我们可能希望消除这种复杂性，并利用当今最受欢迎的Java框架Spring的好处。我们有什么替代方案？
- en: If we look back to the old-style JDBC, we have to remember its shortcomings,
    such as opening and closing connections by yourself or manually handling exceptions—overall,
    we would have to deal with a lot of service code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾传统的JDBC，我们必须记住它的缺点，比如自己打开和关闭连接或手动处理异常——总的来说，我们不得不处理大量的服务代码。
- en: 'Spring Data JDBC allows us to create our own queries to be executed against
    the database, but it also has its own ORM and uses concepts already used by JPA,
    Hibernate, and Spring Data JPA: entities, repositories, and `@Query` annotations.
    Spring Data JDBC does not use JPQL and there is no portability. Queries must be
    written in plain SQL and be specific to the database vendor. Entity loading must
    be done through SQL queries, and it is either complete or absent. Caching and
    lazy loading are not available. Sessions and dirty tracking do not exist; we have
    to explicitly save entities.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JDBC允许我们创建自己的查询以在数据库上执行，但它也有自己的ORM，并使用JPA、Hibernate和Spring Data
    JPA已经使用的概念：实体、仓库和`@Query`注解。Spring Data JDBC不使用JPQL，也没有可移植性。查询必须以纯SQL编写，并且必须是特定于数据库供应商的。实体加载必须通过SQL查询完成，要么是完整的，要么是不存在的。缓存和懒加载不可用。会话和脏检查不存在；我们必须显式保存实体。
- en: Also, at the time of writing this chapter, Spring Data JDBC does not support
    schema generation. We can declare our entities as we do in Hibernate or Spring
    Data JPA, but the DDL commands need to be written and run.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在撰写本章时，Spring Data JDBC不支持模式生成。我们可以像在Hibernate或Spring Data JPA中那样声明我们的实体，但DDL命令需要编写和运行。
- en: Let’s create a project that uses Spring Data JDBC and analyze its capabilities
    to support us as we introduce new features.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个使用Spring Data JDBC的项目，并分析其能力以支持我们在引入新功能时的需求。
- en: 15.1 Creating a Spring Data JDBC project
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1 创建一个Spring Data JDBC项目
- en: In this chapter, we’ll create an application that will manage and persist CaveatEmptor
    users with Spring Data JDBC as a persistence framework, much like we did using
    Spring Data JPA in chapter 4\. We’ll create a Spring Boot application to use Spring
    Data JDBC.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个应用程序，它将使用Spring Data JDBC作为持久化框架来管理和持久化CaveatEmptor用户，这与我们在第四章中使用Spring
    Data JPA所做的一样。我们将创建一个Spring Boot应用程序来使用Spring Data JDBC。
- en: 'To get started, we’ll use the Spring Initializr website ([https://start.spring.io/](https://start.spring.io/))
    to create a new Spring Boot project (figure 15.1) with the following characteristics:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将使用Spring Initializr网站([https://start.spring.io/](https://start.spring.io/))创建一个新的Spring
    Boot项目（图15.1），具有以下特性：
- en: 'Group: com.manning.javapersistence'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组：com.manning.javapersistence
- en: 'Artifact: spring-data-jdbc'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工件：spring-data-jdbc
- en: 'Description: Spring Data JDBC project'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述：Spring Data JDBC 项目
- en: 'We’ll also add the following dependencies:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加以下依赖项：
- en: Spring Data JDBC (this will add `spring-boot-starter-data-jdbc` in the Maven
    pom.xml file)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data JDBC（这将向 Maven pom.xml 文件中添加 `spring-boot-starter-data-jdbc`）
- en: MySQL Driver (this will add `mysql-connector-java` in the Maven pom.xml file)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 驱动程序（这将向 Maven pom.xml 文件中添加 `mysql-connector-java`）
- en: Note To execute the examples from the source code, you’ll first need to run
    the Ch15.sql script.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要执行源代码中的示例，您首先需要运行 Ch15.sql 脚本。
- en: '![](../../OEBPS/Images/CH15_F01_Tudose2.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH15_F01_Tudose2.png)'
- en: Figure 15.1 Creating a new Spring Boot project using Spring Data JDBC and MySQL
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 使用 Spring Data JDBC 和 MySQL 创建新的 Spring Boot 项目
- en: 'The skeleton of the project contains four files:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 项目骨架包含四个文件：
- en: SpringDataJdbcApplication, including a skeleton `main` method
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SpringDataJdbcApplication，包括一个骨架 `main` 方法
- en: SpringDataJdbcApplicationTests, including a skeleton test method
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SpringDataJdbcApplicationTests，包括一个骨架测试方法
- en: application.properties, which is empty at the beginning
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: application.properties，最初为空
- en: pom.xml, including the management information needed by Maven
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pom.xml，包括 Maven 需要的管理信息
- en: 'The pom.xml file, shown in the following listing, includes the dependencies
    that we added to start the Spring Data JDBC project: we’ll use the Spring Data
    JDBC framework to access a MySQL database, for which we need the driver.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中显示的 pom.xml 文件包括我们添加以启动 Spring Data JDBC 项目的依赖项：我们将使用 Spring Data JDBC
    框架来访问 MySQL 数据库，我们需要该驱动程序。
- en: Listing 15.1 The pom.xml Maven file
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.1 pom.xml Maven 文件
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Ⓐ `spring-boot-starter-data-jdbc` is the starter dependency used by Spring Boot
    to connect to a relational database through Spring Data JDBC.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `spring-boot-starter-data-jdbc` 是 Spring Boot 用于通过 Spring Data JDBC 连接到关系型数据库的启动依赖项。
- en: Ⓑ `mysql-connector-java` is the JDBC driver for MySQL. It is a runtime dependency,
    meaning it is needed in the classpath only at runtime.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `mysql-connector-java` 是 MySQL 的 JDBC 驱动程序。它是一个运行时依赖项，意味着它仅在运行时需要包含在类路径中。
- en: Ⓒ `spring-boot-starter-test` is the Spring Boot starter dependency for testing.
    It is needed only for the test compilation and execution phases.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `spring-boot-starter-test` 是 Spring Boot 用于测试的启动依赖项。它仅在测试编译和执行阶段需要。
- en: The application.properties file can include various properties that will be
    used by the application. Spring Boot will automatically find and load the application.properties
    file from the classpath, and the src/main/resources folder is added by Maven to
    the classpath. As the initialization script is run by default only for embedded
    databases, and we are using MySQL, we’ll have to force the execution of the script
    by setting the initialization mode, `spring.sql.init.mode`, to be `always`. The
    configuration file is shown in the following listing.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: application.properties 文件可以包含应用程序将使用的各种属性。Spring Boot 将自动从类路径中查找并加载 application.properties
    文件，并且 Maven 将 src/main/resources 文件夹添加到类路径中。由于初始化脚本默认仅对嵌入式数据库运行，而我们使用的是 MySQL，因此我们必须通过设置初始化模式
    `spring.sql.init.mode` 为 `always` 来强制执行脚本。配置文件如下所示。
- en: Listing 15.2 The application.properties file
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.2 application.properties 文件
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ⓐ The URL of the database.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 数据库的 URL。
- en: Ⓑ The credentials to access the database. Replace them with the credentials
    on your machine, and use a password in real life.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 访问数据库的凭证。请用您机器上的凭证替换它们，并在实际生活中使用密码。
- en: Ⓒ The dialect of the database, MySQL.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 数据库方言，MySQL。
- en: Ⓓ The SQL initialization mode is `always`, so the SQL file will be always executed,
    recreating the database schema.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ SQL 初始化模式是 `always`，因此 SQL 文件将始终执行，重新创建数据库模式。
- en: The SQL script that is automatically executed will look like the one in the
    following listing, dropping and recreating the `USERS` table. At startup, Spring
    Boot will always execute the schema.sql and data.sql files on the classpath.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 自动执行的 SQL 脚本将类似于以下列表中的脚本，删除并重新创建 `USERS` 表。在启动时，Spring Boot 将始终执行类路径中的 schema.sql
    和 data.sql 文件。
- en: Listing 15.3 The schema.sql file
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.3 schema.sql 文件
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We’ll now define the entity class corresponding to the `USERS` table as demonstrated
    in listing 15.4\. We’ll use some Spring-specific annotations to configure how
    the class is mapped to the table in the database:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义与 `USERS` 表对应的实体类，如下列 15.4 所示。我们将使用一些特定的 Spring 注解来配置类如何映射到数据库中的表：
- en: '`org.springframework.data.relational.core.mapping.Table`—This is different
    from the previously used `javax.persistence.Table`, which is JPA-specific.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.data.relational.core.mapping.Table`——这与之前使用的 `javax.persistence.Table`
    不同，后者是 JPA 特有的。'
- en: '`org.springframework.data.annotation.Id`—This is different from the previously
    used `javax.persistence.Id`, which is JPA-specific. We defined the corresponding
    column in the database as `ID` `INTEGER` `AUTO_INCREMENT` `PRIMARY` `KEY`, so
    the database will take care of generating the auto-incremented values.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.data.annotation.Id`——这与之前使用的 `javax.persistence.Id` 不同，后者是
    JPA 特有的。我们在数据库中定义了相应的列作为 `ID` `INTEGER` `AUTO_INCREMENT` `PRIMARY` `KEY`，因此数据库将负责生成自动递增的值。'
- en: '`org.springframework.data.relational.core.mapping.Column`—This is dif-ferent
    from the previously used `javax.persistence.Column`, which is JPA-specific. For
    the column names, Spring Data JDBC will convert the camel case used for the definition
    of class fields into the snake case used for the definition of table columns.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.data.relational.core.mapping.Column`——这与之前使用的 `javax.persistence.Column`
    不同，后者是 JPA 特有的。对于列名，Spring Data JDBC 将将类字段定义中使用的驼峰式转换为表列定义中使用的蛇形命名。'
- en: Listing 15.4 The `User` class
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.4 `User` 类
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Ⓐ Annotate the `User` class with the `@Table` annotation, explicitly indicating
    that the corresponding table is `USERS`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 使用 `@Table` 注解标注 `User` 类，明确指出对应的表是 `USERS`。
- en: Ⓑ Annotate the `id` field with the `@Id` annotation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 使用 `@Id` 注解标注 `id` 字段。
- en: Ⓒ Annotate the `id` field with the `@Column("ID")` annotation, specifying the
    corresponding column in the database. This is the default value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 使用 `@Column("ID")` 注解标注 `id` 字段，指定数据库中的对应列。这是默认值。
- en: Ⓓ Annotate the username field with the `@Column("USERNAME")` annotation, specifying
    the corresponding column in the database. This is the default value.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 使用 `@Column("USERNAME")` 注解标注用户名字段，指定数据库中的对应列。这是默认值。
- en: Ⓔ Annotate the `registrationDate` field with the `@Column("REGISTRATION_DATE")`
    annotation, specifying the corresponding column in the database. This is the default
    value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 使用 `@Column("REGISTRATION_DATE")` 注解标注 `registrationDate` 字段，指定数据库中的对应列。这是默认值。
- en: We’ll also create the `UserRepository` interface that extends `CrudRepository`
    and thus provides access to the database.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个扩展 `CrudRepository` 的 `UserRepository` 接口，从而提供对数据库的访问。
- en: Listing 15.5 The `UserRepository` interface
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.5 `UserRepository` 接口
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `UserRepository` interface extends `CrudRepository<User,` `Long>`. This
    means that it is a repository of `User` entities, having a `Long` identifier.
    Remember, the `User` class has an `id` field annotated as `@Id` of type `Long`.
    We can directly call methods such as `save`, `findAll``,` or `findById`, inherited
    from `CrudRepository`, and we can use them without any other additional information
    to execute the usual operations against a database. Spring Data JDBC will create
    a proxy class implementing the `UserRepository` interface and implement its methods.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserRepository` 接口扩展了 `CrudRepository<User, Long>`。这意味着它是一个 `User` 实体仓库，具有
    `Long` 标识符。记住，`User` 类有一个被标注为 `@Id` 的 `id` 字段，类型为 `Long`。我们可以直接调用从 `CrudRepository`
    继承的方法，如 `save`、`findAll` 或 `findById`，而无需任何其他附加信息即可执行对数据库的常规操作。Spring Data JDBC
    将创建一个实现 `UserRepository` 接口的代理类并实现其方法。'
- en: 'Note It is worth recalling what we mentioned in section 4.3: `CrudRepository`
    is a generic technology-agnostic persistence interface that we can use not only
    for JPA/relational databases, as you’ve seen so far.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：值得回顾我们在第4.3节中提到的内容：“`CrudRepository` 是一种通用的、与技术无关的持久化接口，我们不仅可以用于 JPA/关系数据库，正如你迄今为止所看到的。”
- en: We are only overriding the `findAll` method so that it returns `List<User>`
    instead of `Iterable<User>`. This will simplify our future tests. As a base class
    for all future tests, we’ll write the `SpringDataJdbcApplicationTests` abstract
    class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只重写了 `findAll` 方法，使其返回 `List<User>` 而不是 `Iterable<User>`。这将简化我们未来的测试。作为所有未来测试的基类，我们将编写
    `SpringDataJdbcApplicationTests` 抽象类。
- en: The `@SpringBootTest` annotation, added by Spring Boot to the initially created
    class, will tell Spring Boot to search the main configuration class (the `@SpringBootApplication`
    annotated class, for instance) and create the `ApplicationContext` to be used
    in the tests. As you’ll recall, the `@SpringBootApplication` annotation added
    by Spring Boot to the class containing the `main` method will enable the Spring
    Boot autoconfiguration mechanism, enable the scan on the package where the application
    is located, and allow us to register extra beans in the context.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot添加到最初创建的类的`@SpringBootTest`注解将告诉Spring Boot搜索主配置类（例如，被`@SpringBootApplication`注解的类），并创建用于测试的`ApplicationContext`。如您所回忆的，Spring
    Boot添加到包含`main`方法的类的`@SpringBootApplication`注解将启用Spring Boot自动配置机制，允许扫描应用程序所在的包，并允许我们在上下文中注册额外的bean。
- en: Using the `@TestInstance(TestInstance.Lifecycle.PER_CLASS)` annotation, we’ll
    ask JUnit 5 to create a single instance of the test class and reuse it for all
    test methods. This will allow us to make the `@BeforeAll` and `@AfterAll` annotated
    methods non-static and to directly use inside them the autowired `UserRepository`
    instance field. The `@BeforeAll` annotated non-static method is executed once
    before all tests from any class extending `SpringDataJdbcApplicationTests`, and
    it saves the list of users created inside the `generateUsers` method to the database.
    The `@AfterAll` annotated non-static method is executed once after all tests from
    any class extending `SpringDataJdbcApplicationTests`, and it deletes all users
    from the database.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@TestInstance(TestInstance.Lifecycle.PER_CLASS)`注解，我们将要求JUnit 5创建一个测试类的单个实例，并为其所有测试方法重用。这将允许我们将`@BeforeAll`和`@AfterAll`注解的方法设置为非静态，并直接在它们内部使用自动装配的`UserRepository`实例字段。被`@BeforeAll`注解的非静态方法将在所有扩展`SpringDataJdbcApplicationTests`的类的测试之前执行一次，并将`generateUsers`方法内部创建的用户列表保存到数据库中。被`@AfterAll`注解的非静态方法将在所有扩展`SpringDataJdbcApplicationTests`的类的测试之后执行一次，并将从数据库中删除所有用户。
- en: Listing 15.6 The `SpringDataJdbcApplicationTests` abstract class
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.6 `SpringDataJdbcApplicationTests`抽象类
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Ⓐ Autowire a `UserRepository` instance. This is possible due to the `@SpringBootApplication`
    annotation, which enables the scan on the package where the application is located
    and registers the beans in the context.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 自动装配一个`UserRepository`实例。这是由于`@SpringBootApplication`注解的存在，它使得Spring Boot能够扫描应用程序所在的包，并在上下文中注册这些bean。
- en: 'The next tests will extend this class and use the already populated database.
    To test the methods that now belong to `UserRepository`, we’ll create the `FindUsersUsingQueriesTest`
    class and follow the same recipe for writing tests: we’ll call the repository
    method and verify its results.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试将扩展这个类并使用已经填充的数据库。为了测试现在属于`UserRepository`的方法，我们将创建`FindUsersUsingQueriesTest`类并遵循编写测试的相同方法：我们将调用仓库方法并验证其结果。
- en: Listing 15.7 The `FindUsersUsingQueriesTest` class
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.7 `FindUsersUsingQueriesTest`类
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 15.2 Working with queries in Spring Data JDBC
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2 在Spring Data JDBC中处理查询
- en: We’ll now look at working with queries in Spring Data JDBC. We’ll start by defining
    queries with the query builder mechanism, and move on to limiting query results,
    sorting and paging, streaming results, using modifying queries, and creating customized
    queries.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨在Spring Data JDBC中处理查询。我们将从使用查询构建器机制定义查询开始，然后继续到限制查询结果、排序和分页、流式处理结果、使用修改查询以及创建自定义查询。
- en: 15.2.1 Defining query methods with Spring Data JDBC
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.1 使用Spring Data JDBC定义查询方法
- en: We’ll extend the `User` class by adding the fields `email`, `level,` and `active`.
    A user may have different levels, which will allow them to execute particular
    actions, such as bidding above some amount. A user may be active or retired (meaning
    they are no longer active in the CaveatEmptor auction system).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过添加`email`、`level`和`active`字段来扩展`User`类。用户可能有不同的级别，这将允许他们执行特定操作，例如在某个金额以上出价。用户可能是活跃的或退休的（这意味着他们在CaveatEmptor拍卖系统中不再活跃）。
- en: Our goal is to write a program that can address use cases that involve finding
    users with some particular level, users who are active or not, users with a given
    username or email, or users with a registration date in a given interval.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是编写一个程序，该程序可以处理涉及查找具有特定级别、活跃或不活跃、给定用户名或电子邮件、或具有给定注册日期在特定时间间隔内的用户的用例。
- en: Listing 15.8 The modified `User` class
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.8 修改后的`User`类
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we are now responsible for the DDL commands to be executed, we can modify
    the content of the schema.sql file on the classpath.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在负责执行DDL命令，我们可以修改类路径上schema.sql文件的内容。
- en: Listing 15.9 The modified schema.sql file
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.9 修改后的schema.sql文件
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ll now add new methods to the `UserRepository` interface that query the database,
    and we’ll use them in newly created tests.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将向`UserRepository`接口添加新的查询数据库的方法，并在新创建的测试中使用它们。
- en: Listing 15.10 The `UserRepository` interface with new methods
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.10 带有新方法的`UserRepository`接口
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The purpose of the query methods is to retrieve information from the database.
    Starting with version 2.0, Spring Data JDBC provides a query builder mechanism
    similar to the one in Spring Data JPA—it creates the behavior of the repository
    methods based on their names. Remember that the query mechanism removes prefixes
    and suffixes such as `find...By`, `get...By`, `query...By`, `read...By`, and `count...By`
    from the name of the method and then parses the remainder of it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 查询方法的目的在于从数据库中检索信息。从2.0版本开始，Spring Data JDBC提供了一个类似于Spring Data JPA的查询构建器机制——它根据方法名称创建仓库方法的操作行为。请记住，查询机制会从方法名称中移除前缀和后缀，如`find...By`、`get...By`、`query...By`、`read...By`和`count...By`，然后解析剩余部分。
- en: Just like Spring Data JPA, Spring Data JDBC will look at the return type of
    the method. If we want to find a `User` and return it in an `Optional` container,
    the method return type will be `Optional<User>`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与Spring Data JPA类似，Spring Data JDBC会查看方法的返回类型。如果我们想查找一个`User`并将其返回在`Optional`容器中，方法返回类型将是`Optional<User>`。
- en: The names of the methods need to follow the rules to determine the resulting
    query. Defined query methods may currently only use properties that can be included
    in a `WHERE` clause, but without joins. If the method naming is wrong (for example,
    the entity property does not match in the query method), we’ll get an error when
    the application context is loaded. Table 15.1 summarizes the use of the essential
    keywords in building Spring Data JDBC query methods and the resulting conditions.
    For a more comprehensive list, see appendix C.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的名称需要遵循确定结果查询的规则。目前定义的查询方法可能只能使用可以包含在`WHERE`子句中的属性，但不能使用连接。如果方法命名错误（例如，实体属性在查询方法中不匹配），则在加载应用程序上下文时将得到错误。表15.1总结了在构建Spring
    Data JDBC查询方法及其结果条件中使用的必要关键字。对于更全面的列表，请参阅附录C。
- en: Table 15.1 Keyword usage in Spring Data JDBC and resulting conditions
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.1 Spring Data JDBC中的关键字使用及其结果条件
- en: '| Keyword | Example | Condition |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 关键字 | 示例 | 条件 |'
- en: '| `Is`, `Equals` | `findByUsername(String` `name)``findByUsernameIs(String`
    `name)``findByUsernameEquals(String` `name)` | `username` `=` `name` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `Is`、`Equals` | `findByUsername(String name)``findByUsernameIs(String name)``findByUsernameEquals(String
    name)` | `username` `=` `name` |'
- en: '| `And` | `findByUsernameAndRegistrationDate(String name,` `LocalDate date)`
    | `username` `=` `name` `and` `registration_date` `=` `date` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `And` | `findByUsernameAndRegistrationDate(String name, LocalDate date)`
    | `username` `=` `name` `and` `registration_date` `=` `date` |'
- en: '| `Or` | `findByUsernameOrRegistrationDate(String name,` `LocalDate date)`
    | `username` `=` `name` `or` `registrationdatev=` `name` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `Or` | `findByUsernameOrRegistrationDate(String name, LocalDate date)` |
    `username` `=` `name` `or` `registrationdatev=` `name` |'
- en: '| `LessThan` | `findByRegistrationDateLessThan(LocalDate` `date)` | `registrationdate`
    `<` `date` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `LessThan` | `findByRegistrationDateLessThan(LocalDate date)` | `registrationdate`
    `<` `date` |'
- en: '| `LessThanEqual` | `findByRegistrationDateLessThanEqual(LocalDate` `date)`
    | `registrationdate <= date` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `LessThanEqual` | `findByRegistrationDateLessThanEqual(LocalDate date)` |
    `registrationdate <= date` |'
- en: '| `GreaterThan` | `findByRegistrationDateGreaterThan(LocalDate` `date)` | `registrationdate`
    `>` `date` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `GreaterThan` | `findByRegistrationDateGreaterThan(LocalDate date)` | `registrationdate`
    `>` `date` |'
- en: '| `GreaterThanEqual` | `findByRegistrationDateGreaterThanEqual(LocalDatevdate)`
    | `registrationdate` `>=` `date` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `GreaterThanEqual` | `findByRegistrationDateGreaterThanEqual(LocalDate date)`
    | `registrationdate` `>=` `date` |'
- en: '| `Between` | `findByRegistrationDateBetween(LocalDate` `from,` `LocalDate
    to)` | `registrationdate between` `from` `and` `to` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `Between` | `findByRegistrationDateBetween(LocalDate from, LocalDate to)`
    | `registrationdate between from and to` |'
- en: '| `OrderBy` | `findByRegistrationDateOrderByUsernameDesc(LocalDate` `date)`
    | `registrationdate` `=` `date order` `by` `username` `desc` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `OrderBy` | `findByRegistrationDateOrderByUsernameDesc(LocalDate date)` |
    `registrationdate` `=` `date` `order` `by` `username` `desc` |'
- en: '| `Like` | `findByUsernameLike(String` `name)` | `username` `like` `name` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `Like` | `findByUsernameLike(String name)` | `username` `like` `name` |'
- en: '| `NotLike` | `findByUsernameNotLike(String` `name)` | `username` `not` `like`
    `name` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `NotLike` | `findByUsernameNotLike(String name)` | `username` `not` `like`
    `name` |'
- en: '| `Before` | `findByRegistrationDateBefore(LocalDate` `date)` | `registrationdate`
    `<` `date` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `Before` | `findByRegistrationDateBefore(LocalDate` `date)` | `registrationdate`
    `<` `date` |'
- en: '| `After` | `findByRegistrationDateAfter(LocalDate` `date)` | `registrationdate`
    `>` `date` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `After` | `findByRegistrationDateAfter(LocalDate` `date)` | `registrationdate`
    `>` `date` |'
- en: '| `Null`, `IsNull` | `findByRegistrationDate(Is)Null()` | `registrationdate`
    `is` `null` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `Null`, `IsNull` | `findByRegistrationDate(Is)Null()` | `registrationdate`
    `is` `null` |'
- en: '| `NotNull`, `IsNotNull` | `findByRegistrationDate(Is)NotNull()` | `registrationdate`
    `is` `not null` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `NotNull`, `IsNotNull` | `findByRegistrationDate(Is)NotNull()` | `registrationdate`
    `is` `not null` |'
- en: '| `Not` | `findByUsernameNot(String` `name)` | `username` `<>` `name` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `Not` | `findByUsernameNot(String` `name)` | `username` `<>` `name` |'
- en: We’ll extend the `SpringDataJdbcApplicationTests` abstract class, the base class
    for our tests, by configuring the newly introduced fields `email`, `level,` and
    `active` for each user.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过为每个用户配置新引入的字段`email`、`level`和`active`来扩展`SpringDataJdbcApplicationTests`抽象类，这是我们的测试的基础类。
- en: Listing 15.11 The updated `SpringDataJdbcApplicationTests` abstract class
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.11 更新的`SpringDataJdbcApplicationTests`抽象类
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next tests extend this class and use the already populated database. The
    use case we want to solve is getting a user or a list of users fulfilling a particular
    condition (such as a registration date within a given interval) or ordered by
    username. To test the methods that now belong to `UserRepository`, we’ll create
    the `FindUsersUsingQueriesTest` class and follow the same recipe for writing tests:
    call the repository method and verify its results.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试扩展了这个类并使用已经填充的数据库。我们想要解决的使用案例是获取满足特定条件（例如在给定区间内的注册日期）的用户或用户列表或按用户名排序。为了测试现在属于`UserRepository`的方法，我们将创建`FindUsersUsingQueriesTest`类并遵循编写测试的相同方法：调用仓库方法并验证其结果。
- en: Listing 15.12 The `FindUsersUsingQueriesTest` class
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.12 `FindUsersUsingQueriesTest`类
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 15.2.2 Limiting query results, sorting, and paging
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.2 限制查询结果、排序和分页
- en: As in Spring Data JPA, the `first` and `top` keywords (used equivalently) can
    limit the results of query methods. The `top` and `first` keywords may be followed
    by an optional numeric value to indicate the maximum result size to be returned.
    If this numeric value is missing, the result size will be 1.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与Spring Data JPA类似，`first`和`top`关键字（等效使用）可以限制查询方法的结果。`top`和`first`关键字后面可以跟一个可选的数值，表示要返回的最大结果大小。如果这个数值缺失，结果大小将是1。
- en: '`Pageable` is an interface for pagination information. In practice, we use
    the `PageRequest` class that implements it. This class can specify the page number,
    the page size, and the sorting criterion.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pageable`是一个用于分页信息的接口。在实际应用中，我们使用实现该接口的`PageRequest`类。这个类可以指定页码、页面大小和排序标准。'
- en: The use cases we want to solve here are getting a limited number of users (such
    as the first user by username or by registration date) or the first users with
    a given level, sorted by registration date, or a large bunch of users in pages,
    so we can easily manipulate them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要解决的使用案例包括获取一定数量的用户（例如按用户名或注册日期排序的第一个用户）或具有特定级别的前几个用户，按注册日期排序，或者按页获取大量用户，这样我们可以轻松地操作它们。
- en: We’ll add the following methods to the `UserRepository` interface.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向`UserRepository`接口添加以下方法。
- en: Listing 15.13 Limiting query results, sorting, and paging in `UserRepository`
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.13 在`UserRepository`中限制查询结果、排序和分页
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These methods follow the pattern required by the query builder mechanism (summarized
    in table 15.1), but this time their purpose is to limit the results of the query,
    so we can do sorting and paging. For example, the `Optional<User> findFirstByOrderByUsernameAsc()`
    method will get the first user by its username (the result is an `Optional`, so
    eventually it may not exist). The `Page<User> findAll(Pageable pageable)` method
    will get all users but in pages. We’ll write the following tests to verify how
    these newly added methods work.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法遵循查询构建器机制所需的模式（总结在表15.1中），但这次它们的目的是限制查询结果，以便我们可以进行排序和分页。例如，`Optional<User>
    findFirstByOrderByUsernameAsc()`方法将按用户名的升序获取第一个用户（结果是`Optional`，所以最终可能不存在）。`Page<User>
    findAll(Pageable pageable)`方法将按页获取所有用户。我们将编写以下测试来验证这些新添加的方法如何工作。
- en: Listing 15.14 Testing limiting query results, sorting, and paging
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.14 测试限制查询结果、排序和分页
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Ⓐ The first test finds the first user by ascending order of username and the
    first user by descending order of registration date.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 第一个测试按用户名的升序和按注册日期的降序找到第一个用户。
- en: Ⓑ Find all users, split them into pages, and return page number 1 of size 3
    (the page numbering starts with 0).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 查找所有用户，将它们分成页面，并返回第1页，大小为3（页码从0开始）。
- en: Ⓒ Find the first 2 users with level 2, ordered by registration date.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 查找前两个等级为2的用户，并按注册日期排序。
- en: Ⓓ The second test defines a sorting criterion on the `User` class. `Sort.TypedSort`
    extends `Sort` and can use method handles to define properties to sort by.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 第二个测试在 `User` 类上定义了一个排序标准。`Sort.TypedSort` 扩展了 `Sort` 并可以使用方法句柄来定义排序的属性。
- en: Ⓔ Find users of level 3 and sort by registration date, descending.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 查找等级为3的用户，并按注册日期降序排序。
- en: Ⓕ The third test finds the active users sorted by registration date, splits
    them into pages, and returns page number 1 of size 4 (page numbering starts with
    0).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 第三个测试按注册日期排序活动用户，将它们分成页面，并返回第1页，大小为4（页码从0开始）。
- en: 15.2.3 Streaming results
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.3 流式结果
- en: Query methods returning more than one result can use standard Java interfaces,
    such as `Iterable`, `List`, and `Set`. Like Spring Data JPA, Spring Data JDBC
    supports `Streamable`, which can be used as an alternative to `Iterable` or any
    collection type. It allows us to concatenate `Streamable`s and to directly filter
    and map over the elements.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 返回多个结果的查询方法可以使用标准 Java 接口，如 `Iterable`、`List` 和 `Set`。与 Spring Data JPA 一样，Spring
    Data JDBC 支持 `Streamable`，它可以作为 `Iterable` 或任何集合类型的替代品。它允许我们连接 `Streamable`s 并直接过滤和映射元素。
- en: The use case we’ll solve here is getting the results as a stream, without waiting
    for the whole collection of users or a page of users to be obtained. This way,
    we can quickly start processing the first results as they flow in. Unlike collections,
    a stream can be consumed only once and is immutable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解决的用例是作为流获取结果，而不必等待整个用户集合或用户页面被获取。这样，我们可以快速开始处理流中流入的第一个结果。与集合不同，流只能消费一次，且不可变。
- en: We’ll add the following methods to the `UserRepository` interface.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `UserRepository` 接口中添加以下方法。
- en: Listing 15.15 Adding methods that return `Streamable` in `UserRepository`
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.15 在 `UserRepository` 中添加返回 `Streamable` 的方法
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We’ll write the following test to verify how these newly added methods interact
    with the database and provide results as streams. A stream is given as a resource
    of the `try` block, so it is automatically closed. An alternative is to explicitly
    call the `close()` method. Otherwise the stream would keep the underlying connection
    to the database.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写以下测试来验证这些新添加的方法如何与数据库交互并提供结果作为流。流作为 `try` 块的资源给出，因此它将被自动关闭。另一种选择是显式调用 `close()`
    方法。否则，流将保持与数据库的底层连接。
- en: Listing 15.16 Testing methods that return `Streamable`
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.16 测试返回 `Streamable` 的方法
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Ⓐ The test will call the `findByEmailContaining` method to search for emails
    containing the `someother` word.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 测试将调用 `findByEmailContaining` 方法来搜索包含 `someother` 单词的电子邮件。
- en: Ⓑ The test will concatenate the resulting `Streamable` with the `Streamable`
    providing users of level 2.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 测试将结果 `Streamable` 与提供等级2用户的 `Streamable` 连接起来。
- en: Ⓒ It will transform this into a stream and will keep the distinct users.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 它将将其转换为流并保留不同的用户。
- en: Ⓓ Check that the resulting stream contains 6 users.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 检查结果流包含6个用户。
- en: 15.2.4 The @Query annotation
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.4 @Query 注解
- en: We can use the `@Query` annotation to create methods for which a custom query
    can be specified. With the `@Query` annotation, the method name does not need
    to follow any naming convention. The custom query can be parameterized, but unlike
    for Spring Data JPA, the parameters can be identified only by name, and they must
    be bound in the query with the `@Param` annotation. Unlike with Spring Data JPA,
    we do not use JPQL but SQL. Consequently, there is no portability—if you change
    the database vendor, you will have to rewrite the queries.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `@Query` 注解来创建可以指定自定义查询的方法。使用 `@Query` 注解，方法名称不需要遵循任何命名约定。自定义查询可以是参数化的，但与
    Spring Data JPA 不同，参数只能通过名称识别，并且它们必须使用 `@Param` 注解在查询中绑定。与 Spring Data JPA 不同，我们不使用
    JPQL 而是使用 SQL。因此，没有可移植性——如果你更改数据库供应商，你必须重写查询。
- en: We’ll add two new methods to the `UserRepository` interface. These methods will
    be annotated with the `@Query` annotation, and their generated behavior will depend
    on the definition of these queries.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `UserRepository` 接口中添加两个新方法。这些方法将使用 `@Query` 注解，并且它们的生成行为将取决于这些查询的定义。
- en: Listing 15.17 Methods annotated with `@Query` in the `UserRepository` interface
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.17 在 `UserRepository` 接口中使用 `@Query` 注解的方法
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Ⓐ The `findNumberOfUsersByActivity` method will return the number of active
    users.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `findNumberOfUsersByActivity`方法将返回活跃用户的数量。
- en: Ⓑ The `findByLevelAndActive` method will return users with the `level` and `active`
    status given as named parameters. The `@Param` annotation will match the `:LEVEL`
    parameter of the query with the `level` argument of the method and the `:ACTIVE`
    parameter of the query with the `active` argument of the method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `findByLevelAndActive`方法将返回具有给定命名参数`level`和`active`状态的用户。`@Param`注解将查询的`:LEVEL`参数与方法的`level`参数匹配，将查询的`:ACTIVE`参数与方法的`active`参数匹配。
- en: Writing tests for these query methods is pretty straightforward and similar
    to the previous examples. They can be found in the source code for the book.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为这些查询方法编写测试相对简单，与之前的示例类似。它们可以在本书的源代码中找到。
- en: 15.2.5 Modifying queries
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2.5 修改查询
- en: We can define modifying methods with the `@Modifying` annotation. For example,
    `INSERT`, `UPDATE`, and `DELETE` queries and DDL statements modify the content
    of the database. The `@Query` annotation can take as an argument the modifying
    query, and it may need binding parameters. At the time of writing, Spring Data
    JDBC does not support query derivation for delete methods (unlike Spring Data
    JPA).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`@Modifying`注解定义修改方法。例如，`INSERT`、`UPDATE`和`DELETE`查询以及DDL语句修改数据库的内容。`@Query`注解可以将修改查询作为参数，并且可能需要绑定参数。在撰写本文时，Spring
    Data JDBC不支持删除方法的查询推导（与Spring Data JPA不同）。
- en: We’ll add the new methods, annotated with the `@Query` annotation, to the `UserRepository`
    interface, but this time the queries will update or delete records from the `USERS`
    table.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加新的方法，这些方法带有`@Query`注解，到`UserRepository`接口中，但这次查询将更新或删除`USERS`表中的记录。
- en: Listing 15.18 Adding modifying methods to the `UserRepository` interface
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.18 向`UserRepository`接口添加修改方法
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Ⓐ The `updateLevel` method will change the `level` of the users having the `oldLevel`
    and set it to the `newLevel`. The method is also annotated with `@Modifying`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `updateLevel`方法将更改具有`oldLevel`的用户`level`并将其设置为`newLevel`。该方法还带有`@Modifying`注解。
- en: Ⓑ The `deleteByLevel` method will remove all users with the `level` given as
    a parameter, as the argument of the `@Query` annotation indicates. The method
    is also annotated with `@Modifying`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `deleteByLevel`方法将删除所有具有作为`@Query`注解参数的`level`的用户，正如方法注解所指示的。该方法也带有`@Modifying`注解。
- en: Writing the tests for these query methods is pretty straightforward and similar
    to the previous examples. They can be found in the source code for the book.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为这些查询方法编写测试相对简单，与之前的示例类似。它们可以在本书的源代码中找到。
- en: 15.3 Modeling relationships with Spring Data JDBC
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3 使用Spring Data JDBC建模关系
- en: Managing the associations between classes and the relationships between tables
    is at the heart of ORM problems. We examined the possible solutions to these problems
    using JPA and Spring Data JPA in chapter 8, and we’ll now look at the approaches
    provided by Spring Data JDBC.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 管理类之间的关联和表之间的关系是ORM问题的核心。我们在第8章中探讨了这些问题的可能解决方案，使用JPA和Spring Data JPA，现在我们将探讨Spring
    Data JDBC提供的方法。
- en: 15.3.1 Modeling a one-to-one relationship with Spring Data JDBC
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.1 使用Spring Data JDBC建模一对一关系
- en: Spring Data JPA can model relationships between entities with the JPA annotations
    `@OneToOne`, `@OneToMany`, `@ManyToMany`. Spring Data JDBC uses a different mechanism
    than JPA. We’ll start with modeling one-to-one relationships between entities
    in Spring Data JDBC using the `User` and `Address` entities. Each `User` will
    have only one `Address`, and each `Address` will belong to one `User`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data JPA可以使用JPA注解`@OneToOne`、`@OneToMany`、`@ManyToMany`来建模实体之间的关系。Spring
    Data JDBC使用与JPA不同的机制。我们将从使用`User`和`Address`实体在Spring Data JDBC中建模实体之间的一对一关系开始。每个`User`将只有一个`Address`，每个`Address`将属于一个`User`。
- en: As previously stated, Spring Boot will always execute the schema.sql file on
    the classpath at startup. As shown in the following listing, it drops and recreates
    the `ADDRESSES` and `USERS` tables.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spring Boot在启动时将始终执行类路径上的schema.sql文件。如下所示列表中，它将删除并重新创建`ADDRESSES`和`USERS`表。
- en: Listing 15.19 The schema.sql file for one-to-one relationships
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.19 一对一关系的schema.sql文件
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `@MappedCollection` annotation (introduced in Spring Data JDBC 1.1) can
    be used on a reference type for a one-to-one relationship. The `ID` field of the
    `USERS` table will be a foreign key in the `ADDRESSES` table, the corresponding
    field from the ADDRESSES table being `USER_ID`. Having one single `Address` reference
    inside `User` will make the relationship one-to-one. In the `User` class, the
    reference to the `Address` field will look like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`@MappedCollection` 注解（自 Spring Data JDBC 1.1 引入）可以用于一对一直接引用的类型。`USERS` 表的
    `ID` 字段将成为 `ADDRESSES` 表的外键，`ADDRESSES` 表中对应的字段是 `USER_ID`。在 `User` 中只有一个 `Address`
    引用将使关系成为一对一。在 `User` 类中，对 `Address` 字段的引用将如下所示：'
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Address` class will also be annotated with `@Table`, because it will correspond
    to a different table from the database:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`Address` 类也将被注解为 `@Table`，因为它将对应于数据库中的不同表：'
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We’ll create two repositories. The first is for the `User` entity:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个仓库。第一个是为 `User` 实体：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The second is for the `Address` entity:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是为 `Address` 实体：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We’ll use these repositories to populate the database and execute the tests:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些仓库来填充数据库并执行测试：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 15.3.2 Modeling embedded entities with Spring Data JDBC
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.2 使用 Spring Data JDBC 建模嵌入实体
- en: We now move on to the modeling of embedded entities in Spring Data JDBC. We
    want to embed the `User` entity and the `Address` class in `User`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在继续在 Spring Data JDBC 中对嵌入实体的建模。我们希望将 `User` 实体和 `Address` 类嵌入到 `User` 中。
- en: The SQL script that’s automatically executed is shown in the following listing.
    There will be only one table, `USERS`, which will embed the information about
    addresses.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 自动执行的 SQL 脚本如下所示。将只有一个表，`USERS`，它将嵌入地址信息。
- en: Listing 15.20 The schema.sql file for embedded entities
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.20 嵌入实体的 schema.sql 文件
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The address will be embedded in the `USERS` table. If the embedded `STREET`
    and `CITY` columns are empty, the `address` field is `null`. In the `User` class,
    the reference to the `Address` field will look like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 地址将被嵌入到 `USERS` 表中。如果嵌入的 `STREET` 和 `CITY` 列为空，则 `address` 字段为 `null`。在 `User`
    类中，对 `Address` 字段的引用将如下所示：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `Address` class will not be annotated with `@Table`, as it will no longer
    correspond to a different table from the database—all its information will be
    embedded in the `USERS` table.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Address` 类将不再被注解为 `@Table`，因为它将不再对应于数据库中的不同表——所有信息都将嵌入到 `USERS` 表中。'
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We’ll create a single repository for the `User` entity.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为 `User` 实体创建一个单独的仓库。
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We’ll then use this repository to populate the database and execute the tests.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用此仓库来填充数据库并执行测试。
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 15.3.3 Modeling a one-to-many relationship with Spring Data JDBC
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.3 使用 Spring Data JDBC 建模一对多关系
- en: We’ll now move on to the modeling of a one-to-many relationship in Spring Data
    JDBC. We have the `User` entity and the `Address` entity. Each user can have many
    addresses.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将转向 Spring Data JDBC 中一对多关系的建模。我们有 `User` 实体和 `Address` 实体。每个用户可以有多个地址。
- en: The SQL script that’s automatically executed is shown in the following listing.
    There will be two tables, `USERS` and `ADDRESSES`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 自动执行的 SQL 脚本如下所示。将有两个表，`USERS` 和 `ADDRESSES`。
- en: Listing 15.21 The schema.sql file for one-to-many relationships
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15.21 用于一对多关系的 schema.sql 文件
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `ID` field of the `USERS` table will be a foreign key in the `ADDRESSES`
    table, the corresponding field from the ADDRESSES table being `USER_ID`. Having
    a set of `Address` references inside `User` will indicate that a `User` has many
    `Address`es. In the `User` class, the reference to the `Address`es will look like
    this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`USERS` 表的 `ID` 字段将成为 `ADDRESSES` 表的外键，`ADDRESSES` 表中对应的字段是 `USER_ID`。在 `User`
    中有一组 `Address` 引用将表示一个 `User` 有多个 `Address`。在 `User` 类中，对 `Addresses` 的引用将如下所示：'
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `Address` class will also be annotated with `@Table`, as it will correspond
    to a different table from the database:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Address` 类也将被注解为 `@Table`，因为它将对应于数据库中的不同表：'
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We’ll create two repositories: one for the `User` entity and one for the `Address`
    entity. The second repository will contain an additional method. Even if the name
    of the `countByUserId` method follows the pattern discussed both for Spring Data
    JDBC and Spring Data JPA, the method needs to be annotated with `@Query`, as `userId`
    does not exist in the `Address` class:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个仓库：一个用于 `User` 实体，另一个用于 `Address` 实体。第二个仓库将包含一个额外的方法。即使 `countByUserId`
    方法的名称遵循了 Spring Data JDBC 和 Spring Data JPA 中讨论的模式，该方法仍需要注解为 `@Query`，因为 `userId`
    不存在于 `Address` 类中：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We’ll use the repositories to populate the database and execute the tests:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用仓库来填充数据库并执行测试：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 15.3.4 Modeling a many-to-many relationship with Spring Data JDBC
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.4 使用Spring Data JDBC建模多对多关系
- en: We’ll now move on to modeling a many-to-many relationship in Spring Data JDBC.
    We have the `User` and `Address` entities. Each `User` can have many `Address`es,
    and each `Address` may have many `User`s. We’ll also need to manually introduce
    a class corresponding to the `USERS_ADDRESSES` intermediary table, which will
    model the many-to-many relationship.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转向使用Spring Data JDBC建模多对多关系。我们有`User`和`Address`实体。每个`User`可以有多个`Address`，每个`Address`也可以有多个`User`。我们还需要手动引入一个对应于`USERS_ADDRESSES`中间表的类，该类将建模多对多关系。
- en: 'The SQL script that’s automatically executed will look like the following listing.
    There will be three tables: `USERS`, `ADDRESSES`, and `USERS_ADDRESSES`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 自动执行的SQL脚本将如下所示。将有三个表：`USERS`、`ADDRESSES`和`USERS_ADDRESSES`。
- en: Listing 15.22 The schema.sql file for many-to-many relationships
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15.22 多对多关系的schema.sql文件
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To model many-to-many relationships, the `User` class will be connected to
    the intermediary class `UserAddress`. Having a set of `UserAddress` references
    inside `User` will indicate that a `User` has many `UserAddress`es. The `ID` field
    of the `USERS` table will be a foreign key in the `USERS_ADDRESSES` table, the
    corresponding field from the USERS_ ADDRESSES table being `USER_ID`. In the `User`
    class, the reference to the `Address`es will look like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建模多对多关系，`User`类将与中间类`UserAddress`连接。在`User`内部拥有`UserAddress`引用集合将表明一个`User`有多个`UserAddress`。`USERS`表的`ID`字段将在`USERS_ADDRESSES`表中作为外键，对应字段为`USER_ID`。在`User`类中，对`Addresses`的引用将如下所示：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `Address` class will also be annotated with `@Table`, as it will correspond
    to a different table from the database:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`Address`类也将使用`@Table`注解，因为它将对应于数据库中的不同表：'
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Also, we’ll create the `UserAddress` class and annotate it with `@Table`, as
    it will correspond to a different table from the database. It will hold only the
    ID of the `Address`, as the `User` class keeps a set of references of `UserAddress`
    type.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将创建`UserAddress`类并使用`@Table`注解，因为它将对应于数据库中的不同表。它将只包含`Address`的ID，因为`User`类保持了一组`UserAddress`类型的引用。
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We’ll create three repositories: one for the `User` entity, one for the `Address`
    entity, and one for the `UserAddress` entity. The third repository will contain
    an additional method: even though the name of the `countByUserId` method follows
    the pattern discussed both for Spring Data JDBC and Spring Data JPA, the method
    needs to be annotated with `@Query`, because the `userId` does not exist in the
    `UserAddress` class.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建三个仓库：一个用于`User`实体，一个用于`Address`实体，还有一个用于`UserAddress`实体。第三个仓库将包含一个额外的方法：尽管`countByUserId`方法的名字遵循了Spring
    Data JDBC和Spring Data JPA中讨论的模式，但该方法需要使用`@Query`注解，因为`userId`不存在于`UserAddress`类中。
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We’ll use the repositories to populate the database and execute the tests:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用仓库来填充数据库并执行测试：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To conclude and finally compare and contrast the current capabilities of Spring
    Data JPA and Spring Data JDBC, take a look at table 15.2\. We’ve summarized here
    the most important capabilities, such as portability, the complexity of learning
    and adopting it in projects, query derivation, native SQL usage, annotation usage,
    relationship modeling, caching and lazy loading, sessions, and dirty tracking.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结并最终比较和对比Spring Data JPA和Spring Data JDBC当前的功能，请查看表15.2。我们在此总结了最重要的功能，例如可移植性、在项目中学习和采用它的复杂性、查询推导、原生SQL的使用、注解的使用、关系建模、缓存和延迟加载、会话和脏检查。
- en: Table 15.2 Spring Data JPA capabilities vs. Spring Data JDBC capabilities
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.2 Spring Data JPA功能与Spring Data JDBC功能对比
- en: '| Spring Data JPA | Spring Data JDBC |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| Spring Data JPA | Spring Data JDBC |'
- en: '| Database-independent and portable | Generally, database-specific |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 数据库无关且可移植 | 通常，数据库特定 |'
- en: '| Introduces complexity through object/relational mapping (ORM) | Less complex,
    but still adheres to the Spring Framework principles |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 通过对象/关系映射（ORM）介绍复杂性 | 简单一些，但仍然遵循Spring框架的原则 |'
- en: '| Automatic schema generation based on the entities | Schema generation through
    DDL commands on the side of the programmer |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 基于实体自动生成模式 | 通过程序员侧的DDL命令生成模式 |'
- en: '| Query derivation since the first version | Query derivation since version
    2.0 |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 从第一个版本开始就有查询推导 | 从2.0版本开始就有查询推导 |'
- en: '| Queries annotated with JPQL code and native SQL | Only queries using native
    SQL |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 使用带有 JPQL 代码和原生 SQL 的查询进行注解 | 只使用原生 SQL 的查询 |'
- en: '| Can reuse classes with JPA annotations | Uses annotations from the `org.springframework.data`
    package |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 可以使用 JPA 注解重用类 | 使用 `org.springframework.data` 包中的注解 |'
- en: '| Models relationships between entities through annotations such as `@OneToMany`,
    `@Embedded`, etc. | Models relationships mostly on the side of the programmer,
    through the design of the classes |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 通过 `@OneToMany`、`@Embedded` 等注解在实体之间建模关系 | 主要在程序员的一侧通过类的设计来建模关系 |'
- en: '| Caching and lazy loading | No caching, no lazy loading |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 缓存和延迟加载 | 没有缓存，没有延迟加载 |'
- en: '| Sessions and dirty tracking | No sessions, no dirty tracking |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 会话和脏跟踪 | 没有会话，没有脏跟踪 |'
- en: Note Spring Data JDBC is a young project, and it is in full development. It
    is expected to add considerable new features in the near future.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Spring Data JDBC 是一个年轻的项目，目前正处于全面开发阶段。预计在不久的将来将添加许多新功能。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You can create and configure a Spring Data JDBC project using Spring Boot, adding
    step-by-step methods that query the database and model different types of relationships.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 Spring Boot 创建和配置一个 Spring Data JDBC 项目，并添加逐步方法来查询数据库和建模不同类型的关系。
- en: You can define and use a series of query methods to access repositories by following
    the Spring Data JDBC query builder mechanisms, as introduced in version 2.0 of
    the framework.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过遵循框架 2.0 版本中介绍的 Spring Data JDBC 查询构建器机制来定义和使用一系列查询方法来访问存储库。
- en: Spring Data JDBC capabilities include limiting query results, sorting, paging,
    streaming results, and the `@Query` annotation.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Data JDBC 的功能包括限制查询结果、排序、分页、流式结果和 `@Query` 注解。
- en: You can create and use modifying queries to update and delete entities.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用修改查询来创建和更新实体。
- en: You can model one-to-one, one-to-many, and many-to-many relationships between
    entities as well as embedded entities with Spring Data JDBC.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 Spring Data JDBC 来建模实体之间的一对一、一对多和多对多关系，以及内嵌实体。
