- en: 'Lesson 15\. Capstone project: choose your own adventure'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第15课. 期末项目：选择你的冒险
- en: After reading [lesson 15](#ch15), you’ll be able to
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第15课](#ch15)之后，您将能够
- en: Write code for a choose-your-own-adventure program
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个选择你自己的冒险程序的代码
- en: Use branches to set up paths through the program
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分支设置程序中的路径
- en: This capstone project is somewhat open-ended.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这个期末项目是有些开放式的。
- en: '|  |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The problem
  id: totrans-6
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You’ll use conditionals and branching to create a story. At each scene, the
    user will enter a word. The word will tell the program which path to continue
    following. Your program should handle all possible paths that the user might choose,
    but doesn’t need to handle any unexpected input from the user.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用条件语句和分支来创建一个故事。在每一个场景中，用户将输入一个单词。这个单词将告诉程序继续跟随哪个路径。您的程序应该处理用户可能选择的所有可能路径，但不需要处理任何意外的用户输入。
- en: '|  |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The walk-through you’ll see is one of many possible others; be as creative as
    you want with your storyline!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到的演练是许多可能之一；在您的剧情中尽可能有创意！
- en: 15.1\. Outlining the game rules
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1\. 概述游戏规则
- en: Anytime you’re getting input from users, you should be aware that they might
    not play by the rules. In your program, specify what you expect from them and
    warn them that anything else might make the program end.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取用户输入时，您应该意识到他们可能不会按照规则来玩。在您的程序中，指定您期望他们做什么，并警告他们任何其他行为可能会使程序结束。
- en: A simple `print` statement will suffice, as in the following listing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的`print`语句就足够了，如下面的列表所示。
- en: Listing 15.1\. Getting user input
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.1\. 获取用户输入
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* How to play**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如何玩**'
- en: '***2* Unexpected behavior closes the program.**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 非预期行为关闭程序。**'
- en: According to the program rules, you’ll have to handle branches for any input
    in capital letters. There’s only one option at the start of the program, to help
    the user get accustomed to this input format.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 根据程序规则，您必须处理任何大写字母输入的分支。程序开始时只有一个选项，以帮助用户习惯这种输入格式。
- en: 15.2\. Creating different paths
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2\. 创建不同的路径
- en: 'The general flow of the program is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的一般流程如下：
- en: Tell users the choices they have.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉用户他们的选择。
- en: Get user input.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取用户输入。
- en: If the user puts in choice 1, print a message. For this path, if the user now
    has more choices, indicate the choices, get input, and so on.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入了选择1，打印一条消息。对于这条路径，如果用户现在有更多选择，指出选择，获取输入，等等。
- en: Otherwise, if the user puts in choice 2, print another message. For this path,
    if the user now has more choices, indicate the choices, get input, and so on.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果用户选择了选项2，打印另一条消息。对于这条路径，如果用户现在有更多选择，指出选择，获取输入，等等。
- en: And so on, for however many choices there are. For each path, if the user now
    has more choices, indicate the choices, get input, and so on.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等，对于有多少选择就有多少。对于每条路径，如果用户现在有更多选择，指出选择，获取输入，等等。
- en: You’ll use nested conditionals to create subpaths within paths. One simple program
    is shown in [listing 15.2](#ch15ex02). It goes only two conditionals deep; one
    nested conditional is inside another. The user can make at most two choices when
    running the program once.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用嵌套条件在路径内创建子路径。一个简单的程序在[列表15.2](#ch15ex02)中展示。它只深入两个条件；一个嵌套条件在另一个内部。用户在运行程序一次时最多可以做出两个选择。
- en: 'The code listing begins by asking for user input. Then it makes sure the user
    understands the rules of the game with a conditional for the keyword `LOOK`. If
    the user types anything else, it shows a message indicating what commands are
    allowed and what the user will see. The first conditional checks whether the user
    typed `LOOK`. If the user did, the code gets user input again, and handles one
    of two possibilities from that input: that the user typed either `LEFT` or `RIGHT`.
    The code prints a different message for these choices.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 代码列表首先要求用户输入。然后它通过一个针对关键字`LOOK`的条件来确保用户理解游戏的规则。如果用户输入了其他任何内容，它会显示一条消息，指出允许的命令以及用户将看到的内容。第一个条件检查用户是否输入了`LOOK`。如果用户确实这样做了，代码会再次获取用户输入，并处理两种可能性：用户输入了`LEFT`或`RIGHT`。代码为这些选择打印不同的消息。
- en: Listing 15.2\. An adventure with only one choice
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.2\. 只有一个选择的冒险
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Input from user**'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 用户输入**'
- en: '***2* Conditional if user types LOOK**'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果用户输入LOOK的条件**'
- en: '***3* Input from user after user LOOKed**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 用户查看后的用户输入**'
- en: '***4* Conditional to check if user types LEFT**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 检查用户是否输入LEFT的条件**'
- en: '***5* Conditional to check if user types RIGHT**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 检查用户是否输入RIGHT的条件**'
- en: '***6* A block to remind users that they can type only certain commands**'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 一个提醒用户只能输入特定命令的块**'
- en: Two choices in a program don’t sound fun. You can add more choices for different
    scenarios.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的两个选择听起来并不有趣。你可以为不同的场景添加更多选择。
- en: 15.3\. More choices? Yes, please!
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3\. 更多的选择？当然，请！
- en: A choose-your-own-adventure game should have more than one or two choices. Use
    many nested conditionals to create many subpaths through the code. You can make
    the adventure as easy or as hard as you want; for example, out of 20 possible
    paths through the code, maybe only one leads to survival.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个“选择你的冒险”游戏应该有不止一个或两个选择。使用许多嵌套条件来创建许多子路径通过代码。你可以使冒险变得容易或困难，例如，在代码中的 20 条可能路径中，可能只有一条通向生存。
- en: '[Figure 15.1](#ch15fig01) shows one possible code structure. A decision is
    marked by the user entering a word. Depending on the chosen word, the user will
    see a new situation for that chosen path. The user will continue making choices
    until the final outcome is reached.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 15.1](#ch15fig01) 展示了一个可能的代码结构。决策由用户输入一个单词来标记。根据选择的单词，用户将看到该路径的新情况。用户将继续做出选择，直到达到最终结果。'
- en: Figure 15.1\. The boxes represent choices for the user. The text below the boxes
    represents the situation. The gray arrows show the path with the choice made.
    The dotted black lines to a smiley face or a sad face represent the end of the
    program, with survival or not. Out of five possible outcomes, only one leads to
    survival.
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 15.1\. 箱子代表用户的选项。箱子下面的文本代表情况。灰色箭头显示已做出选择的路径。到笑脸或哭脸的虚线黑色线条代表程序的结束，表示生存与否。在五种可能的结果中，只有一种通向生存。
- en: '![](images/15fig01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](images/15fig01.jpg)'
- en: The following listing provides the code associated with [figure 15.1](#ch15fig01).
    Only one path leads to survival. The user must enter LEFT, then CRAB, then YES,
    then TREE, and then NO. Any other choice leads to text indicating that the user
    has perished on the island.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表提供了与 [图 15.1](#ch15fig01) 相关的代码。只有一条路径通向生存。用户必须输入 LEFT，然后 CRAB，然后 YES，然后
    TREE，然后 NO。任何其他选择都会导致显示用户在岛上丧生的文本。
- en: Listing 15.3\. One possible choose-your-own-adventure code
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.3\. 一个可能的“选择你的冒险”代码
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* First choice**'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 首选**'
- en: '***2* Choice for if-branch of *1***'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为 *1* 的 if 分支的选择**'
- en: '***3* Choice for elif-branch of *1***'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 选项为 *1* 的 elif 分支**'
- en: '***4* Nested choice, for if branch of *3***'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 嵌套选择，为 *3* 的 if 分支**'
- en: '***5* No choice, only one possibility**'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 没有选择，只有一种可能性**'
- en: '***6* Choice for *5***'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 为 *5* 的选择**'
- en: '***7* Nested choice for elif-branch of *3***'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 为 *3* 的 elif 分支的嵌套选择**'
- en: '***8* First choice**'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 首选**'
- en: Summary
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this lesson, my objective was to teach you to use conditionals to write
    a program in which the user makes choices to try to survive the scenario outlined
    at the beginning of the program. To create paths for different choices that the
    user can make after having already made a choice, you used nested conditionals.
    Here are the major takeaways:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，我的目标是教会你如何使用条件语句编写一个程序，用户可以通过选择来尝试在程序开始时概述的场景中生存下来。为了创建用户在已经做出选择后可以做出的不同选择的路径，你使用了嵌套条件。以下是主要收获：
- en: Conditionals offer choices to the user.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语句为用户提供选择。
- en: Nested conditionals are useful for offering a different set of choices after
    making one choice.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套条件在做出一个选择后提供另一组选择是有用的。
