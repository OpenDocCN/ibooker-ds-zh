- en: 6 Smart pointers and polymorphism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 智能指针和多态
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using inheritance for dynamic polymorphism
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用继承实现动态多态
- en: Special member functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊成员函数
- en: Type traits
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型特性
- en: Using smart pointers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用智能指针
- en: Random number distributions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机数分布
- en: In this chapter, we will work with classes again, but this time using inheritance.
    We will create various `"Blob"` classes. Our blobs will be able to move forward
    and backward. If we get our blobs in a line at the bottom of a virtual paper bag,
    we can set them off racing and see which blob escapes the paper bag first. Separately
    from practicing with classes, we can then claim and furthermore prove that we
    can code our way out of a paper bag, a skill all programmers should aim for.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将再次使用类，但这次使用继承。我们将创建各种`"Blob"`类。我们的粘液块将能够向前和向后移动。如果我们把粘液块排成一行在虚拟纸袋的底部，我们可以让它们开始赛跑，看看哪个粘液块首先逃离纸袋。除了在类上进行练习之外，我们还可以声称并进一步证明我们可以通过编码从纸袋中逃脱，这是所有程序员都应该追求的技能。
- en: We will start with a simple class hierarchy and create a blob that takes a step
    at a time. We will consider which special member functions we need when we use
    inheritance and use type traits to interrogate various member functions. We will
    use random numbers again, using various distributions to decide how big a step
    a blob takes. The randomness will make the race more exciting. By storing a blob
    in a *smart pointer*, we can keep various types of blobs in a `vector`. Their
    behavior will vary depending on the type of blob, giving us *dynamic polymorphism*.
    They can then race, and we can sit back, watch, and congratulate ourselves on
    coding our way out of a paper bag.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简单的类层次结构开始，创建一个一次迈一步的粘液块。我们将考虑在继承时需要哪些特殊成员函数，并使用类型特性来查询各种成员函数。我们将再次使用随机数，使用各种分布来决定粘液块迈多大的一步。这种随机性将使比赛更加刺激。通过将粘液块存储在*智能指针*中，我们可以在`vector`中保持各种类型的粘液块。它们的行为将根据粘液块类型而变化，给我们提供*动态多态性*。然后它们可以赛跑，我们可以坐下来观看，并为我们通过编码从纸袋中逃脱而自我祝贺。
- en: 6.1 A class hierarchy
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 类层次结构
- en: 'We will represent a blob with an asterisk, `*`, and leave a trail of asterisks
    to show the path taken. We can indicate the sides of the bag with a `|` character
    and the bottom with a `-` character. All blobs will start at the bottom of a bag
    and then move a step or so at a time. We might see something like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用星号`*`来表示粘液块，并留下星号轨迹以显示路径。我们可以用`|`字符表示袋子的侧面，用`-`字符表示底部。所有粘液块都将从袋子的底部开始，然后一次移动一步或更多。我们可能会看到类似这样的情况：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To race blobs out of a paper bag, we need to define a `Blob` type. We could
    give each blob an `x` and `y` coordinate, but we will not vary `x`, so need only
    track `y`. If we store blobs in a `vector`, we can use the vector’s index to indicate
    the `x` coordinate. For our first race, we will have one type of blob that always
    moves forward by the same amount. Later, we can add a second type of `Blob` that
    takes a random step to add some variety.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将纸袋中的粘液块赛跑，我们需要定义一个`Blob`类型。我们可以给每个粘液块一个`x`和`y`坐标，但我们将不改变`x`，因此只需要跟踪`y`。如果我们将粘液块存储在`vector`中，我们可以使用向量的索引来指示`x`坐标。对于我们的第一次赛跑，我们将有一种类型的粘液块，它总是以相同的量向前移动。稍后，我们可以添加第二种类型的`Blob`，它将采取随机的一步以增加一些变化。
- en: 6.1.1 An abstract base class
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 抽象基类
- en: We’ll create a base class for our blobs and make derived classes later. We know
    each blob needs to take a step, so we need a `step` function. We will also want
    to know the total number of steps taken so we can display the right number of
    asterisks. The `step` function changes the instance, increasing the total number
    of steps, but the `total_ steps` function does not change the instance, so the
    latter can be marked `const`. Therefore, we need two member functions but keep
    them abstract, indicated by `= 0` after the declaration. Derived classes can implement
    their own versions of these functions, giving us the polymorphism we need. Both
    of the abstract functions need to be marked `virtual`. Virtual methods are implemented
    via a table of virtual function pointers called a *v-table*. When we call a virtual
    method via a pointer or reference, the v-table is used to look up which overridden
    virtual function to invoke. Virtual methods, therefore, allow us to create different
    derived classes with different `step` functions. The *abstract base class* (ABC)
    can live in a header file, called `Race.h`, inside a namespace called `Race`.
    The class doesn’t need much code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的 blob 创建一个基类，稍后创建派生类。我们知道每个 blob 都需要移动一步，所以我们需要一个 `step` 函数。我们还想知道总共移动了多少步，这样我们就可以显示正确的星号数量。`step`
    函数会改变实例，增加总步数，但 `total_steps` 函数不会改变实例，所以后者可以被标记为 `const`。因此，我们需要两个成员函数，但保持它们为抽象的，通过在声明后使用
    `= 0` 来表示。派生类可以实现它们自己的这些函数版本，从而给我们提供所需的多态性。这两个抽象函数都需要标记为 `virtual`。虚方法通过一个称为 *v-table*
    的虚函数指针表来实现。当我们通过指针或引用调用虚方法时，v-table 被用来查找要调用的重写的虚函数。因此，虚方法允许我们创建具有不同 `step` 函数的不同派生类。*抽象基类*
    (ABC) 可以存在于一个名为 `Race.h` 的头文件中，位于一个名为 `Race` 的命名空间内。这个类不需要太多的代码。
- en: Listing 6.1 A first attempt at a base class
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 基类的一个初步尝试
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Abstract function to take a step
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 执行一步的抽象函数
- en: ❷ Abstract function returning total steps
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回总步数的抽象函数
- en: 'We can’t create an instance of this `Blob` because it has abstract functions.
    If we write some derived classes, implementing both abstract functions, we can
    make various blobs and race them. However, we haven’t declared a destructor for
    our base class. In fact, we haven’t added any of the special member functions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能创建这个 `Blob` 的实例，因为它有抽象函数。如果我们编写一些派生类，实现这两个抽象函数，我们可以创建各种 blob 并进行比赛。然而，我们没有为我们的基类声明析构函数。实际上，我们还没有添加任何特殊成员函数：
- en: '*A default constructor*—`X()`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*默认构造函数*—`X()`'
- en: '*A copy constructor*—`X(const X&)`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*拷贝构造函数*—`X(const X&)`'
- en: '*A copy assignment*—`operator = (const X&)`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*拷贝赋值运算符*—`operator = (const X&)`'
- en: '*A move constructor*—`X(X&&)`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*移动构造函数*—`X(X&&)`'
- en: '*A move assignment*—`operator = (X&&)`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*移动赋值运算符*—`operator = (X&&)`'
- en: '*A destructor* *—*`~X()`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*析构函数*—`~X()`'
- en: This means all six functions are defaulted because we haven’t defined any of
    them. Writing no code and therefore accepting the six defaults is often called
    the *rule of zero*. This is perfect for many situations. The core guidelines even
    tell us to avoid defining defaults if possible ([http://mng.bz/M9Km](http://mng.bz/M9Km));
    after all, less code usually means fewer bugs. Sometimes we do need to write some
    code, though. If we are managing memory or handles to resources, we need to ensure
    the right thing happens; otherwise, we could get memory leaks. We are not managing
    memory or handles in our class, but we need *polymorphism*, and therefore, we
    do have a problem. Consider what happens when we have a derived class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着所有六个函数都被默认定义，因为我们没有定义任何一个。不写代码并因此接受六个默认值通常被称为 *零规则*。这在许多情况下都是完美的。核心指南甚至告诉我们，如果可能的话，避免定义默认值
    ([http://mng.bz/M9Km](http://mng.bz/M9Km))；毕竟，代码越少通常意味着错误越少。尽管如此，有时我们确实需要编写一些代码。如果我们正在管理内存或资源句柄，我们需要确保发生正确的事情；否则，我们可能会得到内存泄漏。在我们的类中，我们并没有管理内存或句柄，但我们需要
    *多态性*，因此，我们确实有一个问题。考虑当我们有一个派生类时会发生什么。
- en: 'Our `Blob` has default implementations of all six special member functions,
    including a destructor. Any derived class will call a base class’ destructor automatically.
    This has always been the case in C++. We need derived classes, filling in the
    implementation of the two abstract functions, so we can race blobs. If we use
    pointers or references to various types of blobs, we can call the virtual methods,
    and the override for the derived class will be used, allowing different `step`
    implementations. We can define a *derived* class and assign a derived instance
    to a pointer to the *base* class:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Blob` 包含所有六个特殊成员函数的默认实现，包括析构函数。任何派生类都会自动调用基类的析构函数。这始终是 C++ 的情况。我们需要派生类，填充两个抽象函数的实现，这样我们就可以进行
    blob 竞赛。如果我们使用各种 blob 类型的指针或引用，我们可以调用虚拟方法，并且派生类的重写将被使用，允许不同的 `step` 实现。我们可以定义一个
    *派生* 类并将派生实例赋值给 *基* 类的指针：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can call
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以称之为
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The step taken will depend on the type of blob because the `step` function is
    *virtual*. However, when we are done, if we call
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所采取的步骤将取决于 blob 的类型，因为 `step` 函数是 *虚拟* 的。然而，当我们完成时，如果我们调用
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: only the `Blob`’s destructor gets called, not the `DerivedBlob`’s. That’s asking
    for trouble. If we delete polymorphically without a virtual destructor, we have
    undefined behavior. We need each destructor to be called. If we made a `DerivedBlob`
    pointer instead
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 只有 `Blob` 的析构函数被调用，而不是 `DerivedBlob` 的。这是在找麻烦。如果我们没有虚拟析构函数就进行多态删除，会有未定义的行为。我们需要每个析构函数都被调用。如果我们创建了一个
    `DerivedBlob` 指针而不是
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: both destructors would be called. This time, `blob` is a `DerivedBlob`, so the
    `DerivedBlob`’s destructor is called, followed by the base class’ destructor.
    The defaulted destructor is not virtual, so it is not in the v-table, as illustrated
    in figure 6.1.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个析构函数都会被调用。这次，`blob` 是 `DerivedBlob`，所以调用的是 `DerivedBlob` 的析构函数，然后是基类的析构函数。默认的析构函数不是虚拟的，所以它不在虚函数表中，如图
    6.1 所示。
- en: '![CH06_F01_Buontempo](../Images/CH06_F01_Buontempo.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F01_Buontempo](../Images/CH06_F01_Buontempo.png)'
- en: 'Figure 6.1 Virtual functions in the v-table, but not the destructor: a `Base`
    pointer calls the `Base` destructor, and a `Derived` pointer calls the `Derived`
    destructor, but a `Base` pointer to the `Derived` class does the wrong thing.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 虚函数在虚函数表中，但不是析构函数：`Base` 指针调用 `Base` 析构函数，而 `Derived` 指针调用 `Derived` 析构函数，但
    `Base` 指向 `Derived` 类的指针做了错误的事情。
- en: We want to be able to use a pointer to the base `Blob` class so we can have
    various derived classes to make an interesting race. In fact, we won’t use raw
    pointers; we’ll find out how to be smarter. Either way, we need one small change
    to fix the problem. If we flag the destructor as `virtual`, it goes in the v-table,
    and the right destructors are called for a `Base` pointer. While we are making
    this change, we can mark the copy constructor and assignment as deleted because
    we don’t need to copy blobs, and we’ll add a default constructor because a base
    class needs an appropriate constructor.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够使用指向基类 `Blob` 的指针，这样我们就可以有各种派生类来制造一个有趣的竞争。实际上，我们不会使用原始指针；我们将找出如何变得更聪明。无论如何，我们需要一个小改动来解决问题。如果我们把析构函数标记为
    `virtual`，它就会进入虚函数表，并且对于 `Base` 指针会调用正确的析构函数。当我们进行这个改动时，我们可以将拷贝构造函数和赋值操作标记为已删除，因为我们不需要复制
    blob，我们还将添加一个默认构造函数，因为基类需要一个合适的构造函数。
- en: Listing 6.2 A better base class
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 一个更好的基类
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Virtual default destructor
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 虚拟默认析构函数
- en: ❷ Default constructor
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 默认构造函数
- en: ❸ Deletes copies that are not needed
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 删除不必要的拷贝
- en: We can now safely make a concrete class deriving from `Blob`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以安全地创建一个从 `Blob` 派生的具体类。
- en: 6.1.2 A concrete class
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 一个具体类
- en: Let’s make a new type of `Blob` that will take two steps forward whenever it
    moves. This new type can derive publicly from `Blob`, so the base class’ public
    methods remain public, and the protected members remain protected, but any private
    members in the base class are inaccessible to the derived class. For a reminder
    of how public, protected, and private access modifiers behave, see CppReference
    ([https://en.cppreference.com/w/cpp/language/access](https://en.cppreference.com/w/cpp/language/access)).
    We have three public methods, so these remain public, and we have nothing else
    to consider.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一种新的 `Blob` 类型，每次移动时都会前进两步。这种新类型可以从 `Blob` 公开派生，因此基类的公共方法仍然是公共的，受保护的成员仍然是受保护的，但基类中的任何私有成员对派生类都是不可访问的。为了提醒如何使用公共、受保护和私有访问修饰符，请参阅
    CppReference ([https://en.cppreference.com/w/cpp/language/access](https://en.cppreference.com/w/cpp/language/access))。我们有三个公共方法，所以这些仍然是公共的，我们没有其他需要考虑的。
- en: We need to implement the abstract functions to make a concrete class. We can
    define these inline in the class because they both need only a single line of
    code. For larger functions, we would use a separate source file and put the definitions
    there.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现抽象函数来创建一个具体类。由于这两个函数都只需要一行代码，我们可以在类中内定义这些函数。对于更大的函数，我们会使用单独的源文件并将定义放在那里。
- en: 'To implement the functions, we *override* them by writing a function with the
    exact same signature. The base class’s member functions must be virtual; otherwise,
    we are *hiding* rather than overriding a function. This has always been the case
    in C++. If you’ve forgotten the details, see Item 33: Avoid hiding inherited names
    in Scott Meyers’ book *Effective C++* (Addison-Wesley Professional, 2005; 3rd
    edition). C++11 introduced the `override` specifier, which we can add to the end
    of the declaration of a member function to make clear we are overriding a function.
    This means the compiler can tell us if we fail to write the signature correctly.
    For example, it’s very easy to forget the word `const` and end up with two different
    functions. We can also use the keyword `final` if we don''t want any further derived
    classes to override the virtual method.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现函数，我们通过编写一个与确切签名完全相同的函数来*重写*它们。基类的成员函数必须是虚拟的；否则，我们是在*隐藏*而不是重写一个函数。这在C++中始终如此。如果你忘记了细节，请参阅斯科特·梅耶斯（Scott
    Meyers）的书籍《Effective C++》（Addison-Wesley Professional，2005；第3版）中的项目33：避免在Scott
    Meyers的《Effective C++》中隐藏继承的名称。C++11引入了`override`指定符，我们可以将其添加到成员函数声明的末尾，以明确表示我们正在重写一个函数。这意味着编译器可以告诉我们是否未能正确编写签名。例如，很容易忘记单词`const`并最终得到两个不同的函数。如果我们不希望任何进一步的派生类重写虚拟方法，我们还可以使用关键字`final`。
- en: Both the `step` and `total_steps` functions use the number of steps so far.
    The former will add to the total steps, and the latter will report the total steps.
    Our new type of blob will take two steps at a time, so it needs to increase the
    total number of steps by two. We can remember the number of steps taken so far
    in an `int` called `y`, indicating the `y` coordinate of a blob. Nothing else
    should use the variable, so we make it private. Our stepper class goes in the
    `Race` header file inside the namespace, implementing the two virtual functions
    inline.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`step`和`total_steps`函数都使用到目前为止的步数。前者将添加到总步数，后者将报告总步数。我们的新类型blob每次需要走两步，因此它需要将总步数增加两步。我们可以在一个名为`y`的`int`中记住到目前为止所走的步数，表示blob的`y`坐标。其他任何东西都不应该使用这个变量，所以我们将其设置为私有。我们的步进类放在命名空间内的`Race`头文件中，并内联实现两个虚拟函数。'
- en: Listing 6.3 A blob taking constant-sized steps
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.3 一个走固定大小步长的blob
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Private int to keep track of steps
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用于跟踪步骤的私有整型变量
- en: ❷ Two steps forward
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 向前两步
- en: ❸ Total number of steps so far
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 到目前为止的总步数
- en: 'We can now create a stepper blob:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个步进blob：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In fact, we can add a `check_properties` function like we have done before and
    use `asserts` to check what our code does. If we put this in `main.cpp`, we can
    check that a step moves us forward by two.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以添加一个类似于我们之前所做过的`check_properties`函数，并使用`asserts`来检查我们的代码做了什么。如果我们将其放在`main.cpp`中，我们可以检查一步是否使我们向前移动两步。
- en: Listing 6.4 Checking that steps move a blob forward
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.4 检查步数是否使blob向前移动
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can now build a race. We only have one type of concrete blob, so we know
    in advance there will be no winners or losers, but it gives us a simple warm-up
    race. We need to decide how to represent the blobs and how to draw the bag.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以构建一场赛跑。我们只有一个具体的blob类型，因此我们事先知道不会有赢家或输家，但这给我们提供了一个简单的热身赛跑。我们需要决定如何表示blob以及如何绘制袋子。
- en: 6.1.3 Warming up for a race
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 为赛跑做准备
- en: We can put a few `StepperBlobs` in a virtual paper bag and let them walk up
    the screen. We will use the abstract base class later when we introduce a new
    type of blob. For this section, we will concentrate on representing the `StepperBlobs`
    in the race. If we used a proper graphics library, we could build a magnificent
    display; however, we have lots more to learn about C++. The SFML (Simple and Fast
    Multimedia Library; see [https://www.sfml-dev.org/index.php](https://www.sfml-dev.org/index.php))
    is relatively easy to get up and running if you want to give it a try. We’ll stick
    with using the console here.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个虚拟的纸袋中放几个`StepperBlobs`并让它们在屏幕上行走。我们将在介绍新类型的blob时使用抽象基类。对于本节，我们将专注于在赛跑中表示`StepperBlobs`。如果我们使用合适的图形库，我们可以构建一个壮观的显示；然而，我们还有更多关于C++要学习。如果你想尝试，SFML（Simple
    and Fast Multimedia Library；见[https://www.sfml-dev.org/index.php](https://www.sfml-dev.org/index.php)）相对容易上手。在这里，我们将坚持使用控制台。
- en: First of all, we need a paper bag. We decided to represent the paper bag using
    `|` and `-` for the edges and a trail of `*`s for a blob.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个纸袋。我们决定使用`|`和`'-'`来表示边缘，并用`*`的轨迹来表示块。
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ll make the bag three rows high and build up the display using strings for
    each row. Each row starts with either a `'|'` and a space, or two spaces if we
    are above the bag, and then two spaces, or `" *"`, per blob, and a final `'|'`.
    The final row consists of `'-'` characters for the bottom of the bag.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使袋子高度为三行，并使用每行的字符串来构建显示。每行以一个`'|'`和一个空格开始，如果我们位于袋子之上，则为两个空格，然后是每个块两个空格或`"
    *"`，最后是一个`'|'`。最后一行由表示袋子底部的`'-'`字符组成。
- en: Let’s write a drawing function, taking the `vector` of `StepperBlobs`, so we
    can draw the blobs along with the paper bag. We can put four such blobs in a vector
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个绘图函数，接受`StepperBlobs`的`vector`，这样我们就可以绘制块和纸袋。我们可以在一个向量中放置四个这样的块
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: and pass this to the function, allowing us to vary the number of blobs. We could
    use an `std::array` instead if we wanted, but `std::vector` means we could vary
    the number at run time if we wanted to. As we sweep through each row, we can check
    the current `y` coordinate against each blob’s total steps. If the `y` position
    is higher than a blob, we show two spaces; otherwise, we use a space and then
    an `*`. We made the `steps` function constant because it doesn’t change a blob,
    so we can pass a `const` reference to a `vector` to the drawing function. We'll
    put the new function in a `Race.cpp` file, remembering to add the declaration
    to the header file. We need the `iostream` and `string` headers too.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 并将此传递给函数，使我们能够改变块的数量。如果我们想的话，可以使用`std::array`，但`std::vector`意味着我们可以在运行时改变数量。当我们遍历每一行时，我们可以将当前的`y`坐标与每个块的总步数进行比较。如果`y`位置高于一个块，我们显示两个空格；否则，我们使用一个空格然后是一个`*`。我们使`steps`函数为常量，因为它不会改变块，所以我们可以将`vector`的常量引用传递给绘图函数。我们将新函数放在`Race.cpp`文件中，并记得在头文件中添加声明。我们还需要`iostream`和`string`头文件。
- en: Listing 6.5 Drawing each blob’s current position
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.5绘制每个块当前的位置
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Left side of bag
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 袋子的左侧
- en: ❷ Blob leaving a trail
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 带有轨迹的块
- en: ❸ No blob here
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这里没有块
- en: ❹ Right side of bag
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 袋子的右侧
- en: ❺ Bottom of bag
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 袋子的底部
- en: We want the blobs to step, so we need another function, `move_blobs`. Because
    the blobs change state when they step, we pass our vector by non-const reference.
    Again, we will use `StepperBlob` here and build up to using different types of
    `Blob` in the next section. We need to add the signature to the header and include
    the `vector` header too.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想让块移动，所以我们需要另一个函数，`move_blobs`。因为块在移动时改变状态，所以我们通过非常量引用传递我们的向量。同样，我们在这里将使用`StepperBlob`并构建到下一节中使用不同类型的`Blob`。我们需要将签名添加到头文件中，并包含`vector`头文件。
- en: Listing 6.6 Declarations in the header file
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.6头文件中的声明
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Blob and stepper like before
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 块和步进器与之前相同
- en: ❷ Function signatures
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 函数签名
- en: We then define the function in the `Race.cpp` file. We can use a range-based
    `for` loop to let each blob take a step.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`Race.cpp`文件中定义该函数。我们可以使用基于范围的`for`循环让每个块迈一步。
- en: Listing 6.7 Moving all the blobs
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.7移动所有块
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Pass by reference
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过引用传递
- en: ❷ Reference to each blob
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对每个块的引用
- en: ❸ Makes blob step
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使块移动
- en: 'If we call these functions in a loop, we’ll have a race. We can clear the screen
    and sleep for a little while between updates. We’ve used the thread’s `sleep_for`
    previously in our countdown in listing 4.11, so pausing is straightforward. If
    we include the `thread` header, we can pause using `chrono` literals, such as
    `1000ms`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在循环中调用这些函数，我们将有一个比赛。我们可以在更新之间清除屏幕并稍微暂停一下。我们之前在列表4.11的倒计时中使用了线程的`sleep_for`，所以暂停是直接的。如果我们包含`thread`头文件，我们可以使用`chrono`文字（如`1000ms`）来暂停：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, there is no platform-independent way to clear a screen in C++. Sometimes
    C++ is used for embedded devices without screens, so that makes sense. However,
    using specific control characters usually works on Linux, Windows, or macOS:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在C++中没有一种平台无关的方法来清除屏幕。有时C++用于没有屏幕的嵌入式设备，这很有意义。然而，使用特定的控制字符通常在Linux、Windows或macOS上有效：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `\x1B` introduces a control character, `[2J` clears the screen, and `[H`
    moves the cursor to the top left. If it doesn’t work on your setup, just print
    a new line character `'\n'` instead, and you’ll get each frame shown down the
    screen. Again, we add the signature
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`\x1B`引入了一个控制字符，`[2J`清除屏幕，`[H`将光标移动到左上角。如果它在您的设置上不起作用，只需打印一个换行符`''\n''`，您将得到屏幕上显示的每一帧。同样，我们添加了签名'
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: to the header file and put the implementation in the source file. The race calls
    our `draw_blobs` and `move_blobs` functions for a while, pausing and clearing
    the screen between each call.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将实现放入源文件。比赛会调用我们的 `draw_blobs` 和 `move_blobs` 函数一段时间，并在每次调用之间暂停和清屏。
- en: Listing 6.8 A somewhat predictable race
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.8 一个有点可预测的比赛
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Clears screen or changes to '\n' if needed
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果需要，清除屏幕或更改到 '\n'
- en: ❷ Pauses
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 暂停
- en: We need to call this from `main` with a `vector` of blobs. Don’t forget to include
    the `Race.cpp` in your build.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从 `main` 函数中调用这个操作，并使用 Blob 的 `vector`。别忘了在你的构建中包含 `Race.cpp`。
- en: Listing 6.9 A warm-up race
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.9 一个热身比赛
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When we run this, the blobs move in lockstep, so they all escape together.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，Blob 会同步移动，因此它们会一起逃逸。
- en: '|'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: It is not much of a race but is a simple demonstration of how to code our way
    out of a paper bag. We’re almost ready to make different types of blobs. Before
    we do, let’s think a bit more about the six special member functions that classes
    might have. Pausing to check which functions are present and absent will help
    cement the six special functions in our minds.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个真正的比赛，而是一个简单的演示，说明如何用代码从纸袋中走出来。我们几乎准备好制作不同类型的 Blob。在我们这样做之前，让我们再思考一下类可能拥有的六个特殊成员函数。暂停以检查哪些函数存在和不存在将有助于在我们的脑海中巩固这六个特殊函数。
- en: 6.1.4 Using type traits to check for special member functions
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.4 使用类型特性检查特殊成员函数
- en: 'Before C++11, we had the *rule of three*: defining a destructor, a copy constructor,
    or a copy assignment operator for a class almost certainly requires all three
    to be defined. If any one of these functions needed to do something special, like
    clone a resource, the others would need to do something appropriate too. Since
    C++11, we must consider move construction and move assignment too, leading to
    what is known as the *rule of five*. In fact, we noted that a class can have six
    possible special member functions. The compiler will generate all six operations
    if we do not define any of them. We added a virtual destructor to the base class
    to allow polymorphic use. So do we know which of the other functions are still
    implicitly defined for us? Do we care? Maybe. If the moves are not available for
    a type, an optimization opportunity may be missed. Remember, we considered two
    versions of `push_back` for a `vector` in chapter 2:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 之前，我们有“三法则”：为一个类定义析构函数、拷贝构造函数或拷贝赋值运算符几乎肯定需要定义所有三个。如果这些函数中的任何一个需要执行特殊操作，比如克隆资源，其他函数也需要执行适当的操作。自
    C++11 以来，我们必须考虑移动构造和移动赋值，这导致了所谓的“五法则”。实际上，我们注意到一个类可以有六个可能的特殊成员函数。如果我们没有定义任何一个，编译器将生成所有六个操作。我们在基类中添加了一个虚析构函数，以允许多态使用。那么，我们是否知道其他哪些函数仍然为我们隐式定义了？我们是否关心？也许吧。如果一个类型不支持移动操作，可能会错过优化机会。记住，我们在第
    2 章中考虑了 `vector` 的两个 `push_back` 版本：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first version makes a copy of the value at the end of the vector, while
    the second version avoids the copy by moving the value. If the type cannot be
    moved, the first version will be used.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个版本在向量的末尾复制值，而第二个版本通过移动值避免了复制。如果类型不支持移动，将使用第一个版本。
- en: Our `Blob` class is abstract, so we can’t make one and try to copy or move it.
    How do we test such a class? At the very least, we need the base class to be virtually
    destructible and not able to be constructed. We can try to find out which functions
    a `Blob` has if we use *type traits*. They live in the `type_traits` header, introduced
    in C++11\. The traits make various operations discoverable via template structs,
    which take a type and populate a Boolean member called `value,` telling us whether
    the operation or trait is supported (see http://mng.bz/yZDE). We can query
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Blob` 类是抽象的，所以我们不能创建一个实例并尝试复制或移动它。我们如何测试这样的类？至少，我们需要基类是虚拟析构的并且不能被构造。如果我们使用
    *类型特性*，我们可以尝试找出 `Blob` 有哪些函数。它们位于 C++11 中引入的 `type_traits` 头文件中。特性通过模板结构体提供各种操作的可发现性，这些结构体接受一个类型并填充一个名为
    `value` 的布尔成员，告诉我们操作或特性是否受支持（见 http://mng.bz/yZDE）。我们可以查询
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'and discover the Blob is not constructible. Rather than spelling out `value`,
    we can use `_v` instead:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 并发现 Blob 是不可构造的。我们不必明确写出 `value`，我们可以使用 `_v` 代替：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Various helper templates ending with `_v` equating to the `value` member were
    introduced in C++17\. In either case, we provide the type we are concerned about
    to the template and receive a Boolean. Reassuringly, `Blob` is not constructible.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++17 中引入了各种以 `_v` 结尾的辅助模板，这些模板与 `value` 成员相等。在任一情况下，我们将我们关心的类型提供给模板，并接收一个布尔值。令人放心的是，`Blob`
    是不可构造的。
- en: In fact, the `is_constructible` trait can check for various ways to construct
    an object. CppReference (see [http://mng.bz/XqyM](http://mng.bz/XqyM)) shows us
    the declaration
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`is_constructible` 特性可以检查构建对象的各种方式。CppReference（见 [http://mng.bz/XqyM](http://mng.bz/XqyM)）向我们展示了声明
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We met the three dots or *parameter pack* in the last chapter when we used
    `std:: variant`. We can try other types to see if we can make a `Blob` from them.
    For example, we can verify that a `Blob` cannot be constructed with an `int` by
    checking whether'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 `std::variant` 的上一章中，我们遇到了三个点或 *参数包*。我们可以尝试其他类型，看看我们能否从它们中创建一个 `Blob`。例如，我们可以通过检查是否无法使用
    `int` 构造 `Blob` 来验证这一点。
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: is false. We can also use `is_default_constructible_v` to specifically check
    for a default constructor.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 是错误的。我们还可以使用 `is_default_constructible_v` 来专门检查默认构造函数。
- en: Type traits cover more than construction. We briefly met concepts in chapter
    4 and considered using `invocable` from the `concepts` header to ensure a template
    parameter was invocable or callable. The `type_traits` header has an `is_invocable`
    trait to discover if the concept applies to a type. We can check a variety of
    other traits too. Have a look through the `type_traits` header. Traits operate
    on a type at compile time, so they are part of the *metaprogramming* library,
    along with the `ratio` header we met in chapter 4, as well as integer sequences,
    which we haven’t looked at yet.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 类型特性不仅涵盖构造。我们在第 4 章中简要介绍了概念，并考虑使用来自 `concepts` 头文件的 `invocable` 来确保模板参数是可调用的或可调用的。`type_traits`
    头文件有一个 `is_invocable` 特性，用于确定概念是否适用于类型。我们还可以检查其他各种特性。请查看 `type_traits` 头文件。特性在编译时对类型进行操作，因此它们是
    *元编程* 库的一部分，包括我们在第 4 章中遇到的 `ratio` 头文件，以及我们尚未查看的整数序列。
- en: Let’s see if we can check which of the six member functions our base class has
    and ensure the destructor is virtual as well. The traits are `constexpr`, so we
    can use `static_assert` in the `check_properties` function we made in listing
    6.4\.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们能否检查基类具有哪些六个成员函数，并确保析构函数也是虚拟的。特性是 `constexpr`，因此我们可以在我们为列表 6.4 制作的 `check_properties`
    函数中使用 `static_assert`。
- en: Listing 6.10 Type traits to check for special member functions
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.10 检查特殊成员函数的类型特性
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Previous checks
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 之前的检查
- en: ❷ Checks six member functions
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查六个成员函数
- en: ❸ Checks destructor is virtual
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查析构函数是虚拟的
- en: Some values are true, and some are false. We can’t construct a blob at all,
    even via copies or moves, because `Blob` is an abstract class with pure virtual
    member functions, but we do have a virtual destructor. However, the move construction
    and move assignment checks might be misleading. The `is_move_constructible` trait
    tells us if a type can be constructed from an rvalue reference. Our blob isn’t
    constructible, so it can’t be move constructed at all. The move-constructible
    trait is *not checking for the presence of a move constructor*; rather, it is
    checking to see if a type can be constructed from an rvalue of the same type.
    The `is_move_assignable` tells us if a type can be assigned from an rvalue, and
    that can mean a function taking a `const` lvalue, because a `const` lvalue reference
    can bind to rvalues. The trait is *not checking for the presence of a move assignment
    operator*. Do we have the move special functions?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一些值是真实的，而另一些是错误的。我们根本无法通过复制或移动来构建一个 blob，因为 `Blob` 是一个具有纯虚成员函数的抽象类，但我们确实有一个虚析构函数。然而，移动构造和移动赋值检查可能具有误导性。`is_move_constructible`
    特性告诉我们一个类型是否可以从右值引用中构造。我们的 blob 不可构造，因此根本不能进行移动构造。移动构造特性 *不是检查移动构造函数的存在*；而是检查类型是否可以从相同类型的右值中构造。`is_move_assignable`
    告诉我们一个类型是否可以从右值中赋值，这可能意味着一个接受 `const` 指向左值的函数，因为 `const` 指向左值引用可以绑定到右值。特性 *不是检查移动赋值运算符的存在*。我们是否有移动特殊函数？
- en: In fact, adding our own destructor blocks implicit moves (see [http://mng.bz/QR6e](http://mng.bz/QR6e)).
    The type traits are telling us if we can assign from a temporary, or rvalue, but
    we are likely to get copies rather than moves. Because we disabled copies, we
    can’t move or copy a blob. Failing to provide a move constructor and move assignment
    operator is not an error, but we are missing an optimization opportunity, as we
    noted when we considered the two versions of `push_back` for a `vector`. In Item
    17 of *Effective Modern C*++ (O’Reilly Media, Incorporated, 2014), Scott Meyers
    points out that moves are requests. If a type is not move enabled, any `"moves"`
    are actually copies. Furthermore, he tells us that *C++ does not generate move
    operations for a class with a user-declared destructor*. The simplest solution
    is to declare the move special functions using `=default`. When we do this, the
    `copy` functions will be disabled! We deleted them because we don’t need them.
    We can declare them if we think we need them. This is often referred to as the
    *rule of five*. Either stick with the rule of zero, accepting the defaults, or
    declare or delete all five of the special members along with the constructors
    according to your needs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，添加我们自己的析构函数阻止了隐式移动（见[http://mng.bz/QR6e](http://mng.bz/QR6e)）。类型特性告诉我们是否可以从临时对象或右值赋值，但我们很可能会得到副本而不是移动。因为我们禁用了副本，所以我们不能移动或复制一个blob。未能提供移动构造函数和移动赋值运算符不是错误，但正如我们在考虑`vector`的`push_back`的两个版本时所指出的，我们错过了一个优化机会。在《有效现代C++》的第17项（O'Reilly
    Media, Incorporated, 2014）中，Scott Meyers指出，移动是请求。如果一个类型不是移动启用，任何“移动”实际上都是复制。此外，他告诉我们*C++不会为具有用户声明的析构函数的类生成移动操作*。最简单的解决方案是使用`=default`声明移动特殊函数。当我们这样做时，`copy`函数将被禁用！我们删除了它们，因为我们不需要它们。如果我们认为需要，我们可以声明它们。这通常被称为*5条规则*。要么坚持零规则，接受默认值，要么根据您的需求声明或删除所有五个特殊成员以及构造函数。
- en: 'Now, if we delete a single special member function, the move-assignment and
    all the other special member functions are implicitly deleted. Peter Sommerlad
    suggests deleting the move assignment if a destructor is defined. He calls this
    pattern *DesDeMovA: Des*tructor => *De*lete *Mov*e *A*ssignment (for an overview,
    see [http://mng.bz/46Eg](http://mng.bz/46Eg)). Disabling copies of polymorphic
    classes can be sensible. We’ll examine this along with other design considerations
    at the end of the chapter. Keep in mind that adding a `destructor` or other special-member
    function may disable others, so you may need to explicitly add a function if you
    need it. The `type_traits` can be used to check which functions you have.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，如果我们删除一个特殊的成员函数，移动赋值和所有其他特殊成员函数都将隐式删除。Peter Sommerlad建议如果定义了析构函数，则删除移动赋值。他称这种模式为*DesDeMovA:
    析构 => 删除 移动 赋值*（概述见[http://mng.bz/46Eg](http://mng.bz/46Eg)）。禁用多态类的副本可能是合理的。我们将在本章末尾与其他设计考虑因素一起探讨这一点。请记住，添加`析构函数`或其他特殊成员函数可能会禁用其他函数，因此如果您需要，可能需要显式添加一个函数。可以使用`type_traits`来检查您有哪些函数。'
- en: This is a big topic. Howard Hinnant talks about it in “Everything You Ever Wanted
    to Know About Move Semantics,” if you want to learn more (ee [https://www.youtube.com/watch?v=vLinb2fgkHk](https://www.youtube.com/watch?v=vLinb2fgkHk)).
    He has also said, “I don’t follow a ‘rule of 5.’ After all, there are 6 special
    members.” (See [http://howardhinnant.github.io/classdecl.html](http://howardhinnant.github.io/classdecl.html).)
    This article provides a neat table showing which of the special members are default
    or blocked when we define one of the other functions. He suggests being explicit
    about what you do and do not want in your class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很大的主题。Howard Hinnant在“你一直想知道的关于移动语义的一切”中讨论了这一点，如果您想了解更多（见[https://www.youtube.com/watch?v=vLinb2fgkHk](https://www.youtube.com/watch?v=vLinb2fgkHk)）。他还说过，“我不遵循‘5条规则’。毕竟，有6个特殊成员。”（见[http://howardhinnant.github.io/classdecl.html](http://howardhinnant.github.io/classdecl.html)。）这篇文章提供了一个整洁的表格，显示了当我们定义其他函数之一时，哪些特殊成员是默认的或被阻止的。他建议在您的类中明确指出您想要和不需要的内容。
- en: Our `Blob` class from listing 6.2 works well enough for our race. We made one
    concrete class derived from the `Blob`. We even had a warm-up race. Let’s make
    another type of blob so we can have a proper race.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从6.2列表中的`Blob`类在我们的比赛中工作得很好。我们从一个`Blob`派生了一个具体的类。我们甚至进行了一次热身赛。让我们再创建一种类型的blob，这样我们就可以进行一场真正的比赛。
- en: 6.2 Writing and using derived classes in a vector
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 在向量中使用派生类进行编写和运用
- en: Let’s make another stepper that takes a varying number of steps each time, using
    random numbers. The `StepperBlob` always takes two steps. Creating a new type
    of `Blob` taking two steps on average but possibly fewer or more seems like a
    suitable racing opponent. Either is likely to win. We can use a uniform distribution
    to generate a whole number of steps from `0` to `4` using
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再做一个步进器，每次都采取不同的步数，使用随机数。`StepperBlob`总是采取两个步骤。创建一个新的`Blob`类型，平均每步两个步骤，但可能更多或更少，似乎是一个合适的对手。任何一种都有可能获胜。我们可以使用均匀分布来生成一个从`0`到`4`的整数步数，使用
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We need a seeded engine, which we’ve seen before. We can use `random_device`
    for the seed
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个带种子的引擎，我们之前已经见过。我们可以使用`random_device`作为种子
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'and pass the engine to the distribution to get a number:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 并将引擎传递给分布以获取一个数字：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Without the seed, the engine will use a default value and give the same sequence
    each time we run the code. The `default_random_engine` is usually a Mersenne Twister,
    the `mt19937`. This class has two constructors we can use to seed the engine.
    We’ve used the version taking a single number. The second version takes a seed
    sequence, `seed_seq`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 没有种子，引擎将使用默认值，并在每次运行代码时给出相同的序列。`default_random_engine`通常是Mersenne Twister，即`mt19937`。这个类有两个构造函数，我们可以使用它们来给引擎设置种子。我们已经使用了接受单个数字的版本。第二个版本接受一个种子序列，`seed_seq`：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In theory, the `seed_seq` can give a greater variety of outcomes each time we
    run the program, and it does allow us to provide a few seeds in a sequence. If
    the seeds themselves are all random too, we get even more variety. Either approach
    is fine for when we only need tens, hundreds, or thousands of random outcomes,
    and the simplest approach using a single number is fine for the simple games we
    have written. If we ever need millions or billions of different possible sequences
    of numbers, we’ll need to put in more thought. There is a proposal to extend C++11’s
    random number generators (see [https://wg21.link/P1932](https://wg21.link/P1932)),
    which gives further details on the limits of the current engines. C++11’s random
    library is completely fine for the games we are making in this book. Problems
    will only arise if you want to run huge Monte-Carlo simulations or need cryptographic
    random numbers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在理论上，`seed_seq`可以在每次运行程序时提供更多样化的结果，并且它确实允许我们在序列中提供几个种子。如果种子本身也是随机的，我们就能得到更多的多样性。这两种方法在只需要几十、几百或几千个随机结果时都适用，而对于我们编写的简单游戏，使用单个数字的最简单方法也足够好。如果我们需要数百万或数十亿种不同的数字序列，我们就需要更多思考。有一个提议要扩展C++11的随机数生成器（见[https://wg21.link/P1932](https://wg21.link/P1932)），它提供了关于当前引擎限制的更多详细信息。C++11的随机库对于我们在本书中制作的游戏来说完全足够。只有在你想运行巨大的蒙特卡洛模拟或需要加密随机数时，才会出现问题。
- en: 6.2.1 A blob moving randomly
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 一个随机移动的blob
- en: 'We could build a new class, containing a `uniform_int_distribution` and a generator,
    giving us a new type of blob. We would use these in the `step` function, adding
    the random number obtained to the current steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建一个新的类，包含一个`uniform_int_distribution`和一个生成器，给我们一个新的blob类型。我们将在`step`函数中使用这些，将获得的随机数加到当前的步骤中：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If we wanted to use each of the distributions in C++, we would end up writing
    20 different classes. That feels repetitive.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在C++中使用每个分布，我们最终会编写20个不同的类。这感觉有些重复。
- en: The distributions do not have a common base class, but they all have an `operator()`
    taking a generator, which they use to create the next random number fitting the
    distribution. We can therefore write a class template taking a generator and distribution
    as types. We need a generator and a distribution member of the type specified
    in the template. We’ll pass both into a constructor, which means we can pass anything,
    including some mocked generators for testing, provided they have the operator
    we need for the `step` function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 分布没有共同的基类，但它们都有一个接受生成器的`operator()`，它们使用它来创建符合分布的下一个随机数。因此，我们可以编写一个模板类，它接受生成器和分布作为类型。我们需要一个生成器和分布成员，其类型由模板指定。我们将它们都传递给构造函数，这意味着我们可以传递任何东西，包括一些用于测试的模拟生成器，只要它们有`step`函数所需的操作符。
- en: The new class, `RandomBlob`, needs to derive publicly from `Blob`, like the
    `StepperBlob` did. The `total_steps` function still returns the total number of
    steps *y*. The `step` function uses the generator and distribution to obtain a
    random step. Some of the distributions return a double or float rather than an
    integer, so we can use a `static_ cast` to obtain an integer.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 新的类 `RandomBlob` 需要像 `StepperBlob` 一样公开继承自 `Blob`。`total_steps` 函数仍然返回总步数 *y*。`step`
    函数使用生成器和分布来获取一个随机步骤。一些分布返回的是双精度浮点数或浮点数而不是整数，因此我们可以使用 `static_cast` 来获取整数。
- en: Listing 6.11 A general-purpose random blob
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.11 一个通用随机blob
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Generator and distribution types
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 生成器和分布类型
- en: ❷ Adds a random step
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 添加一个随机步骤
- en: 'We make a `RandomBlob` using an engine and distribution. We can use a uniform
    distribution taking between zero and four steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用引擎和分布来创建一个 `RandomBlob`。我们可以使用一个在零到四个步骤之间的均匀分布：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can change the distribution parameter to get a blob that behaves differently.
    We can use a normal distribution, with mean 2.0 and a standard deviation of 1.0,
    indicating how likely numbers are to deviate from the mean. Bigger means more
    extreme values are likely:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更改分布参数以获得行为不同的blob。我们可以使用一个均值为2.0和标准差为1.0的正态分布，这表明数字偏离平均值的可能性。更大的值意味着更极端的值更有可能：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The parameters `2.0` and `1.0` mean something very different for this distribution.
    They no longer tell us the minimum and maximum values. Each distribution has different
    parameters specific to the underlying distribution function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 `2.0` 和 `1.0` 对于这个分布来说意义大不相同。它们不再告诉我们最小值和最大值。每个分布都有针对底层分布函数的特定参数。
- en: 'C++11’s `random` library supports various distributions (see [https://en.cppreference.com/w/cpp/header/random](https://en.cppreference.com/w/cpp/header/random)):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: C++11的 `random` 库支持各种分布（见[https://en.cppreference.com/w/cpp/header/random](https://en.cppreference.com/w/cpp/header/random)）：
- en: '*Uniform ints and reals*—Suitable for picking a number in a range with equal
    likelihood.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*均匀整数和实数*—适合在范围内以相等可能性选择一个数字。'
- en: '*Bernoulli and related binomial distributions*—Useful for modeling the number
    of successes or failures.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*伯努利和相关二项分布*—用于模拟成功或失败的数量。'
- en: '*Poisson distribution*—Modeling how many times an event might happen in a period
    of time; for example, how many buses might turn up in the next few minutes.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*泊松分布*—模拟在一段时间内事件可能发生的次数；例如，在接下来的几分钟内可能会有多少公交车到达。'
- en: '*Normal related distributions*—Producing real (rather than integer) values.
    This group has six distributions: normal, lognormal, Chi-squared, Cauchy, Fisher,
    and student. These can be used for a huge variety of models, but the normal is
    commonly used for people’s heights and other situations where most values tend
    to be nearer the mean, or average, but extreme values are possible.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与正态分布相关的分布*—产生实数（而不是整数）值。这一组有六个分布：正态分布、对数正态分布、卡方分布、柯西分布、费舍尔分布和t分布。这些可以用于大量不同的模型，但正态分布通常用于人们的身高和其他大多数值趋向于接近平均值或平均的情况，但极端值是可能的。'
- en: '*Sampling distributions*—Similar to the uniform distributions but allow us
    to make specific values or ranges of values more likely by providing a weighting.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*抽样分布*—类似于均匀分布，但通过提供权重，可以使特定的值或值范围更有可能。'
- en: In each case, the distribution uses a *probability function* to smear out numbers
    provided by the engine to give the required properties of the distribution. For
    a uniform distribution, each number must be equally likely. For a normal distribution,
    values near the mean are more likely than extreme values. Lots of interesting
    mathematics are lurking behind this, but generating a plot of probability functions
    used gives us an idea of how many steps are likely. CppReference gives the function
    used for each distribution. Comparing the `uniform_int_distribution` and `normal_distribution`
    we considered, we get plots as shown in figure 6.2.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，分布使用一个 *概率函数* 将引擎提供的数字平滑化，以给出分布所需的各种属性。对于均匀分布，每个数字必须具有相等的可能性。对于正态分布，接近平均值的值比极端值更有可能。许多有趣的数学原理隐藏在这背后，但生成概率函数的图表可以让我们了解可能有多少步骤。CppReference提供了每个分布使用的函数。比较我们考虑的
    `uniform_int_distribution` 和 `normal_distribution`，我们得到如图6.2所示的图表。
- en: '![CH06_F02_Buontempo](../Images/CH06_F02_Buontempo.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F02_Buontempo](../Images/CH06_F02_Buontempo.png)'
- en: Figure 6.2 Random uniform steps on [0, 4] and normally distributed steps with
    mean 2.0 and standard deviation of 1.0
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 [0, 4] 上的随机均匀步骤和均值为2.0、标准差为1.0的正态分布步骤
- en: On average, we expect two steps from either of these distributions. The normal
    distribution might take many more or even go backwards, while the uniform steps
    are never negative. We can use any other distributions we want. We can even use
    a fake for testing. The template-head we used
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 平均而言，我们期望从这两个分布中任选其一有两次步骤。正态分布可能需要更多步骤，甚至可能倒退，而均匀分布的步骤永远不会是负数。我们可以使用我们想要的任何其他分布。我们甚至可以使用一个假的来测试。我们使用的模板头
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: has no constraints at all, so the `T` and `U` can be anything. We learn about
    requirements and concepts in chapter 4, noting we can constrain parameters with
    concepts, such as invocable
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何约束，所以`T`和`U`可以是任何东西。我们在第4章中学习了要求和概念，注意到我们可以使用概念约束参数，例如`invocable`。
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: to ensure only a function taking two integers is passed as the message parameter
    to our number-guessing game. Our `RandomBlob` needs an `invocable` generator taking
    no parameters, written as `std::invocable<>`. The named requirement lives in the
    `concepts` header, so if we include the header, we can swap the `typename` keyword
    to the constraint
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 确保只有接受两个整数作为消息参数的函数被传递到我们的数字猜谜游戏中。我们的`RandomBlob`需要一个接受无参数的`invocable`生成器，写作`std::invocable<>`。命名要求位于`concepts`头文件中，因此如果我们包含该头文件，我们可以将`typename`关键字替换为约束
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: to be more specific and get better error messages if we use an unsuitable type.
    In fact, CppReference gives named requirements for random numbers (see [https://en.cppreference.com/w/cpp/named_req](https://en.cppreference.com/w/cpp/named_req)),
    including a `RandomNumberEngine` and a `RandomNumberDistribution`. These named
    requirements would allow us to be more precise; however, only some of the requirements
    listed were formalized in the C++20 concepts library. Constraining the generator
    to be `invocable` is good enough for our simple game.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要更具体，如果使用不合适的数据类型，我们可以得到更好的错误信息。实际上，CppReference为随机数提供了命名要求（见[https://en.cppreference.com/w/cpp/named_req](https://en.cppreference.com/w/cpp/named_req)），包括`RandomNumberEngine`和`RandomNumberDistribution`。这些命名要求可以让我们更加精确；然而，只有列出的要求中的一些在C++20概念库中得到了形式化。将生成器约束为`invocable`对于我们的简单游戏来说已经足够好了。
- en: Another important thing we can do is add tests for our code, using a lambda
    for the generator and engine, with very little effort. Returning `0` instead of
    a random number often helps to find bugs since the mathematics with zeros is often
    easy to do in our heads. We can make a “generator” that always returns `0` and
    call it in a “distribution” lambda to pass that `0` back.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以做的一件重要的事情是为我们的代码添加测试，使用lambda表达式作为生成器和引擎，几乎不需要任何努力。返回`0`而不是随机数通常有助于找到错误，因为用零进行的数学运算通常很容易在脑海中完成。我们可以创建一个总是返回`0`的“生成器”，并在“分布”lambda中调用它，以传递那个`0`。
- en: Listing 6.12 Testing with random generators and distributions
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.12 使用随机生成器和分布进行测试
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ Generates 0 every time
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每次都生成0
- en: ❷ Passes on the 0
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 传递0
- en: ❸ Takes a random step
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 取一个随机步骤
- en: ❹ 0 total steps
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 总步骤数为0
- en: 'We can make all kinds of different random blobs now. The warm-up race used
    a `vector` of `StepperBlobs`. We could make a `vector` of `RandomBlobs`, but how
    can we make the stepper and random blobs compete? They are different types, but
    they do share a common base type. We could put raw pointers in a `vector`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以制作各种不同的随机blob。预热赛使用了一个`StepperBlobs`的`vector`。我们可以制作一个`RandomBlobs`的`vector`，但如何让步进器和随机blob竞争呢？它们是不同的类型，但它们确实共享一个公共基类型。我们可以将原始指针放入一个`vector`中：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Our virtual methods support the polymorphism we need for a race, provided we
    use a pointer or reference to a `Blob`. Ensuring references don’t go out of scope
    when we still need them is hard work, so pointers are better. However, we would
    have to delete the blob pointers by hand when we were done or if anything threw
    an exception. C++11 introduced *smart pointers* to address these challenges, which
    make our life easier.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法支持我们需要的多态性，前提是我们使用指向`Blob`的指针或引用。确保引用在我们还需要它们的时候不会超出作用域是一项艰巨的工作，因此指针更好。然而，当我们完成时或发生异常时，我们必须手动删除blob指针。C++11引入了*智能指针*来解决这些挑战，这使得我们的生活更加容易。
- en: 6.2.2 Smart pointers
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 智能指针
- en: The destructors we’ve written don’t do anything. They don’t need to. However,
    one place where C++ shines is by allowing us to do the setup in the constructor
    and tidying up in the destructor. This is known as *resource acquisition is initialization*
    (RAII). The STL frequently uses RAII. For example, we know a `vector` creates
    objects for us on the heap. When the `vector` goes out of scope, the allocated
    objects are deleted. We don’t have to remember to tidy up, because the `vector`
    is an RAII class. If we put raw pointers in a `vector`, though, the pointers will
    be cleaned up, rather than what they point to.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的析构函数不做任何事情。它们不需要这样做。然而，C++在允许我们在构造函数中进行设置并在析构函数中进行清理方面表现出色。这被称为*资源获取即初始化*（RAII）。STL经常使用RAII。例如，我们知道`vector`在堆上为我们创建对象。当`vector`超出作用域时，分配的对象会被删除。我们不需要记住清理，因为`vector`是一个RAII类。如果我们将原始指针放入`vector`中，指针将被清理，而不是它们所指向的内容。
- en: Smart pointers are another `RAII` class, managing raw pointers. We can put smart
    pointers in a `vector`. When the vector goes out of scope, each contained element’s
    destructor is called. In turn, the smart pointer’s destructor clears up the raw
    pointer. Smart pointers come in different types, but all allow us to write code
    as presented in the following listing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针是另一种`RAII`类，用于管理原始指针。我们可以将智能指针放入`vector`中。当向量超出作用域时，每个包含元素的析构函数都会被调用。反过来，智能指针的析构函数会清理原始指针。智能指针有多种类型，但所有类型都允许我们编写如下所示代码。
- en: Listing 6.13 Using smart pointers in a `vector`
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.13 在`vector`中使用智能指针
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ Puts some blobs in a vector
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将一些数据块放入向量中
- en: ❷ End of scope, so vector calls smart pointers’ destructors
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 范围结束，因此向量调用智能指针的析构函数
- en: 'The `memory` header lists four smart pointers:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`memory`头文件列出了四个智能指针：'
- en: '`unique_ptr`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique_ptr`'
- en: '`shared_ptr`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared_ptr`'
- en: '`weak_ptr`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weak_ptr`'
- en: '`auto_ptr`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto_ptr`'
- en: The last smart pointer has unusual copy semantics (see [https://en.cppreference.com/w/cpp/memory/auto_ptr](https://en.cppreference.com/w/cpp/memory/auto_ptr)).
    A copy would steal the pointer, meaning these smart pointers could not be used
    in vectors or other containers. If a `vector` resizes, the elements need to be
    copied or moved, so something with unusual copy semantics causes problems. The
    `auto_ptr` was deprecated in C++11 and removed in C++17\. The remaining three
    types are much easier to use.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个智能指针具有不寻常的复制语义（参见[https://en.cppreference.com/w/cpp/memory/auto_ptr](https://en.cppreference.com/w/cpp/memory/auto_ptr)）。复制会窃取指针，这意味着这些智能指针不能用于向量或其他容器。如果向量进行大小调整，元素需要被复制或移动，因此具有不寻常复制语义的东西会引起问题。`auto_ptr`在C++11中被弃用，并在C++17中被移除。剩下的三种类型更容易使用。
- en: A `unique_ptr` manages a raw pointer. The `unique_ptr` owns the underlying pointer,
    so copying is disabled, but moving is allowed. After all, if something is unique,
    you shouldn’t be able to make copies of it. In contrast, a `shared_ptr` also manages
    a raw pointer, but several `shared_ptr` can own the same object. The owned object
    is destroyed, and its memory is deallocated when all the `shared_ptr` owning the
    underlying object go out of scope or are reset to point to something else. Shared
    pointers, therefore, have a shared count, held in what’s referred to as a *control
    block*. We can specify what happens when the unique or shared pointers go out
    of scope, but they both call `delete` by default. This information is also stored
    in the control block. Now, the sharing means you might end up with a circular
    dependency and a potential resource leak, so there is a `weak_ptr` as well. The
    `weak_ptr` is like a `shared_ptr` but acts more like a passive observer, monitoring
    the control block. The watched `shared_ptr` can delete the underlying resource,
    so the `weak_ptr` needs to check to see if the underlying resource has been deleted
    before trying to use the underlying pointer. See [https://www.modernescpp.com/index.php/std-weak-ptr](https://www.modernescpp.com/index.php/std-weak-ptr)
    for further details. The relationship among these three types of smart pointers
    is shown in figure 6.3.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr`管理一个原始指针。`unique_ptr`拥有底层的指针，因此复制是被禁用的，但移动是允许的。毕竟，如果某物是唯一的，你不应该能够复制它。相比之下，`shared_ptr`也管理一个原始指针，但多个`shared_ptr`可以拥有同一个对象。当所有拥有底层对象的`shared_ptr`超出作用域或重置为指向其他对象时，拥有的对象将被销毁，其内存将被释放。因此，共享指针有一个共享计数，存储在所谓的控制块中。我们可以指定当唯一或共享指针超出作用域时会发生什么，但它们默认都会调用`delete`。此信息也存储在控制块中。现在，共享意味着你可能会遇到循环依赖和潜在的资源泄露，因此还有一个`weak_ptr`。`weak_ptr`就像一个`shared_ptr`，但更像是一个被动的观察者，监控控制块。被观察的`shared_ptr`可以删除底层资源，因此`weak_ptr`需要在尝试使用底层指针之前检查底层资源是否已被删除。有关更多详细信息，请参阅[https://www.modernescpp.com/index.php/std-weak-ptr](https://www.modernescpp.com/index.php/std-weak-ptr)。这些三种智能指针之间的关系如图6.3所示。'
- en: '![CH06_F03_Buontempo](../Images/CH06_F03_Buontempo.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![CH06_F03_Buontempo](../Images/CH06_F03_Buontempo.png)'
- en: Figure 6.3 A unique pointer owns a pointer, shared pointers share a pointer
    and a reference count, and a weak pointer watches the shared pointer control block.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 一个唯一指针拥有一个指针，共享指针共享一个指针和一个引用计数，而弱指针监控共享指针的控制块。
- en: These three types of pointers cover a variety of use cases; however, the `unique_ptr`
    is sufficient for our needs. Nothing needs to share or observe the underlying
    raw pointer. Furthermore, Herb Sutter suggested using a `unique_ptr` by default
    (see [http://mng.bz/n1D8](http://mng.bz/n1D8)). The `shared_ptr` is more complicated
    because it needs the control block, which makes it more heavyweight. Switching
    to a `shared_ptr` from a `unique_ptr` is straightforward, so starting with a `unique_ptr`
    makes sense.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种类型的指针涵盖了各种使用场景；然而，对于我们的需求来说，`unique_ptr`就足够了。不需要共享或观察底层的原始指针。此外，Herb Sutter建议默认使用`unique_ptr`（参见[http://mng.bz/n1D8](http://mng.bz/n1D8)）。`shared_ptr`更复杂，因为它需要控制块，这使得它更重。从`unique_ptr`切换到`shared_ptr`很简单，所以从`unique_ptr`开始是有意义的。
- en: We, therefore, need to create a `vector` of `std::unique_ptr<Blob>`. We can
    then populate the `vector` with any classes deriving from the base class and make
    them race. We can make a `unique_ptr` in a couple of ways, either by using `new`
    explicitly
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要创建一个`std::unique_ptr<Blob>`的`vector`。然后我们可以用从基类派生的任何类填充`vector`并使它们竞争。我们可以通过几种方式创建一个`unique_ptr`，要么是显式使用`new`：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'or by using the `make_unique` method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用`make_unique`方法：
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The latter approach is better. First, Herb Sutter’s post tells us to avoid using
    `new`. Using `new` means we may have to handle raw pointers directly, which requires
    a lot of care. When we pass the `new StepperBlob` to the smart pointer, memory
    is allocated, and the constructor is called. If the constructor were to throw
    an exception, the `unique_ptr` itself wouldn’t be constructed, so its destructor
    wouldn’t get called, and the `StepperBlob` memory would leak. If the allocation
    and construction happens inside the `make_unique` call, everything is dealt with
    for us. There is a `make_shared` function for similar reasons.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 后者方法更好。首先，Herb Sutter的文章告诉我们避免使用`new`。使用`new`意味着我们可能需要直接处理原始指针，这需要很多小心。当我们把`new
    StepperBlob`传递给智能指针时，内存被分配，构造函数被调用。如果构造函数抛出异常，`unique_ptr`本身就不会被构造，因此它的析构函数不会被调用，`StepperBlob`内存就会泄漏。如果分配和构造发生在`make_unique`调用内部，所有的事情都会为我们处理。出于类似的原因，有一个`make_shared`函数。
- en: 6.2.3 Race!
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 比赛！
- en: We are now able to make a vector of various types of blobs and set them racing.
    We need a new race function, taking an `std::vector<std::unique_ptr<Blob>>`, and
    new `move_blobs` and `draw_blobs` functions also taking a `vector` of smart pointers.
    The declaration goes in the header, inside the namespace, and we need to include
    the `memory` header for the `unique_ptr`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够创建一个包含各种类型`blob`的向量并将它们设置为比赛。我们需要一个新的比赛函数，它接受一个`std::vector<std::unique_ptr<Blob>>`，还需要新的`move_blobs`和`draw_blobs`函数，它们也接受一个智能指针的`vector`。声明在头文件中，在命名空间内，我们需要包含`memory`头文件以使用`unique_ptr`。
- en: Listing 6.14 Adding overloaded methods to the header
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.14 向头文件添加重载方法
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ Everything as before
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一切照旧
- en: ❷ Overloads for polymorphic blobs
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 多态`blob`的重载
- en: We now need to define the functions. The race function is identical to listing
    6.8, apart from the type of the `blobs` parameter. In listing 6.8, we had a `vector`
    of `StepperBlobs`. Now we can have various blobs in the `vector.`
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要定义函数。比赛函数与列表6.8相同，除了`blobs`参数的类型。在列表6.8中，我们有一个`StepperBlobs`的`vector`。现在我们可以在`vector`中有各种`blob`。
- en: Listing 6.15 A less predictable race
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.15 一个不太可预测的比赛
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We need to implement the move and draw functions too. When we moved the blobs
    in listing 6.7, we called
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要实现移动和绘制函数。当我们移动列表6.7中的`blob`时，我们调用
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: for each blob. Now the blobs are unique pointers to blobs, so we need to use
    the `operator->` to call a member function on the underlying pointer. Apart from
    that, the function is very similar.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个`blob`。现在`blob`是`blob`的唯一指针，所以我们需要使用`operator->`来在底层指针上调用成员函数。除此之外，函数非常相似。
- en: Listing 6.16 Moving all the blobs
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.16 移动所有`blob`
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ -> to call an underlying pointer’s method
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ -> 调用一个底层指针的方法
- en: Finally, we need to implement the overloaded `draw_blobs` method. Again, this
    is very like the previous draw method in listing 6.5, but we use `operator->`
    to find a blob’s current steps.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要实现重载的`draw_blobs`方法。同样，这与列表6.5中的先前绘制方法非常相似，但我们使用`operator->`来找到`blob`的当前步数。
- en: Listing 6.17 Drawing each blob's current position
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.17 绘制每个`blob`的当前位置
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ -> to call an underlying pointer’s method
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ -> 调用一个底层指针的方法
- en: Armed with the new methods, we can finally have a proper race. We need some
    blobs, and some steppers racing some random blobs would be good. Since the steppers
    move two steps at a time, using a uniform distribution of integers between `0`
    and `4` gives random blobs averaging two steps overall. We realized that gives
    both types a fair chance. We can make a `unique_ptr` to a `StepperBlob` and then
    a `unique_ptr` to a `RandomBlob` in a loop, so run half the number requested,
    adding two Blobs each time. Each `RandomBlob` needs an engine and a distribution.
    The engine needs seeding, so we’ll use `random_device` as usual. Finally, we’ll
    make the distribution range from `0` to `4`, using `uniform_int_distribution{0,`
    `4}`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 有了新的方法，我们终于可以进行一场真正的比赛了。我们需要一些`blob`，一些赛步器与一些随机的`blob`比赛会很好。由于赛步器每次移动两步，使用介于`0`和`4`之间的整数均匀分布可以给出平均两步的随机`blob`。我们意识到这给了两种类型公平的机会。我们可以在一个循环中创建一个指向`StepperBlob`的`unique_ptr`和一个指向`RandomBlob`的`unique_ptr`，所以运行一半请求的数量，每次添加两个`Blob`。每个`RandomBlob`需要一个引擎和一个分布。引擎需要播种，所以我们通常使用`random_device`。最后，我们将分布范围设置为`0`到`4`，使用`uniform_int_distribution{0,
    4}`。
- en: Listing 6.18 Creating blobs for a proper race
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.18 创建用于比赛的`blob`
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ Chooses how many of each blob types
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 选择每种`blob`类型有多少个
- en: ❷ Loops to half the number, adding two blobs each time
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 循环到一半的数量，每次添加两个`blob`
- en: ❸ Stepper is default constructed.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `Stepper`是默认构造的。
- en: ❹ RandomBlob needs an engine and a distribution.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ `RandomBlob`需要一个引擎和一个分布。
- en: We can now create our blobs in `main` and race them. Let’s try four of each
    kind of blob, giving us eight to race.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在 `main` 中创建我们的 blob 并让它们赛跑。让我们尝试每种类型的四个 blob，总共八个来赛跑。
- en: Listing 6.19 A proper race
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.19 正确的赛跑
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The random blobs might win, but the steppers can beat them. To start with, the
    blobs are in the bottom of the bag, raring to go.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 随机的 blob 可能会赢，但步进器可以打败它们。一开始，blob 在袋子的底部，准备出发。
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: They move, and some random blobs may take the lead.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 它们移动，一些随机的 blob 可能会领先。
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The steppers might catch up a bit at the next move.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次移动时，步进器可能会追上一点。
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: And finally, some random blobs win, but one is left behind on this run.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些随机的 blob 赢了，但有一个在这个运行中被留在了后面。
- en: '[PRE56]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: A second run can give a different outcome. We have raced our way out of a paper
    bag. Don’t forget, we considered other distributions too. Try this out with a
    normal distribution, and see if any go backward.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次运行可能会得到不同的结果。我们已经通过赛跑的方式从纸袋中出来了。别忘了，我们也考虑了其他分布。尝试使用正态分布，看看是否有任何向后的情况。
- en: 6.2.4 Some design considerations
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.4 一些设计考虑
- en: 'We disabled moves and copies on our base class. If we had left the copies,
    we could make a new derived type:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在基类中禁用了移动和复制。如果我们留下了复制，我们可以创建一个新的派生类型：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Admittedly, the derived type doesn’t do much, but maybe we need it to do something
    else for the virtual member functions. Nothing is stopping us from writing a function
    using a `StepperBlob`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然派生类型没有做什么，但也许我们需要它为虚拟成员函数做其他事情。没有什么阻止我们使用 `StepperBlob` 编写一个函数：
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Inside this function, we have a `StepperBlob`, even if we call it with the
    derived type:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们有一个 `StepperBlob`，即使我们用派生类型调用它：
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Inside the `bogus` function, the blob is a `StepperBlob` because we passed
    it by value, and it was copied. This is known as *slicing*. We’ve sliced the derived
    class down to the `StepperBlob` class, and the wrong virtual functions get called.
    The core guidelines ([http://mng.bz/orDj](http://mng.bz/orDj)) suggest making
    the copy and move operations deleted using `=delete` to avoid slicing ([http://mng.bz/6nr5](http://mng.bz/6nr5)).
    The DesDeMovA approach would have the same effect. If all these operations go,
    we can add a clone method if we need to enable copying. Alternatively, just marking
    the copies as deleted in the base `Blob` class means the call to the `bogus` function
    with the derived class no longer compiles. Fortunately, we did this in our base
    class. We could even stop a derived class from being written using the keyword
    `final` that we met earlier. We can mark functions as `override` or `final`, but
    we can also mark a whole class `final`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `bogus` 函数内部，blob 是一个 `StepperBlob`，因为我们通过值传递了它，并且它被复制了。这被称为 *切片*。我们将派生类切片到了
    `StepperBlob` 类，错误的虚函数被调用了。核心指南 ([http://mng.bz/orDj](http://mng.bz/orDj)) 建议使用
    `=delete` 来删除复制和移动操作以避免切片 ([http://mng.bz/6nr5](http://mng.bz/6nr5))。DesDeMovA
    方法也会有相同的效果。如果所有这些操作都去掉了，我们就可以添加一个克隆方法，如果我们需要启用复制的话。或者，只需在基类 `Blob` 中将复制标记为已删除，那么使用派生类调用
    `bogus` 函数将不再编译。幸运的是，我们在基类中已经这样做了。我们甚至可以使用我们之前遇到的 `final` 关键字来阻止派生类的编写。我们可以将函数标记为
    `override` 或 `final`，但我们也可以将整个类标记为 `final`：
- en: '[PRE60]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: A `final` class cannot be used as a base class, so the derived class itself
    does not compile.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `final` 类不能用作基类，所以派生类本身无法编译。
- en: Object-oriented programming (OOP) can get very complicated. When we show the
    race, all we really need are the total steps so far per blob. Using an `std::vector
    <int>` to collect the steps would work. We could accumulate the total steps for
    each blob without any need for OOP. We could have done that at the outset but
    would then have missed the opportunity to learn a lot of C++. In fact, remember
    when we tested the `RandomStepper` in listing 6.12? We took `0` steps using
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）可能会变得非常复杂。当我们展示赛跑时，我们真正需要的是每个 blob 的总步数。使用 `std::vector <int>` 来收集步数是可行的。我们可以为每个
    blob 累积总步数，而不需要任何面向对象编程。我们一开始就可以这样做，但那样就会错过学习很多 C++ 的机会。实际上，记得我们在列表 6.12 中测试 `RandomStepper`
    的时候吗？我们使用了 `0` 步
- en: '[PRE61]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `StepperBlob` takes `2` steps, so we could use a fake generator returning
    `2` instead of `0`
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`StepperBlob` 需要 `2` 步，所以我们可以使用返回 `2` 而不是 `0` 的假生成器'
- en: '[PRE62]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: to make a blob taking `2` steps. Again, we wouldn’t need OOP. Templates give
    us compile-time or *static polymorphism*. OOP has its place, but C++ allows us
    to work in a variety of paradigms.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `2` 步来创建一个 blob。再次强调，我们不需要面向对象编程（OOP）。模板为我们提供了编译时或 *静态多态性*。OOP 有其位置，但 C++
    允许我们在各种范式下工作。
- en: We’ve used `vector` several times now and considered an `array` as an alternative
    when we know how many items we need at compile time. We haven’t built anything
    needing a lookup table yet. In the next chapter, we will use some associative
    containers to make dictionaries.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经多次使用了`vector`，并在编译时知道需要多少项时，将其视为`array`的替代品。我们还没有构建需要查找表的任何东西。在下一章中，我们将使用一些关联容器来制作字典。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Always declare a virtual destructor in a `base` class and mark pure virtual
    functions with `=0.`
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是在`base`类中声明一个虚析构函数，并用`=0`标记纯虚函数。
- en: The rule of zero means the six special member functions are provided if we do
    not declare any of them. If only a constructor is declared, the remaining five
    special member functions are provided.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零法则意味着如果我们没有声明任何一个特殊成员函数，将提供六个特殊成员函数。如果只声明了构造函数，则提供剩余的五个特殊成员函数。
- en: Add the keyword `override` to an overridden method to ensure you have the signature
    correct, and use the keyword `final` to stop further overrides.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重写的方法中添加关键字`override`以确保你有正确的签名，并使用关键字`final`来阻止进一步的覆盖。
- en: Use `type_traits` to find traits for a type; for example, `std::is_ constructible_v`.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`type_traits`来查找类型的特性；例如，`std::is_constructible_v`。
- en: Adding a destructor blocks the compiler from implicitly supplying the move special
    member functions.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加析构函数会阻止编译器隐式提供移动特殊成员函数。
- en: The rule of five means any class requiring move semantics needs to declare all
    five special member functions, possibly along with constructors, if there is a
    user-declared destructor, copy constructor, or copy assignment operator.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 五法则意味着任何需要移动语义的类都需要声明所有五个特殊成员函数，如果存在用户声明的析构函数、拷贝构造函数或拷贝赋值运算符，可能还需要构造函数。
- en: Using an `std::seed_seq` can generate a greater variety of random numbers, but
    just using `std::random_device` is often good enough for simple games.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::seed_seq`可以生成更多种类的随机数，但仅使用`std::random_device`对于简单的游戏通常就足够了。
- en: Use smart pointers rather than raw pointers, and prefer the simpler `unique_ptr`
    by default.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相比于原始指针，使用智能指针，并默认首选更简单的`unique_ptr`。
- en: Use the `operator->` of a smart pointer to call a member function on the referenced
    object.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用智能指针的`operator->`来调用引用对象的成员函数。
