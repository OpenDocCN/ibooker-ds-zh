- en: Part 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分
- en: Benefits of functional programming applicable to concurrent programs
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于并发程序的功能编程的好处
- en: Functional programming is a programming paradigm that focuses on abstraction
    and composition. In these first three chapters you’ll learn how to treat computations
    as the evaluation of expressions to avoid the mutation of data. To enhance concurrent
    programming, the functional paradigm provides tools and techniques to write deterministic
    programs. Output only depends upon input and not on the state of the program at
    execution time. The functional paradigm also facilitates writing code with fewer
    bugs by emphasizing separation of concerns between purely functional aspects,
    isolating side effects, and controlling unwanted behaviors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一种关注抽象和组合的编程范式。在这前三章中，你将学习如何将计算视为表达式的评估，以避免数据的突变。为了增强并发编程，函数式范式提供了工具和技术来编写确定性程序。输出仅取决于输入，而不是程序在执行时的状态。函数式范式还通过强调纯函数方面之间的关注点分离、隔离副作用和控制不良行为，来促进编写更少错误的代码。
- en: This part of the book introduces the main concepts and benefits of functional
    programming applicable to concurrent programs. Concepts discussed include programming
    with pure functions, immutability, laziness, and composition.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分介绍了适用于并发程序的功能编程的主要概念和好处。讨论的概念包括使用纯函数编程、不可变性、惰性和组合。
- en: '1'
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Functional concurrency foundations
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式并发基础
- en: '**This chapter covers**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Why you need concurrency
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你需要并发
- en: Differences between concurrency, parallelism, and multithreading
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发、并行和多线程之间的区别
- en: Avoiding common pitfalls when writing concurrent applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免编写并发应用程序时的常见陷阱
- en: Sharing variables between threads
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线程之间共享变量
- en: Using the functional paradigm to develop concurrent programs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数式范式开发并发程序
- en: In the past, software developers were confident that, over time, their programs
    would run faster than ever. This proved true over the years due to improved hardware
    that enabled programs to increase speed with each new generation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，软件开发者有信心，随着时间的推移，他们的程序会运行得比以往任何时候都快。由于每一代硬件的改进，这一预测在多年中得到了证实。
- en: For the past 50 years, the hardware industry has experienced uninterrupted improvements.
    Prior to 2005, the processor evolution continuously delivered faster single-core
    CPUs, until finally reaching the limit of CPU speed predicted by Gordon Moore.
    Moore, a computer scientist, predicted in 1965 that the density and speed of transistors
    would double every 18 months before reaching a maximum speed beyond which technology
    couldn’t advance. The original prediction for the increase of CPU speed presumed
    a speed-doubling trend for 10 years. Moore’s prediction, known as Moore’s Law,
    was correct—except that progress continued for almost 50 years (decades past his
    estimate).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的50年里，硬件行业经历了不间断的改进。在2005年之前，处理器的发展持续带来更快的单核CPU，直到最终达到戈登·摩尔预测的CPU速度极限。摩尔是一位计算机科学家，他在1965年预测，在达到技术无法再进步的最大速度之前，晶体管的密度和速度每18个月会翻倍。对CPU速度增加的原始预测假设了10年的速度翻倍趋势。摩尔预测，即摩尔定律，是正确的——除了进步持续了近50年（远远超过了他的估计）。
- en: Today, the single-processor CPU has nearly reached the speed of light, all the
    while generating an enormous amount of heat due to energy dissipation; this heat
    is the limiting factor to further improvements.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，单核CPU的速度几乎达到了光速，同时由于能量耗散产生了巨大的热量；这种热量是进一步改进的限制因素。
- en: Moore’s prediction about transistor speed has come to fruition (transistors
    cannot run any faster) but it isn’t dead (modern transistors are increasing in
    density, providing opportunities for parallelism within the confines of that top
    speed). The combination of multicore architecture and parallel programming models
    is keeping Moore’s Law alive! As CPU single-core performance improvement stagnates,
    developers adapt by segueing into multicore architecture and developing software
    that supports and integrates concurrency.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 摩尔关于晶体管速度的预测已经实现（晶体管无法运行得更快）但它并没有死亡（现代晶体管的密度正在增加，在最高速度的范围内提供了并行性的机会）。多核架构和并行编程模型的结合使摩尔定律得以延续！随着CPU单核性能的改进停滞，开发者通过转向多核架构并开发支持并集成并发的软件来适应。
- en: The processor revolution has begun. The new trend in multicore processor design
    has brought parallel programming into the mainstream. Multicore processor architecture
    offers the possibility of more efficient computing, but all this power requires
    additional work for developers. If programmers want more performance in their
    code, they must adapt to new design patterns to maximize hardware utilization,
    exploiting multiple cores through parallelism and concurrency.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器革命已经开始了。多核处理器设计的新趋势将并行编程带入了主流。多核处理器架构提供了更高效计算的可能性，但所有这些力量都需要开发者进行额外的工作。如果程序员想要在代码中获得更多性能，他们必须适应新的设计模式以最大化硬件利用率，通过并行性和并发性利用多个核心。
- en: In this chapter, we’ll cover general information about concurrency by examining
    several of its benefits and the challenges of writing traditional concurrent programs.
    Next, we’ll introduce functional paradigm concepts that make it possible to overcome
    traditional limitations by using simple and maintainable code. By the end of this
    chapter, you’ll understand why concurrency is a valued programming model, and
    why the functional paradigm is the right tool for writing correct concurrent programs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过检查其一些好处和编写传统并发程序所面临的挑战来探讨并发的一般信息。接下来，我们将介绍函数式范式概念，这些概念通过使用简单且易于维护的代码来克服传统限制。到本章结束时，您将理解为什么并发是一个值得的程序模型，以及为什么函数式范式是编写正确并发程序的正确工具。
- en: 1.1 What you’ll learn from this book
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 您将从本书中学到的内容
- en: In this book I’ll look at considerations and challenges for writing concurrent
    multithreaded applications in a traditional programming paradigm. I’ll explore
    how to successfully address these challenges and avoid concurrency pitfalls using
    the functional paradigm. Next, I’ll introduce the benefits of using abstractions
    in functional programming to create declarative, simple-to-implement, and highly
    performant concurrent programs. Over the course of this book, we’ll examine complex
    concurrent issues providing an insight into the best practices necessary to build
    concurrent and scalable programs in .NET using the functional paradigm. You’ll
    become familiar with how functional programming helps developers support concurrency
    by encouraging immutable data structures that can be passed between threads without
    having to worry about a shared state, all while avoiding side effects. By the
    end of the book you’ll master how to write more modular, readable, and maintainable
    code in both C# and F# languages. You’ll be more productive and proficient while
    writing programs that function at peak performance with fewer lines of code. Ultimately,
    armed with your newfound skills, you’ll have the knowledge needed to become an
    expert at delivering successful high-performance solutions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我将探讨在传统编程范式下编写并发多线程应用程序的考虑和挑战。我将探讨如何通过函数式范式成功解决这些挑战并避免并发陷阱。接下来，我将介绍使用函数式编程中的抽象来创建声明式、易于实现和高度并发的程序的好处。在本书的整个过程中，我们将检查复杂并发问题，提供在.NET中使用函数式范式构建并发和可扩展程序的最佳实践见解。您将熟悉函数式编程如何通过鼓励不可变数据结构来帮助开发者支持并发，这些数据结构可以在线程之间传递而无需担心共享状态，同时避免副作用。到本书结束时，您将掌握如何在C#和F#语言中编写更模块化、可读性和可维护的代码。在编写程序时，您将更加高效和熟练，这些程序以更少的代码行数达到峰值性能。最终，凭借您新获得的能力，您将拥有成为交付成功高性能解决方案专家所需的知识。
- en: 'Here’s what you’ll learn:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习以下内容：
- en: How to combine asynchronous operations with the Task Parallel Library
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将异步操作与任务并行库结合使用
- en: How to avoid common problems and troubleshoot your multithreaded and asynchronous
    applications
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何避免常见问题并调试您的多线程和异步应用程序
- en: Knowledge of concurrent programming models that adopt the functional paradigm
    (functional, asynchronous, event-driven, and message passing with agents and actors)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解采用函数式范式的并发编程模型（函数式、异步、事件驱动以及通过代理和演员的消息传递）
- en: How to build high-performance, concurrent systems using the functional paradigm
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用函数式范式构建高性能、并发的系统
- en: How to express and compose asynchronous computations in a declarative style
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何以声明式风格表达和组合异步计算
- en: How to seamlessly accelerate sequential programs in a pure fashion by using
    data-parallel programming
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过使用数据并行编程以纯方式无缝加速顺序程序
- en: How to implement reactive and event-based programs declaratively with Rx-style
    event streams
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Rx风格的流式事件声明式地实现反应式和基于事件的程序
- en: How to use functional concurrent collections for building lock-free multithreaded
    programs
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用功能并发集合构建无锁的线程安全程序
- en: How to write scalable, performant, and robust server-side applications
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写可扩展、性能良好且健壮的服务器端应用程序
- en: How to solve problems using concurrent programming patterns such as the Fork/Join,
    parallel aggregation, and the Divide and Conquer technique
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用并发编程模式解决问题，例如Fork/Join、并行聚合和分而治之技术
- en: How to process massive data sets with parallel streams and parallel Map/Reduce
    implementations
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用并行流和并行Map/Reduce实现处理大量数据集
- en: This book assumes you have knowledge of general programming, but not functional
    programming. To apply functional concurrency in your coding, you only need a subset
    of the concepts from functional programming, and I’ll explain what you need to
    know along the way. In this fashion, you’ll gain the many benefits of functional
    concurrency in a shorter learning curve, focused on what you can use right away
    in your day-to-day coding experiences.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设您已具备通用编程知识，但不是函数式编程。要在您的编码中应用函数式并发，您只需要函数式编程概念的一个子集，我将在过程中解释您需要了解的内容。这样，您将在更短的学习曲线上获得函数式并发的许多好处，专注于您在日常编码体验中可以立即使用的内容。
- en: 1.2 Let’s start with terminology
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 让我们从术语开始
- en: This section defines terms related to the topic of this book, so we start on
    common ground. In computer programming, some terms (such as *concurrency*, *parallelism,*
    and *multithreading*) are used in the same context, but have different meanings.
    Due to their similarities, the tendency to treat these terms as the same thing
    is common, but it is not correct. When it becomes important to reason about the
    behavior of a program, it’s crucial to make a distinction between computer programming
    terms. For example, concurrency is, by definition, multithreading, but multithreading
    isn’t necessarily concurrent. You can easily make a multicore CPU function like
    a single-core CPU, but not the other way around.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本节定义了与本书主题相关的术语，因此我们从共同基础开始。在计算机编程中，一些术语（如*并发*、*并行性*和*多线程*）在相同语境中使用，但含义不同。由于它们的相似性，将这些术语视为同一事物的倾向很常见，但这是不正确的。当需要推理程序的行为时，区分计算机编程术语至关重要。例如，根据定义，并发是多线程，但多线程不一定是并发的。您可以轻松地将多核CPU的功能像单核CPU一样使用，但反之则不然。
- en: 'This section aims to establish a common ground about the definitions and terminologies
    related to the topic of this book. By the end of this section, you’ll learn the
    meaning of these terms:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本节旨在就本书主题相关的定义和术语建立共同基础。在本节结束时，您将了解这些术语的含义：
- en: Sequential programming
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序编程
- en: Concurrent programming
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发编程
- en: Parallel programming
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行编程
- en: Multitasking
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多任务
- en: Multithreading
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程
- en: 1.2.1 Sequential programming performs one task at a time
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.1 顺序编程一次执行一个任务
- en: '*Sequential* *programming* is the act of accomplishing things in steps. Let’s
    consider a simple example, such as getting a cup of cappuccino at the local coffee
    shop. You first stand in line to place your order with the lone barista. The barista
    is responsible for taking the order and delivering the drink; moreover, they are
    able to make only one drink at a time so you must wait patiently—or not—in line
    before you order. Making a cappuccino involves grinding the coffee, brewing the
    coffee, steaming the milk, frothing the milk, and combining the coffee and milk,
    so more time passes before you get your cappuccino. [Figure 1.1](#figure1.1) shows
    this process.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*顺序* *编程* 是按步骤完成事情的行为。让我们考虑一个简单的例子，比如在当地咖啡馆点一杯卡布奇诺。您首先排队，向唯一的咖啡师下单。咖啡师负责接单和提供饮料；此外，他们一次只能制作一杯饮料，因此您在下单前必须耐心等待——或者不耐心——在队列中。制作卡布奇诺涉及磨咖啡，煮咖啡，加热牛奶，打奶泡，以及将咖啡和牛奶混合，因此在您得到卡布奇诺之前会花费更多时间。[图1.1](#figure1.1)
    展示了这一过程。'
- en: '![c01-01.png](Images/c01-01.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![c01-01.png](Images/c01-01.png)'
- en: '[Figure 1.1](#figureanchor1.1) For each person in line, the barista is sequentially
    repeating the same set of instructions (grind coffee, brew coffee, steam milk,
    froth milk, and combine the coffee and the milk to make a cappuccino).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.1](#figureanchor1.1) 对于排队的每个人，咖啡师会依次重复相同的指令集（磨咖啡，煮咖啡，加热牛奶，打奶泡，将咖啡和牛奶混合制成卡布奇诺）。'
- en: '[Figure 1.1](#figure1.1) is an example of sequential work, where one task must
    be completed before the next. It is a convenient approach, with a clear set of
    systematic (step-by-step) instructions of what to do and when to do it. In this
    example, the barista will likely not get confused and make any mistakes while
    preparing the cappuccino because the steps are clear and ordered. The disadvantage
    of preparing a cappuccino step-by-step is that the barista must wait during parts
    of the process. While waiting for the coffee to be ground or the milk to be frothed,
    the barista is effectively inactive (blocked). The same concept applies to sequential
    and concurrent programming models. As shown in [figure 1.2](#figure1.2), sequential
    programming involves a consecutive, progressively ordered execution of processes,
    one instruction at a time in a linear fashion.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.1](#figure1.1) 是顺序工作的一个例子，其中必须完成一个任务才能开始下一个任务。这是一个方便的方法，有一套明确的系统（逐步）指令，说明何时做什么。在这个例子中，咖啡师在准备卡布奇诺时不太可能感到困惑或出错，因为步骤清晰且有序。逐步准备卡布奇诺的缺点是咖啡师在过程中的某些部分必须等待。在等待咖啡磨碎或牛奶打泡时，咖啡师实际上是无效的（阻塞）。同样的概念也适用于顺序和并发编程模型。如图1.2所示，顺序编程涉及按顺序、逐步有序执行的过程，每次只按线性方式执行一条指令。'
- en: '![c01-02.png](Images/c01-02.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![c01-02.png](Images/c01-02.png)'
- en: '[Figure 1.2](#figureanchor1.2) Typical sequential coding involving a consecutive,
    progressively ordered execution of processes'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.2](#figureanchor1.2) 典型的顺序编码，涉及按顺序、逐步有序执行的过程'
- en: In imperative and object-oriented programming (OOP) we tend to write code that
    behaves sequentially, with all attention and resources focused on the task currently
    running. We model and execute the program by performing an ordered set of statements,
    one after another.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式和面向对象编程（OOP）中，我们倾向于编写按顺序执行代码，所有注意力和资源都集中在当前运行的任务上。我们通过执行一系列有序的语句来模拟和执行程序，一个接一个。
- en: 1.2.2 Concurrent programming runs multiple tasks at the same time
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.2 并发编程同时运行多个任务
- en: Suppose the barista prefers to initiate multiple steps and execute them concurrently?
    This moves the customer line along much faster (and, consequently, increases garnered
    tips). For example, once the coffee is ground, the barista can start brewing the
    espresso. During the brewing, the barista can take a new order or start the process
    of steaming and frothing the milk. In this instance, the barista gives the perception
    of doing multiple operations at the same time (multitasking), but this is only
    an illusion. More details on multitasking are covered in section 1.2.4\. In fact,
    because the barista has only one espresso machine, they must stop one task to
    start or continue another, which means the barista executes only one task at a
    time, as shown in [figure 1.3](#figure1.3). In modern multicore computers, this
    is a waste of valuable resources.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设咖啡师更喜欢同时启动多个步骤并并发执行它们？这将使顾客队伍移动得更快（并且，相应地，增加赚取的小费）。例如，一旦咖啡磨好，咖啡师就可以开始冲泡浓缩咖啡。在冲泡过程中，咖啡师可以接受新的订单或开始蒸汽和打泡牛奶的过程。在这种情况下，咖啡师给人一种同时进行多个操作（多任务处理）的印象，但这只是一种错觉。关于多任务处理的更多细节将在1.2.4节中介绍。实际上，因为咖啡师只有一个浓缩咖啡机，他们必须停止一个任务才能开始或继续另一个任务，这意味着咖啡师一次只能执行一个任务，如图1.3所示。在现代多核计算机中，这是一种资源的浪费。
- en: '![c01-03.png](Images/c01-03.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![c01-03.png](Images/c01-03.png)'
- en: '[Figure 1.3](#figureanchor1.3) The barista switches between the operations
    (multitasking) of preparing the coffee (grind and brew) and preparing the milk
    (steam and froth). As a result, the barista executes segments of multiple tasks
    in an interleaved manner, giving the illusion of multitasking. But only one operation
    is executed at a time due to the sharing of common resources.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.3](#figureanchor1.3) 咖啡师在准备咖啡（磨豆和冲泡）和准备牛奶（蒸汽和打泡）的操作之间切换（多任务处理）。因此，咖啡师以交错的方式执行多个任务的片段，给人一种多任务处理的错觉。但由于共享公共资源，每次只能执行一个操作。'
- en: '*Concurrency* describes the ability to run several programs or multiple parts
    of a program at the same time. In computer programming, using concurrency within
    an application provides actual multitasking, dividing the application into multiple
    and independent processes that run at the same time (concurrently) in different
    threads. This can happen either in a single CPU core or in parallel, if multiple
    CPU cores are available. The throughput (the rate at which the CPU processes a
    computation) and responsiveness of the program can be improved through the asynchronous
    or parallel execution of a task. An application that streams video content is
    concurrent, for example, because it simultaneously reads the digital data from
    the network, decompresses it, and updates its presentation onscreen.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*并发*描述了同时运行多个程序或程序多个部分的能力。在计算机编程中，在应用程序中使用并发提供了实际的多任务处理，将应用程序划分为多个独立的过程，这些过程可以在不同的线程中同时（并发）运行。这可以在单个CPU核心中发生，也可以在多个CPU核心可用时并行发生。通过异步或并行执行任务，可以提高程序的吞吐量（CPU处理计算的速率）和响应性。例如，流式传输视频内容的应用程序是并发的，因为它同时从网络读取数字数据，解压缩它，并更新屏幕上的展示。'
- en: Concurrency gives the impression that these threads are running in parallel
    and that different parts of the program can run simultaneously. But in a single-core
    environment, the execution of one thread is temporarily paused and switched to
    another thread, as is the case with the barista in [figure 1.3](#figure1.3). If
    the barista wishes to speed up production by simultaneously performing several
    tasks, then the available resources must be increased. In computer programming,
    this process is called parallelism.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 并发给人一种这些线程正在并行运行的印象，不同的程序部分可以同时运行。但在单核环境中，一个线程的执行会暂时暂停并切换到另一个线程，就像[图1.3](#figure1.3)中的咖啡师一样。如果咖啡师希望通过同时执行多个任务来加快生产，那么必须增加可用资源。在计算机编程中，这个过程被称为并行化。
- en: 1.2.3 Parallel programming executes multiples tasks simultaneously
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.3 并行编程同时执行多个任务
- en: From the developer’s prospective, we think of parallelism when we consider the
    questions, “How can my program execute many things at once?” or “How can my program
    solve one problem faster?” *Parallelism* is the concept of executing multiple
    tasks at once concurrently, literally at the same time on different cores, to
    improve the speed of the application. Although all parallel programs are concurrent,
    we have seen that not all concurrency is parallel. That’s because parallelism
    depends on the actual runtime environment, and it requires hardware support (multiple
    cores). Parallelism is achievable only in multicore devices ([figure 1.4](#figure1.4))
    and is the means to increasing performance and throughput of a program.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，当我们考虑“我的程序如何同时执行多个任务？”或“我的程序如何更快地解决问题？”这样的问题时，我们会想到并行化。*并行化*是指同时执行多个任务的概念，字面上是在不同的核心上同时执行，以提高应用程序的速度。尽管所有并行程序都是并发的，但我们已经看到并非所有并发都是并行。这是因为并行化依赖于实际的运行时环境，并且需要硬件支持（多个核心）。只有在多核设备上才能实现并行化（[图1.4](#figure1.4)），这是提高程序性能和吞吐量的手段。
- en: '![c01-04.png](Images/c01-04.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![c01-04.png](Images/c01-04.png)'
- en: '[Figure 1.4](#figureanchor1.4) Only multicore machines allow parallelism for
    simultaneously executing different tasks. In this figure, each core is performing
    an independent task.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.4](#figureanchor1.4) 只有多核机器允许并行化，以同时执行不同的任务。在这个图中，每个核心都在执行一个独立任务。'
- en: To return to the coffee shop example, imagine that you’re the manager and wish
    to reduce the waiting time for customers by speeding up drink production. An intuitive
    solution is to hire a second barista and set up a second coffee station. With
    two baristas working simultaneously, the queues of customers can be processed
    independently and in parallel, and the preparation of cappuccinos ([figure 1.5](#figure1.5))
    speeds up.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 回到咖啡店示例，假设你是经理，希望通过加快饮品制作速度来减少顾客的等待时间。一个直观的解决方案是雇佣第二名咖啡师并设置第二个咖啡站。当两名咖啡师同时工作时，顾客的队伍可以独立且并行地处理，卡布奇诺的制作（[图1.5](#figure1.5)）也会加快。
- en: '![c01-05.png](Images/c01-05.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![c01-05.png](Images/c01-05.png)'
- en: '[Figure 1.5](#figureanchor1.5) The production of cappuccinos is faster because
    two baristas can work in parallel with two coffee stations.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.5](#figureanchor1.5) 由于有两名咖啡师可以在两个咖啡站上并行工作，卡布奇诺的制作速度更快。'
- en: No break in production results in a benefit in performance. The goal of parallelism
    is to maximize the use of all available computational resources; in this case,
    the two baristas are working in parallel at separate stations (multicore processing).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 生产过程中没有中断可以带来性能上的好处。并行性的目标是最大化使用所有可用的计算资源；在这种情况下，两个咖啡师在各自的站台上并行工作（多核处理）。
- en: Parallelism can be achieved when a single task is split into multiple independent
    subtasks, which are then run using all the available cores. In [figure 1.5](#figure1.5),
    a multicore machine (two coffee stations) allows parallelism for simultaneously
    executing different tasks (two busy baristas) without interruption.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个任务被分割成多个独立的子任务时，可以通过使用所有可用的核心来实现并行性。在[图1.5](#figure1.5)中，一个多核机器（两个咖啡站）允许并行执行不同的任务（两个忙碌的咖啡师）而不会中断。
- en: The concept of timing is fundamental for simultaneously executing operations
    in parallel. In such a program, operations are *concurrent* if they can be executed
    in parallel, and these operations are *parallel* if the executions overlap in
    time (see [figure 1.6](#figure1.6)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 时间概念对于并行执行操作是基本的。在这样的程序中，如果操作可以并行执行，则这些操作是*并发的*；如果执行在时间上重叠（参见[图1.6](#figure1.6)），则这些操作是*并行的*。
- en: '![c01-06.png](Images/c01-06.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![c01-06.png](Images/c01-06.png)'
- en: '[Figure 1.6](#figureanchor1.6) Parallel computing is a type of computation
    in which many calculations are carried out simultaneously, operating on the principle
    that large problems can often be divided into smaller ones, which are then solved
    at the same time.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.6](#figureanchor1.6) 并行计算是一种计算类型，其中许多计算是同时进行的，其原理是大型问题通常可以被分解成更小的部分，这些部分随后同时解决。'
- en: Parallelism and concurrency are related programming models. A parallel program
    is also concurrent, but a concurrent program isn’t always parallel, with parallel
    programming being a subset of concurrent programming. While concurrency refers
    to the design of the system, parallelism relates to the execution. Concurrent
    and parallel programming models are directly linked to the local hardware environment
    where they’re performed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 并行性和并发性是相关的编程模型。并行程序也是并发的，但并发程序并不总是并行的，因为并行编程是并发编程的一个子集。虽然并发性指的是系统的设计，但并行性则与执行相关。并发和并行编程模型直接与它们执行时的本地硬件环境相关联。
- en: 1.2.4 Multitasking performs multiple tasks concurrently over time
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.4 多任务在时间上同时执行多个任务
- en: '*Multitasking* is the concept of performing multiple tasks over a period of
    time by executing them concurrently. We’re familiar with this idea because we
    multitask all the time in our daily lives. For example, while waiting for the
    barista to prepare our cappuccino, we use our smartphone to check our emails or
    scan a news story. We’re doing two things at one time: waiting and using a smartphone.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*多任务处理*是指在一段时间内通过并发执行多个任务的概念。我们熟悉这个想法，因为我们每天都在日常生活中进行多任务处理。例如，当我们等待咖啡师准备我们的卡布奇诺时，我们使用智能手机检查电子邮件或浏览新闻故事。我们一次做两件事：等待和使用智能手机。'
- en: Computer multitasking was designed in the days when computers had a single CPU
    to concurrently perform many tasks while sharing the same computing resources.
    Initially, only one task could be executed at a time through time slicing of the
    CPU. (*Time slice* refers to a sophisticated scheduling logic that coordinates
    execution between multiple threads.) The amount of time the schedule allows a
    thread to run before scheduling a different thread is called *thread quantum*.
    The CPU is time sliced so that each thread gets to perform one operation before
    the execution context is switched to another thread. Context switching is a procedure
    handled by the operating system to multitask for optimized performance ([figure
    1.7](#figure1.7)). But in a single-core computer, it’s possible that multitasking
    can slow down the performance of a program by introducing extra overhead for context
    switching between threads.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机多任务处理是在计算机只有一个CPU的时代设计的，以在共享相同的计算资源的同时并发执行许多任务。最初，只能通过CPU的时间切片来同时执行一个任务。(*时间切片*指的是一种复杂的调度逻辑，它协调多个线程之间的执行。)调度允许一个线程在调度另一个线程之前运行的时长被称为*线程量子*。CPU通过时间切片，使得每个线程在执行上下文切换到另一个线程之前都能执行一个操作。上下文切换是由操作系统处理的多任务处理程序，以优化性能（[图1.7](#figure1.7)）。但在单核计算机中，多任务处理可能会通过引入线程间上下文切换的额外开销来降低程序的性能。
- en: '![c01-07.png](Images/c01-07.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![c01-07.png](Images/c01-07.png)'
- en: '[Figure 1.7](#figureanchor1.7) Each task has a different shade, indicating
    that the context switch in a single-core machine gives the illusion that multiple
    tasks run in parallel, but only one task is processed at a time.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1.7](#figureanchor1.7) 每个任务都有不同的阴影，表示在单核机器上的上下文切换给人一种多个任务并行运行的错觉，但实际上每次只处理一个任务。'
- en: 'There are two kinds of multitasking operating systems:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的多任务操作系统：
- en: '*Cooperative* *multitasking systems*, where*the scheduler lets each task run
    until it finishes or explicitly yields execution control back to the scheduler*'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*协作* *多任务系统*，其中*调度器允许每个任务运行直到完成或显式地将执行控制权交回给调度器*'
- en: '**   *Preemptive* *multitasking systems* (such as Microsoft Windows),*where
    the scheduler prioritizes the execution of tasks, and the underlying system, considering
    the priority of the tasks, switches the execution sequence once the time allocation
    is completed by yielding control to other tasks**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**   *抢占式* *多任务系统*（如微软Windows），*其中调度器优先执行任务，底层系统根据任务的优先级，在时间分配完成后通过将控制权交给其他任务来切换执行顺序**'
- en: '**Most operating systems designed in the last decade have provided preemptive
    multitasking. Multitasking is useful for UI responsiveness to help avoid freezing
    the UI during long operations.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**过去十年中设计的多数操作系统都提供了抢占式多任务。多任务对于UI响应性很有用，有助于在长时间操作期间避免UI冻结。'
- en: 1.2.5 Multithreading for performance improvement
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2.5 多线程用于性能提升
- en: '*Multithreading* is an extension of the concept of multitasking, aiming to
    improve the performance of a program by maximizing and optimizing computer resources.
    Multithreading is a form of concurrency that uses multiple threads of execution.
    Multithreading implies concurrency, but concurrency doesn’t necessarily imply
    multithreading. Multithreading enables an application to explicitly subdivide
    specific tasks into individual threads that run in parallel within the same process.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*多线程* 是多任务概念的扩展，旨在通过最大化优化计算机资源来提高程序性能。多线程是使用多个执行线程的并发形式。多线程意味着并发，但并发不一定意味着多线程。多线程使应用程序能够显式地将特定任务细分到单个线程中，这些线程在同一个进程中并行运行。'
- en: 'A *thread* is a unit of computation (an independent set of programming instructions
    designed to achieve a particular result), which the operating system scheduler
    independently executes and manages. Multithreading differs from multitasking:
    unlike multitasking, with multithreading the threads share resources. But this
    “sharing resources” design presents more programming challenges than multitasking
    does. We discuss the problem of sharing variables between threads later in this
    chapter in section 1.4.1.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*线程* 是一个计算单元（一组旨在实现特定结果的独立编程指令），操作系统调度器独立执行和管理。多线程与多任务不同：与多任务不同，多线程中的线程共享资源。但这种“资源共享”的设计比多任务更具编程挑战性。我们将在本章的1.4.1节中讨论线程间共享变量的问题。'
- en: The concepts of parallel and multithreading programming are closely related.
    But in contrast to parallelism, multithreading is hardware-agnostic, which means
    that it can be performed regardless of the number of cores. Parallel programming
    is a superset of multithreading. You could use multithreading to parallelize a
    program by sharing resources in the same process, for example, but you could also
    parallelize a program by executing the computation in multiple processes or even
    in different computers. [Figure 1.8](#figure1.8) shows the relationship between
    these terms.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 并行编程和多线程编程的概念密切相关。但与并行性相比，多线程是硬件无关的，这意味着它可以在不考虑核心数量的情况下执行。并行编程是多线程的超集。你可以通过在同一个进程中共享资源来使用多线程并行化一个程序，例如，但你也可以通过在多个进程甚至在不同的计算机上执行计算来并行化一个程序。[图 1.8](#figure1.8)
    展示了这些术语之间的关系。
- en: '![c01-08.png](Images/c01-08.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![c01-08.png](Images/c01-08.png)'
- en: '[Figure 1.8](#figureanchor1.8) Relationship between concurrency, parallelism,
    multithreading, and multitasking in a single and a multicore device'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1.8](#figureanchor1.8) 单核和多核设备中并发、并行、多线程和多任务之间的关系'
- en: 'To summarize:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 总结如下：
- en: '*Sequential programming* refers to a set of ordered instructions executed one
    at a time on one CPU.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*顺序编程* 指的是在单个CPU上依次执行的一组有序指令。'
- en: '*Concurrent programming* handles several operations at one time and doesn’t
    require hardware support (using either one or multiple cores).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*并发编程* 同时处理多个操作，不需要硬件支持（使用一个或多个核心）。'
- en: '*Parallel programming* executes multiple operations at the same time on multiple
    CPUs. All parallel programs are concurrent, running simultaneously, but not all
    concurrency is parallel. The reason is that parallelism is achievable only on
    multi-core devices.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*并行编程*在多个CPU上同时执行多个操作。所有并行程序都是并发的，同时运行，但并非所有并发都是并行。原因是并行性只能在多核设备上实现。'
- en: '*Multitasking* concurrently performs multiple threads from different processes.
    Multitasking doesn’t necessarily mean parallel execution, which is achieved only
    when using multiple CPUs.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多任务处理*同时执行来自不同进程的多个线程。多任务处理并不一定意味着并行执行，只有在使用多个CPU时才能实现并行执行。'
- en: '*Multithreading* extends the idea of multitasking; it’s a form of concurrency
    that uses multiple, independent threads of execution from the same process. Each
    thread can run concurrently or in parallel, depending on the hardware support.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多线程*扩展了多任务处理的概念；它是一种使用来自同一进程的多个独立执行线程的并发形式。每个线程可以并发或并行运行，这取决于硬件支持。'
- en: 1.3 Why the need for concurrency?
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 为什么需要并发？
- en: Concurrency is a natural part of life—as humans we’re accustomed to multitasking.
    We can read an email while drinking a cup of coffee, or type while listening to
    our favorite song. The main reason to use concurrency in an application is to
    increase performance and responsiveness, and to achieve low latency. It’s common
    sense that if one person does two tasks one after another it would take longer
    than if two people did those same two tasks simultaneously.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是生活的一部分自然属性——作为人类，我们习惯于多任务处理。我们可以在喝咖啡的同时阅读电子邮件，或者在我们最喜欢的歌曲中打字。在应用程序中使用并发的最主要原因是提高性能和响应速度，以及实现低延迟。常识告诉我们，如果一个人一个接一个地完成两个任务，所需时间会比两个人同时完成这两个任务要长。
- en: It’s the same with applications. The problem is that most applications aren’t
    written to evenly split the tasks required among the available CPUs. Computers
    are used in many different fields, such as analytics, finance, science, and health
    care. The amount of data analyzed is increasing year by year. Two good illustrations
    are Google and Pixar.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序也是如此。问题是大多数应用程序并没有编写成平均分配所需任务到可用的CPU上。计算机被用于许多不同的领域，如分析、金融、科学和医疗保健。每年分析的数据量都在增加。两个很好的例子是谷歌和皮克斯。
- en: In 2012, Google received more than 2 million search queries per minute; in 2014,
    that number more than doubled. In 1995, Pixar produced the first completely computer-­generated
    movie, *Toy Story*. In computer animation, myriad details and information must
    be rendered for each image, such as shading and lighting. All this information
    changes at the rate of 24 frames per second. In a 3D movie, an exponential increase
    in changing information is required.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 2012年，谷歌每分钟接收超过200万个搜索查询；到2014年，这个数字翻了一番多。1995年，皮克斯制作了第一部完全由计算机生成的电影，《玩具总动员》。在计算机动画中，每个图像都需要渲染无数细节和信息，例如阴影和照明。所有这些信息都以每秒24帧的速度变化。在3D电影中，需要指数级增加变化信息。
- en: The creators of *Toy Story* used 100 connected dual-processor machines to create
    their movie, and the use of parallel computation was indispensable. Pixar’s tools
    evolved for *Toy Story 2*; the company used 1,400 computer processors for digital
    movie editing, thereby vastly improving digital quality and editing time. In the
    beginning of 2000, Pixar’s computer power increased even more, to 3,500 processors.
    Sixteen years later, the computer power used to process a fully animated movie
    reached an absurd 24,000 cores. The need for parallel computing continues to increase
    exponentially.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 《玩具总动员》的制作者使用了100台连接的双处理器机器来制作他们的电影，并行计算的使用是不可或缺的。皮克斯的工具在《玩具总动员2》中得到了进化；该公司使用了1400个计算机处理器进行数字电影编辑，从而大大提高了数字质量和编辑时间。2000年初，皮克斯的计算机能力进一步增加，达到3500个处理器。十六年后，用于处理全动画电影的计算机能力达到了荒谬的24000个核心。对并行计算的需求继续呈指数级增长。
- en: Let’s consider a processor with *N* (as any number) running cores. In a single-threaded
    application, only one core runs. The same application executing multiple threads
    will be faster, and as the demand for performance grows, so too will the demand
    for *N* to grow, making parallel programs the standard programming model choice
    for the future.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个有*N*（任何数字）个运行核心的处理器。在单线程应用程序中，只有一个核心运行。同一个应用程序执行多个线程将会更快，随着对性能的需求增长，对*N*的需求也会增长，使得并行程序成为未来标准编程模型的选择。
- en: If you run an application in a multicore machine that wasn’t designed with concurrency
    in mind, you’re wasting computer productivity because the application as it sequences
    through the processes will only use a portion of the available computer power.
    In this case, if you open Task Manager, or any CPU performance counter, you’ll
    notice only one core running high, possibly at 100%, while all the other cores
    are underused or idle. In a machine with eight cores, running non-concurrent programs
    means the overall use of the resources could be as low as 15% ([figure 1.9](#figure1.9)).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在一个未考虑并发设计的多核机器上运行应用程序，您正在浪费计算机的生产力，因为应用程序在按顺序通过进程时只会使用部分可用的计算机功率。在这种情况下，如果您打开任务管理器或任何CPU性能计数器，您会注意到只有一个核心在高负荷运行，可能达到100%，而所有其他核心都未充分利用或空闲。在一个具有八个核心的机器上运行非并发程序意味着资源的使用率可能低至15%([图1.9](#figure1.9))。
- en: '![c01-09.png](Images/c01-09.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![c01-09.png](Images/c01-09.png)'
- en: '[Figure 1.9](#figureanchor1.9) Windows Task Manager shows a program poorly
    utilizing CPU resources.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.9](#figureanchor1.9) Windows任务管理器显示一个程序未能充分利用CPU资源。'
- en: Such waste of computing power unequivocally illustrates that sequential code
    isn’t the correct programming model for multicore processers. To maximize the
    use of the available computational resources, Microsoft’s .NET platform provides
    parallel execution of code through multithreading. By using parallelism, a program
    can take full advantage of the resources available, as illustrated by the CPU
    performance counter in [figure 1.10](#figure1.10), where you’ll notice that all
    the processor cores are running high, possibly at 100%. Current hardware trends
    predict more cores instead of faster clock speeds; therefore, developers have
    no choice but to embrace this evolution and become parallel programmers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种计算能力的浪费明确表明，顺序代码不是多核处理器的正确编程模型。为了最大限度地利用可用的计算资源，微软的.NET平台通过多线程提供代码的并行执行。通过使用并行性，程序可以充分利用可用的资源，如[图1.10](#figure1.10)中的CPU性能计数器所示，您会注意到所有处理器核心都在高负荷运行，可能达到100%。当前的硬件趋势预测将会有更多的核心而不是更快的时钟速度；因此，开发者别无选择，只能拥抱这一演变，成为并行程序员。
- en: '![c01-10.png](Images/c01-10.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![c01-10.png](Images/c01-10.png)'
- en: '[Figure 1.10](#figureanchor1.10) A program written with concurrency in mind
    can maximize CPU resources, possibly up to 100%.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.10](#figureanchor1.10) 考虑到并发编写的程序可以最大化CPU资源，可能高达100%。'
- en: 1.3.1 Present and future of concurrent programming
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1 并发编程的现在与未来
- en: Mastering concurrency to deliver scalable programs has become a required skill.
    Companies are interested in hiring and investing in engineers who have a deep
    knowledge of writing concurrent code. In fact, writing correct parallel computation
    can save time and money. It’s cheaper to build scalable programs that use the
    computational resources available with fewer servers, than to keep buying and
    adding expensive hardware that is underused to reach the same level of performance.
    In addition, more hardware requires more maintenance and electric power to operate.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握并发编程以交付可扩展程序已成为一项必备技能。公司对招聘和投资那些对编写并发代码有深厚知识的工程师感兴趣。实际上，编写正确的并行计算可以节省时间和金钱。使用较少的服务器即可构建可扩展程序，并利用可用的计算资源，这比不断购买和添加未充分利用的昂贵硬件以达到相同性能水平要便宜得多。此外，更多的硬件需要更多的维护和电力来运行。
- en: This is an exciting time to learn to write multithreaded code, and it’s rewarding
    to improve the performance of your program with the functional programming (FP)
    approach. Functional programming is a programming style that treats computation
    as the evaluation of expressions and avoids changing-state and mutable data. Because
    immutability is the default, and with the addition of a fantastic composition
    and declarative programming style, FP makes it effortless to write concurrent
    programs. More details follow in section1.5.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个学习编写多线程代码的激动人心的时刻，使用函数式编程（FP）方法提高程序性能是令人满意的。函数式编程是一种将计算视为表达式的评估，并避免改变状态和可变数据的编程风格。由于不可变性是默认的，加上出色的组合和声明式编程风格，FP使得编写并发程序变得轻而易举。更多细节将在第1.5节中介绍。
- en: While it’s a bit unnerving to think in a new paradigm, the initial challenge
    of learning parallel programming diminishes quickly, and the reward for perseverance
    is infinite. You’ll find something magical and spectacular about opening the Windows
    Task Manager and proudly noticing that the CPU usage spikes to 100% after your
    code changes. Once you become familiar and comfortable with writing highly scalable
    systems using the functional paradigm, it will be difficult to go back to the
    slow style of sequential code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在新的范式下思考可能会让人有些不安，但学习并行编程的初始挑战很快就会减少，坚持不懈的回报是无限的。你会发现打开Windows任务管理器并自豪地注意到在代码更改后CPU使用率激增是一种神奇而壮观的事情。一旦你熟悉并习惯于使用函数式范式编写高度可扩展的系统，就很难回到缓慢的顺序代码风格。
- en: Concurrency is the next innovation that will dominate the computer industry,
    and it will transform how developers write software. The evolution of software
    requirements in the industry and the demand for high-performance software that
    delivers great user experience through non-blocking UIs will continue to spur
    the need for concurrency. In lockstep with the direction of hardware, it’s evident
    that concurrency and parallelism are the future of programming.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是计算机行业即将到来的下一个创新，它将改变开发者编写软件的方式。随着行业对软件需求的演变和对通过非阻塞UI提供卓越用户体验的高性能软件的需求，对并发的需求将持续增加。与硬件发展方向一致，显然并发和并行性是编程的未来。
- en: 1.4 The pitfalls of concurrent programming
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 并发编程的陷阱
- en: Concurrent and parallel programming are without doubt beneficial for rapid responsiveness
    and speedy execution of a given computation. But this gain of performance and
    reactive experience comes with a price. Using sequential programs, the execution
    of the code takes the happy path of predictability and determinism. Conversely,
    multithreaded programming requires commitment and effort to achieve correctness.
    Furthermore, reasoning about multiple executions running simultaneously is difficult
    because we’re used to thinking sequentially.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和并行编程无疑对快速响应和给定计算的快速执行有益。但这种性能和反应性体验的收益是有代价的。使用顺序程序，代码的执行遵循可预测性和确定性的快乐路径。相反，多线程编程需要承诺和努力才能实现正确性。此外，由于我们习惯于按顺序思考，因此对同时运行的多个执行进行推理是困难的。
- en: 'The process of developing parallel programs involves more than creating and
    spawning multiple threads. Writing programs that execute in parallel is demanding
    and requires thoughtful design. You should design with the following questions
    in mind:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 开发并行程序的过程不仅仅是创建和生成多个线程。编写并行执行的程序要求严格，需要深思熟虑的设计。你应该在设计时考虑以下问题：
- en: How is it possible to use concurrency and parallelism to reach incredible computational
    performance and a highly responsive application?
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用并发和并行性达到令人难以置信的计算性能和高度响应的应用？
- en: How can such programs take full advantage of the power provided by a multicore
    computer?
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样的程序如何充分利用多核计算机提供的强大功能？
- en: How can communication with and access to the same memory location between threads
    be coordinated while ensuring thread safety? (A method is called *thread-safe*
    when the data and state don’t get corrupted if two or more threads attempt to
    access and modify the data or state at the same time.)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在确保线程安全的同时协调线程之间的通信和对同一内存位置的访问？（当两个或多个线程同时尝试访问和修改数据或状态时，如果数据或状态没有损坏，则称该方法为*线程安全*。）
- en: How can a program ensure deterministic execution?
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序如何确保确定性执行？
- en: How can the execution of a program be parallelized without jeopardizing the
    quality of the final result?
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在不危及最终结果质量的情况下并行化程序的执行？
- en: These aren’t easy questions to answer. But certain patterns and techniques can
    help. For example, in the presence of side effects,^([1](#c01-footnote-1))  the
    determinism of the computation is lost because the order in which concurrent tasks
    execute becomes variable. The obvious solution is to avoid side effects in favor
    of pure functions. You’ll learn these techniques and practices during the course
    of the book.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题并不容易回答。但某些模式和技巧可以帮助。例如，在存在副作用的情况下，^([1](#c01-footnote-1)) 计算的可确定性会丧失，因为并发任务执行的顺序变得可变。明显的解决方案是避免副作用，转而使用纯函数。你将在本书的学习过程中了解这些技术和实践。
- en: 1.4.1 Concurrency hazards
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.1 并发风险
- en: Writing concurrent programs isn’t easy, and many sophisticated elements must
    be considered during program design. Creating new threads or queuing multiple
    jobs on the thread pool is relatively simple, but how do you ensure correctness
    in the program? When many threads continually access shared data, you must consider
    how to safeguard the data structure to guarantee its integrity. A thread should
    write and modify a memory location atomically,^([2](#c01-footnote-2))  without
    interference by other threads. The reality is that programs written in imperative
    programming languages or in languages with variables whose values can change (mutable
    variables) will always be vulnerable to data races, regardless of the level of
    memory synchronization or concurrent libraries used.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 编写并发程序并不容易，在程序设计过程中必须考虑许多复杂元素。创建新线程或在线程池中排队多个作业相对简单，但如何确保程序的正确性呢？当许多线程持续访问共享数据时，你必须考虑如何保护数据结构以确保其完整性。一个线程应该原子性地写入和修改内存位置，^([2](#c01-footnote-2)) 
    而不受其他线程的干扰。现实是，使用命令式编程语言或具有可变值的变量（可变变量）编写的程序，无论使用何种级别的内存同步或并发库，都始终容易受到数据竞争的影响。
- en: 'Consider the case of two threads (Thread 1 and Thread 2) running in parallel,
    both trying to access and modify the shared value *x* as shown in [figure 1.11](#figure1.11).
    For Thread 1 to modify a variable requires more than one CPU instruction: the
    value must be read from memory, then modified and ultimately written back to memory.
    If Thread 2 tries to read from the same memory location while Thread 1 is writing
    back an updated value, the value of *x* changed. More precisely, it’s possible
    that Thread 1 and Thread 2 read the value *x* simultaneously, then Thread 1 modifies
    the value *x* and writes it back to memory, while Thread 2 also modifies the value
    *x*. The result is data corruption. This phenomenon is called *race condition*.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两个线程（线程1和线程2）并行运行的情况，它们都在尝试访问和修改共享值*x*，如图[1.11](#figure1.11)所示。对于线程1来说，修改一个变量需要多个CPU指令：值必须从内存中读取，然后修改，最后写回内存。如果线程2在线程1写回更新值时尝试从同一内存位置读取，则*x*的值会改变。更准确地说，线程1和线程2可能同时读取*x*的值，然后线程1修改*x*的值并将其写回内存，而线程2也修改*x*的值。结果是数据损坏。这种现象称为*竞争条件*。
- en: '![c01-11.png](Images/c01-11.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![c01-11.png](Images/c01-11.png)'
- en: '[Figure 1.11](#figureanchor1.11) Two threads (Thread 1 and Thread 2) run in
    parallel, both trying to access and modify the shared value *x*. If Thread 2 tries
    to read from the same memory location while Thread 1 writes back an updated value,
    the value of *x* changes. This result is data corruption or *race condition*.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.11](#figureanchor1.11) 两个线程（线程1和线程2）并行运行，都试图访问和修改共享值*x*。如果线程2在线程1写回更新值时尝试从同一内存位置读取，则*x*的值会改变。这种结果会导致数据损坏或*竞争条件*。'
- en: The combination of a mutable state and parallelism in a program is synonymous
    with problems. The solution from the imperative paradigm perspective is to protect
    the mutable state by locking access to more than one thread at a time. This technique
    is called *mutual exclusion* because the access of one thread to a given memory
    location prevents access of other threads at that time. The concept of timing
    is central as multiple threads must access the same data at the same time to benefit
    from this technique. The introduction of locks to synchronize access by multiple
    threads to shared resources solves the problem of data corruption, but introduces
    more complications that can lead to *deadlock*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中可变状态和并行性的组合等同于问题。从命令式范式角度来看的解决方案是，通过锁定对多个线程的访问来保护可变状态。这种技术称为*互斥*，因为一个线程对给定内存位置的访问阻止了其他线程在该时刻的访问。时间概念是核心的，因为多个线程必须同时访问相同的数据才能从这种技术中受益。引入锁以同步多个线程对共享资源的访问，解决了数据损坏的问题，但引入了可能导致*死锁*的更多复杂性。
- en: Consider the case in [figure 1.12](#figure1.12) where Thread 1 and Thread 2
    are waiting for each other to complete work and are blocked indefinitely in that
    waiting. Thread 1 acquires Lock A, and, right after, Thread 2 acquires Lock B.
    At this point, both threads are waiting on a lock that will never be released.
    This is a case of deadlock.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[图1.12](#figure1.12)中的情况，其中线程1和线程2正在等待对方完成工作，并在等待中无限期地阻塞。线程1获取锁A，紧接着线程2获取锁B。此时，两个线程都在等待一个永远不会释放的锁。这是一个*死锁*的例子。
- en: '![c01-12.png](Images/c01-12.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![c01-12.png](Images/c01-12.png)'
- en: '[Figure 1.12](#figureanchor1.12) In this scenario, Thread 1 acquires Lock A,
    and Thread 2 acquires Lock B. Then, Thread 2 tries to acquire Lock A while Thread
    1 tries to acquire Lock B that is already acquired by Thread 2, which is waiting
    to acquire Lock A before releasing Lock B. At this point, both threads are waiting
    at the lock that’ll never be released. This is a case of deadlock.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.12](#figureanchor1.12) 在这个场景中，线程1获取锁A，线程2获取锁B。然后，线程2试图获取锁A，而线程1试图获取已被线程2获取的锁B，线程2正在等待获取锁A以释放锁B。此时，两个线程都在等待永远不会释放的锁。这是一个死锁的例子。'
- en: 'Here is a list of concurrency hazards with a brief explanation. Later, you’ll
    get more details on each, with a specific focus on how to avoid them:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一份关于并发风险的简要解释列表。稍后，你将更详细地了解每个风险，并特别关注如何避免它们：
- en: Race condition is a state that occurs when a shared mutable resource (a file,
    image, variable, or collection, for example) is accessed at the same time by multiple
    threads, leaving an inconsistent state. The consequent data corruption makes a
    program unreliable and unusable.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞态条件是当共享可变资源（例如文件、图像、变量或集合）同时被多个线程访问时发生的状态。这会导致不一致的状态，后续的数据损坏使得程序不可靠且无法使用。
- en: Performance decline is a common problem when multiple threads share state contention
    that requires synchronization techniques. Mutual exclusion locks (or mutexes),
    as the name suggests, prevent the code from running in parallel by forcing multiple
    threads to stop work to communicate and synchronize memory access. The acquisition
    and release of locks comes with a performance penalty, slowing down all processes.
    As the number of cores gets larger, the cost of lock contention can potentially
    increase. As more tasks are introduced to share the same data, the overhead associated
    with locks can negatively impact the computation. Section 1.4.3 demonstrates the
    consequences and overhead costs due to introducing lock synchronization.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当多个线程共享需要同步技术的状态竞争时，性能下降是一个常见问题。互斥锁（或mutex），正如其名所示，通过迫使多个线程停止工作以进行通信和同步内存访问来防止代码并行运行。锁的获取和释放伴随着性能惩罚，减慢了所有进程。随着核心数量的增加，锁竞争的成本可能会增加。随着更多任务被引入以共享相同的数据，与锁相关的开销可能会对计算产生负面影响。第1.4.3节展示了由于引入锁同步而产生的后果和开销成本。
- en: Deadlock is a concurrency problem that originates from using locks. It occurs
    when a cycle of tasks exists in which each task is blocked while waiting for another
    to proceed. Because all tasks are waiting for another task to do something, they’re
    blocked indefinitely. The more that resources are shared among threads, the more
    locks are needed to avoid race condition, and the higher the risk of deadlocks.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死锁是源于使用锁的并发问题。它发生在存在任务循环的情况下，其中每个任务在等待另一个任务继续时被阻塞。由于所有任务都在等待另一个任务做某事，它们被无限期地阻塞。线程之间共享的资源越多，需要的锁就越多以避免竞态条件，死锁的风险就越高。
- en: Lack of composition is a design problem originating from the introduction of
    locks in the code. Locks don’t compose. Composition encourages problem dismantling
    by breaking up a complex problem into smaller pieces that are easier to solve,
    then gluing them back together. Composition is a fundamental tenet in FP.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏组合是源于代码中引入锁的设计问题。锁不能组合。组合鼓励通过将复杂问题分解成更小的、更容易解决的问题来解决问题，然后将它们重新粘合在一起。组合是函数式编程（FP）的一个基本原则。
- en: 1.4.2 The sharing of state evolution
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.2 状态演化的共享
- en: Real-world programs require interaction between tasks, such as exchanging information
    to coordinate work. This cannot be implemented without sharing data that’s accessible
    to all the tasks. Dealing with this shared state is the root of most problems
    related to parallel programming, unless the shared data is immutable or each task
    has its own copy. The solution is to safeguard all the code from those concurrency
    problems. No compiler or tool can help you position these primitive synchronization
    locks in the correct location in your code. It all depends on your skill as a
    programmer.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 实际程序需要任务之间的交互，例如交换信息以协调工作。没有共享所有任务都可以访问的数据，这是无法实现的。处理这种共享状态是大多数与并行编程相关问题的根源，除非共享数据是不可变的或每个任务都有自己的副本。解决方案是保护所有代码免受这些并发问题的影响。没有编译器或工具可以帮助你将原始同步锁定位在代码的正确位置。这完全取决于你作为程序员的技能。
- en: Because of these potential problems, the programming community has cried out,
    and in response, libraries and frameworks have been written and introduced into
    mainstream object-oriented languages (such as C# and Java) to provide concurrency
    safeguards, which were not part of the original language design. This support
    is a design correction, illustrated with the presence of shared memory in imperative
    and object-oriented, general-purpose programming environments. Meanwhile, functional
    languages don’t need safeguards because the concept of FP maps well onto concurrent
    programming models.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些潜在问题，编程社区已经大声疾呼，作为回应，已经编写并引入了库和框架到主流面向对象语言（如C#和Java）中，以提供并发保障，这些保障并非原始语言设计的一部分。这种支持是一种设计修正，体现在命令式和面向对象、通用编程环境中的共享内存的存在。同时，函数式语言不需要保障，因为函数式编程的概念很好地映射到并发编程模型中。
- en: '1.4.3 A simple real-world example: parallel quicksort'
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.3 一个简单的现实世界示例：并行快速排序
- en: Sorting algorithms are used generally in technical computing and can be a bottleneck.
    Let’s consider a Quicksort algorithm,^([3](#c01-footnote-3))  a CPU-bound computation
    amenable to parallelization that orders the elements of an array. This example
    aims to demonstrate the pitfalls of converting a sequential algorithm into a parallel
    version and points out that introducing parallelism in your code requires extra
    thinking before making any decisions. Otherwise, performance could potentially
    have an opposite outcome to that expected.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 排序算法通常用于技术计算，可能成为瓶颈。让我们考虑一个快速排序算法，^([3](#c01-footnote-3)) 这是一个适用于并行化的CPU密集型计算，它对数组元素进行排序。这个例子旨在演示将顺序算法转换为并行版本的风险，并指出在做出任何决定之前，在代码中引入并行性需要额外的思考。否则，性能可能会产生与预期相反的结果。
- en: 'Quicksort is a Divide and Conquer algorithm; it first divides a large array
    into two smaller sub-arrays of low elements and high elements. Quicksort can then
    recursively sort the sub-arrays, and is amenable to parallelization. It can operate
    in place on an array, requiring small additional amounts of memory to perform
    the sorting. The algorithm consists of three simple steps, as shown in [figure
    1.13](#figure1.13):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序是一种分而治之算法；它首先将一个大数组分为两个较小的子数组，一个是低元素子数组，另一个是高元素子数组。然后快速排序可以递归地对子数组进行排序，并且易于并行化。它可以在数组上原地操作，执行排序时只需要少量额外的内存。该算法由三个简单的步骤组成，如图1.13所示：
- en: Select a pivot element.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个基准元素。
- en: Partition the sequence into subsequences according to their order relative to
    the pivot.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据与基准的相对顺序将序列划分为子序列。
- en: Quicksort the subsequences.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对子序列进行快速排序。
- en: '![c01-13.png](Images/c01-13.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![c01-13.png](Images/c01-13.png)'
- en: '[Figure 1.13](#figureanchor1.13) The recursive function divides and conquers.
    Each block is divided into equal halves, where the pivot element must be the median
    of the sequence, until each portion of code can be executed independently. When
    all the single blocks are completed, they send the result back to the previous
    caller to be aggregated. Quicksort is based on the idea of picking a pivot point
    and partitioning the sequence into sub-sequence elements smaller than the pivot
    and bigger than the pivot elements before recursively sorting the two smaller
    sequences.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.13](#figureanchor1.13) 递归函数进行分而治之。每个块被分成相等的两半，其中基准元素必须是序列的中位数，直到每个代码部分都可以独立执行。当所有单个块都完成后，它们将结果发送回前一个调用者进行聚合。快速排序基于选择一个基准点并将序列划分为小于基准的子序列和大于基准的子序列元素，然后递归地对两个较小的序列进行排序的想法。'
- en: Recursive algorithms, especially ones based on a form of Divide and Conquer,
    are a great candidate for parallelization and CPU-bound computations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 递归算法，尤其是基于分而治之形式的算法，是并行化和CPU密集型计算的优秀候选者。
- en: The Microsoft Task Parallel Library (TPL), introduced after the release of .NET
    4.0, makes it easier to implement and exploit parallelism for this type of algorithm.
    Using the TPL, you can divide each step of the algorithm and perform each task
    in parallel, recursively. It’s a straight and easy implementation, but you must
    be careful of the level of depth to which the threads are created to avoid adding
    more tasks than necessary.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 微软任务并行库（TPL），在.NET 4.0发布后推出，使得实现和利用此类算法的并行性变得更加容易。使用TPL，你可以将算法的每个步骤分割，并递归地并行执行每个任务。这是一个直接且简单的实现，但你必须小心线程创建的深度，以避免添加不必要的任务。
- en: To implement the Quicksort algorithm, you’ll use the FP language F#. Due to
    its intrinsic recursive nature, however, the idea behind this implementation can
    also be applied to C#, which requires an imperative `for` loop approach with a
    mutable state. C# doesn’t support optimized tail-recursive functions such as F#,
    so a hazard exists of raising a stack overflow exception when the call-stack pointer
    exceeds the stack constraint. In chapter 3, we’ll go into detail on how to overcome
    this C# limitation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现快速排序算法，你将使用 FP 语言 F#。然而，由于其固有的递归性质，这个实现背后的思想也可以应用于 C#，它需要一个具有可变状态的命令式 `for`
    循环方法。C# 不支持 F# 那样的优化尾递归函数，因此在调用栈指针超过栈限制时，可能会引发堆栈溢出异常。在第 3 章中，我们将详细介绍如何克服这个 C#
    限制。
- en: '[Listing 1.1](#listing1.1) shows a Quicksort function in F# that adopts the
    Divide and Conquer strategy. For each recursive iteration, you select a pivot
    point and use that to partition the total array. You partition the elements around
    the pivot point using the `List.partition` API, then recursively sort the lists
    on each side of the pivot. F# has great built-in support for data structure manipulation.
    In this case, you’re using the `List.partition` API, which returns a tuple containing
    two lists: one that satisfies the predicate and another that doesn’t.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 1.1](#listing1.1) 展示了一个采用分而治之策略的 F# 快速排序函数。对于每次递归迭代，你选择一个枢轴点并使用它来划分整个数组。你使用
    `List.partition` API 在枢轴点周围划分元素，然后递归地对枢轴两侧的列表进行排序。F# 对数据结构操作有很好的内置支持。在这种情况下，你正在使用
    `List.partition` API，它返回一个包含两个列表的元组：一个满足谓词的列表，另一个不满足谓词的列表。'
- en: '[Listing 1.1](#listinganchor1.1) Simple Quicksort algorithm'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 1.1](#listinganchor1.1) 简单的快速排序算法'
- en: '[PRE0]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Running this Quicksort algorithm against an array of 1 million random, unsorted
    integers on my system (eight logical cores; 2.2 GHz clock speed) takes an average
    of 6.5 seconds. But when you analyze this algorithm design, the opportunity to
    parallelize is evident. At the end of `quicksortSequential`, you recursively call
    into `quicksortSequential` with each partition of the array identified by the
    `(fun number -> number < firstElement) restOfList`. By spawning new tasks using
    the TPL, you can rewrite in parallel this portion of the code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统上（八个逻辑核心；2.2 GHz 时钟速度）运行这个快速排序算法，针对一个包含一百万个随机、未排序整数的数组，平均需要 6.5 秒。但是，当你分析这个算法设计时，并行化的机会是显而易见的。在
    `quicksortSequential` 的末尾，你递归地调用 `quicksortSequential`，每个分区由 `(fun number -> number
    < firstElement) restOfList` 标识。通过使用 TPL 来生成新任务，你可以并行重写这部分代码。
- en: '[Listing 1.2](#listinganchor1.2) Parallel Quicksort algorithm using the TPL'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 1.2](#listinganchor1.2) 使用 TPL 的并行快速排序算法'
- en: '[PRE1]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The algorithm in [Listing 1.2](#listing1.2) is running in parallel, which now
    is using more CPU resources by spreading the work across all available cores.
    But even with improved resource utilization, the overall performance result isn’t
    meeting expectations.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 1.2](#listing1.2) 中的算法正在并行运行，现在通过在所有可用核心之间分配工作，正在使用更多的 CPU 资源。但即使资源利用率有所提高，整体性能结果并没有达到预期。'
- en: 'Execution time dramatically increases instead of decreases. The parallelized
    Quicksort algorithm is passed from an average of 6.5 seconds per run to approximately
    12 seconds. The overall processing time has slowed down. In this case, the problem
    is that the algorithm is *over-parallelized*. Each time the internal array is
    partitioned, two new tasks are spawned to parallelize this algorithm. This design
    is spawning too many tasks in relation to the cores available, which is inducing
    parallelization overhead. This is especially true in a Divide and Conquer algorithm
    that involves parallelizing a recursive function. It’s important that you don’t
    add more tasks than necessary. The disappointing result demonstrates an important
    characteristic of parallelism: inherent limitations exist on how much extra threading
    or extra processing will help a specific algorithmic implementation.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时间反而增加了，而不是减少。并行化的快速排序算法从每次运行平均 6.5 秒增加到大约 12 秒。整体处理时间变慢了。在这种情况下，问题在于算法过度并行化。每次内部数组被划分时，都会生成两个新任务来并行化这个算法。这种设计相对于可用的核心产生了过多的任务，这导致了并行化开销。这在涉及并行化递归函数的分而治之算法中尤其如此。重要的是不要添加比必要的更多任务。令人失望的结果展示了并行化的重要特性：在如何增加额外的线程或处理来帮助特定的算法实现方面存在固有的限制。
- en: To achieve better optimization, you can refactor the previous `quicksortParallel`
    function by stopping the recursive parallelization after a certain point. In this
    way, the algorithm’s first recursions will still be executed in parallel until
    the deepest recursion, which will revert to the serial approach. This design guarantees
    taking full advantage of cores. Plus, the overhead added by parallelizing is dramatically
    reduced.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现更好的优化，你可以通过在某个点停止递归并行化来重构之前的 `quicksortParallel` 函数。这样，算法的前几次递归仍然会并行执行，直到最深的递归，然后会回退到串行方法。这种设计保证了充分利用核心。此外，并行化带来的开销也大大减少。
- en: '[Listing 1.3](#listing1.3) shows this new design approach. It takes into account
    the level where the recursive function is running; if the level is below a predefined
    threshold, it stops parallelizing. The function `quicksortParallelWithDepth` has
    an extra argument, `depth`, whose purpose is to reduce and control the number
    of times a recursive function is parallelized. The `depth` argument is decremented
    on each recursive call, and new tasks are created until this argument value reaches
    zero. In this case, you’re passing the value resulting from `Math.Log(float System.Enviroment.ProcessorCount,
    2.) + 4.` for the `max depth`. This ensures that every level of the recursion
    will spawn two child tasks until all the available cores are enlisted.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 1.3](#listing1.3) 展示了这种新的设计方法。它考虑了递归函数运行的层级；如果层级低于预定义的阈值，它将停止并行化。函数 `quicksortParallelWithDepth`
    有一个额外的参数，`depth`，其目的是减少和控制递归函数并行化的次数。`depth` 参数在每次递归调用时递减，并创建新任务，直到该参数值达到零。在这种情况下，你为
    `max depth` 传递了由 `Math.Log(float System.Enviroment.ProcessorCount, 2.) + 4.` 计算出的值。这确保了递归的每一层都将产生两个子任务，直到所有可用的核心都被征用。'
- en: '[Listing 1.3](#listinganchor1.3) A better parallel `Quicksort` algorithm using
    the TPL'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 1.3](#listinganchor1.3) 使用 TPL 的更好的并行 `Quicksort` 算法'
- en: '[PRE2]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: One relevant factor in selecting the number of tasks is how similar the predicted
    run time of the tasks will be. In the case of `quicksortParallelWithDepth`, the
    duration of the tasks can vary substantially, because the pivot points depend
    on the unsorted data. They don’t necessarily result in segments of equal size.
    To compensate for the uneven sizes of the tasks, the formula in this example calculates
    the `depth` argument to produce more tasks than cores. The formula limits the
    number of tasks to approximately 16 times the number of cores because the number
    of tasks can be no larger than `2 ^ depth.` Our objective is to have a Quicksort
    workload that is balanced, and that doesn’t start more tasks than required. Starting
    a `Task` during each iteration (recursion), when the depth level is reached, saturates
    the processors.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 选择任务数量的一个相关因素是预测的任务运行时间将有多相似。在 `quicksortParallelWithDepth` 的情况下，任务的持续时间可能会有很大的变化，因为枢轴点依赖于未排序的数据。它们不一定导致大小相等的段。为了补偿任务大小的不均匀，本例中的公式计算
    `depth` 参数以产生比核心更多的任务。该公式将任务的数量限制在大约是核心数量的 16 倍，因为任务的数量不能超过 `2 ^ depth`。我们的目标是使快速排序的工作负载平衡，并且不启动比所需的更多的任务。在每次迭代（递归）期间启动
    `Task`，当达到深度层级时，会饱和处理器。
- en: In most cases, the Quicksort generates an unbalanced workload because the fragments
    produced are not of equal size. The conceptual formula `log2``(ProcessorCount)
    + 4` calculates the `depth` argument to limit and adapt the number of running
    tasks regardless of the cases.^([4](#c01-footnote-4))  If you substitute `depth
    = log2(ProcessorCount) + 4` and simplify the expression, you see that the number
    of tasks is 16 times `ProcessorCount`. Limiting the number of subtasks by measuring
    the recursion depth is an extremely important technique.^([5](#c01-footnote-5))
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，快速排序生成不平衡的工作负载，因为产生的片段大小不均。概念公式 `log2`(ProcessorCount) + 4` 计算出 `depth`
    参数以限制和适应运行任务的数量，无论在何种情况下。[4](#c01-footnote-4) 如果你将 `depth = log2(ProcessorCount)
    + 4` 代入并简化表达式，你会发现任务的数量是 `ProcessorCount` 的 16 倍。通过测量递归深度来限制子任务的数量是一种极其重要的技术。[5](#c01-footnote-5)
- en: 'For example, in the case of four-core machines, the depth is calculated as
    follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在四核机器的情况下，深度计算如下：
- en: '[PRE3]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The result is a range between approximately 36 to 64 concurrent tasks, because
    during each iteration two tasks are started for each branch, which in turn double
    in each iteration. In this way, the overall work of partitioning among threads
    has a fair and suitable distribution for each core.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是大约 36 到 64 个并发任务的范围，因为在每次迭代中，每个分支都会启动两个任务，这些任务在每次迭代中都会翻倍。这样，线程之间的分区工作在各个核心之间有公平和合适的分配。
- en: 1.4.4 Benchmarking in F#
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4.4 F# 中的基准测试
- en: You executed the Quicksort sample using the F# REPL (Read-Evaluate-Print-Loop),
    which is a handy tool to run a targeted portion of code because it skips the compilation
    step of the program. The REPL fits quite well in prototyping and data-analysis
    development because it facilitates the programming process. Another benefit is
    the built-in `#time` functionality, which toggles the display of performance information.
    When it’s enabled, F# `Interactive` measures real time, CPU time, and garbage
    collection information for each section of code that’s interpreted and executed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用了 F# REPL（读取-评估-打印循环）执行了 Quicksort 示例，这是一个方便的工具，可以运行代码的特定部分，因为它跳过了程序的编译步骤。REPL
    在原型设计和数据分析开发中非常适合，因为它简化了编程过程。另一个好处是内置的 `#time` 功能，它可以切换性能信息的显示。当启用时，F# `Interactive`
    测量每个解释和执行的代码段的实时、CPU 时间和垃圾回收信息。
- en: Table 1.1 sorts a 3 GB array, enabling the 64-bit environment flag to avoid
    size restriction. It’s run on a computer with eight logical cores (four physical
    cores with hyper-threading). On an average of 10 runs, [table 1.1](#table1.1)
    shows the execution times in seconds.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 对 3 GB 的数组进行排序，启用 64 位环境标志以避免大小限制。它在具有八个逻辑核心（四个物理核心带有超线程）的计算机上运行。在平均 10
    次运行中，[表 1.1](#table1.1) 显示了执行时间（以秒为单位）。
- en: '[Table 1.1](#tableanchor1.1)  Benchmark of sorting with Quicksort'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 1.1](#tableanchor1.1)  Quicksort 排序基准测试'
- en: '| **Serial** | **Parallel** | **Parallel 4 threads** | **Parallel 8 threads**
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **串行** | **并行** | **并行 4 线程** | **并行 8 线程** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 6.52 | 12.41 | 4.76 | 3.50 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 6.52 | 12.41 | 4.76 | 3.50 |'
- en: It’s important to mention that for a small array, fewer than 100 items, the
    parallel sort algorithms are slower than the serial version due to the overhead
    of creating and/or spawning new threads. Even if you correctly write a parallel
    program, the overhead introduced with concurrency constructors could overwhelm
    the program runtime, delivering the opposite expectation by decreasing performance.
    For this reason, it’s important to benchmark the original sequential code as a
    baseline and then continue to measure each change to validate whether parallelism
    is beneficial. A complete strategy should consider this factor and approach parallelism
    only if the array size is greater than a threshold (recursive depth), which usually
    matches the number of cores, after which it defaults back to the serial behavior.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，对于小于 100 项的小数组，由于创建和/或生成新线程的开销，并行排序算法比串行版本慢。即使你正确编写了并行程序，并发构造函数引入的开销可能会压倒程序运行时间，从而降低性能，这与预期相反。因此，重要的是将原始串行代码作为基线进行基准测试，然后继续测量每次更改，以验证并行化是否有益。完整的策略应考虑这个因素，并且只有当数组大小大于一个阈值（递归深度）时才采用并行化，这个阈值通常与核心数相匹配，之后它默认回到串行行为。
- en: 1.5 Why choose functional programming for concurrency?
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 为什么选择函数式编程进行并发？
- en: The trouble is that essentially all the interesting applications of concurrency
    involve the deliberate and controlled mutation of shared state, such as screen
    real estate, the file system, or the internal data structures of the program.
    The right solution, therefore, is to provide mechanisms which allow the safe mutation
    of shared state section.
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 问题在于，本质上所有有趣的并发应用都涉及到对共享状态的故意和受控的修改，例如屏幕空间、文件系统或程序的内部数据结构。因此，正确的解决方案是提供允许安全修改共享状态部分的机制。
- en: —Peyton Jones, Andrew Gordon, and Sigbjorn Finne (“Concurrent Haskell,” *Proceedings
    of the 23rd ACM Symposium on Principles of Programming Languages*, St. Petersburg
    Beach, FL, January 1996)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: —佩顿·琼斯、安德鲁·戈登和西格博恩·菲恩（《并发 Haskell》，*第 23 届 ACM 程序设计语言原理研讨会论文集*，圣彼得堡海滩，FL，1996
    年 1 月）
- en: FP is about minimizing and controlling side effects, commonly referred to as
    *pure functional programming*. FP uses the concept of transformation, where a
    function creates a copy of a value *x* and then modifies the copy, leaving the
    original value *x* unchanged and free to be used by other parts of the program.
    It encourages considering whether mutability and side effects are necessary when
    designing the program. FP allows mutability and side effects, but in a strategic
    and explicit manner, isolating this area from the rest of the code by utilizing
    methods to encapsulate them.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: FP 是关于最小化和控制副作用，通常被称为 *纯函数式编程*。FP 使用转换的概念，其中函数创建一个值 *x* 的副本，然后修改副本，而原始值 *x*
    保持不变，可以由程序的其它部分自由使用。它鼓励在设计程序时考虑是否需要可变性和副作用。FP 允许可变性和副作用，但以战略性和明确的方式，通过利用封装它们的方法将这一区域与代码的其余部分隔离开来。
- en: The main reason for adopting functional paradigms is to solve the problems that
    exist in the multicore era. Highly concurrent applications, such as web servers
    and data-analysis databases, suffer from several architectural issues. These systems
    must be scalable to respond to a large number of concurrent requests, which leads
    to design challenges for handling maximum resource contention and high-scheduling
    frequency. Moreover, race conditions and deadlocks are common, which makes troubleshooting
    and debugging code difficult.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 采用函数式范式的最主要原因是解决多核时代存在的问题。高度并发的应用程序，如网络服务器和数据分析数据库，遭受了几个架构问题。这些系统必须可扩展以响应大量并发请求，这导致了处理最大资源竞争和高调度频率的设计挑战。此外，竞争条件和死锁很常见，这使得代码的故障排除和调试变得困难。
- en: In this chapter, we discussed a number of common issues specific to developing
    concurrent applications in either imperative or OOP. In these programming paradigms,
    we’re dealing with objects as a base construct. Conversely, in terms of concurrency,
    dealing with objects has caveats to consider when passing from a single-thread
    program to a massively parallelizing work, which is a challenging and entirely
    different scenario.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了在命令式或面向对象编程中开发并发应用程序的一些常见问题。在这些编程范式中，我们处理对象作为基本构造。相反，在并发方面，当从单线程程序过渡到大规模并行化工作（这是一个具有挑战性和完全不同的场景）时，处理对象有一些需要注意的注意事项。
- en: The traditional solution for these problems is to synchronize access to resources,
    avoiding contention between threads. But this same solution is a double-edged
    sword because using primitives for synchronization, such as `lock` for mutual
    exclusion, leads to possible deadlock or race conditions. In fact, the state of
    a variable (as the name *variable* implies) can mutate. In OOP, a variable usually
    represents an object that’s liable to change over time. Because of this, you can
    never rely on its state and, consequentially, you must check its current value
    to avoid unwanted behaviors ([figure 1.14](#figure1.14)).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的传统解决方案是对资源访问进行同步，以避免线程之间的竞争。但这个解决方案是一把双刃剑，因为使用同步原语，如用于互斥的 `lock`，可能导致死锁或竞争条件。实际上，变量的状态（正如其名称
    *variable* 所暗示的）可能会发生变化。在面向对象编程（OOP）中，变量通常代表一个随着时间的推移可能会发生变化的对象。正因为如此，你永远不能依赖其状态，因此，你必须检查其当前值以避免不希望的行为
    ([图 1.14](#figure1.14))。
- en: '![c01-14.png](Images/c01-14.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![c01-14.png](Images/c01-14.png)'
- en: '[Figure 1.14](#figureanchor1.14) In the functional paradigm, due to immutability
    as a default construct, concurrent programming guarantees deterministic execution,
    even in the case of a shared state. Conversely, imperative and OOP use mutable
    states, which are hard to manage in a multithread environment, and this leads
    to nondeterministic programs.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1.14](#figureanchor1.14) 在函数式范式下，由于默认构造为不可变性，并发编程保证了确定性执行，即使在共享状态的情况下也是如此。相反，命令式和面向对象编程使用可变状态，这在多线程环境中难以管理，这导致了非确定性程序。'
- en: It’s important to consider that components of systems that embrace the FP concept
    can no longer interfere with each other, and they can be used in a multithreaded
    environment without using any locking strategies.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的是，采用 FP 概念的系统组件不能再相互干扰，并且可以在不使用任何锁定策略的情况下在多线程环境中使用。
- en: Development of safe parallel programs using a share of mutable variables and
    side-­effect functions takes substantial effort from the programmer, who must
    make critical decisions, often leading to synchronization in the form of locking.
    By removing those fundamental problems through functional programming, you can
    also remove those concurrency-specific issues. This is why FP makes an excellent
    concurrent programming model. It is an exceptional fit for concurrent programmers
    to achieve correct high performance in highly multithreaded environments using
    simple code. At the heart of FP, neither variables nor state are mutable and cannot
    be shared, and functions may not have side effects.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用共享的可变变量和副作用函数开发安全的并行程序需要程序员付出大量努力，他们必须做出关键决策，这通常会导致以锁定形式出现的同步。通过通过函数式编程消除这些基本问题，你还可以消除这些特定于并发的并发问题。这就是为什么FP是一个出色的并发编程模型。它非常适合并发程序员，在高度多线程环境中使用简单代码实现正确的高性能。在FP的核心，变量和状态都是不可变的，不能共享，函数可能没有副作用。
- en: FP is the most practical way to write concurrent programs. Trying to write them
    in imperative languages isn’t only difficult, it also leads to bugs that are difficult
    to discover, reproduce, and fix.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: FP是编写并发程序最实用的方法。试图用命令式语言编写它们不仅困难，而且还会导致难以发现、复制和修复的错误。
- en: 'How are you going to take advantage of every computer core available to you?
    The answer is simple: embrace the functional paradigm!'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你将如何利用你所能获得的每一个计算机核心？答案是简单的：拥抱函数式范式！
- en: 1.5.1 Benefits of functional programming
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.1 函数式编程的好处
- en: There are real advantages to learning FP, even if you have no plans to adopt
    this style in the immediate future. Still, it’s hard to convince someone to spend
    their time on something new without showing immediate benefits. The benefits come
    in the form of idiomatic language features that can initially seem overwhelming.
    FP, however, is a paradigm that will give you great coding power and positive
    impact in your programs after a short learning curve. Within a few weeks of using
    FP techniques, you’ll improve the readability and correctness of your applications.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你目前没有计划采用这种风格，学习函数式编程（FP）也有实际的好处。然而，如果不展示即时的好处，很难说服某人花时间学习新事物。好处以惯用语言特性形式出现，最初可能看起来令人不知所措。然而，FP是一种范式，在经过一段学习曲线后，将赋予你强大的编码能力和程序中的积极影响。在几周内使用FP技术后，你会提高应用程序的可读性和正确性。
- en: 'The benefits of FP (with focus on concurrency) include the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: FP（侧重于并发）的好处包括以下内容：
- en: '*Immutability* —A property that prevents modification of an object state after
    creation. In FP, variable assignment is not a concept. Once a value has been associated
    with an identifier, it cannot change. Functional code is immutable by definition.
    Immutable objects can be safely transferred between threads, leading to great
    optimization opportunities. Immutability removes the problems of memory corruption
    (race condition) and deadlocks because of the absence of mutual exclusion.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不可变性* — 一种在创建后防止修改对象状态的性质。在FP中，变量赋值不是一个概念。一旦一个值与一个标识符相关联，它就不能改变。函数式代码按定义是不可变的。不可变对象可以在线程之间安全地传输，从而带来巨大的优化机会。不可变性消除了由于缺乏互斥而导致的内存损坏（竞争条件）和死锁问题。'
- en: '*Pure function* —This has no side effects, which means that functions don’t
    change any input or data of any type outside the function body. Functions are
    said to be pure if they’re transparent to the user, and their return value depends
    only on the input arguments. By passing the same arguments into a pure function,
    the result won’t change, and each process will return the same value, producing
    consistent and expected behavior.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*纯函数* — 这没有副作用，这意味着函数不会改变函数体外的任何输入或数据。如果函数对用户来说是透明的，并且它们的返回值仅取决于输入参数，那么它们就被说成是纯函数。通过将相同的参数传递给纯函数，结果不会改变，每个过程都会返回相同的值，产生一致和预期的行为。'
- en: '*Referential transparency* —The idea of a function whose output depends on
    and maps only to its input. In other words, each time a function receives the
    same arguments, the result is the same. This concept is valuable in concurrent
    programming because the definition of the expression can be replaced with its
    value and will have the same meaning. Referential transparency guarantees that
    a set of functions can be evaluated in any order and in parallel, without changing
    the application''s behavior.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*引用透明性* — 函数的输出仅依赖于其输入并映射到其输入的概念。换句话说，每次函数接收到相同的参数时，结果都是相同的。这个概念在并发编程中很有价值，因为表达式的定义可以被其值替换，并且具有相同的意义。引用透明性保证了可以以任何顺序和并行地评估一组函数，而不会改变应用程序的行为。'
- en: '*Lazy evaluation* —Used in FP to retrieve the result of a function on demand
    or to defer the analysis of a big data stream until needed.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*惰性求值* — 在函数式编程中用于按需检索函数的结果或延迟对大数据流的分析，直到需要时。'
- en: '*Composability* —Used to compose functions and create higher-level abstractions
    out of simple functions. Composability is the most powerful tool to defeat complexity,
    letting you define and build solutions for complex problems.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可组合性* — 用于组合函数并从简单的函数中创建更高级的抽象。可组合性是战胜复杂性的最有力的工具，让你能够定义和构建复杂问题的解决方案。'
- en: Learning to program functionally allows you to write more modular, expression-­oriented,
    and conceptually simple code. The combinations of these FP assets will let you
    understand what your code is doing, regardless of how many threads the code is
    executing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 学习函数式编程可以使你编写更模块化、面向表达式和概念上简单的代码。这些函数式编程资产的组合将让你理解你的代码正在做什么，无论代码正在执行多少线程。
- en: Later in this book, you’ll learn techniques to apply parallelism and bypass
    issues associated with mutable states and side effects. The functional paradigm
    approach to these concepts aims to simplify and maximize efficiency in coding
    with a declarative programming style.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，你将学习应用并行性和绕过与可变状态和副作用相关问题的技术。函数式范式对这些概念的方法旨在通过声明式编程风格简化并最大化编码效率。
- en: 1.6 Embracing the functional paradigm
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 拥抱函数式范式
- en: Sometimes, change is difficult. Often, developers who are comfortable in their
    domain knowledge lack the motivation to look at programming problems from a different
    perspective. Learning any new program paradigm is hard and requires time to transition
    to developing in a different style. Changing your programming perspective requires
    a switch in your thinking and approach, not solely learning new code syntax for
    a new programming language.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，改变是困难的。通常，在领域知识中感到舒适的开发者缺乏从不同角度看待编程问题的动力。学习任何新的程序范式都是困难的，并且需要时间来过渡到以不同风格进行开发。改变你的编程视角需要改变你的思维和方式，而不仅仅是学习新编程语言的新代码语法。
- en: Going from a language such as Java to C# isn’t difficult; in terms of concepts,
    they’re the same. Going from an imperative paradigm to a functional paradigm is
    a far more difficult challenge. Core concepts are replaced. You have no more state.
    You have no more variables. You have no more side effects.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java这样的语言到C#并不困难；在概念上，它们是相同的。从命令式范式到函数式范式的转变是一个更加困难的挑战。核心概念被替换。你不再有状态。你不再有变量。你不再有副作用。
- en: But the effort you make to change paradigms will pay large dividends. Most developers
    will agree that learning a new language makes you a better developer, and liken
    that to a patient whose doctor prescribes 30 minutes of exercise per day to be
    healthy. The patient knows the real benefits in exercise, but is also aware that
    daily exercise implies commitment and sacrifice.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但你为改变范式所付出的努力将带来巨大的回报。大多数开发者都会同意，学习一门新语言可以使你成为一名更好的开发者，并将这比作一位医生建议患者每天锻炼30分钟以保持健康。患者知道锻炼的真正益处，但同时也意识到日常锻炼意味着承诺和牺牲。
- en: 'Similarly, learning a new paradigm isn’t hard, but does require dedication,
    engagement, and time. I encourage everyone who wants to be a better programmer
    to consider learning the FP paradigm. Learning FP is like riding a roller coaster:
    during the process there will be times when you feel excited and levitated, followed
    by times when you believe that you understand a principle only to descend steeply—screaming—but
    the ride is worth it. Think of learning FP as a journey, an investment in your
    personal and professional career with guaranteed return. Keep in mind that part
    of the learning is to make mistakes and develop skills to avoid those in the future.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，学习一种新范式并不难，但确实需要奉献、参与和时间。我鼓励所有希望成为更好的程序员的人考虑学习函数式编程（FP）范式。学习FP就像乘坐过山车：在这个过程中，你会有感到兴奋和飘浮的时刻，然后会有你认为你理解了一个原则，但随后会急剧下降——尖叫——但这次旅行是值得的。将学习FP视为一段旅程，是对你个人和职业生涯的投资，并保证有回报。记住，学习的一部分是犯错误，并发展技能以避免将来再犯同样的错误。
- en: Throughout this process, you should identify the concepts that are difficult
    to understand and try to overcome those difficulties. Think about how to use these
    abstractions in practice, solving simple problems to begin with. My experience
    shows that you can break through a mental roadblock by finding out what the intent
    of a concept is by using a real example. This book will walk you through the benefits
    of FP applied to concurrency and a distributed system. It’s a narrow path, but
    on the other side, you’ll emerge with several great foundational concepts to use
    in your everyday programming. I am confident you’ll gain new insights into how
    to solve complex problems and become a superior software engineer using the immense
    power of FP.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，你应该识别难以理解的概念，并尝试克服这些困难。考虑如何在实践中使用这些抽象概念，从解决简单问题开始。我的经验表明，通过使用真实示例来找出一个概念的目的，你可以突破心理障碍。这本书将引导你了解将函数式编程（FP）应用于并发和分布式系统的益处。这是一条狭窄的道路，但在另一边，你将获得几个在日常生活中编程时可以使用的优秀基础概念。我坚信，你将获得解决复杂问题的新的见解，并利用函数式编程的巨大力量成为一名更优秀的软件工程师。
- en: 1.7 Why use F# and C# for functional concurrent programming?
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 为什么选择F#和C#进行函数式并发编程？
- en: The focus of this book is to develop and design highly scalable and performant
    systems, adopting the functional paradigm to write correct concurrent code. This
    doesn’t mean you must learn a new language; you can apply the functional paradigm
    by using tools that you’re already familiar with, such as the multipurpose languages
    C# and F#. Over the years several functional features have been added to those
    languages, making it easier for you to shift to incorporating this new paradigm.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的焦点是开发和设计高度可扩展和性能优异的系统，采用函数式范式来编写正确的并发代码。这并不意味着你必须学习一门新语言；你可以通过使用你已经熟悉的工具来应用函数式范式，例如多用途语言C#和F#。多年来，这些语言已经添加了几个函数式特性，使你更容易转向采用这种新范式。
- en: The intrinsically different approach to solving problems is the reason these
    languages were chosen. Both programming languages can be used to solve the same
    problem in very different ways, which makes a case for choosing the best tool
    for the job. With a well-rounded toolset, you can design a better and easier solution.
    In fact, as software engineers, you *should* think of programming languages as
    tools.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 解决问题的本质不同方法是选择这些语言的原因。这两种编程语言都可以用非常不同的方式解决相同的问题，这为选择最适合工作的工具提供了论据。拥有一个全面的工具集，你可以设计出更好、更简单的解决方案。实际上，作为软件工程师，你应该将编程语言视为工具。
- en: 'Ideally, a solution should be a combination of C# and F# projects that work
    together cohesively. Both languages cover a different programming model, but the
    option to choose which tool to use for the job provides an enormous benefit in
    terms of productivity and efficiency. Another aspect to selecting these languages
    is their different concurrent programming model support, which can be mixed. For
    instance:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，解决方案应该是由协同工作的C#和F#项目组合而成。这两种语言覆盖了不同的编程模型，但选择使用哪种工具来完成工作的选项，在生产力效率方面提供了巨大的好处。选择这些语言的另一个方面是它们对不同的并发编程模型的支持，可以混合使用。例如：
- en: F# offers a much simpler model than C# for asynchronous computation, called
    *asynchronous workflows*.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 提供了一个比C#更简单的异步计算模型，称为 *异步工作流*。
- en: Both C# and F# are strongly typed, multipurpose programming languages with support
    for multiple paradigms that encompass functional, imperative, and OOP techniques.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 和 F# 都是强类型、多用途的编程语言，支持多种范式，包括函数式、命令式和 OOP 技术。
- en: Both languages are part of the .NET ecosystem and derive a rich set of libraries
    that can be used equally by both languages.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两种语言都是 .NET 生态系统的一部分，并衍生出丰富的库，这些库可以被两种语言同等使用。
- en: F# is a functional-first programming language that provides an enormous productivity
    boost. In fact, programs written in F# tend to be more succinct and lead to less
    code to maintain.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 是一种以函数式编程语言为先的语言，提供了巨大的生产力提升。实际上，用 F# 编写的程序往往更简洁，并且导致需要维护的代码更少。
- en: F# combines the benefits of a functional declarative programming style with
    support from the imperative object-oriented style. This lets you develop applications
    using your existing object-oriented and imperative programming skills.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 结合了函数式声明式编程风格的优点和命令式面向对象风格的支撑。这使得你可以使用现有的面向对象和命令式编程技能来开发应用程序。
- en: F# has a set of built-in lock-free data structures, due to default immutable
    constructors. An example is the discriminated union and the record types. These
    types have structural equality and don’t allow `null`s that lead to “trusting”
    the integrity of the data and easier comparisons.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于默认的不可变构造函数，F# 有一系列内置的无锁数据结构。例如，有判别联合和记录类型。这些类型具有结构相等性，不允许 `null`，这有助于“信任”数据的完整性并简化比较。
- en: F#, different from C#, strongly discourages the use of `null` values, also known
    as the billion-dollar mistake, and, instead, encourages the use of immutable data
    structures. This lack of null reference helps to minimize the number of bugs in
    programming.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 C# 不同，F# 强烈反对使用 `null` 值，也称为“十亿美元的错误”，相反，它鼓励使用不可变数据结构。这种对空引用的缺乏有助于减少编程中的错误数量。
- en: F# is naturally parallelizable because it uses immutably as a default type constructor,
    and because of its .NET foundation, it integrates with the C# language with state-of-the-art
    capability at the implementation level.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 由于默认使用不可变作为类型构造函数，并且由于其 .NET 基础，它能够以最先进的实现能力与 C# 语言集成，因此自然可并行化。
- en: C# design tends toward an imperative language, first with full support for OOP.
    (I like to define this as imperative OO.) The functional paradigm, during the
    past years and since the release of .NET 3.5, has influenced the C# language with
    the addition of features like lambda expressions and LINQ for list comprehension.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 的设计倾向于命令式语言，首先是完全支持面向对象编程（OOP）。（我喜欢将其定义为命令式 OOP。）在过去的几年中，自从 .NET 3.5 发布以来，函数式范式通过添加
    lambda 表达式和 LINQ（列表理解）等功能，已经影响了 C# 语言。
- en: C# also has great concurrency tools that let you easily write parallel programs
    and readily solve tough real-world problems. Indeed, exceptional multicore development
    support within the C# language is versatile, and capable of rapid development
    and prototyping of highly parallel symmetric multiprocessing (SMP) applications.
    These programming languages are great tools for writing concurrent software, and
    the power and options for workable solutions aggregate when used in coexistence.
    SMP is the processing of programs by multiple processors that share a common operating
    system and memory.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 也拥有强大的并发工具，这些工具可以帮助你轻松编写并行程序，并迅速解决复杂的现实世界问题。实际上，C# 语言在多核开发方面的卓越支持是灵活多变的，能够快速开发和原型化高度并行的对称多处理（SMP）应用程序。这些编程语言是编写并发软件的出色工具，当它们共存时，可用的解决方案的强大功能和选项会聚合。SMP
    是通过多个共享相同操作系统和内存的处理器的程序处理。
- en: F# and C# can interoperate. In fact, an F# function can call a method in a C#
    library, and vice versa.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: F# 和 C# 可以互操作。实际上，一个 F# 函数可以调用 C# 库中的方法，反之亦然。
- en: In the coming chapters, we’ll discuss alternative concurrent approaches, such
    as data parallelism, asynchronous, and the message-passing programming model.
    We’ll build libraries using the best tools that each of these programming languages
    can offer and compare those with other languages. We’ll also examine tools and
    libraries like the TPL and Reactive Extensions (Rx) that have been successfully
    designed, inspired, and implemented by adopting the functional paradigm to obtain
    composable abstraction.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论替代的并发方法，如数据并行、异步和消息传递编程模型。我们将使用这些编程语言各自提供的最佳工具构建库，并将它们与其他语言进行比较。我们还将检查像
    TPL 和反应式扩展（Rx）这样的工具和库，这些工具和库通过采用函数式范式进行设计、灵感和实现，以获得可组合的抽象。
- en: It’s obvious that the industry is looking for a reliable and simple concurrent
    programming model, shown by the fact that software companies are investing in
    libraries that remove the level of abstraction from the traditional and complex
    memory-synchronization models. Examples of these higher-level libraries are Intel’s
    Threading Building Blocks (TBB) and Microsoft’s TPL.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，行业正在寻找一个可靠且简单的并发编程模型，这从软件公司投资于移除传统和复杂内存同步模型抽象级别的库中可以看出。这些高级库的例子包括英特尔的多线程构建块（TBB）和微软的任务并行库（TPL）。
- en: There are also interesting open source projects, such as OpenMP (which provides
    pragmas [compiler-specific definitions that you can use to create new preprocessor
    functionality or to send implementation-defined information to the compiler] that
    you can insert into a program to make parts of it parallel) and OpenCL (a low-level
    language to communicate with Graphic Processing Units [GPUs]). GPU programming
    has traction and has been sanctioned by Microsoft with C++ AMP extensions and
    Accelerator .NET.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 还有有趣的开放源代码项目，例如 OpenMP（它提供了可以插入到程序中以使其部分并行的编译器特定定义的预处理器功能或实现定义信息，称为pragma）和
    OpenCL（一种与图形处理单元 [GPU] 通信的低级语言）。GPU 编程具有吸引力，并且得到了微软通过 C++ AMP 扩展和 Accelerator
    .NET 的认可。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: No silver bullet exists for the challenges and complexities of concurrent and
    parallel programming. As a professional engineer, you need different types of
    ammunition, and you need to know how and when to use them to hit the target.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发和并行编程的挑战和复杂性没有银弹存在。作为一名专业工程师，你需要不同类型的弹药，并且你需要知道如何以及何时使用它们来击中目标。
- en: Programs must be designed with concurrency in mind; programmers cannot continue
    writing sequential code, turning a blind eye to the benefits of parallel programming.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序设计时必须考虑到并发性；程序员不能继续编写顺序代码，而忽视并行编程的好处。
- en: Moore’s Law isn’t incorrect. Instead, it has changed direction toward an increased
    number of cores per processor rather than increased speed for a single CPU.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摩尔定律并没有错误。相反，它已经转向了每个处理器核心数量增加的方向，而不是单个 CPU 的速度增加。
- en: While writing concurrent code, you must keep in mind the distinction between
    concurrency, multithreading, multitasking, and parallelism.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写并发代码时，你必须牢记并发、多线程、多任务和并行之间的区别。
- en: The share of mutable states and side effects are the primary concerns to avoid
    in a concurrent environment because they lead to unwanted program behaviors and
    bugs.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在并发环境中，可变状态和副作用的比例是首要关注的问题，因为它们会导致不希望出现的程序行为和错误。
- en: To avoid the pitfalls of writing concurrent applications, you should use programming
    models and tools that raise the level of abstraction.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免编写并发应用程序的陷阱，你应该使用提高抽象级别的编程模型和工具。
- en: The functional paradigm gives you the right tools and principles to handle concurrency
    easily and correctly in your code.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数范式为你提供了处理代码中并发性的正确工具和原则。
- en: Functional programming excels in parallel computation because immutability is
    the default, making it simpler to reason about the share of data.**  **# 2
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程在并行计算中表现出色，因为不可变性是默认的，这使得推理共享数据更容易。**  **# 2
- en: Functional programming techniques for concurrency
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程的功能性技术
- en: '**This chapter covers**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Solving complex problems by composing simple solutions
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过组合简单解决方案来解决复杂问题
- en: Simplifying functional programming with closures
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用闭包简化函数式编程
- en: Improving program performance with functional techniques
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用功能性技术提高程序性能
- en: Using lazy evaluation
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用惰性评估
- en: Writing code in functional programming can make you feel like the driver of
    fast car, speeding along without the need to know how the underlying mechanics
    work. In chapter 1, you learned that taking an FP approach to writing concurrent
    applications better answers the challenges in writing those applications than,
    for example, an object-oriented approach does. Key concepts, such as immutable
    variables and purity, in any FP language mean that while writing concurrent applications
    remains far from easy, developers can be confident that they won’t face several
    of the traditional pitfalls of parallel programming. The design of FP means issues
    such as race conditions and deadlocks can’t happen.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中编写代码可以让你感觉像是一名驾驶着快车的驾驶员，无需了解底层机械原理就能高速行驶。在第1章中，你了解到采用函数式编程方法来编写并发应用程序，比例如面向对象方法更好地解决了编写这些应用程序的挑战。任何函数式语言中的关键概念，如不可变变量和纯度，意味着虽然编写并发应用程序仍然远非易事，但开发者可以确信他们不会面临许多传统的并行编程陷阱。函数式编程的设计意味着诸如竞态条件和死锁等问题不会发生。
- en: In this chapter we’ll look in more detail at the main FP principles that help
    in our quest to write high-quality concurrent applications. You’ll learn what
    the principles are, how they work in both C# (as far as possible) and in F#, and
    how they fit into the patterns for parallel programming.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更详细地探讨主要的函数式编程原则，这些原则有助于我们编写高质量的并发应用程序。你将了解这些原则是什么，它们如何在C#（尽可能）和F#中工作，以及它们如何适应并行编程的模式。
- en: In this chapter, I assume that you have a familiarity with the basic principles
    of FP. If you don’t, see appendix A for the detailed information you need to continue.
    By the end of this chapter, you’ll know how to use functional techniques to compose
    simple functions to solve complex problems and to cache and precompute data safely
    in a multi­threaded environment to speed up your program execution.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我假设你已经熟悉了函数式编程的基本原则。如果你不熟悉，请参阅附录A以获取你需要继续阅读的详细信息。到本章结束时，你将知道如何使用函数式技术将简单的函数组合起来解决复杂问题，并在多线程环境中安全地缓存和预计算数据以加快程序执行速度。
- en: 2.1 Using function composition to solve complex problems
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 使用函数组合解决复杂问题
- en: '*Function* *composition* is the combining of functions in a manner where the
    output from one function becomes the input for the next function, leading to the
    creation of a new function. This process can continue endlessly, chaining functions
    together to create powerful new functions to solve complex problems. Through composition,
    you can achieve modularization to simplify the structure of your program.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数* *组合*是将函数以某种方式组合在一起，其中一个函数的输出成为下一个函数的输入，从而创建一个新的函数。这个过程可以无限进行，将函数链接在一起以创建强大的新函数来解决复杂问题。通过组合，你可以实现模块化，简化程序的结构。'
- en: The *functional paradigm* leads to simple program design. The main motivation
    behind function composition is to provide a simple mechanism for building easy-to-­understand,
    maintainable, reusable, and succinct code. In addition, the composition of functions
    with no side effects keeps the code pure, which preserves the logic of parallelism.
    Basically, concurrent programs that are based on function composition are easier
    to design and less convoluted than programs that aren’t.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数式范式*导致程序设计简单。函数组合背后的主要动机是提供一个简单的机制，用于构建易于理解、易于维护、可重用且简洁的代码。此外，无副作用的函数组合保持了代码的纯度，从而保留了并行逻辑。基本上，基于函数组合的并发程序比非函数组合的程序更容易设计且结构更简单。'
- en: Function composition makes it possible to construct and glue together a series
    of simple functions into a single massive and more complex function. Why is it
    important to glue code together? Imagine solving a problem in a top-down way.
    You start with the big problem and then deconstruct it into smaller problems,
    until eventually it’s small enough that you can directly solve the problem. The
    outcome is a set of small solutions that you can then glue back together to solve
    the original larger problem. Composition is the glue to piece together big solutions.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合使得将一系列简单的函数构建和粘合在一起成为一个单一的大而复杂的函数成为可能。为什么粘合代码很重要呢？想象一下以自上而下的方式解决问题。你从大问题开始，然后将其分解成更小的问题，直到最终足够小，可以直接解决问题。结果是，你得到了一系列小解决方案，然后你可以将它们粘合在一起来解决原始的更大问题。组合是将大解决方案拼接在一起的内聚力。
- en: 'Think of function composition as pipelining in the sense that the resulting
    value of one function supplies the first parameter to the subsequent function.
    There are differences:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数组合视为管道化的概念，即一个函数的结果为后续函数提供第一个参数。这里有一些区别：
- en: Pipelining executes a sequence of operations, where the input of each function
    is the output of the previous function.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道化执行一系列操作，其中每个函数的输入是前一个函数的输出。
- en: Function composition returns a new function that’s the combination of two or
    more functions and isn’t immediately invoked (input -> function -> output).
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组合返回一个新的函数，它是两个或更多函数的组合，并且不会立即调用（输入 -> 函数 -> 输出）。
- en: 2.1.1 Function composition in C#
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 C# 中的函数组合
- en: The C# language doesn’t support function composition natively, which creates
    semantic challenges. But it’s possible to introduce the functionality in a straightforward
    manner. Consider a simple case in C# (shown in [Listing 2.1](#listing2.1)) using
    a lambda expression to define two functions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: C# 语言本身不支持函数组合，这造成了语义上的挑战。但可以通过直接的方式引入这种功能。考虑一个简单的 C# 例子（如[列表 2.1](#listing2.1)所示），使用
    lambda 表达式定义两个函数。
- en: '[Listing 2.1](#listinganchor2.1)  HOFs `grindCoffee` and `brewCoffee` to `Espresso`
    in C#'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.1](#listinganchor2.1)  C# 中的 HOFs `grindCoffee` 和 `brewCoffee` 到 `Espresso`'
- en: '[PRE4]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first function, `grindCoffee`, accepts an object `coffeeBeans` as a parameter
    and returns an instance of a new `CoffeeGround`. The second function, `brewCoffee`,
    takes as a parameter a `coffeeGround` object and returns an instance of a new
    `Espresso`. The intent of these functions is to make an `Espresso` by combining
    the ingredients resulting from their evaluation. How can you combine these functions?
    In C#, you have the option of executing the functions consecutively, passing the
    result of the first function into the second one as a chain.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数 `grindCoffee` 接受一个 `coffeeBeans` 对象作为参数，并返回一个新的 `CoffeeGround` 实例。第二个函数
    `brewCoffee` 接受一个 `coffeeGround` 对象作为参数，并返回一个新的 `Espresso` 实例。这些函数的目的是通过组合它们的评估结果来制作
    `Espresso`。你如何组合这些函数？在 C# 中，你可以选择连续执行这些函数，将第一个函数的结果作为链传递给第二个函数。
- en: Listing 2.2 Composition function in C# (bad)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 C# 中的组合函数（不良）
- en: '[PRE5]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, execute the function `grindCoffee`, passing the parameter `coffeeBeans`,
    then pass the result `coffeeGround` into the function `brewCoffee`. A second and
    equivalent option is to concatenate the execution of both `grindCoffee` and `brewCoffee`,
    which implements the basic idea of function composition. But this is a bad pattern
    in terms of readability because it forces you to read the code from right to left,
    which isn’t the natural way to read English. It would be nice to read the code
    logically from left to right.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，执行函数 `grindCoffee`，传递参数 `coffeeBeans`，然后将结果 `coffeeGround` 传递给函数 `brewCoffee`。第二个等效的选项是将
    `grindCoffee` 和 `brewCoffee` 的执行连接起来，这实现了函数组合的基本思想。但从可读性的角度来看，这是一个不好的模式，因为它迫使你从右到左阅读代码，这不是阅读英语的自然方式。最好是从左到右逻辑地阅读代码。
- en: A better solution is to create a generic, specialized extension method that
    can be used to compose any two functions with one or more generic input arguments.
    The following listing defines a `Compose` function and refactors the previous
    example. (The generic arguments are in bold.)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是创建一个通用的、专门的扩展方法，可以用来组合任何两个具有一个或多个泛型输入参数的函数。以下列表定义了一个 `Compose` 函数，并重构了之前的例子。（泛型参数用粗体表示。）
- en: Listing 2.3 `Compose` function in C#
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 `Compose` 函数在 C# 中
- en: '[PRE6]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As shown in [figure 2.1](#figure2.1), the higher-order function `Compose` chains
    the functions `grindCoffee` and `brewCoffee`, creating a new function `makeEspresso`
    that accepts an argument `coffeeBeans` and executes `brewCoffee (grindCoffee(coffeeBeans)`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 2.1](#figure2.1)所示，高阶函数 `Compose` 将函数 `grindCoffee` 和 `brewCoffee` 连接起来，创建一个新的函数
    `makeEspresso`，它接受一个参数 `coffeeBeans` 并执行 `brewCoffee (grindCoffee(coffeeBeans))`。
- en: '![c02-01.png](Images/c02-01.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![c02-01.png](Images/c02-01.png)'
- en: '[Figure 2.1](#figureanchor2.1) Function composition from function `Func<CoffeeBeans,
    CoffeeGround> grindCoffee` to function `Func<CoffeeGround, Espresso> brewCoffee`.
    Because the output of function `grindCoffee` matches the input of function `brewCoffee`,
    the functions can be composed in a new function that maps from input `CoffeeBeans`
    to output `Espresso`.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.1](#figureanchor2.1) 从函数 `Func<CoffeeBeans, CoffeeGround> grindCoffee`
    到函数 `Func<CoffeeGround, Espresso> brewCoffee` 的函数组合。因为 `grindCoffee` 函数的输出与 `brewCoffee`
    函数的输入相匹配，所以这些函数可以在一个新的函数中组合，该函数将输入 `CoffeeBeans` 映射到输出 `Espresso`。'
- en: In the function body, you can easily see the line that looks precisely like
    the lambda expression `makeEspresso`. This extension method encapsulates the notion
    of composing functions. The idea is to create a function that returns the result
    of applying the inner function `grindCoffee` and then applying the outer function
    `brewCoffee` to the result. This is a common pattern in mathematics, and it would
    be represented by the notation `brewCoffee` of `grindCoffee`, meaning `grindCoffee`
    applied to `brewCoffee`. It’s easy to create higher-order functions (HOFs)^([1](#c02-footnote-1)) 
    using extension methods to raise the level of abstraction defining reusable and
    modular functions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体中，你可以轻松地看到看起来与lambda表达式 `makeEspresso` 完全相同的行。这种扩展方法封装了函数组合的概念。其思路是创建一个函数，该函数返回将内部函数
    `grindCoffee` 的结果应用于外部函数 `brewCoffee` 的结果。这在数学中是一个常见的模式，可以用 `brewCoffee` 的 `grindCoffee`
    表示法来表示，意味着 `grindCoffee` 应用到 `brewCoffee`。使用扩展方法来提高抽象级别，创建可重用和模块化的函数（HOFs）是很容易的^([1](#c02-footnote-1))。
- en: Having a compositional semantic built into the language, such as in F#, helps
    structure the code in a declarative nature. It’s unfortunate that there’s no similarly
    sophisticated solution in C#. In the source code for this book, you’ll find a
    library with several overloads of the `Compose` extension methods that can provide
    similar useful and reusable solutions.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 等语言中内置组合语义有助于以声明性方式结构化代码。遗憾的是，在 C# 中没有类似复杂的解决方案。在这本书的源代码中，你可以找到一个包含多个 `Compose`
    扩展方法重载的库，这些方法可以提供类似的有用和可重用解决方案。
- en: 2.1.2 Function composition in F#
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 F# 中的函数组合
- en: Function composition is natively supported in F#. In fact, the definition of
    the `compose` function is built into the language with the `>>` infix operator.
    Using this operator in F#, you can combine existing functions to build new ones.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: F# 内置了对函数组合的支持。实际上，`compose` 函数的定义是用 `>>` 中缀操作符内置到语言中的。在 F# 中使用此操作符，你可以组合现有函数来构建新的函数。
- en: Let’s consider a simple scenario where you want to increase by 4 and multiply
    by 3 each element in a list. The following listing shows how to construct this
    function with and without the help of function composition so you can compare
    the two approaches.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的场景，你想要将列表中的每个元素增加4然后乘以3。以下列表显示了如何使用和未使用函数组合来构建此函数，以便你可以比较两种方法。
- en: Listing 2.4 F# support for function composition
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 F# 对函数组合的支持
- en: '[PRE7]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The example code applies the function `add4` and `multiplyBy3` to each element
    of the list using the `map`, part of the `List` module in F#. `List.map` is equivalent
    to the `Select` static method in LINQ. The combination of the two functions is
    accomplished using a sequential semantic approach that forces the code to read
    unnaturally from inside out: `multiplyBy3(add4(x))`. The function composition
    style, which uses a more idiomatic F# with the `>>` infix operator, allows the
    code to read from left to right as in a textbook, and the result is much more
    refined, succinct, and easier to understand.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码使用 `map` 函数将 `add4` 和 `multiplyBy3` 函数应用于列表中的每个元素，`map` 函数是 F# 中 `List`
    模块的一部分。`List.map` 等同于 LINQ 中的 `Select` 静态方法。这两个函数的组合是通过一种强制代码从内向外读取的顺序语义方法来实现的：`multiplyBy3(add4(x))`。使用
    `>>` 中缀操作符的函数组合风格允许代码从左到右读取，就像教科书一样，结果更加精致、简洁，且易于理解。
- en: Another way to achieve function composition with simple and modular code semantics
    is by using a technique called closures.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 实现具有简单和模块化代码语义的功能组合的另一种方法是使用一种称为闭包的技术。
- en: 2.2 Closures to simplify functional thinking
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 使用闭包简化函数式思维
- en: 'A *closure* aims to simplify functional thinking, and it allows the runtime
    to manage state, releasing extra complexity for the developer. A closure is a
    first-class function with free variables that are bound in the lexical environment.
    Behind these buzzwords hides a simple concept: closures are a more convenient
    way to give functions access to local state and to pass data into background operations.
    They are special functions that carry an implicit binding to all the nonlocal
    variables (also called *free variables* or *up-­values*) referenced. Moreover,
    a closure allows a function to access one or more nonlocal variables even when
    invoked outside its immediate lexical scope, and the body of this special function
    can transport these *free variables* as a single entity, defined in its enclosing
    scope. More importantly, a closure encapsulates behavior and passes it around
    like any other object, granting access to the context in which the closure was
    created, reading, and updating these values.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*闭包* 的目的是简化函数式思维，并允许运行时管理状态，为开发者释放额外的复杂性。闭包是一个一等函数，具有绑定在词法环境中的自由变量。在这些术语背后隐藏着一个简单的概念：闭包是提供函数访问局部状态和将数据传递到后台操作的一种更方便的方式。它们是特殊的函数，具有对所引用的所有非局部变量（也称为
    *自由变量* 或 *上值*）的隐式绑定。此外，闭包允许函数在调用其直接词法作用域之外时访问一个或多个非局部变量，并且这个特殊函数的主体可以将这些 *自由变量*
    作为单个实体传输，这些变量在其封装作用域中定义。更重要的是，闭包封装行为，就像任何其他对象一样传递它，授予访问闭包创建、读取和更新这些值的上下文。'
- en: In FP or in any other programming language that supports higher-order functions,
    without the support of closures the scope of the data could create problems and
    disadvantages. In the case of C# and F#, however, the compiler uses closures to
    increase and expand the scope of variables. Consequently, the data is accessible
    and visible in the current context, as shown in [figure 2.2](#figure2.2).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程（FP）或任何支持高阶函数的其他编程语言中，如果没有闭包的支持，数据的范围可能会造成问题和不利因素。然而，在 C# 和 F# 的情况下，编译器使用闭包来增加和扩展变量的作用域。因此，数据在当前上下文中是可访问和可见的，如图
    2.2 所示。[图 2.2](#figure2.2)。
- en: '![c02-02.png](Images/c02-02.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![c02-02.png](Images/c02-02.png)'
- en: '[Figure 2.2](#figureanchor2.2) In this example using a closure, the local variable
    `X`, in the body of the outer function `Increment`, is exposed in the form of
    a function (`Func<int>`) generated by the inner function. The important thing
    is the return type of the function `Increment`, which is a function capturing
    the enclosed variable `X`, not the variable itself. Each time the function reference
    `incr` runs, the value of the captured variable `X` increases.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.2](#figureanchor2.2) 在这个使用闭包的例子中，外部函数 `Increment` 的局部变量 `X` 以由内部函数生成的函数（`Func<int>`）的形式暴露出来。重要的是函数
    `Increment` 的返回类型，它是一个捕获封装变量 `X` 的函数，而不是变量本身。每次函数引用 `incr` 运行时，捕获的变量 `X` 的值都会增加。'
- en: In C#, closures have been available since .NET 2.0; but the use and definition
    of closures is easier since the introduction of lambda expressions and the anonymous
    method in .NET, which make for a harmonious mixture.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，自 .NET 2.0 以来就提供了闭包功能；但是，自从引入了 lambda 表达式和 .NET 中的匿名方法之后，闭包的使用和定义变得更加容易，这形成了一种和谐的混合。
- en: This section uses C# for the code samples, though the same concepts and techniques
    apply to F#. This listing defines a closure using an anonymous method.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 本节使用 C# 作为代码示例，尽管相同的概念和技术也适用于 F#。此列表使用匿名方法定义了一个闭包。
- en: Listing 2.5 Closure defined in C# using an anonymous method
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.5 使用匿名方法在 C# 中定义的闭包
- en: '[PRE8]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, the anonymous function `lambda` references a free variable
    `freeVariable` that’s in its enclosing scope. The closure gives the function access
    to its surrounding state (in this case, `freeVariable)`, providing clearer and
    more readable code. Replicating the same functionality without a closure probably
    means creating a class that you want the function to use (and that knows about
    the local variable), and passing that class as an argument. Here, the closure
    helps the runtime to manage state, avoiding the extra and unnecessary boilerplate
    of creating fields to manage state. This is one of the benefits of a closure:
    it can be used as a portable execution mechanism for passing extra context into
    HOFs. Not surprisingly, closures are often used in combination with LINQ. You
    should consider closures as a positive side effect of lambda expressions and a
    great programming trick for your toolbox.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，匿名函数 `lambda` 引用了其封装作用域中的自由变量 `freeVariable`。闭包使函数能够访问其周围的状态（在这种情况下，`freeVariable`），从而提供更清晰、更易读的代码。在没有闭包的情况下复制相同的功能可能意味着创建一个你希望函数使用的类（并且该类了解局部变量），并将该类作为参数传递。在这里，闭包帮助运行时管理状态，避免了创建用于管理状态的额外且不必要的样板代码。这是闭包的一个好处：它可以作为一个可移植的执行机制，用于将额外上下文传递到高阶函数（HOFs）中。不出所料，闭包通常与
    LINQ 结合使用。你应该将闭包视为 lambda 表达式的积极副作用，以及你工具箱中的一项伟大编程技巧。
- en: 2.2.1 Captured variables in closures with lambda expressions
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 使用 lambda 表达式在闭包中捕获变量
- en: The power of closures emerges when the same variable can be used even when it
    would have gone out of scope. Because the variable has been captured, it isn’t
    garbage collected. The advantage of using closures is that you can have a method-level
    variable, which is generally used to implement techniques for memory caching to
    improve computational performance. These functional techniques of**memoization*
    and *functional precomputation* are discussed later in this chapter.*
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当相同的变量即使在它本应超出作用域的情况下也可以使用时，闭包的力量就显现出来了。因为变量已经被捕获，所以它不会被垃圾回收。使用闭包的优势在于你可以有一个方法级别的变量，这通常用于实现内存缓存技术以改善计算性能。本章后面将讨论这些功能技术**记忆化**和*函数式预计算*。
- en: '*[Listing 2.6](#listing2.6) uses an event programming model (EPM) to download
    an image that asynchronously illustrates how captured variables work with closures.
    When the download completes, the process continues updating a client application
    UI. The implementation uses an asynchronous semantic API call. When the request
    completes, the registered event `DownloadDataCompleted` fires and executes the
    remaining logic.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*[列表 2.6](#listing2.6) 使用事件编程模型（EPM）下载一个图像，异步展示了捕获变量如何与闭包一起工作。当下载完成时，进程继续更新客户端应用程序的用户界面。实现使用异步语义
    API 调用。当请求完成时，注册的事件 `DownloadDataCompleted` 触发并执行剩余的逻辑*。'
- en: '[Listing 2.6](#listinganchor2.6) Event register with a lambda expression capturing
    a local variable'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.6](#listinganchor2.6) 使用 lambda 表达式捕获局部变量的事件寄存器'
- en: '[PRE9]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, you get a reference of the image control named `img`. Then you use a
    lambda expression to register the handler callback for the event `DownloadDataCompleted`
    to process when `DownloadDataAsync` completes. Inside the lambda block, the code
    can access the state from out of scope directly due to closures. This access allows
    you to check the state of the image pointer, and, if it isn’t `null`, update the
    UI.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你获取名为 `img` 的图像控制器的引用。然后，你使用 lambda 表达式注册处理程序回调，以便在 `DownloadDataAsync` 完成时处理
    `DownloadDataCompleted` 事件。在 lambda 块内部，由于闭包，代码可以直接访问作用域之外的状态。这种访问允许你检查图像指针的状态，如果它不是
    `null`，则更新用户界面。
- en: This is a fairly straightforward process, but the timeline flow adds interesting
    behavior. The method is asynchronous, so by the time data has returned from the
    service and the callback updates the `image`, the method is already complete.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当直接的过程，但时间线流程增加了有趣的行为。该方法异步执行，因此当数据从服务返回并回调更新 `image` 时，方法已经完成。
- en: If the method completes, should the local variable*`image`*be out of scope?
    How is the image updated then? The answer is called a *captured variable*. The
    lambda expression captures the local variable `image`, which consequently stays
    in scope even though normally it would be released. From this example, you should
    consider captured variables as a snapshot of the values of the variables at the
    time the closure was created. If you built the same process without this captured
    variable, you’d need a class-level variable to hold the image value.**
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法完成，局部变量*`image`*是否应该超出作用域？那么图像如何更新？答案被称为 *捕获变量*。lambda 表达式捕获局部变量 `image`，因此即使通常会被释放，它仍然保持作用域。从这个例子中，你应该将捕获变量视为闭包创建时变量值的快照。如果你在没有这个捕获变量的相同过程中构建相同的过程，你需要一个类级变量来保存图像值。**
- en: '**To prove this, let’s analyze what happens if we add a line of code at the
    end of [Listing 2.6](#listing2.6), changing the image reference to a `null` pointer
    (in bold).'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**为了证明这一点，让我们分析如果在 [列表 2.6](#listing2.6) 的末尾添加一行代码，将图像引用更改为 `null` 指针（加粗）会发生什么。**'
- en: Listing 2.7 Proving the time of captured variable evaluation
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7 证明捕获变量的时间
- en: '[PRE10]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By running the program with the applied changes, the image in the UI won’t update
    because the pointer is set to `null` before executing the lambda expression body.
    Even though the image had a value at the time it was captured, it’s `null` at
    the time the code is executed. The lifetime of captured variables is extended
    until all the closures referencing the variables become eligible for garbage collection.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行经过修改的程序，UI 中的图像不会更新，因为在执行 lambda 表达式主体之前，指针被设置为 `null`。尽管在捕获时图像有一个值，但在代码执行时它是
    `null`。捕获变量的生命周期延长，直到所有引用变量的闭包都适合进行垃圾回收。
- en: In F#, the concept of `null` objects doesn’t exist, so it isn’t possible to
    run such undesirable scenarios.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在 F# 中，不存在 `null` 对象的概念，因此不可能运行这样的不良场景。
- en: 2.2.2 Closures in a multithreading environment
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.2 多线程环境中的闭包
- en: Let’s analyze a use case scenario where you use closures to provide data to
    a task that often runs in a different thread than the main one. In FP, closures
    are commonly used to manage mutable state to limit and isolate the scope of mutable
    structures, allowing thread-safe access. This fits well in a multithreading environment.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一个使用闭包向通常在主线程之外运行的任务提供数据的用例场景。在 FP 中，闭包通常用于管理可变状态，以限制和隔离可变结构的范围，允许线程安全访问。这非常适合多线程环境。
- en: In [Listing 2.8](#listing2.8), a lambda expression invokes the method `Console.WriteLine`
    from a new `Task` of the TPL (`System.Threading.Tasks.Task`). When this task starts,
    the lambda expression constructs a closure that encloses the local variable `iteration`,
    which is passed as an argument to the method that runs in another thread. In this
    case, the compiler is automatically generating an anonymous class with this variable
    as an exposed property.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 2.8](#listing2.8) 中，一个 lambda 表达式从 TPL 的一个新 `Task`（`System.Threading.Tasks.Task`）中调用
    `Console.WriteLine` 方法。当这个任务开始时，lambda 表达式构建一个闭包，该闭包封装了作为另一个线程中运行的方法的参数传递的局部变量
    `iteration`。在这种情况下，编译器会自动生成一个匿名类，该变量作为公开属性。
- en: '[Listing 2.8](#listinganchor2.8)  Closure capturing variables in a multithreaded
    environment'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.8](#listinganchor2.8) 在多线程环境中捕获闭包变量'
- en: '[PRE11]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Closures can lead to strange behaviors. In theory, this program should work:
    you expect the program to print the numbers 1 to 10\. But in practice, this isn’t
    the case; the program will print the number 10 ten times, because you’re using
    the same variable in several lambda expressions, and these anonymous functions
    share the variable value.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包可能导致奇怪的行为。从理论上讲，这个程序应该可以工作：你期望程序打印出从 1 到 10 的数字。但在实践中，情况并非如此；程序将打印数字 10 十次，因为你使用了多个
    lambda 表达式中相同的变量，这些匿名函数共享变量值。
- en: Let’s analyze another example. In this listing, you pass data into two different
    threads using lambda expressions.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析另一个例子。在这个列表中，你使用 lambda 表达式将数据传递到两个不同的线程中。
- en: Listing 2.9 Strange behavior using closures in multithreaded code
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.9 在多线程代码中使用闭包的奇怪行为
- en: '[PRE12]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Even if the first lambda expression captures the variable `i` before its value
    changes, both threads will print the number 7 because the variable `i` is changed
    before both threads start. The reason for this subtle problem is the mutable nature
    of C#. When a closure captures a mutable variable by a lambda expression, the
    lambda captures the reference of the variable instead of the current value of
    that variable. Consequently, if a task runs after the referenced value of the
    variable is changed, the value will be the latest in memory rather than the one
    at the time the variable was captured.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 即使第一个 lambda 表达式在变量值改变之前捕获了变量 `i`，两个线程也会打印数字 7，因为变量 `i` 在两个线程开始之前已经被改变。这个微妙问题的原因是
    C# 的可变性质。当一个闭包通过 lambda 表达式捕获一个可变变量时，lambda 表达式捕获的是变量的引用而不是该变量的当前值。因此，如果任务在变量的引用值改变之后运行，那么值将是内存中的最新值，而不是变量被捕获时的值。
- en: This is a reason to adopt other solutions instead of manually coding the parallel
    loop. `Parallel.For` from the TPL solves this bug. One possible solution in C#
    is to create and capture a new temporary variable for each `Task`. That way, the
    declaration of the new variable is allocated in a new heap location, conserving
    the original value. This same sophisticated and ingenious behavior doesn’t apply
    in functional languages. Let’s look at a similar scenario using F#.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么选择其他解决方案而不是手动编写并行循环的原因之一。TPL 中的 `Parallel.For` 解决了这个错误。在 C# 中，一个可能的解决方案是为每个
    `Task` 创建并捕获一个新的临时变量。这样，新变量的声明就被分配在新的堆位置，保留了原始值。这种复杂而巧妙的行为在函数式语言中并不适用。让我们看看使用
    F# 的类似场景。
- en: Listing 2.10 Closures capturing variables in a multithreaded environment in
    F#
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.10 F# 中多线程环境中捕获变量的闭包
- en: '[PRE13]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Running this version of the code, the result is as expected: the program prints
    the numbers 1 to 10\. The explanation is that F# handles its procedural `for`
    loop differently than does C#. Instead of using a mutable variable and updating
    its value during each iteration, the F# compiler creates a new immutable value
    for every iteration with a different location in memory. The outcome of this functional
    behavior of preferring immutable types is that the lambda captures a reference
    to an immutable value that never changes.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个版本的代码，结果正如预期：程序打印了数字 1 到 10。解释是 F# 处理它的过程式 `for` 循环的方式与 C# 不同。F# 编译器为每次迭代创建一个新的不可变值，并在内存中具有不同的位置，而不是使用可变变量并在每次迭代中更新其值。这种偏好不可变类型的函数式行为的结果是
    lambda 捕获了对一个永远不会改变的不可变值的引用。
- en: Multithreading environments commonly use closures because of the simplicity
    of capturing and passing variables in different contexts that require extra thinking.
    The following listing illustrates how the .NET TPL library can use closures to
    execute multiple threads using the `Parallel.Invoke` API.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程环境通常使用闭包，因为捕获和在不同上下文中传递变量很简单，这需要额外的思考。以下列表说明了 .NET TPL 库如何使用闭包通过 `Parallel.Invoke`
    API 执行多个线程。
- en: Listing 2.11 Closures capturing variables in a multithreaded environment
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.11 多线程环境中捕获变量的闭包
- en: '[PRE14]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the example, `Parallel.Invoke` spawns two independent tasks, each running
    the `ProcessArray` method against a portion of the `array` whose variable is captured
    and enclosed by the lambda expressions.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，`Parallel.Invoke` 生成了两个独立任务，每个任务都会运行 `ProcessArray` 方法，针对 `array` 的一个部分，该部分的变量被
    lambda 表达式捕获并封装。
- en: 'In the context of task parallelism, be aware of variables captured in closures:
    because closures capture the reference of a variable, not its actual value, you
    can end up sharing what isn’t obvious. Closures are a powerful technique that
    you can use to implement patterns to increase the performance of your program.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务并行化的上下文中，请注意闭包中捕获的变量：因为闭包捕获的是变量的引用而不是其实际值，你可能会无意中共享一些不明显的内容。闭包是一种强大的技术，你可以用它来实现模式，以提高你程序的性能。
- en: 2.3 Memoization-caching technique for program speedup
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 用于程序加速的备忘录缓存技术
- en: '*Memoization*, also known as *tabling*, is an FP technique that aims to increase
    the performance of an application. The program speedup is achieved by caching
    the results of a function, and avoiding unnecessary extra computational overhead
    that originates from repeating the same computations. This is possible because
    memoization bypasses the execution of expensive function calls by storing the
    result of prior computations with the identical arguments (as shown in [figure
    2.3](#figure2.3)) for retrieval when the arguments are presented again. A memoized
    function keeps in memory the result of a computation so it can be returned immediately
    in future calls.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*缓存技术*，也称为*表格技术*，是一种旨在提高应用程序性能的FP技术。通过缓存函数的结果，避免了由于重复相同的计算而产生的额外不必要的计算开销，从而实现了程序速度的提升。这是可能的，因为缓存技术通过存储具有相同参数的前期计算结果（如图2.3所示）来绕过昂贵的函数调用执行，以便在参数再次出现时检索。缓存函数将计算结果保留在内存中，以便在未来的调用中立即返回。'
- en: '![c02-03.png](Images/c02-03.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![c02-03.png](Images/c02-03.png)'
- en: '[Figure 2.3](#figureanchor2.3) Memoization is a technique to cache values for
    a function, ensuring a run of only one evaluation. When an input value is passed
    into a memoized function, the internal table storage verifies if an associated
    result exists for this input to return immediately. Otherwise, the function initializer
    runs the computation, and then it updates the internal table storage and returns
    the result. The next time the same input value is passed into the memoized function,
    the table storage contains the associated result and the computation is skipped.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.3](#figureanchor2.3) 缓存技术是一种缓存函数值的技巧，确保只进行一次评估。当输入值传递给缓存函数时，内部表存储会验证是否存在与该输入关联的结果，以便立即返回。否则，函数初始化器将运行计算，然后更新内部表存储并返回结果。下次相同的输入值传递给缓存函数时，表存储中包含关联的结果，计算将被跳过。'
- en: This concept may sound complex at first, but it’s a simple technique once applied.
    Memoization uses closures to facilitate the conversion of a function into a data
    structure that facilitates access to a local variable. A closure is used as a
    wrapper for each call to a memoized function. The purpose of this local variable,
    usually a lookup table, is to store the results of the internal function as a
    value and to use the arguments passed into this function as a key reference.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念一开始可能听起来很复杂，但一旦应用起来就是一个简单的技术。缓存技术使用闭包来促进函数转换为便于访问局部变量的数据结构。闭包被用作缓存函数每次调用的包装器。这个局部变量，通常是一个查找表，目的是将内部函数的结果作为值存储，并使用传递给此函数的参数作为键引用。
- en: The memoization technique fits well in a multithreaded environment, providing
    an enormous performance boost. The main benefit arises when a function is repeatedly
    applied to the same arguments; but, running the function is more expensive in
    terms of CPU computation than accessing the corresponding data structure. To apply
    a color filter to an image, for example, it’s a good idea to run multiple threads
    in parallel. Each thread accesses a portion of the image and modifies the pixels
    in context. But it’s possible that the filter color is applied to a set of pixels
    having identical values. In this case, if the computation will get the same result,
    why should it be re-evaluated? Instead, the result can be cached using memoization,
    and the threads can skip unnecessary work and finish the image processing more
    quickly.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存技术非常适合多线程环境，可以提供巨大的性能提升。主要好处在于当一个函数被反复应用于相同的参数时；但是，从CPU计算的角度来看，运行函数的成本比访问相应的数据结构要高。例如，为了给图像应用颜色过滤器，并行运行多个线程是一个好主意。每个线程访问图像的一部分并修改上下文中的像素。但是，可能存在将过滤器颜色应用于具有相同值的像素集的情况。在这种情况下，如果计算将得到相同的结果，为什么还要重新评估呢？相反，可以使用缓存技术将结果缓存起来，这样线程就可以跳过不必要的任务，更快地完成图像处理。
- en: The following listing shows a basic implementation of a memoized function in
    C#.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了C#中缓存函数的基本实现。
- en: Listing 2.12  Simple example that clarifies how memoization works
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.12  说明缓存技术工作原理的简单示例
- en: '[PRE15]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, you define the `Memoize` function, which internally uses the generic
    collection `Dictionary` as a table variable for caching. A closure captures the
    local variable so it can be accessed from both the delegate pointing to the closure
    and the outer function. When the HOF is called, it first tries to match the input
    to the function to validate whether the parameter has already been cached. If
    the parameter key exists, the cache table returns the result. If the parameter
    key doesn’t exist, the first step is to evaluate the function with the parameter,
    add the parameter and the relative result to the cache table, and ultimately return
    the result. It’s important to mention that memoization is an HOF because it takes
    a function as input and returns a function as output.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你定义 `Memoize` 函数，该函数内部使用泛型集合 `Dictionary` 作为缓存表变量的表。闭包捕获局部变量，以便可以从指向闭包的委托和外部函数中访问它。当
    HOF 被调用时，它首先尝试将输入与函数匹配以验证参数是否已经被缓存。如果参数键存在，缓存表返回结果。如果参数键不存在，第一步是使用参数评估函数，将参数和相关的结果添加到缓存表中，并最终返回结果。重要的是要提到，memoization
    是一个 HOF，因为它接受一个函数作为输入并返回一个函数作为输出。
- en: This is the equivalent `memoize` function implemented in F#.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 F# 中实现的等效 `memoize` 函数。
- en: Listing 2.13 `memoize` function in F#
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.13 F# 中的 `memoize` 函数
- en: '[PRE16]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a simple example using the previously defined `memoize` function. In
    [Listing 2.14](#listing2.14), the `Greeting` function returns a string with a
    welcoming message for the name passed as an argument. The message also includes
    the time when the function is called, which is used to keep track of time when
    the function runs. The code applies a two-second delay between each call for demonstration
    purposes.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用之前定义的 `memoize` 函数的简单示例。在 [列表 2.14](#listing2.14) 中，`Greeting` 函数返回一个字符串，其中包含传递给参数的欢迎消息。消息还包括函数被调用时的时间，这用于在函数运行时跟踪时间。代码为了演示目的，在每次调用之间应用了
    2 秒的延迟。
- en: '[Listing 2.14](#listinganchor2.14) Greeting example in C#'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.14](#listinganchor2.14) C# 中的问候示例'
- en: '[PRE17]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, the code re-executes the same messages but uses a memoized version of
    the function `Greeting`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码重新执行相同的消息，但使用 `Greeting` 函数的 memoized 版本。
- en: Listing 2.15 Greeting example using a memoized function
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.15 使用 memoized 函数的问候示例
- en: '[PRE18]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The output indicates that the first two calls happened at different times as
    anticipated. But what happens in a third call? Why does the third function call
    return the message with the exact same time as the first one? The answer is memoization.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明前两次调用发生在不同的时间，正如预期的那样。但在第三次调用中发生了什么？为什么第三次函数调用返回与第一次完全相同时间的消息？答案是 memoization。
- en: The first and third function `greetingMemoize("Richard")` calls have the same
    arguments, and their results have been cached only once during the initial call
    by the function `greetingMemoize`. The result from the third function call isn’t
    the effect of its execution, but is the stored result of the function with the
    same argument, and consequently the time matches.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次和第三次函数调用 `greetingMemoize("Richard")` 有相同的参数，并且它们的结果在 `greetingMemoize` 函数的初始调用中只被缓存了一次。第三次函数调用的结果不是其执行的效果，而是具有相同参数的函数存储的结果，因此时间匹配。
- en: This is how memoization works. The memoized function’s job is to look up the
    argument passed in an internal table. If it finds the input value, it returns
    the previously computed result. Otherwise, the function stores the result in the
    table.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 memoization 的工作原理。memoized 函数的职责是在内部表中查找传入的参数。如果找到输入值，它将返回之前计算的结果。否则，函数将结果存储在表中。
- en: 2.4 Memoize in action for a fast web crawler
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 使用 memoize 快速网络爬虫的实际应用
- en: Now, you’ll implement a more interesting example using what you learned in the
    previous section. For this example, you’ll build a web crawler that extracts and
    prints into the console the page title of each website visited. [Listing 2.16](#listing2.16)
    runs the code without memoization. Then you’ll re-execute the same program using
    the memoization technique and compare the outcome. Ultimately, you’ll download
    multiple websites’ contents, combining parallel execution and memoization.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将使用上一节中学到的知识实现一个更有趣的示例。对于这个示例，你将构建一个网络爬虫，它从每个访问的网站中提取并打印到控制台中的页面标题。[列表 2.16](#listing2.16)
    运行的是没有 memoization 的代码。然后你将使用 memoization 技术重新执行相同的程序，并比较结果。最终，你将下载多个网站的 内容，结合并行执行和
    memoization。
- en: '[Listing 2.16](#listinganchor2.16) Web crawler in C#'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.16](#listinganchor2.16) C# 中的网络爬虫'
- en: '[PRE19]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `WebCrawler` function downloads the content of the web page URL passed as
    an argument by calling the method `GetWebContent`. Next, it analyzes the content
    downloaded and extracts the hyperlinks contained in the web page, which are sent
    back to the initial function to be processed, repeating the operations for each
    of the hyperlinks. Here is the web crawler in action.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebCrawler` 函数通过调用 `GetWebContent` 方法下载作为参数传递的网页 URL 的内容。接下来，它分析下载的内容并提取网页中包含的超链接，这些超链接被发送回初始函数进行处理，对每个超链接重复这些操作。下面是网络爬虫的实际运行情况。'
- en: Listing 2.17 Web crawler execution
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.17 执行网络爬虫
- en: '[PRE20]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You’re using LINQ (Language Integrated Query) to run the web crawler against
    a collection of given URLs. When the query expression is materialized during the
    `foreach` loop, the function `ExtractWebPageTitle` extracts the page title from
    each page’s content and prints it to the console. Because of the cross-network
    nature of the operation, the function `GetWebContent` requires time to complete
    the download. One problem with the previous code implementation is the existence
    of duplicate hyperlinks. It’s common that web pages have duplicate hyperlinks,
    which in this example cause redundant and unnecessary downloads. A better solution
    is to memoize the function `WebCrawler`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在使用 LINQ（语言集成查询）对一组给定的 URL 运行网络爬虫。当查询表达式在 `foreach` 循环中实现时，`ExtractWebPageTitle`
    函数从每个页面的内容中提取页面标题并将其打印到控制台。由于操作的跨网络性质，`GetWebContent` 函数需要时间来完成下载。前一个代码实现的一个问题是存在重复的超链接。通常，网页会有重复的超链接，在这个例子中导致冗余和不必要的下载。更好的解决方案是缓存
    `WebCrawler` 函数。
- en: Listing 2.18 Web crawler execution using memoization
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.18 使用缓存执行网络爬虫
- en: '[PRE21]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, you implemented the HOF `WebCrawlerMemoized`, which is the
    memoized version of the function `WebCrawler`. The output confirms that the memoized
    version of the code runs faster. In fact, to extract the content a second time
    from the web page [www.google.com](http://www.google.com) took only 2 ms, as opposed
    to more than 5 seconds without memoization.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你实现了 `WebCrawlerMemoized` 高阶函数，它是 `WebCrawler` 函数的缓存版本。输出确认了缓存版本的代码运行速度更快。实际上，从网页
    [www.google.com](http://www.google.com) 提取内容第二次只用了 2 毫秒，而没有缓存则需要超过 5 秒钟。
- en: A further improvement should involve downloading the web pages in parallel.
    Fortunately, because you used LINQ to process the query, only a marginal code
    change is required to use multiple threads. Since the advent of the .NET 4.0 framework,
    LINQ has an extension method `AsParallel()` to enable a parallel version of LINQ
    (or PLINQ). The nature of PLINQ is to deal with data parallelism; both topics
    will be covered in chapter 4.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步的改进应涉及并行下载网页。幸运的是，因为你使用了 LINQ 处理查询，所以只需要微小的代码更改就可以使用多线程。自 .NET 4.0 框架问世以来，LINQ
    有一个扩展方法 `AsParallel()`，它能够启用 LINQ 的并行版本（或 PLINQ）。PLINQ 的本质是处理数据并行性；这两个主题将在第 4
    章中介绍。
- en: LINQ and PLINQ are technologies designed and implemented using functional programming
    concepts, with special attention to emphasizing a declarative programming style.
    This is achievable because the functional paradigm tends to raise the level of
    abstraction in comparison with other program paradigms. Abstraction consents to
    write code without the need to know the implementation details of the underlying
    library, as shown here.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 和 PLINQ 是使用函数式编程概念设计和实现的，特别强调声明式编程风格。这是可行的，因为函数式范式与其他程序范式相比，往往能提高抽象级别。抽象允许编写代码时无需了解底层库的实现细节，正如这里所示。
- en: Listing 2.19 Web crawler query using PLINQ
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.19 使用 PLINQ 的网络爬虫查询
- en: '[PRE22]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: PLINQ is easy to use and can give you substantial performance benefits. Although
    we only showed one method, the `AsParallel` extension method, there’s more to
    it than that.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ 易于使用，并且可以带来实质性的性能提升。尽管我们只展示了 `AsParallel` 扩展方法，但它的内容远不止于此。
- en: Before running the program, you have one more refactoring to apply—caches. Because
    they must be accessible by all threads, caches tend to be static. With the introduction
    of parallelism, it’s possible for multiple threads to simultaneously access the
    memoize function, causing a race-condition problem due to the underlying mutable
    data structure exposed. The race-condition problem is discussed in the previous
    chapter. Fortunately, this is an easy fix, as shown in this listing.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行程序之前，你还有一个重构需要应用——缓存。因为它们必须对所有线程可访问，所以缓存往往被设置为静态。随着并行性的引入，多个线程可以同时访问备忘录函数，这可能导致由于暴露的底层可变数据结构而引起的竞争条件问题。竞争条件问题在上一章中已有讨论。幸运的是，这是一个简单的修复，如本列表所示。
- en: Listing 2.20 Thread-safe memoization function
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.20](#listinganchor2.20) 线程安全的备忘录函数'
- en: '[PRE23]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The quick answer is to replace the current `Dictionary` collection with the
    equivalent thread-safe version `ConcurrentDictionary`. This refactoring interestingly
    requires less code. Next, you implement a thread-safe memoized version of the
    function `GetWebContent`, which is used for the LINQ expression. Now you can run
    the web crawler in parallel. To process the pages from the example, a dual-core
    machine can complete the analysis in less than 7 seconds, compared to the 18 seconds
    of the initial implementation. The upgraded code, besides running faster, also
    reduces the network I/O operations.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 快速答案是替换当前的 `Dictionary` 集合为等效的线程安全版本 `ConcurrentDictionary`。这个重构有趣地需要更少的代码。接下来，你实现一个线程安全的备忘录版本的函数
    `GetWebContent`，该函数用于 LINQ 表达式。现在你可以并行运行网络爬虫。为了处理示例中的页面，双核机器可以在不到 7 秒内完成分析，而初始实现需要
    18 秒。升级后的代码不仅运行更快，还减少了网络 I/O 操作。
- en: 2.5 Lazy memoization for better performance
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 更好的性能的延迟备忘录
- en: In the previous example, the web crawler allows multiple concurrent threads
    to access the memoized function with minimum overhead. But it doesn’t enforce
    the function initializer `func(a)` from being executed multiple times for the
    same value, while evaluating the expression. This might appear to be a small issue,
    but in highly concurrent applications, the occurrences multiply (in particular,
    if the object initialization is expensive). The solution is to add an object to
    the cache that isn’t initialized, but rather a function that initializes the item
    on demand. You can wrap the result value from the function initializer into a
    `Lazy` type (as highlighted with bold in [Listing 2.21](#listing2.21)). The listing
    shows the memoization solution, which represents a perfect design in terms of
    thread safety and performance, while avoiding duplicate cache item initialization.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，网络爬虫允许多个并发线程以最小的开销访问备忘录函数，但它不强制执行函数初始化器 `func(a)` 在评估表达式时对相同值执行多次。这似乎是一个小问题，但在高度并发的应用程序中，这种情况会成倍增加（特别是如果对象初始化成本高昂）。解决方案是向缓存添加一个未初始化的对象，而是一个按需初始化项的函数。你可以将函数初始化器的结果值包装在一个
    `Lazy` 类型中（如 [列表 2.21](#listing2.21) 中用粗体突出显示）。该列表显示了备忘录解决方案，它在线程安全和性能方面代表了一个完美的设计，同时避免了重复的缓存项初始化。
- en: '[Listing 2.21](#listinganchor2.21)  Thread-safe memoization function with safe
    lazy evaluation'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.21](#listinganchor2.21)  线程安全的延迟评估备忘录函数'
- en: '[PRE24]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: According to the Microsoft documentation, the method `GetOrAdd` doesn’t prevent
    the function `func` from being called more than once for the same given argument,
    but it does guarantee that the result of only one “evaluation of the function”
    is added to the collection. There could be multiple threads checking the cache
    concurrently before the cached value is added, for example. Also, there’s no way
    to enforce the function `func(a)` to be thread safe. Without this guarantee, it’s
    possible that in a multithreaded environment, multiple threads could access the
    same function simultaneously—meaning `func(a)` should also be thread safe itself.
    The solution proposed, avoiding primitive locks, is to use the `Lazy<T>` construct
    in .NET 4.0\. This solution gives you the guarantee of full thread safety, regardless
    of the implementation of the function `func`, and ensures a single evaluation
    of the function.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 根据微软的文档，`GetOrAdd` 方法不会阻止函数 `func` 对于相同的给定参数被多次调用，但它确实保证只将“函数评估的结果”添加到集合中。例如，在缓存值添加之前，可能有多个线程同时检查缓存。此外，没有方法可以强制函数
    `func(a)` 是线程安全的。没有这个保证，在多线程环境中，多个线程可能同时访问同一个函数——这意味着 `func(a)` 也应该是线程安全的。提出的解决方案是避免使用原始锁，而是在
    .NET 4.0 中使用 `Lazy<T>` 构造。这个解决方案提供了对函数 `func` 实现的完全线程安全保证，并确保函数只被评估一次。
- en: 2.5.1 Gotchas for function memoization
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 函数记忆化的注意事项
- en: 'The implementations of memoization introduced in the previous code examples
    are a somewhat naive approach. The solution of storing data in a simple dictionary
    works, but it isn’t a long-term solution. A dictionary is unbounded; consequently,
    the items are never removed from memory but only added, which can, at some point,
    lead to memory leak issues. Solutions exist to all these problems. One option
    is to implement a memoize function that uses a `WeakReference` type to store the
    result values, which permits the results to be collected when the garbage collector
    (GC) runs. Since the introduction of the collection `ConditionalWeakDictionary`
    with the .NET 4.0 framework, this implementation is simple: a dictionary takes
    as a key a type instance that’s held as a *weak reference*. The associated values
    are kept as long as the key lives. When the key is reclaimed by the GC to be collocated,
    the reference to the data is removed, making it available for collection.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中引入的记忆化实现是一种相当天真方法。将数据存储在简单字典中的解决方案是可行的，但它不是长期解决方案。字典是无界的；因此，项目永远不会从内存中移除，只会添加，这可能在某个时候导致内存泄漏问题。存在解决所有这些问题的方法。一个选项是实现一个使用
    `WeakReference` 类型存储结果值的记忆化函数，这允许在垃圾回收器（GC）运行时收集结果。自从 .NET 4.0 框架引入了 `ConditionalWeakDictionary`
    收集以来，这种实现变得简单：字典使用一个作为弱引用持有的类型实例作为键。关联的值只要键存在就保持。当键被GC回收以进行合并时，对数据的引用被移除，使其可用于收集。
- en: Weak references are a valuable mechanism for handling references to managed
    objects. The typical object reference (also known as a strong reference) has a
    deterministic behavior, where as long as you have a reference to the object, the
    GC won’t collect the object that consequently stays alive. But in certain scenarios,
    you want to keep an invisible string attached to an object without interfering
    with the GC’s ability to reclaim that object’s memory. If the GC reclaimed the
    memory, your string becomes unattached and you can detect this. If the GC hasn’t
    touched the object yet, you can pull the string and retrieve a strong reference
    to the object to use it again. This facility is useful for automatically managing
    a cache that can keep weak references to the least recently used objects without
    preventing them from being collected and inevitably optimizing the memory resources.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 弱引用是处理对托管对象引用的有价值机制。典型的对象引用（也称为强引用）具有确定性行为，只要你有对象的引用，垃圾回收器（GC）就不会收集该对象，从而使其保持存活状态。但在某些场景下，你希望在不干扰GC回收该对象内存能力的情况下，将一个不可见的字符串附加到对象上。如果GC回收了内存，你的字符串就会变得无关联，你可以检测到这一点。如果GC尚未接触该对象，你可以拉出字符串，并检索到对象的强引用以再次使用。这种功能对于自动管理缓存非常有用，它可以保持对最近最少使用对象的弱引用，同时防止它们被回收，从而不可避免地优化内存资源。
- en: An alternative option is to use a cache-expiration policy by storing a timestamp
    with each result, indicating the time when the item is persisted. In this case,
    you have to define a constant time to invalidate the items. When the time expires,
    the item is removed from the collection. The downloadable source code for this
    book holds both of these implementations.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用缓存过期策略，通过将时间戳存储在每个结果中，指示项目持久化的时间。在这种情况下，你必须定义一个常数时间来使项目无效。当时间到期时，项目将从集合中删除。本书的可下载源代码包含这两种实现。
- en: 2.6 Effective concurrent speculation to amortize the cost of expensive computations
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 有效并发推测以分摊昂贵计算的成本
- en: '**Speculative* *Processing* (precomputation) is a good reason to exploit concurrency.
    Speculative Processing is an FP pattern in which computations are performed before
    the actual algorithm runs, and as soon as all the inputs of the function are available.
    The idea behind concurrent speculation is to amortize the cost of expensive computation
    and improve the performance and responsiveness of a program. This technique is
    easily applicable in parallel computing, where multicore hardware can be used
    to precompute multiple operations spawning a concurrently running task and have
    the data ready to read without delay.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**推测性** **处理**（预计算）是利用并发的良好理由。推测性处理是一种函数式编程（FP）模式，其中在算法实际运行之前，以及一旦函数的所有输入都可用时，执行计算。并发推测背后的想法是分摊昂贵计算的成本，并提高程序的性能和响应速度。这种技术在并行计算中很容易应用，可以使用多核硬件来预计算多个操作，从而启动并发运行的任务，并使数据准备好读取而无需延迟。'
- en: Let’s say you’re given a long list of input words, and you want to compute a
    function that finds the best fuzzy match^([2](#c02-footnote-2))  of a word in
    the list. For the fuzzy-match algorithm, you’re going to apply the *Jaro-Winkler
    distance*, which measures the similarity between two strings. We’re not going
    to cover the implementation of this algorithm here. You can find the complete
    implementation in the online source code.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被给了一个长的输入单词列表，并且你想计算一个函数，该函数可以找到列表中单词的最佳模糊匹配^([2](#c02-footnote-2))。对于模糊匹配算法，你将应用*Jaro-Winkler距离*，该距离衡量两个字符串之间的相似性。我们不会在这里介绍该算法的实现。你可以在在线源代码中找到完整的实现。
- en: This listing shows the implementation of the fuzzy-match function using the
    Jaro-Winkler algorithm (highlighted in bold).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表显示了使用Jaro-Winkler算法实现模糊匹配函数（如粗体所示）。
- en: '[Listing 2.22](#listinganchor2.22) Implementing a fuzzy match in C#'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表2.22](#listinganchor2.22) 在C#中实现模糊匹配'
- en: '[PRE25]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The function `FuzzyMatch` uses PLINQ to compute in parallel the fuzzy match
    for the word passed as an argument against another array of strings. The result
    is a `HashSet` collection of matches, which is then ordered by best match to return
    the first value from the list. `HashSet` is an efficient data structure for lookups.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`FuzzyMatch`使用PLINQ并行计算传递给函数的单词与另一个字符串数组之间的模糊匹配。结果是匹配的`HashSet`集合，然后按最佳匹配顺序排列，以返回列表中的第一个值。"HashSet"是一种高效的数据结构，用于查找。
- en: 'The logic is similar to a lookup. Because `List<string> words` could contain
    duplicates, the function first instantiates a data structure that’s more efficient.
    Then the function utilizes this data structure to run the actual fuzzy match.
    This implementation isn’t efficient, as the design issue is evident: `FuzzyMatch`
    is applied each time it’s called to both of its arguments. The internal table
    structure is rebuilt every time `FuzzyMatch` is executed, wasting any positive
    effect.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑类似于查找。因为`List<string> words`可能包含重复项，所以函数首先实例化一个更有效的数据结构。然后函数利用这个数据结构来运行实际的模糊匹配。这种实现并不高效，因为设计问题很明显："FuzzyMatch"每次调用时都应用于其两个参数。每次执行"FuzzyMatch"时都会重建内部表结构，浪费了任何积极的效果。
- en: How can you improve this efficiency? By applying a combination of a partial
    function application or a partial application and the memoization technique from
    FP, you can achieve precomputation. For more details about partial application,
    see appendix A. The concept of precomputation is closely related to memoization,
    which in this case uses a table containing pre-calculated values. The next listing
    shows the implementation of a faster fuzzy-match function (as highlighted in bold).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何提高效率？通过应用部分函数应用或部分应用以及来自函数式编程（FP）的备忘录技术，你可以实现预计算。有关部分应用的更多详细信息，请参阅附录A。预计算的概念与备忘录紧密相关，在这种情况下，它使用包含预计算值的表格。下面的列表显示了实现一个更快的模糊匹配函数（如粗体所示）。
- en: '[Listing 2.23](#listinganchor2.23) Fast fuzzy match using precomputation'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.23](#listinganchor2.23) 使用预计算进行快速模糊匹配'
- en: '[PRE26]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, you create a partial applied version of the function `PartialFuzzyMatch`.
    This new function takes as an argument only `List<string> words` and returns a
    new function that handles the second argument. This is a clever strategy because
    it consumes the first argument as soon as it’s passed, by precomputing the efficient
    lookup structure.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建了一个函数 `PartialFuzzyMatch` 的偏应用版本。这个新函数只接受 `List<string> words` 作为参数，并返回一个新的函数来处理第二个参数。这是一个巧妙的策略，因为它通过预计算高效的查找结构，立即消耗第一个参数。
- en: Interestingly, the compiler uses a closure to store the data structure, which
    is accessible through the lambda expression returned from the function. A lambda
    expression is an especially handy way to provide a function with a precomputed
    state. Then, you can define the `fastFuzzyMatch` function by supplying the argument
    `List<string> words`, which is used to prepare an underlying lookup table, resulting
    in faster computation. After supplying `List<string> words`, `fastFuzzyMatch`
    returns a function that takes the string `word` argument, but immediately computes
    the `HashSet` for the lookup.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，编译器使用闭包来存储数据结构，该数据结构可以通过函数返回的 lambda 表达式访问。lambda 表达式是提供预计算状态给函数的一种特别方便的方式。然后，你可以通过提供参数
    `List<string> words` 来定义 `fastFuzzyMatch` 函数，该参数用于准备底层查找表，从而实现更快的计算。在提供 `List<string>
    words` 之后，`fastFuzzyMatch` 返回一个接受字符串参数 `word` 的函数，但立即计算用于查找的 `HashSet`。
- en: With these changes, the processing time is reduced by half when performing the
    fuzzy match against the strings *magic* and *light,* compared to the one that
    calculates these values as needed.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，与字符串 *magic* 和 *light* 进行模糊匹配时的处理时间比按需计算这些值时减少了半。
- en: 2.6.1 Precomputation with natural functional support
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.1 使用自然函数支持进行预计算
- en: Now let’s look at the same fuzzy-match implementation using the functional language
    F#. [Listing 2.24](#listing2.24) shows a slightly different implementation due
    to the intrinsic functional semantic of F# (the `AsParallel` method is highlighted
    in bold).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看使用函数式语言 F# 的相同模糊匹配实现。[列表 2.24](#listing2.24) 显示了一个略有不同的实现，这是由于 F# 的内在函数语义（`AsParallel`
    方法以粗体突出显示）。
- en: '[Listing 2.24](#listinganchor2.24) Implementing a fast fuzzy match in F#'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.24](#listinganchor2.24) 在 F# 中实现快速模糊匹配'
- en: '[PRE27]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The implementation of `fuzzyMatch` forces the F# runtime to generate the internal
    set of strings on each call. In opposition, the partial applied function `fastFuzzyMatch`
    initializes the internal set only once and reuses it for all the subsequent calls.
    Precomputation is a caching technique that performs an initial computation to
    create, in this case, a `HashSet<string>` ready to be accessed.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`fuzzyMatch` 的实现迫使 F# 运行时在每次调用时生成内部字符串集合。相反，偏应用函数 `fastFuzzyMatch` 只初始化一次内部集合，并重用于所有后续调用。预计算是一种缓存技术，它执行初始计算以创建，在这种情况下，一个
    `HashSet<string>`，以便可以访问。'
- en: 'The F# implementation uses a query expression to query and transform the data.
    This approach lets you use PLINQ as in the equivalent C# in [Listing 2.23](#listing2.23).
    But in F# there’s a more functional style to parallelize operations on sequences—adopting
    the parallel sequence (`PSeq`). Using this module, the function `fuzzyMatch` can
    be rewritten in a compositional form:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: F# 实现使用查询表达式来查询和转换数据。这种方法允许你使用与 [列表 2.23](#listing2.23) 中等效的 C# 中的 PLINQ。但在
    F# 中，有一个更函数式的风格来并行化序列上的操作——采用并行序列 (`PSeq`)。使用此模块，可以将 `fuzzyMatch` 函数重写为组合形式：
- en: '[PRE28]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The code implementations of `fuzzyMatch` in C# and F# are equivalent, but the
    former functional language is curried as a default. This makes it easier to refactor
    using partial application. The F# parallel sequence `PSeq` used in the previous
    code snippet is covered in chapter 5.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`fuzzyMatch` 在 C# 和 F# 中的代码实现是等效的，但前者作为默认值是柯里化的。这使得使用偏应用进行重构变得更容易。在前面代码片段中使用的
    F# 并行序列 `PSeq` 在第 5 章中介绍。'
- en: 'It’s clearer by looking at the `fuzzyMatch` signature type:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看 `fuzzyMatch` 签名类型，可以更清晰地理解：
- en: '[PRE29]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The signature reads as a function that takes a string set as an argument, returns
    a function that takes a string as an argument, and then returns a string as a
    return type. This chain of functions lets you utilize the partial application
    strategy without thinking about it.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 签名函数读取为一个接受字符串集合作为参数的函数，返回一个接受字符串作为参数的函数，然后返回字符串作为返回类型。这个函数链允许你在不思考的情况下利用偏应用策略。
- en: 2.6.2 Let the best computation win
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.2 让最佳计算获胜
- en: 'Another example of speculative evaluation is inspired by the unambiguous choice
    operator,^([3](#c02-footnote-3))  created by Conal Elliott ([http://conal.net](http://conal.net))
    for his functional reactive programming (FRP) implementation ([http://conal.net/papers/push-pull-frp](http://conal.net/papers/push-pull-frp)).
    The idea behind this operator is simple: it’s a function that takes two arguments
    and concurrently evaluates them, returning the first result available.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个推测性评估的例子是受到由Conal Elliott ([3](#c02-footnote-3)) 创建的不明确的选项操作符^的启发，他为其函数式响应式编程（FRP）实现([http://conal.net](http://conal.net))。这个操作符背后的想法很简单：它是一个接受两个参数并并发评估它们的函数，返回第一个可用的结果。
- en: This concept can be extended to more than two parallel functions. Imagine that
    you’re using multiple weather services to check the temperature in a city. You
    can simultaneously spawn separate tasks to query each service, and after the fastest
    task returns, you don’t need to wait for the other to complete. The function waits
    for the fastest task to come back and cancels the remaining tasks. The following
    listing shows a simple implementation without support for error handling.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念可以扩展到两个以上的并行函数。想象一下，你正在使用多个天气服务来检查一个城市的温度。你可以同时启动单独的任务来查询每个服务，在最快任务返回后，你不需要等待其他任务完成。函数等待最快任务返回并取消剩余的任务。以下列表展示了没有错误处理支持的一个简单实现。
- en: Listing 2.25  Implementing the fastest weather task
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.25  实现最快的天气任务
- en: '[PRE30]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Precomputation is a crucial technique for implementing any kind of function
    and service, from simple to complex and more advanced computation engines. Speculative
    evaluation aims to consume CPU resources that would otherwise sit idle. This is
    a convenient technique in any program, and it can be implemented in any language
    that supports closure to capture and expose these partial values.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 预计算是实现任何类型函数和服务的关键技术，从简单到复杂，再到更高级的计算引擎。推测性评估旨在消耗那些本将闲置的CPU资源。这是一种在任何程序中都方便的技术，并且可以在支持闭包捕获和暴露这些部分值的任何语言中实现。
- en: 2.7 Being lazy is a good thing
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7 懒惰是好事
- en: A common problem in concurrency is having the ability to correctly initialize
    a shared object in a thread-safe manner. To improve the startup time of an application
    when the object has an expensive and time-consuming construct, this need is even
    more accentuated.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 并发中的一个常见问题是能够以线程安全的方式正确初始化一个共享对象。当对象具有昂贵且耗时的结构时，这种需求变得更加突出，以提高应用程序的启动时间。
- en: '*Lazy evaluation* is a programming technique used to defer the evaluation of
    an expression until the last possible moment, when it’s accessed. Believe it or
    not, laziness can lead to success—and in this case, it’s an essential tool for
    your tool belt. Somewhat counterintuitive, the power of lazy evaluation makes
    a program run faster because it only provides what’s required for the query result,
    preventing excessive computations. Imagine writing a program that executes different
    long-running operations, possibly analyzing large amounts of data to produce various
    reports. If these operations are evaluated simultaneously, the system can run
    into performance issues and hang. Plus, it’s possible that not all of these long-running
    operations are immediately necessary, which provokes a waste of resources and
    time if they begin right away.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '*惰性评估*是一种编程技术，用于将表达式的评估推迟到最后一刻，即它被访问时。信不信由你，懒惰可以导致成功——在这种情况下，它是你的工具箱中的必备工具。有些反直觉，惰性评估的力量使程序运行得更快，因为它只提供查询结果所需的，防止过度计算。想象一下编写一个程序，它执行不同的长时间运行的操作，可能分析大量数据以生成各种报告。如果这些操作同时评估，系统可能会遇到性能问题并挂起。此外，可能并非所有这些长时间运行的操作都是立即必要的，如果它们立即开始，可能会造成资源和时间上的浪费。'
- en: A better strategy is to perform long-running operations on demand and only as
    needed, which also reduces memory pressure in the system. In effect, lazy evaluation
    also leads to efficient memory management, improving performance due to lower
    memory consumption. Being lazy in this case is more efficient. Reducing unnecessary
    and expensive garbage collection cleanups in managed programming languages—such
    as C#, Java, and F#—makes the programs run faster.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的策略是在需要时才执行长时间运行的操作，并且仅当需要时，这也有助于减少系统中的内存压力。实际上，延迟评估也导致高效的内存管理，由于内存消耗降低，从而提高性能。在这种情况下，懒惰是更有效率的。在受管理的编程语言（如C#、Java和F#）中减少不必要的和昂贵的垃圾收集清理，可以使程序运行得更快。
- en: 2.7.1 Strict languages for understanding concurrent behaviors
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.7.1 用于理解并发行为的严格语言
- en: The opposite of lazy evaluation is *eager evaluation*, also known as *strict
    evaluation*, which means that the expression is evaluated immediately. C# and
    F#, as well as the majority of other mainstream programming languages, are strict
    languages.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 与延迟评估相反的是*急切评估*，也称为*严格评估*，这意味着表达式会立即被评估。C#和F#以及大多数其他主流编程语言都是严格语言。
- en: Imperative programming languages don’t have an internal model for containing
    and controlling side effects, so it’s reasonable that they’re eagerly evaluated.
    To understand how a program executes, a language that’s strictly evaluated must
    know the order in which side effects (such as I/O) run, making it easy to understand
    how the program executes. In fact, a strict language can analyze the computation
    and have an idea of the work that must be done.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式编程语言没有内部模型来包含和控制副作用，因此它们被急切地评估是合理的。为了理解程序如何执行，严格评估的语言必须知道副作用（如I/O）运行的顺序，这使得理解程序执行变得容易。实际上，严格语言可以分析计算，并对必须完成的工作有一个大致的了解。
- en: Because both C# and F# aren’t purely FP languages, there’s no guarantee that
    every value is referentially transparent; consequently, they cannot be lazily
    evaluated programming languages.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C#和F#都不是纯函数式编程语言，因此不能保证每个值都是引用透明的；因此，它们不能是延迟评估的编程语言。
- en: In general, lazy evaluation can be difficult to mix with imperative features,
    which sometimes introduce side effects, such as exception and I/O operation, because
    the order of operations becomes non-deterministic. For more information, I recommend
    “Why Functional Programming Matters,” by John Hughes ([http://mng.bz/qp3B](http://mng.bz/qp3B)).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，延迟评估难以与命令式特性混合，因为命令式特性有时会引入副作用，例如异常和I/O操作，因为操作顺序变得非确定性。有关更多信息，我推荐阅读John Hughes的《Why
    Functional Programming Matters》（[http://mng.bz/qp3B](http://mng.bz/qp3B)）。
- en: 'In FP, lazy evaluation and side effects cannot coexist. Despite the possibility
    of adding the notion of lazy evaluation in an imperative language, the combination
    with side effects makes the program complex. In fact, lazy evaluation forces the
    developer to remove the order of execution constraints and dependencies according
    to which parts of the program are evaluated. Writing a program with side effects
    can become difficult because it requires the notion of function order of execution,
    which reduces the opportunity for code modularity and compositionality. Functional
    programming aims to be explicit about side effects, to be aware of them, and to
    provide tools to isolate and control them. For instance, Haskell uses the functional
    programming language convention of identifying a function with side effects with
    the `IO` type. This Haskell function definition reads a file, causing side effects:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程（FP）中，延迟评估和副作用不能共存。尽管在命令式语言中添加延迟评估的概念是可能的，但与副作用的结合会使程序变得复杂。实际上，延迟评估迫使开发者根据程序哪些部分被评估来移除执行顺序的约束和依赖。编写带有副作用的程序可能会变得困难，因为它需要函数执行顺序的概念，这减少了代码模块化和组合性的机会。函数式编程旨在明确副作用，了解它们，并提供工具来隔离和控制它们。例如，Haskell使用函数式编程语言的约定，用`IO`类型标识带有副作用的函数。以下是一个Haskell函数定义，它读取文件，导致副作用：
- en: '[PRE31]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This explicit definition notifies the compiler of the presence of side effects,
    and the compiler then applies optimization and validation as needed.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这个明确的定义通知编译器存在副作用，然后编译器根据需要应用优化和验证。
- en: Lazy evaluation becomes an important technique with multicore and multithreading
    programs. To support this technique, Microsoft introduced (with Framework 4.0)
    a generic type constructor called `Lazy<T>`, which simplifies the initialization
    of objects with deferred creation in a thread-safe fashion. Here’s the definition
    of a lazy object `Person`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载在多核和多线程程序中成为一个重要的技术。为了支持这项技术，Microsoft（从 Framework 4.0 开始）引入了一个名为`Lazy<T>`的泛型类型构造函数，它简化了以线程安全的方式延迟创建对象的初始化。以下是懒对象`Person`的定义。
- en: Listing 2.26 Lazy initialization of the `Person` object
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.26 `Person` 对象的懒初始化
- en: '[PRE32]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the example, you define a simple `Person` class with a read-only field, which
    also causes `FullName` to print on the console. Then, you create a lazy initializer
    for this object by supplying a factory delegate into `Lazy<Person>`, which is
    responsible for the object instantiation. In this case, a lambda expression is
    convenient to use in place of the factory delegate. [Figure 2.4](#figure2.4) illustrates
    this.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，你定义了一个简单的`Person`类，它有一个只读字段，这也导致`FullName`在控制台上打印。然后，你通过向`Lazy<Person>`提供工厂委托来为这个对象创建一个懒初始化器，该委托负责对象实例化。在这种情况下，使用lambda表达式代替工厂委托是方便的。[图
    2.4](#figure2.4) 展示了这一点。
- en: '![c02-04.png](Images/c02-04.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![c02-04.png](Images/c02-04.png)'
- en: '[Figure 2.4](#figureanchor2.4) The value of the `Person` object is initialized
    only once, when the `Value` property is accessed the first time. Successive calls
    return the same cached value. If you have an array of `Lazy<Person>` objects,
    when the items of the array are accessed, only the first one is initialized. The
    others will reuse the cache result.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.4](#figureanchor2.4) `Person` 对象的值仅在第一次访问`Value`属性时初始化。后续调用返回相同的缓存值。如果你有一个`Lazy<Person>`对象的数组，当访问数组中的项目时，只有第一个被初始化。其他的将重用缓存结果。'
- en: When the actual evaluation of the expression is required to use the underlying
    object `Person`, you access the `Value` property on the identifier, which forces
    the factory delegate of the `Lazy` object to be performed only one time if the
    value isn’t materialized yet. No matter how many consecutive calls or how many
    threads simultaneously access the lazy initializer, they all wait for the same
    instance. To prove it, the listing creates an array of five `Person`s, which is
    initialized in the `for` loop. During each iteration, the `Person` object is retrieved
    by calling the identifier property `Value`, but even if it’s called five times,
    the output (`Fred Flintstone)` is called only once.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要实际评估表达式以使用底层对象`Person`时，你访问标识符上的`Value`属性，这将迫使`Lazy`对象的工厂委托只执行一次（如果值尚未实现）。无论连续调用多少次或多少线程同时访问懒加载初始化器，它们都等待同一个实例。为了证明这一点，列表创建了一个包含五个`Person`的数组，在`for`循环中进行初始化。在每次迭代中，通过调用标识符属性`Value`来检索`Person`对象，即使它被调用五次，输出（`Fred
    Flintstone`）也只被调用一次。
- en: 2.7.2 Lazy caching technique and thread-safe Singleton pattern
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.7.2 懒加载技术及线程安全的单例模式
- en: Lazy evaluation in .NET is considered a caching technique because it remembers
    the result of the operation that has been performed, and the program can run more
    efficiently by avoiding repetitive and duplicate operations.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，懒加载被认为是一种缓存技术，因为它会记住已执行的操作的结果，程序可以通过避免重复和重复的操作来运行得更高效。
- en: Because the execution operations are done on demand and, more importantly, only
    once, the `Lazy<T>` construct is the recommended mechanism to implement a Singleton
    pattern. The Singleton pattern creates a single instance of a given resource,
    which is shared within the multiple parts of your code. This resource needs to
    be initialized only once, the first time it’s accessed, which is precisely the
    behavior of `Lazy<T>`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 因为执行操作是在需要时进行的，更重要的是，只进行一次，所以`Lazy<T>`结构是推荐用来实现单例模式的机制。单例模式创建给定资源的单个实例，该实例在代码的多个部分中共享。这个资源只需要初始化一次，即第一次访问时，这正是`Lazy<T>`的行为。
- en: You have different ways of implementing the Singleton pattern in .NET, but certain
    of these techniques have limitations, such as unguaranteed thread safety or lost
    lazy instantiation.^([4](#c02-footnote-4))  The `Lazy<T>` construct provides a
    better and simpler singleton design, which ensures true laziness and thread safety,
    as shown next.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，你有不同的方法来实现单例模式，但其中某些技术存在局限性，例如无法保证线程安全或丢失懒加载实例化。[4](#c02-footnote-4)
    `Lazy<T>`结构提供了一个更好、更简单的单例设计，它确保了真正的懒加载和线程安全，如下所示。
- en: Listing 2.27 A Singleton pattern using `Lazy<T>`
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.27 使用 `Lazy<T>` 的单例模式
- en: '[PRE33]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `Lazy<T>` primitive also takes a Boolean flag, passed after the lambda expression,
    as an optional argument to enable thread-safe behavior. This implements a sophisticated
    and light version of the Double-Check Locking pattern.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lazy<T>` 原始类型还接受一个布尔标志，作为 lambda 表达式之后的可选参数，以启用线程安全行为。这实现了一个复杂且轻量级的双重检查锁定模式。'
- en: This property guarantees that the initialization of the object is thread safe.
    When the flag is enabled, which is the default mode, no matter how many threads
    call the Singleton`LazyInitializer`, all the threads receive the same instance,
    which is cached after the first call. This is a great advantage, without which
    you’d be forced to manually guard and ensure the thread safety for the shared
    field.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性保证了对象的初始化是线程安全的。当标志被启用时，这是默认模式，无论多少线程调用 `SingletonLazyInitializer`，所有线程都将收到相同的实例，该实例在第一次调用后进行缓存。这是一个巨大的优势，没有它，你就必须手动保护并确保共享字段的线程安全。
- en: It’s important to emphasize that if the lazy-evaluated object implementation
    is thread-safe, that doesn’t automatically mean that all its properties are thread
    safe as well.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要强调，如果懒计算的对象实现是线程安全的，这并不意味着它的所有属性也都是线程安全的。
- en: 2.7.3 Lazy support in F#
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.7.3 F# 中的懒支持
- en: 'F# supports the same `Lazy<T>` type with the addition of lazy computation,
    which is of type `Lazy<T>`, where the actual generic type that is used for `T`
    is determined from the result of the expression. The F# standard library automatically
    enforces mutual exclusion, so that pure function code is thread safe when simultaneously
    forcing the same lazy value from separate threads. The F# use of the `Lazy` type
    is a little different from C#, where you wrap the function around a `Lazy` data
    type. This code example shows the F# `Lazy` computation of a `Person` object:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: F# 支持与 `Lazy<T>` 类型相同的类型，并增加了懒计算功能，该功能类型为 `Lazy<T>`，其中用于 `T` 的实际泛型类型由表达式的结果确定。F#
    标准库自动强制互斥，因此当从不同的线程同时强制相同的懒值时，纯函数代码是线程安全的。F# 对 `Lazy` 类型的使用与 C# 略有不同，在 C# 中，你将函数包装在
    `Lazy` 数据类型周围。此代码示例展示了 F# 中 `Lazy` 计算一个 `Person` 对象：
- en: '[PRE34]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The function `barneyRubble` creates an instance of `Lazy<Person>`, for which
    the value isn’t yet materialized. Then, to force the computation, you call the
    method `Force` that retrieves the value on demand**.**
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `barneyRubble` 创建了一个 `Lazy<Person>` 实例，其值尚未实现。然后，为了强制计算，你调用 `Force` 方法来按需检索值**。**
- en: 2.7.4 Lazy and Task, a powerful combination
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.7.4 懒和 Task，强大的组合
- en: 'For performance and scalability reasons, in a concurrent application it’s useful
    to combine a lazy evaluation that can be executed on demand using an independent
    thread. The `Lazy` initializer `Lazy<T>` can be utilized to implement a useful
    pattern to instantiate objects that require asynchronous operations. Let’s consider
    the class `Person` that was used in the previous section. If the first and second
    name fields are loaded from a database, you can apply a type `Lazy<Task<Person>>`
    to defer the I/O computation. It’s interesting that between `Task<T>` and `Lazy<T>`
    there’s a commonality: both evaluate a given expression exactly once.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 由于性能和可扩展性的原因，在并发应用程序中，结合一个可以独立线程按需执行的懒计算非常有用。`Lazy<T>` 初始化器可以用来实现一个有用的模式，用于实例化需要异步操作的对象。让我们考虑在前一节中使用过的
    `Person` 类。如果第一个和第二个名字字段是从数据库加载的，你可以应用类型 `Lazy<Task<Person>>` 来延迟 I/O 计算。有趣的是，在
    `Task<T>` 和 `Lazy<T>` 之间存在共性：两者都恰好评估一次给定的表达式。
- en: Listing 2.29 Lazy asynchronous operation to initialize the `Person` object
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.29 初始化 `Person` 对象的懒异步操作
- en: '[PRE35]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, the delegate returns a `Task<Person>`, which asynchronously
    determines the value once and returns the value to all callers. These are the
    kind of designs that ultimately improve the scalability of your program. In the
    example, this feature implements asynchronous operations using the `async-await`
    keywords (introduced in C# 5.0`)`. Chapter 8 covers in detail the topics of asynchronicity
    and scalability.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，委托返回一个 `Task<Person>`，它异步确定值一次，并将值返回给所有调用者。这些是最终提高程序可扩展性的设计。在示例中，此功能使用
    `async-await` 关键字（在 C# 5.0 中引入）实现异步操作。第 8 章详细介绍了异步性和可扩展性的主题。
- en: This is a useful design that can improve scalability and parallelism in your
    program. But there’s a subtle risk. Because the lambda expression is asynchronous,
    it can be executed on any thread that calls `Value`, and the expression will run
    within the context. A better solution is to wrap the expression in an underlying
    `Task`, which will force the asynchronous execution on a thread-pool thread. This
    listing shows the preferred pattern.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的设计，可以提高程序的可扩展性和并行性。但存在一个微妙的风险。因为lambda表达式是异步的，它可以在调用`Value`的任何线程上执行，表达式将在上下文中运行。更好的解决方案是将表达式包装在底层的`Task`中，这将强制在线程池线程上执行异步执行。此列表显示了首选模式。
- en: Listing 2.30 Better pattern
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.30 更好的模式
- en: '[PRE36]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Summary
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Function composition applies the result of one function to the input of another,
    creating a new function. You can use it in FP to solve complex problems by decomposing
    them into smaller and simpler problems that are easier to solve and then ultimately
    piece together these sets of solutions.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组合将一个函数的结果应用于另一个函数的输入，创建一个新的函数。在FP中，你可以通过将复杂问题分解为更小、更简单的问题来解决复杂问题，这些问题更容易解决，然后最终将这些解决方案组合在一起。
- en: Closure is an in-line delegate/anonymous method attached to its parent method,
    where the variables defined in the parent’s method body can be referenced from
    within the anonymous method. Closure provides a convenient way to give a function
    access to local state (which is enclosed in the function), even if it’s out of
    scope. It’s the foundation to designing functional programming code segments that
    include memoization, lazy initialization, and precomputation to increase computation
    speed.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包是其父方法中内联的委托/匿名方法，其中可以在匿名方法内部引用父方法体中定义的变量。闭包提供了一种方便的方式，即使超出作用域，也能让函数访问局部状态（该状态被封装在函数中）。它是设计包含记忆化、延迟初始化和预计算以提高计算速度的函数式编程代码段的基础。
- en: Memoization is a functional programming technique that maintains the results
    of intermediate computations instead of recomputing them. It’s considered a form
    of caching.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆化是一种函数式编程技术，它维护中间计算的结果，而不是重新计算它们。它被认为是一种缓存形式。
- en: Precomputation is a technique to perform an initial computation that generates
    a series of results, usually in the form of a lookup table. These precomputed
    values can be used directly from an algorithm to avoid needless, repetitive, and
    expensive computations each time your code is executed. Generally, precomputation
    replaces memoization and is used in combination with partial applied functions.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预计算是一种执行初始计算的技术，该计算生成一系列结果，通常以查找表的形式。这些预计算值可以直接从算法中使用，以避免每次代码执行时进行不必要的、重复的且昂贵的计算。通常，预计算取代了记忆化，并与部分应用函数结合使用。
- en: Lazy initialization is another variation of caching. Specifically, this technique
    defers the computation of a factory function for the instantiation of an object
    until needed, creating the object only once. The main purpose of lazy initialization
    is to improve performance by reducing memory consumption and avoiding unnecessary
    computation.****  ***# 3
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒初始化是缓存的另一种变体。具体来说，这种技术将工厂函数的计算延迟到对象实例化所需时，仅创建一次对象。懒初始化的主要目的是通过减少内存消耗和避免不必要的计算来提高性能。
- en: Functional data structures and immutability
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式数据结构和不可变性
- en: '**This chapter covers**'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Building parallel applications with functional data structures
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数式数据结构构建并行应用程序
- en: Using immutability for high-performant, lock-free code
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不可变性实现高性能、无锁的代码
- en: Implementing parallel patterns with functional recursion
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数式递归实现并行模式
- en: Implementing immutable objects in C# and F#
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C#和F#中实现不可变对象
- en: Working with tree data structures
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与树数据结构一起工作
- en: 'Data comes in a multitude of forms. Consequently, it’s not surprising that
    many computer programs are organized around two primary constraints: data and
    data manipulation. Functional programming fits well into this world because, to
    a large extent, this programming paradigm is about data transformation. Functional
    transformations allow you to alter a set of structured data from its original
    form into another form without having to worry about side effects or state. For
    example, you can transform a collection of countries into a collection of cities
    using a map function and keep the initial data unchanged. Side effects are a key
    challenge for concurrent programming because the effects raised in one thread
    can influence the behavior of another thread.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 数据以多种形式存在。因此，许多计算机程序围绕两个主要约束组织起来并不令人惊讶：数据和数据处理。函数式编程很好地融入了这个世界，因为从很大程度上说，这种编程范式是关于数据转换的。函数式转换允许你将一组结构化数据从其原始形式转换为另一种形式，而无需担心副作用或状态。例如，你可以使用映射函数将一组国家转换为城市集合，同时保持初始数据不变。副作用是并发编程的一个关键挑战，因为一个线程中产生的效果可能会影响另一个线程的行为。
- en: Over the past few years, mainstream programming languages have added new features
    to make multithreaded applications easier to develop. Microsoft, for example,
    has added the TPL and the `async/await` keywords to the .NET framework to reduce
    programmers’ apprehension when implementing concurrent code. But there are still
    challenges with keeping a mutable state protected from corruption when multiple
    threads are involved. The good news is that FP lets you write code that transforms
    immutable data without side effects.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，主流编程语言添加了新功能，使多线程应用程序的开发变得更加容易。例如，微软已经将TPL和`async/await`关键字添加到.NET框架中，以减少程序员在实现并发代码时的担忧。但是，当涉及多个线程时，仍然存在保护可变状态免受损坏的挑战。好消息是，FP让你能够编写无副作用的代码来转换不可变数据。
- en: In this chapter, you’ll learn to write concurrent code using a functional data
    structure and using immutable states, adopting the right data structure in a concurrent
    environment to improve performance effortlessly. *Functional data structures*
    boost performance by sharing data structures between threads and running in parallel
    without synchronization.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用函数式数据结构和不可变状态编写并发代码，在并发环境中采用合适的数据结构来轻松提高性能。*函数式数据结构*通过在线程之间共享数据结构并在无需同步的情况下并行运行来提高性能。
- en: As a first step in this chapter, you’ll develop a functional list in both C#
    and F#. These are great exercises for understanding how immutable functional data
    structures work. Next, we’ll cover immutable tree data structures, and you’ll
    learn how to use recursion in FP to build a binary tree structure in parallel.
    Parallel recursion is used in an example to simultaneously download multiple images
    from the web.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章的第一步，你将使用C#和F#开发一个函数式列表。这些练习对于理解不可变函数式数据结构的工作方式非常有用。接下来，我们将介绍不可变树数据结构，你将学习如何在FP中使用递归并行构建二叉树结构。在示例中，并行递归用于同时从网络上下载多个图像。
- en: By the end of the chapter, you’ll exploit immutability and functional data structures
    to run a program faster in parallel, avoiding the pitfalls, such as race conditions,
    of shared mutable of state. In other words, if you want concurrency and a strong
    guarantee of correctness, you must give up mutation.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将利用不可变性和函数式数据结构来并行运行程序，从而更快地运行，避免共享可变状态的陷阱，如竞态条件。换句话说，如果你想实现并发和强正确性保证，你必须放弃修改。
- en: '3.1 Real-world example: hunting the thread-unsafe object'
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 现实世界示例：寻找线程不安全对象
- en: Building software in a controlled environment usually doesn’t lead to unwelcome
    surprises. Unfortunately, if a program that you write on your local machine is
    deployed to a server that isn’t under your control, this might introduce different
    variables. In the production environment, programs can run into unanticipated
    problems and unpredictable heavy loads. I’m sure that more than once in your career,
    you’ve heard, “It works on my machine.”
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在受控环境中构建软件通常不会导致不愉快的惊喜。不幸的是，如果你在本地机器上编写的程序被部署到不受你控制的服务器上，这可能会引入不同的变量。在生产环境中，程序可能会遇到未预料到的问题和不可预测的重负载。我相信在你的职业生涯中，你不止一次听说过，“在我的机器上它运行正常。”
- en: When software goes live, multiple factors can go wrong, causing the programs
    to behave unreliably. A while ago, my boss called me to analyze a production issue.
    The application was a simple chat system used for customer support. The program
    was using web sockets to communicate from the frontend directly with the Windows
    server hub written in C#. The underlying technology to establish the bidirectional
    communication between client and server was Microsoft SignalR ([http://mng.bz/Fal1](http://mng.bz/Fal1)).
    See [figure 3.1](#figure3.1).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件上线时，多个因素可能会出错，导致程序行为不可靠。不久前，我的老板打电话让我分析一个生产问题。该应用程序是一个简单的聊天系统，用于客户支持。程序使用Web套接字从前端直接与用C#编写的Windows服务器中心点通信。建立客户端和服务器之间双向通信的底层技术是Microsoft
    SignalR ([http://mng.bz/Fal1](http://mng.bz/Fal1))。参见[图3.1](#figure3.1)。
- en: Before being deployed in production, the program had passed all the tests. Once
    deployed, however, the server’s resources were stressed. The CPU usage was continually
    between 85% to 95% of capacity, negatively affecting overall performance by preventing
    the system from being responsive to incoming requests. The result was unacceptable,
    and the problem needed a quick resolution.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署到生产环境之前，程序已经通过了所有测试。然而，一旦部署，服务器的资源就承受了压力。CPU使用率持续在85%到95%的容量之间，由于阻止系统对传入请求做出响应，从而对整体性能产生了负面影响。结果是不可接受的，问题需要迅速解决。
- en: '![c03-01.png](Images/c03-01.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![c03-01.png](Images/c03-01.png)'
- en: '[Figure 3.1](#figureanchor3.1) Architecture of a web server chat application
    using a SignalR hub. The clients connected are registered in a local static dictionary
    (lookup table) whose instance is shared.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.1](#figureanchor3.1) 使用SignalR中心点的Web服务器聊天应用程序的架构。连接的客户端注册在本地静态字典（查找表）中，其实例是共享的。'
- en: As Sherlock Holmes said, “When you have eliminated the impossible, whatever
    remains, however improbable, must be the truth.” I put on my super-sleuth hat
    and then, using a valued lens, I began to look at the code. After debugging and
    investigation, I detected the portion of code that caused the bottleneck.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 正如夏洛克·福尔摩斯所说，“当你排除了所有不可能的情况，无论多么不可能，剩下的，必然是真相。”我戴上我的超级侦探帽，然后，使用一个宝贵的视角，我开始审视代码。经过调试和调查，我发现了导致瓶颈的代码部分。
- en: I used a profiling tool to analyze the application’s performance. Sampling and
    profiling the application is a good place to start looking for bottlenecks in
    the application. The profiling tool samples the program when it runs, examining
    the execution times to inspect as conventional data. The data collected is a statistical
    profiling representation of the individual methods that are doing the most work
    in the application. The final report shows these methods, which can be inspected
    by looking for the hot path ([http://mng.bz/agzj](http://mng.bz/agzj)) where most
    of the work in the application is executed.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了一个性能分析工具来分析应用程序的性能。对应用程序进行采样和性能分析是寻找应用程序瓶颈的好起点。性能分析工具在程序运行时进行采样，检查执行时间以检查常规数据。收集到的数据是应用程序中执行最多工作的单个方法的统计性能分析表示。最终报告显示了这些方法，可以通过查找热点路径（[http://mng.bz/agzj](http://mng.bz/agzj)）来检查，大多数应用程序的工作都在这里执行。
- en: The high CPU-core utilization problem originated in the `OnConnected` and `OnDisconnected`
    methods due to the contention of a shared state. In this case, the shared state
    was a generic `Dictionary` type, used to keep the connected users in memory. A
    *Thread contention* is a condition where one thread is waiting for an object,
    being held by another thread, to be released. The waiting thread cannot continue
    until the other thread releases the object (it’s locked). This listing shows the
    problematic server code.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 高CPU核心利用率问题源于`OnConnected`和`OnDisconnected`方法中共享状态的竞争。在这种情况下，共享状态是一个通用的`Dictionary`类型，用于在内存中保持连接的用户。*线程竞争*是一种条件，其中一个线程正在等待另一个线程持有的对象被释放。等待的线程无法继续执行，直到另一个线程释放对象（它被锁定）。下面的列表显示了有问题的服务器代码。
- en: Listing 3.1 SignalR hub in C# that registers connections in context
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 C#中的SignalR中心点，用于在上下文中注册连接
- en: '[PRE37]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The operations `OnConnected` and `OnDisconnected` rely on a shared global dictionary,
    communally used in these types of programs to maintain a local state. Notice that
    each time one of these methods is executed, the underlying collection is called
    twice. The program logic checks whether the `User Connection Id` exists and applies
    some behavior accordingly:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 操作 `OnConnected` 和 `OnDisconnected` 依赖于一个共享的全局字典，在这些类型的程序中共同使用以维护本地状态。请注意，每次执行这些方法之一时，底层集合会被调用两次。程序逻辑检查
    `用户连接 ID` 是否存在，并据此应用一些行为：
- en: '[PRE38]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Can you see the issue? For each new client request, a new connection is established,
    and a new instance of the hub is created. The local state is maintained by a static
    variable, which keeps track of the current user connection and is shared by all
    instances of the hub. According to the Microsoft documentation, “A static constructor
    is only called one time, and a static class remains in memory for the lifetime
    of the application domain in which your program resides.”^([1](#c03-footnote-1))
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看出问题吗？对于每个新的客户端请求，都会建立一个新连接，并创建一个新的 hub 实例。本地状态由一个静态变量维护，它跟踪当前用户连接，并由 hub
    的所有实例共享。根据微软的文档，“静态构造函数只被调用一次，静态类在程序所在的程序域的生命周期内保持内存中。”^([1](#c03-footnote-1))
- en: 'Here’s the collection used for user-connection tracking:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于用户连接跟踪的集合：
- en: '[PRE39]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`Guid` is the unique connection identifier created by SignalR when the connection
    between client and server is established. The string represents the name of the
    user defined during login. In this case, the program clearly runs in a multithreaded
    environment. Every incoming request is a new thread; consequently, there will
    be several requests simultaneously accessing the shared state, which eventually
    leads to multithreading problems.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`Guid` 是 SignalR 在客户端和服务器之间建立连接时创建的唯一连接标识符。该字符串表示在登录期间定义的用户名称。在这种情况下，程序显然是在一个多线程环境中运行的。每个传入请求都是一个新线程；因此，将会有多个请求同时访问共享状态，这最终会导致多线程问题。'
- en: The MSDN documentation is clear in this regard. It says that a `Dictionary`
    collection can support multiple readers concurrently, as long as the collection
    isn’t modified.^([2](#c03-footnote-2))  Enumerating through the collection is
    intrinsically not thread safe because a thread could update the dictionary while
    another thread is changing the state of the collection.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: MSDN 文档在这方面很明确。它说，只要集合没有被修改，`Dictionary` 集合可以支持并发多个读取者。^([2](#c03-footnote-2))
    遍历集合本身不是线程安全的，因为一个线程可能在另一个线程更改集合状态的同时更新字典。
- en: Several possible solutions exist to avoid this limitation. The first approach
    is to make the collection thread safe and accessible by multiple threads for both
    `read` and `write` operations using `lock primitive`. This solution is correct
    but downgrades performance.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几种可能的解决方案来避免这种限制。第一种方法是使集合线程安全，并允许多个线程通过 `lock` 原语进行 `read` 和 `write` 操作。这个解决方案是正确的，但会降低性能。
- en: The preferred alternative is to achieve the same level of thread safety without
    synchronization; for example, using immutable collections.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的替代方案是在不进行同步的情况下达到相同的线程安全级别；例如，使用不可变集合。
- en: '3.1.1 .NET immutable collections: a safe solution'
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 .NET 不可变集合：一个安全解决方案
- en: Microsoft introduced immutable collections, found in the namespace `System.Collections.Immutable`,
    with .NET Framework 4.5\. This is part of the evolution of threading tools after
    TPL in .NET 4.0 and the `async` and `await` keywords after .NET 4.5\.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 微软在 .NET Framework 4.5 中引入了不可变集合，位于 `System.Collections.Immutable` 命名空间中。这是在
    .NET 4.0 中的 TPL 之后和 .NET 4.5 之后的 `async` 和 `await` 关键字之后的线程工具演变的一部分。
- en: 'The immutable collections follow the functional paradigm concepts covered in
    this chapter, and provide implicit thread safety in multithreaded applications
    to overcome the challenge to maintain and control mutable state. Similar to concurrent
    collections, they’re also thread safe, but the underlying implementation is different.
    Any operations that change the data structures don’t modify the original instance.
    Instead, they return a changed copy and leave the original instance unchanged.
    The immutable collections have been heavily tuned for maximum performance and
    use the *Structural Sharing*^([ 3](#c03-footnote-3))  pattern to minimize garbage
    collector (GC) demands. As an example, this code snippet creates an immutable
    collection from a generic mutable one (the immutable command is in bold). Then,
    by updating the collections with a new item, a new collection is created, leaving
    the original unaffected:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变集合遵循本章中介绍的函数式范式概念，并在多线程应用程序中提供隐式线程安全，以克服维护和控制可变状态带来的挑战。类似于并发集合，它们也是线程安全的，但底层实现不同。任何更改数据结构的操作都不会修改原始实例。相反，它们返回一个更改后的副本，并保持原始实例不变。不可变集合已经针对最大性能进行了大量优化，并使用*结构共享*^([3](#c03-footnote-3))模式来最小化垃圾收集器（GC）的需求。例如，以下代码片段从一个泛型可变集合创建一个不可变集合（不可变命令以粗体显示）。然后，通过更新集合以添加新项目，创建一个新的集合，而原始集合不受影响：
- en: '[PRE40]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Any changes to the collection in one thread aren’t visible to the other threads,
    because they still reference the original unmodified collection, which is the
    reason why immutable collections are inherently thread safe.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个线程中对集合的任何更改对其他线程都是不可见的，因为它们仍然引用原始未修改的集合，这也是不可变集合天生线程安全的原因。
- en: '[Table 3.1](#table3.1) shows an implementation of an immutable collection for
    each of the related mutable generic collections.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '[表3.1](#table3.1) 展示了为每个相关的可变泛型集合实现的一个不可变集合的实现。'
- en: '[Table 3.1](#tableanchor3.1) Immutable collections for .NET Framework 4.5'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[表3.1](#tableanchor3.1) .NET Framework 4.5的不可变集合'
- en: '| **Immutable collection** | **Mutable collection** |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| **不可变集合** | **可变集合** |'
- en: '| --- | --- |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ImmutableList<T>` | `List<T>` |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| `ImmutableList<T>` | `List<T>` |'
- en: '| `ImmutableDictionary<TKey, TValue>` | `Dictionary<TKey, TValue>` |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| `ImmutableDictionary<TKey, TValue>` | `Dictionary<TKey, TValue>` |'
- en: '| `ImmutableHashSet<T>` | `HashSet<T>` |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| `ImmutableHashSet<T>` | `HashSet<T>` |'
- en: '| `ImmutableStack<T>` | `Stack<T>` |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| `ImmutableStack<T>` | `Stack<T>` |'
- en: '| `ImmutableQueue<T>` | `Queue<T>` |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| `ImmutableQueue<T>` | `Queue<T>` |'
- en: Here are two ways to create an immutable list.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两种创建不可变列表的方法。
- en: Listing 3.2 Constructing .NET immutable collections
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 构建.NET不可变集合
- en: '[PRE41]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The second approach simplifies the construction of the list by creating a temporary
    list builder, which is used to add an element to the list and then seals (freezes)
    the elements into an immutable structure.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法通过创建一个临时列表构建器来简化列表的构建，该构建器用于向列表添加元素，然后将元素密封（冻结）到不可变结构中。
- en: 'In reference to the data corruption (race condition) problem in the original
    chat program, immutable collections can be used in a Windows server hub to maintain
    the state of the open SignalR connections. This is safely accomplished with multithread
    access. Luckily, the `System.Collections.Immutable` namespace contains the equivalent
    version of `Dictionary` for lookups: `ImmutableDictionary.`'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 关于原始聊天程序中的数据损坏（竞态条件）问题，不可变集合可以在Windows服务器中心用于维护打开的SignalR连接的状态。这可以通过多线程访问安全地完成。幸运的是，`System.Collections.Immutable`命名空间包含用于查找的`Dictionary`的等效版本：`ImmutableDictionary.`。
- en: You may ask, “But if the collection is immutable, how it can be updated while
    preserving thread safety?” You can use lock statements around operations that
    involve reading or writing the collection. Building a thread-safe collection using
    locks is straightforward; but it is a more expensive approach than required. A
    better option is to protect the writes with a single compare-and-swap (CAS) operation,
    which removes the need for locks and leaves the read operation unguarded. This
    lock-free technique is more scalable and performs better than the counterpart
    (one that uses a synchronization primitive).
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，“但如果集合是不可变的，它是如何更新的同时保持线程安全的？”你可以在涉及读取或写入集合的操作周围使用锁语句。使用锁构建线程安全的集合很简单；但这是一种比所需更昂贵的方法。更好的选择是使用单个比较和交换（CAS）操作来保护写入，这消除了对锁的需求，并使读取操作不受保护。这种无锁技术比对应技术（使用同步原语）更可扩展，性能更好。
- en: CAS operations
  id: totrans-485
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CAS操作
- en: CAS is a special instruction used in multithreaded programming as a form of
    synchronization that atomically performs an operation on memory locations. An
    atomic operation either succeeds or fails as a unit.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: CAS 是一种在多线程编程中使用的特殊指令，作为同步的一种形式，它以原子方式对内存位置执行操作。原子操作要么作为一个单元成功，要么失败。
- en: '*Atomicity* refers to operations that alter a state in a single step in such
    a way that the outcome is autonomous, observed as either done or not done, with
    no in-between state. Other parallel threads can only see the old or the new state.
    When an atomic operation is performed on a shared variable, threads cannot observe
    its modification until it completes. In fact, an atomic operation reads a value
    as it appears at a single moment in time. Primitive atomic operations are machine
    instructions and can be exposed by .NET in the `System.Threading.Interlocked`
    class, such as the `Interlocked.CompareExchange` and the `Interlocked.Increment`
    methods.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '*原子性* 指的是在单步中改变状态的操作，使得结果自主，观察结果要么是完成要么是没有完成，没有中间状态。其他并行线程只能看到旧状态或新状态。当一个原子操作在一个共享变量上执行时，线程无法观察到其修改直到它完成。实际上，原子操作读取的是在某一时刻出现的值。原始的原子操作是机器指令，可以通过
    .NET 中的 `System.Threading.Interlocked` 类暴露，例如 `Interlocked.CompareExchange` 和
    `Interlocked.Increment` 方法。'
- en: The CAS instruction modifies shared data without the need to acquire and release
    a lock and allows extreme levels of parallelism. This is where immutable data
    structures really shine because they minimize the chances of incurring ABA problems
    ([https://en.wikipedia.org/wiki/ABA_problem](https://en.wikipedia.org/wiki/ABA_problem)).
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: CAS 指令在不需要获取和释放锁的情况下修改共享数据，并允许极高的并行级别。这正是不可变数据结构真正发光的地方，因为它们最小化了发生 ABA 问题的可能性（[https://en.wikipedia.org/wiki/ABA_problem](https://en.wikipedia.org/wiki/ABA_problem)）。
- en: The idea is to keep the state that has to change contained into a single and,
    most importantly, isolated immutable object (in this case, the `ImmutableDictionary`)`.`
    Because the object is isolated, there’s no sharing of state; therefore, there’s
    nothing to synchronize.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是将必须改变的状态包含在一个单一且最重要的是隔离的不可变对象（在这种情况下，是 `ImmutableDictionary`）中。因为对象是隔离的，所以没有状态共享；因此，没有需要同步的内容。
- en: The following listing shows the implementation of a helper object called `Atom`.
    The name is inspired by the Clojure atom ([https://clojure.org/reference/atoms](https://clojure.org/reference/atoms)),
    which internally uses the `Interlocked.CompareExchange` operator to perform atomic
    CAS operations.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了名为 `Atom` 的辅助对象的实现。这个名字受到了 Clojure 原子（[https://clojure.org/reference/atoms](https://clojure.org/reference/atoms)）的启发，它内部使用
    `Interlocked.CompareExchange` 操作符来执行原子 CAS 操作。
- en: Listing 3.3 `Atom` object to perform CAS instructions
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 执行 CAS 指令的 `Atom` 对象
- en: '[PRE42]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `Atom` class encapsulates a reference object of type `T` marked `volatile`,^([4](#c03-footnote-4)) 
    which must be immutable to achieve the correct behavior of value swapping. The
    property `Value` is used to read the current state of a wrapped object. The purpose
    of the `Swap` function is to execute the CAS instruction to pass to the caller
    of this function a new value based on the previous value using the `factory` delegate.
    The CAS operation takes an old and a new value, and it atomically sets the `Atom`
    to the new value only if the current value equals the passed-in old value. If
    the `Swap` function can’t set the new value using `Interlocked.CompareExchange`,
    it continues to retry until it’s successful.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`Atom` 类封装了一个标记为 `volatile` 的类型 `T` 的引用对象，为了实现正确的值交换行为，该对象必须是不可变的。`Value` 属性用于读取包装对象的当前状态。`Swap`
    函数的目的是执行 CAS 指令，通过 `factory` 委托将基于前一个值的新值传递给此函数的调用者。CAS 操作接受一个旧值和一个新值，并且只有当当前值等于传入的旧值时，才原子地将
    `Atom` 设置为新值。如果 `Swap` 函数无法使用 `Interlocked.CompareExchange` 设置新值，它将继续重试，直到成功。'
- en: '[Listing 3.4](#listing3.4) shows how to use the `Atom` class with the `ImmutableDictionary`
    object in the context of a SignalR server hub. The code implements only the `OnConnected`
    method. The same concept applies to the `OnDisconnected` function`.`'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3.4](#listing3.4) 展示了如何在 SignalR 服务器端点的上下文中使用 `Atom` 类和 `ImmutableDictionary`
    对象。代码仅实现了 `OnConnected` 方法。同样的概念也适用于 `OnDisconnected` 函数。'
- en: '[Listing 3.4](#listinganchor3.4) Thread-safe `ImmutableDictionary` using an
    `Atom` object'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3.4](#listinganchor3.4) 使用 `Atom` 对象的线程安全 `ImmutableDictionary`'
- en: '[PRE43]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `Atom Swap` method wraps the call to update the underlying `Immutable­Dictionary`.
    The `Atom Value` property can be accessed at any time to check the current open
    SignalR connections. This operation is thread safe because it’s read-only. The
    `Atom` class is generic, and it can be used to update atomically any type. But
    immutable collections have a specialized helper class (described next).
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '`Atom Swap`方法封装了对底层`Immutable­Dictionary`的更新调用。`Atom Value`属性可以在任何时候访问，以检查当前打开的SignalR连接。此操作是线程安全的，因为它只读。`Atom`类是泛型的，它可以用来原子地更新任何类型。但是不可变集合有一个专门的辅助类（将在下文中描述）。'
- en: The ImmutableInterlocked class
  id: totrans-498
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`ImmutableInterlocked`类'
- en: Because you need to update the immutable collections in a thread-safe manner,
    Microsoft introduced the `ImmutableInterlocked` class, which can be found in the
    `System.Collections.Immutable` namespace. This class provides a set of functions
    that handles updating immutable collections using the CAS mechanism previously
    mentioned. It exposes the same functionality of the `Atom` object. In this listing,
    `Immutable­Dictionary` replaces `Dictionary`.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您需要以线程安全的方式更新不可变集合，Microsoft引入了`ImmutableInterlocked`类，该类可在`System.Collections.Immutable`命名空间中找到。此类提供了一组函数，用于处理使用之前提到的CAS机制更新不可变集合。它公开了与`Atom`对象相同的功能。在此列表中，`Immutable­Dictionary`替换了`Dictionary`。
- en: '[Listing 3.5](#listinganchor3.5) Hub maintaining open connections using `ImmutableDictionary`'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表3.5](#listinganchor3.5) 使用`ImmutableDictionary`维护打开连接的中心'
- en: '[PRE44]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Updating an `ImmutableDictionary` is performed atomically, which means in this
    case that a user connection is added only if it doesn’t exist. With this change,
    the SignalR hub works correctly and is lock free, and the server didn’t spike
    high percentages of CPU utilization. But there’s a cost to using immutable collections
    for frequent updates. For example, the time required to add 1 million users to
    the `ImmutableDictionary` using `ImmutableInterlocked` is 2.518 seconds. This
    value is probably acceptable in most cases, but if you’re aiming to produce a
    highly performant system, it’s important to do the research and employ the right
    tool for the job.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`ImmutableDictionary`是原子性的，这意味着在这种情况下，只有当用户连接不存在时才会添加。随着这一变化，SignalR中心工作正常且无锁，服务器CPU利用率没有大幅上升。但是，使用不可变集合进行频繁更新的代价是存在的。例如，使用`ImmutableInterlocked`将100万用户添加到`ImmutableDictionary`所需的时间是2.518秒。这个值在大多数情况下可能是可接受的，但如果您旨在构建一个高性能的系统，那么进行研究和采用正确的工具进行工作是非常重要的。
- en: In general, the use of immutable collections fits perfectly for shared state
    among different threads, when the number of updates is low. Their value (state)
    is guaranteed to be thread safe; it can be safely passed among additional threads.
    If you need a collection that has to handle many updates concurrently, a better
    solution is to exploit a .NET concurrent collection.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，不可变集合的使用非常适合不同线程之间的共享状态，当更新次数较低时。它们的值（状态）保证是线程安全的；它可以在额外的线程之间安全地传递。如果您需要一个必须同时处理许多更新的集合，则更好的解决方案是利用.NET并发集合。
- en: '3.1.2 .NET concurrent collections: a faster solution'
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 .NET并发集合：一个更快的解决方案
- en: In the .NET framework, the `System.Collections.Concurrent` namespace provides
    a set of thread-safe collections designed to simplify thread-safe access to shared
    data. Concurrent collections are mutable collection instances that aim to increase
    the performance and scalability of multithreaded applications. Because they can
    be safely accessed and updated by multiple threads at the same time, they’re recommended
    for multithreaded programs instead of the analogous collections in `System.Collections.Generic`.
    [Table 3.2](#table3.2) shows the concurrent collections available in .NET.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET框架中，`System.Collections.Concurrent`命名空间提供了一组线程安全的集合，旨在简化对共享数据的线程安全访问。并发集合是可变的集合实例，旨在提高多线程应用程序的性能和可伸缩性。由于它们可以同时被多个线程安全地访问和更新，因此建议在多线程程序中使用它们，而不是`System.Collections.Generic`中类似集合。[表3.2](#table3.2)显示了.NET中可用的并发集合。
- en: '[Table 3.2](#tableanchor3.2) Concurrent collection details'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '[表3.2](#tableanchor3.2) 并发集合详细信息'
- en: '| **Concurrent collection** | **Implementation details** | **Synchronization
    techniques** |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '| **并发集合** | **实现细节** | **同步技术** |'
- en: '| --- | --- | --- |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `ConcurrentBag<T>` | Works like a generic list | If multiple threads are
    detected, a primitive monitor coordinates their access; otherwise, the synchronization
    is avoided. |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| `ConcurrentBag<T>` | 类似于泛型列表 | 如果检测到多个线程，则使用原始监视器协调它们的访问；否则，避免同步。 |'
- en: '| `ConcurrentStack<T>` | Generic stack implemented using a singly linked list
    | Lock free using a CAS technique. |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| `ConcurrentStack<T>` | 使用单链表实现的泛型栈 | 使用CAS技术实现无锁。|'
- en: '| `ConcurrentQueue<T>` | Generic queue implemented using a linked list of array
    segments | Lock free using CAS technique. |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| `ConcurrentQueue<T>` | 使用数组段链表实现的泛型队列 | 使用CAS技术实现无锁。|'
- en: '| `ConcurrentDictionary<K, V>` | Generic dictionary implemented using a hash
    table | Lock free for read operations; lock synchronization for updates. |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| `ConcurrentDictionary<K, V>` | 使用哈希表实现的泛型字典 | 读取操作无锁；更新操作使用锁同步。|'
- en: Back to the SignalR hub example of “Hunt the thread-unsafe object,” `ConcurrentDictionary`
    is a better option than the not-thread-safe `Dictionary`, and due to the frequent
    and wide number of updates, it’s also a better option than `ImmutableDictionary`.
    In fact, `System.Collections.Concurrent` has been designed for high performance
    using a mix of fine-grained^([5](#c03-footnote-5))  and lock-free patterns. These
    techniques ensure that threads accessing the concurrent collection are blocked
    for a minimum amount of time or, in certain cases, completely avoid the blocking.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 回到“寻找线程不安全对象”的SignalR hub示例，`ConcurrentDictionary`比不安全的`Dictionary`更好，而且由于频繁和大量的更新，它也比`ImmutableDictionary`更好。实际上，`System.Collections.Concurrent`已经设计为使用细粒度^([5](#c03-footnote-5))和锁-free模式来提高性能。这些技术确保访问并发集合的线程被阻塞的时间最短，或者在某些情况下，完全避免阻塞。
- en: '`ConcurrentDictionary` can ensure scalability while handling several requests
    per second. It’s possible to assign and retrieve values using square-bracket indexing
    like the conventional generic `Dictionary`, but `ConcurrentDictionary` also offers
    a number of methods that are concurrency friendly such as `AddOrUpdate` or `GetOrAdd`.
    The `AddOrUpdate` method takes a key and a value parameter, and another parameter
    that is a delegate. If the key isn’t in the dictionary, it’s inserted using the
    value parameter. If the key is in the dictionary, the delegate is called and the
    dictionary is updated with the resulting value. Providing what you do in the delegate
    is also thread safe, this removes the danger of another thread coming in and changing
    the dictionary between you reading a value out of it and writing another back.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentDictionary`可以在处理每秒多个请求的同时确保可伸缩性。您可以使用方括号索引像传统的泛型`Dictionary`一样分配和检索值，但`ConcurrentDictionary`还提供了一些并发友好的方法，例如`AddOrUpdate`或`GetOrAdd`。`AddOrUpdate`方法接受一个键和一个值参数，以及一个代表参数。如果键不在字典中，它将使用值参数插入。如果键在字典中，将调用代表，并使用结果值更新字典。在代表中提供您要执行的操作也是线程安全的，这消除了另一个线程在您从字典中读取值和写入另一个值之间更改字典的风险。'
- en: In the following listing, the `ConcurrentDictionary` keeps the state of open
    connections in the SignalR hub.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，`ConcurrentDictionary`在SignalR hub中保持打开连接的状态。
- en: Listing 3.6 Hub maintaining open connections using `ConcurrentDictionary`
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 使用`ConcurrentDictionary`维护打开的连接
- en: '[PRE45]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The code looks similar to the code listing using the `ImmutableDictionary`,
    ([Listing 3.5](#listing3.5)), but the performance of adding and removing many
    connections (`connection`) is faster. For example, the time required to add 1
    million users to the `ConcurentDictionarry` is only 52 ms, in comparison to the
    2.518 s of the `ImmutableDictionary`. This value is probably fine in many cases,
    but if you want to produce a highly performant system, it’s important to research
    and employ the right tool.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来与使用`ImmutableDictionary`的代码列表（[列表3.5](#listing3.5)）相似，但在添加和删除许多连接（`connection`）的性能上更快。例如，将100万用户添加到`ConcurentDictionarry`所需的时间仅为52毫秒，而`ImmutableDictionary`则需要2.518秒。这个值在许多情况下可能足够好，但如果您想构建一个高性能的系统，那么研究和采用正确的工具是非常重要的。
- en: You need to understand how these collections work. Initially, it seems the collections
    are used without any FP style, due to their mutable characteristics. But the collections
    create an internal snapshot that mimics a temporary immutability to preserve thread
    safety during their iteration, allowing the snapshot to be enumerated safely.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要了解这些集合是如何工作的。最初，由于它们的可变特性，似乎这些集合在使用时没有采用任何FP风格。但是，集合创建了一个内部快照，模拟了临时的不可变性，以在迭代期间保持线程安全，允许安全地枚举快照。
- en: Concurrent collections work well with algorithms that consider the producer/consumer^([6](#c03-footnote-6)) 
    implementation. A *Producer/Consumer pattern* aims to partition and balance the
    workload between one or more producers and one or more consumers. A *producer*
    generates data in an independent thread and inserts it into a queue. A *consumer*
    runs a separate thread concurrently, which consumes the data from the queue. For
    example, a producer could download images and store them in a queue that’s accessed
    by a consumer that performs image processing. These two entities work independently,
    and if the workload from the producer increases, you can spawn a new consumer
    to balance the workload. The Producer/Consumer pattern is one of the most widely
    used parallel programming patterns, and it will be discussed and implemented in
    chapter 7.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 并发集合与考虑生产者/消费者^([6](#c03-footnote-6)) 实现的算法配合良好。*生产者/消费者模式*旨在将工作负载在一名或多名生产者和一名或多名消费者之间进行分区和平衡。一个*生产者*在一个独立的线程中生成数据并将其插入到队列中。一个*消费者*运行一个并行的单独线程，从队列中消费数据。例如，一个生产者可以下载图片并将它们存储在一个由执行图像处理的消费者访问的队列中。这两个实体独立工作，如果生产者的工作负载增加，你可以启动一个新的消费者来平衡工作负载。生产者/消费者模式是应用最广泛的并行编程模式之一，它将在第7章中讨论和实现。
- en: '3.1.3 The agent message-passing pattern: a faster, better solution'
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 代理消息传递模式：更快、更好的解决方案
- en: The final solution for “Hunt the thread-unsafe object” was the introduction
    of a local agent into the SignalR hub, which provides asynchronous access to maintain
    high scalability during high-volume access. An agent is a unit of computation
    that handles one message at a time, and the message is sent asynchronously, which
    means the sender doesn’t have to wait for the answer, so there’s no blocking.
    In this case, the dictionary is isolated and can be accessed only by the agent,
    which updates the collection in a single-thread fashion, eliminating the hazard
    of data corruption and the need for locks. This fix is scalable because the agent’s
    asynchronous semantic operation can process 3 million messages per second, and
    the code runs faster because it removes the extra overhead from using synchronizations.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: “寻找线程不安全对象”的最终解决方案是在SignalR中心引入本地代理，它提供了异步访问以在高流量访问期间保持高可伸缩性。代理是一个计算单元，一次处理一条消息，消息是异步发送的，这意味着发送者不需要等待答案，因此没有阻塞。在这种情况下，字典被隔离，只能由代理访问，它以单线程方式更新集合，消除了数据损坏的风险和锁的需求。这个修复是可伸缩的，因为代理的异步语义操作可以每秒处理300万条消息，代码运行得更快，因为它消除了使用同步的额外开销。
- en: Programming with agents and message passing is discussed in chapter 11\. Don’t
    worry if you don’t completely understand the code; it will become clear during
    this journey, and you can always reference appendix B. This approach requires
    fewer changes in the code compared to the previous solutions, but application
    performance isn’t jeopardized. This listing shows the implementation of the agent
    in F#.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11章中讨论了使用代理和消息传递进行编程。如果你不完全理解代码，不要担心；在这次旅程中它会变得清晰，你始终可以参考附录B。与之前的解决方案相比，这种方法需要更少的代码更改，但不会影响应用程序的性能。此列表显示了在F#中实现代理的方法。
- en: Listing 3.7 F# agent that ensures thread-safe access to mutable states
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7 确保对可变状态线程安全访问的F#代理
- en: '[PRE46]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the following listing, the refactored C# code uses the final solution. Because
    of the interoperability between .NET programming languages, it’s possible to develop
    a library using one language that’s accessed by the other. In this case, C# is
    accessing the F# library with the `MailboxProcessor` (`Agent`) code.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，重构的C#代码使用了最终解决方案。由于.NET编程语言之间的互操作性，可以使用一种语言开发库，而另一种语言可以访问它。在这种情况下，C#使用`MailboxProcessor`（`Agent`）代码访问F#库。
- en: Listing 3.8 SignalR hub in C# using an F# agent
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.8 使用F#代理的C# SignalR中心
- en: '[PRE47]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In summary, the final solution solved the problem by dramatically reducing the
    CPU consumption to almost zero ([figure 3.2](#figure3.2)).
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，最终解决方案通过将CPU消耗大幅降低到几乎为零([图3.2](#figure3.2))解决了问题。
- en: The takeaway from this experience is that sharing a mutable state in the multithreading
    environment isn’t a good idea. Originally, the `Dictionary` collection had to
    maintain the user connections currently online; mutability was almost a necessity.
    You could use a functional approach with an immutable structure, but instead create
    a new collection for each update, which is probably overkill. A better solution
    is to use an agent to isolate mutability and make the agent accessible from the
    caller methods. This is a functional approach that uses the natural thread safety
    of agents.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 从这次经验中得到的启示是，在多线程环境中共享可变状态不是一个好主意。最初，`Dictionary` 集合必须维护当前在线的用户连接；可变性几乎是必需的。你可以使用一个不可变结构的功能方法，但相反，为每次更新创建一个新的集合，这可能是过度设计。更好的解决方案是使用代理来隔离可变性，并使代理可以从调用方法中访问。这是一种使用代理的自然线程安全性的功能方法。
- en: The result of this approach is an increase of scalability because access is
    asynchronous without blocking, and it allows you to easily add logic in the agent
    body, such as logging and error handling.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的结果是可扩展性的增加，因为访问是异步的，不会阻塞，并且它允许你轻松地在代理体中添加逻辑，例如记录日志和错误处理。
- en: '![c03-02.png](Images/c03-02.png)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![c03-02.png](Images/c03-02.png)'
- en: '[Figure 3.2](#figureanchor3.2) Architecture of a web server for a chat application
    using a SignalR hub. This solution, compared to [figure 3.1](#figure3.1), removes
    the mutable dictionary that was shared between multiple threads to handle the
    incoming requests. To replace the dictionary, there is a local agent that guarantees
    high scalability and thread safety in this multithreaded scenario.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.2](#figureanchor3.2) 使用SignalR hub的聊天应用程序的Web服务器架构。与[图3.1](#figure3.1)相比，此解决方案移除了在多个线程之间共享的可变字典，以处理传入的请求。为了替换字典，有一个本地代理保证了在此多线程场景中的高可扩展性和线程安全性。'
- en: 3.2 Safely sharing functional data structures among threads
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 在线程间安全地共享功能性数据结构
- en: A *persistent data structure (*also known as a *functional data structure*)
    is a data structure in which no operations result in permanent changes to the
    underlying structure. *Persistent* means that all versions of the structure that
    are modified endure over time. In other words, such a data structure is immutable
    because update operations don’t modify the data structure but return a new one
    with the updated values.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '*持久性数据结构*（也称为*功能性数据结构*）是一种数据结构，其中没有任何操作会导致底层结构发生永久性更改。*持久性*意味着所有修改过的结构版本都会随着时间的推移而持续存在。换句话说，这样的数据结构是不可变的，因为更新操作不会修改数据结构，而是返回一个新的具有更新值的结构。'
- en: Persistent, in terms of data, is commonly misconstrued as storing data in a
    physical entity, such as a database or filesystem. In FP, a functional data structure
    is long lasting. Most traditional imperative data structures (such as those from
    `System.Collections.Generic:` `Dictionary`, `List`, `Queue`, `Stack`, and so forth)
    are ephemeral because their state exists only for a short time between updates.
    Updates are destructive, as shown in [figure 3.3](#figure3.3).
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据方面，持久性通常被误解为将数据存储在物理实体中，例如数据库或文件系统。在函数式编程（FP）中，功能性数据结构是持久的。大多数传统的命令式数据结构（例如来自
    `System.Collections.Generic:` 的 `Dictionary`、`List`、`Queue`、`Stack` 等等）是短暂的，因为它们的状态仅在更新之间存在很短的时间。更新是破坏性的，如[图3.3](#figure3.3)所示。
- en: A functional data structure guarantees consistent behavior regardless of whether
    the structure is accessed by different threads of execution or even by a different
    process, with no concern for potential changes to the data. Persistent data structures
    don’t support destructive updates, but instead keep the old versions of a data
    structure.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性数据结构保证无论结构是否被不同的执行线程或甚至不同的进程访问，都能保持一致的行为，无需担心数据可能的变化。持久性数据结构不支持破坏性更新，而是保留数据结构的旧版本。
- en: 'Understandably, when compared to traditional imperative data structures, purely
    functional data structures are notoriously memory allocation intensive, which
    leads to substantial performance degradation. Fortunately, persistent data structures
    are designed with efficiency in mind, by carefully reusing a common state between
    versions of a data structure. This is possible by using the immutable nature of
    the functional data structures: Because they can never be changed, reusing different
    versions is effortless. You can compose a new data structure from parts of an
    old one by referring to the existing data rather than copying it. This technique
    is called *structural sharing* (see section 3.3.5). This implementation is more
    streamlined than creating a new copy of data every time an update is performed,
    leading to improved performance.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 可以理解的是，与传统命令式数据结构相比，纯函数式数据结构在内存分配上非常密集，这导致了性能的显著下降。幸运的是，持久数据结构在设计时考虑了效率，通过仔细地在数据结构的版本之间重用公共状态。这是通过使用函数式数据结构的不可变性实现的：因为它们永远不会改变，所以重用不同版本是毫不费力的。你可以通过引用现有数据而不是复制它，从旧数据的一部分组合成一个新的数据结构。这种技术被称为*结构共享*（见3.3.5节）。这种实现比每次更新时创建新的数据副本更加高效，从而提高了性能。
- en: '![c03-03.png](Images/c03-03.png)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![c03-03.png](Images/c03-03.png)'
- en: '[Figure 3.3](#figureanchor3.3) Destructive update vs. a persistent update of
    a list. The list at right is updating in place to mutate the value 3 with the
    value 5, without preserving the original list. This process is also known as destructive.
    At left, the functional list doesn’t mutate its values, but creates a new list
    with the updated value.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.3](#figureanchor3.3) 列表的破坏性更新与持久更新。右侧的列表正在原地更新，将值3替换为5，而不保留原始列表。这个过程也被称为破坏性更新。左侧的函数式列表不修改其值，而是创建一个包含更新值的新列表。'
- en: 3.3 Immutability for a change
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 更改的不可变性
- en: 'In *Working Effectively with Legacy Code*, author Michael Feathers compares
    OOP and FP as follows:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在《有效处理遗留代码》一书中，作者迈克尔·费瑟斯将面向对象编程（OOP）和函数式编程（FP）比较如下：
- en: Object-oriented programming makes code understandable by encapsulating moving
    parts. Functional programming makes code understandable by minimizing moving parts.
  id: totrans-543
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 面向对象编程通过封装移动部分使代码易于理解。函数式编程通过最小化移动部分使代码易于理解。
- en: — Michael Feathers, Working Effectively with Legacy Code (Prentice Hall, 2004)
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: — 迈克尔·费瑟斯，有效处理遗留代码（普伦蒂斯·霍尔，2004年）
- en: What this means is that immutability minimizes the parts of code that change,
    making it easier to reason about how those parts behave. *Immutability* makes
    the functional code free of side effects. A shared variable, which is an example
    of a side effect, is a serious obstacle for creating parallel code and results
    in non-deterministic execution. By removing the side effect, you can have a good
    coding approach.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着不可变性最小化了代码中需要更改的部分，使得推理这些部分的行为变得更加容易。*不可变性*使函数式代码免受副作用的影响。共享变量，作为副作用的一个例子，是创建并行代码的一个严重障碍，并导致非确定性执行。通过消除副作用，你可以拥有良好的编码方法。
- en: In .NET, for example, the framework designers decided to construct `string`s
    as immutable objects, using a functional approach, to make it easier to write
    better code. As you recall, an immutable object is one whose state cannot be modified
    after it’s created. The adoption of immutability in your coding style and the
    learning curve required by this necessitates extra attention; but the resulting
    cleaner code syntax and devolution (reducing unnecessary boilerplate code) will
    be well worth the effort. Moreover, the outcome of adopting this transformation
    of data versus the mutation of data significantly reduces the likelihood of bugs
    in your code, and the interactions and dependencies between different parts of
    your code base become easier to manage.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在.NET中，框架设计者决定使用函数式方法将`string`构建为不可变对象，以使编写更好的代码变得更加容易。正如你所回忆的，不可变对象是指创建后其状态不能被修改的对象。在编码风格中采用不可变性以及由此产生的学习曲线需要额外的关注；但结果将得到更简洁的代码语法和简化（减少不必要的样板代码），这将非常值得努力。此外，采用这种数据转换而非数据修改的方法，可以显著降低代码中错误的可能性，并且代码库不同部分之间的交互和依赖关系更容易管理。
- en: The use of immutable objects as part of your programming model forces each thread
    to process against its own copy of data, which facilitates writing correct, concurrent
    code. In addition, it is safe to have multiple threads simultaneously accessing
    shared data if that access is read-only. In fact, because you do not need locks
    or synchronization techniques, the hazards of possible deadlocks and race conditions
    will never occur ([figure 3.4](#figure3.4)). We discussed these techniques in
    chapter 1.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 将不可变对象作为编程模型的一部分，迫使每个线程处理其自己的数据副本，这有助于编写正确的并发代码。此外，如果访问是只读的，则可以安全地让多个线程同时访问共享数据。实际上，因为你不需要锁或同步技术，所以可能的死锁和竞态条件的风险永远不会发生（[图
    3.4](#figure3.4)）。我们在第 1 章讨论了这些技术。
- en: '![c03-04.png](Images/c03-04.png)'
  id: totrans-548
  prefs: []
  type: TYPE_IMG
  zh: '![c03-04.png](Images/c03-04.png)'
- en: '[Figure 3.4](#figureanchor3.4) A Cartesian representation of the implications
    of using a mutable or immutable state in combination with a shared or unshared
    state'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.4](#figureanchor3.4) 使用可变或不可变状态与共享或非共享状态结合的笛卡尔表示'
- en: Functional languages, such as F#, are immutable by default, which makes them
    perfect for concurrency. Immutability won’t instantaneously cause your code to
    run faster or make your program massively scalable, but it does prepare your code
    to be parallelized with small changes in the code base.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式语言，如 F#，默认是不可变的，这使得它们非常适合并发。不可变性不会立即使你的代码运行得更快或使你的程序大规模可扩展，但它确实为你的代码在代码库中做小的改动后并行化做好了准备。
- en: In object-oriented languages, such as C# and Java, writing concurrent applications
    can be difficult because mutability is the default behavior, and there’s no tool
    to help prevent or offset it. In imperative programming languages, mutable data
    structures are considered perfectly normal and, although global state isn’t recommended,
    mutable state is commonly shared across areas of a program. This is a recipe for
    disaster in parallel programming. Fortunately, as mentioned earlier, C# and F#
    when compiled share the same intermediate language, which makes it easy to share
    functionality. You can define the domain and objects of your program in F# to
    take advantage of its types and conciseness (most importantly, its types are immutable
    by default), for example. Then, develop your program in C# to consume the F# library,
    which guarantees immutable behavior without extra work.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的语言，如 C# 和 Java 中，编写并发应用程序可能很困难，因为可变性是默认行为，而且没有工具可以帮助防止或抵消它。在命令式编程语言中，可变数据结构被认为是完全正常的，尽管全局状态不被推荐，但可变状态通常在程序的不同区域之间共享。这在并行编程中是一个灾难性的配方。幸运的是，如前所述，C#
    和 F# 编译后共享相同的中间语言，这使得功能共享变得容易。你可以在 F# 中定义程序的领域和对象，利用其类型和简洁性（最重要的是，其类型默认是不可变的），例如。然后，用
    C# 开发你的程序以使用 F# 库，这保证了不可变行为而无需额外的工作。
- en: Immutability is an important tool for building concurrent applications, but
    using immutable types doesn’t make the program run faster. But it does make the
    code ready for parallelism; immutability facilitates increased degrees of concurrency,
    which in a multicore computer translates into better performance and speed. Immutable
    objects can be shared safely among multiple threads, avoiding the need of lock
    synchronization, which can keep programs from running in parallel.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 不变性是构建并发应用程序的重要工具，但使用不可变类型并不会使程序运行得更快。但它确实使代码准备好并行执行；不可变性促进了更高程度的并发，这在多核计算机中转化为更好的性能和速度。不可变对象可以在多个线程之间安全地共享，避免了锁同步的需要，这可以使程序并行运行。
- en: The .NET framework provides several immutable types—some are functional, some
    can be used in multithreaded programs, and some both. [Table 3.3](#table3.3) lists
    the characteristics of these types, which will be covered later in this chapter.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 框架提供了几种不可变类型——有些是函数式的，有些可用于多线程程序，有些两者都是。[表 3.3](#table3.3) 列出了这些类型的特性，这些内容将在本章后面讨论。
- en: '[Table 3.3](#tableanchor3.3) Characteristics of .NET framework immutable types'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3.3](#tableanchor3.3) .NET 框架不可变类型的特性'
- en: '| **Type** | **.NET lang.** | **Is it functional?** | **Characteristics** |
    **Thread safe?** | **Utilization** |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **.NET 语言** | **是否是函数式** | **特性** | **线程安全** | **利用率** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| F# list | F# | Yes | Immutable linked list with fast append insertion | Yes
    | Used in combination with recursion to build and traverse *n*-element lists |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| F# 列表 | F# | 是 | 快速追加插入的不可变链表 | 是 | 与递归结合用于构建和遍历 *n*-元素列表 |'
- en: '| Array | C# and F# | No | Zero-indexed mutable array type stored in a continuous
    memory location | Yes with partition^([a](#c03-footnote-a))  | Efficient data
    storage for fast access |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | C# 和 F# | 否 | 存储在连续内存位置中的零索引可变数组类型 | 是，带有分区^([a](#c03-footnote-a)) 
    | 高效的数据存储，用于快速访问 |'
- en: '| Concurrent collections | C# and F# | No | Set of collections optimized for
    multithreaded read/ write access | Yes | Shared data in multi­threaded program;
    perfect fit for the Producer/Consumer pattern |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| 并发集合 | C# 和 F# | 否 | 优化多线程读写访问的集合集 | 是 | 多线程程序中的共享数据；非常适合生产者/消费者模式 |'
- en: '| Immutable collections | C# and F# | Yes | Set of collections that make it
    easier to work with a parallel computing environment; their value can be passed
    freely between different threads without generating data corruption | Yes | Keeping
    state under control when multiple threads are involved |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| 不可变集合 | C# 和 F# | 是 | 一组使处理并行计算环境更容易的集合；它们的值可以在不同的线程之间自由传递，而不会产生数据损坏 | 是
    | 在涉及多个线程时保持状态可控 |'
- en: '| Discriminated union (DU) | F# | Yes | Represents a data type that stores
    one of several possible options | Yes | Commonly used to model domains and to
    represent hierarchical structures like an abstract syntax tree |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| 区分联合（DU） | F# | 是 | 表示存储几种可能选项之一的数据类型 | 是 | 常用于建模领域和表示像抽象语法树这样的层次结构 |'
- en: '| Tuple | C# and F# | Yes | Type that groups two or more values of any (possibly
    different) type | No | Used to return multiple values from functions |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| 元组 | C# 和 F# | 是 | 将两个或更多任意（可能不同）类型的值组合在一起的类型 | 否 | 用于从函数返回多个值 |'
- en: '| F# tuple | F# | Yes |  | Yes |  |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| F# 元组 | F# | 是 |  | 是 |  |'
- en: '| Record type | F# | Yes | Represents aggregates of named value properties;
    can be viewed as a tuple with named members that can be accessed using dot notation
    | Yes | Used in place of conventional classes providing immutable semantics; fits
    well in domain design like DU and can be used in C# |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| 记录类型 | F# | 是 | 表示命名值属性聚合的类型；可以看作是具有命名成员的元组，可以使用点符号访问 | 是 | 用作提供不可变语义的常规类的替代品；非常适合领域设计，如
    DU，并且可以在 C# 中使用 |'
- en: '|  |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.3.1 Functional data structure for data parallelism
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 用于数据并行的函数数据结构
- en: Immutable data structures are a perfect fit for data parallelism because they
    facilitate sharing data among otherwise isolated tasks in an efficient zero-copy
    manner. In fact, when multiple threads access partitionable data in parallel,
    the role of immutability is fundamental to safely processing chunks of data that
    belong to the same structure but that appear isolated. It’s possible to achieve
    the same grade of correct data parallelism by adopting functional purity, which
    means instead of immutability using a function that avoids side effects.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据结构非常适合数据并行，因为它们以高效的无拷贝方式促进了不同任务之间的数据共享。实际上，当多个线程并行访问可分数据时，不可变性在安全处理属于同一结构但看似孤立的各个数据块方面起着基本作用。通过采用函数纯净性，即使用避免副作用的函数而不是不可变性，可以实现相同级别的正确数据并行性。
- en: The underlying functionality of PLINQ, for instance, promotes *purity*. A function
    is pure when it has no side effects and its return value is only determined by
    its input values.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，PLINQ 的底层功能促进了 *纯净性*。一个函数是纯净的，当它没有副作用，并且其返回值仅由其输入值决定时。
- en: PLINQ is a higher-level abstraction language that lies on top of multithreading
    components, abstracting the lower-level details while still exposing a simplified
    LINQ semantic. PLINQ aims to reduce the time of execution and increase the overall
    performance of the query, using all available computer resources. (PLINQ is covered
    in chapter 5.)
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ 是一种位于多线程组件之上的高级抽象语言，它抽象了底层细节，同时仍然暴露了简化的 LINQ 语义。PLINQ 的目标是减少执行时间并提高查询的整体性能，利用所有可用的计算机资源。（PLINQ
    在第 5 章中有详细说明。）
- en: 3.3.2 Performance implications of using immutability
  id: totrans-570
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 使用不可变性的性能影响
- en: Certain coders assume that programming with immutable objects is inefficient
    and has severe performance implications. For example, the pure functional way
    to append something to a list is to return a new copy of the list with the new
    element added, leaving the original list unchanged. This can involve increased
    memory pressure for the GC. Because every modification returns a new value, the
    GC must deal with a large number of short-lived variables. But, because the compiler
    knows that existing data is immutable, and because the data will not change, the
    compiler can optimize memory allocation by reusing the collection partially or
    as a whole. Consequently, the performance impact of using immutable objects is
    minimum, almost irrelevant, because a typical copy of an object, in place of a
    traditional mutation, creates a shallow copy. In this way, the objects referenced
    by the original object are not copied; only the reference is copied, which is
    a small bitwise replica of the original.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 某些程序员认为使用不可变对象进行编程效率低下，并且有严重的性能影响。例如，将元素添加到列表的纯函数式方法是返回一个包含新元素的新列表副本，而原始列表保持不变。这可能会增加GC的内存压力。因为每次修改都会返回一个新的值，GC必须处理大量短生命周期的变量。但是，因为编译器知道现有数据是不可变的，并且因为数据不会改变，编译器可以通过部分或全部重用集合来优化内存分配。因此，使用不可变对象对性能的影响最小，几乎无关紧要，因为典型的对象副本，代替传统的修改，创建了一个浅拷贝。这样，原始对象引用的对象不会被复制；只有引用被复制，这是原始对象的一个小的位操作副本。
- en: With the speed of CPUs today, this is almost an irrelevant price to pay in comparison
    to the benefits achieved as a thread-safety guarantee. A mitigating factor to
    consider is that, currently, performance translates into parallel programming,
    which requires more copying of objects and more memory pressure.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 与线程安全保证带来的好处相比，与今天CPU的速度相比，这几乎是一个微不足道的代价。需要考虑的一个缓解因素是，目前，性能转化为并行编程，这需要更多对象的复制和更大的内存压力。
- en: 3.3.3 Immutability in C#
  id: totrans-573
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 C#中的不可变性
- en: In C#, immutability isn’t a supported construct. But it isn’t difficult to create
    immutable objects in C#; the problem is that the compiler doesn’t enforce this
    style and the programmer must do so with code. Adopting immutability in C# requires
    additional effort and extra diligence. In C#, an immutable object can be created
    by using the keyword `const` or `readonly`*.*
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，不可变性不是一个受支持的构造。但是，在C#中创建不可变对象并不困难；问题在于编译器不会强制执行这种风格，程序员必须通过代码来实现。在C#中采用不可变性需要额外的努力和更多的细心。在C#中，可以通过使用关键字`const`或`readonly`*.*来创建不可变对象。
- en: Any field can be decorated with the `const` keyword; the only precondition is
    that the assignment and declaration are a single-line statement. Once declared
    and assigned, the `const` value cannot be changed, and it belongs at the class
    level, accessing it directly and not by an instance.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 任何字段都可以用`const`关键字进行修饰；唯一的前提是赋值和声明是单行语句。一旦声明并赋值，`const`值就不能更改，并且它属于类级别，直接访问它，而不是通过实例。
- en: The other option, decorating a value with the `readonly` keyword, can be done
    inline or through the constructor when the class is instantiated. After the initialization
    of a field marked `readonly`*,* the field value cannot be changed, and its value
    is accessible through the instance of the class. More important, to maintain the
    object as immutable when there are required changes to properties or state, you
    should create a new instance of the original object with the updated state. Keep
    in mind that `readonly` objects in C# are first-level immutable and shallow immutable
    only. In C#, an object is shallow immutable when the immutability isn’t guaranteed
    to all its fields and properties, but only to the object itself. If an object
    `Person` has a read-only property `Address`, which is a complex object exposing
    properties such as street, city, and ZIP code, then these properties don’t inherit
    the immutability behavior if not marked as read-only. Conversely, an immutable
    object with all the fields and properties marked as read-only is deeply immutable.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是在类实例化时使用 `readonly` 关键字装饰值，可以内联进行或通过构造函数进行。在标记为 `readonly` 的字段初始化后，其值不能更改，并且可以通过类的实例访问其值。更重要的是，当属性或状态需要更改时，为了保持对象不可变，你应该使用更新后的状态创建原始对象的新实例。记住，C#
    中的 `readonly` 对象是第一级不可变和浅不可变的。在 C# 中，一个对象是浅不可变的，当其不可变性不能保证所有字段和属性时，但只保证对象本身。如果一个
    `Person` 对象有一个只读属性 `Address`，它是一个复杂的对象，暴露了如街道、城市和 ZIP 码等属性，那么如果这些属性没有标记为只读，它们不会继承不可变行为。相反，所有字段和属性都标记为只读的不可变对象是深不可变的。
- en: This listing shows immutable class `Person` in C#.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表展示了 C# 中的不可变类 `Person`。
- en: Listing 3.9 Shallow immutable class `Person` in C#
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.9 C# 中的浅不可变类 `Person`
- en: '[PRE48]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this code, the `Person` object is shallow immutable because, despite the
    field `Address` being immune to modification (it’s marked read-only), its underlying
    fields can be changed. In fact, you can create an instance of the object `Person`
    and `Address` as
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`Person` 对象是浅不可变的，因为尽管字段 `Address` 不可修改（它被标记为只读），但其底层字段可以更改。实际上，你可以创建
    `Person` 和 `Address` 对象的实例，如下：
- en: '[PRE49]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, if you try to modify the field `Address,` the compiler throws an exception
    (in bold), but you can still change the fields of the object `address.ZipCode`:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你尝试修改字段 `Address`，编译器会抛出一个异常（粗体），但你仍然可以修改对象 `address.ZipCode` 的字段：
- en: '[PRE50]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is an example of a shallow immutable object. Microsoft realized the importance
    of programming with immutability in a modern context and introduced a feature
    to easily create an immutable class with C# 6.0\. This feature, called *getter-only
    auto-properties*, lets you declare auto-properties without a setter method, which
    implicitly creates a `readonly` backing field. This, unfortunately, implements
    the shallow immutable behavior.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个浅不可变对象的例子。微软意识到在现代环境中使用不可变性编程的重要性，并引入了一个功能，可以轻松地使用 C# 6.0 创建不可变类。这个功能称为
    *只读属性自动属性*，它允许你声明没有设置器方法的自动属性，这会隐式地创建一个 `readonly` 后备字段。不幸的是，这实现了浅不可变行为。
- en: Listing 3.10 Immutable class in C# with getter-only auto-properties
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.10 使用只读属性自动属性的 C# 不可变类
- en: '[PRE51]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In this immutable version of the class `Person`, it’s important to notice that
    the methods responsible for updating the `FirstName`, `LastName`, `Age`, and `Address`
    don’t mutate any state; instead, they create a new instance of `Person`. In OOP,
    objects are instantiated by invoking the constructor, then setting the state of
    the object by updating properties and calling methods. This approach results in
    an inconvenient and verbose construction syntax. This is where the functions added
    to `Change` the properties of the `Person` object come into play. Using these
    functions, it’s possible to adopt a chain pattern, which is known as *fluent interface*.
    Here’s an example of such a pattern by creating an instance of a class `Person`
    and changing the age and address:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `Person` 类的不可变版本中，重要的是要注意，负责更新 `FirstName`、`LastName`、`Age` 和 `Address`
    的方法不会修改任何状态；相反，它们会创建一个新的 `Person` 实例。在面向对象编程中，对象是通过调用构造函数来实例化的，然后通过更新属性和调用方法来设置对象的状态。这种方法导致了一个不便且冗长的构造语法。这就是添加到
    `Change` `Person` 对象属性的功能发挥作用的地方。使用这些函数，可以采用链式模式，这被称为 *流畅接口*。以下是一个创建 `Person`
    类实例并更改年龄和地址的示例模式：
- en: '[PRE52]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In summary, to make a class immutable in C#, you must:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，要在 C# 中使一个类不可变，你必须：
- en: Always design a class with a constructor that takes the argument that’s used
    to set the state of the object.
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是设计一个具有设置对象状态所使用的参数的构造函数的类。
- en: Define the fields as read-only and utilize properties without a public setter;
    the values will be assigned in the constructor.
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字段定义为只读，并使用没有公共设置器的属性；值将在构造函数中分配。
- en: Avoid any method designed to mutate the internal state of the class.
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免任何旨在修改类内部状态的方法。
- en: 3.3.4 Immutability in F#
  id: totrans-593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.4 F# 中的不可变性
- en: 'As mentioned, the programming language F# is immutable by default. Therefore,
    the concept of a variable doesn’t exist because, by definition, if a variable
    is immutable, then it isn’t a variable. F# replaces a variable with an identifier,
    which associates (binds) with a value using the keyword `let`. After this association,
    the value cannot change. Besides a full set of immutable collections, F# has a
    built-in series of helpful immutable constructs, designed for pure functional
    programming, as shown in [Listing 3.11](#listing3.11). These built-in types are
    `tuple` and `record`, and they have a number of advantages over the `CLI` types:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，编程语言 F# 默认是不可变的。因此，变量的概念不存在，因为根据定义，如果变量是不可变的，那么它就不是变量。F# 用标识符替换变量，该标识符通过关键字
    `let` 与值关联（绑定）。在此关联之后，值不能改变。除了完整的不可变集合之外，F# 还内置了一系列有助于纯函数式编程的不可变构造，如[列表 3.11](#listing3.11)所示。这些内置类型是
    `tuple` 和 `record`，并且它们在 `CLI` 类型之上具有许多优点：
- en: They are immutable.
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是不可变的。
- en: They cannot be `null`.
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不能为 `null`。
- en: They have built-in structural equality and comparison.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们具有内置的结构相等性和比较。
- en: This listing shows use of an immutable type in F#.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表展示了在 F# 中使用不可变类型。
- en: '[Listing 3.11](#listinganchor3.11) F# immutable types'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3.11](#listinganchor3.11) F# 不可变类型'
- en: '[PRE53]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The type `tuple` is a set of unnamed ordered values, which can be of different
    heterogeneous ([https://en.wikipedia.org/wiki/Homogeneity_and_heterogeneity](https://en.wikipedia.org/wiki/Homogeneity_and_heterogeneity))
    types. `Tuple has the advantage of being usable on the fly, and is perfect for
    defining temporary and lightweight structures containing an arbitrary number of
    elements. For example, (true, “Hello”, 2, 3.14) is a four tuple.`
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `tuple` 是一组无名的有序值集合，可以是不同异构的([https://en.wikipedia.org/wiki/Homogeneity_and_heterogeneity](https://en.wikipedia.org/wiki/Homogeneity_and_heterogeneity))类型。`Tuple`
    有即用即用的优点，非常适合定义包含任意数量元素的临时和轻量级结构。例如，(true, “Hello”, 2, 3.14) 是一个四元组。
- en: '[PRE54]*****'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE54]*****'
