- en: 'Chapter 16\. DevOps tools: Deploying a scripted server environment using Ansible'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第16章\. DevOps工具：使用Ansible部署脚本化服务器环境
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using orchestration tools to automate tiered Linux deployments
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用编排工具自动化分层Linux部署
- en: Managing Linux servers using Ansible playbooks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible剧本管理Linux服务器
- en: Organizing deployment-related data in a modular architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块化架构中组织部署相关数据
- en: You’ve seen how scripts can automate complicated and boring processes to ensure
    they’re done regularly and done right. You wrote scripts to help with backup jobs
    back in [chapter 5](kindle_split_013.xhtml#ch05). You also saw how virtual Linux
    servers can be provisioned and launched in seconds in [chapter 2](kindle_split_010.xhtml#ch02).
    Is there any reason why you shouldn’t be able to put those tools together and
    automate the creation of entire virtual infrastructure environments? Nope. No
    reason at all.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了脚本如何自动化复杂且无聊的过程，以确保它们定期且正确地完成。你曾在[第5章](kindle_split_013.xhtml#ch05)中编写脚本以帮助备份工作。你也在[第2章](kindle_split_010.xhtml#ch02)中看到了虚拟Linux服务器如何在几秒钟内配置和启动。有什么理由你不能将这些工具组合起来，自动化整个虚拟基础设施环境的创建呢？没有。完全没有理由。
- en: Should you want to? Well, if you and your team are involved in an IT project
    involving multiple developers regularly pushing software versions to multiple
    servers, then you should probably give it some serious consideration, especially
    if you’ve got plans to adopt some variation of the DevOps approach to project
    management illustrated in [figure 16.1](#ch16fig01).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否想要这样做？好吧，如果你和你的团队参与了一个涉及多个开发者定期将软件版本推送到多个服务器的IT项目，那么你可能需要认真考虑一下，尤其是如果你有计划采用[图16.1](#ch16fig01)中展示的DevOps项目管理方法之一。
- en: Figure 16.1\. A typical DevOps cycle incorporates feedback, testing, and monitoring
    into the development process.
  id: totrans-7
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图16.1\. 典型的DevOps周期将反馈、测试和监控纳入开发过程。
- en: '![](Images/16fig01_alt.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/16fig01_alt.jpg)'
- en: What’s DevOps? It’s a way to organize the workflow used by technology companies
    and organizations through close collaboration among a project’s development, quality
    assurance (QA), and system administration teams. The goal is to use templates
    (*infrastructure as code*) to speed up time-to-deployment and software update
    cycles, and to allow greater levels of process automation and monitoring.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是DevOps？它是一种通过项目开发、质量保证（QA）和系统管理团队之间的紧密协作来组织科技公司和组织工作流程的方法。目标是使用模板（*基础设施即代码*）来加快部署和软件更新周期，并允许更高水平的流程自动化和监控。
- en: Many of the automation dividends will come through the smart implementation
    of orchestration tools like Ansible. Being able to plug new or updated code into
    a kind of virtual assembly line with all the underlying infrastructure and compatibility
    details invisibly taken care of can certainly speed things up. But it can also
    greatly improve quality and reduce errors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多自动化收益将通过智能实施像Ansible这样的编排工具来实现。能够将新的或更新的代码插入到一个虚拟装配线上，所有底层基础设施和兼容性细节都无形中得到了处理，这无疑可以加快速度。但它也可以大大提高质量并减少错误。
- en: Because most of the DevOps action is built on Linux infrastructure, and because
    sysadmins are as important to the process as developers, there’s a good chance
    that sooner or later your Linux career will touch DevOps. Before wrapping up this
    book, it would be a good idea to get a bit of a taste of the world of DevOps and
    orchestration.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因为大多数DevOps操作都是建立在Linux基础设施之上的，而且系统管理员在流程中的重要性不亚于开发者，所以你的Linux职业生涯迟早会接触到DevOps。在结束这本书之前，了解一点DevOps和编排的世界会是个不错的选择。
- en: Imagine you’re responsible for a complicated platform like the one illustrated
    in [figure 16.2](#ch16fig02). That includes separate application, database, and
    authentication servers, all replicated in development, production, and backup
    environments. The development servers give you a safe place to test your code
    before pushing it out to production, and the backup servers can be called into
    service should the production servers crash. Your developers are constantly working
    to add features and squash bugs. And they’re regularly pushing their new code
    through the production cycle. In addition, the number of servers you run is constantly
    changing to meet rising and falling user demand.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您负责一个像[图16.2](#ch16fig02)中展示的复杂平台。这包括单独的应用程序、数据库和认证服务器，所有这些都在开发、生产和备份环境中进行了复制。开发服务器为您提供了一个安全的地方来测试您的代码，在将其推送到生产环境之前，备份服务器可以在生产服务器崩溃时投入使用。您的开发人员不断努力添加功能和修复错误。他们定期将新代码推送到生产周期中。此外，您运行的服务器数量不断变化，以满足不断上升和下降的用户需求。
- en: Figure 16.2\. A typical application development environment fed by regular software
    updates from the development team
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图16.2. 一个典型的应用程序开发环境，由开发团队定期提供的常规软件更新所驱动
- en: '![](Images/16fig02_alt.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/16fig02_alt.jpg)'
- en: With so much code flying back and forth in so many directions, you’re going
    to need some help keeping it all straight.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在如此多的代码在多个方向上飞来飞去的情况下，您将需要一些帮助来保持一切井然有序。
- en: 16.1\. What deployment orchestrators can do for you
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1. 部署编排器能为您做什么
- en: Deployment orchestrators will be perfectly happy working their magic on old-fashioned
    bare-metal servers, but you’ll only enjoy their full power when you incorporate
    them into virtualized deployments. Given how easy it is to script the creation
    of virtual servers, whether on your own hardware or using the resources of a cloud
    provider like AWS, being able to automate the creation of software stacks for
    your VMs will only add speed and efficiency.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 部署编排器在旧式的裸金属服务器上施展它们的魔力时会非常满意，但只有当您将它们融入虚拟化部署中时，您才能享受到它们的全部力量。鉴于在您自己的硬件上或使用像AWS这样的云服务提供商的资源上创建虚拟服务器的脚本化过程是多么容易，能够自动化为您的虚拟机创建软件堆栈只会增加速度和效率。
- en: The idea is that you compose one or more text files whose contents declare the
    precise state you want for all the system and application software on a specified
    machine (usually known as a *host*). When run, the orchestrator will read those
    files, log on to the appropriate host or hosts, and execute all the commands needed
    to achieve the desired state. Rather than having to go through the tedious and
    error-prone process manually on each of the hosts you’re launching, you tell the
    orchestrator to do it all for you. Once your infrastructure grows to dozens or
    even thousands of hosts, this kind of automation isn’t just convenient, it’s essential.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是您编写一个或多个文本文件，其内容声明了您希望指定机器（通常称为*主机*）上所有系统和应用程序软件的精确状态。当运行时，编排器将读取这些文件，登录到适当的宿主或宿主机，并执行所有必要的命令以实现所需的状态。您不必在您启动的每个宿主机上手动进行繁琐且容易出错的流程，而是告诉编排器为您完成所有这些工作。一旦您的基础设施扩展到数十个甚至数千个宿主机，这种自动化不仅方便，而且是必不可少的。
- en: But if this is all about automating file system actions, why not use the Bash
    scripting skills you already have? Well, you probably could, but once you start
    trying to incorporate things like remote authentication and conflicting software
    stacks into those scripts, your life will quickly become insanely complicated.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果这一切都是关于自动化文件系统操作，为什么不用您已经拥有的Bash脚本技能呢？好吧，您可能可以，但一旦您开始尝试将这些脚本与远程认证和冲突的软件堆栈等元素结合起来，您的生活很快就会变得疯狂复杂。
- en: 'Orchestrators will safely and reliably manage variables and passwords for you,
    and apply them within the proper context as often and in as many ways as necessary.
    You don’t need to track all the fine details on your own. Because there are all
    kinds of orchestration tools, the one you choose will largely depend on the specifics
    of your project, organization, and background. You’ll need to ask yourself some
    basic questions: “Are most of the people involved going to be developers or IT
    professionals?” “Will you be using a continuous integration methodology?” [Table
    16.1](#ch16table01) provides some quick and dirty profiles of four of the main
    players.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 编排器将安全可靠地为你管理变量和密码，并在适当的情况下以必要的方式和次数应用它们。你不需要自己跟踪所有细节。由于有各种各样的编排工具，你选择的工具将主要取决于你项目的具体细节、组织背景。你需要问自己一些基本问题：“大多数参与人员会是开发者还是IT专业人士？”
    “你将使用持续集成方法吗？” [表16.1](#ch16table01) 提供了四个主要参与者的快速简略介绍。
- en: Table 16.1\. Popular deployment orchestrators
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表16.1\. 流行的部署编排器
- en: '| Tool | Features |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 工具 | 功能 |'
- en: '| --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | ---'
- en: '| Puppet | Broad community support |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| Puppet | 广泛的社区支持 |'
- en: '|   | Some coding skills recommended |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|   | 推荐一些编码技能 |'
- en: '|   | Extensible using Ruby |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|   | 可使用Ruby扩展 |'
- en: '|   | Requires agents installed on all clients |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|   | 需要在所有客户端上安装代理 |'
- en: '| Chef | Integrated with Git |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| Chef | 与Git集成 |'
- en: '|   | Some coding skills recommended |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|   | 推荐一些编码技能 |'
- en: '|   | Extensible using Ruby |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|   | 可使用Ruby扩展 |'
- en: '|   | High learning curve |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|   | 学习曲线高 |'
- en: '|   | Broad community support |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|   | 广泛的社区支持 |'
- en: '|   | Requires chef-client installed on all clients |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|   | 需要在所有客户端上安装chef-client |'
- en: '| Ansible | Sysadmin friendly |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| Ansible | 系统管理员友好 |'
- en: '|   | Python-based |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|   | 基于 Python |'
- en: '|   | No code needed, no host-based agents |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '|   | 无需代码，无需基于主机的代理 |'
- en: '|   | Simple, fast connections work via SSH |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|   | 简单、快速通过SSH连接 |'
- en: '|   | Run via text-based files (called playbooks) |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|   | 通过基于文本的文件（称为playbooks）运行 |'
- en: '|   | Minimal learning curve |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|   | 学习曲线最小 |'
- en: '| Salt | Works through agents (called minions) |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| Salt | 通过代理（称为minions）工作 |'
- en: '|   | Highly scalable |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|   | 高度可扩展 |'
- en: '|   | Sysadmin friendly |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|   | 系统管理员友好 |'
- en: As a sysadmin, Ansible sounds like a winner for me, so that’s what we’ll focus
    on for the rest of this chapter. But the needs and expectations of your specific
    project may differ.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为系统管理员，Ansible对我来说听起来是一个赢家，所以我们将在本章的剩余部分集中关注它。但你的具体项目和期望可能不同。
- en: '16.2\. Ansible: Installation and setup'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2\. Ansible：安装和设置
- en: Before starting, you’ll need a recent version of Python on your Ansible server
    and on all the machines you plan to use as hosts. Either `apt install python`
    or `yum install python` will do that job. Whichever version of Python you use
    (meaning Python 2 or 3), make sure `python --version` works from the command line.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，你需要在Ansible服务器以及你计划用作主机的所有机器上安装最新的Python版本。无论是使用`apt install python`还是`yum
    install python`都可以完成这项工作。无论你使用哪个版本的Python（意味着Python 2或3），确保`python --version`可以从命令行工作。
- en: '|  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As of the time of this writing, Ansible often works better using the older 2.7
    version of Python. That, however, will probably not be a long-term condition.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Ansible通常使用较旧的2.7版本的Python表现更好。然而，这可能不会是一个长期的状态。
- en: '|  |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In order to install Ansible on the server (or *control machine*), you’ll need
    to enable the EPEL repository (for CentOS 6), the Extras repository (for CentOS
    7), or the ppa:ansible repository for Ubuntu. Before you can enable that repository
    on Ubuntu using the `add-apt-repository` command, however, you may need to install
    the software-properties-common package. That’ll go like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在服务器（或*控制机器*）上安装Ansible，你需要启用EPEL仓库（针对CentOS 6）、 Extras仓库（针对CentOS 7），或者Ubuntu的ppa:ansible仓库。然而，在Ubuntu上使用`add-apt-repository`命令启用该仓库之前，你可能需要安装软件包`software-properties-common`。操作步骤如下：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Finally, fire up two or three Python-ready LXC containers to serve as hosts
    (or *nodes*), the creatures that do all the work. There’s no need to install Ansible
    on any of the hosts, just on the control machine.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，启动两个或三个Python就绪的LXC容器作为主机（或*节点*），这些是执行所有工作的生物。不需要在任何主机上安装Ansible，只需在控制机器上安装即可。
- en: 16.2.1\. Setting up passwordless access to hosts
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.1\. 设置无密码访问主机
- en: 'Let’s look at how to set up passwordless access to hosts. Ansible prefers to
    do its work over SSH connections. Although it’s possible to handle authentication
    from the command line, it’s far better to send SSH keys to enable passwordless
    access with your hosts. You remember how that works from [chapter 3](kindle_split_011.xhtml#ch03),
    but here it is again:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何设置对主机的无密码访问。Ansible 倾向于通过 SSH 连接来完成其工作。尽管从命令行处理身份验证是可能的，但将 SSH 密钥发送到主机以实现无密码访问要远远好于从命令行处理身份验证。你记得这是从
    [第 3 章](kindle_split_011.xhtml#ch03) 中学到的，但这里再重复一遍：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Run this if you don’t already have a key pair on your local system.**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果你本地系统上还没有密钥对，请运行此命令。**'
- en: '***2* The login and IP address of the host machine to which you’re copying
    your server’s SSH key**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你要复制服务器 SSH 密钥的主机机器的登录名和 IP 地址**'
- en: '***3* You’ll need to enter a password for the host machine user account to
    authorize the key transfer.**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 你需要为主机机器用户账户输入密码以授权密钥传输。**'
- en: Now that Ansible is properly installed and connected to your hosts, it’s time
    to configure your environment.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Ansible 已经正确安装并连接到你的主机，是时候配置你的环境了。
- en: 16.2.2\. Organizing Ansible hosts
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.2\. 组织 Ansible 主机
- en: Ansible gets its information about which hosts to manage from an inventory file
    called hosts in the /etc/ansible/ directory. The file can be a simple list of
    IP addresses or domain names, or a combination thereof.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 从位于 /etc/ansible 目录下的名为 hosts 的清单文件中获取有关要管理的哪些主机的信息。该文件可以是 IP 地址或域名的一个简单列表，或者两者的组合。
- en: Listing 16.1\. A simple example of a /etc/ansible/hosts file
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.1\. 一个简单的 /etc/ansible/hosts 文件示例
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: But as the number of hosts you’re expecting Ansible to administer grows, along
    with the complexity of your overall environment, you’ll want to organize things
    a bit better. One way to do that is by dividing your hosts into host groups, which
    can then be targeted for precise Ansible actions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，随着你期望 Ansible 管理的主机数量以及你整体环境的复杂性增长，你可能想要更好地组织这些事情。实现这一目标的一种方法是将你的主机划分为主机组，然后可以对它们执行精确的
    Ansible 操作。
- en: Listing 16.2\. An example of a /etc/ansible/hosts file organized into host groups
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.2\. 一个组织成主机组的 /etc/ansible/hosts 文件示例
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using host groups, Ansible tasks can be configured to run against only a well-defined
    subset of your hosts, perhaps sending updated public-facing web pages to only
    the web servers and new configuration files to the databases (illustrated in [figure
    16.3](#ch16fig03)).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主机组，Ansible 任务可以配置为仅针对定义良好的主机子集运行，例如，仅向 Web 服务器发送更新的公共网页，向数据库发送新的配置文件（如图 16.3
    所示）。
- en: Figure 16.3\. Task-specific updates being pushed to servers organized in host
    groups
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 16.3\. 推送到主机组中特定任务的更新
- en: '![](Images/16fig03_alt.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/16fig03_alt.jpg)'
- en: 'There’s a lot more control that can be applied to the hosts file. You’ll find
    that the default hosts file created in /etc/ansible/ during installation will
    already include a nice selection of syntax suggestions, like how you can reference
    multiple host names in a single line: `www[001:006].example.com`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可以应用于 hosts 文件的控制还有很多。你会发现，在安装过程中在 /etc/ansible/ 中创建的默认 hosts 文件已经包含了一些很好的语法建议，例如，如何在单行中引用多个主机名：`www[001:006].example.com`。
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: So you’ll be able to follow along with the demos in this chapter, add the IP
    address of your Python-ready LXC (or other) hosts to the hosts file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你将能够跟随本章中的演示，将你的 Python 准备好的 LXC（或其他）主机的 IP 地址添加到 hosts 文件中。
- en: '|  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 16.2.3\. Testing connectivity
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.3\. 测试连接性
- en: 'To test that things are set up properly, Ansible can try to contact the hosts
    listed in the hosts file. This command runs Ansible from the command line in what’s
    known as *ad hoc* mode. The `-m` tells Ansible to load and run the ping module
    to send a simple “Are You There?” request to all the hosts listed in the hosts
    file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试设置是否正确，Ansible 可以尝试联系 hosts 文件中列出的主机。这个命令以所谓的 *ad hoc* 模式从命令行运行 Ansible。`-m`
    参数告诉 Ansible 加载并运行 ping 模块，向 hosts 文件中列出的所有主机发送简单的“你在吗？”请求：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `all` condition in that command means you want this action performed on
    all the hosts listed in the hosts file. If you only wanted to ping a specific
    host group, you would use the group name instead of `all`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令中的 `all` 条件表示你希望此操作在 hosts 文件中列出的所有主机上执行。如果你只想ping一个特定的主机组，你将使用组名而不是 `all`：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that you’re connected, you can run simple commands remotely. This example
    copies the /etc/group file to the home directory of each of your hosts. Remember,
    the reason you’re able to do this without providing authentication is because
    you previously used `ssh-keygen` to save your SSH key to the remote host:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经连接上了，你可以远程运行简单的命令。这个例子将/etc/group文件复制到每个主机的家目录中。记住，你之所以能够不提供认证就完成这项操作，是因为你之前使用了`ssh-keygen`将你的SSH密钥保存到了远程主机上：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can confirm the operation worked by running `ls` over SSH:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在SSH上运行`ls`来确认操作是否成功：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If the username of the account you’re logged in to on your Ansible server is
    not the same as the usernames on your hosts, you’ll need to tell Ansible about
    it. You can do that from the command line using the `--user` argument, which,
    assuming the host usernames are ubuntu, would look like this: `ansible --user
    ubuntu all -m ping`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你登录到Ansible服务器上的账户的用户名与你的主机上的用户名不同，你需要告诉Ansible。你可以通过命令行使用`--user`参数来做到这一点，假设主机用户名是ubuntu，它看起来像这样：`ansible
    --user ubuntu all -m ping`。
- en: 16.3\. Authentication
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3\. 认证
- en: Now suppose you need to execute a command on your remote hosts that requires
    sudo powers. Imagine you want to push an updated .html file to all of the dozens
    of web servers toiling away tirelessly behind your load balancer. It sure would
    make a lot of sense to do it in one go, rather than to repeat the operation individually
    for each host.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你需要在你远程主机上执行需要sudo权限的命令。想象一下，你想要将更新的.html文件推送到你负载均衡器后面辛勤工作的数十个Web服务器上。一次性完成这个操作，而不是为每个主机单独重复操作，确实很有意义。
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**What’s a load balancer?**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是负载均衡器？**'
- en: In case you’re curious, a *load balancer* is a server or network router that
    receives requests for access to a service and redirects those requests to multiple
    application servers. Load balancers are good at spreading demand among servers
    to ensure that no one of them is overloaded, and at directing requests away from
    unhealthy or unavailable servers. Two widely used open source Linux packages for
    load balancing are HAProxy and, in addition to its web server features, nginx.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这个好奇，*负载均衡器*是一个服务器或网络路由器，它接收访问服务的请求并将这些请求重定向到多个应用服务器。负载均衡器擅长在服务器之间分配需求，以确保没有一台服务器过载，并且能够将请求从不健康或不可用的服务器上移开。两个广泛使用的开源Linux负载均衡软件包是HAProxy和nginx，除了其Web服务器功能外，nginx也用于负载均衡。
- en: '|  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Why not try it yourself? See what happens when you try to use the copy module
    to copy a file in your local home directory (perhaps the group file you copied
    there earlier) to the /var/www/html/ directory on your remote host. If your host
    doesn’t happen to have a /var/www/html/ directory already, you can produce the
    same effect by substituting any system directory (like /etc/) that’s not owned
    by your user:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不自己试试？看看当你尝试使用copy模块将本地家目录中的文件（可能是你之前复制到那里的group文件）复制到远程主机的/var/www/html目录时会发生什么。如果你的主机没有预先设置/var/www/html目录，你可以通过替换任何不属于你的用户的系统目录（如/etc/）来产生相同的效果：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* src= points to the location of the source file on the local machine;
    dest= points to the target location on the host.**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* src=指向本地机器上源文件的位置；dest=指向主机上的目标位置。**'
- en: '***2* A descriptive error message explaining what went wrong**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 一个描述性的错误消息，解释出了什么问题**'
- en: Whoops. “Destination /var/www/html not writable” sounds like a permissions issue.
    Looks like you’ll have to find a way to escalate your privileges. The best way
    to do that is through settings in the /etc/ansible/ansible.cfg file. As you can
    see from the following example, I edited the `[privilege_escalation]` section
    of ansible.cfg by uncommenting its four lines.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀。 “目标/var/www/html不可写”听起来像是一个权限问题。看起来你需要找到一种方法来提升你的权限。最好的方法是通过/etc/ansible/ansible.cfg文件中的设置。正如以下示例所示，我通过取消注释ansible.cfg文件中的四行来编辑了`[privilege_escalation]`部分。
- en: Listing 16.3\. Changed settings in /etc/ansible/ansible.cfg
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.3\. /etc/ansible/ansible.cfg中的更改设置
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you run the copy operation once again, this time adding the `--ask-become-pass`
    argument, Ansible reads the updated configuration file and prompts for the remote
    ubuntu user’s sudo password. This time you’ll be successful:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次运行copy操作时，这次添加了`--ask-become-pass`参数，Ansible会读取更新的配置文件并提示输入远程ubuntu用户的sudo密码。这次你会成功：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Log in to your remote server to confirm that the file has been copied. By the
    way, from a security perspective, it’d be a terrible idea to leave a copy of your
    group file in the web root. This was just an example. Please don’t leave it there.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到你的远程服务器以确认文件已被复制。顺便说一句，从安全的角度来看，将你的组文件留在web根目录里是一个糟糕的主意。这只是一个例子。请不要将其留在那里。
- en: 16.4\. Ansible playbooks
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.4\. Ansible playbooks
- en: 'As you’ve seen, you can be up and running with some basic Ansible activities
    in a minute or two. But those basics won’t get you far. If you want to exploit
    the real power of the tool so it can orchestrate the kind of automated multi-tier
    infrastructure I described in the chapter introduction, you’ll need to learn to
    use playbooks. *Playbooks* are the way you closely define the policies and actions
    you want Ansible to trigger. They’re also an easy way to share working configuration
    profiles. Here are two ways you can use a playbook:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你可以在一两分钟内启动一些基本的Ansible活动。但那些基础知识不会让你走得太远。如果你想利用工具的真正力量，使其能够编排我在章节引言中描述的那种自动化多级基础设施，你需要学习如何使用playbooks。*Playbooks*是你紧密定义Ansible想要触发的策略和动作的方式。它们也是共享工作配置配置文件的一种简单方法。这里有你可以使用playbook的两种方式：
- en: As a simple, standalone script
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为简单的独立脚本
- en: As a reference that points to resources spread across a specially structured
    directory tree (for more complicated environments)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为指向一个特别结构的目录树中分布的资源（用于更复杂的环境）的参考
- en: 16.4.1\. Writing a simple playbook
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.4.1\. 编写简单的playbook
- en: Let’s learn how to create a simple playbook that can all in one go provision
    a relatively straightforward web server. To do this, you’ll use modules (like
    the copy module you saw previously), tasks for running Linux system actions, and
    handlers to dynamically respond to system events. First, make sure your hosts
    file in /etc/ansible/ is up to date.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何创建一个简单的playbook，它可以一次性部署一个相对简单的web服务器。为此，你需要使用模块（如之前看到的copy模块），运行Linux系统操作的tasks，以及用于动态响应系统事件的handlers。首先，确保你的/etc/ansible/目录下的hosts文件是最新的。
- en: Listing 16.4\. A simple /etc/ansible/hosts file
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.4\. 一个简单的/etc/ansible/hosts文件
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, you’ll need to create a YAML-formatted file called site.yml. *YAML* is
    a text-formatting language related to the more widely used JavaScript Object Notation
    (JSON). Although you’ll need to be careful getting the indentation right, the
    YAML format does produce configuration profiles that are easy to read, understand,
    and edit.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要创建一个名为site.yml的YAML格式文件。*YAML*是一种与更广泛使用的JavaScript Object Notation (JSON)相关的文本格式化语言。虽然你需要小心地正确缩进，但YAML格式确实可以生成易于阅读、理解和编辑的配置配置文件。
- en: 'After starting with a line containing three dashes (`---`), your file will
    include three sections: `hosts`, `tasks`, and `handlers`. In this case, the `hosts`
    section tells Ansible to apply the playbook’s actions to all the addresses from
    the webservers group in the hosts file. The `tasks` section (indented the same
    number of spaces as hosts) introduces three tasks (or *modules*): `apt` to install
    the Apache web server, `copy` to copy a local file to the web document root, and
    `service`, much like `systemctl` in a systemd environment, to make sure Apache
    is running.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中以包含三个短横线（`---`）的行开始后，你的文件将包括三个部分：`hosts`、`tasks`和`handlers`。在这种情况下，`hosts`部分告诉Ansible将playbook的操作应用于hosts文件中webservers组的所有地址。`tasks`部分（缩进与hosts相同数量的空格）介绍了三个tasks（或*modules*）：`apt`用于安装Apache
    web服务器，`copy`用于将本地文件复制到web文档根目录，以及`service`，类似于systemd环境中的`systemctl`，以确保Apache正在运行。
- en: Listing 16.5\. A simple Ansible playbook called site.yml
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.5\. 一个简单的名为site.yml的Ansible playbook
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Runs the tasks only on those hosts listed in the webservers host group**'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 只在webservers主机组中列出的主机上运行任务**'
- en: '***2* The apt module installs the apache2 package on an Ubuntu machine**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* apt模块在Ubuntu机器上安装apache2包**'
- en: '***3* Requiring the latest value for the state property ensures that the latest
    version of the software is installed.**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 确保state属性的最新值确保安装了软件的最新版本。**'
- en: '***4* Requires the existence of an index.html file in a local directory called
    project/**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 需要一个名为project/**的本地目录中存在index.html文件**'
- en: '***5* The handler name; even though it looks more like a description, it can
    be used as a reference from within a task.**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 处理器名称；尽管它看起来更像是一个描述，但它可以在任务内部用作参考。**'
- en: 'To test this yourself, you could create a simple file called index.html and
    save it to a directory on your Ansible server. (I used an LXC container for my
    Ansible lab.) Make sure to properly reference the file location in the playbook
    (the way it was in the `copy: src=` line from the previous playbook example).
    The file can, if you like, contain nothing more complicated than the words *Hello
    World*. It’s only there to confirm the playbook worked. Once the playbook has
    run, a copy of that file should exist in the web document root.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '要自己测试，你可以创建一个名为 index.html 的简单文件，并将其保存到你的 Ansible 服务器上的一个目录中。（我在我的 Ansible
    实验室中使用了 LXC 容器。）确保在剧本中正确引用文件位置（就像上一个剧本示例中的 `copy: src=` 行那样）。如果你愿意，该文件可以不包含比 *Hello
    World* 更复杂的单词。它仅仅是为了确认剧本是否工作。一旦剧本运行，该文件的副本应该存在于网页文档根目录中。'
- en: Also, note the `notify:` line within the copy task in the previous example.
    Once the copy task is complete, `notify` triggers the handler with the name `restart
    apache` that will, in turn, make sure that Apache is restarted and running properly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意上一个示例中复制任务内的 `notify:` 行。一旦复制任务完成，`notify` 将触发名为 `restart apache` 的处理程序，这将确保
    Apache 被重新启动并正常运行。
- en: 'As you build your own playbooks, you’ll definitely need more syntax and feature
    information. Running `ansible-doc` and the name of a particular module will get
    you going:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建自己的剧本时，你肯定需要更多的语法和功能信息。运行 `ansible-doc` 和特定模块的名称将帮助你入门：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Running your playbook
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 运行你的剧本
- en: 'Assuming your /etc/ansible/ansible.cfg file is still properly configured to
    handle host authentication, you’re ready to use the `ansible-playbook` command
    to run your playbook. By default, the command will use the hosts listed in /etc/ansible/hosts,
    but you can use `-i` to point it to a different file. Here’s an example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的 /etc/ansible/ansible.cfg 文件仍然正确配置以处理主机身份验证，你现在可以使用 `ansible-playbook` 命令来运行你的剧本。默认情况下，该命令将使用
    /etc/ansible/hosts 中列出的主机，但你可以使用 `-i` 来指向不同的文件。以下是一个示例：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* A brief summary of the task’s purpose**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 对任务目的的简要总结**'
- en: '***2* The ok message tells you that a task has successfully completed.**'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 成功消息告诉你任务已成功完成。**'
- en: '***3* A summary of the results of running the playbook**'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 运行剧本的结果摘要**'
- en: Success! With that single command you’ve built a working web server on all the
    hosts you listed in your hosts file. Don’t believe me? Point your browser to the
    URL that should be used by the index2.html file you copied (10.0.3.96/index2.html,
    in my case). You should see your index2.html file displayed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！使用这个单一命令，你已经在你的 hosts 文件中列出的所有主机上建立了一个工作的 Web 服务器。你不相信吗？将你的浏览器指向应该由你复制的 index2.html
    文件使用的 URL（在我的例子中是 10.0.3.96/index2.html）。你应该能看到你的 index2.html 文件被显示出来。
- en: 16.4.2\. Creating multi-tiered, role-powered playbooks
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.4.2\. 创建多级、基于角色的剧本
- en: Once your Ansible-managed infrastructure becomes weighted down with layers of
    elements, each with its own detailed parameters, keeping them all in a single
    playbook script is impractical. Try to imagine what it might be like to manage
    the kind of platform illustrated earlier in [figure 16.2](#ch16fig02).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的 Ansible 管理的基础设施被层层元素压垮，每个元素都有其详细的参数，将它们全部放在一个剧本脚本中是不切实际的。试着想象一下，管理前面在 [图
    16.2](#ch16fig02) 中展示的那种平台会是什么样子。
- en: 'Breaking out the tasks, handlers, and other data types into separate directories
    and files will make things much more readable. This kind of modular organization
    also makes it possible to build new playbooks without having to reinvent any wheels:
    you’ll always have full and easy access to everything you’ve created.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将任务、处理程序和其他数据类型拆分到单独的目录和文件中会使内容更加易于阅读。这种模块化组织也使得构建新的剧本成为可能，而无需重新发明轮子：你将始终能够轻松访问你创建的一切。
- en: Ansible organizes its modular elements into roles and even provides its own
    command-line tool, ansible-galaxy, to manage existing roles and generate the necessary
    file system framework for starting new roles. [Figure 16.4](#ch16fig04) illustrates
    the basic Ansible topology.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 将其模块化元素组织到角色中，甚至提供自己的命令行工具 ansible-galaxy 来管理现有角色并生成启动新角色所需必要的文件系统框架。[图
    16.4](#ch16fig04) 展示了基本的 Ansible 拓扑。
- en: Figure 16.4\. Ansible roles shown as self-contained groupings of resources,
    including access to system dependencies
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 16.4\. 以资源自包含分组形式展示的 Ansible 角色，包括对系统依赖的访问
- en: '![](Images/16fig04_alt.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/16fig04_alt.jpg)'
- en: Generating an Ansible role
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生成 Ansible 角色
- en: Choose a directory to use as your Ansible root. If you’re working on a container
    or VM whose whole purpose is to act as an Ansible server, this might as well be
    your main user’s document root (/home/username/). From the Ansible root, you’ll
    create a directory called roles and then move to the new directory.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个目录作为你的 Ansible 根目录。如果你在一个容器或 VM 上工作，其整个目的就是作为 Ansible 服务器，那么这也可以是你的主要用户的文档根目录（/home/username/）。从
    Ansible 根目录开始，你将创建一个名为 roles 的目录，然后移动到新目录。
- en: 'Once there, initialize the directory using `ansible-galaxy init` followed by
    the name you want to use for your role:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦到达那里，使用 `ansible-galaxy init` 初始化目录，然后跟随着你想要用于你的角色的名称：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A new directory called web-app is created. Run `ls -R` to recursively list
    the new subdirectories and their contents that ansible-galaxy created for you:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个名为 web-app 的新目录。运行 `ls -R` 以递归列出 ansible-galaxy 为你创建的新子目录及其内容：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Each subdirectory within web-app is displayed with a leading ./.**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* web-app 中的每个子目录都以 ./ 开头。**'
- en: '***2* Some directories are already populated with largely empty playbook files
    of their own.**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 一些目录已经包含了自己大量为空的 playbook 文件。**'
- en: 'How does Ansible consume the data contained in those directories? Here’s something
    to chew on: the variable values and parameters set in those files will often control
    the way Ansible manages the resources launched using that particular role.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 如何消费这些目录中的数据？这里有件事值得思考：那些文件中设置的变量值和参数通常会控制 Ansible 使用该特定角色管理资源的方式。
- en: 'Read that one or two more times. Done? OK, there are two things that should
    stand out: *often control* (but not always?) and *that particular role* (you mean
    I could have others?).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 读一遍或两遍。完成了吗？好的，有两件事应该会突出：*经常控制*（但并不总是？）和*那个特定的角色*（你是说我可以有其他角色？）。
- en: 'Right and right. The settings added to files beneath your web-app role directory
    can be invoked either from a top-level playbook or through an ad hoc command-line
    action. By way of example, you might have defined a web document root location
    in the roles/web-app/defaults/main.yml file as `webroot_location: /var/www/myroot/`.
    Invoking the `webroot_location` variable will always return the value `/var/www/myroot/`.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '对，对。添加到你的 web-app 角色目录下文件中的设置可以从顶层 playbook 或通过 ad hoc 命令行操作来调用。例如，你可能在 roles/web-app/defaults/main.yml
    文件中定义了一个网络文档根位置，为 `webroot_location: /var/www/myroot/`。调用 `webroot_location` 变量将始终返回
    `/var/www/myroot/` 的值。'
- en: Except when it doesn’t. You see, Ansible was designed for environments encompassing
    multiple projects. You might have a separate playbook for each of a handful of
    separate applications and others for internal company services. There’s nothing
    stopping you from managing more than one application from a single Ansible server.
    This will probably mean that you want a particular variable to mean one thing
    for application *x* and another for application *y*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了某些情况外。你看，Ansible 是为包含多个项目的环境设计的。你可能为几个独立的应用程序各自有一个单独的 playbook，还有其他用于公司内部服务的
    playbook。没有任何阻止你从单个 Ansible 服务器管理多个应用程序的。这可能意味着你希望特定的变量对于应用程序 *x* 来说意味着一件事，而对于应用程序
    *y* 来说意味着另一件事。
- en: 'Which brings us to the second notable point: each application or service can
    be defined by its own Ansible role. But, so that multiple roles can happily coexist
    on a single system, you’ll need a way to prioritize their overlapping variables.
    The way Ansible does that is quite complicated, but I can summarize it by saying
    that values found in a role’s vars/ directory override those from /defaults, and
    values explicitly set using `-e` (or `--extra-vars=`) beat everything else.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这就引出了第二个值得注意的点：每个应用程序或服务都可以通过其自己的 Ansible 角色来定义。但是，为了让多个角色能够在单个系统上愉快地共存，你需要一种方法来优先处理它们的重叠变量。Ansible
    这样做的方式相当复杂，但我可以总结说，角色 vars/ 目录中的值会覆盖 /defaults 中的值，而使用 `-e`（或 `--extra-vars=`）显式设置的值会覆盖其他所有值。
- en: 'What might go into each of your roles/web-app/ directories? Here’s a short
    list:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 roles/web-app/ 目录中可能包含什么内容？这里有一个简短的列表：
- en: The vars/ directory is likely to contain information on the file system locations
    for encryption keys.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: vars/ 目录可能包含有关加密密钥文件系统位置的信息。
- en: The templates/ directory will hold templates that are meant to be installed
    as, say, Apache configuration files in Python’s .j2 format.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: templates/ 目录将包含模板，这些模板旨在以，例如，Apache 配置文件的形式安装，格式为 Python 的 .j2。
- en: The files/ directory could contain other files (like that .html file you copied
    in the previous example) that are used for host-based data.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: files/ 目录可能包含其他文件（比如你在上一个例子中复制的那个 .html 文件），这些文件用于基于主机的数据。
- en: 16.4.3\. Managing passwords in Ansible
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.4.3\. 在Ansible中管理密码
- en: 'Although you’ll probably need to include host passwords in your Ansible infrastructure,
    you should never store them in plain text documents. Ever. Rather, Ansible provides
    a tool called Vault that stores sensitive data in encrypted files that can, when
    necessary, be safely called by a playbook. This snippet opens an editor into which
    you can enter a new Vault password:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能需要在Ansible基础设施中包含主机密码，但你绝不应该以纯文本形式存储它们。永远不要。相反，Ansible提供了一个名为Vault的工具，该工具将敏感数据存储在加密文件中，当需要时，可以通过playbook安全地调用。此片段打开一个编辑器，你可以在此处输入新的Vault密码：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* If you don’t want Vault to open the password file in Vim, you can export
    the editor variable as Nano.**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果你不希望Vault在Vim中打开密码文件，可以将编辑器变量导出为Nano。**'
- en: '***2* You’ll be prompted to enter a new Vault password before adding the password
    you want to use for host access.**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在添加你想要用于主机访问的密码之前，你将被提示输入一个新的Vault密码。**'
- en: 'Assuming your hosts are all using only a single password, this works by adding
    the `--ask-vault-pass` argument to the `ansible-playbook` command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的主机都只使用单个密码，这是通过在`ansible-playbook`命令中添加`--ask-vault-pass`参数来实现的：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For your information, since Ansible version 2.3, it’s also possible to make
    use of what Ansible calls a *vaulted variable*, which is essentially an encrypted
    password stored in a plain text YAML file. This makes it possible to manage multiple
    passwords.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 供你参考，自从Ansible版本2.3以来，也可以利用Ansible所说的*加密变量*，这实际上是一个存储在纯文本YAML文件中的加密密码。这使得管理多个密码成为可能。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Orchestration tools let you automate server infrastructure at scale, whether
    it’s a single host or thousands. The tool you choose will depend on your team’s
    skill set, project needs, and company culture.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编排工具让你能够大规模自动化服务器基础设施，无论是单个主机还是数千个。你选择的工具将取决于你团队的技能、项目需求和公司文化。
- en: Ansible requires no coding, runs on SSH, and has a light footprint.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible不需要编写代码，在SSH上运行，并且占用资源较少。
- en: Ansible playbooks, especially playbooks that run resources through roles, are
    effective and efficient ways to manage security and resources.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible playbooks，尤其是通过角色运行资源的playbooks，是管理和有效利用安全资源的高效方式。
- en: Key terms
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键术语
- en: '*DevOps* is a project organization structure to help development and admin
    teams speed up and automate product development cycles.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*DevOps*是一种项目组织结构，旨在帮助开发和运维团队加快并自动化产品开发周期。'
- en: '*Orchestration deployment* tools let you precisely script infrastructure behavior
    to achieve desired states through automation.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编排部署*工具让你能够精确地通过自动化脚本基础设施行为来实现所需的状态。'
- en: A *host group* is a way to organize hosts so that Ansible can be directed to
    manage well-defined subsets of your host fleet.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主机组*是一种组织主机的方式，以便Ansible可以指向管理主机群集中的明确子集。'
- en: In Ansible playbooks, *modules* are predefined command sequences run on a host
    system, *handlers* are actions triggered by events, and *roles* are bundled resources
    organized to serve a single project.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Ansible playbooks中，*模块*是在主机系统上运行的预定义命令序列，*处理器*是由事件触发的动作，而*角色*是组织成单一项目服务的捆绑资源。
- en: Security best practices
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全最佳实践
- en: Directing Ansible to access your hosts using passwordless, key-pair-based SSH
    is preferred to having to enter passwords at the command line for each operation.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Ansible指向使用无密码、基于密钥对的SSH访问你的主机，比在每次操作中输入密码更受欢迎。
- en: Never include passwords in Ansible playbooks or other plain text scripts. Use
    Ansible Vault instead.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要在Ansible playbooks或其他纯文本脚本中包含密码。请使用Ansible Vault。
- en: Command-line review
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令行审查
- en: '`add-apt-repository ppa:ansible/ansible` adds the Debian Ansible software repository
    to allow apt to install Ansible on an Ubuntu/Debian machine.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add-apt-repository ppa:ansible/ansible`将Debian Ansible软件仓库添加到apt中，以便在Ubuntu/Debian机器上安装Ansible。'
- en: '`ansible webservers -m ping` tests all the hosts in the webservers host group
    for network connectivity.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible webservers -m ping`测试webservers主机组中的所有主机以检查网络连接性。'
- en: '`ansible webservers -m copy -a "src=/home/ubuntu/stuff.html dest=/var/ www/html/"`
    copies a local file to the specified file location on all the hosts in the webservers
    group.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible webservers -m copy -a "src=/home/ubuntu/stuff.html dest=/var/www/html/"`将本地文件复制到webservers组中所有主机的指定文件位置。'
- en: '`ansible-doc apt` displays syntax and usage information on the apt module.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-doc apt`显示apt模块的语法和用法信息。'
- en: '`ansible-playbook site.yml` launches an operation based on the site.yml playbook.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-playbook site.yml`根据site.yml playbooks启动操作。'
- en: '`ansible-playbook site.yml --ask-vault-pass` uses a Vault password to authenticate
    and perform playbook operations.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible-playbook site.yml --ask-vault-pass` 使用Vault密码进行身份验证并执行playbook操作。'
- en: Test yourself
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试自己
- en: '**[1](#ch16qa2q0a1)**'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch16qa2q0a1)**'
- en: ''
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following orchestration tools would work best for a team of developers
    with little experience in DevOps who are building a large and complex platform?
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个编排工具最适合对DevOps经验较少的开发者团队构建大型且复杂的平台？
- en: ''
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Ansible
  id: totrans-184
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible
- en: Chef
  id: totrans-185
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: Chef
- en: Puppet
  id: totrans-186
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: Puppet
- en: Salt
  id: totrans-187
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: Salt
- en: '**[2](#ch16qa2q0a2)**'
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch16qa2q0a2)**'
- en: ''
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following packages must be installed on each host for Ansible to
    work?
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个软件包必须在每个主机上安装，以便Ansible能够工作？
- en: ''
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Ansible
  id: totrans-192
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible
- en: Python
  id: totrans-193
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python
- en: software-properties-common
  id: totrans-194
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: software-properties-common
- en: Ansible and Python
  id: totrans-195
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible和Python
- en: '**[3](#ch16qa2q0a3)**'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch16qa2q0a3)**'
- en: ''
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following design considerations is primarily a security concern?
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个设计考虑因素主要是安全关注点？
- en: ''
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Organizing your hosts into host groups
  id: totrans-200
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的宿主机组织成宿主机组
- en: Scheduling regular connectivity testing for all hosts
  id: totrans-201
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为所有宿主机安排定期的连通性测试
- en: Separating environment variables
  id: totrans-202
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分离环境变量
- en: Storing data in Ansible Vault
  id: totrans-203
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Ansible Vault中存储数据
- en: '**[4](#ch16qa2q0a4)**'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](#ch16qa2q0a4)**'
- en: ''
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What command tells Ansible to automatically populate the default web document
    root with a local file on only those hosts running Apache?
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哪个命令告诉Ansible仅在运行Apache的宿主机上自动用本地文件填充默认的Web文档根目录？
- en: ''
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`ansible all -i copy -a "src=/var/www/html/ dest=/home/ubuntu/stuff.html"`'
  id: totrans-208
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible all -i copy -a "src=/var/www/html/ dest=/home/ubuntu/stuff.html"`'
- en: '`ansible all webservers -m copy -a "/home/ubuntu/stuff.html /var/www/html/"`'
  id: totrans-209
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible all webservers -m copy -a "/home/ubuntu/stuff.html /var/www/html/"`'
- en: '`ansible webservers -m copy -a "src=/home/ubuntu/stuff.html dest=/var/www/html/"`'
  id: totrans-210
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible webservers -m copy -a "src=/home/ubuntu/stuff.html dest=/var/www/html/"`'
- en: '`ansible webservers -m copy -a src=/home/ubuntu/stuff.html dest=/var/www/html/`'
  id: totrans-211
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible webservers -m copy -a src=/home/ubuntu/stuff.html dest=/var/www/html/`'
- en: '**[5](#ch16qa2q0a5)**'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[5](#ch16qa2q0a5)**'
- en: ''
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following commands will create the directories and files you need
    for a new Ansible role?
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个命令将创建您为新的Ansible角色所需的所有目录和文件？
- en: ''
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`ansible-root-directory/roles/ansible-galaxy init rolename`'
  id: totrans-216
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible-root-directory/roles/ansible-galaxy init rolename`'
- en: '`ansible-root-directory/ansible-galaxy rolename`'
  id: totrans-217
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible-root-directory/ansible-galaxy rolename`'
- en: '`ansible-root-directory/roles/ansible-init rolename`'
  id: totrans-218
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible-root-directory/roles/ansible-init rolename`'
- en: '`ansible-root-directory/roles/ansible init rolename`'
  id: totrans-219
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ansible-root-directory/roles/ansible init rolename`'
- en: Answer key
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 答案键
- en: '**[1.](#ch16qa1q1)**'
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1.](#ch16qa1q1)**'
- en: ''
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b
- en: '**[2.](#ch16qa1q2)**'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2.](#ch16qa1q2)**'
- en: ''
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b
- en: '**[3.](#ch16qa1q3)**'
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3.](#ch16qa1q3)**'
- en: ''
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d
- en: '**[4.](#ch16qa1q4)**'
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4.](#ch16qa1q4)**'
- en: ''
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c
- en: '**[5.](#ch16qa1q5)**'
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[5.](#ch16qa1q5)**'
- en: ''
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a
