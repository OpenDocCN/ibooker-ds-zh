- en: 2 Kubernetes and GitOps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 Kubernetes 和 GitOps
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Solving problems with Kubernetes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 解决问题
- en: Running and managing Kubernetes locally
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地运行和管理 Kubernetes
- en: Understanding the basics of GitOps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 GitOps 的基础知识
- en: Implementing a simple Kubernetes GitOps operator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个简单的 Kubernetes GitOps 操作员
- en: In chapter 1, you learned about Kubernetes and why its declarative model makes
    it an excellent match to be managed using GitOps. This chapter will briefly introduce
    Kubernetes architecture and objects and the differences between declarative and
    imperative object management. By the end of this chapter, you will implement a
    basic GitOps Kubernetes deployment operator.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，你学习了 Kubernetes 以及为什么它的声明式模型使其非常适合使用 GitOps 进行管理。本章将简要介绍 Kubernetes 架构和对象，以及声明式和命令式对象管理的区别。在本章结束时，你将实现一个基本的
    GitOps Kubernetes 部署操作员。
- en: 2.1 Kubernetes introduction
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 Kubernetes 简介
- en: Before diving into why Kubernetes and GitOps work so well together, let’s talk
    about Kubernetes itself. This section provides a high-level overview of Kubernetes,
    how it compares to other container orchestration systems, and its architecture.
    We will also have an exercise that demonstrates how to run Kubernetes locally,
    which will be used for the other exercises in this book. This section is only
    a brief introduction and refresher on Kubernetes. For a fun but informative overview
    of Kubernetes, check out “The Illustrated Children’s Guide to Kubernetes” and
    “Phippy Goes to the Zoo” by the Cloud Native Computing Foundation.^([1](#pgfId-1076468))
    If you are completely new to Kubernetes, we recommend reading *Kubernetes in Action,
    Second Edition*, by Marko Lukša (Manning, 2020) and then returning to this book.
    If you are already familiar with Kubernetes and running minikube, you may skip
    to the exercise at the end of section 2.1.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨为什么 Kubernetes 和 GitOps 能够如此良好地协同工作之前，让我们先谈谈 Kubernetes 本身。本节提供了 Kubernetes
    的高级概述，包括它与其他容器编排系统的比较以及其架构。我们还将有一个练习，演示如何在本地运行 Kubernetes，这将被用于本书中的其他练习。本节仅是对
    Kubernetes 的简要介绍和复习。如果你想有趣且信息丰富地了解 Kubernetes，可以查看云原生计算基金会出版的“儿童插图 Kubernetes
    指南”和“Phippy 去动物园”^[1](#pgfId-1076468)。如果你对 Kubernetes 完全陌生，我们建议阅读 Marko Lukša（Manning，2020
    年）的《Kubernetes 动作，第二版》，然后返回本书。如果你已经熟悉 Kubernetes 并运行 minikube，你可以跳到 2.1 节末的练习。
- en: 2.1.1 What is Kubernetes?
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 什么是 Kubernetes？
- en: Kubernetes is an open source container orchestration system released in 2014\.
    OK, but what are containers, and why do you need to orchestrate them?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个于 2014 年发布的开源容器编排系统。好的，但什么是容器，为什么你需要对它们进行编排？
- en: Containers provide a standard way to package your application’s code, configuration,
    and dependencies into a single resource. This enables developers to ensure that
    the application will run properly on any other machine regardless of any customized
    settings that machine may have that could differ from the machine used for writing
    and testing the code. Docker simplified and popularized containerization, which
    is now recognized as a fundamental technology used to build distributed systems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 容器提供了一种标准方式来打包你的应用程序代码、配置和依赖项到一个单一的资源中。这使得开发者可以确保应用程序无论在任何其他机器上都能正常运行，无论该机器可能有什么定制设置，这些设置可能与编写和测试代码所使用的机器不同。Docker
    简化和普及了容器化，现在它被认为是一种用于构建分布式系统的基本技术。
- en: chroot An operation available in UNIX operating systems, which changes the apparent
    root directory for the current running process and its children. Chroot provides
    a way to isolate a process and its children from the rest of the system. It was
    a precursor to containerization and Docker.^([2](#pgfId-1076479))
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: chroot 是 UNIX 操作系统中可用的一种操作，它更改当前运行进程及其子进程的可见根目录。Chroot 提供了一种将进程及其子进程从系统其余部分隔离的方法。它是容器化的前身，也是
    Docker 的基础。[2](#pgfId-1076479)
- en: 'While Docker solved the packaging and isolation problem of individual applications,
    there were still many questions about how to orchestrate the operation of multiple
    applications into a working distributed system:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Docker 解决了单个应用程序的打包和隔离问题，但关于如何编排多个应用程序的操作以形成一个工作分布式系统的问题仍然很多：
- en: How do containers communicate?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是如何进行通信的？
- en: How is traffic routed between containers?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器之间的流量是如何路由的？
- en: How are containers scaled up to handle additional application load?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是如何进行扩展以处理额外的应用负载的？
- en: How is the underlying infrastructure of the cluster scaled up to run the required
    containers?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群的底层基础设施是如何进行扩展以运行所需的容器的？
- en: All these operations are the responsibility of a container orchestration system
    and are provided by Kubernetes. Kubernetes helps to automate the deployment, scaling,
    and management of applications using containers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都是容器编排系统的责任，并由 Kubernetes 提供。Kubernetes 帮助自动化使用容器部署、扩展和管理应用程序。
- en: Note Borg is Google’s internal container cluster management system used to power
    online services like Google search, Gmail, and YouTube. Kubernetes leverages Borg’s
    innovations and lessons learned, explaining why it is more stable and moves so
    much more quickly than its competitors.^([3](#pgfId-1076491))
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Borg 是 Google 的内部容器集群管理系统，用于支持 Google 搜索、Gmail 和 YouTube 等在线服务。Kubernetes
    利用 Borg 的创新和经验教训，解释了为什么它比竞争对手更稳定，发展得更快。[3](#pgfId-1076491)
- en: Kubernetes was initially developed and open-sourced by Google based on a decade
    of experience with container orchestration using Borg, Google’s proprietary cluster
    management system. Because of this, Kubernetes is relatively stable and mature
    for a system so complex. Because of its open API and extendable architecture,
    Kubernetes has developed an extensive community around it, which has further fueled
    its success. It is one of the top GitHub projects (as measured by stars), provides
    excellent documentation, and has a significant Slack and Stack Overflow community.
    An endless number of blogs and presentations from community members share their
    knowledge of using Kubernetes. Despite being started by Google, Kubernetes is
    not influenced by a single vendor. This makes the community open, collaborative,
    and innovative.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是基于 Google 使用其专有集群管理系统 Borg 进行容器编排的十年经验而开发和开源的。因此，对于如此复杂的系统来说，Kubernetes
    相对稳定且成熟。由于其开放的 API 和可扩展的架构，Kubernetes 周围已经发展出一个庞大的社区，这进一步推动了其成功。它是 GitHub 上评分最高的项目之一（按星级衡量），提供了优秀的文档，并拥有庞大的
    Slack 和 Stack Overflow 社区。社区成员的无尽博客和演示文稿分享了他们使用 Kubernetes 的知识。尽管 Kubernetes 是由
    Google 启动的，但它不受单一供应商的影响。这使得社区开放、协作且具有创新性。
- en: 2.1.2 Other container orchestrators
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 其他容器编排器
- en: Since late 2016, Kubernetes has become recognized as the dominant de facto industry-standard
    container orchestration system in much the same way that Docker has become the
    standard for containers. However, several Kubernetes alternatives address the
    same container orchestration problem as Kubernetes. Docker Swarm is Docker’s native
    container orchestration engine that was released in 2015\. It is tightly integrated
    with the Docker API and uses a YAML-based deployment model called Docker Compose.
    Apache Mesos was officially released in 2016 (although it has a history well before
    then) and supports large clusters, scaling to thousands of nodes.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2016 年末以来，Kubernetes 已经成为业界公认的、事实上的行业标准容器编排系统，与 Docker 成为容器标准的方式相似。然而，有几个
    Kubernetes 的替代方案解决了与 Kubernetes 相同的容器编排问题。Docker Swarm 是 Docker 在 2015 年发布的原生容器编排引擎，它与
    Docker API 紧密集成，并使用基于 YAML 的部署模型 Docker Compose。Apache Mesos 于 2016 年正式发布（尽管在此之前已有很长时间的历史），支持大型集群，可扩展到数千个节点。
- en: While it may be possible to apply a GitOps approach to deploying applications
    using other container orchestration systems, this book focuses on Kubernetes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管将 GitOps 方法应用于使用其他容器编排系统部署应用程序可能是可行的，但本书的重点是 Kubernetes。
- en: 2.1.3 Kubernetes architecture
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 Kubernetes 架构
- en: By the end of this chapter, you will complete an exercise that implements a
    basic GitOps continuous deployment operator for Kubernetes. But to understand
    how a GitOps operator functions, it is essential that you first understand a few
    Kubernetes core concepts and learn how it is organized at a high level.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将完成一个练习，实现一个基本的 GitOps 持续部署操作符用于 Kubernetes。但要理解 GitOps 操作符是如何工作的，首先理解一些
    Kubernetes 核心概念以及它在高层次上的组织方式是至关重要的。
- en: 'Kubernetes is an extensive and robust system with many different types of resources
    and operations that can be performed on those resources. Kubernetes provides a
    layer of abstraction over the infrastructure and introduces the following set
    of basic objects that represent the desired cluster state:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个庞大且健壮的系统，具有许多不同类型的资源和可以在这些资源上执行的操作。Kubernetes 在基础设施之上提供了一层抽象，并引入了以下一组基本对象，它们代表了所需的集群状态：
- en: '*Pod*—A group of containers deployed together on the same host. The Pod is
    the smallest deployable unit on a node and provides a way to mount storage, set
    environment variables, and provide other container configuration information.
    When all the containers of a Pod exit, the Pod dies also.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pod*—在同一主机上一起部署的一组容器。Pod是节点上可部署的最小单元，提供挂载存储、设置环境变量和提供其他容器配置信息的方式。当一个Pod的所有容器退出时，该Pod也会死亡。'
- en: '*Service*—An abstraction that defines a logical set of Pods and a policy to
    access them.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Service*—定义了一组逻辑Pod及其访问策略的抽象。'
- en: '*Volume*—A directory accessible to containers running in a Pod.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Volume*—Pod中运行的容器可访问的目录。'
- en: Kubernetes architecture uses primary resources as a foundational layer for a
    set of higher-level resources. The higher-level resources implement features needed
    for real production use cases that leverage/extend the primary resources’ functionality.
    In figure 2.1, you see that the ReplicaSet resource controls the creation of one
    or more Pod resources. Some other examples of high-level resources include
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes架构使用主要资源作为一组更高层次资源的基础层。更高层次资源实现了针对实际生产用例所需的功能，这些用例利用/扩展了主要资源的功能。在图2.1中，您可以看到ReplicaSet资源控制一个或多个Pod资源的创建。其他一些高级资源的例子包括
- en: '![](Images/CH02_F01_Yuen.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F01_Yuen.png)'
- en: Figure 2.1 This diagram illustrates a typical Kubernetes environment deployed
    in a Namespace. A ReplicaSet is an example of a higher-level resource that manages
    the life cycle of Pods, which are lower-level, primary resources.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 该图展示了在命名空间中部署的典型Kubernetes环境。ReplicaSet是管理Pod生命周期的更高层次资源的一个例子，Pod是更低层次、主要资源。
- en: R*eplicaSe*t—Defines that a desired number of identically configured Pods are
    running. If a Pod in the ReplicaSet terminates, a new Pod will be started to bring
    the number of running Pods back to the desired number.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R*eplicaSe*t—定义了所需数量的配置相同的Pod正在运行。如果ReplicaSet中的Pod终止，将启动一个新的Pod，以将运行Pod的数量恢复到所需数量。
- en: '*Deployment*—Enables declarative updates for Pods and ReplicaSets.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Deployment*—为Pods和ReplicaSets启用声明式更新。'
- en: '*Job*—Creates one or more Pods that run to completion.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Job*—创建一个或多个运行至完成的Pod。'
- en: '*CronJob*—Creates Jobs on a time-based schedule.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CronJob*—基于时间表创建作业。'
- en: Another important Kubernetes resource is the Namespace. Most kinds of Kubernetes
    resources belong to one (and only one) Namespace. A Namespace defines a naming
    scope where resources within a particular Namespace must be uniquely named. Namespaces
    also provide a way to isolate users and applications from each other through role-based
    access controls (RBACs), network policies, and resource quotas. These controls
    allow creating a multitenant Kubernetes cluster where multiple users share the
    same cluster and avoid impacting each other (for example, the “noisy neighbor”
    problem). As we will see in chapter 3, Namespaces are also essential in GitOps
    for defining application environments.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的Kubernetes资源是命名空间。大多数类型的Kubernetes资源属于一个（且仅一个）命名空间。命名空间定义了一个命名范围，其中特定命名空间内的资源必须具有唯一名称。命名空间还提供了一种通过基于角色的访问控制（RBAC）、网络策略和资源配额来隔离用户和应用程序的方法。这些控制允许创建一个多租户Kubernetes集群，其中多个用户共享同一个集群，避免相互影响（例如，“嘈杂邻居”问题）。正如我们在第3章中将要看到的，命名空间在GitOps中对于定义应用程序环境也是必不可少的。
- en: 'Kubernetes objects are stored in a control plane,^([4](#pgfId-1076533)) which
    monitors the cluster state, makes changes, schedules work, and responds to events.
    To perform these duties, each Kubernetes control plane runs the following three
    processes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes对象存储在控制平面中，^([4](#pgfId-1076533)) 它监控集群状态，进行更改，调度工作，并对事件做出响应。为了执行这些任务，每个Kubernetes控制平面运行以下三个进程：
- en: '`kube-apiserver`—An entry point to the cluster providing a REST API to evaluate
    and update the desired cluster state'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-apiserver`—集群的入口点，提供REST API以评估和更新所需的集群状态'
- en: '`kube-controller-manager`—Daemon continuously monitoring the shared state of
    the cluster through the API server to make changes attempting to move the current
    state toward the desired state'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-controller-manager`—守护进程通过API服务器持续监控集群的共享状态，尝试将当前状态移动到所需状态以进行更改'
- en: '`kube-scheduler`—A component that is responsible for scheduling the workloads
    across the available nodes in the cluster'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-scheduler`—一个负责在集群中可用的节点间调度工作负载的组件'
- en: '`etcd`—A highly available key-value database typically used as Kubernetes’
    backing store for all cluster configuration data'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd`—一个高度可用的键值数据库，通常用作Kubernetes所有集群配置数据的后端存储'
- en: '![](Images/CH02_F02_Yuen.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F02_Yuen.png)'
- en: Figure 2.2 A Kubernetes cluster consists of several Services that run on the
    master nodes of the control plane and several other Services that run on the cluster’s
    worker nodes. Together, these Services provide the essential Services that make
    up a Kubernetes cluster.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 Kubernetes 集群由运行在控制平面主节点上的多个服务以及运行在集群工作节点上的多个其他服务组成。这些服务共同提供了构成 Kubernetes
    集群的必要服务。
- en: 'The actual cluster workloads run using the compute resources of Kubernetes
    nodes. A node is a worker machine (either a VM or physical machine) that runs
    the necessary software to allow it to be managed by the cluster. Similar to the
    masters, each node runs a predefined set of processes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的集群工作负载使用 Kubernetes 节点的计算资源运行。节点是一个工作机器（无论是虚拟机还是物理机），它运行必要的软件以允许它被集群管理。类似于主节点，每个节点运行一组预定义的进程：
- en: '`kubelet`—The primary “node agent” that manages the actual containers on the
    node'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubelet`——管理节点上实际容器的“节点代理”'
- en: '`kube-proxy`—A network proxy that reflects Services as defined in the Kubernetes
    API on each node and can do simple TCP, UDP, and SCTP stream forwarding'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-proxy`——一个网络代理，在每个节点上反映 Kubernetes API 中定义的服务，并且可以进行简单的 TCP、UDP 和 SCTP
    流转发'
- en: 2.1.4 Deploying to Kubernetes
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 部署到 Kubernetes
- en: In this exercise, you will deploy a website using *NG*I*NX* on Kubernetes. You
    will review some basic Kubernetes operations and become familiar with minikube,
    the single-node Kubernetes environment you will use for most exercises in this
    book.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用 *NG*I*NX* 在 Kubernetes 上部署一个网站。你将回顾一些基本的 Kubernetes 操作，并熟悉 minikube，这是你将在本书的大部分练习中使用的单节点
    Kubernetes 环境。
- en: 'Kubernetes test environment: minikube Refer to appendix A to set up a Kubernetes
    test environment using minikube to complete this exercise.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 测试环境：minikube 请参考附录 A，使用 minikube 设置 Kubernetes 测试环境以完成此练习。
- en: Creating a Pod
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 Pod
- en: As was mentioned earlier in the chapter, a Pod is the smallest object in Kubernetes
    and represents a particular application workload. A Pod represents a group of
    related containers running on the same host and having the same operating requirements.
    All containers of a single Pod share the same network address, port space, and
    (optionally) file system using Kubernetes Volumes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面提到的，Pod 是 Kubernetes 中最小的对象，代表特定的应用程序工作负载。Pod 代表在相同主机上运行并具有相同操作要求的容器组。单个
    Pod 的所有容器共享相同的网络地址、端口空间和（可选）文件系统，这是通过 Kubernetes 卷实现的。
- en: NGINX NGINX is an open source software web server used by many organizations
    and enterprises to host their websites because of its performance and stability.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX NGINX 是一个开源软件 Web 服务器，许多组织和企业使用它来托管他们的网站，因为它具有高性能和稳定性。
- en: In this exercise, you will create a Pod that hosts a website using NGINX. In
    Kubernetes, objects can be defined by a YAML text file “manifest” that provides
    all the information needed for Kubernetes to create and manage the object. Here
    is the listing for our NGINX Pod manifest.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个 Pod，使用 NGINX 托管网站。在 Kubernetes 中，可以通过 YAML 文本文件“清单”定义对象，该文件提供了
    Kubernetes 创建和管理对象所需的所有信息。以下是我们的 NGINX Pod 清单的列表。
- en: Listing 2.1 NGINX Pod manifest [(http://mng.bz/e5JJ)](https://shortener.manning.com/e5JJ)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 NGINX Pod 清单 [(http://mng.bz/e5JJ)](https://shortener.manning.com/e5JJ)
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ The field kind and apiVersion are present in every Kubernetes resource and
    determine what type of object should be created and how it should be handled.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 字段 kind 和 apiVersion 存在于每个 Kubernetes 资源中，并确定应该创建什么类型的对象以及如何处理它。
- en: ❷ In this example, metadata has a name field that helps identify each Kubernetes
    resource. Metadata may also contain UID, labels, and other fields that will be
    covered later.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在这个例子中，元数据有一个名称字段，有助于识别每个 Kubernetes 资源。元数据还可能包含 UID、标签和其他将在以后介绍的字段。
- en: ❸ The spec section contains configuration that is specific to a particular kind
    of object. In the Pod example, spec includes a list of containers, the Volume
    shared between containers, and the Pod’s restartPolicy.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 规范部分包含特定于特定对象的配置。在 Pod 示例中，规范包括容器列表、容器之间共享的卷以及 Pod 的重启策略。
- en: ❹ The Volume that is used to share data between containers
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 用于在容器之间共享数据的卷
- en: ❺ The init section contains HTML generated using the cowsay^([5](#pgfId-1086925))
    command.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 初始化部分包含使用 cowsay^([5](#pgfId-1086925)) 命令生成的 HTML。
- en: ❻ The main container that serves the generated HTML file using the NGINX server
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 主要容器，用于通过 NGINX 服务器提供生成的 HTML 文件
- en: 'You are welcome to type in this listing and save it with a filename of nginx-Pod.yaml.
    However, since this book’s object isn’t to improve your typing skills, we recommend
    cloning our public Git repository mentioned in chapter 1 that contains all the
    listings in this book and using those files directly:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以输入此列表并将其保存为nginx-Pod.yaml文件名。然而，由于本书的目标不是提高你的打字技巧，我们建议克隆第1章中提到的公共Git仓库，该仓库包含本书中的所有列表，并直接使用这些文件：
- en: '[https://github.com/gitopsbook/resources](https://github.com/gitopsbook/resources)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/gitopsbook/resources](https://github.com/gitopsbook/resources)'
- en: 'Let’s go ahead and start a minikube cluster and create the NGINX Pod using
    the following commands:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续启动minikube集群并使用以下命令创建NGINX Pod：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Figure 2.3 shows what the Pod looks like running inside the minikube.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3显示了Pod在minikube内部运行的外观。
- en: '![](Images/CH02_F03_Yuen.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F03_Yuen.png)'
- en: Figure 2.3 The nginx-init container writes the desired index.html file to the
    mounted Volume. The main NGINX container also mounts the Volume and displays the
    generated index.html when receiving HTTP requests.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 nginx-init容器将所需的index.html文件写入挂载的卷。主要的NGINX容器也挂载了卷，并在接收到HTTP请求时显示生成的index.html。
- en: Getting Pod status
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 获取Pod状态
- en: 'As soon as the Pod is created, Kubernetes inspects the `spec` field and attempts
    to run the configured set of containers on an appropriate node in the cluster.
    The information about progress is available in the Pod manifest in the `status`
    field. The kubectl utility provides several commands to access it. Let’s try to
    get the Pod status using the `kubectl get Pods` command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Pod创建完成，Kubernetes会检查`spec`字段，并尝试在集群中适当节点上运行配置的容器集。关于进度的信息可以在Pod的`status`字段中找到。kubectl实用工具提供了多个命令来访问它。让我们尝试使用`kubectl
    get Pods`命令来获取Pod状态：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `get Pods` command provides a list of all the Pods running in a particular
    Namespace. In this case, we didn’t specify a Namespace, so it gives the list of
    Pods running in the default Namespace. Assuming all goes well, the *NG*I*NX* Pod
    should be in the `Running` state.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`get Pods`命令提供了特定命名空间中所有Pod的列表。在这种情况下，我们没有指定命名空间，因此它给出了在默认命名空间中运行的Pod列表。假设一切顺利，*NGINX*
    Pod应该处于`Running`状态。'
- en: 'To learn even more about a Pod’s status or debug why the Pod is not in the
    `Running` state, the `kubectl` `describe` `Pod` command outputs detailed information,
    including related Kubernetes events:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Pod状态更多或调试Pod为何不在`Running`状态的原因，可以使用`kubectl describe Pod`命令输出详细信息，包括相关的Kubernetes事件：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Typically, the events section will contain clues as to why a Pod is not in the
    `Running` state.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，事件部分将包含有关Pod为何不在`Running`状态的原因的线索。
- en: The most exhaustive information is available via `kubectl` `get` `Pod` `nginx`
    `-o=yaml`, which outputs the full internal representation of the object in YAML
    format. The raw YAML output is difficult to read, and it is typically meant for
    programmatic access by resource controllers. Kubernetes resource controllers will
    be covered in more detail later in this chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最全面的信息可以通过`kubectl get Pod nginx -o=yaml`获取，它以YAML格式输出对象的完整内部表示。原始的YAML输出难以阅读，通常是为了程序化访问资源控制器。Kubernetes资源控制器将在本章后面更详细地介绍。
- en: Accessing the Pod
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 访问Pod
- en: A Pod in the `Running` state means that all containers successfully started
    and the NGINX Pod is ready to serve requests. If the NGINX Pod in our cluster
    is running, we can try accessing it and prove that it is working.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当Pod处于`Running`状态时，意味着所有容器都已成功启动，NGINX Pod已准备好处理请求。如果我们的集群中的NGINX Pod正在运行，我们可以尝试访问它并证明它正在工作。
- en: 'Pods are not accessible from outside the cluster by default. There are multiple
    ways to configure external access, which include Kubernetes Services, Ingress,
    and more. For the sake of simplicity, we are going to use the command `kubectl`
    `port-forward` that forwards connections from a local port to a port on a Pod:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Pod无法从集群外部访问。有多种配置外部访问的方式，包括Kubernetes服务、Ingress等。为了简化，我们将使用`kubectl port-forward`命令，该命令将本地端口上的连接转发到Pod上的端口：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Keep the `kubectl port-forward` command running, and try opening http://localhost:8080/
    in your browser. You should see the generated HTML file!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 保持`kubectl port-forward`命令运行，并在浏览器中尝试打开http://localhost:8080/。你应该会看到生成的HTML文件！
- en: '![](Images/CH02_F04_Yuen.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F04_Yuen.png)'
- en: Figure 2.4 The generated HTML file content from the docker/whalesay image isan
    ASCII rendering of a cute whale with a speech bubble of greeting passed as a command
    argument. The `port-forward` command allows port 80 of the Pod (HTML) to be accessed
    on port 8080 of the local host.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 从docker/whalesay镜像生成的HTML文件内容是一个可爱的鲸鱼ASCII渲染，其问候语通过命令参数传递。`port-forward`命令允许Pod（HTML）的80端口在本地主机的8080端口上访问。
- en: Exercise 2.1
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.1
- en: Now that your NGINX Pod is running, use the `kubectl` `exec` command to get
    a shell on the running container.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的NGINX Pod正在运行，请使用`kubectl` `exec`命令在运行中的容器上获取一个shell。
- en: HINT The command would be something like `kubectl` `exec` `-it <POD_NAME> --
    /bin/bash`. Poke around in the shell. Run `ls`, `df`, and `ps` `-ef` as well as
    other Linux commands. What happens if you terminate the NGINX process?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：命令可能类似于`kubectl` `exec` `-it <POD_NAME> -- /bin/bash`。在shell中四处探索。运行`ls`、`df`和`ps`
    `-ef`以及其他Linux命令。如果你终止NGINX进程会发生什么？
- en: 'As the final step in this exercise, let’s delete the Pod to free up cluster
    resources. The Pod can be deleted using the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习的最终步骤中，让我们删除Pod以释放集群资源。可以使用以下命令删除Pod：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 2.2 Declarative vs. imperative object management
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 声明式与imperative对象管理
- en: The Kubernetes `kubectl` command-line tool is used to create, update, and manage
    Kubernetes objects and supports imperative commands, imperative object configuration,
    and declarative object configuration.^([6](#pgfId-1076776)) Let’s go through a
    real-world example that demonstrates the difference between an imperative/procedural
    configuration and a declarative configuration in Kubernetes. First, let’s look
    at how kubectl can be used imperatively.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的`kubectl`命令行工具用于创建、更新和管理Kubernetes对象，并支持 imperative 命令、imperative
    对象配置和声明式对象配置。[6](#pgfId-1076776) 让我们通过一个真实世界的示例来了解Kubernetes中imperative/procedural配置与声明式配置之间的区别。首先，让我们看看kubectl如何被imperatively使用。
- en: Declarative vs. imperative Please refer to section 1.3.1 for a detailed explanation
    of declarative versus imperative.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式与imperative 请参阅第1.3.1节，以详细了解声明式与imperative的区别。
- en: In the following example, let’s create a script that will deploy an NGINX service
    with three replicas and some annotations on the deployment.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，让我们创建一个脚本，该脚本将部署一个具有三个副本和一些注释的NGINX服务。
- en: Listing 2.2 Imperative kubectl commands [(imperative-deployment.sh)](https://github.com/gitopsbook/resources/blob/master/chapter-02/imperative-deployment.sh)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2 Imperative kubectl命令 [(imperative-deployment.sh)](https://github.com/gitopsbook/resources/blob/master/chapter-02/imperative-deployment.sh)
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Creates a new deployment object called nginx-imperative
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个名为nginx-imperative的新部署对象
- en: ❷ Scales the nginx-imperative deployment to have three replicas of the Pod
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将nginx-imperative部署扩展到具有三个Pod副本
- en: ❸ Adds an annotation with the key environment and value prod to the nginx-imperative
    deployment
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在nginx-imperative部署中添加了一个带有键环境值prod的注释
- en: ❹ Adds an annotation with the key organization and value sales to the nginx-imperative
    deployment
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在nginx-imperative部署中添加了一个带有关键组织和销售价值的注释
- en: 'Try running the script against your minikube cluster, and check that the deployment
    was created successfully:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在您的minikube集群上运行脚本，并检查部署是否成功创建：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Great! The deployment was created as expected. But now let’s edit our `deployment.sh`
    script to change the value of the `organization` annotation from `sales` to `marketing`
    and then rerun the script:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！部署已按预期创建。但现在让我们编辑我们的`deployment.sh`脚本，将`organization`注释的值从`sales`更改为`marketing`，然后重新运行脚本：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, the new script failed because the deployment and annotations
    already exist. To make it work, we would need to enhance our script with additional
    commands and logic to handle the update case in addition to the creation case.
    Sure, this can be done, but it turns out we don’t have to do all that work because
    kubectl can itself examine the current state of the system and do the right thing
    using declarative object configuration.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，新脚本失败了，因为部署和注释已经存在。为了使其工作，我们需要增强我们的脚本，添加额外的命令和逻辑来处理更新情况，而不仅仅是创建情况。当然，这可以做到，但结果是我们不必做所有这些工作，因为kubectl本身可以检查系统的当前状态，并使用声明式对象配置做正确的事情。
- en: The following manifest defines a deployment identical to the one created by
    our script (except that the deployment’s name is `nginx-declarative`).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下清单定义了一个与我们的脚本创建的部署相同的部署（除了部署的名称是`nginx-declarative`）。
- en: Listing 2.3 Declarative [(http://mng.bz/OEpP)](https://shortener.manning.com/OEpP)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3 声明式 [(http://mng.bz/OEpP)](https://shortener.manning.com/OEpP)
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can use the semi-magical `kubectl` `apply` command to create the `nginx-declarative`
    deployment:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用半魔法般的 `kubectl` `apply` 命令来创建 `nginx-declarative` 部署：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After running the `apply`, we see the `nginx-declarative` deployment resource
    created. But what happens when we run `kubectl` `apply` again?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `apply` 后，我们看到创建了 `nginx-declarative` 部署资源。但当我们再次运行 `kubectl` `apply` 时会发生什么呢？
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice the change in the output message. The second time `kubectl` `apply` was
    run, the program detected that no changes needed to be made and subsequently reported
    that the deployment was unchanged. This is a subtle but critical difference between
    a `kubectl` `create` versus a `kubectl` `apply`. A `kubectl` `create` will fail
    if the resource already exists. The `kubectl` `apply` command first detects whether
    the resource exists and performs a create operation if the object doesn’t exist
    or an update if it already exists.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出消息的变化。第二次运行 `kubectl` `apply` 时，程序检测到不需要进行任何更改，并随后报告部署未更改。这是 `kubectl` `create`
    与 `kubectl` `apply` 之间的一个微妙但关键的区别。如果资源已存在，`kubectl` `create` 将会失败。`kubectl` `apply`
    命令首先检测资源是否存在，如果对象不存在，则执行创建操作；如果对象已存在，则执行更新操作。
- en: 'As with the imperative example, what if we want to change the value of the
    organization annotation from sales to marketing? Let’s edit the declarative-deployment.yaml
    file and change the `metadata.annotations.organization` field from `sales` to
    `marketing`. But before we run `kubectl` `apply` again, let’s run `kubectl` `diff`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与强制性的示例一样，如果我们想将组织注释的值从销售更改为营销怎么办？让我们编辑 `declarative-deployment.yaml` 文件，并将
    `metadata.annotations.organization` 字段从 `sales` 更改为 `marketing`。但在我们再次运行 `kubectl`
    `apply` 之前，让我们先运行 `kubectl` `diff`：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ The value of the organization label was changed from sales to marketing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 组织标签的值已从销售更改为营销。
- en: ❷ The generation of this resource was changed by the system when doing kubectl
    apply.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在执行 kubectl apply 时，系统已更改了此资源的生成方式。
- en: As you can see, `kubectl` `diff` correctly identified that the organization
    was changed from `sales` to `marketing`. We also see that `kubectl` `apply` successfully
    applied the new changes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`kubectl` `diff` 正确识别出组织已从 `sales` 更改为 `marketing`。我们还可以看到 `kubectl` `apply`
    成功应用了新的更改。
- en: 'In this exercise, both the imperative and declarative examples result in a
    deployment resource configured in precisely the same way. And at first glance,
    the imperative approach may appear to be much simpler. It contains only a few
    code lines compared to the declarative deployment spec’s verbosity that is five
    times the script’s size. However, it contains problems that make it a poor choice
    to use in practice:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，强制性和声明性示例都导致以完全相同的方式配置了部署资源。乍一看，强制性的方法可能看起来要简单得多。与声明性部署规范的冗长性相比，它只包含几行代码，而声明性部署规范的冗长性是脚本大小的五倍。然而，它包含了一些问题，使得它在实践中使用时不是一个好的选择：
- en: The code is not idempotent and may have different results if executed more than
    once. If run a second time, an error will be thrown complaining that the deployment
    NGINX already exists. In contrast, the deployment spec is idempotent, meaning
    it can be applied as many times as needed, handling the case where the deployment
    already exists.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码不具有幂等性，如果多次执行可能会得到不同的结果。如果再次运行，将会抛出一个错误，抱怨部署 NGINX 已经存在。相比之下，部署规范是幂等的，这意味着可以根据需要多次应用，处理部署已存在的情况。
- en: It is more difficult to manage changes to the resource over time, especially
    when the difference is subtractive. Suppose you no longer wanted organization
    to be annotated on the deployment. Simply removing the `kubectl` `annotate` command
    from the scripted code would not help since it would do nothing to remove the
    existing deployment’s annotation. A separate operation would be needed to remove
    it. On the other hand, with the declarative approach, you only need to remove
    the annotation line from the spec, and Kubernetes would take care of removing
    the annotation to reflect your desired state.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着时间的推移管理资源更改变得更加困难，尤其是在差异是减法的情况下。假设你不再希望组织被注释在部署上。简单地从脚本代码中移除 `kubectl` `annotate`
    命令并不能解决问题，因为它对删除现有部署的注释没有任何帮助。需要单独的操作来删除它。另一方面，使用声明性方法，你只需从规范中移除注释行，Kubernetes
    就会负责删除注释以反映你希望的状态。
- en: It is more difficult to *understand* changes. If a team member sent a pull request
    modifying the script to do something differently, it would be like any other source
    code review. The reviewer would need to mentally walk through the script’s logic
    to verify the algorithm achieves the desired outcome. There can even be bugs in
    the script. On the other hand, a pull request that changes a declarative deployment
    specification clearly shows the change to the system’s desired state. It is simpler
    to review, as there is no logic to check, only a configuration change.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解变化更为困难。如果一个团队成员发送了一个修改脚本的拉取请求，以执行不同的操作，那么这就像任何其他源代码审查一样。审查者需要心理上遍历脚本的逻辑来验证算法是否实现了预期的结果。脚本中甚至可能存在错误。另一方面，修改声明式部署规范的拉取请求清楚地显示了系统期望状态的变化。审查起来更简单，因为没有逻辑需要检查，只有配置更改。
- en: The code is not atomic, meaning that if one of the four commands in the script
    failed, the system’s state would be partially changed and wouldn’t be in the original
    state, nor would it be in the desired state. With the declarative approach, the
    entire spec is received as a single request, and the system attempts to fulfill
    all aspects of the desired state as a whole.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码不是原子的，这意味着如果脚本中的四个命令之一失败，系统状态将部分更改，既不会回到原始状态，也不会达到期望状态。使用声明式方法，整个规范作为一个单一请求接收，系统尝试作为一个整体实现所有期望状态方面。
- en: As you can imagine, what started as a simple shell script would need to become
    more and more complicated to achieve idempotency. There are dozens of options
    available in the Kubernetes deployment spec. With the scripted approach, if/else
    checks would need to be littered throughout the script to understand the existing
    state and conditionally modify the deployment.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，最初只是一个简单的 shell 脚本，为了实现幂等性，需要变得越来越复杂。Kubernetes 部署规范中有数十个选项可用。使用脚本方法，需要在脚本中散布
    if/else 检查，以了解现有状态并条件性地修改部署。
- en: 2.2.1 How declarative configuration works
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2.1 声明式配置的工作原理
- en: 'As we saw in the previous exercise, declarative configuration management is
    powered by the `kubectl` `apply` command. In contrast with imperative kubectl
    commands, like `scale` and `annotate`, the `kubectl` `apply` command has one parameter,
    the path to the file containing the resource manifest:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的练习中看到的，声明式配置管理是由 `kubectl` `apply` 命令驱动的。与 `scale` 和 `annotate` 这样的命令式
    `kubectl` 命令相比，`kubectl` `apply` 命令有一个参数，即包含资源清单的文件的路径：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The command is responsible for figuring out which changes should be applied
    to the matching resource in the Kubernetes cluster and update the resource using
    the Kubernetes API. It is a critical feature that makes Kubernetes a perfect fit
    for GitOps. Let’s learn more about the logic behind `kubectl` `apply` and understand
    what it can and cannot do. To understand which problems `kubectl` `apply` is solving,
    let’s go through different scenarios using the Deployment resource we created
    earlier.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令负责确定应该应用到 Kubernetes 集群中匹配资源上的哪些更改，并使用 Kubernetes API 更新资源。这是一个关键特性，使得 Kubernetes
    成为 GitOps 的完美选择。让我们更深入地了解 `kubectl` `apply` 背后的逻辑，并了解它能做什么以及不能做什么。为了理解 `kubectl`
    `apply` 解决了哪些问题，让我们通过使用我们之前创建的 Deployment 资源来探讨不同的场景。
- en: The simplest scenario is when the matching resource does not exist in the Kubernetes
    cluster. In this case, kubectl creates a new resource using the manifest stored
    in the specified file.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的情况是当匹配的资源不存在于 Kubernetes 集群中。在这种情况下，kubectl 会使用存储在指定文件中的清单创建一个新的资源。
- en: 'If the matching resource exists, why doesn’t kubectl replace it? The answer
    is obvious if you look at the complete manifest resource using the `kubectl` `get`
    command. Following is a partial listing of the Deployment resource that was created
    in the example. Some parts of the manifest have been omitted for clarity (indicated
    with ellipses):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匹配的资源存在，为什么 kubectl 不替换它？如果你使用 `kubectl` `get` 命令查看完整的清单资源，答案就显而易见了。以下是示例中创建的
    Deployment 资源的部分列表。为了清晰起见，清单的一些部分已被省略（用省略号表示）：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you may have noticed, a live resource manifest includes all the fields specified
    in the file plus dozens of new fields such as additional metadata, the `status`
    field, and other fields in the resource spec. All these additional fields are
    populated by the Deployment controller and contain important information about
    the resource’s running state. The controller populates information about resource
    state in the `status` field and applies default values of all unspecified optional
    fields, such as `revisionHistoryLimit` and `strategy`. To preserve this information,
    `kubectl` `apply` merges the manifest from the specified file and the live resource
    manifest. As a result, the command updates only fields specified in the file,
    keeping everything else untouched. So if we decide to scale down the deployment
    and change the `replicas` field to `1`, then kubectl changes only that field in
    the live resource and saves it back to Kubernetes using an update API.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，实时资源清单包括文件中指定的所有字段以及数十个新字段，如额外的元数据、`status`字段和资源规范中的其他字段。所有这些附加字段都是由Deployment控制器填充的，并包含有关资源运行状态的重要信息。控制器在`status`字段中填充有关资源状态的信息，并为所有未指定的可选字段应用默认值，例如`revisionHistoryLimit`和`strategy`。为了保留这些信息，`kubectl
    apply`合并了指定文件和实时资源清单。因此，该命令只更新文件中指定的字段，保持其他一切不变。所以如果我们决定缩小部署并将`replicas`字段更改为`1`，那么kubectl只更改实时资源中的该字段，并使用更新API将其保存回Kubernetes。
- en: In real life, we don’t want to control all possible fields that influence resource
    behavior in a declarative way. It makes sense to leave some room for imperativeness
    and skip fields that should be changed dynamically. The `replicas` field of the
    Deployment resource is a perfect example. Instead of hardcoding the number of
    replicas you want to use, the Horizontal Pod Autoscaler can be used to dynamically
    scale up or scale down your application based on load.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，我们不想以声明性方式控制所有可能影响资源行为的字段。留出一些空间用于强制性，并跳过那些应该动态更改的字段是有意义的。Deployment资源的`replicas`字段是一个完美的例子。您可以使用水平Pod自动伸缩器动态地根据负载扩展或缩小应用程序，而不是硬编码您想要使用的副本数量。
- en: Horizontal Pod Autoscaler The Horizontal Pod Autoscaler automatically scales
    the number of Pods in a replication controller, deployment, or replica set based
    on observed CPU utilization (or, with custom metrics support, on some other application-provided
    metric).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 水平Pod自动伸缩器水平Pod自动伸缩器根据观察到的CPU利用率（或，在自定义度量支持的情况下，根据某些其他应用程序提供的度量）自动调整副本控制器、部署或副本集中的Pod数量。
- en: Let’s go ahead and remove the `replicas` field from the Deployment manifest.
    After applying this change, the `replicas` field is reset to the default value
    of one replica. But wait! The `kubectl` `apply` command updates only those fields
    that are specified in the file and ignores the rest. How does it know that the
    `replicas` field was deleted? The additional information that allows kubectl to
    handle the delete use case is hidden in an annotation of the live resource. Every
    time the `kubectl` `apply` command updates a resource, it saves the input manifest
    in the `kubectl.kubernetes.io/last-applied-configuration` annotation. So when
    the command is executed the next time, it retrieves the most recently applied
    manifest from the annotation, representing the common ancestor of the new desired
    manifest and live resource manifest. This allows kubectl to execute a three-way
    diff/merge and properly handle the case where some fields are removed from the
    resource manifest.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，从Deployment清单中移除`replicas`字段。应用这个更改后，`replicas`字段将重置为默认值一个副本。但是等等！`kubectl
    apply`命令只更新文件中指定的字段，并忽略其他字段。它是如何知道`replicas`字段已被删除的呢？允许kubectl处理删除用例的附加信息隐藏在实时资源的注解中。每次`kubectl
    apply`命令更新资源时，它都会将输入清单保存到`kubectl.kubernetes.io/last-applied-configuration`注解中。因此，当命令下次执行时，它会从注解中检索最近应用的清单，这代表了新期望清单和实时资源清单的共同祖先。这允许kubectl执行三次合并/合并，并正确处理从资源清单中删除某些字段的情况。
- en: Three-way merge A three-way merge is a merge algorithm that automatically analyzes
    differences between two files while also considering the origin or the common
    ancestor of both files.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 三向合并三向合并是一种合并算法，它自动分析两个文件之间的差异，同时考虑两个文件的起源或共同祖先。
- en: Finally, let’s discuss the situations where `kubectl apply` might not work as
    expected and should be used carefully.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们讨论一下`kubectl apply`可能无法按预期工作的情况，以及应该谨慎使用它的情况。
- en: First off, you typically should not mix imperative commands, such as `kubectl
    edit` or `kubectl` `scale`, with declarative resource management. This will make
    the current state not match the `last-applied-configuration` annotation and will
    defeat the merge algorithm kubectl uses to determine deleted fields. The typical
    scenario is when you experiment with the resource using `kubectl edit` and want
    to roll back changes by applying the original manifests stored in files. Unfortunately,
    it might not work since changes made by the `kubectl` `edit` command are not stored
    anywhere. For example, if you temporarily add the `resource` `limits` field to
    the deployment, the `kubectl apply` won’t remove it since the `limits` field is
    not mentioned in the `last-applied-configuration` annotation or the manifest from
    the file. The `kubectl` `replace` command similarly ignores the `last-applied-configuration`
    annotation and removes that annotation altogether after applying the changes.
    So if you make any changes imperatively, you should be ready to undo the changes
    using imperative commands before continuing with declarative configuration.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通常你不应该将命令式命令，如`kubectl edit`或`kubectl scale`，与声明式资源管理混合使用。这会导致当前状态与`last-applied-configuration`注解不匹配，并会破坏kubectl用来确定已删除字段的合并算法。典型的场景是当你使用`kubectl
    edit`对资源进行实验，并希望通过应用存储在文件中的原始清单来回滚更改。不幸的是，这可能不起作用，因为`kubectl edit`命令所做的更改并未存储在任何地方。例如，如果你临时将`resource`
    `limits`字段添加到部署中，`kubectl apply`不会移除它，因为`limits`字段在`last-applied-configuration`注解或文件中的清单中都没有提到。同样，`kubectl
    replace`命令也会忽略`last-applied-configuration`注解，并在应用更改后完全删除该注解。因此，如果你以命令式方式做出任何更改，你应该准备好在继续声明式配置之前使用命令式命令来撤销更改。
- en: You should also be careful when you want to stop managing fields declaratively.
    A typical example of this problem is adding the Horizontal Pod Autoscaler to manage
    scaling the number of replicas for an existing deployment. Typically, before introducing
    the Horizontal Pod Autoscaler, the number of deployment replicas is managed declaratively.
    To pass control of the `replicas` field over to the Horizontal Pod Autoscaler,
    the `replicas` field must first be deleted from the file that contains the Deployment
    manifest. This is so the next `kubectl` `apply` does not override the `replicas`
    value set by the Horizontal Pod Autoscaler. However, don’t forget that the `replicas`
    field might also be stored in the `last-applied-configuration` annotation. If
    that is the case, the missing `replicas` field in the manifest file will be treated
    as a field deletion, so whenever `kubectl` `apply` is run, the `replicas` value
    set imperatively by the Horizontal Pod Autoscaler will be removed from the live
    Deployment. The Deployment will scale down to the default of one replica.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要停止声明式管理字段时，也应该小心。这个问题的一个典型例子是将水平Pod自动伸缩器添加到管理现有部署副本数量的缩放。通常，在引入水平Pod自动伸缩器之前，部署副本的数量是声明式管理的。要将`replicas`字段的控制权交给水平Pod自动伸缩器，必须首先从包含部署清单的文件中删除`replicas`字段。这样做是为了确保下一次`kubectl
    apply`不会覆盖水平Pod自动伸缩器设置的`replicas`值。然而，不要忘记`replicas`字段可能也存储在`last-applied-configuration`注解中。如果是这样，清单文件中缺失的`replicas`字段将被视为字段删除，因此每次运行`kubectl
    apply`时，水平Pod自动伸缩器以命令式方式设置的`replicas`值将被从实时部署中移除。部署将缩放到默认的单个副本。
- en: 'In this section, we covered the different mechanisms for managing Kubernetes
    objects: imperative and declarative. You also learned a little about the internals
    of kubectl and how it identifies changes to apply to live objects. But at this
    point, you may be wondering what all this has to do with GitOps. The answer is
    simple: everything! Understanding how kubectl and Kubernetes manages changes to
    live objects is critical for understanding how the GitOps tools discussed in later
    chapters identify if the Git repository holding the Kubernetes configuration is
    in sync with the live state and how it tracks and applies changes.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了管理Kubernetes对象的不同机制：命令式和声明式。你还了解了一些关于kubectl内部结构和它如何识别应用于实时对象的变化。但在此阶段，你可能想知道所有这些与GitOps有什么关系。答案是简单的：一切！理解kubectl和Kubernetes如何管理实时对象的变化对于理解后续章节中讨论的GitOps工具如何识别包含Kubernetes配置的Git仓库是否与实时状态同步，以及它如何跟踪和应用更改至关重要。
- en: 2.3 Controller architecture
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 控制器架构
- en: 'So far, we’ve learned about Kubernetes’ declarative nature and the benefits
    it provides. Let’s talk about what is behind each Kubernetes resource: the controller
    architecture. Understanding how controllers work will help us use Kubernetes more
    efficiently and understand how it can be extended.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了Kubernetes的声明式特性和它提供的优势。让我们来谈谈每个Kubernetes资源背后的内容：控制器架构。了解控制器的工作原理将帮助我们更有效地使用Kubernetes，并理解它如何扩展。
- en: Controllers are brains that understand what a particular kind of resource manifest
    means and execute the necessary work to make the system’s actual state match the
    desired state as described by the manifest. Each controller is typically responsible
    for only one resource type. Through listening to the API server events related
    to the resource type being managed, the controller continuously watches for changes
    to the resource’s configuration and performs the necessary work to move the current
    state toward the desired state. An essential feature of Kubernetes controllers
    is the ability to delegate work to other controllers. This layered architecture
    is powerful and allows you to reuse functionality provided by different resource
    types effectively. Let’s consider a concrete example to understand the delegation
    concept better.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是理解特定类型资源清单含义的大脑，并执行必要的任务以使系统的实际状态与清单中描述的期望状态相匹配。每个控制器通常只负责一种资源类型。通过监听与被管理资源类型相关的API服务器事件，控制器持续监视资源配置的变化，并执行必要的任务以将当前状态移动到期望状态。Kubernetes控制器的一个基本特性是能够将工作委派给其他控制器。这种分层架构非常强大，并允许你有效地重用不同资源类型提供的功能。让我们通过一个具体的例子来更好地理解委派的概念。
- en: 2.3.1 Controller delegation
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 控制器委派
- en: The Deployment, ReplicaSet, and Pod resources perfectly demonstrate how delegation
    empowers Kubernetes. The Pod provides the ability to run one or more containers
    that have requested resources on a node in the cluster. This allows the Pod controller
    to focus simply on running an instance of an application and abstract the logic
    related to infrastructure provisioning, scaling up and down, networking, and other
    complicated details, leaving those to other controllers. Although the Pod resource
    provides many features, it is still not enough to run an application in production.
    We need to run multiple instances of the same application (for resiliency and
    performance), which means we need multiple Pods. The ReplicaSet controller solves
    this problem. Instead of directly managing multiple containers, it orchestrates
    multiple Pods and delegates the container orchestration to the Pod resource. Similarly,
    the Deployment controller leverages functionality provided by ReplicaSets to implement
    various deployment strategies such as rolling updates.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment、ReplicaSet和Pod资源完美地展示了委派如何赋予Kubernetes能力。Pod提供了在集群中的节点上运行一个或多个请求资源的容器的功能。这使得Pod控制器可以专注于简单地运行一个应用程序实例，并抽象出与基础设施配置、扩展和缩减、网络以及其他复杂细节相关的逻辑，将这些留给其他控制器。尽管Pod资源提供了许多功能，但它仍然不足以在生产环境中运行应用程序。我们需要运行同一应用程序的多个实例（为了弹性和性能），这意味着我们需要多个Pod。ReplicaSet控制器解决了这个问题。它不是直接管理多个容器，而是编排多个Pod，并将容器编排委派给Pod资源。同样，Deployment控制器利用ReplicaSet提供的功能来实现各种部署策略，如滚动更新。
- en: '![](Images/CH02_F05_Yuen.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 Kubernetes资源分层](Images/CH02_F05_Yuen.png)'
- en: Figure 2.5 Kubernetes allows for a resource hierarchy. Higher-level resources
    providing additional functionality, such as ReplicaSets and Deployments, can manage
    other higher-level resources or primary resources, such as Pods. This is implemented
    through a series of controllers, each managing events related to the resources
    it controls.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 Kubernetes允许资源分层。提供额外功能的高级资源，如ReplicaSets和Deployments，可以管理其他高级资源或基本资源，如Pods。这是通过一系列控制器实现的，每个控制器管理与其控制的资源相关的事件。
- en: Controller delegation benefit With controller delegation, Kubernetes functionality
    can be easily extended to support new capabilities. For example, services that
    are not backward-compatible can only be deployed with a blue/green strategy (not
    rolling updates). Controller delegation allows a new controller to be rewritten
    to support blue/green deployment and still leverage the Deployment controller
    functionality through delegation without reimplementing the Deployment controller’s
    core functionality.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器委托的好处 通过控制器委托，Kubernetes 功能可以轻松扩展以支持新功能。例如，不向后兼容的服务只能使用蓝/绿策略（不是滚动更新）进行部署。控制器委托允许重新编写新的控制器以支持蓝/绿部署，并通过委托仍然可以利用
    Deployment 控制器的功能，而无需重新实现 Deployment 控制器的核心功能。
- en: So as you can see from this example, controller delegation allows Kubernetes
    to build progressively more complex resources from simple ones.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如您可以从这个例子中看到的那样，控制器委托允许 Kubernetes 从简单的资源逐步构建更复杂的资源。
- en: 2.3.2 Controller pattern
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 控制器模式
- en: Although all controllers have different responsibilities, the implementation
    of each controller follows the same simple pattern. Each controller runs an infinite
    loop, and every iteration reconciles the desired and the actual state of the cluster
    resources it is responsible for. During reconciliation, the controller is looking
    for differences between the actual and desired states and making the changes necessary
    to move the current state towards the desired state.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有控制器都有不同的职责，但每个控制器的实现都遵循相同的简单模式。每个控制器运行一个无限循环，并且每次迭代都会协调其负责的集群资源的所需状态和实际状态。在协调过程中，控制器正在寻找实际状态和所需状态之间的差异，并做出必要的更改，以将当前状态移动到所需状态。
- en: The desired state is represented by the `spec` field of the resource manifest.
    The question is, how does the controller know about the actual state? This information
    is available in the `status` field. After every successful reconciliation, the
    controller updates the `status` field. The `status` field provides information
    about cluster state to end users and enables the work of higher-level controllers.
    Figure 2.6 demonstrates the reconciliation loop.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所需状态由资源清单的 `spec` 字段表示。问题是，控制器如何知道实际状态？这个信息在 `status` 字段中可用。每次成功协调后，控制器都会更新
    `status` 字段。`status` 字段为最终用户提供有关集群状态的信息，并使高级控制器的操作成为可能。图 2.6 展示了协调循环。
- en: '![](Images/CH02_F06_Yuen.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F06_Yuen.png)'
- en: Figure 2.6 A controller operates in a continuous reconciliation loop where it
    attempts to converge the desired state as defined in the spec with the current
    state. Changes and updates to the resource are reported by updating the resource
    status. The controller may delegate work to other Kubernetes controllers or perform
    other operations, such as managing external resources using the cloud provider’s
    API.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 一个控制器在一个连续的协调循环中运行，它试图将 `spec` 中定义的所需状态与当前状态收敛。通过更新资源状态来报告资源的更改和更新。控制器可能将工作委托给其他
    Kubernetes 控制器或执行其他操作，例如使用云提供商的 API 管理外部资源。
- en: Controllers vs. operators
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器与 operators 的比较
- en: Two terms that are often confused are *operator* and *controller*. In this book,
    the term *GitOps operator* is used to describe continuous delivery tools instead
    of *GitOps controller*. The reason for this is we are representing a specific
    type of controller that is application and domain-specific.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 经常被混淆的两个术语是 *operator* 和 *controller*。在这本书中，术语 *GitOps operator* 用于描述持续交付工具，而不是
    *GitOps controller*。这样做的原因是我们代表了一种特定的控制器，这种控制器是针对应用程序和特定领域的。
- en: Kubernetes operators A *Kubernetes operator* is an application-specific controller
    that extends the Kubernetes API to create, configure, and manage instances of
    complex stateful applications on behalf of a Kubernetes user. It builds upon the
    primary Kubernetes resource and controller concepts and includes domain or application-specific
    knowledge to automate everyday tasks.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes operators 一个 *Kubernetes operator* 是一个特定于应用程序的控制器，它扩展了 Kubernetes
    API，代表 Kubernetes 用户创建、配置和管理复杂有状态应用程序的实例。它建立在主要的 Kubernetes 资源和控制概念之上，并包括特定于领域或应用程序的知识，以自动化日常任务。
- en: The terms *operator* and *controller* are often confused since they are sometimes
    used interchangeably, and the line between the two is often blurred. However,
    another way to think about it is that the term *operator* is used to describe
    application-specific controllers. All operators use the controller pattern, but
    not all controllers are operators. Generally speaking, controllers tend to manage
    lower-level, reusable building-block resources, whereas operators operate at a
    higher level and are application-specific. Some examples of controllers are all
    of the built-in controllers that manage Kubernetes native types (Deployments,
    Jobs, Ingresses, and so on), as well as third-party controllers such as cert-manager
    (which provisions and manages TLS certificates) and the Argo Workflow Controller,
    which introduces a new job-like workflow resource in the cluster. An example of
    an operator is Prometheus, which manages Prometheus database installations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*操作符*和*控制器*经常被混淆，因为它们有时可以互换使用，两者之间的界限通常模糊不清。然而，另一种思考方式是，术语*操作符*用于描述特定应用的控制器。所有操作符都使用控制器模式，但并非所有控制器都是操作符。一般来说，控制器倾向于管理较低级别的、可重用的构建块资源，而操作符在更高层次上运行，且针对特定应用。控制器的一些例子包括所有管理
    Kubernetes 原生类型（如部署、作业、入口等）的内置控制器，以及第三方控制器，如 cert-manager（提供和管理 TLS 证书）和 Argo
    工作流控制器，后者在集群中引入了一种新的类似作业的工作流资源。操作符的一个例子是 Prometheus，它管理 Prometheus 数据库安装。
- en: 2.3.3 NGINX operator
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 NGINX 操作符
- en: 'After learning about the controller fundamentals and the differences between
    controllers and operators, we are ready to implement an operator! The sample operator
    will solve a real-life task: managing a suite of NGINX servers with preconfigured
    static content. The operator will allow the user to specify a list of NGINX servers
    and configure static files mounted on each server. The task is not trivial and
    demonstrates the flexibility and power of Kubernetes.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了控制器基础知识和控制器与操作符之间的区别之后，我们准备实现一个操作符！这个示例操作符将解决一个现实生活中的任务：管理一组预配置静态内容的 NGINX
    服务器。操作符将允许用户指定一组 NGINX 服务器并配置每个服务器上挂载的静态文件。这项任务并不简单，展示了 Kubernetes 的灵活性和强大功能。
- en: Design
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 设计
- en: As mentioned earlier in this chapter, Kubernetes’ architecture allows you to
    leverage an existing controller’s functionality through delegation. Our NGINX
    controller is going to leverage Deployment resources to delegate the NGINX deployment
    task.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，Kubernetes 的架构允许您通过委派利用现有控制器的功能。我们的 NGINX 控制器将利用 Deployment 资源来委派 NGINX
    部署任务。
- en: The next question is which resource should be used to configure the list of
    servers and customized static content. The most appropriate existing resource
    is the ConfigMap. According to the official Kubernetes documentation, the ConfigMap
    is “an API object used to store non-confidential data in key-value pairs.”^([7](#pgfId-1077030))
    The ConfigMap can be consumed as environment variables, command-line arguments,
    or config files in a Volume. The controller will create a Deployment for each
    ConfigMap and mount the ConfigMap data into the default NGINX static website directory.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的问题是应该使用哪种资源来配置服务器列表和自定义静态内容。最合适的现有资源是 ConfigMap。根据官方 Kubernetes 文档，ConfigMap
    是“一个用于以键值对形式存储非机密数据的 API 对象。”^([7](#pgfId-1077030)) ConfigMap 可以作为环境变量、命令行参数或卷中的配置文件来使用。控制器将为每个
    ConfigMap 创建一个 Deployment，并将 ConfigMap 数据挂载到默认的 NGINX 静态网站目录中。
- en: Implementation
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 实现
- en: 'Once we’ve decided on the design of the main building blocks, it is time to
    write some code. Most Kubernetes-related projects, including Kubernetes itself,
    are implemented using Go. However, Kubernetes controllers can be implemented using
    any language, including Java, C++, or even JavaScript. For the sake of simplicity,
    we are going to use a language that is most likely familiar to you: the Bash scripting
    language.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们决定了主要构建块的设计，就是时候编写一些代码了。大多数与 Kubernetes 相关的项目，包括 Kubernetes 本身，都是使用 Go 语言实现的。然而，Kubernetes
    控制器可以使用任何语言实现，包括 Java、C++，甚至是 JavaScript。为了简化，我们将使用您可能最熟悉的语言：Bash 脚本语言。
- en: 'In section 2.3.2 we mentioned that each controller maintains an infinite loop
    and continuously reconciles the desired and actual state. In our example, the
    desired state is represented by the list of ConfigMaps. The most efficient way
    to loop through every ConfigMap change is using the Kubernetes `watch` API. The
    `watch` feature is provided by the Kubernetes API for most resource types and
    allows the caller to be notified when a resource is created, modified, or deleted.
    The kubectl utility allows watching for resource changes using the `get` command
    with the `--watch` flag. The `--output-watch-events` command instructs kubectl
    to output the change type, which takes one of the following values: `ADDED`, `MODIFIED`,
    or `DELETED`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.3.2 节中，我们提到每个控制器都维护一个无限循环，并持续地协调期望状态和实际状态。在我们的示例中，期望状态由 ConfigMap 的列表表示。遍历每个
    ConfigMap 变化的最高效方式是使用 Kubernetes 的 `watch` API。`watch` 功能由 Kubernetes API 为大多数资源类型提供，允许调用者在资源被创建、修改或删除时收到通知。kubectl
    工具允许使用带有 `--watch` 标志的 `get` 命令来监视资源变化。`--output-watch-events` 命令指示 kubectl 输出更改类型，它可以是以下值之一：`ADDED`、`MODIFIED`
    或 `DELETED`。
- en: '![](Images/CH02_F07_Yuen.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F07_Yuen.png)'
- en: Figure 2.7 In the NGINX operator design, a ConfigMap is created containing the
    data to be served by NGINX. The NGINX operator creates a Deployment for each ConfigMap.
    Additional NGINX Deployments can be created simply by creating a ConfigMap with
    the web page data.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 在 NGINX 操作符设计中，创建了一个包含 NGINX 将要提供的数据的 ConfigMap。NGINX 操作符为每个 ConfigMap
    创建一个 Deployment。只需创建一个包含网页数据的 ConfigMap，就可以简单地创建额外的 NGINX 部署。
- en: Kubectl version Ensure that you are using the latest version of kubectl for
    this tutorial (version 1.16 or later). The `--output-watch-events` option was
    added relatively recently.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl 版本 确保您在本教程中使用 kubectl 的最新版本（版本 1.16 或更高版本）。`--output-watch-events` 选项是相对较新添加的。
- en: Listing 2.4 Sample ConfigMap ([http://mng.bz/GxRN](http://mng.bz/GxRN))
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 示例 ConfigMap ([http://mng.bz/GxRN](http://mng.bz/GxRN))
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In one window, run the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个窗口中，运行以下命令：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In another terminal window, run `kubectl apply -f sample.yaml` to create the
    sample ConfigMap. Notice the new output in the window running the `kubectl --watch`
    command. Now run `kubectl` `delete` `-f` `sample.yaml`. You should now see a `DELETED`
    event appear:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，运行 `kubectl apply -f sample.yaml` 以创建示例 ConfigMap。注意运行 `kubectl --watch`
    命令的窗口中的新输出。现在运行 `kubectl delete -f sample.yaml`。现在您应该看到一个 `DELETED` 事件出现：
- en: '[PRE17]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After running this experiment manually, you should be able to see how we can
    write our NGINX operator as a Bash script.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 手动运行此实验后，您应该能够看到我们如何将 NGINX 操作符编写为 Bash 脚本。
- en: The `kubectl` `get` `--watch` command outputs a new line every time a ConfigMap
    resource is created, changed, or deleted. The script will consume the output of
    `kubectl` `get` `--watch` and either create a new Deployment or delete a Deployment
    depending on the output ConfigMap event type. Without further delay, the full
    operator implementation is shown in the following code listing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl get --watch` 命令在创建、更改或删除 ConfigMap 资源时输出新行。脚本将消耗 `kubectl get --watch`
    的输出，并根据输出 ConfigMap 事件类型创建或删除新的 Deployment。现在，不拖延，完整的操作符实现如下代码所示。'
- en: Listing 2.5 NGINX controller [(http://mng.bz/zxmZ)](https://shortener.manning.com/zxmZ)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.5 NGINX 控制器 [(http://mng.bz/zxmZ)](https://shortener.manning.com/zxmZ)
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ This kubectl command outputs all the events that occur for configmap objects.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此 kubectl 命令输出 configmap 对象发生的所有事件。
- en: ❷ The output from kubectl is processed by this infinite loop.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ kubectl 的输出由这个无限循环处理。
- en: ❸ The name of the configmap and the event type are parsed from the kubectl output.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从 kubectl 输出中解析出 configmap 的名称和事件类型。
- en: ❹ If the configmap has been ADDED or MODIFIED, apply the NGINX deployment manifest
    (everything between the two EOF tags) for that configmap.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果 configmap 已被添加或修改，则应用该 configmap 的 NGINX 部署清单（两个 EOF 标签之间的所有内容）。
- en: ❺ If the configmap has been DELETED, delete the NGINX deployment for that configmap.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果 configmap 已被删除，则删除该 configmap 的 NGINX 部署。
- en: Testing
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 测试
- en: 'Now that the implementation is done, we are ready to test our controller. In
    real life, the controller is packaged into a Docker image and runs inside the
    cluster. It is OK to run the controller outside of the cluster for testing purposes,
    which is precisely what we are going to do. Using instructions from appendix A,
    start a minikube cluster, save the controller code into a file called controller.sh,
    and start it using this Bash command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在实施完成，我们准备测试我们的控制器。在现实生活中，控制器被打包成一个Docker镜像，并在集群内部运行。对于测试目的，在集群外部运行控制器是可以接受的，这正是我们即将要做的事情。使用附录A中的说明，启动一个minikube集群，将控制器代码保存到名为controller.sh的文件中，并使用以下Bash命令启动它：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note This example requires kubectl version 1.16 or later.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：此示例需要kubectl版本1.16或更高版本。
- en: The controller is running and waiting for the ConfigMap. Let’s create one. Refer
    to listing 2.4 for the manifest of the ConfigMap.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器正在运行并等待ConfigMap。让我们创建一个。请参阅2.4节中的ConfigMap的清单。
- en: 'We create the ConfigMap using the `kubectl apply` command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`kubectl apply`命令创建ConfigMap：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The controller notices the change and creates an instance of Deployment using
    the `kubectl apply` command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器注意到变化，并使用`kubectl apply`命令创建一个Deployment实例：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Exercise 2.2
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.2
- en: Try accessing the NGINX controller by forwarding port 80 locally to make sure
    the controller works as expected. Try to delete or modify the ConfigMap and see
    how the controller reacts accordingly.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过在本地转发端口80来访问NGINX控制器，以确保控制器按预期工作。尝试删除或修改ConfigMap，看看控制器如何相应地做出反应。
- en: Exercise 2.3
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.3
- en: Create additional ConfigMaps to launch an NGINX server for each member of your
    family that displays `Hello` `<name>!`. Also, don’t forget to call/text/Snapchat
    them IRL.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 创建额外的ConfigMap，为您的家庭成员中的每个人启动一个显示`Hello` `<name>!`的NGINX服务器。同时，别忘了在现实生活中给他们打电话/发短信/Snapchat。
- en: Exercise 2.4
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.4
- en: 'Write a Dockerfile to package the NGINX controller. Deploy it to your test
    Kubernetes cluster. Hint: You will need to create RBAC resources for the operator.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Dockerfile来打包NGINX控制器。将其部署到您的测试Kubernetes集群中。提示：您需要为操作员创建RBAC资源。
- en: 2.4 Kubernetes + GitOps
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 Kubernetes + GitOps
- en: GitOps assumes that every piece of infrastructure is represented as a file stored
    in a revision control system, and there is an automated process that seamlessly
    applies changes to the application runtime environment. Without a system like
    Kubernetes, this is, unfortunately, easier said than done. There are too many
    things to worry about and many different technologies that do not work well together.
    These two assumptions often become an unsolvable obstacle that prevents the implementation
    of an efficient infrastructure-as-code process.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps假设每个基础设施组件都表示为一个存储在版本控制系统中的文件，并且存在一个自动化的过程，可以无缝地将更改应用到应用程序的运行时环境中。如果没有像Kubernetes这样的系统，这很遗憾，说起来容易做起来难。有太多的事情需要担心，还有很多不同的技术不能很好地协同工作。这两个假设通常成为无法解决的障碍，阻碍了高效基础设施即代码过程的实施。
- en: Kubernetes has dramatically improved the situation. As Kubernetes gained more
    and more adoption, the idea of infrastructure as code (IaC) has evolved, which
    resulted in the creation of new tooling that implements GitOps. So what is so
    special about Kubernetes, and how and why did it lead to the rise of GitOps?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes显著改善了这种情况。随着Kubernetes被越来越广泛地采用，基础设施即代码（IaC）的概念也随之发展，这导致了新的工具的创建，这些工具实现了GitOps。那么Kubernetes有什么特别之处，它是如何以及为什么导致了GitOps的兴起？
- en: Kubernetes enables GitOps by fully embracing declarative APIs as its primary
    mode of operation and providing the controller patterns and backend framework
    necessary to implement those APIs. The system was designed with the principles
    of declarative specifications and eventual consistency and convergence from its
    inception.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes通过完全采用声明式API作为其主要操作模式，并提供实现这些API所需的控制器模式和后端框架，从而实现了GitOps。该系统从一开始就按照声明性规范和最终一致性以及收敛的原则进行设计。
- en: Eventual consistency *Eventual consistency* is a consistency model used in distributed
    computing to achieve high availability that informally guarantees that, if no
    new updates are made to a given data item, eventually all accesses to that item
    will return the last updated value.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最终一致性*最终一致性*是分布式计算中用于实现高可用性的一个一致性模型，非正式地保证，如果没有对给定数据项进行新的更新，最终所有对该项的访问都将返回最后更新的值。
- en: This decision is what led to the prominence of GitOps in Kubernetes. Unlike
    traditional systems, in Kubernetes there are almost no APIs that can modify only
    a subset of some existing resources. For example, there is no API (and never will
    be) that changes only the container image of a Pod. Instead, the Kubernetes API
    server expects all API requests to provide a complete manifest of the resource
    to the API server. It was an intentional decision not to give any convenience
    APIs to users. As a result, Kubernetes users are essentially forced into a declarative
    mode of operation, which leads these same users to the need to store these declarative
    specifications somewhere. Git became the natural medium to store these specifications,
    and GitOps then became the natural delivery tool to deploy these manifests from
    Git.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个决策导致了 GitOps 在 Kubernetes 中的突出地位。与传统的系统不同，在 Kubernetes 中几乎没有只能修改某些现有资源子集的
    API。例如，没有（也永远不会）只更改 Pod 容器镜像的 API。相反，Kubernetes API 服务器期望所有 API 请求向 API 服务器提供资源的完整清单。这是一个有意向用户不提供任何便利
    API 的决策。因此，Kubernetes 用户实际上被迫进入声明性操作模式，这导致这些用户需要将这些声明性规范存储在某个地方。Git 成为了存储这些规范的自然介质，GitOps
    然后成为了从 Git 部署这些清单的自然交付工具。
- en: 2.5 Getting started with CI/CD
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 开始使用 CI/CD
- en: Now that you’ve learned the basic architecture and principles of a Kubernetes
    controller and how Kubernetes is a good fit for GitOps, it’s time to implement
    your own GitOps operator. In this tutorial, we will first be creating a rudimentary
    GitOps operator to drive continuous delivery. This is followed by an example of
    how you would integrate continuous integration (CI) with a GitOps-based continuous
    delivery (CD) solution.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经学习了 Kubernetes 控制器的基本架构和原则，以及 Kubernetes 如何适合 GitOps，现在是时候实现自己的 GitOps
    操作符了。在本教程中，我们将首先创建一个基本的 GitOps 操作符来驱动持续交付。之后，我们将举例说明如何将持续集成（CI）与基于 GitOps 的持续交付（CD）解决方案集成。
- en: 2.5.1 Basic GitOps operator
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 基本GitOps操作符
- en: To implement your own GitOps operator, a continuously running control loop needs
    to be implemented that performs the three steps illustrated in figure 2.8.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现自己的 GitOps 操作符，需要实现一个持续运行的控制循环，该循环执行图 2.8 中展示的三个步骤。
- en: '![](Images/CH02_F08_Yuen.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH02_F08_Yuen.png)'
- en: Figure 2.8 The GitOps reconciliation loop begins by cloning the repository to
    fetch the configuration repository’s latest version into local storage. Next,
    the manifest discovery step walks the cloned repository’s filesystem, looking
    for any Kubernetes manifests to apply to the cluster. Last, the `kubectl apply`
    step performs the actual deployment by applying all of the discovered manifests
    to the cluster.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 GitOps 协调循环首先通过克隆仓库来获取配置仓库的最新版本到本地存储。接下来，清单发现步骤遍历克隆仓库的文件系统，寻找任何要应用到集群中的
    Kubernetes 清单。最后，`kubectl apply` 步骤通过将所有发现的清单应用到集群来执行实际的部署。
- en: While this control loop could be implemented in any number of ways, most simply,
    it could be implemented as a Kubernetes CronJob.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个控制循环可以用多种方式实现，但最简单的方式是将其实现为一个 Kubernetes CronJob。
- en: Listing 2.6 CronJob GitOps operator [(http://mng.bz/0myz)](https://shortener.manning.com/0myz)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 CronJob GitOps 操作符 [(http://mng.bz/0myz)](https://shortener.manning.com/0myz)
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Executes the GitOps reconciliation loop every five minutes
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每 5 分钟执行一次 GitOps 协调循环
- en: ❷ Prevents concurrent executions of the job
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 防止作业并发执行
- en: ❸ Doesn’t retry failed jobs since this is a recurring CronJob; retries happen
    naturally
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 由于这是一个重复的 CronJob，不会重试失败的作业；重试会自然发生
- en: ❹ Doesn’t restart the container when it completes
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 容器完成时不会重新启动
- en: ❺ A Kubernetes Service account that has sufficient privileges to create and
    modify objects into the cluster
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 一个具有足够权限在集群中创建和修改对象的 Kubernetes 服务账户
- en: ❻ The Docker image that has the git, find, and kubectl binaries preloaded into
    it
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 包含预装了 git、find 和 kubectl 二进制文件的 Docker 镜像
- en: ❼ The command and args fields contain the actual logic of the GitOps reconciliation
    loop.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 命令和参数字段包含 GitOps 协调循环的实际逻辑。
- en: The job template spec contains the meat of the operator logic. The CronJob `gitops-cron`
    contains the control loop logic that deploys manifests from Git to the cluster
    on a regularly scheduled basis. The `schedule` field is a `cron` expression, which
    in this example will result in the job being executed every five minutes. Setting
    the `concurrencyPolicy` to `Forbid` prevents concurrent executions of the job,
    allowing the current execution to complete before attempting to start a second.
    Note that this will only happen if a single execution takes longer than five minutes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 作业模板规范包含了操作逻辑的核心。CronJob `gitops-cron`包含了控制循环逻辑，定期从Git部署清单到集群。`schedule`字段是一个`cron`表达式，在这个例子中，它将导致作业每五分钟执行一次。将`concurrencyPolicy`设置为`Forbid`可以防止作业的并发执行，允许当前执行完成后再尝试启动第二个。请注意，这只会发生在单个执行时间超过五分钟的情况下。
- en: The `jobTemplate` is a Kubernetes Job template spec. The Job template spec contains
    a Pod template spec (jobTemplate.spec.template.spec), which is the same spec that
    you may be familiar with from writing Kubernetes manifests for Deployments, Pods,
    Jobs, and so on. The `backoffLimit` specifies the number of retries before considering
    a Job as failed. A value of zero means that it will not retry. Since this is a
    recurring CronJob, retries happen naturally, so there is no need to retry immediately.
    A `restartPolicy` of `Never` is required to prevent the Job from restarting the
    container when it completes, which is a container’s normal behavior. The `serviceAccountName`
    field references a Kubernetes Service account with sufficient privileges to create
    and modify objects in the cluster. Since this operator could potentially deploy
    any type of resource, the gitops-operator Service account should be bound to an
    admin-level ClusterRole.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`jobTemplate`是一个Kubernetes作业模板规范。作业模板规范包含一个Pod模板规范（jobTemplate.spec.template.spec），这是您可能从为部署、Pod、作业等编写Kubernetes清单时熟悉的规范。`backoffLimit`指定了在将作业视为失败之前重试的次数。零值表示不会重试。由于这是一个周期性的CronJob，重试会自然发生，因此不需要立即重试。需要`restartPolicy`为`Never`以防止作业在完成时重新启动容器，这是容器的正常行为。`serviceAccountName`字段引用了一个具有足够权限在集群中创建和修改对象的Kubernetes
    Service account。由于此操作员可能部署任何类型的资源，gitops-operator Service account应该绑定到具有管理员级别的ClusterRole。'
- en: 'The `command` and `args` fields contain the actual logic of the GitOps reconciliation
    loop. It consists of only two commands:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`command`和`args`字段包含了GitOps协调循环的实际逻辑。它只包含两个命令：'
- en: '`git clone`—Clones the latest repository to local storage'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git clone`—将最新仓库克隆到本地存储'
- en: '`find`—Discovers YAML files in the repo, and for each YAML file located, executes
    the `kubectl apply` command'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find`—在仓库中查找YAML文件，并为每个找到的YAML文件执行`kubectl apply`命令'
- en: To use this, simply apply the CronJob to the cluster. Note that you would first
    need to apply the following supporting resources.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此功能，只需将CronJob应用到集群中。请注意，您首先需要应用以下支持资源。
- en: Listing 2.7 CronJob GitOps resources [(http://mng.bz/KMln)](https://shortener.manning.com/KMln)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.7 CronJob GitOps资源 [(http://mng.bz/KMln)](https://shortener.manning.com/KMln)
- en: '[PRE23]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Namespace gitops is where the CronJob and ServiceAccount will live.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `gitops`命名空间是CronJob和ServiceAccount将驻留的地方。
- en: ❷ ServiceAccount gitops-serviceaccount is the Kubernetes Service account that
    will have privileges to deploy to the cluster.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `ServiceAccount gitops-serviceaccount`是具有将权限部署到集群的Kubernetes Service account。
- en: ❸ ClusterRoleBinding gitops-operator binds/grants cluster admin-level privileges
    to the ServiceAccount, gitops-serviceaccount.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ `ClusterRoleBinding gitops-operator`将集群管理员级别的权限绑定/授予ServiceAccount，gitops-serviceaccount。
- en: Multiresource YAML files Management of multiple resources can be simplified
    by grouping them in the same file (separated by `---` in YAML). Listing 2.7 is
    an example of a single YAML file defining multiple related resources.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 多资源YAML文件管理可以通过将多个资源分组到同一个文件中（在YAML中以`---`分隔）来简化。列表2.7是一个示例，展示了单个YAML文件定义了多个相关资源。
- en: This example is primitive, meant to illustrate the fundamental concepts of a
    GitOps continuous delivery operator. It is not meant for any real production use
    since it lacks many features needed in a real-world production environment. For
    example, it cannot prune any resources that are no longer defined in Git. Another
    limitation is that it does not deal with any credentials required to connect to
    the Git repository.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例是原始的，旨在说明GitOps持续交付操作员的基本概念。它不适用于任何实际的生产使用，因为它缺少在现实世界生产环境中所需的功能。例如，它不能修剪在Git中未定义的资源。另一个限制是它不处理连接到Git仓库所需的任何凭证。
- en: Exercise 2.5
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 练习2.5
- en: Modify the CronJob to point to your own GitHub repository. Apply the new CronJob,
    and add YAML files to your repository. Verify that the corresponding Kubernetes
    resources are created.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 修改CronJob以指向你自己的GitHub仓库。应用新的CronJob，并将YAML文件添加到你的仓库中。验证相应的Kubernetes资源是否已创建。
- en: 2.5.2 Continuous integration pipeline
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 持续集成流水线
- en: In the previous section, we implemented a basic GitOps CD mechanism that continuously
    delivers manifests in a Git repository to the cluster. The next step is to integrate
    this process with a CI pipeline, which publishes new container images and updates
    the Kubernetes manifests with the new image. GitOps integrates well with any CI
    system, as the process is more or less the same as a typical build pipeline. The
    main difference is that instead of the CI pipeline communicating directly to the
    Kubernetes API server, it commits the desired change into Git and trusts that
    sometime later, the new changes will be detected by the GitOps operator and applied.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们实现了一个基本的GitOps CD机制，该机制将Git仓库中的清单持续交付到集群。下一步是将此过程与CI流水线集成，该流水线发布新的容器镜像，并使用新镜像更新Kubernetes清单。GitOps与任何CI系统都集成得很好，因为过程或多或少与典型的构建流水线相同。主要区别是，CI流水线不是直接与Kubernetes
    API服务器通信，而是将期望的更改提交到Git，并相信在某个时候，GitOps操作员会检测到新更改并将其应用。
- en: '![](Images/CH02_F09_Yuen.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH02_F09_Yuen.png)'
- en: Figure 2.9 A GitOps CI pipeline is similar to a typical CI pipeline. The code
    is built and tested, and then the artifact (a tagged Docker image) is pushed to
    the image registry. The additional step is the GitOps CI pipeline also updates
    the manifests in the configuration repo with the latest image tag. This update
    may trigger a GitOps CD job to apply the updated manifests to the cluster.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 GitOps CI流水线类似于典型的CI流水线。代码被构建和测试，然后工件（标记过的Docker镜像）被推送到镜像仓库。额外的步骤是GitOps
    CI流水线还会更新配置仓库中的清单，以包含最新的镜像标签。此更新可能会触发GitOps CD作业，将更新的清单应用到集群中。
- en: The goal of a GitOps CI pipeline is to
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps CI流水线的目标是
- en: Build your application and run unit testing as necessary
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建你的应用程序并根据需要运行单元测试
- en: Publish a new container image to a container registry
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新的容器镜像发布到容器仓库
- en: Update the Kubernetes manifests in Git to reflect the new image
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新Git中的Kubernetes清单以反映新镜像
- en: The following example is a typical series of commands that would be executed
    in a CI pipeline to achieve this.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是在CI流水线中执行的一系列典型命令，以实现此目的。
- en: Listing 2.8 Example GitOps CI ([http://mng.bz/9M18](http://mng.bz/9M18))
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8 示例GitOps CI ([http://mng.bz/9M18](http://mng.bz/9M18))
- en: '[PRE24]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Uses the first seven characters of the current commit-SHA as the version to
    uniquely identify the artifacts from this build
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用当前提交-SHA的前七个字符作为版本，以唯一标识此构建的工件
- en: ❷ Builds and tests your application’s binaries as you usually would
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 按照通常的方式构建和测试你的应用程序的二进制文件
- en: ❸ Builds the container image, pushes it to a container registry, and incorporates
    the unique version as part of the container image tag
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 构建容器镜像，将其推送到容器仓库，并将唯一版本作为容器镜像标签的一部分
- en: ❹ Clones the Git deployment repo containing the Kubernetes manifests
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 克隆包含Kubernetes清单的Git部署仓库
- en: ❺ Updates the manifests with the new image
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用新镜像更新清单
- en: ❻ Commits and pushes the manifest changes to the deployment configuration repo
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将清单更改提交并推送到部署配置仓库
- en: This example pipeline is one way that a GitOps CI pipeline may look. There are
    some important points to highlight regarding the different choices you might make
    that would better suit your needs.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例流水线是GitOps CI流水线可能看起来的一种方式。有一些重要的要点需要强调，这些不同的选择可能会更好地满足你的需求。
- en: Image tags and the trap of the latest tag
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像标签和最新标签的陷阱
- en: Notice in the first two steps of the example pipeline, the current Git commit-SHA
    of the application’s Git repository is used as a version variable, which is then
    incorporated as part of the container’s image tag. A resulting container image
    in the example pipeline might look like `gitopsbook/sample-app:cc52a36`, where
    `cc52a36` is the commit-SHA at the time of the build.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在示例管道的前两步中，当前应用程序 Git 仓库的 Git 提交 SHA 被用作版本变量，然后作为容器镜像标签的一部分被整合。示例管道中的结果容器镜像可能看起来像
    `gitopsbook/sample-app:cc52a36`，其中 `cc52a36` 是构建时的提交 SHA。
- en: 'It is important to use a unique version string (like a commit-SHA) that is
    different in each build since the version is incorporated as part of the container
    image tag. A common mistake that people make is to use `latest` as their image
    tag (such as `gitopsbook/sample-app:latest`) or reuse the same image tag from
    build to build. A naive pipeline might make the following mistake:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用独特的版本字符串（如提交 SHA）非常重要，因为版本被整合为容器镜像标签的一部分。人们常犯的一个常见错误是将 `latest` 作为他们的镜像标签（例如
    `gitopsbook/sample-app:latest`）或从构建到构建重用相同的镜像标签。一个简单的管道可能会犯以下错误：
- en: '[PRE25]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Reusing image tags from build to build is a terrible practice for several reasons.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 从构建到构建重用镜像标签是一种非常糟糕的做法，原因有几个。
- en: 'The first reason why container tags should not be reused is that when container
    image tags are reused, Kubernetes will not deploy the new version to the cluster.
    This is because the second time the manifests are attempted to be applied, Kubernetes
    will not detect any change in the manifests, and the second `kubectl` `apply`
    will have zero effect. For example, say build #1 publishes the image `gitopsbook/sample-app
    :latest` and deploys it to the cluster. The Deployment manifest for this might
    look something like this.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '容器标签不应重用的第一个原因是，当重用容器镜像标签时，Kubernetes 不会将新版本部署到集群中。这是因为第二次尝试应用清单时，Kubernetes
    不会检测到清单中的任何变化，第二次 `kubectl apply` 将没有任何效果。例如，假设构建 #1 发布了镜像 `gitopsbook/sample-app
    :latest` 并将其部署到集群中。这个 Deployment 清单可能看起来像这样。'
- en: Listing 2.9 Sample app deployment [(http://mng.bz/j4m9)](https://shortener.manning.com/j4m9)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.9 示例应用程序部署 [(http://mng.bz/j4m9)](https://shortener.manning.com/j4m9)
- en: '[PRE26]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When build #2 runs, even though a new container image for `gitopsbook/sample-app:latest`
    has been pushed to the container registry, the Kubernetes Deployment YAML for
    the application is the same as it was in build #1\. The Deployment specs are the
    same from the perspective of Kubernetes; there is no difference between what is
    being applied in build #1 versus build #2\. Kubernetes treats the second apply
    as a no-op (no operation) and does nothing. For Kubernetes to redeploy, something
    needs to be different in the Deployment spec from the first build to the second.
    Using unique container image tags ensures there is a difference.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '当运行构建 #2 时，尽管已经将新的容器镜像 `gitopsbook/sample-app:latest` 推送到容器注册库，但应用程序的 Kubernetes
    Deployment YAML 与构建 #1 中的相同。从 Kubernetes 的角度来看，部署规范是相同的；构建 #1 和构建 #2 中应用的内容没有区别。Kubernetes
    将第二次应用视为无操作（no-op）并且不执行任何操作。为了使 Kubernetes 重新部署，部署规范中必须从第一次构建到第二次构建有所不同。使用唯一的容器镜像标签确保存在差异。'
- en: 'Another reason for incorporating a unique version into the image tag is that
    it enables traceability. By incorporating something like the application’s Git
    commit-SHA into the tag, there is never any question about what version of the
    software is currently running in the cluster. For example, you could run the following
    kubectl command, which outputs the images of all deployments in the Namespace:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将独特版本纳入镜像标签的另一个原因是它实现了可追溯性。通过将类似应用程序的 Git 提交 SHA 这样的内容纳入标签，集群中当前运行的软件版本永远不会产生疑问。例如，您可以运行以下
    kubectl 命令，该命令输出命名空间中所有部署的镜像：
- en: '[PRE27]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By using the convention of tying container image tags to Git commit-SHAs of
    your application repository, you can trace the currently running version of the
    `sample-app` to commit `508d3df`. From there, you have full knowledge of exactly
    what version of your application is running in the cluster.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将容器镜像标签与应用程序仓库的 Git 提交 SHA 相关联的约定，您可以追踪当前运行的 `sample-app` 版本到提交 `508d3df`。从那里，您将完全了解集群中运行的应用程序的确切版本。
- en: 'The third and possibly most important reason for not reusing image tags such
    as `latest` is that rollback to the older version becomes impossible. When you
    reuse image tags, you are overriding or rewriting the meaning of that overwritten
    image. Imagine the following sequence of events:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 不重用像`latest`这样的图像标签的第三个，可能是最重要的原因，是回滚到旧版本变得不可能。当你重用图像标签时，你正在覆盖或重写被覆盖图像的含义。想象以下事件序列：
- en: 'Build #1 publishes the container image `gitopsbook/sample-app:latest` and deploys
    it to the cluster.'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建号1发布了容器镜像`gitopsbook/sample-app:latest`并将其部署到集群中。
- en: 'Build #2 republishes the container image `gitopsbook/sample-app:latest`, overwriting
    the image tag deployed in build #1\. It redeploys this image to the cluster.'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建号2重新发布了容器镜像`gitopsbook/sample-app:latest`，覆盖了构建号1中部署的图像标签。它将此镜像重新部署到集群中。
- en: 'Sometime after build #2 is deployed, it is discovered that a severe bug exists
    in the latest version of the code, and immediate rollback is necessary to the
    version created in build #1.'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在部署构建号2之后，发现代码的最新版本存在一个严重的bug，并且需要立即回滚到构建号1创建的版本。
- en: 'There is no easy way to redeploy the version of the `sample-app` created during
    build #1 because there is no image tag representing that version of the software.
    The second build overwrote the `latest` image tag, effectively making the original
    image unreachable (at least not without extreme measures).'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有代表该软件版本的图像标签，因此没有简单的方法可以重新部署构建号1期间创建的`sample-app`版本。第二次构建覆盖了`latest`图像标签，实际上使原始图像不可访问（至少不是没有极端措施）。
- en: For these reasons, it is not recommended to reuse image tags, such as `latest`,
    at least in production environments. With that said, in dev and test environments,
    continuously creating new and unique image tags (which likely never get cleaned
    up) could cause an excessive amount of disk usage in your container registry or
    become unmanageable just by the sheer number of image tags. In these scenarios,
    reusing image tags may be appropriate, understanding Kubernetes’ behavior of not
    doing anything when the same specification is applied twice.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，不建议在生产环境中重用图像标签，如`latest`。话虽如此，在开发和测试环境中，持续创建新的唯一图像标签（这些标签可能永远不会被清理）可能会导致你的容器注册库的磁盘使用量过多，或者仅仅是因为图像标签的数量庞大而变得难以管理。在这些情况下，重用图像标签可能是合适的，理解Kubernetes在应用相同的规范两次时不会采取任何行动的行为。
- en: Kubectl rollout restart Kubectl has a convenience command, `kubectl rollout
    restart`, which causes all the Pods of a deployment to restart (even if the image
    tag is the same). It is useful in dev and test scenarios where the image tag has
    been overwritten and redeploy is desired. It works by injecting an arbitrary timestamp
    into the Pod template metadata annotations. This causes the Pod spec to be different
    from what it was before, which causes a regular, rolling update of the Pods.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Kubectl rollout restart Kubectl有一个方便的命令，`kubectl rollout restart`，它会导致部署的所有Pod重启（即使图像标签相同）。这在图像标签被覆盖并希望重新部署的开发和测试场景中很有用。它通过在Pod模板元数据注解中注入任意时间戳来实现。这导致Pod规范与之前不同，从而引起Pod的常规滚动更新。
- en: One thing to note is that our CI example uses a Git commit-SHA as the unique
    image tag. But instead of a Git commit-SHA, the image tag could incorporate any
    other unique identifier, such as a semantic version, a build number, a date/time
    string, or even a combination of these pieces of information.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一件事是，我们的CI示例使用Git提交-SHA作为唯一的图像标签。但除了Git提交-SHA之外，图像标签可以包含任何其他唯一标识符，例如语义版本、构建号、日期/时间字符串，甚至这些信息的组合。
- en: Semantic version A *semantic version* is a versioning methodology that uses
    a three-digit convention (MAJOR.MINOR.PATCH) to convey the meaning of a version
    (such as v2.0.1). MAJOR is incremented when there are incompatible API changes.
    MINOR is incremented when functionality is added in a backward-compatible manner.
    PATCH is incremented when there are backward-compatible bug fixes.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本A *语义版本* 是一种使用三位数约定（MAJOR.MINOR.PATCH）来传达版本含义（如v2.0.1）的版本控制方法。当存在不兼容的API更改时，MAJOR会增加。当以向后兼容的方式添加功能时，MINOR会增加。当有向后兼容的bug修复时，PATCH会增加。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Kubernetes is a container orchestration system for deployment, scaling, and
    management of containers.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes是一个用于部署、扩展和管理容器的容器编排系统。
- en: Basic Kubernetes objects are Pod, Service, and Volume.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本Kubernetes对象是Pod、Service和Volume。
- en: The Kubernetes control plane consists of `kube-apiserver`, `kube-controller
    -manager`, and `kube-scheduler`.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes控制平面由`kube-apiserver`、`kube-controller-manager`和`kube-scheduler`组成。
- en: Each Kubernetes worker node runs `kubelet` and `kube-proxy`.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个Kubernetes工作节点都运行`kubelet`和`kube-proxy`。
- en: A `Running` Service in a Pod is accessible from your computer using `kubectl
    port-forward.`
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Pod中运行的`Running`服务可以通过`kubectl port-forward`从您的计算机访问。
- en: Pods can be deployed by using imperative or declarative syntax. Imperative deployment
    is not idempotent, and declarative deployment is idempotent. For GitOps, declarative
    is the preferred method.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod可以通过使用命令式或声明式语法进行部署。命令式部署不是幂等的，而声明式部署是幂等的。对于GitOps，声明式是首选方法。
- en: Controllers are the brains in Kubernetes to bring the `Running` state into the
    desired state.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器是Kubernetes的大脑，用于将`Running`状态转换为所需状态。
- en: A Kubernetes operator can be implemented simply as a shell script by monitoring
    ConfigMap changes and updating deployment.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes操作符可以通过监控ConfigMap的更改并更新部署简单地实现为shell脚本。
- en: Kubernetes configuration is declarative.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes配置是声明式的。
- en: GitOps complements Kubernetes due to its declarative nature.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其声明式特性，GitOps补充了Kubernetes。
- en: GitOps operators trigger deployments to your Kubernetes cluster based on changes
    to revision-controlled configuration files stored in Git.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitOps操作符根据存储在Git中受版本控制的配置文件的变化触发对Kubernetes集群的部署。
- en: A simple GitOps operator can be implemented as a script by regularly checking
    the manifest Git repo for changes.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的GitOps操作符可以通过定期检查清单Git仓库的更改实现为脚本。
- en: '*C*I pipeline can be implemented as a script with steps to build the Docker
    image and update the manifest with the new image tag.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C*I管道可以通过一个脚本实现，该脚本包含构建Docker镜像和更新清单以包含新镜像标签的步骤。'
- en: '* * *'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1.[https://www.cncf.io/phippy](https://www.cncf.io/phippy/).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 1.[https://www.cncf.io/phippy](https://www.cncf.io/phippy/).
- en: 2.[https://en.wikipedia.org/wiki/Chroot](https://en.wikipedia.org/wiki/Chroot).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 2.[https://en.wikipedia.org/wiki/Chroot](https://en.wikipedia.org/wiki/Chroot).
- en: 3.[https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes](https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 3.[https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes](https://kubernetes.io/blog/2015/04/borg-predecessor-to-kubernetes/).
- en: 4.[https://kubernetes.io/docs/concepts/overview/components/#control-plane-components](https://kubernetes.io/docs/concepts/overview/components/#control-plane-components).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 4.[https://kubernetes.io/docs/concepts/overview/components/#control-plane-components](https://kubernetes.io/docs/concepts/overview/components/#control-plane-components).
- en: 5.https://en.wikipedia.org/wiki/Cowsay.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 5.https://en.wikipedia.org/wiki/Cowsay.
- en: 6.[http://mng.bz/pVdP](http://mng.bz/pVdP).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 6.[http://mng.bz/pVdP](http://mng.bz/pVdP).
- en: 7.[http://mng.bz/Yq67](http://mng.bz/Yq67).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 7.[http://mng.bz/Yq67](http://mng.bz/Yq67).
