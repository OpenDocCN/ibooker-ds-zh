- en: Chapter 14\. Testing Angular applications
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 14 章\. 测试 Angular 应用程序
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using the Jasmine framework for unit testing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jasmine 框架进行单元测试
- en: Identifying the main artifacts from the Angular testing library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别 Angular 测试库中的主要工件
- en: Testing services, components, and the router
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试服务、组件和路由器
- en: Running unit tests against web browsers with the Karma test runner
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Karma 测试运行器对 Web 浏览器运行单元测试
- en: End-to-end testing with the Protractor framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Protractor 框架进行端到端测试
- en: To ensure that your software has no bugs, you need to test it. Even if your
    application has no bugs today, it may have them tomorrow, after you modify the
    existing code or introduce new code. Even if you don’t change the code in a particular
    module, it may stop working properly as a result of changes in another module
    or in the runtime environment. Your application code has to be retested regularly,
    and that process should be automated. You should prepare test scripts and start
    running them as early as possible in your development cycle.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您的软件没有错误，您需要对其进行测试。即使您的应用程序今天没有错误，在您修改现有代码或引入新代码后，它可能明天会有错误。即使您没有更改特定模块的代码，它也可能因为另一个模块或运行时环境的变化而无法正常工作。您的应用程序代码需要定期重新测试，并且该过程应该自动化。您应该在开发周期的早期就准备测试脚本并开始运行它们。
- en: 'This chapter covers two main types of testing for the frontend of web apps:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了针对 Web 应用程序前端的两种主要测试类型：
- en: '***Unit testing*—** Asserts that a small unit of code accepts the expected
    input data and returns the expected result. Unit testing is about testing isolated
    pieces of code, especially public interfaces.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***单元测试*—** 断言一个小块代码接受预期的输入数据并返回预期的结果。单元测试是关于测试独立的代码片段，特别是公共接口。'
- en: '***End-to-end testing*—** Asserts that the entire application works as end
    users expect and that all application parts properly interact with each other.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***端到端测试*—** 断言整个应用程序按最终用户期望的方式工作，并且所有应用程序部分都正确地相互交互。'
- en: Unit tests are for testing the business logic of small, isolated units of code.
    They run reasonably fast, and you’ll be running unit tests a lot more often than
    end-to-end tests. End-to-end (e2e) testing simulates user actions (such as button
    clicks) and checks that the application behaves as expected. During end-to-end
    testing, you shouldn’t run unit-testing scripts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试用于测试小型、独立代码单元的业务逻辑。它们运行得相当快，您将比端到端测试更频繁地运行单元测试。端到端（e2e）测试模拟用户操作（如按钮点击）并检查应用程序是否按预期运行。在端到端测试期间，您不应运行单元测试脚本。
- en: '|  |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: There are also integration tests that check that more that one app member can
    communicate. Whereas unit tests mock dependencies (for example, HTTP responses),
    integration tests use the real ones. To turn a unit test into an integration test,
    don’t use mocks.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些集成测试，用于检查多个应用程序成员是否可以通信。与单元测试模拟依赖项（例如，HTTP 响应）不同，集成测试使用真实的依赖项。要将单元测试转换为集成测试，不要使用模拟。
- en: '|  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: We’ll start by covering the basics of unit testing with Jasmine, and then we’ll
    show you how the Angular testing library is used with Jasmine. After that, you’ll
    see how to use Protractor, the library for e2e tests. Toward the end of the chapter,
    we’ll show you how to write and run e2e scripts to test the product-search workflow
    of ngAuction.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从介绍 Jasmine 的单元测试基础开始，然后展示如何使用 Angular 测试库与 Jasmine 结合。之后，您将了解如何使用 Protractor，这个用于端到端测试的库。在章节的末尾，我们将向您展示如何编写和运行端到端脚本以测试
    ngAuction 的产品搜索工作流程。
- en: 14.1\. Unit testing
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1\. 单元测试
- en: The authors of this book work as consultants on large projects for various clients.
    Pretty often these projects were written without unit tests in place. We’re going
    to describe a typical situation that we’ve run into on multiple occasions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书作者在为各种客户的大型项目中担任顾问。相当常见的是，这些项目在没有单元测试的情况下编写。我们将描述一个典型的场景，我们在多次场合都遇到过这种情况。
- en: A large app evolves over several years. Some of the developers who started writing
    the app are gone. A new developer joins the project and has to quickly learn the
    code and get up to speed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大型应用程序可能经过几年的演变。一些最初编写应用程序的开发者已经离开了。一个新的开发者加入了项目，并需要快速学习代码并跟上进度。
- en: A new business requirement comes in, and the new team member starts working
    on it. They implement this requirement in the existing function `doSomething()`,
    but the QA team opens another issue, reporting that the app is broken in a seemingly
    unrelated area. After additional research, it becomes obvious that the app is
    broken because of the code change made in `doSomething()`. The new developer doesn’t
    know about a certain business condition and can’t account for it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的业务需求出现，新团队成员开始着手处理它。他们在现有的 `doSomething()` 函数中实现了这个需求，但 QA 团队又提出了另一个问题，报告说应用在看似无关的区域出现了问题。经过进一步的研究，很明显，应用出现问题是因为在
    `doSomething()` 中所做的代码更改。新开发者不了解某个业务条件，无法对此进行解释。
- en: This wouldn’t have happened if unit (or e2e) tests were written with the original
    version of `doSomething()` and run as a part of each build. Besides, the original
    unit test would serve as documentation for `doSomething()`. Although writing unit
    tests seems like an additional, time-consuming task, it may save you a lot more
    time in the long run.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单元测试（或端到端测试）是用 `doSomething()` 的原始版本编写的，并且作为每个构建的一部分运行，这种情况就不会发生。此外，原始单元测试将作为
    `doSomething()` 的文档。尽管编写单元测试看起来像是一项额外的、耗时的工作，但从长远来看，它可能会为你节省更多的时间。
- en: We like the definition given by Google engineer Elliotte Rusty Harold during
    one of his presentations—that a unit test should verify that a known, fixed input
    produces a known, fixed output. If you provide a fixed input for a function that
    internally uses other dependencies, those dependencies should be mocked out, so
    a single unit test script tests an isolated unit of code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢 Google 工程师 Elliotte Rusty Harold 在他的某次演讲中给出的定义——一个单元测试应该验证一个已知、固定的输入产生一个已知、固定的输出。如果你为一个内部使用其他依赖项的函数提供固定的输入，那么这些依赖项应该被模拟，这样单个单元测试脚本就可以测试一个独立的代码单元。
- en: Several frameworks have been created specifically for writing unit tests, and
    Angular documentation recommends Jasmine for this purpose (see the Angular documentation
    at [http://mng.bz/0nv3](http://mng.bz/0nv3)). We’ll start with a brief overview
    of Jasmine.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 已经创建了几个专门用于编写单元测试的框架，Angular 文档推荐使用 Jasmine 来实现这一目的（请参阅 Angular 文档，[http://mng.bz/0nv3](http://mng.bz/0nv3)）。我们将从
    Jasmine 的简要概述开始。
- en: 14.1.1\. Getting to know Jasmine
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.1\. 了解 Jasmine
- en: Jasmine ([https://jasmine.github.io/](https://jasmine.github.io/)) enables you
    to implement a *behavior-driven development* (BDD) process, which suggests that
    tests of any unit of software should be specified in terms of the desired behavior
    of the unit. With BDD, you use natural language constructs to describe what you
    think your code should be doing. You write unit test specifications (specs) in
    the form of short sentences, such as “StarsComponent emits the rating change event.”
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine ([https://jasmine.github.io/](https://jasmine.github.io/)) 允许你实现一种 *行为驱动开发*（BDD）过程，该过程建议任何软件单元的测试都应从该单元期望的行为来指定。使用
    BDD，你使用自然语言结构来描述你认为代码应该做什么。你以简短句子的形式编写单元测试规范（specs），例如：“StarsComponent 发射评分更改事件。”
- en: 'Because it’s so easy to understand the meaning of tests, they can serve as
    your program documentation. If other developers need to become familiar with your
    code, they can start by reading the code for the unit tests to understand your
    intentions. Using natural language to describe tests has another advantage: it’s
    easy to reason about the test results, as shown in [figure 14.1](#ch14fig01).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试的含义很容易理解，因此它们可以作为你的程序文档。如果其他开发者需要熟悉你的代码，他们可以从阅读单元测试代码开始，以了解你的意图。使用自然语言描述测试的另一个优点是：它很容易对测试结果进行推理，如图
    14.1 所示。
- en: Figure 14.1\. Running tests using Jasmine’s test runner
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.1\. 使用 Jasmine 的测试运行器运行测试
- en: '![](Images/14fig01_alt.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/14fig01_alt.jpg)'
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Even though Jasmine comes with its own browser-based test runner, you’ll be
    using a command-line-based test runner called Karma that can be easily integrated
    into the automated build process of your apps.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Jasmine 自带基于浏览器的测试运行器，但你将使用一个基于命令行的测试运行器 Karma，它可以轻松集成到你的应用的自动化构建过程中。
- en: '|  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In BDD frameworks, a test is called a *spec*, and a combination of one or more
    specs is called a *suite*. A test suite is defined with the `describe()` function—this
    is where you describe what you’re testing. Each spec in a suite is programmed
    as an `it()` function, which defines the expected behavior of the code under test
    and how to test it. The following listing shows an example.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在行为驱动开发（BDD）框架中，一个测试被称为 *规范*，一个或多个规范的组合称为 *套件*。套件是通过 `describe()` 函数定义的——这就是你描述你要测试的内容的地方。套件中的每个规范都编程为一个
    `it()` 函数，它定义了待测试代码的预期行为以及如何测试它。以下列表显示了一个示例。
- en: Listing 14.1\. A simple Jasmine test suite
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.1\. 简单的 Jasmine 测试套件
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* A suite description and a function implementing the suite**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 套件描述和实现套件的函数**'
- en: '***2* A spec to test multiplication**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 测试乘法的规范**'
- en: '***3* A spec to test division**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 测试除法的规范**'
- en: 'Testing frameworks have the notion of an *assertion*, which is a way of questioning
    whether an expression under test is true or false. If the assertion returns `false`,
    the framework throws an error. In Jasmine, assertions are specified using the
    `expect()` function, followed by *matchers*:`toBe()`, `toEqual()`, and so on.
    It’s as if you’re writing a sentence, “I expect 2 plus 2 to equal 4”:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架有一个 *断言* 的概念，它是一种询问测试表达式是否为真或假的方式。如果断言返回 `false`，则框架抛出错误。在 Jasmine 中，断言是通过
    `expect()` 函数指定的，后跟 *匹配器*：`toBe()`、`toEqual()` 等。这就像你正在写一个句子，“我期望 2 加 2 等于 4”：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Matchers implement a Boolean comparison between the actual and expected values.
    If the matcher returns `true`, the spec passes. If you expect a test result not
    to have a certain value, just add the keyword `not` before the matcher:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配器实现了实际值和预期值之间的布尔比较。如果匹配器返回 `true`，则规范通过。如果你期望测试结果不包含某个特定值，只需在匹配器前添加关键字 `not`：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the complete list of matchers in the type definition file @types/jasmine/index.d.ts,
    located in the directory node_modules. The Angular testing library adds more matchers,
    listed at [http://mng.bz/hx5u](http://mng.bz/hx5u).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在类型定义文件 @types/jasmine/index.d.ts 中找到完整的匹配器列表，该文件位于 node_modules 目录中。Angular
    测试库添加了更多匹配器，列在 [http://mng.bz/hx5u](http://mng.bz/hx5u)。
- en: '|  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In Angular, test suites have the same names as the files under test, adding
    the suffix .spec to the name. For example, the file application.spec.ts contains
    the test script for application.ts. [Figure 14.2](#ch14fig02) shows a minimalistic
    test suite that can be located in the app.component.spec.ts file; it makes an
    *assertion* that the variable `app` is an instance of `AppComponent`. An assertion
    is the expectation plus the matcher.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，测试套件的名称与测试文件下的文件名相同，名称后添加 .spec 后缀。例如，文件 application.spec.ts 包含
    application.ts 的测试脚本。[图 14.2](#ch14fig02) 显示了一个可以位于 app.component.spec.ts 文件中的最小化测试套件；它断言变量
    `app` 是 `AppComponent` 的实例。断言是期望加上匹配器。
- en: Figure 14.2\. A minimalistic test suite
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.2\. 最小化测试套件
- en: '![](Images/14fig02_alt.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14fig02_alt.jpg)'
- en: '[Figure 14.2](#ch14fig02) shows a test suite containing a single spec. If you
    extract the texts from `describe()` and `it()` and put them together, you’ll get
    a sentence that clearly indicates what you’re testing here: “ApplicationComponent
    is successfully instantiated.” If other developers need to know what your spec
    tests, they can read the texts in `describe()` and `it()`. Each test should be
    self-descriptive so it can serve as program documentation.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14.2](#ch14fig02) 显示了一个包含单个规范的测试套件。如果你从 `describe()` 和 `it()` 中提取文本并将它们放在一起，你会得到一个清楚地表明你在这里测试什么的句子：“ApplicationComponent
    成功实例化。”如果其他开发者需要知道你的规范测试了什么，他们可以阅读 `describe()` 和 `it()` 中的文本。每个测试都应该具有自描述性，以便它可以作为程序文档。'
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Although the test shown in [figure 14.2](#ch14fig02) was generated by Angular
    CLI, it’s pretty useless because the chances that the `AppComponent` won’t be
    successfully instantiated are close to zero.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然图 14.2 中显示的测试是由 Angular CLI 生成的，但它相当无用，因为 `AppComponent` 无法成功实例化的可能性几乎为零。
- en: '|  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The code in [figure 14.2](#ch14fig02) instantiates `AppComponent` and expects
    the expression `app instanceof AppComponent` to evaluate to `true`. From the `import`
    statement, you can guess that this test script is located in the same directory
    as `AppComponent`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 中的代码实例化了 `AppComponent` 并期望表达式 `app instanceof AppComponent` 评估为 `true`。从
    `import` 语句中，你可以猜测这个测试脚本位于与 `AppComponent` 相同的目录中。
- en: '|  |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In Angular applications, you keep each test script in the same directory as
    the component (or service) under test, so if you need to reuse a component in
    another app, all related files are located together. If you use Angular CLI for
    generating a component or service, the boilerplate code for tests (the .spec.ts
    file) will be generated in the same directory.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 应用程序中，你将每个测试脚本保存在与被测试的组件（或服务）相同的目录中，因此如果你需要在另一个应用程序中重用组件，所有相关文件都位于一起。如果你使用
    Angular CLI 生成组件或服务，测试的样板代码（.spec.ts 文件）将在同一目录中生成。
- en: '|  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: If you want some code to be executed before each test (such as to prepare test
    dependencies), you can specify it in the *setup* functions `beforeAll()` and `beforeEach()`,
    which will run before the suite or each spec, respectively. If you want to execute
    some code right after the suite or each spec is finished, use the *teardown* functions
    `afterAll()` and `afterEach()`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在每次测试之前执行一些代码（例如准备测试依赖项），你可以在 `setup` 函数 `beforeAll()` 和 `beforeEach()`
    中指定它，它们将分别在套件或每个测试用例之前运行。如果你想在套件或每个测试用例完成后立即执行一些代码，请使用 `teardown` 函数 `afterAll()`
    和 `afterEach()`。
- en: Let’s see how to apply Jasmine API while unit-testing a TypeScript class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在单元测试 TypeScript 类时应用 Jasmine API。
- en: 14.1.2\. Writing test scripts for a class
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.2\. 为类编写测试脚本
- en: Imagine you have a `Counter` class with one `counter` property and two methods
    that allow incrementing or decrementing the value of this property.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个具有一个 `counter` 属性和两个方法的 `Counter` 类，这两个方法允许增加或减少该属性的值。
- en: Listing 14.2\. counter.ts
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.2\. counter.ts
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* A class property**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 一个类属性'
- en: '***2* A method to increment the value**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 一个用于增加值的函数'
- en: '***3* A method to decrement the value**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 一个用于减少值的函数'
- en: What do you want to unit-test here? You want to make sure that the `increment()`
    method increments the value of `counter` by one, and that the `decrement()` method
    decrements this value by one. Applying Jasmine terminology, you want to write
    a test suite with two specs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在这里进行单元测试吗？你想要确保 `increment()` 方法将 `counter` 的值增加一，而 `decrement()` 方法将此值减少一。使用
    Jasmine 术语，你想要编写一个包含两个测试用例的测试套件。
- en: Remember that a spec should test an isolated piece of functionality, so each
    spec should create an instance of the `Counter` class and invoke *only one* of
    its methods. The first version of the counter.spec.ts file is shown in the following
    listing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一个测试用例应该测试一个独立的功能部分，因此每个测试用例都应该创建 `Counter` 类的一个实例，并只调用其一个方法。counter.spec.ts
    文件的第一个版本如下所示。
- en: Listing 14.3\. counter.spec.ts
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.3\. counter.spec.ts
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* The test suite declaration states that you’ll test the Counter.**'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 测试套件声明表示你将测试 Counter。'
- en: '***2* The first spec tests if increment works.**'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 首个测试用例检查增加功能是否正常。'
- en: '***3* The setup phase creates a new instance of the Counter.**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 设置阶段创建一个 Counter 的新实例。'
- en: '***4* Invokes the function under test**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4** 调用被测试的函数'
- en: '***5* Declares the expectation, assertion, and matcher**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5** 声明期望、断言和匹配器'
- en: Each of your specs has similar functionality. The setup phase creates a fresh
    instance of the `Counter` class, then it invokes the method to be tested, and
    finally it declares the expectation with the `expect()` method. In one spec, you
    expect the `counter` to be `1`, and in another `-1`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你的每个测试用例都有类似的功能。设置阶段创建 `Counter` 类的一个新实例，然后调用要测试的方法，最后使用 `expect()` 方法声明期望。在一个测试用例中，你期望
    `counter` 为 `1`，在另一个中为 `-1`。
- en: 'This suite of tests will work, but you have some code duplication here: each
    of the specs repeats the instantiation of `Counter`. In the refactored version
    of your test script, you’ll remove the `Counter` instantiation from the specs
    and do it before the specs. Take a look at the new test version in the following
    listing. Is it correct?'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试套件将工作，但你在这里有一些代码重复：每个测试用例都重复了 `Counter` 的实例化。在你测试脚本的重构版本中，你将删除从测试用例中移除的
    `Counter` 实例化，并在测试之前执行它。看看以下列表中的新测试版本。这是正确的吗？
- en: Listing 14.4\. Refactored counter.spec.ts
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.4\. 重构后的 counter.spec.ts
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Instantiates Counter before the specs**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 在测试用例之前实例化 Counter'
- en: This test is not correct. Your test suite will create an instance of `Counter`,
    and the first spec will increase the `counter` value to `1` as expected. But when
    the second spec decrements the `counter`, its value becomes `0`, though the matcher
    expects it to be `-1`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试是不正确的。你的测试套件将创建一个 `Counter` 的实例，第一个测试用例将 `counter` 的值增加到 `1`，正如预期的那样。但当第二个测试用例减少
    `counter` 时，其值变为 `0`，尽管匹配器期望它为 `-1`。
- en: The final version of your test script, shown in the nest listing, fixes this
    mistake by creating the instance of `Counter` inside Jasmine’s `beforeEach()`
    function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您测试脚本的最终版本，如下一列表所示，通过在 Jasmine 的 `beforeEach()` 函数内部创建 `Counter` 实例来修复了这个错误。
- en: Listing 14.5\. The final version of counter.spec.ts
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.5\. counter.spec.ts 的最终版本
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Instantiates Counter inside beforeEach()**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在 beforeEach() 中实例化 Counter**'
- en: Now this script properly instructs Jasmine to create a new instance of `Counter`
    before running each spec of your suite. Let’s see how to run it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个脚本正确地指导 Jasmine 在运行您的套件中的每个 spec 之前创建一个新的 `Counter` 实例。让我们看看如何运行它。
- en: 14.2\. Running Jasmine scripts with Karma
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2\. 使用 Karma 运行 Jasmine 脚本
- en: 'For projects that don’t use Angular CLI, you need to do lots of manual configurations
    to run Jasmine tests. Without Angular CLI, you start with installing Jasmine and
    its type definition files as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '对于不使用 Angular CLI 的项目，您需要执行大量的手动配置才能运行 Jasmine 测试。在没有 Angular CLI 的情况下，您需要按照以下方式安装
    Jasmine 及其类型定义文件： '
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then you need to create a test.html file that includes script tags to load Jasmine
    and your specs (the TypeScript code needs to be precompiled into JavaScript).
    Finally, you need to manually load test.html in each browser you care about and
    watch whether your tests fail or pass.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您需要创建一个包含脚本标签以加载 Jasmine 和您的规格（TypeScript 代码需要预先编译成 JavaScript）的 test.html
    文件。最后，您需要手动在每个您关心的浏览器中加载 test.html 并观察您的测试是否通过或失败。
- en: But running unit tests from the command line is a better option, because that
    way you can integrate tests into the project build process. This is one of the
    main reasons for using a command-line test runner called Karma (see [https://karma-runner.github.io](https://karma-runner.github.io)).
    Along with that benefit, Karma has multiple useful plugins and can be used with
    many JavaScript testing libraries for testing against all major browsers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但从命令行运行单元测试是一个更好的选择，因为这样您可以集成测试到项目构建过程中。这是使用名为 Karma 的命令行测试运行器（见 [https://karma-runner.github.io](https://karma-runner.github.io)）的主要原因之一。除了这个好处之外，Karma
    还具有多个有用的插件，并且可以与许多 JavaScript 测试库一起使用，以针对所有主要浏览器进行测试。
- en: Karma is used for testing JavaScript code written with or without frameworks.
    Karma can run tests to check whether your application works properly in multiple
    browsers (Chrome, Firefox, Internet Explorer, and so on). In non-Angular CLI projects,
    you can install Karma and the plugins for Jasmine, Chrome, and Firefox, as shown
    in the following listing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Karma 用于测试使用或未使用框架编写的 JavaScript 代码。Karma 可以运行测试以检查您的应用程序是否在多个浏览器（Chrome、Firefox、Internet
    Explorer 等）中正常工作。在非 Angular CLI 项目中，您可以按照以下列表安装 Karma 和 Jasmine、Chrome 以及 Firefox
    的插件。
- en: Listing 14.6\. Installing Karma
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.6\. 安装 Karma
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Installs Karma and its Jasmine plugin**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 安装 Karma 及其 Jasmine 插件**'
- en: '***2* Installs the plugin to test in Chrome**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在 Chrome 中安装插件**'
- en: '***3* Installs the plugin to test in Firefox**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在 Firefox 中安装插件以进行测试**'
- en: Then you need to prepare a configuration file, karma.conf.js, for your project—but
    you’re spoiled by Angular CLI, which installs and configures everything you need
    for testing Angular apps, including Jasmine and Karma. We’ve generated a new project
    with Angular CLI and added the code described in the previous section to test
    the `Counter` class there. You’ll find this project in the hello-jasmine directory.
    [Figure 14.3](#ch14fig03) shows the structure of this project, marking all test-related
    files and directories.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您需要为项目准备一个配置文件，即 karma.conf.js，但您被 Angular CLI 宠坏了，因为它为您安装并配置了测试 Angular 应用所需的所有内容，包括
    Jasmine 和 Karma。我们使用 Angular CLI 创建了一个新项目，并将上一节中描述的代码添加到测试 `Counter` 类中。您将在 hello-jasmine
    目录中找到这个项目。[图 14.3](#ch14fig03) 展示了该项目的结构，标记了所有与测试相关的文件和目录。
- en: Figure 14.3\. The hello-jasmine project
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.3\. hello-jasmine 项目
- en: '![](Images/14fig03_alt.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14fig03_alt.jpg)'
- en: At the very top, you see the e2e directory, and at the bottom, the protractor.conf.js
    file, which were generated for end-to-end testing, described in [section 14.4](#ch14lev1sec4).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，您可以看到 e2e 目录，在底部，是用于端到端测试的 protractor.conf.js 文件，这些都是在[第 14.4 节](#ch14lev1sec4)中描述的。
- en: The counter.spec.ts file is the manually written test script described in the
    previous section. The app.component.spec.ts file was generated by Angular CLI
    for testing the `AppComponent`, and you’ll see its content in [section 14.3.1](#ch14lev2sec5).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`counter.spec.ts` 文件是上一节中描述的手动编写的测试脚本。`app.component.spec.ts` 文件是由 Angular
    CLI 为测试 `AppComponent` 生成的，您将在[第 14.3.1 节](#ch14lev2sec5)中看到其内容。'
- en: The generated file test.ts is the main testing script that loads all test scripts.
    The karma.conf.js file is used by the Karma runner as soon as you run the `ng
    test` command, which compiles and runs unit tests. After the tests are compiled,
    `ng test` uses the compiled script test.js to load the Angular testing library
    and all the .spec.ts files, and start the Karma runner. [Figure 14.4](#ch14fig04).
    shows the output of the `ng test` command that in the hello-jasmine project.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 test.ts 文件是主要的测试脚本，它加载所有测试脚本。当你运行 `ng test` 命令时，karma.conf.js 文件被 Karma
    运行器使用，该命令编译并运行单元测试。测试编译完成后，`ng test` 使用编译后的脚本 test.js 加载 Angular 测试库和所有 .spec.ts
    文件，并启动 Karma 运行器。[图 14.4](#ch14fig04) 显示了在 hello-jasmine 项目中运行 `ng test` 命令的输出。
- en: Figure 14.4\. Running `ng test` in the hello-jasmine project
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.4\. 在 hello-jasmine 项目中运行 `ng test`
- en: '![](Images/14fig04_alt.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/14fig04_alt.jpg)'
- en: To run the tests, Karma starts the Chrome browser (the only one configured by
    Angular CLI) and runs five tests that end successfully. Why five? You wrote only
    two tests in the `counter.spec.ts` file, right? Angular CLI also generates the
    app.component .spec.ts file, which includes the test suite with three `it()` functions
    defined. Karma executes all files that have an extension .spec.ts.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，Karma 启动 Chrome 浏览器（Angular CLI 配置的唯一一个），并运行五个成功结束的测试。为什么是五个？你在 `counter.spec.ts`
    文件中只写了两个测试，对吧？Angular CLI 还生成了 app.component.spec.ts 文件，其中包含包含三个 `it()` 函数定义的测试套件。Karma
    执行所有扩展名为 .spec.ts 的文件。
- en: '|  |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Angular CLI projects include the karma-jasmine-html-reporter package, and if
    you want to see the test results in the browser, open the URL http://localhost:9876.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CLI 项目包含 karma-jasmine-html-reporter 包，如果你想通过浏览器查看测试结果，请打开 URL http://localhost:9876。
- en: '|  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You don’t want to run tests from app.component.spec.ts at this point, so let’s
    turn them off. If you want the test runner to skip some tests, rename their spec
    function from `it()` to `xit()`. Here, *x* is for *exclude*. If you want to skip
    the entire test suite, rename `describe()` to `xdescribe()`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在不想从 app.component.spec.ts 运行测试，所以让我们将其关闭。如果你想让测试运行器跳过一些测试，将它们的 spec 函数从 `it()`
    重命名为 `xit()`。在这里，*x* 代表 *exclude*。如果你想跳过整个测试套件，将 `describe()` 重命名为 `xdescribe()`。
- en: 'If you exclude the test suite in app.component.spec.ts, the tests will be automatically
    rerun, reporting that two tests ran successfully (those that you wrote for `Counter`),
    and three specs were skipped (those that were generated by Angular CLI):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从 app.component.spec.ts 中排除测试套件，测试将自动重新运行，报告显示两个测试成功运行（你为 `Counter` 编写的那些），三个
    spec 被跳过（由 Angular CLI 生成的那些）：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As the number of specs grows, you may want to execute just some of them to see
    the results faster. Renaming a spec function from `it()` to `fit()` (*f* is for
    *force*) will execute only these tests while skipping the rest.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 随着spec数量的增加，你可能只想执行其中一些以更快地看到结果。将 spec 函数从 `it()` 重命名为 `fit()`（*f* 代表 *force*）将只执行这些测试，跳过其余的。
- en: '|  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**You know how to test, but why is still not clear**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**你知道如何测试，但为什么还不清楚**'
- en: 'Let’s say you know how to test the methods of your `Counter` class, but you
    still may have a million-dollar question: Why test such simple functions like
    `increment()` and `decrement()`? Isn’t it obvious that they’ll always work fine?
    In the real world, things change, and what used to be simple becomes not so simple
    anymore.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你知道如何测试 `Counter` 类的方法，但你可能仍然有一个价值百万美元的问题：为什么测试像 `increment()` 和 `decrement()`
    这样简单的函数？它们不是总是能正常工作吗？在现实世界中，事情会发生变化，曾经简单的事情变得不再那么简单。
- en: Say the business logic for the `decrement()` function changes, and the new requirement
    is not to allow `counter` to be less than `2`. The developer changes the `decrement()`
    code to look like this the following.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `decrement()` 函数的业务逻辑发生了变化，新的要求是不允许 `counter` 小于 `2`。开发者将 `decrement()` 代码更改为以下样子。
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Suddenly, you have two possible *execution paths*:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 突然，你有两条可能的*执行路径*：
- en: The current counter value is greater than `2`.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前计数器的值大于 `2`。
- en: The current counter value is equal to `2`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前计数器的值等于 `2`。
- en: 'If you had the unit test for `decrement()`, the next time you run `ng test`
    it would fail, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为 `decrement()` 编写了单元测试，那么下次你运行 `ng test` 时，它将失败，如下所示：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* The text describes the spec that failed.**'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 文本描述了失败的 spec。**'
- en: '***2* The assertion failed because the code under test didn’t decrement the
    counter that was equal to zero.**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 断言失败，因为被测试的代码没有减少等于零的计数器。**'
- en: The fact that your unit test failed is a good thing, because it tells you that
    something changed in the application logic—in `decrement()`. Now the developer
    should see what changed and add another spec to the test suite so you have two
    `it()` blocks testing both execution paths of `decrement()` to ensure that it
    always works properly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您的单元测试失败是一个好事，因为它告诉您应用程序逻辑中发生了变化——在 `decrement()` 中。现在开发者应该查看发生了什么，并向测试套件中添加另一个
    spec，以便您有两个 `it()` 块来测试 `decrement()` 的两个执行路径，以确保它始终正常工作。
- en: In the real world, business requirements change pretty often, and if developers
    implement them without providing unit tests for the new functionality, your app
    can become unreliable and will keep you (or production support engineers) awake
    at night.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，业务需求经常变化，如果开发者在没有为新功能提供单元测试的情况下实现它们，您的应用程序可能会变得不可靠，并且会让您（或生产支持工程师）在夜间无法入睡。
- en: '|  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The output of the failed test may not be easy to read because it can include
    multiple lines of error stack trace. Consider using the continuous testing tool
    called Wallaby (see [https://wallabyjs.com/docs](https://wallabyjs.com/docs)),
    which shows you a short error message in your IDE right next to the code of the
    spec that failed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 失败测试的输出可能不易阅读，因为它可能包含多行错误堆栈跟踪。考虑使用名为 Wallaby 的持续测试工具（见 [https://wallabyjs.com/docs](https://wallabyjs.com/docs)），它会在您的
    IDE 中显示一个简短的错误消息，紧邻失败的 spec 代码。
- en: '|  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'In [chapter 12](kindle_split_021.xhtml#ch12), section 12.3.6, we explained
    how to automate the build process by running a sequence of npm scripts. If you
    add `ng test` to your build command, the build will be aborted if any of the unit
    tests fail. For example, the build script can look like this: `"build": "ng test
    && ng build"`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '在 [第 12 章](kindle_split_021.xhtml#ch12)，12.3.6 节中，我们解释了如何通过运行一系列 npm 脚本来自动化构建过程。如果您将
    `ng test` 添加到构建命令中，如果任何单元测试失败，构建将被终止。例如，构建脚本可以看起来像这样："build": "ng test && ng build"。'
- en: '|  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: It’s great that Angular CLI generates a Karma config file that works, but sometimes
    you may want to modify it based on your project needs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，Angular CLI 生成了一个可用的 Karma 配置文件，但有时您可能希望根据项目需求对其进行修改。
- en: 14.2.1\. Karma configuration file
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.1. Karma 配置文件
- en: When Angular CLI generates a new project, it includes karma.conf.js preconfigured
    to run Jasmine unit tests in the Chrome browser. You can read about all available
    configuration options at [http://mng.bz/82cQ](http://mng.bz/82cQ), but we’ll just
    highlight some of them that you may want to modify in your projects. The generated
    karma.conf.js file is shown in the following listing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Angular CLI 生成一个新项目时，它包括预先配置好的 karma.conf.js 文件，用于在 Chrome 浏览器中运行 Jasmine
    单元测试。您可以在 [http://mng.bz/82cQ](http://mng.bz/82cQ) 上阅读所有可用的配置选项，但我们将仅突出一些您可能希望在项目中修改的选项。以下列出的是生成的
    karma.conf.js 文件。
- en: Listing 14.7\. Angular CLI-generated karma.conf.js file
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.7\. Angular CLI 生成的 karma.conf.js 文件
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Includes the plugin for testing in Chrome**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含 Chrome 测试插件**'
- en: '***2* Includes the code coverage reporter**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 包含代码覆盖率报告器**'
- en: '***3* Includes the Angular CLI plugin for Karma**'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 包含 Angular CLI 的 Karma 插件**'
- en: '***4* Reports test progress on the console**'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在控制台上报告测试进度**'
- en: '***5* Uses karma-jasmine-html-reporter**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用 karma-jasmine-html-reporter**'
- en: '***6* Runs the HTML reporter on this port**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 在此端口上运行 HTML 报告器**'
- en: '***7* Lists the browsers to be used in tests**'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 列出测试中使用的浏览器**'
- en: '***8* Runs in a watch mode**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 以监视模式运行**'
- en: '|  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you want Karma to print a message about each completed spec on the console,
    add karma-mocha-reporter as `devDependency` in package.json, add the line `require('karma-mocha-reporter')`
    to karma.conf.js, and replace the `progress` reporter with `mocha`. If you run
    tests in continuous integration (CI) servers, use the karma-junit-reporter that
    can write test results into a file in JUnit XML format.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想让 Karma 在控制台打印每个完成的 spec 的消息，请在 package.json 中添加 karma-mocha-reporter 作为
    `devDependency`，将 `require('karma-mocha-reporter')` 行添加到 karma.conf.js 中，并用 `mocha`
    替换 `progress` 报告器。如果您在持续集成（CI）服务器上运行测试，请使用可以将测试结果写入 JUnit XML 格式文件的 karma-junit-reporter。
- en: '|  |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This configuration file uses only the Chrome plugin, but in real-world apps,
    you want to run tests in several browsers. The next section shows you how to add
    Firefox to the list of browsers to be used in tests.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置文件仅使用 Chrome 插件，但在现实世界的应用程序中，您希望在多个浏览器中运行测试。下一节将向您展示如何将 Firefox 添加到测试中使用的浏览器列表。
- en: 'Karma can report how well your code is covered with tests using the Istanbul
    reporter, and you can run the following command to generate the coverage report:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Karma 可以使用 Istanbul 报告器来报告你的代码测试覆盖率，你可以运行以下命令来生成覆盖率报告：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will create a directory called coverage that will include an index.html
    file that loads the coverage report. For example, your hello-jasmine project includes
    one `AppComponent` and the `Counter` class, which are completely covered with
    unit tests. The generated report is shown in [figure 14.5](#ch14fig05).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 coverage 的目录，其中包含一个加载覆盖率报告的 index.html 文件。例如，你的 hello-jasmine 项目包含一个
    `AppComponent` 和 `Counter` 类，它们完全被单元测试覆盖。生成的报告如图 14.5 所示。
- en: Figure 14.5\. Test coverage report for the hello-jasmine project
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.5. hello-jasmine 项目的测试覆盖率报告
- en: '![](Images/14fig05_alt.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片 14fig05_alt](Images/14fig05_alt.jpg)'
- en: '|  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Some organizations impose strict rules for code coverage, such as that at least
    90% of the code must be covered with unit tests or the build must fail. To enforce
    such coverage, install the npm package karma-istanbul-threshold and add the `istanbulThresholdReporter`
    section to karma.conf.js. For more details, see [http://mng.bz/544u](http://mng.bz/544u).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组织对代码覆盖率有严格的规则，例如至少 90% 的代码必须被单元测试覆盖，否则构建将失败。为了强制执行这种覆盖率，安装 npm 包 karma-istanbul-threshold
    并将 `istanbulThresholdReporter` 部分添加到 karma.conf.js 中。更多详情请参阅 [http://mng.bz/544u](http://mng.bz/544u)。
- en: '|  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 14.2.2\. Testing in multiple browsers
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.2. 在多个浏览器中进行测试
- en: Typically, a developer doesn’t manually test each and every code change in multiple
    browsers. Chrome is a preferred browser for dev mode, and you may be unpleasantly
    surprised when the tester reports that your app works well in Chrome, but produces
    errors in Safari, Firefox, or Internet Explorer. To eliminate these surprises,
    you should run unit tests in all browsers that matter to your users.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开发者不会在多个浏览器中手动测试每个代码更改。Chrome 是开发模式的首选浏览器，当测试人员报告你的应用程序在 Chrome 中运行良好，但在
    Safari、Firefox 或 Internet Explorer 中产生错误时，你可能会感到不愉快。为了消除这些惊喜，你应该在所有对用户重要的浏览器中运行单元测试。
- en: 'Luckily, that’s pretty easy to set up with Karma. Let’s say you want Karma
    to run tests not only in Chrome, but in Firefox as well (you have to have Firefox
    installed on your computer). First, install the karma-firefox-launcher plugin:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，使用 Karma 设置起来相当简单。假设你想要 Karma 不仅在 Chrome 中运行测试，还要在 Firefox 中运行（你必须在电脑上安装
    Firefox）。首先，安装 karma-firefox-launcher 插件：
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, add the following line in the `plugins` section of karma.conf.js:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 karma.conf.js 的 `plugins` 部分中添加以下行：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, add Firefox to the `browsers` list in karma.conf.js, so that it looks
    as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 Firefox 添加到 karma.conf.js 中的 `browsers` 列表中，使其看起来如下：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you need to set up a CI environment on a Linux server, you can either install
    Xvfb (a virtual display server) or use a *headless* browser (a browser without
    a UI). For example, you can specify `ChromeHeadless` to use the headless Chrome
    browser.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在 Linux 服务器上设置 CI 环境，你可以安装 Xvfb（一个虚拟显示服务器）或使用 *无头浏览器*（一个没有 UI 的浏览器）。例如，你可以指定
    `ChromeHeadless` 来使用无头 Chrome 浏览器。
- en: '|  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now if you run the `ng test` command, it’ll run the tests in both Chrome and
    Firefox. Install Karma plugins for each browser you care about, and this will
    eliminate surprises like “But it worked fine in Chrome!”
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行 `ng test` 命令，它将在 Chrome 和 Firefox 中运行测试。为每个你关心的浏览器安装 Karma 插件，这将消除“但在
    Chrome 中运行良好！”这样的惊喜。
- en: We’ve gone over the basics of writing and running unit tests. Let’s see how
    to unit-test Angular components, services, and the router.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了编写和运行单元测试的基础。让我们看看如何对 Angular 组件、服务和路由进行单元测试。
- en: 14.3\. Using the Angular testing library
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3. 使用 Angular 测试库
- en: Angular comes with a testing library that includes the wrappers for some Jasmine
    functions and adds such functions as `inject()`, `async()`, `fakeAsync()`, and
    others.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 内置了一个测试库，它包括一些 Jasmine 函数的包装器，并添加了 `inject()`、`async()`、`fakeAsync()`
    等函数。
- en: To test Angular artifacts, you need to create and configure an Angular module
    for the class under test using the `configureTestingModule()` method of the `TestBed`
    utility, which allows you to declare modules, components, providers, and so on.
    For example, the syntax for configuring a testing module looks similar to configuring
    `@NgModule()`, as you can see in the following listing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 Angular 组件，你需要使用 `TestBed` 工具的 `configureTestingModule()` 方法创建和配置测试用例的 Angular
    模块，这允许你声明模块、组件、提供者等。例如，配置测试模块的语法类似于配置 `@NgModule()`，如下所示。
- en: Listing 14.8\. Configuring the testing module for your app
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.8\. 为您的应用配置测试模块
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Runs this code asynchronously before each spec**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在每个规范之前异步运行此代码**'
- en: '***2* Configures the testing module**'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 配置测试模块**'
- en: '***3* Lists components under test**'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 列出测试组件**'
- en: '***4* Compiles components**'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 编译组件**'
- en: The `beforeEach()` function is used in test suites during the setup phase. With
    it you can specify the required modules, components, and providers that may be
    needed by each test. The `async()` function runs in the Zone and may be used with
    asynchronous code. The `async()` function doesn’t complete until all of its asynchronous
    operations have been completed or the specified timeout has passed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEach()` 函数在测试套件的设置阶段使用。通过它，你可以指定每个测试可能需要的所需模块、组件和提供者。`async()` 函数在 Zone
    中运行，可以与异步代码一起使用。`async()` 函数不会完成，直到其所有异步操作都已完成或指定的超时时间已通过。'
- en: In an Angular app, the components are “magically” created and services are injected,
    but in test scripts, you’ll need to explicitly instantiate components and invoke
    the `inject()` function or the `TestBed.get()` function to inject services. If
    a function under test invokes asynchronous functions, you should wrap such it
    into `async()` or `fakeAsync()`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 应用中，组件是“神奇地”创建的，服务被注入，但在测试脚本中，你需要显式实例化组件并调用 `inject()` 函数或 `TestBed.get()`
    函数来注入服务。如果被测试的函数调用了异步函数，你应该将这些函数包裹在 `async()` 或 `fakeAsync()` 中。
- en: '`async()` will run the function(s) under test in the Zone. If your test code
    uses time-outs, observables, or promises, wrap it into `async()` to ensure that
    the `expect()` function is invoked after all the asynchronous functions are complete.
    If you don’t do this, `expect()` may be executed before the results of async functions
    are in, and the test will fail. The `async()` function waits for async code to
    be finished, which is a good thing. On the other hand, such a wait may slow down
    the tests, and the `fakeAsync()` function allows you to eliminate the wait.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`async()` 将在 Zone 中运行被测试的函数（s）。如果你的测试代码使用了超时、观察者或承诺，请将其包裹在 `async()` 中，以确保在所有异步函数完成后调用
    `expect()` 函数。如果不这样做，`expect()` 可能会在异步函数的结果到来之前执行，从而导致测试失败。`async()` 函数等待异步代码完成，这是一个好事。另一方面，这样的等待可能会减慢测试速度，而
    `fakeAsync()` 函数允许你消除等待。'
- en: '`fakeAsync()` identifies the timers in the code under test and replaces the
    code inside `setTimeout()`, `setInterval()`, or the `debounceTime()` with immediately
    executed functions as if they’re synchronous, and executes them in order. It also
    gives you more-precise time control with the `tick()` and `flush()` functions,
    which allow you to fast-forward the time.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`fakeAsync()` 识别代码中测试的计时器，并用立即执行的函数替换 `setTimeout()`、`setInterval()` 或 `debounceTime()`
    中的代码，就像它们是同步的，并按顺序执行它们。它还通过 `tick()` 和 `flush()` 函数提供了更精确的时间控制，这些函数允许你快进时间。'
- en: You can optionally provide the time value in milliseconds for fast-forwarding,
    so there’s no need to wait, even if the async function uses `setTimeout()` or
    `Observable.interval()`. For example, if you have an input field that uses the
    RxJS operator `myInputField.valueChanges.debounceTime(500).subscribe()`, you can
    write `tick (499)` to fast-forward the time by 499 milliseconds and then assert
    that the subscriber didn’t get the data entered in the input field.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择提供以毫秒为单位的时间值进行快进，因此无需等待，即使异步函数使用了 `setTimeout()` 或 `Observable.interval()`。例如，如果你有一个使用
    RxJS 操作符 `myInputField.valueChanges.debounceTime(500).subscribe()` 的输入字段，你可以编写
    `tick (499)` 来快进 499 毫秒，然后断言订阅者没有接收到输入字段中输入的数据。
- en: You can use the `tick()` function only inside `fakeAsync()`. Calling `tick()`
    without the argument means that you want the code that follows to be executed
    after all pending asynchronous activities finish.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能在 `fakeAsync()` 中使用 `tick()` 函数。不带参数调用 `tick()` 表示你希望随后的代码在所有挂起的异步活动完成后执行。
- en: To see the tests from this section in action, open the unit-testing-samples
    project that comes with this chapter, run `npm install`, and then run `ng test`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看本节中的测试示例，请打开本章附带的项目 unit-testing-samples，运行 `npm install`，然后运行 `ng test`。
- en: Let’s see some of the APIs of the Angular testing library, starting with reviewing
    the code of the app.component.spec.ts file generated by Angular CLI.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Angular 测试库的一些 API，从审查由 Angular CLI 生成的 app.component.spec.ts 文件的代码开始。
- en: 14.3.1\. Testing components
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.1\. 测试组件
- en: Components are classes with templates. If a component’s class contains methods
    implementing some application logic, you can test them as you would any other
    function. But more often, you’ll be testing the UI to see that the bindings work
    properly and that the component template displays expected data.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是带有模板的类。如果一个组件的类包含实现某些应用程序逻辑的方法，您可以像测试任何其他函数一样测试它们。但更常见的是，您会测试UI，以确保绑定正常工作，并且组件模板显示预期的数据。
- en: 'Under the hood, an Angular component consists of two parts: an instance of
    the class and the DOM element. Technically, when you write a unit test for a component,
    it’s more of an integration test, because it has to check that the instance of
    the component class and the DOM object work in sync.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，Angular组件由两部分组成：类的实例和DOM元素。技术上，当您为一个组件编写单元测试时，它更像是一个集成测试，因为它必须检查组件类的实例和DOM对象是否同步工作。
- en: The Angular testing library offers the `TestBed.createComponent()` method, which
    returns a `ComponentFixture` object that gives you access to both the component
    and the native DOM object of the rendered template.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Angular测试库提供了`TestBed.createComponent()`方法，该方法返回一个`ComponentFixture`对象，它使您能够访问渲染模板的组件和原生DOM对象。
- en: To access the component instance, you can use the `ComponentFixture.componentInstance`
    property, and to access the DOM element, use `ComponentFixture.nativeElement`.
    If you want to get access to the fixture’s API (for example, to access the component’s
    injector, run CSS query selectors, find styles or child nodes, or trigger an event
    handler), use its `DebugElement`, as in `ComponentFixture.debugElement.componentInstance`
    and `ComponentFixture.debugElement.nativeElement`, respectively. [Figure 14.6](#ch14fig06)
    illustrates some of the properties of the `ComponentFixture` object, which also
    exist in `debugElement`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问组件实例，您可以使用`ComponentFixture.componentInstance`属性，要访问DOM元素，使用`ComponentFixture.nativeElement`。如果您想访问固定装置的API（例如，访问组件的注入器、运行CSS查询选择器、查找样式或子节点或触发事件处理器），请使用其`DebugElement`，如`ComponentFixture.debugElement.componentInstance`和`ComponentFixture.debugElement.nativeElement`，分别。[图14.6](#ch14fig06)说明了`ComponentFixture`对象的一些属性，这些属性也存在于`debugElement`中。
- en: Figure 14.6\. Properties of `ComponentFixture`
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.6\. `ComponentFixture`的属性
- en: '![](Images/14fig06_alt.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14fig06_alt.jpg)'
- en: To update the bindings, you can trigger the change detection cycle on the component
    by invoking the `detectChanges()` method on the fixture. After change detection
    has updated the UI, you can run the `expect()` function to check the rendered
    values.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新绑定，您可以通过在固定装置上调用`detectChanges()`方法来触发组件上的更改检测周期。更改检测更新UI后，您可以运行`expect()`函数来检查渲染的值。
- en: 'After configuring the test module, you usually perform the following steps
    to test a component:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置测试模块后，您通常执行以下步骤来测试组件：
- en: '**1**.  Invoke `TestBed.createComponent()` to create a component.'
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 调用`TestBed.createComponent()`来创建组件。'
- en: '**2**.  Use a reference to `componentInstance` to invoke the component’s methods.'
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 使用对`componentInstance`的引用来调用组件的方法。'
- en: '**3**.  Invoke `ComponentFixture.detectChanges()` to trigger change detection.'
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 调用`ComponentFixture.detectChanges()`来触发更改检测。'
- en: '**4**.  Use a reference to `nativeElement` to access the DOM object and check
    whether it has the expected value.'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 使用对`nativeElement`的引用来访问DOM对象并检查它是否具有预期的值。'
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you want change detection to be triggered automatically, you can configure
    the testing module with the provider for the `ComponentFixtureAutoDetect` service.
    Although this seems to be a better choice than manually invoking `detectChanges()`,
    this service only notices the asynchronous activities and won’t react to synchronous
    updates of component properties.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想自动触发更改检测，您可以通过配置测试模块中的`ComponentFixtureAutoDetect`服务的提供者来实现。尽管这似乎比手动调用`detectChanges()`更好，但此服务仅注意异步活动，不会对组件属性的同步更新做出反应。
- en: '|  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Let’s examine the code of the generated app.component.spec.ts file and see
    how it performs these steps. This Angular CLI–generated script declares a test
    suite containing three specs:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查生成的`app.component.spec.ts`文件的代码，看看它是如何执行这些步骤的。这个由Angular CLI生成的脚本声明了一个包含三个规格的测试套件：
- en: '**1**.  Check that the component instance is created.'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 检查组件实例是否已创建。'
- en: '**2**.  Check that this component has a `title` property with the value `app`.'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 检查该组件有一个值为`app`的`title`属性。'
- en: '**3**.  Check that the UI has an `<h1>` element with the text “Welcome to app!”'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 检查UI中是否有文本为“欢迎使用app!”的`<h1>`元素'
- en: The code is shown in the following listing.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下所示。
- en: Listing 14.9\. app.component.spec.ts
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.9\. app.component.spec.ts
- en: '[PRE18]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Imports the required modules from the Angular testing library**'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从Angular测试库导入所需的模块**'
- en: '***2* Wraps component compilation into async()**'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将组件编译包装成async()**'
- en: '***3* In setup phase, configures the testing module asynchronously in the Zone**'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在设置阶段，异步地在Zone中配置测试模块**'
- en: '***4* Compiles component(s) to inline styles and templates**'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将组件编译成内联样式和模板**'
- en: '***5* Instantiates the AppComponent**'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 实例化AppComponent**'
- en: '***6* Gets a reference to the component’s instance**'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 获取组件实例的引用**'
- en: '***7* Checks that the coercion of the app to a Boolean yields true**'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 检查将app转换为布尔值的结果为true**'
- en: '***8* Triggers change detection to update the component’s DOM object**'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 触发更改检测以更新组件的DOM对象**'
- en: '***9* Gets a reference to the DOM object**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 获取DOM对象的引用**'
- en: '***10* Checks that the DOM object has the <h1> element containing this text**'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 检查DOM对象是否包含包含此文本的<h1>元素**'
- en: Note that the functions that instantiate the component are wrapped into `async()`.
    That’s because a component can have a template and styles in separate files, and
    reading files is an asynchronous operation.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，实例化组件的函数被包装在`async()`中。这是因为组件可以有自己的模板和样式文件，而读取文件是一个异步操作。
- en: Invoking `detectChanges()` triggers change detection that updates the bindings
    on the DOM elements. After this is done, you can query the content of the DOM
    elements to assure that the UI shows the expected values.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`detectChanges()`触发更改检测，更新DOM元素上的绑定。在此之后，你可以查询DOM元素的内容，以确保UI显示预期的值。
- en: '|  |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Currently, Angular CLI generates the test with repeating `createComponent()`
    invocations. A better solution would be to write another `beforeEach()` function
    and create the fixture there.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Angular CLI通过重复调用`createComponent()`生成测试。更好的解决方案是编写另一个`beforeEach()`函数并在那里创建固定装置。
- en: '|  |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Running `ng test` in a newly generated project will report that all tests passed.
    The browser opens at http://localhost:9876, and you’ll see the testing report
    shown in [figure 14.7](#ch14fig07).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在新创建的项目中运行`ng test`将报告所有测试通过。浏览器将在http://localhost:9876打开，你将看到[图14.7](#ch14fig07)中显示的测试报告。
- en: Figure 14.7\. A successful run of `ng test`
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.7\. `ng test`的成功运行
- en: '![](Images/14fig07.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14fig07.jpg)'
- en: Let’s see what happens if you change the value of the `title` property in the
    `AppComponent` from `app` to `my app`. Because `ng test` runs in watch mode, the
    tests will automatically rerun, you’ll see the messages about two failed specs
    on the console, and the list of specs will look like [figure 14.8](#ch14fig08)
    (the failed specs are shown in red if you have the e-book).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果你将AppComponent中的`title`属性值从`app`更改为`my app`会发生什么。因为`ng test`在监视模式下运行，测试将自动重新运行，你将在控制台看到关于两个失败的规格的消息，规格列表将看起来像[图14.8](#ch14fig08)（如果你有电子书，失败的规格将以红色显示）。
- en: Figure 14.8\. Spec list with failures
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.8\. 包含失败的规格列表
- en: '![](Images/14fig08.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14fig08.jpg)'
- en: The first failed spec message reads “AppComponent should have as title ‘app’,”
    and the second message is “AppComponent should render title in a h1 tag.” These
    are the messages provided in the `it()` functions. Clicking any of the failed
    specs will open another page, providing more details and the stack trace.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个失败的规格消息是“AppComponent应该有标题‘app’”，第二个消息是“AppComponent应该在h1标签中渲染标题。”这些是在`it()`函数中提供的消息。点击任何失败的规格将打开另一个页面，提供更多细节和堆栈跟踪。
- en: '|  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Keep in mind that if your component uses lifecycle hooks, they won’t be called
    automatically. You need to call them explicitly, as in `app .ngOnInit()`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果你的组件使用生命周期钩子，它们不会自动调用。你需要显式调用它们，就像`app.ngOnInit()`一样。
- en: '|  |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s add another spec in the next listing to ensure that if the `title` property
    changes in the `AppComponent` class, it’ll be properly rendered in the UI.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一个列表中添加另一个规格，以确保如果AppComponent类中的`title`属性发生变化，它将在UI中正确渲染。
- en: Listing 14.10\. A spec for the `title` update
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.10\. 更新`title`的规格
- en: '[PRE19]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Updates the title property**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 更新标题属性**'
- en: '***2* Forces change detection**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 强制更改检测**'
- en: '***3* Checks that the UI reflects the updated title**'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 检查UI是否反映了更新的标题**'
- en: Now `ng test` will run this extra spec and will report that it successfully
    finished. In this section, you used the generated test for `AppComponent`, but
    you’ll see another script that tests a component in the hands-on section.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `ng test` 将运行这个额外的规格，并报告它已成功完成。在本节中，你使用了为 `AppComponent` 生成的测试，但你在实践部分将看到另一个测试组件的脚本。
- en: A typical component uses services for data manipulation, and you create mock
    services that return hardcoded (and the same) values to concentrate on testing
    the component’s functionality. The specs for components should test only components;
    services should be tested separately.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的组件使用服务进行数据处理，你创建模拟服务，返回硬编码（且相同）的值，以便专注于测试组件的功能。组件的规范应该只测试组件；服务应该单独测试。
- en: 14.3.2\. Testing services
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.2\. 测试服务
- en: A service is a class with one or more methods, and you unit-test only the public
    ones, which in turn may invoke private methods. In Angular apps, you specify providers
    for services in `@Component` or `@NgModule`, so Angular can properly instantiate
    and inject them. In test scripts, you also declare providers for services under
    test, but you do this inside `TestBed.configureTestingModule()` in the setup phase.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是一个包含一个或多个方法的类，你只对公共方法进行单元测试，这些方法反过来可能调用私有方法。在 Angular 应用中，你在 `@Component`
    或 `@NgModule` 中指定服务的提供者，以便 Angular 可以正确实例化和注入它们。在测试脚本中，你也在设置阶段在 `TestBed.configureTestingModule()`
    内声明测试服务的提供者。
- en: Also, if in Angular apps you can use the provider’s token in the class constructor
    to inject a service, in tests, the injection is done differently. For example,
    you can explicitly invoke the `inject()` function. The other option to instantiate
    and inject a service is to use the `TestBed.get()` method, which uses the root
    injector, as shown in [figure 14.9](#ch14fig09). This will work if the service
    provider is specified in the root testing module.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你在 Angular 应用中可以在类构造函数中使用提供者的令牌来注入服务，在测试中，注入方式不同。例如，你可以显式调用 `inject()`
    函数。另一种实例化和注入服务的方法是使用 `TestBed.get()` 方法，它使用根注入器，如 [图 14.9](#ch14fig09) 所示。如果服务提供者在根测试模块中指定，这将有效。
- en: Figure 14.9\. Injecting a service into the test script
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.9\. 将服务注入测试脚本
- en: '![](Images/14fig09_alt.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14fig09_alt.jpg)'
- en: 'Component-level injectors can be used as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 组件级注入器可以使用如下方式：
- en: '[PRE20]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s generate a product service by running the following Angular CLI command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行以下 Angular CLI 命令来生成一个产品服务：
- en: '[PRE21]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This command will generate the files product.service.ts and product.service.spec.ts.
    The latter will contain the boilerplate code shown in the following listing.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将生成 product.service.ts 和 product.service.spec.ts 文件。后者将包含以下列表中显示的样板代码。
- en: Listing 14.11\. product.service.spec.ts
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.11\. product.service.spec.ts
- en: '[PRE22]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Configures the provider**'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 配置提供者**'
- en: '***2* Injects the service**'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入服务**'
- en: '***3* Implements the testing logic**'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 实现测试逻辑**'
- en: 'If you needed to inject more than one service, the `inject()` function would
    list an array of DI tokens followed by the function with the argument list corresponding
    to the names of tokens:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要注入多个服务，`inject()` 函数将列出 DI 令牌数组，后跟与令牌名称对应的参数列表的函数：
- en: '[PRE23]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you add methods to the `ProductService` class, you could test them similarly
    to testing methods in the `Counter` class, as you did earlier, but you need to
    consider a special case when a service relies on another service, such as on `HttpClient`.
    Making HTTP requests to a server during unit tests would slow them down. Besides,
    you don’t want your unit tests to fail if the server’s down. Remember, unit tests
    are for testing isolated pieces of code.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向 `ProductService` 类添加方法时，你可以像之前测试 `Counter` 类中的方法一样测试它们，但你需要考虑一个特殊情况，即当服务依赖于另一个服务，例如
    `HttpClient` 时。在单元测试期间向服务器发送 HTTP 请求会减慢测试速度。此外，你不想因为服务器故障而导致单元测试失败。记住，单元测试是为了测试独立的代码片段。
- en: The code that comes with this chapter includes the unit-testing-samples project
    and the app called readfile. It includes `ProductService`, which uses `HttpClient`
    to read the data/products.json file, as shown in the following listing.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 本章附带代码包括单元测试示例项目和一个名为 readfile 的应用。它包括 `ProductService`，该服务使用 `HttpClient` 读取
    data/products.json 文件，如下所示列表。
- en: Listing 14.12\. Reading data/products.json in a service
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.12\. 在服务中读取 data/products.json
- en: '[PRE24]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Injects HttpClient**'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注入 HttpClient**'
- en: '***2* Reads the file**'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 读取文件**'
- en: Let’s write a unit test for the `getProducts()` method. You don’t want your
    test to fail if someone removes the data/products.json file, because that wouldn’t
    mean there’s an issue in `getProducts()`. You’ll mock the `HttpClient` with the
    help of `HttpTestingController` from `HttpClientTestingModule`. `HttpTestingController`
    doesn’t make an HTTP request but allows you to emulate it using hardcoded data.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `getProducts()` 方法编写一个单元测试。你不希望测试失败，如果有人删除了 data/products.json 文件，因为这并不意味着
    `getProducts()` 中存在问题。你将使用 `HttpClientTestingModule` 中的 `HttpTestingController`
    来模拟 `HttpClient`。`HttpTestingController` 不会发出 HTTP 请求，但允许你使用硬编码的数据来模拟它。
- en: To add the hardcoded data to the response body, you’ll use the `HttpTestingController.flush()`
    method, and to emulate an error, you’ll use `HttpTestingController.error()`, as
    shown in the following listing.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要将硬编码的数据添加到响应体中，你将使用 `HttpTestingController.flush()` 方法，要模拟错误，你将使用 `HttpTestingController.error()`，如下面的列表所示。
- en: Listing 14.13\. product.service.spec.ts
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.13\. product.service.spec.ts
- en: '[PRE25]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* Includes HttpClientTestingModule to the testing module**'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 HttpClientTestingModule 添加到测试模块**'
- en: '***2* Injects ProductService**'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入 ProductService**'
- en: '***3* Injects HttpTestingController**'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注入 HttpTestingController**'
- en: '***4* Prepares hardcoded product data**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 准备硬编码的产品数据**'
- en: '***5* Subscribes to the response and asserts the result**'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 订阅响应并断言结果**'
- en: '***6* Sends the product data to the client**'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将产品数据发送到客户端**'
- en: '***7* Prepares the error message**'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 准备错误消息**'
- en: '***8* Doesn’t handle product data**'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 不处理产品数据**'
- en: '***9* Asserts that the expected error was received**'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 断言接收到了预期的错误**'
- en: '***10* Sends the error to the client**'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 将错误发送到客户端**'
- en: '***11* Asserts that there are no outstanding requests**'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11* 断言没有挂起的请求**'
- en: In the first spec, you hardcode the data for one product and then invoke `getProducts()`
    and subscribe to the response.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个规范中，你为单个产品硬编码数据，然后调用 `getProducts()` 并订阅响应。
- en: '|  |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Jasmine offers a `spyOn()` function that could intercept the specified function
    (for example, `getProducts()`), where you could just return a stub object with
    the expected data. But using such a spy wouldn’t make an HTTP request. Because
    you use `HttpTestingController`, the HTTP request is made and will be intercepted
    by `HttpTestingController`, which won’t be making a real HTTP request to read
    products.json but will take the hardcoded product data and send it through the
    HTTP machinery.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine 提供了一个 `spyOn()` 函数，可以拦截指定的函数（例如，`getProducts()`），你可以在其中返回一个包含预期数据的存根对象。但使用这样的存根不会发出
    HTTP 请求。因为使用了 `HttpTestingController`，HTTP 请求会被发出并被 `HttpTestingController` 拦截，它不会向读取
    products.json 发出真实的 HTTP 请求，而是将硬编码的产品数据通过 HTTP 机制发送。
- en: '|  |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You expect the `getProducts()` method to make a single request to /data/products
    .json and return its mock, and this is what `expectOne()` is for. If no such request
    has been made, or if more than one such request has been made, the spec will fail.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你期望 `getProducts()` 方法对 /data/products .json 发出单个请求并返回其模拟，这就是 `expectOne()`
    的作用。如果没有发出此类请求，或者发出了多个此类请求，规范将失败。
- en: With the real `HttpClient` service, invoking the `subscribe()` method would
    result in receiving either the data or an error, but with `HttpTestingController`,
    the subscriber won’t get any data until you invoke `flush()` or `error()`. Here,
    you provide hardcoded data in the response body.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用真实的 `HttpClient` 服务，调用 `subscribe()` 方法会导致接收数据或错误，但使用 `HttpTestingController`，订阅者将不会收到任何数据，直到你调用
    `flush()` 或 `error()`。在这里，你将在响应体中提供硬编码的数据。
- en: When Karma opens the browser with the test results, you can open Chrome Dev
    Tools in the Sources tab, find the source code for your spec file, and add breakpoints
    to debug your test code just as you’d do with any TypeScript code. In particular,
    if you place a breakpoint in the line that invokes `flush()` in [listing 14.13](#ch14ex13),
    you’ll see that it’s invoked before the code in `subscribe()`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Karma 打开浏览器并显示测试结果时，你可以在“源”标签页中打开 Chrome Dev Tools，找到你的 spec 文件的源代码，并添加断点来调试你的测试代码，就像调试任何
    TypeScript 代码一样。特别是，如果你在 [列表 14.13](#ch14ex13) 中调用 `flush()` 的行上放置断点，你会看到它在 `subscribe()`
    中的代码之前被调用。
- en: The `verify()` method tested all HTTP requests, and there are no outstanding
    ones. You assert this in the teardown phase after running each spec.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`verify()` 方法测试了所有 HTTP 请求，并且没有挂起的请求。你会在每个规范运行后的清理阶段断言这一点。'
- en: Note that the code in each spec is wrapped into the `async()` function. This
    ensures that your `expect()` calls will be made after all asynchronous calls from
    the spec are complete.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个规格中的代码都被包装在 `async()` 函数中。这确保了您的 `expect()` 调用将在规格中的所有异步调用完成后进行。
- en: '|  |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You can read about other techniques for replacing real services with mocks,
    stubs, and spies in the Angular testing documentation at [https://angular.io/guide/testing](https://angular.io/guide/testing).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Angular 测试文档中阅读有关用模拟、存根和间谍替换真实服务的其他技术的信息，请参阅 [https://angular.io/guide/testing](https://angular.io/guide/testing)。
- en: '|  |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now let’s see how to test the router.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何测试路由。
- en: 14.3.3\. Testing components that use routing
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.3\. 测试使用路由的组件
- en: If a component includes routing, you may want to test different navigation functionality.
    For example, you may want to test that the router properly navigates where it’s
    supposed to, that parameters are properly passed to the destination component,
    and that the guards don’t let unauthorized users visit certain routes.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果组件包含路由，您可能想要测试不同的导航功能。例如，您可能想要测试路由是否正确地导航到它应该去的地方，参数是否正确传递到目标组件，以及守卫是否不允许未经授权的用户访问某些路由。
- en: To test router-related functionality, Angular offers the `RouterTestingModule`,
    which intercepts navigation but doesn’t load the destination component. For the
    test, you need the router configuration; you can either use the same one that’s
    used in the application or create a separate configuration just for testing. The
    latter could be a better option if your route configuration includes many components.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试路由相关的功能，Angular 提供了 `RouterTestingModule`，它可以拦截导航但不加载目标组件。对于测试，你需要路由配置；你可以使用应用程序中使用的相同配置，或者创建一个仅用于测试的单独配置。如果您的路由配置包含许多组件，后者可能是一个更好的选择。
- en: A user can navigate the app either by interacting with the application or by
    entering a URL directly in the browser’s address bar. The `Router` object is responsible
    for navigation implemented in your app code, and the `Location` object represents
    the URL in the address bar. These two objects work in sync.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过与应用程序交互或直接在浏览器地址栏中输入 URL 来导航应用程序。`Router` 对象负责在您的应用程序代码中实现的导航，而 `Location`
    对象表示地址栏中的 URL。这两个对象协同工作。
- en: To test if the router properly navigates your app, invoke `navigate()` and `navigateByUrl()`
    in your specs, and pass parameters, if needed. The `navigate()` method takes an
    array of routes and parameters as an argument, whereas `navigateByUrl()` takes
    a string representing the segment of the URL you want to navigate to.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试路由是否正确导航您的应用程序，请在您的规格说明中调用 `navigate()` 和 `navigateByUrl()`，如果需要，传递参数。`navigate()`
    方法接受一个包含路由和参数的数组作为参数，而 `navigateByUrl()` 接受一个表示您想要导航到的 URL 段的字符串。
- en: If you use `navigate()`, you specify the configured path and route params, if
    any. If the router is properly configured, it should update the URL in the address
    bar of the browser. To illustrate this, you’ll reuse the code of one of the apps
    from [chapter 3](kindle_split_012.xhtml#ch03), but you’ll add the spec file. In
    that app, the router configuration for the `AppComponent` includes the path /product/:id,
    as shown in the following listing.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 `navigate()`，您指定配置的路径和路由参数（如果有的话）。如果路由配置正确，它应该更新浏览器地址栏中的 URL。为了说明这一点，您将重用
    [第 3 章](kindle_split_012.xhtml#ch03) 中一个应用程序的代码，但您将添加规格文件。在该应用程序中，`AppComponent`
    的路由配置包括路径 /product/:id，如下面的列表所示。
- en: Listing 14.14\. A fragment from app.routing.ts
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.14\. app.routing.ts 的一部分
- en: '[PRE26]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* A default route**'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 默认路由**'
- en: '***2* A route with a parameter**'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 带有参数的路由**'
- en: When the user clicks the Product Details link, the app navigates to the `ProductDetailComponent`,
    as shown in the following listing.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击产品详情链接时，应用程序将导航到 `ProductDetailComponent`，如下面的列表所示。
- en: Listing 14.15\. app.component.ts
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.15\. app.component.ts
- en: '[PRE27]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* A link to navigate to the product-detail view**'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导航到产品详情视图的链接**'
- en: '***2* The value to be passed to the product-detail view**'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 要传递给产品详情视图的值**'
- en: In the app.component.spec.ts file, you’ll test that when the user clicks the
    Product Details link, the URL includes the segment /product/1234\. The `Router`
    and `Location` objects will be injected by using the `TestBed.get()` API. To emulate
    the click on the Product Details link, you need to get access to the corresponding
    DOM object, which you do by using the `By.css()` API. The utility class `By` has
    the `css()` method, which matches elements using the provided CSS selector. Because
    your app component has two links, you assign `id=product` to the product-details
    link so you can get ahold of it by invoking `By.css('#product')`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app.component.spec.ts` 文件中，您将测试当用户点击产品详情链接时，URL 包含段 /product/1234。您将通过使用
    `TestBed.get()` API 注入 `Router` 和 `Location` 对象。为了模拟点击产品详情链接，您需要获取相应的 DOM 对象，这可以通过使用
    `By.css()` API 实现。实用类 `By` 有 `css()` 方法，它使用提供的 CSS 选择器匹配元素。因为您的应用程序组件有两个链接，所以您将
    `id=product` 分配给产品详情链接，这样您就可以通过调用 `By.css('#product')` 来获取它。
- en: 'To emulate the click on the link, you use the `triggerEventHandler()` method
    with two arguments. The first argument has the value `click` that represents the
    click event. The second argument has the value `{button: 0}` that represents the
    event object. The `RouterLink` directive expects the value to include the property
    `button` with the number that represents the mouse button, and zero is for the
    left mouse button, as shown in the following listing.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '为了模拟点击链接，你使用 `triggerEventHandler()` 方法并传入两个参数。第一个参数的值为 `click`，代表点击事件。第二个参数的值为
    `{button: 0}`，代表事件对象。`RouterLink` 指令期望的值应包含表示鼠标按钮的 `button` 属性，其中零表示左鼠标按钮，如下所示。'
- en: Listing 14.16\. app.component.spec.ts
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.16\. app.component.spec.ts
- en: '[PRE28]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* Loads the routes configuration**'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 加载路由配置**'
- en: '***2* Injects the Router object**'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入 Router 对象**'
- en: '***3* Injects the Location object**'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注入 Location 对象**'
- en: '***4* Triggers change detection**'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 触发变更检测**'
- en: '***5* Get access to the product-details link**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 获取产品详情链接的访问权限**'
- en: '***6* Clicks the link**'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 点击链接**'
- en: '***7* Checks the assertion**'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 检查断言**'
- en: The `fakeAsync()` function wraps the navigation code (the asynchronous operation),
    and the `tick()` function ensures that the asynchronous navigation finishes before
    you run the assertion.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`fakeAsync()` 函数包装导航代码（异步操作），而 `tick()` 函数确保在您运行断言之前异步导航完成。'
- en: '[Figure 14.10](#ch14fig10) shows the sequence of actions performed by the preceding
    script.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14.10](#ch14fig10) 展示了前面脚本执行的动作序列。'
- en: Figure 14.10\. Steps in testing navigation
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.10\. 测试导航步骤
- en: '![](Images/14fig10_alt.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14fig10_alt.jpg)'
- en: The `ng test` command will run all unit tests in the unit-testing-samples project,
    which has three apps. All eight specs should successfully complete. The eighth
    spec will report “AppComponent can navigate and pass params to the product detail
    view.”
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng test` 命令将在单元测试样本项目中运行所有单元测试，该项目包含三个应用程序。所有八个规范都应该成功完成。第八个规范将报告“AppComponent
    可以导航并将参数传递到产品详情视图”。'
- en: '|  |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: To make unit testing a part of your automated build process, integrate the `ng
    test` command into the build process by adding `&& ng test` to the npm build script
    described in section 12.3.6 in [chapter 12](kindle_split_021.xhtml#ch12).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 要将单元测试集成到您的自动化构建过程中，请通过在 12.3.6 节中描述的 npm 构建脚本中添加 `&& ng test` 来将 `ng test`
    命令集成到构建过程中。[第 12 章](kindle_split_021.xhtml#ch12)。
- en: '|  |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Unit testing the functionality implemented in the route guards is another practical
    use case. In [chapter 4](kindle_split_013.xhtml#ch04), we covered such guards
    as `CanActivate`, `CanDeactivate`, and `Resolve`. Because guards are services,
    you can test them separately, as explained in the preceding section.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试在路由守卫中实现的功能是另一个实际用例。在第 4 章（kindle_split_013.xhtml#ch04）中，我们介绍了 `CanActivate`、`CanDeactivate`
    和 `Resolve` 等守卫。因为守卫是服务，您可以像前节中解释的那样单独测试它们。
- en: This concludes our coverage of unit-testing basics. Unit tests assert that each
    artifact of your Angular app works as expected in isolation. But how can you ensure
    that several components, services, and other artifacts play well together without
    the need to manually test each workflow?
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对单元测试基础知识的介绍。单元测试断言您的 Angular 应用程序中的每个工件在独立情况下按预期工作。但您如何确保几个组件、服务和其它工件在没有手动测试每个工作流的情况下能够良好协作呢？
- en: 14.4\. End-to-end testing with Protractor
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4\. 使用 Protractor 进行端到端测试
- en: End-to-end (E2E) testing is for testing the entire app workflow by simulating
    user interaction with the app. For example, the process of placing an order may
    use multiple components and services. You can create an E2E test to ensure that
    this workflow behaves as expected. Also, if in unit tests you’re mocking dependencies,
    E2E tests will use the real ones.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端（E2E）测试是通过模拟用户与应用的交互来测试整个应用工作流程。例如，下订单的过程可能涉及多个组件和服务。您可以创建一个端到端测试来确保此工作流程按预期行为。此外，如果在单元测试中您正在模拟依赖项，端到端测试将使用真实的依赖项。
- en: To manually test a specific workflow like the login functionality, a QA engineer
    prepares an ID/password that works, opens the login page, enters the ID/password,
    and clicks the Login button. After that, QA wants to assert that the landing page
    of your app is successfully rendered. The tester can also run another test to
    ensure that if the wrong ID/password is entered, the landing page won’t be rendered.
    This is a manual way of E2E testing of the login workflow.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动测试特定的工作流程，例如登录功能，质量保证工程师准备一个有效的ID/密码，打开登录页面，输入ID/密码，然后点击登录按钮。之后，质量保证工程师希望断言您的应用着陆页已成功渲染。测试人员还可以运行另一个测试以确保如果输入错误的ID/密码，着陆页不会渲染。这是登录工作流程端到端测试的手动方式。
- en: Protractor is a testing library that allows you to test app workflows *simulating*
    user actions without the need to perform them manually. You still need to prepare
    test data and script the test logic, but the tests will run without human interaction.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor是一个测试库，允许您在不手动执行的情况下模拟用户操作来测试应用工作流程。您仍然需要准备测试数据和编写测试逻辑，但测试将在没有人工交互的情况下运行。
- en: By default, Protractor uses the Jasmine syntax for tests, unless you manually
    configure another supported framework (see [http://mng.bz/d64d](http://mng.bz/d64d)).
    So your E2E test scripts will use already familiar `describe()` and `it()` blocks
    plus an additional API.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Protractor使用Jasmine语法进行测试，除非您手动配置另一个支持的框架（见[http://mng.bz/d64d](http://mng.bz/d64d)）。因此，您的端到端测试脚本将使用已经熟悉的`describe()`和`it()`块以及额外的API。
- en: 14.4.1\. Protractor basics
  id: totrans-352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.4.1. Protractor基础
- en: While manually testing app workflows, a user “drives” the web browser by entering
    data, selecting options, and clicking buttons. Protractor is based on Selenium
    WebDriver (see [http://www.seleniumhq.org/docs/03_webdriver.jsp](http://www.seleniumhq.org/docs/03_webdriver.jsp))
    that can automatically drive the browser, based on the provided scripts. Protractor
    also includes an Angular-specific API for locating UI elements.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在手动测试应用工作流程时，用户通过输入数据、选择选项和点击按钮来“驾驶”网络浏览器。Protractor基于Selenium WebDriver（见[http://www.seleniumhq.org/docs/03_webdriver.jsp](http://www.seleniumhq.org/docs/03_webdriver.jsp)），它可以根据提供的脚本自动驱动浏览器。Protractor还包括用于定位UI元素的Angular特定API。
- en: In your setup, Protractor will run the web browser and tests on the same machine,
    so you need Selenium WebDriver for the browser(s) you want to run the tests in.
    The other option would be to set up a separate machine for testing and run Selenium
    Server there. Selenium offers implementations of WebDriver for different programming
    languages, and Protractor uses the one called WebDriverJS.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的设置中，Protractor将在同一台机器上运行网络浏览器和测试，因此您需要为要在其中运行测试的浏览器安装Selenium WebDriver。另一种选择是为测试设置一台单独的机器并在那里运行Selenium
    Server。Selenium为不同的编程语言提供了WebDriver的实现，Protractor使用的是WebDriverJS。
- en: When you generate a new project with Angular CLI, it includes Protractor and
    its configuration files as well as the e2e directory with sample test scripts.
    Prior to Angular 6, the e2e directory included three files, as shown in [figure
    14.11](#ch14fig11). Starting from Angular 6, the generated e2e directory includes
    the configuration file protractor .conf.js.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Angular CLI生成一个新项目时，它包括Protractor及其配置文件以及包含示例测试脚本的e2e目录。在Angular 6之前，e2e目录包含三个文件，如图14.11所示。[figure
    14.11](#ch14fig11)。从Angular 6开始，生成的e2e目录包括配置文件protractor .conf.js。
- en: Figure 14.11\. Angular CLI-generated E2E code
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.11. Angular CLI生成的E2E代码
- en: '![](Images/14fig11_alt.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14fig11_alt.jpg)'
- en: '|  |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'Starting from Angular CLI 6, when you generate a new project, it includes two
    apps: one is a project for your app, and another app contains the basic E2E tests.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 从Angular CLI 6开始，当你生成一个新项目时，它包括两个应用：一个是您的应用项目，另一个应用包含基本的端到端测试。
- en: '|  |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You run the E2E tests by entering the `ng e2e` command, which loads the test
    scripts based on the configuration in the protractor.conf.js file. That file by
    default assumes that all E2E test scripts are located in the e2e directory, and
    the app has to be launched in Chrome.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过输入 `ng e2e` 命令来运行 E2E 测试，该命令根据 protractor.conf.js 文件中的配置加载测试脚本。该文件默认假设所有
    E2E 测试脚本都位于 e2e 目录中，并且应用程序必须在 Chrome 中启动。
- en: Listing 14.17\. A fragment from protractor.conf.js
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.17\. protractor.conf.js 的一个片段
- en: '[PRE29]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* Where the test scripts are**'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 测试脚本的位置**'
- en: '***2* Which browser to run your app in**'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在哪个浏览器中运行你的应用程序**'
- en: '***3* Connects to the browser directly without the server**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 直接连接到浏览器而不通过服务器**'
- en: The `ng e2e` command builds the app bundles, starts the Node instance, and loads
    the test scripts, Protractor, and Selenium WebDriver. Protractor launches your
    app in the browser(s), and your test scripts communicate with the browser using
    the API of Protractor and WebDriverJS. [Figure 14.12](#ch14fig12) shows the E2E
    test players used in this chapter’s examples.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng e2e` 命令构建应用程序包，启动 Node 实例，并加载测试脚本、Protractor 和 Selenium WebDriver。Protractor
    在浏览器（s）中启动你的应用程序，并且你的测试脚本通过 Protractor 和 WebDriverJS 的 API 与浏览器进行通信。[图 14.12](#ch14fig12)
    展示了本章示例中使用的 E2E 测试玩家。'
- en: Figure 14.12\. Angular CLI–generated E2E code
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.12\. 由 Angular CLI 生成的 E2E 代码
- en: '![](Images/14fig12_alt.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14fig12_alt.jpg)'
- en: Prior to running your test scripts, Protractor unzips the browser-specific driver
    (for example, ChromeDriver) into the node_modules/webdriver-manager/selenium folder
    so Selenium WebDriver can properly communicate with the browser. During the tests,
    Protractor will launch the browser, and after the tests finish, Protractor will
    close it.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试脚本之前，Protractor 将浏览器特定的驱动程序（例如，ChromeDriver）解压缩到 node_modules/webdriver-manager/selenium
    文件夹中，以便 Selenium WebDriver 可以正确地与浏览器通信。在测试期间，Protractor 将启动浏览器，测试完成后，Protractor
    将关闭它。
- en: 'Protractor can use scripts created in different unit-testing frameworks (Jasmine
    is a default one), and each of them may have a different API for locating and
    representing page elements. To spare you from changing E2E scripts if you decide
    to switch to another unit-testing framework, Protractor comes with an API (see
    [www.protractortest.org/#/api](http://www.protractortest.org/#/api)) that works
    with all supported frameworks:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor 可以使用在不同单元测试框架中创建的脚本（Jasmine 是默认的一个），并且每个框架可能都有不同的 API 用于定位和表示页面元素。为了避免你在决定切换到另一个单元测试框架时更改
    E2E 脚本，Protractor 提供了一个 API（见 [www.protractortest.org/#/api](http://www.protractortest.org/#/api)），它可以与所有支持的框架一起工作：
- en: '`browser` provides an API to control the browser, for example `getCurrentUrl()`,
    `wait()`, and so on.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`browser` 提供了一个 API 来控制浏览器，例如 `getCurrentUrl()`、`wait()` 等。'
- en: '`by` is a locator for finding elements in Angular applications by ID, CSS,
    button or link text, and so forth.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`by` 是一个定位器，用于通过 ID、CSS、按钮或链接文本等方式在 Angular 应用程序中查找元素。'
- en: '`element` offers an API for finding and working with a single element on a
    web page.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element` 提供了一个 API，用于在网页上查找和操作单个元素。'
- en: '`element.all` is used for finding and working with collections of elements,
    for example, iterating over the elements of an HTML list or table.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element.all` 用于查找和操作元素集合，例如，遍历 HTML 列表或表格的元素。'
- en: '|  |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Tip
- en: '`$("selector")` is an alias for `element(by.css("selector"))`, and `$$("selector")`
    is an alias for `element.all(by.css("selector"))`.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`$("selector")` 是 `element(by.css("selector"))` 的别名，而 `$$("selector")` 是 `element.all(by.css("selector"))`
    的别名。'
- en: '|  |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Although in Angular apps you can use the structural directive `*ngFor` for rendering
    a collection of UI elements, in tests you should use `element.all` for referring
    to and finding elements in a collection.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 Angular 应用程序中你可以使用结构化指令 `*ngFor` 来渲染一组 UI 元素，但在测试中你应该使用 `element.all` 来引用和查找集合中的元素。
- en: '|  |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Tip
- en: Though Protractor defines its own API, it also exposes the WebDriver API, as
    in `browser.takeScreenshot()`.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Protractor 定义了自己的 API，但它也暴露了 WebDriver API，例如 `browser.takeScreenshot()`。
- en: '|  |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The E2E tests load the real app in the browser, locate elements on the page,
    and can programmatically click buttons and links, fill out forms with data, submit
    them to the server, and then again locate the elements on the resulting page to
    ensure that they have the expected content. You can write an E2E test using one
    of the following approaches:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: E2E 测试在浏览器中加载真实的应用程序，定位页面上的元素，并且可以程序化地点击按钮和链接，用数据填写表单，将它们提交到服务器，然后再定位结果页面上的元素以确保它们具有预期的内容。你可以使用以下方法之一编写
    E2E 测试：
- en: In the same script, locate DOM elements by using their IDs or CSS classes and
    assert that the application logic works correctly. The IDs or CSS classes may
    change over time, so if you have several scripts testing the same page, you need
    to update each script accordingly.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一脚本中，使用它们的 ID 或 CSS 类定位 DOM 元素，并断言应用程序逻辑是否正确。ID 或 CSS 类可能会随时间变化，因此如果您有多个脚本测试同一页面，您需要相应地更新每个脚本。
- en: Implement the *Page Object* design pattern (see [https://martinfowler.com/bliki/PageObject.html](https://martinfowler.com/bliki/PageObject.html))
    by writing the expectations and assertions in one file, and in another, write
    the code that interacts with the UI elements and invokes the app’s API. The page
    object can implement UI interaction with either the entire page or its part (for
    example, the toolbar), and can be reused by multiple tests. Should the CSS of
    the HTML elements change, you’ll need to modify a single page object script.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在一个文件中编写期望和断言，在另一个文件中编写与 UI 元素交互并调用应用程序 API 的代码，实现 *页面对象* 设计模式（见 [https://martinfowler.com/bliki/PageObject.html](https://martinfowler.com/bliki/PageObject.html)）。页面对象可以实现与整个页面或其部分（例如，工具栏）的
    UI 交互，并且可以被多个测试重用。如果 HTML 元素的 CSS 发生变化，您需要修改单个页面对象脚本。
- en: Tests written using the first approach are difficult to read because they don’t
    provide an easy way of understanding which workflows are implemented on the page.
    You’ll use the second approach, where all UI interactions are implemented in the
    page objects (.po.ts files), and the specs with assertions are in the scripts
    (.e2e-spec.ts files). This approach reduces code duplication because you don’t
    need to copy-paste the element locators if multiple specs need to access the same
    HTML element. A page object can serve as a single place for simulating user activity
    for important workflows, such as `login()` or `getProducts()`, rather than having
    these activities scattered throughout the tests.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第一种方法编写的测试难以阅读，因为它们没有提供理解页面实现了哪些工作流程的简单方法。您将使用第二种方法，其中所有 UI 交互都在页面对象（.po.ts
    文件）中实现，而断言的规范在脚本（.e2e-spec.ts 文件）中。这种方法减少了代码重复，因为如果多个规范需要访问相同的 HTML 元素，您不需要复制粘贴元素定位器。页面对象可以作为模拟重要工作流程（如
    `login()` 或 `getProducts()`）的单一位置，而不是将这些活动分散在测试中。
- en: Let’s look at the E2E test generated by Angular CLI for the new projects.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Angular CLI 为新项目生成的端到端测试。
- en: 14.4.2\. Angular CLI–generated tests
  id: totrans-391
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.4.2\. Angular CLI 生成的测试
- en: 'When you generate a new project with Angular CLI, it creates a directory, e2e,
    that contains three files:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 Angular CLI 生成新项目时，它创建一个名为 e2e 的目录，该目录包含三个文件：
- en: '***app.po.ts*—** The page object for `AppComponent`'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***app.po.ts*—** `AppComponent` 的页面对象'
- en: '***app.e2e-spec.ts*—** The E2E test for the generated `AppComponent`'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***app.e2e-spec.ts*—** 生成的 `AppComponent` 的端到端测试'
- en: '***tsconfig.e2e.json*—** The TypeScript compiler options'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***tsconfig.e2e.json*—** TypeScript 编译器选项'
- en: The app.po.ts file contains a simple `AppPage` class with just two methods,
    as shown in [listing 14.18](#ch14ex18). The first one contains the code to navigate
    to the root page of the component, and the second has code to locate the HTML
    element by CSS and get its text. This page object is the only place that contains
    code locating elements by CSS.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: app.po.ts 文件包含一个简单的 `AppPage` 类，其中只有两个方法，如 [列表 14.18](#ch14ex18) 所示。第一个方法包含导航到组件根页面的代码，第二个方法包含通过
    CSS 定位 HTML 元素并获取其文本的代码。这个页面对象是唯一包含通过 CSS 定位元素的代码的地方。
- en: Listing 14.18\. The generated app.po.ts file
  id: totrans-397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.18\. 生成的 app.po.ts 文件
- en: '[PRE30]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* Navigates to the default route**'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导航到默认路由**'
- en: '***2* Gets the text from the <h1> element**'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从 <h1> 元素获取文本**'
- en: The code for the app.e2e-spec.ts file is shown in [listing 14.19](#ch14ex19).
    This test looks very similar to the unit tests shown in the last section. Note
    that this file doesn’t include the code that directly interacts with the HTML
    page; it uses the API of the page object instead.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: app.e2e-spec.ts 文件的代码如 [列表 14.19](#ch14ex19) 所示。这个测试看起来与上一节中显示的单元测试非常相似。请注意，此文件不包括直接与
    HTML 页面交互的代码；它使用页面对象的 API。
- en: Listing 14.19\. The generated app.e2e-spec.ts file
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.19\. 生成的 app.e2e-spec.ts 文件
- en: '[PRE31]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* Creates an instance of the page**'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建页面实例**'
- en: '***2* Navigates to the default route**'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导航到默认路由**'
- en: '***3* Asserts that the text returned by getParagraphText() is correct**'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 断言 getParagraphText() 返回的文本是正确的**'
- en: 'Because app.e2e-spec.ts doesn’t contain any element locators, it’s easy to
    follow the test logic: you navigate to the landing page and retrieve the content
    of a paragraph. You can run the preceding E2E test using the command `ng e2e`.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 app.e2e-spec.ts 不包含任何元素定位器，所以测试逻辑很容易理解：您导航到着陆页面并检索段落的内容。您可以使用命令 `ng e2e`
    运行前面的 E2E 测试。
- en: '|  |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-409
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: E2E tests run slower that unit tests, and you don’t want to run them each time
    you save a file, as you did with `ng test` in the last section. Besides, instead
    of creating E2E tests for each and every workflow, you may want to identify the
    most important ones and run tests just for them.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: E2E 测试的运行速度比单元测试慢，您不希望在每次保存文件时都运行它们，就像上一节中使用的 `ng test` 一样。此外，您可能不想为每个工作流程创建
    E2E 测试，而是识别最重要的测试并只为它们运行测试。
- en: '|  |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that you’ve seen how generated tests work, you can write your own E2E test.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了生成的测试是如何工作的，您可以编写自己的 E2E 测试。
- en: 14.4.3\. Testing a login page
  id: totrans-413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.4.3\. 测试登录页面
- en: The E2E test from the preceding section didn’t include a workflow that would
    require data entry and navigation. In this section, you’ll write a test for an
    app that uses a form and routing. The code that comes with this chapter includes
    a project called e2e-testing-samples with a simple app that has a login page and
    a home page. The routes in this app are configured in the following listing.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的 E2E 测试没有包含需要数据输入和导航的工作流程。在本节中，您将为使用表单和路由的应用程序编写测试。本章附带的项目中包含一个名为 e2e-testing-samples
    的项目，其中有一个简单的应用程序，具有登录页面和主页。此应用程序的路由配置如下所示。
- en: Listing 14.20\. Route configurations
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.20\. 路由配置
- en: '[PRE32]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* Redirects the base URL to the login page**'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将基本 URL 重定向到登录页面**'
- en: '***2* Renders the login component**'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 渲染登录组件**'
- en: '***3* Renders the home component**'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 渲染主页组件**'
- en: 'The template of the `HomeComponent` has just one line:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`HomeComponent` 的模板只有一行：'
- en: '[PRE33]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The login component in the following listing has a Login button and a form with
    two fields for entering ID and password. If a user enters `Joe` as the ID and
    `password` as the password, your app navigates to the home page; otherwise, it
    stays on the login page and shows the message “Invalid ID or password.”
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表中的登录组件包含一个登录按钮和一个包含两个输入 ID 和密码字段的表单。如果用户将 `Joe` 作为 ID 和 `password` 作为密码输入，则您的应用程序将导航到主页；否则，它将停留在登录页面并显示消息“无效的
    ID 或密码”。
- en: Listing 14.21\. login.component.ts
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.21\. login.component.ts
- en: '[PRE34]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* A login form**'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 登录表单**'
- en: '***2* The invalid login message**'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 无效登录消息**'
- en: '***3* Router injection**'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 路由注入**'
- en: '***4* Navigation to the home page**'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 导航到主页**'
- en: '***5* Navigation to the login page**'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 导航到登录页面**'
- en: Your tests are located in the e2e directory and include two page objects, login.po.ts
    and home.po.ts, and one spec, login.e2e-spec.ts. The page object for the home
    page contains a method to return the header’s text. The following listing shows
    home.po.ts.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 您的测试位于 e2e 目录中，包括两个页面对象，login.po.ts 和 home.po.ts，以及一个规范，login.e2e-spec.ts。主页面的页面对象包含一个返回头部文本的方法。以下列表显示了
    home.po.ts。
- en: Listing 14.22\. home.po.ts
  id: totrans-431
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.22\. home.po.ts
- en: '[PRE35]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The login page object uses locators to get references to the form fields and
    the button. The `login()` method simulates user actions: entering the ID and password
    and clicking the Login button. The `navigateToLogin()` method instructs the browser
    to visit the URL configured to the login component—for example, http://localhost:4200/login.
    The `getErrorMessage()` method returns the login error message that may or may
    not be present on the page. login.po.ts is shown in the following listing.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 登录页面对象使用定位器来获取表单字段和按钮的引用。`login()` 方法模拟用户操作：输入 ID 和密码并点击登录按钮。`navigateToLogin()`
    方法指示浏览器访问配置到登录组件的 URL——例如，http://localhost:4200/login。`getErrorMessage()` 方法返回页面可能存在或不存在登录错误消息。以下列表显示了
    login.po.ts。
- en: Listing 14.23\. login.po.ts
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.23\. login.po.ts
- en: '[PRE36]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Locates the page elements using $ as an alias for element(by.css())**'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 $ 作为 element(by.css()) 的别名定位页面元素**'
- en: '***2* Enters the provided ID and password**'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 输入提供的 ID 和密码**'
- en: '***3* Clicks the Login button**'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 点击登录按钮**'
- en: '***4* Navigates to the login page**'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 导航到登录页面**'
- en: '***5* Returns the login error message**'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 返回登录错误消息**'
- en: This page object makes the login procedure easy to understand. The `sendKey()`
    method is used for simulating data entry, and `click()` simulates a button click.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面对象使登录过程易于理解。`sendKey()` 方法用于模拟数据输入，而 `click()` 模拟按钮点击。
- en: 'Now let’s review the test suite for the login workflow. It instantiates the
    login page object and includes two specs: one for testing a successful login and
    another for a failed one.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来回顾登录工作流程的测试套件。它实例化了登录页面对象，并包含两个规范：一个用于测试成功的登录，另一个用于失败的登录。
- en: The first spec instructs Protractor to navigate to the login page and log in
    the user with the hardcoded data `Joe` and `password`. If the login was successful,
    the app navigates to the home page, and you assert this by checking that the URL
    in the browser contains /home. You also assert that the rendered page contains
    the header “Home Component.”
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个规范指示Protractor导航到登录页面并使用硬编码的数据 `Joe` 和 `password` 登录用户。如果登录成功，应用将导航到主页，你通过检查浏览器中的URL是否包含
    /home 来断言这一点。你还断言渲染的页面包含标题“主页组件。”
- en: The spec for the failed login asserts that the app stays on the login page and
    the error message is displayed. Note in the following listing that this script
    has no code directly interacting with the UI.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 失败登录的规范断言应用停留在登录页面，并显示错误消息。注意以下列表中，此脚本没有直接与UI交互的代码。
- en: Listing 14.24\. login.e2e-spec.ts
  id: totrans-445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.24\. login.e2e-spec.ts
- en: '[PRE37]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* Instantiates the login page object**'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 实例化登录页面对象**'
- en: '***2* A spec for a successful login**'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 成功登录的规范**'
- en: '***3* Navigates to the login page**'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 导航到登录页面**'
- en: '***4* Logs in with proper credentials**'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用正确的凭据登录**'
- en: '***5* Gets the browser’s URL**'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 获取浏览器的URL**'
- en: '***6* Asserts that the URL contains /home**'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 断言URL包含 /home**'
- en: '***7* Instantiates the home page object**'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 实例化主页对象**'
- en: '***8* Asserts that the page header is correct**'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 断言页面标题正确**'
- en: '***9* A spec for a failed login**'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 失败登录的规范**'
- en: '***10* Executes the failed login**'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 执行失败的登录**'
- en: '***11* Asserts that the app still shows the login page**'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11* 断言应用仍然显示登录页面**'
- en: '***12* Asserts that the error message is shown**'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***12* 断言错误消息显示**'
- en: The `LoginComponent` uses the `*ngIf` structural directive to conditionally
    show or hide the login error message, and your failed login spec asserts that
    the error message is present on the page.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginComponent` 使用 `*ngIf` 结构性指令有条件地显示或隐藏登录错误消息，你的失败的登录规范断言错误消息出现在页面上。'
- en: Sometimes you need to wait for certain operations to complete before making
    assertions. For example, the `login()` method in your page object ends with the
    button click, and the spec for the successful login contains the assertion that
    the URL contains /home.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在执行断言之前需要等待某些操作完成。例如，你的页面对象中的 `login()` 方法以按钮点击结束，成功的登录规范包含断言URL包含 /home。
- en: This assertion will always be true because your login process completes in no
    time as it doesn’t connect to an authentication server to check user credentials.
    In the real world, the authentication could take a couple of seconds, and the
    assertion for /home could run sooner than the URL changes to /home, causing the
    test to fail.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这个断言始终为真，因为你的登录过程几乎瞬间完成，因为它没有连接到认证服务器来检查用户凭据。在现实世界中，认证可能需要几秒钟，而针对 /home 的断言可能会在URL变为
    /home 之前运行，导致测试失败。
- en: In such cases, you can invoke the `browser.wait()` command, where you can specify
    the condition to wait for. In the hands-on section, you’ll write a test that clicks
    the Search button that makes an HTTP request for products, which needs some time
    to finish. There, you’ll use a helper function that waits for the URL to change
    before making assertions.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，你可以调用 `browser.wait()` 命令，其中你可以指定要等待的条件。在实战部分，你将编写一个测试，点击搜索按钮，该按钮会为产品发起一个HTTP请求，这需要一些时间来完成。在那里，你将使用一个辅助函数，在执行断言之前等待URL发生变化。
- en: Run this test with the `ng e2e` command, and you’ll see how Protractor opens
    the Chrome browser for a short time, fills out the form, and clicks the Login
    button. The Terminal window shows the output, which you can see in [figure 14.13](#ch14fig13).
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ng e2e` 命令运行此测试，你会看到Protractor如何短暂地打开Chrome浏览器，填写表单，并点击登录按钮。终端窗口显示输出，你可以在[图14.13](#ch14fig13)中看到。
- en: Figure 14.13\. Running E2E tests for the login app
  id: totrans-464
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.13\. 运行登录应用的端到端测试
- en: '![](Images/14fig13_alt.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14fig13_alt.jpg)'
- en: Both specs from your E2E test passed. If you want to see the tests fail, remove
    the `<h1>` tags in the template of the `HomeComponent` or modify the valid credentials
    to anything other than `Joe` and `password` in the `LoginComponent`. Changing
    the names of the form fields in the template of `LoginComponent` will also cause
    the test to fail because the WebDriver locators won’t find these elements on the
    login page.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 你的端到端测试中的两个规范都通过了。如果你想看到测试失败，请从 `HomeComponent` 的模板中删除 `<h1>` 标签，或者在 `LoginComponent`
    中将有效的凭据修改为除 `Joe` 和 `password` 之外的其他任何内容。更改 `LoginComponent` 模板中表单字段的名称也会导致测试失败，因为
    WebDriver 定位器无法在登录页面上找到这些元素。
- en: This chapter has enough material to get you started with unit and E2E testing
    of Angular apps. Both Jasmine and (especially) Protractor offer more APIs that
    can be used in tests. For more detailed coverage, check out the book *Testing
    Angular Applications* (Jesse Palmer et al., Manning, 2018), with details at [www.manning.com/books/testing-angular-applications](http://www.manning.com/books/testing-angular-applications).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了足够的材料，帮助你开始对 Angular 应用进行单元和端到端测试。Jasmine 和（尤其是）Protractor 都提供了更多可以在测试中使用的
    API。要获取更详细的覆盖范围，请查看书籍 *Testing Angular Applications*（Jesse Palmer 等著，Manning，2018），详细信息请见
    [www.manning.com/books/testing-angular-applications](http://www.manning.com/books/testing-angular-applications)。
- en: '|  |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using async and await in E2E tests**'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '**在端到端测试中使用 async 和 await**'
- en: Protractor uses WebDriverJS. Its API is entirely asynchronous, and its functions
    return promises. All asynchronous operations (for example, `sendKey()` and `click()`)
    are placed in the queue of pending promises called *control-flow queue* using
    the WebDriver promise manager to ensure that assertions (such as `expect()` functions)
    run after asynchronous operations.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: Protractor 使用 WebDriverJS。它的 API 完全是异步的，并且它的函数返回承诺。所有异步操作（例如，`sendKey()` 和 `click()`）都通过
    WebDriver 承诺管理器放入待处理的承诺队列中，称为 *控制流队列*，以确保断言（如 `expect()` 函数）在异步操作之后运行。
- en: Because the WebDriver promise manager doesn’t execute async functions right
    away but places them in a queue instead, it’s hard to debug this code. That’s
    why WebDriver’s promise manager is being deprecated, and you can use the `async`
    and `await` keywords to ensure that flow is properly synchronized (see [http://mng.bz/f72u](http://mng.bz/f72u)
    for details).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 WebDriver 承诺管理器不会立即执行异步函数，而是将其放入队列中，因此很难调试此代码。这就是为什么 WebDriver 的承诺管理器正在被弃用，你可以使用
    `async` 和 `await` 关键字来确保流程正确同步（有关详细信息，请参阅 [http://mng.bz/f72u](http://mng.bz/f72u)）。
- en: For example, the following code declares a `login()` method.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码声明了一个 `login()` 方法。
- en: '[PRE38]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* Declares that the function returns a promise**'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明该函数返回一个承诺**'
- en: '***2* Waits for the promise to be resolved or rejected**'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 等待承诺解决或拒绝**'
- en: 'You can’t use the `async`/`await` keywords with WebDriver’s promise manager,
    so you need to turn if off by adding the following option in protractor.conf.js:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能与 WebDriver 的承诺管理器一起使用 `async`/`await` 关键字，因此你需要通过在 protractor.conf.js 中添加以下选项来关闭它：
- en: '[PRE39]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|  |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If after getting familiar with the combination of Protractor and the Selenium
    ecosystem you’d like to find a simpler solution for E2E testing of your apps,
    take a look at the Cypress framework available at [https://www.cypress.io](https://www.cypress.io).
    It’s a new but very promising kid on the block. Meanwhile, let’s add some Protractor
    E2E tests to ngAuction.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉了 Protractor 和 Selenium 生态系统的组合，并希望为你的应用找到更简单的端到端测试解决方案，请查看 Cypress 框架，可在
    [https://www.cypress.io](https://www.cypress.io) 找到。它是一个新但非常有前途的框架。同时，让我们向 ngAuction
    添加一些 Protractor 端到端测试。
- en: '14.5\. Hands-on: Adding an E2E test to ngAuction'
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.5\. 实践：向 ngAuction 添加端到端测试
- en: The goal of this exercise is to add one E2E test to the ngAuction app, which
    you can find in the ng-auction folder in the source code that comes with this
    chapter. We took the ngAuction project from [chapter 13](kindle_split_022.xhtml#ch13)
    and added to it the E2E test for the product-search workflow. This test will use
    the price range from $10 to $100 to assert that matching products are retrieved
    from the server and rendered in the browser.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的目标是为 ngAuction 应用添加一个端到端测试，你可以在本章提供的源代码中的 ng-auction 文件夹中找到它。我们从第 13 章（kindle_split_022.xhtml#ch13）中提取了
    ngAuction 项目，并添加了产品搜索工作流程的端到端测试。此测试将使用 $10 到 $100 的价格范围来断言从服务器检索到的匹配产品在浏览器中渲染。
- en: '|  |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Source code for this chapter can be found at [https://github.com/Farata/angulartypescript](https://github.com/Farata/angulartypescript)
    and [www.manning.com/books/angular-development-with-typescript-second-edition](http://www.manning.com/books/angular-development-with-typescript-second-edition).
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在[https://github.com/Farata/angulartypescript](https://github.com/Farata/angulartypescript)和[www.manning.com/books/angular-development-with-typescript-second-edition](http://www.manning.com/books/angular-development-with-typescript-second-edition)找到。
- en: '|  |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Prior to running this E2E test, you need to run `npm install` in the server
    directory, compile the code with the `tsc` command, and start the server by running
    the following command:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此端到端测试之前，您需要在服务器目录中运行`npm install`，使用`tsc`命令编译代码，并通过运行以下命令启动服务器：
- en: '[PRE40]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now you’re ready to review and run the tests located in the client directory
    of ngAuction.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已准备好审查和运行位于ngAuction客户端目录中的测试。
- en: 14.5.1\. E2E testing of the product-search workflow
  id: totrans-489
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.5.1\. 产品搜索工作流程的端到端测试
- en: 'To perform product search, a real user would need to fulfill the following
    steps:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行产品搜索，实际用户需要完成以下步骤：
- en: '**1**.  Open the landing page of ngAuction.'
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 打开ngAuction的着陆页。'
- en: '**2**.  Click the Search button in the top-left corner so the search panel
    will show up.'
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 点击左上角的搜索按钮，以便搜索面板显示出来。'
- en: '**3**.  Enter search criteria for products.'
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 输入产品的搜索条件。'
- en: '**4**.  Click the Search button to see the search results.'
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 点击搜索按钮以查看搜索结果。'
- en: '**5**.  Browse the products that meet the search criteria.'
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**. 浏览符合搜索条件的商品。'
- en: 'Your E2E test will consist of two files located in the e2e directory: the page
    object in the search.po.ts file and the test suite in search.e2e-spec.ts. All
    assertions will be programmed in the search.e2e-spec.ts file, but the page object
    will implement the following logical steps:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 您的端到端测试将包括位于e2e目录中的两个文件：`search.po.ts`文件中的页面对象和`search.e2e-spec.ts`文件中的测试套件。所有断言都将编程在`search.e2e-spec.ts`文件中，但页面对象将实现以下逻辑步骤：
- en: '**1**.  Find the Search button and click it.'
  id: totrans-497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 找到搜索按钮并点击它。'
- en: '**2**.  Fill out the search form with data.'
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 使用数据填写搜索表单。'
- en: '**3**.  Click the Search button.'
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 点击搜索按钮。'
- en: '**4**.  Wait until the server returns and renders products in the browser.'
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 等待服务器返回并在浏览器中渲染产品。'
- en: '**5**.  Check to see that the browser rendered products.'
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**. 检查浏览器是否渲染了产品。'
- en: To ensure that your search will return some products, your test will use a wide
    range of prices from $10 to $100 as the search criteria.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您的搜索会返回一些产品，您的测试将使用从$10到$100的广泛价格范围作为搜索条件。
- en: In several cases, you’ll be checking that the browser URL is what you expect
    it to be, so we’ll remind you how the routes are configured in the home.module.ts
    in ngAuction, as shown in the following listing.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在几种情况下，您将检查浏览器URL是否如您预期的那样，因此我们将提醒您在ngAuction的`home.module.ts`中如何配置路由，如下列所示。
- en: Listing 14.25\. Routes configuration from the home module
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.25\. 来自home模块的路由配置
- en: '[PRE41]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Let’s start by identifying the HTML elements that will participate in our test.
    The file app.component.html includes the markup in the following listing for the
    Search button.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先识别将参与我们测试的HTML元素。`app.component.html`文件包含以下列表中的搜索按钮标记。
- en: Listing 14.26\. The Search button on the toolbar
  id: totrans-507
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.26\. 工具栏上的搜索按钮
- en: '[PRE42]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1* The added ID simplifies the code for locating this button.**'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加的ID简化了定位此按钮的代码。**'
- en: Your page object will contain the lines in the following listing to locate the
    button and click it.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 您的页面对象将包含以下列表中的行以定位按钮并点击它。
- en: Listing 14.27\. The beginning of the `SearchPage` class
  id: totrans-511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.27\. `SearchPage`类的开始
- en: '[PRE43]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* A method for searching products by price range**'
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一种按价格范围搜索产品的搜索方法**'
- en: '***2* Locating the Search button**'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定位搜索按钮**'
- en: '***3* The button click to display the search form**'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 点击按钮以显示搜索表单**'
- en: After the button is clicked, the search form is displayed, and you locate the
    fields for the minimum and maximum prices and fill them with the provided prices,
    as shown in the following listing.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮后，搜索表单会显示，您会找到最小和最大价格字段并填写提供的价格，如下列所示。
- en: Listing 14.28\. Entering the search criteria
  id: totrans-517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.28\. 输入搜索条件
- en: '[PRE44]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1* Locates the form fields for prices**'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定位价格表单字段**'
- en: '***2* Fills out some of the form fields**'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 填写一些表单字段**'
- en: If the user did this manually, the search form would look like [figure 14.14](#ch14fig14).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户手动这样做，搜索表单将看起来像[图14.14](#ch14fig14)。
- en: Figure 14.14\. The form with search criteria
  id: totrans-522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.14\. 带有搜索条件的表单
- en: '![](Images/14fig14.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/14fig14.jpg)'
- en: 'Now that the search criteria is entered, you need to locate and click the form’s
    Search button to perform the product search. If you run ngAuction and enter the
    min and max prices as $10 and $100, and then click the Search button, the resulting
    view will show the products, and the browser URL will look like this: http://localhost:4200/search?minPrice=10&maxPrice=100.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 现在搜索条件已经输入，你需要定位并点击表单的搜索按钮以执行产品搜索。如果你运行ngAuction，输入最小和最大价格为$10和$100，然后点击搜索按钮，结果视图将显示产品，浏览器URL将看起来像这样：http://localhost:4200/search?minPrice=10&maxPrice=100。
- en: But it’ll take a second before the HTTP request is complete and the URL changes.
    The real user would be patiently waiting until the search results appeared. But
    in your test script, if you try to assert that the URL contains the search segment
    right after the button click, the assertion may or may not be true depending on
    how fast your server responds.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 但在HTTP请求完成并URL改变之前需要一点时间。真实用户会耐心等待直到搜索结果出现。但在你的测试脚本中，如果你尝试在按钮点击后立即断言URL包含搜索段，这个断言可能对也可能不对，这取决于你的服务器响应速度有多快。
- en: You didn’t need to worry about delays in login.po.ts from [section 14.4.3](#ch14lev2sec10),
    because no server requests were made there, and the URL changed instantaneously.
    This time, you want to wait until the URL changes before returning from the method
    `performSearch()`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要担心从[第14.4.3节](#ch14lev2sec10)的`login.po.ts`登录延迟，因为那里没有发起服务器请求，URL也瞬间改变。这次，你希望在从`performSearch()`方法返回之前等待URL改变。
- en: You’ll use the `ExpectedConditions` class, where you can define the condition
    to wait for. Then, by invoking `browser.wait()`, you can wait for the expected
    condition to become true—otherwise, the test has to fail by timeout. The following
    code listing locates and clicks the Search button and then waits until the URL
    changes to contain the /search segment.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用`ExpectedConditions`类，其中你可以定义要等待的条件。然后，通过调用`browser.wait()`，你可以等待预期条件变为真——否则，测试将因超时而失败。以下代码示例定位并点击搜索按钮，然后等待URL改变以包含/search段。
- en: Listing 14.29\. Clicking the form’s Search button
  id: totrans-528
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.29\. 点击表单的搜索按钮
- en: '[PRE45]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* Locates the Search button**'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定位搜索按钮**'
- en: '***2* Clicks the Search button**'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 点击搜索按钮**'
- en: '***3* Declares the constant for the expected condition**'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 声明预期条件的常量**'
- en: '***4* Uses the urlContains() API to check the expected condition**'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用urlContains() API检查预期条件**'
- en: '***5* Waits for the expected condition for up to 5 seconds or fails**'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 等待预期条件最多5秒或失败**'
- en: '***6* The message to display in case of timeout**'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 超时时的显示消息**'
- en: This code waits for up to 5 seconds, and if the URL doesn’t change, it fails,
    printing the message shown in [figure 14.15](#ch14fig15). You may need to increase
    the timeout value depending on how fast the product search is performed on your
    computer.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码等待最多5秒钟，如果URL没有改变，则失败，并打印出[图14.15](#ch14fig15)中显示的消息。你可能需要根据你电脑上产品搜索的速度来增加超时值。
- en: Figure 14.15\. The test fails on timeout.
  id: totrans-537
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.15\. 测试在超时失败。
- en: '![](Images/14fig15_alt.jpg)'
  id: totrans-538
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/14fig15_alt.jpg)'
- en: If the user manually searched for products in the price range between $10 and
    $100, the resulting view could look like [figure 14.16](#ch14fig16).
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户手动搜索了价格在$10到$100之间的产品，结果视图可能看起来像[图14.16](#ch14fig16)。
- en: Figure 14.16\. The search-result view
  id: totrans-540
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.16\. 搜索结果视图
- en: '![](Images/14fig16_alt.jpg)'
  id: totrans-541
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/14fig16_alt.jpg)'
- en: If the search operation initiated by the test script returns products, you extract
    the price of the first product, so later on (in the spec) you can assert that
    the product price meets the search criteria. Because the search may return a collection
    of products, you’ll access them using the alias `$$` for the `element.all` API.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由测试脚本启动的搜索操作返回产品，你将提取第一个产品的价格，以便稍后（在规范中）你可以断言产品价格符合搜索条件。因为搜索可能返回一系列产品，所以你会使用`element.all`
    API的别名`$$`来访问它们。
- en: Each of the products has the `tile__price-tag` style, as shown in [figure 14.17](#ch14fig17),
    taken from the Element tab in the Chrome Dev Tools panel while the products grid
    was shown. You’ll use the `tile__price-tag` style to locate products.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 每个产品都有如图14.17所示的`tile__price-tag`样式，该图是从Chrome Dev Tools面板的Element选项卡中获取的，当时产品网格正在显示。你将使用`tile__price-tag`样式来定位产品。
- en: Figure 14.17\. CSS selector for the price
  id: totrans-544
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.17\. 价格的CSS选择器
- en: '![](Images/14fig17_alt.jpg)'
  id: totrans-545
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/14fig17_alt.jpg)'
- en: When the product price is extracted, you need to convert it to a number. In
    ngAuction, the product price is rendered as a string with the dollar sign, such
    as “$70” in [figure 14.17](#ch14fig17). But you need its numeric representation
    so the spec can assert that the price falls within the specified range. The `getFirstProductPrice()`
    method includes the code that removes the dollar sign from the string and converts
    it to an integer value, as you can see in the next listing.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 当提取产品价格时，您需要将其转换为数字。在ngAuction中，产品价格以包含美元符号的字符串形式呈现，例如[图14.17](#ch14fig17)中的“$70”。但您需要其数值表示，以便规范可以断言价格在指定的范围内。`getFirstProductPrice()`方法包含从字符串中删除美元符号并将其转换为整数值的代码，如下一列表所示。
- en: Listing 14.30\. Getting the price of the first product
  id: totrans-547
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.30\. 获取第一个产品的价格
- en: '[PRE46]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Uses element.all for finding products**'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用element.all查找产品**'
- en: '***2* Gets the text of the first product**'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 获取第一个产品的文本**'
- en: '***3* Protractor’s API returns promises, so applies then()**'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Protractor的API返回promises，因此应用then()**'
- en: '***4* Converts the product price to a number and returns it**'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将产品价格转换为数字并返回**'
- en: The complete code of your page object is shown in the following listing.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 您的页面对象的完整代码如下所示。
- en: Listing 14.31\. search.po.ts
  id: totrans-554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.31\. search.po.ts
- en: '[PRE47]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Clicks the Search icon in the toolbar**'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 点击工具栏中的搜索图标**'
- en: '***2* Fills out min and max prices on the search form**'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在搜索表单中填写最小和最大价格**'
- en: '***3* Clicks the Search button on the form**'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 点击表单上的搜索按钮**'
- en: '***4* Declares an expected condition**'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 声明一个预期条件**'
- en: '***5* Waits for the expected condition for up to 5 seconds**'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 等待最多5秒的预期条件**'
- en: '***6* Declares a method for navigating to the landing page**'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 声明一个导航到着陆页的方法**'
- en: '***7* Locates all price elements**'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 定位所有价格元素**'
- en: '***8* Singles out the first product price**'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 提取第一个产品的价格**'
- en: '***9* Converts the price into a number**'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 将价格转换为数字**'
- en: Now let’s review the code of the test suite located in the search.e2e-spec.ts
    file.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来回顾位于search.e2e-spec.ts文件中的测试套件的代码。
- en: The test suite for the search workflow contains one spec, which uses the page
    object and adds assertions to each step of the workflow. The spec starts by navigating
    to the landing page of ngAuction and then asserts that the URL of the page contains
    the segment /categories/all.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索工作流程的测试套件包含一个规范，该规范使用页面对象并在工作流程的每个步骤中添加断言。规范首先导航到ngAuction的着陆页，然后断言页面的URL包含段
    /categories/all。
- en: Then the spec performs the test by invoking the `performSearch()` method on
    the page object, passing `10` and `100` as a price range for the search. After
    this method completes, it performs three assertions to check that the URL of the
    resulting page contains the segment /search?minPrice=10&maxPrice=100 and the price
    of the first product is greater than $10 and less than $100\. The code of this
    test suite is shown in the following listing.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，规范通过在页面对象上调用`performSearch()`方法并传递`10`和`100`作为搜索的价格范围来执行测试。在此方法完成后，它执行三个断言以检查结果页面的URL是否包含段
    /search?minPrice=10&maxPrice=100，以及第一个产品的价格是否大于$10且小于$100。此测试套件的代码如下所示。
- en: Listing 14.32\. search.e2e-spec.ts
  id: totrans-568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.32\. search.e2e-spec.ts
- en: '[PRE48]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* Instantiates the page object**'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 实例化页面对象**'
- en: '***2* Asserts the URL of the landing page**'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 断言着陆页的URL**'
- en: '***3* Searches for products**'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 搜索产品**'
- en: '***4* Asserts the URL of the page with the search results**'
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 断言搜索结果的页面URL**'
- en: '***5* Gets the price of the first product**'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 获取第一个产品的价格**'
- en: '***6* Asserts that the price is greater than 10**'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 声明价格大于10**'
- en: '***7* Asserts that the price is less than 100**'
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 声明价格小于100**'
- en: In the Terminal window, switch to the client directory, run `npm install`, and
    run the test with the `ng e2e` command. The test will successfully complete, and
    you’ll see the message shown in [figure 14.18](#ch14fig18).
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端窗口中，切换到客户端目录，运行`npm install`，然后使用`ng e2e`命令运行测试。测试将成功完成，您将看到[图14.18](#ch14fig18)中显示的消息。
- en: Figure 14.18\. The product-search test succeeded.
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.18\. 产品搜索测试成功。
- en: '![](Images/14fig18_alt.jpg)'
  id: totrans-579
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14fig18_alt.jpg)'
- en: To make the test fail, modify the spec to test the case when no products are
    returned by using a price range between $1 and $5,000,000\. Your ngAuction isn’t
    created for Sotheby’s, and you don’t carry expensive items.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 要使测试失败，修改规范以测试没有产品返回的情况，使用介于$1和$5,000,000之间的价格范围。您的ngAuction并非为苏富比而创建，您也不携带贵重物品。
- en: Summary
  id: totrans-581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Unit tests run quickly, but most application business logic should be tested
    with E2E tests.
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试运行得很快，但大多数应用业务逻辑应该使用端到端测试进行测试。
- en: While you’re writing tests, make them fail to see that their failure report
    is easy to understand.
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在编写测试时，让它们失败以确认其失败报告易于理解。
- en: Running unit tests should be part of your automated build process, but E2E tests
    shouldn’t.
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行单元测试应该是你自动化构建过程的一部分，但端到端测试则不应如此。
