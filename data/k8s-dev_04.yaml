- en: 3 Deploying to Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 部署到 Kubernetes
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Kubernetes concepts related to specifying and hosting application deployments
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与指定和托管应用程序部署相关的 Kubernetes 概念
- en: Deploying a containerized application to Kubernetes on a cloud platform
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云平台上将容器化应用程序部署到 Kubernetes
- en: Updating deployments with new versions of the application container
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用应用程序容器的新版本更新部署
- en: Running a version of Kubernetes locally for testing and development
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地运行 Kubernetes 版本进行测试和开发
- en: In the previous chapter, we covered how to containerize your application. If
    you stopped there, you would have a portable, reproducible environment for your
    app, not to mention a convenient developer setup. However, you may have trouble
    scaling that app when you go to production.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了如何容器化你的应用程序。如果你在那里停止，你将有一个便携且可重复的环境，更不用说方便的开发者设置。然而，当你进入生产时，你可能会有困难来扩展那个应用程序。
- en: For ultra-simple deployments where you don’t mind running one container per
    virtual machine (VM), you might be able to deploy containers to VMs directly and
    then scale your VMs as needed. You’d get a few of the advantages of containers,
    such as convenient packaging. However, if, like most, you have a number of different
    services to deploy, you’ll probably need something more flexible.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于超简单部署，如果你不介意每个虚拟机（VM）运行一个容器，你可能会直接将容器部署到 VM 上，然后根据需要扩展你的 VM。你会得到一些容器的好处，比如方便的打包。然而，如果你像大多数人一样，有多个不同的服务要部署，你可能需要更灵活的东西。
- en: This is where a container orchestrator like Kubernetes comes in. Container orchestration
    is just a fancy way of saying tooling that handles the scheduling and monitoring
    of a bunch of different containers on a bunch of different machines. It allows
    you to work primarily in terms of your application deployment—the container and
    its deployment attributes, such as how many replicas (instances) of the container
    there should be; and requirements such as high availability (spreading across
    failure domains), service networking, and so on—rather than needing to be overly
    concerned with the configuration of the underlying compute.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是容器编排器如 Kubernetes 发挥作用的地方。容器编排只是指处理多个不同机器上多个不同容器调度和监控的工具。它允许你主要从应用程序部署的角度工作——容器及其部署属性，例如应该有多少个容器副本（实例）；以及高可用性（跨故障域扩展）、服务网络等要求——而不是过度关注底层计算的配置。
- en: Being able to conveniently manage multiple services on a shared pool of compute
    resources gives you efficiency when running multiple applications or adopting
    patterns like microservices, where the various parts of your application are deployed
    and managed separately. You can mix different types of deployments, too, from
    a stateless application to a stateful database, batch jobs, and more—all without
    needing to worry too much about exactly which machine each container ends up actually
    running on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 能够方便地管理共享计算资源池中的多个服务，当运行多个应用程序或采用如微服务这样的模式时，其中应用程序的不同部分被分别部署和管理，这会给你带来效率。你还可以混合不同类型的部署，从无状态应用程序到有状态数据库、批处理作业等——而不必过多担心每个容器最终实际运行在哪个机器上。
- en: 3.1 Kubernetes architecture
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 Kubernetes 架构
- en: Kubernetes is an abstraction layer that sits at the workload level on top of
    the raw compute primitives like VMs (or bare metal machines) and load balancers.
    VMs are referred to as *nodes* and are arranged into a *cluster*. Containers (one
    or multiple) are grouped into a scheduling unit known as a *Pod*. Networking is
    configured via a *Service*. Other higher-order building blocks like *Deployment*
    exist to make Pods even easier to manage. Let’s explore some of the basic building
    blocks of this architecture before deploying our first workload.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个抽象层，它位于原始计算原语（如 VM 或裸机）和负载均衡器之上的工作负载级别。VM 被称为 *节点*，并排列成 *集群*。容器（一个或多个）被组合成一个称为
    *Pod* 的调度单元。网络通过 *服务* 进行配置。其他更高阶的构建块，如 *Deployment*，存在以使 Pod 更容易管理。在我们部署第一个工作负载之前，让我们探索这个架构的一些基本构建块。
- en: 3.1.1 The Kubernetes cluster
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 Kubernetes 集群
- en: The Kubernetes cluster is a collection of nodes, which are the compute instances
    on which the containers are run. Most commonly, these are virtual machines, but
    they can also be bare metal (nonvirtualized) machines. Each of these nodes runs
    a special Kubernetes process called the *kubelet*, which is responsible for communicating
    with the control plane (the Kubernetes orchestration process) and managing the
    lifecycle of the containers, which run on nodes via the container run time. Other
    than the operating system, the kubelet, and the container runtime environment,
    the remaining processes, including your own workloads and some system components
    responsible for logging and monitoring, are run in containers, as shown in figure
    3.1.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群是由节点组成的集合，这些节点是运行容器的计算实例。最常见的是虚拟机，但它们也可以是裸机（非虚拟化）机器。每个节点都运行一个特殊的Kubernetes进程，称为*kubelet*，它负责与控制平面（Kubernetes编排过程）通信并管理在节点上通过容器运行时运行的容器的生命周期。除了操作系统、kubelet和容器运行时环境之外，其他进程，包括您的工作负载和一些负责日志记录和监控的系统组件，都在容器中运行，如图3.1所示。
- en: '![03-01](../../OEBPS/Images/03-01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![03-01](../../OEBPS/Images/03-01.png)'
- en: Figure 3.1 Processes running on a VM, which Kubernetes calls a *node*
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 在虚拟机上运行的过程，Kubernetes称之为*节点*
- en: 'In the cluster, one or multiple (when operating in high availability mode)
    nodes have a special role, as shown in figure 3.2: running the Kubernetes orchestrator
    program itself. The special nodes that form the control plane are responsible
    for'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群中，一个或多个（在高可用模式下操作时）节点具有特殊角色，如图3.2所示：运行Kubernetes编排程序本身。构成控制平面的特殊节点负责
- en: Running the API, which you use to interact with the cluster using tools such
    as the Kubernetes command-line interface (CLI) tool
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行API，您可以使用它通过工具（如Kubernetes命令行界面（CLI）工具）与集群交互
- en: Storing the state of the cluster
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储集群的状态
- en: Coordinating with all the nodes in the cluster to schedule (start, stop, restart)
    containers on them
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调集群中的所有节点以调度（启动、停止、重启）它们上的容器
- en: '![03-02](../../OEBPS/Images/03-02.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![03-02](../../OEBPS/Images/03-02.png)'
- en: Figure 3.2 Self-managed Kubernetes cluster with the control plane and worker
    nodes
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 自管理的Kubernetes集群，包含控制平面和工作节点
- en: In most cloud environments, the control plane is offered as a managed service.
    In such environments, the control plane nodes are typically not visible to the
    user, and the fact that the control plane may run on a node is an implementation
    detail. In these environments, you’ll typically think of the cluster as the managed
    control plane with worker nodes, as shown in figure 3.3.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数云环境中，控制平面作为托管服务提供。在这样的环境中，控制平面节点通常对用户不可见，控制平面可能运行在节点上是一个实现细节。在这些环境中，您通常会认为集群是托管控制平面与工作节点组成的，如图3.3所示。
- en: '![03-03](../../OEBPS/Images/03-03.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![03-03](../../OEBPS/Images/03-03.png)'
- en: Figure 3.3 Cloud-based Kubernetes cluster with nodes connecting to a hosted
    control plane
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 基于云的Kubernetes集群，节点连接到托管控制平面
- en: Worker nodes (herein referred to simply as *nodes*) are responsible for managing
    the lifecycle of containers that run, including tasks such as starting and stopping
    containers. The control plane will instruct the node to run a certain container,
    but the actual execution of the container is then the responsibility of the node.
    The nodes also take some actions by themselves without needing to check in with
    the control plane, like restarting a container that has crashed or reclaiming
    memory when the node is running low.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 工作节点（在此简称为*节点*）负责管理运行中的容器的生命周期，包括启动和停止容器等任务。控制平面将指示节点运行特定的容器，但容器的实际执行则是节点的责任。节点也会自行采取一些行动，而无需向控制平面汇报，例如重启已崩溃的容器或在节点内存不足时回收内存。
- en: Collectively, the control plane and nodes form the *Kubernetes cluster* and
    provide the Kubernetes platform on which you can schedule your workloads. The
    cluster itself is provisioned and managed by whatever platform provider you use
    to run Kubernetes, which is responsible for creating the cluster resources like
    nodes. This book, aimed at developers, focuses primarily on *using* the Kubernetes
    cluster to run your workloads rather than the platform provider tasks (which are
    more in the cloud provider domain) of offering this service to developers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，控制平面和节点组成了*Kubernetes集群*，并提供了可以在其上调度你的工作负载的Kubernetes平台。集群本身是由你用来运行Kubernetes的平台提供商提供的，它负责创建集群资源，如节点。本书旨在面向开发者，主要关注*使用*Kubernetes集群来运行你的工作负载，而不是平台提供商的任务（这些任务更多地属于云提供商领域），为开发者提供这项服务。
- en: 3.1.2 Kubernetes objects
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 Kubernetes对象
- en: 'Once the cluster is created, you interact with Kubernetes primarily by creating,
    inspecting, and modifying Kubernetes objects through the Kubernetes API. Each
    of these objects represents a particular deployment construct in the system. For
    example, there is an object that represents a group of containers (Pod), one that
    represents a group of Pods (Deployment), one for network Services, and so on.
    Even the node is represented as an object which you can query to view the aspects
    of the current status, like how much resources are being used. To deploy a typical
    stateless web application into the cluster, you’ll use three objects: the Pod,
    a Deployment (which encapsulates the Pod), and a Service.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦集群创建完成，你主要通过创建、检查和修改通过Kubernetes API的Kubernetes对象与Kubernetes交互。这些对象中的每一个都代表系统中的特定部署结构。例如，有一个对象代表一组容器（Pod），一个代表一组Pod（Deployment），一个用于网络服务，等等。甚至节点也被表示为一个对象，你可以查询它来查看当前状态的一些方面，例如正在使用多少资源。要将典型的无状态Web应用程序部署到集群中，你将使用三个对象：Pod、Deployment（它封装Pod）和服务。
- en: Pod
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Pod
- en: The Pod is simply a collection of containers. Often, a Pod will be just a single
    container, but it could be multiple containers in the case where tightly coupled
    containers need to be deployed together (figure 3.4).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Pod仅仅是容器的一个集合。通常，Pod将只是一个单个容器，但在紧密耦合的容器需要一起部署的情况下，Pod可能会有多个容器（图3.4）。
- en: '![03-04](../../OEBPS/Images/03-04.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![03-04](../../OEBPS/Images/03-04.png)'
- en: Figure 3.4 The Kubernetes Pod, which can have one or many containers
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 Kubernetes Pod，可以有一个或多个容器
- en: The Pod is used as the primary scheduling unit in Kubernetes. Encompassing your
    application and its containers, it’s the unit of compute that Kubernetes schedules
    onto nodes according to the resources you require. For example, if your workload
    requires two CPU cores to run, you specify that in the Pod definition, and Kubernetes
    will find a machine with two available CPU resources.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Pod被用作Kubernetes中的主要调度单元。它包含你的应用程序及其容器，是Kubernetes根据你所需的资源在节点上调度的计算单元。例如，如果你的工作负载需要两个CPU核心来运行，你可以在Pod定义中指定这一点，Kubernetes将找到一个有两个可用CPU资源的机器。
- en: How many containers to a Pod?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Pod有多少个容器？
- en: Except for simple cases where a tightly coupled dependency exists between multiple
    containers, most containers are deployed individually with one container per Pod.
    Common situations where you might have multiple containers include so-called sidecars,
    where a second container is used for authorization, logging, or some other function,
    and other situations where multiple containers are tightly coupled, such that
    they benefit from being deployed together.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存在多个容器之间紧密耦合依赖的简单情况外，大多数容器都是独立部署的，每个Pod一个容器。你可能有多容器的情况包括所谓的sidecars，其中第二个容器用于授权、日志记录或其他功能，以及其他多个容器紧密耦合的情况，这样它们可以从一起部署中受益。
- en: 'If you were to inspect the processes running on the node, you would not see
    the Pod itself, just a bunch of processes from the containers (figure 3.5). The
    Pod is just a logical grouping of containers. It’s Kubernetes that binds these
    containers together, ensuring that they share a common lifecycle: they are created
    together; if one fails, they are restarted together; and they are terminated together.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查节点上运行的过程，你不会看到Pod本身，只会看到来自容器的许多进程（图3.5）。Pod只是容器的一个逻辑分组。是Kubernetes将这些容器绑定在一起，确保它们共享一个共同的生存周期：它们一起创建；如果一个失败，它们会一起重启；并且它们会一起终止。
- en: '![03-05](../../OEBPS/Images/03-05.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![03-05](../../OEBPS/Images/03-05.png)'
- en: Figure 3.5 Multiple Pods running on a node
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 节点上运行的多个Pod
- en: Deployment
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Deployment
- en: While you can instruct Kubernetes to run Pods directly, you will rarely do so.
    Applications crash and machines fail, so Pods need to be restarted or rescheduled.
    Instead of directly scheduling Pods, it’s better to wrap them into a higher-order
    object that manages the Pod lifecycle.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以指示 Kubernetes 直接运行 Pods，但你很少这样做。应用程序会崩溃，机器会失败，因此 Pods 需要重新启动或重新调度。与其直接调度
    Pods，不如将它们包装成一个更高阶的对象，该对象管理 Pods 的生命周期。
- en: For applications like web servers that need to run continuously, that object
    is a *Deployment*. Other options include a *Job* for running batch processes to
    completion, covered in chapter 10\. In the Deployment, you specify how many replicas
    of the Pod you wish to be running and other information, like how updates should
    be rolled out.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要持续运行的 Web 服务器等应用程序，该对象是 *Deployment*。其他选项包括在第 10 章中介绍的用于运行批处理过程的 *Job*。在
    Deployment 中，你指定希望运行的 Pod 副本数量以及其他信息，例如如何滚动更新。
- en: Like all objects in Kubernetes, a Deployment (figure 3.6) is a specification
    for the desired state of the system, which Kubernetes seeks to actuate. You can
    specify things like the number of replicas of your Pod and, as we’ll cover in
    later chapters, detailed requirements for how the Pods are spread across the cluster.
    Kubernetes continuously reconciles the observed state to the desired state while
    attempting to deliver what you requested. For example, if a Pod was to become
    unavailable sometime after it was deployed, like what would happen if the node
    it was running on failed, Kubernetes will observe that there are fewer Pods running
    than desired and schedule new instances of the Pod to once again meet your requirements.
    These automated operations for scaling and repairing are the primary reason for
    using a Deployment to manage the lifecycle of a service, rather than running Pods
    directly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Kubernetes 中的所有对象一样，Deployment（图 3.6）是系统期望状态的规范，Kubernetes 试图实现这一状态。你可以指定诸如
    Pod 的副本数量等信息，以及我们在后续章节中将要讨论的 Pod 在集群中分布的详细要求。Kubernetes 在尝试提供你所请求的内容的同时，持续地将观察到的状态与期望状态进行协调。例如，如果某个
    Pod 在部署后某个时间点变得不可用，比如运行它的节点失败，Kubernetes 会观察到运行的 Pods 数量少于期望值，并调度新的 Pod 实例以满足你的要求。这些自动化的扩展和修复操作是使用
    Deployment 而不是直接运行 Pods 来管理服务生命周期的首要原因。
- en: '![03-06](../../OEBPS/Images/03-06.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![03-06](../../OEBPS/Images/03-06.png)'
- en: Figure 3.6 A Deployment with three replicas of Pod `foo-app`
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 包含三个 Pod `foo-app` 副本的 Deployment
- en: Service
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 服务
- en: Services are how you expose an application running on a set of Pods as a network
    service. A Service provides a single addressing mechanism and spreads the load
    across the Pods (figure 3.7). Services get their own internal IP address and DNS
    record, which can be referenced by other Pods running within the cluster, and
    can also be assigned an external IP address.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是暴露在一系列 Pods 上运行的应用程序作为网络服务的方式。服务提供了一个单一的寻址机制，并在 Pods 之间分配负载（图 3.7）。服务有自己的内部
    IP 地址和 DNS 记录，可以在集群内运行的其他 Pods 中引用，也可以分配一个外部 IP 地址。
- en: '![03-07](../../OEBPS/Images/03-07.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![03-07](../../OEBPS/Images/03-07.png)'
- en: Figure 3.7 A Kubernetes Service
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 Kubernetes 服务
- en: 3.2 Deploying an application
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 部署应用程序
- en: 'Let’s get started by deploying an application and making it available on the
    internet. Later, we’ll update it with a new version. In other words, we will perform
    a basic application development-release-update cycle with Kubernetes. To do this,
    we’ll use the Kubernetes objects discussed in the prior section: a *Pod*, which
    will be managed by a *Deployment*, and exposed with a *Service*.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从部署一个应用程序并在互联网上使其可用开始。稍后，我们将使用新版本更新它。换句话说，我们将使用 Kubernetes 在前一个章节中讨论的对象执行基本的应用程序开发-发布-更新周期：一个
    *Pod*，它将由 *Deployment* 管理，并通过 *Service* 暴露。
- en: 3.2.1 Creating a cluster
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 创建集群
- en: Before deploying the application, you’ll need a Kubernetes cluster to use. I
    recommend creating one on a public cloud, as it’s less hassle to get set up, and
    people can check out your creations immediately as you can share a public IP for
    any services you deploy. Many cloud providers have free trials to help reduce
    costs while learning.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署应用程序之前，你需要一个 Kubernetes 集群来使用。我建议在公共云上创建一个，因为这样设置起来更方便，人们可以立即查看你的作品，因为你可以为部署的任何服务共享一个公共
    IP。许多云服务提供商都提供免费试用，以帮助在学习过程中降低成本。
- en: Developing with a local Kubernetes cluster is another option, but there are
    some inherent differences between the environment of a local Kubernetes cluster
    and a cloud-based cluster, particularly around things like load balancing. I prefer
    to learn the environment that I can use in production on day one, hence my suggestion
    to pick a cloud provider and start with that.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本地 Kubernetes 集群进行开发是另一种选择，但本地 Kubernetes 集群的环境与基于云的集群之间有一些固有的差异，尤其是在像负载均衡这样的问题上。我更喜欢学习第一天就能在生产环境中使用的环境，因此我建议选择一个云提供商并从那里开始。
- en: Prefer a local cluster?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 倾向于使用本地集群？
- en: If you’d prefer to use a local distribution of Kubernetes, I’ve got you covered.
    Follow the steps in section 3.4 to get your `kubectl` command connected to a local
    cluster instead and then come back to section 3.2.3 on deploying to Kubernetes
    and continue.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更愿意使用本地的 Kubernetes 发行版，我已经为你准备好了。按照第 3.4 节的步骤操作，将你的 `kubectl` 命令连接到本地集群，然后再回到第
    3.2.3 节继续部署到 Kubernetes 的内容。
- en: Just note that when you go to deploy your own locally built container image,
    there are some considerations that are outlined in section 3.4 to ensure Kubernetes
    can find your image, and the way you access any Services you create will be different
    (also outlined in that section) due to the lack of public load balancers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 只要注意，当你准备部署你自己的本地构建的容器镜像时，有一些在 3.4 节中概述的考虑因素，以确保 Kubernetes 可以找到你的镜像，并且由于缺乏公共负载均衡器，你访问你创建的任何服务的方式将不同（也在该节中概述）。
- en: 'At the end of the day, all you need to run just about every sample in this
    book is a Kubernetes cluster hosted somewhere and the Kubernetes command-line
    tool `kubectl` (pronounced: “cube cuttle”) authenticated to use that cluster,
    which any getting-started guide should get you. The next two steps use Google
    Cloud, but I’ll also include some instructions along the way on how to substitute
    the platform of your choice.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你只需要一个托管在某处的 Kubernetes 集群和认证到该集群使用的 Kubernetes 命令行工具 `kubectl`（发音为：“cube
    cuttle”），就可以运行这本书中的几乎所有示例了。接下来的两个步骤将使用 Google Cloud，但我也会在过程中提供如何替换你选择的平台的说明。
- en: Google Kubernetes Engine
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Google Kubernetes Engine
- en: Google Kubernetes Engine (GKE) was the first Kubernetes product to market and
    is a popular choice for trying out Kubernetes due to its maturity and ease of
    use. I work on the GKE team, and I know this platform best, so it’s the one I’ll
    be using for the few places in this book with platform-specific requirements.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Google Kubernetes Engine (GKE) 是第一个推向市场的 Kubernetes 产品，由于其成熟度和易用性，成为尝试 Kubernetes
    的热门选择。我在 GKE 团队工作，对这个平台最为了解，因此我将在这本书中需要特定平台要求的一些地方使用它。
- en: I’ve written this book to be applicable anywhere you find Kubernetes, and I
    expect that it will be useful for learning Kubernetes whether you’re using GKE,
    OpenShift, Azure Kubernetes Service (AKS), Elastic Kubernetes Service (EKS), or
    any one of the other Kubernetes platforms and distributions out there. There are
    a few places where the platform plays a role (like now, when creating a cluster),
    and in those instances, I’ll demonstrate the action with instructions for GKE,
    but I’ll also be providing pointers on how to find the equivalents on other platforms.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我写这本书是为了在任何你找到 Kubernetes 的地方都能使用，我预计无论你是使用 GKE、OpenShift、Azure Kubernetes Service
    (AKS)、Elastic Kubernetes Service (EKS) 还是其他任何 Kubernetes 平台和发行版，这本书都将对你学习 Kubernetes
    有用。在少数几个地方，平台会发挥作用（比如现在创建集群的时候），在这些情况下，我会用 GKE 的说明来演示操作，但我也会提供如何在其他平台上找到等效操作的指南。
- en: Creating a Kubernetes cluster on any cloud
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何云上创建 Kubernetes 集群
- en: All you need to run the examples in this chapter after this setup section is
    the `kubectl` tool authenticated to the Kubernetes cluster of your choice. Creating
    and authenticating `kubectl` is the goal, and as you will see for GKE, this can
    be done with two commands. You can substitute those commands for the equivalent
    cluster creation and authentication for the platform of your choice.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设置部分之后，你只需要运行本章示例的 `kubectl` 工具已经认证到你所选择的 Kubernetes 集群。创建和认证 `kubectl` 是目标，正如你将看到的
    GKE 一样，这可以通过两个命令完成。你可以用你选择的平台的等效集群创建和认证命令替换这些命令。
- en: To run the following examples on any provider, follow the cluster creation guide
    for the provider of your choice and then continue to section 3.2.2\. Uploading
    containers is also another provider-specific action, but I’ve got you covered
    with some general tips there on how to get that done on any platform.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要在任何提供程序上运行以下示例，请遵循您选择的提供程序的集群创建指南，然后继续到第3.2.2节。上传容器也是另一个特定于提供程序的操作，但我已经为您提供了如何在任何平台上完成此操作的通用提示。
- en: To start with GKE, you’ll need a Google Account (if you have an @gmail.com email
    address, then you have a Google Account). Head over to [https://console.cloud.google.com/](https://console.cloud.google.com/),
    select your account, and review the terms. Activate your free trial if you have
    not done so already or add billing info so you can run these samples (again, if
    you wish to run the samples locally, you can instead follow the steps in section
    3.4 to get a local-only cluster).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用GKE，您需要一个Google账户（如果您有@gmail.com电子邮件地址，那么您就有Google账户）。请访问[https://console.cloud.google.com/](https://console.cloud.google.com/)，选择您的账户，并查看条款。如果您尚未激活免费试用，请激活它，或者添加账单信息以便您能够运行这些示例（如果您希望在本地上运行示例，您也可以按照第3.4节中的步骤操作以获取仅本地的集群）。
- en: 'With your account set up, head over to GKE in the console (direct link: [https://console.cloud.google.com/kubernetes](https://console.cloud.google.com/kubernetes))
    and create a cluster. I recommend Autopilot mode, which takes care of the provisioning
    and management of nodes for you. With Autopilot, you can set a name, pick a region
    (as I’ve done in figure 3.8), and leave the networking and advanced settings as
    the default.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的账户设置完成后，转到控制台中的GKE（直接链接：[https://console.cloud.google.com/kubernetes](https://console.cloud.google.com/kubernetes)）并创建一个集群。我建议使用自动模式，该模式会为您处理节点的供应和管理。使用自动模式，您可以设置名称，选择一个区域（如图3.8所示），并将网络和高级设置保留为默认值。
- en: '![03-08](../../OEBPS/Images/03-08.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![03-08](../../OEBPS/Images/03-08.png)'
- en: Figure 3.8 GKE Autopilot’s cluster creation UI
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 GKE Autopilot的集群创建用户界面
- en: Next, set up the command-line tools. You’ll need the cloud provider CLI (in
    this case, `gcloud` for Google Cloud) to perform cluster operations like creating
    and authenticating, and `kubectl` for interacting with the Kubernetes API. Download
    the `gcloud` CLI at [https://cloud.google.com/sdk/install](https://cloud.google.com/sdk/install)
    and follow the installation instructions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置命令行工具。您需要云提供程序CLI（在本例中为`gcloud`用于Google Cloud）来执行集群操作，如创建和认证，以及`kubectl`用于与Kubernetes
    API交互。在[https://cloud.google.com/sdk/install](https://cloud.google.com/sdk/install)下载`gcloud`
    CLI并按照安装说明操作。
- en: 'Once installed, run the `gcloud` `init` command to log in. If you have more
    than one Google Account, be sure to select the same account that you created the
    cluster in earlier:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，运行`gcloud init`命令进行登录。如果您有多个Google账户，请确保选择您之前创建集群时使用的相同账户：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The Kubernetes CLI, `kubectl`, can be installed standalone (following the instructions
    at [https://kubernetes.io/docs/tasks/tools/](https://kubernetes.io/docs/tasks/tools/))
    or via `gcloud`. It doesn’t matter how you install it, but since this example
    uses `gcloud`, we can conveniently use it to install `kubectl`, like so:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes CLI，`kubectl`，可以独立安装（按照[https://kubernetes.io/docs/tasks/tools/](https://kubernetes.io/docs/tasks/tools/)中的说明操作）或通过`gcloud`安装。安装方式无关紧要，但鉴于本例使用`gcloud`，我们可以方便地使用它来安装`kubectl`，如下所示：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the cluster is ready and `gcloud` is configured, click Connect in the
    UI and copy the gcloud command provided (as seen in figure 3.9) into your shell
    to authenticate `kubectl`. Or, run the following command with your own cluster
    details:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦集群准备就绪且`gcloud`已配置，请在UI中点击“连接”，并将提供的gcloud命令（如图3.9所示）复制到您的shell中以认证`kubectl`。或者，使用您自己的集群详细信息运行以下命令：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![03-09](../../OEBPS/Images/03-09.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![03-09](../../OEBPS/Images/03-09.png)'
- en: Figure 3.9 GKE’s cluster connection UI
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 GKE的集群连接用户界面
- en: That command is the glue between the Google Cloud world and the Kubernetes one
    and authenticates the `kubectl` CLI with the right credentials to access your
    GKE cluster.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令是Google Cloud世界和Kubernetes之间的粘合剂，并使用正确的凭据对`kubectl` CLI进行认证以访问您的GKE集群。
- en: Creating clusters in the CLI
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在CLI中创建集群
- en: 'Rather than using the UI, you can do both the creation and connection steps
    from the command line, like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用用户界面，您可以从命令行执行创建和连接步骤，如下所示：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With your cluster created and `kubectl` authenticated, you’re ready to get
    going with your first application! To make sure everything is working, run `kubectl`
    `get` `pods`. It should state that there are no resources (since we’ve yet to
    deploy any Pods):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的集群创建并`kubectl`认证后，你就可以开始使用你的第一个应用程序了！为了确保一切正常，运行`kubectl get pods`。它应该指出没有资源（因为我们还没有部署任何Pods）：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you get an error, it is likely that your cluster wasn’t created or authenticated
    correctly. Try repeating the previous steps or lookup the error message.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到错误，很可能是你的集群没有正确创建或认证。尝试重复之前的步骤或查找错误信息。
- en: 3.2.2 Uploading your container
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 上传你的容器
- en: Until now, the containers we’ve created have been stored and run locally on
    your machine. Before you can deploy the container into Kubernetes running in the
    cloud, you’ll need to upload your container image to a container registry. This
    is simply a place that stores the container image data and provides a way for
    Kubernetes to fetch the image. Most registries support options for public images,
    which anyone can use (like for open source projects and samples for a book), or
    private images, which require authentication (which you will use for your own
    proprietary applications).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的容器都存储和运行在本地的机器上。在你可以将容器部署到云中运行的Kubernetes之前，你需要将你的容器镜像上传到容器注册库。这只是一个存储容器镜像数据并提供Kubernetes获取镜像的方式的地方。大多数注册库支持公共镜像选项，任何人都可以使用（如开源项目和书籍的示例），或者私有镜像，这需要认证（你将使用它来为你的专有应用程序）。
- en: If you prefer, you can skip this step and use the publicly available images
    referenced in the following examples. However, I’d recommend that you build and
    upload your own container to use, so you can deploy your own applications when
    the time comes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以跳过此步骤并使用以下示例中引用的公开可用的镜像。然而，我建议你构建并上传自己的容器来使用，这样你就可以在需要的时候部署自己的应用程序。
- en: Docker Hub is a popular choice as a container registry, particularly when it
    comes to public container images. This includes the base images (like the ones
    we used in the previous chapter), open source software like MariaDB, or perhaps
    your own software and demos you wish to share with the world. You can also access
    private container images from Docker Hub (and other registries) from any Kubernetes
    platform, with a bit of extra configuration to set up the credentials.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub作为一个容器注册库的选择很受欢迎，尤其是在公共容器镜像方面。这包括基础镜像（如我们在上一章中使用的那些），开源软件如MariaDB，或者可能是你希望与世界分享的自己的软件和演示。你还可以从Docker
    Hub（和其他注册库）访问任何Kubernetes平台的私有容器镜像，只需进行一些额外的配置来设置凭证。
- en: The default choice for most users who wish to keep their images *private* is
    to use the container registry of your cloud provider, as this generally gives
    you efficiencies in terms of image pull time, reduced network data costs, and
    simpler authentication. For Google Cloud, that’s Artifact Registry; on Amazon
    Web Services (AWS), it’s Amazon Elastic Container Registry; on Azure, it’s Azure
    Container Registry; and so on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数希望保持其镜像*私有*的用户来说，使用云提供商的容器注册库是默认选择，因为这通常在镜像拉取时间、减少网络数据成本和简化认证方面提供了效率。对于Google
    Cloud，那是Artifact Registry；在Amazon Web Services (AWS)上，它是Amazon Elastic Container
    Registry；在Azure上，它是Azure Container Registry；等等。
- en: Once you have chosen your preferred location, follow these steps to get your
    containers uploaded.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了你偏好的位置，按照以下步骤上传你的容器。
- en: Account setup
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 账户设置
- en: To get started, first create an account at your preferred provider if you don’t
    have one already and then create a repository where you’ll be uploading the images.
    For Docker Hub, head over to [https://hub.docker.com/](https://hub.docker.com/),
    sign in, and then navigate to Create Repository.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，如果你还没有账户，首先在你偏好的提供商处创建一个账户，然后创建一个仓库，你将在其中上传图片。对于Docker Hub，请访问[https://hub.docker.com/](https://hub.docker.com/)，登录，然后导航到创建仓库。
- en: For Artifact Registry, go to [https://console.cloud.google.com/artifacts](https://console.cloud.google.com/artifacts)
    and create a new repository of type Docker in your desired location. Make a note
    of the path that is generated, which will look something like `us-docker.pkg.dev/my-project/my
    -repository`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Artifact Registry，请访问[https://console.cloud.google.com/artifacts](https://console.cloud.google.com/artifacts)，并在你希望的位置创建一个类型为Docker的新仓库。注意生成的路径，它看起来可能像`us-docker.pkg.dev/my-project/my-repository`。
- en: Authenticate
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 认证
- en: Next, you want to authenticate the `docker` command-line tool so it can upload
    images to your freshly created repository. Follow the instructions for your container
    registry to authenticate the docker command-line tool.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你想要验证`docker`命令行工具，以便它可以上传镜像到你的新创建的仓库。按照你的容器仓库的说明来验证`docker`命令行工具。
- en: To do this in Docker Hub, you would run
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Docker Hub中这样做，你会运行
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For Artifact Registry, recall the path of the repository you created earlier.
    Take the host portion of that path (e.g., `us-docker.pkg.dev`) and run the following
    command to install a credential helper to the Docker tool so you can upload images
    there. You can run this multiple times, once for each separate host you use:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工件仓库，回想一下你之前创建的仓库路径。取该路径的主机部分（例如，`us-docker.pkg.dev`），然后运行以下命令将凭证助手安装到Docker工具中，以便你可以将镜像上传到那里。你可以多次运行此命令，每次运行针对你使用的每个单独的主机：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: TIP Authenticating Docker with the cloud provider of your choice is typically
    an easy operation. Just look for the cloud-specific command to configure the Docker
    CLI with the right credentials. The search query “authenticate docker with [your
    cloud provider] container registry” should do the trick!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：使用你选择的云提供商验证Docker通常是一个简单的操作。只需查找配置Docker CLI的正确凭证的云特定命令。搜索查询“使用[你的云提供商]容器仓库验证Docker”应该可以解决问题！
- en: Tag
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 标签
- en: When you build images, they are assigned a random hash-based name, like `82ca16cefe84`.
    Generally, it is a good idea to add your own tag that is somewhat meaningful so
    you can easily refer to your own images. In the previous chapter, we used these
    tags so we could run our images locally using nice names like `docker` `run` `timeserver`
    instead of `docker` `run` `82ca16cefe84`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建镜像时，它们会被分配一个基于随机哈希的名称，例如`82ca16cefe84`。通常，添加一个具有一定意义的自定义标签是一个好主意，这样你可以轻松地引用自己的镜像。在前一章中，我们使用了这些标签，这样我们就可以使用像`docker`
    `run` `timeserver`这样的友好名称在本地运行我们的镜像，而不是使用`docker` `run` `82ca16cefe84`。
- en: When you upload containers into container registries, the tag takes on an additional
    meaning. You are required to tag the image with a name that follows a specific
    path convention dictated by the container registry for it to know which account
    and path to store the image in (and so that your local docker client knows which
    registry to upload it to). Tagging your image with a simple name like `timeserver`
    won’t work when you’re uploading to these repositories.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将容器上传到容器仓库时，标签具有额外的含义。你必须使用遵循容器仓库指定的特定路径约定的名称来标记镜像，以便它知道将镜像存储在哪个账户和路径中（以及让你的本地Docker客户端知道上传到哪个仓库）。当你上传到这些仓库时，使用像`timeserver`这样的简单名称来标记你的镜像将不起作用。
- en: Docker Hub uses the convention
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub使用以下约定
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: where `$USERNAME` is your docker username, `$REPOSITORY_NAME` is the name of
    the repository you created in Docker Hub, and `$VERSION_TAG` is an arbitrary string
    (typically including a number). Putting it together, in my own case, where my
    username is “wdenniss”, and my repository is “timeserver”, the string I get is
    `docker.io/wdenniss/timeserver:1`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`$USERNAME`是你的Docker用户名，`$REPOSITORY_NAME`是你创建在Docker Hub中的仓库名称，`$VERSION_TAG`是一个任意字符串（通常包括一个数字）。结合我的情况，我的用户名是“wdenniss”，我的仓库是“timeserver”，我得到的字符串是`docker.io/wdenniss/timeserver:1`。
- en: The version tag
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 版本标签
- en: 'The version tag is an unstructured string used to refer to the version of the
    image. The convention is to use the version number (potentially constructed as
    major.minor .patch) and optionally with a suffix: for example, `2`.`2.1`, `2.1.5`,
    `2.1.5-beta`. A special version tag `latest` can be used to refer to the most
    recent image when running containers, but don’t use `latest` when tagging the
    images for upload, as it’s applied automatically by the container repository.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 版本标签是一个无结构的字符串，用于引用镜像的版本。约定是使用版本号（可能构造为major.minor .patch）和可选后缀：例如，`2`.`2.1`，`2.1.5`，`2.1.5-beta`。可以使用特殊的版本标签`latest`来引用运行容器时最新的镜像，但在标记上传的镜像时不要使用`latest`，因为它会被容器仓库自动应用。
- en: 'Each repository has its own format. For Google Cloud’s Artifact Registry, the
    format consists of the following construction:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每个仓库都有自己的格式。对于Google Cloud的工件仓库，其格式由以下结构组成：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After you create the Artifact Registry repository in the UI console, you should
    see the first portion of this string displayed (e.g., `us-docker.pkg.dev/wdenniss/ts`),
    which you can copy (or you can build the string using the previous formula). To
    this prefix, append any image name and tag that you like, such as `timeserver:1`.
    Put it together, and you’ll get something, which, for me, looks like the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI控制台中创建Artifact Registry仓库后，您应该看到字符串的前一部分显示出来（例如，`us-docker.pkg.dev/wdenniss/ts`），您可以复制（或者您也可以使用前面的公式构建字符串）。在这个前缀后面，添加您喜欢的任何镜像名称和标记，例如`timeserver:1`。将其组合起来，对我来说，看起来如下所示：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Container registry tag conventions
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 容器仓库标记约定
- en: 'Every private container registry has its own magic string concatenation that
    you need to create the right tag, and they’re all different. For example, Azure^a
    documents `$REGISTRY_NAME.azurecr.io/$REPOSITORY_NAME:$VERSION_TAG` and AWS^b
    documents `$AWS_ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com/$REPOSITORY_NAME: $VERSION_TAG`*.*
    One thing I’m sure about: make sure you follow the guidelines of whatever container
    registry you’re using; otherwise, Kubernetes won’t know where to push the image.
    The search term I use is “[cloud provider] registry container tag name.”'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '每个私有容器仓库都有自己的魔法字符串连接，您需要创建正确的标记，而且它们都不同。例如，Azure^a记录了`$REGISTRY_NAME.azurecr.io/$REPOSITORY_NAME:$VERSION_TAG`，AWS^b记录了`$AWS_ACCOUNT_ID.dkr.ecr.$REGION.amazonaws.com/$REPOSITORY_NAME:
    $VERSION_TAG`*.* 我可以肯定的是：确保您遵循您所使用的容器仓库的指南；否则，Kubernetes将不知道将镜像推送到哪里。我使用的搜索词是“[cloud
    provider] registry container tag name”。'
- en: ^a [http://mng.bz/o1YD](http://mng.bz/o1YD)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ^a [http://mng.bz/o1YD](http://mng.bz/o1YD)
- en: ^b [http://mng.bz/nWOd](http://mng.bz/nWOd)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ^b [http://mng.bz/nWOd](http://mng.bz/nWOd)
- en: 'Once you’ve worked out the right image tag to use (which we’ll refer to as
    `$IMAGE_TAG` in the remaining examples), you can tag any existing Docker image
    for uploading. To upload one of the images we built in the earlier chapter to
    a container registry, you can reference the image from its previous tag and add
    a container registry tag (images can have multiple tags). If you built the example
    in section 2.2.1 using `docker` `build` `.` `-t` `timeserver`, this image will
    have the tag `timeserver`, which means we can retag it for the container registry,
    like so:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了要使用的正确镜像标记（在后续示例中我们将称之为`$IMAGE_TAG`），您就可以为上传标记任何现有的Docker镜像。要将我们在早期章节中构建的其中一个镜像上传到容器仓库，您可以引用其之前的标记并添加容器仓库标记（镜像可以有多个标记）。如果您在2.2.1节中使用`docker`
    `build` `.` `-t` `timeserver`构建了示例，这个镜像将具有`timeserver`标记，这意味着我们可以将其重新标记为容器仓库，如下所示：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note If you get the error “No such image,” then keep reading as we are about
    to build it from scratch again anyway.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您收到“没有这样的镜像”错误，请继续阅读，因为我们即将从头开始再次构建它。
- en: 'You can view the resulting list of images, like so:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看生成的镜像列表，如下所示：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can also look up existing images and tag them based on image ID (`docker`
    `tag` `$IMAGE_ID` `$IMAGE_TAG`), but I suggest tagging when you build to avoid
    confusion. In fact, I generally find it quicker to simply rebuild the image than
    try to find the right image ID after the fact.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以根据镜像ID（`docker` `tag` `$IMAGE_ID` `$IMAGE_TAG`）查找现有镜像并对其进行标记，但我建议在构建时进行标记以避免混淆。实际上，我通常发现简单地重新构建镜像比事后尝试找到正确的镜像ID要快得多。
- en: To build and tag the sample container, replace `$IMAGE_TAG` with your own repository
    image name, and from the root sample directory run
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和标记示例容器，请将`$IMAGE_TAG`替换为您自己的仓库镜像名称，然后从根示例目录运行
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Push
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 推送
- en: Once our repository is set up, Docker is authenticated, and your image is tagged,
    you can push the image to the repository with
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的仓库设置完成，Docker认证就绪，并且您的镜像已标记，您可以使用以下命令将镜像推送到仓库
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previous authentication step installed a helper into the Docker configuration
    that enables Docker to speak with your cloud’s container registry, whatever that
    may be. If you get a Permission Denied error, either you didn’t authenticate Docker
    correctly, or your image tag string construction is wrong. Verify that you authenticated
    Docker to the appropriate repository and set the correct image tag. Refer to the
    up-to-date documentation for your chosen container registry for guidance.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的认证步骤在Docker配置中安装了一个辅助程序，使Docker能够与您的云容器仓库进行通信，无论是什么。如果您收到“权限拒绝”错误，那么要么您没有正确认证Docker，要么您的镜像标记字符串构建错误。请验证您是否已将Docker认证到适当的仓库并设置了正确的镜像标记。请参考您选择的容器仓库的最新文档以获取指导。
- en: 'If it goes well, you should see output like the following. Pay particular attention
    to the last line, which is where any authentication errors will be displayed:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会看到以下输出。特别注意最后一行，这是任何认证错误将显示的位置：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once the image has been uploaded, you’re now ready to deploy your code into
    Kubernetes!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦镜像已上传，你现在就可以将你的代码部署到 Kubernetes 中了！
- en: 3.2.3 Deploying to Kubernetes
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 部署到 Kubernetes
- en: With a cluster created and `kubectl` authenticated, we can deploy our first
    application. To do this, we’ll create an aptly named Deployment object. Kubernetes
    uses declarative configuration, where you declare the state you want (like “I
    want 3 copies of my container running in the cluster”) in a configuration file.
    Then, submit that config to the cluster, and Kubernetes will strive to meet the
    requirements you specified.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建集群并使用 `kubectl` 进行认证后，我们可以部署我们的第一个应用程序。为此，我们将创建一个恰如其分的 Deployment 对象。Kubernetes
    使用声明式配置，你在配置文件中声明你想要的状态（例如，“我想要在集群中运行 3 个我的容器副本”），然后提交该配置到集群，Kubernetes 将努力满足你指定的要求。
- en: For the configuration file, most developers use YAML as it’s easier to edit
    manually. JSON is another option (primarily used with automated access), and some
    config can be created imperatively (discussed in section 3.3). Listing 3.1 is
    a minimal Deployment specification for the timeserver application from chapter
    2\. It references a public container image built from the included sample app,
    which I have uploaded to Docker Hub. If you have your own image, such as one pushed
    to a container repository in the previous section, edit this file and replace
    my image with yours.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于配置文件，大多数开发者使用 YAML，因为它更容易手动编辑。JSON 是另一个选项（主要用于自动化访问），并且某些配置可以命令式地创建（在第 3.3
    节中讨论）。列表 3.1 是来自第 2 章的 timeserver 应用程序的极简 Deployment 规范。它引用了一个由包含的样本应用程序构建的公共容器镜像，我已经将其上传到
    Docker Hub。如果你有自己的镜像，例如在上一节中推送到容器仓库的镜像，请编辑此文件，并用你的镜像替换我的镜像。
- en: Listing 3.1 Chapter03/3.2_DeployingToKubernetes/deploy.yaml
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.1 第 3 章/3.2_DeployingToKubernetes/deploy.yaml
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ How many Pod replicas (instances) to deploy
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 部署多少个 Pod 副本（实例）
- en: ❷ Which container image to deploy and run
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 部署和运行哪个容器镜像
- en: This manifest will create three replicas of our container. Later, we’ll see
    how to configure a load balancer to split incoming requests over these three running
    instances. In this example of a minimalist Deployment config, the three most important
    lines are the name, which is needed to inspect, modify, and delete the Deployment;
    the replica count; and the container name. The rest is basically glue to make
    it all work (don’t worry, I’ll explain how the glue works as well).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此清单将创建我们容器的三个副本。稍后，我们将看到如何配置负载均衡器来将这些三个运行实例的传入请求进行分配。在这个极简的 Deployment 配置示例中，最重要的三条线是名称，这是检查、修改和删除
    Deployment 所必需的；副本数量；以及容器名称。其余部分基本上是使一切工作的粘合剂（别担心，我还会解释粘合剂是如何工作的）。
- en: The container image path is like a URL that references where to find the container.
    If you uploaded your container following the previous section, you already have
    this image path from that step. My container image with the docker.io prefix is
    available on Docker Hub, a popular place to host public images, including base
    images. One thing to note is that if you ever see an image path without a domain,
    like `ubuntu`, or `wdenniss/timeserver`, it’s simply shorthand for an image hosted
    on Docker Hub.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像路径就像一个 URL，它引用了查找容器的位置。如果你按照上一节上传了你的容器，你已经在那个步骤中有了这个镜像路径。我的带有 docker.io
    前缀的容器镜像可在 Docker Hub 上找到，这是一个流行的托管公共镜像的地方，包括基础镜像。需要注意的是，如果你看到没有域的镜像路径，例如 `ubuntu`
    或 `wdenniss/timeserver`，它只是指在 Docker Hub 上托管的镜像的简写。
- en: So, that’s the Deployment. Let’s create it in the cluster. From the root sample
    directory, run
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是 Deployment。让我们在集群中创建它。从根样本目录中运行
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This instructs Kubernetes to create the object defined by the configuration
    file. If you need to make changes once it’s deployed (like changing the image
    version), you can make your changes locally and update the Deployment in the cluster
    with
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示 Kubernetes 创建配置文件中定义的对象。如果你在部署后需要做出更改（例如更改镜像版本），你可以在本地进行更改，并使用以下命令更新集群中的
    Deployment
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To observe the state of the Deployment, run
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要观察 Deployment 的状态，请运行
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As mentioned earlier, the Deployment is a declarative statement of your desired
    requirements, for example, “3 replicas of this Pod.” When you create the Deployment
    and the system returns a success response, it simply means that Kubernetes accepted
    your Deployment for scheduling—not that it had completed scheduling in the manner
    you desired. Querying the Deployment with `kubectl` `get` will show you the current
    status, such as how many of the Pods are ready to serve traffic (the number in
    the `READY` column) and later, when you update the Deployment, how many of the
    pods are running the latest version during a roll out of a new version (the number
    in the `UP-TO-DATE` column). To see more detail about the Pods that form your
    Deployment, you can also query the Pods themselves:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Deployment 是你所需要求的声明性语句，例如，“3 个副本的此 Pod。”当你创建 Deployment 并系统返回成功响应时，这仅仅意味着
    Kubernetes 接受了你的 Deployment 以进行调度——并不意味着它已经按照你期望的方式完成了调度。使用 `kubectl get` 查询 Deployment
    将会显示当前状态，例如有多少个 Pod 准备好服务流量（`READY` 列中的数字），以及稍后，当你更新 Deployment 时，有多少个 Pod 在新版本部署过程中运行最新版本（`UP-TO-DATE`
    列中的数字）。要查看构成你的 Deployment 的 Pod 的更多详细信息，你也可以查询这些 Pod 本身：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'NOTE If Pods show pending here, it may mean that your cluster doesn’t have
    enough resources. In the case of a dynamically provisioned environment, simply
    waiting a minute or so is generally enough to see them scheduled. If they stay
    pending, review the advice that follows in the section “Troubleshooting: Stuck
    in Pending.”'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果这里显示 Pod 处于挂起状态，这可能意味着你的集群没有足够的资源。在动态配置的环境中，通常只需等待一分钟或更长时间就足够看到它们被调度。如果它们仍然处于挂起状态，请查看“故障排除：卡在挂起状态”部分中的后续建议。
- en: 'The `kubectl` `get` `pods` command returns the state of *all* pods in the active
    namespace, so once you have a lot of Deployments, this might get a bit jumbled.
    Instead, you can use a more verbose form where you pass the Pod’s label (discussed
    in section 3.2.4 ) as a selector. Here’s a complete example using the label of
    our example Deployment:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl get pods` 命令返回活动命名空间中所有 Pod 的状态，所以一旦你有很多 Deployment，这可能会变得有些混乱。相反，你可以使用更详细的形式，其中你传递
    Pod 的标签（在第 3.2.4 节中讨论过）作为选择器。以下是一个使用示例 Deployment 标签的完整示例：'
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the Pod is running, we can interact with it! To connect to our fresh Deployment
    and visit the server that we deployed before creating a public IP, we can simply
    forward a port from our local machine to the containers, like so:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Pod 运行起来，我们就可以与之交互了！为了连接到我们刚刚创建的 Deployment 并访问之前创建公共 IP 之前部署的服务器，我们可以简单地从我们的本地机器转发一个端口到容器，如下所示：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This allows you to interact with the Deployment from localhost by browsing
    to http:// localhost:8080\. As you try out the containerized application, you
    can watch the log output in a new command-line shell, like so:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你通过浏览 http://localhost:8080 来从 localhost 与 Deployment 交互。当你尝试容器化应用程序时，你可以在新的命令行外壳中查看日志输出，如下所示：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The logs command, using the `-f` (follow) parameter, will stream the logs from
    one of the Pods in the Deployment. It’s a good idea to log a statement to `stdout`
    in your own apps on startup, as was done here with “Listening on 0.0.0.0:80”,
    so that you can be assured the container really did start as expected.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-f`（跟随）参数的日志命令将从 Deployment 中的一个 Pod 流式传输日志。在你的应用程序启动时将一条语句记录到 `stdout`
    中是一个好主意，就像这里用“Listening on 0.0.0.0:80”所做的那样，这样你可以确保容器确实按照预期启动。
- en: Most actions you take in Kubernetes are not instant. Creating a Pod takes time
    to provision new compute capacity (depending on what Kubernetes platform you are
    using), download the container from the container registry, and boot your container.
    If everything goes well, you should have running containers in a couple of minutes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，你执行的大多数操作都不是瞬时的。创建一个 Pod 需要时间来配置新的计算能力（这取决于你使用的 Kubernetes 平台），从容器仓库下载容器，并启动你的容器。如果一切顺利，你应在几分钟内就有正在运行的容器。
- en: When things have succeeded, the Pods from your Deployment will report a status
    (when queried with `kubectl` `get` `pods`) of `Running`. You may see other statuses
    like `Pending` while it is waiting for capacity and `ContainerCreating` once the
    container has been scheduled to your nodes and is booting. Confusing matters is
    that sometimes a Pod can get stuck in `Pending`—it’s a bit of an ambiguous state—and
    there can be other errors. What follows is a list of common error situations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切顺利时，你的部署中的Pod将报告一个状态（使用`kubectl get pods`查询时），状态为`Running`。你可能还会看到其他状态，如`Pending`，当它在等待容量时，以及`ContainerCreating`，一旦容器被调度到你的节点并启动。令人困惑的是，有时一个Pod可能会卡在`Pending`状态——这是一个有点模糊的状态——并且可能还有其他错误。以下是一些常见的错误情况列表。
- en: 'Troubleshooting: Image pull error (ErrImagePull/ErrImagePullBackoff)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排除：镜像拉取错误（ErrImagePull/ErrImagePullBackoff）
- en: This error indicates that Kubernetes was unable to download the container image.
    This typically means that the image name was misspelled in your configuration,
    the image doesn’t exist in the image repository, or your cluster doesn’t have
    the required credentials to access the repository.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误表明Kubernetes无法下载容器镜像。这通常意味着在你的配置中镜像名称拼写错误，镜像不存在于镜像仓库中，或者你的集群没有访问仓库所需的凭据。
- en: Check the spelling of your image and verify that the image is in your repository.
    For a quick fix just to get the Deployment running, try a public container image
    like the one I’ve provided. Any fixes you make to your Deployment configuration
    can be applied using `kubectl` `apply` `-f` `deploy.yaml`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你的镜像拼写，并验证该镜像是否存储在你的仓库中。为了快速修复以使部署运行，可以尝试使用我提供的公共容器镜像。你可以使用`kubectl apply
    -f deploy.yaml`来应用你对部署配置所做的任何修复。
- en: 'Troubleshooting: Stuck in Pending'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排除：卡在挂起状态
- en: If you see a Pod stuck in the `Pending` state for more than a minute or so,
    it typically means that the Kubernetes scheduler is unable to find space on your
    cluster to deploy the Pod to. Often, this problem can be resolved by adding additional
    resources to your cluster, like an additional or larger compute node.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到一个Pod在`Pending`状态中挂起一分钟以上，通常意味着Kubernetes调度器无法在你的集群中找到空间来部署Pod。通常，这个问题可以通过向你的集群添加额外的资源来解决，比如添加一个额外的或更大的计算节点。
- en: 'You can see the details of the pending Pod by “describing” it as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式“描述”挂起的Pod来查看其详细信息：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `Events` section contains a list of any errors that Kubernetes has encountered.
    If you attempted to schedule a Deployment and no resources were available, you’ll
    see a warning like `FailedScheduling`. Here’s the event text I see for a Pod that
    I attempted to schedule but where there were not enough resources:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Events`部分包含Kubernetes遇到的所有错误列表。如果你尝试调度一个部署但没有可用资源，你会看到一个警告，例如`FailedScheduling`。以下是我看到的一个Pod尝试调度但资源不足的事件文本：'
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As long as at least one of your Pods is in the `Running` state, you don’t need
    to worry for now, as your Service should still run as long as one Pod exists to
    answer requests. However, if they are all pending, you’ll need to take action—likely
    by adding more compute resources.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 只要至少有一个你的Pod处于`Running`状态，你现在就不必担心，因为只要有一个Pod存在来响应请求，你的服务应该仍然可以运行。然而，如果它们都处于挂起状态，你可能需要采取行动——很可能是通过添加更多的计算资源。
- en: 'Troubleshooting: Crashing container (CrashLoopBackOff)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排除：容器崩溃（CrashLoopBackOff）
- en: Another common error is a crashing container. There can be various reasons for
    a crashing container, including that the container failed to start (e.g., due
    to a configuration error) or that the container crashes soon after starting.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的错误是容器崩溃。容器崩溃可能有各种原因，包括容器启动失败（例如，由于配置错误）或者容器启动后不久就崩溃。
- en: For the purposes of Kubernetes deployments, a *crash* is any container process
    that terminates—even one that terminates with a successful exit code. Deployments
    are designed for long-running processes, not once-off tasks (Kubernetes does have
    a way to represent a Pod that should be scheduled to run as a once-off task, and
    that is the Job object, covered in chapter 10).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes部署的范围内，任何终止的容器进程都算作崩溃——即使是以成功的退出代码终止的。部署是为长时间运行的过程设计的，而不是一次性任务（Kubernetes确实有一种表示应作为一次性任务调度的Pod的方法，那就是Job对象，在第10章中介绍）。
- en: The occasional crash of a container in a Deployment-managed Pod like the ones
    we are deploying here is handled gracefully by restarting it. In fact, when you
    run `kubectl` `get` `pods`, you can see how many times a container has been restarted.
    You can have a container that crashes every hour, and as far as Kubernetes is
    concerned, that’s totally fine; it will keep restarting it, and it will go on
    its merry way.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在像我们在这里部署的 Deployment 管理的 Pod 中，容器偶尔崩溃会被优雅地处理，通过重启它。实际上，当你运行 `kubectl get pods`
    时，你可以看到容器重启了多少次。你可以有一个每小时崩溃一次的容器，从 Kubernetes 的角度来看，这完全没问题；它将继续重启它，并继续其愉快的旅程。
- en: A container that crashes either instantly at boot or quickly after, however,
    is put into an exponential backoff loop, where rather than continuing to restart
    it continuously (consuming the resources of the system), Kubernetes introduces
    a delay between restart attempts that increases exponentially (i.e., 10 seconds,
    then 20 seconds, 40 seconds, and so on).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个在启动时立即崩溃或在启动后很快崩溃的容器会被放入一个指数退避循环中，在这种循环中，Kubernetes 不是持续不断地重启它（消耗系统的资源），而是在重启尝试之间引入一个指数级增加的延迟（例如，10
    秒，然后 20 秒，40 秒，以此类推）。
- en: When a container crashes the first time, it will have a status like `RunContainerError`
    (for a container that errored at start), or `Completed` for one that exited. Once
    the crash has been repeated a couple of times, the status will move to `CrashLoopBackOff`.
    The chances are, any container in the `CrashLoopBackOff` state has a problem that
    needs your attention. One possibility is that the container may exit when an external
    dependency (like a database) is not being met, in which case you should ensure
    that the external service is running and can be connected to.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器第一次崩溃时，它将有一个类似于 `RunContainerError`（对于在启动时出错的容器）的状态，或者对于退出的容器是 `Completed`。一旦崩溃重复了两次，状态将变为
    `CrashLoopBackOff`。可能性很大，任何处于 `CrashLoopBackOff` 状态的容器都存在需要你注意的问题。一种可能性是，当外部依赖（如数据库）未满足时，容器可能会退出，在这种情况下，你应该确保外部服务正在运行并且可以连接到。
- en: 'To debug crashed containers, I always start with `kubectl` `describe` `pod`
    `$POD_NAME` like the earlier problems to view the events for clues there. The
    container’s logs are another good place to check. You can retrieve these with
    `kubectl` `logs` `$POD_NAME`. When dealing with crashing containers, you may wish
    to view the logs from the *prior* instantiation of the container (before it was
    restarted after crashing) to see any error printed when it crashed, as this often
    will indicate the cause. To do that, add `--previous` (or just `-p`) to your log
    request:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试崩溃的容器，我总是从像早期问题中那样使用 `kubectl describe pod $POD_NAME` 开始，查看那里的事件以获取线索。容器的日志也是另一个很好的检查点。你可以使用
    `kubectl logs $POD_NAME` 来检索这些日志。在处理崩溃的容器时，你可能希望查看容器在 *之前* 实例化时的日志（在崩溃后重启之前），以查看崩溃时打印的任何错误，因为这通常将指示原因。为此，将
    `--previous`（或仅 `-p`）添加到你的日志请求中：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 3.2.4 The PodSpec
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.4 PodSpec
- en: It’s worth taking a moment to understand how the Deployment object is composed
    since it actually encapsulates a Pod object, which has its own specification.
    You will see this pattern repeated with other higher-order workload types in Kubernetes
    like Job. It’s also relevant because the way that we expose the Deployment in
    a Service is actually by referencing the Pods, not the Deployment.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 值得花点时间理解 Deployment 对象是如何组成的，因为它实际上封装了一个具有自己规范的 Pod 对象。你将在 Kubernetes 中其他更高阶的工作负载类型（如
    Job）中看到这种模式的重复。这也很重要，因为我们通过引用 Pod 而不是 Deployment 来公开 Deployment。
- en: When you create a Deployment of three replicas, in actuality, you are instructing
    the Kubernetes Deployment controller to create and manage three Pods. The Deployment
    controller manages the lifecycle of these pods, including replacing them with
    newer versions when you update the Deployment with a new container and rescheduling
    Pods that get evicted due to planned or unplanned maintenance events. Figure 3.10
    has a visual breakdown of this object composition.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个包含三个副本的 Deployment 时，实际上你是在指示 Kubernetes Deployment 控制器创建和管理三个 Pod。Deployment
    控制器管理这些 Pod 的生命周期，包括当你使用新的容器更新 Deployment 时用新版本替换它们，以及重新安排因计划内或计划外维护事件而被驱逐的 Pod。图
    3.10 展示了此对象组成的视觉分解。
- en: '![03-10](../../OEBPS/Images/03-10.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![03-10](../../OEBPS/Images/03-10.png)'
- en: Figure 3.10 Pod object embedded in the Deployment object
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 Pod 对象嵌入在 Deployment 对象中
- en: The Pod object template is referred to in the Kubernetes API documentation as
    the PodSpec. You can actually yank it out and run it by itself. To do so, you’ll
    need to provide a header specifying that this object is of kind Pod rather than
    a Deployment; then, you can copy the entire YAML under `template` into the root
    of the config, as shown in the following listing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 文档中将 Pod 对象模板称为 PodSpec。实际上，您可以将其提取出来单独运行。为此，您需要提供一个标题，指定此对象是
    Pod 类型而不是 Deployment 类型；然后，您可以将 `template` 下的整个 YAML 复制到配置的根目录中，如下面的列表所示。
- en: Listing 3.2 Chapter03/3.2.4_ThePodSpec/pod.yaml
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 第 3 章/3.2.4_ThePodSpec/pod.yaml
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can go ahead and create this Pod directly. Such pods are unmanaged by any
    Kubernetes controller. They will be rebooted if they crash, but if they are evicted
    due to causes such as an upgrade event or node failure, they won’t be rescheduled.
    That’s why typically you won’t schedule the Pod directly but rather use a higher-order
    object like a Deployment or, as we’ll see in the later chapters, StatefulSet,
    Job, and others.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接创建这个 Pod。这样的 Pod 不会被任何 Kubernetes 控制器管理。如果它们崩溃，将会重启，但如果由于升级事件或节点故障等原因被驱逐，它们将不会被重新调度。这就是为什么通常您不会直接调度
    Pod，而是使用更高阶的对象，如 Deployment，或者，正如我们将在后面的章节中看到的，StatefulSet、Job 以及其他。
- en: NOTE One of the key takeaways of this object composition in Kubernetes is that
    every time you see a PodSpec in an object like a Deployment, know that it carries
    all the capabilities of a Pod. That means you can look at the documentation for
    Pod and use any of the values within the Pod template of the managed object.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Kubernetes 中这种对象组合的关键要点之一是，每次您在 Deployment 等对象中看到 PodSpec 时，都知道它携带了 Pod 的所有功能。这意味着您可以查看
    Pod 的文档，并使用管理对象 Pod 模板中的任何值。
- en: 'The PodSpec includes key information about your application, including the
    container or containers that comprise it. Each of these containers has its own
    name (so you can reference the individual containers in a multicontainer Pod),
    as well as the most important field: the container image path. There are a lot
    of optional fields as well, including some important ones to specify health checks
    and resource requirements, which are covered in the coming chapters.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: PodSpec 包含了关于您应用程序的关键信息，包括构成它的容器或容器。这些容器中的每一个都有自己的名称（因此您可以在多容器 Pod 中引用单个容器），以及最重要的字段：容器镜像路径。还有许多可选字段，包括一些重要的字段来指定健康检查和资源需求，这些内容将在接下来的章节中介绍。
- en: There are also some seemingly repetitive labels in the Deployment and its embedded
    PodSpec. The Deployment’s spec has a `selector` `→` `matchLabels` section, and
    the PodSpec has a `metadata` `→` `labels` section, both containing the same key-value
    pair `pod:` `timeserver-pod`. So, what’s going on here?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Deployment 及其嵌入的 PodSpec 中也有一些看似重复的标签。Deployment 的规范有一个 `selector` `→` `matchLabels`
    部分，PodSpec 有一个 `metadata` `→` `labels` 部分，两者都包含相同的键值对 `pod:` `timeserver-pod`。那么这里发生了什么？
- en: Well, since the Pod object actually exists somewhat separately after creation
    (it is created as a separate object that is managed by the Deployment controller),
    we need a way to reference it. Kubernetes solves this by requiring that the Pod
    has a label (which is an arbitrary key-value pair), and that we reference (select)
    that same label from the Deployment. This is essentially the glue that binds the
    two objects together. It’s easier to visualize in a diagram, as shown in figure
    3.11.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，由于 Pod 对象在创建后实际上存在某种程度的独立性（它被创建为一个由 Deployment 控制器管理的独立对象），我们需要一种方式来引用它。Kubernetes
    通过要求 Pod 有一个标签（这是一个任意的键值对），并且从 Deployment 中引用（选择）相同的标签来解决此问题。这实际上是绑定两个对象的粘合剂。如图
    3.11 所示，在图表中更容易可视化。
- en: '![03-11](../../OEBPS/Images/03-11.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![03-11](../../OEBPS/Images/03-11.png)'
- en: Figure 3.11 Relationship of the Deployment’s selector and the Pod template’s
    labels
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 部署的选择器和 Pod 模板标签之间的关系
- en: 'This process may seem unnecessary, after all: can’t Kubernetes do this object
    linking for us since the PodSpec is embedded in the Deployment? The reason you
    need to specify these labels manually is that they play an important role when
    referencing Pods directly in other objects. For example, in the next section,
    in which we configure a network Service, it references the Pods of the Deployment
    directly, not the Deployment itself. The same is true for other concepts covered
    later in the book, such as a Pod Disruption Budget (PDB). By specifying the label
    for your Pods, you will know what label to reference in these other objects. The
    Pod is the fundamental execution and scheduling unit in Kubernetes, and the Deployment
    is just one of many ways to create, manage, and interact with Pods.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可能看起来是不必要的：既然 PodSpec 已经嵌入到 Deployment 中，Kubernetes 不能为我们做这个对象链接吗？你需要手动指定这些标签的原因是，它们在直接在其他对象中引用
    Pods 时扮演着重要的角色。例如，在下一节中，当我们配置网络服务时，它直接引用了 Deployment 的 Pods，而不是 Deployment 本身。书中稍后讨论的其他概念也是如此，例如
    Pod 故障预算（PDB）。通过指定你的 Pod 标签，你将知道在这些其他对象中应该引用哪个标签。Pod 是 Kubernetes 中的基本执行和调度单元，而
    Deployment 只是创建、管理和与 Pods 交互的多种方式之一。
- en: As for the key-value label itself, it’s completely arbitrary. You can use `foo:`
    `bar` for all Kubernetes cares. I used `pod:` `timeserver-pod`, as I find it reads
    well when selecting Pods in other objects. A lot of documentation uses something
    like `app:` `timeserver`. I have avoided repeating the name of the Deployment
    (`timeserver`) as the value of this label to avoid the misconception that the
    name of the Deployment has anything to do with the Pod label (since it doesn’t).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于键值标签本身，它是完全任意的。你可以使用 `foo:` `bar` 对 Kubernetes 来说都一样。我使用了 `pod:` `timeserver-pod`，因为我发现当在其它对象中选择
    Pods 时，这样读起来很好。很多文档都使用类似 `app:` `timeserver` 的格式。我避免重复使用 Deployment (`timeserver`)
    的名称作为标签的值，以避免产生误解，即 Deployment 的名称与 Pod 标签有任何关联（因为实际上没有）。
- en: So, that’s how the Deployment object is constructed with an embedded PodSpec.
    I hope it’s useful to understand this object composition and how the Pod is referenced.
    In the next section, we’ll expose this Deployment to the world, which will reference
    the Pod by its labels.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是使用嵌入 PodSpec 的方式构建 Deployment 对象。我希望这有助于理解对象组合以及 Pod 的引用方式。在下一节中，我们将向世界展示这个
    Deployment，它将通过标签引用 Pod。
- en: 3.2.5 Publishing your Service
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.5 发布你的服务
- en: With your container successfully deployed, no doubt you’ll want to interact
    with it! Each Pod is given its own cluster-local (internal) IP address, which
    can be used for communication between Pods within the cluster. It’s possible to
    expose Pods directly on the internet as well as on the node’s IP (with the field
    `hostPort`), but unless you’re writing a real-time game server, that’s rarely
    what you’ll do. Typically, and especially when Deployment is used, you will aggregate
    your Pods into a Service, which provides a single access point with an internal
    (and optionally external) IP, and load balance requests across your pods. Even
    if you had a Deployment of a single Pod, you’ll still want to create a Service
    to provide a stable address.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的容器成功部署后，毫无疑问你将想要与之交互！每个 Pod 都会被分配一个自己的集群本地（内部）IP 地址，这可以用于集群内 Pods 之间的通信。你也可以直接在互联网上以及节点的
    IP 地址上（使用 `hostPort` 字段）公开 Pods，但除非你正在编写实时游戏服务器，否则这很少是你要做的事情。通常情况下，尤其是在使用 Deployment
    时，你将把你的 Pods 聚合成一个服务，该服务提供一个单一的访问点，具有内部（和可选的）IP，并在你的 Pods 之间进行负载均衡。即使你只有一个 Pod
    的 Deployment，你仍然需要创建一个服务来提供一个稳定的地址。
- en: In addition to load balancing, Services keep track of which Pods are running
    and capable of receiving traffic. For example, while you may have specified three
    replicas in your Deployment, that doesn’t mean that three replicas will be available
    at all times. There might only be two if a node is being upgraded, or there could
    be more than three while you’re rolling out a new version of your Deployment.
    The Service will only route traffic to running Pods (in the next chapter, we’ll
    cover some key information you need to provide to make that works smoothly).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除了负载均衡之外，服务还跟踪哪些 Pods 正在运行并且能够接收流量。例如，虽然你可能已经在你的 Deployment 中指定了三个副本，但这并不意味着三个副本将始终可用。如果节点正在升级，可能只有两个副本，或者在你部署
    Deployment 的新版本时，可能会有超过三个副本。服务只会将流量路由到正在运行的 Pods（在下一章中，我们将介绍一些关键信息，你需要提供这些信息以确保其顺利工作）。
- en: Services are used internally within the cluster to enable communication between
    multiple applications (a so-called microservice architecture) and offer convenient
    features, such as service discovery, for this purpose. This topic is covered in
    detail in chapter 7\. For now, let’s focus on using a Service and expose your
    new application to the internet by specifying a `LoadBalancer`-type Service to
    get it in the hands of end-users. As with the Deployment, we’ll start with a YAML
    configuration.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 服务在集群内部使用，用于实现多个应用程序（所谓的微服务架构）之间的通信，并为此提供方便的功能，如服务发现。这个主题在第7章中详细讨论。现在，让我们专注于使用服务，并通过指定一个`LoadBalancer`类型的服务将你的新应用程序暴露给互联网，以便最终用户可以使用它。与Deployment一样，我们将从YAML配置开始。
- en: Listing 3.3 Chapter03/3.2_DeployingToKubernetes/service.yaml
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 第3章/3.2_Kubernetes部署/service.yaml
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Traffic will be routed to Pods that have this label.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 流量将被路由到具有此标签的Pod
- en: ❷ The port the Service will be exposed on
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 服务将公开的端口
- en: ❸ The container’s destination port that traffic will be forwarded to
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 容器的目标端口，流量将被转发到该端口
- en: ❹ The network protocol
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 网络协议
- en: ❺ Type of Service; in this case, an external load balancer
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 服务类型；在这种情况下，是外部负载均衡器
- en: The port list allows you to configure which port to expose for users of the
    Service (`port`) and which port of the Pod that this traffic will be sent to (`targetPort`).
    This allows you to, say, expose a service on port 80 (the default HTTP port) and
    connect it to an application in a container running on port 8080.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 端口列表允许你配置为服务用户公开哪个端口（`port`）以及将流量发送到的Pod的哪个端口（`targetPort`）。这允许你，比如说，在端口80（默认的HTTP端口）上公开一个服务，并将其连接到运行在端口8080的应用程序。
- en: Each Pod and Service in Kubernetes has its own internal cluster IP, so you don’t
    need to worry about port conflicts between Pods. Thus, you can run your application
    on whatever port you like (such as port 80 for an HTTP service) and use the same
    number for `port` and `targetPort` for simplicity, as with the previous example.
    If you do this, you can omit `targetPort` completely, as the default is to use
    the `port` value.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的每个Pod和服务都有自己的内部集群IP，因此你不需要担心Pod之间的端口冲突。因此，你可以将你的应用程序运行在任何你喜欢的端口上（例如HTTP服务的端口80），并且为了简单起见，可以将`port`和`targetPort`设置为相同的数字，就像上一个示例中那样。如果你这样做，你可以完全省略`targetPort`，因为默认情况下会使用`port`值。
- en: All Services (other than headless Services, covered in Chapter 9) are given
    an internal, cluster-local IP address that Pods in the cluster can use. If you
    specify `type:` `LoadBalancer` as in the previous example, an external IP address
    will be provisioned in addition.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 所有服务（除了在第9章中提到的无头服务）都会分配一个内部、集群本地的IP地址，集群中的Pod可以使用这个IP地址。如果你像上一个示例中那样指定`type:`
    `LoadBalancer`，那么还会额外分配一个外部IP地址。
- en: Notice also that this Service has a section named `selector`, like our Deployment
    had. The Service doesn’t reference the Deployment and actually has no knowledge
    of the Deployment. Instead, it references the set of Pods that have the given
    label (which, in this case, will be the Pods created by our Deployment). Once
    again, it’s easier to visualize, as in figure 3.12.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个服务有一个名为`selector`的部分，就像我们的Deployment一样。服务并不引用Deployment，实际上对Deployment一无所知。相反，它引用了具有给定标签的Pod集合（在这种情况下，将是我们的Deployment创建的Pod）。再次强调，如图3.12所示，这更容易可视化。
- en: '![03-12](../../OEBPS/Images/03-12.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![03-12](../../OEBPS/Images/03-12.png)'
- en: Figure 3.12 Relationship between the Service and the Pods it targets (selects)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 服务与其目标Pod（选择器）之间的关系
- en: 'Unlike in the Deployment object, the `selector` section has no `matchLabels`
    subsection. They are, however, equivalent. Deployment is just using a newer, more
    expressive syntax in Kubernetes. The selectors in the Deployment and in the Service
    are achieving the same result: specifying the set of Pods that the object is referencing.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与Deployment对象不同，`selector`部分没有`matchLabels`子部分。然而，它们是等效的。Deployment只是在Kubernetes中使用了一种更新、更易于表达的语法。Deployment和Service中的选择器达到了相同的结果：指定对象引用的Pod集合。
- en: Create the Service object on your cluster with
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在你的集群上创建服务对象
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Notice how the creation command (`kubectl` `create`) is the same for the Deployment
    as the Service. All Kubernetes objects can be created, read, updated, and deleted
    (so-called CRUD operations) with four `kubectl` commands: `kubectl` `create`,
    `kubectl` `get`, `kubectl` `apply`, and `kubectl` `delete`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，创建命令（`kubectl create`）对于Deployment和服务是相同的。所有Kubernetes对象都可以使用四个`kubectl`命令进行创建、读取、更新和删除（所谓的CRUD操作）：`kubectl
    create`、`kubectl get`、`kubectl apply`和`kubectl delete`。
- en: 'To see the status of your Service, you can call `kubectl` `get` on the object
    type, like so:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看服务状态，你可以调用`kubectl get`命令来获取对象类型，如下所示：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that your Service is listed there (in this example, `timeserver`), as
    well as another Service named `kubernetes`. You can ignore the `kubernetes` Service
    if one is shown, as that’s the Kubernetes API service itself running in your cluster.
    You can also specify just the Service you’re interested in with `kubectl` `get`
    `service` `$SERVICE_NAME`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你的服务在那里列出（在这个例子中是`timeserver`），以及另一个名为`kubernetes`的服务。如果显示`kubernetes`服务，你可以忽略它，因为那是运行在你集群中的Kubernetes
    API服务本身。你也可以使用`kubectl get service $SERVICE_NAME`来指定你感兴趣的服务。
- en: If the `External` `IP` in the output indicates `Pending`, it just means the
    external IP is waiting for the load balancer to come online. It’s common for this
    to take a minute or two, so no need to rush to debug why it’s pending unless it’s
    been that way for a while. Rather than repeating the previous `get` command repeatedly,
    you can stream any changes to the status by adding the `--watch/-w` flag (i.e.,
    `kubectl` `get` `service` `-w`). Run that command, and within a couple of minutes,
    you should see output indicating that your Service now has an external IP.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出中的`External IP`显示为`Pending`，这仅仅意味着外部IP正在等待负载均衡器上线。这种情况通常需要一两分钟，所以除非已经这样了一段时间，否则无需急于调试为什么它处于挂起状态。与其反复重复之前的`get`命令，不如通过添加`--watch/-w`标志（即`kubectl
    get service -w`）来流式传输任何状态变化。运行该命令，几分钟后，你应该会看到输出指示你的服务现在有一个外部IP。
- en: Note To have an external IP provisioned, you must be running Kubernetes on a
    cloud provider, as the provider is provisioning an externally routable network
    load balancer behind the scenes. If you’re developing locally, see section 3.4.3
    on how to connect using tools like `kubectl` `port-forward`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要分配外部IP，你必须在一个云提供商上运行Kubernetes，因为提供商在幕后提供可外部路由的网络负载均衡器。如果你在本地开发，请参阅第3.4.3节了解如何使用`kubectl
    port-forward`等工具连接。
- en: 'Once the IP comes online, try accessing the Service by visiting the URL. Based
    on the preceding example output, this would mean visiting `http://203.0.113.16`
    (but replace it with your own external IP from `kubectl` `get` `service!`). The
    `curl` tool is great for testing HTTP requests from the command line (`curl` `http://203.0.113.16`);
    viewing it in a browser works just as well, too:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦IP上线，尝试通过访问URL来访问服务。根据前面的示例输出，这意味着访问`http://203.0.113.16`（但用`kubectl get service`获取的你的自己的外部IP替换它）。`curl`工具非常适合从命令行测试HTTP请求（`curl
    http://203.0.113.16`）；在浏览器中查看效果一样好：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Troubleshooting: Unable to connect'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排除：无法连接
- en: Two common reasons for an `Unable` `to` `Connect` error are (1) the selector
    is incorrect and (2) your ports are wrong. Triple-check that the selector matches
    the labels in your Deployment’s Pod template. Verify that the target port is,
    indeed, the port your container is listening on (a boot-time debug message in
    the container printing the port can be a good way to help verify this) and that
    you’re connecting to the right port from your browser.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 导致“无法连接”错误的两个常见原因是（1）选择器不正确和（2）你的端口设置错误。请三倍检查选择器是否与你的部署Pod模板中的标签匹配。验证目标端口确实是你容器监听的端口（容器启动时的调试信息中打印的端口可以是一个帮助验证的好方法），并且你正在从浏览器连接到正确的端口。
- en: See whether you can connect to one of your Pods directly on the `targetPort`
    using `kubectl`’s port-forwarding capability. If you can’t connect to the Pod
    directly, then the problem is likely with the Pod. If it does work, the problem
    could be an incorrect Service definition. You can set up a port forward to one
    of the Pods in the Deployment with
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你是否可以直接通过`kubectl`的端口转发功能连接到你的Pod的`targetPort`。如果你无法直接连接到Pod，那么问题可能就出在Pod本身。如果连接成功，问题可能是服务定义不正确。你可以通过以下命令设置端口转发到部署中的某个Pod：
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: where `$FROM_PORT` is the port you’ll use locally, and `$TO_PORT` is the `targetPort`
    that you defined in your Service. Using our example earlier, this would be
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`$FROM_PORT`是你将使用的本地端口，`$TO_PORT`是你服务中定义的`targetPort`。使用我们之前的例子，这将是这样：
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Then browse to http://localhost:8080. This will select one of the Pods in the
    Deployment automatically (bypassing the Service). You can also specify a specific
    Pod to connect to directly with
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，浏览到http://localhost:8080。这将自动选择部署中的一个Pod（绕过服务）。你也可以直接指定要连接的特定Pod：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Troubleshooting: External IP stuck in pending'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排除：外部IP挂起
- en: It can take a little while to get an external IP, so give it a few minutes.
    Verify that your cloud provider will provision external IPs for Services of type
    `LoadBalanacer`. Check the provider’s documentation for any additional information
    about setting up load balancers in Kubernetes.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 获取外部IP可能需要一点时间，所以请给它几分钟。验证您的云提供商是否会为类型为 `LoadBalanacer` 的服务提供外部IP。请查阅提供商的文档以获取有关在Kubernetes中设置负载均衡器的任何附加信息。
- en: 'If you’re running locally or just want to try out the Service without waiting
    for the external IP, you can forward a port on your machine to the Service, like
    so:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在本地运行或只想尝试服务而不等待外部IP，您可以将您的机器上的端口转发到服务，如下所示：
- en: '[PRE34]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 3.2.6 Interacting with the Deployment
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.6 与部署交互
- en: During development, it’s convenient to be able to interact with the container
    to run commands or copy files back and forth. Fortunately, Kubernetes makes this
    about as easy as Docker does.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，能够与容器交互以运行命令或复制文件来来回去是非常方便的。幸运的是，Kubernetes使这几乎与Docker一样简单。
- en: Running one-off commands
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一次性命令
- en: Just as we can run one-off commands on the Docker image using the `docker` `exec`
    command (covered in chapter 2), we can also run one-off commands on our Pods with
    `kubectl` `exec`. A common command used to diagnose problems in the container
    is `sh`, which will give you an interactive shell on the container (provided that
    `sh` is available in the container). From there, you can perform whatever other
    debugging steps you need to do inside the container.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以在Docker镜像上使用 `docker` `exec` 命令（在第2章中介绍）运行一次性命令一样，我们也可以使用 `kubectl` `exec`
    在我们的Pod上运行一次性命令。用于诊断容器问题的常见命令是 `sh`，它将在容器上提供一个交互式shell（假设容器中提供了 `sh`）。从那里，您可以执行您需要在容器内进行的任何其他调试步骤。
- en: 'Technically, `exec` is run against a Pod, but we can specify the Deployment
    instead of a specific Pod, and `kubectl` will select one Pod at random to run
    the command on:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，`exec` 是针对Pod运行的，但我们可以指定Deployment而不是特定的Pod，`kubectl` 将随机选择一个Pod来运行该命令：
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can run any command on the container in this way, for example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这种方式在容器上运行任何命令，例如：
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Copying files to/from the container
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件复制到/从容器
- en: 'Again, similar to Docker, `kubectl` has a `cp` command allowing you to copy
    files between your system and the container. This command requires that the `tar`
    binary be present in your container image. This can be useful when you want to
    download your application logs or other diagnostic information. The default path
    is the container’s working directory, so if you have a file in the container named
    “example.txt” you could copy it to your machine like so:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，类似于Docker，`kubectl` 有一个 `cp` 命令允许您在您的系统和容器之间复制文件。此命令要求您的容器镜像中存在 `tar` 二进制文件。这可以在您想要下载应用程序日志或其他诊断信息时很有用。默认路径是容器的当前工作目录，所以如果您在容器中有一个名为“example.txt”的文件，您可以将它复制到您的机器上，如下所示：
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can also copy files in the other direction:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在相反方向复制文件：
- en: '[PRE38]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 3.2.7 Updating your application
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.7 更新您的应用程序
- en: Now that your application has been deployed and published to the world, no doubt
    you’ll want to be able to update it. Make a code change to the sample app and
    then build and push the container image to the container repository with a new
    version tag. For example, if you previously used `us-docker.pkg.dev/wdenniss/ts/timeserver:1`,
    your new image could be `us-docker.pkg.dev/wdenniss/ts/timeserver:2`. You can
    make this tag anything you like, but it’s a good convention to use version numbers.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的应用程序已经部署并发布到全世界，毫无疑问您会想要能够更新它。对示例应用程序进行代码更改，然后使用新的版本标签构建并推送容器镜像到容器仓库。例如，如果您之前使用的是
    `us-docker.pkg.dev/wdenniss/ts/timeserver:1`，您的新镜像可以是 `us-docker.pkg.dev/wdenniss/ts/timeserver:2`。您可以随意命名这个标签，但使用版本号是一个好习惯。
- en: 'Once the container image has been pushed to the repository (as we did in section
    3.2.2), update the `deploy.yaml` file from listing 3.1 with the new image name—for
    example (emphasis added):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦容器镜像已推送到仓库（如我们在3.2.2节中所做的那样），使用列表3.1中的新镜像名称更新 `deploy.yaml` 文件——例如（强调部分）：
- en: Listing 3.4 Chapter03/3.2.7_Updating/deploy.yaml
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 第3章/3.2.7_更新/deploy.yaml
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ New image version
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 新镜像版本
- en: Save the file and apply the change to your cluster with
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并使用以下命令将更改应用到您的集群中
- en: '[PRE40]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When you apply this change, an interesting thing happens. Remember how Kubernetes
    constantly seeks to actuate your requirements, driving the state it observes in
    the system to the state you require? Well, since you just declared that the Deployment
    is now using the image with the version tag `2` and all the Pods are currently
    tagged `1`, Kubernetes will seek to update the live state so that all Pods are
    the current version.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当你应用这个更改时，会发生一些有趣的事情。还记得 Kubernetes 如何不断寻求执行你的要求，将系统观察到的状态驱动到你所需要的状态吗？好吧，既然你刚刚声明部署现在正在使用版本标签为
    `2` 的镜像，并且所有 Pod 当前都标记为 `1`，Kubernetes 将寻求更新实时状态，以便所有 Pod 都是当前版本。
- en: 'We can see this in action by running `kubectl` `get` `deploy`. Here’s some
    example output:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行 `kubectl get deploy` 来看到这个功能的具体实现。以下是一些示例输出：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `READY` column shows how many Pods are serving traffic and how many we requested.
    In this case, all three are ready. The `UP-TO-DATE` column, however, indicates
    that only one of these Pods is the current version. This is because, rather than
    replacing all the Pods at once, causing some downtime to the application, by default,
    Pods are updated with a so-called rolling update strategy—that is, one or several
    at a time.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`READY` 列显示有多少 Pod 在处理流量以及我们请求了多少个。在这种情况下，所有三个都准备好了。然而，`UP-TO-DATE` 列却表明，这些
    Pod 中只有一个处于当前版本。这是因为，为了避免一次性替换所有 Pod 导致应用程序出现停机时间，默认情况下，Pod 会通过所谓的滚动更新策略进行更新——即一次更新一个或几个。'
- en: Rolling updates and other rollout strategies are covered in detail in the next
    chapter, as well as important health checks that need to be configured to avoid
    glitches during the rollout. For now, it’s enough to know that Kubernetes will
    actuate your changes and will replace the old v1 Pods with the new v2 Pods.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动更新和其他部署策略将在下一章中详细说明，以及需要配置的重要健康检查，以避免在部署过程中出现故障。目前，只需知道 Kubernetes 将执行你的更改，并将旧的
    v1 Pods 替换为新的 v2 Pods。
- en: Once the `UP-TO-DATE` count is equal to the `READY` count, the rollout is complete.
    You can also observe the individual Pods being created and replaced with `kubectl`
    `get` `pods`, which will show a list of all Pods in the Deployment, both new and
    old.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `UP-TO-DATE` 的数量等于 `READY` 的数量，部署就完成了。你还可以通过 `kubectl get pods` 来观察正在创建和替换的各个
    Pod，这将显示部署中所有 Pod 的列表，包括新的和旧的。
- en: Monitoring the rollout
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 监视部署
- en: Since the output of the `kubectl` `get` commands displays the moment-in-time
    information, but the Deployment is continuously changing, most operators will
    monitor the Deployment in an automated way, avoiding the need to constantly rerun
    the same command. Kubernetes includes one such option, the `--watch/-w` flag,
    which can be added to most `kubectl` commands, such as `kubectl` `get` `pods`
    `-w` and `kubectl` `get` `deploy` `-w.` When `watch` is specified, any changes
    to the status will be streamed to the console output.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `kubectl get` 命令的输出显示的是瞬时的信息，但部署是持续变化的，大多数操作员都会以自动化的方式监视部署，避免需要不断重新运行相同的命令。Kubernetes
    包含一个这样的选项，即 `--watch/-w` 标志，它可以添加到大多数 `kubectl` 命令中，例如 `kubectl get pods -w` 和
    `kubectl get deploy -w`。当指定了 `watch` 时，任何状态的变化都会流式传输到控制台输出。
- en: The disadvantage of the `watch` flag is that it kind of jumbles the output.
    If you have many Pods changing, you’ll see line after line printed, and it’s easy
    to lose sight of the current state of the system. My preference is to use the
    Linux `watch` command instead. Unlike the `watch` flag, the `watch` command refreshes
    the entire output, optionally showing you what changed between the current and
    the last update. This command is available in most Linux distros, macOS, and the
    Windows Subsystem for Linux (WSL) and can be found wherever you get your packages.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`watch` 标志的缺点是它有点混乱输出。如果你有很多 Pod 发生变化，你会看到一行行打印出来，很容易失去对系统当前状态的视线。我的偏好是使用 Linux
    的 `watch` 命令。与 `watch` 标志不同，`watch` 命令会刷新整个输出，可选地显示当前更新和上次更新之间的更改。这个命令在大多数 Linux
    发行版、macOS 和 Windows Subsystem for Linux (WSL) 中都可用，可以在你获取软件包的地方找到。'
- en: When `watch` is installed, you can simply prepend it to any `kubectl` command,
    such as
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装了 `watch` 之后，你只需将其添加到任何 `kubectl` 命令之前，例如
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'My favorite `watch` flag is `-d`, which will highlight any changes:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的 `watch` 标志是 `-d`，它将突出显示任何更改：
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With a terminal window (or tmux session window) opened for watching each command,
    you can put together a real-time status dashboard with just `watch` and `kubectl`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开一个用于监视每个命令的终端窗口（或 tmux 会话窗口）的情况下，你可以仅使用 `watch` 和 `kubectl` 组装一个实时状态仪表板。
- en: Watching the Deployment
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 监视部署
- en: 'The previously discussed `kubectl` `get` `deploy` and `kubectl` `get` `pods`
    commands return all Deployments and Pods, respectively, in the current namespace.
    As you make more Deployments, you may want to specify just the resources you’re
    interested in:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 之前讨论的`kubectl get deploy`和`kubectl get pods`命令分别返回当前命名空间中的所有Deployment和Pod。随着你创建更多的Deployment，你可能只想指定你感兴趣的资源：
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The name of the object can be found in the `name` field in the metadata section
    at the top of the file. Viewing all pods from a single Deployment is a little
    more tricky; however, you can use the label selector to get the status of a set
    of Pods with
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的名称可以在文件顶部的元数据部分的`name`字段中找到。从单个Deployment中查看所有Pod可能有点棘手；然而，你可以使用标签选择器来获取一组Pod的状态
- en: '[PRE45]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: where `pod=timeserver-pod` is the label selector specified in the Deployment.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`pod=timeserver-pod`是在Deployment中指定的标签选择器。
- en: 3.2.8 Cleaning up
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.8 清理
- en: 'There are a number of ways to clean up the objects we’ve created. You can delete
    by object type and name:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 清理我们创建的对象有几种方法。你可以按对象类型和名称进行删除：
- en: '[PRE46]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: NOTE You don’t need to delete Pods that are managed by another object like Deployment,
    only those you created manually. Deleting the Deployment will automatically delete
    all the Pods it manages.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你不需要删除由其他对象（如Deployment）管理的Pod，只需删除你手动创建的Pod。删除Deployment将自动删除它所管理的所有Pod。
- en: 'Or, you can delete objects by referencing individual configuration files or
    a directory of configuration files:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过引用单个配置文件或配置文件目录来删除对象：
- en: '[PRE47]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If, after deleting, you change your mind, you can simply create them again
    (e.g., `kubectl` `create` `-f` `3.2_DeployingToKubernetes`). That’s the beauty
    of capturing your configuration in files: you don’t need to remember any tweaks
    you made to the live state because everything is updated first in the configuration.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你删除后改变了主意，你可以简单地再次创建它们（例如，`kubectl create -f 3.2_DeployingToKubernetes`）。这就是捕获你的配置在文件中的美妙之处：你不需要记住你对实时状态所做的任何调整，因为一切首先都在配置中更新。
- en: The cluster itself often carries a charge, so once you’re done for the day,
    you can consider deleting it as well. This can be done using the UI console for
    most cloud providers. If you’re using GKE with the command line, you can run `gcloud`
    `container` `clusters` `delete` `$CLUSTER_NAME` `--region` `$REGION`. Even without
    any Pods or Services running in the cluster, nodes themselves typically carry
    charges (unless you’re using a platform like GKE Autopilot) but deleting the cluster
    should clean them up as well. If you’re keeping the cluster and are using a platform
    that bills for nodes, pay attention to your node resources in addition to your
    Kubernetes objects, so you only have what you need.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 集群本身通常会产生费用，所以一旦你一天的工作完成，你也可以考虑将其删除。这可以通过大多数云提供商的UI控制台完成。如果你使用GKE并通过命令行，你可以运行`gcloud
    container clusters delete $CLUSTER_NAME --region $REGION`。即使集群中没有运行任何Pod或Service，节点本身通常也会产生费用（除非你使用像GKE
    Autopilot这样的平台），但删除集群应该也会清理它们。如果你保留集群并且使用按节点计费的平台，除了你的Kubernetes对象外，还要注意你的节点资源，这样你只有你需要的东西。
- en: TIP The rest of the book will assume you know how to delete resources you don’t
    want to keep around. As you try out the examples in this book (and elsewhere),
    keep these steps in mind and be sure to delete any objects you created and no
    longer need to free up resources and reduce your bill!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：本书的其余部分将假设你知道如何删除你不想保留的资源。当你尝试本书（以及其他地方）的示例时，请记住这些步骤，并确保删除你创建的任何不再需要的对象，以释放资源并减少你的账单！
- en: 3.3 Imperative commands
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 命令式命令
- en: 'Kubernetes offers two approaches for interacting with the system: declaratively,
    where you specify (declare) in configuration files the state that you want and
    apply those configurations to the cluster, and imperatively, where you instruct
    the API one command (imperative) at a time to perform your wishes. The configuration-driven
    declarative model is the approach that is strongly preferred by most practitioners
    (including myself) and is what you’ll most often encounter in a workplace.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了两种与系统交互的方法：声明式，其中你在配置文件中指定（声明）你想要的状态，并将这些配置应用到集群中；以及命令式，其中你一次指令API一个命令（命令式）来执行你的愿望。配置驱动的声明式模型是大多数从业者（包括我自己）强烈首选的方法，也是你将在工作场所最常遇到的方法。
- en: 'In fact, it’s possible to create a Deployment with our container and expose
    it to the internet using purely imperative commands. For completeness, here’s
    how you would do that (provided the previous example was deleted following the
    cleanup steps in section 3.2.8):'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，可以使用我们的容器创建 Deployment 并仅使用命令式命令将其暴露到互联网上。为了完整性，以下是这样做的方法（假设在3.2.8节中清理步骤之后删除了前面的示例）：
- en: 'Create the Deployment:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 Deployment：
- en: '[PRE48]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a Service of type `LoadBalancer` on Port 80 to expose this Service:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在端口 80 上创建一个类型为 `LoadBalancer` 的服务以暴露此服务：
- en: '[PRE49]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Observe the result:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察结果：
- en: '[PRE50]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Update the container in the Deployment with a new version:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 Deployment 中的容器为新版本：
- en: '[PRE51]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This option may look simpler at first brush when compared to controlling Kubernetes
    using configuration files that are, frankly, a little verbose at times. However,
    there are good reasons to prefer the configuration-based approach. The first is
    reproducibility. Let’s say you need to reproduce the configuration on another
    environment, like production and staging, which is a pretty common use case. With
    the declarative approach, you can just apply the same exact config in the new
    environment (with any needed tweaks). If you went the imperative route, you would
    need to remember the commands, perhaps storing them in a bash script.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用有时略显冗长的配置文件控制 Kubernetes 相比，这种选项乍一看可能看起来更简单。然而，有很好的理由选择基于配置的方法。第一个原因是可重复性。假设你需要在其他环境中重现配置，比如生产环境和预发布环境，这是一个相当常见的用例。使用声明式方法，你只需在新环境中应用完全相同的配置（进行任何必要的调整）。如果你选择了命令式路线，你需要记住命令，可能将它们存储在
    bash 脚本中。
- en: 'It’s also harder to make changes. With configuration files, if you need to
    change a setting, you can just update the configuration and reapply it, after
    which Kubernetes will dutifully carry out your wishes. With a command-based approach,
    each change is itself a different command: `kubectl` `set` `image` to change the
    image, `kubectl` `scale` to change the number of replicas, and so on. You also
    run the risk that the command could fail, which may occur due to a network timeout,
    whereas with configuration, the changes will be picked up the next time you apply
    them. Chapter 11 covers taking configuration files and treating them just as you
    do the source code for your application, a so-called GitOps or configuration as
    code methodology where imperative commands would not be an option at all.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 改变也更为困难。使用配置文件时，如果你需要更改设置，只需更新配置并重新应用即可，之后 Kubernetes 将尽职尽责地执行你的愿望。使用基于命令的方法，每个更改都是一个不同的命令：使用
    `kubectl` `set` `image` 更改镜像，使用 `kubectl` `scale` 更改副本数量，等等。你还面临命令可能失败的风险，这可能是因为网络超时，而使用配置，更改将在下一次应用时被捕获。第11章介绍了将配置文件视为应用程序源代码的方式，这是一种所谓的
    GitOps 或配置即代码方法，其中命令式命令根本不是一种选择。
- en: If you encounter a system previously built with imperative commands, fear not,
    as configuration can be exported from the cluster with `kubectl` `get` `-o` `yaml`
    `$RESOURCE_TYPE` `$RESOURCE_NAME`. When exporting a configuration like this from
    the live cluster, though, there are some extraneous fields you’ll need to remove
    (covered in section 11.1.2). Fortunately, it’s never too late to switch, as whether
    you use declarative or imperative commands, Kubernetes is still storing the object
    in the same way.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到一个以前用命令式命令构建的系统，不要害怕，因为可以使用 `kubectl` `get` `-o` `yaml` `$RESOURCE_TYPE`
    `$RESOURCE_NAME` 从集群中导出配置。然而，当从运行中的集群导出此类配置时，你需要移除一些额外的字段（在11.1.2节中介绍）。幸运的是，切换永远不会太晚，因为无论你使用声明式还是命令式命令，Kubernetes
    都会以相同的方式存储对象。
- en: 3.4 Local Kubernetes environments
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 本地 Kubernetes 环境
- en: 'This chapter so far has used a cloud-based Kubernetes provider as the deployment
    environment. You can, of course, run Kubernetes locally as well. I chose to lead
    with a public cloud provider instead of a local development cluster to demonstrate
    deploying on Kubernetes, as I assume, for most, the goal is to publish your service
    and make it accessible beyond your own machine. Indeed, if you’re following the
    examples in this chapter in order, then congratulations: you can now deploy your
    apps to the world using Kubernetes! In future chapters, you’ll learn how to operationalize
    them, scale them up, and more.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章已经使用基于云的 Kubernetes 提供商作为部署环境。当然，你可以在本地运行 Kubernetes。我选择以公共云提供商而不是本地开发集群作为起点，是为了展示如何在
    Kubernetes 上进行部署，因为我假设，对于大多数人来说，目标是发布你的服务并使其超出你自己的机器可访问的范围。确实，如果你按照本章的示例顺序进行，那么恭喜你：你现在可以使用
    Kubernetes 将你的应用程序部署到全世界！在未来的章节中，你将学习如何使它们投入运营、扩展规模以及更多。
- en: Local Kubernetes development clusters, however, definitely have their place.
    They are useful during development when you want to rapidly deploy and iterate
    on code while running in a Kubernetes cluster, particularly when your application
    consists of several different services. They’re a great place to try out and learn
    Kubernetes constructs without paying for a cloud service and are a convenient
    option for testing your deployment configuration locally.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本地 Kubernetes 开发集群确实有其位置。在开发过程中，当你希望在 Kubernetes 集群中快速部署和迭代代码时，它们非常有用，尤其是当你的应用程序由几个不同的服务组成时。它们是尝试和学习
    Kubernetes 构造的好地方，无需支付云服务费用，并且是本地测试部署配置的便捷选项。
- en: There are a lot of differences in using Kubernetes locally on a machine in a
    nonproduction-grade environment with a fixed set of resources compared to a production-grade
    cloud service with dynamic provisioning. In the cloud, you can scale up massively
    using multiple machines spread over a geographical region, while your local machine
    has a fixed set of resources. In the cloud, you can get a production-grade routable
    public IP for your Service—not so much on your local machine. Due to these differences
    and many more, I believe learning directly in your target product environment
    is more efficient. Hence, the focus in this book on production-grade clusters.
    That being said, as long as you understand the differences, a local development
    cluster can be a useful tool indeed.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在非生产级环境中使用 Kubernetes 在机器上本地运行与使用具有动态预配的生产级云服务相比，存在许多差异。在云中，你可以使用地理区域内分布的多个机器进行大规模扩展，而你的本地机器资源是固定的。在云中，你可以为你的服务获取生产级可路由的公共
    IP 地址——在你的本地机器上则不然。由于这些差异以及更多，我相信直接在目标产品环境中学习效率更高。因此，本书的重点是生产级集群。话虽如此，只要你能理解这些差异，本地开发集群确实是一个非常有用的工具。
- en: Do you need a Kubernetes cluster for application development?
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要 Kubernetes 集群来进行应用程序开发吗？
- en: There’s no requirement to use Kubernetes during application development just
    because you use it for production deployment. A fairly common app development
    pattern I’ve observed is using Docker Compose (covered in section 2.3) for local
    development and testing, with the resulting application deployed to Kubernetes
    for production.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你在生产部署中使用 Kubernetes，并不意味着在应用程序开发期间也必须使用 Kubernetes。我观察到的一个相当常见的应用程序开发模式是使用
    Docker Compose（在第 2.3 节中介绍）进行本地开发和测试，然后将应用程序部署到 Kubernetes 进行生产。
- en: Docker Compose works pretty well for the development of apps with only a handful
    of interservice dependencies. The downside is you need to define the application
    config twice (once for development with Compose and once for production in Kubernetes),
    but this overhead is minor for apps with only a few service dependencies. The
    upside is that Docker has some useful tools for development, in particular, being
    able to mount local folders into the container, which means for interpreted languages
    like Python and Ruby, you can change code without a container rebuild. It’s also
    simple to configure since you can skip all the production-related config like
    replica count and resource requirements.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 对于开发只有少量服务依赖的应用程序来说效果相当不错。缺点是你需要为应用程序配置定义两次（一次是使用 Compose 进行开发，一次是在
    Kubernetes 中进行生产），但对于只有少量服务依赖的应用程序来说，这种开销微乎其微。优点是 Docker 为开发提供了一些有用的工具，特别是能够将本地文件夹挂载到容器中，这意味着对于像
    Python 和 Ruby 这样的解释型语言，你可以在不重新构建容器的情况下更改代码。由于你可以跳过所有与生产相关的配置，如副本数量和资源需求，因此配置起来也很简单。
- en: It’s hard to understate the usefulness of Compose being able to mount your local
    app folder as a read/write volume, edit code without a container rebuild, get
    output from commands you run in the container like log files, and perform database
    upgrades right in your development folder. Kubernetes does have some tools to
    level the playing field here, like Skaffold, which gets you a tight development
    loop with Kubernetes (local or cloud) as the target, but Docker has a sterling
    reputation among developers for a reason.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 强调 Compose 能够将你的本地应用文件夹挂载为可读写卷，无需重新构建容器即可编辑代码，从你在容器中运行的命令（如日志文件）中获取输出，并在你的开发文件夹中直接执行数据库升级，其有用性不容小觑。Kubernetes
    确实有一些工具可以平衡这个领域，如 Skaffold，它为你提供了一个与 Kubernetes（本地或云）作为目标紧密的开发循环，但 Docker 在开发者中享有良好的声誉是有原因的。
- en: As I always say, use the best tool for the job. Decide whether a local Kubernetes
    cluster or a Docker Compose setup works best for application development and use
    what works for you. Even if you choose to use Compose for application development,
    you may still utilize a local Kubernetes cluster for deployment testing.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我经常说的，使用最适合的工具。决定是使用本地 Kubernetes 集群还是 Docker Compose 设置来开发应用程序，并使用最适合你的方法。即使你选择使用
    Compose 进行应用程序开发，你仍然可以利用本地 Kubernetes 集群进行部署测试。
- en: There are a bunch of options for running a local Kubernetes cluster. The two
    most popular are Docker Desktop and Minikube. In fact, if you have Docker Desktop
    installed, then you already have a local single-node Kubernetes cluster! Minikube,
    created by the Kubernetes project, is also trivial to set up and offers a few
    more advanced options like multiple nodes, which are useful when you want to test
    more advanced Kubernetes constructs like Pod spread policies and affinity (chapter
    8).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 运行本地 Kubernetes 集群有多种选项。其中最受欢迎的是 Docker Desktop 和 Minikube。实际上，如果你已经安装了 Docker
    Desktop，那么你已经有了一个本地的单节点 Kubernetes 集群！Minikube 是由 Kubernetes 项目创建的，设置起来也很简单，并提供了一些更高级的选项，如多个节点，这在你想测试更高级的
    Kubernetes 构造，如 Pod 扩散策略和亲和力（第 8 章）时很有用。
- en: 3.4.1 Docker Desktop’s Kubernetes cluster
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 Docker Desktop 的 Kubernetes 集群
- en: 'Docker Desktop comes with its own single-node Kubernetes development environment.
    If you have Docker Desktop installed, then you already have a local Kubernetes
    environment. Follow the instructions at [https://docs.docker.com/desktop/kubernetes/](https://docs.docker.com/desktop/kubernetes/)
    to get going in two simple steps:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Desktop 自带单节点 Kubernetes 开发环境。如果你已经安装了 Docker Desktop，那么你已经有了一个本地的 Kubernetes
    环境。按照 [https://docs.docker.com/desktop/kubernetes/](https://docs.docker.com/desktop/kubernetes/)
    中的说明，只需两步即可开始使用：
- en: Enable Kubernetes in Docker Desktop settings and ensure it’s running.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Docker Desktop 设置中启用 Kubernetes 并确保其正在运行。
- en: Using `kubectl`, switch contexts to the Docker Desktop cluster.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `kubectl` 切换到 Docker Desktop 集群。
- en: NOTE Be aware that Docker’s local Kubernetes option is packaged with the “Docker
    Desktop” product. If you are using Docker via the Docker Engine install on Linux,
    it does not have this functionality.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Docker 的本地 Kubernetes 选项包含在“Docker Desktop”产品中。如果你是通过 Linux 上的 Docker Engine
    安装使用 Docker，则没有这项功能。
- en: 'Once Docker Desktop is running with Kubernetes enabled, you can view the context
    and switch to it:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Docker Desktop 启用了 Kubernetes，你可以查看上下文并切换到它：
- en: '[PRE52]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In fact, you can use these commands to switch to any cluster that you previously
    connected to, including a cloud platform like the one used previously in this
    chapter. Any time you wish to switch clusters, simply run
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以使用这些命令切换到之前连接过的任何集群，包括本章之前使用过的云平台。任何时候你想切换集群，只需运行
- en: '[PRE53]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: I find those two commands a bit tedious to type when switching between clusters
    a lot, so I highly recommend the `kubectx` tool ([https://github.com/ahmetb/kubectx](https://github.com/ahmetb/kubectx)),
    which makes it a lot quicker. To switch contexts with `kubectx`, use
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现当频繁在集群之间切换时，那两个命令输入起来有点繁琐，所以我强烈推荐 `kubectx` 工具 ([https://github.com/ahmetb/kubectx](https://github.com/ahmetb/kubectx))，它可以使切换上下文变得更快。要使用
    `kubectx` 切换上下文，请使用
- en: '[PRE54]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you have any problems with Docker Desktop, then the Restart Kubernetes Cluster
    and Clean/Purge Data options found in the debug menu are your friends.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Docker Desktop 上遇到任何问题，那么调试菜单中的“重启 Kubernetes 集群”和“清理/清除数据”选项将是你的朋友。
- en: 3.4.2 Minikube
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 Minikube
- en: Minikube is another great choice for testing locally and allows you to test
    more Kubernetes functionality by providing a multinode environment. It’s maintained
    by the open source Kubernetes community. Follow the instructions at [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)
    to install Minikube for your system.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube 是本地测试的另一个优秀选择，它通过提供一个多节点环境，允许你测试更多的 Kubernetes 功能。它由开源 Kubernetes 社区维护。按照
    [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)
    中的说明为你的系统安装 Minikube。
- en: 'Once installed, to boot a virtual multinode cluster (which I recommend, as
    it more closely resembles a production Kubernetes environment), run `minikube`
    `start` and pass the number of nodes you desire:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，要启动一个虚拟的多节点集群（我推荐这样做，因为它更接近生产环境中的 Kubernetes 环境），请运行 `minikube start`
    并传递你想要的节点数量：
- en: '[PRE55]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `start` command will automatically configure `kubectl` to use the Minikube
    context, meaning any `kubectl` commands will operate on the Minikube cluster.
    To change the context back to a different cluster, like your production cluster,
    use the `kubectl` `config` or `kubectx` commands described in the previous section.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`start` 命令将自动配置 `kubectl` 以使用 Minikube 上下文，这意味着任何 `kubectl` 命令都将作用于 Minikube
    集群。要更改上下文回到不同的集群，例如你的生产集群，请使用前一小节中描述的 `kubectl config` 或 `kubectx` 命令。'
- en: 'Once Minikube is running, you can go ahead and use it like a regular Kubernetes
    cluster, following the instructions in this chapter. Before you start using it,
    to verify that things are running as expected, run `kubectl` `get` `nodes` to
    check that you can connect to the cluster:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Minikube 运行起来，你就可以像使用常规 Kubernetes 集群一样使用它，按照本章中的说明进行操作。在开始使用之前，为了验证一切按预期运行，请运行
    `kubectl get nodes` 来检查你是否可以连接到集群：
- en: '[PRE56]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If you’re done using Minikube and want to get your machine’s CPU and memory
    resources back, run `minikube` `stop`. To delete all the data and make room for
    a new Minikube cluster next time with different settings (like a different node
    count), use `minikube` `delete`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经完成使用 Minikube 并想恢复你机器的 CPU 和内存资源，请运行 `minikube stop`。要删除所有数据并为下一次使用不同设置（如不同的节点数量）的新
    Minikube 集群腾出空间，请使用 `minikube delete`。
- en: 3.4.3 Using your local Kubernetes cluster
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.3 使用你的本地 Kubernetes 集群
- en: With `kubectl` set up to point to your preferred local Kubernetes cluster, you
    can deploy your application locally using the same `kubectl` commands shown earlier
    in this chapter. Two important differences, however, will be in how you expose
    and access Services and how you reference container images built locally. To deploy
    the sample application from this chapter, from the sample root directory, run
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `kubectl` 设置为指向你偏好的本地 Kubernetes 集群时，你可以使用本章前面展示的相同 `kubectl` 命令在本地部署你的应用程序。然而，有两个重要的区别，那就是你如何暴露和访问服务以及如何引用本地构建的容器镜像。要部署本章中的示例应用程序，从示例根目录运行
- en: '[PRE57]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The benefit of declarative configuration
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式配置的好处
- en: Throughout this book, examples are given using declarative configuration rather
    than imperative commands. In other words, to create a Deployment, we first create
    the configuration of the Deployment and then apply it, as opposed to using `kubectl`
    to create the Deployment directly.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，示例都是使用声明式配置而不是 imperative 命令给出的。换句话说，要创建一个 Deployment，我们首先创建 Deployment
    的配置，然后应用它，而不是直接使用 `kubectl` 创建 Deployment。
- en: One of the many benefits of this approach is that you can test out your configuration
    locally and then deploy it confidently to production later without needing to
    remember a bunch of one-off commands. Notice how we can deploy the same configuration
    files against the local cluster as we did against the production cluster. Neat!
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的好处之一是，你可以在本地测试你的配置，然后有信心将其部署到生产环境中，而不需要记住一大堆一次性命令。注意我们如何将相同的配置文件部署到本地集群和到生产集群。真
    neat！
- en: Accessing the Service
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 访问服务
- en: Unlike when developing on a cloud Kubernetes provider, when creating a `LoadBalancer`-type
    Service locally, you won’t get an external IP. For Docker Desktop, Minikube, and,
    in fact, any Kubernetes cluster, you can also use `kubectl` to forward ports from
    your local machine to the Service inside the cluster. This is useful for testing
    against a local Kubernetes cluster and debugging your cloud cluster. To expose
    the Service locally, use
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 与在云 Kubernetes 提供商上开发不同，当在本地创建 `LoadBalancer` 类型的服务时，你不会得到一个外部 IP。对于 Docker
    Desktop、Minikube 以及实际上任何 Kubernetes 集群，你也可以使用 `kubectl` 将你的本地机器的端口转发到集群内部的服务。这对于针对本地
    Kubernetes 集群进行测试和调试云集群非常有用。要本地暴露服务，请使用
- en: '[PRE58]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'where `FROM_PORT` is the port you’ll access the Service on locally, and `TO_PORT`
    is the IP of the Service. For our demo, choosing `8080` as a high-level port,
    the command can look like the following:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `FROM_PORT` 是你将在本地访问服务的端口，而 `TO_PORT` 是服务的 IP 地址。在我们的演示中，选择 `8080` 作为高级端口，命令可能看起来如下所示：
- en: '[PRE59]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: You can then browse to http://localhost:8080 to connect to the Service. There
    are a range of useful flags[¹](#pgfId-1072716) for `port-forward`, including `--address`
    `0.0.0.0`, to bind to all network interfaces so you can access the forwarded Service
    from other devices on the network (if your firewall allows it). Port forwarding
    is also useful to debug services running on a cloud Kubernetes platform.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以浏览到 http://localhost:8080 来连接到服务。`port-forward` 有很多有用的标志[¹](#pgfId-1072716)，包括
    `--address 0.0.0.0`，以便绑定到所有网络接口，这样你就可以从网络上的其他设备访问转发的服务（如果你的防火墙允许这样做）。端口转发对于调试在云
    Kubernetes 平台上运行的服务也非常有用。
- en: Minikube offers an additional way[²](#pgfId-1072722) to route traffic to your
    Service. It can be accessed with
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube 提供了一种额外的路由流量到你的服务的方法[²](#pgfId-1072722)。你可以通过以下方式访问：
- en: '[PRE60]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: For the sample in the earlier section, that would be
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面章节中的示例，那将是
- en: '[PRE61]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Accessing Kubernetes Services locally from Docker
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Docker 本地访问 Kubernetes 服务
- en: Are you running a Service in Kubernetes that you want to access directly from
    a Docker container running outside of Kubernetes for some reason? For example,
    you’re doing some rapid iterating in Docker and want to access an established
    Service in Kubernetes.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否在 Kubernetes 中运行一个服务，出于某种原因你想直接从运行在 Kubernetes 外部的 Docker 容器访问它？例如，你正在 Docker
    中进行一些快速迭代，并想访问 Kubernetes 中已建立的服务。
- en: The solution is easy. Forward the Service so that the port is open on your local
    machine as previously described. You can then reference it in containers running
    directly in Docker using `host.docker.internal` on whatever port you forwarded.
    `host.docker.internal` is how containers can talk to services on the local machine,
    and since you forwarded the port to your local machine, the connection can go
    through.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案很简单。将服务转发，使得端口在你的本地机器上是开放的，就像之前描述的那样。然后你可以在 Docker 中直接运行的容器中引用它，使用 `host.docker.internal`
    在你转发的任何端口上。`host.docker.internal` 是容器如何与本地机器上的服务通信的方式，由于你已将端口转发到本地机器，连接可以通过。
- en: For example, say you deploy Redis in Kubernetes (see chapter 9) and forward
    the ports with `kubectl` `port-forward` `service/timeserver` `6379:6379`. You
    then want to connect to it from a local container in Docker running Python using
    the redis-py library. You can do that with `redis.Redis(host='host.docker.internal',`
    `port=` `'6379')`. Happy coding!
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你在 Kubernetes 中部署 Redis（见第 9 章），并使用 `kubectl port-forward service/timeserver
    6379:6379` 转发端口。然后你想要从运行 Python 的本地 Docker 容器连接到它。你可以使用 `redis.Redis(host='host.docker.internal',
    port='6379')` 来实现。祝您编码愉快！
- en: Deploying local images
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 部署本地镜像
- en: By default, a local Kubernetes cluster will attempt to pull container images
    from the internet—behaving just like a production Kubernetes cluster. For public
    images like `ubuntu` or my sample image `docker.io/wdenniss/timeserver`, everything
    will just work. But extra steps are required to supply your own images built locally
    to the local cluster. Of course, you could upload them to a public container registry
    as you would for production, whereby your local cluster will pull them like in
    production.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，本地 Kubernetes 集群将尝试从互联网拉取容器镜像——表现得就像一个生产 Kubernetes 集群一样。对于公共镜像，如 `ubuntu`
    或我的示例镜像 `docker.io/wdenniss/timeserver`，一切都会正常工作。但是，为了向本地集群提供你自己构建的本地镜像，你需要采取额外步骤。当然，你可以像在生产环境中一样将它们上传到公共容器注册库，这样你的本地集群就会像在生产环境中一样拉取它们。
- en: Uploading every image you build during development, however, is a bit of a hassle.
    It slows down your development as you wait for the push and pull. Also, unless
    you’re using public images, you’ll need to provision credentials so your local
    cluster can access them (a step that is typically done for you when you’re pulling
    private images from the container registry of your Kubernetes provider).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在开发过程中上传你构建的每个镜像，却有点麻烦。这会减慢你的开发速度，因为你需要等待推送和拉取。此外，除非你使用公共镜像，否则你需要提供凭证，以便你的本地集群可以访问它们（通常当你从
    Kubernetes 提供商的容器注册库拉取私有镜像时，这一步骤会为你完成）。
- en: To get your local cluster to use a local image, you need to make two changes
    to your Kubernetes Deployment configuration. First, add the `imagePullPolicy`
    parameter and set it to `Never` and, second, refer to your image using its local
    image name without any repository prefix.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 要使您的本地集群使用本地镜像，您需要修改您的 Kubernetes 部署配置文件的两个地方。首先，添加 `imagePullPolicy` 参数并将其设置为
    `Never`，其次，使用不带任何仓库前缀的本地镜像名称引用您的镜像。
- en: 'The path for locally built images is simply their repository and version tag,
    with no repository URL prefix. If you’ve built an image with `docker` `build`
    `.` `-t` `timeserver` as we did in chapter 2, you would reference this in your
    Pod spec as `image:` `timeserver:latest` in your config file (using `latest` as
    the version tag will give us the most recently built image). Run `docker` `images`
    to view a list of available local images. The following is an example of a Deployment
    referencing this locally built image:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 本地构建的镜像的路径只是它们的仓库和版本标签，没有仓库 URL 前缀。如果您已经使用 `docker` `build` `.` `-t` `timeserver`
    构建了一个镜像，就像我们在第 2 章中所做的那样，您可以在配置文件中将此引用为 `image:` `timeserver:latest`（使用 `latest`
    作为版本标签将给我们最新的构建镜像）。运行 `docker` `images` 查看可用本地镜像列表。以下是一个引用此本地构建镜像的 Deployment
    示例：
- en: Listing 3.5 Chapter03/3.4.3_LocalDevelopment/deploy.yaml
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.5 第 03 章/3.4.3_本地开发/deploy.yaml
- en: '[PRE62]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: ❶ Reference to a locally available image
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对本地可用镜像的引用
- en: ❷ Image pull policy prevents Kubernetes from attempting to fetch this local
    image remotely.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 镜像拉取策略阻止 Kubernetes 尝试从远程位置获取此本地镜像。
- en: TIP Only apply the `imagePullPolicy:` `Never` configuration to images you plan
    to provide locally. You don’t want to set this on remote images, as they won’t
    be pulled and will error with a `ErrImageNeverPull` status. If you see that error,
    it means the image isn’t available locally, yet the Deployment was configured
    to use a local image.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：仅将 `imagePullPolicy:` `Never` 配置应用于您计划本地提供的镜像。您不希望将此设置在远程镜像上，因为它们不会被拉取，并且会因
    `ErrImageNeverPull` 状态而出现错误。如果您看到这个错误，这意味着镜像尚未本地可用，但部署已被配置为使用本地镜像。
- en: There is one more step if you’re using Minikube. While Docker Desktop has access
    to all the images you built locally with Docker, Minikube does not (it has its
    own independent container run time and doesn’t share images with your local install
    of Docker). To push local images you want to use into Minikube, simply run the
    command
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Minikube，还有一步。虽然 Docker Desktop 可以访问您使用 Docker 本地构建的所有镜像，但 Minikube
    不能（它有自己的独立容器运行时，并且不会与您本地的 Docker 安装共享镜像）。要将您想要推送到 Minikube 的本地镜像推送到 Minikube，只需运行以下命令
- en: '[PRE63]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: such as
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 例如
- en: '[PRE64]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then, apply your changes with `kubectl` as before:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，像之前一样使用 `kubectl` 应用您的更改：
- en: '[PRE65]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A Kubernetes cluster consists of a control plane and nodes on which your containers
    are run.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 集群由控制平面和运行您的容器的节点组成。
- en: You interact with the cluster via the Kubernetes API, typically with the command-line
    tool `kubectl`.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您通过 Kubernetes API 与集群交互，通常使用命令行工具 `kubectl`。
- en: To deploy your own application to Kubernetes, first, upload the container image
    to a container repository.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将您自己的应用程序部署到 Kubernetes，首先，将容器镜像上传到容器仓库。
- en: Workloads are specified using objects such as a Deployment, which encapsulates
    a Pod, which defines your containers.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用如 Deployment 这样的对象指定工作负载，它封装了一个 Pod，该 Pod 定义了您的容器。
- en: Services are used to create network endpoints and expose containers to the internet.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务用于创建网络端点并将容器暴露到互联网。
- en: Pods are referenced by other objects, such as Deployments and Services, using
    labels.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod 通过标签被其他对象（如 Deployment 和 Service）引用。
- en: Kubernetes uses declarative configuration, typically YAML-formatted configuration
    files.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 使用声明性配置，通常是 YAML 格式的配置文件。
- en: You specify your requirements through the configuration, and the Kubernetes
    controller seeks to actuate and fulfill them continuously.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您通过配置指定您的需求，Kubernetes 控制器会持续尝试实现和满足这些需求。
- en: Updating the application is as simple as modifying the configuration with the
    new container version and applying the change to the cluster.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新应用程序就像使用新容器版本修改配置并将更改应用到集群一样简单。
- en: Kubernetes will compare changes across configuration versions and actuate any
    specified changes.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 将比较配置版本之间的更改，并实现任何指定的更改。
- en: '* * *'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ^(1.) [https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#port-forward](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#port-forward)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: ^ (1.) [https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#port-forward](https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#port-forward)
- en: ^(2.) [https://kubernetes.io/docs/setup/learning-environment/minikube/#services](https://kubernetes.io/docs/setup/learning-environment/minikube/#services)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://kubernetes.io/docs/setup/learning-environment/minikube/#services](https://kubernetes.io/docs/setup/learning-environment/minikube/#services)'
