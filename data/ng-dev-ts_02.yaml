- en: Chapter 3\. Router basics
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 章\. 路由基础
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Configuring parent and child routes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置父路由和子路由
- en: Passing data while navigating from one route to another
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导航从一个路由到另一个路由时传递数据
- en: Configuring and using child routes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和使用子路由
- en: In a single-page application (SPA), the web page won’t be reloaded, but its
    parts may change. You’ll want to add navigation to this application so it’ll change
    the content area of the page (known as the *router outlet*) based on the user’s
    actions. The Angular router allows you to configure and implement such navigation
    without performing a full page reload.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在单页应用（SPA）中，网页不会重新加载，但其部分可能会改变。您可能希望向此应用程序添加导航，以便根据用户操作更改页面内容区域（称为*路由出口*）。Angular
    路由器允许您配置和实现此类导航，而无需执行完整的页面重新加载。
- en: In general, you can think of a *router* as an object responsible for the view
    state of the application. Every application has one router object, and you need
    to configure the routes of your app.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可以将*路由器*视为一个负责应用程序视图状态的对象。每个应用程序都有一个路由器对象，您需要配置应用程序的路由。
- en: In this chapter, we’ll discuss the major features of the Angular router, including
    configuring routes in parent and child components, passing data to routes, and
    adding router support to the HTML anchor elements.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 Angular 路由的主要功能，包括在父组件和子组件中配置路由、向路由传递数据以及向 HTML 锚点元素添加路由支持。
- en: The ngAuction app now has a home view; you’ll add a second view so that if the
    user clicks the title of a product on the home page, the page’s content will change
    to display the details of the selected product. At any given time, the user will
    see either the `HomeComponent` or the `ProductDetailComponent` in the `<router-outlet>`
    area.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ngAuction 应用现在有一个主页视图；您将添加第二个视图，以便如果用户点击主页上的产品标题，页面内容将更改以显示所选产品的详细信息。在任何给定时间，用户将在`<router-outlet>`区域看到`HomeComponent`或`ProductDetailComponent`之一。
- en: 3.1\. Routing basics
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1\. 路由基础
- en: You can think of an SPA as a collection of states, such as home, product detail,
    and shipping. Each state represents a different view of the same SPA.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将单页应用（SPA）视为一组状态，例如主页、产品详情和运输。每个状态代表同一SPA的不同视图。
- en: '[Figure 3.1](#ch03fig01) shows the landing page of the ngAuction app, which
    has a navigation bar (a component) at the top, a search form (another component)
    on the left, and a footer (yet another component) at the bottom, and you want
    these components to remain visible all the time.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.1](#ch03fig01) 展示了 ngAuction 应用的着陆页，其中顶部有一个导航栏（一个组件），左侧有一个搜索表单（另一个组件），底部有一个页脚（另一个组件），并且您希望这些组件始终可见。'
- en: Figure 3.1\. Components on the home page of ngAuction
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.1\. ngAuction 应用主页上的组件
- en: '![](Images/03fig01_alt.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3.2](Images/03fig01_alt.jpg)'
- en: Besides the parts that are always visible, there’s a content area (see [figure
    3.2](#ch03fig02)) that initially will display the `<nga-home>` component and its
    children but can show other views as well, based on the user’s actions. To show
    other views, you’ll need to configure the router so it can display different views
    in the outlet, replacing one view with another. You’ll be assigning a component
    for each view that you want to display in this area. This content area is represented
    by the tag `<router-outlet>`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了始终可见的部分之外，还有一个内容区域（见[图 3.2](#ch03fig02)），最初将显示`<nga-home>`组件及其子组件，但也可以根据用户操作显示其他视图。要显示其他视图，您需要配置路由，使其能够在出口处显示不同的视图，用一种视图替换另一种视图。您将为要在该区域显示的每个视图分配一个组件。这个内容区域由`<router-outlet>`标签表示。
- en: '|  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: There can be more than one outlet on the page. We’ll cover this in [section
    4.2](kindle_split_013.xhtml#ch04lev1sec2) in [chapter 4](kindle_split_013.xhtml#ch04).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 页面上可以有多个出口。我们将在[第 4 章的 4.2 节](kindle_split_013.xhtml#ch04lev1sec2)中介绍这一点。
- en: '|  |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 3.2\. Allocating the area for changing views
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.2\. 分配更改视图的区域
- en: '![](Images/03fig02_alt.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3.2](Images/03fig02_alt.jpg)'
- en: The router is responsible for managing client-side navigation, and later in
    this chapter we provide a high-level overview of the router. In the non-SPA world,
    site navigation is implemented by a series of requests to a server, which refreshes
    the entire page by sending the appropriate HTML documents to the browser. With
    SPAs, the code for rendering components is already on the client (except for the
    lazy-loading scenarios covered in section 4.3 of [chapter 4](kindle_split_013.xhtml#ch04)),
    and you need to replace one view with another.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器负责管理客户端导航，在本章的后面部分我们将提供一个路由器的高级概述。在非SPA世界中，网站导航是通过向服务器发出一系列请求来实现的，通过向浏览器发送适当的HTML文档来刷新整个页面。在SPA中，渲染组件的代码已经位于客户端（除了在第4章第4.3节中涵盖的懒加载场景之外），您需要用另一个视图替换一个视图。
- en: As the user navigates the application, the app can still make requests to the
    server to retrieve or send data. Sometimes a view (the combination of the UI code
    and data) has everything it needs already downloaded to the browser. Other times
    a view will communicate with the server by issuing AJAX requests or via WebSockets.
    Each view will have a unique URL shown in the location bar of the browser. We’ll
    discuss that next.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在应用程序中导航时，应用程序仍然可以向服务器发出请求以检索或发送数据。有时一个视图（UI代码和数据组合）已经将所需的所有内容下载到浏览器中。其他时候，视图将通过发出AJAX请求或通过WebSockets与服务器进行通信。每个视图都会有一个在浏览器地址栏中显示的唯一URL。我们将在下一节讨论这一点。
- en: 3.2\. Location strategies
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 位置策略
- en: 'At any given time, the browser’s location bar displays the URL of the current
    view. A URL can contain different parts, or segments. It starts with a protocol
    followed by a domain name, and it may include a port number. Parameters that need
    to be passed to the server may follow a question mark (this is true for HTTP `GET`
    requests), like this: [http://mysite.com:8080/auction?someParam=1234](http://mysite.com:8080/auction?someParam=1234).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何给定时间，浏览器的地址栏显示当前视图的URL。一个URL可以包含不同的部分，或称为段。它以协议开始，后跟域名，并且可能包括端口号。需要传递给服务器的参数可能跟在问号之后（这对于HTTP
    `GET`请求是正确的），如下所示：[http://mysite.com:8080/auction?someParam=1234](http://mysite.com:8080/auction?someParam=1234)。
- en: 'In a non-SPA, changing any character in the preceding URL results in a new
    request to the server. In SPAs, you need the ability to modify the URL without
    forcing the browser to make a server-side request so the application can locate
    the proper view on the client. Angular offers two location strategies for implementing
    client-side navigation:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在非SPA中，更改前面URL中的任何字符会导致向服务器发出新的请求。在SPA中，您需要能够修改URL而无需强制浏览器进行服务器端请求，以便应用程序可以在客户端定位适当的视图。Angular提供了两种位置策略来实现客户端导航：
- en: '**`HashLocationStrategy`—** A hash sign (#) is added to the URL, and the URL
    segment after the hash uniquely identifies the view to be used as a web page fragment.
    This strategy works with all browsers, including the old ones.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`HashLocationStrategy`—** 在URL中添加一个哈希符号（#），哈希符号之后的URL段唯一标识了用作网页片段的视图。这种策略与所有浏览器兼容，包括旧浏览器。'
- en: '**`PathLocationStrategy`—** This `History` API–based strategy works only in
    browsers that support HTML5\. This is the default location strategy in Angular.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`PathLocationStrategy`—** 这种基于`History` API的策略仅在支持HTML5的浏览器中工作。这是Angular中的默认位置策略。'
- en: 3.2.1\. Hash-based navigation
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.1\. 基于哈希的导航
- en: A sample URL that uses hash-based navigation is shown in [figure 3.3](#ch03fig03).
    Changing any character to the right of the hash sign doesn’t cause a direct server-side
    request but navigates to the view represented by the path (with or without parameters)
    after the hash. The hash sign serves as a separator between the base URL and the
    client-side location of the required content.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于哈希的导航的示例URL显示在[图3.3](#ch03fig03)中。将哈希符号右侧的任何字符进行更改不会直接导致服务器端请求，而是在哈希之后导航到由路径（带或不带参数）表示的视图。哈希符号充当基础URL和所需内容的客户端位置之间的分隔符。
- en: Figure 3.3\. Dissecting the URL
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3\. 解构URL
- en: '![](Images/03fig03_alt.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig03_alt.jpg)'
- en: 'Try to navigate an SPA like Gmail and watch the URL. For the Inbox, it looks
    like this: [https://mail.google.com/mail/u/0/#inbox](https://mail.google.com/mail/u/0/#inbox).
    Now go to the Sent folder, and the hash portion of the URL will change from *inbox*
    to *sent*. The client-side JavaScript code invokes the necessary functions to
    display the Sent view. But why does the Gmail app still show you the “Loading
    . . .” message when you switch to the Sent box? The JavaScript code of the Sent
    view can still make AJAX requests to the server to get the new data, but it doesn’t
    have to load any additional code, markup, or CSS from the server.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试导航一个像 Gmail 这样的 SPA 并观察 URL。对于收件箱，它看起来像这样：[https://mail.google.com/mail/u/0/#inbox](https://mail.google.com/mail/u/0/#inbox)。现在转到已发送文件夹，URL
    的哈希部分将从 *inbox* 更改为 *sent*。客户端 JavaScript 代码调用必要的函数以显示已发送视图。但为什么当切换到已发送框时，Gmail
    应用仍然显示“正在加载...”的消息？已发送视图的 JavaScript 代码仍然可以向服务器发出 AJAX 请求以获取新数据，但它不需要从服务器加载任何额外的代码、标记或
    CSS。
- en: To use hash-based navigation, `@NgModule()` has to include the `providers` value
    (we discuss providers in the [section 5.2](kindle_split_014.xhtml#ch05lev1sec2)
    in [chapter 5](kindle_split_014.xhtml#ch05)), as shown in the following listing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用基于哈希的导航，`@NgModule()` 必须包含 `providers` 值（我们将在第 5 章的 [5.2 节](kindle_split_014.xhtml#ch05lev1sec2)中讨论提供者），如下所示。
- en: Listing 3.1\. Using the hash location strategy
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.1\. 使用哈希位置策略
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* The provider is needed, so Angular injects the service supporting the
    hash location strategy.**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 提供者需要，以便 Angular 注入支持哈希位置策略的服务。**'
- en: 3.2.2\. History API-based navigation
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.2.2\. 基于 History API 的导航
- en: The browser’s `History` API allows you to move back and forth through the user’s
    navigation history as well as programmatically manipulate the history stack (see
    “Manipulating the Browser History” in the Mozilla Developer Network, [http://mng.bz/i64G](http://mng.bz/i64G)).
    In particular, the `pushState()` method is used to attach a segment to the base
    URL as the user navigates your SPA.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器的 `History` API 允许你通过用户导航历史记录来回移动，以及通过编程方式操作历史堆栈（请参阅 Mozilla 开发者网络中的“操作浏览器历史记录”，[http://mng.bz/i64G](http://mng.bz/i64G)）。特别是，`pushState()`
    方法用于在用户导航你的单页应用（SPA）时附加一个段到基本 URL。
- en: 'Consider the following URL: [http://mysite.com:8080/products/page/3](http://mysite.com:8080/products/page/3)
    (note the absence of the hash sign). The URL segment *products/page/3* can be
    pushed (attached) to the base URL programmatically without using the hash tag.
    If the user navigates from page 3 to 4, the application’s code will push the URL
    segment *products/page/4*, saving the previously visited *products/page/3* in
    the browser history.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 URL：[http://mysite.com:8080/products/page/3](http://mysite.com:8080/products/page/3)（注意没有哈希符号）。URL
    段 *products/page/3* 可以通过程序将（附加）到基本 URL，而不使用哈希标签。如果用户从第 3 页导航到第 4 页，应用程序的代码将推送
    URL 段 *products/page/4*，并将之前访问过的 *products/page/3* 保存到浏览器历史记录中。
- en: 'Angular spares you from invoking `pushState()` explicitly—you just need to
    configure the URL segments and map them to the corresponding components. With
    the `History` API–based location strategy, you need to tell Angular what to use
    as a base URL in your application so it can properly append the client-side URL
    segments. If you want to serve an Angular app on a non-root path, you have to
    do the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 免去了你显式调用 `pushState()` 的麻烦——你只需配置 URL 段并映射到相应的组件。基于 `History` API 的位置策略，你需要告诉
    Angular 在你的应用程序中用作基本 URL 的内容，以便它能够正确地附加客户端 URL 段。如果你想在非根路径上提供 Angular 应用，你必须执行以下操作：
- en: Add the `<base>` tag to the header of index.html, such as `<base href="/mypath">`,
    or use the `--base-href` option while running `ng build`. Angular CLI–generated
    projects include `<base href="/">` in index.html.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `<base>` 标签添加到 index.html 的头部，例如 `<base href="/mypath">`，或在运行 `ng build` 时使用
    `--base-href` 选项。Angular CLI 生成的项目在 index.html 中包含 `<base href="/">`。
- en: Assign a value for the `APP_BASE_HREF` constant in the root module and use it
    as the `providers` value. The following listing uses `/` as a base URL, but it
    can be any URL segment that denotes the end of the base URL.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在根模块中为 `APP_BASE_HREF` 常量分配一个值，并将其用作 `providers` 值。以下列表使用 `/` 作为基本 URL，但它可以是表示基本
    URL 结尾的任何 URL 段。
- en: Listing 3.2\. Adding support to a `History`-based API
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.2\. 为基于 `History` 的 API 添加支持
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* The provider is needed so the router properly resolves URLs.**'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 提供者需要，以便路由正确解析 URL。**'
- en: '`APP_BASE_HREF` affects how the router resolves `routerLink` properties and
    the `router.navigate()` calls within the app, whereas the `<base href=". . .">`
    tag affects how the browser resolves URLs when loading static resources like `<link>`,
    `<script>`, and `<img>` tags.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`APP_BASE_HREF`影响路由器如何解析应用程序内`routerLink`属性和`router.navigate()`调用，而`<base href=".
    . .">`标签影响浏览器在加载静态资源（如`<link>`、`<script>`和`<img>`标签）时解析URL的方式。'
- en: 3.3\. The building blocks of client-side navigation
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3\. 客户端导航的构建块
- en: Let’s get familiar with the main concepts of implementing client-side navigation
    using the Angular router. Routes are configured using the `RouterModule`. If your
    application needs routing, make sure your package.json file includes the dependency
    `@angular/router`. Angular includes many classes supporting navigation—for example,
    `Router`, `Route`, `Routes`, `ActivatedRoute`, and others. You configure routes
    in an array of objects of type `Route`, as in the following listing. Each of the
    elements in this array is an object of type `Route`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们熟悉使用Angular路由实现客户端导航的主要概念。路由是通过`RouterModule`配置的。如果您的应用程序需要路由，请确保您的`package.json`文件包含依赖项`@angular/router`。Angular包含许多支持导航的类——例如，`Router`、`Route`、`Routes`、`ActivatedRoute`等。您将路由配置在类型为`Route`的对象数组中，如下一列表所示。此数组中的每个元素都是类型为`Route`的对象。
- en: Listing 3.3\. A sample routes configuration
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.3\. 路由配置示例
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Renders the HomeComponent by default**'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 默认渲染HomeComponent**'
- en: '***2* If the URL contains the product fragment, renders ProductDetailComponent**'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果URL包含产品片段，则渲染ProductDetailComponent**'
- en: Because route configuration is done on the module level, you need to let the
    app module know about the routes in the `@NgModule()` decorator. If you declare
    routes for the root module, use the `forRoot()` method, for example, as shown
    in the following listing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于路由配置是在模块级别完成的，因此您需要让应用程序模块了解`@NgModule()`装饰器中的路由。如果您为根模块声明路由，请使用`forRoot()`方法，例如，如下所示。
- en: Listing 3.4\. Letting the root module know about the routes
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.4\. 让根模块了解路由
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Creates a router module and a service for the app root module**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为应用程序根模块创建一个路由模块和一个服务**'
- en: If you generated your app using the Angular CLI command `ng new` with the `--routing`
    option (as you did in the hands-on section in [chapter 2](kindle_split_011.xhtml#ch02)),
    you’ll get a separate file, app-routing.module.ts, where you can configure routes,
    as illustrated in the next listing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用带有`--routing`选项的Angular CLI命令`ng new`生成了应用程序（正如您在[第2章](kindle_split_011.xhtml#ch02)的手动部分所做的那样），您将获得一个单独的文件`app-routing.module.ts`，您可以在其中配置路由，如下一列表所示。
- en: Listing 3.5\. A separate module with route support
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.5\. 具有路由支持的独立模块
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Configures routes**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 配置路由**'
- en: '***2* Creates a router module and a service for the app root module**'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为应用程序根模块创建一个路由模块和一个服务**'
- en: '***3* Makes this module accessible from other modules**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使此模块可从其他模块访问**'
- en: If you’re configuring routes for a feature module (not for the root one), use
    the `forChild()` method, which also creates a router module but doesn’t create
    the router service (`forRoot()` should have created the service by now), as you
    can see in the following listing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在为功能模块配置路由（而不是根模块），请使用`forChild()`方法，该方法也会创建一个路由模块，但不会创建路由服务（`forRoot()`应该已经创建了服务），如下一列表所示。
- en: Listing 3.6\. Creating a router module for a feature module
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.6\. 为功能模块创建路由模块
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Creates a router module but doesn’t create the router service**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建路由模块但不创建路由服务**'
- en: Let’s start with a simple app that illustrates routing. Say you want to create
    a root component that has two links, Home and Product Details, at the top of the
    page. The application should render either `HomeComponent` or `ProductDetailComponent`,
    depending on which link the user clicks. `HomeComponent` will render the text
    “Home Component,” and `ProductDetailComponent` will render “Product Detail Component.”
    Initially the web page should display `HomeComponent`, as shown in [figure 3.4](#ch03fig04).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的应用程序开始，该应用程序说明了路由。假设您想创建一个根组件，该组件在页面顶部有两个链接，分别是“首页”和“产品详情”。应用程序应根据用户点击的链接渲染`HomeComponent`或`ProductDetailComponent`。`HomeComponent`将渲染文本“首页组件”，而`ProductDetailComponent`将渲染“产品详情组件”。最初，网页应显示`HomeComponent`，如图[3.4](#ch03fig04)所示。
- en: Figure 3.4\. Home component rendered with red background
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.4\. 带有红色背景的首页组件
- en: '![](Images/03fig04_alt.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig04_alt.jpg)'
- en: After the user clicks the Product Details link, the router should display the
    `ProductDetailComponent`, as shown in [figure 3.5](#ch03fig05).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 用户点击产品详情链接后，路由器应显示`ProductDetailComponent`，如图[3.5](#ch03fig05)所示。
- en: Figure 3.5\. Product-detail component rendered with cyan background
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.5\. 以青色背景渲染的产品详情组件
- en: '![](Images/03fig05_alt.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/03fig05_alt.jpg)'
- en: You can see how the URLs for these routes look in [figures 3.4](#ch03fig04)
    and [3.5](#ch03fig05). The main goal of this basic app is to become familiar with
    the router, so the components will be very simple, as in the following listing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图3.4](#ch03fig04)和[3.5](#ch03fig05)中看到这些路由的URL看起来如何。这个基本应用的主要目标是熟悉路由器，因此组件将非常简单，如下面的列表所示。
- en: Listing 3.7\. `HomeComponent`
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.7\. `HomeComponent`
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Renders this component with red background**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 以红色背景渲染此组件**'
- en: The code of the `ProductDetailComponent` looks similar, as you can see in the
    following listing, but instead of red it uses a cyan background.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductDetailComponent`的代码看起来很相似，如以下列表所示，但它使用的是青色背景而不是红色。'
- en: Listing 3.8\. `ProductDetailComponent`
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.8\. `ProductDetailComponent`
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Renders this component with cyan background**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 以青色背景渲染此组件**'
- en: The `Routes` type is just a collection of the objects of the type defined in
    the `Route` interface, as shown in the next listing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Routes`类型只是`Route`接口中定义的类型对象的集合，如下一个列表所示。'
- en: Listing 3.9\. Angular’s `Route` interface
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.9\. Angular的`Route`接口
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can pass to the `forRoot()` or `forChild()` functions a config object that
    only has a couple of properties filled in. In the basic app, you use just two
    properties defined in the `Route` interface: `path` and `component`. We’ll do
    it in a file called app.routing.ts, as in the following listing.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向`forRoot()`或`forChild()`函数传递一个配置对象，该对象只填充了几个属性。在基本应用中，你使用在`Route`接口中定义的两个属性：`path`和`component`。我们将在名为app.routing.ts的文件中这样做，如下面的列表所示。
- en: Listing 3.10\. app.routing.ts
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.10\. app.routing.ts
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* HomeComponent is mapped to a path containing an empty string, which implicitly
    makes it a default route.**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* HomeComponent映射到一个包含空字符串的路径，这隐式地使其成为默认路由。**'
- en: '***2* If the URL has the product segment after the base URL, renders the ProductDetail-Component
    in the router outlet**'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果URL在基本URL后有产品段，则在路由出口中渲染ProductDetail-Component**'
- en: '***3* Invokes forRoot() and exports the router configuration so it can be imported
    by the root module**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 调用invokes forRoot()并导出路由配置，以便根模块可以导入**'
- en: The next step is to create a root component that will contain the links for
    navigating between the home and product-detail views. The following listing shows
    the root `AppComponent` located in the app.component.ts file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个根组件，它将包含在主页和产品详情视图之间导航的链接。以下列表显示了位于app.component.ts文件中的根`AppComponent`。
- en: Listing 3.11\. app.component.ts
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.11\. app.component.ts
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Creates a link that binds routerLink to the empty path**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个绑定routerLink到空路径的链接**'
- en: '***2* Creates a link that binds routerLink to the path /product**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个绑定routerLink到路径/product的链接**'
- en: '***3* The <router-outlet> specifies the area on the page where the router will
    render the components (one at a time).**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* `<router-outlet>`指定了页面中路由将渲染组件的区域（一次一个）。**'
- en: The square brackets around `routerLink` denote property binding, while the brackets
    on the right represent an array with one element (for example, `['/']`). The second
    anchor tag has the `routerLink` property bound to the component configured for
    the /product path. The matched components will be rendered in the area marked
    with `<router-outlet>`, which in this app is located below the anchor tags.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`routerLink`周围的方括号表示属性绑定，而右侧的括号表示一个包含一个元素的数组（例如，`[''/'']`）。第二个锚标签将`routerLink`属性绑定到为/product路径配置的组件。匹配的组件将在标记为`<router-outlet>`的区域渲染，在这个应用中位于锚标签下方。'
- en: None of the components are aware of the router configuration, because it’s the
    module’s business, as shown in the following listing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 没有组件知道路由配置，因为它属于模块的业务，如下面的列表所示。
- en: Listing 3.12\. app.module.ts
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.12\. app.module.ts
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Imports the routes configuration**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入路由配置**'
- en: '***2* Adds the routes configuration to @NgModule()**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将路由配置添加到@NgModule()**'
- en: '***3* Lets the dependency injection mechanism know that you want HashLocationStrategy**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 让依赖注入机制知道你想要HashLocationStrategy**'
- en: The module’s `providers` property is an array of registered providers (there’s
    just one in this example) for dependency injection, which is covered in [chapter
    5](kindle_split_014.xhtml#ch05). At this point, you just need to know that although
    the default location strategy is `PathLocationStrategy`, you want Angular to use
    the `HashLocationStrategy` class for routing (note the hash sign in the URL in
    [figure 3.5](#ch03fig05)).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的`providers`属性是一个注册提供者的数组（本例中只有一个），用于依赖注入，这将在[第5章](kindle_split_014.xhtml#ch05)中介绍。在此阶段，您只需知道，尽管默认的位置策略是`PathLocationStrategy`，但您希望Angular使用`HashLocationStrategy`类进行路由（注意[图3.5](#ch03fig05)中URL中的哈希符号）。
- en: 'In the project router-samples that comes with this chapter, we’ve configured
    multiple applications in the .angular-cli.json file. The app described in this
    section has the name *basic*, and you can run it by entering the following command
    in your Terminal window:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章附带的项目router-samples中，我们在.angular-cli.json文件中配置了多个应用程序。本节中描述的应用程序名称为*basic*，您可以通过在终端窗口中输入以下命令来运行它：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|  |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'In Angular 6, the .angular-cli.json file is renamed angular.json. Also, if
    you decide to run the Angular 6 version of this app (it comes with the book code
    samples), the `--app` option isn’t needed: `ng serve basic -o`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Angular 6中，.angular-cli.json文件已重命名为angular.json。另外，如果您决定运行此应用的Angular 6版本（它包含书中的代码示例），则不需要`--app`选项：`ng
    serve basic -o`。
- en: '|  |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Don’t forget to run `npm install` in the project router-samples.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在项目router-samples中运行`npm install`。
- en: '|  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In the basic routing code sample, we arranged the navigation using `routerLink`
    in HTML anchor tags. But what if you need to arrange navigation programmatically
    without asking the user to click a link?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本的路由代码示例中，我们使用HTML锚标签中的`routerLink`来安排导航。但如果您需要在不要求用户点击链接的情况下以编程方式安排导航呢？
- en: 3.4\. Navigating to routes with navigate()
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4\. 使用`navigate()`导航到路由
- en: Let’s modify the basic code sample to navigate by using the `navigate()` method.
    You’ll add a button that will also navigate to the `ProductDetailComponent`, but
    this time no HTML anchors will be used.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改基本的代码示例，使用`navigate()`方法进行导航。您将添加一个按钮，该按钮也将导航到`ProductDetailComponent`，但这次不使用HTML锚点。
- en: The following listing reuses the router configuration from the previous section
    but invokes the `navigate()` method on the `Router` instance that will be injected
    into the `AppComponent` via its constructor.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表重用了上一节中的路由配置，但在`AppComponent`的构造函数中注入的`Router`实例上调用了`navigate()`方法。
- en: Listing 3.13\. Using `navigate()`
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.13\. 使用`navigate()`
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Clicking this button invokes the navigateToProductDetail() method.**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 点击此按钮将调用navigateToProductDetail()方法。**'
- en: '***2* Angular will inject the instance of Router into the router variable.**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Angular会将Router实例注入到router变量中。**'
- en: '***3* Navigates to the configured product route programmatically**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 以编程方式导航到配置的产品路由**'
- en: In [listing 3.13](#ch03ex13), the user needs to click a button to go to the
    product route. But the navigation could be implemented without requiring user
    actions—just invoke the `navigate()` method from your application code when necessary.
    For example, you can force the app to navigate to the login route if the user
    isn’t logged in.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表3.13](#ch03ex13)中，用户需要点击按钮才能转到产品路由。但导航可以不要求用户操作实现——只需在需要时从您的应用程序代码中调用`navigate()`方法。例如，您可以强制应用程序导航到登录路由，如果用户未登录。
- en: 'By default the address bar of the browser changes as the user navigates with
    the router. If you don’t want to show the URL of the current route, use the `skipLocationChange`
    directive:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当用户使用路由器导航时，浏览器的地址栏会发生变化。如果您不想显示当前路由的URL，请使用`skipLocationChange`指令：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this case, the URL remains http://localhost:4200/#/ even when the user navigates
    to the `product` route. To achieve the same effect with programmatic navigation,
    use the following syntax:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，即使用户导航到`product`路由，URL仍然保持为http://localhost:4200/#/。为了以编程方式达到相同的效果，请使用以下语法：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Handling 404 errors**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理404错误**'
- en: If the user enters a nonexistent URL in your application, the router won’t be
    able to find a matching route and will print an error message on the browser console,
    leaving the user to wonder why no navigation is happening. Consider creating an
    application component that will be displayed whenever the application can’t find
    the matching component.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户在您的应用程序中输入一个不存在的URL，路由器将无法找到匹配的路由，并在浏览器控制台打印错误消息，让用户困惑为什么没有发生导航。考虑创建一个应用程序组件，该组件将在应用程序无法找到匹配组件时显示。
- en: 'For example, you could create a component named _404Component and configure
    it with the wildcard path `**`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以创建一个名为_404Component的组件，并使用通配符路径`**`进行配置：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The wildcard route configuration has to be the last element in the array of
    routes. The router always treats the wildcard route as a match, so any routes
    listed after the wildcard route won’t be considered.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符路由配置必须是路由数组中的最后一个元素。路由器始终将通配符路由视为匹配，因此通配符路由之后的任何路由都不会被考虑。
- en: '|  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.5\. Passing data to routes
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5. 传递数据到路由
- en: The basic routing application showed how you can display different components
    in the router outlet area, but you often need to also pass some data to the component.
    For example, if the app component shows a list of products and you want to navigate
    to the product-detail route, you need to pass the product ID to the component
    that represents the destination route. In this case, you need to add a parameter
    to the `path` property in the route configuration. In the following listing, you
    change the configuration of the `product` route to indicate that the `ProductDetailComponent`
    has to be rendered when the URL segment includes the value after `'product'` (the
    colon denotes the variable part of the path - `:id`).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 基本路由应用程序展示了如何在路由出口区域显示不同的组件，但您通常还需要向组件传递一些数据。例如，如果应用程序组件显示产品列表，并且您想导航到产品详情路由，您需要将产品ID传递到代表目标路由的组件。在这种情况下，您需要在路由配置中的`path`属性中添加一个参数。在以下列表中，您更改了`product`路由的配置，以指示当URL段包含`'product'`之后的值时（冒号表示路径的变量部分
    - `:id`），必须渲染`ProductDetailComponent`。
- en: Listing 3.14\. `Routes` configuration
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.14. `Routes`配置
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* If the URL contains the fragment product followed by a value, renders
    ProductDetailComponent and passes the value to it**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果URL包含product片段后跟一个值，则渲染ProductDetailComponent并将其值传递给它**'
- en: Accordingly, your app component needs to include the value of the product ID
    in the `routerLink` to ensure that the value of the product ID will be passed
    to the `ProductDetailComponent` if the user chooses to go this route. The new
    version of the app may look like the following listing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您的应用程序组件需要将产品ID的值包含在`routerLink`中，以确保如果用户选择此路由，产品ID的值将被传递到`ProductDetailComponent`。应用程序的新版本可能看起来如下所示。
- en: Listing 3.15\. app.component.ts
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.15. app.component.ts
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* If the user clicks this link, navigates to the product route, passing
    the value of productId**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果用户点击此链接，导航到产品路由，传递productId的值**'
- en: '***2* Sets the value of the productId property**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置productId属性的值**'
- en: The second `routerLink` is bound to the two-element array providing the static
    part of the path /product and the value `/:id` that represents the product ID.
    The elements of the array build up the path specified in the routes configuration
    given to the `RouterModule.forRoot()` method. For the product-detail route, Angular
    will construct the URL segment /product/1234.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`routerLink`绑定到包含路径的静态部分/product和代表产品ID的值`/:id`的两个元素数组。数组元素构建了传递给`RouterModule.forRoot()`方法的路由配置中指定的路径。对于产品详情路由，Angular将构造URL段/product/1234。
- en: 'To see this app in action, run the following command in your Terminal window:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用程序的实际运行情况，请在您的终端窗口中运行以下命令：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 3.5.1\. Extracting parameters from ActivatedRoute
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.1. 从ActivatedRoute中提取参数
- en: If a parent component can pass a parameter to the route, the component that
    represents the destination route should be able to receive it. Instruct Angular
    to inject the instance of `ActivatedRoute` to the constructor of the component
    that represents the destination route. The instance of the `ActivatedRoute` will
    include the passed parameters, as well as the route’s URL segment and other properties.
    The new version of the component, which renders product detail and is capable
    of receiving parameters, will be called `ProductDetailComponent`, which will get
    an object of type `ActivatedRoute` injected into it, as shown in the following
    listing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果父组件可以将参数传递给路由，则表示目标路由的组件应该能够接收它。指示 Angular 将 `ActivatedRoute` 实例注入到表示目标路由的组件的构造函数中。`ActivatedRoute`
    实例将包括传递的参数以及路由的 URL 段和其他属性。新版本的组件，它能够渲染产品详情并接收参数，将被称为 `ProductDetailComponent`，它将获得一个
    `ActivatedRoute` 对象的注入，如下所示。
- en: Listing 3.16\. `ProductDetailComponentParam`
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.16\. `ProductDetailComponentParam`
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Displays the received product ID**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显示接收到的产品 ID**'
- en: '***2* The ActivatedRoute object is injected into the constructor of this component.**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将此组件的构造函数中注入的 ActivatedRoute 对象。**'
- en: '***3* Gets the value of the parameter named id and assigns it to the productID
    class variable, which is used in the template via binding**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 获取名为 id 的参数的值并将其分配给 productID 类变量，该变量通过绑定在模板中使用**'
- en: '[Figure 3.6](#ch03fig06) shows how the product-detail view will be rendered
    in the browser. Note the URL: the router replaced the product/:id path with /product/1234.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.6](#ch03fig06) 展示了产品详情视图在浏览器中的渲染方式。注意 URL：路由将产品/:id 路径替换为 /product/1234。'
- en: Figure 3.6\. The product-detail route received the product ID `1234`.
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.6\. 产品详情路由接收了产品 ID `1234`。
- en: '![](Images/03fig06_alt.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig06_alt.jpg)'
- en: '|  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Passing changing parameters to the route**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**将参数传递给路由**'
- en: In this app, you use the property `snapshot` of type `ActivatedRouteSnapshot`
    to retrieve the parameter’s value. The `snapshot` means “one-time deal,” and this
    property is used in scenarios when the parameters passed to the route never change.
    In your app, it works because the product ID in the parent route never changes
    and is always `1234`. But if you try to change the URL shown in [figure 3.6](#ch03fig06)
    manually (for example, make it /product/12345), the `ProductDetailComponent` won’t
    reflect the change in the parameter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在此应用中，您使用 `ActivatedRouteSnapshot` 类型的 `snapshot` 属性来检索参数的值。`snapshot` 表示“一次性操作”，此属性用于参数传递给路由时永远不会改变的场景。在您的应用中，它之所以有效，是因为父路由中的产品
    ID 永远不会改变，始终是 `1234`。但是，如果您尝试手动更改 [图 3.6](#ch03fig06) 中显示的 URL（例如，将其更改为 /product/12345），则
    `ProductDetailComponent` 不会反映参数的变化。
- en: 'There are scenarios when the parameter value keeps changing after navigating
    to a route. For example, the `AppComponent` renders a list of products, and the
    user can select different products. Both `AppComponent` and `ProductDetailComponent`
    are rendered in the same window. In this case, instead of using the `snapshot`
    property, you need to subscribe to the `ActivatedRoute.paramMap` property, which
    will emit a new value each time the user clicks on a different product, for example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，参数值在导航到路由后仍然会不断变化。例如，`AppComponent` 渲染产品列表，用户可以选择不同的产品。`AppComponent`
    和 `ProductDetailComponent` 都在同一窗口中渲染。在这种情况下，您需要订阅 `ActivatedRoute.paramMap` 属性，而不是使用
    `snapshot` 属性，因为每次用户点击不同的产品时，它都会发出新的值，例如：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You’ll see this example in [chapter 6](kindle_split_015.xhtml#ch06) in [section
    6.6](kindle_split_015.xhtml#ch06lev1sec6).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在 [第 6 章](kindle_split_015.xhtml#ch06) 的 [6.6 节](kindle_split_015.xhtml#ch06lev1sec6)
    中看到此示例。
- en: '|  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Let’s review the steps that Angular performed under the hood to render the
    main page of the application:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 Angular 在渲染应用程序主页面时在幕后执行的步骤：
- en: '**1**.  Check the content of each `routerLink`.'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  检查每个 `routerLink` 的内容。'
- en: '**2**.  Concatenate the values specified in the array. If an array item is
    an expression, evaluate this expression (like `productId`). Finally, append the
    value of `APP_BASE_HREF` in the beginning of the resulting string.'
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  连接数组中指定的值。如果数组项是一个表达式，则评估此表达式（如 `productId`）。最后，将 `APP_BASE_HREF` 的值追加到结果字符串的开头。'
- en: '**3**.  The `RouterLink` directive adds the `href` attribute if this directive
    is attached to an `<a>` element; otherwise, it just listens to the `click` events.'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  `RouterLink` 指令如果附加到 `<a>` 元素上，则会添加 `href` 属性；否则，它只监听 `click` 事件。'
- en: '[Figure 3.7](#ch03fig07) shows a snapshot of the home page of the application
    with the Chrome Developer Tools panel open. Because the `path` property of the
    configured home route had an empty string, Angular didn’t add anything to the
    base URL of the page. But the anchor under the Product Details link has already
    been converted into a regular HTML tag. When the user clicks the Product Details
    link, the router will attach a hash sign and add /product/1234 to the base URL
    so that the absolute URL of the product-detail view will become http://localhost:4200/#/product/1234.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3.7](#ch03fig07)显示了应用程序主页的快照，其中Chrome开发者工具面板已打开。因为配置的主路由的`path`属性为空字符串，所以Angular没有向页面基本URL添加任何内容。但是，产品详情链接下的锚点已经转换为常规HTML标签。当用户点击产品详情链接时，路由器将附加一个哈希符号并将/product/1234添加到基本URL，从而使产品详情视图的绝对URL成为http://localhost:4200/#/product/1234。'
- en: Figure 3.7\. Angular-compiled code in the browser
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.7\. 浏览器中的Angular编译代码
- en: '![](Images/03fig07_alt.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig07_alt.jpg)'
- en: '|  |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In this section, you learned how to pass dynamic data to routes—the data that
    may change during the runtime. Sometimes, you need to pass static data to routes
    (data that doesn’t change). You can pass any arbitrary data to routes by using
    the `data` property in the routes configuration. You’ll see such an example in
    section 4.3.1 in [chapter 4](kindle_split_013.xhtml#ch04).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何将动态数据传递给路由——这些数据可能在运行时发生变化。有时，您需要将静态数据传递给路由（不改变的数据）。您可以通过在路由配置中使用`data`属性将任何任意数据传递给路由。您将在第4章的4.3.1节中看到一个这样的示例。
- en: '|  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Sometimes, you need to pass to a route optional query parameters that are not
    part of the route configuration. Let’s take a look at how to pass query parameters.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要传递给路由可选查询参数，这些参数不是路由配置的一部分。让我们看看如何传递查询参数。
- en: 3.5.2\. Passing query parameters to a route
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.2\. 将查询参数传递给路由
- en: 'You can use query parameters (the URL segment after the question mark), as
    in the following URL: http://localhost:4200/products?category=sports. Query parameters
    aren’t scoped to a particular route, and if you want to pass them while navigating
    with the `routerLink`, you can do as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用查询参数（问号后的URL段），如下面的URL所示：http://localhost:4200/products?category=sports。查询参数不限于特定的路由，如果您想在导航时通过`routerLink`传递它们，您可以这样做：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Because query parameters aren’t scoped to a particular route and can be accessed
    by any active route, the route configuration doesn’t need to include them:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因为查询参数不限于特定的路由，并且可以被任何活动路由访问，所以路由配置不需要包括它们：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To pass query parameters using programmatic navigation, you need to have access
    to the `Router` object. The code could look like the following listing.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用程序化导航传递查询参数，您需要访问`Router`对象。代码可能看起来像以下列表。
- en: Listing 3.17\. Injecting and accessing the `Router` object
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.17\. 注入和访问`Router`对象
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Injects the Router object**'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注入Router对象**'
- en: '***2* Invokes navigate() on the Router object**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在`Router`对象上调用navigate()**'
- en: In this example, you pass an object with one query parameter; but you can specify
    multiple parameters as well.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您传递了一个包含一个查询参数的对象；但您也可以指定多个参数。
- en: To receive query parameters in the destination component, you’ll use the `ActivatedRoute`
    object again.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要在目标组件中接收查询参数，您将再次使用`ActivatedRoute`对象。
- en: Listing 3.18\. Receiving query parameters
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.18\. 接收查询参数
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* Extracts the query param named category**'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 提取名为category的查询参数**'
- en: 'To see this code sample in action, run the following command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此代码示例的实际效果，请运行以下命令：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 3.6\. Child routes
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6\. 子路由
- en: An Angular application is a tree of components that have parent-child relations.
    A child component can have its own routes, but all routes are configured outside
    of any component. Imagine that you want to enable `ProductDetailComponent` (the
    child of the `AppComponent`) to show either the product description or the seller’s
    info. Moreover, there could be more than one seller of the same product, so you’ll
    need to pass the seller ID to show the details of the seller. The following listing
    configures routes for the child, `ProductDetailComponent`, by using the `children`
    property of the `Route`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Angular应用程序是由具有父子关系的组件组成的树。子组件可以有自己的路由，但所有路由都在任何组件之外配置。想象一下，您想启用`ProductDetailComponent`（`AppComponent`的子组件）显示产品描述或卖家信息。此外，同一产品可能有多个卖家，因此您需要传递卖家ID以显示卖家详情。以下列表通过使用`Route`的`children`属性为子路由`ProductDetailComponent`配置路由。
- en: Listing 3.19\. Configuring child routes
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.19\. 配置子路由
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* This property configures routes for ProductDetailComponent.**'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 此属性配置 ProductDetailComponent 的路由。**'
- en: '***2* ProductDescriptionComponent there by default.**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* ProductDescriptionComponent 默认存在。**'
- en: '***3* From ProductDetailComponent, the user can navigate to the SellerInfoComponent.**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 从 ProductDetailComponent，用户可以导航到 SellerInfoComponent。**'
- en: Here, the `children` property is a part of the configuration of the route with
    the path product/:id. You pass the product ID while navigating to the `product`
    route, and then, if the user decides to navigate to the `seller`, you pass the
    seller ID to the `SellerInfoComponent`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`children` 属性是路径为 product/:id 的路由配置的一部分。在导航到 `product` 路由时，您传递产品 ID，然后，如果用户决定导航到
    `seller`，您将卖家 ID 传递给 `SellerInfoComponent`。
- en: '[Figure 3.8](#ch03fig08) shows how the application will look once the user
    clicks the Product Details link on the root component, which renders `ProductDetailComponent`
    (the child), showing `ProductDescriptionComponent` by default, because the latter
    component was configured for the empty `path` property.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.8](#ch03fig08) 展示了用户在根组件上点击产品详情链接后应用程序的外观，这将渲染 `ProductDetailComponent`（子组件），默认显示
    `ProductDescriptionComponent`，因为后者组件被配置为空 `path` 属性。'
- en: Figure 3.8\. The product description route
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.8\. 产品描述路由
- en: '![](Images/03fig08_alt.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig08_alt.jpg)'
- en: '[Figure 3.9](#ch03fig09) shows the application after the user clicks the Product
    Details link and then clicks Seller Info.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.9](#ch03fig09) 展示了用户点击产品详情链接然后点击卖家信息后的应用程序。'
- en: '|  |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re reading the electronic version of this book, you’ll see that the seller’s
    info is shown on a yellow background. We did this intentionally to discuss the
    styling of components a bit later in this chapter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在阅读这本书的电子版，您会看到卖家信息显示在黄色背景上。我们故意这样做是为了稍后在本章中讨论组件的样式。
- en: '|  |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 3.9\. The child route renders `SellerInfo`
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.9\. 子路由渲染 `SellerInfo`
- en: '![](Images/03fig09_alt.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig09_alt.jpg)'
- en: To implement the views shown in [figures 3.8](#ch03fig08) and [3.9](#ch03fig09),
    you’ll modify `ProductDetailComponent` so it also has two children, `SellerInfoComponent`
    and `ProductDescriptionComponent`, and its own `<router-outlet>`. [Figure 3.10](#ch03fig10)
    shows the hierarchy of components that you’re going to implement.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现 [图 3.8](#ch03fig08) 和 [图 3.9](#ch03fig09) 中显示的视图，您需要修改 `ProductDetailComponent`，使其也具有两个子组件
    `SellerInfoComponent` 和 `ProductDescriptionComponent`，以及自己的 `<router-outlet>`。
    [图 3.10](#ch03fig10) 展示了您将要实现的组件层次结构。
- en: Figure 3.10\. The routes hierarchy
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.10\. 路由层次结构
- en: '![](Images/03fig10_alt.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig10_alt.jpg)'
- en: The following three listings show the code of the `ProductDetailComponent`,
    `ProductDescriptionComponent`, and `SellerInfoComponent`. The new version of `ProductDetailComponent`
    has its own outlet, where it can display either `ProductDescriptionComponent`
    (the default) or `SellerInfoComponent`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个列表显示了 `ProductDetailComponent`、`ProductDescriptionComponent` 和 `SellerInfoComponent`
    的代码。`ProductDetailComponent` 的新版本有自己的出口，可以在其中显示 `ProductDescriptionComponent`（默认）或
    `SellerInfoComponent`。
- en: Listing 3.20\. product.detail.component.ts
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.20\. product.detail.component.ts
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* ProductDetailComponent allocates its own router-outlet area for rendering
    its child components one at a time.**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* ProductDetailComponent 为其子组件逐个渲染分配了自己的路由出口区域。**'
- en: '***2* When the user clicks this link, Angular adds the /seller/5678 segment
    to the existing URL and renders SellerInfoComponent.**'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当用户点击此链接时，Angular 将 /seller/5678 段添加到现有 URL 并渲染 SellerInfoComponent。**'
- en: When the user clicks the Product With Children link, and it has children, the
    product/1234 segment is added to the URL. The router finds a match to this path
    in the configuration object and renders the `ProductDetailComponent` in the outlet.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击带有子组件的产品链接时，URL 中会添加 product/1234 段。路由器在配置对象中找到与此路径匹配的内容，并在出口处渲染 `ProductDetailComponent`。
- en: The user navigates to the `ProductDetailComponent`, which by default renders
    the `ProductDescriptionComponent` as per route configuration. Then, the user clicks
    the Seller Info link, and the URL will include the product/1234/seller/5678 segment
    after the hash sign, as shown in [figure 3.11](#ch03fig11).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 用户导航到 `ProductDetailComponent`，默认情况下根据路由配置渲染 `ProductDescriptionComponent`。然后，用户点击卖家信息链接，URL
    将在哈希符号后包含 product/1234/seller/5678 段，如 [图 3.11](#ch03fig11) 所示。
- en: Figure 3.11\. The URL of the seller component
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.11\. 卖家组件的 URL
- en: '![](Images/03fig11_alt.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig11_alt.jpg)'
- en: The router will find a match in the configuration object and will render `SellerInfoComponent`
    in the child’s `<router-outlet>`. The code of the `ProductDescriptionComponent`
    is trivial, as you can see in the following listing.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 路由将在配置对象中找到一个匹配项，并在子组件的 `<router-outlet>` 中渲染 `SellerInfoComponent`。`ProductDescriptionComponent`
    的代码很简单，如下所示。
- en: Listing 3.21\. product.description.component.ts
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.21\. product.description.component.ts
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Because `SellerInfoComponent` expects to receive the seller ID, its constructor
    needs an argument of type `ActivatedRoute` to get the seller ID, as the following
    listing shows, and as you did in `ProductDetailComponent`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `SellerInfoComponent` 期望接收卖家 ID，所以它的构造函数需要一个类型为 `ActivatedRoute` 的参数来获取卖家
    ID，如下所示，就像你在 `ProductDetailComponent` 中做的那样。
- en: Listing 3.22\. seller.info.component.ts
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.22\. seller.info.component.ts
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* A pseudo class :host is used to display the content of this component
    on a yellow background.**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用伪类 :host 在黄色背景上显示此组件的内容。**'
- en: '***2* Injects the Activated-Route object**'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入 Activated-Route 对象**'
- en: '***3* Gets the value of the passed id and assigns it to sellerID for rendering**'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 获取传递的 id 的值并将其分配给 sellerID 以进行渲染**'
- en: 'The `:host` pseudo class selector can be used with elements that are created
    using Shadow DOM (discussed in [section 8.5.1](kindle_split_017.xhtml#ch08lev2sec5)
    in [chapter 8](kindle_split_017.xhtml#ch08)), which provides better encapsulation
    for components. Although not all web browsers support Shadow DOM yet, Angular
    emulates Shadow DOM by default. Here, you use `:host` to apply the yellow background
    color to `SellerInfoComponent`. In the emulated mode, the `:host` selector is
    transformed into a randomly generated, attribute-based selector, like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `:host` 伪类选择器与使用阴影 DOM（在第 8 章第 8.5.1 节中讨论）创建的元素一起使用，这为组件提供了更好的封装。尽管并非所有网络浏览器都支持阴影
    DOM，但 Angular 默认模拟阴影 DOM。在这里，你使用 `:host` 将黄色背景颜色应用到 `SellerInfoComponent`。在模拟模式下，`:host`
    选择器被转换为一个基于属性的随机生成的选择器，如下所示：
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The attribute (here, `ng-host-f23ed`) is attached to the element that represents
    the component. Shadow DOM styles of the components aren’t merged with the styles
    of the global DOM, and the IDs of the components’ HTML tags won’t overlap with
    the IDs of the DOM.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 属性（在此处，`ng-host-f23ed`）附加到表示组件的元素。组件的阴影 DOM 样式不会与全局 DOM 的样式合并，组件的 HTML 标签的 ID
    也不会与 DOM 的 ID 冲突。
- en: 'To run this code sample, enter the following command in the Terminal window
    of the router-samples project:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此代码示例，请在路由-samples 项目的终端窗口中输入以下命令：
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|  |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Deep linking**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**深度链接**'
- en: '*Deep linking* is the ability to create a link to specific content inside a
    web page rather than to the entire page. In the basic routing applications, you’ve
    seen examples of deep linking:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*深度链接* 是创建指向网页内特定内容而不是整个页面的链接的能力。在基本的路由应用程序中，你已经看到了深度链接的例子：'
- en: The URL http://localhost:4200/#/product/1234 links not just to the product-detail
    page but to a specific view representing the product with an ID of `1234`.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL http://localhost:4200/#/product/1234 不仅链接到产品详情页面，还链接到一个表示具有 ID `1234` 的特定产品视图。
- en: The URL http://localhost:4200/#/product/1234/seller/5678 links even deeper.
    It shows the information about the seller with an ID of `5678` that sells the
    product whose ID is `1234`.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL http://localhost:4200/#/product/1234/seller/5678 深入链接。它显示了具有 ID `5678` 的卖家信息，该卖家销售具有
    ID `1234` 的产品。
- en: You can easily see deep linking in action by copying the link http://localhost:4200/#/product/1234/seller/5678
    from the application running in Chrome and pasting it into Firefox or Safari.
    There is a caveat, though. With `PathLocationStrategy`, when you enter the direct
    URL of the route in the browser’s address bar, it still makes a request to the
    server, which won’t find the resource (and rightly so) named as your route. This
    will cause a 404 error. Configure your web server to do a redirect to index.html
    of your app in cases when a requested resource isn’t found. This will put your
    Angular app back in control, and the route will be properly resolved. The Angular
    CLI development server is already configured for redirects.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从在 Chrome 中运行的应用程序复制链接 http://localhost:4200/#/product/1234/seller/5678
    并将其粘贴到 Firefox 或 Safari 中来轻松看到深度链接的实际应用。但是有一个注意事项。使用 `PathLocationStrategy` 时，当你直接在浏览器地址栏中输入路由的直接
    URL，它仍然会向服务器发出请求，服务器找不到名为你的路由的资源（这是正确的）。这将导致 404 错误。当请求的资源未找到时，配置你的 web 服务器将重定向到你的应用程序的
    index.html。这将使你的 Angular 应用程序重新获得控制权，并且路由将被正确解析。Angular CLI 开发服务器已经配置了重定向。
- en: '|  |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Router events**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由事件**'
- en: 'As the user navigates your app, Angular dispatches events, such as `NavigationStart`,
    `NavigationEnd`, and so on. There are about a dozen router events, and you can
    intercept any of them if need be. In [chapter 6](kindle_split_015.xhtml#ch06),
    [section 6.6](kindle_split_015.xhtml#ch06lev1sec6), you’ll see an example of using
    router events to decide when to show and hide the progress bar if the navigation
    is slow. For debugging purposes, you can log router events in the browser’s console
    by using the `enableTracing` option (it works only in the root module):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户导航您的应用程序时，Angular会分发事件，例如`NavigationStart`、`NavigationEnd`等。大约有一打路由事件，如果需要，您可以拦截任何一个。在[第6章](kindle_split_015.xhtml#ch06)的[6.6节](kindle_split_015.xhtml#ch06lev1sec6)中，您将看到一个使用路由事件来决定何时显示和隐藏进度条的示例，如果导航速度慢的话。为了调试目的，您可以使用`enableTracing`选项在浏览器控制台中记录路由事件（它仅在根模块中工作）：
- en: '[PRE33]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|  |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now that you’ve learned router basic features, let’s see how can you apply them
    in your ngAuction application.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学习了路由的基本功能，让我们看看如何在ngAuction应用程序中应用它们。
- en: '3.7\. Hands-on: Adding navigation to the online auction'
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7\. 动手：为在线拍卖添加导航
- en: '|  |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: Source code for this chapter can be found at [https://github.com/Farata/angulartypescript](https://github.com/Farata/angulartypescript)
    and [www.manning.com/books/angular-development-with-typescript-second-edition](http://www.manning.com/books/angular-development-with-typescript-second-edition).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在[https://github.com/Farata/angulartypescript](https://github.com/Farata/angulartypescript)和[www.manning.com/books/angular-development-with-typescript-second-edition](http://www.manning.com/books/angular-development-with-typescript-second-edition)找到。
- en: '|  |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This hands-on exercise starts where we left off in [chapter 2](kindle_split_011.xhtml#ch02).
    So far, you’ve partially implemented the landing page of ngAuction; your goal
    is to render several product items under the carousel component so the landing
    page looks as shown in [figure 3.12](#ch03fig12).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动手练习从我们在[第2章](kindle_split_011.xhtml#ch02)中停止的地方开始。到目前为止，您已经部分实现了ngAuction的着陆页；您的目标是让几个产品项在轮播组件下渲染，使着陆页看起来如图3.12所示。
- en: Figure 3.12\. The landing page of ngAuction with products
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.12\. 带有产品的ngAuction着陆页
- en: '![](Images/03fig12_alt.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig12_alt.jpg)'
- en: The data for this view will be provided by `ProductService`. This hands-on exercise
    contains instructions for injecting the `ProductService` into the `HomeComponent`.
    You’ll also implement the navigation so that when the user clicks the product
    title, the `Router` will render the `ProductDetail` component in the `<router-outlet>`
    area.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此视图的数据将由`ProductService`提供。这个动手练习包含了将`ProductService`注入到`HomeComponent`中的说明。您还将实现导航，以便当用户点击产品标题时，`Router`将在`<router-outlet>`区域渲染`ProductDetail`组件。
- en: Your `ProductService` will contain hardcoded data about the products. Adding
    `ProductService` as an argument to the constructor of `HomeComponent` will instruct
    Angular to instantiate and inject the product object into this component.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`ProductService`将包含关于产品的硬编码数据。将`ProductService`作为`HomeComponent`构造函数的参数将指示Angular实例化和注入产品对象到该组件。
- en: 'As a starting point, you’ll use the project in the chapter3/ngAuction folder,
    which, for the most part, is the same as chapter2/ngAuction with one addition:
    the shared/product.service.ts file contains the code to provide product data.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 作为起点，您将使用位于chapter3/ngAuction文件夹中的项目，该项目大部分与chapter2/ngAuction相同，只是增加了一个：shared/product.service.ts文件包含提供产品数据的代码。
- en: To start working on this exercise, open the chapter3/ngAuction folder in your
    IDE and install the project dependencies by running the `npm install` command.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个练习，请在您的IDE中打开chapter3/ngAuction文件夹，并通过运行`npm install`命令安装项目依赖。
- en: 3.7.1\. ProductService
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.1\. ProductService
- en: '`ProductService` contains hardcoded data about products and the API to retrieve
    them. Let’s review the code in product.service.ts shown in the following listing
    (we removed the majority of the hardcoded data for brevity).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductService`包含关于产品和获取它们的API的硬编码数据。让我们回顾以下列表中所示的product.service.ts中的代码（为了简洁，我们删除了大部分硬编码数据）。'
- en: Listing 3.23\. product.service.ts
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.23\. product.service.ts
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* The Product instances will be returned by the methods of ProductService.**'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 产品实例将通过ProductService的方法返回。**'
- en: '***2* The class ProductService offers an API to get products.**'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* ProductService类提供了一个获取产品的API。**'
- en: '***3* This method returns all hardcoded products.**'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 此方法返回所有硬编码的产品。**'
- en: '***4* This method returns one product based on productId.**'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 此方法根据productId返回一个产品。**'
- en: '***5* An array with hardcoded products**'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 包含硬编码产品的数组**'
- en: Shortly, you’ll be adding the code that will have Angular create an instance
    of the `ProductService` class and inject it into `ProductItemComponent` and `ProductDetailComponent`
    so they can invoke the `getProducts()` and `getProductById()` methods on the service.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你将添加代码，让 Angular 创建 `ProductService` 类的实例，并将其注入到 `ProductItemComponent`
    和 `ProductDetailComponent` 中，以便它们可以在服务上调用 `getProducts()` 和 `getProductById()`
    方法。
- en: 3.7.2\. ProductItemComponent
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.2\. ProductItemComponent
- en: '[Figure 3.13](#ch03fig13) shows six products, each an instance of `ProductItemComponent`.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.13](#ch03fig13) 展示了六个产品，每个都是一个 `ProductItemComponent` 的实例。'
- en: Figure 3.13\. Six instances of `ProductItemComponent`
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.13\. 六个 `ProductItemComponent` 实例
- en: '![](Images/03fig13_alt.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig13_alt.jpg)'
- en: '`ProductItemComponent` knows how to render one product based on the product
    provided by its parent (`HomeComponent`). Modify product-item.component.ts to
    look like the following listing.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductItemComponent` 知道如何根据其父组件（`HomeComponent`）提供的产品渲染一个产品。将 product-item.component.ts
    修改如下所示。'
- en: Listing 3.24\. product-item.component.ts
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.24\. product-item.component.ts
- en: '[PRE35]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* This input property will receive the product from the parent component.**'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 此输入属性将从父组件接收产品。**'
- en: The product to render will be given to `ProductItemComponent` via its property
    `product` decorated with `@Input()`. The `@Input()` properties are described in
    [section 8.2.1](kindle_split_017.xhtml#ch08lev2sec1). in [chapter 8](kindle_split_017.xhtml#ch08).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染的产品将通过 `ProductItemComponent` 的属性 `product`（带有 `@Input()` 装饰器）传递给它。`@Input()`
    属性在 [第 8.2.1 节](kindle_split_017.xhtml#ch08lev2sec1)中描述，位于 [第 8 章](kindle_split_017.xhtml#ch08)。
- en: Modify product-item.component.html with the content shown in the following listing.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下列表中的内容修改 product-item.component.html。
- en: Listing 3.25\. product-item.component.html
  id: totrans-283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.25\. product-item.component.html
- en: '[PRE36]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Applying the currency pipe for formatting**'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 应用货币管道进行格式化**'
- en: '***2* The product title becomes a link to navigate to product details.**'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 产品标题变成了导航到产品详情的链接。**'
- en: '***3* The rating component is commented out and will be added later.**'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 评分组件已被注释并将在以后添加。**'
- en: Note that you bind the product’s `price`, `title`, and `id` properties in the
    component’s template. You also use an Angular built-in pipe, `currency`, for price
    formatting. For now, you’ll keep the `<nga-stars>` component commented out because
    the code of the `StarsComponent` isn’t ready yet. Note that `product.title` is
    a `routerLink` that will navigate to `ProductDetailComponent` when the user clicks
    it. The instance of `ProductItemComponent` will be hosted by `HomeComponent`,
    which you’ll update next.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你将产品的 `price`、`title` 和 `id` 属性绑定到组件的模板中。你还使用了一个 Angular 内置管道，`currency`，来格式化价格。目前，你将
    `<nga-stars>` 组件注释掉，因为 `StarsComponent` 的代码尚未准备好。注意，`product.title` 是一个 `routerLink`，当用户点击它时将导航到
    `ProductDetailComponent`。`ProductItemComponent` 的实例将由 `HomeComponent` 托管，你将在下一部分更新它。
- en: 3.7.3\. HomeComponent
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.3\. HomeComponent
- en: The home component will
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: home 组件将
- en: Use the injected `ProductService` to retrieve all featured products and store
    them in the `products` array.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用注入的 `ProductService` 检索所有特色产品并将它们存储在 `products` 数组中。
- en: Render the `ProductItemComponent` for each product located in the `products`
    array.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `products` 数组中每个找到的产品渲染 `ProductItemComponent`。
- en: In [section 2.7.8](kindle_split_011.xhtml#ch02lev2sec11) in [chapter 2](kindle_split_011.xhtml#ch02),
    you implemented the first version of the `HomeComponent` and added the carousel
    to its template. Now, you need to modify the constructor to inject the `ProductService`
    and retrieve the products in the `ngOnInit()` method. Modify the code in home.component.ts
    to look like the following listing.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2.7.8 节](kindle_split_011.xhtml#ch02lev2sec11)中，位于 [第 2 章](kindle_split_011.xhtml#ch02)，你实现了
    `HomeComponent` 的第一个版本，并将其添加到模板中。现在，你需要修改构造函数以注入 `ProductService` 并在 `ngOnInit()`
    方法中检索产品。将 home.component.ts 中的代码修改如下所示。
- en: Listing 3.26\. home.component.ts
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.26\. home.component.ts
- en: '[PRE37]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* Injecting the ProductService**'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注入 ProductService**'
- en: '***2* Implementing the lifecycle method ngOnInit() that’s invoked after the
    constructor**'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 实现在构造函数之后调用的生命周期方法 ngOnInit()**'
- en: '***3* Using the ProductService to retrieve products**'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 ProductService 检索产品**'
- en: When Angular instantiates `HomeComponent`, it injects the instance of `ProductService`.
    Because you used the `private` qualifier, the generated JavaScript will have an
    instance variable, `productService`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Angular 实例化 `HomeComponent` 时，它会注入 `ProductService` 的实例。因为使用了 `private` 标识符，生成的
    JavaScript 将会有一个实例变量，`productService`。
- en: Angular invokes the component lifecycle method `ngOnInit()` after the constructor,
    and you invoke the `getProducts()` method there. In [section 9.2](kindle_split_018.xhtml#ch09lev1sec2).
    in [chapter 9](kindle_split_018.xhtml#ch09), we’ll discuss the component lifecycle
    methods, and you’ll see why `ngOnInit()` is the right place for fetching data.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 在构造函数之后调用组件生命周期方法 `ngOnInit()`，你将在那里调用 `getProducts()` 方法。在第 9 章的 [9.2
    节](kindle_split_018.xhtml#ch09lev1sec2)中，我们将讨论组件生命周期方法，你将看到为什么 `ngOnInit()` 是获取数据的正确位置。
- en: Modify home.component.html to loop through the array `products` with the structural
    directive `*ngFor` and render each product.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 home.component.html 文件，使用结构指令 `*ngFor` 遍历数组 `products` 并渲染每个产品。
- en: Listing 3.27\. home.component.html
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.27\. home.component.html
- en: '[PRE38]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* The carousel component goes on top.**'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 轮播组件位于顶部。**'
- en: '***2* Iterating through the array products**'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 遍历 products 数组**'
- en: '***3* Allocates four columns of the Bootstrap flexible grid for each component**'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 为每个组件分配 Bootstrap 弹性网格的四列**'
- en: '***4* Rendering the <nga-product-item> component for each product**'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 为每个产品渲染 <nga-product-item> 组件**'
- en: Each product is represented by the same HTML fragment on the web page. Because
    there are multiple products, you need to render the same HTML multiple times.
    The `NgFor` directive is used inside the component template to loop through the
    list of items in the data collection, rendering HTML markup for each item. In
    component templates, `*ngFor` represents the `NgFor` directive.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 每个产品在网页上由相同的 HTML 片段表示。因为有多件产品，所以需要多次渲染相同的 HTML。组件模板内部使用 `NgFor` 指令来遍历数据集合中的项目列表，为每个项目渲染
    HTML 标记。在组件模板中，`*ngFor` 代表 `NgFor` 指令。
- en: 'Because the `*ngFor` directive is located inside a `<div>`, each loop iteration
    will render a `<div>` with the content of the corresponding `<nga-product-item>`
    inside. To pass an instance of a product to `ProductItemComponent`, you use the
    square brackets for property binding:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `*ngFor` 指令位于 `<div>` 内部，每次循环迭代都会渲染一个包含相应 `<nga-product-item>` 内容的 `<div>`。要将产品实例传递给
    `ProductItemComponent`，你使用方括号进行属性绑定：
- en: '[PRE39]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `[product]` on the left refers to the property named `product` inside the
    `<nga-product-item>` component, and `product` on the right is a local template
    variable declared on the fly in the `*ngFor` directive as `let product`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的 `[product]` 指的是 `<nga-product-item>` 组件内部的名为 `product` 的属性，而右侧的 `product`
    是在 `*ngFor` 指令中即时声明的本地模板变量，作为 `let product`。
- en: The Bootstrap’s grid styles `class="col-sm-4 col-lg-4 col-md-4"` instruct the
    browser to split the width of the `<div>` by evenly allocating 4 columns (out
    of 12) to each product on small, large, and medium devices, as shown in [figure
    3.14](#ch03fig14). Try to remove this class, and see how it affects the UI.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 的网格样式 `class="col-sm-4 col-lg-4 col-md-4"` 指示浏览器将 `<div>` 的宽度平均分成
    4 列（12 列中的 4 列），分配给小、大和中等设备上的每个产品，如图 3.14 所示。尝试移除此类，看看它如何影响 UI。
- en: Figure 3.14\. Splitting the `<div>` width using Bootstrap grid
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.14\. 使用 Bootstrap 网格分割 `<div>` 宽度
- en: '![](Images/03fig14_alt.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig14_alt.jpg)'
- en: Run the `ng serve -o` command, and you’ll see six products rendered under the
    carousel, as shown in [figure 3.14](#ch03fig14), except there won’t be any stars
    with product ratings. We’ll take care of the stars next.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `ng serve -o` 命令，你将看到在轮播图中渲染了六个产品，如图 3.14 所示，但产品评分中不会有任何星星。我们将在下一部分处理星星。
- en: 3.7.4\. StarsComponent
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.4\. 星级组件
- en: The `StarsComponent` will render stars to display the product rating, as shown
    in [figure 3.15](#ch03fig15).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`StarsComponent` 将渲染星星以显示产品评分，如图 3.15 所示。'
- en: Figure 3.15\. The `StarsComponent`
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.15\. 星级组件
- en: '![](Images/03fig15.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03fig15.jpg)'
- en: On the landing page of ngAuction, the `StarsComponent` will be a child component
    of `ProductItemComponent`. Eventually, we’ll reuse it in the `ProductDetailComponent`
    as well.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ngAuction 的着陆页上，`StarsComponent` 将是 `ProductItemComponent` 的子组件。最终，我们还会在 `ProductDetailComponent`
    中重用它。
- en: Modify the code of the generated stars.component.ts file to look as follows.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 修改生成的 stars.component.ts 文件的代码，使其看起来如下。
- en: Listing 3.28\. stars.component.ts
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.28\. stars.component.ts
- en: '[PRE40]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* Decorates the property count with @Input (covered in section 8.1.2 in
    [chapter 8](kindle_split_017.xhtml#ch08)) so the parent component can assign its
    value using property binding**'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 @Input 装饰属性 count（在第 8 章的 8.1.2 节中介绍）以便父组件可以使用属性绑定来分配其值**'
- en: '***2* Decorates the property rating with @Input for the same reason**'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 @Input 装饰属性 rating 的原因相同**'
- en: '***3* Each element of this array corresponds to a single star.**'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 此数组的每个元素对应一个单独的星形。**'
- en: '***4* Initializes the stars array with Boolean values based on the rating provided
    by the parent component**'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 根据父组件提供的评分初始化星形数组为布尔值**'
- en: The `count` property specifies the total number of stars to be rendered. If
    the parent component doesn’t provide the value for this input property, five stars
    will be rendered by default. The `StarsComponent` can render more or fewer stars
    if need be. The following listing shows how you can render seven stars.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`属性指定要渲染的星形总数。如果父组件没有提供此输入属性的值，则默认渲染五个星形。如果需要，`StarsComponent`可以渲染更多或更少的星形。以下列表显示了如何渲染七个星形。'
- en: Listing 3.29\. Rendering seven stars
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.29\. 渲染七个星形
- en: '[PRE41]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* Binding 7 to the count input property**'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将7绑定到count输入属性**'
- en: '***2* Binding the product.rating to the rating input property of the <nga-stars>
    component**'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将产品评分绑定到<nga-stars>组件的rating输入属性**'
- en: The elements of the `stars` array with the `false` value represent stars without
    a color, and those with `true` represent stars filled with color. The `rating`
    property stores the average product rating that determines how many stars should
    be filled with color and how many should remain empty.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`stars`数组中具有`false`值的元素表示没有颜色的星形，而具有`true`值的元素表示填充颜色的星形。`rating`属性存储平均产品评分，该评分确定应该填充颜色的星形数量以及应该保持空白的星形数量。'
- en: 'The Bootstrap 4 framework doesn’t include images that render stars. There are
    several popular libraries of icon fonts out there (Material Design Icons, Font
    Awesome, Octicons, and so on); we’ll use Material Design Icons. To keep them local
    in the project, install these icons as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap 4框架不包含渲染星形的图像。有多个流行的图标字体库（Material Design Icons、Font Awesome、Octicons等）；我们将使用Material
    Design Icons。为了在项目中本地化它们，按照以下方式安装这些图标：
- en: '[PRE42]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Then add these fonts to the `styles` section of the .angular-cli.json file so
    it looks like the following listing.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将这些字体添加到`.angular-cli.json`文件的`styles`部分，如下所示列表。
- en: Listing 3.30\. Styles section of .angular-cli.json
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.30\. .angular-cli.json的样式部分
- en: '[PRE43]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* Adding Material Design Icons**'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加Material Design图标**'
- en: Modify the content of stars.component.html to look like the following listing.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 修改stars.component.html的内容，使其看起来如下所示列表。
- en: Listing 3.31\. stars.component.html
  id: totrans-341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.31\. stars.component.html
- en: '[PRE44]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1* Iterates through the Boolean array stars and applies either the filled
    or empty star**'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 遍历布尔数组stars并应用填充或空白的星形**'
- en: '***2* Uses the material-icons style**'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用material-icons样式**'
- en: '***3* A Material Design star filled with color is called star_rate.**'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 填充颜色的Material Design星形称为star_rate。**'
- en: '***4* An empty star style is called star_border.**'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 一个空的星形样式称为star_border。**'
- en: Note how you bind either one CSS class or another (double curly brackets). To
    style the star icon, add the following styles to stars.component.css.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你如何绑定一个或另一个CSS类（使用双大括号）。为了样式化星形图标，将以下样式添加到stars.component.css文件中。
- en: Listing 3.32\. stars.component.css
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.32\. stars.component.css
- en: '[PRE45]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* Styles the star icon**'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 样式化星形图标**'
- en: The `ProductItemComponent` will be the parent of the `StarsComponent`. To make
    it a child of the `ProductItemComponent`, uncomment the `<div>` in the product-item.component.html
    file created earlier.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductItemComponent`将是`StarsComponent`的父组件。为了使其成为`ProductItemComponent`的子组件，取消注释之前创建的product-item.component.html文件中的`<div>`。'
- en: Listing 3.33\. Adding a <div> with the <nga-stars> component
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.33\. 添加带有<nga-stars>组件的<div>
- en: '[PRE46]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Makes the stars dark red (see the CSS in the next listing)**'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将星形设置为深红色（请参阅下一列表中的CSS）**'
- en: '***2* Binding the product.rating to the input property of the <nga-stars> component**'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将产品评分绑定到<nga-stars>组件的输入属性**'
- en: The CSS selector `ratings` will be defined in the product-item.component.css
    file. You’ll make the stars dark red and add some padding by using the following
    listing’s style in the product-item.component.css file.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: CSS选择器`ratings`将在product-item.component.css文件中定义。您将使用以下列表中的样式在product-item.component.css文件中将星形设置为深红色并添加一些填充。
- en: Listing 3.34\. product-item.component.css
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.34\. product-item.component.css
- en: '[PRE47]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Setting the color to dark red**'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置颜色为深红色**'
- en: '***2* Ensures that images won’t overlap each other**'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 确保图像不会相互重叠**'
- en: You add this style to the parent of `StarsComponent` to be able to pick different
    star colors in the child component if need be. If another component will need
    to render stars, you can choose another color there. Now your `ProductItemComponent`
    renders ratings for each child product, as shown in [figure 3.14](#ch03fig14).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您将此样式添加到 `StarsComponent` 的父组件中，以便在子组件中需要时选择不同的星级颜色。如果另一个组件需要渲染星级，您可以在那里选择另一种颜色。现在您的
    `ProductItemComponent` 为每个子产品渲染评分，如图 3.14 所示。
- en: It’s time to implement navigation with the `Router`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候使用 `Router` 实现导航了。
- en: 3.7.5\. ProductDetailComponent
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.5\. ProductDetailComponent
- en: In [chapter 2](kindle_split_011.xhtml#ch02), you generated the routing module,
    but it has only one configured route, which renders `HomeComponent`, as you can
    see in the following listing.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 章](kindle_split_011.xhtml#ch02) 中，您生成了路由模块，但它只有一个配置的路由，如您在以下列表中看到的，它渲染
    `HomeComponent`。
- en: Listing 3.35\. app-routing.module.ts
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.35\. app-routing.module.ts
- en: '[PRE48]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* Configuring a default route**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 配置默认路由**'
- en: '***2* Creating a router module and service for the app root module**'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为应用程序根模块创建一个路由模块和服务**'
- en: '***3* Reexporting the RouterModule so other modules can access it**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 重新导出 RouterModule，以便其他模块可以访问它**'
- en: You want to add another route so that when the user clicks on the product title
    in the `ProductItemComponent`, the `Router` replaces `HomeComponent` with `ProductDetailComponent`.
    During this navigation, you want to pass the ID of the selected product to `ProductDetailComponent`.
    Modify the routes configuration to look like the following listing, and don’t
    forget to import `ProductDetailComponent`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 您想添加另一个路由，以便当用户在 `ProductItemComponent` 中点击产品标题时，`Router` 将 `HomeComponent`
    替换为 `ProductDetailComponent`。在此导航过程中，您想将所选产品的 ID 传递给 `ProductDetailComponent`。修改路由配置，使其看起来如下所示，并且不要忘记导入
    `ProductDetailComponent`。
- en: Listing 3.36\. Configuring a second route
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.36\. 配置第二个路由
- en: '[PRE49]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1* Configuring a route for the URL fragments, like products/123**'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 配置 URL 片段的路由，如 products/123**'
- en: The `ProductDetailComponent` will receive the selected product ID from the parent
    via the injected `ActivatedRoute` and then make a request to `ProductService`
    to retrieve product details. Because `ProductDetailComponent` will reuse the instance
    of `ProductService` that Angular created for you on app startup, add this service
    to the constructor’s arguments. Modify the code in product-detail.component.ts
    to look like the following listing.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductDetailComponent` 将通过注入的 `ActivatedRoute` 从父组件接收所选产品 ID，然后向 `ProductService`
    发送请求以检索产品详情。由于 `ProductDetailComponent` 将重用 Angular 在应用程序启动时为您创建的 `ProductService`
    实例，因此将此服务添加到构造函数的参数中。修改 `product-detail.component.ts` 中的代码，使其看起来如下所示。'
- en: Listing 3.37\. product-detail.component.ts
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.37\. product-detail.component.ts
- en: '[PRE50]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1* Both ActivatedRoute and ProductService are injected into the constructor.**'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 同时将 ActivatedRoute 和 ProductService 注入到构造函数中。**'
- en: '***2* Extracts the parameter productId from the ActivatedRoute**'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从 ActivatedRoute 中提取 productId 参数**'
- en: '***3* Invokes getProductById() on the service, providing prodId as an argument**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在服务上调用 getProductById()，并提供 prodId 作为参数**'
- en: The values of the properties of the instance variable `product` will be bound
    to the component template and rendered by the browser. The template of `ProductDetailComponent`
    will contain the product image (a gray rectangle) with product price, title, and
    description.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量 `product` 的属性值将被绑定到组件模板，并由浏览器渲染。`ProductDetailComponent` 的模板将包含产品图片（一个灰色矩形）、产品价格、标题和描述。
- en: Modify the content of product-detail.component.html to look like the following
    listing.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `product-detail.component.html` 的内容，使其看起来如下所示。
- en: Listing 3.38\. product-detail.component.html
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.38\. product-detail.component.html
- en: '[PRE51]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* Renders the product price on the right**'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在右侧渲染产品价格**'
- en: '***2* Renders the product title**'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 渲染产品标题**'
- en: '***3* Renders the product description**'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 渲染产品描述**'
- en: '***4* Uses the class ratings to render stars in the dark red color**'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用类 ratings 以深红色渲染星级**'
- en: '***5* Renders the StarsComponent with binding on the product rating to the
    component’s property rating**'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用绑定到组件属性 rating 的产品评分渲染 StarsComponent**'
- en: '`ProductDetailComponent` also uses `<nga-stars>`. For a change, let’s paint
    the stars dark green by adding the following listing’s style in product-detail.component.css.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductDetailComponent` 也使用了 `<nga-stars>`。为了改变一下，让我们在 `product-detail.component.css`
    中添加以下列表的样式。'
- en: Listing 3.39\. product-detail.component.css
  id: totrans-390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.39\. product-detail.component.css
- en: '[PRE52]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* Sets the star color to dark green**'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将星级设置为深绿色**'
- en: Run the app with `ng serve -o`—the navigation to the product-detail view will
    work. Click the title of the first product, and the `Router` will create an instance
    of the `ProductDetailComponent`. The browser will show the product details, as
    shown in [figure 3.16](#ch03fig16).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ng serve -o` 运行应用——导航到产品详情视图将正常工作。点击第一个产品的标题，`Router` 将创建一个 `ProductDetailComponent`
    的实例。浏览器将显示产品详情，如图 [3.16](#ch03fig16) 所示。
- en: Figure 3.16\. Rendering product details
  id: totrans-394
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.16\. 渲染产品详情
- en: '![](Images/03fig16_alt.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.16](Images/03fig16_alt.jpg)'
- en: Run this app with `ng serve -o` to see the landing page of ngAuction. Note that
    in the product-detail view, the stars are shown in the dark green color, whereas
    on the landing page, they’re dark red.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ng serve -o` 运行此应用以查看 ngAuction 的着陆页。请注意，在产品详情视图中，星星显示为深绿色，而在着陆页上，它们是深红色。
- en: Summary
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: You can configure routes in parent and child components.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在父组件和子组件中配置路由。
- en: You can pass data to routes during navigation.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在导航过程中向路由传递数据。
- en: During navigation, the router renders components in the area defined by the
    `<router-outlet>` tag.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导航过程中，路由器在由 `<router-outlet>` 标签定义的区域渲染组件。
