- en: Chapter 4\. Component-testing microservices
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四章\. 组件测试微服务
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Introducing the Arquillian testing framework
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Arquillian 测试框架
- en: Working with Arquillian extensions for RESTful web services and Spring
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Arquillian 扩展进行 RESTful Web 服务和 Spring 的开发
- en: Testing resource, domain, and remote components
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试资源、领域和远程组件
- en: You’ve learned about the basic component makeup of a microservice and various
    basic testing techniques. Now it’s time to dig a little deeper into what style
    of test best suits each component, and how you should implement those tests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了微服务的基本组件构成和各种基本测试技术。现在，是时候深入探讨哪种测试风格最适合每个组件，以及你应该如何实现这些测试了。
- en: 'Component tests should be designed to verify the functionality of and between
    a microservice’s internal modules, with one exception: the external public-facing
    resource component. You want to be sure the public-facing service is accessible
    to the world in the way that you’ve planned, so you’ll need to define a client-based
    test that ensures this is the case. A component test shouldn’t cross a remote
    boundary outside the local machine.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 组件测试应该设计为验证微服务内部模块的功能以及它们之间的功能，但有一个例外：外部面向公众的资源组件。你想要确保面向公众的服务以你计划的方式对世界开放，因此你需要定义一个基于客户端的测试来确保这一点。组件测试不应该跨越本地机器之外的远程边界。
- en: You need a good mixture of solitary and sociable tests to cover all the internal
    interactions of the microservice under test. Tests should use doubles to replace
    interactions that would normally collaborate with external resources.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要良好的独立和社交测试混合，以覆盖正在测试的微服务的所有内部交互。测试应使用替身来替换通常与外部资源协作的交互。
- en: 'We’re sure that at some point you’ve written a test to be sure a piece of code
    is correct, only to later deploy that code to the staging or production environment
    and have it fail. That’s happened to all of us! It usually has to do with something
    in the production environment that wasn’t apparent at the development stage. Testing
    components in what we call a *production-near* environment ensures that they react
    the way you expect. We’ll focus on this scenario next: developing production-near
    testing using the Arquillian test framework.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确信在某个时刻，你曾编写过一个测试来确保一段代码的正确性，但后来在部署到预发布或生产环境时，代码却失败了。这种情况我们都遇到过！通常这与生产环境中在开发阶段不明显的问题有关。在所谓的*生产近环境*中测试组件可以确保它们以你期望的方式反应。接下来，我们将关注这个场景：使用
    Arquillian 测试框架开发生产近测试。
- en: 4.1\. The Arquillian test framework
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. Arquillian 测试框架
- en: Arquillian was originally created for testing applications that run in a Java
    EE container such as Apache TomEE, JBoss AS, IBM Liberty Profile, Payara, Red
    Hat WildFly, and many more. The framework has evolved since then to encompass
    not only Java EE, but also Spring and Docker environments. You can find the full
    history on the Arquillian website at [www.arquillian.org](http://www.arquillian.org).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian 最初是为测试在 Java EE 容器中运行的应用程序而创建的，例如 Apache TomEE、JBoss AS、IBM Liberty
    Profile、Payara、Red Hat WildFly 以及许多其他容器。自那时起，该框架已经发展，不仅包括 Java EE，还包括 Spring 和
    Docker 环境。你可以在 Arquillian 网站上找到完整的历史记录：[www.arquillian.org](http://www.arquillian.org)。
- en: '|  |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Even though we can often be found evangelizing about Arquillian online or at
    conferences, we don’t want you to think we’re promoting this framework because
    we’re being sponsored. We’re promoting it because we have, over several years,
    found it to be the best-of-breed tool for solving many of our personal testing
    challenges. We hope you’ll enjoy learning about it and using it as much as we
    do.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们经常在网上或会议上宣传 Arquillian，但我们不希望你认为我们推广这个框架是因为我们得到了赞助。我们推广它是因为在过去的几年里，我们发现它是我们解决许多个人测试挑战的最佳工具。我们希望你会像我们一样享受学习和使用它。
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Arquillian is a framework that can be used for all kinds of software testing.
    When it comes to testing microservices, Java EE, or Spring Boot, the Arquillian
    test framework is the best thing since sliced bread. It’s important to find a
    tool that doesn’t tie you to a specific product or implementation. If there’s
    one thing we know in software engineering, it’s that things change. Arquillian
    has been designed from the ground up to be as flexible as possible with regard
    to change, but as simple as possible to use.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian 是一个可以用于各种软件测试的框架。当涉及到测试微服务、Java EE 或 Spring Boot 时，Arquillian 测试框架是自切片面包以来最好的东西。找到不将你绑定到特定产品或实现的工具很重要。如果我们知道软件工程中的任何事情，那就是事情会变化。Arquillian
    从一开始就被设计成在变化方面尽可能灵活，但在使用上尽可能简单。
- en: The framework can be expanded to meet new demands by using extensions. Thus
    it can incorporate many other well-known testing components such as Mockito and
    PowerMock. It doesn’t try to compete with these technologies, but rather incorporates
    their use in a standardized lifecycle.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用扩展，框架可以扩展以满足新的需求。因此，它可以整合许多其他知名的测试组件，如 Mockito 和 PowerMock。它并不试图与这些技术竞争，而是将它们的使用纳入标准化的生命周期中。
- en: You already understand unit testing and the `@Test` annotation, so it would
    be a step in the wrong direction to try to introduce a completely new concept.
    Arquillian takes what you already know and enriches this common knowledge with
    new features. As a result, you can be up and running in a few hours, if not minutes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经理解了单元测试和`@Test`注解，因此尝试引入一个全新的概念将是错误的方向。Arquillian 将你已知的知识融入其中，并利用新特性丰富了这种共同知识。因此，如果你不是在几分钟内，你可以在几小时内开始运行。
- en: Before we look at a real test, you should understand the Arquillian test lifecycle.
    The test itself will look trivial, but under the hood there’s a lot going on.
    It’s not essential that you know exactly how it all works, but having a basic
    understanding may help you in the future if you run into issues. The diagrams
    in [figures 4.1](kindle_split_013_split_001.xhtml#ch04fig01) through [4.6](kindle_split_013_split_001.xhtml#ch04fig06)
    outline the basic Arquillian automated lifecycle.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看真实测试之前，你应该了解 Arquillian 测试生命周期。测试本身可能看起来很简单，但在底层有很多事情在进行。你不需要确切地知道它是如何工作的，但如果你遇到问题，基本的理解可能会在将来帮助你。图
    4.1（kindle_split_013_split_001.xhtml#ch04fig01）至图 4.6（kindle_split_013_split_001.xhtml#ch04fig06）中的图表概述了基本的
    Arquillian 自动化生命周期。
- en: Figure 4.1\. Selecting the test container
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.1\. 选择测试容器
- en: '![](Images/04fig01_alt.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig01_alt.jpg)'
- en: '|  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: For all intents and purposes, *container* is another word for your application
    server of choice. Whenever you see the word *container*, just think *application
    server*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从所有目的和意义上讲，*容器*是你选择的应用服务器的另一个名称。无论何时你看到“容器”这个词，只需想到“应用服务器”。
- en: '|  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: As previously mentioned, we’re not going to tie you down to a specific container.
    The first phase is to select the container that will be used for the current test
    ([figure 4.1](kindle_split_013_split_001.xhtml#ch04fig01)). You can run tests
    against several containers at the same time, as we’ll discuss in [chapter 5](kindle_split_014_split_000.xhtml#ch05).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们不会将你限制在特定的容器上。第一阶段是选择用于当前测试的容器（[图 4.1](kindle_split_013_split_001.xhtml#ch04fig01)）。你可以同时针对多个容器运行测试，正如我们将在[第
    5 章](kindle_split_014_split_000.xhtml#ch05)中讨论的那样。
- en: Either the selected container is started by Arquillian, or you can connect to
    an existing container ([figure 4.2](kindle_split_013_split_001.xhtml#ch04fig02)).
    Connecting to a running container means the test can avoid the startup cost of
    the container. This will be covered later in this chapter, in [section 4.6.1](kindle_split_013_split_006.xhtml#ch04lev2sec9).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要么由 Arquillian 启动选定的容器，要么你可以连接到现有的容器（[图 4.2](kindle_split_013_split_001.xhtml#ch04fig02)）。连接到正在运行的容器意味着测试可以避免容器的启动成本。这一点将在本章后面的[4.6.1
    节](kindle_split_013_split_006.xhtml#ch04lev2sec9)中详细说明。
- en: Figure 4.2\. Activating the container environment
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.2\. 激活容器环境
- en: '![](Images/04fig02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig02.jpg)'
- en: The classes under test need to be deployed to the container in some way. Arquillian
    knows how to take your test classes and deploy them to the selected container
    to run the tests. The complexity of this task is hidden by the framework. You
    can use an extremely powerful tool called *ShrinkWrap* to package your test application
    as the container expects ([figure 4.3](kindle_split_013_split_001.xhtml#ch04fig03)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将测试类以某种方式部署到容器中。Arquillian 知道如何将你的测试类部署到选定的容器中运行测试。这个任务的复杂性被框架隐藏了。你可以使用一个名为
    *ShrinkWrap* 的极其强大的工具来打包你的测试应用程序，使其符合容器的期望（[图 4.3](kindle_split_013_split_001.xhtml#ch04fig03)）。
- en: Figure 4.3\. Packaging the test application using ShrinkWrap, and deploying
    to the container
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.3\. 使用 ShrinkWrap 打包测试应用程序并将其部署到容器
- en: '![](Images/04fig03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig03.jpg)'
- en: Once ShrinkWrap has packaged your test and deployed it, the tests are run against
    the container ([figure 4.4](kindle_split_013_split_001.xhtml#ch04fig04)). Many
    elements belonging to the test environment are proxied and can be accessed from
    a local context using CDI. You’ll see this extremely powerful feature in action
    shortly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 ShrinkWrap 打包并部署了你的测试，测试就会在容器上运行（[图 4.4](kindle_split_013_split_001.xhtml#ch04fig04)）。测试环境中属于许多元素的内容都会被代理，并且可以使用
    CDI 从本地上下文中访问。你很快就会看到这个极其强大的功能是如何发挥作用的。
- en: Figure 4.4\. The deployed test application runs in the container.
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.4\. 部署的测试应用程序在容器中运行。
- en: '![](Images/04fig04.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig04.jpg)'
- en: As the tests run, the results need to be captured and collected. Again, the
    framework hides this complexity from you and works hand in hand with the common
    unit test you’re familiar with already. The IDE or build environment displays
    the results in the exact same fashion as a normal test ([figure 4.5](kindle_split_013_split_001.xhtml#ch04fig05)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试运行过程中，需要捕获和收集结果。同样，框架会隐藏这种复杂性，并与你熟悉的常见单元测试紧密协作。IDE 或构建环境会以与正常测试完全相同的方式显示结果（[图
    4.5](kindle_split_013_split_001.xhtml#ch04fig05)）。
- en: Figure 4.5\. Capturing the results and returning them to the test environment
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.5\. 捕获结果并将其返回到测试环境
- en: '![](Images/04fig05.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig05.jpg)'
- en: Once all the tests are complete, the resources used throughout the test cycle
    are disposed of safely ([figure 4.6](kindle_split_013_split_001.xhtml#ch04fig06)).
    This may include shutting down the application server, databases, and other remote
    connections used during the test.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有测试完成，整个测试周期中使用的资源都会被安全地处置（[图 4.6](kindle_split_013_split_001.xhtml#ch04fig06)）。这可能包括关闭应用程序服务器、数据库和其他在测试期间使用的远程连接。
- en: Figure 4.6\. Cleaning up resources and shutting down the container
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.6\. 清理资源和关闭容器
- en: '![](Images/04fig06.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04fig06.jpg)'
- en: '|  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: If the container is started by Arquillian and a test suffers a catastrophic
    failure, be aware that the server may be left running as a dangling process. This
    usually manifests itself as a port conflict on the next test run. If this happens,
    you’ll need to locate the errant container process and terminate it manually.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器由 Arquillian 启动并且测试发生灾难性故障，请注意服务器可能作为悬挂进程继续运行。这通常表现为下一次测试运行时的端口冲突。如果发生这种情况，你需要找到错误的容器进程并将其手动终止。
- en: '|  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.2\. Introducing the @RunWith(Arquillian.class) annotation
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2\. 介绍 @RunWith(Arquillian.class) 注解
- en: 'We’ll introduce several concepts in this chapter, because they go hand in hand:
    *build-script* dependencies, the `@RunWith(Arquillian.class)` annotation, and
    the *arquillian.xml* configuration file. For now, keep in mind that although the
    Arquillian configuration file is optional to the test, you may eventually need
    to customize the internally configured default settings. This will become clear
    after you read this chapter; don’t worry just yet about how the container is configured
    or what build-script modifications are required.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍几个相互关联的概念：*构建脚本*依赖项、`@RunWith(Arquillian.class)` 注解和 *arquillian.xml*
    配置文件。目前，请记住，尽管 Arquillian 配置文件对于测试是可选的，但你最终可能需要自定义内部配置的默认设置。阅读本章后，这会变得清晰；现在不必担心容器是如何配置的或需要哪些构建脚本修改。
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, we left the `imports` in place so you can see the relevant
    namespaces. In later examples, we omit most of these for the sake of brevity.
    All the source code for the demo application is available with the book as a reference;
    see [www.manning.com/books/testing-java-microservices](http://www.manning.com/books/testing-java-microservices).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们保留了 `imports` 以便你可以看到相关的命名空间。在后续的例子中，为了简洁起见，我们省略了这些内容的大部分。所有演示应用程序的源代码都随书提供作为参考；请参阅
    [www.manning.com/books/testing-java-microservices](http://www.manning.com/books/testing-java-microservices)。
- en: '|  |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The following listing shows a simple Arquillian test (code/game/src/test/java/book/games/arquillian/ArquillianBasicTest.java).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个简单的 Arquillian 测试（code/game/src/test/java/book/games/arquillian/ArquillianBasicTest.java）。
- en: Listing 4.1\. Arquillian test
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1\. Arquillian 测试
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Defines this as an Arquillian test**'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将此定义为 Arquillian 测试**'
- en: '***2* Defines the deployment**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义部署**'
- en: '***3* Builds an application archive**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 构建应用程序存档**'
- en: '***4* Adds test-persistence.xml to enable JPA**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 添加 test-persistence.xml 以启用 JPA**'
- en: '***5* Generates and adds a beans.xml file to switch on CDI**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 生成并添加 beans.xml 文件以启用 CDI**'
- en: '***6* Injects the runtime instance of the GamesService bean into the test class**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将 GamesService bean 的运行时实例注入到测试类中**'
- en: '***7* Injects the transaction-aware Games EJB instance into the test class**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 在运行时将事务感知的 Games EJB 实例注入到测试类中**'
- en: '***8* Injects the runtime JPA EntityManager instance into the test class at
    runtime**'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 在运行时将运行时 JPA EntityManager 实例注入到测试类中**'
- en: '***9* Indicates that the method is a test**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 指示该方法是一个测试**'
- en: '***10* Asserts to demonstrate that the injections worked**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 断言以证明注入已成功**'
- en: 'Let’s go through all the elements required to build up this Arquillian test.
    The following steps correspond to the annotations in [listing 4.1](kindle_split_013_split_002.xhtml#ch04ex01):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一了解构建这个 Arquillian 测试所需的所有元素。以下步骤对应于[列表 4.1](kindle_split_013_split_002.xhtml#ch04ex01)中的注解：
- en: '**1**.  You define this test class as an Arquillian test and inform JUnit that
    there’s some wiring to do before any test runs.'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 你将这个测试类定义为 Arquillian 测试，并通知 JUnit 在任何测试运行之前有一些连接要做。'
- en: '**2**.  @Deployment defines a deployment of everything you need for the test
    to run in the container. This is the shrink-wrapped application to be physically
    deployed to the container. The defining method must be static.'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. @Deployment 定义了测试运行在容器中所需的所有内容的部署。这是要物理部署到容器的 shrink-wrapped 应用程序。定义方法必须是静态的。'
- en: '**3**.  Build an application archive using ShrinkWrap. This may look a little
    confusing, but [section 4.3](kindle_split_013_split_003.xhtml#ch04lev1sec3) discusses
    how to use ShrinkWrap to build a deployment archive. Here, you’re building a WAR
    file, so ignore the comments. You add only the classes that make up the test;
    the application may be much larger.'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 使用 ShrinkWrap 构建应用程序存档。这可能会有些令人困惑，但[第 4.3 节](kindle_split_013_split_003.xhtml#ch04lev1sec3)讨论了如何使用
    ShrinkWrap 构建部署存档。在这里，你正在构建一个 WAR 文件，所以忽略注释。你只需添加构成测试的类；应用程序可能要大得多。'
- en: '**4**.  Add a copy of test-persistence.xml to the application under the META-INF
    directory, to enable JPA. test-persistence.xml resides in the project’s test/resources
    directory. It will be copied to the automatically created directory and renamed
    persistence.xml. Your tests may not require persistence, but it’s easy to add
    resources here.'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 在应用程序的 META-INF 目录下添加 test-persistence.xml 的副本以启用 JPA。test-persistence.xml
    位于项目的 test/resources 目录中。它将被复制到自动创建的目录并重命名为 persistence.xml。你的测试可能不需要持久化，但在这里添加资源很容易。'
- en: '**5**.  Generate and add an empty beans.xml file to the archive WEB-INF directory
    to switch on CDI (contexts and dependency injection—EE6). EmptyAsset.INSTANCE
    tells ShrinkWrap to create an empty file, but in step 4 you saw how you can add
    a local file.'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**. 在存档 WEB-INF 目录中生成并添加一个空的 beans.xml 文件以启用 CDI（上下文和依赖注入—EE6）。EmptyAsset.INSTANCE
    告诉 ShrinkWrap 创建一个空文件，但在步骤 4 中你看到了如何添加本地文件。'
- en: '**6**.  Inject the runtime instance of the GamesService bean via CDI into the
    test class when JUnit runs the test. You can call this instance from within the
    test environment just as you would from your application. How cool is that? This
    is where you get your first taste of how powerful the Arquillian framework is.'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**6**. 当 JUnit 运行测试时，通过 CDI 将 GamesService bean 的运行时实例注入到测试类中。你可以在测试环境中调用这个实例，就像你从应用程序中调用一样。这有多酷？这就是你第一次尝到
    Arquillian 框架有多强大的味道。'
- en: '**7**.  Inject the transaction-aware Games EJB instance into the test class
    at runtime. Similar to CDI, injecting container-hosted EJBs directly into the
    test class gives you full access to the runtime bean.'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**7**. 在运行时将事务感知的Games EJB实例注入到测试类中。类似于CDI，直接将容器托管的EJB注入到测试类中，可以让你完全访问运行时bean。'
- en: '**8**.  Inject the runtime JPA `EntityManager` instance into the test class
    at runtime. This example allows direct access to the application persistence layer
    from within the test.'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**8**. 在运行时将JPA `EntityManager`实例注入到测试类中。此示例允许在测试中直接访问应用程序持久层。'
- en: '**9**.  The usual @Test annotation denotes that the method is to be a test.
    Several of the previous steps are obviously optional, such as CDI and JPA, and
    are provided to demonstrate some of what to expect from Arquillian.'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**9**. 常规的`@Test`注解表示该方法是一个测试。前几个步骤显然是可选的，例如CDI和JPA，并提供了一些从Arquillian可以期待的内容的示例。'
- en: '**10**.  Simple asserts demonstrate that the injections worked.'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**10**. 简单的断言证明了注入是有效的。'
- en: Imagine how thorough your microservice tests can now be in a few lines of code.
    As you can see, adding the `@RunWith(Arquillian.class)`, `@Deployment`, and `@Test`
    annotations creates a very empowered test environment.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，现在在几行代码中，你的微服务测试可以多么彻底。正如你所见，添加`@RunWith(Arquillian.class)`、`@Deployment`和`@Test`注解创建了一个非常强大的测试环境。
- en: Even if your application is a microservice, it’s fair to say that the deployment
    is unlikely to consist of only a few classes. In this basic test, you add classes
    individually—and that would be tedious in a larger application. The next section
    delves into the power of ShrinkWrap; it will enable you to add literally anything
    you’re ever likely to need in your archive—and more!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的应用程序是一个微服务，可以说部署不太可能只包含几个类。在这个基本测试中，你单独添加类——在一个更大的应用程序中这将很繁琐。下一节将深入探讨ShrinkWrap的强大功能；它将使你能够添加你归档中可能需要的任何东西——甚至更多！
- en: 4.3\. The ShrinkWrap utility class
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3. ShrinkWrap实用工具类
- en: Like many components in the Arquillian universe, ShrinkWrap evolved from a basic
    need into a powerful tool in its own right. Early in the development of Arquillian,
    it became obvious that a tool was required to build a Java archive containing
    all the desired dependencies for the test, and also a means to deploy that archive
    to the application server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与Arquillian宇宙中的许多组件一样，ShrinkWrap从基本需求发展成为一个强大的工具。在Arquillian的开发初期，很明显需要一个工具来构建包含所有所需依赖项的Java归档，并且还需要一种将归档部署到应用服务器的手段。
- en: Relying on the build process for the application wouldn’t work. The build process
    could be slow, the resulting deployable archive could be large, and integration
    with each possible build process would be exceptionally difficult, if not impossible.
    Arquillian needed something easier, faster, and more isolated. ShrinkWrap achieves
    this by being the manager of a virtual filesystem that can export as a Java archive.
    All the possible entry types of that archive are modeled and exposed to you, so
    you can build up any type of archive containing anything you need for the test.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于应用程序的构建过程是不可行的。构建过程可能很慢，生成的可部署归档可能很大，并且与每个可能的构建过程集成将非常困难，如果不是不可能的。Arquillian需要更简单、更快、更隔离的东西。ShrinkWrap通过管理一个可以导出为Java归档的虚拟文件系统来实现这一点。该归档的所有可能的条目类型都被建模并暴露给你，因此你可以构建包含任何测试所需内容的任何类型的归档。
- en: We’re sure you’re familiar with the various archive formats common to web deployments,
    including Java archive (JAR), web archive (WAR), enterprise archive (EAR), and
    Roshal archive (RAR) files. ShrinkWrap understands these formats exceptionally
    well, but it can build *any* zip-based archive.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相信你对常见的网络部署归档格式很熟悉，包括Java归档（JAR）、网络归档（WAR）、企业归档（EAR）和Roshal归档（RAR）文件。ShrinkWrap对这些格式理解得非常好，但它可以构建任何基于zip的归档。
- en: 'The idea is to take your application and break it down into the smallest possible
    archive format required to achieve your test goal:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是将你的应用程序分解成实现测试目标所需的最小归档格式：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Creates a simple JAR file, and adds a single class**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个简单的JAR文件，并添加一个类**'
- en: '***2* Creates a more complex WAR file format, and adds a JAR file**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个更复杂的WAR文件格式，并添加一个JAR文件**'
- en: '***3* Creates an EAR file, and adds a WAR file**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建一个EAR文件，并添加一个WAR文件**'
- en: For the purposes of Arquillian, ShrinkWrap is the library used to create *microdeployments*
    for tests to run against. You could almost call these microdeployments microservices,
    because this is essentially what they are. But ShrinkWrap can do more and can
    also be used as a standalone utility. That would be beyond the scope of this book,
    so we won’t cover it; feel free to do some research if you want to learn more
    ([http://arquillian.org/modules/shrinkwrap-shrinkwrap/](http://arquillian.org/modules/shrinkwrap-shrinkwrap/)).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Arquillian来说，ShrinkWrap是用于创建测试运行时所需的*微部署*的库。你几乎可以称这些微部署为微服务，因为本质上就是这样。但ShrinkWrap可以做更多，也可以作为一个独立的实用工具使用。这超出了本书的范围，所以我们不会涉及它；如果你想要了解更多信息，请随意进行研究
    ([http://arquillian.org/modules/shrinkwrap-shrinkwrap/](http://arquillian.org/modules/shrinkwrap-shrinkwrap/))).
- en: ShrinkWrap essentially manages an in-memory representation of a Java archive,
    whatever the format. That representation can be modified by adding or removing
    entries through a powerful API. After the archive is built to your requirements,
    it can be handed off to Arquillian for deployment to the container. We’ll cover
    adding the required dependencies in [section 4.5.1](kindle_split_013_split_005.xhtml#ch04lev2sec7),
    but it’s important to understand what you’ll be adding, and why, before you get
    to that stage.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ShrinkWrap基本上管理了一个Java存档的内存表示，无论格式如何。这个表示可以通过添加或删除条目来通过强大的API进行修改。存档构建到满足你的要求后，可以将其交给Arquillian进行部署到容器中。我们将在[第4.5.1节](kindle_split_013_split_005.xhtml#ch04lev2sec7)中介绍添加所需的依赖项，但在达到那个阶段之前，了解你将要添加的内容以及为什么这样做是很重要的。
- en: 4.3.1\. Building an archive with ShrinkWrap
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.1\. 使用ShrinkWrap构建存档
- en: 'Creating an archive is simple. You create an empty archive using the static
    `create()` method of the `org.jboss.shrinkwrap.api.ShrinkWrap` class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 创建存档很简单。你使用`org.jboss.shrinkwrap.api.ShrinkWrap`类的静态`create()`方法创建一个空存档：
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Of course, all this does is create an empty archive with a name, but you’ve
    created your first ShrinkWrap archive. Congratulations!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些只是创建了一个带有名称的空存档，但你已经创建了你的第一个ShrinkWrap存档。恭喜你！
- en: 'Next, you’ll want to add more assets to the archive. Before you do that, you
    might find this snippet useful, to help you see the contents of the archive during
    development:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可能会想要向存档中添加更多资产。在你这样做之前，你可能发现这个片段很有用，可以帮助你在开发过程中查看存档的内容：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Using toString() is an easy way to see what your archive contains. This
    is a plain Java toString call.**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 使用`toString()`是一种查看你的存档包含什么内容的好方法。这是一个普通的Java `toString()`调用。'
- en: '***2* Other forms of toString() can be used, as well. Use your IDE to discover
    more.**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 也可以使用其他形式的`toString()`。使用你的IDE来发现更多。'
- en: 4.3.2\. Adding content to the ShrinkWrap archive
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.2\. 向ShrinkWrap存档添加内容
- en: A `GenericArchive` doesn’t do much in the way of adding assets to an archive.
    But ShrinkWrap can create much more than a simple `GenericArchive`!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenericArchive`在向存档添加资产方面并不做什么。但ShrinkWrap可以创建比简单的`GenericArchive`更多！'
- en: All you need to do to create a different kind of archive is pass the subclass
    of `Archive` you wish to create in the method. When a more specific subtype is
    used, many more options are available for adding content to the archive.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建不同类型的存档，你只需要在方法中传递你想要创建的`Archive`子类。当使用更具体的子类型时，可用于向存档添加内容的选择会更多。
- en: 'For example, with a JAR, you can add classes, packages, META-INF resources,
    and so on. The other types have similar additions: a WAR has methods to add web
    content, libraries, and web.xml. An EAR can add modules, application resources,
    and application.xml, as well as libraries and manifest resources. You can learn
    more by exploring the ShrinkWrap API.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于JAR文件，你可以添加类、包、META-INF资源等。其他类型也有类似的功能：WAR有添加Web内容、库和web.xml的方法。EAR可以添加模块、应用程序资源、application.xml，以及库和清单资源。你可以通过探索ShrinkWrap
    API来了解更多。
- en: You’ll notice that many of these methods have multiple overrides. You may not
    use all the methods, but each has its purpose. If you find yourself doing something
    that feels like it could be easier, look at the method overrides you don’t often
    use—something may be available to make your task easier.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这些方法中有多个重载。你可能不会使用所有这些方法，但每个方法都有其用途。如果你发现自己正在做某件事，感觉可能更简单，那么看看你不太常用的方法重载——可能有一些东西可以使你的任务更容易。
- en: 'The first thing you’ll want to do with an archive is add classes to it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存档时，你首先想要做的是向其中添加类：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* All the add methods are intuitive, but you’ll probably want to add classes.**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 所有添加方法都是直观的，但你可能想要添加类。'
- en: '***2* You may also want to add packages.**'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 您可能还想添加包。**'
- en: '|  |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'The plural `add` methods are `vararg` versions of the singular versions and
    can be used to add multiple items at a time: for example, `addClasses` and `addPackages`.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 复数形式的 `add` 方法是单数形式的 `vararg` 版本，可以一次添加多个项目：例如，`addClasses` 和 `addPackages`。
- en: '|  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The following is an example of using the *singular* `addClass` method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 *单数* `addClass` 方法的示例：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You add the name here: my.jar. If you don’t add a name, a name will be generated
    in the format UUID.jar, so we suggest using descriptive names from the start.
    They make more sense when you’re visually scanning the console output or log files.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这里添加名称：my.jar。如果您不添加名称，将生成一个格式为 UUID.jar 的名称，因此我们建议从一开始就使用描述性名称。它们在您在控制台输出或日志文件中直观扫描时更有意义。
- en: '|  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Use the test-class name as part of the archive name: this.getClass().getName()
    + .jar. This will help to visually separate test archives in the console output.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用测试类名作为存档名称的一部分：this.getClass().getName() + .jar。这将有助于在控制台输出中直观地分离测试存档。
- en: '|  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Sometimes it’s more convenient to add an entire namespace package to the archive.
    As you should expect by now, there’s a simple call for this—`addPackages`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将整个命名空间包添加到存档中会更方便。正如您现在应该预料到的，有一个简单的调用可以做到这一点——`addPackages`：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* The most useful version of this method, where true denotes a recursive
    call that adds all child packages and classes**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 此方法最有用的版本，其中 true 表示递归调用，添加所有子包和类**'
- en: 4.3.3\. Adding resources
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.3\. 添加资源
- en: 'You’ll invariably need to know how to add resources to an archive. These include
    things like the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您不可避免地需要知道如何将资源添加到存档。这些包括以下内容：
- en: A beans.xml file for CDI
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CDI 的 beans.xml 文件
- en: A persistence.xml file for JPA
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JPA 的 persistence.xml 文件
- en: Service implementations
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务实现
- en: Tag-library descriptors
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签库描述符
- en: Other common configuration files
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他常见配置文件
- en: 'Here’s how to add these items to the archive:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将这些项目添加到存档的方法：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Adds the test resource test-persistence.xml to the archive under META-INF/persistence.xml**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将测试资源 test-persistence.xml 添加到存档中的 META-INF/persistence.xml**'
- en: '***2* Creates an empty file asset, and adds it to the archive as beans.xml**'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个空文件资产，并将其添加到存档中的 beans.xml**'
- en: '***3* Alternative method of locating and adding a resource from the test classpath**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 从测试类路径中定位和添加资源的替代方法**'
- en: '***4* Adds the alternative resource to the archive using a BasicPath descriptor**'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用 BasicPath 描述符将替代资源添加到存档**'
- en: 'Both methods produce the same output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法产生相同的输出：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, ShrinkWrap has many ways to achieve the same result. You don’t
    have to know how to use all of these methods right now, but it’s nice to know
    that there’s nearly always a simple way to do whatever you want.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，ShrinkWrap 有许多方法可以达到相同的结果。您现在不必知道如何使用所有这些方法，但知道几乎总是有简单的方法来做您想做的事情是很好的。
- en: 4.3.4\. Adding libraries and dependencies
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.4\. 添加库和依赖项
- en: 'Your application is likely to require additional libraries and third-party
    dependencies, such as the Apache Commons Libraries ([https://commons.apache.org](https://commons.apache.org)).
    Adding a few items to your archive is reasonably concise:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序可能需要额外的库和第三方依赖项，例如 Apache Commons 库 ([https://commons.apache.org](https://commons.apache.org))。将一些项目添加到存档中是相当简洁的：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Creates a JAR file, in this case an SPI (more about SPIs in the next
    section)**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个 JAR 文件，在本例中是一个 SPI（关于 SPI 的更多信息将在下一节中介绍）**'
- en: '***2* Adds a single class. ShrinkWrap knows where to add this in a WAR file
    (/WEB-INF/classes/).**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 添加单个类。ShrinkWrap 知道在哪里将其添加到 WAR 文件中 (/WEB-INF/classes/)。**'
- en: '***3* Adds a standard resource to a defined path**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将标准资源添加到定义的路径**'
- en: '***4* Adds the JAR file to a WAR file. Again, ShrinkWrap automatically adds
    this to the correct path (/WEB-INF/lib/).**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将 JAR 文件添加到 WAR 文件中。同样，ShrinkWrap 会自动将其添加到正确的路径 (/WEB-INF/lib/)。**'
- en: As you’d expect, ShrinkWrap provides simple methods to achieve something complex.
    But what if your application is far more than just a Hello World example? ShrinkWrap
    alone isn’t going to be enough. That leads us into the next topic.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所料，ShrinkWrap 提供了简单的方法来实现复杂的功能。但您的应用程序如果远不止一个 Hello World 示例呢？ShrinkWrap 单独是不够的。这引出了下一个主题。
- en: 4.3.5\. Adding complex dependencies with the Maven resolver
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.5\. 使用 Maven 解析器添加复杂依赖项
- en: The *Maven resolver* is another powerful utility class that allows you to add
    heavyweight options to an archive. It’s designed to complement what you’ve already
    learned about the ShrinkWrap utility class. We’ll only touch on what’s required
    for its basic use; you can gain deeper insight at the project’s website, [https://github.com/shrinkwrap/resolver](https://github.com/shrinkwrap/resolver).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*Maven 解析器* 是另一个强大的实用工具类，允许你向存档添加重量级选项。它旨在补充你已经了解的 ShrinkWrap 实用工具类。我们只会简要介绍其基本使用方法；你可以在项目的网站上获得更深入的见解，[https://github.com/shrinkwrap/resolver](https://github.com/shrinkwrap/resolver)。'
- en: 'Using the resolver is simple and is best described using an example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用解析器很简单，最好通过一个示例来描述：
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* Imports the Maven utility class**'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 Maven 实用工具类**'
- en: '***2* Defines the Maven coordinate you want to resolve using the groupId:artifactId:version
    (GAV) schema**'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义使用 groupId:artifactId:version (GAV) 格式要解析的 Maven 坐标**'
- en: '***3* Resolves the defined GAV coordinate**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 解析定义的 GAV 坐标**'
- en: '***4* Additionally fetches all the transient (related) dependencies for the
    main artifact**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 此外，检索主工件的所有临时（相关）依赖项**'
- en: '***5* Adds a complete list of dependencies as a File array**'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将完整的依赖项列表作为一个文件数组添加**'
- en: '***6* Adds all the dependencies to a WAR archive**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将所有依赖项添加到 WAR 存档中**'
- en: 'The resolver can return more than just a file, if you know the type of the
    resource. An addition to GAV, you can also specify the package type (P, for archives
    such as WAR or JAR) and the classifier (C, a user-defined name). Here’s a complete
    list of explicit resource types at the time of writing:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道资源的类型，解析器可以返回不仅仅是文件。除了 GAV，你还可以指定包类型（P，用于如 WAR 或 JAR 的存档）和分类器（C，用户定义的名称）。以下是写作时的完整资源类型列表：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `MavenCoordinate.class` provides detailed metainformation about the specified
    artifact. If you’re unsure what resources the artifact provides, you can use this
    class to discover the details.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`MavenCoordinate.class` 提供了有关指定工件详细元信息。如果你不确定工件提供了哪些资源，可以使用这个类来发现详细信息。'
- en: '|  |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You’re responsible for closing a retrieved `InputStream` type. The stream is
    a direct connection to the repository artifact.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你负责关闭检索到的 `InputStream` 类型。该流是直接连接到仓库工件。
- en: '|  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'As powerful as the resolver is, you may have noticed that there’s one small
    potential drawback: the artifact version number is hardcoded in the GAV coordinate
    string. For a small number of fixed dependencies, keeping them in sync maybe not
    be an issue; but if your application is forever evolving, this could be a problem.
    Not to worry: the API provides a solution. The resolver understands Maven *pom.xml*
    files ([https://maven.apache.org/pom.html](https://maven.apache.org/pom.html)).
    You can import dependencies from any pom.xml file location, so it could be your
    project POM or one completely separate from your build:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管解析器功能强大，但你可能已经注意到有一个小的潜在缺点：工件版本号在 GAV 坐标字符串中是硬编码的。对于少量固定的依赖项，保持它们同步可能不是问题；但如果你的应用程序一直在发展，这可能会成为一个问题。不用担心：API
    提供了一个解决方案。解析器理解 Maven *pom.xml* 文件 ([https://maven.apache.org/pom.html](https://maven.apache.org/pom.html))。你可以从任何
    pom.xml 文件位置导入依赖项，所以它可以是你的项目 POM，也可以是完全独立于你的构建的：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Specifies a file path to the pom.xml to load**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 指定要加载的 pom.xml 文件路径**'
- en: '***2* Defines the scopes you want to import (there are multiple methods that
    cover all the scopes)**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义要导入的范围（有多种方法可以覆盖所有范围）**'
- en: '***3* Resolves the complete list of dependencies as a File array**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将完整的依赖列表解析为一个文件数组**'
- en: 4.3.6\. Adding a service implementation
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.3.6. 添加服务实现
- en: '*Service provider implementations* (SPIs, mng.bz/i7QX) are a way of enabling
    the extension of an application in a standard fashion. ShrinkWrap understands
    this mechanism and can remove most of the standard boilerplate code required to
    add a known SPI to your archive.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务提供者实现*（SPIs，mng.bz/i7QX）是一种以标准方式扩展应用程序的方法。ShrinkWrap 理解这种机制，并且可以移除添加已知 SPI
    到存档所需的大部分标准样板代码。'
- en: 'The various `addAsServiceProvider` methods are handy for getting ShrinkWrap
    to create the services file for the specified interface and classes. The following
    code will create the javax.enterprise.inject.spi.Extension file, add the class
    name of the service to it, and then place the file in the standard META-INF file
    structure:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 各种 `addAsServiceProvider` 方法对于让 ShrinkWrap 为指定的接口和类创建服务文件非常有用。以下代码将创建 javax.enterprise.inject.spi.Extension
    文件，将服务类的名称添加到其中，然后将文件放置在标准的 META-INF 文件结构中：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Adds the required structure for an SPI**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加了 SPI 所需的结构**'
- en: '***2* Sometimes the added interface is provided by the container.**'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 有时，附加的接口是由容器提供的。**'
- en: '***3* It’s often better to use the addAsServiceProvider method and add the
    class separately.**'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 通常最好使用 addAsServiceProvider 方法并单独添加类。**'
- en: Providing both methods for adding an SPI gives you all the flexibility required
    to add any implementation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 提供两种添加 SPI 的方法为你提供了添加任何实现所需的所有灵活性。
- en: 4.4\. Write once and reuse your code
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4. 编写一次，重用你的代码
- en: 'Now that you understand how to create archives, you may wonder why you should
    go to all this trouble when your build tool can do it all for you. Aside from
    the obvious answer—“That’s how it’s done with Arquillian”—there are a number of
    good reasons. The most important reason is that Arquillian significantly lowers
    the barrier to performing integration and functional tests. Even if you chose
    not to use Arquillian, you’d still need to do the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何创建存档，你可能想知道为什么你要费这么大的劲，因为你的构建工具可以为你做所有这些。除了显而易见的答案——“这就是 Arquillian
    的做法”——还有许多很好的理由。最重要的理由是 Arquillian 显著降低了执行集成和功能测试的门槛。即使你没有选择使用 Arquillian，你仍然需要做以下事情：
- en: Create an archive that can be deployed.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可以部署的存档。
- en: Deploy that archive to a running container/application server.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将存档部署到正在运行的容器/应用程序服务器。
- en: Run the tests in the deployed archive.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在已部署的存档中运行测试。
- en: Retrieve the results of the tests from the container.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从容器中检索测试结果。
- en: Undeploy the archive.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消部署存档。
- en: Shut down the container.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭容器。
- en: 'Arquillian handles this for you in a transparent fashion. It’s trivial to create
    an abstract base class for all your tests to extend, override, and reuse:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian 以透明的方式为你处理这些。为所有测试创建一个抽象基类以扩展、覆盖和重用是微不足道的：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Calls a static parent or utility method that delivers a ready-made WebArchive
    to add additional requirements to**'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调用一个静态父方法或实用工具方法，该方法提供了一个现成的 WebArchive 以添加额外的需求**'
- en: This base class generalizes your application, and test classes just need to
    add the additional requirements. You can even create your own utility class for
    this purpose.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基类概括了你的应用程序，测试类只需要添加额外的需求。你甚至可以为此创建自己的实用工具类。
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Most, if not all, applications share common foundations that can be extracted
    to abstract classes. This is no different when it comes to testing. Identify the
    code that’s common to your testing strategy, and do exactly the same thing—create
    an abstract test class. This will save you time in the long run.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数，如果不是所有，应用程序都有可以提取到抽象类中的共同基础。在测试方面也是如此。识别出你测试策略中通用的代码，并做完全相同的事情——创建一个抽象测试类。这将在长期内为你节省时间。
- en: '|  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Your build may help with creating the archive, but you’ll need to make sure
    you have all the testing dependencies added, which your regular build probably
    doesn’t include without considerable extra configuration. Creating these smaller
    deployments, *microdeployments*, helps isolate the test from other parts of the
    application. It also helps you think in terms of the smallest testable unit of
    work.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你的构建可能有助于创建存档，但你需要确保添加了所有的测试依赖项，这通常需要相当多的额外配置。创建这些较小的部署，*微部署*，有助于隔离测试与其他应用程序部分。这也帮助你从最小的可测试工作单元的角度思考。
- en: Microdeployments also allow you to skip the full build, which is both a reason
    to use them and a side effect. If your full build takes one minute to create the
    testable archive, that’s one additional minute you’ll need to run a test! That
    time can quickly add up while you’re testing, especially if you’re running tests
    locally. The side effect is that not only do you skip the build, but, if you’re
    using an incremental compiler, you also skip an implicit compile phase. That can
    lead to some serious time savings!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 微部署还允许你跳过完整的构建，这既是使用它们的原因，也是副作用。如果你的完整构建需要一分钟来创建可测试的存档，那么你将需要额外一分钟来运行测试！当你进行测试时，这段时间会迅速增加，尤其是如果你是在本地运行测试。副作用是，你不仅跳过了构建，如果你使用的是增量编译器，你也会跳过一个隐式的编译阶段。这可以节省大量时间！
- en: 4.5\. Build-script modifications
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5. 修改构建脚本
- en: 'You now have a good grasp of the elements you add to a basic JUnit test to
    make an Arquillian test, but where do all these elements come from? You’ve got
    it: dependencies!'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经很好地掌握了添加到基本 JUnit 测试中以使其成为 Arquillian 测试的元素，但这些元素都是从哪里来的呢？答案是：依赖项！
- en: 'There are numerous build environments, so it would be almost impossible to
    cover them all. We use the two most popular systems throughout the example projects:
    Maven and Gradle. Detailing both of these systems will give you more than enough
    information to configure any other system, because they’re closely linked to the
    Maven GAV coordinate system and also allow for specifying the packaging and a
    classifier if required:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在众多构建环境，因此几乎不可能涵盖所有内容。我们在示例项目中使用了两个最流行的系统：Maven 和 Gradle。详细说明这两个系统将为您提供足够的信息来配置任何其他系统，因为它们与
    Maven GAV 坐标系统紧密相关，并且允许在需要时指定打包和分类器：
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Arquillian, ShrinkWrap, and Resolver all provide a Maven *bill of materials*
    (BOM) pom.xml file.^([[1](kindle_split_013_split_005.xhtml#ch04fn01)]) A BOM defines
    all the required dependencies you’ll need, including version numbers. This eliminates
    needing a lot of individual dependency declarations. The Arquillian BOM imports
    the ShrinkWrap and Resolver BOMs, so you only need to include the Arquillian BOM
    in the `<dependencyManagement>` section of the project pom.xml.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian、ShrinkWrap 和 Resolver 都提供了 Maven *物料清单*（BOM）pom.xml 文件。[1](kindle_split_013_split_005.xhtml#ch04fn01)
    BOM 定义了您将需要的所有依赖关系，包括版本号。这消除了需要大量单个依赖关系声明。Arquillian BOM 导入了 ShrinkWrap 和 Resolver
    BOM，因此您只需在项目 pom.xml 的 `<dependencyManagement>` 部分包含 Arquillian BOM 即可。
- en: ¹
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See “Introduction to the Dependency Mechanism,” *Apache Maven Project*, ([http://mng.bz/OR0F](http://mng.bz/OR0F)).
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请参阅“依赖机制简介”，*Apache Maven 项目*（[http://mng.bz/OR0F](http://mng.bz/OR0F)）。
- en: 4.5.1\. Defining Maven dependencies
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.1\. 定义 Maven 依赖关系
- en: If you’re using Maven for your build, adding the dependencies for Arquillian
    is trivial. Declare the BOM using the `import` scope in the `<dependencyManagement>`
    section of your project pom.xml. You can see in the following listing that a WildFly
    ([http://wildfly.org](http://wildfly.org)) BOM is provided. BOMs are useful!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Maven 进行构建，添加 Arquillian 的依赖关系非常简单。在项目 pom.xml 的 `<dependencyManagement>`
    部分使用 `import` 范围声明 BOM。您可以在以下列表中看到提供了一个 WildFly ([http://wildfly.org](http://wildfly.org))
    BOM。BOM 非常有用！
- en: 'Listing 4.2\. code/game/pom.xml: `<dependencyManagement>`'
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 4.2\. code/game/pom.xml: `<dependencyManagement>`'
- en: '[PRE16]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|  |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A BOM is used to define the versions and transient dependencies of specific
    artifacts that are *likely* to be used in the project. In a multimodule build,
    `<dependencyManagement>` should be in the parent pom.xml and serve as a contract
    for all the child modules. The actual dependencies used are then defined in the
    `<dependencies>` section, where the `<version>` definition is omitted.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: BOM（Bill of Materials）用于定义项目中可能使用的特定工件版本和临时依赖关系。在多模块构建中，`<dependencyManagement>`
    应该位于父 pom.xml 中，并作为所有子模块的合同。实际的依赖关系定义在 `<dependencies>` 部分，其中省略了 `<version>` 定义。
- en: '|  |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You also need to add the Arquillian container adapter and an implementation
    to the `<dependencies>` section of your project. This example uses the WildFly
    container adapter from Red Hat ([www.redhat.com](http://www.redhat.com)), but
    it can be any adapter implementation you like, such as the Apache TomEE adapter
    ([http://mng.bz/O5fo](http://mng.bz/O5fo)).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要将 Arquillian 容器适配器和实现添加到项目的 `<dependencies>` 部分。此示例使用 Red Hat 的 WildFly
    容器适配器（[www.redhat.com](http://www.redhat.com)），但可以是您喜欢的任何适配器实现，例如 Apache TomEE
    适配器（[http://mng.bz/O5fo](http://mng.bz/O5fo)）。
- en: 'Listing 4.3\. code/game/pom.xml: `<dependencies>`'
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '列表 4.3\. code/game/pom.xml: `<dependencies>`'
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|  |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The mere fact that you now have an adapter implementation on the test classpath
    is enough for Arquillian to find and use it. It’s possible to define multiple
    implementations using Maven build profiles—we’ll discuss this further in [chapter
    5](kindle_split_014_split_000.xhtml#ch05).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅在测试类路径上有一个适配器实现就足以让 Arquillian 找到并使用它。您可以使用 Maven 构建配置文件定义多个实现——我们将在第 5 章中进一步讨论这一点。
- en: '|  |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’ll always be able to find the adapter for your application server by searching
    the internet for “[container name]+arquillian.” Note that the defined `<scope>`
    is `test`, because you should only be using Arquillian for testing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在互联网上搜索 “[容器名称]+arquillian” 来始终找到您应用程序服务器的适配器。请注意，定义的 `<scope>` 是 `test`，因为您应该只使用
    Arquillian 进行测试。
- en: '|  |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `arquillian-junit-container` artifact pulls in ShrinkWrap and resolvers
    as transient dependencies. If you want to use ShrinkWrap or resolvers in your
    application, you need to define them individually, using the required scope.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`arquillian-junit-container` 艺术品会拉入 ShrinkWrap 和 resolvers 作为临时依赖。如果您想在您的应用程序中使用
    ShrinkWrap 或 resolvers，您需要单独定义它们，使用所需的范围。'
- en: '|  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.5.2\. Defining Gradle dependencies
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.5.2\. 定义 Gradle 依赖
- en: Gradle doesn’t understand the concept of a BOM out of the box. Fortunately,
    a few plugins enable this feature—otherwise, you’d have to add all the dependencies
    individually. You still have to add a few more dependency definitions, but the
    BOM declares all the versions and transient dependencies for you.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 默认不支持 BOM 的概念。幸运的是，一些插件启用了此功能——否则，您必须单独添加所有依赖项。您仍然需要添加一些额外的依赖定义，但 BOM
    会为您声明所有版本和临时依赖。
- en: '|  |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We’ve formatted long coordinate lines for the book, so please replace `o.j.s`
    with `org.jboss.shrinkwrap`, `o.j.a` with `org.jboss.arquillian`, and `o.g` with
    `org.glassfish`. If in doubt, check the example code.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为本书格式化了长坐标行，因此请将 `o.j.s` 替换为 `org.jboss.shrinkwrap`，将 `o.j.a` 替换为 `org.jboss.arquillian`，将
    `o.g` 替换为 `org.glassfish`。如有疑问，请检查示例代码。
- en: '|  |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The following listing shows an example build.gradle file taken from the aggregatorservice
    application (code/aggregator/build.gradle).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了从 aggregatorservice 应用程序（code/aggregator/build.gradle）中提取的示例 build.gradle
    文件。
- en: Listing 4.4\. Example build.gradle file
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4\. 示例 build.gradle 文件
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Defines the dependency-management plugin that allows you to use Maven
    BOM imports**'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义了依赖管理插件，允许您使用 Maven BOM 导入**'
- en: '***2* Uses the plugin to import the Arquillian, ShrinkWrap, and resolver dependencies**'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用插件导入 Arquillian、ShrinkWrap 和 resolver 依赖**'
- en: '***3* Declares all the dependencies the application requires**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 声明应用程序所需的全部依赖**'
- en: '***4* Adds the Arquillian dependency. Because the BOM defines all the required
    version numbers, you don’t need to include them here (unless an override is desired).**'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 添加 Arquillian 依赖。因为 BOM 定义了所有必需的版本号，所以您不需要在这里包含它们（除非需要覆盖）。**'
- en: '***5* Adds any container implementation. Here, you use an embedded Apache Tomcat
    container.**'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 添加任何容器实现。在这里，您使用嵌入式的 Apache Tomcat 容器。**'
- en: '***6* Adds the ShrinkWrap dependencies declared in the BOM**'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 添加 BOM 中声明的 ShrinkWrap 依赖**'
- en: '***7* Adds the Resolver dependencies declared in the BOM**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 添加 BOM 中声明的 Resolver 依赖**'
- en: 4.6\. Overriding the default Arquillian configuration
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6\. 覆盖默认的 Arquillian 配置
- en: We’ve now covered all the elements required to run a standard Arquillian unit
    test. These include using required annotations, packaging and deploying an application
    archive, and including all the required dependencies in the build scripts. As
    indicated at the beginning of the chapter, all of this relies on an as-yet-unexposed
    default configuration.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经涵盖了运行标准 Arquillian 单元测试所需的所有元素。这包括使用必需的注解、打包和部署应用程序存档，以及在构建脚本中包含所有必需的依赖项。如本章开头所述，所有这些都依赖于尚未公开的默认配置。
- en: There may come a time when the default configuration requires customization.
    For example, you may need to start the container on a different port than the
    default one (to avoid port conflicts) or in HTTPS mode (to test security), or
    specify options like a key-store file.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，默认配置可能需要定制。例如，您可能需要在一个不同于默认端口的端口上启动容器（以避免端口冲突）或以 HTTPS 模式（以测试安全性），或指定选项，如密钥库文件。
- en: Arquillian checks for configuration settings in a file named arquillian.xml
    in the root of your classpath. If this file exists, it’s loaded; otherwise, default
    values are used. Until now, Arquillian has been using a default set of configuration
    options transparently in the background. These default options are supplied by
    the vendor-specific container-adapter implementation found on the classpath.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian 会检查类路径根目录下名为 arquillian.xml 的配置设置文件。如果此文件存在，则将其加载；否则，使用默认值。到目前为止，Arquillian
    一直在后台透明地使用默认的配置选项集。这些默认选项由类路径上找到的特定供应商的容器适配器实现提供。
- en: The usual location for this file in a typical Maven project is [project]/src/test/resources/arquillian.xml.
    Files in this test resources directory are only available on the test classpath
    during runtime, which is usually the required scenario. The following listing
    shows an example.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的 Maven 项目中，此文件通常位于 [project]/src/test/resources/arquillian.xml。此测试资源目录中的文件仅在运行时才可在测试类路径上使用，这通常是必需的场景。以下列表展示了示例。
- en: Listing 4.5\. Example arquillian.xml file with two containers
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.5\. 包含两个容器的示例 arquillian.xml 文件
- en: '[PRE19]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Following the standard XML declaration comes <arquillian>, the body definition
    with schema references.**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在遵循标准 XML 声明之后是 <arquillian>，带有模式引用的主体定义。**'
- en: '***2* It’s common to have only one <container qualifier=“[name]”>; we’ll explain
    why there are two here in a moment.**'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 通常只有一个 <container qualifier=“[name]”>；我们将在稍后解释为什么这里有两个。**'
- en: '***3* The second container, flagged as the default**'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 第二个容器，标记为默认**'
- en: '***4* Container property definition—there can be multiple properties**'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 容器属性定义——可以有多个属性**'
- en: This configuration is XML, so there are no surprises in the layout. Let’s take
    a deeper look at the most important configuration options.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置是 XML 格式，因此在布局上没有惊喜。让我们更深入地看看最重要的配置选项。
- en: '|  |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Because each container is vendor specific, some of the contents of the arquillian.xml
    file will have vendor-specific options. Use the information in [listing 4.5](kindle_split_013_split_006.xhtml#ch04ex05)
    as an example, but ensure that you use the correct options for your chosen container.
    We’ll highlight the areas that require attention throughout this section.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个容器都是供应商特定的，所以 arquillian.xml 文件中的一些内容将包含供应商特定的选项。以[列表 4.5](kindle_split_013_split_006.xhtml#ch04ex05)中的信息为例，但请确保你使用你选择的容器的正确选项。我们将在本节中突出需要关注的区域。
- en: '|  |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.6.1\. The container definition
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.1\. 容器定义
- en: In [section 4.5.1](kindle_split_013_split_005.xhtml#ch04lev2sec7), you learned
    how to add a default container adapter to the test classpath using the Maven coordinates.
    `<container qualifier="[name]">` is where you make a declaration for a specific
    runtime container that you’ll test against. If Arquillian finds only one container
    definition, it will always be used as the default.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 4.5.1 节](kindle_split_013_split_005.xhtml#ch04lev2sec7)中，你学习了如何使用 Maven
    坐标向测试类路径添加默认容器适配器。`<container qualifier="[name]">` 是你为将要测试的特定运行时容器做出声明的位置。如果 Arquillian
    只找到一个容器定义，它将始终用作默认值。
- en: 'We’ll discuss using multiple containers in depth in [chapter 7](kindle_split_016_split_000.xhtml#ch07).
    In brief, if multiple container definitions exist, Arquillian looks for two things:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第 7 章](kindle_split_016_split_000.xhtml#ch07)中深入讨论使用多个容器。简而言之，如果存在多个容器定义，Arquillian
    会寻找两个东西：
- en: A container with a `default="true"` attribute. This container will be used as
    the default—that makes sense.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 `default="true"` 属性的容器。这个容器将被用作默认值——这是有道理的。
- en: The system property `arquillian.launch`, with the name of the container to use
    for the current runtime.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统属性 `arquillian.launch`，其中包含用于当前运行时的容器名称。
- en: The `arquillian.launch` system property can be defined or overridden using Maven
    profiles.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 Maven 配置文件定义或覆盖 `arquillian.launch` 系统属性。
- en: 4.6.2\. Specifying container properties
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.6.2\. 指定容器属性
- en: 'A container property is straightforward: `<property name="[name]">[value]</property>`.
    You can add any number of container properties to the `<configuration>` element.
    As we warned earlier in the chapter, these properties are vendor specific.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 容器属性很简单：`<property name="[name]">[value]</property>`。你可以在 `<configuration>`
    元素中添加任意数量的容器属性。正如我们在本章前面警告的那样，这些属性是供应商特定的。
- en: The most common use for container properties is to define a server port to bind
    to, to prevent conflicts. Some providers allow a random port, which is a cool
    feature because it allows tests to run in parallel. The example in [listing 4.5](kindle_split_013_split_006.xhtml#ch04ex05)
    set a system property `javaVmArguments` for both WildFly container definitions.
    You’ll see the relevance of this later in this section. As you can imagine, listing
    all the available properties for all the available container implementations here
    would be impossible. [Table 4.1](kindle_split_013_split_006.xhtml#ch04table01)
    gives a few; please take the time to find the properties that are available for
    your container of choice.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 容器属性最常见的用途是定义一个要绑定的服务器端口，以防止冲突。一些提供商允许使用随机端口，这是一个很酷的功能，因为它允许测试并行运行。示例[列表 4.5](kindle_split_013_split_006.xhtml#ch04ex05)为
    WildFly 容器定义设置了系统属性 `javaVmArguments`。你将在本节后面看到这一点的重要性。正如你可以想象的那样，在这里列出所有可用的容器实现的所有可用属性是不可能的。[表
    4.1](kindle_split_013_split_006.xhtml#ch04table01)给出了一些；请花时间找到你选择的容器可用的属性。
- en: Table 4.1\. Common containers and properties
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 4.1\. 常见容器和属性
- en: '| Container | Property | Value |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 容器 | 属性 | 值 |'
- en: '| --- | --- | --- |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Apache TomEE | httpPort | -1 (Random) |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| Apache TomEE | httpPort | -1 (随机) |'
- en: '| Apache TomEE | stopPort | -1 (Random) |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| Apache TomEE | stopPort | -1 (随机) |'
- en: '| WildFly | serverConfig | server.xml (File) |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| WildFly | serverConfig | server.xml (文件) |'
- en: '| GlassFish | bindHttpPort | [port] |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| GlassFish | bindHttpPort | [端口号] |'
- en: '|  |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: When you’re using an embedded container (remote container adapters are always
    named as such), you can also set system properties via `maven-surefire-plugin`.
    See [http://mng.bz/cI7V](http://mng.bz/cI7V).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用嵌入式容器（远程容器适配器总是这样命名）时，你也可以通过`maven-surefire-plugin`设置系统属性。参见[http://mng.bz/cI7V](http://mng.bz/cI7V)。
- en: '|  |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 4.7\. Using Arquillian REST extensions
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7\. 使用Arquillian REST扩展
- en: REST web services are now commonplace, and it’s increasingly unlikely that a
    web-based or microservice application isn’t using this technology today. That
    doesn’t mean a microservice can’t use a different protocol (far from it); but
    that would be an edge case and specific to a business scope. Here, we’ll focus
    on REST over HTTP/S, and how Arquillian can lighten the load when you’re building
    a test environment.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: REST网络服务现在很常见，而且越来越不可能有一个基于Web或微服务应用今天不使用这项技术。这并不意味着微服务不能使用不同的协议（远非如此）；但这将是一个边缘情况，并且特定于业务范围。在这里，我们将关注HTTP/S上的REST，以及Arquillian如何在构建测试环境时减轻负担。
- en: 'Two modules are available. The REST client extension is designed to be used
    in a black-box test environment: the client is completely isolated from the application
    and sees only the endpoints as a real remote client. The Warp REST module is for
    much more complex tests, where you want to intercept incoming and outgoing REST
    requests and responses. The next two sections cover these modules.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个模块可用。REST客户端扩展旨在用于黑盒测试环境：客户端完全与应用程序隔离，并且仅将端点视为真实远程客户端。Warp REST模块用于更复杂的测试，其中你想要拦截传入和传出的REST请求和响应。接下来的两个部分将介绍这些模块。
- en: 4.7.1\. The Arquillian REST client extension
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.7.1\. Arquillian REST客户端扩展
- en: Sometimes you need to test a REST application in a black-box environment, the
    test acting as if it were a real client, to ensure that your endpoint is working
    as expected when called by an external source. When you know the interface (the
    contract) and you have well-defined input, and you also know what results you
    expect to get from a resource call, then the Arquillian REST client extension
    will be useful to you. Let’s look at a concise example (code/comments/src/test/java/book/comments/boundary/CommentsResourceTest.java).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要在一个黑盒环境中测试REST应用程序，测试行为就像是一个真实客户端，以确保当由外部源调用时，你的端点按预期工作。当你知道接口（合同）并且你有明确定义的输入，你还知道从资源调用中期望得到什么结果时，Arquillian
    REST客户端扩展将对你很有用。让我们看看一个简洁的例子（code/comments/src/test/java/book/comments/boundary/CommentsResourceTest.java）。
- en: Listing 4.6\. Using the Arquillian REST client extension
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.6\. 使用Arquillian REST客户端扩展
- en: '[PRE20]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* The now all-too-familiar @RunWith(Arquillian.class) testing annotation**'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 现在非常熟悉的@RunWith(Arquillian.class)测试注解**'
- en: '***2* When you know that all the tests in a class will act as black-box clients,
    use the testable = false option, rather than @RunAsClient. The packaging here
    adds the REST CommentsResource.class and required dependencies.**'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当你知道一个类中的所有测试都将作为黑盒客户端执行时，使用testable = false选项，而不是@RunAsClient。这里的打包添加了REST
    CommentsResource.class和所需的依赖项。**'
- en: '***3* Injects the CommentsResource.class REST resource interface directly into
    the test method using the @ArquillianResteasyResource annotation**'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用@ArquillianResteasyResource注解直接将CommentsResource.class REST资源接口注入到测试方法中**'
- en: '***4* Uses the CommentsResource.class REST resource interface directly in the
    test method**'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在测试方法中直接使用CommentsResource.class REST资源接口**'
- en: If you’ve ever used the JAX-RS `ClientBuilder` in a REST-based test, then it
    should be obvious here how much boilerplate has been replaced by using the `@ArquillianResteasyResource`
    annotation. It’s fair to say that this extension has removed a significant amount
    of code required to access the endpoint. Under the hood, real HTTP requests and
    responses are performed, but the interface now acts as a simplified proxy.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经在使用基于REST的测试中使用过JAX-RS `ClientBuilder`，那么在这里使用`@ArquillianResteasyResource`注解替换了多少样板代码应该很清楚。可以说，这个扩展已经移除了一大部分访问端点所需的代码。在底层，执行真实的HTTP请求和响应，但现在接口充当了一个简化的代理。
- en: '|  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: You’ll find several tests in the book’s code that use the JAX-RS `ClientBuilder`
    to test resources. For finer testing, it’s more useful than `@ArquillianResteasyResource`.
    You can decide which path to follow—both have their merits.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在本书的代码中找到几个使用JAX-RS `ClientBuilder`测试资源的测试。对于更精细的测试，它比`@ArquillianResteasyResource`更有用。你可以决定走哪条路——两者都有其优点。
- en: '|  |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'If you want to use the REST extension in your tests, you need to add the following
    dependencies to your build script:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在你的测试中使用REST扩展，你需要在你的构建脚本中添加以下依赖项：
- en: '[PRE21]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|  |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, we used the latest available release. It was flagged
    as an alpha version, but it’s very stable. Please check for and use the latest
    release where possible.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，我们使用了最新可用的版本。它被标记为alpha版本，但非常稳定。请尽可能检查并使用最新版本。
- en: '|  |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 4.7.2\. The Warp REST extension
  id: totrans-293
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.7.2\. Warp REST扩展
- en: The Arquillian Warp REST extension allows you to test your RESTful applications
    on the server side. This extension provides utilities for intercepting the state
    of the executing service, and provides the state in container tests that may be
    executed directly before or after the service is invoked. It supports JAX-RS major
    versions including 1.1 and 2.0 and the most popular implementations.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian Warp REST扩展允许你在服务器端测试你的RESTful应用程序。此扩展提供了拦截执行服务状态的实用工具，并在服务调用之前或之后可能执行的容器测试中提供状态。它支持包括1.1和2.0在内的JAX-RS主要版本以及最流行的实现。
- en: This topic is advanced and requires a good understanding of the underlying protocol
    to be useful. The following test adds an inspection that fires after the endpoint
    is invoked (code/comments/src/test/java/book/comments/boundary/CommentsWarpTest.java).
    Internally, a REST endpoint is invoked by a servlet that understands the client/server
    protocol. The Warp annotations `@AfterServlet` and `@BeforeServlet` can be used
    on methods to gain access to the current protocol states.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题是高级的，需要很好地理解底层协议才能有用。以下测试在端点调用后添加了一个检查（code/comments/src/test/java/book/comments/boundary/CommentsWarpTest.java）。内部，一个REST端点由一个理解客户端/服务器协议的servlet调用。可以在方法上使用Warp注解`@AfterServlet`和`@BeforeServlet`来访问当前的协议状态。
- en: Listing 4.7\. Adding an inspection after an endpoint
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.7\. 在端点之后添加检查
- en: '[PRE22]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Flags the test class as a Warp-enabled test using the @WarpTest annotation**'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 @WarpTest 注解将测试类标记为Warp启用测试**'
- en: '***2* Ensures that the REST environment is available for the test class**'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 确保REST环境对测试类可用**'
- en: '***3* Defines the underlying protocol using the @OverProtocol annotation**'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 @OverProtocol 注解定义底层协议**'
- en: '***4* Injects the REST context path that’s used to access the server**'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 注入用于访问服务器的REST上下文路径**'
- en: '***5* Configures the REST client proxy to the server resource**'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 配置REST客户端代理到服务器资源**'
- en: '***6* Isolates the test method in a black-box environment using the @RunAsClient
    annotation**'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 使用 @RunAsClient 注解在黑盒环境中隔离测试方法**'
- en: '***7* Initiates the REST call and adds an inspection**'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 启动REST调用并添加检查**'
- en: '***8* Provides the REST call context to access protocol information**'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 提供REST调用上下文以访问协议信息**'
- en: '***9* Indicates that the method should be called directly after the servlet
    call**'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 指示该方法应在servlet调用之后直接调用**'
- en: '***10* Access to protocol states allows testing.**'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 访问协议状态允许测试。**'
- en: 'If you want to use the REST Warp extension in your tests, you need to add the
    following dependencies to your build script:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在你的测试中使用REST Warp扩展，你需要在你的构建脚本中添加以下依赖项：
- en: '[PRE23]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|  |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As noted earlier, at the time of writing, we used the latest available release
    in the code. Even though this was flagged as an alpha version, it’s very stable
    for testing. Please check for and use the latest release where possible.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在撰写本文时，我们使用了代码中可用的最新版本。尽管这被标记为alpha版本，但它对测试来说非常稳定。请尽可能检查并使用最新版本。
- en: '|  |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 4.8\. Testing Spring applications using Arquillian
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.8\. 使用Arquillian测试Spring应用程序
- en: One of the key benefits of the microservices architecture that we mentioned
    in [chapter 1](kindle_split_010_split_000.xhtml#ch01) is the ability to delegate
    service development to multiple teams, using multiple technologies. The only important
    aspect in a multitechnology environment is that the resource component is accessible
    using a defined protocol, in this case REST over HTTP. How the actual service
    is implemented is irrelevant from a team-to-team perspective. To demonstrate this
    principle, the video service in the book’s demo application is a Spring Boot application.
    You still need to test this application just like any other.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](kindle_split_010_split_000.xhtml#ch01)中提到的微服务架构的关键优势之一是能够将服务开发委托给多个团队，使用多种技术。在多技术环境中，唯一重要的方面是资源组件可以通过定义的协议访问，在这种情况下是通过HTTP上的REST。从团队到团队的角度来看，实际服务的实现是不相关的。为了演示这个原则，书中演示应用程序的视频服务是一个Spring
    Boot应用程序。您仍然需要像测试任何其他应用程序一样测试这个应用程序。
- en: Arquillian provides a Spring v4+ extension that can be used to aid testing.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Arquillian提供了一个Spring v4+扩展，可用于辅助测试。
- en: 4.8.1\. The Arquillian Spring Framework extension
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.8.1\. Arquillian Spring框架扩展
- en: 'The Spring Framework extension works in a fashion similar to `@SpringJUnit4ClassRunner`,
    but it remains within the Arquillian test-environment context and has less boilerplate
    code to get started writing tests. If you’re already familiar with Spring JUnit
    integration, we suggest taking a look at this approach and making an educated
    evaluation of its use before dismissing it. If you aren’t, then this is likely
    to be the easiest approach for you to start with, because the setup is less verbose
    than the Spring runner. The extension supports the following implementations:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Spring框架扩展的工作方式类似于`@SpringJUnit4ClassRunner`，但它保持在Arquillian测试环境上下文中，并且启动测试时需要更少的样板代码。如果您已经熟悉Spring
    JUnit集成，我们建议您查看这种方法，并在将其摒弃之前进行有根据的评价。如果您不熟悉，那么这可能是您开始时最容易的方法，因为设置比Spring运行器更简洁。扩展支持以下实现：
- en: Injecting Spring beans into test classes
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Spring bean注入测试类
- en: Configuring from both XML- and Java-based configs
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从XML和Java配置中配置
- en: Injecting beans configured in web applications (for example, `DispatcherServlet`)
    for tests annotated with @`SpringWebConfiguration`
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向测试中注入配置在Web应用程序中（例如，`DispatcherServlet`）的bean，这些测试使用了`@SpringWebConfiguration`注解
- en: Support for both Spring (`@Autowired`, `@Qualifier`, `@Required`) and JSR 330
    (`@Inject`, `@Named`) annotations
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持Spring（`@Autowired`、`@Qualifier`、`@Required`）和JSR 330（`@Inject`、`@Named`）注解
- en: Support for bean initialization (`@PostConstruct`)
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持bean初始化（`@PostConstruct`）
- en: Autopackaging the `spring-context` and `spring-web` artifacts
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动打包`spring-context`和`spring-web`组件
- en: 'To add the Spring extension to your project, you need to add the following
    artifacts to your build script (using the latest versions from [http://arquillian.org/modules/spring-extension](http://arquillian.org/modules/spring-extension)):'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Spring扩展添加到您的项目中，您需要在构建脚本中添加以下组件（使用来自[http://arquillian.org/modules/spring-extension](http://arquillian.org/modules/spring-extension)的最新版本）：
- en: '[PRE24]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Required base artifact**'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 必需的基本组件***'
- en: '***2* Optional artifact, required when using annotation-based configuration
    (recommended)**'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 可选组件，当使用基于注解的配置时需要（推荐）***'
- en: We’re not going to look at the file-based configuration, because we’re sure
    even the most hardcore Spring gurus are now using annotation-based configuration.
    Let’s look at a basic test that contains all the relevant elements (code/video/i-tests/src/test/java/book/video/YoutubeVideosArquillianTest.java).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会查看基于文件的配置，因为我们确信即使是经验最丰富的Spring大师现在也在使用基于注解的配置。让我们看看一个包含所有相关元素的基本测试（code/video/i-tests/src/test/java/book/video/YoutubeVideosArquillianTest.java）。
- en: Listing 4.8\. Using the Spring Framework extension
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.8\. 使用Spring框架扩展
- en: '[PRE25]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* Lists all the classes that produce @Bean implementations (the Spring
    equivalent of the Java EE @Produces annotation)**'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 列出所有产生`@Bean`实现的类（Spring对Java EE `@Produces`注解的等效）***'
- en: '***2* A typical @Bean producer—the perfect place to create a mock, if required**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 典型的`@Bean`生产者——如果需要，这是一个创建模拟的理想位置***'
- en: '***3* The usual Arquillian deployment archive**'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 常规的Arquillian部署归档***'
- en: '***4* Injects an implementation using the @Autowired annotation**'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用`@Autowired`注解注入实现***'
- en: '***5* Standard test that can use the injected resources**'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 可以使用注入资源的标准测试***'
- en: 'That covers all you need to know about testing a standard Spring application.
    There are a few more annotations covering more-advanced topics that are outside
    the scope of this book and border on requiring a Spring tutorial; visit the extension
    website at mng.bz/Y4J8 to get a better understanding of what’s available. The
    following annotations are supported and will be familiar to Spring developers:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了您需要了解的所有关于测试标准Spring应用程序的知识。还有一些更高级的注释，这些注释超出了本书的范围，几乎需要Spring教程；访问扩展网站mng.bz/Y4J8以更好地了解可用的内容。以下注释受支持，并且Spring开发者会感到熟悉：
- en: '`@SpringWebConfiguration`—For MVC testing'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SpringWebConfiguration`—用于MVC测试'
- en: '`@EnableWebMvc`—Also for MVC testing'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@EnableWebMvc`—也用于MVC测试'
- en: '`@ComponentScan`—Scanning for `@Component`-annotated beans, rather than `@Bean`
    producers'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ComponentScan`—扫描带有`@Component`注释的Bean，而不是`@Bean`生产者'
- en: '`@OverProtocol`—For defining the underlying protocol'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@OverProtocol`—用于定义底层协议'
- en: 4.8.2\. Testing Spring Boot applications
  id: totrans-342
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.8.2\. 测试Spring Boot应用程序
- en: Spring Boot is a technology that’s rapidly growing in popularity. At the time
    of writing, there’s only experimental Arquillian integration with the Spring Framework
    extension for a Spring Boot–based application.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot是一种迅速增长的流行技术。在撰写本文时，只有基于Spring Boot应用程序的Spring框架扩展的实验性Arquillian集成。
- en: It would be possible to create a test that ignores or sidesteps the defining
    `@SpringBootApplication` annotation, but that would be cheating. For now, it’s
    helpful to see and understand how you can test a Spring Boot application that’s
    intended to run as a microservice. The application consists of a `Main` class
    that’s annotated with `@SpringBootApplication`. This clearly denotes the beginning
    of a Spring Boot application, and it fires up classpath scanning and discovery.
    That’s what we mean by sidestepping—you could create an Arquillian test that emulates
    the automatic configuration that’s performed by `@SpringBootApplication`. We’ll
    leave that as an exercise for experienced Spring developers.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能创建一个忽略或绕过定义`@SpringBootApplication`注释的测试，但这将是作弊行为。目前，了解和理解如何测试旨在作为微服务运行的Spring
    Boot应用程序是有帮助的。该应用程序由一个带有`@SpringBootApplication`注释的`Main`类组成。这清楚地表明了Spring Boot应用程序的开始，并启动了类路径扫描和发现。这就是我们所说的绕过——您可以为经验丰富的Spring开发者创建一个模拟`@SpringBootApplication`执行的自动配置的Arquillian测试。我们将把这个留作经验丰富的Spring开发者的练习。
- en: Here’s the `Main` class used in the book’s video service project.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是书中视频服务项目使用的`Main`类。
- en: Listing 4.9\. code/video/src/main/java/book/video/Main.java
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.9\. code/video/src/main/java/book/video/Main.java
- en: '[PRE26]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* Denotes the Main class as a—you guessed it—Spring Boot application**'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将Main类标记为——您猜对了——Spring Boot应用程序**'
- en: '***2* A standard static void main method for a runnable Java application class**'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 一个可运行的Java应用程序类的标准静态void main方法**'
- en: The next step is to tell the test class where to find the `Main` class. This
    is done by adding the `@SpringApplicationConfiguration` that points to the class
    in hand (code/video/i-tests/src/test/java/book/video/YoutubeVideosTest.java).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是告诉测试类在哪里可以找到`Main`类。这是通过添加指向当前类的`@SpringApplicationConfiguration`来完成的（code/video/i-tests/src/test/java/book/video/YoutubeVideosTest.java）。
- en: Listing 4.10\. Adding `@SpringApplicationConfiguration`
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.10\. 添加`@SpringApplicationConfiguration`
- en: '[PRE27]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Initializes the unit test using the Spring JUnit class, rather than Arquillian**'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用Spring JUnit类初始化单元测试，而不是Arquillian**'
- en: '***2* Points to the Spring Boot application class, Main.java**'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 指向Spring Boot应用程序类，Main.java**'
- en: '***3* Injects a bean class**'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注入一个Bean类**'
- en: '***4* From this point on, the test will work exactly as you’d expect.**'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 从现在开始，测试将完全按照您预期的那样工作。**'
- en: 4.9\. More-complex Arquillian test examples
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9\. 更复杂的Arquillian测试示例
- en: 'The next few sections take a quick look at some example tests that build on
    everything we’ve just explained. If you see something that hasn’t been discussed
    yet, don’t worry: make note of it, and see if you can work out what it does by
    reading the code. Arquillian tries to be as easy to understand as possible, but
    having a wealth of plugins can sometimes increase the learning curve. The following
    chapters introduce these advanced plugin features along the way.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几节将简要介绍一些示例测试，这些测试基于我们刚刚解释的内容。如果您看到尚未讨论的内容，请不要担心：记下来，并尝试通过阅读代码来找出它是做什么的。Arquillian试图尽可能容易理解，但丰富的插件有时会增加学习曲线。以下章节在介绍这些高级插件功能的同时进行。
- en: 4.9.1\. Testing the remote component
  id: totrans-359
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.9.1\. 测试远程组件
- en: The remote component is where your microservice domain component touches anything
    that could be considered a remote resource. This wouldn’t include something as
    complex as a remote database, because that dwells in the persistence scope and
    is masked by the ORM layer or some other conventional API. Think more along the
    lines of something for which you specifically have to write the client access
    code—your own remote API.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 远程组件是您的微服务领域组件接触任何可能被认为是远程资源的地方。这不会包括像远程数据库这样复杂的东西，因为那属于持久化范围，并且被 ORM 层或其他传统
    API 所掩盖。更多地考虑那些您必须专门编写客户端访问代码的情况——您的远程 API。
- en: You’re looking to test the interactions between your microservice domain component
    and the remote component; not the remote component to the actual remote resource—that
    would be considered a contract test, which is covered in [chapter 6](kindle_split_015_split_000.xhtml#ch06).
    In a component test, you’re not allowed to make calls outside of the local machine.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要测试微服务领域组件与远程组件之间的交互；而不是远程组件与实际远程资源之间的交互——这将被视为合同测试，它包含在第 6 章（[chapter 6](kindle_split_015_split_000.xhtml#ch06)）中。在组件测试中，您不允许在本地机器之外进行调用。
- en: 'The following listing is an example of code reuse (code/game/src/test/java/book/games/arquillian/ArquillianAbstractTest.java).
    You’ll use it as a base class for some tests: creating the base deployment archive
    and mocking remote calls. Have a quick look, and then we’ll explain.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表是一个代码重用的示例（code/game/src/test/java/book/games/arquillian/ArquillianAbstractTest.java）。您将把它用作一些测试的基础类：创建基本部署存档和模拟远程调用。快速浏览一下，然后我们将进行解释。
- en: Listing 4.11\. Test for the remote component
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.11\. 远程组件的测试
- en: '[PRE28]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* WireMock stubbing of the [https://www.igdb.com/](https://www.igdb.com/)
    API remote calls that will be performed before each test (@Before)**'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在每个测试之前（@Before）对 [https://www.igdb.com/](https://www.igdb.com/) API
    远程调用进行 WireMock 模拟**'
- en: '***2* WireMockRule that defines which port to listen on. The rule can do a
    lot more than just define a port.**'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* WireMock 规则定义了要监听的端口。该规则可以做的不仅仅是定义端口。**'
- en: '***3* Utility method that creates the minimum archive to test against. You
    can use this archive in implementations and add more items to it using ShrinkWrap
    methods.**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建用于测试的最小存档的实用方法。您可以在实现中使用此存档，并使用 ShrinkWrap 方法向其中添加更多项目。**'
- en: WireMock is basically a real HTTP proxy server that listens to a defined port
    (using `WireMockRule`). The IGDB API is well defined and version stable. It’s
    a REST API, like the one the microservice resource component depicts. This means
    you can intercept remote calls on a defined port and simulate the runtime responses.
    You don’t need to change a single line of code in any of your runtime classes!
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: WireMock 基本上是一个真实的 HTTP 代理服务器，它监听一个定义的端口（使用 `WireMockRule`）。IGDB API 定义良好且版本稳定。它是一个
    REST API，就像微服务资源组件所描述的那样。这意味着您可以在定义的端口上拦截远程调用并模拟运行时响应。您不需要在运行时类中更改任何一行代码！
- en: In [listing 4.11](kindle_split_013_split_009.xhtml#ch04ex11), `stubFor` is a
    comprehensive use case that intercepts a GET call to a known API path, /games/search,
    using a query parameter `q` with the value `"Zelda"` and with an HTTP `Authorization`
    header equal to “Token . . .”. If everything matches, it then returns a response
    with code 200 (OK) that contains JSON with a specific body content, as defined
    by the IGDB API ([http://mng.bz/xVF4](http://mng.bz/xVF4)).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 4.11](kindle_split_013_split_009.xhtml#ch04ex11) 中，`stubFor` 是一个综合用例，它拦截了对已知
    API 路径 /games/search 的 GET 调用，使用查询参数 `q` 的值为 `"Zelda"`，以及 HTTP `Authorization`
    标头等于“Token ...”。如果一切匹配，它将返回一个包含特定正文内容的 JSON 响应，正文内容由 IGDB API 定义（[http://mng.bz/xVF4](http://mng.bz/xVF4)）。
- en: '|  |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The power of WireMock**'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**WireMock 的力量**'
- en: There’s some pretty powerful magic going on in [listing 4.11](kindle_split_013_split_009.xhtml#ch04ex11)
    with WireMock ([http://wiremock.org](http://wiremock.org)). In the application,
    you’ll find a class named `IgdbGateway.class`—this is the gateway component that
    the microservice remote-resource component `GamesService.class` wraps/uses to
    make real remote calls to the [www.igdb.com](http://www.igdb.com) API.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 4.11](kindle_split_013_split_009.xhtml#ch04ex11) 中，WireMock ([http://wiremock.org](http://wiremock.org))
    进行了一些相当强大的操作。在应用程序中，您会找到一个名为 `IgdbGateway.class` 的类——这是微服务远程资源组件 `GamesService.class`
    所封装/使用的网关组件，用于对 [www.igdb.com](http://www.igdb.com) API 进行真实的远程调用。
- en: This is a concrete class with no interface that’s injected into the application.
    If you wanted to mock this class, how would you do it? Without extracting an interface
    and separating the implementation, so that you could use a dummy implementation
    to test against, you’d have a difficult time. In the past, that’s exactly what
    you would have done; or you would have had to think up another fancy solution
    like using CDI alternatives in tests, just to run a unit test.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个没有接口的具体类，被注入到应用程序中。如果你想要模拟这个类，你会怎么做？如果没有提取接口并分离实现，以便可以使用虚拟实现进行测试，你会遇到困难。在过去，这正是你可能会做的事情；或者你可能需要想出另一个复杂的解决方案，比如在测试中使用CDI替代方案，只是为了运行单元测试。
- en: Another approach could be to use something like Mockito’s `when([method-call]).thenReturn([response]])`,
    which is great for mocking interfaces and *some* objects. We say *some* because
    mocking a concrete object can have many unknown side effects that require proper
    analysis and a good understanding of the class at hand. Even if you got that far,
    what would happen when this mocked object was packaged and deployed to a container?
    The simple answer is, try it and see. The long answer goes beyond the scope of
    this book.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法可能是使用类似于Mockito的`when([方法调用]).thenReturn([响应])`，这对于模拟接口和*某些*对象来说非常好。我们说*某些*，因为模拟一个具体对象可能会产生许多未知的副作用，这需要适当的分析和对当前类的良好理解。即使你做到了这一点，当这个模拟对象被打包并部署到容器中时会发生什么？简单的答案是，试试看。长答案超出了本书的范围。
- en: '|  |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'To see the significance of the `stubFor` WireMock interceptor, let’s look at
    a test that uses it: the `ArquillianRemoteTest` class (code/game/src/test/java/book/games/arquillian/ArquillianRemoteTest.java).'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到`stubFor` WireMock拦截器的重要性，让我们看看一个使用它的测试：`ArquillianRemoteTest`类（code/game/src/test/java/book/games/arquillian/ArquillianRemoteTest.java）。
- en: Listing 4.12\. Using a WireMock interceptor in a test
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.12\. 在测试中使用WireMock拦截器
- en: '[PRE29]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* The test class extends the base class and is annotated in the usual fashion.**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 测试类扩展了基类，并按照常规方式进行注解。**'
- en: '***2* Creates the archive using the utility method, and adds the elements specific
    to this test—in particular, the WireMock standalone library**'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用实用方法创建存档，并添加特定于此测试的元素——特别是WireMock独立库**'
- en: '***3* Injects the unchanged concrete IgdbGateway class**'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注入未更改的具体IgdbGateway类**'
- en: '***4* Directs testing of the concrete class method, which is intercepted by
    the WireMock proxy**'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 指导对具体类方法的测试，该方法被WireMock代理拦截**'
- en: '|  |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You could at this point have injected and tested `GamesService.class`, which
    is the microservice remote-resource component in a real sense. The example instead
    injects `IgdbGateway.class` to demonstrate the WireMock stubbing for a concrete
    class.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，你可以注入并测试`GamesService.class`，这在实际意义上是微服务远程资源组件。示例中相反地注入了`IgdbGateway.class`来演示对具体类的WireMock存根。
- en: '|  |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You may be wondering how the `IgdbGateway` class knows to call the proxy. You
    may remember that when discussing the arquillian.xml file, we mentioned the significance
    of the `javaVmArguments` property. This property defines JVM system properties
    using the standard Java command-line option `-D`. `IgdbGateway` defines the `IGDB_API_KEY`
    property to set the API key and the `IGDB_HOST` property to set the host URL,
    to access the real service:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道`IgdbGateway`类是如何知道调用代理的。你可能记得在讨论`arquillian.xml`文件时，我们提到了`javaVmArguments`属性的的重要性。此属性使用标准的Java命令行选项`-D`定义JVM系统属性。`IgdbGateway`定义了`IGDB_API_KEY`属性来设置API密钥，以及`IGDB_HOST`属性来设置主机URL，以访问真实服务：
- en: '[PRE30]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When the test is run, Arquillian starts the container and provides the arguments
    via the configuration. The `IgdbGateway` class reads the properties and uses the
    dummy key and URL to make remote calls. These real remote calls are intercepted
    by the local WireMock proxy, which returns the constructed response. How neat
    is that? You’ll see more from WireMock throughout the rest of the book.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试运行时，Arquillian启动容器并通过配置提供参数。`IgdbGateway`类读取属性，并使用虚拟密钥和URL进行远程调用。这些真实远程调用被本地的WireMock代理拦截，并返回构造的响应。这有多酷？你将在本书的其余部分看到更多关于WireMock的内容。
- en: 4.9.2\. Testing the resource component
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.9.2\. 测试资源组件
- en: The resource component is where you expose microservice features through a RESTful
    endpoint—like your own API. To test this component properly, you have to *think*
    like a client application. How would a client call the endpoint resources in the
    wild?
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 资源组件是你通过RESTful端点公开微服务功能的地方——就像你自己的API。为了正确测试这个组件，你必须像客户端应用程序一样思考。客户端会如何调用野外端点的资源？
- en: Let’s keep this test as simple as possible. Similar to the previous test, this
    test extends `ArquillianAbstractTest` to reuse the archive and WireMock proxy.
    Let’s first look at the test, and then we’ll explain what’s going on (code/game/src/test/java/book/games/arquillian/ArquillianResourceTest.java).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尽可能保持这个测试的简单性。类似于之前的测试，这个测试通过扩展`ArquillianAbstractTest`来重用存档和WireMock代理。让我们首先看看测试，然后我们将解释正在发生的事情（code/game/src/test/java/book/games/arquillian/ArquillianResourceTest.java）。
- en: Listing 4.13\. Test for the resource component
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.13\. 资源组件的测试
- en: '[PRE31]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* Reuses code by extending a base class that provides a baseline testing
    environment**'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 通过扩展提供基线测试环境的基础类来重用代码**'
- en: '***2* New annotated option that creates an archive for deployment**'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 新的注解选项，用于创建部署存档**'
- en: '***3* New @RunAsClient annotation for a test method**'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 新的 @RunAsClient 注解用于测试方法**'
- en: '***4* New annotated parameter @Arquillian-Resource that injects a URL**'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 新的注解参数 @Arquillian-Resource，用于注入URL**'
- en: '***5* Uses the injected URL to build a JAX-RS target to call**'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用注入的URL构建JAX-RS目标进行调用**'
- en: '***6* Obtains and waits for an asynchronous response from the server**'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 从服务器获取并等待异步响应**'
- en: '***7* Retrieves a strongly typed collection from the response to test**'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 从响应中检索强类型集合以进行测试**'
- en: There are several new elements to discuss here. First, we’ll address the `@Deployment(testable
    = false)` and `@RunAsClient` annotations, because they mean more or less the same
    thing. Defining an archive with `testable` as `false` means this archive will
    be completely isolated from the test class. It’s a black-box test, where Arquillian
    has no knowledge of what the archive contains and deploys the archive as is. You
    can’t inject or use anything from the archive in the test class, which makes this
    class a perfect example for the current use case. Using `@Deployment(testable
    = false)` effectively says *all* test methods in this class are to run as an isolated
    client.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有几个新的元素需要讨论。首先，我们将讨论`@Deployment(testable = false)`和`@RunAsClient`注解，因为它们或多或少意味着相同的事情。将`testable`设置为`false`定义的存档将完全与测试类隔离。这是一个黑盒测试，Arquillian对存档包含的内容一无所知，并按原样部署存档。你无法在测试类中注入或使用存档中的任何内容，这使得这个类成为当前用例的完美示例。使用`@Deployment(testable
    = false)`实际上意味着这个类中的所有测试方法都将作为一个独立的客户端运行。
- en: Why do you need the `@RunAsClient` annotation on your test method? You don’t!
    It’s in this example to shorten the exercise. `@RunAsClient` basically says, “Run
    this specific test method isolated from the test.” You’d *normally* use one or
    the other approach in a test class, but not both together. The advantage of `@RunAsClient`
    is then clear. You use it in a test class that has multiple mixed-mode test methods,
    with some running isolated and others using injected resources.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要在测试方法上使用`@RunAsClient`注解？你不需要！这个例子中包含它只是为了缩短练习。`@RunAsClient`基本上意味着，“从这个测试中独立运行这个特定的测试方法。”你通常会在测试类中使用一种或另一种方法，但不会同时使用两种。`@RunAsClient`的优势因此变得明显。你会在具有多个混合模式测试方法的测试类中使用它，其中一些运行独立，而另一些则使用注入的资源。
- en: The next new annotation, `@ArquillianResource`, can be used either as a field
    annotation or, as you see here, as a method annotation. It’s possible to write
    your own `ArquillianResource` provider so that virtually anything can be injected
    by this annotation. Describing that here would be out of scope; if you want to
    know more, search the internet for “arquillian-extension-producer.”
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个新注解`@ArquillianResource`可以用作字段注解，或者，如你所见，用作方法注解。你可以编写自己的`ArquillianResource`提供程序，以便几乎可以通过这个注解注入任何内容。在这里描述它将超出范围；如果你想了解更多，请在互联网上搜索“arquillian-extension-producer”。
- en: Out of the box, you can inject a resource URL that’s relevant to the scope of
    your test. You already know how to configure your server and change the listening
    port, for example. But how does your isolated client test know about this? You
    could try to scan for and read the configuration, but that would be error prone,
    and it would also be useless if the container was configured to use a random port.
    Now you know that you can use the `@ArquillianResource` annotation to inject your
    URL.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，你可以注入一个与测试范围相关的资源URL。你已经知道如何配置服务器和更改监听端口，例如。但是你的独立客户端测试如何知道这一点呢？你可以尝试扫描并读取配置，但这会容易出错，如果容器配置为使用随机端口，这也会变得毫无用处。现在你知道你可以使用`@ArquillianResource`注解来注入你的URL。
- en: 4.9.3\. Testing the domain component
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.9.3\. 测试领域组件
- en: The domain component is tricky to describe from a testing point of view, not
    because it’s hard to test, but because it’s specific to your application. The
    main point to take away is that you need to test it no matter what. Arquillian
    may or may not be useful for this task.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 从测试的角度来看，描述领域组件是有些棘手的，不是因为测试它很难，而是因为它特定于你的应用程序。需要记住的主要点是无论怎样你都需要对其进行测试。Arquillian可能对这个任务有用也可能没有用。
- en: 'You should always follow these basic rules:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终遵循以下基本规则：
- en: Use a solitary unit test.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单独的单元测试。
- en: Never cross boundaries.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要跨越边界。
- en: The class under test should be the only concrete class in the test, if possible.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，被测试的类应该是测试中唯一的具体类。
- en: 4.9.4\. Testing the persistence component
  id: totrans-412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 4.9.4\. 测试持久化组件
- en: Just about every application you’ll ever write will contain some sort of persistence
    layer. It may be as trivial as a simple properties file to store application settings,
    or, at the opposite end of the scale, like the SAP Persistence Service. More often
    than not, you’ll use a database. These days, especially with Java EE, you’ll want
    to hide the native database implementations behind an object-relational mapping
    (ORM) system. We’ll assume you’re already familiar with topics like the Java Persistence
    API (JPA) and SQL. If you aren’t, please take the time to read up on these important
    topics before moving on to [chapter 5](kindle_split_014_split_000.xhtml#ch05),
    where testing the persistence component in a fully integrated test is covered
    in depth.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要编写的几乎每个应用程序都将包含某种持久化层。这可能只是一个简单的属性文件来存储应用程序设置，或者，在相反的一端，像SAP持久化服务。通常情况下，你会使用数据库。如今，尤其是在Java
    EE中，你可能会想要在对象关系映射（ORM）系统后面隐藏本地数据库实现。我们假设你已经熟悉诸如Java持久化API（JPA）和SQL等主题。如果你不熟悉，请在继续到第5章之前，花些时间了解这些重要主题，其中详细介绍了在完全集成测试中测试持久化组件。
- en: You know you’re not allowed to cross a remote boundary outside of your local
    machine, so how can you meet this challenge and use a database? You don’t want
    to change the semantics of your persistence context, so you can either mock the
    `EntityManager` or test against an embedded database. Mocking the `EntityManager`
    isn’t a great idea for a component test that needs to test persistence, because
    it sidesteps persistence. So, using an embedded database is our preferred option.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你不允许在本地机器之外跨越远程边界，那么你如何应对这个挑战并使用数据库呢？你不想改变持久化上下文的语义，因此你可以模拟`EntityManager`或针对嵌入式数据库进行测试。对于需要测试持久化的组件测试来说，模拟`EntityManager`并不是一个好主意，因为它绕过了持久化。因此，使用嵌入式数据库是我们的首选选项。
- en: There are several embedded databases in the Java ecosystem, some in the SQL
    space and others in the NoSQL ecosystem. Some of these databases use disk storage,
    and others use volatile in-memory storage. Due to their high performance, we recommend
    that you use an in-memory database for testing, if possible. [Table 4.2](kindle_split_013_split_009.xhtml#ch04table02)
    lists several vendors from the Java ecosystem that provide embedded/in-memory
    databases.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: Java生态系统中存在几个嵌入式数据库，一些在SQL空间，其他在NoSQL生态系统中。其中一些数据库使用磁盘存储，而其他则使用易失性的内存存储。由于它们的高性能，如果可能的话，我们建议你使用内存数据库进行测试。[表4.2](kindle_split_013_split_009.xhtml#ch04table02)列出了Java生态系统中提供嵌入式/内存数据库的几个供应商。
- en: Table 4.2\. Database vendors
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表4.2\. 数据库供应商
- en: '| Type | Project | Site |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 项目 | 网站 |'
- en: '| --- | --- | --- |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| SQL | HyperSQL | [http://hsqldb.org](http://hsqldb.org) |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| SQL | HyperSQL | [http://hsqldb.org](http://hsqldb.org) |'
- en: '| SQL | H2 | [www.h2database.com/html/main.html](http://www.h2database.com/html/main.html)
    |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| SQL | H2 | [www.h2database.com/html/main.html](http://www.h2database.com/html/main.html)
    |'
- en: '| SQL | Derby | [http://db.apache.org/derby](http://db.apache.org/derby) |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| SQL | Derby | [http://db.apache.org/derby](http://db.apache.org/derby) |'
- en: '| NoSQL MongoDB | Fongo | [https://github.com/fakemongo/fongo](https://github.com/fakemongo/fongo)
    |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| NoSQL MongoDB | Fongo | [https://github.com/fakemongo/fongo](https://github.com/fakemongo/fongo)
    |'
- en: '| NoSQL Neo4J | Neo4J | [https://neo4j.com/](https://neo4j.com/) |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| NoSQL Neo4J | Neo4J | [https://neo4j.com/](https://neo4j.com/) |'
- en: '| NoSQL Infinispan | Infinispan | [http://infinispan.org/](http://infinispan.org/)
    |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| NoSQL Infinispan | Infinispan | [http://infinispan.org/](http://infinispan.org/)
    |'
- en: Notice that currently, in the SQL sphere, you have several options to choose
    from out of the box. For the NoSQL ecosystem, you’ll need to rely on vendor support
    for embedded-mode versions.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，目前，在 SQL 领域，你可以在开箱即用的基础上从几个选项中进行选择。对于 NoSQL 生态系统，你需要依赖供应商对嵌入式模式的版本支持。
- en: Based on our experience, the best SQL embedded in-memory database to use for
    testing purposes is H2\. It provides good performance for both read and write
    operations, and it offers compatibility modes for major SQL vendors like IBM DB2,
    MS SQL Server, MySQL, Oracle, and PostgreSQL. All this and a small footprint of
    just 1 MB make it hard to beat.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的经验，用于测试目的的最佳 SQL 嵌入式内存数据库是 H2。它为读写操作都提供了良好的性能，并为 IBM DB2、MS SQL Server、MySQL、Oracle
    和 PostgreSQL 等主要 SQL 供应商提供了兼容模式。所有这些加上仅 1 MB 的小体积使其难以被超越。
- en: The example Gamer application uses one SQL database and two NoSQL databases
    (Redis and MongoDB). Unfortunately, there’s no support for embedded Redis; in
    cases where it wouldn’t be possible to run component tests at the speed of light,
    we recommend that you skip them and write an integration test, instead. You’ll
    learn more about this in [chapter 5](kindle_split_014_split_000.xhtml#ch05).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 Gamer 应用程序使用一个 SQL 数据库和两个 NoSQL 数据库（Redis 和 MongoDB）。不幸的是，没有嵌入式 Redis 的支持；在无法以光速运行组件测试的情况下，我们建议你跳过它们，而是编写一个集成测试。你将在第
    5 章（kindle_split_014_split_000.xhtml#ch05）中了解更多关于这一点。
- en: 'To use H2, you need to import the `com.h2database:h2:<version>` dependency
    in your project with the scope `test`, using the build tool you’ve chosen. The
    next step is to configure the JDBC driver using H2-specific parameters; for example:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 H2，你需要使用你选择的构建工具将 `com.h2database:h2:<version>` 依赖项导入你的项目，范围设置为 `test`。下一步是使用
    H2 特定的参数配置 JDBC 驱动程序；例如：
- en: '[PRE32]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* The last URL parameter (test) is used as the database identifier or name.**'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 最后的 URL 参数（test）用作数据库标识符或名称。**'
- en: To use H2, you need to set the H2 JDBC driver to `org.h2.Driver` and the URL
    of the connection to `jdbc:h2:mem:test`. This URL defines the `mem` keyword, which
    tells the H2 driver to work using in-memory mode. The last parameter of the URL
    is the database identifier, which is used to avoid clashes when starting more
    than one in-memory database in the same JVM. Finally, you need to set the user
    and password (for testing, you can use `sa` as the username and a blank password).
    Following these steps reconfigures the persistence layer (boundary) to use the
    H2 database instead of the one configured for production.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 H2，你需要将 H2 JDBC 驱动程序设置为 `org.h2.Driver`，并将连接的 URL 设置为 `jdbc:h2:mem:test`。此
    URL 定义了 `mem` 关键字，它告诉 H2 驱动程序以内存模式工作。URL 的最后一个参数是数据库标识符，它用于在同一个 JVM 中启动多个内存数据库时避免冲突。最后，你需要设置用户名和密码（对于测试，可以使用
    `sa` 作为用户名，空密码）。按照这些步骤重新配置持久层（边界）以使用 H2 数据库而不是为生产配置的数据库。
- en: 'All services in the application that use a SQL database should write component
    tests for the persistence boundary using H2, which will ensure that testing performance
    isn’t compromised. Use the ShrinkWrap microdeployment feature to include the test-persistence
    configuration into the deployment file:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中所有使用 SQL 数据库的服务都应该使用 H2 为持久边界编写组件测试，这将确保测试性能不受影响。使用 ShrinkWrap 微部署功能将测试持久性配置包含到部署文件中：
- en: '[PRE33]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ShrinkWrap copies test-persistence.xml from src/test/resources and adds it to
    the microdeployment file at the location META-INF/persistence.xml.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: ShrinkWrap 将 src/test/resources 中的 test-persistence.xml 复制并添加到微部署文件中的位置为 META-INF/persistence.xml。
- en: The comments service uses a MongoDB database in the persistence layer. MongoDB
    also isn’t available as an embedded solution, so every time you need to use it,
    you’ll have to spin up a `mongod` process. To avoid this problem during testing,
    the Fongo project was established.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 评论服务在持久层使用 MongoDB 数据库。MongoDB 也不是嵌入式解决方案，所以每次需要使用它时，你都需要启动一个 `mongod` 进程。为了避免在测试期间出现这个问题，Fongo
    项目被建立。
- en: '*Fongo* is an in-memory Java implementation of MongoDB. It intercepts calls
    to the standard `mongo-java-driver` for finds, updates, inserts, removes, and
    several other useful methods. Although it has some limitations, it supports most
    of the common operations required to use MongoDB. To use Fongo, you need to import
    the `com.github.fakemongo:fongo:<version>` dependency in your project with the
    scope `test`, using your build tool of choice.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '*Fongo* 是MongoDB的内存中Java实现。它拦截了对标准`mongo-java-driver`的查找、更新、插入、删除和其他几个有用方法的调用。尽管它有一些限制，但它支持使用MongoDB所需的大部分常见操作。要使用Fongo，你需要将`com.github.fakemongo:fongo:<version>`依赖项导入你的项目中，范围设置为`test`，使用你选择的构建工具。'
- en: 'The next step is to instantiate the `com.github.fakemongo.Fongo` class and
    get a `com.mongodb.DB` object reference, which in this case is a Fongo custom
    implementation:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实例化`com.github.fakemongo.Fongo`类，并获取一个`com.mongodb.DB`对象引用，在这种情况下是一个Fongo自定义实现：
- en: '[PRE34]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* Creates a Fongo instance**'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个Fongo实例**'
- en: '***2* Gets the MongoDB driver overridden classes**'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 获取覆盖的MongoDB驱动程序类**'
- en: The most important step is creating the Fongo instance. After that, you can
    get the overridden MongoDB classes from the Java driver, which can then be passed
    to the boundary instead of the real classes.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的一步是创建Fongo实例。之后，你可以从Java驱动程序中获取覆盖的MongoDB类，然后将它们传递给边界而不是真实类。
- en: In [chapter 5](kindle_split_014_split_000.xhtml#ch05), we’ll go deeper into
    this topic and highlight some problems you may encounter when writing persistence
    tests, and how to fix them. The only difference between what you’ve just learned
    and the discussion in [chapter 5](kindle_split_014_split_000.xhtml#ch05) is that
    this example used an in-memory embedded database, and later you’ll use a *real*
    remote database. The concepts are the same.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](kindle_split_014_split_000.xhtml#ch05)中，我们将更深入地探讨这个主题，并突出你在编写持久性测试时可能遇到的一些问题，以及如何解决这些问题。你刚刚学到的东西和[第5章](kindle_split_014_split_000.xhtml#ch05)中的讨论之间的唯一区别是，这个示例使用了一个内存中的嵌入式数据库，而后来你将使用一个*真实*的远程数据库。概念是相同的。
- en: When you read [chapter 5](kindle_split_014_split_000.xhtml#ch05), remember what
    you’ve learned here. Also, take a good look at the demo code and use it as a template
    for your own tests.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读[第5章](kindle_split_014_split_000.xhtml#ch05)时，请记住在这里学到的内容。同时，仔细查看示例代码，并将其作为你自己的测试模板使用。
- en: Exercises
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习
- en: Putting this chapter into practice may seem daunting right now, so start small
    and build up your confidence using the ShrinkWrap utility and the Arquillian testing
    framework. As a simple exercise, just to get started, find all the uses of `ShrinkWrap.create`
    in the demo code; then, using the generated archive `toString` methods, print
    out the contents to the console. Doing so will help you understand how the archives
    are made up, and what’s required to perform useful Arquillian tests.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 将本章内容付诸实践可能现在看起来有些令人畏惧，所以从小处着手，利用ShrinkWrap实用工具和Arquillian测试框架逐步建立信心。作为一个简单的练习，为了开始，找到示例代码中所有`ShrinkWrap.create`的使用；然后，使用生成的归档`toString`方法，将内容打印到控制台。这样做将帮助你理解归档是如何组成的，以及执行有用的Arquillian测试所需的内容。
- en: For a more advanced task, look back at `ArquillianResourceTest` in the game
    service project. You’ll see that it uses `ClientBuilder` to create a REST client.
    That’s a lot of boilerplate for a test method, but you know Arquillian can make
    your life a little easier here. Try to convert this test to use the Arquillian
    REST client, and see how much of the boilerplate code you can remove.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个更高级的任务，回顾游戏服务项目中的`ArquillianResourceTest`。你会看到它使用`ClientBuilder`来创建REST客户端。对于一个测试方法来说，这有很多样板代码，但你知道Arquillian可以在这里让你轻松一些。尝试将这个测试转换为使用Arquillian
    REST客户端，并看看你可以移除多少样板代码。
- en: Summary
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Use the Arquillian workflow to automate as much of your tests as possible.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Arquillian工作流尽可能自动化你的测试。
- en: Annotate a standard test class with Arquillian-specific annotations to remove
    boilerplate code.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Arquillian特定的注解注释一个标准测试类，以删除样板代码。
- en: Define repeated elements of deployment archives in base classes or utility classes—write
    once, and reuse.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基类或工具类中定义部署归档的重复元素——编写一次，即可重用。
- en: Inject testable elements into a test class to test against.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可测试的元素注入到测试类中以进行测试。
- en: Create flexible test environments against multiple containers using Maven profiles
    for plugins.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Maven配置文件为插件创建针对多个容器的灵活测试环境。
- en: Override the default container options in the arquillian.xml file.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在arquillian.xml文件中覆盖默认的容器选项。
- en: Use Arquillian extensions to provide a feature-rich testing environment.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Arquillian扩展提供功能丰富的测试环境。
