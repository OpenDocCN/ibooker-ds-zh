- en: Part 2\. Docker and development
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分\. Docker 和开发
- en: In [part 1](kindle_split_009.xhtml#part01), you learned Docker’s core concepts
    and architecture by example. [Part 2](#part02) will take you from this base and
    demonstrate ways Docker can be used in development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第一部分](kindle_split_009.xhtml#part01) 中，你通过示例学习了 Docker 的核心概念和架构。[第二部分](#part02)
    将带你从这个基础出发，展示 Docker 在开发中的应用。
- en: '[Chapter 3](kindle_split_013.xhtml#ch03) covers using Docker as a lightweight
    virtual machine. This is a controversial area. Although there are critical differences
    between virtual machines and Docker containers, development can be sped up considerably
    in many cases by using Docker. It’s also an effective means of getting familiar
    with Docker before we move into more advanced Docker usage.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 3 章](kindle_split_013.xhtml#ch03) 涵盖了使用 Docker 作为轻量级虚拟机。这是一个有争议的领域。尽管虚拟机和
    Docker 容器之间存在关键差异，但在许多情况下，使用 Docker 可以显著加快开发速度。这也是一个在进入更高级的 Docker 使用之前熟悉 Docker
    的有效方法。'
- en: '[Chapters 4](kindle_split_014.xhtml#ch04), [5](kindle_split_015.xhtml#ch05),
    and [6](kindle_split_016.xhtml#ch06) cover over 20 techniques to make building,
    running, and managing Docker containers more effective and efficient. In addition
    to building and running containers, you’ll learn about persisting data with volumes
    and keeping your Docker host in order.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 4 章](kindle_split_014.xhtml#ch04)，[第 5 章](kindle_split_015.xhtml#ch05)，和
    [第 6 章](kindle_split_016.xhtml#ch06) 涵盖了超过 20 种技术，使构建、运行和管理 Docker 容器更加高效。除了构建和运行容器外，你还将学习如何使用卷持久化数据以及保持你的
    Docker 主机有序。'
- en: '[Chapter 7](kindle_split_017.xhtml#ch07) covers the important area of configuration
    management. You’ll use Dockerfiles and traditional configuration management tools
    to get control of your Docker builds. We’ll also cover the creation and curation
    of minimal Docker images to reduce image bloat. By the end of this part you’ll
    have a wealth of useful techniques for single-use Docker and be ready to take
    Docker into a DevOps context.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 7 章](kindle_split_017.xhtml#ch07) 涵盖了配置管理的重要领域。你将使用 Dockerfile 和传统的配置管理工具来控制你的
    Docker 构建。我们还将涵盖创建和维护最小 Docker 镜像以减少镜像膨胀。在本部分结束时，你将拥有大量有用的技术，用于单次使用的 Docker，并准备好将
    Docker 带入 DevOps 环境。'
- en: Chapter 3\. Using Docker as a lightweight virtual machine
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 章\. 使用 Docker 作为轻量级虚拟机
- en: '|  |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Converting a virtual machine to a Docker image
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将虚拟机转换为 Docker 镜像
- en: Managing the startup of your container’s services
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理你的容器服务的启动
- en: Saving your work as you go
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行过程中保存你的工作
- en: Managing Docker images on your machine
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理你机器上的 Docker 镜像
- en: Sharing images on the Docker Hub
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Docker Hub 上共享镜像
- en: Playing—and winning—at 2048 with Docker
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用 Docker 玩 2048 并获胜
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Virtual machines (VMs) have become ubiquitous in software development and deployment
    since the turn of the century. The abstraction of machines to software has made
    the movement and control of software and services in the internet age easier and
    cheaper.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 自世纪初以来，虚拟机（VM）在软件开发和部署中变得无处不在。将机器抽象为软件使得在互联网时代软件和服务的移动和控制变得更加容易和便宜。
- en: '|  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: A virtual machine is an application that emulates a computer, usually to run
    an operating system and applications. It can be placed on any (compatible) physical
    resources that are available. The end user experiences the software as though
    it were on a physical machine, but those managing the hardware can focus on larger-scale
    resource allocation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机是一种模拟计算机的应用程序，通常用于运行操作系统和应用程序。它可以放置在任何（兼容的）可用的物理资源上。最终用户会像在物理机器上一样体验软件，但管理硬件的人员可以专注于更大规模的资源分配。
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Docker isn’t a VM technology. It doesn’t simulate a machine’s hardware and it
    doesn’t include an operating system. A Docker container is not, by default, constrained
    to specific hardware limits. If Docker virtualizes anything, it virtualizes the
    environment in which services run, not the machine. Moreover, Docker can’t easily
    run Windows software (or even that written for other Unix-derived operating systems).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 不是一个 VM 技术。它不模拟机器的硬件，也不包含操作系统。默认情况下，Docker 容器不受特定硬件限制。如果 Docker 虚拟化了任何东西，它虚拟化的是服务运行的环境，而不是机器。此外，Docker
    无法轻松运行 Windows 软件（甚至是为其他 Unix 衍生操作系统编写的软件）。
- en: From some standpoints, though, Docker can be used much as a VM. For developers
    and testers in the internet age, the fact that there’s no init process or direct
    hardware interaction is not usually of great significance. And there are significant
    commonalities, such as its isolation from the surrounding hardware and its amenability
    to more fine-grained approaches to software delivery.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从某些角度来看，Docker可以像虚拟机一样使用。对于互联网时代的开发人员和测试人员来说，没有init进程或直接硬件交互的事实通常并不重要。而且存在许多显著的共性，例如其与周围硬件的隔离以及其易于采用更细粒度的软件交付方法。
- en: This chapter will take you through the scenarios in which you could use Docker
    as you previously might have used a VM. Using Docker won’t give you any obvious
    functional advantages over a VM, but the speed and convenience Docker brings to
    the movement and tracking of environments can be a game-changer for your development
    pipeline.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带您了解您可能以前使用虚拟机时使用的Docker场景。使用Docker不会给您带来任何明显的功能优势，但Docker在环境移动和跟踪方面的速度和便利性可能会改变您的开发流程。
- en: 3.1\. From VM to container
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1. 从虚拟机到容器
- en: In an ideal world, moving from VMs to containers would be a simple matter of
    running configuration management scripts against a Docker image from a distribution
    similar to the VM’s. For those of us who aren’t in that happy state of affairs,
    this section will show how you can convert a VM to a container—or containers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个理想的世界里，从虚拟机迁移到容器将只是运行针对与虚拟机类似的Docker镜像的配置管理脚本这么简单。对于我们这些不处于这种幸福状态的人来说，本节将展示您如何将虚拟机转换为容器——或者容器。
- en: '|  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Converting your VM to a container**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**将您的虚拟机转换为容器**'
- en: The Docker Hub doesn’t have all possible base images, so for some niche Linux
    distributions and use cases, people need to create their own. For example, if
    you have an existing application state in a VM, you may want to put that state
    inside a Docker image so that you can iterate further on that, or to benefit from
    the Docker ecosystem by using tooling and related technology that exists there.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub没有所有可能的基镜像，因此对于一些利基Linux发行版和用例，人们需要创建自己的。例如，如果您在虚拟机中有一个现有的应用程序状态，您可能希望将该状态放入Docker镜像中，以便您可以在此基础上进一步迭代，或者通过使用存在于那里的工具和相关技术来从Docker生态系统获益。
- en: Ideally you’d want to build an equivalent of your VM from scratch using standard
    Docker techniques, such as Dockerfiles combined with standard configuration management
    tools (see [chapter 7](kindle_split_017.xhtml#ch07)). The reality, though, is
    that many VMs aren’t carefully configuration-managed. This might happen because
    a VM has grown organically as people have used it, and the investment needed to
    recreate it in a more structured way isn’t worth it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您可能希望从头开始构建您虚拟机的等效版本，使用标准的Docker技术，例如Dockerfile与标准配置管理工具相结合（参见第7章[chapter
    7](kindle_split_017.xhtml#ch07)）。然而，现实情况是，许多虚拟机并没有得到仔细的配置管理。这可能是因为虚拟机随着人们的使用而有机地增长，而将其以更结构化的方式重新创建所需的投入并不值得。
- en: '**PROBLEM**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You have a VM you want to convert to a Docker image.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您有一个想要转换为Docker镜像的虚拟机。
- en: '**SOLUTION**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Archive and copy the filesystem of the VM and package it into a Docker image.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 归档并复制虚拟机的文件系统，并将其打包成Docker镜像。
- en: 'First we’re going to divide VMs into two broad groups:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将虚拟机分为两大类：
- en: '*Local VM*—VM disk image lives on and VM execution happens on your computer.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*本地虚拟机*——虚拟机磁盘镜像存在于您的计算机上，虚拟机执行也在您的计算机上。'
- en: '*Remote VM*—VM disk image storage and VM execution happen somewhere else.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*远程虚拟机*——虚拟机磁盘镜像存储和虚拟机执行发生在别处。'
- en: The principle for both groups of VMs (and anything else you want to create a
    Docker image from) is the same—you get a TAR of the filesystem and `ADD` the TAR
    file to `/` of the `scratch` image.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两组虚拟机（以及您想要从其创建Docker镜像的任何其他内容）的原则是相同的——您得到一个文件系统的TAR包，并将TAR文件添加到`scratch`镜像的`/`目录下。
- en: '|  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `ADD` Dockerfile command (unlike its sibling command `COPY`) unpacks TAR
    files (as well as gzipped files and other similar file types) when they’re placed
    in an image like this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD` Dockerfile命令（与它的兄弟命令`COPY`不同）在它们放置在像这样的镜像中时，会解包TAR文件（以及gzip文件和其他类似文件类型）。'
- en: '|  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: The *scratch* image is a zero-byte pseudo-image you can build on top of. Typically
    it’s used in cases like this where you want to copy (or add) a complete filesystem
    using a Dockerfile.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`scratch`镜像是一个零字节的伪镜像，您可以在其上构建。通常，它用于此类情况，您想要使用Dockerfile复制（或添加）一个完整的文件系统。'
- en: '|  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: We’ll now look at a case where you have a local VirtualBox VM.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨一个您有一个本地VirtualBox虚拟机的情况。
- en: 'Before you get started, you need to do the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始之前，你需要做以下几步：
- en: Install the `qemu-nbd` tool (available as part of the `qemu-utils` package on
    Ubuntu).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`qemu-nbd`工具（在Ubuntu上作为`qemu-utils`包的一部分提供）。
- en: Identify the path to your VM disk image.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定你的虚拟机磁盘镜像的路径。
- en: Shut down your VM.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭你的虚拟机。
- en: If your VM disk image is in the .vdi or .vmdk format, this technique should
    work well. Other formats may experience mixed success. The following code demonstrates
    how you can turn your VM file into a virtual disk, which allows you to copy all
    the files from it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的虚拟机磁盘镜像格式为.vdi或.vmdk，这个技术应该效果很好。其他格式可能会遇到不同的成功。以下代码演示了如何将你的虚拟机文件转换为虚拟磁盘，这允许你复制其中的所有文件。
- en: Listing 3.1\. Extracting the filesystem of a VM image
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.1\. 提取虚拟机镜像的文件系统
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1*** **Sets up a variable pointing to your VM disk image**'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设置一个指向你的虚拟机磁盘镜像的变量**'
- en: '***2*** **Initializes a kernel module required by qemu-nbd**'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **初始化qemu-nbd所需的内核模块**'
- en: '***3*** **Connects the VM disk to a virtual device node**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将虚拟机磁盘连接到虚拟设备节点**'
- en: '***4*** **Lists the partition numbers available to mount on this disk**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **列出可用于在此磁盘上挂载的分区编号**'
- en: '***5*** **Mounts the selected partition at /mnt with qemu-nbd**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **使用qemu-nbd将选定的分区挂载到/mnt**'
- en: '***6*** **Creates a TAR file called img.tar from /mnt**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **从/mnt创建名为img.tar的TAR文件**'
- en: '***7*** **Unmounts and cleans up after qemu-nbd**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **卸载并清理qemu-nbd后的操作**'
- en: '|  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: To choose which partition to mount, run `sudo cfdisk /dev/nbd0` to see what’s
    available. Note that if you see LVM anywhere, your disk has a nontrivial partitioning
    scheme—you’ll need to do some additional research into how to mount LVM partitions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择要挂载的分区，运行`sudo cfdisk /dev/nbd0`以查看可用选项。注意，如果你在任何地方看到LVM，你的磁盘有一个非平凡的分区方案——你需要做一些额外的研究来了解如何挂载LVM分区。
- en: '|  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If your VM is kept remotely, you have a choice: either shut down the VM and
    ask your operations team to perform a dump of the partition you want, or create
    a TAR of your VM while it’s still running.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的虚拟机是远程管理的，你有选择：要么关闭虚拟机并要求你的运维团队执行你想要的分区的转储，要么在虚拟机运行时创建虚拟机的TAR文件。
- en: 'If you get a partition dump, you can mount this fairly easily and then turn
    it into a TAR file as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到了分区转储，你可以相当容易地挂载它，然后按照以下步骤将其转换为TAR文件：
- en: Listing 3.2\. Extracting a partition
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.2\. 提取分区
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can create a TAR file from a running system. This is quite
    simple after logging into the system:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以从运行中的系统创建一个TAR文件。在登录系统后，这个过程相当简单：
- en: Listing 3.3\. Extracting the filesystem of a running VM
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.3\. 提取运行中虚拟机的文件系统
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You now have a TAR of the filesystem image that you can transfer to a different
    machine with `scp`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经有了一个文件系统镜像的TAR文件，你可以使用`scp`将其传输到另一台机器。
- en: '|  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Creating a TAR from a running system may seem like the easiest option (no shutdowns,
    installing software, or making requests to other teams), but it has a severe downside—you
    could copy a file in an inconsistent state and hit strange problems when trying
    to use your new Docker image. If you must go this route, first stop as many applications
    and services as possible.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从运行中的系统创建TAR文件可能看起来是最简单的选项（无需关闭，安装软件或向其他团队提出请求），但它有一个严重的缺点——你可能会复制一个处于不一致状态的文件，并在尝试使用你的新Docker镜像时遇到奇怪的问题。如果你必须走这条路，首先尽可能停止尽可能多的应用程序和服务。
- en: '|  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Once you’ve got the TAR of your filesystem, you can add it to your image. This
    is the easiest step of the process and consists of a two-line Dockerfile.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得了你的文件系统的TAR文件，你可以将其添加到你的镜像中。这是这个过程最简单的一步，只需要一个两行的Dockerfile。
- en: Listing 3.4\. Adding an archive to a Docker image
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.4\. 将存档添加到Docker镜像
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can now run `docker build.` and you have your image!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行`docker build.`，你就有你的镜像了！
- en: '|  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Docker provides an alternative to `ADD` in the form of the `docker import` command,
    which you can use with `cat img.tar | docker import - new_image _name`. But building
    on top of the image with additional instructions will require you to create a
    Dockerfile anyway, so it may be simpler to go the `ADD` route, so you can easily
    see the history of your image.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供了`ADD`命令的替代方案，即`docker import`命令，你可以使用`cat img.tar | docker import -
    new_image _name`。但是，在镜像上使用额外指令构建将需要你创建一个Dockerfile，所以可能更简单的是走`ADD`路线，这样你可以轻松地查看你的镜像历史。
- en: '|  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You now have an image in Docker, and you can start experimenting with it. In
    this case, you might start by creating a new Dockerfile based on your new image,
    to experiment with stripping out files and packages.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经在 Docker 中有了镜像，你可以开始对其进行实验。在这种情况下，你可能从基于你的新镜像创建一个新的 Dockerfile 开始，以实验去除文件和包。
- en: Once you’ve done this and are happy with your results, you can use `docker export`
    on a running container to export a new, slimmer TAR that you can use as the basis
    for a newer image, and repeat the process until you get an image you’re happy
    with.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了这个，并且对结果满意，你就可以在运行的容器上使用 `docker export` 来导出一个新的、更精简的 TAR 文件，你可以将其用作创建新镜像的基础，并重复此过程，直到你得到一个满意的镜像。
- en: The flow chart in [figure 3.1](#ch03fig01) demonstrates this process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.1](#ch03fig01) 中的流程图展示了这个过程。'
- en: Figure 3.1\. Image-stripping flowchart
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.1\. 镜像剥离流程图
- en: '![](Images/03fig01_alt.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1](Images/03fig01_alt.jpg)'
- en: '**DISCUSSION**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This technique demonstrates a few fundamental principles and techniques that
    are useful in contexts other than converting a VM to a Docker image.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术演示了一些在将虚拟机转换为 Docker 镜像之外的环境中也有用的基本原理和技术。
- en: 'Most broadly, it shows that a Docker image is essentially a set of files and
    some metadata: the `scratch` image is an empty filesystem over which a TAR file
    can be laid. We’ll return to this theme when we look at *slim* Docker images.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最广泛地说，它表明 Docker 镜像本质上是一组文件和一些元数据：`scratch` 镜像是可以在其上放置 TAR 文件的空文件系统。当我们查看 *slim*
    Docker 镜像时，我们将回到这个主题。
- en: More specifically, you’ve seen how you can `ADD` a TAR file to a Docker image,
    and how you can use the `qemu-nbd` tool.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，你已经看到了如何将 TAR 文件添加到 Docker 镜像中，以及如何使用 `qemu-nbd` 工具。
- en: Once you have your image, you might need to know how to run it like a more traditional
    host. Because Docker containers typically run one application process only, this
    is somewhat against the grain, and it’s covered in the next technique.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了你的镜像，你可能需要知道如何像更传统的宿主机一样运行它。因为 Docker 容器通常只运行一个应用程序进程，这有些违背常理，下一项技术将涉及这一点。
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**A host-like container**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**类似主机的容器**'
- en: We’ll now move on to one of the more contentious areas of discussion within
    the Docker community—running a host-like image, with multiple processes running
    from the start.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转向 Docker 社区内讨论的更具争议性的领域之一——运行类似主机的镜像，从启动时就有多个进程运行。
- en: This is considered bad form in parts of the Docker community. Containers are
    not virtual machines—there are significant differences—and pretending there aren’t
    can cause confusion and issues down the line.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 社区的一些部分，这被认为是不良的格式。容器不是虚拟机——它们之间存在显著差异——假装没有差异可能会导致混淆和后续问题。
- en: For good or ill, this technique will show you how to run a host-like image and
    discuss some of the issues around doing this.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 无论好坏，这项技术将向你展示如何运行类似主机的镜像，并讨论一些与此相关的问题。
- en: '|  |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**注意**'
- en: Running a host-like image can be a good way to persuade Docker refuseniks that
    Docker is useful. As they use it more, they’ll understand the paradigm better
    and the microservices approach will make more sense to them. At the company we
    introduced Docker into, we found that this monolithic approach was a great way
    to move people from developing on dev servers and laptops to a more contained
    and manageable environment. From there, moving Docker into testing, continuous
    integration, escrow, and DevOps workflows was trivial.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 运行类似主机的镜像可以是说服 Docker 拒绝者 Docker 有用的好方法。随着他们更多地使用它，他们将更好地理解这种范式，并且微服务方法对他们来说将更有意义。在我们引入
    Docker 的公司，我们发现这种单体方法是将人们从在开发服务器和笔记本电脑上开发转移到更封闭和可管理的环境中的绝佳方式。从那里，将 Docker 引入测试、持续集成、托管和
    DevOps 工作流程变得微不足道。
- en: '|  |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Differences between VMs and Docker containers
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 虚拟机与 Docker 容器之间的差异
- en: 'These are a few of the differences between VMs and Docker containers:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是虚拟机和 Docker 容器之间的一些差异：
- en: Docker is application-oriented, whereas VMs are operating-system oriented.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 是以应用程序为导向的，而虚拟机是以操作系统为导向的。
- en: Docker containers share an operating system with other Docker containers. In
    contrast, VMs each have their own operating system managed by a hypervisor.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 容器与其他 Docker 容器共享操作系统。相比之下，每个虚拟机都有自己的操作系统，由虚拟机管理程序管理。
- en: Docker containers are designed to run one principal process, not manage multiple
    sets of processes.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 容器的设计是为了运行一个主要进程，而不是管理多个进程集。
- en: '|  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**PROBLEM**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want a normal host-like environment for your container with multiple processes
    and services set up.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望你的容器拥有一个类似主机的正常环境，其中设置了多个进程和服务。
- en: '**SOLUTION**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use a base container designed to run multiple processes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设计用于运行多个进程的基础容器。
- en: For this technique you’re going to use an image designed to simulate a host,
    and provision it with the applications you need. The base image will be the phusion/
    baseimage Docker image, an image designed to run multiple processes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个技术，你将使用一个设计用于模拟主机的镜像，并配备你需要的应用程序。基础镜像将是 phusion/baseimage Docker 镜像，这是一个设计用于运行多个进程的镜像。
- en: The first steps are to start the image and jump into it with `docker exec`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首步是启动镜像，然后使用 `docker exec` 进入它。
- en: Listing 3.5\. Running the phusion base image
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.5\. 运行 phusion 基础镜像
- en: '[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1*** **Starts the image in the background**'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在后台启动镜像**'
- en: '***2*** **Returns the ID of the new container**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **返回新容器的 ID**'
- en: '***3*** **Passes the container ID to docker exec and allocates an interactive
    terminal**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将容器 ID 传递给 docker exec 并分配一个交互式终端**'
- en: '***4*** **The prompt to the started container terminal**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **启动的容器终端的提示**'
- en: In this code, `docker run` will start the image in the background, starting
    the default command for the image and returning the ID of the newly created container.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`docker run` 将在后台启动镜像，启动镜像的默认命令，并返回新创建的容器的 ID。
- en: You then pass this container ID to `docker exec`, which is a command that starts
    a new process inside an already running container. The `-i` flag allows you to
    interact with the new process, and `-t` indicates that you want to set up a TTY
    to allow you to start a terminal (`/bin/bash`) inside the container.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将这个容器 ID 传递给 `docker exec`，这是一个在已运行的容器内启动新进程的命令。`-i` 标志允许你与新的进程交互，而 `-t`
    表示你想要设置一个 TTY，以便你可以在容器内启动一个终端（`/bin/bash`）。
- en: If you wait a minute and then look at the processes table, your output will
    look something like the following.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你等待一分钟，然后查看进程表，你的输出将类似于以下内容。
- en: Listing 3.6\. Processes running in a host-like container
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.6\. 在类似主机的容器中运行的进程
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1*** **Runs a ps command to list all the running processes**'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **运行 ps 命令以列出所有运行中的进程**'
- en: '***2*** **A simple init process designed to run all the other services**'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **一个简单的 init 进程，用于运行所有其他服务**'
- en: '***3*** **The bash process started by docker exec and acting as your shell**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **由 docker exec 启动并作为你的 shell 的 bash 进程**'
- en: '***4*** **runsvdir runs the services defined in the passed-in /etc/service
    directory.**'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **runsvdir 运行在传入的 /etc/service 目录中定义的服务。**'
- en: '***5*** **The three standard services (cron, sshd, and syslog) are started
    here with the runsv command.**'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **在这里使用 runsv 命令启动了三个标准服务（cron、sshd 和 syslog）**'
- en: '***6*** **The ps command currently being run**'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **当前正在运行的 ps 命令**'
- en: You can see that the container starts up much like a host, initializing services
    such as cron and sshd that make it appear similar to a standard Linux host.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，容器启动起来就像主机一样，初始化了诸如 cron 和 sshd 等服务，使其看起来类似于标准的 Linux 主机。
- en: '**DISCUSSION**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Although this can be useful in initial demos for engineers new to Docker or
    genuinely useful for your particular circumstances, it’s worth being aware that
    it’s a somewhat controversial idea.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这可能在为新手工程师进行 Docker 初始演示时很有用，或者在你特定的环境下确实有用，但值得注意的是，这是一个有些争议的想法。
- en: The history of container use has tended toward using them to isolate workloads
    to “one service per container.” Proponents of the host-like image approach argue
    that this doesn’t violate that principle, because the container can still fulfill
    a single discrete function for the system within which it runs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 容器使用的历史通常倾向于将它们用于将工作负载隔离到“每个容器一个服务”。类似主机的镜像方法的支持者认为，这并不违反该原则，因为容器仍然可以在其运行的系统中履行一个单一的离散功能。
- en: More recently, the growing popularity of both the Kubernetes’ pod and docker-compose
    concepts has made the host-like container relatively redundant—separate containers
    can be conjoined into a single entity at a higher level, rather than managing
    multiple processes using a traditional init service.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，Kubernetes 的 pod 和 docker-compose 概念的日益流行使得类似主机的容器相对冗余——可以在更高层次上将独立的容器连接成一个单一实体，而不是使用传统的
    init 服务来管理多个进程。
- en: The next technique looks at how you can break up such a monolithic application
    into microservice-style containers.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个技术将探讨如何将这样的单体应用程序拆分成微服务风格的容器。
- en: '|  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Splitting a system into microservice containers**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**将系统分割成微服务容器**'
- en: We’ve explored how to use a container as a monolithic entity (like a classical
    server) and explained that it can be a great way to quickly move a system architecture
    onto Docker. In the Docker world, however, it’s generally considered a best practice
    to split up your system as much as possible until you have one service running
    per container and have all containers connected by networks.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何将容器用作单体实体（如经典服务器），并解释了这可以快速将系统架构迁移到Docker的一种很好的方式。然而，在Docker的世界里，通常认为将系统尽可能分割是最佳实践，直到每个容器运行一个服务，并且所有容器通过网络连接。
- en: The primary reason for using one service per container is the easier separation
    of concerns through the single-responsibility principle. If you have one container
    doing one job, it’s easier to put that container through the software development
    lifecycle of development, test, and production while worrying less about its interactions
    with other components. This makes for more agile deliveries and more scalable
    software projects. It does create management overhead, though, so it’s good to
    consider whether it’s worth it for your use case.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用每个容器一个服务的主要原因是通过单一责任原则更容易地分离关注点。如果你有一个容器只做一项工作，那么在开发、测试和生产软件开发生命周期中，你更容易处理这个容器，同时减少对其与其他组件交互的担忧。这使得交付更加敏捷，软件项目更具可扩展性。然而，这也创造了管理开销，因此考虑它是否值得你的用例是很好的。
- en: Putting aside the discussion of which approach is better for you right now,
    the best-practice approach has one clear advantage—experimentation and rebuilds
    are much faster when using Dockerfiles, as you’ll see.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不论哪种方法更适合你，最佳实践方法的一个明显优势是，使用Dockerfile进行实验和重建要快得多，正如你将看到的。
- en: '**PROBLEM**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to break your application up into distinct and more manageable services.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望将你的应用程序分解成独立且更易于管理的服务。
- en: '**SOLUTION**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Create a container for each discrete service process.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个独立的服务进程创建一个容器。
- en: As we’ve touched upon already, there’s some debate within the Docker community
    about how strictly the “one service per container” rule should be followed, with
    part of this stemming from a disagreement over the definitions—is it a single
    process, or a collection of processes that combine to fulfill a need? It often
    boils down to a statement that, given the ability to redesign a system from scratch,
    microservices is the route most would chose. But sometimes practicality beats
    idealism—when evaluating Docker for our organization, we found ourselves in the
    position of having to go the monolithic route in order get Docker working as quickly
    and easily as possible.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，在Docker社区中关于“每个容器一个服务”规则应该多么严格地遵循有一些争议，其中一部分源于对定义的分歧——是单个进程，还是满足需求的一组进程的组合？这通常归结为一个声明，即如果有机会从头开始重新设计系统，大多数人会选择微服务。但有时实用性胜过理想主义——在评估我们的组织使用Docker时，我们发现自己不得不走单体路线，以便尽可能快且容易地让Docker工作。
- en: Let’s take a look at one of the concrete disadvantages of using monoliths inside
    Docker. First, the following listing shows you how you’d build a monolith with
    a database, application, and web server.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看使用Docker内部单体的一些具体缺点。首先，以下列表展示了如何构建一个包含数据库、应用程序和Web服务器的单体。
- en: '|  |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: These examples are for explanation purposes and have been simplified accordingly.
    Trying to run them directly won’t necessarily work.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例仅用于说明目的，并相应地进行了简化。直接尝试运行它们不一定能成功。
- en: '|  |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing 3.7\. Setting up a simple PostgreSQL, NodeJS, and Nginx application
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.7\. 设置一个简单的PostgreSQL、NodeJS和Nginx应用程序
- en: '[PRE6]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Each Dockerfile command creates a single new layer on top of the previous one,
    but using `&&` in your `RUN` statements effectively ensures that several commands
    get run as one command. This is useful because it can keep your images small.
    If you run a package update command like `apt-get update` with an install command
    in this way, you ensure that whenever the packages are installed, they’ll be from
    an updated package cache.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Dockerfile命令在之前的基础上创建一个单独的新层，但使用`&&`在你的`RUN`语句中实际上确保了多个命令作为一个命令运行。这很有用，因为它可以使你的镜像更小。如果你以这种方式运行一个包更新命令，如`apt-get
    update`，并附带一个安装命令，你将确保每次安装包时，它们都将来自更新的包缓存。
- en: '|  |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The preceding example is a conceptually simple Dockerfile that installs everything
    you need inside the container and then sets up the database, application, and
    web server. Unfortunately, there’s a problem if you want to quickly rebuild your
    container—any change to any file under your repository will rebuild everything
    starting from the `{*}` onwards, because the cache can’t be reused. If you have
    some slow steps (database creation or `npm install`), you could be waiting for
    a while for the container to rebuild.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例是一个概念上简单的 Dockerfile，它在容器内安装所需的一切，然后设置数据库、应用程序和 Web 服务器。不幸的是，如果你想要快速重建你的容器——任何对你仓库下任何文件的更改都将从
    `{*}` 开始重建一切，因为缓存无法重用。如果你有一些缓慢的步骤（数据库创建或 `npm install`），你可能需要等待一段时间才能重建容器。
- en: The solution to this is to split up the `COPY . /opt/` instruction into the
    individual aspects of the application (database, app, and web setup).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是将 `COPY . /opt/` 指令拆分为应用程序的各个部分（数据库、应用程序和 Web 设置）。
- en: Listing 3.8\. Dockerfile for a monolithic application
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.8\. 单体应用的 Dockerfile
- en: '[PRE7]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, the `COPY` command is split into two separate instructions.
    This means the database won’t be rebuilt every time code changes, as the cache
    can be reused for the unchanged files delivered before the code. Unfortunately,
    because the caching functionality is fairly simple, the container still has to
    be completely rebuilt every time a change is made to the schema scripts. The only
    way to resolve this is to move away from sequential setup steps and create multiple
    Dockerfiles, as shown in [listings 3.9](#ch03ex09) through [3.11](#ch03ex11).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`COPY` 命令被拆分为两个单独的指令。这意味着数据库不会在每次代码更改时重建，因为可以重用之前在代码之前交付的未更改文件的缓存。不幸的是，因为缓存功能相当简单，每次对模式脚本进行更改时，容器仍然需要完全重建。唯一解决这个问题的方法是从顺序设置步骤中移开，并创建多个
    Dockerfile，如 [列表 3.9](#ch03ex09) 到 [3.11](#ch03ex11) 所示。
- en: Listing 3.9\. Dockerfile for the postgres service
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.9\. postgres 服务的 Dockerfile
- en: '[PRE8]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Listing 3.10\. Dockerfile for the nodejs service
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.10\. nodejs 服务的 Dockerfile
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Listing 3.11\. Dockerfile for the nginx service
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.11\. nginx 服务的 Dockerfile
- en: '[PRE10]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Whenever one of the `db`, `app`, or `conf` folders changes, only one container
    will need to be rebuilt. This is particularly useful when you have many more than
    three containers or there are time-intensive setup steps. With some care, you
    can add the bare minimum of files necessary for each step and get more useful
    Dockerfile caching as a result.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `db`、`app` 或 `conf` 中的任何一个文件夹发生变化时，只需要重建一个容器。当你有超过三个容器或者有耗时设置步骤时，这尤其有用。通过一些小心谨慎，你可以为每个步骤添加必要的最小文件，从而获得更有用的
    Dockerfile 缓存。
- en: In the app Dockerfile ([listing 3.10](#ch03ex10)), the operation of `npm install`
    is defined by a single file, `package.json`, so you can alter your Dockerfile
    to take advantage of Dockerfile layer caching and only rebuild the slow `npm install`
    step when necessary, as follows.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序 Dockerfile ([列表 3.10](#ch03ex10)) 中，`npm install` 的操作由一个文件 `package.json`
    定义，因此你可以修改你的 Dockerfile 以利用 Dockerfile 层缓存，并且只在必要时重建缓慢的 `npm install` 步骤，如下所示。
- en: Listing 3.12\. Faster Dockerfile for the nginx service
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.12\. 更快的 nginx 服务的 Dockerfile
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now you have three discrete, separate Dockerfiles where formerly you had one.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有了三个独立的、分开的 Dockerfile，而之前只有一个。
- en: '**DISCUSSION**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Unfortunately, there’s no such thing as a free lunch—you’ve traded a single
    simple Dockerfile for multiple Dockerfiles with duplication. You can address this
    partially by adding another Dockerfile to act as your base image, but some duplication
    is not uncommon. Additionally, there’s now some complexity in starting your image—in
    addition to `EXPOSE` steps making appropriate ports available for linking and
    altering of Postgres configuration, you need to be sure to link the containers
    every time they start up. Fortunately there’s tooling for this called *Docker
    Compose*, which we’ll cover in [technique 76](kindle_split_021.xhtml#ch10sb02).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，没有免费的午餐——你用多个 Dockerfile 中的重复内容换取了单个简单的 Dockerfile。你可以通过添加另一个 Dockerfile
    作为基础镜像来部分解决这个问题，但一些重复内容并不罕见。此外，现在启动你的镜像有一些复杂性——除了 `EXPOSE` 步骤使适当的端口可用于链接和更改 Postgres
    配置外，你还需要确保每次容器启动时都链接容器。幸运的是，有一个名为 *Docker Compose* 的工具可以做到这一点，我们将在 [技巧 76](kindle_split_021.xhtml#ch10sb02)
    中介绍。
- en: So far in this section you’ve taken a VM, turned it into a Docker image, run
    a host-like container, and broken a monolith into separate Docker images.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本节中，你已经将虚拟机转换成了 Docker 镜像，运行了一个类似主机的容器，并将单体拆分成了单独的 Docker 镜像。
- en: If, after reading this book, you still want to run multiple processes from within
    a container, there are specific tools that can help you do that. One of these—Supervisord—is
    treated in the next technique.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在阅读这本书之后，您仍然想在容器内运行多个进程，有一些特定的工具可以帮助您做到这一点。其中之一——Supervisord——将在下一个技术中介绍。
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Managing the startup of your container’s services**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**管理容器服务的启动**'
- en: As is made clear throughout the Docker literature, a Docker container is *not*
    a VM. One of the key differences between a Docker container and a VM is that a
    container is designed to run one process. When that process finishes, the container
    exits. This is different from a Linux VM (or any Linux OS) in that it doesn’t
    have an init process.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如 Docker 文献中明确指出的，Docker 容器 *不是* 虚拟机。Docker 容器和虚拟机之间的一个主要区别是，容器设计用来运行一个进程。当该进程完成后，容器就会退出。这与
    Linux 虚拟机（或任何 Linux OS）不同，因为它没有 init 进程。
- en: The init process runs on a Linux OS with a process ID of 1 and a parent process
    ID of 0\. This init process might be called “init” or “systemd.” Whatever it’s
    called, its job is to manage the housekeeping for all other processes running
    on that operating system.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: init 进程在 Linux OS 上运行，进程 ID 为 1，父进程 ID 为 0。这个 init 进程可能被称为“init”或“systemd”。无论它叫什么，它的任务是管理该操作系统上运行的所有其他进程的维护工作。
- en: If you start to experiment with Docker, you may find that you want to start
    multiple processes. You might want to run cron jobs to tidy up your local application
    log files, for example, or set up an internal memcached server within the container.
    If you take this path, you may end up writing shell scripts to manage the startup
    of these sub-processes. In effect, you’ll be emulating the work of the init process.
    Don’t do that! The many problems arising from process management have been encountered
    by others before and have been solved in prepackaged systems.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您开始尝试使用 Docker，可能会发现您想要启动多个进程。例如，您可能想要运行 cron 作业来整理您的本地应用程序日志文件，或者在内容器中设置一个内部
    memcached 服务器。如果您选择这条路径，您可能最终会编写 shell 脚本来管理这些子进程的启动。实际上，您将模拟 init 进程的工作。不要这样做！其他人之前已经遇到过许多由进程管理引起的问题，并且已经在预包装系统中得到了解决。
- en: Whatever your reason for running multiple processes inside a container, it’s
    important to avoid reinventing the wheel.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您在容器内运行多个进程的原因是什么，避免重新发明轮子是很重要的。
- en: '**PROBLEM**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to manage multiple processes within a container.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要在容器内管理多个进程。
- en: '**SOLUTION**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use Supervisor to manage the processes in your container.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Supervisor 来管理容器中的进程。
- en: We’ll show you how to provision a container running both Tomcat and an Apache
    web server, and have it start up and run in a managed way, with the Supervisor
    application ([http://supervisord.org/](http://supervisord.org/)) managing process
    startup for you.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向您展示如何配置一个同时运行 Tomcat 和 Apache 网络服务器的容器，并以受管理的方式启动和运行，由 Supervisor 应用程序 ([http://supervisord.org/](http://supervisord.org/))
    管理进程启动。
- en: First, create your Dockerfile in a new and empty directory, as the following
    listing shows.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在新的空目录中创建您的 Dockerfile，如下所示。
- en: Listing 3.13\. Example Supervisor Dockerfile
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.13\. 示例 Supervisor Dockerfile
- en: '[PRE12]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1*** **Starts from ubuntu:14.04**'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从 ubuntu:14.04 开始**'
- en: '***2*** **Sets an environment variable to indicate that this session is non-interactive**'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **设置一个环境变量以指示此会话是非交互式的**'
- en: '***3*** **Installs python-pip (to install Supervisor), apache2, and tomcat7**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **安装 python-pip（用于安装 Supervisor）、apache2 和 tomcat7**'
- en: '***4*** **Installs Supervisor with pip**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **使用 pip 安装 Supervisor**'
- en: '***5*** **Creates housekeeping directories needed to run the applications**'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **创建运行应用程序所需的维护目录**'
- en: '***6*** **Creates a default supervisord configura-tion file with the echo_supervisord_conf
    utility**'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **使用 echo_supervisord_conf 工具创建默认的 supervisord 配置文件**'
- en: '***7*** **Appends the Apache and Tomcat supervisord configuration settings
    to the supervisord configuration file**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **将 Apache 和 Tomcat 的 supervisord 配置设置追加到 supervisord 配置文件**'
- en: '***8*** **Removes the file you uploaded, as it’s no longer needed**'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **删除您上传的文件，因为它不再需要**'
- en: '***9*** **You only need to run Supervisor now on container startup**'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** **现在您只需要在容器启动时运行 Supervisor**'
- en: You’ll also need configuration for Supervisor, to specify what applications
    it needs to start up, as shown in the next listing.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要为 Supervisor 配置，以指定它需要启动哪些应用程序，如下一个列表所示。
- en: Listing 3.14\. supervisord_add.conf
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.14\. supervisord_add.conf
- en: '[PRE13]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1*** **Declares the global configuration section for supervisord**'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **声明 supervisord 的全局配置部分**'
- en: '***2*** **Doesn’t daemonize the Supervisor process, as it’s the foreground
    process for the container**'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **不会将Supervisor进程作为守护进程运行，因为它是容器的前台进程**'
- en: '***3*** **Section declaration for a new program**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **新程序的节声明**'
- en: '***4*** **Commands to start up the programs declared in the section**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **启动该节中声明的程序的命令**'
- en: '***5*** **Section declaration for a new program**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **新程序的节声明**'
- en: '***6*** **Commands to start up the programs declared in the section**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **启动该节中声明的程序的命令**'
- en: '***7*** **Configuration pertaining to logging**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **与日志记录相关的配置**'
- en: 'You build the image using the standard single-command Docker process because
    you’re using a Dockerfile. Run this command to perform the build:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用Dockerfile构建镜像时使用标准的单命令Docker过程，因为你正在使用Dockerfile。运行此命令以执行构建：
- en: '[PRE14]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can now run your image!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行你的镜像了！
- en: Listing 3.15\. Run the supervised container
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.15\. 运行受监督的容器
- en: '[PRE15]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1*** **Maps the container’s port 80 to the host’s port 9000, gives the container
    a name, and specifies the image name you’re running, as tagged with the build
    command previously**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将容器的端口80映射到主机的端口9000，给容器命名，并指定你正在运行的镜像名称，该名称已通过之前的构建命令标记**'
- en: '***2*** **Starts up the Supervisor process**'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **启动Supervisor进程**'
- en: '***3*** **Starts up the managed processes**'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **启动管理进程**'
- en: '***4*** **Managed processes have been deemed by Supervisor to have successfully
    started.**'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **Supervisor已认为管理进程已成功启动。**'
- en: If you navigate to http://localhost:9000, you should see the default page of
    the Apache server you started up.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你导航到http://localhost:9000，你应该能看到你启动的Apache服务器的默认页面。
- en: 'To clean up the container, run the following command:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要清理容器，请运行以下命令：
- en: '[PRE16]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**DISCUSSION**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This technique used Supervisor to manage multiple processes in your Docker container.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术使用Supervisor来管理你的Docker容器中的多个进程。
- en: If you’re interested in alternatives to Supervisor, there’s also `runit`, which
    was used by the phusion base image covered in [technique 12](#ch03sb03).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣的是Supervisor的替代方案，还有`runit`，它在[技术12](#ch03sb03)中提到的phusion基础镜像中使用过。
- en: '|  |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.2\. Saving and restoring your work
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 保存和恢复你的工作
- en: Some people say that code isn’t written until it’s committed to source control—it
    doesn’t always hurt to have the same attitude about containers. It’s possible
    to save state with VMs by using snapshots, but Docker takes a much more active
    approach in encouraging the saving and reusing of your existing work.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人说，代码只有在提交到源代码控制中才算完成——对于容器来说，持有同样的态度并不总是有害的。使用快照可以通过VM保存状态，但Docker采取了更加积极的措施来鼓励保存和重用你的现有工作。
- en: We’ll cover the “save game” approach to development, the niceties of tagging,
    using the Docker Hub, and referring to specific images in your builds. Because
    these operations are considered so fundamental, Docker makes them relatively simple
    and quick. Nonetheless, this can still be a confusing topic for Docker newbies,
    so in the next section we’ll take you through the steps to a fuller understanding
    of this subject.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍“保存游戏”的开发方法、标记的细微之处、使用Docker Hub以及在你的构建中引用特定镜像。由于这些操作被认为是如此基本，Docker使它们相对简单快捷。尽管如此，这仍然可能是Docker新手感到困惑的话题，所以在下一段中，我们将带你了解这一主题的完整理解步骤。
- en: '|  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The “save game” approach: Cheap source control**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**“保存游戏”方法：低成本源代码控制**'
- en: If you’ve ever developed any kind of software, you’ve likely exclaimed, “I’m
    sure it was working before!” at least once. Perhaps your language was not as sober
    as this. The inability to restore a system to a known good (or maybe only “better”)
    state when you’re hurriedly hacking away at code to hit a deadline or fix a bug
    is the cause of many broken keyboards.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经开发过任何类型的软件，你很可能至少一次惊叹过，“我确信它之前是工作的！”也许你的语言没有这么冷静。当你匆忙地编写代码以赶上截止日期或修复错误时，无法将系统恢复到已知的好（或可能只是“更好”）状态，这是许多损坏键盘的原因。
- en: 'Source control has helped significantly with this, but there are two problems
    in this particular case:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码控制在这方面有很大帮助，但在这个特定情况下存在两个问题：
- en: The source may not reflect the state of your “working” environment’s filesystem.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码可能不会反映你的“工作”环境文件系统的状态。
- en: You may not be willing to commit the code yet.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能还不愿意提交代码。
- en: The first problem is more significant than the second. Although modern source
    control tools like Git can easily create local throwaway branches, capturing the
    state of your entire development filesystem isn’t the purpose of source control.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题比第二个问题更重要。尽管像 Git 这样的现代源代码控制工具可以轻松创建本地临时分支，但捕获整个开发文件系统的状态并不是源代码控制的目的。
- en: Docker provides a cheap and quick way to store the state of your container’s
    development filesystem through its commit functionality, and that’s what we’re
    going to explore here.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 通过其提交功能提供了一种便宜且快速的方法来存储容器开发文件系统的状态，这正是我们将要探讨的。
- en: '**PROBLEM**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to save the state of your development environment.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您想保存您开发环境的状态。
- en: '**SOLUTION**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Regularly commit your container so you can recover state at that point.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 定期提交您的容器，以便您可以在该点恢复状态。
- en: Let’s imagine you want to make a change to your to-do application from [chapter
    1](kindle_split_010.xhtml#ch01). The CEO of ToDoCorp isn’t happy and wants the
    title of the browser to show “ToDoCorp’s ToDo App” instead of “Swarm+React - TodoMVC.”
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设您想从 [第 1 章](kindle_split_010.xhtml#ch01) 中更改您的待办事项应用程序。ToDoCorp 的 CEO 不高兴，希望浏览器标题显示“ToDoCorp
    的待办应用”而不是“Swarm+React - TodoMVC”。
- en: You’re not sure how to achieve this, so you probably want to fire up your application
    and experiment by changing files to see what happens.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您不确定如何实现这一点，所以您可能想启动您的应用程序并通过更改文件来实验，看看会发生什么。
- en: Listing 3.16\. Debugging the application in a terminal
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.16\. 在终端中调试应用程序
- en: '[PRE17]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `docker run` command starts the to-do application in a container in the
    background (`-d`), mapping the container’s port 8000 to port 8000 on the host
    (`-p 8000:8000`), naming it todobug1 (`--name todobug1`) for easy reference, and
    returning the container ID. The command started in the container will be the default
    command specified when the `dockerinpractice/todoapp` image was built. We’ve built
    it for you and made it available on the Docker Hub.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run` 命令在后台（`-d`）启动待办事项应用程序，将容器的端口 8000 映射到主机上的端口 8000（`-p 8000:8000`），命名为
    todobug1（`--name todobug1`）以便于引用，并返回容器 ID。在容器中启动的命令将是构建 `dockerinpractice/todoapp`
    镜像时指定的默认命令。我们已经为您构建了它，并在 Docker Hub 上提供。'
- en: The second command will start `/bin/bash` in the running container. The name
    `todobug1` is used, but you can also use the container ID. The `-i` makes this
    `exec` run interactively, and `-t` makes sure that the `exec` will work as a terminal
    would.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令将在运行中的容器中启动 `/bin/bash`。使用 `todobug1` 作为名称，但您也可以使用容器 ID。`-i` 使此 `exec`
    运行交互式，`-t` 确保该 `exec` 将像终端一样工作。
- en: 'Now you’re in the container, so the first step in experimenting is to install
    an editor. We prefer vim, so we used these commands:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经在容器中，所以实验的第一步是安装一个编辑器。我们更喜欢 vim，所以我们使用了以下命令：
- en: '[PRE18]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After a little effort, you realize that the file you need to change is local.html.
    You therefore change line 5 in that file as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一点努力，您会意识到需要更改的文件是 local.html。因此，您将此文件的第 5 行更改为以下内容：
- en: '[PRE19]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then word comes through that the CEO might want the title to be in lowercase,
    as she’s heard that it looks more modern. You want to be ready either way, so
    you commit what you have at the moment. In another terminal you run the following
    command.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，传来消息说 CEO 可能希望标题为小写，因为她听说这样看起来更现代。您想两种情况都做好准备，所以您提交了当前的状态。在另一个终端中，您运行以下命令。
- en: Listing 3.17\. Committing container state
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.17\. 提交容器状态
- en: '[PRE20]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1*** **Turns the container you created earlier into an image**'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将您之前创建的容器转换为镜像**'
- en: '***2*** **The new image ID of the container you’ve committed**'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **您已提交的容器的新的镜像 ID**'
- en: You’ve now committed your container to an image that you can run from later.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已将容器提交为镜像，您可以在以后运行它。
- en: '|  |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Committing a container only stores the state of the filesystem at the time of
    the commit, not the processes. Docker containers aren’t VMs, remember! If your
    environment’s state depends on the state of running processes that aren’t recoverable
    through standard files, this technique won’t store the state as you need it. In
    this case, you’ll probably want to look at making your development processes recoverable.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 提交容器只存储提交时文件系统的状态，而不是进程。记住，Docker 容器不是虚拟机！如果您的环境状态依赖于无法通过标准文件恢复的运行进程的状态，这种技术不会以您需要的方式存储状态。在这种情况下，您可能希望考虑使您的开发流程可恢复。
- en: '|  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Next, you change local.html to the other possible required value:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将本地.html 文件更改为其他可能的必需值：
- en: '[PRE21]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Commit again:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提交：
- en: '[PRE22]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You now have two image IDs that represent the two options (ca76b45144f2 cb31f
    da6a31e55f784c93df8c9d4c96bbeacd73cad9cd55d2970 and 071f6a36c23a19801285 b82eafc99333c76f63ea0aa0b44902c6bae482a6e036
    in our example, but yours will be different). When the CEO comes in to evaluate
    which one she wants, you can run up either image and let her decide which one
    to commit.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有两个图像 ID 代表两种选项（在我们的例子中是 ca76b45144f2 cb31f da6a31e55f784c93df8c9d4c96bbeacd73cad9cd55d2970
    和 071f6a36c23a19801285 b82eafc99333c76f63ea0aa0b44902c6bae482a6e036，但你的将是不同的）。当
    CEO 来评估她想要哪一个时，你可以运行任何一个镜像并让她决定要提交哪一个。
- en: You do this by opening up new terminals and running the following commands.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过打开新的终端并运行以下命令来完成这项操作。
- en: Listing 3.18\. Running up both committed images as containers
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.18\. 同时运行两个提交的镜像作为容器
- en: '[PRE23]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1*** **Maps the container’s port 8000 to the host’s port 8001 and specifies
    the lowercase image ID**'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将容器的端口 8000 映射到主机的端口 8001 并指定小写图像 ID**'
- en: '***2*** **Maps the container’s port 8000 to the host’s port 8002 and specifies
    the uppercase image ID**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将容器的端口 8000 映射到主机的端口 8002 并指定大写图像 ID**'
- en: In this way you can present the uppercase option as available on http://localhost:8001
    and the lowercase option on http://localhost:8002.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，你可以在 http://localhost:8001 上提供大写选项，在 http://localhost:8002 上提供小写选项。
- en: '|  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Any dependencies external to the container (such as databases, Docker volumes,
    or other services called) aren’t stored on commit. This technique doesn’t have
    any external dependencies so you don’t need to worry about that.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 容器外部（如数据库、Docker 卷或其他服务）的任何依赖项在提交时都不会存储。这种技术没有外部依赖项，所以你不需要担心这一点。
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**DISCUSSION**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This technique demonstrated `docker commit`’s functionality, and how it might
    be used in a development workflow. Docker users tend to be directed toward using
    `docker commit` only as part of a formal `commit-tag-push` workflow, so it’s good
    to remember that it has other uses too.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术展示了 `docker commit` 的功能，以及它如何在开发工作流程中使用。Docker 用户往往被引导仅将 `docker commit`
    作为正式的 `commit-tag-push` 工作流程的一部分来使用，因此记住它还有其他用途也是好的。
- en: We find this to be a useful technique when we’ve negotiated a tricky sequence
    of commands to set up an application. Committing the container, once successful,
    also records your bash session history, meaning that a set of steps for regaining
    the state of your system is available. This can save a *lot* of time! It’s also
    useful when you’re experimenting with a new feature and are unsure whether you’re
    finished, or when you’ve recreated a bug and want to be as sure as possible that
    you can return to the broken state.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现，当我们协商了一系列复杂的命令来设置应用程序时，这是一个有用的技术。一旦容器提交成功，也会记录你的 bash 会话历史，这意味着有一组步骤可以恢复你的系统状态。这可以节省
    *很多* 时间！当你正在尝试一个新功能且不确定是否完成，或者当你重新创建了一个错误并希望尽可能确保可以返回到损坏状态时，这也很有用。
- en: You may well be wondering whether there’s a better way to reference images than
    with long random strings of characters. The next technique will look at giving
    these containers names you can more easily reference.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道是否有比使用长随机字符字符串更好的方法来引用镜像。接下来的技术将探讨给这些容器命名，以便更容易引用。
- en: '|  |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Docker tagging**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker 标记**'
- en: You’ve now saved the state of your container by committing, and you have a random
    string as the ID of your image. It’s obviously difficult to remember and manage
    the large numbers of these image IDs. It would be helpful to use Docker’s tagging
    functionality to give readable names (and tags) to your images and remind you
    what they were created for.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提交，你现在已经保存了容器的状态，并且你的镜像 ID 是一个随机字符串。显然，很难记住和管理这些图像 ID 的大量数量。使用 Docker 的标记功能给你的图像提供可读的名称（和标签）并将它们创建的原因提醒自己会很有帮助。
- en: Mastering this technique will allow you to see what your images are for at a
    glance, making image management on your machine far simpler.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 精通这项技术将允许你一眼看出你的镜像用途，使你在机器上的镜像管理变得简单得多。
- en: '**PROBLEM**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to conveniently reference and store a Docker commit.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要方便地引用和存储 Docker 提交。
- en: '**SOLUTION**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the `docker tag` command to name your commits.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker tag` 命令来命名你的提交。
- en: In its basic form, tagging a Docker image is simple.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在其基本形式中，对 Docker 镜像进行标记是简单的。
- en: Listing 3.19\. A simple `docker tag` command
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.19\. 简单的 `docker tag` 命令
- en: '[PRE24]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1*** **The docker tag command**'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **docker tag 命令**'
- en: '***2*** **The image ID you want to give a name to**'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **你想命名的图像 ID**'
- en: '***3*** **The name you want to give your image**'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **你想要给你的镜像取的名字**'
- en: 'This gives your image a name that you can refer to, like so:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这给你的镜像赋予了一个你可以引用的名称，如下所示：
- en: '[PRE25]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is much easier than remembering random strings of letters and numbers!
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这比记住随机的字母和数字字符串要容易得多！
- en: If you want to share your images with others, there’s more to tagging than this,
    though. Unfortunately, the terminology around tags can be rather confusing. Terms
    such as *image name* and *repository* are used interchangeably. [Table 3.1](#ch03table01)
    provides some definitions.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要与他人分享你的镜像，标签的使用远不止这些。不幸的是，关于标签的术语可能相当令人困惑。诸如 *镜像名称* 和 *存储库* 这样的术语可以互换使用。[表
    3.1](#ch03table01) 提供了一些定义。
- en: Table 3.1\. Docker tagging terms
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 3.1\. Docker 标签术语
- en: '| **Term** | **Meaning** |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| **术语** | **含义** |'
- en: '| --- | --- |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Image | A read-only layer. |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 镜像 | 一个只读层。 |'
- en: '| Name | The name of your image, such as “todoapp.” |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 你的镜像名称，例如 “todoapp。” |'
- en: '| Tag | As a verb, it refers to giving an image a name. As a noun, it’s a modifier
    for your image name. |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 标签 | 作为动词，它指的是给镜像命名。作为名词，它是镜像名称的修饰符。 |'
- en: '| Repository | A hosted collection of tagged images that together create the
    filesystem for a container. |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 存储库 | 一个托管标记的镜像集合，这些镜像共同构成了容器的文件系统。 |'
- en: Perhaps the most confusing terms in this table are “image” and “repository.”
    We’ve been using the term *image* loosely to mean a collection of layers that
    we spawn a container from, but technically an image is a single layer that refers
    to its parent layer recursively. A *repository* is hosted, meaning that it’s stored
    somewhere (either on your Docker daemon or on a registry). In addition, a repository
    is a collection of tagged images that make up the filesystem for a container.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表格中最令人困惑的术语可能是“镜像”和“存储库”。我们一直在松散地使用术语 *镜像* 来指代我们从中启动容器的层集合，但从技术上讲，一个镜像是一个单层，它递归地引用其父层。一个
    *存储库* 是托管的意思，这意味着它存储在某处（要么是在你的 Docker 守护进程中，要么是在一个注册表中）。此外，一个存储库是由标记的镜像组成的集合，这些镜像构成了容器的文件系统。
- en: An analogy with Git can be helpful here. When cloning a Git repository, you
    check out the state of the files at the point you requested. This is analogous
    to an image. The repository is the entire history of the files at each commit,
    going back to the initial commit. You therefore check out the repository at the
    head’s “layer.” The other “layers” (or commits) are all there in the repository
    you’ve cloned.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Git 的类比在这里可能会有所帮助。当克隆 Git 存储库时，你检查出你请求的文件的状态。这与镜像类似。存储库是每个提交的文件的历史记录，追溯到初始提交。因此，你在“头部”的“层”处检查出存储库。其他“层”（或提交）都在你克隆的存储库中。
- en: In practice, the terms “image” and “repository” are used more or less interchangeably,
    so don’t worry too much about this. But be aware that these terms exist and are
    used similarly.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，“镜像”和“存储库”这两个术语的使用几乎是互换的，所以不必过于担心这一点。但请注意，这些术语确实存在，并且被类似地使用。
- en: What you’ve seen so far is how to give an image ID a name. Confusingly, this
    name isn’t the image’s “tag,” although people often refer to it as that. We distinguish
    between the action “to tag” (verb) and the “tag” (noun) you can give to the image
    name. This tag (noun) allows you to name a specific version of the image. You
    might add a tag to manage references to different versions of the same image.
    For example, you could tag an image with a version name or the date of commit.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你到目前为止所看到的是如何给镜像 ID 赋予一个名称。令人困惑的是，这个名称并不是镜像的“标签”，尽管人们经常这样称呼它。我们区分了“标记”（动词）和可以赋予镜像名称的“标签”（名词）。这个标签（名词）允许你命名镜像的特定版本。你可能添加一个标签来管理对同一镜像不同版本的引用。例如，你可以用版本名称或提交日期来标记一个镜像。
- en: A good example of a repository with multiple tags is the Ubuntu image. If you
    pull the Ubuntu image and then run `docker images`, you’ll get output similar
    to the following listing.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有多个标签的存储库的好例子是 Ubuntu 镜像。如果你拉取 Ubuntu 镜像然后运行 `docker images`，你会得到类似于以下列表的输出。
- en: Listing 3.20\. An image with multiple tags
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.20\. 带有多个标签的镜像
- en: '[PRE26]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The Repository column lists the hosted collection of layers called “ubuntu”.
    Often this is referred to as the “image.” The Tag column here lists four different
    names (trusty, 14.04, 14.04.1, and latest). The Image ID column lists identical
    image IDs. This is because these differently tagged images are identical.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库列列出了称为“ubuntu”的托管层集合。通常这被称为“镜像”。标签列这里列出了四个不同的名称（trusty、14.04、14.04.1 和 latest）。镜像
    ID 列列出了相同的镜像 ID。这是因为这些不同标记的镜像实际上是相同的。
- en: This shows that you can have a repository with multiple tags from the same image
    ID. In theory, though, these tags could later point to different image IDs. If
    “trusty” gets a security update, for example, the image ID may be changed with
    a new commit by the maintainers and tagged with “trusty”, “14.04.2”, and “latest”.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明你可以从相同的镜像ID拥有多个标签的仓库。从理论上讲，尽管这些标签以后可能指向不同的镜像ID。例如，如果“trusty”获得安全更新，例如，维护者可能会通过新的提交更改图像ID，并用“trusty”、“14.04.2”和“latest”进行标记。
- en: The default is to give your image a tag of “latest” if no tag is specified.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果没有指定标签，则给你的镜像一个“latest”标签。
- en: '|  |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The “latest” tag has no special significance in Docker—it’s a default for tagging
    and pulling. It *doesn’t* necessarily mean that this was the last tag set for
    this image. The “latest” tag of your image may be an old version of the image,
    as versions built later may have been tagged with a specific tag like “v1.2.3”.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker中，“latest”标签没有特殊意义——它是标记和拉取的默认值。这*并不一定*意味着这是为该镜像设置的最后一个标签。你的镜像的“latest”标签可能是一个旧版本的镜像，因为后来构建的版本可能被标记为特定的标签，如“v1.2.3”。
- en: '|  |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**DISCUSSION**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: 'In this section we covered Docker image tagging. In itself, this technique
    is relatively simple. The real challenge we’ve found—and focused on here—is navigating
    the loose use of terminology among Docker users. It’s worth re-emphasizing that
    when people talk about an image, they might be referring to a tagged image, or
    even a repository. Another particularly common mistake is referring to an image
    as a container: “Just download the container and run it.” Colleagues at work who
    have been using Docker for a while still frequently ask us, “What’s the difference
    between a container and an image?”'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了Docker镜像标记。就其本身而言，这项技术相对简单。我们发现的真正挑战——并且在这里集中关注的是——在Docker用户中术语的松散使用。值得再次强调的是，当人们谈论一个镜像时，他们可能指的是一个标记过的镜像，甚至是一个仓库。另一个特别常见的错误是将镜像称为容器：“只需下载容器并运行它。”使用Docker一段时间的工作同事仍然经常向我们提问，“容器和镜像之间的区别是什么？”
- en: In the next technique you’ll learn how to share your now-tagged image with others
    using a Docker image hub.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个技术中，你将学习如何使用Docker镜像库与他人共享你现在标记的图像。
- en: '|  |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Sharing images on the Docker Hub**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**在Docker Hub上共享图像**'
- en: Tagging images with descriptive names would be even more helpful if you could
    share these names (and images) with other people. To satisfy this need, Docker
    comes with the ability to easily move images to other places, and Docker Inc.
    created the Docker Hub as a free service to encourage this sharing.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能与他人共享这些名称（和图像）以及描述性的图像名称，那么标记图像将更有帮助。为了满足这一需求，Docker提供了轻松将图像移动到其他地方的能力，并且Docker
    Inc.创建了Docker Hub作为一项免费服务，以鼓励这种共享。
- en: '|  |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-334
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: To follow this technique, you’ll need a Docker Hub account that you have logged
    into previously by running `docker login` on your host machine. If you haven’t
    set one up, you can do so at [http://hub.docker.com](http://hub.docker.com). Just
    follow the instructions to register.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循这项技术，你需要一个Docker Hub账户，你之前已经通过在主机机器上运行`docker login`登录过。如果你还没有设置一个，你可以在[http://hub.docker.com](http://hub.docker.com)上设置一个。只需按照说明进行注册。
- en: '|  |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**PROBLEM**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to share a Docker image publicly.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望公开分享一个Docker镜像。
- en: '**SOLUTION**'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the Docker Hub registry to share your image.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker Hub注册表来共享你的图像。
- en: As with tagging, the terminology around registries can be confusing. [Table
    3.2](#ch03table02) should help you understand how the terms are used.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 与标记一样，围绕注册表的术语可能会令人困惑。[表3.2](#ch03table02)应有助于你了解术语的使用方式。
- en: Table 3.2\. Docker registry terms
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表3.2\. Docker注册表术语
- en: '| **Term** | **Meaning** |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| **术语** | **含义** |'
- en: '| --- | --- |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Username | Your Docker registry username. |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 用户名 | 你的Docker注册表用户名。 |'
- en: '| Registry | Registries hold images. A registry is a store you can upload images
    to or download them from. Registries can be public or private. |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 注册表 | 注册表存储图像。注册表是一个你可以上传图像或从中下载图像的存储库。注册表可以是公共的或私有的。 |'
- en: '| Registry host | The host on which the Docker registry runs. |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 注册表主机 | Docker注册表运行的主机。 |'
- en: '| Docker Hub | The default public registry hosted at [https://hub.docker.com](https://hub.docker.com).
    |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| Docker Hub | 默认的公共注册表，托管在[https://hub.docker.com](https://hub.docker.com)。
    |'
- en: '| Index | The same as a registry host. It appears to be a deprecated term.
    |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | 与注册表主机相同。这似乎是一个已弃用的术语。 |'
- en: As you’ve seen previously, it’s possible to tag an image as many times as you
    like. This is useful for “copying over” an image so that you have control of it.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您之前看到的，您可以多次标记一个镜像。这对于“复制”一个镜像以便您控制它非常有用。
- en: Let’s say your username on the Docker Hub is “adev”. The following three commands
    show how to copy the “debian:wheezy” image from the Docker Hub to be under your
    own account.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在 Docker Hub 上的用户名是“adev”。以下三个命令展示了如何将“debian:wheezy”镜像从 Docker Hub 复制到您自己的账户下。
- en: Listing 3.21\. Copying a public image and pushing to adev’s Docker Hub account
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.21\. 复制公共镜像并将其推送到 adev 的 Docker Hub 账户
- en: '[PRE27]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1*** **Pulls the Debian image from the Docker Hub**'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从 Docker Hub 拉取 Debian 镜像**'
- en: '***2*** **Tags the wheezy image with your own username (adev) and tag (mywheezy1)**'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用您的用户名（adev）和标签（mywheezy1）标记 wheezy 镜像**'
- en: '***3*** **Pushes the newly created tag**'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **推送新创建的标签**'
- en: You now have a reference to the Debian wheezy image you downloaded that you
    can maintain, refer to, and build on.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经有一个可以维护、参考和构建的 Debian wheezy 镜像的引用。
- en: If you have a private repository to push to, the process is identical, except
    that you must specify the address of the registry before the tag. Let’s say you
    have a repository that’s served from [http://mycorp.private.dockerregistry](http://mycorp.private.dockerregistry).
    The following listing will tag and push the image.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个私有仓库要推送，过程是相同的，但您必须在标签之前指定仓库的地址。比如说，您有一个从 [http://mycorp.private.dockerregistry](http://mycorp.private.dockerregistry)
    提供服务的仓库。以下列表将标记并推送镜像。
- en: Listing 3.22\. Copying a public image and pushing to adev’s private registry
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.22\. 复制公共镜像并将其推送到开发者的私有仓库
- en: '[PRE28]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1*** **Pulls the Debian image from the Docker Hub**'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从 Docker Hub 拉取 Debian 镜像**'
- en: '***2*** **Tags the wheezy image with your registry (mycorp.private.dockerregistry),
    username (adev), and tag (mywheezy1)**'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用您的仓库（mycorp.private.dockerregistry）、用户名（adev）和标签（mywheezy1）标记 wheezy
    镜像**'
- en: '***3*** **Pushes the newly created tag to the private registry. Note that the
    private registry server’s address is required both when tagging and pushing, so
    that Docker can be sure it’s pushing to the right place.**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将新创建的标签推送到私有仓库。请注意，在打标签和推送时都需要私有仓库服务器的地址，这样 Docker 才能确保它推送到正确的位置。**'
- en: The preceding commands won’t push the image to the public Docker Hub but will
    push it to the private repository, so that anyone with access to resources on
    that service can pull it.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令不会将镜像推送到公共 Docker Hub，而是将其推送到私有仓库，这样任何有权访问该服务资源的人都可以拉取它。
- en: '**DISCUSSION**'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: You now have the ability to share your images with others. This is a great way
    to share work, ideas, or even issues you’re facing with other engineers.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有权限与他人共享您的镜像。这是一种很好的方式来分享工作、想法，甚至您面临的问题与其他工程师。
- en: Just as GitHub isn’t the only publicly available Git server, Docker Hub isn’t
    the only publicly available Docker registry. But like GitHub, it’s the most popular.
    For example, RedHat has a hub at [https://access.redhat.com/containers](https://access.redhat.com/containers).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 GitHub 不是唯一的公开 Git 服务器一样，Docker Hub 也不是唯一的公开 Docker 仓库。但就像 GitHub 一样，它是最受欢迎的。例如，RedHat
    在 [https://access.redhat.com/containers](https://access.redhat.com/containers)
    有一个中心。
- en: Again, like Git servers, public and private Docker registries might have different
    features and characteristics that make one or the other appeal to you. If you’re
    evaluating them, you might want to think about things like cost (to buy, subscribe
    to, or maintain), adherence to APIs, security features, and performance.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，就像 Git 服务器一样，公共和私有 Docker 仓库可能具有不同的功能和特性，使得其中一个或另一个对您更有吸引力。如果您正在评估它们，您可能需要考虑诸如成本（购买、订阅或维护）、遵守
    API、安全功能和性能等因素。
- en: In the next technique, we’ll look at how specific images can be referenced to
    help avoid issues that arise when the image reference you’re using is unspecific.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个技术中，我们将探讨如何引用特定的镜像以帮助避免当您使用的镜像引用不具体时出现的问题。
- en: '|  |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Referring to a specific image in builds**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**在构建中引用特定镜像**'
- en: Most of the time you’ll be referring to generic image names in your builds,
    such as “node” or “ubuntu” and will proceed without problem.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，您会在构建中引用通用镜像名称，如“node”或“ubuntu”，并且不会有问题。
- en: If you refer to an image name, it’s possible that the image can change while
    the tag remains the same, as paradoxical as it sounds. The repository name is
    only a reference, and it may be altered to point to a different underlying image.
    Specifying a tag with the colon notation (such as `ubuntu:trusty`) doesn’t remove
    this risk either, as security updates can use the same tag to automatically rebuild
    vulnerable images.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你引用了一个镜像名称，那么在标签保持不变的情况下，镜像本身可能会发生变化，这听起来可能有些矛盾。仓库名称只是一个参考，它可能被修改以指向不同的底层镜像。使用冒号表示法（例如
    `ubuntu:trusty`）指定标签也不能消除这种风险，因为安全更新可以使用相同的标签自动重建易受攻击的镜像。
- en: 'Most of the time you’ll want this—the maintainers of the image may have found
    an improvement, and patching security holes is generally a good thing. Occasionally,
    though, this can cause you pain. And this is not merely a theoretical risk: this
    has happened to us on a number of occasions, breaking continuous delivery builds
    in a way that’s difficult to debug. In the early days of Docker, packages would
    be added to and removed from the most popular images regularly (including, on
    one memorable occasion, the disappearance of the `passwd` command!), making builds
    that previously worked suddenly break.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你会希望这样——镜像的维护者可能已经找到了改进，修补安全漏洞通常是一件好事。然而，偶尔这也可能给你带来痛苦。这不仅仅是一个理论风险：这种情况在我们身上已经发生多次，导致持续交付构建难以调试。在
    Docker 的早期阶段，最流行的镜像会定期添加和删除包（包括一次难忘的场合，`passwd` 命令消失了！），使得之前工作的构建突然中断。
- en: '**PROBLEM**'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to be sure that your build is from a specific and unchanging image.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要确保你的构建来自一个特定且不变的镜像。
- en: '**SOLUTION**'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: To be absolutely certain that you’re building against a given set of files,
    specify a specific image ID in your Dockerfile.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你正在构建针对一组特定的文件，请在 Dockerfile 中指定特定的镜像 ID。
- en: 'Here’s an example (which will likely not work for you):'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子（可能对你不起作用）：
- en: Listing 3.23\. Dockerfile with a specific image ID
  id: totrans-381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.23\. 带有特定镜像 ID 的 Dockerfile
- en: '[PRE29]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1*** **Builds from a specific image (or layer) ID**'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从特定的镜像（或层）ID 构建**'
- en: '***2*** **Runs commands within this image to record the image you built from
    within a file in the new image**'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在此镜像内运行命令以将构建的镜像记录在新镜像中的一个文件中**'
- en: '***3*** **The built image will by default output the information you recorded
    in the /etc/buildinfo file.**'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **构建的镜像默认会输出你在 /etc/buildinfo 文件中记录的信息。**'
- en: To build from a specific image (or layer) ID like this, the image ID and its
    data must be stored locally on your Docker daemon. The Docker registry won’t perform
    any kind of lookup to find the image ID in layers of images available to you on
    the Docker Hub, or in any other registry you may be configured to use.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 要从特定的镜像（或层）ID 构建如下，该镜像 ID 及其数据必须存储在本地 Docker 守护进程上。Docker 仓库不会执行任何类型的查找，以在 Docker
    Hub 上可用的镜像层中找到该镜像 ID，或在任何其他配置的仓库中。
- en: Note that the image you refer to need not be tagged—it could be any layer you
    have locally. You can begin your build from any layer you wish. This might be
    useful for certain surgical or experimental procedures you want to perform for
    Dockerfile build analysis.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你引用的镜像不需要标记——它可以是任何你本地的层。你可以从任何你希望的层开始构建。这可能对某些需要为 Dockerfile 构建分析执行的手术或实验性程序很有用。
- en: If you want to persist the image remotely, it’s best to tag and push the image
    to a repository that’s under your control in a remote registry.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望远程持久化镜像，最好是将镜像标记并推送到你控制的远程仓库。
- en: '|  |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: It’s worth pointing out that almost the opposite problem can occur when a Docker
    image that was previously working suddenly does not. Usually this is because something
    on the network has changed. One memorable example of this was when our builds
    failed to `apt-get update` one morning. We assumed it was a problem with our local
    deb cache and tried debugging without success until a friendly sysadmin pointed
    out that the particular version of Ubuntu we were building from was no longer
    supported. This meant that the network calls to `apt-get update` were returning
    an HTTP error.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，当之前工作的 Docker 镜像突然不再工作时，可能会发生几乎相反的问题。通常这是因为网络中发生了变化。一个难忘的例子是，我们有一次构建在早上无法执行
    `apt-get update`。我们假设这是本地 deb 缓存的问题，并尝试调试但没有成功，直到一位友好的系统管理员指出，我们正在构建的 Ubuntu 版本已经不再受支持。这意味着
    `apt-get update` 的网络调用返回了 HTTP 错误。
- en: '|  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**DISCUSSION**'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Although it might sound a little theoretical, it’s important to understand the
    advantages and disadvantages of being more specific about the image you want to
    build or run.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能听起来有点理论化，但了解您想要构建或运行的镜像的更具体信息的优缺点是很重要的。
- en: Being more specific makes the result of your action more predictable and debuggable,
    as there’s less ambiguity about which Docker image is or was downloaded. The disadvantage
    is that your image may not be the latest available, and you may therefore miss
    out on critical updates. Which state of affairs you prefer will depend on your
    particular use case and what you need to prioritize in your Docker environment.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 更加具体可以使得您行动的结果更加可预测和可调试，因为关于哪个Docker镜像被下载或曾经下载的模糊性更少。缺点是您的镜像可能不是最新可用的，因此您可能会错过关键更新。您更倾向于哪种状态将取决于您的特定用例以及您在Docker环境中需要优先考虑的内容。
- en: 'In the next section, you’ll apply what you’ve learned to a somewhat playful
    real-world scenario: winning at 2048.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将应用您所学到的知识到一个相对有趣的现实场景：在2048中获胜。
- en: '|  |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 3.3\. Environments as processes
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3. 环境作为进程
- en: One way of viewing Docker is to see it as turning environments into processes.
    VMs can be treated in the same way, but Docker makes this much more convenient
    and efficient.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 一种看待Docker的方式是将其视为将环境转换为进程。虚拟机也可以以同样的方式处理，但Docker使这一过程更加方便和高效。
- en: To illustrate this, we’ll show you how the speedy spin-up, storage, and recreation
    of container state can allow you to do something otherwise (almost) impossible—winning
    at 2048!
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们将向您展示快速启动、存储和重新创建容器状态如何让您做到其他情况下（几乎）不可能的事情——在2048中获胜！
- en: '|  |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The “save game” approach: Winning at 2048**'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**“保存游戏”方法：在2048中获胜**'
- en: This technique is designed to provide you with a little light relief while showing
    you how Docker can be used to revert state easily. If you’re not familiar with
    2048, it’s an addictive game where you push numbers around a board. The original
    version is available online at [http://gabrielecirulli.github.io/2048](http://gabrielecirulli.github.io/2048)
    if you want to get acquainted with it first.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术旨在在向您展示如何使用Docker轻松回滚状态的同时，为您提供一些轻松的娱乐。如果您不熟悉2048，它是一款上瘾的游戏，您需要在棋盘上推动数字。如果您想先熟悉一下，原始版本可在[http://gabrielecirulli.github.io/2048](http://gabrielecirulli.github.io/2048)上找到。
- en: '**PROBLEM**'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to save container state regularly in order to revert to a known state
    if necessary.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望定期保存容器状态，以便在必要时回滚到已知状态。
- en: '**SOLUTION**'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use `docker commit` to “save game” whenever you are unsure whether you will
    survive in 2048.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker commit`来“保存游戏”，无论您是否确定能在2048中存活。
- en: We’ve created a monolithic image on which you can play 2048 within a Docker
    container that contains a VNC server and Firefox.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个单体镜像，您可以在其中使用Docker容器玩2048，该容器包含一个VNC服务器和Firefox。
- en: To use this image you’ll need to install a VNC client. Popular implementations
    include TigerVNC and VNC Viewer. If you don’t have one, a quick search for “vnc
    client” on the package manager on your host should yield useful results.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此镜像，您需要安装一个VNC客户端。流行的实现包括TigerVNC和VNC Viewer。如果您没有，在主机上的包管理器中快速搜索“vnc client”应该会得到有用的结果。
- en: To start up the container, run the following commands.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动容器，请运行以下命令。
- en: Listing 3.24\. Start the 2048 container
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表3.24. 启动2048容器
- en: '[PRE30]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1*** **Run the imiell/win2048 image as a daemon**'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **运行imiell/win2048镜像作为守护进程**'
- en: '***2*** **Use VNC to get GUI access to the container**'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用VNC获取容器的GUI访问权限**'
- en: 'First you run a container from the `imiell/win2048` image that we’ve prepared
    for you. You start this in the background and specify that it should open two
    ports (5901 and 6080) to the host. These ports will be used by the VNC server
    started automatically inside the container. You also give the container a name
    for easy use later: `win2048`.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您从为我们准备的`imiell/win2048`镜像运行一个容器。您将其在后台启动，并指定它应该打开两个端口（5901和6080）到主机。这些端口将由容器内自动启动的VNC服务器使用。您还给了容器一个名字，以便以后方便使用：`win2048`。
- en: You can now run your VNC viewer (the executable may differ depending on what
    you have installed) and instruct it to connect to your local computer. Because
    the appropriate ports have been exposed from the container, connecting to localhost
    will actually connect to the container. The `:1` after `localhost` is appropriate
    if you have no X displays on your host, other than a standard desktop—if you do,
    you may need to choose a different number and look at the documentation for your
    VNC viewer to manually specify the VNC port as `5901`.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以运行您的 VNC 查看器（可执行文件可能取决于您安装了什么），并指示它连接到您的本地计算机。由于容器已暴露了适当的端口，连接到 localhost
    实际上会连接到容器。如果您的宿主上没有 X 显示（除了标准桌面），则 `localhost` 后的 `:1` 是合适的——如果您有，您可能需要选择不同的数字，并查看您的
    VNC 查看器的文档以手动指定 VNC 端口为 `5901`。
- en: Once you’re connected to the VNC server, you’ll be prompted for a password.
    The password for VNC on this image is “vncpass”. You’ll then see a window with
    a Firefox tab and a 2048 table preloaded. Click on it to give it focus, and play
    until you’re ready to save the game.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您连接到 VNC 服务器，您将需要输入密码。此镜像上 VNC 的密码是“vncpass”。然后您将看到一个带有 Firefox 标签和预加载的 2048
    表格的窗口。点击它以获得焦点，并玩到您准备好保存游戏为止。
- en: 'To save the game, you tag the named container after committing it:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存游戏，您在提交后标记命名容器：
- en: Listing 3.25\. Commit and tag the game state
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.25\. 提交并标记游戏状态
- en: '[PRE31]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1*** **Commits the `win2048` container**'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** **提交 `win2048` 容器**'
- en: '***2*** **The tag that references your commit**'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** **引用您的提交的标记**'
- en: '***3*** **Tags the commit with the current time as an integer**'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** **使用当前时间作为整数标记提交**'
- en: An image ID was generated by committing the `win2048` container, and now you
    want to give it a unique name (because you may be creating a number of these images).
    To do this, you can use the output of `date +%s` as part of the image name. This
    outputs the number of seconds since the first day of 1970, providing a unique
    (for our purposes), constantly increasing value. The `$(command)` syntax just
    substitutes the output of `command` at that position. If you prefer, you can run
    `date +%s` manually and paste the output as part of the image name instead.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提交 `win2048` 容器生成了一个镜像 ID，现在您想给它一个独特的名称（因为您可能正在创建许多这样的镜像）。为此，您可以使用 `date +%s`
    的输出作为镜像名称的一部分。这输出自 1970 年第一天以来的秒数，提供了一个独特（对我们来说）、不断增长的价值。`$(command)` 语法只是在该位置替换
    `command` 的输出。如果您愿意，您可以手动运行 `date +%s` 并将输出粘贴为镜像名称的一部分。
- en: You can then continue playing until you lose. Now comes the magic! You can return
    to your save point with the following commands.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续玩游戏，直到您输掉为止。现在来点魔法！您可以使用以下命令返回到您的保存点。
- en: Listing 3.26\. Return to the saved game
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 3.26\. 返回保存的游戏
- en: '[PRE32]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`$mytag` is a tag selected from the `docker images` command. Repeat the `tag`,
    `rm`, and `run` steps until you complete 2048.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`$mytag` 是从 `docker images` 命令中选择的标记。重复 `tag`、`rm` 和 `run` 步骤，直到完成 2048。'
- en: '**DISCUSSION**'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: We hope that was fun. This example is more fun than practical, but we have used—and
    seen other developers use—this technique to great effect, especially when their
    environments are complex and the work they’re doing is somewhat forensic and tricky.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这很有趣。这个例子比实际更有趣，但我们已经使用——并看到其他开发者使用——这种技术取得了很好的效果，尤其是在他们的环境复杂且他们所做的工作相对具有调查性和复杂时。
- en: '|  |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: You can create a Docker container that looks like a “normal” host. Some consider
    this to be bad practice, but it may benefit your business or fit your use case.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以创建一个看起来像“正常”主机的 Docker 容器。有些人认为这是不好的做法，但它可能对您的业务有益或适合您的用例。
- en: It’s relatively easy to convert a VM to a Docker image to make the initial move
    to Docker.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将虚拟机转换为 Docker 镜像相对简单，这是迈向 Docker 的第一步。
- en: You can supervise services on your containers to mimic their previous VM-like
    operation.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以监督容器上的服务，以模仿它们之前的类似虚拟机操作。
- en: Committing is the correct way to save your work as you go.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随时保存您的作品是提交的正确方式。
- en: You can specify a particular Docker image to build from by using its build ID.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过使用其构建 ID 来指定要从中构建的特定 Docker 镜像。
- en: You can name your images and share them with the world on the Docker Hub for
    free.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以为您的图像命名，并在 Docker Hub 上免费与世界分享。
- en: You can even use Docker’s commit capability to win at games like 2048!
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您甚至可以使用 Docker 的提交功能在 2048 等游戏中获胜！
- en: Chapter 4\. Building images
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四章\. 构建镜像
- en: '|  |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Some basics of image creation
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像创建的一些基础知识
- en: Manipulating the Docker build cache for fast and reliable builds
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作 Docker 构建缓存以实现快速和可靠的构建
- en: Configuring timezones as part of an image build
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在镜像构建过程中配置时区
- en: Running commands directly on your containers from the host
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从主机直接在容器上运行命令
- en: Drilling down into the layers created by an image build
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入研究镜像构建过程中创建的层
- en: Using the more advanced ONBUILD feature when building and using images
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建和使用镜像时使用更高级的 ONBUILD 功能
- en: '|  |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: To get beyond the basics of using Docker, you’ll want to start creating your
    own building blocks (images) to pull together in interesting ways. This chapter
    will cover some of the important parts of image creation, looking at practicalities
    that you might otherwise stumble over.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 要超越 Docker 的基本使用，你将想要开始创建自己的构建块（镜像），以有趣的方式组合在一起。本章将涵盖镜像创建的一些重要部分，探讨你可能遇到的实际问题。
- en: 4.1\. Building images
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1\. 构建镜像
- en: Although the simplicity of Dockerfiles makes them a powerful time-saving tool,
    there are some subtleties that can cause confusion. We’ll take you over a few
    time-saving features and their details, starting with the `ADD` instruction. Then
    we’ll cover the Docker build cache, how it can let you down, and how you can manipulate
    it to your advantage.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Dockerfile 的简单性使它们成为节省时间的强大工具，但也有一些细微之处可能会引起混淆。我们将向您介绍一些节省时间的功能及其细节，从 `ADD`
    指令开始。然后我们将介绍 Docker 构建缓存，它如何让你失望，以及如何操纵它以获得优势。
- en: Remember to refer to the official Docker documentation for complete Dockerfile
    instructions at [https://docs.docker.com](https://docs.docker.com).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 记得查阅官方 Docker 文档，了解完整的 Dockerfile 指令，网址为 [https://docs.docker.com](https://docs.docker.com)。
- en: '|  |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Injecting files into your image using ADD**'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 ADD 将文件注入到您的镜像中**'
- en: Although it’s possible to add files within a Dockerfile using the `RUN` command
    and basic shell primitives, this can quickly become unmanageable. The `ADD` command
    was added to the list of Dockerfile commands to address the need to put large
    numbers of files into an image without fuss.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以在 Dockerfile 中使用 `RUN` 命令和基本的 shell 基本操作来添加文件，但这很快就会变得难以管理。为了解决将大量文件放入镜像而无需麻烦的需求，`ADD`
    命令被添加到了 Dockerfile 命令列表中。
- en: '**PROBLEM**'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to download and unpack a tarball into your image in a concise way.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望以简洁的方式下载并解压 tarball 到你的镜像中。
- en: '**SOLUTION**'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Tar and compress your files, and use the `ADD` directive in your Dockerfile.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件打包并压缩，然后在 Dockerfile 中使用 `ADD` 指令。
- en: Create a fresh environment for this Docker build with `mkdir add_example &&
    cd add_example`. Then retrieve a tarball and give it a name you can reference
    later.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `mkdir add_example && cd add_example` 创建一个用于此 Docker 构建的新环境。然后检索一个 tarball
    并给它一个你可以稍后引用的名字。
- en: Listing 4.1\. Downloading a TAR file
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1\. 下载 TAR 文件
- en: '[PRE33]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this case we’ve used a TAR file from another technique, but it could be any
    tarball you like.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了一个来自另一种技术的 TAR 文件，但它可以是任何你喜欢的 tarball。
- en: Listing 4.2\. Adding a TAR file to an image
  id: totrans-465
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2\. 将 TAR 文件添加到镜像中
- en: '[PRE34]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Build this Dockerfile with `docker build --no-cache .` and the output should
    look like this:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker build --no-cache .` 构建此 Dockerfile，输出应该如下所示：
- en: Listing 4.3\. Building an image with a TAR file
  id: totrans-468
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3\. 使用 TAR 文件构建镜像
- en: '[PRE35]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can see from this output that the tarball has been unpacked into the target
    directory by the Docker daemon (the extended output of all the files has been
    edited). Docker will unpack tarfiles of most standard types (.gz, .bz2, .xz, .tar).
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这个输出中看到，tarball 已经被 Docker 守护进程（所有文件的扩展输出已被编辑）解压到目标目录中。Docker 将解压大多数标准类型的
    tarfile（.gz, .bz2, .xz, .tar）。
- en: It’s worth observing that although you can download tarballs from URLs, they’ll
    only be unpacked automatically if they’re stored in the local filesystem. This
    can lead to confusion.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，尽管你可以从 URL 下载 tarball，但只有当它们存储在本地文件系统中时，它们才会自动解压。这可能会导致混淆。
- en: If you repeat the preceding process with the following Dockerfile, you’ll notice
    that the file is downloaded but not unpacked.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用以下 Dockerfile 重复执行前面的过程，你会注意到文件被下载但没有解压。
- en: Listing 4.4\. Directly adding of the TAR file from the URL
  id: totrans-473
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4\. 直接从 URL 添加 TAR 文件
- en: '[PRE36]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1*** **The file is retrieved from the internet using a URL.**'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **文件通过 URL 从互联网检索。**'
- en: '***2*** **The destination directory is indicated by the directory name and
    a trailing slash. Without the trailing slash, the argument is treated as a filename
    for the downloaded file.**'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **目标目录由目录名和尾随斜线指示。如果没有尾随斜线，则参数被视为下载文件的文件名。**'
- en: 'Here’s the resulting build output:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是生成的构建输出：
- en: '[PRE37]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1*** **The libeatmydata-105.tar.gz file has been downloaded and placed in
    the /opt/libeatmydata directory without being unpacked.**'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **libeatmydata-105.tar.gz文件已下载并放置在/opt/libeatmydata目录中，未解压。**'
- en: Note that without the trailing slash in the `ADD` line in the previous Dockerfile,
    the file would be downloaded and saved with that filename. The trailing slash
    indicates that the file should be downloaded and placed in the directory specified.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在先前的Dockerfile中的`ADD`行末尾没有斜杠，文件将下载并保存为该文件名。末尾的斜杠表示文件应该下载并放置在指定的目录中。
- en: All new files and directories are owned by root (or whoever has group or user
    IDs of 0 within the container).
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 所有新的文件和目录都属于root（或在容器内具有组或用户ID为0的任何人）。
- en: '|  |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Whitespace in filenames
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 文件名中的空白字符
- en: 'If your filenames have whitespace in them, you’ll need to use the quoted form
    of `ADD` (or `COPY`):'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的文件名中有空白字符，你需要使用`ADD`（或`COPY`）的引号形式：
- en: '[PRE38]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|  |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**DISCUSSION**'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: The `ADD` Dockerfile instruction is quite a workhorse, with a number of different
    pieces of functionality you can take advantage of. If you’re going to write more
    than a couple of Dockerfiles (which you likely will as you go through this book),
    it’s worth reading the official Dockerfile instructions documentation—there aren’t
    many (18 instructions are listed in the documentation at the time of writing at
    [https://docs.docker.com/engine/reference/builder](https://docs.docker.com/engine/reference/builder))
    and you’ll only use a few of them regularly.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD` Dockerfile指令是一个非常强大的工具，具有许多不同的功能，你可以利用这些功能。如果你打算编写超过几个Dockerfile（随着你阅读这本书，你很可能会这样做），阅读官方Dockerfile指令文档是值得的——文档并不多（在撰写本文时，文档中列出了18条指令）并且你只会经常使用其中的一些。'
- en: People often ask about adding compressed files without extracting them. For
    this you should use the `COPY` command, which looks exactly like the `ADD` command
    but doesn’t unpack any files and won’t download over the internet.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常询问如何添加未解压的压缩文件。为此，你应该使用`COPY`命令，它看起来与`ADD`命令完全一样，但不会解压任何文件，也不会从互联网上下载。
- en: '|  |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Rebuilding without the cache**'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '**不使用缓存重建**'
- en: 'Building with Dockerfiles takes advantage of a useful caching feature: steps
    that have already been built are only rebuilt if the commands have changed. The
    next listing shows the output of a rebuild of the to-do app from [chapter 1](kindle_split_010.xhtml#ch01).'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Dockerfile构建利用了一个有用的缓存功能：只有当命令已更改时，已构建的步骤才会重新构建。下一个列表显示了从[第1章](kindle_split_010.xhtml#ch01)重建待办事项应用程序的重建输出。
- en: Listing 4.5\. Rebuilding with the cache
  id: totrans-494
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.5\. 使用缓存重建
- en: '[PRE39]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1*** **Indicates you’re using the cache**'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **表示你正在使用缓存**'
- en: '***2*** **Specifies the cached image/layer ID**'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **指定缓存的镜像/层ID**'
- en: '***3*** **The final image is “rebuilt,” but in reality nothing has changed.**'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **最终镜像“重建”，但实际上没有任何变化。**'
- en: As useful and time-saving as this is, it’s not always the behavior you want.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这很有用且节省时间，但这并不总是你想要的行为。
- en: Taking the preceding Dockerfile as an example, imagine you’d changed your source
    code and pushed it to the Git repository. The new code wouldn’t be checked out,
    because the `git clone` command hasn’t changed. As far as the Docker build is
    concerned, it’s the same, so the cached image can be reused.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 以先前的Dockerfile为例，假设你已更改了源代码并将其推送到Git仓库。新的代码不会被检出，因为`git clone`命令没有改变。就Docker构建而言，它是相同的，因此可以重用缓存的镜像。
- en: In these cases, you’ll want to rebuild your image without using the cache.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，你将想要不使用缓存重建你的镜像。
- en: '**PROBLEM**'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to rebuild your Dockerfile without using the cache.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在不使用缓存的情况下重建Dockerfile。
- en: '**SOLUTION**'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: To force a rebuild without using the image cache, run your `docker build` with
    the `--no-cache` flag. The following listing runs the previous build with `--no-cache`.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制不使用镜像缓存进行重建，请使用带有`--no-cache`标志的`docker build`运行。以下列表使用`--no-cache`运行了先前的构建。
- en: Listing 4.6\. Forcing a rebuild without using the cache
  id: totrans-506
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.6\. 不使用缓存强制重建
- en: '[PRE40]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1*** **Rebuilds the Docker image, ignoring cached layers with the --no-cache
    flag**'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **重建Docker镜像，忽略带有--no-cache标志的缓存层**'
- en: '***2*** **No mention of caching this time**'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **这次没有提及缓存**'
- en: '***3*** **Intervening images have a different ID than in the previous listing.**'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **中间的镜像ID与先前的列表不同。**'
- en: '***4*** **A new image is built.**'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **构建了一个新镜像。**'
- en: The output shows no mention of caching, and each intervening layer ID is different
    from the output in [listing 4.5](#ch04ex05).
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果没有提及缓存，并且每个中间层ID都与[列表4.5](#ch04ex05)中的输出不同。
- en: Similar problems can occur in other situations. We were flummoxed early on using
    Dockerfiles when a network blip meant that a command didn’t retrieve something
    properly from the network, but the command didn’t error. We kept calling `docker
    build`, but the resulting bug wouldn’t go away! This was because a “bad” image
    had found its way into the cache, and we didn’t understand the way Docker caching
    worked. Eventually we figured it out.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的问题也可能在其他情况下发生。我们最初在使用Dockerfile时遇到了困惑，因为网络问题导致命令无法从网络中正确检索某些内容，但命令并没有出错。我们一直调用`docker
    build`，但产生的错误却一直存在！这是因为一个“不良”的镜像已经进入了缓存，而我们不了解Docker缓存的工作方式。最终我们弄明白了。
- en: '**DISCUSSION**'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Removing caching can be a useful sanity check once you’ve got your final Dockerfile,
    to make sure it works from top to bottom, particularly when you’re using internal
    web resources in your company that you may have changed while iterating on the
    Dockerfile. This situation doesn’t occur if you’re using `ADD`, because Docker
    will download the file every time to check if it has changed, but that behavior
    can be tiresome if you’re pretty sure it’s going to stay the same and you just
    want to get going with writing the rest of the Dockerfile.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在您有了最终的Dockerfile之后，移除缓存可以是一个有用的合理性检查，以确保它从头到尾都能正常工作，尤其是当您在公司内部使用可能已经更改的Web资源时。如果您使用`ADD`，这种情况不会发生，因为Docker会每次都下载文件以检查它是否已更改，但如果您非常确信它将保持不变，只想继续编写Dockerfile的其余部分，这种行为可能会让人感到厌烦。
- en: '|  |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Busting the cache**'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '**打破缓存**'
- en: Using the `--no-cache` flag is often enough to get around any problems with
    the cache, but sometimes you’ll want a more fine-grained solution. If you have
    a build that takes a long time, for example, you may want to use the cache up
    to a certain point, and then invalidate it to rerun a command and create a new
    image.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--no-cache`标志通常足以解决任何与缓存相关的问题，但有时您可能需要一个更细致的解决方案。例如，如果您有一个耗时较长的构建，您可能希望使用缓存到某个点，然后使缓存失效以重新运行命令并创建新镜像。
- en: '**PROBLEM**'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to invalidate the Docker build cache from a specific point in the Dockerfile
    build.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望从Dockerfile构建的特定点无效化Docker构建缓存。
- en: '**SOLUTION**'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Add a benign comment after the command to invalidate the cache.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令后添加一个无害的注释以使缓存失效。
- en: 'Starting with the Dockerfile in [https://github.com/docker-in-practice/todo](https://github.com/docker-in-practice/todo)
    (which corresponds to the `Step` lines in the following output), we’ve done a
    build and then added a comment in the Dockerfile on the line with `CMD`. You can
    see the output of doing `docker build` again here:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://github.com/docker-in-practice/todo](https://github.com/docker-in-practice/todo)中的Dockerfile开始（这对应于以下输出中的`Step`行），我们已经进行了构建，并在Dockerfile中`CMD`行的旁边添加了注释。您可以在下面看到再次执行`docker
    build`的输出：
- en: '[PRE41]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1*** **A “normal” docker build**'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **一个“正常”的Docker构建**'
- en: '***2*** **Cache is used up to here.**'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **缓存已使用到这里。**'
- en: '***3*** **Cache has been invalidated, but the command is effectively unchanged.**'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **缓存已被失效，但命令本身实际上没有改变。**'
- en: '***4*** **A new image has been created.**'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **已创建新镜像。**'
- en: The reason this trick works is because Docker treats the non-whitespace change
    to the line as though it were a new command, so the cached layer is not re-used.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧之所以有效，是因为Docker将行中的非空白更改视为新命令，因此不会重新使用缓存的层。
- en: You may be wondering (as we did when we first looked at Docker) whether you
    can move Docker layers from image to image, merging them at will as though they
    were change sets in Git. This isn’t possible at present within Docker. A layer
    is defined as a change set from a given image only. Because of this, once the
    cache has been broken, it can’t be re-applied for commands re-used later in the
    build. For this reason, you’re advised to put commands that are less likely to
    change nearer the top of the Dockerfile if possible.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道（就像我们最初查看Docker时那样），您是否可以将Docker层从镜像移动到另一个镜像，像Git中的更改集一样随意合并。在Docker中目前无法做到这一点。层被定义为从给定镜像的更改集。因此，一旦缓存被打破，它就不能在构建过程中稍后重用的命令中重新应用。因此，建议如果可能的话，将不太可能改变的命令放在Dockerfile的顶部。
- en: '**DISCUSSION**'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: For the initial iteration on a Dockerfile, splitting up every single command
    into a separate layer is excellent for speed of iteration, because you can selectively
    rerun parts of the process, as shown in the previous listing, but it’s not so
    great for producing a small final image. It’s not unheard-of for builds with a
    reasonable amount of complexity to approach the hard limit of 42 layers. To mitigate
    this, once you have a working build you’re happy with, you should look at the
    steps in [technique 56](kindle_split_017.xhtml#ch07sb09) for creating a production-ready
    image.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Dockerfile 的初始迭代，将每个命令拆分成单独的层对于迭代速度来说非常好，因为你可以选择性地重新运行过程的部分，如前一个列表所示，但这对于生成小型最终镜像来说并不那么好。对于具有一定复杂性的构建来说，接近
    42 层的硬限制并不罕见。为了减轻这种情况，一旦你有一个满意的正常构建，你应该查看 [技术 56](kindle_split_017.xhtml#ch07sb09)
    中的步骤，以创建一个生产就绪的镜像。
- en: '|  |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Intelligent cache-busting using build-args**'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用构建参数进行智能缓存中断**'
- en: In the previous technique you saw how the cache can be busted mid-build by changing
    the relevant line.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的技术中，你看到了如何通过更改相关行在构建过程中中断缓存。
- en: In this technique we’re going to take things a step further by controlling whether
    or not the cache is busted from the build command.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技术中，我们将通过控制是否从构建命令中断缓存来更进一步。
- en: '**PROBLEM**'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to bust the cache on demand when performing a build, without editing
    the Dockerfile.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望在构建时按需中断缓存，而不需要编辑 Dockerfile。
- en: '**SOLUTION**'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the `ARG` directive in your Dockerfile to enable surgical cache-busting.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Dockerfile 中使用 `ARG` 指令来启用手术式缓存中断。
- en: To demonstrate this, you’re again going to use the Dockerfile at [https://github.com/docker-in-practice/todo](https://github.com/docker-in-practice/todo),
    but make a minor change to it.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，你将再次使用 [https://github.com/docker-in-practice/todo](https://github.com/docker-in-practice/todo)
    中的 Dockerfile，但对其做一点小的修改。
- en: What you want to do is control the busting of the cache before the `npm install`.
    Why would you want to do this? As you’ve learned, by default Docker will only
    break the cache if the command in the Dockerfile changes. But let’s imagine that
    updated npm packages are available, and you want to make sure you get them. One
    option is to manually change the line (as you saw in the previous technique),
    but a more elegant way to achieve the same thing involves using the Docker `ARGS`
    directive and a bash trick.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要在 `npm install` 之前控制缓存的中断。你为什么要这样做呢？正如你所学的，默认情况下，Docker 只有在 Dockerfile 中的命令更改时才会中断缓存。但是，让我们想象一下，有更新的
    npm 包可用，你想要确保你得到它们。一个选项是手动更改这一行（如你在之前的技术中看到的），但实现相同目标的一种更优雅的方法是使用 Docker `ARGS`
    指令和 bash 技巧。
- en: Add the `ARG` line to the Dockerfile as follows.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式将 `ARG` 行添加到 Dockerfile 中。
- en: Listing 4.7\. Simple Dockerfile with bustable cache
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.7\. 具有可中断缓存的简单 Dockerfile
- en: '[PRE42]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1*** **The ARG directive sets an environment variable for the build.**'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **`ARG` 指令为构建设置环境变量。**'
- en: In this example, you use the ARG directive to set the `CACHEBUST` environment
    variable and default it to `no` if it’s not set by the `docker build` command.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你使用 `ARG` 指令设置 `CACHEBUST` 环境变量，并在 `docker build` 命令未设置时将其默认设置为 `no`。
- en: 'Now build that Dockerfile “normally”:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照“正常”方式构建 Dockerfile：
- en: '[PRE43]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you build it again with exactly the same `docker build` command, you’ll observe
    that the Docker build cache is used, and no changes are made to the resulting
    image.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次使用完全相同的 `docker build` 命令构建它，你会观察到 Docker 构建缓存被使用，并且结果镜像没有进行任何更改。
- en: '[PRE44]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: At this point you decide that you want to force the npm packages to be rebuilt.
    Perhaps a bug has been fixed, or you want to be sure you’re up to date. This is
    where the `ARG` variable you added to the Dockerfile in [listing 4.7](#ch04ex07)
    comes in. If this `ARG` variable is set to a value never used before on your host,
    the cache will be busted from that point.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你决定你想强制重新构建 npm 包。也许一个错误已经被修复，或者你想要确保你是最新的。这就是你在 [列表 4.7](#ch04ex07) 中添加到
    Dockerfile 中的 `ARG` 变量发挥作用的地方。如果这个 `ARG` 变量在你的主机上从未使用过，那么从那个点开始缓存将被中断。
- en: 'This is where you use the `build-arg` flag to `docker build`, along with a
    bash trick to force a fresh value:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在 `docker build` 中使用 `build-arg` 标志并配合 bash 技巧强制使用新值的地方：
- en: '[PRE45]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1*** **Run docker build with the build-arg flag, setting the CACHEBUST argument
    to a pseudo-random value generated by bash**'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 使用带有 `build-arg` 标志的 `docker build` 命令，将 `CACHEBUST` 参数设置为 bash 生成的伪随机值'
- en: '***2*** **Because the ARG CACHEBUST=no line itself has not changed, the cache
    is used here.**'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **因为 `ARG CACHEBUST=no` 行本身没有更改，所以这里使用了缓存。**'
- en: '***3*** **Because the CACHEBUST arg was set to a previously unset value, the
    cache is busted, and the npm install command is run again.**'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **因为 CACHEBUST 参数被设置为一个之前未设置的值，缓存被打破，npm 安装命令再次运行。**'
- en: Note that the cache is busted on the line *following* the `ARG` line, not the
    `ARG` line itself. This can be a little confusing. The key thing to look out for
    is the “Running in” phrase—this means that a new container has been created to
    run the build line in.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，缓存是在 `ARG` 行之后的行上打破的，而不是 `ARG` 行本身。这可能会有些令人困惑。关键是要注意“运行中”这个短语——这意味着已经创建了一个新的容器来运行构建行。
- en: 'The use of the `${RANDOM}` argument is worth explaining. Bash provides you
    with this reserved variable name to give you an easy way of getting a value between
    one and five digits long:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 解释 `${RANDOM}` 参数的用法是值得的。Bash 提供了这个保留变量名，以便你能够轻松地获取一个长度为一到五位数的值：
- en: '[PRE46]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This can come in handy, such as when you want a probably unique value to create
    files just for a specific run of a script.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能很有用，比如当你想要一个可能唯一的值来为特定脚本的运行创建文件时。
- en: 'You can even produce a much longer random number if you’re concerned about
    clashes:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你担心冲突，你甚至可以生成一个更长的随机数：
- en: '[PRE47]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Note that if you’re not using bash (or a shell that has this `RANDOM` variable
    available), this technique won’t work. In that case, you could use the date command
    instead to produce a fresh value:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你没有使用 bash（或具有此 `RANDOM` 变量的 shell），这个技术将不起作用。在这种情况下，你可以使用 date 命令来生成一个新鲜值：
- en: '[PRE48]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**DISCUSSION**'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This technique has demonstrated a few things that will come in handy when using
    Docker. You’ve learned about using the `--build-args` flag to pass in a value
    to the Dockerfile and bust the cache on demand, creating a fresh build without
    changing the Dockerfile.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在使用 Docker 时展示了一些实用的功能。你已经学会了如何使用 `--build-args` 标志向 Dockerfile 传递一个值，并在需要时打破缓存，创建一个不更改
    Dockerfile 的新构建。
- en: If you use bash, you’ve also learned about the `RANDOM` variable, and how it
    can be useful in other contexts than just Docker builds.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 bash，你也已经学会了 `RANDOM` 变量的用法，以及它在 Docker 构建之外的其他上下文中的有用性。
- en: '|  |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Intelligent cache-busting using the ADD directive**'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 ADD 指令进行智能缓存打破**'
- en: In the previous technique you saw how the cache could be busted mid-build at
    a time of your choosing, which was itself a level up from using the `--no-cache`
    flag to ignore the cache completely.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的技术中，你看到了如何在构建过程中选择性地打破缓存，这比使用 `--no-cache` 标志完全忽略缓存要高级。
- en: Now you’re going to take it to the next level, so that you can automatically
    bust the cache only when it’s necessary to. This can save you a lot of time and
    compute—and therefore money!
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将把它提升到下一个层次，这样你就可以在必要时自动打破缓存。这可以为你节省大量的时间和计算资源——因此，也可以节省金钱！
- en: '**PROBLEM**'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to bust the cache when a remote resource has changed.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望在远程资源发生变化时打破缓存。
- en: '**SOLUTION**'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the Dockerfile `ADD` directive to only bust the cache when the response
    from a URL changes.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Dockerfile 的 `ADD` 指令仅在 URL 的响应发生变化时打破缓存。
- en: One of the early criticisms of Dockerfiles was that their claim of producing
    reliable build results was misleading. Indeed, we took this very subject up with
    the creator of Docker back in 2013 ([http://mng.bz/B8E4](http://mng.bz/B8E4)).
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 早期的一些批评之一是，它们声称能够产生可靠的构建结果是不准确的。确实，我们在 2013 年就这个问题与 Docker 的创造者进行了讨论（[http://mng.bz/B8E4](http://mng.bz/B8E4)）。
- en: Specifically, if you make a call to the network with a directive in your Dockerfile
    like this,
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，如果你在 Dockerfile 中使用如下指令调用网络，
- en: '[PRE49]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: then by default the Docker build will perform this once per Docker daemon. The
    code on GitHub could change substantially, but as far as your Docker daemon is
    concerned, the build is up to date. Years could pass, and the same Docker daemon
    will still be using the cache.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker 构建将在每个 Docker 守护程序上执行一次。GitHub 上的代码可能会发生重大变化，但就你的 Docker 守护程序而言，构建是更新的。即使年复一年，同一个
    Docker 守护程序仍然会使用缓存。
- en: This may sound like a theoretical concern, but it’s a very real one for many
    users. We’ve seen this happen many times at work, causing confusion. You’ve already
    seen some solutions to this, but for many complex or large builds, those solutions
    are not granular enough.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来像是一个理论上的担忧，但对于许多用户来说，这是一个非常现实的问题。我们在工作中已经多次看到这种情况发生，导致困惑。你已经看到了一些解决方案，但对于许多复杂或大型构建，这些解决方案还不够细致。
- en: '**The smart cache-busting pattern**'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '**智能缓存打破模式**'
- en: Imagine you have a Dockerfile that looks like the following listing (note that
    it won’t work! It’s just a Dockerfile pattern to show the principle).
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个如下所示的 Dockerfile（注意，它不会工作！它只是一个 Dockerfile 模式，用于展示原理）。
- en: Listing 4.8\. An example Dockerfile
  id: totrans-587
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.8\. 一个示例 Dockerfile
- en: '[PRE50]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1*** **Installs a series of packages as a prerequisite**'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **安装一系列作为先决条件的包**'
- en: '***2*** **Clones a regularly changing repository (nodejs is just an example)**'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **克隆一个经常变化的仓库（nodejs 只是一个例子）**'
- en: '***3*** **Runs a make and install command, which builds the project**'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **运行 make 和 install 命令，用于构建项目**'
- en: 'This Dockerfile presents some challenges to creating an efficient build process.
    If you want to build everything from scratch each time, the solution is simple:
    use the `--no-cache` argument to `docker build`. The problem with this is that
    each time you run a build you’re repeating the package installation in the second
    line, which is (mostly) unnecessary.'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Dockerfile 在创建高效的构建过程中提出了一些挑战。如果你每次都想要从头开始构建一切，解决方案很简单：使用 `docker build`
    的 `--no-cache` 参数。但问题在于，每次你运行构建时，你都会在第二行重复包的安装，而这（大部分）是不必要的。
- en: 'This challenge can be solved by busting the cache just before the `git clone`
    (demonstrated in the last technique). This raises another challenge, however:
    what if the Git repository hasn’t changed? Then you’re doing a potentially costly
    network transfer, followed by a potentially costly `make` command. Network, compute,
    and disk resources are all being used unnecessarily.'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 这个挑战可以通过在 `git clone` 之前清除缓存来解决（如上一种技术所示）。然而，这又提出了另一个挑战：如果 Git 仓库没有更改呢？那么你将进行可能代价高昂的网络传输，随后是可能代价高昂的
    `make` 命令。网络、计算和磁盘资源都被不必要地使用了。
- en: One way to get around this is to use [technique 23](#ch04sb05), where you pass
    in a build argument with a new value every time you know that the remote repository
    has changed. But this still requires manual investigation to determine whether
    there has been a change, and intervention.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是使用 [技术 23](#ch04sb05)，每次当你知道远程仓库已更改时，都传递一个具有新值的构建参数。但这也仍然需要手动调查来确定是否发生了更改，并采取干预措施。
- en: What you need is a command that can determine whether the resource has changed
    since the last build, and only then bust the cache.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的是一个命令，它可以确定资源自上次构建以来是否已更改，然后才清除缓存。
- en: '**The ADD directive—unexpected benefits**'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '**`ADD` 指令——意外的好处**'
- en: Enter the `ADD` directive!
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用 `ADD` 指令了！
- en: 'You’re already familiar with `ADD`, as it’s a basic Dockerfile directive. Normally
    it’s used to add a file to the resulting image, but there are two useful features
    of `ADD` that you can use to your advantage in this context: it caches the contents
    of the file it refers to, and it can take a network resource as an argument. This
    means that you can bust the cache whenever the output of a web request changes.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经熟悉 `ADD`，因为它是 Dockerfile 的一个基本指令。通常它用于将文件添加到结果镜像中，但 `ADD` 有两个有用的特性，你可以在这种情况下利用它们：它缓存它引用的文件的内容，并且它可以接受网络资源作为参数。这意味着你可以在网络请求的输出发生变化时随时清除缓存。
- en: How can you take advantage of this when cloning a repository? Well, that depends
    on the nature of the resource you’re referencing over the network. Many resources
    will have a page that changes when the repository itself changes, but these will
    vary from resource type to resource type. Here we’ll focus on GitHub repos, because
    that’s a common use case.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何在克隆仓库时利用这一点？嗯，这取决于你通过网络引用的资源性质。许多资源在仓库本身更改时会有一个页面发生变化，但这些会因资源类型而异。在这里，我们将关注
    GitHub 仓库，因为这是一个常见的用例。
- en: The GitHub API provides a useful resource that can help here. It has URLs for
    each repository that return JSON for the most recent commits. When a new commit
    is made, the content of the response changes.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub API 提供了一个有用的资源，可以帮助你在这里。它为每个仓库提供了返回最新提交 JSON 的 URL。当创建新提交时，响应的内容会发生变化。
- en: Listing 4.9\. Using `ADD` to trigger a cache bust
  id: totrans-601
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.9\. 使用 `ADD` 触发缓存清除
- en: '[PRE51]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1*** **The URL that changes when a new commit is made**'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **当创建新提交时更改的 URL**'
- en: '***2*** **It doesn’t matter where the output of the file goes, so we send it
    to /dev/null.**'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **文件输出去向无关紧要，所以我们将其发送到 /dev/null。**'
- en: '***3*** **The git clone will take place only when a change is made.**'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **仅在发生更改时才会进行 git clone**'
- en: The result of the preceding listing is that the cache is busted only when a
    commit has been made to the repo since the last build. No human intervention is
    required, and no manual checking.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个列表的结果是，只有在最后一次构建之后向仓库提交了提交时，缓存才会被破坏。不需要人工干预，也不需要手动检查。
- en: If you want to test this mechanism with a frequently changing repo, try using
    the Linux kernel.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用频繁更改的仓库测试此机制，请尝试使用 Linux 内核。
- en: Listing 4.10\. Adding the Linux kernel code to an image
  id: totrans-608
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.10\. 将 Linux 内核代码添加到镜像中
- en: '[PRE52]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1*** **The ADD command, this time using the Linux repository**'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用 Linux 仓库的 ADD 命令**'
- en: '***2*** **Outputs the system date into the built image, which will show when
    the last cache-busting build took place**'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将系统日期输出到构建的镜像中，这将显示最后一次缓存破坏构建发生的时间**'
- en: If you create a folder and put the preceding code into a Dockerfile, and then
    run the following command regularly (every hour, for example), the output date
    will change only when the Linux Git repo changes.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建一个文件夹，将前面的代码放入 Dockerfile 中，然后定期运行以下命令（例如每小时一次），输出日期只有在 Linux Git 仓库更改时才会改变。
- en: Listing 4.11\. Building a Linux code image
  id: totrans-613
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.11\. 构建Linux代码镜像
- en: '[PRE53]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***1*** **Builds the image and gives it the name linux_last_updated**'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **构建镜像并给它命名为 linux_last_updated**'
- en: '***2*** **Outputs the contents of the /build_time file from the resulting image**'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **输出结果镜像中 /build_time 文件的内容**'
- en: '**DISCUSSION**'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This technique demonstrated a valuable automated technique for ensuring builds
    only take place when necessary.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术展示了一种宝贵的自动化技术，以确保仅在必要时进行构建。
- en: It also demonstrated some of the details of how the `ADD` command works. You
    saw that the “file” could be a network resource, and that if the contents of the
    file (or network resource) change from a previous build, a cache bust takes place.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 它还展示了 `ADD` 命令的一些工作细节。你看到“文件”可以是网络资源，如果文件（或网络资源）的内容从以前的构建中更改，则会发生缓存破坏。
- en: In addition, you also saw that network resources have related resources that
    can indicate whether the resource you’re referencing has changed. Although you
    could, for example, reference the main GitHub page to see if there are any changes
    there, it’s likely that the page changes more frequently than the last commit
    (such as if the time of the web response is buried in the page source, or if there’s
    a unique reference string in each response).
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还看到了网络资源有相关的资源可以指示你引用的资源是否已更改。虽然你可以，例如，引用主 GitHub 页面来查看是否有任何更改，但该页面可能比最后一次提交更改得更频繁（例如，如果网页响应的时间被埋藏在页面源代码中，或者如果每个响应都有一个唯一的引用字符串）。
- en: 'In the case of GitHub, you can reference the API, as you saw. Other services,
    such as BitBucket, offer similar resources. The Kubernetes project, for example,
    offers this URL to indicate which release is stable: [https://storage.googleapis.com/kubernetesrelease/release/stable.txt](https://storage.googleapis.com/kubernetesrelease/release/stable.txt).
    If you were building a Kubernetes-based project, you might put an `ADD` line in
    your Dockerfile to bust the cache whenever this response changes.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 的情况下，你可以引用 API，正如你所看到的。其他服务，如 BitBucket，提供类似资源。例如，Kubernetes 项目提供此
    URL 来指示哪个版本是稳定的：[https://storage.googleapis.com/kubernetesrelease/release/stable.txt](https://storage.googleapis.com/kubernetesrelease/release/stable.txt)。如果你正在构建基于
    Kubernetes 的项目，你可以在 Dockerfile 中添加一条 `ADD` 行，以便在响应更改时破坏缓存。
- en: '|  |'
  id: totrans-622
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-623
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Setting the right time zone in your containers**'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '**在容器中设置正确的时间区域**'
- en: If you’ve ever installed a full operating system, you’ll know that setting the
    time zone is part of the process of setting it up. Even though a container isn’t
    an operating system (or a virtual machine), it contains the files that tell programs
    how to interpret the time for the configured timezone.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经安装过完整的操作系统，你就会知道设置时区是设置过程的一部分。即使容器不是操作系统（或虚拟机），它也包含告诉程序如何解释配置时区时间的文件。
- en: '**PROBLEM**'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to set the time zone correctly for your containers.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要为你的容器设置正确的时间区域。
- en: '**SOLUTION**'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Replace the container’s localtime file with a link to the time zone you want.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 将容器的 localtime 文件替换为指向你想要的时间区域的链接。
- en: The following listing demonstrates the problem. It doesn’t matter where in the
    world you run this, the container will show the same time zone.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了问题。无论你在世界的哪个地方运行它，容器都会显示相同的时区。
- en: Listing 4.12\. Container starting with wrong time zone
  id: totrans-631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.12\. 以错误时区开始的容器
- en: '[PRE54]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1*** **Runs a command to display the time zone on the host**'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **运行命令以显示主机上的时区**'
- en: '***2*** **The time zone on the host is GMT.**'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **主机上的时区是 GMT。**'
- en: '***3*** **Runs a container and outputs the date from within that**'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **运行容器并输出容器内的日期**'
- en: '***4*** **The time zone in the container is GMT.**'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **容器中的时区是 GMT。**'
- en: The container contains the files that determine which time zone is used by the
    container to interpret the time value it gets. The actual time used is, of course,
    tracked by the host operating system.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 容器包含确定容器使用哪个时区来解释它获取的时间值的文件。实际使用的时间当然由主机操作系统跟踪。
- en: The next listing shows how you can set the time zone to the one you want.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了如何设置您想要的时区。
- en: Listing 4.13\. Dockerfile for replacing the centos:7 default time zone
  id: totrans-639
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.13\. 替换 centos:7 默认时区的 Dockerfile
- en: '[PRE55]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1*** **Starts from the centos image we just looked at**'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从我们刚才查看的 centos 镜像启动**'
- en: '***2*** **Removes the existing localtime symlink file**'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **删除现有的 localtime 链接文件**'
- en: '***3*** **Replaces the /etc/localtime link with a link to the time zone you
    want**'
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将 /etc/localtime 链接替换为指向您想要的时区的链接**'
- en: '***4*** **Shows the time zone of your container as the default command to run**'
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **显示容器的时区作为默认要运行的命令**'
- en: In [listing 4.13](#ch04ex13) the key file is /etc/localtime. This points to
    the file that tells the container which time zone to use when it’s asked for the
    time. The default time given is in the UTC time standard, which is used if the
    file doesn’t exist (the minimal BusyBox image, for example, doesn’t have it).
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 4.13](#ch04ex13) 中，关键文件是 /etc/localtime。它指向一个文件，告诉容器在请求时间时使用哪个时区。默认时间是以
    UTC 时间标准给出的，如果文件不存在（例如，最小的 BusyBox 镜像没有它），则使用该时间。
- en: The following listing shows the output of building the preceding Dockerfile.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了构建前面 Dockerfile 的输出。
- en: Listing 4.14\. Building a time-zone-replacing Dockerfile
  id: totrans-647
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.14\. 构建替换时区的 Dockerfile
- en: '[PRE56]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1*** **Builds the container**'
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **构建容器**'
- en: '***2*** **Runs the container**'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **运行容器**'
- en: '***3*** **Outputs the specified time zone**'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **输出指定的时区**'
- en: In this way you can specify the time zone to use within—and only within—your
    container. Many applications depend on this setting, so it comes up not infrequently
    if you’re running a Docker service.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，您可以在容器内部指定要使用的时区——并且仅限于容器内部。许多应用程序都依赖于这个设置，所以如果您运行 Docker 服务，它并不罕见。
- en: There’s another problem that this container-level time granularity can solve.
    If you’re working for a multinational organization and run many different applications
    on servers based in data centers around the world, the ability to change the time
    zone in your image and trust that it will report the right time wherever it lands
    is a useful trick to have to hand.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 这种容器级时间粒度还可以解决另一个问题。如果您为跨国组织工作，并在全球数据中心的服务器上运行许多不同的应用程序，那么在您的镜像中更改时区并相信它无论在哪里都能报告正确的时间，这是一个有用的技巧。
- en: '**DISCUSSION**'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Because the point of Docker images is explicitly to provide a consistent experience
    no matter where you run your container, there are a number of things you may stumble
    across if you do want varied results depending on where an image is deployed.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Docker 镜像的目的是明确地提供无论在哪里运行容器都一致的经验，因此如果您希望根据镜像部署的位置得到不同的结果，您可能会遇到一些事情。
- en: As an example, if you’re automatically producing CSV spreadsheets of data for
    users in different locations, they may have certain expectations of the data format.
    American users might expect dates in the mm/dd format, whereas Europeans might
    expect dates in dd/mm format, and Chinese users might expect dates in their own
    character set.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您正在为不同地点的用户自动生成数据 CSV 电子表格，他们可能对数据格式有一定的期望。美国用户可能期望日期以 mm/dd 格式显示，而欧洲用户可能期望日期以
    dd/mm 格式显示，中国用户可能期望日期以他们自己的字符集显示。
- en: In the next technique we’ll consider locale settings, which affect how dates
    and times are printed in the `local` format, among other things.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个技术中，我们将考虑区域设置，这会影响日期和时间在 `local` 格式中的打印方式，以及其他方面。
- en: '|  |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-659
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Locale management**'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '**区域管理**'
- en: In addition to time zones, locales are another aspect of Docker images that
    can be relevant when building images or running containers.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 除了时区之外，区域也是 Docker 镜像的另一个方面，在构建镜像或运行容器时可能相关。
- en: '|  |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-663
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**注意**'
- en: A locale defines which language and country settings your programs should use.
    Typically a locale will be set in the environment through the `LANG`, `LANGUAGE`,
    and `locale-gen` variables, and through variables beginning with `LC_`, such as
    `LC_TIME`, whose setting determines how the time is displayed to the user.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 区域设置定义了您的程序应使用哪种语言和国家设置。通常，区域设置将通过`LANG`、`LANGUAGE`和`locale-gen`变量在环境中设置，以及以`LC_`开头的变量，例如`LC_TIME`，其设置决定了时间如何显示给用户。
- en: '|  |'
  id: totrans-665
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-666
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-667
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'An encoding (in this context) is the means by which text is stored as bytes
    on a computer. A good introduction to this subject is available from W3C here:
    [https://www.w3.org/International/questions/qa-what-is-encoding](https://www.w3.org/International/questions/qa-what-is-encoding).
    It’s worth taking the time to understand this subject, as it comes up in all sorts
    of contexts.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 编码（在这个上下文中）是文本在计算机上以字节形式存储的方式。关于这个主题的良好介绍可以在W3C这里找到：[https://www.w3.org/International/questions/qa-what-is-encoding](https://www.w3.org/International/questions/qa-what-is-encoding)。花时间理解这个主题是值得的，因为它在各种上下文中都会出现。
- en: '|  |'
  id: totrans-669
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**PROBLEM**'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You’re seeing encoding errors in your application builds or deployments.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 您在应用程序构建或部署中看到编码错误。
- en: '**SOLUTION**'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Ensure the langugage-specific environment variables are correctly set in your
    Dockerfile.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在Dockerfile中正确设置了语言特定的环境变量。
- en: Encoding issues aren’t always obvious to all users, but they can be fatal when
    building applications.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 编码问题并不总是对所有用户都很明显，但在构建应用程序时可能会致命。
- en: Here are a couple of examples of typical encoding errors when building applications
    in Docker.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是构建Docker中的应用程序时典型的编码错误的一些示例。
- en: Listing 4.15\. Typical encoding errors
  id: totrans-676
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.15\. 典型的编码错误
- en: '[PRE57]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: These errors can kill a build or an application stone dead.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误可能会使构建或应用程序完全失败。
- en: '|  |'
  id: totrans-679
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-680
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: A non-exhaustive list of key words to look out for in the error are “encoding,”
    “ascii,” “unicode,” “UTF-8,” “character,” and “codec.” If you see these words,
    chances are you’re dealing with an encoding issue.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误中需要注意的关键词列表不完整，包括“encoding”、“ascii”、“unicode”、“UTF-8”、“character”和“codec”。如果您看到这些单词，那么您可能正在处理一个编码问题。
- en: '|  |'
  id: totrans-682
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**What does this have to do with Docker?**'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '**这与Docker有什么关系？**'
- en: When you set up a full-blown operating system, you’re typically guided through
    a setup process that asks you to confirm your preferred time zone, language, keyboard
    layout, and so on.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 当您设置一个完整的操作系统时，您通常会通过一个设置过程引导，该过程要求您确认首选时区、语言、键盘布局等。
- en: Docker containers, as you know by now, aren’t full-blown operating systems set
    up for general use. Rather they’re (increasingly) minimal environments for running
    applications. By default, therefore, they may not come with all the setup you’re
    used to with an operating system.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，Docker容器不是为通用用途设置的完整操作系统。相反，它们是（越来越多地）用于运行应用程序的最小环境。因此，默认情况下，它们可能不会包含您在操作系统中习惯的所有设置。
- en: In particular, Debian removed their dependency on the locales package in 2011,
    which means that, by default, there’s no locale setup in a container based on
    a Debian image. For example, the following listing shows a Debian-derived Ubuntu
    image’s default environment.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是Debian在2011年移除了对区域设置包的依赖，这意味着默认情况下，基于Debian镜像的容器中没有区域设置。例如，以下列表显示了基于Debian的Ubuntu镜像的默认环境。
- en: Listing 4.16\. Default environment on an Ubuntu container
  id: totrans-687
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.16\. Ubuntu容器上的默认环境
- en: '[PRE58]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There are no `LANG` or similar `LC_` settings available in the image by default.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在镜像中没有可用的`LANG`或类似的`LC_`设置。
- en: Our Docker host is shown in the next listing.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Docker主机在下一个列表中显示。
- en: Listing 4.17\. LANG setting on Docker host OS
  id: totrans-691
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.17\. Docker主机OS上的LANG设置
- en: '[PRE59]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: There’s a `LANG` setting in our shell that informs applications that the preferred
    encoding in our terminal is British English, with text encoded in UTF-8.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的shell中有一个`LANG`设置，它通知应用程序我们的终端首选编码是英国英语，文本以UTF-8编码。
- en: To demonstrate an encoding issue, we’ll create a file locally that contains
    a UTF-8-encoded UK currency symbol (the UK’s pound sign), and then show how the
    interpretation of that file changes depending on the terminal’s encoding.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示编码问题，我们将在本地创建一个包含UTF-8编码的英国货币符号（英国的英镑符号）的文件，然后展示根据终端的编码，该文件的解释如何变化。
- en: Listing 4.18\. Creating and showing a UTF-8-encoded UK currency symbol
  id: totrans-695
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.18\. 创建并显示一个UTF-8编码的英国货币符号
- en: '[PRE60]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1*** **Uses echo with the -e flag to output two bytes into a file, which
    represent a UK pound sign**'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用带有-e标志的echo将两个字节输出到文件中，这两个字节代表一个英国英镑符号**'
- en: '***2*** **Cats the file; we’ll see a pound sign.**'
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **读取文件；我们将看到一个英镑符号。**'
- en: In UTF-8, a pound sign is represented by two bytes. We output these two bytes
    using `echo -e` and the `\x` notation and redirect output into a file. When we
    `cat` the file, the terminal reads the two bytes and knows to interpret the output
    as a pound sign.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 在UTF-8中，英镑符号由两个字节表示。我们使用`echo -e`和`\x`表示法输出这两个字节，并将输出重定向到文件。当我们`cat`文件时，终端读取这两个字节并知道将输出解释为英镑符号。
- en: 'Now if we change our terminal’s encoding to use the Western (ISO Latin 1) encoding
    (which sets up our local `LANG` also) and output the file, it looks quite different:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们更改我们的终端编码以使用西方（ISO Latin 1）编码（这也设置了我们的本地`LANG`），然后输出文件，看起来相当不同：
- en: Listing 4.19\. Demonstrating the encoding problem with the UK currency symbol
  id: totrans-701
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.19\. 使用英国货币符号演示编码问题
- en: '[PRE61]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1*** **The LANG environment variable is now set to Western (ISO Latin 1),
    which is set by the terminal.**'
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **现在`LANG`环境变量被设置为西方（ISO Latin 1），这是由终端设置的。**'
- en: '***2*** **The two bytes are interpreted differently, as two separate characters
    that are displayed to us.**'
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **这两个字节被解释为两个不同的字符，显示给我们。**'
- en: The `\xc2` byte is interpreted as a capital *A* with a circumflex on top, and
    the `\xa3` byte is interpreted as a UK pound sign!
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '`\xc2`字节被解释为带上方重音符号的大写*A*，而`\xa3`字节被解释为英国英镑符号！'
- en: '|  |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-707
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We say “we” rather than “you” above deliberately! Debugging and controlling
    encodings is a tricky affair, which can depend on a combination of the running
    application’s state, the environment variables you have set up, the running application,
    and all of the preceding factors that create the data you’re examining!
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面故意使用“我们”而不是“你”！调试和控制编码是一件棘手的事情，这可以取决于运行应用程序的状态、你设置的环境变量、运行的应用程序以及所有创建你正在检查的数据的前置因素！
- en: '|  |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As you’ve seen, encodings can be affected by the encoding set in the terminal.
    Getting back to Docker, we noted that no encoding environment variables were set
    by default in our Ubuntu container. Because of this, you can get different results
    when running the same commands on your host or in a container. If you see errors
    that seem to relate to encodings, you may need to set them in your Dockerfile.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，编码可能会受到终端中设置的编码集的影响。回到Docker，我们注意到在我们的Ubuntu容器中默认没有设置编码环境变量。因此，当你在主机或容器中运行相同的命令时，可能会得到不同的结果。如果你看到似乎与编码相关的错误，你可能需要在你的Dockerfile中设置它们。
- en: '**Setting up encodings in a Dockerfile**'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '**在Dockerfile中设置编码**'
- en: We’ll now look at how you can control the encoding of a Debian-based image.
    We’ve chosen this image because it’s likely to be one of the more common contexts.
    This example will set up a simple image that just outputs its default environment
    variables.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨如何控制基于Debian的镜像的编码。我们选择这个镜像，因为它可能是更常见的上下文之一。此示例将设置一个简单的镜像，它只输出其默认环境变量。
- en: Listing 4.20\. Setting up a Dockerfile example
  id: totrans-713
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.20\. 设置Dockerfile示例
- en: '[PRE62]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1*** **Uses a Debian-derived base image**'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用基于Debian的基础镜像**'
- en: '***2*** **Updates the package index and installs the locales package**'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **更新软件包索引并安装区域设置包**'
- en: '***3*** **Generates the locale for US English, encoded with UTF-8**'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **为美国英语生成区域设置，编码为UTF-8**'
- en: '***4*** **Sets the LANG environment variable**'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **设置`LANG`环境变量**'
- en: '***5*** **Sets the LANGUAGE environment variable**'
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **设置`LANGUAGE`环境变量**'
- en: '***6*** **The default command env will display the environment setup for the
    container.**'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **默认的命令`env`将显示容器的环境设置。**'
- en: You may be wondering what the differences between the `LANG` and `LANGUAGE`
    variables are. Briefly, `LANG` is the default setting for the preferred language
    and encoding settings. It also provides a default when applications look for the
    more specific `LC_*` settings. `LANGUAGE` is used to provide an ordered list of
    languages preferred by applications if the principal one isn’t available. More
    information can be found by running `man locale`.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道`LANG`和`LANGUAGE`变量之间的区别是什么。简而言之，`LANG`是首选语言和编码设置的默认设置。它还在应用程序查找更具体的`LC_*`设置时提供默认值。`LANGUAGE`用于在主要语言不可用时，为应用程序提供一个按顺序排列的语言偏好列表。更多信息可以通过运行`man
    locale`来获取。
- en: Now you can build the image, and run it to see what’s changed.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以构建镜像，并运行它以查看发生了什么变化。
- en: Listing 4.21\. Building and running the `encoding` image
  id: totrans-723
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.21\. 构建`encoding`镜像并运行
- en: '[PRE63]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '***1*** **Builds the encoding Docker image**'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **构建编码Docker镜像**'
- en: '***2*** **Runs the built Docker image**'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **运行构建的Docker镜像**'
- en: '***3*** **The LANGUAGE variable is set in the environment**'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在环境中设置了LANGUAGE变量**'
- en: '***4*** **The LANG variable is set in the environment**'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **在环境中设置了LANG变量**'
- en: '**DISCUSSION**'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Like the previous time zone technique, this technique illustrates an issue that
    catches people out on a regular basis. Like many of the more irritating issues
    we come across, these don’t always make themselves obvious when the image is being
    built, which makes the time wasted debugging these issues very frustrating. For
    this reason, it’s worth keeping these settings in mind when supporting others
    who are using Docker images.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的时间区域技术一样，这个技术展示了人们经常遇到的一个问题。像许多我们遇到的更令人烦恼的问题一样，这些问题在构建镜像时并不总是显而易见，这使得调试这些问题所浪费的时间非常令人沮丧。因此，在支持使用Docker镜像的其他人时，值得记住这些设置。
- en: '|  |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Stepping through layers with the image-stepper**'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用image-stepper通过镜像层进行步骤**'
- en: If you’ve built an image that has a number of steps, you can often find yourself
    in the position of wanting to know where a particular file was introduced, or
    what state it was in at a particular point in the build. Combing through each
    image layer can be laborious, because you’ll have to determine the order of layers,
    retrieve each ID, and start each one up using that ID.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你构建了一个包含多个步骤的镜像，你可能会发现自己想要知道某个特定文件是在哪个步骤中引入的，或者它在构建的某个特定时刻处于什么状态。逐层检查每个镜像层可能会很费力，因为你需要确定层的顺序，检索每个ID，并使用该ID启动每一层。
- en: This technique shows you a one-liner that tags each layer of the build in order,
    meaning you only have to increment a number to work through the images and find
    out whatever it is you need to know.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技术展示了如何用一行命令按顺序标记构建的每一层，这意味着你只需要递增一个数字就可以遍历镜像并找出你需要知道的信息。
- en: '**PROBLEM**'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to easily refer to each step of your build.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望轻松地引用构建的每个步骤。
- en: '**SOLUTION**'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the docker-in-practice/image-stepper image to order the tags for your image.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 使用docker-in-practice/image-stepper镜像来为你的镜像排序标签。
- en: To illustrate this technique, we’ll first show you a script that achieves this
    result so you understand how it works. Then we’ll give you a constructed image
    to make achieving the result easier.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个技术，我们首先会展示一个实现这一结果的脚本，以便你理解它是如何工作的。然后，我们将提供一个构建的镜像，以便更容易地实现这一结果。
- en: Here’s a simple script that tags every layer in a given image (myimage) in the
    order of creation.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的脚本，它会按照创建顺序给给定镜像（myimage）中的每一层打上标签。
- en: The Dockerfile for myimage follows.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: myimage的Dockerfile如下。
- en: Listing 4.22\. Dockerfile for image with multiple layers
  id: totrans-743
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.22\. 具有多层镜像的Dockerfile
- en: '[PRE64]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1*** **Uses debian as a base image**'
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用debian作为基础镜像**'
- en: '***2*** **Creates 10 files in separate layers**'
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在单独的层中创建10个文件**'
- en: '***3*** **Runs a bespoke command that cats the first file**'
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **运行一个自定义命令来显示第一个文件**'
- en: This is a simple enough Dockerfile, but it’s one where it will be clear which
    stage you are at in the build.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的Dockerfile，但它清楚地表明了你在构建过程中的哪个阶段。
- en: Build this docker image with the following command.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令构建此Docker镜像。
- en: Listing 4.23\. Building the myimage image
  id: totrans-750
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.23\. 构建 myimage 镜像
- en: '[PRE65]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '***1*** **Builds the image with the quiet (-q) flag, tagging it as myimage**'
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用静默（-q）标志构建镜像，并标记为myimage**'
- en: '***2*** **The image identifier is the only output.**'
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **镜像标识符是唯一的输出。**'
- en: Once the image is built, you can run the following script.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像构建完成后，你可以运行以下脚本。
- en: Listing 4.24\. Tagging each layer of myimage in numerical order
  id: totrans-755
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.24\. 以数字顺序标记myimage的每一层
- en: '[PRE66]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '***1*** **Initializes the counter variable (x) to 1**'
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **初始化计数器变量（x）为1**'
- en: '***2*** **Runs a for loop to retrieve the history of the image**'
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **运行一个循环来检索镜像的历史记录**'
- en: '***3*** **Doesn’t consider the remotely built layers, which are marked as missing
    (see the note below)**'
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **不考虑远程构建的层，这些层标记为缺失（见下面的注释）**'
- en: '***4*** **Uses the tac utility to reverse the order of image IDs the docker
    history command outputs**'
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **使用tac实用程序来反转docker history命令输出的镜像ID顺序**'
- en: '***5*** **In each iteration of the loop, tags the image appropriately with
    the incrementing number**'
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **在循环的每次迭代中，使用递增的数字适当地标记镜像**'
- en: '***6*** **Increments the step counter**'
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **增加步骤计数器**'
- en: If you save the preceding file as tag.sh and run it, the image will be tagged
    in layer order.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将前面的文件保存为tag.sh并运行它，镜像将按层顺序标记。
- en: '|  |'
  id: totrans-764
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-765
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This tagging method technique will only work on images built locally. See the
    note in [technique 16](kindle_split_013.xhtml#ch03sb07) for more information.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 这种打标签的方法技术仅适用于本地构建的镜像。有关更多信息，请参阅[技术 16](kindle_split_013.xhtml#ch03sb07)中的注释。
- en: '|  |'
  id: totrans-767
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 4.25\. Tagging and showing the layers
  id: totrans-768
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.25\. 打标签和显示层
- en: '[PRE67]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '***1*** **Runs the script from [listing 4.24](#ch04ex24)**'
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **运行来自[列表 4.24](#ch04ex24)的脚本**'
- en: '***2*** **Runs a docker images command with a simple grep to see the tagged
    layers**'
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **运行带有简单grep的docker images命令，以查看打标签的层**'
- en: '***3*** **The steps to build the myimage image**'
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **构建myimage镜像的步骤**'
- en: '***4*** **The original (and older) base image has also been tagged as latest_step_1.**'
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **原始（较旧）的基础镜像也已标记为latest_step_1。**'
- en: Now that you’ve seen the principle, we’ll demonstrate how to dockerize this
    one-off script and make it work for the general case.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了原理，我们将演示如何将这个一次性脚本docker化，使其适用于通用情况。
- en: '|  |'
  id: totrans-775
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-776
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The code for this technique is available at [https://github.com/docker-in-practice/image-stepper](https://github.com/docker-in-practice/image-stepper).
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术的代码可在[https://github.com/docker-in-practice/image-stepper](https://github.com/docker-in-practice/image-stepper)找到。
- en: '|  |'
  id: totrans-778
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: First, turn the previous script into a script that can take arguments.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将之前的脚本转换成一个可以接受参数的脚本。
- en: Listing 4.26\. Generic tagging script for the image-stepper image
  id: totrans-780
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.26\. image-stepper镜像的通用打标签脚本
- en: '[PRE68]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***1*** **Defines a bash script that can take two arguments: the image name
    to process, and the tag you want to step up to**'
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **定义一个bash脚本，它可以接受两个参数：要处理的镜像名称和要升级到的标签**'
- en: '***2*** **The script from [listing 4.24](#ch04ex24), with the arguments substituted
    in**'
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将参数替换后的[列表 4.24](#ch04ex24)中的脚本**'
- en: You can then embed the script in [listing 4.26](#ch04ex26) into a Docker image
    that you place into a Dockerfile and run as the default `ENTRYPOINT`.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将[列表 4.26](#ch04ex26)中的脚本嵌入到一个Docker镜像中，并将其放置在Dockerfile中，作为默认的`ENTRYPOINT`运行。
- en: Listing 4.27\. Dockerfile for image-stepper image
  id: totrans-785
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.27\. image-stepper镜像的Dockerfile
- en: '[PRE69]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '***1*** **Uses Ubuntu as a base layer**'
  id: totrans-787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用Ubuntu作为基础层**'
- en: '***2*** **Installs docker.io to get the Docker client binary**'
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **安装docker.io以获取Docker客户端二进制文件**'
- en: '***3*** **Adds the script from [listing 4.26](#ch04ex26) to the image**'
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将[列表 4.26](#ch04ex26)中的脚本添加到镜像中**'
- en: '***4*** **Runs the image_stepper script by default**'
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **默认运行image_stepper脚本**'
- en: The Dockerfile in [listing 4.27](#ch04ex27) creates an image that runs the script
    in [listing 4.26](#ch04ex26). The command in [listing 4.28](#ch04ex28) runs this
    image, giving `myimage` as an argument.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4.27](#ch04ex27)中的Dockerfile创建了一个运行[列表 4.26](#ch04ex26)中脚本的镜像。在[列表 4.28](#ch04ex28)中的命令运行此镜像，并将`myimage`作为参数。'
- en: This image, when run against another Docker image built on your host, will then
    create the tags for each step, allowing you to easily look at the layers in order.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个镜像在你的主机上构建的另一个Docker镜像上运行时，将为每个步骤创建标签，让你可以轻松地按顺序查看层。
- en: The version of the client binary installed by the docker.io package must be
    compatible with the version of the Docker daemon on your host machine, typically
    meaning the client must not be newer.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 由docker.io包安装的客户端二进制版本必须与主机机器上Docker守护进程的版本兼容，通常意味着客户端不能比守护进程更新。
- en: Listing 4.28\. Running image-stepper against another image
  id: totrans-794
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.28\. 对另一个镜像运行image-stepper
- en: '[PRE70]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1*** **Runs the image-stepper image as a container, and removes the container
    when done**'
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **以容器形式运行image-stepper镜像，完成后删除容器**'
- en: '***2*** **Mounts the host’s docker socket, so you can use the Docker client
    installed in [listing 4.27](#ch04ex27)**'
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **挂载主机的docker套接字，这样你就可以使用[列表 4.27](#ch04ex27)中安装的Docker客户端**'
- en: '***3*** **Downloads the image-stepper image from the Docker Hub**'
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **从Docker Hub下载image-stepper镜像**'
- en: '***4*** **Tags the myimage created previously**'
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **为之前创建的myimage打标签**'
- en: '***5*** **The output of the docker run command**'
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **docker run命令的输出**'
- en: '***6*** **Runs docker images and greps out the images you’ve just tagged**'
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **运行docker images并grep出你刚刚标记的镜像**'
- en: '***7*** **The images are tagged.**'
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **镜像已打标签。**'
- en: '***8*** **Picks a step at random and lists the files in the root directory,
    grep-ing out the ones created in the Dockerfile from [listing 4.27](#ch04ex27)**'
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **随机选择一个步骤并列出根目录中的文件，grep出[列表 4.27](#ch04ex27)中的Dockerfile创建的文件**'
- en: '***9*** **The files shown are those created up to that step.**'
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** **显示的文件是到该步骤为止创建的文件。**'
- en: '|  |'
  id: totrans-805
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-806
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: On non-Linux OSs (such as Mac and Windows) you may need to specify the folder
    in which Docker runs in your Docker preferences as a file sharing setting.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 在非Linux操作系统（如Mac和Windows）上，你可能需要在Docker首选项中指定Docker运行的文件夹，作为文件共享设置。
- en: '|  |'
  id: totrans-808
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This technique is useful for seeing where a particular file was added within
    a build, or what state a file was in at a particular point in the build. When
    debugging a build, this can be invaluable!
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术有助于查看在构建过程中某个特定文件是如何被添加的，或者文件在构建的某个特定点处于什么状态。在调试构建时，这可能非常有价值！
- en: '**DISCUSSION**'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This technique is used in [technique 52](kindle_split_017.xhtml#ch07sb05) to
    demonstrate that a deleted secret is accessible within a layer within an image.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术用于[技术52](kindle_split_017.xhtml#ch07sb05)中，以演示已删除的秘密在镜像的层中是可访问的。
- en: '|  |'
  id: totrans-812
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-813
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Onbuild and golang**'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '**ONBUILD和golang**'
- en: The `ONBUILD` directive can cause a lot of confusion for new Docker users. This
    technique demonstrates its use in a real-world context by building and running
    a Go application with a two-line Dockerfile.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '`ONBUILD`指令可能会让新的Docker用户感到困惑。这个技术通过构建和运行一个带有两行Dockerfile的Go应用程序，在真实世界场景中展示了其用法。'
- en: '**PROBLEM**'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to reduce the steps in building an image required for an application.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望减少构建应用程序所需的镜像步骤。
- en: '**SOLUTION**'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the `ONBUILD` command to automate and encapsulate the building of an image.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ONBUILD`命令来自动化和封装镜像的构建。
- en: First you’ll run the process through, and then we’ll explain what’s going on.
    The example we’ll use is the outyet project, which is an example in the golang
    GitHub repository. All it does is set up a web service that returns a page telling
    you whether Go 1.4 is available yet.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将运行这个过程，然后我们将解释正在发生的事情。我们将使用的例子是outyet项目，这是golang GitHub仓库中的一个例子。它所做的只是设置一个返回页面的网络服务，告诉你Go
    1.4是否已经可用。
- en: Build the image as follows.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式构建镜像。
- en: Listing 4.29\. Building the outyet image
  id: totrans-822
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.29\. 构建outyet镜像
- en: '[PRE71]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '***1*** **Clones the Git repository**'
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **克隆Git仓库**'
- en: '***2*** **Navigates to the outyet folder**'
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **导航到outyet文件夹**'
- en: '***3*** **Builds the outyet image**'
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **构建outyet镜像**'
- en: Run a container from the resulting image, and retrieve the served web page.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 从生成的镜像运行容器，并检索提供的网页。
- en: Listing 4.30\. Running and validating the outyet image
  id: totrans-828
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.30\. 运行和验证outyet镜像
- en: '[PRE72]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '***1*** **The --publish flag tells Docker to publish the container’s port 8080
    on the external port 6060.**'
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **`--publish`标志告诉Docker将容器的端口8080发布到外部端口6060。**'
- en: '***2*** **The --name flag gives your container a predictable name to make it
    easier to work with.**'
  id: totrans-831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **`--name`标志为容器提供一个可预测的名称，以便更容易地与之交互。**'
- en: '***3*** **Runs the container in the background**'
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在后台运行容器**'
- en: '***4*** **Curls the output container’s port**'
  id: totrans-833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **卷曲输出容器的端口**'
- en: '***5*** **The webpage that the container serves**'
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **容器提供的网页**'
- en: That’s it—a simple application that returns a web page that tells you whether
    Go 1.4 is out yet or not.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——一个简单的应用程序，返回一个网页，告诉你Go 1.4是否已经发布。
- en: If you look around the cloned repository, you’ll see the Dockerfile is just
    two lines!
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你环顾克隆的仓库，你会看到Dockerfile只有两行！
- en: Listing 4.31\. The onyet Dockerfile
  id: totrans-837
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.31\. onyet Dockerfile
- en: '[PRE73]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '***1*** **Starts the build from the golang:onbuild image**'
  id: totrans-839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **从golang:onbuild镜像开始构建**'
- en: '***2*** **Exposes port 8080**'
  id: totrans-840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **暴露端口8080**'
- en: Confused yet? OK, it may make more sense when you look at the Dockerfile for
    the golang:onbuild image.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 还感到困惑吗？好吧，当你查看golang:onbuild镜像的Dockerfile时，这可能更有意义。
- en: Listing 4.32\. The golang:onbuild Dockerfile
  id: totrans-842
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.32\. golang:onbuild Dockerfile
- en: '[PRE74]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '***1*** **Uses the golang:1.7 image as a base**'
  id: totrans-844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用golang:1.7镜像作为基础**'
- en: '***2*** **Makes a folder to store the application in**'
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **创建一个文件夹来存储应用程序**'
- en: '***3*** **Moves into that folder**'
  id: totrans-846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **移动到那个文件夹**'
- en: '***4*** **Sets the resulting image’s command to call the go-wrapper to run
    the go app**'
  id: totrans-847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将结果镜像的命令设置为调用go-wrapper来运行go应用程序**'
- en: '***5*** **The first ONBUILD command copies the code in the context of the Dockerfile
    into the image.**'
  id: totrans-848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **第一个ONBUILD命令将Dockerfile上下文中的代码复制到镜像中。**'
- en: '***6*** **The second ONBUILD command downloads any dependencies, again using
    the go-wrapper command.**'
  id: totrans-849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **第二个ONBUILD命令使用go-wrapper命令下载任何依赖项。**'
- en: '***7*** **The third ONBUILD**'
  id: totrans-850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **第三个ONBUILD指令**'
- en: The golang:onbuild image defines what happens when the image is used in the
    `FROM` directive in any other Dockerfile. The result is that when a Dockerfile
    uses this image as a base, the `ONBUILD` commands will fire as soon as the `FROM`
    image is downloaded, and (if not overridden) the `CMD` will be run when the resulting
    image is run as a container.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: golang:onbuild镜像定义了当在其他Dockerfile的`FROM`指令中使用该镜像时会发生什么。结果是，当Dockerfile使用此镜像作为基础时，`ONBUILD`命令将在`FROM`镜像下载后立即触发，并且（如果未覆盖）当结果镜像作为容器运行时将运行`CMD`。
- en: Now the output of the `docker build` command in the next listing may make more
    sense.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 现在下面列表中`docker build`命令的输出可能更有意义。
- en: '[PRE75]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1*** **The FROM directive is run, and the golang:onbuild image is**'
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **执行FROM指令，并使用golang:onbuild镜像。**'
- en: '***2*** **The Docker build signals its intention to run the ONBUILD directives.**'
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **Docker构建发出运行ONBUILD指令的意图。**'
- en: '***3*** **The first ONBUILD directive copies the Go code in the Dockerfile’s
    context into the build.**'
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **执行第一个ONBUILD指令，将Dockerfile上下文中的Go代码复制到构建中。**'
- en: '***4*** **The second ONBUILD directive is fired, which downloads.**'
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **触发第二个ONBUILD指令，用于下载。**'
- en: '***5*** **The go-wrapper call triggers a shell call to go get.**'
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **go-wrapper调用触发对go get的shell调用。**'
- en: '***6*** **The third ONBUILD directive is fired, which installs the application.**'
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **执行第三个ONBUILD指令，该指令安装应用程序。**'
- en: '***7*** **The go-wrapper call triggers a shell call to go install.**'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **go-wrapper调用触发对go install的shell调用。**'
- en: '***8*** **The three containers built as a result of the ONBUILD command are
    removed.**'
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **由ONBUILD命令创建的三个容器被移除。**'
- en: '***9*** **The EXPOSE directive in the second line of the Dockerfile is run.**'
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** **Dockerfile的第二行中运行的EXPOSE指令。**'
- en: The result of this technique is that you have an easy way to build an image
    that only contains the code required to run it, and no more. Leaving the build
    tools lying around in the image not only makes it larger than it needs to be,
    but also increases the security attack surface of the running container.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的结果是，你有一个简单的方法来构建一个只包含运行它所需的代码的镜像，不再需要更多。在镜像中留下构建工具不仅使其比需要的大，还增加了运行容器的安全攻击面。
- en: '**DISCUSSION**'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Because Docker and Go are fashionable technologies currently often seen together,
    we’ve used this to demonstrate how `ONBUILD` can be used to build a Go binary.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker和Go是目前经常一起看到的流行技术，我们使用了这个例子来展示如何使用`ONBUILD`来构建Go二进制文件。
- en: Other examples of `ONBUILD` images exist. There are `node:onbuild` and `python:onbuild`
    images available on Docker Hub.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '`ONBUILD`镜像的其他示例存在。Docker Hub上有可用的`node:onbuild`和`python:onbuild`镜像。'
- en: It’s hoped that this might inspire you to construct your own `ONBUILD` image
    that could help your organization with common patterns of building. This standardization
    can help reduce impedance mismatch between different teams even further.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这能激发你构建自己的`ONBUILD`镜像，以帮助你的组织处理常见的构建模式。这种标准化可以帮助进一步减少不同团队之间的阻抗不匹配。
- en: '|  |'
  id: totrans-868
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-869
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: You can insert files from your local machine and from the internet into images.
  id: totrans-870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从你的本地机器和互联网上插入文件到镜像中。
- en: The cache is a crucial part of building images, but it can be a fickle friend
    and occasionally needs prompting to do what you want.
  id: totrans-871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存是构建镜像的关键部分，但它可能是一个反复无常的朋友，有时需要提示才能完成你想要的事情。
- en: You can “bust” the cache using build arguments or using the `ADD` directive,
    or you can ignore the cache completely with the `no-cache` option.
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用构建参数或使用`ADD`指令来“打破”缓存，或者你可以使用`no-cache`选项完全忽略缓存。
- en: The `ADD` directive is generally used to inject local files and folders into
    the built image.
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD`指令通常用于将本地文件和文件夹注入到构建的镜像中。'
- en: System configuration may still be relevant inside Docker, and image build time
    is a great time to do it.
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统配置在Docker内部可能仍然相关，而镜像构建时间是一个很好的进行配置的时间。
- en: You can debug your build process using the “image-stepper” technique ([technique
    27](#ch04sb09)), which tags each stage of the build for you.
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用“image-stepper”技术（[技术27](#ch04sb09)）来调试你的构建过程，该技术为你标记构建的每个阶段。
- en: The time zone setting is the most common “gotcha” when configuring containers,
    especially when you are a non-U.S. or multinational company.
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时区设置是在配置容器时最常见的“陷阱”，尤其是当你是一家非美国或跨国公司时。
- en: Images with `ONBUILD` are very easy to use, because you might not need to customize
    the build at all.
  id: totrans-877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`ONBUILD`的镜像非常容易使用，因为你可能根本不需要自定义构建。
- en: Chapter 5\. Running containers
  id: totrans-878
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第五章\. 运行容器
- en: '|  |'
  id: totrans-879
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Using GUI applications within Docker
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker中使用GUI应用程序
- en: Retrieving information about containers
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取容器信息
- en: The different ways you can terminate containers
  id: totrans-883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以终止容器的不同方式
- en: Starting containers on a remote machine
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在远程机器上启动容器
- en: Using and managing Docker volumes for persistent shared data
  id: totrans-885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用和管理Docker卷以持久共享数据
- en: 'Learning your first Docker patterns: the data and dev tools containers'
  id: totrans-886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习您的第一个Docker模式：数据和开发工具容器
- en: '|  |'
  id: totrans-887
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You can’t get very far without running containers when using Docker, and there’s
    a lot to understand if you want to use the full power they make available.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Docker时，如果不运行容器，您将无法走得很远，如果您想充分利用它们提供的功能，那么有很多东西需要理解。
- en: This chapter will look at some of the details involved in running containers,
    examine some concrete use cases, and provide a thorough treatment of the possibilities
    enabled by volumes along the way.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨运行容器的一些细节，检查一些具体用例，并详细阐述通过卷实现的可能性的处理。
- en: 5.1\. Running containers
  id: totrans-890
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1. 运行容器
- en: Although much of this book is about running containers, there are some practical
    techniques related to running containers on your host that may not be immediately
    obvious. We’ll look at how you can get GUI applications working, start a container
    on a remote machine, inspect the state of containers and their source images,
    shut down containers, manage Docker daemons on remote machines, and use a wildcard
    DNS service to make testing easier.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这本书的大部分内容都是关于运行容器的，但有一些与在您的宿主机上运行容器相关的实用技术可能并不立即明显。我们将探讨您如何使GUI应用程序工作，在远程机器上启动容器，检查容器的状态及其源镜像，关闭容器，管理远程机器上的Docker守护程序，以及使用通配符DNS服务使测试更容易。
- en: '|  |'
  id: totrans-892
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Running GUIs within Docker**'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '**在Docker中运行GUI**'
- en: You’ve already seen a GUI served from within a Docker container using a VNC
    server in [technique 19](kindle_split_013.xhtml#ch03sb10). That’s one way to view
    applications within your Docker container, and it’s self-contained, requiring
    only a VNC client to use.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了使用VNC服务器在[技术19](kindle_split_013.xhtml#ch03sb10)中从Docker容器中提供GUI的一种方式。这是查看Docker容器中应用程序的一种方法，它是自包含的，只需要一个VNC客户端即可使用。
- en: Fortunately there’s a more lightweight and well-integrated way to run GUIs on
    your desktop, but it requires more setup on your part. It mounts the directory
    on the host that manages communications with the X server, so that it’s accessible
    to the container.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种更轻量级且集成度更高的方式在您的桌面上运行GUI，但这需要您进行更多的设置。它将目录挂载到管理X服务器的宿主机上，以便容器可以访问。
- en: '**PROBLEM**'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to run GUIs in a container as though they were normal desktop apps.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在容器中运行GUI，就像它们是正常的桌面应用程序一样。
- en: '**SOLUTION**'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Create an image with your user credentials and the program, and bind mount your
    X server to it.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含您的用户凭证和程序的镜像，并将您的X服务器绑定挂载到它上。
- en: '[Figure 5.1](#ch05fig01) shows how the final setup will work.'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.1](#ch05fig01)显示了最终设置将如何工作。'
- en: Figure 5.1\. Communicating with the host’s X server
  id: totrans-901
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1. 与宿主机的X服务器通信
- en: '![](Images/05fig01_alt.jpg)'
  id: totrans-902
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig01_alt.jpg)'
- en: The container is linked to the host via the mount of the host’s /tmp/.X11 directory,
    and this is how the container can perform actions on the host’s desktop.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 容器通过宿主机`/tmp/.X11`目录的挂载与宿主机链接，这就是容器如何在宿主机的桌面上执行操作的方式。
- en: First make a new directory somewhere convenient, and determine your user and
    group IDs with the `id` command, as shown in the following listing.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在某个方便的地方创建一个新的目录，并使用`id`命令确定您的用户和组ID，如下所示。
- en: Listing 5.1\. Setting up a directory and finding out your user details
  id: totrans-905
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.1. 设置目录和获取用户详细信息
- en: '[PRE76]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '***1*** **Gets information about your user that you’ll need for the Dockerfile**'
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **获取您在Dockerfile中需要的关于您用户的信息**'
- en: '***2*** **Note your user ID (uid). In this case, it’s 1000.**'
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **注意您的用户ID（uid）。在这种情况下，它是1000。**'
- en: '***3*** **Note your group ID (gid). In this case, it’s 1000.**'
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **注意您的组ID（gid）。在这种情况下，它是1000。**'
- en: Now create a file called Dockerfile as follows.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为Dockerfile的文件，如下所示。
- en: Listing 5.2\. Firefox in a Dockerfile
  id: totrans-911
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.2. Dockerfile中的Firefox
- en: '[PRE77]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1*** **Installs Firefox as the GUI app. You can change this to whatever
    application(s) you may want.**'
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **安装Firefox作为GUI应用程序。您可以将此更改为您可能想要的任何应用程序。**'
- en: '***2*** **Adds your host’s group to the image. Replace GID with your group
    ID and USERNAME with your username.**'
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将宿主机的组添加到镜像中。用GID替换您的组ID，用USERNAME替换您的用户名。**'
- en: '***3*** **Adds your user account to the image. Replace USERNAME with your username,
    UID with your user ID, and GID with your group ID.**'
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将您的用户账户添加到镜像中。将 USERNAME 替换为您的用户名，UID 替换为您的用户 ID，GID 替换为您的组 ID。**'
- en: '***4*** **The image should run as the user you’ve created. Replace USERNAME
    with your username.**'
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **镜像应以您创建的用户身份运行。将 USERNAME 替换为您的用户名。**'
- en: '***5*** **Sets the HOME variable. Replace USERNAME with your username.**'
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **设置 HOME 变量。将 USERNAME 替换为您的用户名。**'
- en: '***6*** **Runs Firefox on startup by default**'
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **默认情况下在启动时运行 Firefox**'
- en: 'Now you can build from that Dockerfile and tag the result as “gui”:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从该 Dockerfile 构建，并将结果标记为“gui”：
- en: '[PRE78]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Run it as follows:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式运行：
- en: '[PRE79]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '***1*** **Bind mounts the X server directory to the container**'
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将 X 服务器目录绑定到容器**'
- en: '***2*** **Sets the DISPLAY variable in the container to be the same as that
    used in the host, so the program knows which X server to talk to**'
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **在容器中将 DISPLAY 变量设置为与主机上使用的相同，以便程序知道与哪个 X 服务器通信**'
- en: '***3*** **Gives the container the appropriate credentials**'
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **为容器提供适当的凭据**'
- en: You’ll see a Firefox window pop up!
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个 Firefox 窗口弹出！
- en: '**DISCUSSION**'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: You can use this technique to avoid mixing up your desktop work with your development
    work. With Firefox, for example, you might want to see how your application behaves
    with no web cache, bookmarks, or search history in a repeatable way for testing
    purposes. If you see error messages about being unable to open a display when
    trying to start the image and run Firefox, see [technique 65](kindle_split_019.xhtml#ch08sb06)
    for other ways to allow containers to start graphical applications that are displayed
    on the host.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此技术来避免混淆您的桌面工作和开发工作。例如，使用 Firefox，您可能想以可重复的方式查看您的应用程序在没有网络缓存、书签或搜索历史的情况下如何表现，以便进行测试。如果您在尝试启动镜像并运行
    Firefox 时看到无法打开显示的错误消息，请参阅[技术 65](kindle_split_019.xhtml#ch08sb06) 了解允许容器在主机上启动图形应用程序的其他方法。
- en: We understand that some people run almost all their applications inside Docker,
    including games! Although we don’t go quite that far, it’s useful to know that
    somebody has probably already encountered any problems you see.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解有些人几乎在 Docker 内运行所有应用程序，包括游戏！虽然我们没有做到那么极端，但了解有人可能已经遇到了您遇到的问题是有用的。
- en: '|  |'
  id: totrans-930
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-931
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Inspecting containers**'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查容器**'
- en: Although the Docker commands give you access to information about images and
    containers, sometimes you’ll want to know more about the internal metadata of
    these Docker objects.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Docker 命令让您可以访问有关镜像和容器的信息，但有时您可能想了解更多关于这些 Docker 对象内部元数据的信息。
- en: '**PROBLEM**'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to find out a container’s IP address.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 您想找出容器的 IP 地址。
- en: '**SOLUTION**'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the `docker inspect` command.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker inspect` 命令。
- en: The `docker inspect` command gives you access to Docker’s internal metadata
    in JSON format, including the IP address. This command produces a lot of output,
    so only a brief snippet of an image’s metadata is shown here.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker inspect` 命令以 JSON 格式提供 Docker 的内部元数据，包括 IP 地址。此命令会产生大量输出，因此这里只显示了镜像元数据的一个简短片段。'
- en: Listing 5.3\. Raw `inspect` output on an image
  id: totrans-939
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.3\. 镜像的原始 `inspect` 输出
- en: '[PRE80]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: You can inspect images and containers by name or ID. Obviously, their metadata
    will differ—for example, a container will have runtime fields such as “State”
    that the image will lack (an image has no state).
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过名称或 ID 检查镜像和容器。显然，它们的元数据将不同——例如，容器将具有“状态”等运行时字段，而镜像则没有（镜像没有状态）。
- en: In this case, you want to find out a container’s IP address on your host. To
    do this, you can use the `docker inspect` command with the `format` flag.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您想找出主机上的容器 IP 地址。为此，您可以使用带有 `format` 标志的 `docker inspect` 命令。
- en: Listing 5.4\. Determining a container’s IP address
  id: totrans-943
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4\. 确定容器的 IP 地址
- en: '[PRE81]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '***1*** **The docker inspect command**'
  id: totrans-945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **docker inspect 命令**'
- en: '***2*** **The format flag. This uses Go templates (not covered here) to format
    the output. Here, the IPAddress field is taken from the NetworkSettings field
    in the inspect output.**'
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **格式标志。这使用 Go 模板（此处未介绍）来格式化输出。在此，IPAddress 字段是从 inspect 输出的 NetworkSettings
    字段中获取的。**'
- en: '***3*** **The ID of the Docker item you want to inspect**'
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **您想要检查的 Docker 项目的 ID**'
- en: This technique can be useful for automation, as the interface is likely to be
    more stable than that of other Docker commands.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术对于自动化很有用，因为接口可能比其他 Docker 命令更稳定。
- en: The following command gives you the IP addresses of all running containers and
    pings them.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令提供了所有运行容器的 IP 地址并对其进行了ping操作。
- en: Listing 5.5\. Getting IP addresses of running containers and pinging each in
    turn
  id: totrans-950
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5\. 获取运行容器的IP地址并对每个进行ping
- en: '[PRE82]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '***1*** **Gets the container IDs of all running containers**'
  id: totrans-952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **获取所有运行容器的容器ID**'
- en: '***2*** **Runs the inspect command against all container IDs to get their IP
    addresses**'
  id: totrans-953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **针对所有容器ID运行inspect命令以获取它们的IP地址**'
- en: '***3*** **Takes each IP address and runs ping against each in turn**'
  id: totrans-954
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **逐个IP地址运行ping命令**'
- en: Note that because `ping` only accepts one IP address, we had to pass an additional
    argument to `xargs` telling it to run the command for each individual line.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为 `ping` 只接受一个IP地址，所以我们不得不向 `xargs` 传递一个额外的参数，告诉它为每行运行命令。
- en: '|  |'
  id: totrans-956
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-957
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you have no running containers, run this command to get one going: docker
    run -d ubuntu sleep 1000.'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有正在运行的容器，运行以下命令来启动一个：docker run -d ubuntu sleep 1000。
- en: '|  |'
  id: totrans-959
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**DISCUSSION**'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Inspecting containers and the method of jumping into containers in [technique
    47](kindle_split_016.xhtml#ch06sb08) are likely the two most important tools in
    your inventory for debugging why containers aren’t working. Inspect shines most
    when you believe you’ve started a container configured in a particular way but
    it behaves unexpectedly—your first step should be to inspect the container to
    verify that Docker agrees with your expectation of the port and volume mappings
    of the container, among other things.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 检查容器和在 [技术 47](kindle_split_016.xhtml#ch06sb08) 中跳入容器的方法可能是你调试容器为何不工作的两个最重要的工具。当你认为你已经以特定方式配置了容器但行为出乎意料时，Inspect
    最为出色——你的第一步应该是检查容器，以验证Docker是否同意你对端口和卷映射的预期，以及其他事项。
- en: '|  |'
  id: totrans-962
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-963
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Cleanly killing containers**'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: '**干净地杀死容器**'
- en: If the state of a container is important to you when it terminates, you may
    want to understand the distinction between `docker kill` and `docker stop`. This
    distinction can also be important if you need your applications to close gracefully
    in order to save data.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器终止时的状态对你很重要，你可能想了解 `docker kill` 和 `docker stop` 之间的区别。如果你需要应用程序优雅地关闭以保存数据，这个区别也可能很重要。
- en: '**PROBLEM**'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to cleanly terminate a container.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要干净地终止一个容器。
- en: '**SOLUTION**'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use `docker stop` rather than `docker kill` to cleanly terminate the container.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker stop` 而不是 `docker kill` 来干净地终止容器。
- en: The crucial point to understand is that `docker kill` doesn’t behave in the
    same way as the standard command-line `kill` program.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的关键点是 `docker kill` 的行为与标准的命令行 `kill` 程序不同。
- en: The `kill` program works by sending a `TERM` (a.k.a. signal value 15) signal
    to the process specified, unless directed otherwise. This signal indicates to
    the program that it should terminate, but it doesn’t force the program. Most programs
    will perform some kind of cleanup when this signal is handled, but the program
    can do what it likes—including ignoring the signal.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '`kill` 程序通过向指定的进程发送 `TERM` 信号（即信号值 15），除非有其他指示。此信号指示程序应该终止，但它不会强制程序。大多数程序在处理此信号时会执行某种类型的清理，但程序可以按自己的意愿行事——包括忽略信号。'
- en: A `KILL` signal (a.k.a. signal value 9), by contrast, forces the specified program
    to terminate.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，`KILL` 信号（即信号值 9）强制指定的程序终止。
- en: Confusingly, `docker kill` uses a `KILL` signal on the running process, giving
    the processes within it no chance to handle the termination. This means that stray
    files, such as files containing running process IDs, may be left in the filesystem.
    Depending on the application’s ability to manage state, this may or may not cause
    problems for you if you start up the container again.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 令人困惑的是，`docker kill` 在运行进程上使用 `KILL` 信号，给其中的进程没有机会处理终止。这意味着可能会在文件系统中留下一些散乱的文件，例如包含运行进程ID的文件。根据应用程序管理状态的能力，这可能会或可能不会在你再次启动容器时给你带来问题。
- en: Even more confusingly, the `docker stop` command acts like the standard `kill`
    command, sending a `TERM` signal (see [table 5.1](#ch05table01)), except it will
    wait for 10 seconds and then send the `KILL` signal if the container hasn’t stopped.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 更令人困惑的是，`docker stop` 命令的行为类似于标准的 `kill` 命令，发送 `TERM` 信号（见 [表 5.1](#ch05table01)），但它将等待10秒钟，如果容器没有停止，则发送
    `KILL` 信号。
- en: Table 5.1\. Stopping and killing
  id: totrans-975
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.1\. 停止和杀死
- en: '| **Command** | **Default signal** | **Default signal value** |'
  id: totrans-976
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **默认信号** | **默认信号值** |'
- en: '| --- | --- | --- |'
  id: totrans-977
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| kill | TERM | 15 |'
  id: totrans-978
  prefs: []
  type: TYPE_TB
  zh: '| kill | TERM | 15 |'
- en: '| docker kill | KILL | 9 |'
  id: totrans-979
  prefs: []
  type: TYPE_TB
  zh: '| docker kill | KILL | 9 |'
- en: '| docker stop | TERM | 15 |'
  id: totrans-980
  prefs: []
  type: TYPE_TB
  zh: '| docker stop | TERM | 15 |'
- en: In summary, don’t use `docker kill` as you’d use `kill`. You’re probably best
    off getting into the habit of using `docker stop`.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，不要像使用`kill`命令那样使用`docker kill`。你最好养成使用`docker stop`的习惯。
- en: '**DISCUSSION**'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Although we recommend `docker stop` for everyday use, `docker kill` has some
    additional configurability that allows you to choose the signal sent to the container
    via the `--signal` argument. As discussed, the default is `KILL`, but you can
    also send `TERM` or one of the less common Unix signals.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们推荐在日常使用中使用`docker stop`，但`docker kill`有一些额外的可配置性，允许你通过`--signal`参数选择发送给容器的信号。如前所述，默认是`KILL`，但你也可以发送`TERM`或一些不太常见的Unix信号。
- en: If you’re writing your own application that you’ll start in a container, the
    `USR1` signal may be of interest. This is explicitly reserved for applications
    to do whatever they want with it, and in some places it’s used as an indication
    to print out progress information, or the equivalent—you could use it for whatever
    you see fit. `HUP` is another popular one, conventionally interpreted by servers
    and other long-running applications to trigger the reloading of configuration
    files and a “soft” restart. Of course, make sure you check the documentation of
    the application you’re running before you start sending random signals to it!
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写自己的应用程序，你将在容器中启动它，那么`USR1`信号可能会引起你的兴趣。这个信号是专门为应用程序保留的，以便它们可以随意使用它，在某些地方它被用作打印进度信息或等效信息的指示——你可以用它来做任何你觉得合适的事情。"HUP"是另一个流行的信号，传统上被服务器和其他长时间运行的应用程序解释为触发配置文件的重新加载和“软”重启。当然，在开始向应用程序发送随机信号之前，确保检查你正在运行的应用程序的文档！
- en: '|  |'
  id: totrans-985
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-986
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using Docker Machine to provision Docker hosts**'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Docker Machine来配置Docker主机**'
- en: Setting up Docker on your local machine was probably not too difficult—there’s
    a script you can use for convenience, or you can use a few commands to add the
    appropriate sources for your package manager. But this can get tedious when you’re
    trying to manage Docker installs on other hosts.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的本地机器上设置Docker可能并不太难——有一个方便的脚本可以使用，或者你可以使用几个命令来为你的包管理器添加适当的源。但是当你试图在其他主机上管理Docker安装时，这可能会变得很繁琐。
- en: '**PROBLEM**'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to spin up containers on a separate Docker host from your machine.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在机器上启动一个与你的机器分开的Docker主机上的容器。
- en: '**SOLUTION**'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Docker Machine is the official solution for managing Docker installs on remote
    machines.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Machine是管理远程机器上Docker安装的官方解决方案。
- en: 'This technique will be useful if you need to run Docker containers on multiple
    external hosts. You may want this for a number of reasons: to test networking
    between Docker containers by provisioning a VM to run within your own physical
    host; to provision containers on a more powerful machine through a VPS provider;
    to risk trashing a host with some kind of crazy experiment; to have the choice
    of running on multiple cloud providers. Whatever the reason, Docker Machine is
    probably the answer for you. It’s also the gateway to more sophisticated orchestration
    tools like Docker Swarm.'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在多个外部主机上运行Docker容器，这项技术将非常有用。你可能出于许多原因想要这样做：通过在你的物理主机内配置一个虚拟机来测试Docker容器之间的网络；通过VPS提供商在更强大的机器上配置容器；进行某种疯狂实验以冒主机损坏的风险；在多个云提供商之间进行选择。无论出于什么原因，Docker
    Machine可能正是你所需要的答案。它也是进入更复杂的编排工具（如Docker Swarm）的门户。
- en: '**What Docker Machine is**'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是Docker Machine**'
- en: 'Docker Machine is mainly a convenience program. It wraps a lot of potentially
    tortuous instructions around provisioning external hosts and turns them into a
    few easy-to-use commands. If you’re familiar with Vagrant, it has a similar feel:
    provisioning and managing other machine environments is made simpler with a consistent
    interface. If you cast your mind back to our architecture overview in [chapter
    2](kindle_split_011.xhtml#ch02), one way of viewing Docker Machine is to imagine
    that it’s facilitating the management of different Docker daemons from one client
    (see [figure 5.2](#ch05fig02)).'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Machine主要是一个方便的程序。它将配置外部主机的大量潜在复杂的指令包装起来，并将它们转换成几个易于使用的命令。如果你熟悉Vagrant，它有类似的感觉：通过一致的界面简化了其他机器环境的配置和管理。如果你回想起我们在[第2章](kindle_split_011.xhtml#ch02)中的架构概述，看待Docker
    Machine的一种方式是想象它正在帮助管理来自一个客户端的不同Docker守护进程（参见[图5.2](#ch05fig02)）。
- en: Figure 5.2\. Docker Machine as a client of external hosts
  id: totrans-996
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.2\. Docker Machine作为外部主机的客户端
- en: '![](Images/05fig02.jpg)'
  id: totrans-997
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig02.jpg)'
- en: 'The list of Docker host providers in [figure 5.2](#ch05fig02) isn’t exhaustive,
    and it’s likely to grow. At the time of writing, the following drivers are available,
    which allow you to provision the given host provider:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.2](#ch05fig02) 中 Docker 主机提供商的列表并不全面，并且可能会增长。在撰写本文时，以下驱动程序可用，允许您配置给定的主机提供商：'
- en: Amazon Web Services
  id: totrans-999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon Web Services
- en: DigitalOcean
  id: totrans-1000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DigitalOcean
- en: Google Compute Engine
  id: totrans-1001
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Compute Engine
- en: IBM SoftLayer
  id: totrans-1002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IBM SoftLayer
- en: Microsoft Azure
  id: totrans-1003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Azure
- en: Microsoft Hyper-V
  id: totrans-1004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Hyper-V
- en: OpenStack
  id: totrans-1005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenStack
- en: Oracle VirtualBox
  id: totrans-1006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle VirtualBox
- en: Rackspace
  id: totrans-1007
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rackspace
- en: VMware Fusion
  id: totrans-1008
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VMware Fusion
- en: VMware vCloud Air
  id: totrans-1009
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VMware vCloud Air
- en: VMware vSphere
  id: totrans-1010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VMware vSphere
- en: The options that must be specified to provision a machine will vary greatly
    depending on the functionality provided by the driver. At one end, provisioning
    an Oracle VirtualBox VM on your machine has only 3 flags available to `create`,
    compared with OpenStack’s 17.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 必须指定的选项将根据驱动程序提供的功能有很大差异。在一端，在你的机器上配置 Oracle VirtualBox VM 只提供了 3 个用于 `create`
    的标志，而与 OpenStack 的 17 个相比。
- en: '|  |'
  id: totrans-1012
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1013
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: It’s worth clarifying that Docker Machine is not any kind of clustering solution
    for Docker. Other tools, such as Docker Swarm, fulfill that function, and we’ll
    look at them later.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 值得澄清的是，Docker Machine 并不是 Docker 的任何类型的集群解决方案。其他工具，如 Docker Swarm，履行这一功能，我们将在后面讨论。
- en: '|  |'
  id: totrans-1015
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Installation**'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装**'
- en: 'Installation involves a straightforward binary. Download links and installation
    instructions for different architectures are available here: [https://github.com/docker/machine/releases](https://github.com/docker/machine/releases).'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 安装涉及一个简单的二进制文件。不同架构的下载链接和安装说明可在此处找到：[https://github.com/docker/machine/releases](https://github.com/docker/machine/releases)。
- en: '|  |'
  id: totrans-1018
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1019
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You may want to move the binary to a standard location, like /usr/bin, and ensure
    it’s renamed or symlinked to `docker-machine` before continuing, as the downloaded
    file may have a longer name suffixed with the binary’s architecture.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望将二进制文件移动到标准位置，如 /usr/bin，并在继续之前确保将其重命名或创建到 `docker-machine` 的符号链接，因为下载的文件可能具有较长的名称，后缀为二进制文件的架构。
- en: '|  |'
  id: totrans-1021
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using Docker Machine**'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 Docker Machine**'
- en: To demonstrate Docker Machine’s use, you can start by creating a VM with a Docker
    daemon on it that you can work with.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 Docker Machine 的使用，您可以首先创建一个带有 Docker 守护进程的 VM，您可以在其上工作。
- en: '|  |'
  id: totrans-1024
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1025
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll need to have Oracle’s VirtualBox installed for this to work. It’s widely
    available in most package managers.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此操作生效，您需要安装 Oracle 的 VirtualBox。它在大多数包管理器中广泛可用。
- en: '|  |'
  id: totrans-1027
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[PRE83]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '***1*** **Use docker-machine’s create subcommand to create a new host and specify
    its type with the --driver flag. The host has been named `host1`.**'
  id: totrans-1029
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用 docker-machine 的 create 子命令创建一个新的主机，并使用 --driver 标志指定其类型。该主机已被命名为
    `host1`。**'
- en: '***2*** **Your machine is now created.**'
  id: totrans-1030
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **您的机器现在已创建。**'
- en: '***3*** **Run this command to set the DOCKER_HOST environment variable, which
    sets the default host that Docker commands will be run on**'
  id: totrans-1031
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **运行此命令以设置 DOCKER_HOST 环境变量，该变量设置 Docker 命令将运行的默认主机**'
- en: 'Vagrant users will feel right at home here. By running these commands, you’ve
    created a machine that you can now manage Docker on. If you follow the instructions
    given in the output, you can SSH directly to the new VM:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant 用户在这里会感到非常自在。通过运行这些命令，您已创建了一个可以现在管理 Docker 的机器。如果您遵循输出中给出的说明，可以直接 SSH
    到新的 VM：
- en: '[PRE84]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '***1*** **The $() takes the output of the docker-machine env command and applies
    it to your environment. docker-machine env outputs a set of commands that you
    can use to set the default host for Docker commands.**'
  id: totrans-1034
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **$() 将 docker-machine env 命令的输出应用于您的环境。docker-machine env 输出一组命令，您可以使用这些命令来设置
    Docker 命令的默认主机。**'
- en: '***2*** **The environment variable names are all prefixed with DOCKER_.**'
  id: totrans-1035
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **环境变量名称都以前缀 DOCKER_ 开头。**'
- en: '***3*** **The DOCKER_HOST variable is the endpoint of the Docker daemon on
    the VM.**'
  id: totrans-1036
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **DOCKER_HOST 变量是 VM 上 Docker 守护进程的端点。**'
- en: '***4*** **These variables handle the security side of connections to the new
    host.**'
  id: totrans-1037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **这些变量处理与新主机连接的安全性方面。**'
- en: '***5*** **The docker command is now pointed at the VM host you’ve created,
    not at your previously used host machine. You’ve created no containers on the
    new VM, so there’s no output.**'
  id: totrans-1038
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **docker 命令现在指向您创建的 VM 主机，而不是之前使用的宿主机。您在新 VM 上没有创建任何容器，因此没有输出。**'
- en: '***6*** **The ssh subcommand will take you directly to the new VM itself.**'
  id: totrans-1039
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **ssh 子命令将直接带您到新的 VM 本身。**'
- en: '**Managing hosts**'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: '**管理主机**'
- en: Managing multiple Docker hosts from one client machine can make it difficult
    to track what’s going on. Docker Machine comes with various management commands
    to make this simpler, as shown in [table 5.2](#ch05table02).
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个客户端机器管理多个 Docker 宿主机可能会使跟踪发生的事情变得困难。Docker Machine 提供了各种管理命令来简化这个过程，如 [表
    5.2](#ch05table02) 所示。
- en: Table 5.2\. List of docker-machine commands
  id: totrans-1042
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.2\. Docker-machine 命令列表
- en: '| **Subcommand** | **Action** |'
  id: totrans-1043
  prefs: []
  type: TYPE_TB
  zh: '| **子命令** | **操作** |'
- en: '| --- | --- |'
  id: totrans-1044
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| create | Creates a new machine |'
  id: totrans-1045
  prefs: []
  type: TYPE_TB
  zh: '| create | 创建新的机器 |'
- en: '| ls | Lists the Docker host machines |'
  id: totrans-1046
  prefs: []
  type: TYPE_TB
  zh: '| ls | 列出 Docker 宿主机 |'
- en: '| stop | Stops the machine |'
  id: totrans-1047
  prefs: []
  type: TYPE_TB
  zh: '| stop | 停止机器 |'
- en: '| start | Starts a machine |'
  id: totrans-1048
  prefs: []
  type: TYPE_TB
  zh: '| start | 启动机器 |'
- en: '| restart | Stops and starts a machine |'
  id: totrans-1049
  prefs: []
  type: TYPE_TB
  zh: '| restart | 停止并启动机器 |'
- en: '| rm | Destroys a machine |'
  id: totrans-1050
  prefs: []
  type: TYPE_TB
  zh: '| rm | 销毁机器 |'
- en: '| kill | Kills a machine off |'
  id: totrans-1051
  prefs: []
  type: TYPE_TB
  zh: '| kill | 关闭机器 |'
- en: '| inspect | Returns a JSON representation of the machine’s metadata |'
  id: totrans-1052
  prefs: []
  type: TYPE_TB
  zh: '| inspect | 返回机器元数据的 JSON 表示形式 |'
- en: '| config | Returns the configuration required to connect to the machine |'
  id: totrans-1053
  prefs: []
  type: TYPE_TB
  zh: '| config | 返回连接到机器所需的配置 |'
- en: '| ip | Returns the IP address of the machine |'
  id: totrans-1054
  prefs: []
  type: TYPE_TB
  zh: '| ip | 返回机器的 IP 地址 |'
- en: '| url | Returns a URL for the Docker daemon on the machine |'
  id: totrans-1055
  prefs: []
  type: TYPE_TB
  zh: '| url | 返回机器上 Docker 守护进程的 URL |'
- en: '| upgrade | Upgrades the Docker version on the host to the latest |'
  id: totrans-1056
  prefs: []
  type: TYPE_TB
  zh: '| upgrade | 将宿主机上的 Docker 版本升级到最新版本 |'
- en: 'The following example lists two machines. The active machine is listed with
    an asterisk, and it has a state associated with it, analogous to the state of
    containers or processes:'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例列出了两个机器。活动机器带有星号标记，并且与它关联有一个状态，类似于容器或进程的状态：
- en: '[PRE85]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '|  |'
  id: totrans-1059
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1060
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: You may be wondering how to switch back to your original host machine Docker
    instance. At the time of writing we haven’t found a simple way to do this. You
    can either `docker-machine rm` all the machines, or if that’s not an option you
    can manually unset the environment variables previously set with `unset DOCKER_HOST
    DOCKER_TLS_VERIFY DOCKER_CERT_PATH`.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道如何切换回原始宿主机 Docker 实例。在撰写本文时，我们还没有找到一种简单的方法来做这件事。你可以选择使用 `docker-machine
    rm` 删除所有机器，或者如果这不是一个选项，你可以手动取消之前使用 `unset DOCKER_HOST DOCKER_TLS_VERIFY DOCKER_CERT_PATH`
    设置的环境变量。
- en: '|  |'
  id: totrans-1062
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**DISCUSSION**'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: You can look at this as turning machines into processes, much like Docker itself
    can be seen as turning environments into processes.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这看作是将机器转化为进程，就像 Docker 本身可以将环境转化为进程一样。
- en: It may be tempting to use a Docker Machine setup to manually manage containers
    across multiple hosts, but if you find yourself manually taking down containers,
    rebuilding them, and starting them back up again on code changes, we encourage
    you to look at [part 4](kindle_split_022.xhtml#part04) of this book. Tedious tasks
    like this can be done by computers perfectly well. [Technique 87](kindle_split_024.xhtml#ch12sb02)
    covers the official solution from Docker Inc. for creating an automatic cluster
    of containers. [Technique 84](kindle_split_023.xhtml#ch11sb04) may be appealing
    if you like the idea of the unified view of a cluster, but also prefer to retain
    ultimate control over where your containers end up running.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker Machine 设置手动管理多个宿主机上的容器可能很有吸引力，但如果你在代码更改时发现需要手动关闭容器、重新构建它们并重新启动，我们鼓励你查看本书的
    [第 4 部分](kindle_split_022.xhtml#part04)。这类繁琐的任务完全可以由计算机完美完成。[技术 87](kindle_split_024.xhtml#ch12sb02)
    涵盖了 Docker Inc. 提供的官方解决方案，用于创建容器的自动集群。[技术 84](kindle_split_023.xhtml#ch11sb04)
    如果你喜欢集群的统一视图，但又希望保留对容器最终运行位置的完全控制，可能很有吸引力。
- en: '|  |'
  id: totrans-1066
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1067
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Wildcard DNS**'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '**通配符 DNS**'
- en: When working with Docker, it’s very common to have many containers running that
    need to refer to a central or external service. When testing or developing such
    systems, it’s normal to use a static IP address for these services. But for many
    Docker-based systems, such as OpenShift, an IP address isn’t sufficient. Such
    applications demand that there’s a DNS lookup.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Docker 时，拥有许多需要引用中心或外部服务的运行容器是非常常见的。在测试或开发此类系统时，通常使用静态 IP 地址为这些服务。但对于许多基于
    Docker 的系统，如 OpenShift，IP 地址是不够的。这类应用程序要求存在 DNS 查询。
- en: The usual solution to this is to edit your /etc/hosts file on the hosts you’re
    running your services on. But this isn’t always possible. For example, you might
    not have access to edit the file. Neither is it always practical. You might have
    too many hosts to maintain, or other bespoke DNS lookup caches might get in the
    way.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的通常方法是编辑你在其上运行服务的宿主机的 /etc/hosts 文件。但这并不总是可能的。例如，你可能没有权限编辑该文件。这也不总是实用的。你可能需要维护太多的宿主机，或者其他的定制
    DNS 查询缓存可能会造成干扰。
- en: In these cases, there’s a solution that uses “real” DNS servers.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，有一个使用“真实”DNS服务器的解决方案。
- en: '**PROBLEM**'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You need a DNS-resolvable URL for a specific IP address.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个可解析的DNS URL来指定一个IP地址。
- en: '**SOLUTION**'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the NIP.IO web service to resolve an IP address to a DNS-resolvable URL
    without any DNS setup.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NIP.IO网络服务，无需任何DNS设置，将IP地址解析为可解析的DNS URL。
- en: This one is really simple. NIP.IO is a web-based service that turns an IP address
    into a URL automatically for you. You just need to replace the “IP” section of
    the URL “[http://IP.nip.io](http://IP.nip.io)” with your desired IP address.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。NIP.IO是一个基于网络的在线服务，可以自动将IP地址转换为URL。你只需将URL中的“IP”部分“[http://IP.nip.io](http://IP.nip.io)”替换为你想要的IP地址即可。
- en: Let’s say the IP address you want a URL to resolve to is “10.0.0.1”. Your URL
    could look like this,
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要解析的URL指向的IP地址是“10.0.0.1”。你的URL可能看起来像这样，
- en: '[http://myappname.10.0.0.1.nip.io](http://myappname.10.0.0.1.nip.io)'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://myappname.10.0.0.1.nip.io](http://myappname.10.0.0.1.nip.io)'
- en: where `myappname` refers to your preferred name for your application, `10.0.0.1`
    refers to the IP address you want the URL to resolve to, and `nip.io` is the “real”
    domain on the internet that manages this DNS lookup service.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`myappname`指的是你为应用程序选择的名称，`10.0.0.1`指的是你希望URL解析到的IP地址，而`nip.io`是互联网上管理此DNS查找服务的“真实”域名。
- en: 'The `myappname.` part is optional, so this URL would resolve to the same IP
    address:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: '`myappname.`部分是可选的，因此这个URL解析到的IP地址相同：'
- en: '[http://10.0.0.1.nip.io](http://10.0.0.1.nip.io)'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://10.0.0.1.nip.io](http://10.0.0.1.nip.io)'
- en: '**DISCUSSION**'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This technique is handy in all sorts of contexts, not just when using Docker-based
    services.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在各种环境中都很有用，而不仅仅是使用基于Docker的服务。
- en: It should be obvious that this technique isn’t suitable for production or proper
    UAT environments, because it submits DNS requests to a third party and reveals
    information about your internal IP address layout. But it can be a very handy
    tool for development work.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种技术不适合生产或正式的UAT环境，因为它向第三方提交DNS请求，并揭示了有关你内部IP地址布局的信息。但它在开发工作中可以是一个非常实用的工具。
- en: If you’re using this service with HTTPS, make sure that the URL (or a suitable
    wildcard) is baked into the certificate you use.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用HTTPS服务，请确保你使用的URL（或一个合适的通配符）已经嵌入到你所使用的证书中。
- en: '|  |'
  id: totrans-1086
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 5.2\. Volumes—a persistent problem
  id: totrans-1087
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2. 卷——一个持续的问题
- en: Containers are a powerful concept, but sometimes not everything you want to
    access is ready to be encapsulated. You may have a reference Oracle database stored
    on a large cluster that you want to connect to for testing. Or maybe you have
    a large legacy server already set up with binaries that can’t easily be reproduced.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是一个强大的概念，但有时你想要访问的东西并不总是准备好被封装。你可能有一个存储在大型集群上的引用Oracle数据库，你想要连接到它进行测试。或者，你可能有一个已经设置好的大型遗留服务器，上面有无法轻易复制的二进制文件。
- en: 'When you begin working with Docker, most of the things you’ll want to access
    will likely be data and programs external to your container. We’ll take you from
    the straightforward mounting of files from your host to more sophisticated container
    patterns: the data container and the dev tools container. We’ll also demonstrate
    a pragmatic favorite of ours for remote mounting across a network that requires
    only an SSH connection to work, and we’ll look at a means of sharing data with
    other users via the BitTorrent protocol.'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始使用Docker时，你想要访问的大部分内容可能都是容器外部的数据和程序。我们将带你从从主机简单挂载文件到更复杂的容器模式：数据容器和开发工具容器。我们还将展示我们偏爱的远程网络挂载方法，这只需要SSH连接即可工作，我们还将探讨通过BitTorrent协议与其他用户共享数据的方法。
- en: Volumes are a core part of Docker, and the issue of external data reference
    is yet another fast-changing area of the Docker ecosystem.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 卷是Docker的核心部分，外部数据引用的问题也是Docker生态系统快速变化的另一个领域。
- en: '|  |'
  id: totrans-1091
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Docker volumes: Problems of persistence**'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker卷：持久性问题**'
- en: Much of the power of containers comes from the fact that they encapsulate as
    much of the state of the environment’s filesystem as is useful.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的强大之处很大程度上源于它们封装了环境文件系统的大部分状态，这对于有用。
- en: Sometimes, though, you don’t want to put files into a container. You might have
    some large files that you want to share across containers or manage separately.
    The classic example is a large centralized database that you want your container
    to access, but you also want other (perhaps more traditional) clients to access
    alongside your newfangled containers.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能不想将文件放入容器中。你可能有一些大文件想要在容器之间共享或单独管理。一个经典的例子是你想要容器访问的大型集中式数据库，但你也不想其他（可能更传统的）客户端与你的新式容器一起访问。
- en: The solution is *volumes*, Docker’s mechanism for managing files outside the
    life-cycle of the container. Although this goes against the philosophy of containers
    being “deployed anywhere” (you won’t be able to deploy your database-dependent
    container where there’s no compatible database available to mount, for example),
    it’s a useful feature for real-world Docker use.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是*卷*，这是Docker管理容器生命周期之外文件的一种机制。尽管这与容器“部署在任何地方”的哲学相悖（例如，你无法在没有兼容数据库可供挂载的地方部署依赖于数据库的容器），但在现实世界的Docker使用中，这是一个有用的功能。
- en: '**PROBLEM**'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to access files on the host from within a container.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在容器内访问主机上的文件。
- en: '**SOLUTION**'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use Docker’s volume flag to access host files from within the container. [Figure
    5.3](#ch05fig03) illustrates the use of a volume flag to interact with the host’s
    filesystem.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker的卷标志从容器内访问主机文件。[图5.3](#ch05fig03)说明了使用卷标志与主机文件系统交互。
- en: Figure 5.3\. A volume inside a container
  id: totrans-1100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3\. 容器内的卷
- en: '![](Images/05fig03_alt.jpg)'
  id: totrans-1101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/05fig03_alt.jpg)'
- en: The following command shows the host’s /var/db/tables directory being mounted
    on /var/data1, and it could be run to start the container in [figure 5.3](#ch05fig03).
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令显示了主机上的 `/var/db/tables` 目录被挂载到 `/var/data1`，并且可以运行以启动容器，如[图5.3](#ch05fig03)所示。
- en: '[PRE86]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `-v` flag (`--volume` in longhand) indicates that a volume external to the
    container is required. The subsequent argument gives the volume specification
    in the form of two directories separated by a colon, instructing Docker to map
    the external /var/ db/tables directory to the container’s /var/data1 directory.
    Both the external and container directories will be created if they don’t exist.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v` 标志（长格式为 `--volume`）表示需要外部容器卷。随后的参数以冒号分隔的两个目录的形式给出卷规范，指示Docker将外部 `/var/db/tables`
    目录映射到容器的 `/var/data1` 目录。如果这两个目录不存在，它们将被创建。'
- en: Beware of mapping over existing directories. The container’s directory will
    be mapped even if it already exists in the image. This means that the directory
    you’re mapping to within the container will effectively disappear. Fun things
    happen if you try to map a key directory! Try mounting an empty directory over
    /bin, for example.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 警惕覆盖现有目录。即使目录已经在镜像中存在，容器的目录也会被映射。这意味着你映射到容器内部的目录将实际上消失。如果你尝试映射一个关键目录，会发生一些有趣的事情！例如，尝试将空目录挂载到
    `/bin` 上。
- en: Also note that volumes are assumed not to persist in Dockerfiles. If you add
    a volume and then make changes to that folder within a Dockerfile, the changes
    won’t be persisted to the resulting image.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在Dockerfile中，假设卷不会持久化。如果你在Dockerfile中添加了一个卷，然后对该文件夹进行了更改，这些更改不会持久化到生成的镜像中。
- en: '|  |'
  id: totrans-1107
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-1108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: You may run into difficulties if your host runs SELinux. If SELinux policy is
    enforced, the container may not be able to write to the /var/db/tables directory.
    You’ll see a “permission denied” error. If you need to work around this, you’ll
    have to talk to your sysadmin (if you have one) or switch off SELinux (for development
    purposes only). See [technique 113](kindle_split_029.xhtml#ch16sb06) for more
    on SELinux.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的主机运行SELinux，你可能会遇到困难。如果强制执行SELinux策略，容器可能无法写入 `/var/db/tables` 目录。你会看到一个“权限被拒绝”的错误。如果你需要解决这个问题，你将不得不与你的系统管理员（如果你有的话）交谈，或者关闭SELinux（仅限开发目的）。有关SELinux的更多信息，请参阅[技术113](kindle_split_029.xhtml#ch16sb06)。
- en: '|  |'
  id: totrans-1110
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**DISCUSSION**'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Exposing files from the host in a container is one of the most common operations
    we perform when experimenting with individual containers—containers are intended
    to be ephemeral, and it’s all too easy to blow one away after spending a significant
    amount of time working on some files within one. Better to be confident that the
    files are safe, come what may.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 从主机在容器中公开文件是我们进行单个容器实验时最常执行的操作之一——容器旨在是短暂的，在某个文件上花费大量时间工作后，很容易将其删除。最好确保文件安全，无论发生什么情况。
- en: There’s also the advantage that the normal overhead of copying files into containers
    with the method in [technique 114](kindle_split_029.xhtml#ch16sb07) is simply
    not present. Databases like the one in [technique 77](kindle_split_021.xhtml#ch10sb03)
    are the obvious beneficiary if they grow large.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有优势，那就是使用[技术 114](kindle_split_029.xhtml#ch16sb07)中的方法将文件复制到容器中的正常开销根本不存在。像[技术
    77](kindle_split_021.xhtml#ch10sb03)中的数据库这样的数据库，如果它们变得很大，将是明显的受益者。
- en: Finally, you’ll see a number of techniques that use `-v /var/run/docker.sock:/
    var/run/docker.sock`, one of the many being [technique 45](kindle_split_016.xhtml#ch06sb06).
    This exposes the special Unix socket file to the container and demonstrates an
    important capability of this technique—you aren’t limited to so-called “regular”
    files—you can also permit more unusual filesystem-based use cases. But if you
    encounter permissions issues with device nodes (for example), you may need to
    refer to [technique 93](kindle_split_027.xhtml#ch14sb02) to get a handle on what
    the `--privileged` flag does.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将看到许多使用 `-v /var/run/docker.sock:/var/run/docker.sock` 的技术，其中之一就是[技术 45](kindle_split_016.xhtml#ch06sb06)。这会将特殊的
    Unix 套接字文件暴露给容器，并展示了这项技术的重要功能——您不仅限于所谓的“常规”文件——您还可以允许更多基于文件系统的非典型用例。但如果您遇到设备节点（例如）的权限问题，您可能需要参考[技术
    93](kindle_split_027.xhtml#ch14sb02)来了解 `--privileged` 标志的作用。
- en: '|  |'
  id: totrans-1115
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1116
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Distributed volumes with Resilio Sync**'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 Resilio 同步的分布式卷**'
- en: When experimenting with Docker in a team, you may want to share large quantities
    of data among team members, but you may not be allocated the resources for a shared
    server with sufficient capacity. The lazy solution to this is copying the latest
    files from other team members when you need them—this quickly gets out of hand
    for a larger team.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 当在团队中实验 Docker 时，您可能希望团队成员之间共享大量数据，但您可能没有足够的资源来分配一个具有足够容量的共享服务器。这种懒惰的解决方案是在需要时从其他团队成员那里复制最新的文件——对于较大的团队来说，这会迅速失控。
- en: The solution is to use a decentralized tool for sharing files—no dedicated resource
    required.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用用于文件共享的去中心化工具——无需专用资源。
- en: '**PROBLEM**'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to share volumes across hosts over the internet.
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 您想在互联网上跨主机共享卷。
- en: '**SOLUTION**'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use a technology called Resilio to share volumes over the internet.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名为 Resilio 的技术通过互联网共享卷。
- en: '[Figure 5.4](#ch05fig04) illustrates the setup you’re aiming for.'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.4](#ch05fig04) 展示了您所追求的设置。'
- en: Figure 5.4\. Using Resilio
  id: totrans-1125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.4\. 使用 Resilio
- en: '![](Images/05fig04_alt.jpg)'
  id: totrans-1126
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig04_alt.jpg)'
- en: The end result is a volume (`/data`) conveniently synchronized over the internet
    without requiring any complicated setup.
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是卷（`/data`）通过互联网方便地同步，无需任何复杂的设置。
- en: 'On your primary server, run the following commands to set up the containers
    on the first host:'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的主服务器上，运行以下命令以在第一台主机上设置容器：
- en: '[PRE87]'
  id: totrans-1129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '***1*** **Runs the published ctlc/btsync image as a daemon container, calls
    the btsync binary, and opens the required ports**'
  id: totrans-1130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 以守护进程容器运行已发布的 ctlc/btsync 图像，调用 btsync 二进制文件，并打开所需的端口'
- en: '***2*** **Gets the output of the resilio container so you can make a note of
    the key**'
  id: totrans-1131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 获取 resilio 容器的输出，以便您可以记录下密钥'
- en: '***3*** **Make a note of this key—it will be different for your run**'
  id: totrans-1132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 记录此密钥——它将因您的运行而不同'
- en: '***4*** **Starts up an interactive container with the volumes from the resilio
    server**'
  id: totrans-1133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 启动一个带有 Resilio 服务器卷的交互式容器'
- en: '***5*** **Adds a file to the /data volume**'
  id: totrans-1134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 将文件添加到 /data 卷'
- en: 'On the second server, open up a terminal and run these commands to synchronize
    the volume:'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二台服务器上打开终端并运行以下命令以同步卷：
- en: '[PRE88]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '***1*** **Starts a resilio client container as a daemon with the key generated
    by the daemon run on host1**'
  id: totrans-1137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 以守护进程模式启动一个由 host1 上运行的守护进程生成的密钥的 resilio 客户端容器'
- en: '***2*** **Starts an interactive container that mounts the volumes from your
    client daemon**'
  id: totrans-1138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 启动一个交互式容器，挂载来自您的客户端守护进程的卷'
- en: '***3*** **The file created on host1 has been transferred to host2.**'
  id: totrans-1139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 在 host1 上创建的文件已传输到 host2。'
- en: '***4*** **Creates a second file on host2**'
  id: totrans-1140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 在 host2 上创建第二个文件'
- en: 'Back on host1’s running container, you should see that the file has been synchronized
    between the hosts exactly as the first file was:'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 host1 的运行容器上，您应该看到文件已经在主机之间同步，就像第一个文件一样：
- en: '[PRE89]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '**DISCUSSION**'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: The synchronization of files comes with no timing guarantees, so you may have
    to wait for the data to sync. This is particularly the case for larger files.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的同步没有时间保证，因此您可能需要等待数据同步。对于较大的文件来说，这种情况尤为明显。
- en: '|  |'
  id: totrans-1145
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-1146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Because the data may be sent over the internet and is processed by a protocol
    over which you have no control, you shouldn’t rely on this technique if you have
    any meaningful security, scalability, or performance constraints.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据可能通过互联网发送，并且由你无法控制的协议处理，如果你有任何有意义的关于安全性、可扩展性或性能的约束，你不应该依赖这种技术。
- en: '|  |'
  id: totrans-1148
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: We’ve only demonstrated that this technique works between two containers, as
    mentioned at the beginning, but it should also work across many members of a team.
    Aside from the obvious use case of large files that don’t fit in version control,
    candidates for distribution include backups and possibly Docker images themselves,
    particularly if this technique is used in combination with an efficient compression
    mechanism like the one shown in [technique 72](kindle_split_020.xhtml#ch09sb04).
    To avoid conflicts, make sure that images are always going in one direction (for
    example, from a build machine to many servers), or follow an agreed-upon process
    for performing updates.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经演示了这种技术在两个容器之间是有效的，正如开头提到的，但它也应该适用于团队中的许多成员。除了明显的大文件不适合版本控制的使用场景之外，还包括备份，甚至可能是Docker镜像本身，尤其是如果这种技术与像[技术72](kindle_split_020.xhtml#ch09sb04)中展示的高效压缩机制结合使用时。为了避免冲突，确保镜像总是单向流动（例如，从构建机器到多个服务器），或者遵循一个协议来执行更新。
- en: '|  |'
  id: totrans-1150
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1151
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Retaining your container’s bash history**'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: '**保留你的容器bash历史**'
- en: Experimenting inside a container, knowing that you can wipe everything out when
    you’re done, can be a liberating experience. But there are some conveniences that
    you lose when doing this. One that we’ve hit many times is forgetting a sequence
    of commands we’ve run inside a container.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内进行实验，知道你完成时可以清除一切，可以是一种解放的经历。但当你这样做时，你会失去一些便利。我们多次遇到的一个问题是忘记在容器内运行的一系列命令。
- en: '**PROBLEM**'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to share your container’s bash history with your host’s history.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望将你的容器bash历史与主机的bash历史共享。
- en: '**SOLUTION**'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the `-e` flag, Docker mounts, and a bash alias to automatically share your
    container’s bash history with the host’s.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-e`标志、Docker挂载和bash别名可以自动将容器的bash历史与主机的bash历史共享。
- en: To understand this problem, we’ll show you a simple scenario where losing this
    history is plain annoying.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个问题，我们将展示一个简单的场景，其中丢失这个历史记录是非常令人烦恼的。
- en: 'Imagine you’re experimenting in Docker containers, and in the midst of your
    work you do something interesting and reusable. We’ll use a simple `echo` command
    for this example, but it could be a long and complex concatenation of programs
    that results in useful output:'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你在Docker容器中进行实验，在工作的过程中你做了一些有趣且可重用的操作。我们将使用一个简单的`echo`命令作为这个例子，但这也可能是一个由多个程序组成的复杂拼接，最终产生有用的输出：
- en: '[PRE90]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'After some time, you want to recall the incredible `echo` command you ran earlier.
    Unfortunately you can’t remember it, and you no longer have the terminal session
    on your screen to scroll to. Out of habit, you try looking through your bash history
    on the host:'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间后，你想回忆起你之前运行的令人难以置信的`echo`命令。不幸的是，你记不起来了，而且你也不再在屏幕上看到终端会话以便滚动查看。出于习惯，你尝试在主机的bash历史中查找：
- en: '[PRE91]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Nothing comes back, because the bash history is kept within the now-removed
    container and not the host you were returned to.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何东西返回，因为bash历史被保存在现在已移除的容器中，而不是你返回的主机中。
- en: 'To share your bash history with the host, you can use a volume mount when running
    your Docker images. Here’s an example:'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你的bash历史与主机共享，你可以在运行Docker镜像时使用卷挂载。以下是一个示例：
- en: '[PRE92]'
  id: totrans-1165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '***1*** **Sets the environment variable picked up by bash. This ensures the
    bash history file used is the one you mount.**'
  id: totrans-1166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设置bash获取的环境变量。这确保了你挂载的bash历史文件是你想要的。**'
- en: '***2*** **Maps the container’s root’s bash history file to the host’s**'
  id: totrans-1167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将容器的根bash历史文件映射到主机上**'
- en: '|  |'
  id: totrans-1168
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You may want to separate the container’s bash history from your host’s. One
    way to do this is to change the value for the first part of the preceding `-v`
    argument.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望将容器的bash历史与主机的bash历史分开。一种方法是通过更改前面`-v`参数的第一部分值来实现。
- en: '|  |'
  id: totrans-1171
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'This is quite a handful to type every time, so to make this more user-friendly
    you can set up an alias by putting this into your ~/.bashrc file:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 每次都要输入这些内容确实很麻烦，所以为了使其更用户友好，你可以在你的`~/.bashrc`文件中设置一个别名：
- en: '[PRE93]'
  id: totrans-1173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This still isn’t seamless, because you have to remember to type `dockbash`
    if you want to perform a `docker run` command. For a more seamless experience,
    you can add these to your ~/.bashrc file:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不是无缝的，因为如果您想执行`docker run`命令，您必须记得输入`dockbash`。为了获得更无缝的体验，您可以将这些添加到您的~/.bashrc文件中：
- en: Listing 5.6\. Function alias to auto-mount host bash history
  id: totrans-1175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**列表5.6\. 自动挂载主机bash历史记录的函数别名**'
- en: '[PRE94]'
  id: totrans-1176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '***1*** **Creates a bash function called basher that will handle the docker
    command\**'
  id: totrans-1177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建一个名为basher的bash函数，该函数将处理docker命令\**'
- en: '***2*** **Determines whether the first argument to basher/docker is “run”**'
  id: totrans-1178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **确定basher/docker的第一个参数是否为“run”**'
- en: '***3*** **Removes that argument from the list of arguments you’ve passed in**'
  id: totrans-1179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **从您传递的参数列表中删除该参数**'
- en: '***4*** **Runs the docker run command you ran earlier, invoking the absolute
    path to the Docker runtime to avoid confusion with the following docker alias.
    The absolute path is discovered by running the “which docker” command on your
    host before implementing this solution.**'
  id: totrans-1180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **运行您之前运行的docker run命令，调用Docker运行时的绝对路径以避免与以下docker别名混淆。绝对路径是通过在实施此解决方案之前在主机上运行“which
    docker”命令来发现的。**'
- en: '***5*** **Passes the arguments after “run” to the Docker runtime**'
  id: totrans-1181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **将“run”之后的参数传递给Docker运行时**'
- en: '***6*** **Runs the docker command with the original arguments intact**'
  id: totrans-1182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **使用原始参数运行docker命令**'
- en: '***7*** **Aliases the docker command when it’s invoked on the command line
    to the basher function you’ve created. This ensures that the call to docker is
    caught before bash finds the docker binary on the path.**'
  id: totrans-1183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **当在命令行上调用docker命令时，将docker命令别名设置为已创建的basher函数。这确保在bash在路径上找到docker二进制文件之前，docker的调用被捕获。**'
- en: '**DISCUSSION**'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Now, when you next open a bash shell and run any `docker run` command, the commands
    that are run within that container will be added to your host’s bash history.
    Make sure the path to Docker is correct. It might be located in /bin/docker, for
    example.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您下次打开bash shell并运行任何`docker run`命令时，该容器内运行的命令将被添加到您的主机bash历史记录中。请确保Docker的路径正确。例如，它可能位于/bin/docker。
- en: '|  |'
  id: totrans-1186
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**注意**'
- en: You’ll need to log out of your host’s original bash session for the history
    file to be updated. This is due to a subtlety of bash and how it updates the bash
    history it keeps in memory. If in doubt, exit all bash sessions you’re aware of,
    and then start one up to ensure your history is as up-to-date as possible.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从主机的原始bash会话中注销，以便更新历史文件。这是由于bash及其如何更新内存中保留的bash历史的一个细微差别。如果有疑问，退出您所知道的全部bash会话，然后重新启动一个以确保您的历史记录尽可能最新。
- en: '|  |'
  id: totrans-1189
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A number of command-line tools with prompts also store history, SQLite being
    one example (storing history in a .sqlite_history file). If you don’t want to
    use the integrated logging solutions available in Docker described in [technique
    102](kindle_split_028.xhtml#ch15sb03), you could use a similar practice to make
    your application write to a file that ends up outside the container. Be aware
    that the complexities of logging, such as log rotation, mean that it may be simpler
    to use a log directory volume rather than just a file.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 许多带有提示的命令行工具也会存储历史记录，SQLite就是一个例子（将历史记录存储在.sqlite_history文件中）。如果您不想使用Docker中描述的集成日志解决方案[技术102](kindle_split_028.xhtml#ch15sb03)，您可以使用类似的实践使您的应用程序写入一个最终位于容器外的文件。请注意，日志的复杂性，如日志轮转，意味着可能更简单的是使用日志目录卷而不是仅仅一个文件。
- en: '|  |'
  id: totrans-1191
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1192
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Data containers**'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据容器**'
- en: If you use volumes a lot on a host, managing the container’s startup can get
    tricky. You may also want the data to be managed by Docker exclusively, and not
    be generally accessible on the host. One way to manage these things more cleanly
    is to use the data-only container design pattern.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在主机上大量使用卷，管理容器的启动可能会变得复杂。您可能还希望数据仅由Docker管理，而不是在主机上普遍可访问。更干净地管理这些事情的一种方法是用数据仅容器设计模式。
- en: '**PROBLEM**'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to use an external volume within a container, but you only want Docker
    to access the files.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 您想在容器内使用外部卷，但只想让Docker访问文件。
- en: '**SOLUTION**'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Start up a data container and use the `--volumes-from` flag when running other
    containers.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个数据容器，并在运行其他容器时使用`--volumes-from`标志。
- en: '[Figure 5.5](#ch05fig05) shows the structure of the data container pattern
    and explains how it works. The key thing to note is that in the second host, the
    containers don’t need to know where the data is located on disk. All they need
    to know is the name of the data container, and they’re good to go. This can make
    the operation of containers more portable.'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5.5](#ch05fig05) 展示了数据容器模式的结构，并解释了它是如何工作的。需要注意的是，在第二个主机上，容器不需要知道数据在磁盘上的位置。它们只需要知道数据容器的名称，然后就可以正常工作了。这可以使容器的操作更加便携。'
- en: Figure 5.5\. The data container pattern
  id: totrans-1200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.5\. 数据容器模式
- en: '![](Images/05fig05_alt.jpg)'
  id: totrans-1201
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig05_alt.jpg)'
- en: Another benefit of this approach over the straightforward mapping of host directories
    is that access to these files is managed by Docker, which means that a non-Docker
    process is less likely to affect the contents.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接映射主机目录相比，这种方法的一个好处是，对这些文件的访问由 Docker 管理，这意味着非 Docker 进程不太可能影响其内容。
- en: '|  |'
  id: totrans-1203
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: People are commonly confused about whether the data-only container needs to
    run. It doesn’t! It merely needs to exist, to have been run on the host, and not
    been deleted.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 人们通常对是否需要运行仅数据容器感到困惑。它不需要！它只需要存在，已经在主机上运行过，并且没有被删除。
- en: '|  |'
  id: totrans-1206
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Let’s go through a simple example so you can get a feel for how to use this
    technique.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来了解如何使用这项技术。
- en: 'First you run your data container:'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您运行您的数据容器：
- en: '[PRE95]'
  id: totrans-1209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `-v` argument doesn’t map the volume to a host directory, so it creates
    the directory within the scope of this container’s responsibility. This directory
    is populated with a single file with `touch`, and the container immediately exists—a
    data container need not be running to be used. We’ve used the small but functional
    busybox image to reduce the amount of extra baggage our data container needs.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v` 参数不会将卷映射到主机目录，因此它会在该容器的责任范围内创建目录。这个目录通过 `touch` 命令添加一个文件，容器立即存在——数据容器不需要运行就可以被使用。我们使用了小巧但功能齐全的
    busybox 镜像来减少数据容器需要的额外负担。'
- en: 'Then you run up another container to access the file you just created:'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您运行另一个容器来访问您刚刚创建的文件：
- en: '[PRE96]'
  id: totrans-1212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '**DISCUSSION**'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: The `--volumes-from` flag allows you to reference the files from the data container
    by mounting them in the current container—you just need to pass it the ID of a
    container with volumes defined. The busybox image doesn’t have bash, so you need
    to start up a simpler shell to verify that the /shared-data folder from the `dc`
    container is available to you.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: '`--volumes-from` 标志允许您通过在当前容器中挂载它们来引用数据容器的文件——您只需要传递一个定义了卷的容器的 ID。busybox 镜像没有
    bash，因此您需要启动一个更简单的 shell 来验证 `dc` 容器中的 /shared-data 文件夹对您是否可用。'
- en: You can start up any number of containers, all reading from and writing to the
    specified data container’s volumes.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以启动任意数量的容器，所有这些容器都从指定的数据容器的卷中读取和写入。
- en: You don’t need to use this pattern in order to use volumes—you may find this
    approach harder to manage than a straightforward mount of a host directory. If,
    however, you like to cleanly delegate responsibility for managing data to a single
    point managed within Docker and uncontaminated by other host processes, data containers
    may be useful for you.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要使用这种模式来使用卷——您可能会发现这种方法比直接挂载主机目录更难管理。然而，如果您喜欢将管理数据的责任干净利落地委托给 Docker 内部管理的单个点，不受其他主机进程的干扰，那么数据容器可能对您很有用。
- en: '|  |'
  id: totrans-1217
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-1218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: If your application is logging from multiple containers to the same data container,
    it’s important to ensure that each container log file writes to a unique file
    path. If you don’t, different containers might overwrite or truncate the file,
    resulting in lost data, or they might write interleaved data, which is less easy
    to analyze. Similarly, if you invoke `--volumes-from` from a data container, you
    allow that container to potentially overlay directories over yours, so be careful
    of name clashes here.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序从多个容器向同一个数据容器记录日志，确保每个容器的日志文件都写入唯一的文件路径是很重要的。如果不这样做，不同的容器可能会覆盖或截断文件，导致数据丢失，或者它们可能会写入交错的数据，这更难分析。同样，如果您从数据容器中调用
    `--volumes-from`，您允许该容器可能覆盖您的目录，因此在这里要小心名称冲突。
- en: '|  |'
  id: totrans-1220
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: It’s important to understand that this pattern can result in heavy disk usage
    that can be relatively difficult to debug. Because Docker manages the volume within
    the data-only container and doesn’t delete the volume when the last container
    referencing it has exited, any data on a volume will persist. This is to prevent
    undesired data loss. For advice on managing this, see [technique 43](kindle_split_016.xhtml#ch06sb04).
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解这种模式可能会导致大量磁盘使用，这可能相对难以调试。因为Docker在数据容器内管理卷，并且当最后一个引用它的容器退出时不会删除卷，所以卷上的任何数据都将持续存在。这是为了防止数据丢失。有关管理方面的建议，请参阅[技术43](kindle_split_016.xhtml#ch06sb04)。
- en: '|  |'
  id: totrans-1222
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-1223
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Remote volume mounting using SSHFS**'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用SSHFS进行远程卷挂载**'
- en: We’ve discussed mounting local files, but soon the question of how to mount
    remote filesystems arises. Perhaps you want to share a reference database on a
    remote server and treat it as if it were local, for example.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了挂载本地文件，但很快就会提出如何挂载远程文件系统的问题。例如，您可能希望将远程服务器上的参考数据库共享并作为本地处理。
- en: Although it’s theoretically possible to set up NFS on your host system and the
    server, and then access the filesystem by mounting that directory, there’s a quicker
    and simpler way for most users that requires no setup on the server side (as long
    as there is SSH access).
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在理论上您可以在主机系统和服务器上设置NFS，并通过挂载该目录来访问文件系统，但对于大多数用户来说，这有一个更快、更简单的方法，不需要在服务器端进行设置（只要存在SSH访问）。
- en: '|  |'
  id: totrans-1227
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-1228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll need root privileges for this technique to work, and you’ll need FUSE
    (Linux’s “Filesystem in Userspace” kernel module) installed. You can determine
    whether you have the latter by running `ls /dev/fuse` in a terminal to see whether
    the file exists.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要root权限才能使此技术生效，并且您需要安装FUSE（Linux的“用户空间文件系统”内核模块）。您可以通过在终端中运行`ls /dev/fuse`来查看该文件是否存在，以确定您是否安装了后者。
- en: '|  |'
  id: totrans-1230
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**PROBLEM**'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to mount a remote filesystem without requiring any server-side configuration.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望挂载远程文件系统而不需要任何服务器端配置。
- en: '**SOLUTION**'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use a technology called SSHFS to mount the remote filesystem so that it appears
    to be local to your machine.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSHFS（SSH文件系统）技术挂载远程文件系统，使其看起来像是您机器上的本地文件系统。
- en: This technique works by using a FUSE kernel module with SSH to give you a standard
    interface to a filesystem, while in the background doing all communications via
    SSH. SSHFS also provides various behind-the-scenes features (such as remote file
    read-ahead) to facilitate the illusion that the files are local. The upshot is
    that once a user is logged into the remote server, they’ll see the files as if
    they were local. [Figure 5.6](#ch05fig06) helps explain this.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 此技术通过使用SSH的FUSE内核模块提供对文件系统的标准接口，同时在后台通过SSH进行所有通信。SSHFS还提供各种幕后功能（如远程文件预读），以促进文件本地化的错觉。结果是，一旦用户登录到远程服务器，他们就会看到文件，就像它们是本地的一样。[图5.6](#ch05fig06)有助于解释这一点。
- en: Figure 5.6\. Mounting a remote filesystem with SSHFS
  id: totrans-1236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.6\. 使用SSHFS挂载远程文件系统
- en: '![](Images/05fig06_alt.jpg)'
  id: totrans-1237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/05fig06_alt.jpg)'
- en: '|  |'
  id: totrans-1238
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-1239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Although this technique doesn’t use the Docker volumes functionality, and the
    files are visible through the filesystem, this technique doesn’t give you any
    container-level persistence. Any changes made take place on the remote server’s
    filesystem only.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然此技术不使用Docker卷功能，并且文件通过文件系统可见，但这并不提供任何容器级别的持久性。任何更改都仅发生在远程服务器的文件系统中。
- en: '|  |'
  id: totrans-1241
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You can get started by running the following commands, adjusted for your environment.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令开始，根据您的环境进行调整。
- en: 'The first step is to start up a container with `--privileged` on your host
    machine:'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在您的宿主机上启动一个带有`--privileged`的容器：
- en: '[PRE97]'
  id: totrans-1244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Then, when it’s started up, run `apt-get update && apt-get install sshfs` from
    within the container to install SSHFS.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当它启动时，在容器内部运行`apt-get update && apt-get install sshfs`来安装SSHFS。
- en: 'When SSHFS is successfully installed, log on to the remote host as follows:'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 当SSHFS成功安装后，按照以下方式登录到远程主机：
- en: '[PRE98]'
  id: totrans-1247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '***1*** **Choose a directory to mount the remote location into**'
  id: totrans-1248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **选择一个目录来挂载远程位置** '
- en: '***2*** **Create the local directory to mount into**'
  id: totrans-1249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **创建挂载的本地目录**'
- en: '***3*** **Replace the values here with your remote host username, remote host
    address, and remote path**'
  id: totrans-1250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在此处替换您的远程主机用户名、远程主机地址和远程路径**'
- en: You’ll now see the contents of the path on the remote server in the folder you’ve
    just created.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将在您刚刚创建的文件夹中看到远程服务器路径的内容。
- en: '|  |'
  id: totrans-1252
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-1253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: It’s simplest to mount to a directory that you’ve newly created, but it’s also
    possible to mount a pre-existing directory with files already present if you use
    the `-o nonempty` option. See the SSHFS man page for more information.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是将挂载到新创建的目录上，但如果您使用`-o nonempty`选项，也可以挂载一个已存在的目录，其中已经存在文件。有关更多信息，请参阅SSHFS手册页。
- en: '|  |'
  id: totrans-1255
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'To cleanly unmount the files, use the `fusermount` command as follows, replacing
    the path as appropriate:'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 要干净地卸载文件，请使用以下`fusermount`命令，根据需要替换路径：
- en: '[PRE99]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '**DISCUSSION**'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This is a great way to quickly get remote mounts working from within containers
    (and on standard Linux machines) with minimal effort.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种快速从容器（和在标准Linux机器上）内实现远程挂载的绝佳方法，只需付出最小的努力。
- en: Although we’ve only talked about SSHFS in this technique, successfully managing
    this opens up the wonderful (and sometimes weird) world of FUSE filesystems inside
    Docker. From storing your data inside Gmail to the distributed GlusterFS filesystem
    for storing petabytes of data across many machines, a number of opportunities
    open up to you.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们只在这个技术中讨论了SSHFS，但成功管理这一点将打开Docker内部FUSE文件系统的美妙（有时也奇怪）世界。从在Gmail中存储您的数据到跨多台机器存储PB级数据的分布式GlusterFS文件系统，为您打开了众多机会。
- en: '|  |'
  id: totrans-1261
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1262
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Sharing data over NFS**'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过NFS共享数据**'
- en: In a larger company, NFS shared directories will likely already be in use—NFS
    is a well-proven option for serving files out of a central location. For Docker
    to get traction, it’s usually fairly important to be able to get access to these
    shared files.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大公司中，NFS共享目录可能已经在使用中——NFS是中央位置提供文件的一个经过充分验证的选项。为了使Docker获得影响力，通常非常重要能够访问这些共享文件。
- en: 'Docker doesn’t support NFS out of the box, and installing an NFS client on
    every container so you can mount the remote folders isn’t considered a best practice.
    Instead, the suggested approach is to have one container act as a translator from
    NFS to a more Docker-friendly concept: volumes.'
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 默认不支持NFS，在每一个容器上安装NFS客户端以便挂载远程文件夹并不是最佳实践。相反，建议的方法是让一个容器充当从NFS到更符合Docker概念的翻译器：卷。
- en: '**PROBLEM**'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want seamless access to a remote filesystem over NFS.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望无缝访问通过NFS的远程文件系统。
- en: '**SOLUTION**'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use an infrastructure data container to broker access to your remote NFS filesystem.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基础设施数据容器来代理对您的远程NFS文件系统的访问。
- en: This technique builds on [technique 37](#ch05sb10), where we created a data
    container to manage data in a running system.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术建立在[技术37](#ch05sb10)的基础上，我们在那里创建了一个数据容器来管理运行系统中的数据。
- en: '[Figure 5.7](#ch05fig07) shows the idea of this technique in the abstract.
    The NFS server exposes the internal directory as the /export folder, which is
    bind-mounted on the host. The Docker host then mounts this folder using the NFS
    protocol to its /mnt folder. Then a so-called “infrastructure container” is created,
    which binds the mount folder.'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5.7](#ch05fig07)展示了这一技术的抽象概念。NFS服务器将内部目录作为/export文件夹暴露出来，该文件夹绑定在主机上。然后Docker主机使用NFS协议将此文件夹挂载到其/mnt文件夹上。然后创建了一个所谓的“基础设施容器”，它绑定挂载文件夹。'
- en: Figure 5.7\. An infrastructure container that brokers NFS access
  id: totrans-1272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.7\. 作为NFS访问经纪人的基础设施容器
- en: '![](Images/05fig07_alt.jpg)'
  id: totrans-1273
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05fig07_alt.jpg)'
- en: 'This may seem a little over-engineered at first glance, but the benefit is
    that it provides a level of indirection as far as the Docker containers are concerned:
    all they need to do is mount the volumes from a pre-agreed infrastructure container,
    and whoever is responsible for the infrastructure can worry about the internal
    plumbing, availability, network, and so on.'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这可能会显得有些过度设计，但好处是它为Docker容器提供了一定程度的间接性：它们只需要挂载来自预先约定的基础设施容器的卷，而负责基础设施的人可以关心内部管道、可用性、网络等问题。
- en: A thorough treatment of NFS is beyond the scope of this book. In this technique,
    we’re just going to go through the steps of setting up such a share on a single
    host by having the NFS server’s components on the same host as the Docker containers.
    This has been tested on Ubuntu 14.04.
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 对NFS的全面介绍超出了本书的范围。在这个技术中，我们将通过在同一个主机上拥有NFS服务器组件，通过在Docker容器上设置这样的共享来介绍这一步骤。这已经在Ubuntu
    14.04上进行了测试。
- en: Suppose you want to share the contents of your host’s /opt/test/db folder, which
    contains the file mybigdb.db.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想共享主机上的/opt/test/db文件夹的内容，该文件夹包含文件mybigdb.db。
- en: 'As root, install the NFS server and create an export directory with open permissions:'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 以root身份安装NFS服务器并创建一个具有开放权限的导出目录：
- en: '[PRE100]'
  id: totrans-1278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '|  |'
  id: totrans-1279
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: We’ve created the NFS share with open permissions, which is not a secure way
    to proceed for a production system. We’ve taken this approach in the interest
    of simplifying this tutorial. NFS security is a complicated and varied topic,
    which is beyond the scope of this book. For more on Docker and security, see [chapter
    14](kindle_split_027.xhtml#ch14).
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已使用开放权限创建了NFS共享，这对于生产系统来说并不是一个安全的方法。我们采取这种方法是为了简化本教程。NFS安全性是一个复杂且多样化的主题，超出了本书的范围。有关Docker和安全的更多信息，请参阅第14章[chapter
    14](kindle_split_027.xhtml#ch14)。
- en: '|  |'
  id: totrans-1282
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Now bind mount the db directory to your export directory:'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将 db 目录绑定到您的导出目录：
- en: '[PRE101]'
  id: totrans-1284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'You should now be able to see the contents of the /opt/test/db directory in
    /export:'
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该能够看到 `/opt/test/db` 目录的内容在 `/export` 中：
- en: '|  |'
  id: totrans-1286
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you want this to persist following a reboot, add this line to your /etc/fstab
    file: `/opt/test/db /export none bind 0 0`'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望重启后此设置持续有效，请将此行添加到您的 /etc/fstab 文件中：`/opt/test/db /export none bind 0 0`
- en: '|  |'
  id: totrans-1289
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Now add this line to your /etc/exports file:'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将此行添加到您的 /etc/exports 文件中：
- en: '[PRE102]'
  id: totrans-1291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: For this proof of concept example, we’re mounting locally on `127.0.0.1`, which
    defeats the object a little. In a real-world scenario, you’d lock this down to
    a class of IP addresses such as `192.168.1.0/24`. If you like playing with fire,
    you can open it up to the world with `*` instead of `127.0.0.1`. For safety, we’re
    mounting read-only (`ro`) here, but you can mount read-write by replacing `ro`
    with `rw`. Remember that if you do this, you’ll need to add a `no_root_squash`
    flag after the `async` flag there, but think about security before going outside
    this sandpit.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个概念验证示例，我们在 `127.0.0.1` 上进行本地挂载，这在一定程度上抵消了效果。在现实世界的场景中，您会将其限制为某个IP地址类，例如
    `192.168.1.0/24`。如果您喜欢玩火，可以用 `*` 代替 `127.0.0.1` 来向世界开放。为了安全起见，我们在这里以只读（`ro`）方式挂载，但您可以通过将
    `ro` 替换为 `rw` 来挂载为读写。请记住，如果您这样做，您需要在 `async` 标志之后添加一个 `no_root_squash` 标志，但在走出这个沙盒之前请考虑安全问题。
- en: 'Mount the directory over NFS to the /mnt directory, export the filesystems
    you specified previously in /etc/exports, and then restart the NFS service to
    pick up the changes:'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过NFS将目录挂载到 `/mnt` 目录，导出您之前在 `/etc/exports` 中指定的文件系统，然后重新启动NFS服务以应用更改：
- en: '[PRE103]'
  id: totrans-1294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Now you’re ready to run your infrastructure container:'
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经准备好运行您的基础设施容器：
- en: '[PRE104]'
  id: totrans-1296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'And now you can run—without privileges, or knowledge of the underlying implementation—the
    directory you want to access:'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在没有权限或对底层实现了解的情况下运行您想要访问的目录：
- en: '[PRE105]'
  id: totrans-1298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '**DISCUSSION**'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This pattern of centrally mounting a shared resource with privileged access
    for use by others in multiple containers is a powerful one that can make development
    workflows much simpler.
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在多个容器中集中挂载共享资源并提供特权的模式非常强大，可以使开发工作流程变得更加简单。
- en: '|  |'
  id: totrans-1301
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If you have a lot of these containers to manage, you can make this easier to
    manage by having a naming convention such as `--name nfs_client_opt _database_live`
    for a container that exposes the /opt/database/live path.
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要管理很多这样的容器，您可以通过为容器指定命名约定（例如 `--name nfs_client_opt_database_live`）来简化管理，该容器公开了
    `/opt/database/live` 路径。
- en: '|  |'
  id: totrans-1304
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1305
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that this technique only provides security through obscurity (which
    is no security at all). As you’ll see later, anyone who can run the Docker executable
    effectively has root privileges on the host.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这种技术只通过隐蔽性提供安全性（这根本不是安全性）。正如您稍后将会看到的，任何可以运行Docker可执行文件的人实际上在主机上都有root权限。
- en: '|  |'
  id: totrans-1308
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Infrastructure containers for brokering access and abstracting away details
    are in some ways an equivalent of service-discovery tools for networking—the precise
    details of how the service runs or where it lives aren’t important. You just need
    to know its name.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 用于代理访问和抽象细节的基础设施容器在某种程度上等同于网络中的服务发现工具——服务的运行细节或其所在位置的具体细节并不重要。您只需要知道它的名字。
- en: As it happens, you’ve seen `--volumes-from` being used before in [technique
    35](#ch05sb08). The details are a little different because the access is being
    brokered to infrastructure running *inside* the container rather than on the host,
    but the principle of using names to refer to available volumes remains. You could
    even swap out that container for the one in this technique and, if configured
    correctly, applications wouldn’t notice a difference in where they look to retrieve
    their files.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，您之前已经在[技术35](#ch05sb08)中看到过`--volumes-from`的使用。细节略有不同，因为访问是通过容器内运行的而不是在主机上运行的基础设施进行协商的，但使用名称引用可用卷的原则仍然适用。您甚至可以用这个技术中的容器替换掉那个容器，如果配置正确，应用程序不会注意到它们检索文件的位置有任何变化。
- en: '|  |'
  id: totrans-1311
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1312
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Dev tools container**'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发工具容器**'
- en: If you’re an engineer who often finds yourself on others’ machines, struggling
    without the programs or configuration you have on your beautiful unique-as-a-snowflake
    development environment, this technique may be for you. Similarly, if you want
    to share your pimped-up dev environment with others, Docker can make this easy.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是一位经常在其他机器上遇到困难，没有您在独特如雪花般的开发环境中拥有的程序或配置的工程师，这项技术可能适合您。同样，如果您想与他人分享您升级后的开发环境，Docker可以使其变得简单。
- en: '**PROBLEM**'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to access your development environment on others’ machines.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 您想在其他机器上访问您的开发环境。
- en: '**SOLUTION**'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Create a Docker image with your setup on it, and place it on a registry.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含您设置的Docker镜像，并将其放置在注册表中。
- en: As a demonstration, we’re going to use one of our dev tools images. You can
    download it by running `docker pull dockerinpractice/docker-dev-tools-image`.
    The repo is available at [https://github.com/docker-in-practice/docker-dev-tools-image](https://github.com/docker-in-practice/docker-dev-tools-image)
    if you want to inspect the Dockerfile.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 作为演示，我们将使用我们的一个开发工具镜像。您可以通过运行`docker pull dockerinpractice/docker-dev-tools-image`来下载它。如果您想检查Dockerfile，该仓库可在[https://github.com/docker-in-practice/docker-dev-tools-image](https://github.com/docker-in-practice/docker-dev-tools-image)找到。
- en: Running up the container is simple—a straightforward `docker run -t -i docker-inpractice/docker-dev-tools-image`
    will give you a shell in our dev environment. You can root around our dotfiles
    and maybe send us some advice about the setup.
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 启动容器很简单——一个简单的`docker run -t -i docker-inpractice/docker-dev-tools-image`将为您提供一个我们开发环境中的shell。您可以浏览我们的dotfiles，也许可以给我们一些关于设置的反馈。
- en: The real power of this technique can be seen when it’s combined with others.
    In the following listing you can see a dev tools container used to display a GUI
    on the host’s network and IPDC stacks and to mount the host’s code.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 当与其他技术结合使用时，这种技术的真正威力才会显现。在下面的列表中，您可以看到一个用于在主机网络上显示GUI和挂载主机代码的dev工具容器。
- en: Listing 5.7\. Running dev-tools image with a GUI
  id: totrans-1322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.7\. 运行带GUI的dev-tools镜像
- en: '[PRE106]'
  id: totrans-1323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '***1*** **Mounts the Docker socket to give access to the host’s Docker daemon**'
  id: totrans-1324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将Docker套接字挂载到主机，以便访问主机的Docker守护进程**'
- en: '***2*** **Mounts the X server Unix domain socket to allow you to start up GUI-based
    applications (see [technique 29](#ch05sb02))**'
  id: totrans-1325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **挂载X服务器Unix域套接字，以便您可以启动基于GUI的应用程序（见[技术29](#ch05sb02)）**'
- en: '***3*** **Sets an environment variable instructing the container to use the
    host display**'
  id: totrans-1326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **设置环境变量，指示容器使用主机显示**'
- en: '***4*** **These arguments bypass the container’s network bridge and allow you
    access to the host’s interprocess communication files (see [technique 109](kindle_split_029.xhtml#ch16sb02)).**'
  id: totrans-1327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **这些参数绕过容器网络桥接，允许您访问主机的进程间通信文件（见[技术109](kindle_split_029.xhtml#ch16sb02)）。**'
- en: '***5*** **Mounts the work area to the container’s home directory**'
  id: totrans-1328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **将工作区域挂载到容器的家目录**'
- en: 'The preceding command gives you an environment with access to the host’s resources:'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令为您提供了一个可以访问主机资源的环境：
- en: Network
  id: totrans-1330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络
- en: Docker daemon (to run normal Docker commands as though on the host)
  id: totrans-1331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker守护进程（在主机上运行正常Docker命令）
- en: Interprocess communication (IPC) files
  id: totrans-1332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程间通信（IPC）文件
- en: X server to start GUI-based apps, if needed
  id: totrans-1333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X服务器启动基于GUI的应用程序，如果需要
- en: '|  |'
  id: totrans-1334
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As always when mounting host directories, be careful not to mount any vital
    directories, as you could do damage. Mounting any host directory under root is
    generally best avoided.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 如挂载主机目录时通常所做的那样，请务必小心不要挂载任何关键目录，因为您可能会造成损害。通常最好避免在根目录下挂载任何主机目录。
- en: '|  |'
  id: totrans-1337
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**DISCUSSION**'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: We mentioned that you have access to the X server, so it’s worth looking at
    [technique 29](#ch05sb02) for a reminder of some of the possibilities.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到你可以访问X服务器，因此值得查看[技术29](#ch05sb02)以提醒一些可能性。
- en: For some more invasive dev tools, perhaps for inspecting processes on the host,
    you may need to look at [technique 109](kindle_split_029.xhtml#ch16sb02) to understand
    how to grant permission to view some (by default) restricted parts of your system.
    [Technique 93](kindle_split_027.xhtml#ch14sb02) is also an important read—just
    because a container can see parts of your system doesn’t necessarily mean it has
    permission to alter them.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些更侵入式的开发工具，可能用于检查主机上的进程，你可能需要查看[技术109](kindle_split_029.xhtml#ch16sb02)以了解如何授予查看系统某些（默认情况下）受限部分的权限。[技术93](kindle_split_027.xhtml#ch14sb02)也是一篇重要的阅读材料——仅仅因为容器可以看到你系统的一部分，并不意味着它有权限修改它们。
- en: '|  |'
  id: totrans-1341
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-1342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: You should reach for volumes if you need to get at external data from inside
    a container.
  id: totrans-1343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要从容器内部访问外部数据，你应该使用卷。
- en: SSHFS is a simple way to access data on other machines with no extra setup.
  id: totrans-1344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSHFS是一种简单的方法，无需额外设置即可访问其他机器上的数据。
- en: Running GUI applications in Docker requires only a small amount of preparation
    of your image.
  id: totrans-1345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker中运行GUI应用程序只需要对镜像进行少量准备。
- en: You can use data containers to abstract away the location of your data.
  id: totrans-1346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用数据容器来抽象化你的数据位置。
- en: Chapter 6\. Day-to-day Docker
  id: totrans-1347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章\. 每日Docker
- en: '|  |'
  id: totrans-1348
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Keeping a handle on your container and volume space usage
  id: totrans-1350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控你的容器和卷空间使用情况
- en: Detaching from containers without stopping them
  id: totrans-1351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从容器中分离而不停止它们
- en: Visualizing your Docker image lineage in a graph
  id: totrans-1352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图表中可视化你的Docker镜像谱系
- en: Running commands directly on your containers from the host
  id: totrans-1353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从主机直接在容器上运行命令
- en: '|  |'
  id: totrans-1354
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: As with any moderately complex software project, Docker has a lot of nooks and
    crannies that are important to know about if you want to keep your experience
    as smooth as possible.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何中等复杂度的软件项目一样，Docker有很多角落和缝隙，如果你想要尽可能保持体验的流畅，那么了解这些角落和缝隙是很重要的。
- en: This chapter’s techniques will show you some of the more important of these,
    as well as introduce some external tools built by third parties to scratch their
    own itches. Think of it as your Docker toolbox.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术将向你展示其中一些更重要的事项，以及介绍一些第三方构建的工具来解决他们自己的问题。把它想象成你的Docker工具箱。
- en: 6.1\. Staying ship-shape
  id: totrans-1357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 保持整洁
- en: If you’re anything like us (and if you’re following this book studiously), your
    growing Docker addiction will mean that you start up numerous containers on, and
    download a variety of images to, your chosen host.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和我们一样（如果你认真地遵循这本书），你日益增长的Docker依赖性意味着你将在选择的主机上启动多个容器，并下载各种镜像到你的主机上。
- en: As time goes on, Docker will take up more and more resources, and some housekeeping
    of containers and volumes will be required. We’ll show you the how and why of
    this. We’ll also introduce some visual tools for keeping your Docker environment
    clean and tidy, in case you want an escape from the command line.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，Docker将占用越来越多的资源，需要对容器和卷进行一些维护。我们将展示如何以及为什么需要这样做。我们还将介绍一些可视化工具，以保持你的Docker环境干净整洁，以防你想要从命令行中解脱出来。
- en: Running containers is all very well, but you’ll fairly quickly find yourself
    wanting to do more than just start a single command in the foreground. We’ll take
    a look at escaping a running container without killing it, and at executing commands
    inside a running container.
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 运行容器固然很好，但你很快就会发现自己想要做的不仅仅是启动一个前台的单个命令。我们将探讨在不终止容器的情况下退出运行中的容器，以及在运行中的容器内执行命令。
- en: '|  |'
  id: totrans-1361
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Running Docker without sudo**'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: '**无需sudo运行Docker**'
- en: The Docker daemon runs in the background of your machine as the root user, giving
    it a significant amount of power, which it exposes to you, the user. Needing to
    use `sudo` is a result of this, but it can be inconvenient and make some third-party
    Docker tools impossible to use.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: Docker守护进程以root用户身份在机器的背景中运行，赋予它相当大的权限，它将这些权限暴露给用户。需要使用`sudo`是这一结果，但它可能不方便，并使得一些第三方Docker工具无法使用。
- en: '**PROBLEM**'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to be able to run the `docker` command without having to use `sudo`.
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望能够在不使用`sudo`的情况下运行`docker`命令。
- en: '**SOLUTION**'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: The official solution is to add yourself to the `docker` group.
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 官方解决方案是将自己添加到`docker`组。
- en: Docker manages permissions around the Docker Unix domain socket through a user
    group. For security reasons, distributions don’t make you part of that group by
    default, as it effectively grants full root access to the system.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: Docker通过用户组管理围绕Docker Unix域套接字的权限。出于安全原因，发行版默认不会让您成为该组的成员，因为这实际上授予了系统完全的root访问权限。
- en: 'By adding yourself to this group, you’ll be able to use the `docker` command
    as yourself:'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将自己添加到该组，您将能够以自己的身份使用`docker`命令：
- en: '[PRE107]'
  id: totrans-1370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Restart Docker and fully log out and in again, or reboot your machine if that’s
    easier. Now you don’t need to remember to type `sudo` or set up an alias to run
    Docker as yourself.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动Docker并完全注销并重新登录，或者如果更容易的话，重新启动您的机器。现在您不需要记住输入`sudo`或设置别名以以自己的身份运行Docker。
- en: '**DISCUSSION**'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This is an extremely important technique for a number of tools used later in
    the book. In general, anything that wants to talk to Docker (without being started
    in a container) will need access to the Docker socket, requiring either `sudo`
    or the setup described in this technique. Docker Compose, introduced in [technique
    76](kindle_split_021.xhtml#ch10sb02), is an official tool from Docker Inc. and
    is an example of such a tool.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在本书后面部分使用的许多工具中的一项极其重要的技术。一般来说，任何想要与Docker通信（而不在容器中启动）的东西都需要访问Docker套接字，这需要`sudo`或本技术中描述的设置。Docker
    Compose，在[技术76](kindle_split_021.xhtml#ch10sb02)中介绍，是Docker Inc.的官方工具，是此类工具的例子。
- en: '|  |'
  id: totrans-1374
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-1375
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Housekeeping containers**'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: '**维护容器**'
- en: A frequent gripe of new Docker users is that in a short space of time you can
    end up with many containers on your system in various states, and there are no
    standard tools for managing this on the command line.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 新的Docker用户经常抱怨，在短时间内，您可能会在系统中拥有许多处于各种状态的容器，而在命令行上没有标准工具来管理这些容器。
- en: '**PROBLEM**'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to prune the containers on your system.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 您想清理系统上的容器。
- en: '**SOLUTION**'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Set up aliases to run the commands that tidy up old containers.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 设置别名以运行清理旧容器的命令。
- en: The simplest approach here is to delete all containers. Obviously, this is something
    of a nuclear option that should only be used if you’re certain it’s what you want.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最简单的方法是删除所有容器。显然，这是一个有点像核选项的操作，只有在您确定这是您想要的时才应该使用。
- en: The following command will remove all containers on your host machine.
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将删除您主机上的所有容器。
- en: '[PRE108]'
  id: totrans-1384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '***1*** **Get a list of all container IDs, both running and stopped, and pass
    them to...**'
  id: totrans-1385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **获取所有容器ID的列表，包括正在运行的和已停止的，并将它们传递给...**'
- en: '***2*** **...the `docker rm -f` command, which will remove any containers passed,
    even if they’re running.**'
  id: totrans-1386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **...`docker rm -f`命令，它将删除传递给它的任何容器，即使它们正在运行。**'
- en: To briefly explain `xargs`, it takes each line of the input and passes them
    all as arguments to the subsequent command. We’ve passed an additional argument
    here, `--no-run-if-empty`, which avoids running the command at all if there’s
    no output from the previous command, in order to avoid an error.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 简单解释一下`xargs`，它将输入的每一行都作为参数传递给后续命令。我们在这里添加了一个额外的参数`--no-run-if-empty`，如果前一个命令没有输出，则避免运行该命令，以避免错误。
- en: 'If you have containers running that you may want to keep, but you want to remove
    all those that have exited, you can filter the items returned by the `docker ps`
    command:'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行可能希望保留的容器，但想删除所有已退出的容器，您可以过滤`docker ps`命令返回的项目：
- en: '[PRE109]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '***1*** **The --filter flag tells the docker ps command which containers you
    want returned. In this case you’re restricting it to containers that have exited.
    Other options are running and restarting.**'
  id: totrans-1390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **`--filter`标志告诉`docker ps`命令您想要返回哪些容器。在这种情况下，您正在限制它只返回已退出的容器。其他选项是正在运行和重新启动。**'
- en: '***2*** **This time you don’t force the removal of containers because they
    shouldn’t be running, based on the filter you’ve given.**'
  id: totrans-1391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **这次您不需要强制删除容器，因为根据您提供的过滤器，它们不应该在运行。**'
- en: 'In fact, removing all stopped containers is such a common use case that Docker
    added a command specifically for it: `docker container prune`. However, this command
    is limited to just that use case, and you’ll need to refer back to the commands
    in this technique for any more complex manipulation of containers.'
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，删除所有已停止的容器是一个如此常见的用例，以至于Docker添加了一个专门为此用例的命令：`docker container prune`。然而，此命令仅限于该用例，并且您需要参考本技术中的命令来进行任何更复杂的容器操作。
- en: 'As an example of a more advanced use case, the following command will list
    all containers with a nonzero error code. You may need this if you have many containers
    on your system and you want to automate the examination and removal of any containers
    that exited unexpectedly:'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 作为更高级用例的示例，以下命令将列出所有退出代码非零的容器。如果您系统中有许多容器，并且您想自动化检查和删除任何意外退出的容器，您可能需要这样做：
- en: '[PRE110]'
  id: totrans-1394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '***1*** **Runs the comm command to compare the contents of two files. The -3
    argument suppresses lines that appear in both files (in this example, those with
    a zero exit code) and outputs any others.**'
  id: totrans-1395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **运行 comm 命令以比较两个文件的内容。-3 参数抑制同时出现在两个文件中的行（在本例中，那些退出代码为零的行）并输出其他行。**'
- en: '***2*** **Finds exited container IDs, sorts them, and passes them as a file
    to comm**'
  id: totrans-1396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **查找已退出的容器ID，对它们进行排序，并将它们作为文件传递给 comm**'
- en: '***3*** **Finds containers with an exit code of 0, sorts them, and passes them
    as a file to comm**'
  id: totrans-1397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **查找退出代码为 0 的容器，对它们进行排序，并将它们作为文件传递给 comm**'
- en: '***4*** **Runs docker inspect against containers with a nonzero exit code (as
    piped in by comm) and saves the output to the error_containers file**'
  id: totrans-1398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **对退出代码非零的容器运行 docker inspect（通过 comm 管道传入）并将输出保存到 error_containers
    文件**'
- en: '|  |'
  id: totrans-1399
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**提示**'
- en: If you’ve not seen it before, the `<(command)` syntax is called *process substitution*.
    It allows you to treat the output of a command as a file and pass it to another
    command, which can be useful where piping output isn’t possible.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前没有见过，`<(command)` 语法称为 *进程替换*。它允许您将命令的输出作为文件处理，并将其传递给另一个命令，这在无法使用管道输出时非常有用。
- en: '|  |'
  id: totrans-1402
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The preceding example is rather complicated, but it shows the power you can
    get from combining different utilities. It outputs all stopped container IDs,
    and then picks just those that have a nonzero exit code (those that exited in
    an unexpected way). If you’re struggling to follow this, running each command
    separately and understanding them that way first can be helpful in learning the
    building blocks.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例相当复杂，但它展示了通过组合不同的实用程序可以获得的强大功能。它输出所有已停止的容器ID，然后仅选择那些退出代码非零的容器（那些以意外方式退出的容器）。如果您觉得难以理解，可以先单独运行每个命令，并首先以这种方式理解它们，这有助于学习构建块。
- en: Such a command could be useful for gathering container information on production.
    You may want to adapt it to run a cron to clear out containers that exited in
    expected ways.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的命令对于收集生产环境中的容器信息可能很有用。您可能需要对其进行修改，以便运行 cron 来清除以预期方式退出的容器。
- en: '|  |'
  id: totrans-1405
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Make these one-liners available as commands
  id: totrans-1406
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将这些单行命令作为命令提供
- en: 'You can add commands as aliases so that they’re more easily run whenever you
    log in to your host. To do this, add lines like the following to the end of your
    ~/.bashrc file:'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将命令作为别名添加，以便在登录到您的宿主机时更容易运行。为此，请将以下类似行添加到您的 ~/.bashrc 文件末尾：
- en: '[PRE111]'
  id: totrans-1408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: When you next log in, running `dockernuke` from the command line will delete
    any Docker containers found on your system.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 您下次登录时，可以从命令行运行 `dockernuke` 来删除您系统上找到的任何 Docker 容器。
- en: We’ve found that this saves a surprising amount of time. But be careful! It’s
    all too easy to remove production containers this way, as we can attest. And even
    if you’re careful enough not to remove running containers, you still might remove
    non-running but still useful data-only containers.
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现这节省了惊人的时间。但请注意！以这种方式删除生产容器很容易，正如我们所证明的那样。即使您足够小心，不会删除正在运行的容器，您仍然可能会删除非运行但仍然有用的数据容器。
- en: '|  |'
  id: totrans-1411
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**DISCUSSION**'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Many of the techniques in this book end up creating containers, particularly
    when introducing Docker Compose in [technique 76](kindle_split_021.xhtml#ch10sb02)
    and in the chapters devoted to orchestration—after all, orchestration is all about
    managing multiple containers. You may find the commands discussed here useful
    for cleaning up your machines (local or remote) to get a fresh start when you
    finish each technique.
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多技术最终都会创建容器，尤其是在介绍 Docker Compose 的 [技术76](kindle_split_021.xhtml#ch10sb02)
    以及在有关编排的章节中——毕竟，编排就是管理多个容器。您可能会发现这里讨论的命令对于清理您的机器（本地或远程）以在每个技术完成后获得一个全新的开始很有用。
- en: '|  |'
  id: totrans-1414
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1415
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Housekeeping volumes**'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: '**维护卷**'
- en: Although volumes are a powerful feature of Docker, they come with a significant
    operational downside. Because volumes can be shared between different containers,
    they can’t be deleted when a container that mounted them is deleted. Imagine the
    scenario outlined in [figure 6.1](#ch06fig01).
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管卷是Docker的一个强大功能，但它们也伴随着显著的运营劣势。因为卷可以在不同的容器之间共享，所以当挂载它们的容器被删除时，卷不能被删除。想象一下[图6.1](#ch06fig01)中描述的场景。
- en: Figure 6.1\. What happens to /var/db when containers are removed?
  id: totrans-1418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1\. 当容器被移除时，/var/db会发生什么？
- en: '![](Images/06fig01_alt.jpg)'
  id: totrans-1419
  prefs: []
  type: TYPE_IMG
  zh: '![Images/06fig01_alt.jpg](Images/06fig01_alt.jpg)'
- en: '“Easy!” you might think. “Delete the volume when the last-referencing container
    is removed!” Indeed, Docker could have taken that option, and this approach is
    the one that garbage-collected programming languages take when they remove objects
    from memory: when no other object references it, it can be deleted.'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: “很简单！”你可能会想，“当最后一个引用容器的容器被删除时，删除卷！”确实，Docker可以选择这个选项，当垃圾回收编程语言从内存中删除对象时，这种方法就是：当没有其他对象引用它时，它可以被删除。
- en: But Docker judged that this could leave people open to losing valuable data
    accidentally and preferred to make it a user decision as to whether a volume should
    be deleted on removal of the container. An unfortunate side effect of this is
    that, by default, volumes remain on your Docker daemon’s host disk until they’re
    removed manually. If these volumes are full of data, your disk can fill up, so
    it’s useful to be aware of ways to manage these orphaned volumes.
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 但Docker认为这可能会让人们不小心丢失有价值的数据，因此更喜欢让用户决定是否在删除容器时删除卷。不幸的是，这的一个副作用是，默认情况下，卷会保留在你的Docker守护进程的主机磁盘上，直到它们被手动删除。如果这些卷充满了数据，你的磁盘可能会被填满，因此了解管理这些孤儿卷的方法是有用的。
- en: '**PROBLEM**'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You’re using too much disk space because orphaned Docker mounts exist in your
    host.
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用太多的磁盘空间，因为存在孤儿Docker挂载在你的主机上。
- en: '**SOLUTION**'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the `-v` flag when calling `docker rm`, or use the `docker volume` subcommands
    to destroy them if you forget.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`docker rm`时使用`-v`标志，或者如果你忘记了，可以使用`docker volume`子命令来销毁它们。
- en: In the scenario in [figure 6.1](#ch06fig01), you can ensure that /var/db is
    deleted if you always call `docker rm` with the `-v` flag. The `-v` flag removes
    any associated volumes if no other container still has it mounted. Fortunately,
    Docker is smart enough to know whether any other container has the volume mounted,
    so there are no nasty surprises.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6.1](#ch06fig01)描述的场景中，如果你总是使用带有`-v`标志的`docker rm`命令，你可以确保删除`/var/db`。`-v`标志会在没有其他容器挂载的情况下删除任何关联的卷。幸运的是，Docker足够智能，能够知道是否有其他容器挂载了该卷，因此不会有任何令人不快的惊喜。
- en: The simplest approach is to get into the habit of typing `-v` whenever you remove
    a container. That way you retain control of whether volumes are removed. But the
    problem with this approach is that you might not want to always delete volumes.
    If you’re writing a lot of data to these volumes, it’s quite likely that you won’t
    want to lose the data. Additionally, if you get into such a habit, it’s likely
    to become automatic, and you’ll only realize you’ve deleted something important
    when it’s too late.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是养成习惯，每次删除容器时都输入`-v`。这样你就可以保留控制卷是否被删除的权利。但这种方法的问题是你可能并不总是想删除卷。如果你正在向这些卷写入大量数据，你很可能不想丢失这些数据。此外，如果你养成了这样的习惯，它很可能会变得自动化，你只有在为时已晚时才会意识到你已经删除了某些重要的东西。
- en: 'In these scenarios you can use a command that was added to Docker after much
    griping and many third-party solutions: `docker volume prune`. This will remove
    any unused volumes:'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些场景中，你可以使用在经过许多抱怨和第三方解决方案之后添加到Docker中的命令：`docker volume prune`。这将删除任何未使用的卷：
- en: '[PRE112]'
  id: totrans-1429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '***1*** **Runs the command to list the volumes Docker is aware of**'
  id: totrans-1430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **运行命令以列出Docker所知的卷**'
- en: '***2*** **Volumes that exist on the machine, whether or not they’re in use**'
  id: totrans-1431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **存在于机器上的卷，无论它们是否在使用**'
- en: '***3*** **Runs the command to delete unused volumes**'
  id: totrans-1432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **运行命令以删除未使用的卷**'
- en: '***4*** **Confirms the deletion of volumes**'
  id: totrans-1433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **确认删除卷**'
- en: '***5*** **Volumes that have been deleted**'
  id: totrans-1434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **已删除的卷**'
- en: If you want to skip the confirmation prompt, perhaps for an automated script,
    you can pass `-f` to `docker volume prune` to skip it.
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要跳过确认提示，可能是因为自动化脚本，你可以将`-f`传递给`docker volume prune`以跳过它。
- en: '|  |'
  id: totrans-1436
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-1437
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to recover data from an undeleted volume that’s no longer referenced
    by any containers, you can use `docker volume inspect` to discover the directory
    a volume lives in (likely under `/var/lib/docker/volumes/`). You can then browse
    it as the root user.
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要从不再被任何容器引用的未删除卷中恢复数据，你可以使用 `docker volume inspect` 来发现卷所在的目录（可能位于 `/var/lib/docker/volumes/`
    之下）。然后你可以以 root 用户浏览它。
- en: '|  |'
  id: totrans-1439
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**DISCUSSION**'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Deleting volumes is likely not something you’ll need to do very often, as large
    files in a container are usually mounted from the host machine and don’t get stored
    in the Docker data directory. But it’s worth doing a cleanup every week or so,
    to avoid them piling up, particularly if you’re using data containers from [technique
    37](kindle_split_015.xhtml#ch05sb10).
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 删除卷可能不是你经常需要做的事情，因为容器中的大文件通常是从主机机器挂载的，并且不会存储在 Docker 数据目录中。但每周清理一次是值得的，以避免它们堆积，尤其是如果你在使用来自[技术
    37](kindle_split_015.xhtml#ch05sb10)的数据容器。
- en: '|  |'
  id: totrans-1442
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1443
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Detaching containers without stopping them**'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: '**不停止容器就分离容器**'
- en: When working with Docker, you’ll often find yourself in a position where you
    have an interactive shell, but exiting from the shell would terminate the container,
    as it’s the container’s principal process. Fortunately there’s a way to detach
    from a container (and, if you want, you can use `docker attach` to connect to
    the container again).
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Docker 时，你经常会发现自己处于一个有交互式 shell 的位置，但退出 shell 会终止容器，因为它是容器的主要进程。幸运的是，有一种方法可以从容器中分离出来（如果你想要的话，可以使用
    `docker attach` 再次连接到容器）。
- en: '**PROBLEM**'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to detach from a container interaction without stopping it.
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要在不停止容器的情况下从容器交互中分离出来。
- en: '**SOLUTION**'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the built-in key combination in Docker to escape from the container.
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 内置的快捷键组合从容器中退出。
- en: Docker has helpfully implemented a key sequence that’s unlikely to be needed
    by any other application and that’s also unlikely to be pressed by accident.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 实用地实现了一个不太可能被任何其他应用程序需要的键序列，并且也不太可能意外按下。
- en: Let’s say you started up a container with `docker run -t -i -p 9005:80 ubuntu
    /bin/bash`, and then `apt-get` installed an Nginx web server. You want to test
    that it’s accessible from your host with a quick `curl` command to `localhost:9005`.
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你使用 `docker run -t -i -p 9005:80 ubuntu /bin/bash` 启动了一个容器，然后使用 `apt-get`
    安装了一个 Nginx 网络服务器。你想要通过一个快速的 `curl` 命令来测试它是否可以从你的主机访问 `localhost:9005`。
- en: Press Ctrl-P and then Ctrl-Q. Note that it’s not all three keys pressed at once.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 Ctrl-P 然后按下 Ctrl-Q。请注意，不是一次性按下这三个键。
- en: '|  |'
  id: totrans-1453
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re running with `--rm` and detach, the container will still be removed
    once it terminates, either because the command finishes or you stop it manually.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `--rm` 和分离运行，容器在终止时仍然会被删除，无论是命令完成还是你手动停止它。
- en: '|  |'
  id: totrans-1456
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**DISCUSSION**'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This technique is useful if you’ve started a container but perhaps forgot to
    start it in the background, as shown in [technique 2](kindle_split_011.xhtml#ch02sb03).
    It also allows you to freely attach and detach from containers if you want to
    check how they’re doing or provide some input.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经启动了一个容器，但可能忘记在后台启动它，这种技术很有用，就像在[技术 2](kindle_split_011.xhtml#ch02sb03)中展示的那样。它还允许你在需要检查容器状态或提供一些输入时，自由地连接和断开容器。
- en: '|  |'
  id: totrans-1459
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1460
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using Portainer to manage your Docker daemon**'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 Portainer 管理你的 Docker 守护进程**'
- en: When demonstrating Docker, it can be difficult to demonstrate how containers
    and images differ—lines on a terminal aren’t visual. In addition, the Docker command-line
    tools can be unfriendly if you want to kill and remove specific containers out
    of many. This problem has been solved with the creation of a point-and-click tool
    for managing the images and containers on your host.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 当演示 Docker 时，很难演示容器和镜像之间的区别——终端上的线条不是可视的。此外，如果你想要从许多容器中杀死和删除特定的容器，Docker 的命令行工具可能不太友好。这个问题通过创建一个用于管理主机上镜像和容器的点击工具得到了解决。
- en: '**PROBLEM**'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to manage containers and images on your host without using the CLI.
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在主机上管理容器和镜像，而不使用 CLI。
- en: '**SOLUTION**'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use Portainer, a tool created by one of the core contributors to Docker.
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Portainer，这是 Docker 的核心贡献者之一创建的工具。
- en: 'Portainer started out life as DockerUI, and you can read about it and find
    the source at [https://github.com/portainer/portainer](https://github.com/portainer/portainer).
    Because there are no prerequisites, you can jump straight to running it:'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: Portainer最初是DockerUI，您可以在[https://github.com/portainer/portainer](https://github.com/portainer/portainer)上阅读关于它的内容并找到源代码。因为没有先决条件，您可以直接跳到运行它：
- en: '[PRE113]'
  id: totrans-1468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: This will start the portainer container in the background. If you now visit
    http://localhost:9000, you’ll see the dashboard giving you at-a-glance information
    for Docker on your computer.
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在后台启动Portainer容器。如果您现在访问http://localhost:9000，您将看到仪表板，它为您提供了计算机上Docker的快速信息。
- en: Container management functionality is probably one of the most useful pieces
    of functionality here—go to the Containers page, and you’ll see your running containers
    listed (including the portainer container), with an option to display all containers.
    From here you can perform bulk operations on containers (such as killing them)
    or click on a container name to dive into more detail about the container and
    perform individual operations relevant to that container. For example, you’ll
    be shown the option to remove a running container.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 容器管理功能可能是这里最有用的功能之一——转到容器页面，您将看到正在运行的容器列表（包括Portainer容器），并有一个显示所有容器的选项。从这里，您可以执行容器的批量操作（例如终止它们）或点击容器名称以深入了解容器并执行与该容器相关的单个操作。例如，您将看到移除正在运行的容器的选项。
- en: The Images page looks fairly similar to the Containers page and also allows
    you to select multiple images and perform bulk operations on them. Clicking on
    the image ID offers some interesting options, such as creating a container from
    the image and tagging the image.
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 图片页面看起来与容器页面相当相似，也允许您选择多个图片并对它们执行批量操作。点击图片ID会提供一些有趣的选择，例如从图片创建容器和标记图片。
- en: Remember that Portainer may lag behind official Docker functionality—if you
    want to use the latest and greatest functionality, you may be forced to resort
    to the command line.
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Portainer可能落后于官方Docker功能——如果您想使用最新和最好的功能，您可能被迫求助于命令行。
- en: '**DISCUSSION**'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Portainer is one of many interfaces available for Docker, and it’s one of the
    most popular, with many features and active development. As one example, you can
    use it to manage remote machines, perhaps after starting containers on them with
    [technique 32](kindle_split_015.xhtml#ch05sb05).
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: Portainer是许多Docker接口之一，也是最受欢迎的之一，具有许多功能和活跃的开发。作为一个例子，您可以使用它来管理远程机器，也许是在它们上启动容器后使用[技术32](kindle_split_015.xhtml#ch05sb05)。
- en: '|  |'
  id: totrans-1475
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1476
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Generating a dependency graph of your Docker images**'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成Docker镜像的依赖关系图**'
- en: The file-layering system in Docker is an immensely powerful idea that can save
    space and make building software much quicker. But once you start using a lot
    of images, it can be difficult to understand how your images are related. The
    `docker images -a` command will return a list of all the layers on your system,
    but this isn’t a user-friendly way to comprehend these relationships—it’s much
    easier to visualize the relationships between your images by creating a tree of
    them as an image using Graphviz.
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的文件分层系统是一个极其强大的想法，它可以节省空间并使构建软件更快。但是，一旦您开始使用大量图片，理解您的图片之间的关系可能会变得困难。`docker
    images -a`命令将返回系统上所有层的列表，但这并不是一个用户友好的方式来理解这些关系——通过使用Graphviz创建它们的树状图来可视化这些关系要容易得多。
- en: This is also a demonstration of Docker’s power to make complicated tasks simpler.
    Installing all the components to produce the image on a host machine would previously
    have involved a long series of error-prone steps, but with Docker it can be turned
    into a single portable command that’s far less likely to fail.
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是Docker使复杂任务变得简单的力量的一个展示。在主机机器上安装所有组件以生成图片以前可能需要一系列冗长且容易出错的操作，但使用Docker，它可以变成一个单一的便携式命令，失败的可能性要小得多。
- en: '**PROBLEM**'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to visualize a tree of the images stored on your host.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 您想可视化存储在主机上的图片树。
- en: '**SOLUTION**'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use an image that we’ve created (based on one by CenturyLink Labs) with this
    functionality to output a PNG or get a web view. This image contains scripts that
    use Graphviz to generate the PNG image file.
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们创建的具有此功能的图片（基于CenturyLink Labs的一个版本）以输出PNG或获取网页视图。此图片包含使用Graphviz生成PNG图像文件的脚本。
- en: This technique uses the Docker image at `dockerinpractice/docker-image-graph`.
    This image may go out of date over time and stop working, so you may want to run
    the following commands to ensure it’s up to date.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术使用 `dockerinpractice/docker-image-graph` 的 Docker 镜像。这个镜像可能会随着时间的推移而过时，停止工作，因此你可能需要运行以下命令来确保它是最新的。
- en: Listing 6.1\. Building an up-to-date docker-image-graph image (optional)
  id: totrans-1485
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.1\. 构建最新的 docker-image-graph 镜像（可选）
- en: '[PRE114]'
  id: totrans-1486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: All you need to do in your `run` command is mount the Docker server socket and
    you’re good to go, as the next listing shows.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `run` 命令中，你只需要挂载 Docker 服务器套接字，然后就可以开始了，正如下一个列表所示。
- en: Listing 6.2\. Generating an image of your layer tree
  id: totrans-1488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.2\. 生成你的层树镜像
- en: '[PRE115]'
  id: totrans-1489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '***1*** **Removes the container when the image is produced**'
  id: totrans-1490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在生成镜像时删除容器**'
- en: '***2*** **Mounts the Docker server’s Unix domain socket so you can access the
    Docker server from within the container. If you’ve changed the default for the
    Docker daemon, this won’t work.**'
  id: totrans-1491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **挂载 Docker 服务器的 Unix 域套接字，以便你可以在容器内访问 Docker 服务器。如果你已经更改了 Docker 守护进程的默认设置，这将不起作用。**'
- en: '***3*** **Specifies an image and produces a PNG as an artifact**'
  id: totrans-1492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **指定一个镜像并生成一个 PNG 作为输出**'
- en: '[Figure 6.2](#ch06fig02) shows a PNG of an image tree from one of our machines.
    You can see from this figure that the node and golang:1.3 images share a common
    root, and that the golang:runtime only shares the global root with the golang:1.3
    image. Similarly, the mesosphere image is built from the same root as the ubuntu-upstart
    image.'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6.2](#ch06fig02) 显示了我们机器上的一个镜像树的 PNG 图像。你可以从这张图中看出，节点和 golang:1.3 镜像共享一个共同的根，而
    golang:runtime 只与 golang:1.3 镜像共享全局根。同样，mesosphere 镜像是基于与 ubuntu-upstart 镜像相同的根构建的。'
- en: Figure 6.2\. Image tree diagram
  id: totrans-1494
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.2\. 镜像树图
- en: '![](Images/06fig02_alt.jpg)'
  id: totrans-1495
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/06fig02_alt.jpg)'
- en: You may be wondering what the global root node on the tree is. This is the *scratch*
    pseudo-image, which is exactly 0 bytes in size.
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道树上的全局根节点是什么。这是 *scratch* 伪镜像，大小正好为 0 字节。
- en: '**DISCUSSION**'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: When you start building more Docker images, perhaps as part of continuous delivery
    in [chapter 9](kindle_split_020.xhtml#ch09), it can be overwhelming to keep track
    of the history of an image and what it’s built on. This can be particularly important
    if you’re trying to speed up your delivery by sharing more layers to optimize
    for size. Periodically pulling all your images and generating a graph can be a
    great way to keep track.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始构建更多的 Docker 镜像时，也许作为第 9 章（kindle_split_020.xhtml#ch09）中持续交付的一部分，跟踪镜像的历史和它基于什么构建可能会变得令人不知所措。如果你试图通过共享更多层来优化大小以加快交付速度，这尤其重要。定期拉取所有镜像并生成图表可以是一种很好的跟踪方法。
- en: '|  |'
  id: totrans-1499
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1500
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Direct action: Executing commands on your container**'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: '**直接操作：在容器上执行命令**'
- en: In the early days of Docker, many users added SSH servers to their images so
    that they could access them with a shell from outside. This was frowned upon by
    Docker, as it treated the container as a VM (and we know that containers aren’t
    VMs) and added process overhead to a system that shouldn’t need it. Many objected
    that once started, there was no easy way to get into a container. As a result,
    Docker introduced the `exec` command, which was a much neater solution to the
    problem of affecting and inspecting the internals of containers once started.
    It’s this command that we’ll discuss here.
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 的早期阶段，许多用户向他们的镜像添加了 SSH 服务器，以便他们可以从外部使用 shell 访问它们。Docker 对此持批评态度，因为它将容器视为虚拟机（我们知道容器不是虚拟机），并为不需要的系统增加了进程开销。许多人反对说，一旦启动，就没有简单的方法进入容器。因此，Docker
    引入了 `exec` 命令，这是一个更整洁的解决方案，用于在容器启动后影响和检查其内部结构。我们在这里讨论的就是这个命令。
- en: '**PROBLEM**'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to perform commands on a running container.
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在运行的容器上执行命令。
- en: '**SOLUTION**'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the `docker exec` command.
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker exec` 命令。
- en: The following command starts a container in the background (with `-d`) and tells
    it to sleep forever (do nothing). We’ll name this command `sleeper`.
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令在后台启动一个容器（使用 `-d`）并告诉它永远睡眠（什么也不做）。我们将这个命令命名为 `sleeper`。
- en: '[PRE116]'
  id: totrans-1508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Now that you’ve started a container, you can perform various actions on it using
    Docker’s `exec` command. The command can be viewed as having three basic modes,
    listed in [table 6.1](#ch06table01).
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经启动了一个容器，你可以使用 Docker 的 `exec` 命令对它执行各种操作。这个命令可以被视为有三个基本模式，如 [表 6.1](#ch06table01)
    中列出。
- en: Table 6.1\. Docker `exec` modes
  id: totrans-1510
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 6.1\. Docker `exec` 模式
- en: '| **Mode** | **Description** |'
  id: totrans-1511
  prefs: []
  type: TYPE_TB
  zh: '| **模式** | **描述** |'
- en: '| --- | --- |'
  id: totrans-1512
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Basic | Runs the command in the container synchronously on the command line
    |'
  id: totrans-1513
  prefs: []
  type: TYPE_TB
  zh: '| 基本 | 在容器中同步地在命令行上运行命令 |'
- en: '| Daemon | Runs the command in the background on the container |'
  id: totrans-1514
  prefs: []
  type: TYPE_TB
  zh: '| 守护进程 | 在容器后台运行命令 |'
- en: '| Interactive | Runs the command and allows the user to interact with it |'
  id: totrans-1515
  prefs: []
  type: TYPE_TB
  zh: '| 交互式 | 运行命令并允许用户与之交互 |'
- en: First we’ll cover the basic mode. The following command runs an `echo` command
    inside our `sleeper` container.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍基本模式。以下命令在我们的`sleeper`容器内运行一个`echo`命令。
- en: '[PRE117]'
  id: totrans-1517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Note that the structure of this command is very similar to the `docker run`
    command, but instead of the ID of an image, we give it the ID of a running container.
    The `echo` command refers to the echo binary within the container, not outside.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此命令的结构与`docker run`命令非常相似，但不同的是，我们给出的是正在运行的容器的ID，而不是镜像的ID。`echo`命令指的是容器内的echo二进制，而不是外部。
- en: 'Daemon mode runs the command in the background; you won’t see the output in
    your terminal. This might be useful for regular housekeeping tasks, where you
    want to fire the command and forget, such as cleaning up log files:'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程模式在后台运行命令；您在终端中看不到输出。这可能对定期维护任务很有用，例如清理日志文件，您只需运行命令然后忘记：
- en: '[PRE118]'
  id: totrans-1520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '***1*** **The -d flag runs the command as a daemon in the background, like
    with docker run.**'
  id: totrans-1521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **-d标志以守护进程的方式在后台运行命令，类似于docker run。**'
- en: '***2*** **Removes all files that are unchanged in the last seven days and that
    end with “log”**'
  id: totrans-1522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **删除过去七天未更改且以“log”结尾的所有文件**'
- en: '***3*** **Returns immediately, regardless of how long it will take to complete**'
  id: totrans-1523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **立即返回，无论完成所需时间长短**'
- en: 'Finally, we have interactive mode. This allows you to run whatever commands
    you like from within the container. To enable this, you’ll usually want to specify
    that the shell should run interactively, which in the following code is bash:'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有交互模式。这允许您在容器内运行任何您喜欢的命令。要启用此模式，您通常需要指定shell应该以交互式方式运行，在以下代码中是bash：
- en: '[PRE119]'
  id: totrans-1525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The `-i` and `-t` arguments do the same thing you’re familiar with from `docker
    run`—they make the command interactive and set up a TTY device so shells will
    function correctly. After running this, you’ll have a prompt running inside the
    container.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i`和`-t`参数与您在`docker run`中熟悉的参数做相同的事情——它们使命令交互式，并设置一个TTY设备，以便shell可以正确运行。运行此命令后，您将在容器内看到一个提示符正在运行。'
- en: '**DISCUSSION**'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Jumping into a container is an essential debugging step when something is going
    wrong, or if you want to figure out what a container is doing. It’s often not
    possible to use the attach and detach method enabled by [technique 44](#ch06sb05)
    because processes in containers are typically run in the foreground, making it
    impossible to get access to a shell prompt. Because `exec` allows you to specify
    the binary you want to run, this isn’t an issue ... as long as the container filesystem
    actually has the binary you want to run.
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现问题时，进入容器是一个基本的调试步骤，或者如果您想了解容器正在做什么。通常不可能使用[技术44](#ch06sb05)启用的附加和分离方法，因为容器中的进程通常在前台运行，这使得无法访问shell提示符。因为`exec`允许您指定要运行的二进制文件，所以这不是问题...只要容器文件系统实际上有您要运行的二进制文件。
- en: In particular, if you’ve used [technique 58](kindle_split_017.xhtml#ch07sb11)
    to create a container with a single binary, you won’t be able to start a shell.
    In this case you may want to stick with [technique 57](kindle_split_017.xhtml#ch07sb10)
    as a low-overhead way to permit `exec`.
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，如果您已经使用[技术58](kindle_split_017.xhtml#ch07sb11)创建了一个包含单个二进制的容器，您将无法启动一个shell。在这种情况下，您可能希望坚持使用[技术57](kindle_split_017.xhtml#ch07sb10)作为低开销的方式来允许`exec`。
- en: '|  |'
  id: totrans-1530
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1531
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Are you in a Docker container?**'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: '**您是否在一个Docker容器中？**'
- en: When creating containers, it’s common to put logic inside shell scripts rather
    than trying to directly write the script in a Dockerfile. Or you may have assorted
    scripts for use while the container is running. Either way, the tasks these perform
    are often carefully customized for use inside a container and can be damaging
    to run on a “normal” machine. In situations like this, it’s useful to have some
    safety rails to prevent accidental execution outside a container.
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建容器时，通常将逻辑放在shell脚本中，而不是直接在Dockerfile中编写脚本。或者您可能有一些在容器运行时使用的脚本。无论如何，这些任务通常针对容器内的使用进行了精心定制，并在“正常”机器上运行可能会造成损害。在这种情况下，有一些安全措施来防止意外在容器外执行是有用的。
- en: '**PROBLEM**'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: Your code needs to know whether you’re operating from within a Docker container.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码需要知道您是否在Docker容器中操作。
- en: '**SOLUTION**'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Check for the existence of the /.dockerenv file. If it exists, you’re likely
    in a Docker container.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 检查/.dockerenv文件是否存在。如果存在，你很可能在一个Docker容器中。
- en: Note that this isn’t a cast-iron guarantee—if anyone, or anything, removed the
    /.dockerenv file, this check could give misleading results. These scenarios are
    unlikely, but at worst you’ll get a false positive with no ill effects; you’ll
    think you’re not in a Docker container and at worst *won’t* run a potentially
    destructive piece of code.
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这并不是一个绝对保证——如果有人或任何东西移除了/.dockerenv文件，这个检查可能会给出误导性的结果。这些情况不太可能发生，但最坏的情况是你会得到一个假阳性，没有任何不良影响；你会认为你不在Docker容器中，在最坏的情况下*不会*运行可能具有破坏性的代码。
- en: A more realistic scenario is that this undocumented behavior of Docker has been
    altered or removed in a newer version of Docker (or you’re using a version from
    before the behavior was first implemented).
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更现实的情况是，Docker的这个未经记录的行为在Docker的新版本中已经被改变或删除（或者你使用的是在行为首次实现之前发布的版本）。
- en: The code might be part of a startup bash script, as in the following listing,
    followed by the remainder of your startup script code.
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能是启动bash脚本的一部分，如下所示，然后是启动脚本代码的其余部分。
- en: Listing 6.3\. Shell script fails if it’s run outside a container
  id: totrans-1541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.3\. 如果在容器外运行，Shell脚本将失败
- en: '[PRE120]'
  id: totrans-1542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Of course, the opposite logic could be used to determine that you are *not*
    running within a container, if that’s your need:'
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以使用相反的逻辑来确定你*不在*容器内运行，如果你有这个需求：
- en: Listing 6.4\. Shell script fails if it’s run inside a container
  id: totrans-1544
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.4\. 如果在容器内运行，Shell脚本将失败
- en: '[PRE121]'
  id: totrans-1545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This example uses bash to determine the existence of the file, but the vast
    majority of programming languages will have their own ways to determine the existence
    of files on the container (or host) filesystem.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用bash来确定文件的存在，但绝大多数编程语言都会有自己的方式来确定容器（或主机）文件系统上文件的存在。
- en: '**DISCUSSION**'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: You may be wondering how often this situation arises. It happens often enough
    for it to be a regular discussion point on Docker forums, where somewhat religious
    arguments flare up about whether this is a valid use case, or whether something
    else in your application’s design is amiss.
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道这种情况发生的频率。这种情况经常发生，足以成为Docker论坛上的常规讨论点，在那里关于这是否是一个有效用例，或者你的应用程序设计中的其他方面是否有问题的宗教式争论会爆发。
- en: Leaving these discussions aside, you can easily end up in a situation where
    you need to switch your code path depending on whether you’re in a Docker container
    or not. One such example we’ve experienced is when using a Makefile to build a
    container.
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些讨论放在一边，你可能会轻易地陷入需要根据是否在Docker容器中切换代码路径的情况。我们遇到的一个例子是使用Makefile构建容器。
- en: '|  |'
  id: totrans-1550
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-1551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: You can configure your machine to let you run Docker without `sudo`.
  id: totrans-1552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以配置你的机器，让你可以在不使用`sudo`的情况下运行Docker。
- en: Use the built-in Docker commands to clean up unused containers and volumes.
  id: totrans-1553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置的Docker命令来清理未使用的容器和卷。
- en: External tools can be used to expose information about your containers in new
    ways.
  id: totrans-1554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用外部工具以新的方式公开有关你的容器的信息。
- en: The `docker exec` command is the correct way to get inside a running container—resist
    installing SSH.
  id: totrans-1555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker exec`命令是进入正在运行的容器的正确方式——请抵制安装SSH。'
- en: 'Chapter 7\. Configuration management: Getting your house in order'
  id: totrans-1556
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章\. 配置管理：整理你的环境
- en: '|  |'
  id: totrans-1557
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Managing the building of images using Dockerfiles
  id: totrans-1559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Dockerfile管理镜像构建
- en: Building images using traditional configuration management tools
  id: totrans-1560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用传统的配置管理工具构建镜像
- en: Managing the secret information required to build images
  id: totrans-1561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理构建镜像所需的秘密信息
- en: Reducing the size of your images for faster, lighter, and safer delivery
  id: totrans-1562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减小镜像大小以实现更快、更轻、更安全的交付
- en: '|  |'
  id: totrans-1563
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Configuration management is the art of managing your environments so that they’re
    stable and predictable. Tools such as Chef and Puppet have attempted to alleviate
    the sysadmin burden of managing multiple machines. To an extent, Docker also reduces
    this burden by making the software environment isolated and portable. Even so,
    configuration management techniques are required to produce Docker images, and
    it’s an important topic to recognize.
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理是管理你的环境，使其稳定和可预测的艺术。例如，Chef和Puppet等工具试图减轻系统管理员管理多台机器的负担。在一定程度上，Docker通过使软件环境隔离和可移植来减少这种负担。即便如此，仍然需要配置管理技术来生成Docker镜像，这是一个重要的认识点。
- en: By the end of the chapter, you’ll know how to integrate your existing tools
    with Docker, solve some Docker-specific problems like removing secrets from layers,
    and follow the best practice of minimizing your final image. As you get more experience
    with Docker, these techniques will give you the ability to build images for whatever
    configuration needs you’re trying to satisfy.
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将知道如何将现有工具与 Docker 集成，解决一些 Docker 特定的问题，如从层中删除机密，并遵循最小化最终镜像的最佳实践。随着你对
    Docker 的经验越来越丰富，这些技术将使你能够为满足任何配置需求构建镜像。
- en: 7.1\. Configuration management and Dockerfiles
  id: totrans-1566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1\. 配置管理和 Dockerfile
- en: Dockerfiles are considered to be the standard way of building Docker images.
    Dockerfiles are often confusing in terms of what they mean for configuration management.
    You may have many questions (particularly if you have experience with other configuration
    management tools), such as
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 被认为是构建 Docker 镜像的标准方式。在配置管理方面，Dockerfile 常常令人困惑。你可能会有很多问题（尤其是如果你有其他配置管理工具的经验），例如
- en: What happens if the base image changes?
  id: totrans-1568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果基础镜像发生变化会怎样？
- en: What happens if the packages I’m installing change and I rebuild?
  id: totrans-1569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我安装的软件包发生变化并且我重新构建会发生什么？
- en: Does this replace Chef/Puppet/Ansible?
  id: totrans-1570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是否取代了 Chef/Puppet/Ansible？
- en: 'In fact, Dockerfiles are quite simple: starting from a given image, a Dockerfile
    specifies a series of shell commands and meta-instructions to Docker, which will
    produce the desired final image.'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Dockerfile 非常简单：从一个给定的镜像开始，Dockerfile 指定了一系列 shell 命令和元指令给 Docker，这将产生所需的最终镜像。
- en: Dockerfiles provide a common, simple, and universal language for provisioning
    Docker images. Within them, you can use anything you like to reach the desired
    end state. You could call out to Puppet, copy in another script, or copy in an
    entire filesystem!
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 为提供 Docker 镜像提供了一个通用、简单和通用的语言。在它们内部，你可以使用任何你喜欢的方式来达到预期的最终状态。你可以调用
    Puppet，复制另一个脚本，或者复制整个文件系统！
- en: First we’ll consider how you can deal with some minor challenges that Dockerfiles
    bring with them. Then we’ll move on to the meatier issues we just outlined.
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将考虑你如何处理 Dockerfile 带来的某些小挑战。然后，我们将继续讨论我们刚刚概述的更复杂的问题。
- en: '|  |'
  id: totrans-1574
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Creating reliable bespoke tools with ENTRYPOINT**'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 `ENTRYPOINT` 创建可靠的定制工具**'
- en: Docker’s potential for allowing you to run commands *anywhere* means that complex
    bespoke instructions or scripts that are run on the command line can be preconfigured
    and wrapped up into a packaged tool.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 允许你在任何地方运行命令的潜力意味着，复杂的定制指令或脚本可以在命令行上预先配置并封装成打包的工具。
- en: The easily misunderstood `ENTRYPOINT` instruction is a vital part of this. You’re
    going to see how it enables you to create Docker images as tools that are well-encapsulated,
    clearly defined, and flexible enough to be useful.
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 容易被误解的 `ENTRYPOINT` 指令是这一过程的关键部分。你将看到它是如何使你能够创建封装良好、定义清晰且足够灵活以供使用的 Docker 镜像的。
- en: '**PROBLEM**'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to define the command the container will run, but leave the command’s
    arguments up to the user.
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要定义容器将运行的命令，但将命令的参数留给用户。
- en: '**SOLUTION**'
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the Dockerfile `ENTRYPOINT` instruction.
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Dockerfile 的 `ENTRYPOINT` 指令。
- en: As a demonstration, we’ll imagine a simple scenario in a corporation where a
    regular admin task is to clean up old log files. Often this is prone to error,
    and people accidentally delete the wrong things, so we’re going to use a Docker
    image to reduce the risk of problems arising.
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: 作为演示，我们将想象一个简单的企业场景，其中常规管理员任务之一是清理旧的日志文件。这通常容易出错，人们会不小心删除错误的东西，因此我们将使用 Docker
    镜像来降低出现问题的风险。
- en: The following script (which you should name “clean_log” when you save it) deletes
    logs over a certain number of days old, where the number of days is passed in
    as a command-line option. Create a new folder anywhere with any name you like,
    move into it, and place `clean_log` within it.
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本（你保存时应将其命名为“clean_log”）会删除超过一定天数的日志，天数作为命令行选项传入。在任何地方创建一个新文件夹，取任何你喜欢的名字，进入它，并在其中放置
    `clean_log`。
- en: Listing 7.1\. `clean_log` shell script
  id: totrans-1584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.1\. `clean_log` shell 脚本
- en: '[PRE122]'
  id: totrans-1585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Note that the log cleaning takes place on the /log_dir folder. This folder will
    only exist when you mount it at runtime. You may have also noticed that there’s
    no check for whether an argument has been passed in to the script. The reason
    for this will be revealed as we go through the technique.
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，日志清理发生在 /log_dir 文件夹上。这个文件夹只有在运行时挂载时才会存在。你可能也注意到脚本中没有检查是否传入了参数。原因将在我们通过技术时揭晓。
- en: Now let’s create a Dockerfile in the same directory to create an image, with
    the script running as the defined command, or *entrypoint*.
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在同一目录下创建一个 Dockerfile 来创建一个图像，其中脚本作为定义的命令或*入口点*运行。
- en: Listing 7.2\. Creating an image with the `clean_log` script
  id: totrans-1588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.2\. 使用 `clean_log` 脚本创建图像
- en: '[PRE123]'
  id: totrans-1589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '***1*** **Adds the previous corporate clean_log script to the image**'
  id: totrans-1590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将之前的公司 clean_log 脚本添加到图像中**'
- en: '***2*** **Defines the entrypoint for this image as being the clean_log script**'
  id: totrans-1591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **定义此图像的入口点为 clean_log 脚本**'
- en: '***3*** **Defines the default argument for the entrypoint command (7 days)**'
  id: totrans-1592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **定义入口点命令的默认参数（7天）**'
- en: '|  |'
  id: totrans-1593
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1594
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: You’ll observe that we generally prefer the array form for `CMD` and `ENTRYPOINT`
    (for example, `CMD ["/usr/bin/command"]`) over the shell form (`CMD /usr/bin/command`).
    This is because the shell form automatically prepends a `/bin/bash -c` command
    to the command you supply, which can result in unexpected behavior. Sometimes,
    however, the shell form is more useful (see [technique 55](#ch07sb08)).
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们通常更喜欢 `CMD` 和 `ENTRYPOINT` 的数组形式（例如，`CMD ["/usr/bin/command"]`），而不是 shell
    形式（`CMD /usr/bin/command`）。这是因为 shell 形式会自动将一个 `/bin/bash -c` 命令添加到你提供的命令之前，这可能会导致意外的行为。然而，有时
    shell 形式更有用（参见[技术 55](#ch07sb08)）。
- en: '|  |'
  id: totrans-1596
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The difference between `ENTRYPOINT` and `CMD` often confuses people. The key
    point to understand is that an entrypoint will always be run when the image is
    started, even if a command is supplied to the `docker run` invocation. If you
    try to supply a command, it will add that as an argument to the entrypoint, replacing
    the default defined in the `CMD` instruction. You can only override the entrypoint
    if you explicitly pass in an `--entrypoint` flag to the `docker run` command.
    This means that running the image with a /bin/bash command won’t give you a shell;
    rather, it will supply /bin/bash as an argument to the clean_log script.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT` 和 `CMD` 之间的区别常常让人困惑。理解的关键点是，当图像启动时，入口点总是会运行，即使你在 `docker run`
    调用中提供了命令。如果你尝试提供命令，它将作为参数添加到入口点，替换 `CMD` 指令中定义的默认值。你只能通过在 `docker run` 命令中显式传递
    `--entrypoint` 标志来覆盖入口点。这意味着使用 `/bin/bash` 命令运行图像不会给你一个 shell；相反，它将 `/bin/bash`
    作为参数提供给 clean_log 脚本。'
- en: 'The fact that a default argument is defined by the `CMD` instruction means
    that the argument supplied need not be checked. Here’s how you might build and
    invoke this tool:'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `CMD` 指令定义了默认参数，因此提供的参数不需要检查。以下是如何构建和调用此工具的方法：
- en: '[PRE124]'
  id: totrans-1599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: After building the image, the image is invoked by mounting `/var/log/myapplogs`
    into the directory the script will use and passing 365 to remove log files over
    a year old, rather than a week.
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建图像后，通过将 `/var/log/myapplogs` 挂载到脚本将使用的目录，并传递 365 来删除一年以上的日志文件，而不是一周，来调用图像。
- en: 'If someone tries to use the image incorrectly by not specifying a number of
    days, they’ll be given an error message:'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人试图不指定天数而错误地使用该图像，他们将会收到一个错误信息：
- en: '[PRE125]'
  id: totrans-1602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '**DISCUSSION**'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This example was quite trivial, but you can imagine that a corporation could
    apply it to centrally manage scripts used across its estate, such that they could
    be maintained and distributed safely with a private registry.
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子相当简单，但你可以想象一个公司可以将它应用于在其整个企业中集中管理脚本，这样它们就可以通过私有仓库安全地维护和分发。
- en: You can view and use the image we created in this technique at dockerinpractice/
    log-cleaner on the Docker Hub.
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Docker Hub 的 dockerinpractice/log-cleaner 上查看和使用我们在此技术中创建的图像。
- en: '|  |'
  id: totrans-1606
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1607
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Avoiding package drift by specifying versions**'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过指定版本避免包漂移**'
- en: Dockerfiles have simple syntax and limited functionality, they can help greatly
    to clarify your build’s requirements, and they can aid the stability of image
    production, but they can’t guarantee repeatable builds. We’re going to explore
    one of the numerous approaches to solving this problem and reducing the risk of
    nasty surprises when the underlying package management dependencies change.
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile具有简单的语法和有限的功能，它们可以极大地帮助阐明构建的要求，并有助于提高镜像生产的稳定性，但它们不能保证可重复的构建。我们将探讨解决此问题的多种方法之一，以减少当底层包管理依赖项发生变化时出现意外风险。
- en: This technique is helpful for avoiding those “it worked yesterday” moments,
    and it may be familiar if you’ve used classic configuration management tools.
    Building Docker images is fundamentally quite different from maintaining a server,
    but some hard-learned lessons are still applicable.
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术有助于避免那些“昨天还工作过”的时刻，如果您使用过经典配置管理工具，可能会觉得这种方法很熟悉。构建Docker镜像与维护服务器在本质上相当不同，但一些经验教训仍然适用。
- en: '|  |'
  id: totrans-1611
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1612
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This technique will only work for Debian-based images, such as Ubuntu. Yum users
    could find analogous techniques to make it work under their package manager.
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术仅适用于基于Debian的镜像，例如Ubuntu。Yum用户可以在他们的包管理器下找到类似的技术来实现。
- en: '|  |'
  id: totrans-1614
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**PROBLEM**'
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to ensure that your deb packages are the versions you expect.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 您想确保您的deb软件包是您期望的版本。
- en: '**SOLUTION**'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Run a script to capture the versions of all dependent packages on a system that’s
    set up as you desire. Then install the specific versions in your Dockerfile, to
    ensure the versions are exactly as you expect.
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一个脚本来捕获您按需设置的系统的所有依赖包的版本。然后在您的Dockerfile中安装特定的版本，以确保版本与您期望的完全一致。
- en: 'A basic check for versions can be performed with an `apt-cache` call on a system
    you’ve verified as OK:'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`apt-cache`调用在您已验证为OK的系统上执行基本版本检查：
- en: '[PRE126]'
  id: totrans-1620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'You can then specify the version in your Dockerfile like this:'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在Dockerfile中这样指定版本：
- en: '[PRE127]'
  id: totrans-1622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: This may be enough for your needs. What this doesn’t do is guarantee that all
    dependencies from this version of nginx have the same versions that you originally
    verified.
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能足以满足您的需求。但这并不能保证nginx这个版本的依赖项与您最初验证的版本相同。
- en: 'You can get information about all of those dependencies by adding a `--recurse`
    flag to the argument:'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在参数中添加`--recurse`标志来获取所有这些依赖项的信息：
- en: '[PRE128]'
  id: totrans-1625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The output of this command is intimidatingly large, so getting a list of version
    requirements is tricky. Fortunately, we maintain a Docker image (what else?) to
    make this easier for you. It outputs the `RUN` line you need to put into your
    Dockerfile to ensure that the versions of all the dependencies are correct.
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出非常大，因此获取版本要求列表很困难。幸运的是，我们维护了一个Docker镜像（还有什么别的？），这使得这个过程更容易。它输出您需要放入Dockerfile中的`RUN`行，以确保所有依赖项的版本都是正确的。
- en: '[PRE129]'
  id: totrans-1627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: At some point your build will fail because a version is no longer available.
    When this happens, you’ll be able to see which package has changed and review
    the change to determine whether it’s OK for your particular image’s needs.
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，您的构建将因为某个版本不再可用而失败。当这种情况发生时，您将能够看到哪个软件包已更改，并审查更改以确定它是否适合您特定镜像的需求。
- en: 'This example assumes that you’re using ubuntu:14.04\. If you’re using a different
    flavor of Debian, fork the repo and change the Dockerfile’s `FROM` instruction
    and build it. The repo is available here: [https://github.com/docker-in-practice/get-versions.git](https://github.com/docker-in-practice/get-versions.git).'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例假设您正在使用ubuntu:14.04。如果您使用的是不同的Debian版本，请fork仓库并更改Dockerfile的`FROM`指令，然后构建它。仓库在此处可用：[https://github.com/docker-in-practice/get-versions.git](https://github.com/docker-in-practice/get-versions.git)。
- en: Although this technique can help you with the stability of your build, it does
    nothing in terms of security, because you’re still downloading packages from a
    repository you have no direct control over.
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种技术可以帮助您提高构建的稳定性，但在安全性方面却无能为力，因为您仍然在下载您无法直接控制的仓库中的软件包。
- en: '**DISCUSSION**'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This technique may seem like a lot of effort to ensure that a text editor is
    exactly as you expect it to be. In the field, though, package drift can result
    in bugs that are incredibly difficult to pin down. Libraries and applications
    can move in subtle ways in builds from one day to the next, and figuring out what
    happened can ruin your day.
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可能看起来需要付出很多努力来确保文本编辑器完全符合你的预期。然而，在实际应用中，包的漂移可能导致难以追踪的bug。库和应用程序在构建过程中可能会以微妙的方式发生变化，弄清楚发生了什么可能会让你的日子变得糟糕。
- en: By pinning down the versions as tightly as possible within your Dockerfile,
    you ensure that one of two things happens. Either the build succeeds and your
    software will behave the same way as it did yesterday, or it fails to build because
    a piece of software has changed, and you’ll need to retest your development pipeline.
    In the second case, you’re aware of what’s changed, and you can narrow down any
    failures that ensue to that specific change.
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Dockerfile中尽可能紧密地锁定版本，你可以确保以下两种情况之一发生。要么构建成功，你的软件将像昨天一样表现，要么由于某个软件发生变化而无法构建，你需要重新测试你的开发流程。在后一种情况下，你会知道发生了什么变化，并且可以将任何随之而来的失败缩小到那个特定的变化。
- en: The point is that when you’re doing continuing builds and integrations, reducing
    the number of variables that change reduces the time spent debugging. That translates
    to money for your business.
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是，当你进行持续构建和集成时，减少变化的变量数量可以减少调试时间。这对你企业的资金来说意味着节省。
- en: '|  |'
  id: totrans-1635
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-1636
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Replacing text with perl -p-i -e**'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用perl -p-i -e替换文本**'
- en: It’s not uncommon when building images with Dockerfiles that you’ll need to
    replace specific items of text across multiple files. Numerous solutions for this
    exist, but we’ll introduce a somewhat unusual favorite that’s particularly handy
    in Dockerfiles.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Dockerfile构建镜像时，你通常需要在多个文件中替换特定的文本项。存在许多解决方案，但我们将介绍一个相对不寻常但特别适用于Dockerfile的解决方案。
- en: '**PROBLEM**'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to alter specific lines in files during a build.
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望在构建过程中修改文件中的特定行。
- en: '**SOLUTION**'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the `perl -p -i -e` command.
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`perl -p -i -e`命令。
- en: 'We recommend this command for a few reasons:'
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐这个命令有几个原因：
- en: Unlike `sed -i` (a command with a similar syntax and effect), this command works
    on multiple files out of the box, even if it encounters a problem with one of
    the files. This means you can run it across a directory with a `'*'` glob pattern
    without fear that it will suddenly break when a directory is added in a later
    revision of the package.
  id: totrans-1644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`sed -i`（一个语法和效果相似的命令）不同，这个命令默认就可以在多个文件上工作，即使它遇到其中一个文件的问题。这意味着你可以在目录中使用`'*'`通配符模式运行它，而不用担心在包的后续版本中添加目录时它会突然中断。
- en: As with `sed`, you can replace the forward slashes in the search and replace
    commands with other characters.
  id: totrans-1645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与`sed`一样，你可以在搜索和替换命令中用其他字符替换正斜杠。
- en: It’s easy to remember (we refer to it as the “perl pie” command).
  id: totrans-1646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆起来很容易（我们称之为“perl pie”命令）。
- en: '|  |'
  id: totrans-1647
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-1648
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This technique assumes an understanding of regular expressions. If you’re not
    familiar with regular expressions, there are plenty of websites available to help
    you.
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术假设你对正则表达式有所了解。如果你不熟悉正则表达式，有很多网站可以帮助你。
- en: '|  |'
  id: totrans-1650
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Here’s a typical example of this command’s use:'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个命令典型使用的一个例子：
- en: '[PRE130]'
  id: totrans-1652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: In this command, the `-p` flag asks Perl to assume a loop while it processes
    all the lines seen. The `-i` flag asks Perl to update the matched lines in place,
    and the `-e` flag asks Perl to treat the supplied string as a Perl program. The
    `s` is an instruction to Perl to search and replace strings as they’re matched
    in the input. Here `127.0.0.1` is replaced with `0.0.0.0`. The `g` modifier ensures
    that all matches are updated, not just the first on any given line. Finally, the
    asterisk (`*`) applies the update to all files in this directory.
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，`-p`标志让Perl在处理所有看到的行时假设一个循环。`-i`标志让Perl就地更新匹配的行，而`-e`标志让Perl将提供的字符串视为Perl程序。`s`是Perl的一个指令，用于搜索和替换输入中匹配的字符串。在这里，`127.0.0.1`被替换为`0.0.0.0`。`g`修饰符确保所有匹配项都被更新，而不仅仅是任何给定行的第一个匹配项。最后，星号（`*`）将更新应用于此目录中的所有文件。
- en: The preceding command performs a fairly common action for Docker containers.
    It replaces the standard localhost IP address (`127.0.0.1`) with one that indicates
    “any” IPv4 address (`0.0.0.0`) when used as an address to listen on. Many applications
    restrict access to the localhost IP by only listening on that address, and frequently
    you’ll want to change this in their config files to the “any” address because
    you’ll be accessing the application from your host, which appears to the container
    to be an external machine.
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令是Docker容器中一个相当常见的操作。当用作监听地址时，它将标准的localhost IP地址（`127.0.0.1`）替换为指示“任何”IPv4地址（`0.0.0.0`）。许多应用程序通过只监听该地址来限制对localhost
    IP的访问，并且通常你会在它们的配置文件中将地址更改为“任何”地址，因为你会从主机访问应用程序，对于容器来说，主机看起来是一个外部机器。
- en: '|  |'
  id: totrans-1655
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1656
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If an application within a Docker container appears not to be accessible to
    you from the host machine, despite the port being open, it can be worth trying
    to update the addresses to listen on to 0.0.0.0 in the application config file
    and restarting. It may be that the application is rejecting you because you’re
    not coming from its localhost. Using `--net=host` (covered later in [technique
    109](kindle_split_029.xhtml#ch16sb02)) when running your image can help confirm
    this hypothesis.
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Docker容器中的应用程序似乎无法从主机机器访问，尽管端口是开放的，那么尝试在应用程序配置文件中将监听地址更新为`0.0.0.0`并重新启动可能是有价值的。可能是因为应用程序拒绝你，因为你不是从它的localhost来的。在运行镜像时使用`--net=host`（稍后在[技巧109](kindle_split_029.xhtml#ch16sb02)中介绍）可以帮助确认这个假设。
- en: '|  |'
  id: totrans-1658
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Another nice feature of `perl -p -i -e` (and `sed`) is that you can use other
    characters to replace the forward slashes if escaping the slashes gets awkward.
    Here’s a real-world example from one of our scripts that adds some directives
    to the default Apache site file. This awkward command,
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: '`perl -p -i -e`（和`sed`）的另一个不错特性是，如果你在转义斜杠时感到尴尬，可以使用其他字符来替换正斜杠。以下是我们脚本中的一个真实世界示例，该脚本向默认的Apache站点文件添加了一些指令。这个尴尬的命令，'
- en: '[PRE131]'
  id: totrans-1660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'becomes this:'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 变成这样：
- en: '[PRE132]'
  id: totrans-1662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: In the rare cases that you want to match or replace both the `/` and `@` characters,
    you can try other characters such as `|` or `#`.
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，如果你想匹配或替换`/`和`@`字符，你可以尝试其他字符，如`|`或`#`。
- en: '**DISCUSSION**'
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This is one of those tips that applies beyond the world of Docker as much as
    within it. It’s a useful tool to have in your armory.
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在Docker世界内外都适用的技巧。这是你武器库中的一个有用工具。
- en: 'We find this technique particularly useful because of its broad application
    beyond use in Dockerfiles, combined with the ease with which it’s remembered:
    it’s “easy as pie,” if you’ll forgive the pun.'
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现这个技巧特别有用，因为它在Dockerfile中的应用非常广泛，而且易于记忆：如果你不介意这个双关语，那就是“易如反掌”。
- en: '|  |'
  id: totrans-1667
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1668
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Flattening images**'
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: '**简化镜像**'
- en: A consequence of the design of Dockerfiles and their production of Docker images
    is that the final image contains the data state at each step in the Dockerfile.
    In the course of building your images, secrets may need to be copied in to ensure
    the build can work. These secrets may be SSH keys, certificates, or password files.
    Deleting these secrets before committing your image doesn’t provide you with any
    real protection, as they’ll be present in higher layers of the final image. A
    malicious user could easily extract them from the image.
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile的设计及其生成Docker镜像的后果是，最终的镜像包含了Dockerfile中每个步骤的数据状态。在构建镜像的过程中，可能需要复制秘密以确保构建可以工作。这些秘密可能是SSH密钥、证书或密码文件。在提交镜像之前删除这些秘密并不能真正提供保护，因为它们将存在于最终镜像的更高层。恶意用户可以轻易地从镜像中提取它们。
- en: One way of handling this problem is to flatten the resulting image.
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的方法之一是简化生成的镜像。
- en: '**PROBLEM**'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to remove secret information from the layer history of your image.
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要从镜像的层历史中删除秘密信息。
- en: '**SOLUTION**'
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Instantiate a container with the image, export it, import it, and then tag it
    with the original image ID.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该镜像实例化一个容器，导出它，导入它，然后使用原始镜像ID对其进行标记。
- en: To demonstrate a scenario where this could be useful, let’s create a simple
    Dockerfile in a new directory that contains a Big Secret. Run `mkdir secrets &&
    cd secrets` and then create a Dockerfile in that folder with the following contents.
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这种情况可能有用的情况，让我们在一个新目录中创建一个简单的Dockerfile，该目录包含一个“大秘密”。运行`mkdir secrets &&
    cd secrets`，然后在那个文件夹中创建一个包含以下内容的Dockerfile。
- en: Listing 7.3\. A Dockerfile that copies in and deletes a secret
  id: totrans-1677
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.3\. 一个复制并删除秘密的Dockerfile
- en: '[PRE133]'
  id: totrans-1678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '***1*** **Place a file with some secret information within your build.**'
  id: totrans-1679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在你的构建中放置一个包含一些机密信息的文件。**'
- en: '***2*** **Do something with the secret file. This Dockerfile only cats the
    file, but yours might SSH to another server or encrypt that secret within the
    image.**'
  id: totrans-1680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **对包含机密信息的文件进行操作。这个Dockerfile只是简单地显示文件，但你的可能需要SSH到另一个服务器或在镜像中加密那个机密信息。**'
- en: '***3*** **Remove the secret file.**'
  id: totrans-1681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **删除机密文件。**'
- en: Now run `docker build -t mysecret .` to build and tag that Dockerfile.
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`docker build -t mysecret .`来构建和标记该Dockerfile。
- en: 'Once it’s built, you can examine the layers of the resulting Docker image with
    the `docker history` command:'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建完成，你可以使用`docker history`命令检查生成的Docker镜像的层：
- en: '[PRE134]'
  id: totrans-1684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '***1*** **Runs the docker history command against the name of the image you
    created**'
  id: totrans-1685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **运行针对你创建的镜像名称的docker history命令**'
- en: '***2*** **The layer where you removed the secret key**'
  id: totrans-1686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **删除机密密钥的层**'
- en: '***3*** **The layer where you added the secret key**'
  id: totrans-1687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **添加机密密钥的层**'
- en: '***4*** **The layer that added the Debian filesystem. Note that this layer
    is the largest one in the history.**'
  id: totrans-1688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **添加了Debian文件系统的层。请注意，这个层是历史中最大的一个。**'
- en: '***5*** **The scratch (empty) layer**'
  id: totrans-1689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **空层（无内容层）**'
- en: 'Now imagine that you’ve downloaded this image from a public registry. You could
    inspect the layer history and then run the following command to reveal the secret
    information:'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你已经从公共注册表中下载了这个镜像。你可以检查层历史记录，然后运行以下命令来揭示机密信息：
- en: '[PRE135]'
  id: totrans-1691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Here we’ve run a specific layer and instructed it to `cat` the secret key we
    removed at a higher layer. As you can see, the file is accessible.
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们运行了一个特定的层，并指示它`cat`出我们在更高层删除的机密密钥。如你所见，文件是可访问的。
- en: 'Now you have a “dangerous” container with a secret inside that you’ve seen
    can be hacked to reveal its secrets. To make this image safe, you’ll need to *flatten*
    it. This means you’ll keep the same data in the image but remove the intermediate
    layering information. To achieve this, you need to export the image as a trivially
    run container and then re-import and tag the resulting image:'
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个包含机密信息且你已看到可以被黑客攻击以揭示其机密的“危险”容器。为了使这个镜像安全，你需要将其*扁平化*。这意味着你将在镜像中保留相同的数据，但删除中间分层信息。为了实现这一点，你需要将镜像导出为一个简单运行的容器，然后重新导入并标记生成的镜像：
- en: '[PRE136]'
  id: totrans-1694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '***1*** **Runs a trivial command to allow the container to exit quickly, because
    you don’t need it to be running**'
  id: totrans-1695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **运行一个简单的命令以允许容器快速退出，因为你不需要它一直运行**'
- en: '***2*** **Runs docker export, taking a container ID as an argument and outputting
    a TAR file of the filesystem contents. This is piped to docker import, which takes
    a TAR file and creates an image from the contents.**'
  id: totrans-1696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **运行docker export命令，以容器ID作为参数，输出文件系统内容的TAR文件。这个TAR文件被管道传输到docker import命令，该命令接受TAR文件并从内容创建镜像。**'
- en: '***3*** **The docker history output now shows only one layer with the final
    set of files.**'
  id: totrans-1697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **显示最终文件集的唯一层的docker history输出**'
- en: The `-` argument to the `docker import` command indicates that you wish to read
    the TAR file from the command’s standard input. The final argument to `docker
    import` indicates how the imported image should be tagged. In this case you’re
    overwriting the previous tag.
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker import`命令的`-`参数表示你希望从命令的标准输入读取TAR文件。`docker import`命令的最后一个参数表示导入的镜像应该如何标记。在这种情况下，你正在覆盖之前的标记。'
- en: Because there’s now only one layer in the image, there’s no record of the layers
    that contained the secrets. No secrets can now be extracted from the image.
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 因为现在镜像中只有一个层，所以没有包含机密信息的层的记录。现在无法从镜像中提取任何机密信息。
- en: '**DISCUSSION**'
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This technique is useful enough to be re-used at various points throughout this
    book, such as in section 7.3.
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术在本书的多个地方都很有用，例如在第7.3节中。
- en: One point to consider if you’re thinking of using this technique is that the
    benefits of multilayered images on layer caching and download times can be lost.
    If your organization plans carefully around this, this technique can play a role
    in these images’ real-world use.
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑使用这种技术，需要考虑的一点是，多层镜像在层缓存和下载时间上的好处可能会丢失。如果你的组织对此进行周密计划，这种技术可以在这些镜像的实际应用中发挥作用。
- en: '|  |'
  id: totrans-1703
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1704
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Managing foreign packages with Alien**'
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用Alien管理外部包**'
- en: Although most Dockerfile examples in this book (and on the internet) use a Debian-based
    image, the reality of software development means that many people won’t be dealing
    with them exclusively.
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书（以及互联网上）的大多数Dockerfile示例都使用基于Debian的镜像，但软件开发的现实意味着许多人不会仅处理它们。
- en: Fortunately tools exist to help you with this.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，存在一些工具可以帮助你完成这项工作。
- en: '**PROBLEM**'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to install a package from a foreign distribution.
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: 你想从外国发行版安装一个包。
- en: '**SOLUTION**'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use a tool called Alien to convert the package. Alien is embedded into a Docker
    image we’ll use as part of the technique.
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名为 Alien 的工具转换包。Alien 集成到我们将作为技术一部分使用的 Docker 镜像中。
- en: Alien is a command-line utility designed to convert package files between the
    various formats listed in [table 7.1](#ch07table01). On more than one occasion,
    we’ve been required to make packages from foreign package management systems work,
    such as .deb files in CentOS, and .rpm files in non-Red Hat-based systems.
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: Alien 是一个命令行工具，旨在将各种格式之间的包文件进行转换，这些格式列于 [表 7.1](#ch07table01) 中。不止一次，我们被要求使来自外国包管理系统的包工作，例如
    CentOS 中的 .deb 文件，以及非 Red Hat 基础系统中的 .rpm 文件。
- en: Table 7.1\. Package formats supported by Alien
  id: totrans-1713
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 7.1\. Alien 支持的包格式
- en: '| **Extension** | **Description** |'
  id: totrans-1714
  prefs: []
  type: TYPE_TB
  zh: '| **扩展名** | **描述** |'
- en: '| --- | --- |'
  id: totrans-1715
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| .deb | Debian package |'
  id: totrans-1716
  prefs: []
  type: TYPE_TB
  zh: '| .deb | Debian 包 |'
- en: '| .rpm | Red Hat package management |'
  id: totrans-1717
  prefs: []
  type: TYPE_TB
  zh: '| .rpm | Red Hat 包管理 |'
- en: '| .tgz | Slackware gzipped TAR file |'
  id: totrans-1718
  prefs: []
  type: TYPE_TB
  zh: '| .tgz | Slackware 压缩的 TAR 文件 |'
- en: '| .pkg | Solaris PKG package |'
  id: totrans-1719
  prefs: []
  type: TYPE_TB
  zh: '| .pkg | Solaris PKG 包 |'
- en: '| .slp | Stampede package |'
  id: totrans-1720
  prefs: []
  type: TYPE_TB
  zh: '| .slp | Stampede 包 |'
- en: '|  |'
  id: totrans-1721
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1722
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: For the purposes of this technique, Solaris and Stampede packages aren’t fully
    covered. Solaris requires software peculiar to Solaris, and Stampede is an abandoned
    project.
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这项技术的目的，Solaris 和 Stampede 包并未完全涵盖。Solaris 需要特有的 Solaris 软件，而 Stampede 是一个已废弃的项目。
- en: '|  |'
  id: totrans-1724
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Researching this book, we discovered that it could be a little fiddly to install
    Alien on non-Debian-based distributions. This being a Docker book, we’ve naturally
    decided to provide a conversion tool in the format of a Docker image. As a bonus,
    this tool uses the `ENTRYPOINT` command from [technique 49](#ch07sb02) to make
    using the tools simpler.
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究这本书时，我们发现，在非 Debian 基础发行版上安装 Alien 可能会有点麻烦。鉴于这是一本 Docker 书，我们自然决定以 Docker
    镜像的形式提供转换工具。作为额外的好处，这个工具使用了 [技术 49](#ch07sb02) 中的 `ENTRYPOINT` 命令来简化工具的使用。
- en: As an example, let’s download and convert (with Alien) the eatmydata package,
    which will be used in [technique 62](kindle_split_019.xhtml#ch08sb03).
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们下载并转换（使用 Alien）eatmydata 包，该包将在 [技术 62](kindle_split_019.xhtml#ch08sb03)
    中使用。
- en: '[PRE137]'
  id: totrans-1727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '***1*** **Creates an empty directory to work in**'
  id: totrans-1728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建一个工作目录**'
- en: '***2*** **Retrieves the package files you want to convert**'
  id: totrans-1729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检索你想要转换的包文件**'
- en: '***3*** **Runs the dockerinpractice/alienate image, mounting the current directory
    to the container’s /io path. The container will examine that directory and try
    to convert any valid files it finds.**'
  id: totrans-1730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **运行 dockerinpractice/alienate 镜像，将当前目录挂载到容器的 /io 路径。容器将检查该目录，并尝试转换它找到的任何有效文件。**'
- en: '***4*** **The container informs you of its actions as it runs its Alien wrapper
    script.**'
  id: totrans-1731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **容器在运行 Alien 包装脚本时通知你其操作。**'
- en: '***5*** **The files have been converted to RPM, Slackware TGZ, and Stampede
    files.**'
  id: totrans-1732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **文件已转换为 RPM、Slackware TGZ 和 Stampede 文件。**'
- en: 'Alternatively, you can pass the URL of a package to be downloaded and converted
    directly to the `docker run` command:'
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以将包的 URL 直接传递给 `docker run` 命令进行下载和转换：
- en: '[PRE138]'
  id: totrans-1734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'If you want to run Alien in a container yourself, you can start up the container
    with this:'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在容器中运行 Alien，你可以使用以下命令启动容器：
- en: '[PRE139]'
  id: totrans-1736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '|  |'
  id: totrans-1737
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-1738
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Alien is a best-effort tool, and it’s not guaranteed to work with the packages
    you give it.
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: Alien 是一个尽力而为的工具，并且不能保证它能与给定的包一起工作。
- en: '|  |'
  id: totrans-1740
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**DISCUSSION**'
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Docker use has brought into sharp focus the “distro wars” that lay dormant for
    some time. Most organizations had settled into simply being Red Hat or Debian
    shops that didn’t need to be concerned with other packaging systems. Now, it’s
    not uncommon to receive requests for the introduction of Docker images that are
    based on “alien” distributions within an organization.
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的使用使沉睡已久的“发行版之战”变得尖锐。大多数组织已经适应了仅仅成为 Red Hat 或 Debian 商店，无需担心其他包管理系统。现在，在组织内部引入基于“alien”发行版的
    Docker 镜像的请求并不罕见。
- en: That’s where this technique can help, as “foreign” packages can be converted
    to a more friendly format. This topic will be revisited in [chapter 14](kindle_split_027.xhtml#ch14),
    where we’ll discuss security.
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这项技术可以提供帮助的地方，因为“外国”包可以被转换为更友好的格式。这个话题将在 [第 14 章](kindle_split_027.xhtml#ch14)
    中再次讨论，我们将讨论安全性。
- en: '|  |'
  id: totrans-1744
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.2\. Traditional configuration management tools with Docker
  id: totrans-1745
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 使用 Docker 的传统配置管理工具
- en: Now we’ll move on to how Dockerfiles can work alongside more traditional configuration
    management tools.
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将讨论 Dockerfile 如何与更传统的配置管理工具一起工作。
- en: We’ll look here at traditional configuration management with `make`, show you
    how you can use your existing Chef scripts to provision your images with Chef
    Solo, and look at a shell script framework built to help non-Docker experts build
    images.
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将探讨传统的配置管理使用 `make`，展示您如何使用现有的 Chef 脚本来使用 Chef Solo 配置您的镜像，并查看一个构建来帮助非
    Docker 专家构建镜像的 shell 脚本框架。
- en: '|  |'
  id: totrans-1748
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Traditional: Using make with Docker**'
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: '**传统方式：使用 make 与 Docker**'
- en: At some point you might find that having a bunch of Dockerfiles is limiting
    your build process. For example, it’s impossible to produce any output *files*
    if you limit yourself to running `docker build`, and there’s no way to have variables
    in Dockerfiles.
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，您可能会发现拥有大量的 Dockerfile 限制了您的构建过程。例如，如果您将自己限制在运行 `docker build`，则无法生成任何输出
    *文件*，并且 Dockerfile 中没有变量。
- en: This requirement for additional tooling can be addressed by a number of tools
    (including plain shell scripts). In this technique we’ll look at how you can twist
    the venerable `make` tool to work with Docker.
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对额外工具的需求可以通过多种工具（包括普通的 shell 脚本）来解决。在这个技术中，我们将探讨如何将古老的 `make` 工具扭曲以与 Docker
    一起工作。
- en: '**PROBLEM**'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to add additional tasks around `docker build` execution.
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 您想在 `docker build` 执行周围添加额外的任务。
- en: '**SOLUTION**'
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use an ancient (in computing terms) tool called `make`.
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个古老的（在计算机术语中）工具，称为 `make`。
- en: 'In case you haven’t used it before, `make` is a tool that takes one or more
    input files and produces an output file, but it can also be used as a task runner.
    Here’s a simple example (note that all indents must be tabs):'
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前没有使用过它，`make` 是一个工具，它接受一个或多个输入文件并生成一个输出文件，但它也可以用作任务运行器。以下是一个简单的示例（注意，所有缩进都必须是制表符）：
- en: Listing 7.4\. A simple Makefile
  id: totrans-1757
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.4\. 一个简单的 Makefile
- en: '[PRE140]'
  id: totrans-1758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '***1*** **By default, make assumes that all targets are filenames that will
    be created by the task. The .PHONY indicates for which task names this is not
    true.**'
  id: totrans-1759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **默认情况下，make 假设所有目标都是将被任务创建的文件名。.PHONY 表示对于哪些任务名称这不是真的。**'
- en: '***2*** **By convention, the first target in a Makefile is “default”. When
    run without an explicit target, make will choose the first in the file. You can
    see that “default” will execute “createfile” as its only dependency.**'
  id: totrans-1760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **按照惯例，Makefile 中的第一个目标是“default”。当没有明确的目标运行时，make 将选择文件中的第一个。您可以看到，“default”将执行“createfile”作为其唯一的依赖项。**'
- en: '***3*** **createfile is a phony task that depends on the x.y.z task.**'
  id: totrans-1761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **createfile 是一个依赖于 x.y.z 任务的虚拟任务。**'
- en: '***4*** **catfile is a phony task that runs a single command.**'
  id: totrans-1762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **catfile 是一个运行单个命令的虚拟任务。**'
- en: '***5*** **x.y.z is a file task that runs two commands and creates the target
    x.y.z file.**'
  id: totrans-1763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **x.y.z 是一个文件任务，运行两个命令并创建目标文件 x.y.z。**'
- en: '|  |'
  id: totrans-1764
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-1765
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: All indents in a Makefile must be tabs, and each command in a target is run
    in a different shell (so environment variables won’t be carried across).
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 中的所有缩进都必须是制表符，并且每个目标中的命令都在不同的 shell 中运行（因此环境变量不会传递）。
- en: '|  |'
  id: totrans-1767
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Once you have the preceding content in a file called Makefile, you can invoke
    any target with a command like `make createfile`.
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在名为 Makefile 的文件中有了前面的内容，您可以使用类似 `make createfile` 的命令调用任何目标。
- en: Now let’s look at some useful patterns in a Makefile—the rest of the targets
    we’ll talk about will be phony, as it’s difficult (although possible) to use file-change
    tracking to trigger Docker builds automatically. Dockerfiles use a cache of layers,
    so builds tend to be fast.
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 Makefile 中的一些有用模式——我们将讨论的其余目标将是虚拟的，因为使用文件更改跟踪来自动触发 Docker 构建（尽管可能，但很困难）。Dockerfile
    使用层缓存，因此构建通常很快。
- en: The first step is to run a Dockerfile. Because a Makefile consists of shell
    commands, this is easy.
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是运行一个 Dockerfile。因为 Makefile 由 shell 命令组成，所以这很简单。
- en: Listing 7.5\. Makefile for building an image
  id: totrans-1771
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.5\. 构建镜像的 Makefile
- en: '[PRE141]'
  id: totrans-1772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Normal variations of this work as you’d expect (such as piping the file to `docker
    build` to remove the context, or using `-f` to use a differently named Dockerfile),
    and you can use the dependencies feature of `make` to automatically build base
    images (used in `FROM`) where necessary. For example, if you checked out a number
    of repositories into a subdirectory called repos (also easily doable with `make`),
    you could add a target, as in the following listing.
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: 正常情况下，这种变化会按预期工作（例如，通过管道将文件传递到 `docker build` 以删除上下文，或使用 `-f` 使用不同命名的 Dockerfile），你可以使用
    `make` 的依赖项功能自动构建必要的基镜像（用于 `FROM`）。例如，如果你将多个仓库检出到名为 `repos` 的子目录中（这也很容易用 `make`
    完成），你可以在以下列表中添加一个目标。
- en: Listing 7.6\. Makefile for building an image in a subdirectory
  id: totrans-1774
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.6\. 在子目录中构建镜像的 Makefile
- en: '[PRE142]'
  id: totrans-1775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: The downside of this is that every time your base image needs rebuilding, Docker
    will upload a build context that includes all of your repos. You can fix this
    by explicitly passing a build context TAR file to Docker.
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，每次你的基础镜像需要重建时，Docker 都会上传一个包含所有你的仓库的构建上下文。你可以通过显式传递一个构建上下文 TAR 文件给
    Docker 来解决这个问题。
- en: Listing 7.7\. Makefile for building an image with a specific set of files
  id: totrans-1777
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.7\. 使用特定文件集构建镜像的 Makefile
- en: '[PRE143]'
  id: totrans-1778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: This explicit statement of dependencies will provide a significant speed increase
    if your directory contains a large number of files that are irrelevant to the
    build. You can slightly modify this target if you want to keep all your build
    dependencies in a different directory.
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 这种显式的依赖声明如果目录中包含大量与构建无关的文件，将提供显著的加速。如果你想将所有构建依赖项保存在不同的目录中，你可以稍微修改这个目标。
- en: Listing 7.8\. Makefile for building an image with a specific set of files with
    renamed paths
  id: totrans-1780
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.8\. 使用特定文件集和重命名路径构建镜像的 Makefile
- en: '[PRE144]'
  id: totrans-1781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Here you add everything in the deps directory to the build context, and use
    the `--transform` option of `tar` (available in recent `tar` versions on Linux)
    to strip any leading “deps/” from filenames. In this particular case, a better
    approach would have been to put the deps and Dockerfile in a directory of their
    own to permit a normal `docker build`, but it’s useful to be aware of this advanced
    use as it can come in handy in the most unlikely places. Always think carefully
    before using it, though, as it adds complexity to your build process.
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将 `deps` 目录中的所有内容添加到构建上下文中，并使用 `tar` 的 `--transform` 选项（在 Linux 上最近的 `tar`
    版本中可用）从文件名中去除任何前缀“deps/”。在这种情况下，一个更好的方法是将 `deps` 和 Dockerfile 放在自己的目录中，以便允许正常的
    `docker build`，但了解这种高级用法是有用的，因为它在最不可能的地方也可能派上用场。不过，在使用之前，一定要仔细思考，因为它会增加你的构建过程的复杂性。
- en: Simple variable substitution is a relatively simple matter, but (as with `--transform`
    previously) think carefully before you use it—Dockerfiles deliberately don’t support
    variables in order to keep builds easily reproducible.
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的变量替换是一个相对简单的问题，但（就像之前使用 `--transform` 一样）在使用之前要仔细思考——Dockerfile 故意不支持变量，以便保持构建过程易于重复。
- en: Here we’re going to use variables passed to `make` and substitute using `sed`,
    but you can pass and substitute however you like.
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用传递给 `make` 的变量，并使用 `sed` 进行替换，但你也可以按你喜欢的方式传递和替换。
- en: Listing 7.9\. Makefile for building an image with basic Dockerfile variable
    substitution
  id: totrans-1785
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.9\. 使用基本的 Dockerfile 变量替换构建镜像的 Makefile
- en: '[PRE145]'
  id: totrans-1786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The Dockerfile will be regenerated every time the base target is run, and you
    can add more variable substitutions by adding more `sed -i` lines. To override
    the default value of `VAR1`, you run `make VAR1=newvalue base`. If your variables
    include slashes, you may need to choose a different `sed` separator, like `sed
    -i 's#{VAR1}#$(VAR1)#' Dockerfile`.
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行基础目标时，Dockerfile 都会重新生成，你可以通过添加更多的 `sed -i` 行来添加更多的变量替换。要覆盖 `VAR1` 的默认值，运行
    `make VAR1=newvalue base`。如果你的变量包含斜杠，你可能需要选择不同的 `sed` 分隔符，如 `sed -i 's#{VAR1}#$(VAR1)#'
    Dockerfile`。
- en: Finally, if you’ve been using Docker as a build tool, you need to know how to
    get files back out of Docker. We’ll present a couple of different possibilities,
    depending on your use case.
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你一直将 Docker 作为构建工具使用，你需要知道如何从 Docker 中提取文件。我们将根据你的使用情况介绍几种不同的可能性。
- en: Listing 7.10\. Makefile for copying files out of an image
  id: totrans-1789
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.10\. 从镜像中复制文件的 Makefile
- en: '[PRE146]'
  id: totrans-1790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Here, `singlefile` runs `cat` on a file and pipes the output to a new file.
    This approach has the advantage of automatically setting the correct owner of
    the file, but it becomes cumbersome for more than one file. The `multifile` approach
    mounts a volume in the container and copies all files from a directory to the
    volume. You can follow this up with a `chown` command to set the correct owner
    on the files, but bear in mind that you’ll probably need to invoke it with `sudo`.
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`singlefile` 在一个文件上运行 `cat` 并将输出管道到一个新文件。这种方法的优势是自动设置文件的正确所有者，但如果有多个文件，就会变得繁琐。`multifile`
    方法在容器中挂载一个卷，并将所有文件从目录复制到卷。你可以通过一个 `chown` 命令来设置文件的正确所有者，但请注意，你可能需要用 `sudo` 来调用它。
- en: The Docker project itself uses the volume-mounting approach when building Docker
    from source.
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 项目本身在从源构建 Docker 时使用卷挂载方法。
- en: '**DISCUSSION**'
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: It might seem a little odd for a tool as old as `make` to appear within a book
    about a relatively new technology like Docker. Why not use a newer build technology
    like Ant, or Maven, or any of the many other general build tools available.
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像 `make` 这样古老的工具出现在一本关于相对较新的技术 Docker 的书中，可能会显得有些奇怪。为什么不使用像 Ant、Maven 或其他许多通用构建工具中的一种较新的构建技术呢？
- en: The answer is that, for all its faults, `make` is a tool that is
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，尽管 `make` 有很多缺点，但它是一个工具，
- en: Unlikely to go away any time soon
  id: totrans-1796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很难在短时间内消失
- en: Well-documented
  id: totrans-1797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档齐全
- en: Highly flexible
  id: totrans-1798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常灵活
- en: Widely available
  id: totrans-1799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广泛可用
- en: Having spent many hours fighting bugs or poorly documented (or undocumented)
    limitations of new build technologies, or trying to install dependencies of these
    systems, `make`’s features have saved us many times. It’s also more likely that
    `make` will be available in five years’ time when other tools are gone, or have
    fallen out of maintenance by their owners.
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: 在花费许多小时与新的构建技术的错误或文档不完善（或未记录）的限制作斗争，或者尝试安装这些系统的依赖项之后，`make` 的功能已经帮我们节省了很多次。而且，`make`
    在五年后仍然可能可用，而其他工具可能已经消失，或者已经由其所有者停止维护。
- en: '|  |'
  id: totrans-1801
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1802
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Building images with Chef Solo**'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 Chef Solo 构建镜像**'
- en: One of the things that confuses newcomers to Docker is whether Dockerfiles are
    the only supported configuration management tool, and whether existing configuration
    management tools should be ported to Dockerfiles. Neither of these is true.
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Docker 的新手来说，可能会感到困惑，不知道 Dockerfile 是否是唯一支持的配置管理工具，以及现有的配置管理工具是否应该移植到 Dockerfile
    中。这两者都不是事实。
- en: Although Dockerfiles are designed to be a simple and portable means of provisioning
    images, they’re also flexible enough to allow any other configuration management
    tool to take over. In short, if you can run it in a terminal, you can run it in
    a Dockerfile.
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Dockerfile 被设计成一种简单且可移植的提供镜像的方法，但它们也足够灵活，允许任何其他配置管理工具接管。简而言之，如果你能在终端中运行它，你就可以在
    Dockerfile 中运行它。
- en: As a demonstration of this, we’ll show you how to get up and running with Chef,
    arguably the most established configuration management tool, in a Dockerfile.
    Using a tool like Chef can reduce the amount of work required for you to configure
    images.
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个演示的一部分，我们将向你展示如何在 Dockerfile 中使用 Chef，这是最成熟的配置管理工具之一，以展示如何在 Dockerfile 中启动和运行
    Chef。使用像 Chef 这样的工具可以减少你配置镜像所需的工作量。
- en: '|  |'
  id: totrans-1807
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1808
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Although familiarity with Chef isn’t required to follow this technique, some
    familiarity will be required to follow it the first time with ease. Covering a
    whole configuration management tool is a book in itself. With careful study and
    some research, this technique can be used to get a good understanding of Chef
    basics.
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不需要熟悉 Chef 就能理解这个技术，但第一次轻松地使用它时，需要一些熟悉度。涵盖整个配置管理工具本身就是一本书。通过仔细学习和一些研究，这个技术可以帮助你很好地理解
    Chef 的基础知识。
- en: '|  |'
  id: totrans-1810
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**PROBLEM**'
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to reduce configuration effort by using Chef.
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望通过使用 Chef 来减少配置工作量。
- en: '**SOLUTION**'
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Install Chef in your container, and run recipes using Chef Solo within that
    container to provision it, all within your Dockerfile.
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的容器中安装 Chef，并在该容器内使用 Chef Solo 运行食谱来配置它，所有这些都在你的 Dockerfile 中完成。
- en: What you’re going to provision is a simple Hello World Apache website. This
    will give you a taste of what Chef can do for your configuration.
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要配置的是一个简单的 Hello World Apache 网站。这将让你尝到 Chef 在配置方面能为你做什么。
- en: Chef Solo requires no external Chef server setup. If you’re already familiar
    with Chef, this example can easily be adapted to enable your pre-existing scripts
    to contact your Chef server if you wish.
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: Chef Solo 不需要外部 Chef 服务器设置。如果你已经熟悉 Chef，此示例可以轻松地修改以启用你的现有脚本来联系你的 Chef 服务器，如果你希望这样做的话。
- en: 'We’re going to walk through the creation of this Chef example, but if you want
    to download the working code, it’s available as a Git repository. To download
    it, run this command:'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步介绍创建此 Chef 示例的过程，但如果你想要下载可工作的代码，它作为一个 Git 仓库可用。要下载它，请运行以下命令：
- en: '[PRE147]'
  id: totrans-1818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: We’ll begin with the simple aim of setting up a web server with Apache that
    outputs “Hello World!” (what else?) when you hit it. The site will be served from
    mysite.com, and a `mysiteuser` user will be set up on the image.
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从设置一个输出“Hello World！”（还能是什么？）的 Apache 服务器开始，当你访问它时。网站将从 mysite.com 服务器提供，并在镜像上设置一个
    `mysiteuser` 用户。
- en: To begin, create a directory and set it up with the files you’ll need for Chef
    configuration.
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个目录，并使用你需要的文件来设置 Chef 配置。
- en: Listing 7.11\. Creating the necessary files for a Chef configuration
  id: totrans-1821
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.11\. 为 Chef 配置创建必要的文件
- en: '[PRE148]'
  id: totrans-1822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '***1*** **The Chef attributes file, which defines the variables for this image
    (or node, in Chef parlance), will contain the recipes in the run-list for this
    image, and other information.**'
  id: totrans-1823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **Chef 属性文件，它定义了此镜像（或节点，在 Chef 术语中）的变量，将包含此镜像的运行列表中的食谱和其他信息。**'
- en: '***2*** **The Chef config file, which sets some base variables for the Chef
    configuration**'
  id: totrans-1824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **Chef 配置文件，它为 Chef 配置设置一些基本变量**'
- en: '***3*** **The Dockerfile that will build the image**'
  id: totrans-1825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **构建镜像的 Dockerfile**'
- en: '***4*** **Creates the default recipe folder, which stores the Chef instructions
    for building the image**'
  id: totrans-1826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **创建默认食谱文件夹，用于存储构建镜像的 Chef 指令**'
- en: '***5*** **Creates the templates for the dynamically configured content**'
  id: totrans-1827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **创建动态配置内容的模板**'
- en: First we’ll fill out attributes.json.
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将填写 attributes.json。
- en: Listing 7.12\. attributes.json
  id: totrans-1829
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.12\. attributes.json
- en: '[PRE149]'
  id: totrans-1830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: This file sets out the recipes you’re going to run. The apache2 recipes will
    be retrieved from a public repository; the mysite recipes will be written here.
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件列出你将要运行的食谱。apache2 食谱将从公共仓库检索；mysite 食谱将在这里编写。
- en: Next, populate your config.rb with some basic information, as shown in the next
    listing.
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在你的 config.rb 中填写一些基本信息，如下一个列表所示。
- en: Listing 7.13\. config.rb
  id: totrans-1833
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.13\. config.rb
- en: '[PRE150]'
  id: totrans-1834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: This file sets up basic information about the location and adds the configuration
    setting `verify_api_cert` to suppress an irrelevant error.
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件设置有关位置的基本信息，并添加配置设置 `verify_api_cert` 以抑制一个无关的错误。
- en: 'Now we get to the meat of the work: the image’s Chef recipe. Each stanza terminated
    by an `end` in the code block defines a Chef resource.'
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们进入工作的核心：镜像的 Chef 食谱。代码块中每个以 `end` 结尾的段落定义了一个 Chef 资源。
- en: Listing 7.14\. cookbooks/mysite/recipes/default.rb
  id: totrans-1837
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.14\. cookbooks/mysite/recipes/default.rb
- en: '[PRE151]'
  id: totrans-1838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '***1*** **Creates a user**'
  id: totrans-1839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建一个用户**'
- en: '***2*** **Creates a directory for the web content**'
  id: totrans-1840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **创建一个用于 web 内容的目录**'
- en: '***3*** **Defines a file that will be placed in the web folder. This file will
    be created from a template defined in the “source” attribute.**'
  id: totrans-1841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **定义一个将放置在 web 文件夹中的文件。此文件将从“source”属性中定义的模板创建。**'
- en: '***4*** **Defines a web app for apache2**'
  id: totrans-1842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **定义一个用于 apache2 的 web 应用**'
- en: '***5*** **In a real scenario you’d have to change references from mysite to
    your website’s name. If you’re accessing or testing from your host, this doesn’t
    matter.**'
  id: totrans-1843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **在实际场景中，你需要将 mysite 的引用更改为你的网站名称。如果你从主机访问或测试，这并不重要。**'
- en: The content of the website is contained within the template file. It contains
    one line, which Chef will read, substituting in the “Hello World!” message from
    config.rb. Chef will then write the substituted file out to the template target
    (/var/www/html/mysite/index.html). This uses a templating language that we’re
    not going to cover here.
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: 网站的内容包含在模板文件中。它包含一行，Chef 将读取该行，并用 config.rb 中的“Hello World！”消息进行替换。然后，Chef 将替换后的文件写入模板目标
    (/var/www/html/mysite/index.html)。这里使用的是我们不会在这里介绍的模板语言。
- en: Listing 7.15\. cookbooks/mysite/templates/default/message.erb
  id: totrans-1845
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.15\. cookbooks/mysite/templates/default/message.erb
- en: '[PRE152]'
  id: totrans-1846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Finally, you put everything together with the Dockerfile, which sets up the
    Chef prerequisites and runs Chef to configure the image, as shown in the following
    listing.
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你使用 Dockerfile 将所有内容组合起来，该文件设置 Chef 预先条件并运行 Chef 来配置镜像，如下一个列表所示。
- en: Listing 7.16\. Dockerfile
  id: totrans-1848
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.16\. Dockerfile
- en: '[PRE153]'
  id: totrans-1849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '***1*** **Downloads and installs Chef. If this download doesn’t work for you,
    check the latest code in docker-chef-solo-example mentioned earlier in this discussion,
    as a later version of Chef may now be required.**'
  id: totrans-1850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **下载并安装Chef。如果这个下载对您不起作用，请检查本讨论中之前提到的docker-chef-solo-example中的最新代码，因为可能现在需要Chef的较新版本。**'
- en: '***2*** **Copies the contents of the working folder into the /chef folder on
    the image**'
  id: totrans-1851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将工作文件夹的内容复制到镜像上的/chef文件夹**'
- en: '***3*** **Moves to the cookbooks folder and downloads the apache2 cookbook
    and its dependencies as tarballs using Chef’s knife utility**'
  id: totrans-1852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **移动到cookbooks文件夹，并使用Chef的knife工具将apache2 cookbooks及其依赖项作为tar包下载**'
- en: '***4*** **Extracts the downloaded tarballs and removes them**'
  id: totrans-1853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **提取下载的tar包并删除它们**'
- en: '***5*** **Runs the chef command to configure your image. Supplies it with the
    attributes and config files you already created.**'
  id: totrans-1854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **运行chef命令来配置您的镜像。提供您已经创建的属性和配置文件。**'
- en: '***6*** **Defines the default command for the image. The sleep infinity command
    ensures that the container doesn’t exit as soon as the service command has finished
    its work.**'
  id: totrans-1855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **定义镜像的默认命令。无限期休眠的命令确保容器在服务命令完成其工作后不会立即退出。**'
- en: 'You’re now ready to build and run the \image:'
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以构建并运行该\image：
- en: '[PRE154]'
  id: totrans-1857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: If you now navigate to http://localhost:8080, you should see your “Hello World!”
    message.
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在导航到http://localhost:8080，您应该看到您的“Hello World！”消息。
- en: '|  |'
  id: totrans-1859
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-1860
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: If your Chef build takes a long time and you’re using the Docker Hub workflow,
    the build can time out. If this happens, you can perform the build on a machine
    you control, pay for a supported service, or break the build steps into smaller
    chunks so that each individual step in the Dockerfile takes less time to return.
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Chef构建耗时较长且您正在使用Docker Hub工作流程，构建可能会超时。如果发生这种情况，您可以在您控制的机器上执行构建，支付支持的服务费用，或者将构建步骤分解成更小的块，以便Dockerfile中的每个单独步骤所需的时间更少。
- en: '|  |'
  id: totrans-1862
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Although this is a trivial example, the benefits of using this approach should
    be clear. With relatively straightforward configuration files, the details of
    getting the image into a desired state are taken care of by the configuration
    management tool. This doesn’t mean that you can forget about the details of configuration;
    changing the values will require you to understand the semantics to ensure you
    don’t break anything. But this approach can save you much time and effort, particularly
    in projects where you don’t need to get into the details too much.
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个简单的例子，但使用这种方法的好处应该是显而易见的。使用相对简单的配置文件，将镜像配置到所需状态的具体细节由配置管理工具处理。这并不意味着您可以忘记配置的细节；更改值将需要您理解语义以确保不会破坏任何东西。但这种方法可以为您节省大量时间和精力，尤其是在您不需要深入了解细节的项目中。
- en: '**DISCUSSION**'
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: The purpose of this technique is to correct a common confusion about the Dockerfile
    concept, specifically that it’s a competitor to other configuration management
    tools like Chef and Ansible.
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的目的是纠正关于Dockerfile概念的常见误解，特别是它与其他配置管理工具（如Chef和Ansible）是竞争对手。
- en: What Docker really is (as we say elsewhere in the book) is a *packaging* tool.
    It allows you to present the results of a build process in a predictable and packaged
    way. How you choose to build it is up to you. You can use Chef, Puppet, Ansible,
    Makefiles, shell scripts, or sculpt them by hand.
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: Docker真正是（正如我们在本书的其他地方所说）一种*打包*工具。它允许您以可预测和打包的方式展示构建过程的结果。您如何选择构建它取决于您。您可以使用Chef、Puppet、Ansible、Makefiles、shell脚本，或者手动雕刻它们。
- en: The reason most people don’t use Chef, Puppet, and the like to build images
    is primarily because Docker images tend to be built as single-purpose and single-process
    tools. But if you already have configuration scripts to hand, why not re-use them?
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人之所以不使用Chef、Puppet等工具来构建镜像，主要是因为Docker镜像往往被构建为单一用途和单一进程的工具。但如果你已经有了配置脚本，为什么不重用它们呢？
- en: '|  |'
  id: totrans-1868
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.3\. Small is beautiful
  id: totrans-1869
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3\. 小巧玲珑
- en: If you’re creating lots of images and sending them hither and thither, the issue
    of image size will be more likely to arise. Although Docker’s use of image layering
    can help with this, you may have such a panoply of images on your estate that
    this isn’t practical to manage.
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在创建大量镜像并将它们发送到各个地方，镜像大小的问题更有可能出现。尽管Docker使用镜像分层可以帮助解决这个问题，但您可能拥有如此众多的镜像，这并不实用来管理。
- en: In these cases, it can be helpful to have some best practices in your organization
    related to reducing images to as small a size as possible. In this section we’ll
    show you some of these, and even how a standard utility image can be reduced by
    an order of magnitude—a much smaller object to fling around your network.
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，在你的组织中有关将镜像减小到尽可能小的最佳实践可能会有所帮助。在本节中，我们将向你展示一些这些实践，甚至如何将标准实用工具镜像减小一个数量级——一个更小的对象可以在你的网络中传输。
- en: '|  |'
  id: totrans-1872
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Tricks for making an image smaller**'
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: '**减小镜像大小的技巧**'
- en: Let’s say you’ve been given an image by a third party, and you want to make
    the image smaller. The simplest approach is to start with an image that works
    and remove the unnecessary files.
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你从第三方那里获得了一个镜像，并且你想使镜像更小。最简单的方法是从一个可以工作的镜像开始，移除不必要的文件。
- en: Classic configuration management tools tend not to remove things unless explicitly
    instructed to do so—instead, they start from a non-working state and add new configurations
    and files. This leads to *snowflake* systems crafted for a particular purpose,
    which may look very different from what you’d get if you ran your configuration
    management tool against a fresh server, especially if the configuration has evolved
    over time. Courtesy of layering and lightweight images in Docker, you can perform
    the reverse of this process and experiment with removing things.
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的配置管理工具通常不会移除任何东西，除非明确指示它们这样做——相反，它们从一个非工作状态开始，添加新的配置和文件。这导致了为特定目的而构建的 *雪花*
    系统，这些系统可能与你在对全新服务器运行配置管理工具时得到的结果大相径庭，尤其是如果配置随着时间的推移而演变的话。得益于 Docker 中的分层和轻量级镜像，你可以执行这个过程的逆过程，并尝试移除某些内容。
- en: '**PROBLEM**'
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to make your images smaller.
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望使你的镜像更小。
- en: '**SOLUTION**'
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'Follow these steps to reduce the size of an image by removing unnecessary packages
    and doc files:'
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤通过移除不必要的包和文档文件来减小图像大小：
- en: Run the image.
  id: totrans-1880
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行镜像。
- en: Enter the container.
  id: totrans-1881
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入容器。
- en: Remove unnecessary files.
  id: totrans-1882
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除不必要的文件。
- en: Commit the container as a new image (see [technique 15](kindle_split_013.xhtml#ch03sb06)).
  id: totrans-1883
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将容器提交为新的镜像（参见[技术 15](kindle_split_013.xhtml#ch03sb06)）。
- en: Flatten the image (see [technique 52](#ch07sb05)).
  id: totrans-1884
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平滑化镜像（参见[技术 52](#ch07sb05)）。
- en: The last two steps have been covered earlier in the book, so we’re only going
    to cover the first three here.
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
  zh: 书中已经介绍了最后两个步骤，所以这里我们只介绍前三个步骤。
- en: To illustrate how to do this, we’re going to take the image created in [technique
    49](#ch07sb02) and try to make that image smaller.
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何操作，我们将使用[技术 49](#ch07sb02)中创建的镜像，并尝试减小该镜像的大小。
- en: 'First, run up the image as a container:'
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将镜像作为容器运行：
- en: '[PRE155]'
  id: totrans-1888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Because this is a Debian-based image, you can start by seeing which packages
    you might not need and removing them. Run `dpkg -l | awk '{print $2}'` and you’ll
    get a list of installed packages on the system.
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个基于 Debian 的镜像，你可以先查看你可能不需要哪些包，并移除它们。运行 `dpkg -l | awk '{print $2}'` 将会得到系统上安装的包列表。
- en: You can then go through those packages running `apt-get purge -y package_name`
    on them. If there’s a scary message warning you that “You are about to do something
    potentially harmful,” press Return to continue.
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以逐个对这些包运行 `apt-get purge -y package_name` 命令。如果出现警告信息“你即将执行可能有害的操作”，按回车键继续。
- en: 'Once you’ve removed all the packages that can safely be removed, you can run
    these commands to clean up the apt cache:'
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你移除了所有可以安全移除的包，你可以运行以下命令来清理 apt 缓存：
- en: '[PRE156]'
  id: totrans-1892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: This is a relatively safe way to reduce space in your images.
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对安全的方式来减少镜像中的空间。
- en: Further significant savings can be made by removing docs. For example, running
    `rm -rf /usr/share/doc/* /usr/share/man/* /usr/share/info/*` will often remove
    sizable files you’ll probably never need. You can take this to the next level
    by manually running `rm` on binaries and libraries you don’t need.
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移除文档可以进一步显著节省空间。例如，运行 `rm -rf /usr/share/doc/* /usr/share/man/* /usr/share/info/*`
    常常可以移除你很可能永远不需要的大文件。你可以通过手动运行 `rm` 命令来删除你不需要的二进制文件和库，将这一过程提升到下一个层次。
- en: Another area for rich pickings is the /var folder, which should contain temporary
    data, or data not essential to the running of programs.
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以大量节省空间的地方是 /var 文件夹，它应该包含临时数据，或者不是程序运行所必需的数据。
- en: 'This command will get rid of all files with the .log suffix:'
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将删除所有以 .log 后缀结尾的文件：
- en: '[PRE157]'
  id: totrans-1897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Now you’ll have a much smaller image than you previously had, ready to commit.
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将拥有一个比之前更小的镜像，准备好提交。
- en: '**DISCUSSION**'
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Using this somewhat manual process, you can get the original dockerinpractice/
    log-cleaner image down to a few dozen MB quite easily, and even make it smaller
    if you have the motivation. Remember that due to Docker’s layering, you’ll need
    to export and import the image as explained in [technique 52](#ch07sb05); otherwise
    the image’s overall size will include the deleted files.
  id: totrans-1900
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个相对手动的过程，你可以轻松地将原始 dockerinpractice/ log-cleaner 镜像减小到几十 MB，如果你有动力，甚至可以使其更小。记住，由于
    Docker 的分层，你需要像在 [技术 52](#ch07sb05) 中解释的那样导出和导入镜像；否则，镜像的整体大小将包括已删除的文件。
- en: '[Technique 59](#ch07sb12) will show you a much more effective (but risky) way
    to significantly reduce the size of your images.'
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: '[技术 59](#ch07sb12) 将向您展示一种更有效（但风险更大）的方法，可以显著减小您镜像的大小。'
- en: '|  |'
  id: totrans-1902
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1903
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: An example of the commands described here is maintained at [https://github.com/docker-in-practice/log-cleaner-purged](https://github.com/docker-in-practice/log-cleaner-purged),
    and it can be pulled with Docker from dockerinpractice/log-cleaner-purged.
  id: totrans-1904
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的命令的示例维护在 [https://github.com/docker-in-practice/log-cleaner-purged](https://github.com/docker-in-practice/log-cleaner-purged)，并且可以通过
    Docker 从 dockerinpractice/log-cleaner-purged 拉取。
- en: '|  |'
  id: totrans-1905
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1906
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1907
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Tiny Docker images with BusyBox and Alpine**'
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 BusyBox 和 Alpine 的微型 Docker 镜像**'
- en: Small, usable OSs that can be embedded onto a low-power or cheap computer have
    existed since Linux began. Fortunately, the efforts of these projects have been
    repurposed to produce small Docker images for use where image size is important.
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Linux 开始，就存在可以嵌入到低功耗或廉价计算机上的小型、可用的操作系统。幸运的是，这些项目的努力已经重新用于生产用于重要尺寸的 Docker
    镜像。
- en: '**PROBLEM**'
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want a small, functional image.
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个小巧、功能齐全的镜像。
- en: '**SOLUTION**'
  id: totrans-1912
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use a small base image, like BusyBox or Alpine, when building your own images.
  id: totrans-1913
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建自己的镜像时，使用小型基础镜像，如 BusyBox 或 Alpine。
- en: This is another area where the state of the art is fast changing. The two popular
    choices for minimal Linux base images are BusyBox and Alpine, and each has different
    characteristics.
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是技术前沿快速变化的一个领域。两个流行的最小 Linux 基础镜像选择是 BusyBox 和 Alpine，它们各有不同的特点。
- en: 'If lean but useful is your aim, BusyBox may fit the bill. If you start up a
    BusyBox image with the following command, something surprising happens:'
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您追求精简但实用，BusyBox 可能符合您的需求。如果您使用以下命令启动 BusyBox 镜像，会发生一些令人惊讶的事情：
- en: '[PRE158]'
  id: totrans-1916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: BusyBox is so lean it has no bash! Instead it uses ash, which is a posix-compliant
    shell—effectively a limited version of more advanced shells such as bash and ksh.
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox 非常精简，没有 bash！相反，它使用 ash，这是一个符合 POSIX 标准的 shell——实际上是一个比 bash 和 ksh 等更高级的
    shell 有限的版本。
- en: '[PRE159]'
  id: totrans-1918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: As the result of many decisions like this, the BusyBox image weighs in at under
    2.5 MB.
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多类似这样的决策，BusyBox 镜像的重量不到 2.5 MB。
- en: '|  |'
  id: totrans-1920
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-1921
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: BusyBox can contain some other nasty surprises. The `tar` version, for example,
    will have difficulty untarring TAR files created with GNU `tar`.
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox 可能会包含一些其他令人惊讶的惊喜。例如，`tar` 版本将难以解包使用 GNU `tar` 创建的 TAR 文件。
- en: '|  |'
  id: totrans-1923
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This is great if you want to write a small script that only requires simple
    tools, but if you want to run anything else you’ll have to install it yourself.
    BusyBox comes with no package management.
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想编写一个只需要简单工具的小脚本，这将非常棒，但如果您想运行其他任何东西，您将不得不自己安装它。BusyBox 不包含包管理。
- en: 'Other maintainers have added package management functionality to BusyBox. For
    example, progrium/busybox might not be the smallest BusyBox container (it’s currently
    a little under 5 MB), but it has opkg, which means you can easily install other
    common packages while keeping the image size to an absolute minimum. If you’re
    missing bash, for example, you can install it like this:'
  id: totrans-1925
  prefs: []
  type: TYPE_NORMAL
  zh: 其他维护者已经向 BusyBox 添加了包管理功能。例如，progrium/busybox 可能不是最小的 BusyBox 容器（它目前略小于 5 MB），但它有
    opkg，这意味着你可以轻松地安装其他常见包，同时将镜像大小保持在绝对最小。例如，如果你缺少 bash，你可以这样安装：
- en: '[PRE160]'
  id: totrans-1926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: When committed, this results in a 6 MB image.
  id: totrans-1927
  prefs: []
  type: TYPE_NORMAL
  zh: 当提交时，这将产生一个 6 MB 的镜像。
- en: Another interesting Docker image (which has become a Docker standard for small
    images) is gliderlabs/alpine. It’s similar to BusyBox but has a more extensive
    range of packages that you can browse at [https://pkgs.alpinelinux.org/packages](https://pkgs.alpinelinux.org/packages).
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的 Docker 镜像是 gliderlabs/alpine。它与 BusyBox 类似，但提供了更广泛的包，您可以在 [https://pkgs.alpinelinux.org/packages](https://pkgs.alpinelinux.org/packages)
    上浏览。
- en: The packages are designed to be lean on install. To take a concrete example,
    here’s a Dockerfile that results in an image that’s just over a quarter of a gigabyte.
  id: totrans-1929
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包被设计为在安装时保持精简。以一个具体的例子来说，以下是一个 Dockerfile，它生成的镜像大小略超过四分之一千兆字节。
- en: Listing 7.17\. Ubuntu plus mysql-client
  id: totrans-1930
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.17\. Ubuntu 加上 mysql-client
- en: '[PRE161]'
  id: totrans-1931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '|  |'
  id: totrans-1932
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1933
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `DEBIAN_FRONTEND=noninteractive` before the `apt-get install` ensures that
    the install doesn’t prompt for any input during the install. As you can’t easily
    engineer responses to questions when running commands, this is often useful in
    Dockerfiles.
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `apt-get install` 前面的 `DEBIAN_FRONTEND=noninteractive` 确保安装过程中不会提示任何输入。由于在运行命令时无法轻易设计对问题的响应，这在
    Dockerfile 中通常很有用。
- en: '|  |'
  id: totrans-1935
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: By contrast, the following listing results in an image that’s a little over
    36 MB.
  id: totrans-1936
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，以下列表的结果是一个略大于 36 MB 的镜像。
- en: Listing 7.18\. Alpine plus `mysql-client`
  id: totrans-1937
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.18\. Alpine 加上 `mysql-client`
- en: '[PRE162]'
  id: totrans-1938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '**DISCUSSION**'
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This is an area in which there’s been much development over the past couple
    of years. The Alpine base image has edged out BusyBox to become something of a
    Docker standard, with the help of some backing from Docker Inc. itself.
  id: totrans-1940
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在过去几年中发展迅速的一个领域。Alpine 基础镜像已经超越了 BusyBox，在 Docker 标准中占据了一席之地，这得益于 Docker Inc.
    的支持。
- en: In addition, the other more “standard” base images have been on diets themselves.
    The Debian image stands at roughly 100 MB as we prepare the second edition of
    this book—much less than it originally was.
  id: totrans-1941
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，其他更“标准”的基础镜像也在进行瘦身。当我们准备本书的第二版时，Debian 镜像大约有 100 MB，比最初要小得多。
- en: One point worth referring to here is that there’s a lot of discussion around
    reducing the size of images, or using smaller base images, when this is not something
    that needs to be addressed. Remember that it’s often best to spend time and effort
    overcoming existing bottlenecks than achieving theoretical benefits that may turn
    out to give little bang for your buck.
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的一点是，关于减少镜像大小或使用更小的基础镜像的讨论很多，但这并不是需要解决的问题。记住，通常最好的做法是花时间和精力克服现有的瓶颈，而不是追求可能效果甚微的理论效益。
- en: '|  |'
  id: totrans-1943
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1944
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The Go model of minimal containers**'
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
  zh: '**最小容器 Go 模型**'
- en: Although it can be illuminating to winnow down your working containers by removing
    redundant files, there’s another option—compiling minimal binaries without dependencies.
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通过删除冗余文件来精简工作容器可以提供启示，但还有一个选项——编译没有依赖项的最小二进制文件。
- en: Doing this radically simplifies the task of configuration management—if there’s
    only one file to deploy and no packages are required, a significant amount of
    configuration management tooling becomes redundant.
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做极大地简化了配置管理的任务——如果只有一个文件要部署且不需要任何包，那么大量的配置管理工具就变得多余了。
- en: '**PROBLEM**'
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to build binary Docker images with no external dependencies.
  id: totrans-1949
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要构建没有外部依赖的二进制 Docker 镜像。
- en: '**SOLUTION**'
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Build a statically linked binary—one that will not try to load any system libraries
    when it starts running.
  id: totrans-1951
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个静态链接的二进制文件——在它启动运行时不会尝试加载任何系统库。
- en: To demonstrate how this can be useful, we’ll first create a small Hello World
    image with a small C program. Then we’ll go on to show you how to do something
    equivalent for a more useful application.
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这如何有用，我们首先创建一个包含小型 C 程序的 Hello World 镜像。然后我们将展示如何为更有用的应用程序做类似的事情。
- en: '**A minimal Hello World binary**'
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: '**最小 Hello World 二进制文件**'
- en: To create the minimal Hello World binary, first create a new directory and a
    Dockerfile, as shown in the following listing.
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建最小的 Hello World 二进制文件，首先创建一个新的目录和一个 Dockerfile，如下所示。
- en: Listing 7.19\. Hello Dockerfile
  id: totrans-1955
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.19\. Hello Dockerfile
- en: '[PRE163]'
  id: totrans-1956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '***1*** **The gcc image is an image designed for compiling.**'
  id: totrans-1957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **gcc 镜像是为编译设计的。**'
- en: '***2*** **Creates a simple one-line C program**'
  id: totrans-1958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **创建一个简单的单行 C 程序**'
- en: '***3*** **Compiles the program with the -static flag, and suppresses warnings
    with -w**'
  id: totrans-1959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **使用 -static 标志编译程序，并使用 -w 抑制警告**'
- en: The preceding Dockerfile compiles a simple Hello World program without dependencies.
    You can now build it and extract that binary from the container, as shown in the
    next listing.
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 Dockerfile 编译了一个没有依赖项的简单 Hello World 程序。你现在可以构建它，并从容器中提取那个二进制文件，如下一个列表所示。
- en: Listing 7.20\. Extracting the binary from the image
  id: totrans-1961
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.20\. 从镜像中提取二进制文件
- en: '[PRE164]'
  id: totrans-1962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '***1*** **Builds the image containing the statically linked “hi” binary**'
  id: totrans-1963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **构建包含静态链接“hi”二进制的镜像**'
- en: '***2*** **Runs the image with a trivial command in order to copy out the binary**'
  id: totrans-1964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用一个简单的命令运行镜像以复制出二进制文件**'
- en: '***3*** **Copies the “hi” binary using the docker cp command**'
  id: totrans-1965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **使用 docker cp 命令复制“hi”二进制文件**'
- en: '***4*** **Cleanup: you don’t need these anymore**'
  id: totrans-1966
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **清理：你不再需要这些了**'
- en: '***5*** **Makes a new folder called “new_folder”**'
  id: totrans-1967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **创建一个名为“new_folder”的新文件夹**'
- en: '***6*** **Moves the “hi” binary into this folder**'
  id: totrans-1968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **将“hi”二进制文件移动到这个文件夹**'
- en: '***7*** **Changes directory into this new folder**'
  id: totrans-1969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **更改目录到这个新文件夹**'
- en: You now have a statically built binary in a fresh directory and have moved into
    it.
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在在新的目录中有一个静态构建的二进制文件，并且已经移动到该目录。
- en: Now create another Dockerfile, as shown in the next listing.
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建另一个 Dockerfile，如下列所示。
- en: Listing 7.21\. Minimal Hello Dockerfile
  id: totrans-1972
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.21\. 最小 Hello Dockerfile
- en: '[PRE165]'
  id: totrans-1973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '***1*** **Uses the zero-byte scratch image**'
  id: totrans-1974
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用零字节 scratch 镜像**'
- en: '***2*** **Adds the “hi” binary to the image**'
  id: totrans-1975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将“hi”二进制文件添加到镜像**'
- en: '***3*** **Defaults the image to run the “hi” binary**'
  id: totrans-1976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **默认镜像运行“hi”二进制文件**'
- en: Build and run it as shown in the following listing.
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下列表所示构建和运行它。
- en: Listing 7.22\. Creating the minimal container
  id: totrans-1978
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.22\. 创建最小容器
- en: '[PRE166]'
  id: totrans-1979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The image builds, runs, and weighs in at under 1 MB.
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像构建、运行，总大小不到 1 MB。
- en: '**A minimal Go web server image**'
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个最小的 Go 网络服务器镜像**'
- en: That was a relatively trivial example, but you can apply the same principle
    to programs built in Go. An interesting feature of the Go language is that it’s
    relatively easy to build such static binaries.
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个相对简单的例子，但你也可以将同样的原则应用到用 Go 编写的程序中。Go 语言的一个有趣特性是构建这样的静态二进制文件相对容易。
- en: To demonstrate this ability, we created a simple web server in Go whose code
    is available at [https://github.com/docker-in-practice/go-web-server](https://github.com/docker-in-practice/go-web-server).
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这一能力，我们创建了一个简单的 Go 语言网络服务器，其代码可在 [https://github.com/docker-in-practice/go-web-server](https://github.com/docker-in-practice/go-web-server)
    找到。
- en: The Dockerfile for building this simple web server is shown in the following
    listing.
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
  zh: 构建此简单网络服务器的 Dockerfile 如下列所示。
- en: Listing 7.23\. Dockerfile to statically compile a Go web server
  id: totrans-1985
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.23\. 用于静态编译 Go 网络服务器的 Dockerfile
- en: '[PRE167]'
  id: totrans-1986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '***1*** **This build is known to work against this version number of the golang
    image; if the build fails, it may be that this version is no longer available.**'
  id: totrans-1987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **这个构建已知可以与 golang 镜像的这个版本号兼容；如果构建失败，可能是因为这个版本已经不再可用。**'
- en: '***2*** **“go get” retrieves the source code from the URL provided and compiles
    it locally. The CGO_ENABLED environment variable is set to 0 to prevent cross-compilation.**'
  id: totrans-1988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **“go get”从提供的 URL 获取源代码并在本地编译。CGO_ENABLED 环境变量设置为 0 以防止交叉编译。**'
- en: '***3*** **Sets a number of miscellaneous flags to the Go compiler to ensure
    static compilation and reduce size**'
  id: totrans-1989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **为 Go 编译器设置一系列杂项标志以确保静态编译并减小大小**'
- en: '***4*** **The Go web server source code repository**'
  id: totrans-1990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **Go 网络服务器源代码仓库**'
- en: '***5*** **Defaults the resulting image to output the executable**'
  id: totrans-1991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **默认生成的镜像输出可执行文件**'
- en: If you save this Dockerfile into an empty directory and build it, you’ll now
    have an image containing the program. Because you specified the default command
    of the image to output the executable content, you now just need to run the image
    and send the output to a file on your host, as the following listing shows.
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个 Dockerfile 保存到一个空目录中并构建它，你现在将拥有一个包含程序的镜像。因为你指定了镜像的默认命令以输出可执行内容，你现在只需运行镜像并将输出发送到主机上的文件，如下列所示。
- en: Listing 7.24\. Getting the Go web server from the image
  id: totrans-1993
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.24\. 从镜像获取 Go 网络服务器
- en: '[PRE168]'
  id: totrans-1994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '***1*** **Builds and tags the image**'
  id: totrans-1995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **构建并标记镜像**'
- en: '***2*** **Makes and moves into a fresh directory to deposit the binary**'
  id: totrans-1996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **创建一个新目录以存放二进制文件并移动到该目录**'
- en: '***3*** **Runs the image and redirects the binary output to a file**'
  id: totrans-1997
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **运行镜像并将二进制输出重定向到文件**'
- en: '***4*** **Makes the binary executable**'
  id: totrans-1998
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **使二进制文件可执行**'
- en: '***5*** **Creates a web page for the server to serve**'
  id: totrans-1999
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **为服务器创建一个网页以提供服务**'
- en: Now, as with the “hi” binary, you have a binary with no library dependencies
    or need to access the filesystem. We’re therefore going to create a Dockerfile
    from the zero-byte scratch image and add the binary to it, as before.
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像“hi”二进制文件一样，你有一个没有库依赖或需要访问文件系统的二进制文件。因此，我们将从零字节 scratch 镜像创建一个 Dockerfile
    并将其添加到其中，就像之前一样。
- en: Listing 7.25\. Go web server Dockerfile
  id: totrans-2001
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.25\. Go 网络服务器 Dockerfile
- en: '[PRE169]'
  id: totrans-2002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '***1*** **Adds the static binary to the image**'
  id: totrans-2003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将静态二进制文件添加到镜像**'
- en: '***2*** **Adds a page to serve from the web server**'
  id: totrans-2004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加一个网页供网络服务器服务**'
- en: '***3*** **Makes the binary the default program run by the image**'
  id: totrans-2005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 将二进制文件设置为图像默认运行的程序'
- en: Now build it and run the image. The resulting image is a little over 4 MB in
    size.
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建它并运行图像。生成的图像大小略大于4 MB。
- en: Listing 7.26\. Building and running the Go web server image
  id: totrans-2007
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.26\. 构建和运行Go网络服务器图像
- en: '[PRE170]'
  id: totrans-2008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: You can access it on http://localhost:8080\. If the port is already in use,
    you can replace the 8080s in the preceding code with a port of your choice.
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过http://localhost:8080访问它。如果端口已被占用，您可以将前面代码中的8080替换为您选择的端口。
- en: '**DISCUSSION**'
  id: totrans-2010
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: If you can bundle applications into one binary, why bother with Docker at all?
    You can move the binary around, run multiple copies, and so on.
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以将应用程序捆绑到一个二进制文件中，为什么还要使用Docker呢？您可以移动二进制文件，运行多个副本，等等。
- en: 'You can do so if you want, but you’d lose the following:'
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想这样做，可以，但您将失去以下内容：
- en: All the container management tools in the Docker ecosystem
  id: totrans-2013
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker生态系统中的所有容器管理工具
- en: The metadata within the Docker images that document significant application
    information, such as ports, volumes, and labels
  id: totrans-2014
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker镜像中包含重要应用程序信息的元数据，例如端口、卷和标签
- en: The isolation that gives Docker its operational power
  id: totrans-2015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给予Docker操作能力的隔离性
- en: As a concrete example, etcd is a static binary by default, but when we examine
    it in [technique 74](kindle_split_020.xhtml#ch09sb06) we’ll demonstrate it inside
    a container to make it easier to see how the same process would work across multiple
    machines and ease deployment.
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
  zh: 作为具体示例，etcd默认是一个静态二进制文件，但当我们[在技术74](kindle_split_020.xhtml#ch09sb06)中检查它时，我们将演示它在容器内，以便更容易地看到相同的过程如何在多台机器上工作，并简化部署。
- en: '|  |'
  id: totrans-2017
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-2018
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using inotifywait to slim containers**'
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用inotifywait精简容器**'
- en: We’re now going to take slimming our containers to the next level by using a
    nifty tool that tells us what files are being referenced when we run a container.
  id: totrans-2020
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过使用一个巧妙的工具来将我们的容器精简到下一级别，这个工具会告诉我们当运行容器时正在引用哪些文件。
- en: This could be called the nuclear option, as it can be quite risky to implement
    on production. But it can be an instructive means of learning about your system,
    even if you don’t follow through with using it for real—a crucial part of configuration
    management is understanding what your application requires to operate correctly.
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以被称为核选项，因为它在生产环境中实施可能会有相当大的风险。但即使您不真正使用它，它也可以是一种了解您系统的有益方式——配置管理的一个关键部分是了解您的应用程序需要什么才能正确运行。
- en: '**PROBLEM**'
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to reduce your container to the smallest possible set of files and
    permissions.
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将容器减少到可能的最小文件和权限集。
- en: '**SOLUTION**'
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Monitor which files are accessed by your program with inotify, and then remove
    any that seem unused.
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
  zh: 使用inotify监控程序访问的文件，然后删除任何看起来未使用的文件。
- en: At a high level, you need to know what files are being accessed when you run
    a command in a container. If you remove all the other files on the container filesystem,
    you’ll theoretically still have everything you need.
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，您需要知道在容器中运行命令时哪些文件被访问。如果您从容器文件系统中删除所有其他文件，理论上您仍然会拥有所需的一切。
- en: In this walkthrough, we’re going to use the log-cleaner-purged image from [technique
    56](#ch07sb09). You’ll install inotify-tools, and then run `inotifywait` to get
    a report on which files were accessed. You’ll then run a simulation of the image’s
    entrypoint (the log_clean script). Then, using the file report generated, you’ll
    remove any file that hasn’t been accessed.
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用来自[技术56](#ch07sb09)的log-cleaner-purged图像。您将安装inotify-tools，然后运行`inotifywait`来获取关于哪些文件被访问的报告。然后，您将运行图像的入口点（log_clean脚本）的模拟。接着，使用生成的文件报告，您将删除任何未被访问的文件。
- en: Listing 7.27\. Performing manual install steps while monitoring with inotifywait
  id: totrans-2028
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.27\. 在使用inotifywait监控的同时执行手动安装步骤
- en: '[PRE171]'
  id: totrans-2029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '***1*** **Overrides the default entrypoint for this image**'
  id: totrans-2030
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **覆盖此图像的默认入口点**'
- en: '***2*** **Gives the container a name you can refer to later**'
  id: totrans-2031
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 为容器赋予一个您稍后可以引用的名字'
- en: '***3*** **Installs the inotify-tools package**'
  id: totrans-2032
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 安装inotify-tools包'
- en: '***4*** **Runs inotifywait in recursive (-r) and daemon (-d) modes to get a
    list of accessed files in the outfile (specified with the -o flag)**'
  id: totrans-2033
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 以递归（-r）和守护进程（-d）模式运行`inotifywait`以获取在outfile（使用-o标志指定）中访问的文件列表'
- en: '***5*** **Specifies the folders you’re interested in watching. Note that you
    don’t watch /tmp because /tmp/inotifywaitout.txt would cause an infinite loop
    if it were itself watched.**'
  id: totrans-2034
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **指定您感兴趣的文件夹。请注意，您不需要监控/tmp，因为如果监控它本身，/tmp/inotifywaitout.txt将导致无限循环。**'
- en: '***6*** **Calls inotifywait again on subfolders of the /usr folder. There are
    too many files in the /usr folder for inotifywait to handle, so you need to specify
    each one separately.**'
  id: totrans-2035
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **在/usr文件夹的子文件夹上再次调用inotifywait。/usr文件夹中的文件太多，inotifywait无法处理，因此您需要分别指定每个文件夹。**'
- en: '***7*** **Sleeps to give inotifywait a decent amount of time to start up**'
  id: totrans-2036
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **休眠以给inotifywait足够的时间启动**'
- en: '***8*** **Accesses the script file you’ll need to use, as well as the rm command,
    to make sure they’re marked as being used.**'
  id: totrans-2037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **访问您需要使用的脚本文件以及rm命令，以确保它们被标记为已使用。**'
- en: '***9*** **Starts a bash shell, as the script does, and runs the commands the
    script would. Note that this will fail, because we didn’t mount any actual log
    folder from the host.**'
  id: totrans-2038
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** **启动bash shell，就像脚本执行时一样，并运行脚本中的命令。请注意，这将失败，因为我们没有从主机挂载任何实际的日志文件夹。**'
- en: '***10*** **Uses the awk utility to generate a list of filenames from the output
    of the inotifywait log, and turns it into a unique and sorted list**'
  id: totrans-2039
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10*** **使用awk实用程序从inotifywait日志的输出中生成文件名列表，并将其转换为唯一且排序的列表**'
- en: '***11*** **Uses the comm utility to output a list of files on the filesystem
    that were not accessed**'
  id: totrans-2040
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11*** **使用comm实用程序输出文件系统上未访问的文件列表**'
- en: '***12*** **Removes all files not accessed**'
  id: totrans-2041
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***12*** **删除所有未访问的文件**'
- en: '***13*** **Exits the bash shell you started and then the container itself**'
  id: totrans-2042
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***13*** **退出您启动的bash shell然后是容器本身**'
- en: At this point you’ve
  id: totrans-2043
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经
- en: Placed a watch on files to see what files are being accessed
  id: totrans-2044
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对文件进行监控以查看哪些文件被访问
- en: Run all the commands to simulate the running of the script
  id: totrans-2045
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行所有命令以模拟脚本的运行
- en: Run commands to ensure you access the script you’ll definitely need, and the
    rm utility
  id: totrans-2046
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行命令以确保您访问到您肯定会需要的脚本，以及rm实用程序
- en: Gained a list of all files not accessed during the run
  id: totrans-2047
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取了运行期间未访问的所有文件的列表
- en: Removed all the non-accessed files
  id: totrans-2048
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除了所有未访问的文件
- en: Now you can flatten this container (see [technique 52](#ch07sb05)) to create
    a new image and test that it still works.
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以扁平化这个容器（参见[技术52](#ch07sb05)）以创建一个新的镜像并测试它是否仍然工作。
- en: Listing 7.28\. Flattening the image and running it
  id: totrans-2050
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.28\. 扁平化镜像并运行它
- en: '[PRE172]'
  id: totrans-2051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '***1*** **Flattens the image and puts the ID into the variable “ID”**'
  id: totrans-2052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将镜像扁平化并将ID放入变量“ID”中**'
- en: '***2*** **Tags the newly flattened image as “smaller”**'
  id: totrans-2053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将新扁平化的镜像标记为“较小”**'
- en: '***3*** **The image is now less than 10% of its previous size.**'
  id: totrans-2054
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **现在镜像的大小已经小于之前的10%。**'
- en: '***4*** **Creates a new folder and file to simulate a log directory for testing**'
  id: totrans-2055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **创建一个新的文件夹和文件以模拟测试的日志目录**'
- en: '***5*** **Runs the newly created image over the test directory and checks that
    the file created has been removed**'
  id: totrans-2056
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **在测试目录上运行新创建的镜像，并检查创建的文件是否已被删除**'
- en: We reduced the size of this image from 96 MB to around 6.5 MB, and it still
    appears to work. Quite a saving!
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个镜像的大小从96 MB减少到大约6.5 MB，并且它仍然看起来可以工作。节省了很多！
- en: '|  |'
  id: totrans-2058
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-2059
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: This technique, like overclocking your CPU, is not an optimization for the unwary.
    This particular example works well because it’s an application that’s quite limited
    in scope, but your mission-critical business application is likely to be more
    complex and dynamic in how it accesses files. You could easily remove a file that
    wasn’t accessed on your run, but that is needed at some other point.
  id: totrans-2060
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术，就像超频CPU一样，并不是对粗心大意者的优化。这个特定的例子之所以效果良好，是因为它是一个范围相当有限的应用程序，但您的关键业务应用程序可能更复杂和动态，在访问文件方面。您可能会轻易删除在运行期间未访问但可能在其他某个时刻需要的文件。
- en: '|  |'
  id: totrans-2061
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If you’re a little nervous of potentially breaking your image by removing files
    you’ll need later, you can use the /tmp/candidates.txt file to get a list of the
    biggest files that were untouched, like this:'
  id: totrans-2062
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对通过删除将来需要的文件而可能破坏镜像感到有些紧张，您可以使用/tmp/candidates.txt文件来获取未更改的最大文件列表，如下所示：
- en: '[PRE173]'
  id: totrans-2063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: You can then remove the larger files that you’re sure won’t be needed by your
    application. There can be big wins here too.
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以删除那些您确信应用不需要的大文件。这里同样可以取得显著的成效。
- en: '**DISCUSSION**'
  id: totrans-2065
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Although this technique has been presented as a Docker technique, it falls into
    the category of “generally useful” techniques that can be applied in other contexts.
    It’s particularly useful when debugging processes where you don’t know quite what’s
    happening, and you want to see which files are being referenced. `strace` is another
    option for doing this, but `inotifywait` is in some ways an easier tool to use
    for this purpose.
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种技术被作为Docker技术提出，但它属于“通常有用”的技术类别，可以在其他环境中应用。它在调试你不太清楚发生了什么的过程时特别有用，你希望看到哪些文件被引用。`strace`是另一种执行此操作的方法，但`inotifywait`在某些方面是一个更容易使用的工具。
- en: This general approach is also used as one avenue of attack in [technique 97](kindle_split_027.xhtml#ch14sb06)
    in the context of reducing the attack surface of a container.
  id: totrans-2067
  prefs: []
  type: TYPE_NORMAL
  zh: 这种一般方法也被用作减少容器攻击面的一个攻击途径，在[技术97](kindle_split_027.xhtml#ch14sb06)的背景下。
- en: '|  |'
  id: totrans-2068
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-2069
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Big can be beautiful**'
  id: totrans-2070
  prefs: []
  type: TYPE_NORMAL
  zh: '**大可以很美**'
- en: Although this section is about keeping images small, it’s worth remembering
    that small is not necessarily better. As we’ll discuss, a relatively large monolithic
    image can be more efficient than a small one.
  id: totrans-2071
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本节是关于保持镜像小，但值得记住的是，小不一定更好。正如我们将讨论的，一个相对较大的单体镜像可能比一个小型镜像更有效率。
- en: '**PROBLEM**'
  id: totrans-2072
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to reduce disk space use and network bandwidth due to Docker images.
  id: totrans-2073
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要减少Docker镜像的磁盘空间使用和网络带宽。
- en: '**SOLUTION**'
  id: totrans-2074
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Create a universal, large, monolithic base image for your organization.
  id: totrans-2075
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的组织创建一个通用、大型的单体基础镜像。
- en: It’s paradoxical, but a large monolithic image could save you disk space and
    network bandwidth.
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: 这看似矛盾，但一个大的单体镜像可能会节省磁盘空间和网络带宽。
- en: Recall that Docker uses a copy-on-write mechanism when its containers are running.
    This means that you could have hundreds of Ubuntu containers running, but only
    a small amount of additional disk space is used for each container started.
  id: totrans-2077
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当Docker容器运行时，Docker使用的是写时复制机制。这意味着你可能有数百个Ubuntu容器在运行，但每个启动的容器只使用少量的额外磁盘空间。
- en: If you have lots of different, smaller images on your Docker server, as in [figure
    7.1](#ch07fig01), more disk space may be used than if you have one larger monolithic
    image with everything you need in it.
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你你的Docker服务器上有许多不同的、较小的镜像，如图7.1所示，那么使用的磁盘空间可能比有一个包含所有所需内容的较大单体镜像要多。
- en: Figure 7.1\. Many small base images vs. fewer large base images
  id: totrans-2079
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1. 许多小型基础镜像与较少的大型基础镜像
- en: '![](Images/07fig01_alt.jpg)'
  id: totrans-2080
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig01_alt.jpg)'
- en: You may be reminded of the principle of a shared library. A shared library can
    be loaded by multiple applications at once, reducing the amount of disk and memory
    needed to run the required programs. In the same way, a shared base image for
    your organization can save space, as it only needs to be downloaded once and should
    contain everything you need. Programs and libraries previously required in multiple
    images are now only required once.
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想起共享库的原则。共享库可以被多个应用程序同时加载，从而减少运行所需程序所需的磁盘和内存量。同样，为你的组织创建一个共享的基础镜像可以节省空间，因为它只需要下载一次，并且应该包含你所需的一切。之前在多个镜像中需要的程序和库现在只需要一次。
- en: In addition, there can be other benefits of sharing a monolithic, centrally
    managed image across teams. The maintenance of this image can be centralized,
    improvements can be shared, and issues with the build need only be solved once.
  id: totrans-2082
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，跨团队共享一个中央管理的单体镜像还可以带来其他好处。这个镜像的维护可以集中化，改进可以共享，构建过程中出现的问题只需要解决一次。
- en: 'If you’re going to adopt this technique, here are some things to watch out
    for:'
  id: totrans-2083
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算采用这种技术，以下是一些需要注意的事项：
- en: The base image should be reliable first. If it doesn’t behave consistently,
    the users will avoid using it.
  id: totrans-2084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础镜像首先应该是可靠的。如果它表现不一致，用户会避免使用它。
- en: Changes to the base image must be tracked somewhere that’s visible so that users
    can debug problems themselves.
  id: totrans-2085
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础镜像的更改必须在用户可以查看的地方进行跟踪，以便用户可以自己调试问题。
- en: Regression tests are essential to reduce confusion when updating the vanilla
    image.
  id: totrans-2086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归测试对于更新基础镜像时减少混淆是必不可少的。
- en: Be careful about what you add to the base—once it’s in the base image, it’s
    hard to remove, and the image can bloat fast.
  id: totrans-2087
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基础镜像中添加的内容要小心，一旦它被添加到基础镜像中，就很难移除，镜像可能会迅速膨胀。
- en: '**DISCUSSION**'
  id: totrans-2088
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: We used this technique to great effect in our 600-strong development company.
    A monthly build of core applications was bundled into a large image and published
    on the internal Docker registry. Teams would build on the so-called “vanilla”
    corporate image by default, and create bespoke layers if necessary on top of that.
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的600人开发公司中有效地使用了这项技术。核心应用程序的每月构建被捆绑到一个大型镜像中，并发布到内部Docker注册库。团队默认基于所谓的“纯”企业镜像进行构建，如果需要，可以在其上创建定制层。
- en: It’s worth taking a look at [technique 12](kindle_split_013.xhtml#ch03sb03)
    for some additional details on monolithic containers—particularly for the mention
    of the phusion/base image Docker image, an image designed with running multiple
    processes in mind.
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
  zh: 值得查看[技术12](kindle_split_013.xhtml#ch03sb03)以获取有关单体容器的一些额外细节——特别是关于phusion/base镜像Docker镜像的提及，这是一个考虑到运行多个进程而设计的镜像。
- en: '|  |'
  id: totrans-2091
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-2092
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: '`ENTRYPOINT` is another way to start Docker containers that allows runtime
    parameters to be configured.'
  id: totrans-2093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`是另一种启动Docker容器的方法，它允许在运行时配置参数。'
- en: Flattening images can be used to prevent the leakage of secrets from your build
    via your image’s layers.
  id: totrans-2094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过扁平化镜像可以防止构建过程中的机密信息通过镜像层泄露。
- en: Packages foreign to your chosen base image’s distribution can be integrated
    using Alien.
  id: totrans-2095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用Alien将不属于所选基础镜像发行版的软件包集成。
- en: Traditional build tools such as `make`, as well as modern ones like Chef, still
    have their place in the Docker world.
  id: totrans-2096
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的构建工具，如`make`，以及现代的如Chef，在Docker世界中仍然有其位置。
- en: Docker images can be reduced using smaller base images, using languages appropriate
    to the task, or removing unnecessary files.
  id: totrans-2097
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用更小的基础镜像、使用适合任务的编程语言或删除不必要的文件来减小Docker镜像的大小。
- en: It’s worth considering whether the size of your image is the most important
    challenge to tackle.
  id: totrans-2098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到镜像的大小是否是您需要解决的最重要挑战是值得考虑的。
