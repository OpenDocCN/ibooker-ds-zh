- en: Chapter 7\. Sufficiently advanced technology...
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 7 章\. 足够先进的技术...
- en: '|  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: '*More advanced features of classes*'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类的高级特性*'
- en: '*Generators*'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成器*'
- en: '*Functional programming*'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*函数式编程*'
- en: '|  |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In this chapter, we’re going to be looking at some of the more advanced tasks
    Python can do. In [chapter 1](kindle_split_009.html#ch01), you learned that Python
    is known as a multi-paradigm language, which means it doesn’t confine you to just
    one way of doing things. There are three main styles of programming: imperative,
    object-oriented, and functional. Python lets you work with all three, and even
    mix and match them where necessary.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Python 可以执行的一些更高级的任务。在 [第 1 章](kindle_split_009.html#ch01) 中，你了解到
    Python 被称为多范式语言，这意味着它不会限制你只使用一种方式做事。有三种主要的编程风格：命令式、面向对象和函数式。Python 允许你使用所有这三种风格，甚至在必要时混合匹配它们。
- en: We’ve already covered imperative and most of object-oriented programming in
    the chapters so far, so this chapter will focus mostly on functional programming
    and the more advanced parts of object-oriented programming in Python.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的章节中介绍了命令式和大部分面向对象编程，所以本章将主要关注函数式编程和 Python 面向对象编程的更高级部分。
- en: Object orientation
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向对象
- en: 'Let’s start by taking a second look at how object-oriented classes should be
    organized, using two separate methods: mixin classes and the *super()* method.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先重新审视一下面向对象类应该如何组织，使用两种独立的方法：混入类（mixin classes）和 *super()* 方法。
- en: Mixin classes
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 混入类
- en: Sometimes you don’t need an entire class to be able to do something. Perhaps
    you only need to add logging, or the ability to save the state of your class to
    disk. In these cases, you could add the functionality to a base class, or to each
    class that needs it, but that can get pretty repetitive. There’s an easier way,
    called a *mixin class*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你不需要整个类就能完成某件事。也许你只需要添加日志记录，或者将你的类状态保存到磁盘的能力。在这些情况下，你可以将功能添加到基类，或者添加到每个需要它的类，但这可能会变得相当重复。有一种更简单的方法，称为
    *混入类*。
- en: The idea is that a mixin class contains only a small, self-contained piece of
    functionality, usually a few methods or variables, which are unlikely to conflict
    with anything in the child class. Take a look at this listing, which creates a
    *Loggable* class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是混入类只包含一小块独立的功能，通常是一两个方法或变量，这些不太可能与子类中的任何内容冲突。看看这个列表，它创建了一个 *Loggable* 类。
- en: Listing 7.1\. A logging mixin
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.1\. 一个日志混入
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The mixin class is defined in exactly the same way as a regular class. Here,
    you add a class variable for the file name and a method to write a line to that
    file. If you want to use the mixin class, all you need to do is inherit from it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 混入类（mixin class）的定义方式与普通类完全相同。在这里，你添加一个用于文件名的类变量和一个将行写入该文件的方法。如果你想使用混入类，你所需要做的就是从它继承。
- en: Once you’re in the child class, all of the mixin’s methods and variables become
    available, and you can override them if you need to.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你进入了子类，所有的混入方法（mixin’s methods）和变量（variables）都将可用，并且如果你需要的话，你可以覆盖它们。
- en: Using simple file logging like this works well, but the following listing features
    a slightly more involved version that uses Python’s built-in logging module. The
    advantage of this version is that, as your program grows, you can take advantage
    of some of the different logging methods—you can send it to your system’s logs,
    or automatically roll over to a new file if the old one gets too big.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种简单的文件日志记录方式效果很好，但下面的列表展示了一个稍微复杂一些的版本，它使用了 Python 的内置日志模块。这个版本的优势在于，随着你的程序增长，你可以利用一些不同的日志方法——你可以将其发送到系统日志，或者当旧日志文件变得太大时自动滚动到新文件。
- en: Listing 7.2\. Using Python’s logging module
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.2\. 使用 Python 的日志模块
- en: '![](ch07list2-0.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07list2-0.jpg)'
- en: '![](ch07list2-1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07list2-1.jpg)'
- en: Rather than rely on class methods, it’s better to instantiate them properly
    from an `__init__` method ![](one.jpg). This way, you can take care of any extra
    initialization you need to do, or require that variables be specified on creation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与其依赖类方法，不如从 `__init__` 方法（![](one.jpg)）正确实例化它们。这样，你可以处理任何额外的初始化工作，或者要求在创建时指定变量。
- en: '![](f0221-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](f0221-01.jpg)'
- en: '![](two.jpg) is all the setup you need to do when creating a logger from Python’s
    logging module. First, you create a logger instance. Then, you can add a handler
    to it, to specify what happens to log entries, and a formatter to that handler,
    to tell it how to write out log lines.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![设置日志器](two.jpg) 是在从 Python 的 logging 模块创建日志器时需要做的所有设置。首先，你创建一个日志器实例。然后，你可以向其中添加一个处理器，以指定日志条目的处理方式，以及向该处理器添加一个格式化器，以告诉它如何写出日志行。'
- en: Your mixin class also needs methods so you can log ![](three.jpg). One option
    is to use a generic log method that you give a severity when you call it, but
    a cleaner way is to use the logger’s methods like *debug*, *info*, *warn*, *error*,
    and *critical*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你的混入类也需要方法，这样你就可以记录 ![记录日志](three.jpg)。一个选项是使用一个通用的日志方法，你在调用它时提供严重性，但更干净的方法是使用日志器的
    *debug*、*info*、*warn*、*error* 和 *critical* 等方法。
- en: Now that you’re using *__init__* in *Loggable*, you’ll need to find a way to
    call it ![](four.jpg). There are two ways. The first is to call each parent class
    explicitly by using its name and method directly, but passing in *self*. The second
    is to use Python’s *super()* method, which finds the method in the next parent
    class. In this case, they do much the same thing, but *super()* properly handles
    the case where you have a common grandparent class. See the next section for potential
    problems when using this method, and the sample code in super_test.py in the code
    tarball for this book.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在 *Loggable* 中使用了 *__init__*，你需要找到一种方法来调用它 ![调用方法](four.jpg)。有两种方法。第一种是明确地通过使用其名称和方法直接调用每个父类，但传递
    *self*。第二种是使用 Python 的 *super()* 方法，它会在下一个父类中查找方法。在这种情况下，它们做的是同一件事，但 *super()*
    正确处理了你有共同祖父母类的情况。参见下一节，了解使用此方法时可能遇到的问题，以及本书代码包中的 super_test.py 中的示例代码。
- en: Once all that’s done, you can use the logging class exactly the same way you
    did in the previous version ![](five.jpg). Note that you’ve also exposed the logger
    object itself, so if you need to, you can call its methods directly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，你可以像在之前的版本中一样使用日志类 ![使用日志类](five.jpg)。请注意，你已暴露了日志器对象本身，因此如果你需要，可以直接调用其方法。
- en: super() and friends
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: super() 和朋友
- en: 'Using the *super()* method with *diamond inheritance* (see [figure 7.1](#ch07fig01))
    can be fraught with peril—the main reason being that, when you use it with common
    methods such as *__init__*, you’re not guaranteed which class’s *__init__* method
    you’ll be calling. Each will be called, but they could be in any order. To cover
    for these cases, it helps to remember the following things when using *super()*:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *super()* 方法与 *菱形继承*（参见 [图 7.1](#ch07fig01)）可能会充满危险——主要原因是当你与常见的如 *__init__*
    方法一起使用时，你不能保证调用的是哪个类的 *__init__* 方法。每个都会被调用，但它们的调用顺序可能是任意的。为了应对这些情况，在使用 *super()*
    时，记住以下事项是有帮助的：
- en: Figure 7.1\. A diamond inheritance structure
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.1\. 菱形继承结构
- en: '![](07fig01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1](07fig01.jpg)'
- en: Use ***kwargs*, avoid using plain arguments, and always pass all the arguments
    you receive to any parent methods. Other parent methods might not have the same
    number or type of arguments as the subclass, particularly when calling *__init__*.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ***kwargs*，避免使用普通参数，并且始终将你接收到的所有参数传递给任何父方法。其他父方法可能没有与子类相同数量或类型的参数，尤其是在调用
    *__init__* 时。
- en: If one of your classes uses *super()*, then they all should. Being inconsistent
    means an *__init__* method might not be called or might be called twice.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的某个类使用了 *super()*，那么它们都应该使用。不一致意味着 *__init__* 方法可能不会被调用，或者可能被调用两次。
- en: You don’t necessarily *need* to use *super()* if you can design your programs
    to avoid diamond inheritance—that is, without parent classes sharing a grandparent.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你能够设计程序以避免菱形继承——也就是说，没有父类共享祖父母，那么你不必 necessarily 使用 *super()*。
- en: Now that you have a better sense of how classes should be organized and what
    to watch out for when using multiple inheritance, let’s take a look at some of
    the other things you can do with classes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对类应该如何组织以及在使用多重继承时需要注意什么有了更好的理解，让我们来看看你可以用类做的一些其他事情。
- en: Customizing classes
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义类
- en: Python gives you a great deal of power when it comes to defining how the methods
    in your class work and which methods are called. Not only do you have access to
    all of Python’s introspection power, but you can also decide to use different
    methods at runtime—even methods that don’t exist.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到定义你的类中的方法如何工作以及哪些方法被调用时，Python 给你提供了大量的权力。你不仅能够访问 Python 的所有反射能力，还可以决定在运行时使用不同的方法——甚至可以使用不存在的方法。
- en: When Python looks up an attribute or method on a class (for example, *self.log_file_name*
    or *test.do_something()* in [listing 7.2](#ch07list2)), it will look up that value
    in a dictionary called *__dict__*. *__dict__*stores all the user-defined values
    for a class and is used for most lookups, but it’s possible to override it at
    several points.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Python 在类上查找属性或方法（例如，[列表 7.2](#ch07list2) 中的 `self.log_file_name` 或 `test.do_something()`）时，它将在名为
    `__dict__` 的字典中查找该值。`__dict__` 存储类的所有用户定义值，并用于大多数查找，但可以在几个点上覆盖它。
- en: Python provides a number of possible ways to customize attribute access by overriding
    some built-in methods. You do so in the same way you’ve been using *__init__*
    to initialize classes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了多种方法来通过覆盖一些内置方法来自定义属性访问。你以与使用 `__init__` 初始化类相同的方式这样做。
- en: __getattr__
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`__getattr__`'
- en: '*__getattr__* is used to provide methods or attributes when they’re not found
    in the class or a parent class. You can use this to catch missing methods or write
    wrappers around other classes or programs. The following listing shows how you
    can use the *__getattr__* method to override the way Python looks up missing attributes.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getattr__` 用于在类或父类中找不到方法或属性时提供方法或属性。你可以使用它来捕获缺失的方法或围绕其他类或程序编写包装器。下面的列表展示了如何使用
    `__getattr__` 方法来覆盖 Python 查找缺失属性的方式。'
- en: Listing 7.3\. Using `__getattr__`
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.3\. 使用 `__getattr__`
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The *__getattr__* method takes one argument, the attribute name, and returns
    what the value should be. In this case, you print the name and then return a default
    value, but you could do anything—log to a file, call an API, or hand over the
    responsibility to another class or function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getattr__` 方法接收一个参数，即属性名称，并返回该值应该是什么。在这种情况下，你打印名称然后返回一个默认值，但你可以做任何事情——记录到文件、调用
    API 或将责任转交给另一个类或函数。'
- en: Now when you try to access a value that doesn’t exist in the class, *__getattr__*
    will step in and return your default value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你尝试访问类中不存在的值时，`__getattr__` 将介入并返回你的默认值。
- en: Because *__getattr__* is only called when the attribute isn’t found, setting
    an attribute first means that *__getattr__* won’t be run.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `__getattr__` 只在找不到属性时调用，所以首先设置属性意味着 `__getattr__` 不会运行。
- en: Now that you can get your attributes, let’s also learn how to set them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以获取你的属性了，让我们也学习如何设置它们。
- en: __setattr__
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`__setattr__`'
- en: '*__setattr__* is used to change the way that Python alters attributes or methods.
    You can intercept calls to your class, log them, or do whatever you need to. The
    following listing shows a simple way to catch attribute access and redirect it
    to a different dictionary instead of inserting it into the default *__dict__.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`__setattr__` 用于改变 Python 修改属性或方法的方式。你可以拦截对类的调用，记录它们，或者做你需要做的任何事情。下面的列表展示了捕获属性访问并将其重定向到不同的字典而不是将其插入到默认的
    `__dict__` 中的简单方法。'
- en: Listing 7.4\. Using __setattr__
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.4\. 使用 `__setattr__`
- en: '![](07list04_alt.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![07list04_alt.jpg](07list04_alt.jpg)'
- en: '![](one.jpg) is where you set *things*, which will store all the attributes
    you’ll set. One catch when using *__setattr__* is that you can’t directly set
    something in the class, because that will result in *__setattr__* calling itself
    and looping until Python runs out of recursion room. You’ll need to set the value
    in the class’s *__dict__* attribute directly, as you do here.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![one.jpg](one.jpg) 是你设置 `things` 的地方，它将存储你将设置的 所有属性。使用 `__setattr__` 时的一个陷阱是，你不能直接在类中设置某些东西，因为这会导致
    `__setattr__` 调用自身并循环，直到 Python 耗尽递归空间。你需要直接在类的 `__dict__` 属性中设置值，就像你在这里做的那样。'
- en: '![](f0225-01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![f0225-01.jpg](f0225-01.jpg)'
- en: Once *things* is set in *__dict__*, though, you can read from it normally, because
    *__getattr__* won’t be called when you access *self.things*. *__setattr__* takes
    a name and a value, and in this case you’re inserting the value into the *things*
    dictionary ![](two.jpg) instead of into the class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在 `__dict__` 中设置了 `things`，你就可以正常读取它，因为当你访问 `self.things` 时不会调用 `__getattr__`。`__setattr__`
    接收一个名称和一个值，在这种情况下，你将值插入到 `things` 字典中 ![two.jpg](two.jpg) 而不是类中。
- en: This version of *__getattr__* looks in the *self.things* dictionary for your
    value ![](three.jpg). If it’s not there, you raise an *AttributeError* to mimic
    Python’s normal handling.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的 `__getattr__` 在 `self.things` 字典中查找你的值 ![three.jpg](three.jpg)。如果不在那里，你将引发一个
    `AttributeError` 来模拟 Python 的正常处理。
- en: The class you’ve written behaves exactly like a normal class, except you have
    close to complete control over how its methods and attributes are read ![](four.jpg).
    If you want to override everything, though, you’ll need to use *__getattribute__*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的类表现得就像一个正常类一样，除了你几乎完全控制其方法和属性的读取方式 ![](four.jpg)。不过，如果你想覆盖一切，你将需要使用 *__getattribute__*。
- en: __getattribute__
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: __getattribute__
- en: Another approach is to override all method access entirely. If *__getattribute__*
    exists in your class, it will be called for all method and attribute access, right?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是完全覆盖所有方法访问。如果你的类中存在 *__getattribute__*，它将为所有方法和属性访问被调用，对吧？
- en: Well, that’s sort of true. Strictly speaking, even *__getattribute__* doesn’t
    override everything. There are still a number of methods, such as *__len__* and
    *__init__*, which are accessed directly by Python and won’t be overridden. But
    everything else, even *__dict__*, goes through *__getattribute__*. This works,
    but in practice it means you’ll have a hard time getting to any of your attributes.
    If you try something like *self.thing*, then you’ll end up in an infinite *__getattribute__*
    loop.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这在某种程度上是正确的。严格来说，甚至 *__getattribute__* 也不是覆盖一切。还有一些方法，如 *__len__* 和 *__init__*，是直接由
    Python 访问的，不会被覆盖。但其他所有内容，包括 *__dict__*，都通过 *__getattribute__* 进行。这可以工作，但在实践中意味着你将很难访问任何属性。如果你尝试像
    *self.thing* 这样的操作，最终你会陷入无限循环的 *__getattribute__*。
- en: 'How do you fix this? *__getattribute__* won’t be much use if you can’t access
    the real variables. The answer is to use a different version of *__getattribute__*:
    the one you would normally be using if you hadn’t just overridden it. The easiest
    way to get to a fresh *__getattribute__* is via the base *object* class, and feed
    in *self* as the instance. The following listing shows you how.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你该如何解决这个问题？如果你无法访问真实变量，那么 *__getattribute__* 将不会有多大用处。答案是使用 *__getattribute__*
    的另一个版本：如果你没有覆盖它，你通常会使用的那个版本。获取一个全新的 *__getattribute__* 的最简单方法是通过基类 *object*，并将
    *self* 作为实例传入。下面的列表显示了如何做到这一点。
- en: Listing 7.5\. Using `__getattribute__`
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.5\. 使用 `__getattribute__`
- en: '![](ch07list5-0.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07list5-0.jpg)'
- en: '![](ch07list5-1.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07list5-1.jpg)'
- en: Python methods are functions, so it’s relatively easy to call back to *object*.
    The only thing you need to do is to pass it *self* as the instance, and the name
    of the attribute you want ![](one.jpg). I’ve also updated *__init__* so you can
    pass in values to set up the internal *things* dictionary.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Python 方法是函数，所以调用回 *object* 相对容易。你需要做的只是传递 *self* 作为实例，以及你想要 ![](one.jpg) 的属性的名称。我还更新了
    *__init__*，这样你就可以传入值来设置内部 *things* 字典。
- en: To tidy up the calls to object, you can define a helper function to make the
    call for you. ![](two.jpg) is a version of *__setattr__* that uses it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了整理对对象的调用，你可以定义一个辅助函数来为你进行调用。![](two.jpg) 是使用它的 *__setattr__* 的一个版本。
- en: Other than the fact that you need to use *object* to get the dictionary you’re
    editing, the call to *__getattribute__* ![](three.jpg) is much like the one to
    *__getattr__*; it receives a name and returns a value, converting *KeyError* to
    *AttributeError* along the way.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你需要使用 *object* 来获取你正在编辑的字典之外，对 *__getattribute__* 的调用 ![](three.jpg) 与对 *__getattr__*
    的调用非常相似；它接收一个名称并返回一个值，在过程中将 *KeyError* 转换为 *AttributeError*。
- en: After you’ve been through all that, your class is ready to be used ![](four.jpg).
    It follows the same usage pattern, but you can now hide the *things* dictionary
    from casual inspection (it’s still visible if you use the old *object.__getattribute__*,
    though).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在经历所有这些之后，你的类就准备好使用了 ![](four.jpg)。它遵循相同的用法模式，但现在你可以从普通检查中隐藏 *things* 字典（尽管如果你使用旧的
    *object.__getattribute__*，它仍然可见）。
- en: If using *__getattribute__* seems like a lot of work, don’t worry. Most of the
    time, you won’t need to use it. But many third-party libraries make use of it
    in addition to *__getattr__* and *__setattr__*. If you need to use them, they
    can save a lot of work and make your class interfaces a lot more Pythonic and
    easy to use.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 *__getattribute__* 看起来像是一项繁重的工作，请不要担心。大多数时候，你不需要使用它。但许多第三方库除了使用 *__getattr__*
    和 *__setattr__* 之外，还使用了它。如果你需要使用它们，它们可以节省大量工作，并使你的类接口更加 Pythonic 和易于使用。
- en: '![](f0227-01.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](f0227-01.jpg)'
- en: Properties
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 属性
- en: A more specific method for customizing your attributes is to use Python’s *property*
    function. Whereas *__getattr__* and *__getattribute__* work across the entire
    class, *property* allows you to specify functions, commonly known as *getters*
    and *setters*, that are responsible for controlling access to an attribute or
    method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更具体的自定义属性的方法是使用 Python 的 *property* 函数。与 *__getattr__* 和 *__getattribute__*
    在整个类中工作不同，*property* 允许你指定函数，通常称为 *获取器* 和 *设置器*，它们负责控制对属性或方法的访问。
- en: 'Properties solve a common programming problem: how to customize attribute access
    without altering your class’s external interface. Without properties, it’s standard
    practice to use getters and setters for every attribute, even if you don’t need
    them, due to the difficulty in switching from attribute access to using a function.
    Python allows you to do this without having to change everything that uses your
    class. The next listing shows how you might create an integer attribute that can
    only be set to an integer from 0 to 31.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 属性解决了常见的编程问题：如何在不妨碍你的类的外部接口的情况下自定义属性访问。如果没有属性，通常的做法是为每个属性使用获取器和设置器，即使你不需要它们，也由于从属性访问切换到使用函数的困难。Python
    允许你这样做，而无需更改使用你的类的所有内容。接下来的列表显示了如何创建一个只能设置为 0 到 31 之间的整数的整数属性。
- en: Listing 7.6\. Using properties
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.6\. 使用属性
- en: '![](07list06_alt.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![07list06_alt.jpg](07list06_alt.jpg)'
- en: The initial setup ![](one.jpg) looks similar to any class’s *__init__* function.
    Some introductions set the hidden variable directly; but I prefer it this way,
    because it means you can’t have *x* set to something out of bounds.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 初始设置 ![one.jpg](one.jpg) 与任何类的 *__init__* 函数类似。一些介绍直接设置隐藏变量；但我更喜欢这种方式，因为它意味着你不能将
    *x* 设置为超出范围的值。
- en: '![](two.jpg) is your getter, which returns the value of *_x*—although you could
    convert it to whatever you liked, or even return *None*.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![two.jpg](two.jpg) 是你的获取器，它返回 *_x* 的值——尽管你可以将其转换为任何你喜欢的值，甚至可以返回 *None*。'
- en: '![](three.jpg) is your setter, which first checks to make sure the value is
    an integer from 0 to 31\. If it isn’t, then you raise a *ValueError*.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![three.jpg](three.jpg) 是你的设置器，它首先检查确保值是一个 0 到 31 之间的整数。如果不是，那么你将引发一个 *ValueError*。'
- en: 'Finally, you set *x* on the class to be a property ![](four.jpg) and pass it
    the getter and setter functions, *get_x* and *set_x*. Note that you can also define
    a read-only property if you only pass a getter. If you then try to set *x*, you’ll
    get *AttributeError: can''t set attribute*.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，你将 *x* 设置为类的属性 ![four.jpg](four.jpg) 并传递获取器和设置器函数，*get_x* 和 *set_x*。请注意，你也可以定义一个只读属性，如果你只传递获取器。如果你尝试设置
    *x*，你会得到 *AttributeError: can''t set attribute*。'
- en: If you didn’t know it was a property, you wouldn’t be able to tell by using
    the class. The interface ![](five.jpg) for your defined *x* is exactly the same
    as if it were a regular attribute.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道它是一个属性，你将无法通过使用类来识别。你定义的 *x* 的接口 ![five.jpg](five.jpg) 与它是一个常规属性时的接口完全相同。
- en: The only exception to the interface is the one you’ve included. If you try to
    set the value of *test2.x* to something out of bounds, you’ll get an exception
    ![](six.jpg).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的例外是你所包含的接口。如果你尝试将 *test2.x* 的值设置为一个超出范围的值，你会得到异常 ![six.jpg](six.jpg)。
- en: In practice, you’ll want to use the methods that are most suited for your use
    case. Some situations, such as logging, wrapping a library, and security checking,
    call for *__getattribute__* or *__getattr__*, but if all you need to do is customize
    a few specific methods, then properties are normally the best way to do it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，你将希望使用最适合你用例的方法。在某些情况下，例如日志记录、包装库和安全性检查，需要使用 *__getattribute__* 或 *__getattr__*，但如果你需要定制的只是几个特定的方法，那么属性通常是完成这项工作的最佳方式。
- en: '![](f0229-01.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![f0229-01.jpg](f0229-01.jpg)'
- en: Emulating other types
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟其他类型
- en: One other common practice is to write classes to emulate certain types, such
    as lists or dictionaries. If you have a class that is supposed to behave similarly
    to a list or a number, it helps when the class behaves in exactly the same way,
    supporting the same methods and raising the same exceptions when you misuse it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的做法是编写类来模拟某些类型，例如列表或字典。如果你有一个应该与列表或数字类似行为的类，当类以完全相同的方式行为，在误用时支持相同的方法和抛出相同的异常时，这会有所帮助。
- en: There are a number of methods you can define that Python will use when you use
    your class in certain ways. For example, if you need two instances of your class
    to compare as equal, you can define an *__eq__* method that takes two objects
    and returns *True* if they should be treated as equal.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义一些方法，Python 在你以某种方式使用你的类时会使用这些方法。例如，如果你需要两个类的实例被视为相等，你可以定义一个 `*__eq__*`
    方法，它接受两个对象，如果它们应该被视为相等，则返回 `*True*`。
- en: 'The next listing provides an example: here, two methods are added to the previous
    class so you can compare them to each other. I’ve renamed the class *LittleNumber*,
    to make its purpose clearer (you’ll also want to rename the class name in the
    exception).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表提供了一个示例：在这里，向之前的类添加了两个方法，以便你可以将它们相互比较。我已经将类重命名为 `*LittleNumber*`，以使其目的更清晰（你还需要在异常中重命名类名）。
- en: Listing 7.7\. Extending properties
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.7\. 扩展属性
- en: '![](ch07list7-0.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![ch07list7-0.jpg](ch07list7-0.jpg)'
- en: '![](ch07list7-1.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![ch07list7-1.jpg](ch07list7-1.jpg)'
- en: This method ![](one.jpg) checks the value against the other one you’re given.
    Whenever Python encounters *a == b*, it will call *a.__eq__(b)* to figure out
    what the real value should be.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法 ![one.jpg](one.jpg) 将值与提供的其他值进行比较。每当 Python 遇到 `*a == b*` 时，它将调用 `*a.__eq__(b)*`
    来确定实际值应该是什么。
- en: In the same way as *__eq__*, *__lt__* ![](two.jpg) will compare two values and
    return *True* if the current instance is less than the one passed in.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `*__eq__*` 类似，`*__lt__*` ![two.jpg](two.jpg) 将比较两个值，如果当前实例小于传入的实例，则返回 `*True*`。
- en: '*__add__* is also useful and should return the result of adding something to
    the class ![](three.jpg). This case is somewhat more complex—you return a new
    *LittleNumber* if you’re passed an integer or another *LittleNumber*, but you
    need to catch two cases: where the value goes out of bounds and where someone
    passes you a different type, such as a string. If you can’t (or won’t) handle
    a particular case, you can return *NotImplemented*, and Python will raise a *TypeError*.
    Again, a more understandable error message here will save you a lot of debugging
    further down the track.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`__add__` 也是一个有用的方法，它应该返回将某个东西添加到类中的结果 ![three.jpg](three.jpg)。这种情况稍微复杂一些——如果你传入一个整数或另一个
    `*LittleNumber*`，你应该返回一个新的 `*LittleNumber*`，但你需要捕获两种情况：值超出范围和有人传入不同的类型，例如字符串。如果你无法（或不愿意）处理特定情况，你可以返回
    `*NotImplemented*`，Python 将引发一个 `*TypeError*`。同样，这里的一个更易于理解的错误消息将帮助你节省大量的调试时间。'
- en: Believe it or not, that’s all you need to get your class to behave something
    like an integer ![](four.jpg). Note that you don’t necessarily need to implement
    all of the mirror functions like *__gt__* and *__ne__*, because Python will try
    their opposites if they’re not defined. All of the expressions here should return
    *True*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，这就是你需要让你的类表现得像整数 ![four.jpg](four.jpg) 的所有内容。请注意，你不必实现所有像 `*__gt__*` 和
    `*__ne__*` 这样的镜像函数，因为如果它们未定义，Python 将尝试它们的相反函数。这里的所有表达式都应该返回 `*True*`。
- en: Here’s a table of some of the most common methods you’ll want to override if
    you’re providing a class similar to some of the built-in types.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个表格，列出了一些你可能会想要覆盖的常见方法，如果你提供的是一个类似于内置类型的类。
- en: Table 7.1\. Common methods you may want to override
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 7.1\. 可能需要覆盖的常见方法
- en: '| Type | Methods | Description |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 方法 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Most types | __eq__(self, other) __ne__(self, other)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '| 大多数类型 | `__eq__(self, other)` `__ne__(self, other)`'
- en: __gt__(self, other)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`__gt__(self, other)`'
- en: __lt__(self, other)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`__lt__(self, other)`'
- en: __le__(self, other)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`__le__(self, other)`'
- en: __ge__(self, other) | Tests for equality and relative value, ==, !=, >, <, <=,
    and >=. |
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`__ge__(self, other)` | 测试相等和相对值，==, !=, >, <, <=, 和 >=。|'
- en: '|   | __str__(self) __repr__(self) | Returns a printable version of the class
    and a printable representation of the class. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|   | `__str__(self)` `__repr__(self)` | 返回类的可打印版本和类的可打印表示。|'
- en: '| Dictionary, list, or other container | __getitem__(self, key) __setitem__(self,
    key, value)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '| 字典、列表或其他容器 | `__getitem__(self, key)` `__setitem__(self, key, value)`'
- en: __delitem__(self, key) | Gets, sets, and deletes an entry. |
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`__delitem__(self, key)` | 获取、设置和删除条目。|'
- en: '|   | keys(self) | Returns a list of keys (dictionaries only). |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|   | `keys(self)` | 返回键的列表（仅适用于字典）。|'
- en: '|   | __len__(self) | Returns the number of entries. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|   | `__len__(self)` | 返回条目数。|'
- en: '|   | __iter__(self) and iterkeys(self) | If your object is large, you might
    want to consider using these methods to return an iterator (see the next section
    for details). |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|   | `__iter__(self)` 和 `iterkeys(self)` | 如果你的对象很大，你可能想考虑使用这些方法来返回一个迭代器（有关详细信息，请参阅下一节）。|'
- en: '|   | __contains__(self, value) | The value of an entry (of a list or set),
    or a key (of a dictionary). |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|    | `__contains__(self, value)` | 一个条目（列表或集合）的值，或一个键（字典）。|'
- en: '| Numbers | __add__(self, other) __sub__(self, other)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '| 数字 | `__add__(self, other)` `__sub__(self, other)`'
- en: __mul__(self, other)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`__mul__(self, other)`'
- en: __floordiv__(self, other)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`__floordiv__(self, other)`'
- en: __pow__(self, other) | Returns the result of adding, multiplying, dividing,
    and raising to a power. |
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`__pow__(self, other)` | 返回加法、乘法、除法和幂运算的结果。|'
- en: '|   | __int__(self) __float__(self) | Converts an instance of a class into
    an integer or float. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|    | `__int__(self)` `__float__(self)` | 将类的实例转换为整数或浮点数。|'
- en: These are by no means the only methods you can set, but they’re by far the most
    common, unless you’re doing something exotic. Let’s look at a practical example
    of how these methods are used in practice, by examining Python’s generators and
    iterators.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绝对不是你可以设置的唯一方法，但它们是最常见的，除非你在做某些异乎寻常的事情。让我们通过检查Python的生成器和迭代器来实际看看这些方法是如何在现实中使用的。
- en: Generators and iterators
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成器和迭代器
- en: Generators are one of Python’s best-kept secrets after list comprehensions,
    and they’re worth looking into in more detail. They’re intended to solve the problem
    of storing state in between function calls, but they’re also useful for cases
    where you need to deal with large amounts of data, perhaps too large to fit easily
    in memory.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是Python在列表推导式之后最好的秘密之一，并且值得更详细地研究。它们旨在解决在函数调用之间存储状态的问题，但它们在需要处理大量数据的情况下也很有用，可能太大而无法轻松地放入内存中。
- en: First we’ll look at iterators, Python’s method for dealing with looping objects.
    Then we’ll look at how you can make use of generators to quickly deal with large
    amounts of data in log files.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看看迭代器，Python处理循环对象的常用方法。然后，我们将看看如何利用生成器快速处理日志文件中的大量数据。
- en: Iterators
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 迭代器
- en: You’ve been using iterators throughout the book, right from [chapter 2](kindle_split_010.html#ch02),
    because every time you use a *for* loop or a list comprehension, iterators have
    been acting behind the scenes. You don’t need to know how iterators work in order
    to make use of them, but they’re useful for understanding how generators operate.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你在整本书中一直在使用迭代器，从[第2章](kindle_split_010.html#ch02)开始，因为每次你使用一个*for*循环或列表推导式时，迭代器都在幕后工作。你不需要知道迭代器是如何工作的，才能使用它们，但了解它们对于理解生成器的工作方式是有用的。
- en: '|  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Iterators are a common solution to a frequent programming task: you have a
    bunch of things—now how do you do something to each one of them? The trick is
    that most Python collections, be they lists, files, or sets, can be used as iterators.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是解决常见编程任务的一种常见方法：你有一堆东西——现在你如何对它们中的每一个都做些什么呢？诀窍在于，大多数Python集合，无论是列表、文件还是集合，都可以用作迭代器。
- en: '|  |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The interface of an iterator is straightforward. It has a *.next()* method,
    which you call over and over again to get each value in the sequence. Once all
    the values are gone, the iterator raises a *StopIteration* exception, which tells
    Python to stop looping. In practice, using an iterator looks something like [figure
    7.2](#ch07fig02).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器的接口很简单。它有一个*.next()*方法，你可以一次又一次地调用它来获取序列中的每个值。一旦所有的值都消失了，迭代器会引发一个*StopIteration*异常，这告诉Python停止循环。在实践中，使用迭代器看起来就像[图7.2](#ch07fig02)所示。
- en: 'Figure 7.2\. The iterator protocol: once you run through three iterations,
    it stops.'
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.2\. 迭代器协议：一旦运行了三次迭代，它就会停止。
- en: '![](07fig02.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig02.jpg)'
- en: When you ask Python to iterate over an object such as a list, the first thing
    it does is call *iter(object)*, which calls that object’s *__iter__* method and
    expects to get an iterator object. You don’t need to use the *__iter__* call directly
    unless you’re creating your own custom iterator. In that case, you’ll need to
    implement both the *__iter__* and the *next()* methods yourself. This listing
    shows how to use the *iter* function to create an iterator from any iterable Python
    object.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你要求Python遍历一个如列表这样的对象时，它首先做的事情是调用*iter(object)*，这会调用那个对象的*__iter__*方法，并期望得到一个迭代器对象。除非你正在创建自己的自定义迭代器，否则你不需要直接使用*__iter__*调用。在这种情况下，你需要自己实现*__iter__*和*next()*方法。这个列表显示了如何使用*iter*函数从任何可迭代的Python对象创建迭代器。
- en: Listing 7.8\. Using an iterator the hard way
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.8\. 使用迭代器的困难方式
- en: '![](07list08.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07list08.jpg)'
- en: 'You use the *iter()* function to create an iterator object for *my_list* ![](one.jpg).
    If you print it, you can see that’s it’s a new type of object—a *listiterator*—
    not a list. When you call the *next()* method of your iterator ![](two.jpg), it
    returns the values from the list: 1, 2, and 3.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用*iter()*函数为*my_list*创建一个迭代器对象![one.jpg]。如果你打印它，你可以看到它是一个新的对象类型——*listiterator*——而不是列表。当你调用迭代器的*next()*方法![two.jpg]时，它返回列表中的值：1、2和3。
- en: Once you’ve run out of values ![](three.jpg), the iterator will raise a *StopIteration*
    exception to signal that the iterator has finished.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用完了值![three.jpg]，迭代器将引发*StopIteration*异常来表示迭代器已结束。
- en: '![](f0234-01.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![f0234-01.jpg]'
- en: The iterator protocol is simple, but it’s a fundamental underpinning of the
    looping and iteration mechanisms in Python. Let’s have a look at how generators
    use this protocol to make your programming life easier.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器协议很简单，但它是Python中循环和迭代机制的基本基础。让我们看看生成器是如何使用这个协议来使你的编程生活更轻松的。
- en: Generators
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成器
- en: 'Generators are similar to iterators. They use exactly the same *.next()* method,
    but they’re easier to create and to understand. Generators are defined exactly
    like functions, except they use a *yield* statement instead of a *return*. Here’s
    a simple example of a generator, which counts down to zero from a specified value:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器类似于迭代器。它们使用完全相同的*.next()*方法，但更容易创建和理解。生成器的定义方式与函数完全相同，只是它们使用*yield*语句而不是*return*语句。以下是一个简单的生成器示例，它从指定的值开始倒数到零：
- en: '![](f0235-01.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![f0235-01.jpg]'
- en: Let’s look at this one step at a time.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地来看。
- en: Generators start out like functions, including the way you give them arguments
    ![](one.jpg). We’re also including a debugging string here, so you can follow
    how the generator is called.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器开始时就像函数一样，包括你给它们的参数![one.jpg]。我们还在这里包含了一个调试字符串，这样你就可以跟踪生成器是如何被调用的。
- en: Generators need some way to return values repeatedly, so usually you’ll see
    a loop ![](two.jpg) within the body.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器需要某种方式来重复返回值，所以通常你会在主体中看到一个循环![two.jpg]。
- en: The *yield* statement ![](three.jpg) will stop your function and return the
    value you give it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*yield*语句![three.jpg]将停止你的函数并返回你给出的值。'
- en: Finally, after each call, Python will return into the generator via the *next()*
    method. You subtract 1 from the value each time, until it’s no longer greater
    than zero, and then the generator will finish with a *StopIteration* exception.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在每次调用之后，Python将通过*next()*方法返回到生成器。你每次都从值中减去1，直到它不再大于零，然后生成器将使用*StopIteration*异常结束。
- en: That’s only half of the puzzle, though—you still need to be able to call your
    generator. The following listing shows how you can do that, by creating a counter
    and then using it in a *for* loop. You can also call it directly with a line like
    *for x in counter(5)*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只是一个谜题的一半——你仍然需要能够调用你的生成器。以下列表显示了你可以如何通过创建计数器并在*for*循环中使用它来做到这一点。你也可以直接使用一行如*for
    x in counter(5)*来调用它。
- en: Listing 7.9\. Using your counter generator
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.9\. 使用你的计数器生成器
- en: '![](07list09.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![07list09.jpg]'
- en: First, you create the counter ![](one.jpg). Even though it looks like a function,
    it doesn’t start right away; instead, it returns a generator object.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建计数器![one.jpg]。尽管它看起来像是一个函数，但它不会立即开始；相反，它返回一个生成器对象。
- en: You can use the generator object in a loop like ![](two.jpg). Python will call
    the generator repeatedly until it runs out of values or the generator exits normally.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在循环中使用生成器对象![two.jpg]。Python将反复调用生成器，直到它用完值或生成器正常退出。
- en: '![](three.jpg) is what the loop prints out. The first line is the initial debug
    from the generator, and the other lines are the results it returns.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![three.jpg]是循环打印出来的内容。第一行是生成器的初始调试信息，其他行是它返回的结果。'
- en: There’s one last mechanism you should know, which can save you a lot of time
    setting up generator functions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该知道最后一个机制，它可以节省你很多设置生成器函数的时间。
- en: Generator expressions
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: 'Generator expressions are a lot like list comprehensions, except that, behind
    the scenes, they use generators rather than building a whole list. Try running
    the following expressions in a Python prompt:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式与列表推导式非常相似，但在幕后，它们使用生成器而不是构建整个列表。尝试在Python提示符中运行以下表达式：
- en: '[PRE2]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Depending on your computer, the list comprehension will either take a long time
    to return or else raise a *MemoryError*. That’s because it’s creating a hundred
    million results and inserting them into a list.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的计算机，列表推导式要么需要很长时间才能返回，要么会引发 *MemoryError*。这是因为它正在创建一亿个结果并将它们插入到列表中。
- en: This generator, on the other hand, will return immediately. It hasn’t created
    any results at all—it will only do that if you try to iterate over *bar*. If you
    break out of that loop after 10 results, then the other 99,999,990 values won’t
    need to be calculated.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，这个生成器将立即返回。它根本就没有创建任何结果——只有当你尝试迭代 *bar* 时才会这样做。如果你在10个结果后跳出循环，那么其他999,999,990个值就不需要计算了。
- en: If generators and iterators are so great, why would you ever use lists or list
    comprehensions? They’re still useful if you want to do anything else with your
    data other than loop over it. If you want to access your values in a random order—say
    the fourth value, then the second, then the eighteenth—then your generators won’t
    help because they access values linearly from the first through to the one millionth.
    Similarly, if you need to add extra values to your list or modify them in some
    way, then generators won’t help—you’ll need a list.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成器和迭代器如此出色，为什么你还会使用列表或列表推导式呢？如果你想要对数据进行除了循环以外的任何操作，它们仍然是有用的。如果你想以随机顺序访问你的值——比如说第四个值，然后是第二个，然后是第十八个——那么你的生成器将帮不上忙，因为它们是线性地从第一个到第1000万个值访问的。同样，如果你需要向你的列表中添加额外的值或以某种方式修改它们，那么生成器将帮不上忙——你需要一个列表。
- en: Now that you know how generators work, let’s look at where they can be useful
    when you write your programs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了生成器的工作原理，让我们看看在你编写程序时它们可以在哪里发挥作用。
- en: Using generators
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用生成器
- en: As you learned at the start of the chapter, you can use generators in cases
    where reading in a large amount of data would slow your program down or make it
    run out of memory and crash.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章开头所学的，在读取大量数据会减慢程序速度或使其耗尽内存而崩溃的情况下，你可以使用生成器。
- en: '|  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In case you haven’t realized it yet, Python is an intensely pragmatic language.
    Every feature has gone through a rigorous community-based vetting process known
    as a Python Enhancement Proposal (PEP), so there will be strong use cases for
    each feature. You can read more about PEPs at [www.python.org/dev/peps/pep-0001/](http://www.python.org/dev/peps/pep-0001/).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有意识到，Python 是一种非常实用的语言。每个特性都经过了一个严格的基于社区的审查过程，称为 Python 增强提案（PEP），因此每个特性都会有强大的用例。你可以在
    [www.python.org/dev/peps/pep-0001/](http://www.python.org/dev/peps/pep-0001/)
    上了解更多关于 PEP 的信息。
- en: '|  |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](f0237-01.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0237-01.jpg)'
- en: A common problem that involves a large amount of data is the processing of files.
    If you have a few hundred log files and need to find out which ones have a certain
    string in them, or collate data across several website directories, then it can
    be hard to make sense of what’s happening within a reasonable amount of time.
    Let’s take a look at a few simple generators that can make your life easier if
    you run into this sort of problem.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及大量数据的一个常见问题是文件处理。如果你有几百个日志文件，需要找出其中哪些包含特定的字符串，或者跨几个网站目录汇总数据，那么在合理的时间内理解所发生的事情可能会很困难。让我们看看一些简单的生成器，这些生成器可以在你遇到这类问题时使你的生活变得更轻松。
- en: Reading files
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取文件
- en: One of the areas where Python makes use of generators is in the file-processing
    sections of the *os* module. *os.walk* is a good example—it allows you to iterate
    recursively through directories, building lists of the files and subdirectories
    within them, but because it builds the list as it goes, it’s nice and fast. You’ve
    already encountered *os.walk* in [chapter 3](kindle_split_011.html#ch03), when
    you were building a program to compare files. A typical use is shown in the following
    listing, which is a program to read a directory and return the files that are
    of a certain type—in this case, .log files.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在处理文件的部分使用生成器的一个领域是 *os* 模块中的文件处理部分。*os.walk* 是一个很好的例子——它允许你递归地遍历目录，构建其中文件和子目录的列表，但由于它在遍历过程中构建列表，所以它既快又好。你已经在前面的
    [第 3 章](kindle_split_011.html#ch03) 中遇到了 *os.walk*，当时你正在构建一个比较文件的程序。以下是一个典型的用法示例，它是一个读取目录并返回特定类型文件（在这种情况下，.log
    文件）的程序。
- en: Listing 7.10\. `os.walk` revisited
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.10\. `os.walk` 重新审视
- en: '![](07list10_alt.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07list10_alt.jpg)'
- en: First, you specify your directory and the file type you want to search for ![](one.jpg).
    *os.walk* returns a generator you can use to iterate over the directory ![](two.jpg).
    It will give you the path of the directory, as well as any subdirectories and
    files within it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你指定你的目录和想要搜索的文件类型 ![图片](one.jpg)。*os.walk* 返回一个生成器，你可以用它来遍历目录 ![图片](two.jpg)。它将给你目录的路径，以及它内部的任何子目录和文件。
- en: You assume that anything that ends in .log is a log file ![](three.jpg). Depending
    on your specific situation, an assumption like this may or may not be warranted,
    but because you will, in practice, have control of the web server, you can add
    the .log part if you need to.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你假设以 .log 结尾的任何东西都是日志文件 ![图片](three.jpg)。根据你的具体情况，这样的假设可能或可能不成立，但因为你实际上将控制网络服务器，如果你需要，你可以添加
    .log 部分。
- en: When you run the program in [listing 7.10](#ch07list10), it will output something
    like the following. Each section contains the directory you’re iterating over
    and then its subdirectories and the log files within the current directory.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 [代码列表 7.10](#ch07list10) 中运行程序时，它将输出类似以下内容。每个部分包含你正在迭代的目录，然后是其子目录和当前目录中的日志文件。
- en: Listing 7.11\. The output from `os.walk`
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.11。`os.walk` 的输出
- en: '[PRE3]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can use some generators to make your code a little easier to work with.
    As an example, let’s say you’re monitoring your web server for errors, so you
    want to find out which of your log files have the word *error* in them. You’d
    also like to print out the line itself so you can track down what’s going on if
    there are any errors. Here are three generators that will help you do that.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用一些生成器使你的代码更容易使用。例如，假设你正在监控你的网络服务器以查找错误，因此你想找出哪些日志文件中包含单词 *error*。你还想打印出该行本身，以便在出现错误时追踪发生了什么。这里有三个生成器可以帮助你做到这一点。
- en: Listing 7.12\. Generators to work through a directory
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.12。遍历目录的生成器
- en: '![](ch07list12-0.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch07list12-0.jpg)'
- en: '![](ch07list12-1.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch07list12-1.jpg)'
- en: '![](f0240-01.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0240-01.jpg)'
- en: This is the same code you saw in [listing 7.10](#ch07list10), but wrapped in
    a generator function ![](one.jpg). One issue with *os.walk* is that it won’t raise
    an exception if you give it a nonexistent directory or something that’s not a
    directory, so you catch both of those cases before you start.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你在 [代码列表 7.10](#ch07list10) 中看到的相同代码，但被封装在一个生成器函数中 ![图片](one.jpg)。*os.walk*
    的问题之一是，如果你给它一个不存在的目录或不是目录的东西，它不会引发异常，所以你在开始之前要捕获这两种情况。
- en: Now that you have *log_files* as a generator, you can use it to build further
    generators. *log_lines* reads each file in turn and yields successive lines of
    each log file, along with the name of the file ![](two.jpg).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了 *log_files* 生成器，你可以用它来构建更进一步的生成器。*log_lines* 逐个读取每个文件，并产生每个日志文件的连续行，以及文件的名称
    ![图片](two.jpg)。
- en: This generator builds on the *log_lines* generator to return only those lines
    that have the word *error* in them ![](three.jpg). Notice also that you’re returning
    a generator comprehension instead of using *yield*. This is an alternative way
    of doing things, one that can make sense for small generators, or where the values
    you’re returning fit the generator comprehension style well.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成器基于 *log_lines* 生成器，只返回包含单词 *error* 的行 ![图片](three.jpg)。注意，你返回的是一个生成器推导式而不是使用
    *yield*。这是做事情的一种替代方式，对于小型生成器或返回的值适合生成器推导式风格的情况来说，这可能是有意义的。
- en: Once you’ve done all the hard work of creating the generators ![](four.jpg),
    calling them is easy—give them the directory and file type, and do what you need
    to with each result.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了创建生成器的所有艰苦工作 ![图片](four.jpg)，调用它们就很容易了——给他们目录和文件类型，然后对每个结果做你需要的事情。
- en: 'Now you can find all the error lines in all the log files in a certain directory.
    Returning the lines with *error* in them isn’t particularly useful, though. What
    if you had an error that didn’t contain the word *error?*Instead, it could contain
    something like *Process #3456 out of memory!*There are all sorts of conditions
    you’d like to check in your log files, so you’ll need something a little more
    powerful.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '现在你可以在某个目录中找到所有日志文件中的错误行。返回包含 *error* 的行并不特别有用。如果你的错误不包含单词 *error* 呢？相反，它可能包含类似
    *进程 #3456 内存不足!* 这样的内容。你希望在日志文件中检查各种条件，所以你需要一些更强大的东西。'
- en: Getting to grips with your log lines
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 掌握你的日志行
- en: You’d like to have a lot more control over the data in your log files, including
    being able to filter by any field or combination of fields. In practice, this
    means you’ll need to break the data from each line in your log file up and interpret
    the bits. The following listing shows some examples from an old Apache access
    log I had lying around.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望对你的日志文件中的数据有更多的控制权，包括能够根据任何字段或字段的组合进行筛选。在实践中，这意味着你需要将日志文件中每一行的数据分割并解释这些比特。以下列表展示了从我在周围找到的一个旧的
    Apache 访问日志中的一些示例。
- en: Listing 7.13\. Apache log lines
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.13\. Apache 日志行
- en: '[PRE4]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These lines are in Apache’s Combined Log Format. Most of the fields are self
    explanatory—IP address is the computer making the request, referer is the URL
    of the page (if any) that was used to reach the page, HTTP request contains the
    path the user was requesting, size is the number of bytes transferred as a result
    of the request, and so on.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行是 Apache 的组合日志格式。大多数字段都是自解释的——IP 地址是发起请求的计算机，引用者是用于到达页面的页面（如果有）的 URL，HTTP
    请求包含用户请求的路径，大小是作为请求结果传输的字节数，等等。
- en: '![](f0241-01.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0241-01.jpg)'
- en: Figure 7.3\. An Apache log line
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.3\. Apache 日志行
- en: '![](07fig03_alt.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig03_alt.jpg)'
- en: 'In [listing 7.13](#ch07list13), you should be able to see three separate requests:
    one from Firefox running under Linux, one from Google’s search spider, and one
    from Microsoft’s MSN. As you learned in [chapter 5](kindle_split_013.html#ch05),
    the user agent string is supplied by the client and so can’t be trusted, but in
    most cases it’s accurate. The HTTP request part is the full command sent to the
    web server, so it includes the type of request (usually GET or POST) and the HTTP
    version as well as the path requested.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 7.13](#ch07list13)中，你应该能够看到三个单独的请求：一个在 Linux 下运行的 Firefox，一个来自 Google 的搜索蜘蛛，以及一个来自
    Microsoft 的 MSN。正如你在[第 5 章](kindle_split_013.html#ch05)中学到的，用户代理字符串由客户端提供，因此不能完全信赖，但在大多数情况下它是准确的。HTTP
    请求部分是发送给 Web 服务器的完整命令，因此它包括请求的类型（通常是 GET 或 POST）以及 HTTP 版本，以及请求的路径。
- en: Pulling out the bits
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提取比特
- en: That explains what the separate fields mean, but how are you going to get them?
    You could split on quotes or spaces, but it’s possible they’ll appear in odd places
    and throw the split function off track. For example, there are spaces in both
    the user-agent and the date-time string. It’s also possible to have quotes within
    the user agent string and the URL, although they’re supposed to be URL encoded.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了各个字段的意义，但你如何获取它们呢？你可以根据引号或空格进行分割，但它们可能出现在奇怪的位置，从而让分割函数偏离轨道。例如，用户代理字符串和日期时间字符串中都有空格。用户代理字符串和
    URL 中也可能包含引号，尽管它们应该是 URL 编码的。
- en: '|  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: My rule of thumb is to use Python’s string methods, like *endswith()* and *.split()*,
    when looking for simple things—but I find they can get unwieldy when you’re trying
    to match against more complicated patterns, like the Apache log line.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我的经验法则是当寻找简单事物时使用 Python 的字符串方法，如 *endswith()* 和 *.split()*，但我发现当你要匹配更复杂的模式，如
    Apache 日志行时，它们可能会变得难以控制。
- en: '|  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In cases like this, it’s usually easier to break out the big guns right at the
    start, rather than experiment with splitting the fields on various characters
    and trying to make sure it will work for everything. In this case, the fastest
    solution is probably to use a parsing tool called a *regular expression*, which
    is useful for reading single lines like this and breaking them down into chunks.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，通常最好一开始就使用强大的工具，而不是尝试用各种字符分割字段并确保它适用于所有情况。在这种情况下，最快的解决方案可能是使用一个称为 *正则表达式*
    的解析工具，这对于读取此类单行文本并将它们分解成块非常有用。
- en: Regular expressions work by using special matching characters to designate particular
    types of character, such as spaces, digits, the letters *a*to *z*, *A* to *Z*,
    and so on. A full description of the gory details of regular expressions is out
    of the scope of this book, but the handy quick reference in [table 7.2](#ch07table02)
    will get you started.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式通过使用特殊的匹配字符来指定特定的字符类型，例如空格、数字、字母 *a* 到 *z*、*A* 到 *Z* 等等。正则表达式的详细描述超出了本书的范围，但[表
    7.2](#ch07table02) 中的便捷快速参考可以帮助你入门。
- en: Table 7.2\. A regular expression cheat sheet
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 7.2\. 正则表达式速查表
- en: '| Expression | Definition |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 定义 |'
- en: '| --- | --- |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| \ | Regular expressions use a backslash for special characters. If you need
    to match an actual backslash, then you can use two backslashes together, \\. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| \ | 正则表达式使用反斜杠作为特殊字符。如果你需要匹配实际的反斜杠，则可以使用两个反斜杠一起，\\。 |'
- en: '| \w | A “word” character: *a–z*, *A–Z*, 0–9, and a few others, such as underscore.
    |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| \w | 一个“单词”字符：*a–z*，*A–Z*，0–9，以及一些其他字符，例如下划线。 |'
- en: '| \W | A non-word character—the opposite of \w. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| \W | 一个非单词字符——\w的反义词。 |'
- en: '| \s | A whitespace character, such as space or tab. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| \s | 一个空白字符，例如空格或制表符。 |'
- en: '| \S | A non-whitespace character. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| \S | 一个非空白字符。 |'
- en: '| \d | A digit character, 0–9. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| \d | 一个数字字符，0–9。 |'
- en: '| . | Any character at all. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| . | 任何字符。 |'
- en: '| + | Extends a special character to match one or more times. \w+ will match
    at least one word character, but could match 20. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| + | 将一个特殊字符扩展为匹配一次或多次。 \w+ 将匹配至少一个单词字符，但可能匹配20个。 |'
- en: '| * | Like +, but matches zero or more instead of one or more. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| * | 与 + 类似，但匹配零个或多个而不是一个或多个。 |'
- en: '| ? | You can use this after a * or + wildcard search to make them less “greedy.”
    .*? will match the minimum it can, rather than as much as possible. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| ? | 您可以在 * 或 + 通配符搜索之后使用它来使它们不那么“贪婪”。 .*? 将匹配尽可能少的字符，而不是尽可能多的字符。 |'
- en: '| () | You can put brackets around a set of characters and pull them out later
    using the .groups() method of the match object. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| () | 您可以将一组字符放在括号中，然后使用匹配对象的 .groups() 方法稍后提取它们。 |'
- en: '| [] | You can put characters between square brackets to match just those.
    [aeiou], for example, matches vowels. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| [] | 您可以在方括号内放置字符以匹配它们。例如，[aeiou] 匹配元音。 |'
- en: '| r'''' | A string preceded with r is a *raw* string, and Python won’t escape
    any backslashes within it. For example, "line 1\nline 2" will normally be split
    over multiple lines, because Python will interpret \n as a return, but r"line
    1\nline 2" won’t. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| r'''' | 前面带有 r 的字符串是一个 *原始* 字符串，Python 不会转义其内的任何反斜杠。例如，"line 1\nline 2" 通常会在多行中拆分，因为Python会将
    \n 解释为换行，但 r"line 1\nline 2" 不会。 |'
- en: '| match vs. search | Two main methods are used on the regular expression object.
    match will try to match from the start of a line, but search will look at the
    whole string. Normally, you’ll want to use search, unless you know you want to
    match at the start. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| match vs. search | 在正则表达式对象上使用了两种主要方法。match 将尝试从行的开头进行匹配，但 search 将查看整个字符串。通常，您会想使用
    search，除非您知道您想要从开头进行匹配。 |'
- en: 'The regular-expression string you’re going to use to match the Apache log lines
    looks like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您将要使用的用于匹配Apache日志行的正则表达式字符串看起来像这样：
- en: '[PRE5]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It looks complicated, but it’s not so hard if you break it down and look at
    the individual parts:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很复杂，但如果分解并查看各个部分，其实并不难：
- en: Most of the fields are groups of alphanumeric characters separated by spaces,
    so you can use *(\S+)* to match them. They’re surrounded by brackets so you can
    access the fields after they’ve been matched. Each part corresponds to one field
    in the Apache log line.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数字段都是由空格分隔的字母数字字符组，因此您可以使用 *(\S+)* 来匹配它们。它们被括号包围，这样您可以在匹配后访问字段。每个部分对应于Apache日志行中的一个字段。
- en: The date-and-time field is the only one with square brackets around it, so you
    can also match that easily and pull out everything, including spaces, with a wildcard
    match. Notice that you escape the *[* and *]* by putting a backslash in front
    of them so the regular expression treats them as normal characters.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期和时间字段是唯一一个周围有方括号的字段，因此您也可以轻松地匹配它并使用通配符匹配提取所有内容，包括空格。请注意，您通过在它们前面放置反斜杠来转义 *[*
    和 *]*，这样正则表达式就会将它们视为普通字符。
- en: The referer and the user agent are also matched using wildcards, because they
    might have quotes or spaces in them.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用者和用户代理也使用通配符进行匹配，因为它们可能包含引号或空格。
- en: The whole string is wrapped in brackets so you can break it over multiple strings
    but still have Python consider them as a single string.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个字符串被括号包围，这样您可以在多个字符串之间断开它，但Python仍然将它们视为单个字符串。
- en: '![](f0244-01.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](f0244-01.jpg)'
- en: Now that you have a rough idea of how you can use regular expressions to match
    the fields in a log line, let’s look at how you write the Python functions and
    generators to make sense of the overall scope of your log files. The following
    listing extends [listing 7.7](#ch07list7) to add new Apache-related functions
    and generators.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经大致了解了如何使用正则表达式匹配日志行中的字段，让我们看看如何编写Python函数和生成器来理解日志文件的整体范围。以下列表扩展了[列表7.7](#ch07list7)，以添加新的Apache相关函数和生成器。
- en: Listing 7.14\. Parsing Apache log lines
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.14\. 解析Apache日志行
- en: '![](ch07list14-0.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07list14-0.jpg)'
- en: '![](ch07list14-1.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07list14-1.jpg)'
- en: Before we get into the functions proper, it’s a good idea to set up some of
    the variables that you’ll need for your regular expressions ![](one.jpg). *apache_log_headers*
    is a list of names for all of the fields you’ll see in your log file, and *log_format*
    is the regular expression string we looked at earlier. You also compile *log_format*
    into *log_regexp* so your matching is faster when you’re parsing the log line.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究函数之前，设置一些你将需要的正则表达式变量是个好主意 ![](one.jpg)。*apache_log_headers* 是你在日志文件中看到的所有字段名称的列表，而
    *log_format* 是我们之前查看的正则表达式字符串。你还把 *log_format* 编译成 *log_regexp*，这样在解析日志行时匹配会更快。
- en: First, you set up a function that is responsible for parsing a single line ![](two.jpg).
    Here’s where you use the compiled regular expression object against the line you’ve
    been passed, using the *match* method. If it matches, *log_split* will be a match
    object, and you can call the *.groups()* method to extract the parts you matched
    with brackets. If there’s no match, *log_split* will be *None*, which means you
    have a line that is probably illegal. There’s not much you can do in this case,
    so you’ll return an empty dictionary.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要设置一个负责解析单行的函数 ![](two.jpg)。在这里，你将编译的正则表达式对象与传递给你的行进行匹配，使用 *match* 方法。如果匹配成功，*log_split*
    将是一个匹配对象，你可以调用 *.groups()* 方法来提取用括号匹配的部分。如果没有匹配，*log_split* 将是 *None*，这意味着你有一行可能是非法的。在这种情况下，你几乎无能为力，所以你会返回一个空字典。
- en: If your function is going to be widely useful, you’ll need to easily access
    different parts of the log line. The easiest way to do that is to put all of the
    fields into a dictionary ![](three.jpg), so you can type *line['user_agent']*
    to access the user-agent string. A fast way to do that is by using Python’s built-in
    *zip* function, which joins the fields together with the list of headers. It creates
    a sequence of tuples (identical to the results of an *.items()* call on a dictionary),
    and then you can cast that to a dictionary with the *dict()* function. Finally,
    you turn some of the results into integers to make them easier to deal with later.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的函数将被广泛使用，你需要能够轻松访问日志行的不同部分。最简单的方法是将所有字段放入一个字典 ![](three.jpg)，这样你就可以通过输入
    *line['user_agent']* 来访问用户代理字符串。一个快速的方法是使用 Python 内置的 *zip* 函数，它将字段与标题列表连接起来。它创建了一个元组序列（与在字典上调用
    *.items()* 的结果相同），然后你可以使用 *dict()* 函数将其转换为字典。最后，你将一些结果转换为整数，以便稍后更容易处理。
- en: Now that you have your line-parsing function, you can add a generator to call
    it for each line of the log file ![](four.jpg).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了你的行解析函数，你可以添加一个生成器来对日志文件的每一行调用它 ![](four.jpg)。
- en: If you have more information about what’s in the line, you can search for more
    detail in your logs ![](five.jpg). Here you’re adding up the total size of the
    requests, but only where the request is successful (a status code of 200). You
    could also do things like exclude the Google, MSN, and Yahoo spiders to get “real”
    web traffic, see what volume of traffic is referred to you by Google, or add up
    individual IP addresses to get an idea of how many unique visitors you have.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你关于行中的内容有更多信息，你可以在日志中搜索更多详细信息 ![](five.jpg)。在这里，你正在计算请求的总大小，但仅限于成功的请求（状态码为
    200）。你也可以做类似的事情，比如排除 Google、MSN 和 Yahoo 的蜘蛛，以获取“真实”的网页流量，查看有多少流量是由 Google 引用的，或者将单个
    IP 地址加起来，以了解你有多少独特的访客。
- en: When you run the program in [listing 7.14](#ch07list14), you should see a list
    of lines and their parsed representation, with a number at the end. That’s the
    number of bytes that were transferred in successful transactions. Your program
    is complete, and you can start adding to it if there are particular features you’d
    like to add.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 [列表 7.14](#ch07list14) 中运行程序时，你应该会看到一系列行及其解析表示，行尾的数字表示成功事务中传输的字节数。你的程序已经完成，如果你想要添加特定的功能，可以开始对其进行扩展。
- en: Functional programming
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数式编程
- en: As you become more familiar with programming, you’ll start to find that certain
    features are more or less error-prone than others. For example, if your program
    makes use of a lot of shared state or global variables, then you might find that
    a lot of your errors tend to be around managing that state and tracking down which
    *!$%@%* function is replacing all your values with *None*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对编程越来越熟悉，你会发现某些功能比其他功能更容易出错。例如，如果你的程序使用了大量的共享状态或全局变量，那么你可能发现很多错误都集中在管理那个状态和追踪哪个
    *!$%@%* 函数将所有值替换为 *None*。
- en: It makes sense to try to find ways to design your program that don’t involve
    error-prone features, and which are clearer and easier to understand. In turn,
    you’ll be able to write larger programs with more features, and write them faster
    than you could before.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试找到不涉及易出错特性、更清晰、更容易理解的设计程序的方法是有意义的。反过来，你将能够编写具有更多功能的更大程序，并且比以前更快地编写它们。
- en: One of those strategies is called *functional programming*. Its main criterion
    is that it uses functions that have no side effects—their output is entirely determined
    by their input, and they don’t modify anything outside the function. If a function
    is written like this, it makes it much easier to reason about and test, because
    you only need to consider the function by itself, not anything else.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这些策略之一被称为*函数式编程*。它的主要标准是它使用没有副作用（它们的输出完全由它们的输入决定，并且它们不会修改函数之外的东西）的函数。如果一个函数是这样编写的，它使得推理和测试变得更容易，因为你只需要考虑函数本身，而不需要考虑其他任何东西。
- en: Another feature of functional programming is that functions are objects in their
    own right—you can pass them as arguments to other functions and store them in
    variables. This might not seem particularly important, but it enables a lot of
    functionality that would otherwise be quite difficult to implement.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的另一个特点是函数本身就是对象——你可以将它们作为参数传递给其他函数并将它们存储在变量中。这可能看起来并不特别重要，但它使得实现许多其他情况下相当困难的功能成为可能。
- en: '![](f0247-01.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](f0247-01.jpg)'
- en: Side effects
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 副作用
- en: '*Side effects* refer to anything a function does that is outside its sphere
    of control or that doesn’t relate to the value it returns. Modifying a global
    variable or one that’s been passed in, writing to a file, and posting values to
    a URL are all examples of side effects. Functions should also only rely on values
    that are passed in, not on anything outside the function.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*副作用*指的是函数在其控制范围之外做的事情或者与它返回的值无关的事情。修改全局变量或传入的变量，写入文件，以及向URL发布值都是副作用。函数也应该只依赖于传入的值，而不是函数之外的东西。'
- en: Map and filter
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Map和filter
- en: Once you know that functions are safe to run and aren’t going to do anything
    weird, you can use them much more frequently—and for situations where you might
    not normally use functions.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道函数是安全的可以运行，并且不会做任何奇怪的事情，你就可以更频繁地使用它们——甚至是在你通常不会使用函数的情况下。
- en: Two common examples are *map* and *filter*. *map* takes a function and an iterable
    object, like a list or generator, and returns a list with the result of that function
    applied to each item in the iterable. *filter*, on the other hand, takes an iterable
    function and returns only those items for which the function returns *True*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 两个常见的例子是*map*和*filter*。*map*接受一个函数和一个可迭代对象，如列表或生成器，并返回一个包含该函数应用于可迭代对象中每个项的结果的列表。另一方面，*filter*接受一个可迭代函数，并只返回那些函数返回*True*的项。
- en: 'In the case of your log files, you might have code like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的日志文件的情况下，你可能会有这样的代码：
- en: '[PRE6]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that *extract_error* pulls the error text from a log line, and *is_error*
    tells you whether the line is an error line. The result will be a new list of
    the error messages from your log file, and the original list will be untouched.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*extract_error*从日志行中提取错误文本，而*is_error*告诉你该行是否是错误行。结果将是一个包含你的日志文件中错误消息的新列表，而原始列表将保持不变。
- en: 'But, in practice, *map* and *filter* tend to make your programs less readable
    than using something like a list comprehension:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在实践中，*map*和*filter*往往不如使用类似列表解析这样的方法使程序更易读：
- en: '[PRE7]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A better use of functional programming is to use functions to change the behavior
    of other functions and classes. A good example is the use of decorators to change
    how functions and methods behave.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的更好用途是使用函数来改变其他函数和类的行为。一个很好的例子是使用装饰器来改变函数和方法的行为。
- en: Passing and returning functions
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 传递和返回函数
- en: Decorators are essentially wrappers around other functions. They take a function
    as an argument, potentially with other arguments, and return another function
    to call in its place. To use a decorator, you place its name above the function
    you’re decorating, preceded by an *@* symbol and any arguments you need afterward,
    like a function.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器本质上是对其他函数的包装。它们接受一个函数作为参数，可能还有其他参数，并返回一个替代调用的函数。要使用装饰器，你将它的名字放在你要装饰的函数上方，前面有一个*@*符号和任何需要的参数，就像一个函数一样。
- en: A real-world example is Django’s *user_passes_test* function, shown next, which
    is used to create decorators like *login_required*. *login_required* checks to
    see whether the user is logged in, and then either returns the regular web page
    if they are (Django calls them *views*) or redirects them to the site’s login
    page if they aren’t. It’s fairly complex, but it uses most of the functional programming
    techniques described so far, plus a few others. I think you’re ready to handle
    it, and we’ll take it step by step.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一个现实世界的例子是Django的*user_passes_test*函数，如下所示，它用于创建像*login_required*这样的装饰器。*login_required*检查用户是否已登录，如果是，则返回常规网页（Django称它们为*views*），如果没有，则将其重定向到网站的登录页面。它相当复杂，但它使用了迄今为止描述的大多数函数式编程技术，以及一些其他技术。我认为你已经准备好处理它了，我们将一步一步地进行。
- en: Listing 7.15\. Django’s `user_passes_test` decorator
  id: totrans-256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.15。Django的`user_passes_test`装饰器
- en: '![](ch07list15-0.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![ch07list15-0.jpg](ch07list15-0.jpg)'
- en: '![](ch07list15-1.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![ch07list15-1.jpg](ch07list15-1.jpg)'
- en: 'The first thing to notice is that *user_passes_test* isn’t a decorator itself:
    it’s a function that returns a function for you to use as a decorator ![](one.jpg).
    This is a common trick if you need a few similar functions—pass in the bits that
    are different, and have the function return something you can use.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，*user_passes_test*本身不是一个装饰器：它是一个返回你可以用作装饰器的函数的函数![一.jpg](one.jpg)。如果你需要几个类似函数，这是一个常见的技巧——传入不同的部分，让函数返回你可以使用的东西。
- en: '![](f0250-01.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![f0250-01.jpg](f0250-01.jpg)'
- en: '![](two.jpg) is the decorator itself. Remember, all it has to do is return
    another function to use in place of *view_func*.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![装饰器本身](two.jpg)就是装饰器。记住，它只需要返回一个用于替代*view_func*的函数。'
- en: If you’re planning on writing a few decorators, it’s worth looking into *functools*![](three.jpg),
    a Python module that provides functional programming– related classes and functions.
    *wrap* makes sure the original meta information, such as the docstring and function
    name, are preserved in the final decorator. Notice also that you’re using **args*
    and ***kwargs* in your function, so the request’s arguments can be passed through
    to the real view.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算编写几个装饰器，那么查看*functools*![三.jpg](three.jpg)，一个提供函数式编程相关类和函数的Python模块是值得的。*wrap*确保原始元信息，如文档字符串和函数名，在最终的装饰器中得以保留。注意，你也在你的函数中使用了**args*和***kwargs*，所以请求的参数可以通过真实视图传递。
- en: '![](four.jpg) is the first part of the test. If *test_func* returns *True*,
    then the user is logged in, and the decorator returns the results of calling the
    real view with the same arguments and keyword arguments.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![测试的第一部分](four.jpg)是测试的第一部分。如果*test_func*返回*True*，则用户已登录，装饰器将返回使用相同参数和关键字参数调用真实视图的结果。'
- en: If they’re not logged in ![](five.jpg), then you return a redirect to the login
    page instead. Note that I’ve snipped out some extra code that figures out *path*
    based on some Django internals—but that’s not necessary to understand how the
    decorator works.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果他们没有登录![五.jpg](five.jpg)，那么你将返回一个重定向到登录页面的响应。注意，我已经剪掉了根据一些Django内部实现确定*path*的额外代码——但这不是理解装饰器工作原理所必需的。
- en: Next, you define the decorator ![](six.jpg). You call *user_passes_test* with
    the relevant arguments and get back a function you can use in place of the real
    view. You also use *lambda*, which is a Python keyword you can use to define small,
    one-line functions. If your function is much more complex than this, though, it’s
    usually better to define a separate function so you can name it and make it clearer.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你定义装饰器![六.jpg](six.jpg)。你用相关参数调用*user_passes_test*，然后得到一个可以替代真实视图的函数。你还会使用*lambda*，这是Python中的一个关键字，可以用来定义小型、单行的函数。如果你的函数比这更复杂，那么通常最好定义一个单独的函数，这样你可以给它命名并使其更清晰。
- en: 'Python will use the function returned by *login_required* in place of the real
    view ![](seven.jpg), so your *top_secret_view* function will first check to make
    sure the user is logged in before it returns any secret documents from one of
    your bunkers. You can also include arguments if you want the decorator to behave
    differently: in this case, by redirecting to a separate login system at /super_secret/login.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Python将使用*login_required*返回的函数替代真实视图![七.jpg](seven.jpg)，所以你的*top_secret_view*函数在返回任何来自你其中一个地堡的秘密文件之前，将首先检查用户是否已登录。你也可以包含参数，如果你想让装饰器有不同的行为：在这种情况下，通过重定向到/超级秘密/login的单独登录系统。
- en: The emphasis in most programming is on objects and how they interact, but there’s
    still a place for well-written, functional programs. Anywhere you need some extra
    configuration, have common functionality that can be extracted, or need to wrap
    something (without the overhead of a whole class), you can use functional programming.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程中，重点是对象及其交互，但优秀的函数式程序仍有其位置。任何需要额外配置、有可提取的公共功能或需要包装某些内容（而不需要整个类的开销）的地方，你都可以使用函数式编程。
- en: Where to from here?
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接下来该做什么？
- en: From here, you can extend your log-parsing script to capture different sorts
    of traffic. You could categorize log entries by type (visitor, logged-in user,
    search engine, bot), which section of your site they use, or what time of day
    they arrive. It’s also possible to track individuals by IP address as they use
    your site, to work out how people make use of your site or to determine what they’re
    looking for.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以扩展你的日志解析脚本以捕获不同类型的流量。你可以根据类型（访客、登录用户、搜索引擎、机器人）、网站使用的部分或到达的时间段对日志条目进行分类。还有可能通过IP地址跟踪个人在使用你的网站时的行为，以了解人们如何使用你的网站或确定他们在寻找什么。
- en: You can use Python’s generators in other types of programs, too. If you were
    reading information from web pages rather than log files, you could still use
    the same strategies to help you reduce the amount of complexity in your code or
    the number of downloads you needed. Any program that needs to reduce the amount
    of data it has to read in, or that needs to call something repeatedly but still
    maintain state, can benefit from using generators.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在其他类型的程序中使用Python的生成器。如果你是从网页而不是日志文件中读取信息，你仍然可以使用相同的策略来帮助你减少代码中的复杂性或所需的下载次数。任何需要减少读取的数据量或需要重复调用但仍然保持状态的程序，都可以从使用生成器中受益。
- en: You should also keep an eye out for areas in your programs might benefit from
    using some of the advanced functionality we looked at in this chapter. The secret
    is that, when you use it, it should make your programs simpler to understand by
    hiding the difficult or repetitive parts in a module or function. When you’re
    writing an application in Django, you only need to include *@login_required* above
    each view you want protected—you don’t need to explicitly check the request’s
    user or redirect to a login page yourself.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该留意程序中可能从本章讨论的一些高级功能中受益的区域。秘密在于，当你使用它时，它应该通过在模块或函数中隐藏困难或重复的部分来使你的程序更容易理解。当你用Django编写应用程序时，你只需要在每个你想要保护的视图中包含`@login_required`——你不需要明确检查请求的用户或自己重定向到登录页面。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the more advanced Python features, like generators
    and decorators, and you saw how you can modify classes’ behavior and bend them
    to your will.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了更高级的Python特性，如生成器和装饰器，并了解了如何修改类的行为，使它们按照你的意愿行事。
- en: You saw how to alter the way a class’s methods are looked up, catch a missing
    method, and even swap out the normal method lookups and use your own criteria.
    You saw how to transparently swap out attributes for functions by using properties,
    and make your class behave like an integer, list, or dictionary by defining special
    methods.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了如何改变查找类方法的方式，捕获缺失的方法，甚至用你自己的标准替换正常的方法查找。你看到了如何通过使用属性来透明地替换属性为函数，并通过定义特殊方法使你的类表现得像整数、列表或字典。
- en: We also looked at how to use generators to help you organize the data in your
    programs, and how they can reduce the memory required in your program by only
    loading data as it’s needed, rather than ahead of time in one big chunk. We covered
    how to link generators together to help write more complicated programs, using
    an example where you parsed information from an Apache log file. We also explored
    using the regular expression module when you need a good way to match or extract
    information from some text.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如何使用生成器来组织程序中的数据，以及它们如何通过仅在需要时加载数据而不是一次性加载一大块数据来减少程序所需的内存。我们介绍了如何将生成器链接起来以帮助编写更复杂的程序，通过一个解析Apache日志文件信息的例子来说明。我们还探讨了在需要一种好方法来匹配或从某些文本中提取信息时使用正则表达式模块。
- en: Finally, we discussed functional programming, and you saw how Python supports
    it with *map* and *filter*, in addition to having functions that can be assigned
    to a variable. Then we looked at decorators and how they work in practice by defining
    and returning different functions.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了函数式编程，你看到了Python如何通过*map*和*filter*支持它，此外还有可以分配给变量的函数。然后我们探讨了装饰器以及它们在实际中是如何通过定义和返回不同的函数来工作的。
- en: We’ve covered most of Python’s features, so from here on, we’re going to take
    a slightly different tack and look at some common libraries that are used with
    Python. In the next chapter, we’ll examine Django, the main web framework used
    with Python.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了Python的大部分特性，所以从现在开始，我们将采取稍微不同的方法，来看看一些与Python一起使用的常见库。在下一章中，我们将研究Django，这是Python使用的主要Web框架。
