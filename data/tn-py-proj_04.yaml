- en: '3 Going on a picnic: Working with lists'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 去野餐：使用列表
- en: Writing code makes me hungry! Let’s write a program to list some tasty foods
    we’d like to eat.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 写代码让我饿了！让我们写一个程序来列出一些我们想吃的美食。
- en: So far we’ve worked with single variables, like a name to say “hello” to or
    a nautical-themed object to point out. In this program, we want to keep track
    of one or more foods that we will store in a `list`, a variable that can hold
    any number of items. We use lists all the time in real life. Maybe it’s your top-five
    favorite songs, your birthday wish list, or a bucket list of the best types of
    buckets.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们处理的是单个变量，比如一个名字来打招呼，或者一个航海主题的对象来指出。在这个程序中，我们想要跟踪一个或多个我们将存储在 `list` 中的食物，`list`
    是一个可以存储任意数量项目的变量。我们在现实生活中经常使用列表。也许它是你最喜欢的五首歌曲，你的生日愿望清单，或者是一个最佳类型桶的清单。
- en: In this chapter, we’re going on a picnic, and we want to print a list of items
    to bring along. You will learn to
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将去野餐，并想打印一个要携带的项目列表。你将学习到
- en: Write a program that accepts multiple positional arguments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个接受多个位置参数的程序
- en: Use `if`, `elif`, and `else` to handle conditional branching with three or more
    options
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `if`、`elif` 和 `else` 来处理三个或更多选项的条件分支
- en: Find and alter items in a list
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中查找和修改项目
- en: Sort and reverse lists
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对列表进行排序和反转
- en: Format a list into a new string
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将列表格式化为新的字符串
- en: '| The items for the list will be passed as positional arguments. When there
    is only one item, you’ll print that:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '| 列表中的项目将通过位置参数传递。当只有一个项目时，你会打印它：'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '| ![](../Images/3-unnumb-1.png) |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/3-unnumb-1.png) |'
- en: '| What? Who just brings salad on a picnic? When there are two items, you’ll
    print “and” between them:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '| 什么？谁会在野餐时带沙拉？当有两个项目时，你会在它们之间打印“和”：'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '| ![](../Images/3-unnumb-2.png) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/3-unnumb-2.png) |'
- en: '| Hmm, chips. That’s an improvement. When there are three or more items, you’ll
    separate the items with commas:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '| 嗯，薯片。这是一个改进。当有三个或更多项目时，你会用逗号分隔它们：'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There’s one other twist. The program will also need to accept a `--sorted` argument
    that will require you to sort the items before you print them. We’ll deal with
    that in a bit. | ![](../Images/3-unnumb-3.png) |
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个转折。程序还需要接受一个 `--sorted` 参数，这将要求你在打印之前对项目进行排序。我们稍后会处理这个问题。 | ![](../Images/3-unnumb-3.png)
    |
- en: 'So, your Python program must do the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你的Python程序必须执行以下操作：
- en: Store one or more positional arguments in a `list`
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中存储一个或多个位置参数
- en: Count the number of arguments
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算参数数量
- en: Possibly sort the items
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能对项目进行排序
- en: Use the `list` to print a new a string that formats the arguments according
    to how many items there are
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `list` 打印一个新字符串，该字符串根据项目数量格式化参数
- en: How should we begin?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何开始？
- en: 3.1 Starting the program
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 启动程序
- en: I will always recommend you start programming by running new.py or by copying
    template/template.py to the program name. This time the program should be called
    picnic.py, and you need to create it in the 03_picnic directory.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是会推荐你通过运行 new.py 或将 template/template.py 复制到程序名称来开始编程。这次程序应该叫做 picnic.py，并且你需要将其创建在
    03_picnic 目录中。
- en: 'You can do this using the new.py program from the top level of your repository:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用存储在存储库顶层的 new.py 程序来做这件事：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now go into the 03_picnic directory and run `make` `test` or `pytest` `-xv`
    `test.py`. You should pass the first two tests (program exists, program creates
    usage) and fail the third:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进入 03_picnic 目录并运行 `make` `test` 或 `pytest` `-xv` `test.py`。你应该通过前两个测试（程序存在，程序创建用法）并失败第三个测试：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The rest of the output complains that the test expected “You are bringing chips”
    but got something else:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的输出抱怨测试期望的是“你将带来薯片”，但得到的是其他东西：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① The program is being run with the argument “chips.”
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ① 程序正在使用参数“chips”运行。
- en: ② This line is causing the error. The output is tested to see if it is equal
    (==) to the string “You are bringing chips.”
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ② 这行代码导致了错误。输出被测试以查看它是否等于字符串“你将带来薯片”。
- en: ③ The line starting with a + sign shows what was expected.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 以加号开始的行显示了预期的内容。
- en: ④ The lines starting with the - sign show what was returned by the program.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 以减号开始的行显示了程序返回的内容。
- en: 'Let’s run the program with the argument “chips” and see what it gets:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用参数“chips”运行程序，看看它会得到什么：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Right, that’s not correct at all! Remember, the template doesn’t yet have the
    *correct* arguments, just some examples, so the first thing we need to do is fix
    the `get_args()` function. Your program should print a usage statement like the
    following if given *no arguments*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对，这完全不对！记住，模板还没有正确的参数，只是提供了一些示例，所以我们需要做的第一件事是修复 `get_args()` 函数。如果给定的 *无参数*，你的程序应该打印出如下用法说明：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And here is the usage for the `-h` or `--help` flags:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `-h` 或 `--help` 标志的用法：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We need one or more positional arguments and an optional flag called `--sorted`.
    Modify your `get_args()` until it produces the preceding output.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个或多个位置参数和一个名为 `--sorted` 的可选标志。修改你的 `get_args()` 函数，直到它产生前面的输出。
- en: Note that there should be one or more of the `item` parameter, so you should
    define it with `nargs='+'`. Refer to section A.4.5 in the appendix for details.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，应该有一个或多个 `item` 参数，因此你应该使用 `nargs='+'` 来定义它。有关详细信息，请参阅附录中的 A.4.5 部分。
- en: 3.2 Writing picnic.py
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 编写 picnic.py
- en: Figure 3.1 shows a tasty diagram of the inputs and outputs for the picnic.py
    program we’ll write.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 展示了我们将要编写的 picnic.py 程序的输入和输出。
- en: '![](../Images/3-1.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-1.png)'
- en: Figure 3.1 A string diagram of the picnic program showing the various inputs
    and outputs the program will handle
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 picnic 程序的字符串图，显示了程序将处理的各个输入和输出
- en: 'The program should accept one or more positional arguments for the items to
    bring on a picnic as well as an `-s` or `--sorted` *flag* to indicate whether
    or not to sort the items. The output will be “You are bringing” followed by the
    list of items formatted according to the following rules:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 程序应该接受一个或多个位置参数，用于携带野餐的物品，以及一个 `-s` 或 `--sorted` 标志来指示是否对物品进行排序。输出将是“你将携带”，然后是按照以下规则格式化的物品列表：
- en: 'If there’s one item, state the item:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有一个项目，请说明该项目：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If there are two items, put “and” in between the items. Note that “potato chips”
    is just *one string* that happens to contain *two words*. If you leave out the
    quotes, there would be three arguments to the program. It doesn’t matter here
    whether you use single or double quotes:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有两个物品，在物品之间放置“and”。注意，“potato chips”只是一个恰好包含两个单词的 *单个字符串*。如果你省略引号，程序会有三个参数。这里你使用单引号还是双引号无关紧要：
- en: '[PRE10]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If there are three or more items, place a comma and space between the items
    and the word “and” before the final element. Don’t forget the comma before the
    “and” (sometimes called the “Oxford comma”) because your author was an English
    lit major and, while I may have finally stopped using two spaces after the end
    of a sentence, you can pry the Oxford comma from my cold, dead hands:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有三个或更多物品，在物品和“and”之前放置一个逗号和空格，并在最后一个元素之前放置一个逗号（有时称为“牛津逗号”），因为你的作者是一名英语文学专业的学生，虽然我可能最终停止在句子末尾使用两个空格，但你可以从我冰冷、死去的双手中夺走牛津逗号：
- en: '[PRE11]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Be sure to sort the items if the `-s` or `--sorted` flag is specified:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了 `-s` 或 `--sorted` 标志，请确保对物品进行排序：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To figure out how many items we have, how to sort and slice them, and how to
    format the output string, we need to talk about the `list` type in Python.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了弄清楚我们有多少个物品，如何对它们进行排序和切片，以及如何格式化输出字符串，我们需要讨论 Python 中的 `list` 类型。
- en: 3.3 Introducing lists
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 列表介绍
- en: It’s time to learn how to define positional arguments so that they are available
    as a `list`. That is, if we run the program like this,
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候学习如何定义位置参数，以便它们可以作为 `list` 使用。也就是说，如果我们像这样运行程序，
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'the arguments `salad` `chips` `cupcakes` will be available as a `list` of strings
    inside the program. If you `print()` a `list` in Python, you’ll see something
    like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 `salad` `chips` `cupcakes` 将作为程序内部的字符串 `list` 可用。如果你在 Python 中 `print()`
    一个 `list`，你会看到如下内容：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '| The square brackets tell us this is a `list`, and the quotes around the elements
    tell us they are strings. Note that the items are shown in the same order as they
    were provided on the command line. Lists always keep their order! | ![](../Images/3-unnumb-4.png)
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 方括号告诉我们这是一个 `list`，元素周围的引号告诉我们它们是字符串。注意，物品的顺序与命令行上提供的顺序相同。列表总是保持其顺序！ | ![图片](../Images/3-unnumb-4.png)
    |'
- en: Let’s go into the REPL and create a variable called `items` to hold some scrumptious
    victuals to bring on our picnic. I really want you to type these commands yourself,
    whether in the `python3` REPL or IPython or a Jupyter Notebook. It’s very important
    to interact in real time with the language.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入 REPL，创建一个名为 `items` 的变量来保存一些美味的食物，以便在野餐上携带。我真的很希望你自己输入这些命令，无论是在 `python3`
    REPL、IPython 还是 Jupyter Notebook 中。与语言进行实时交互非常重要。
- en: 'To create a new, empty `list`, you can use the `list()` function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的空 `list`，你可以使用 `list()` 函数：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Or you can use empty square brackets:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用空方括号：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Check what Python says for the `type()`. Yep, it’s a `list`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 Python 对 `type()` 的输出。是的，它是一个 `list`：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'One of the first things we need to know is how many `items` we have for our
    picnic. Just as with a `str`, we can use `len()` (length) to get the number of
    elements in `items`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道的第一件事是我们要为野餐准备多少 `items`。就像 `str` 一样，我们可以使用 `len()`（长度）来获取 `items` 中的元素数量：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The length of an empty `list` is `0`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 空列表的长度是 `0`。
- en: 3.3.1 Adding one element to a list
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 向列表中添加一个元素
- en: 'An empty `list` is not very useful. Let’s see how we can add new items. We
    used `help(str)` in the last chapter to read documentation about the string methods--the
    functions that belong to every `str` in Python. Here I want you to use `help(list)`
    to learn about the `list` methods:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 空列表并不很有用。让我们看看我们如何添加新项目。我们在上一章中使用了 `help(str)` 来阅读有关字符串方法的文档——属于 Python 中每个
    `str` 的函数。这里我想让你使用 `help(list)` 来了解 `list` 方法：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Remember that pressing the spacebar or *F* key (or Ctrl-F) will take you forward,
    and pressing *B* (or Ctrl-B) will take you back. Pressing the / key will let you
    search for a string.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，按空格键或 *F* 键（或 Ctrl-F）可以前进，按 *B* 键（或 Ctrl-B）可以后退。按 / 键可以搜索字符串。
- en: You’ll see lots of “double-under” methods, like `__len__`. Skip over those,
    and the first method is `list.append()`, which we can use to add items to the
    end of a `list`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到很多“双下划线”方法，比如 `__len__`。跳过那些，第一个方法就是 `list.append()`，我们可以用它来向列表的末尾添加项目。
- en: 'If we evaluate `items`, the empty brackets will tell us that it’s empty:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们评估 `items`，空括号会告诉我们它是空的：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s add “sammiches” to the end:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向列表末尾添加“sammiches”：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Nothing happened, so how do we know if it worked? Let’s check the length. It
    should be `1`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 没有发生任何事，那么我们怎么知道它是否成功了？让我们检查长度。它应该是 `1`：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Hooray! That worked. In the spirit of testing, we’ll use the `assert` statement
    to verify that the length is `1`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 欢呼！这成功了。在测试的精神下，我们将使用 `assert` 语句来验证长度是 `1`：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The fact that nothing happens is good. When an assertion fails, it triggers
    an exception that results in a lot of messages.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 什么都没发生是好事。当断言失败时，它会触发一个异常，导致大量消息输出。
- en: 'If you type `items` and press Enter in the REPL, Python will show you the contents:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入 `items` 并在 REPL 中按 Enter 键，Python 将会显示其内容：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Cool, we added one element.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 好极了，我们添加了一个元素。
- en: 3.3.2 Adding many elements to a list
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 向列表中添加多个元素
- en: 'Let’s try to add “chips” and “ice cream” to `items`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将“chips”和“ice cream”添加到 `items` 中：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is one of those pesky exceptions, and these will cause your programs to
    *crash*, something we want to avoid at all costs. As you can see, `append()` `takes`
    `exactly` `one` `argument`, and we gave it two. If you look at `items`, you’ll
    see that nothing was added:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个讨厌的异常，这些异常会导致你的程序 *崩溃*，我们无论如何都想避免这种情况。正如你所看到的，`append()` 函数需要 `exactly`
    一个 `argument`，而我们给了它两个。如果你查看 `items`，你会看到什么都没加：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'OK, so maybe we were supposed to give it a `list` of items to add? Let’s try
    that:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，也许我们本应该给它一个要添加的 `list`？让我们试试：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Well, that didn’t cause an exception, so maybe it worked? We would expect there
    to be three `items`, so let’s use an assertion to check that:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这并没有引发异常，所以可能它成功了？我们预计会有三个 `items`，所以让我们用一个断言来检查一下：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We get another exception, because `len(items)` is not `3`. What is the length?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们又遇到了另一个异常，因为 `len(items)` 不是 `3`。长度是多少？
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Only `2`? Let’s look at `items`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 只有 `2` 个？让我们看看 `items`：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Check that out! Lists can hold any type of data, like strings and numbers and
    even other lists (see figure 3.2). We asked `items.append()` to add `['chips',`
    `'ice` `cream']`, which is a `list`, and that’s just what it did. Of course, it’s
    not what we wanted.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一下！列表可以存储任何类型的数据，比如字符串、数字，甚至其他列表（见图 3.2）。我们要求 `items.append()` 添加 `['chips',`
    `'ice` `cream']`，这是一个列表，这正是它所做的事情。当然，这并不是我们想要的。
- en: '![](../Images/3-2.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片 3-2](../Images/3-2.png)'
- en: Figure 3.2 A list can hold any mix of values, such as a string and another list
    of strings.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 列表可以存储任何混合类型的数据，例如字符串和另一个字符串列表。
- en: 'Let’s reset `items` so we can fix this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重置 `items` 以便修复这个问题：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you read further into the help, you will find the `list.extend()` method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你继续阅读帮助文档，你会找到 `list.extend()` 方法：
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '| Let’s try that:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '| 让我们试试：'
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '| ![](../Images/3-unnumb-5.png) |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| ![图片 3-5](../Images/3-unnumb-5.png) |'
- en: 'Well that’s frustrating! Now Python is telling us that `extend()` `takes` `exactly`
    `one` `argument`, which, if you refer to the `help`, should be an `iterable`.
    A `list` is something you can iterate (travel over from beginning to end), so
    that will work:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，真让人沮丧！现在Python告诉我们`extend()``恰好`需要`一个`参数，如果你查看`help`，它应该是一个`iterable`。`list`是一种你可以迭代的（从头到尾遍历）东西，所以这会起作用：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Nothing happened. No exception, so maybe that worked? Let’s check the length.
    It *should* be 3:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 没有发生任何事情。没有异常，所以可能成功了？让我们检查长度。它*应该*是3：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Yes! Let’s look at the items we’ve added:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！让我们看看我们添加的项目：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Great! This is sounding like a pretty delicious outing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！这听起来像是一次相当美味的出行。
- en: 'If you know everything that will go into the `list`, you can create it like
    so:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道将要放入`list`中的所有内容，你可以这样创建它：
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `list.append()` and `list.extend()` methods add new elements to the *end*
    of a given `list`. The `list.insert()` method allows you to place new items at
    any position by specifying the index. I can use the index `0` to put a new element
    at the beginning of `items`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`list.append()`和`list.extend()`方法将新元素添加到给定`list`的*末尾*。`list.insert()`方法允许你通过指定索引将新项目放置在任何位置。我可以使用索引`0`将新元素放在`items`的开始位置：'
- en: '[PRE38]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'I recommend you read through all the `list` functions so you get an idea of
    just how powerful this data structure is. In addition to `help(list)`, you can
    also find lots of great documentation here: [https://docs.python.org/3/tutorial/datastructures.html](https://docs.python.org/3/tutorial/datastructures.html).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你阅读所有的`list`函数，这样你就可以了解这个数据结构有多强大。除了`help(list)`之外，你还可以在这里找到很多优秀的文档：[https://docs.python.org/3/tutorial/datastructures.html](https://docs.python.org/3/tutorial/datastructures.html)。
- en: 3.3.3 Indexing lists
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 列表索引
- en: We now have a `list` of items. We know how to use `len()` to find how many items
    there are in the `items` list, and now we need to know how to get parts of the
    `list` to format.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`list`。我们知道如何使用`len()`来找出`items`列表中有多少个项目，现在我们需要知道如何获取列表的部分来格式化。
- en: Indexing a `list` in Python looks exactly the same as indexing a `str` (figure
    3.3). (This actually makes me a bit uncomfortable, so I tend to imagine a `str`
    as a `list` of characters, and then I feel somewhat better.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Python中`list`的索引看起来与`str`的索引完全相同（图3.3）。（这实际上让我有点不舒服，所以我倾向于想象一个`str`是一个字符的`list`，然后我感觉好一些。）
- en: '![](../Images/3-3.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-3.png)'
- en: Figure 3.3 Indexing lists and strings is the same. For both, you start counting
    at 0, and you can also use negative numbers to index from the end.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 列表和字符串的索引是相同的。对于两者，你都是从0开始计数的，你也可以使用负数来从末尾索引。
- en: 'All indexing in Python is zero-offset, so the first element of `items` is at
    index `items[0]`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的所有索引都是零偏移的，所以`items`的第一个元素在索引`items[0]`：
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If the index is negative, Python starts counting backwards from the end of
    the `list`. The index `-1` is the last element of the `list`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引是负数，Python将从`list`的末尾开始反向计数。索引`-1`是`list`的最后一个元素：
- en: '[PRE40]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You should be very careful when using indexes to reference elements in a `list`.
    This is unsafe code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用索引来引用`list`中的元素时，你应该非常小心。这是不安全的代码：
- en: '[PRE41]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Warning Referencing an index that is not present will cause an exception.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 引用不存在的索引将导致异常。
- en: You’ll soon learn how to safely *iterate*, or travel through, a `list` so that
    you don’t have to use indexes to get at elements.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快就会学会如何安全地*迭代*，或者遍历`list`，这样你就不必使用索引来获取元素。
- en: 3.3.4 Slicing lists
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.4 列表切片
- en: You can extract “slices” (sub-lists) of a `list` by using `list[start:stop]`.
    To get the first two elements, you use `[0:2]`. Remember that the `2` is actually
    the index of the *third* element, but it’s not inclusive, as shown in figure 3.4.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`list[start:stop]`来从`list`中提取“切片”（子列表）。要获取前两个元素，你使用`[0:2]`。记住，`2`实际上是第三个元素的索引，但它不是包含的，如图3.4所示。
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![](../Images/3-4.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-4.png)'
- en: Figure 3.4 The `stop` value for a list slice is not included. If the `stop`
    value is omitted, the slice goes to the end of the list.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 列表切片的`stop`值不包括在内。如果省略了`stop`值，切片将延伸到列表的末尾。
- en: 'If you leave out `start`, it will default to a value of `0`, so the following
    line does the same thing:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你省略了`start`，它将默认为`0`的值，所以以下行做的是同样的事情：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you leave out `stop`, it will go to the end of the `list`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你省略了`stop`，它将延伸到`list`的末尾：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Oddly, it is completely *safe* for slices to use `list` indexes that don’t
    exist. For example, we can ask for all the elements from index `10` to the end,
    even though there is nothing at index `10`. Instead of an exception, we get an
    empty `list`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，切片使用不存在的`列表`索引是完全**安全的**。例如，我们可以要求从索引`10`到末尾的所有元素，即使索引`10`处没有任何内容。而不是异常，我们得到一个空的`列表`：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For this chapter’s exercise, you’re going to need to insert the word “and” into
    the `list` if there are three or more elements. Could you use a `list` index to
    do that?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的练习，你需要将单词“and”插入到`列表`中，如果列表中有三个或更多元素。你能使用`列表`索引来完成这个操作吗？
- en: 3.3.5 Finding elements in a list
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.5 在列表中查找元素
- en: Did we remember to pack the chips?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们记得要带上薯片吗？
- en: 'Often you’ll want to know if some item is in a `list`. The `index` method will
    return the location of an element in a `list`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可能会想知道某个项目是否在`列表`中。`index`方法将返回元素在`列表`中的位置：
- en: '[PRE46]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Note that `list.index()` is unsafe code, because it will cause an exception
    if the argument is not present in the `list`. See what happens if we check for
    a fog machine:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`list.index()`是不安全的代码，因为它如果参数不在`列表`中将会引发异常。看看如果我们检查一个烟雾机会发生什么：
- en: '[PRE47]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You should never use `list.index()` unless you have first verified that an
    element is present. The `x` `in` `y` approach that we used in chapter 2 to see
    if a letter was in a string of vowels can also be used for lists. We get back
    a `True` value if `x` is `in` the collection of `y`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不应该使用`list.index()`，除非你首先验证元素是否存在。我们在第2章中使用`x in y`方法来检查一个字母是否在元音字符串中，也可以用于列表。如果`x`在`y`的集合中，我们得到一个`True`值：
- en: '[PRE48]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '| I hope they’re salt and vinegar chips.The same code returns `False` if the
    element is not present:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '| 我希望它们是盐和醋味的薯片。如果元素不存在，相同的代码会返回`False`：'
- en: '[PRE49]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We’re going to need to talk to the planning committee. What’s a picnic without
    a fog machine? | ![](../Images/3-unnumb-6.png) |
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要与规划委员会谈谈。没有烟雾机，野餐会是什么样子？| ![](../Images/3-unnumb-6.png) |
- en: 3.3.6 Removing elements from a list
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.6 从列表中删除元素
- en: The `list.pop()` method will remove *and return* the element at the index, as
    shown in figure 3.5\. By default it will remove the *last* item (`-1`).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`list.pop()`方法将删除并返回索引处的元素，如图3.5所示。默认情况下，它将删除最后一个项目（`-1`）。'
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![](../Images/3-5.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-5.png)'
- en: Figure 3.5 The `list.pop()` method will remove an element from the list.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 `list.pop()`方法将从列表中删除一个元素。
- en: 'If we look at `items`, we will see it’s now shorter by one:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`items`，我们会看到它现在比之前短了一个：
- en: '[PRE51]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can use an index value to remove an element at a particular location. For
    instance, we can use `0` to remove the first element (see figure 3.6):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用索引值来删除特定位置的元素。例如，我们可以使用`0`来删除第一个元素（见图3.6）：
- en: '[PRE52]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![](../Images/3-6.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-6.png)'
- en: Figure 3.6 You can specify an index value to `list.pop()` to remove a particular
    element.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 你可以指定一个索引值给`list.pop()`以删除特定的元素。
- en: 'Now `items` is shorter still:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`items`变得更短了：
- en: '[PRE53]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can also use the `list.remove()` method to remove the first occurrence
    of a given item (see figure 3.7):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`list.remove()`方法来删除给定项目的第一个出现（见图3.7）：
- en: '[PRE54]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '![](../Images/3-7.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-7.png)'
- en: Figure 3.7 The `list.remove()` method will remove an element matching a given
    value.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 `list.remove()`方法将删除与给定值匹配的元素。
- en: Warning The `list.remove()` method will cause an exception if the element is
    not present.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：如果元素不存在，`list.remove()`方法将引发异常。
- en: '| If we try to use `items.remove()` to remove the chips again, we’ll get an
    exception:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '| 如果我们尝试使用`items.remove()`再次删除薯片，我们会得到一个异常：'
- en: '[PRE55]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '| ![](../Images/3-unnumb-7.png) |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/3-unnumb-7.png) |'
- en: 'So don’t use this code unless you’ve verified that a given element is in the
    `list`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，除非你已验证给定元素在`列表`中，否则不要使用此代码：
- en: '[PRE56]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 3.3.7 Sorting and reversing a list
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.7 对列表进行排序和反转
- en: If the `--sorted` flag is used to call our program, we’re going to need to sort
    the items. You might notice in the help documentation that two methods, `list.reverse()`
    and `list.sort()`, stress that they work *in place. That means that the* `list`
    *itself will be either reversed or sorted, and nothing will be returned*. So,
    given this `list`,
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`--sorted`标志调用我们的程序，我们需要对项目进行排序。你可能会在帮助文档中注意到，两个方法`list.reverse()`和`list.sort()`都强调它们是**就地操作**。这意味着**列表**本身将被反转或排序，而不会返回任何内容。所以，给定这个`列表`，
- en: '[PRE57]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '| the `items.sort()` method will return nothing:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '| `items.sort()`方法将返回空值：'
- en: '[PRE58]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If you inspect `items`, you will see that the items have been sorted alphabetically:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查`items`，你会看到项目已经按字母顺序排序：
- en: '[PRE59]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '| ![](../Images/3-unnumb-8.png) |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/3-unnumb-8.png) |'
- en: 'As with `list.sort()`, nothing is returned from the `list.reverse()` call:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `list.sort()` 一样，`list.reverse()` 调用不会返回任何内容：
- en: '[PRE60]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'But the `items` are now in the opposite order:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在 `items` 的顺序是相反的：
- en: '[PRE61]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `list.sort()` and `list.reverse()`*methods* are easily confused with the
    `sorted()` and `reversed()`*functions*. The `sorted()`*function* accepts a `list`
    as an argument and *returns* a new `list`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`list.sort()` 和 `list.reverse()`*方法* 容易与 `sorted()` 和 `reversed()`*函数* 混淆。`sorted()`*函数*
    接受一个 `list` 作为参数并 *返回* 一个新的 `list`：'
- en: '[PRE62]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It’s crucial to note that the `sorted()` function *does not alter* the given
    `list`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`sorted()` 函数 *不会改变* 给定的 `list`：
- en: '[PRE63]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Note that Python will sort a `list` of numbers *numerically*, so we’ve got
    that going for us, which is nice:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Python 会按 *数值* 对 `list` 进行排序，所以我们有这个优势，这很好：
- en: '[PRE64]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Warning Sorting a `list` that mixes strings and numbers will cause an exception!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：混合字符串和数字的 `list` 排序将导致异常！
- en: '[PRE65]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `list.sort()`*method* is a function that belongs to the `list`. It can
    take arguments that affect the way the sorting happens. Let’s look at `help(list.sort)`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`list.sort()`*方法* 是属于 `list` 的函数。它可以接受影响排序方式的参数。让我们查看 `help(list.sort)`：'
- en: '[PRE66]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'That means we can also `sort()items` in reverse, like so:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们也可以按相反顺序对 `items` 进行排序，如下所示：
- en: '[PRE67]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now they look like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它们看起来是这样的：
- en: '[PRE68]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '| ![](../Images/3-unnumb-9.png) | The `reversed()` function works a bit differently:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '| ![](../Images/3-unnumb-9.png) | `reversed()` 函数的工作方式略有不同：'
- en: '[PRE69]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: I bet you were expecting to see a new `list` with the items in reverse. This
    is an example of a *lazy* function in Python. The process of reversing a `list`
    might take a while, so Python is showing that it has generated an *iterator object*
    that will provide the reversed `list` when we actually need the elements. |
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌你期望看到一个新的 `list`，其中的项目顺序相反。这是一个 Python 中 *惰性* 函数的例子。反转 `list` 的过程可能需要一段时间，所以
    Python 正在显示它已经生成了一个 *迭代器对象*，当我们实际需要元素时，它将提供反转的 `list`。|
- en: 'We can see the values of our `reversed()` list in the REPL by using the `list()`
    function to evaluate the iterator:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `list()` 函数来评估迭代器，在 REPL 中查看我们的 `reversed()` 列表中的值：
- en: '[PRE70]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As with the `sorted()` function, the original `items` remains unchanged:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `sorted()` 函数一样，原始的 `items` 保持不变：
- en: '[PRE71]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If you use the `list.sort()` method instead of the `sorted()` function, you
    might end up deleting your data. Imagine you wanted to set `items` equal to the
    sorted list of `items`, like so:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `list.sort()` 方法而不是 `sorted()` 函数，你可能会丢失你的数据。想象一下，你想要将 `items` 设置为排序后的
    `items` 列表，如下所示：
- en: '[PRE72]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'What is in `items` now? If you print `items` in the REPL, you won’t see anything
    useful, so inspect the `type()`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`items` 中现在有什么？如果你在 REPL 中打印 `items`，你不会看到任何有用的内容，所以检查 `type()`：'
- en: '[PRE73]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: It’s no longer a `list`. We set it equal to the result of calling the `items.sort()`
    method, which changes `items` *in place* and returns `None`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 它不再是 `list`。我们将其设置为调用 `items.sort()` 方法的返回结果，这将 *就地* 改变 `items` 并返回 `None`。
- en: If the `--sorted` flag is given to your program, you will need to sort your
    items in order to pass the test. Will you use `list.sort()` or the `sorted()`
    function?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序中提供了 `--sorted` 标志，你需要对项目进行排序才能通过测试。你会使用 `list.sort()` 还是 `sorted()` 函数？
- en: 3.3.8 Lists are mutable
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.8 列表是可变的
- en: 'As you’ve seen, we can change a `list` quite easily. The `list.sort()` and
    `list.reverse()` methods change the whole list, but you can also change any single
    element by referencing it by index. Maybe we should make our picnic slightly healthier
    by swapping out the chips for apples:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们可以很容易地改变 `list`。`list.sort()` 和 `list.reverse()` 方法改变整个列表，但你也可以通过索引引用来更改任何单个元素。也许我们应该通过用苹果替换薯片来使我们的野餐稍微健康一些：
- en: '[PRE74]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: ① See if the string 'chips' is in the list of items.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ① 检查字符串 'chips' 是否在项目列表中。
- en: ② Assign the index of 'chips' to the variable idx.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ② 将 'chips' 的索引分配给变量 idx。
- en: ③ Use the index idx to change the element to 'apples'.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用索引 idx 将元素更改为 'apples'。
- en: 'Let’s look at `items` to verify the result:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看 `items` 以验证结果：
- en: '[PRE75]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '| We can also write a couple of tests:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '| 我们也可以编写几个测试：'
- en: '[PRE76]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: ① Make sure “chips” are no longer on the menu.② Check that we now have some
    “apples.” | ![](../Images/3-unnumb-10.png) |
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ① 确保菜单上不再有“chips”。② 检查我们现在是否有“apples”。 | ![](../Images/3-unnumb-10.png) |
- en: You will need to get the word “and” into your list just before the last element
    when there are three or more items. Could you use this idea?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当有三个或更多项目时，你需要在最后一个元素之前将单词“and”放入你的列表中。你能用这个想法吗？
- en: 3.3.9 Joining a list
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.9 列表连接
- en: In this chapter’s exercise, you’ll need to print a string based on the number
    of elements in the given list. The string will intersperse other strings like
    a comma and a space (`',` `'`) between the elements of the list.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的练习中，你需要根据给定列表中的元素数量打印一个字符串。该字符串将在列表元素之间插入其他字符串，如逗号和空格（`,` `'`）。
- en: 'The following syntax will join a list with a string made of a comma and a space:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语法将使用由逗号和空格组成的字符串连接列表：
- en: '[PRE77]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '![](../Images/3-unnumb-11.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-unnumb-11.png)'
- en: The preceding code uses the `str.join()` method and passes the `list` as an
    argument. It always feels backwards to me, but that’s the way it goes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用了 `str.join()` 方法并将 `list` 作为参数传递。这对我来说总感觉是反过来的，但就是这样。
- en: 'The result of `str.join()` is a new string:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.join()` 的结果是一个新的字符串：'
- en: '[PRE78]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The original `list` remains unchanged:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 `list` 保持不变：
- en: '[PRE79]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We can do quite a bit more with Python’s `list`, but that should be enough for
    you to solve this chapter’s problem.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 Python 的 `list` 做很多事情，但这应该足以让你解决本章的问题。
- en: 3.4 Conditional branching with if/elif/else
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 使用 if/elif/else 的条件分支
- en: You need to use conditional branching, based on the number of items, to correctly
    format the output. In chapter 2’s exercise, there were two conditions--either
    a vowel or not--so we used `if`/`else` statements. Here we have three options
    to consider, so you will have to use `elif` (else-if) as well.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要根据项目数量使用条件分支，以正确格式化输出。在第二章的练习中，有两个条件——要么是元音，要么不是——所以我们使用了 `if`/`else` 语句。这里我们有三个选项要考虑，所以你将不得不使用
    `elif`（else-if）。
- en: 'For instance, suppose we want to classify someone by their age using three
    options:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要通过三个选项来根据年龄对某人进行分类：
- en: If their age is greater than `0`, it is valid.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们的年龄大于 `0`，则是有效的。
- en: If their age is less than `18`, they are a minor.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们的年龄小于 `18`，他们是未成年人。
- en: Otherwise, they are 18 years or older, which means they can vote.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，他们18岁或以上，这意味着他们可以投票。
- en: 'Here is how we could write that code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样编写代码：
- en: '[PRE80]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: See if you can use that example to figure out how to write the three options
    for picnic.py. First write the branch that handles one item. Then write the branch
    that handles two items. Then write the last branch for three or more items. Run
    the tests *after every change to your program*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你是否能使用这个例子来弄清楚如何为 picnic.py 编写三个选项。首先编写处理一个项目的分支。然后编写处理两个项目的分支。接着编写处理三个或更多项目的最后一个分支。每次修改你的程序后都要运行测试。
- en: 3.4.1 Time to write
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 写作时间
- en: 'Now go write the program yourself before you look at my solution. Here are
    a few hints:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在你看我的解决方案之前，先自己写程序。这里有一些提示：
- en: Go into your 03_picnic directory and run `new.py` `picnic.py` to create your
    program. Then run `make` `test` (or `pytest` `-xv` `test.py`). You should pass
    the first two tests.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入你的 03_picnic 目录并运行 `new.py` `picnic.py` 来创建你的程序。然后运行 `make` `test`（或 `pytest`
    `-xv` `test.py`）。你应该通过前两个测试。
- en: Next work on getting your `--help` usage looking like the example shown earlier
    in the chapter. It’s very important to define your arguments correctly. For the
    `items` argument, look at `nargs` in `argparse`, as discussed in section A.4.5
    of the appendix.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，努力让你的 `--help` 使用说明看起来像本章前面展示的示例。正确定义你的参数非常重要。对于 `items` 参数，查看 `argparse`
    中的 `nargs`，如附录 A.4.5 节所述。
- en: If you use new.py to start your program, be sure to keep the Boolean flag and
    modify it for your `sorted` flag.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用 new.py 来启动你的程序，确保保留布尔标志并修改你的 `sorted` 标志。
- en: Solve the tests in order! First handle one item, then handle two items, and
    then handle three. Then handle the sorted items.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按顺序解决测试！首先处理一个项目，然后处理两个项目，接着处理三个。然后处理排序后的项目。
- en: You’ll get the best benefit from this book if you try writing the programs and
    passing the tests before reading the solutions!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在你阅读解决方案之前，尝试编写程序并通过测试，这将让你从这本书中获得最大的收益！
- en: 3.5 Solution
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 解决方案
- en: Here is one way to satisfy the tests. If you wrote something different that
    passed, that’s great!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种满足测试的方法。如果你写了不同的代码并且通过了，那也很好！
- en: '[PRE81]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: ① The get_args() function is placed first so we can easily see what the program
    accepts when we read it. Note that the function order here is not important to
    Python, only to us readers.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将 get_args() 函数放在前面，这样我们就可以在阅读时轻松地看到程序接受的内容。请注意，这里的函数顺序对 Python 来说并不重要，只对我们读者来说重要。
- en: ② The item argument uses nargs='+' so that it will accept one or more positional
    arguments, which will be strings.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ② 项目参数使用 nargs='+'，这样它将接受一个或多个位置参数，这些参数将是字符串。
- en: ③ The dashes in the short (-s) and long (--sorted) names make this an option.
    There is no value associated with this argument. It’s either present (in which
    case it will be True) or absent (False).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 短名（-s）和长名（--sorted）中的破折号使这成为一个选项。此参数没有关联的值。它要么存在（在这种情况下为True），要么不存在（False）。
- en: ④ Process the command-line arguments and return them to the caller.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 处理命令行参数并将它们返回给调用者。
- en: ⑤ The main() function is where the program will start.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ main()函数是程序开始的地方。
- en: ⑥ Call the get_args() function and put the returned value into the variable
    args. If there is a problem parsing the arguments, the program will fail before
    the values are returned.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 调用get_args()函数并将返回值放入变量args中。如果解析参数时出现问题，程序将在返回值之前失败。
- en: ⑦ Copy the item list from args into the new variable items.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 将args中的项目列表复制到新变量items中。
- en: ⑧ Use the length function len() to get the number of items in the list. There
    can never be zero items because we defined the argument using nargs='+', which
    always requires at least one value.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 使用len()函数获取列表中的项目数量。由于我们使用nargs='+’定义了参数，所以项目数量永远不会为零。
- en: ⑨ The args.sorted value will be either True or False.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ args.sorted的值将是True或False。
- en: ⑩ If we are supposed to sort the items, call the items.sort() method to sort
    them in place.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 如果我们需要排序项目，调用items.sort()方法就地排序它们。
- en: ⑪ Use an empty string to initialize a variable to hold the items we are bringing.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 使用空字符串初始化一个变量来保存我们要带来的项目。
- en: ⑫ If the number of items is 1, we will assign the one item to bringing.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 如果项目数量为1，我们将一个项目分配给bringing。
- en: ⑬ If the number of items is 2, put the string ' and ' in between the items.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 如果项目数量为2，在项目之间插入字符串'和'。
- en: ⑭ Otherwise, alter the last element in items to append the string 'and ' before
    whatever is already there.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 否则，将items中的最后一个元素更改为在现有内容之前追加字符串'和'。
- en: ⑮ Join the items on a string of comma and space.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ 将项目用逗号和空格连接起来。
- en: ⑯ Print the output string, using the str.format() method to interpolate the
    bringing variable.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ⑯ 使用str.format()方法将变量插入到输出字符串中。
- en: ⑰ When Python runs the program, it will read all the lines to this point but
    will not run anything. Here we look to see if we are in the “main” namespace.
    If we are, we call the main() function to make the program begin.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: ⑰ 当Python运行程序时，它将读取到这一点的所有行，但不会运行任何内容。在这里我们查看我们是否在“main”命名空间中。如果是，我们调用main()函数使程序开始。
- en: 3.6 Discussion
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 讨论
- en: How did it go? Did it take you long to write your version? How different was
    it from mine? Let’s talk about my solution. It’s fine if yours is different from
    mine, just as long as you pass the tests!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么样？写你的版本花了很长时间吗？它与我的版本有多大的不同？让我们谈谈我的解决方案。如果你的解决方案与我的不同，只要通过测试就可以。
- en: 3.6.1 Defining the arguments
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.1 定义参数
- en: 'This program can accept a variable number of arguments that are all the same
    thing (strings). In my `get_args()` method I define an `item` like so:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序可以接受可变数量的参数，这些参数都是同一类型（字符串）。在我的`get_args()`方法中，我定义了一个`item`如下：
- en: '[PRE82]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: ① A positional parameter called item
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ① 调用参数
- en: ② An indication to the user in the usage that this should be a string
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在使用说明中对用户指示这是一个字符串
- en: ③ The number of arguments, where '+' means one or more
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 参数的数量，其中“+”表示一个或多个
- en: ④ A longer help description that appears for the -h or --help options
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 较长的帮助描述，在-h或--help选项中显示
- en: This program also accepts `-s` and `--sorted` arguments. They are “flags,” which
    typically means that they are `True` if they are present and `False` if absent.
    Remember that the leading dashes makes them optional.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序还接受`-s`和`--sorted`参数。它们是“标志”，通常意味着如果它们存在则为True，不存在则为False。记住，前面的破折号使它们成为可选的。
- en: '[PRE83]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: ① The short flag name
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ① 短标志名
- en: ② The long flag name
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ② 长标志名
- en: ③ If the flag is present, store a True value. The default value will be False.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 如果标志存在，存储True值。默认值将是False。
- en: ④ The longer help description
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 较长的帮助描述
- en: 3.6.2 Assigning and sorting the items
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.2 分配和排序项目
- en: 'In `main()` I call `get_args()` to get the arguments, and I assign them to
    the `args` variable. Then I create the `items` variable to hold the `args.item`
    value(s):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我调用`get_args()`来获取参数，并将它们分配给`args`变量。然后我创建`items`变量来保存`args.item`值：
- en: '[PRE84]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'If `args.sorted` is `True`, I need to sort `items`. I chose the in-place `sort`
    method here:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`args.sorted`为True，我需要排序`items`。在这里我选择了就地`sort`方法：
- en: '[PRE85]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now I have the items, sorted if needed, and I need to format them for output.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有了项目，如果需要，已经排序，我需要将它们格式化以供输出。
- en: 3.6.3 Formatting the items
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.3 格式化项目
- en: 'I suggested you solve the tests in order. There are four conditions we need
    to solve:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你按顺序解决测试。我们需要解决四个条件：
- en: Zero items
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有项目
- en: One item
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个项目
- en: Two items
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个项目
- en: Three or more items
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个或更多项目
- en: 'The first test is actually handled by `argparse`--if the user fails to provide
    any arguments, they get a usage message:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试实际上是由`argparse`处理的--如果用户没有提供任何参数，他们会收到一个用法信息：
- en: '[PRE86]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Since `argparse` handles the case of no arguments, we have to handle the other
    three conditions. Here’s one way to do that:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`argparse`处理了没有参数的情况，我们必须处理其他三种情况。这里有一个这样做的方法：
- en: '[PRE87]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: ① Initialize a variable for what we are bringing.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ① 初始化一个变量来表示我们要带什么。
- en: ② Check if the number of items is 1.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ② 检查项目数量是否为1。
- en: ③ If there is one item, bringing is the one item.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 如果只有一个项目，那就带这一个项目。
- en: ④ Check if the number of items is 2.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 检查项目数量是否为2。
- en: ⑤ If there are two items, we join the items on the string ' and '.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 如果有两个项目，我们将项目连接在字符串`' and '`上。
- en: ⑥ Otherwise...
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 否则...
- en: ⑦ Insert the string 'and ' before the last item.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 在最后一个项目之前插入字符串`'and '`。
- en: ⑧ Join all the items on the string ', '.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 将所有项目连接在字符串`', '`上。
- en: Can you come up with any other ways to do this?
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想出其他做这件事的方法吗？
- en: 3.6.4 Printing the items
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.4 打印项目
- en: 'Finally, to `print()` the output, I used a format string where the `{}` indicate
    a placeholder for a value, like so:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了`print()`输出，我使用了一个格式化字符串，其中`{}`表示一个值的占位符，如下所示：
- en: '[PRE88]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If you prefer, you could use an `f''''`-string:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以使用一个`f''`-字符串：
- en: '[PRE89]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: They both get the job done.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 他们都完成了工作。
- en: 3.7 Going further
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 进一步了解
- en: Add an option so the user can choose not to print with the Oxford comma (even
    though that is a morally indefensible option).
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个选项，让用户可以选择不使用牛津逗号（尽管这是一个在道德上无法辩护的选择）。
- en: Add an option to separate items with a character passed in by the user (like
    a semicolon if the list of items needs to contain commas).
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个选项，允许用户使用传递给用户的字符（如如果项目列表需要包含逗号，则使用分号）来分隔项目。
- en: Be sure to add tests to the test.py program to ensure your new features are
    correct!
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在test.py程序中添加测试以确保你的新功能是正确的！
- en: Summary
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Python lists are ordered sequences of other Python data types, such as strings
    and numbers.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python列表是有序的Python数据类型的序列，如字符串和数字。
- en: There are methods like `list.append()` and `list.extend()` to add elements to
    a `list`. Use `list.pop()` and `list.remove()` to remove elements.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有像`list.append()`和`list.extend()`这样的方法可以向`list`中添加元素。使用`list.pop()`和`list.remove()`来删除元素。
- en: You can use `x` `in` `y` to ask if element `x` is in the list `y`. You can also
    use `list.index()` to find the index of an element, but this will cause an exception
    if the element is not present.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`x in y`来询问元素`x`是否在列表`y`中。你也可以使用`list.index()`来查找元素的索引，但如果元素不存在，这将引发异常。
- en: Lists can be sorted and reversed, and elements within lists can be modified.
    Lists are useful when the order of the elements is important.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表可以排序和反转，列表内的元素可以修改。当元素的顺序很重要时，列表很有用。
- en: Strings and lists share many features, such as using `len()` to find their lengths,
    using zero-based indexing where `0` is the first element and `-1` is the last,
    and using slices to extract smaller pieces from the whole.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串和列表共享许多特性，例如使用`len()`来找到它们的长度，使用基于0的索引，其中`0`是第一个元素，`-1`是最后一个，以及使用切片从整体中提取较小的部分。
- en: The `str.join()` method can be used to make a new `str` from a `list`.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str.join()`方法可以用来从一个`list`中创建一个新的`str`。'
- en: '`if`/`elif`/`else` can be used to branch code depending on conditions.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`/`elif`/`else`可以根据条件分支代码。'
