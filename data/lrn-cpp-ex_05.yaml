- en: 5 Creating and using objects and arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 创建和使用对象和数组
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Writing a class or structure
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写类或结构
- en: Scoped enums
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域枚举
- en: Using an `array` instead of a `vector` when we know how many elements we need
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们知道需要多少元素时，使用`array`而不是`vector`
- en: Writing a comparison operator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写比较运算符
- en: Defaulted functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认函数
- en: Using `std::variant`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::variant`
- en: In this chapter, we will create a deck of cards and write a higher-or-lower
    card game for guessing whether the next card from a deck is higher or lower. We
    will create a class for a card and store a deck of cards in an `array`. We need
    to consider how to define comparison operators for our cards, as well as how to
    write constructors and other member functions. We’ll need to use a random shuffle
    too. We will then extend the game to include jokers and learn how to use `std::variant`.
    By the end of the chapter, we will have a working card game and be ready to do
    more with classes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一副牌并编写一个高低牌游戏，用于猜测牌堆中下一张牌是更高还是更低。我们将创建一个代表牌的类，并将一副牌存储在一个`array`中。我们需要考虑如何为我们的牌定义比较运算符，以及如何编写构造函数和其他成员函数。我们还需要使用随机洗牌。然后我们将扩展游戏以包括小丑牌，并学习如何使用`std::variant`。到本章结束时，我们将有一个可工作的牌游戏，并准备好使用类做更多的事情。
- en: 5.1 Creating a deck of playing cards
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 创建一副扑克牌
- en: 'We will start by defining a card class. We can declare a card using either
    the keyword `class` or `struct`. If we use a `struct`, everything is public by
    default, which is a simple starting point. A card has a suit and a value. There
    are four suits and 13 possible values per suit: 1, or ace; 2 up to 10; and three
    court cards. We will also need to display and compare cards, as well as a way
    to create a whole deck. We will start with the cards themselves.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个卡片类。我们可以使用关键字`class`或`struct`来声明一个卡片。如果我们使用`struct`，则默认所有内容都是公开的，这是一个简单的起点。一张卡片有一个花色和一个数值。有四种花色，每种花色有13个可能的数值：1，或王牌；2到10；以及三种宫廷牌。我们还需要显示和比较卡片，以及创建一整副牌的方法。我们将从卡片本身开始。
- en: Up to now, we have put all our code in a `main.cpp` file. For this chapter,
    we will make a header file, called `playing_cards.h`, and include it in our `main.cpp`.
    As we add functions, most of them will go into a `playing_cards.cpp` source file.
    Let’s take a moment to remind ourselves of the basics of using source and header
    files. When we use header files, we always need an *include guard*. This stops
    a header file from being included more than once in the same source file, which
    can lead to problems, including violation of the *one definition rule*. Without
    the guard, including the same header twice, which can easily happen indirectly
    if one header includes another, means enums, structures, and so on will be defined
    twice, which is not allowed. This is nothing new. CppReference provides more details
    on this topic ([http://mng.bz/z0Rg](http://mng.bz/z0Rg)). Some people still use
    macros for include or header guards, picking a unique name.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的代码都放在了`main.cpp`文件中。对于本章，我们将创建一个头文件，命名为`playing_cards.h`，并将其包含在`main.cpp`中。随着我们添加函数，大多数函数都将放入一个`playing_cards.cpp`源文件中。让我们花点时间提醒一下使用源文件和头文件的基本知识。当我们使用头文件时，我们总是需要一个*包含保护*。这阻止了头文件在同一个源文件中被包含多次，这可能导致问题，包括违反*单一定义规则*。如果没有保护，包含相同的头文件两次，这很容易间接发生，如果头文件包含另一个头文件，意味着枚举、结构体等将被定义两次，这是不允许的。这不是什么新鲜事。C++Reference提供了更多关于这个主题的详细信息([http://mng.bz/z0Rg](http://mng.bz/z0Rg))。有些人仍然使用宏来包含或作为头文件保护，选择一个独特的名称。
- en: Listing 5.1 Macro-style include guards
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1 宏样式的包含保护
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, the `pragma` directive `once` is now widely supported. If this directive
    does not work on your compiler, it's fine to use the macro version. Let’s create
    a namespace for our cards, keeping structures and functions in the `namespace`
    scope.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`pragma`指令`once`现在得到了广泛的支持。如果这个指令在您的编译器上不起作用，使用宏版本是可以的。让我们为我们的牌创建一个命名空间，将结构和函数保持在`namespace`作用域内。
- en: Listing 5.2 `playing_cards` header file
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.2 `playing_cards`头文件
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Include guard
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含保护
- en: ❷ Namespace for subsequent declarations
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为后续声明命名空间
- en: Finally, we include this header in `main.cpp`, using quotation marks, `""`,
    rather than angle brackets, `<>`, which indicate it is ours rather than a library
    header. The specifics of where the search for an included header file is conducted
    are implementation defined, but the quoted version searches where the angled-bracket
    version would if its initial search fails. People often use angled brackets for
    standard library headers and quotation marks for their own headers. Our main function
    doesn’t do much yet, but we now have places to put our code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`main.cpp`中包含这个头文件，使用引号`""`而不是尖括号`<>`，这表示它是我们的而不是库头文件。搜索包含的头文件的具体位置是实现定义的，但引号版本会在尖括号版本初始搜索失败时搜索。人们通常使用尖括号来表示标准库头文件，使用引号来表示自己的头文件。我们的主函数目前还没有做什么，但现在我们有地方放置我们的代码了。
- en: Listing 5.3 Including the header file
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 包含头文件
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Includes our header
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含我们的头文件
- en: We are now ready to create some playing cards for our game.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以为我们的游戏创建一些牌了。
- en: 5.1.1 Defining a card type using a scoped enum for the suit
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 使用范围枚举定义牌类型
- en: We know we need a suit and a value for each playing card. We can use integers
    for the value initially, and although we could use an integer for the suit too,
    using an `enum` is clearer. C++11 introduced *scoped enumerations*, which look
    very similar to the old unscoped `enum` but have the word `class`, or, equivalently,
    `struct`, between the `enum` keyword and the name. Add an `enum` to the `playing_cards.h`
    file, with one *enumerator* per suit, inside the namespace.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们需要为每一张牌指定一个花色和一个数值。最初我们可以使用整数来表示数值，尽管我们也可以用整数来表示花色，但使用`enum`会更清晰。C++11引入了**范围枚举**，它们看起来与旧的未范围`enum`非常相似，但在`enum`关键字和名称之间有一个`class`，或者等价地，`struct`。在`playing_cards.h`文件中添加一个`enum`，每个花色对应一个枚举值，在命名空间内。
- en: Listing 5.4 Scope `enum` for suits
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.4 范围`enum`用于花色
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Include guard
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含保护
- en: ❷ Namespace
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 命名空间
- en: ❸ Notice the word class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 注意到单词`class`。
- en: The small addition of the word `class` makes a big difference. Without it, we
    have an old-style `enum` and could use `Hearts` or any of the other values, or
    enumerators, without qualification. This means we can compare values from different
    enums by mistake. If two different enums are used to indicate whether a function
    succeeds, they might both designate success with OK and a failure with one of
    many values. It then becomes possible to check whether a result is OK, conflating
    the two different enums. To use our suit, we need to say `Suit::Hearts`, making
    potential unintended comparisons impossible.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 单词`class`的添加带来了很大的不同。没有它，我们有一个旧式的`enum`，可以无限制地使用`Hearts`或其他任何值，或者枚举值。这意味着我们可能会错误地比较来自不同枚举的值。如果使用两个不同的枚举来指示函数是否成功，它们可能会都使用`OK`表示成功，使用许多值之一表示失败。然后，检查结果是否为`OK`时，可能会混淆这两个不同的枚举。要使用我们的花色，我们需要说`Suit::Hearts`，这样就可以避免潜在的意外比较。
- en: There is no implicit conversion from the values of a scoped enumerator to integral
    types, which was possible with the old enums. We need to explicitly use a cast
    if we want to use the value as a number. Scoped enums are safer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 范围枚举的值到整型的隐式转换是不存在的，这在旧的枚举中是可能的。如果我们想将值用作数字，我们需要显式使用类型转换。范围枚举更安全。
- en: We begin with a `struct` to hold value and suit for an initial card type inside
    the namespace in the header file.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在头文件中的命名空间内开始使用一个`struct`来保存初始牌类型的数值和花色。
- en: Listing 5.5 A card structure
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5 牌结构
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can then create a card with a value and a suit in `main`, provided we include
    our header and use the `cards` namespace. We will use *aggregate initialization*,
    which looks remarkably like the uniform initialization using an initializer list.
    We used this in chapter 2 to make the first row of Pascal’s triangle: `std::vector<int>`
    `data{1}`. Aggregate initialization is different, though. The initializer list
    is a list of values of the same type, but our aggregate initialization uses a
    list of different types. Our `Card` struct has an `int` data member, followed
    by a `Suit`, so we provide these in that order to instantiate a `Card`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`main`中，我们可以创建一个带有数值和花色的牌，前提是我们包含我们的头文件并使用`cards`命名空间。我们将使用**聚合初始化**，它看起来非常像使用初始化列表的统一初始化。我们在第2章中使用它来制作帕斯卡三角形的第一行：`std::vector<int>
    data{1}`。聚合初始化是不同的。初始化列表是相同类型的值的列表，但我们的聚合初始化使用不同类型的列表。我们的`Card`结构体有一个`int`数据成员，后面跟着一个`Suit`，所以我们按照这个顺序提供这些值来实例化一个`Card`。
- en: Listing 5.6 Using the `Card` struct
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.6 使用`Card`结构体
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Includes our header
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含我们的头文件
- en: ❷ Uses the namespace
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用命名空间
- en: ❸ Creates a card with a value and Suit
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建一个带有数值和花色的卡片
- en: We can just specify the value, `Card` `card{2}`, and the suit will be default
    initialized to the first `enum` value. However, we cannot say `Card card{Suit::Clubs}`.
    We can leave out initializers toward the end but not at the start.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以只指定值，`Card` `card{2}`，而花色将默认初始化为第一个 `enum` 值。然而，我们不能说 `Card card{Suit::Clubs}`。我们可以在末尾省略初始化器，但不能在开头省略。
- en: Had we not used a scoped `enum` for the suit, we would be using two `int`s to
    make a card and would have to remember which was which. Using `card{2,` `Suit::Clubs}`
    is much clearer and less error prone than `card{2,` `3}`. As it stands, though,
    we could use 0 or 14 for the face value of a card. We learned about the whole
    value idiom in the last chapter when we used a `year_month_day`. We can employ
    the same idea now by making a type for the card’s value and also ensuring only
    values from 1 to 13 are used. In addition to validating the value used, we will
    see how to use the type to display the cards easily later on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有使用作用域 `enum` 来表示花色，我们将使用两个 `int` 来制作卡片，并且必须记住哪个是哪个。使用 `card{2,` `Suit::Clubs}`
    比使用 `card{2,` `3}` 更清晰且更不容易出错。然而，目前，我们可以使用 0 或 14 作为卡片的数值。我们在上一章学习整值习语时了解了 `year_month_day`。现在我们可以通过为卡片的数值创建一个类型，并确保只使用
    1 到 13 的数值来应用同样的想法。除了验证使用的值外，我们还将看到如何使用该类型来轻松显示卡片。
- en: 5.1.2 Defining a card type using a strong type for the face value
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 使用数值的强类型定义卡片类型
- en: The face value needs to take an `int` and store it, providing a getter function,
    so code can use the value if needed. In the last chapter, we considered the whole-value
    idiom to create lightweight types to ensure parameters are passed correctly. If
    we make a `FaceValue` class with an `explicit` constructor, we can’t pass an `int`
    where a function requires a face value. For example, if we have a function with
    signature
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 面值需要接受一个 `int` 并将其存储起来，提供获取函数，以便代码在需要时可以使用该值。在上一章中，我们考虑了整值习语来创建轻量级类型，以确保参数被正确传递。如果我们创建一个具有
    `explicit` 构造函数的 `FaceValue` 类，我们无法在需要面值的地方传递一个 `int`。例如，如果我们有一个函数，其签名是
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'we cannot call it with an `int`. Instead, we need to create a face value:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用 `int` 来调用它。相反，我们需要创建一个面值：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: An `int` cannot be implicitly converted to our new type because the constructor
    is explicit.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构造函数是显式的，`int` 不能隐式转换为我们的新类型。
- en: We will throw an exception if the value used is invalid. An `std::invalid_argument`
    exception from the `stdexcept` header makes sense.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的值无效，我们将抛出一个异常。来自 `stdexcept` 头文件的 `std::invalid_argument` 异常是有意义的。
- en: Listing 5.7 A type for a face value
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.7 一个数值类型
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Explicit constructor
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 显式构造函数
- en: ❷ Validates the value
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 验证数值
- en: We can then change the type in the `Card` definition from `int value` to `FaceValue
    value`. To create a card like we did in listing 5.6, we have to explicitly make
    a `FaceValue`, `Card` `card{` `FaceValue(2),` `Suit::Clubs}`, rather than being
    able to say `Card card{2,` `Suit::Clubs}`. We will have to make a tiny bit more
    effort when we construct a card, but we will get a suit and a valid value for
    a card if we construct one properly. Before we start using the `FaceValue`, we
    should think slightly more about how we make cards. Things can still go wrong.
    Let’s revisit our card type, ensuring we only make useful playing cards.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `Card` 定义中的 `int value` 类型更改为 `FaceValue value`。要创建类似于列表 5.6 中的卡片，我们必须显式地创建一个
    `FaceValue`，然后创建一个 `Card` `card{` `FaceValue(2),` `Suit::Clubs}`，而不是能够说 `Card
    card{2,` `Suit::Clubs}`。在构建卡片时，我们需要付出一点更多的努力，但如果我们正确构建，我们将得到一个花色和一个有效的卡片数值。在我们开始使用
    `FaceValue` 之前，我们应该稍微更多地考虑我们如何制作卡片。事情仍然可能会出错。让我们回顾我们的卡片类型，确保我们只制作有用的扑克牌。
- en: 5.1.3 Constructors and default values
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 构造函数和默认值
- en: 'Before we use our `FaceValue`, consider our `Card` type defined in listing
    5.5\. Our struct has two members, an `int` value and a `Suit`. We can create a
    card without a value or suit:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 `FaceValue` 之前，考虑一下列表 5.5 中定义的 `Card` 类型。我们的结构有两个成员，一个 `int` 值和一个 `Suit`。我们可以创建一个没有值或花色的卡片：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, the two member fields will not be initialized. If we try to read those
    fields, we have undefined behavior. In Visual Studio 2022, I happen to get a value
    of `-858993460` and a suit of `-858993460` as well in the Debug build. In a release
    build, I might get different garbage values. The compiler can do as it pleases
    with such code, so you are likely to get different behavior with another compiler.
    If we use brace initialization
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这两个成员字段将不会被初始化。如果我们尝试读取这些字段，我们将遇到未定义的行为。在 Visual Studio 2022 的调试构建中，我偶然得到
    `-858993460` 的值和 `-858993460` 的花色。在发布构建中，我可能会得到不同的垃圾值。编译器可以随意处理此类代码，因此你可能会用另一个编译器得到不同的行为。如果我们使用花括号初始化
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: the members are default initialized. We have seen brace or uniform initialization
    before, and remembering to initialize variables is a good habit to get into. We
    could try to be very careful not to use the uninitialized values, but it’s safer
    to ensure we cannot create dangerous playing cards in the first place. We can
    adopt a variety of approaches to avoid the uninitialized member variables.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 成员将被默认初始化。我们之前已经见过花括号或统一初始化，记住初始化变量是一个好习惯。我们可以尝试非常小心地不使用未初始化的值，但更安全的方法是确保我们首先不能创建危险的玩牌。我们可以采用各种方法来避免未初始化的成员变量。
- en: The simplest approach is to use default values to initialize the value and suit.
    Since C++11, we can use *default member initializers*, giving a default value
    directly to any members we want to initialize. An integer default initializes
    to 0, and an enum to the first value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是使用默认值来初始化值和花色。自 C++11 以来，我们可以使用 *默认成员初始化器*，直接为任何我们想要初始化的成员提供默认值。整数默认初始化为
    0，枚举初始化为第一个值。
- en: Listing 5.8 A card structure
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.8 一个卡片结构
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Initializes members with defaults
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用默认值初始化成员
- en: 'Our previously dangerous card now has values, which we can safely read, giving
    us a 0 of hearts: a very unlikely playing card but with no undefined behavior.
    If we now use the `FaceValue` instead, we can’t make a card with a value of 0,
    so we need to choose an acceptable value, say, 1.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前危险卡片现在有了值，我们可以安全地读取，得到 0 的红桃：一个非常不可能的玩牌，但没有未定义的行为。如果我们现在使用 `FaceValue`，我们无法创建一个值为
    0 的卡片，因此我们需要选择一个可接受的价值，比如说，1。
- en: Listing 5.9 A card structure
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 一个卡片结构
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Initializes FaceValue with a viable default
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用有效默认值初始化 FaceValue
- en: We could use this definition for our game, but let’s consider an alternative
    approach first because we still have potential problems. A `struct`’s members
    are public by default, which means we can use them directly. We can therefore
    easily change their values, which might not be a good idea. We can either flag
    them as private or use the word `class` instead of `struct` because the members
    of a `class` are private by default then. In either case, we need a way to set
    the values; otherwise, every card will have the same value. We can add a public
    constructor, taking a value and a suit, and store them. If we need these values
    from outside the `class` or `struct`, we will need to add getters as well. These
    should be flagged as `const`, as they do not change the `Card` member values.
    This allows them to be called by a card variable, regardless of whether or not
    it is `const`. We can either change the name of the original structure or remove
    it and make a new, improved type in the header file in the namespace.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个定义来为我们的游戏，但让我们先考虑一种替代方法，因为我们仍然有可能遇到问题。`struct` 的成员默认是公有的，这意味着我们可以直接使用它们。因此，我们可以轻松地更改它们的值，这可能不是一个好主意。我们可以将它们标记为私有，或者使用
    `class` 而不是 `struct`，因为 `class` 的成员默认是私有的。在任何情况下，我们都需要一种设置值的方法；否则，每张卡片都将具有相同的值。我们可以添加一个公共构造函数，接受一个值和一个花色，并将它们存储起来。如果我们需要从
    `class` 或 `struct` 外部获取这些值，我们还需要添加获取器。这些应该被标记为 `const`，因为它们不会更改 `Card` 成员值。这允许它们被一个卡片变量调用，无论它是否是
    `const`。我们可以更改原始结构的名称，或者将其删除并在命名空间中的头文件中创建一个新的、改进的类型。
- en: Listing 5.10 A card class
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.10 一个卡片类
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Constructor taking value and suit
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 带有值和花色的构造函数
- en: ❷ Stores the value and suit
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 存储值和花色
- en: ❸ Getters, flagged as const
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 标记为 const 的获取器
- en: ❹ Private members
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 私有成员
- en: We can no longer default construct a card. Having written our own constructor
    taking parameters, we no longer get a default constructor generated for us. The
    dangerous card we created before is now impossible. Trying
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能再使用默认构造函数创建一个卡片。既然我们已经编写了自己的带参数的构造函数，我们就不会再自动生成默认构造函数。之前创建的危险卡片现在是不可能的。尝试
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: will not compile. This should also be familiar if you have used C++ before.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将无法编译。如果你之前使用过 C++，这也应该很熟悉。
- en: We need to default construct cards when we use an `std::array` to build a deck
    of cards. C++11 introduced a way to *default* default constructors. If we add
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `std::array` 构建一副牌时，我们需要默认构造牌。C++11 引入了一种创建 *默认* 默认构造函数的方法。如果我们添加
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: to the class in listing 5.10, our `impossible_card` then becomes possible. The
    compiler defines a default constructor, even though we wrote another constructor.
    We should still add default member initializers for the value and suit like we
    did before so the default constructor initializes these.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到列表 5.10 中的类，我们的 `impossible_card` 就变成了可能的。即使我们写了另一个构造函数，编译器也会定义一个默认构造函数。我们仍然应该像之前那样添加默认成员初始化器，以便默认构造函数可以初始化这些值。
- en: Listing 5.11 A default constructible card
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.11 一个可默认构造的牌
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Default constructor
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 默认构造函数
- en: ❷ Member initializers
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 成员初始化器
- en: We can also mark a constructor as deleted with `=` `delete`. This will stop
    the constructor from being generated. We can do this for any special member function,
    such as `copy` or `move` constructors, assignment operators, or the destructor.
    Prior to C++11, we often made the functions we wanted to hide private to avoid
    them being used. Being able to say a function is deleted is much simpler and makes
    our intentions clear. We will look at the special member functions in more detail
    in the next chapter. For now, we have a robust card type. We need a way to display
    a card; then we can move on to create a deck of cards and write our game.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `=` `delete` 标记一个构造函数为已删除。这将阻止生成该构造函数。我们可以为任何特殊成员函数这样做，例如 `copy` 或 `move`
    构造函数、赋值运算符或析构函数。在 C++11 之前，我们经常将想要隐藏的函数设置为私有，以避免它们被使用。能够说一个函数是已删除的更简单，并且使我们的意图更明确。我们将在下一章中更详细地研究特殊成员函数。现在，我们有一个健壮的牌类型。我们需要一种显示牌的方法；然后我们可以继续创建一副牌并编写我们的游戏。
- en: 5.1.4 Displaying playing cards
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.4 显示扑克牌
- en: To display a card, we want to be able to write
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示一张牌，我们想要能够写出
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Therefore, we need to provide a stream insertion operator for our `Card` type.
    We wrote a stream insertion operator in listing 2.5\. We need an overload taking
    a reference to an `std::ostream` as the first parameter and a constant reference
    to a `Card` as the second:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要为我们的 `Card` 类型提供一个流插入运算符。我们在列表 2.5 中编写了一个流插入运算符。我们需要一个重载，它接受 `std::ostream`
    的引用作为第一个参数，以及一个常量引用 `Card` 作为第二个参数：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We return a reference to the stream so calls can be chained together:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回流的一个引用，以便可以链式调用：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `std::ostream` lives in the `iostream` header, so we include that and add
    the declaration of our operator to our header file in the namespace.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::ostream` 位于 `iostream` 头文件中，因此我们包含该头文件，并将我们的操作符声明添加到头文件中的命名空间。'
- en: Listing 5.12 Declaring `operator<<` for a card
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.12 声明牌的 `operator<<`
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Includes the header we use
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含我们使用的头文件
- en: ❷ Declares our function
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 声明我们的函数
- en: We have two data members to stream out. The `FaceValue` member has a getter
    called `value` that we can use to stream out the underlying `int`. A card’s value
    will show as a number, even if it’s an ace or court card. We’ll improve on that
    later. The suit is a scoped `enum`, which we can also stream out as an `int` for
    now. By default, scoped enums use `int`s for the enumerators, so we can cast the
    suit to an `int`, using `static_ cast`, and stream that out too. Our header file
    promised a function in a namespace, so we define the function inside `namespace`
    `cards` in the source file called `playing_ cards.cpp`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个数据成员需要输出。`FaceValue` 成员有一个名为 `value` 的获取器，我们可以用它来输出底层的 `int`。一张牌的值将显示为一个数字，即使它是
    A 牌或宫廷牌。我们稍后会改进这一点。花色是一个范围 `enum`，我们目前也可以将其作为 `int` 输出。默认情况下，范围枚举使用 `int` 作为枚举值，因此我们可以使用
    `static_cast` 将花色转换为 `int` 并输出。我们的头文件承诺在命名空间中定义一个函数，所以我们定义该函数在源文件 `playing_cards.cpp`
    中的 `namespace` `cards` 内。
- en: Listing 5.13 Defining `operator <<` for a card
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.13 定义牌的 `operator <<`
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Includes our header
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含我们的头文件
- en: ❷ Adds codes inside a namespace
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在命名空间内添加代码
- en: ❸ Defines the function
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 定义函数
- en: ❹ Gets the FaceValue’s value
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 获取 `FaceValue` 的值
- en: ❺ Casts the enum to an int
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将枚举转换为 `int`
- en: 'If you are building this from a prompt, you need to state both `cpp` files
    for your build command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从提示符构建，你需要在你构建命令中指定两个 `cpp` 文件：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Armed with `Card card{FaceValue(2), Suit::Clubs}`, we can now write
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 带着使用 `Card card{FaceValue(2), Suit::Clubs}` 构造的 `Card`，我们现在可以写出
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: and get `2` `of` `2`. Clubs is the third element in the `enum`, so using a zero-based
    index does give us 2 for clubs, but seeing `2` `of` `Clubs` would be nicer.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 并得到 `2` `of` `2`。梅花是 `enum` 的第三个元素，所以使用基于 `0` 的索引确实给我们 `2` 代表梅花，但看到 `2` `of`
    `梅花` 会更美观。
- en: We could update the stream operator for a card, but we may have situations where
    we only want to show the face value or suit. We could write a stream operator
    for each, or we could write a `to_string` method. C++11 added `to_string` methods
    for numeric types. These functions live in the `string` header.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更新卡片的流操作符，但可能存在我们只想显示面值或花色的情况。我们可以为每个写一个流操作符，或者我们可以写一个 `to_string` 方法。C++11
    为数值类型添加了 `to_string` 方法。这些函数位于 `string` 头文件中。
- en: 'We can write our own `to_string` overloads, one for a `Suit` and one for a
    `FaceValue`. The declaration for the `Suit` takes a `Suit` and returns a `string`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写自己的 `to_string` 重载，一个用于 `Suit`，一个用于 `FaceValue`。`Suit` 的声明接受一个 `Suit`
    并返回一个 `string`：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As with the other declarations, it belongs in the header file. We also include
    the `string` header in our header because we are using an `std::string`. So much
    for the declaration. How do we define the function? In the last chapter, we noted
    we can use the `operator ""s` from `std::literals` to make an `std::string`. `"Hearts"s`
    creates an `std::string`, while `"Hearts"` is a char array. This is not a big
    deal, but we are returning a string, so let’s create a string. The simplest approach
    possible for our `to_string` function is to use a `switch` statement, pairing
    up enumerators and suits. We add a default to silence potential warnings about
    a code path without a return statement.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他声明一样，它属于头文件。我们还包含 `string` 头文件在我们的头文件中，因为我们正在使用 `std::string`。关于声明的部分就到这里。我们如何定义函数呢？在上一章中，我们提到我们可以使用
    `std::literals` 中的 `operator ""s` 来创建一个 `std::string`。`"Hearts"s` 创建了一个 `std::string`，而
    `"Hearts"` 是一个字符数组。这不是什么大问题，但我们是返回一个字符串，所以让我们创建一个字符串。对于我们的 `to_string` 函数，最简单的方法是使用
    `switch` 语句，将枚举符和花色配对。我们添加一个默认值来抑制关于没有返回语句的代码路径的潜在警告。
- en: Listing 5.14 Turning an enum value into a string
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.14 将枚举值转换为字符串
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ For operator ""s
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用于操作符 ""s
- en: ❷ Creates std::strings directly
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 直接创建 std::strings
- en: We could throw an exception at the end rather than returning a question mark.
    There are options, but this simple approach is good enough.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在末尾抛出一个异常而不是返回一个问号。有选择，但这个简单的方法已经足够好。
- en: Note Java and C# enums support a `ToString` method, but C++ does not. If C++
    had reflection, we could convert an enum value to a string. However, C++ does
    not support reflection yet, but there is a technical specification (called TS
    for short; see [https://www.iso.org/deliverables-all.html](https://www.iso.org/deliverables-all.html))
    for compile time, or static, reflection ([http://mng.bz/G9n8](http://mng.bz/G9n8)).
    Potential C++ features sometimes have example implementations, and some compilers
    also offer experimental headers, for example, `<experimental/reflect>` (see [http://mng.bz/YRMQ](http://mng.bz/YRMQ)).
    There is more than one reflection proposal ([http://mng.bz/OPjO](http://mng.bz/OPjO)),
    so time will tell which approach C++ ends up taking.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Java 和 C# 枚举支持一个 `ToString` 方法，但 C++ 不支持。如果 C++ 有反射，我们可以将枚举值转换为字符串。然而，C++
    还不支持反射，但有一个技术规范（简称 TS；见 [https://www.iso.org/deliverables-all.html](https://www.iso.org/deliverables-all.html)）用于编译时或静态反射
    ([http://mng.bz/G9n8](http://mng.bz/G9n8))。潜在的 C++ 功能有时有示例实现，一些编译器也提供实验性头文件，例如
    `<experimental/reflect>`（见 [http://mng.bz/YRMQ](http://mng.bz/YRMQ)）。有多个反射建议 ([http://mng.bz/OPjO](http://mng.bz/OPjO))，所以时间会告诉我们
    C++ 最终会采取哪种方法。
- en: We can now get `2` `of` `Clubs` when we display the card we created. However,
    court cards and aces will be displayed as numbers as it stands. Because we created
    a `FaceValue` type, we can write another `to_string` overload, with special cases
    for court cards and an ace. Any other value will use the `std::to_string` method
    for `int`s. As usual, we declare the function in the header and define it inside
    our namespace in the playing cards source file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们显示我们创建的卡片时，我们可以得到 `2` `of` `Clubs`。然而，由于目前的状态，宫廷卡片和 A 牌将显示为数字。因为我们创建了一个
    `FaceValue` 类型，我们可以写另一个 `to_string` 重载，为宫廷卡片和 A 牌提供特殊案例。任何其他值将使用 `std::to_string`
    方法为 `int`。像往常一样，我们在头文件中声明函数，并在玩牌源文件中的命名空间内定义它。
- en: Listing 5.15 Converting card value to a string
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.15 将卡片值转换为字符串
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ For operator ""s
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用于操作符 ""s
- en: ❷ Creates std::strings directly
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 直接创建 std::strings
- en: ❸ 2 to 9 as strings
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 2 到 9 作为字符串
- en: We can now update our stream insertion operator to use our overloaded `to_string`
    functions
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更新我们的流插入操作符以使用我们的重载 `to_string` 函数
- en: Listing 5.16 Showing ace, jack, queen, king, or number
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.16 显示 A 牌、杰克、王后、国王或数字
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Uses our new functions
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用我们的新函数
- en: If we stream out a special value card
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们流出一个特殊值卡片
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: we see `Ace of Hearts`. We can make individual cards, so now we need to make
    a deck of cards.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到“红桃A”。我们可以制作单独的牌，所以现在我们需要制作一副牌。
- en: 5.1.5 Using an array to make a deck of cards
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.5 使用数组创建一副牌
- en: 'We previously used a `vector` when we wanted a collection of elements. The
    `vector` is great when we have an unknown number of elements, but we know we need
    52 cards for a full deck. C++11 introduced the array type ([https://en.cppreference.com/w/cpp/container/array](https://en.cppreference.com/w/cpp/container/array))
    for a fixed-size array. It lives in the `array` header and is defined with a type
    and a size:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用`vector`时想要一个元素集合。当元素数量未知但我们需要52张牌来组成一副完整的牌时，`vector`非常棒。C++11引入了数组类型([https://en.cppreference.com/w/cpp/container/array](https://en.cppreference.com/w/cpp/container/array))，用于固定大小的数组。它位于`array`头文件中，并使用类型和大小定义：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `vector` took the type of elements, `T`, but `array` also needs a compile
    time size, `N`. A vector can resize dynamically, but the array size is fixed at
    compile time to the chosen size. The array has a very small overhead for housekeeping
    and can be placed on the stack rather than the heap. This is illustrated in figure
    5.1.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector`取了元素类型`T`，但`array`也需要一个编译时的大小`N`。向量可以动态调整大小，但数组的大小在编译时固定为所选大小。数组在维护方面有非常小的开销，并且可以放在栈上而不是堆上。这如图5.1所示。'
- en: '![CH05_F01_Buontempo](../Images/CH05_F01_Buontempo.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F01_Buontempo](../Images/CH05_F01_Buontempo.png)'
- en: Figure 5.1 A vector has more overhead, places elements on the heap, and can
    change size dynamically, while an array has a smaller overhead and fixed size.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 向量有更多的开销，将元素放置在堆上，并且可以动态改变大小，而数组有较小的开销和固定的大小。
- en: Our deck of cards can therefore be declared as
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以声明一副牌
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We could use a C-style array, `Card` `deck[52]`, instead, but the `std::array`
    keeps us safer because we always know the size of the array. In both cases, we
    get 52 default constructed cards. With a `vector`, we would `push_back` or `emplace`
    any new cards we needed, and the `vector` would grow. We can initialize some or
    all of the cards using aggregate initialization. Thus
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用C风格的数组`Card` `deck[52]`，但`std::array`使我们更安全，因为我们总是知道数组的大小。在这两种情况下，我们都会得到52个默认构造的牌。使用`vector`，我们会`push_back`或`emplace`任何我们需要的新的牌，并且`vector`会增长。我们可以使用聚合初始化来初始化一些或所有牌。因此
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: puts a 2 of hearts at the start and uses the default constructor for the remaining
    51 cards. We can access specific elements like we would in a `vector` or a C-style
    array, using `operator[]`, so `deck[0]` is the first card. If we need to pass
    our `array` to a function taking a pointer to the array type (e.g., in a C library
    function), we can call the `data` member function to obtain a pointer to the underlying
    data.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始处放置一张红桃2，并使用默认构造函数为剩余的51张牌。我们可以像在`vector`或C风格数组中一样访问特定元素，使用`operator[]`，所以`deck[0]`是第一张牌。如果我们需要将我们的`array`传递给需要一个指向数组类型的指针的函数（例如，在C库函数中），我们可以调用`data`成员函数来获取对底层数据的指针。
- en: Let’s write a function to create a deck of cards. We need to include the `array`
    header, declare the function in our header, and then define it in the source file.
    We need 13 values for each of the four suits. Unfortunately, we cannot simply
    iterate over the `Suit` enumeration. Nothing forces the values to be contiguous,
    even though they are in our case. Using `operator++` might therefore use an invalid
    enum value in the general case. What we can do instead is put the values into
    an `initializer_list`. We used brace initialization in chapter 2 when we discussed
    the uniform initialization syntax. By making an initializer list of the suits
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个函数来创建一副牌。我们需要包含`array`头文件，在我们的头文件中声明函数，然后在源文件中定义它。对于四种花色中的每一种，我们需要13个值。不幸的是，我们无法简单地遍历`Suit`枚举。即使在这种情况下，值也不一定是连续的。因此，在一般情况下，使用`operator++`可能会使用一个无效的枚举值。我们可以做的是将这些值放入一个`initializer_list`中。我们在第2章讨论统一初始化语法时使用了花括号初始化。通过创建一个花色的初始化列表
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: we have an array-like object we can use in a loop. We need to cycle through
    the 13 face values for each suit. Starting with an iterator at the beginning of
    the `array`, we can set its contents using `*card` and move to the next card using
    `++card` each time around the loop.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个类似数组的对象可以在循环中使用。我们需要遍历每个花色的13个面值。从`array`的开始位置使用迭代器，我们可以使用`*card`设置其内容，并在每次循环中通过使用`++card`移动到下一张牌。
- en: Listing 5.17 Building a deck of cards
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.17 构建一副牌
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Iterator starting with the first card
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从第一张牌开始的迭代器
- en: ❷ Initializer list of suits
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 花色的初始化列表
- en: ❸ Cycles round values
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 循环值
- en: ❹ Sets the card’s values
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 设置牌的值
- en: ❺ Moves to next card
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 移动到下一张牌
- en: We could use what we have so far to make a card game, but we noted the encouragement
    to avoid raw loops and prefer algorithms in chapter 2\. We can refactor the function
    in listing 5.17 to create a deck of cards using algorithms instead. We haven’t
    seen any tests in this chapter, but the GitHub code includes a `check_properties`
    function, similar to the test functions we wrote in previous chapters. Think about
    what we should test before we refactor the code. Do we get an exception for a
    card with face value 0? Do we really have 52 distinct cards?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用到目前为止所拥有的内容来制作一副牌，但我们注意到在第二章中鼓励避免使用原始循环并优先考虑算法。我们可以重构列表5.17中的函数，使用算法来创建一副牌。在本章中我们没有看到任何测试，但GitHub代码中包含一个`check_properties`函数，类似于我们在前几章中编写的测试函数。在重构代码之前，我们应该考虑测试什么。对于面值为0的牌，我们会得到一个异常吗？我们真的有52张不同的牌吗？
- en: 5.1.6 Using generate to fill the array
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.6 使用generate填充数组
- en: 'The `algorithm` header includes a method called `generate`, which assigns successive
    values generated by a function object to a range `[first,` `last)`. C++20 introduced
    newer versions, including overloads that apply to ranges, so we can use the `std::array<Card,`
    `52>` `deck` directly, without finding `begin` and `end` ourselves. We can use
    a lambda as the function object to generate the values:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`algorithm`头文件中包含一个名为`generate`的方法，该方法将函数对象生成的连续值分配给范围`[first, last)`。C++20引入了新的版本，包括适用于范围的重载，因此我们可以直接使用`std::array<Card,
    52> deck`，而无需自己找到`begin`和`end`。我们可以使用lambda作为函数对象来生成值：'
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We want to cycle through values from 1 to 13, with one of each value per suit.
    We noted there is no `operator++` for an enum, since that might use an invalid
    enum value; therefore, we used an initializer list in listing 5.17 to loop over
    each enumerator. Let’s consider an alternative and learn a little more about scoped
    enums. In our case, the enum values are contiguous, and in fact, when we get to
    the last suit, we could start back at the beginning, allowing us to use an array
    of 104 cards to get two decks of cards if we wanted. We can cast the enum value
    to an `int` using `static_cast` because we noted that a scoped enum has an underlying
    type, which will be an `int` by default. We declared our `enum` like this
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望循环遍历1到13的值，每个花色中有一个相同的值。我们注意到枚举没有`operator++`操作符，因为这可能会使用一个无效的枚举值；因此，我们在列表5.17中使用初始化列表来遍历每个枚举器。让我们考虑一个替代方案，并了解一些关于作用域枚举的更多信息。在我们的情况下，枚举值是连续的，实际上，当我们到达最后一副牌时，我们可以从开始处重新开始，这样我们就可以使用104张牌的数组来得到两副牌，如果我们想的话。我们可以使用`static_cast`将枚举值转换为`int`，因为我们注意到作用域枚举有一个底层类型，默认情况下将是`int`。我们这样声明我们的`enum`：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'in listing 5.4\. We can also specify a type if we want to; for example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表5.4中。我们也可以指定一个类型；例如：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This might save a bit of space if we do not need an integer, and we can even
    use a `char` if we have very few values. Alternatively, we could use a `long long`
    if we needed a very long list of enumerators. Rather than casting to `int`, we
    can use `underlying_type` to decide what to cast to in the general case. We can
    then pick the next suit and go back to the start when we reach the end.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要整数，这可能会节省一点空间，如果我们有非常少的值，我们甚至可以使用`char`。或者，如果我们需要一个非常长的枚举值列表，我们可以使用`long
    long`。而不是将类型强制转换为`int`，在一般情况下，我们可以使用`underlying_type`来决定转换为什么类型。然后我们可以选择下一个花色，并在达到末尾时回到起点。
- en: Listing 5.18 Incrementing our enum
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.18 递增我们的枚举
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Underlying enum type
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 底层枚举类型
- en: ❷ Back to first suit
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回第一副牌
- en: ❸ Increments using a cast
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用强制转换进行递增
- en: This code is relying on contiguous enumerator values, and changing the order
    of the enumerators would break the code. However, it’s worth being aware of the
    `underlying_type` of a scoped enum.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码依赖于连续的枚举值，改变枚举值的顺序会破坏代码。然而，了解作用域枚举的`underlying_type`是值得注意的。
- en: As with all the code for our cards, we put the function in the playing card
    source file and declare it in the header file. We can now generate the values
    needed for our `array`. Whether we use the ranges version of `generate` or the
    `begin`/`end` version, we need to include the `algorithm` header. We start with
    a card value of one, incrementing for each card generated. If the value is greater
    than 13, we drop back to one and increment the suit. All of this happens in a
    lambda, so we capture the value and suit by reference, using `[&value, &suit]`.
    The `generate` function calls the lambda once per item in the deck, assigning
    the generated card to each element.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们所有牌的代码一样，我们将函数放在扑克牌源文件中，并在头文件中声明它。我们现在可以生成我们 `array` 所需的值。无论我们使用 `generate`
    的范围版本还是 `begin`/`end` 版本，我们都需要包含 `algorithm` 头文件。我们从一张牌的值为一开始，为每张生成的牌递增。如果值大于
    13，我们将回到一，并递增花色。所有这些都在 lambda 中发生，所以我们通过引用捕获值和花色，使用 `[&value, &suit]`。`generate`
    函数对牌堆中的每个项目调用 lambda 一次，将生成的牌分配给每个元素。
- en: Listing 5.19 Generating the deck of cards
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.19 生成牌组
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Starts with ace of hearts
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 以红桃A开始
- en: ❷ Captures by ref
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过引用捕获
- en: ❸ Resets value and increments suit
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 重置值并递增花色
- en: ❹ Lambda returns a Card and increments value
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ Lambda 返回一个 Card 并递增值
- en: We have a full deck of playing cards, so we are nearly ready to build our game.
    First, we need to be able to compare two cards to decide if one is higher or lower
    than the other.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一副完整的扑克牌，所以我们几乎准备好构建我们的游戏。首先，我们需要能够比较两张牌，以决定一张牌是否比另一张牌高或低。
- en: 5.1.7 Comparison operators and defaults
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.7 比较运算符和默认值
- en: 'There are six possible comparisons for a type:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个类型，有六种可能的比较：
- en: '*Equal* (`==)`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*等于* (`==`)'
- en: '*Not equal* (`!=` )'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*不等* (`!=` )'
- en: '*Less than* (`<)`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*小于* (`<`)'
- en: '*Greater than* (`>`)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大于* (`>`)'
- en: '*Less than or equal* (`<=)`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*小于或等于* (`<=`)'
- en: '*Greater than or equal* (`>=)`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大于或等于* (`>=`)'
- en: C++ has allowed us to write our own comparison operators for a long time. For
    example, we can implement a less-than operator inline in the class definition.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 已经允许我们长时间编写自己的比较运算符。例如，我们可以在类定义中内联实现一个小于运算符。
- en: Listing 5.20 Less-than operator for a `Card`
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.20 `Card` 的小于运算符
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can then compare two cards:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以比较两张牌：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Whether we want to include the suit in the comparison might be a discussion
    point because some card games treat one suit as more valuable than another. More
    importantly, we would expect greater than or equal (`operator` `>=)` to return
    the opposite. However
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 是否将花色包含在比较中可能是一个讨论点，因为一些纸牌游戏将一个花色视为比另一个花色更有价值。更重要的是，我们预计大于或等于 (`operator >=`)
    将返回相反的结果。然而
- en: '[PRE41]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'doesn’t compile. If we write a less-than operator, the other comparisons are
    not generated for us. We could write all the comparison operators ourselves, but
    this is tedious and error prone. C++20 introduced `operator<=>`, sometimes called
    the *spaceship operator* because it looks somewhat like a spaceship, to make our
    lives easier. The spaceship operator gives one of three possible values and is
    therefore also known as a *three-way comparison operator*:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 无法编译。如果我们编写一个小于运算符，其他比较就不会为我们生成。我们可以自己编写所有比较运算符，但这既繁琐又容易出错。C++20 引入了 `operator<=>`，有时称为
    *spaceship operator*，因为它看起来有点像一艘宇宙飞船，这使得我们的工作更简单。这个宇宙飞船运算符给出三种可能值之一，因此也被称为 *三路比较运算符*：
- en: '*x* <=> *y* < 0 if *x* < *y*'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x* <=> *y* < 0 如果 *x* 小于 *y*'
- en: '*x* <=> *y* > 0 if *x* > *y*'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x* <=> *y* > 0 如果 *x* 大于 *y*'
- en: '*x* <=> *y* == 0 if *x* is equal *y*'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x* <=> *y* == 0 如果 *x* 等于 *y*'
- en: The return type is an *order category type*. The full details are involved,
    but for an integral type, such as an `int` or our `Suit` enum, we get an `std::strong_ordering`
    back, defined in the `compare` header (see [http://mng.bz/p1D0](http://mng.bz/p1D0)).
    We can use the keyword `auto`, rather than looking up which specific return type
    we need to use. This result can in turn be transformed automatically into one
    of the six two-way comparison operators. Now, we could implement the spaceship
    operator ourselves, but we can also mark it with the keyword `default.` If we
    do this, the compiler generates all the comparisons for us. The default comparison
    operators will use the fields in the order defined in the class, so both the value
    and the suit are compared. The fields, therefore, need to be comparable, so we
    also need a spaceship operator in our `FaceValue`. The default version will then
    be able to compare the values of two `FaceValues`, using the `value_` member,
    which is exactly what we require.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型是一个*顺序类别类型*。详细内容涉及较多，但对于整型，例如`int`或我们的`Suit`枚举，我们会得到一个`std::strong_ordering`返回值，它在`compare`头文件中定义（见[http://mng.bz/p1D0](http://mng.bz/p1D0)）。我们可以使用关键字`auto`，而不是查找我们需要使用哪个特定的返回类型。这个结果可以自动转换成六个双向比较运算符之一。现在，我们既可以自己实现飞船运算符，也可以用关键字`default`来标记它。如果我们这样做，编译器会为我们生成所有的比较。默认比较运算符将使用类中按顺序定义的字段，因此值和花色都会被比较。因此，字段需要是可比较的，所以我们的`FaceValue`也需要一个飞船运算符。默认版本将能够比较两个`FaceValue`的值，使用的是`value_`成员，这正是我们所需要的。
- en: We need to add the `compare` header first, which works out the return type and
    synthesizes the comparison operators for us. We then add a single line to both
    our `FaceValue` and `Card` definitions and, finally, have what we need.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要添加`compare`头文件，它会计算出返回类型并为我们合成比较运算符。然后我们在`FaceValue`和`Card`的定义中添加一行，最后我们就有了所需的内容。
- en: Listing 5.21 Default three-way comparison operator
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.21 默认的三向比较运算符
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ Generates default comparison
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 生成默认比较
- en: ❷ Value used in comparison
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用于比较的值
- en: ❸ Generates default comparison
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 生成默认比较
- en: ❹ Value and suit used in comparison
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 用于比较的值和花色
- en: That took very little effort to add six comparison operators to both of our
    types. As we used 1 for an ace, this defaulted operator means aces are the lowest
    card. We could write our own comparison instead, or use the values 2 to 14, making
    14 the ace and therefore the card with the highest value. Feel free to do that
    instead for extra practice. Armed with a deck of cards and a way to compare cards,
    we can now create a card game of higher or lower.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的两种类型添加六个比较运算符几乎不费吹灰之力。因为我们把1用作A，这个默认运算符意味着A是最小的牌。我们也可以自己编写比较，或者使用2到14的值，使14为A，因此是价值最高的牌。你可以自由地这样做以进行额外的练习。有了牌堆和比较牌的方法，我们现在可以创建一个高或低牌局游戏。
- en: 5.2 Higher-or-lower card game
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 高或低牌局游戏
- en: When we create our deck of cards, they run in order, so we can work out what
    comes next. Randomizing the order would make the game more interesting, so we
    need a way to shuffle the cards.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建我们的牌堆时，牌是按顺序排列的，因此我们可以计算出下一张是什么。随机化顺序会使游戏更有趣，因此我们需要一种洗牌的方法。
- en: 5.2.1 Shuffling the deck
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 洗牌
- en: We’ve used random numbers before; however, we now want a random shuffle, rather
    than a sequence of random numbers. The `algorithm` header has the method we need.
    If we look at CppReference ([http://mng.bz/eEjZ](http://mng.bz/eEjZ)), we see
    `random_shuffle` and `shuffle` methods. Each of the `random_shuffle` versions
    has been deprecated or removed. One version used C’s `rand` function, which is
    likely to be deprecated at some point. We have seen how much better the C++ random
    number generators are. Using `rand` can depend on the global state, which causes
    problems for multithreaded code. Some naïve implementations of `random_shuffle`
    also used `rand()` `% i` for an index `i` to swap elements. Whenever we use a
    modulus for a random number, we are in danger of skewing a distribution. Stephan
    Lavavej gave a talk back in 2013 titled “rand() Considered Harmful” (see [http://mng.bz/g7Dn](http://mng.bz/g7Dn)),
    explaining why we should avoid using `rand` in conjunction with `%`. If we wanted
    to simulate a dice roll, using `rand()` `% 6` would not give us a uniform distribution
    because `MAX_INT` is not a multiple of six. Lower dice rolls will therefore be
    slightly more likely. Try it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经使用过随机数；然而，我们现在需要一个随机洗牌，而不是随机数的序列。`algorithm` 头文件中有我们需要的函数。如果我们查看 CppReference
    ([http://mng.bz/eEjZ](http://mng.bz/eEjZ))，我们会看到 `random_shuffle` 和 `shuffle`
    方法。每个 `random_shuffle` 版本都已弃用或删除。一个版本使用了 C 的 `rand` 函数，这可能在某个时候被弃用。我们已经看到 C++
    随机数生成器有多好。使用 `rand` 可能依赖于全局状态，这会导致多线程代码出现问题。一些简单的 `random_shuffle` 实现也使用了 `rand()`
    `% i` 来为索引 `i` 交换元素。每次我们使用随机数的模运算时，我们都有偏斜分布的风险。Stephan Lavavej 在 2013 年发表了一个名为“rand()
    Considered Harmful”的演讲（见 [http://mng.bz/g7Dn](http://mng.bz/g7Dn)），解释了为什么我们应该避免与
    `%` 一起使用 `rand`。如果我们想模拟掷骰子，使用 `rand()` `% 6` 不会给我们一个均匀分布，因为 `MAX_INT` 不是六的倍数。因此，较小的骰子点数将稍微更有可能。试试看。
- en: Avoiding the deprecated shuffles leaves us with `std::shuffle`. This requires
    items to shuffle and a random number generator. We can either pass `begin` and
    `end` to `std::shuffle` or use the range variant, `std::ranges::shuffle`, on our
    deck of cards directly. We will use `random_device` to seed an `mt19937` generator,
    like we have done before. We need to include the `algorithm` and `random` headers
    for `shuffle` and a random generator, respectively. We need to pass the deck by
    reference so we can change it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 避免弃用的洗牌方法，我们只剩下 `std::shuffle`。这需要一个要洗的元素和一个随机数生成器。我们可以将 `begin` 和 `end` 传递给
    `std::shuffle`，或者直接在我们的牌组上使用范围变体，`std::ranges::shuffle`。我们将使用 `random_device`
    来初始化一个 `mt19937` 生成器，就像我们之前做的那样。我们需要包含 `algorithm` 和 `random` 头文件，分别用于 `shuffle`
    和随机生成器。我们需要通过引用传递牌组，这样我们就可以改变它。
- en: Listing 5.22 Shuffling the cards
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.22 洗牌卡片
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ Passes deck by reference
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过引用传递牌组
- en: ❷ Seeds the random number generator
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 初始化随机数生成器
- en: ❸ Shuffles the deck
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 洗牌
- en: For a card game that requires several shuffles, it would be sensible to have
    a class with a shuffle method, setting up the generator in the constructor. Nonetheless,
    the simple approach in listing 5.22 is sufficient for our higher-or-lower card
    game. We now have a way to shuffle a deck of cards, so we can build our game.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要多次洗牌的纸牌游戏，有一个具有洗牌方法、在构造函数中设置生成器的类是有意义的。尽管如此，列表 5.22 中的简单方法对于我们的高低牌游戏来说是足够的。我们现在有了一种洗牌的方法，所以我们可以构建我们的游戏。
- en: 5.2.2 Building the game
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 构建游戏
- en: 'We will show the first card in the deck and ask the player whether the next
    card will be higher or lower, and we will continue until we run out of cards or
    the player is wrong. We can use a single character, `''h''` for higher or `''l''`
    for lower, so the player doesn’t need to type much:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示牌组中的第一张牌，并询问玩家下一张牌将是更高还是更低，我们将继续进行，直到牌用完或玩家猜错。我们可以使用单个字符，`'h'` 表示更高或 `'l'`
    表示更低，这样玩家就不需要输入太多：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We compare the current card and the next card, relying on the automatically
    generated `operator<` and `operator>` given by default from the three-way comparison
    in listing 5.21 to see whether the guess is correct.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们比较当前牌和下一张牌，依赖于列表 5.21 中给出的默认的三向比较自动生成的 `operator<` 和 `operator>` 来判断猜测是否正确。
- en: Listing 5.23 Checking whether the guess is correct
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.23 检查猜测是否正确
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The game starts with the first card in the deck. We can find the first card
    in the array in various ways, but it might be nice to keep track of how many guesses
    are correct and report this when the game is over. We can use this count to index
    into the array, as we would with a C-style array, and the index will tell us how
    far we are through the deck. We’ll run through all the cards in the deck but stop
    if an incorrect guess is made. Pulling this together gives us our higher-or-lower
    card game function.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏从牌组中的第一张牌开始。我们可以用各种方式找到数组中的第一张牌，但跟踪正确猜测的数量并在游戏结束时报告这个数字可能是个好主意。我们可以使用这个计数来索引数组，就像使用C风格数组一样，索引将告诉我们我们已通过牌组的程度。我们将遍历牌组中的所有牌，但如果猜错则停止。将这些组合在一起就得到了我们的高低牌游戏函数。
- en: Listing 5.24 Higher-or-lower card game
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.24 高低牌游戏
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ Loops around remaining 51 cards
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在剩余的51张牌周围循环
- en: ❷ Shows current card
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 显示当前牌
- en: ❸ Higher or lower
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 高或低
- en: ❹ Checks the guess
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查猜测
- en: ❺ Drops out of loop if wrong
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果猜错则退出循环
- en: ❻ Shows how many are correct
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 显示正确数量
- en: Again, we’ll define this in the playing card source file and declare it in our
    header file. We then call it from `main`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将在扑克牌源文件中定义它，并在我们的头文件中声明它。然后我们从`main`函数中调用它。
- en: Listing 5.25 Our game
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.25 我们的游戏
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Don’t forget, aces are the lowest value, and the suits have an order too. It
    is difficult to get more than a handful correct. A typical game might play out
    like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，A牌是最低的牌面，花色也有顺序。正确地拿到一手牌是困难的。一场典型的游戏可能如下进行：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We have a working card game. We created a simple structure and used it in an
    array. We let C++ do most of the work for us, generating the comparison we needed
    to decide if a card was higher or lower. We could stop here, but some card games
    use jokers as well. A joker does not have a suit or value, so how can we add jokers
    to our deck of cards?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个工作的牌局。我们创建了一个简单的结构并在数组中使用它。我们让C++为我们做大部分工作，生成我们需要的比较来确定一张牌是高还是低。我们可以在这里停止，但一些牌局也使用`Joker`。`Joker`没有花色或牌面值，所以我们如何将`Joker`添加到我们的牌组中？
- en: 5.2.3 Using std::variant to support cards or jokers
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 使用`std::variant`支持卡片或`Joker`
- en: The simplest way to define a joker is as an empty struct.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个`Joker`的最简单方法是一个空的`struct`。
- en: Listing 5.26 A joker
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.26 一个`Joker`
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: That is all we need.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我们所需要的。
- en: 'We know how to make a deck of 52 playing cards:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何制作一副52张的扑克牌：
- en: '[PRE50]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'How do we add two jokers? We can’t add jokers to this deck because they are
    a different type. We could make a common base type and use pointers for dynamic
    polymorphism, but that seems over the top. A much simpler approach would be an
    array of one of two types: cards or jokers. The `std::variant`, introduced in
    C++17, makes this possible. It lives in the `variant` header and behaves like
    a `union`, but it is safer. C’s `union` type has a sequence of possible members.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何添加两个`Joker`？我们不能将`Joker`添加到这张牌组中，因为它们是不同类型。我们可以创建一个公共基类型并使用指针来实现动态多态，但这似乎过于复杂。一个更简单的方法是使用一个包含两种类型之一（卡片或`Joker`）的数组。C++17中引入的`std::variant`使得这成为可能。它位于`variant`头文件中，其行为类似于`union`，但更安全。C的`union`类型有一系列可能的成员。
- en: Listing 5.27 A union
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.27 一个联合体
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The union is big enough to hold the largest type used. To access a `Card` from
    this `union`, you use the `card` member, and for a `Joker`, use the `joker` member,
    but you need to track which type is in use. In contrast, a `variant` knows which
    type it currently holds, so the `variant` is often described as a *type-safe union*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 联合体足够大，可以容纳使用的最大类型。要从这个联合体中访问一个`Card`，你使用`card`成员，对于`Joker`，使用`joker`成员，但你需要跟踪正在使用哪种类型。相比之下，`variant`知道它当前持有哪种类型，因此`variant`通常被描述为一种*类型安全的联合体*。
- en: 'We declare a `variant` by stating which types it can hold:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过声明它可以持有的类型来声明一个`variant`：
- en: '[PRE52]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `variant` is a class template defined as a *variadic template*. We will
    look at these in more detail in the last chapter, but for now, notice the three
    dots in the definition:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`variant`是一个定义为*可变参数模板*的类模板。我们将在最后一章更详细地探讨这些内容，但就现在而言，请注意定义中的三个点：'
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The dots are called a *parameter pack*, allowing us to use zero or more template
    arguments. This allows us to define a variant with the two types we need. We used
    `std::optional` in chapter 3 to handle input, which only needed one type. Declaring
    an `optional` without assigning a value
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点被称为*参数包*，允许我们使用零个或多个模板参数。这使我们能够定义一个包含所需两种类型的`variant`。我们在第3章使用了`std::optional`来处理输入，它只需要一种类型。声明一个未赋值的`optional`
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: has no value. If we use this card in a Boolean context, it will evaluate to
    false, so we could make an `optional` work, but the code might be hard to follow.
    We’d need to remember that `if(!card)` meant we had a joker. How do we use a `variant`,
    then?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 没有值。如果我们在这个布尔上下文中使用这张牌，它将评估为 false，所以我们可以使一个 `optional` 工作，但代码可能难以理解。我们需要记住
    `if(!card)` 意味着我们有一个 Jokers。那么我们如何使用 `variant` 呢？
- en: A `variant` is initialized to the first of the alternative types, provided that
    type can be default constructed. If it can’t, we get a compile error. Both of
    our types can be default constructed, so that won’t happen here. So using
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `variant` 被初始化为第一个可选类型，前提是这个类型可以被默认构造。如果它不能，我们会得到一个编译错误。我们的两种类型都可以被默认构造，所以这里不会发生这种情况。所以使用
- en: '[PRE55]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'gives us a default constructed `Card` because that’s the first type. We could
    also create a `Joker` instead:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造了一个 `Card`，因为那是第一个类型。我们也可以创建一个 `Joker`：
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In fact, there are various ways to create a variant. We can avoid making a
    temporary `Joker{}` to construct the variant using the `std::in_place_index` function.
    For a `Joker`, we want index 1 and do not have any arguments for the joker’s constructor,
    so we’ll use `std::in_place_index` with value 1:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有各种创建 variant 的方法。我们可以避免使用临时 `Joker{}` 来构造 variant，使用 `std::in_place_index`
    函数。对于一个 `Joker`，我们想要索引 1，并且没有为 joker 的构造函数提供任何参数，所以我们将使用 `std::in_place_index`
    并设置值为 1：
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'For a `Card`, we use the zero index and pass the value and suit to the `Card`
    constructor:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Card`，我们使用零索引并将值和花色传递给 `Card` 构造函数：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: For further details, see [http://mng.bz/amzY](http://mng.bz/amzY).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 更多细节请见 [http://mng.bz/amzY](http://mng.bz/amzY)。
- en: 'We can determine whether we have a joker by checking the variant’s type:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查 variant 的类型来确定我们是否有 Jokers：
- en: '[PRE59]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'There are various ways to retrieve the values. For example, we can use `get`
    with an index:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种方法可以检索值。例如，我们可以使用带索引的 `get`：
- en: '[PRE60]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If we try to get a `Joker` instead
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试获取一个 `Joker`
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: an `std::bad_variant_access` is thrown. Alternatively, we can use `get_if` to
    avoid the exception. Rather than an index, we can use a type, `std::get<Card>(two_of_clubs)`,
    which saves having to remember the order of the types. CppReference gives all
    the details ([https://en.cppreference.com/w/cpp/utility/variant](https://en.cppreference.com/w/cpp/utility/variant)),
    but we now know enough to make a deck of cards with jokers.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 会抛出 `std::bad_variant_access`。或者，我们可以使用 `get_if` 来避免异常。而不是索引，我们可以使用类型，`std::get<Card>(two_of_clubs)`，这样可以节省记住类型顺序的麻烦。CppReference
    提供了所有细节([https://en.cppreference.com/w/cpp/utility/variant](https://en.cppreference.com/w/cpp/utility/variant))，但我们现在已经足够了解如何制作带有
    Jokers 的牌组。
- en: 'We have used `optional` and have met `variant`. There is a third type, called
    `std::any`, which lives in the `any` header. All three types were introduced in
    C++17 and offer slightly different alternatives to similar problems. As the name
    suggests, we can use `any` for almost anything, specifically any copy-constructible
    type. An `any` variable can be switched to other types as needed:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了 `optional` 并遇到了 `variant`。还有一种类型，称为 `std::any`，它位于 `any` 头文件中。这三种类型都是在
    C++17 中引入的，为类似问题提供了一些不同的替代方案。正如其名所示，我们可以几乎用 `any` 做任何事情，特别是任何可复制的类型。`any` 变量可以根据需要转换为其他类型：
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We need to use the `any_cast` method to get the value back. If we have a `Card`
    rather than a `Joker`, calling
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用 `any_cast` 方法来获取值。如果我们有一个 `Card` 而不是 `Joker`，调用
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: would throw an `std::bad_any_cast`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 将抛出 `std::bad_any_cast`。
- en: We could therefore use `any`; however, using `variant` is clearer because we
    will either have a `Card` or a `Joker`. We could even employ `optional`, using
    a variable with no value to indicate a `Joker`, but the intent is clearer when
    we use a `variant`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用 `any`；然而，使用 `variant` 更清晰，因为我们要么有一个 `Card`，要么有一个 `Joker`。我们甚至可以使用
    `optional`，用一个没有值的变量来表示 `Joker`，但使用 `variant` 的意图更清晰。
- en: 5.2.4 Building the game with an extended deck of cards
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 使用扩展牌组构建游戏
- en: 'Let''s make an extended deck. First, we need to add jokers to the deck. We
    can do this in many ways. We met `array` and noted we can initialize some or all
    of the elements using aggregate initialization. We can therefore make the first
    two elements `Joker`s like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制作一个扩展牌组。首先，我们需要向牌组中添加 Jokers。我们可以用很多种方法来做这件事。我们遇到了 `array` 并注意到我们可以使用聚合初始化来初始化一些或所有元素。因此，我们可以这样制作前两个元素为
    `Joker`：
- en: '[PRE64]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can also make the usual 52 cards like we have done before:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以制作像之前一样的 52 张普通牌：
- en: '[PRE65]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If we copy these 52 cards over, we will have a deck of cards with two jokers.
    We’ve used `copy` before in chapter 2\. There are several variants of copy, which
    all live in the `algorithm` header. In chapter 2, we met the `ranges::copy` version.
    We have two jokers at the start of the deck, so we want to copy cards after the
    two jokers. Therefore, we need to start copying at `begin` + 2, as shown in figure
    5.2.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们复制这 52 张牌，我们将得到一张带有两张小丑牌的牌组。我们在第 2 章中已经使用了`copy`。`copy`有几个变体，它们都位于`algorithm`头文件中。在第
    2 章中，我们遇到了`ranges::copy`版本。牌组开始处有两张小丑牌，因此我们想要复制两张小丑牌之后的牌。因此，我们需要从`begin` + 2 开始复制，如图
    5.2 所示。
- en: '![CH05_F02_Buontempo](../Images/CH05_F02_Buontempo.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![CH05_F02_Buontempo](../Images/CH05_F02_Buontempo.png)'
- en: Figure 5.2 With two jokers at the start of our array, we copy cards to `begin`
    `+` `2`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 在我们的数组开始处有两张小丑牌，我们将牌复制到`begin` `+` `2`。
- en: In code, we write
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们编写
- en: '[PRE66]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We could use `std::copy` instead, using the `begin` and `end` member functions:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`std::copy`代替，使用`begin`和`end`成员函数：
- en: '[PRE67]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can even use the `begin` and `end` free functions:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用`begin`和`end`自由函数：
- en: '[PRE68]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Some things, like a C-style array, can be iterated but do not have a `begin`
    or `end` method, in which case these free functions can be used instead. If we
    use the free functions when member functions are available, they call the member
    functions for us, so it won’t make any difference for us in this case.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一些东西，比如 C 风格的数组，可以迭代但没有`begin`或`end`方法，在这种情况下可以使用这些自由函数。如果我们使用自由函数而成员函数可用，它们会为我们调用成员函数，所以在这种情况下对我们没有影响。
- en: We need to include the `variant` header in our header and declare the function.
    Using the `ranges` version, we can create an extended deck in the playing card
    source file.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的头文件中包含`variant`头并声明该函数。使用`ranges`版本，我们可以在玩牌源文件中创建一个扩展牌组。
- en: Listing 5.28 Creating an extended deck
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.28 创建扩展牌组
- en: '[PRE69]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: ❶ Starts with two jokers
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从两张小丑牌开始
- en: ❷ Copies a normal deck after the two jokers
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在两张小丑牌之后复制一张普通牌
- en: 'We need to shuffle the extended deck of cards. Our original function worked
    for an array of 52 cards. We now have an array of variants holding either a `Joker`
    or a card, so we can declare an overloaded function in our header:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要洗扩展牌组的牌。我们的原始函数适用于 52 张牌的数组。我们现在有一个包含`Joker`或牌的变体数组的数组，因此我们可以在我们的头文件中声明一个重载函数：
- en: '[PRE70]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We can then define the new function.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以定义新的函数。
- en: Listing 5.29 Shufflling an extended deck
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.29 洗扩展牌组
- en: '[PRE71]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The only difference between this shuffle and the previous version in listing
    5.22 is the type of deck. We could write a function template instead to save the
    duplication. Try it out!
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表 5.22 中的上一个版本相比，这个洗牌的唯一区别是牌组的类型。我们可以编写一个函数模板来避免重复。试试看！
- en: We need two additions to make our higher-or-lower card game work with the extended
    deck. First, we need to decide if a guess involving a `Joker` is correct. If we
    say the guess is correct if either card is a joker, the player in effect gets
    a free turn. We’ll use the `std::holds_alternative<Joker>` function to see whether
    we have a joker and return `true` in that case. Otherwise, we have two non-jokers,
    so we can call our original function, using `std::get<Card>` to obtain cards from
    the variants.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的更高或更低牌游戏与扩展牌组一起工作，我们需要进行两个补充。首先，我们需要决定是否包含`Joker`的猜测是正确的。如果我们说如果任一牌是小丑牌，猜测就是正确的，那么玩家实际上得到了一个免费回合。我们将使用`std::holds_alternative<Joker>`函数来查看我们是否有小丑牌，并在那种情况下返回`true`。否则，我们有两张非小丑牌，因此我们可以调用我们的原始函数，使用`std::get<Card>`从变体中获取牌。
- en: Listing 5.30 Checking whether the guess is correct for an extended deck
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.30 检查扩展牌组的猜测是否正确
- en: '[PRE72]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: ❶ Returns true if either card is a joker
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果任一牌是小丑牌则返回 true
- en: ❷ Gets cards from the variants
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从变体中获取牌
- en: ❸ Otherwise calls the original function
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 否则调用原始函数
- en: We potentially need to display jokers, so we need an overload of the stream
    insertion operator for our variant. Again, we use `holds_alternative` to see if
    we have a joker, in which case we send `"JOKER"` to the stream; otherwise, we
    call our original function.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要显示小丑牌，因此我们需要为我们的变体重载流插入运算符。同样，我们使用`holds_alternative`来查看我们是否有小丑牌，在这种情况下，我们将`"JOKER"`发送到流；否则，我们调用我们的原始函数。
- en: Listing 5.31 Streaming out cards and jokers
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.31 流式输出牌和小丑牌
- en: '[PRE73]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: ❶ A Joker
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一张小丑牌
- en: ❷ Streams the card
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 流式传输牌
- en: We can now write a new game using an extended deck. The code is identical to
    our original game from listing 5.24, except for the creation of an extended deck.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用扩展牌组编写一个新的游戏。代码与列表 5.24 中的原始游戏相同，只是扩展牌组的创建不同。
- en: Listing 5.32 Higher-or-lower card game with jokers
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.32 带有鬼牌的高低牌游戏
- en: '[PRE74]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: ❶ Creates a deck with jokers
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个带有鬼牌的牌组
- en: 'We are relatively unlikely to get a joker, but it could happen. A typical game
    might look like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相对不太可能得到鬼牌，但它可能发生。一个典型的游戏可能看起来像这样：
- en: '[PRE75]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We have built our own type and more. However, we haven’t tried object-oriented
    programming yet. In the next chapter, we will write another class and provide
    virtual functions to learn more about classes.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了自己的类型等等。然而，我们还没有尝试面向对象编程。在下一章中，我们将编写另一个类并提供虚函数来学习更多关于类的内容。
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Headers need an include guard, and the `pragma` directive `once` is now widely
    supported.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头文件需要一个包含保护，并且 `pragma` 指令 `once` 现在得到了广泛的支持。
- en: Use a scoped enum in preference to a C-style enum.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先使用作用域枚举而不是 C 风格枚举。
- en: Certain functions can be flagged as defaulted or deleted.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些函数可以被标记为默认或删除。
- en: The `string` header provides a `to_string` method for numeric values.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string` 头文件为数值提供了 `to_string` 方法。'
- en: Use `std::array` for a container when the size is known at compile time.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当大小在编译时已知时，使用 `std::array` 作为容器。
- en: The three-way comparison (`operator` `<=>`) was introduced in C++20 and can
    be marked as `default`, generating comparisons for us.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三元比较运算符（`operator` `<=>`）在 C++20 中被引入，并可以标记为 `default`，为我们生成比较。
- en: Use `std::shuffle` to shuffle a collection, passing an appropriately seeded
    random number generator.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::shuffle` 来洗牌一个集合，传递一个适当种子的随机数生成器。
- en: Use `std::variant` if an object is one of a limited number of unrelated types.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个对象是有限数量的不相关类型之一，请使用 `std::variant`。
- en: Use `std::any` if you need one of any possible copy-constructible types.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要任何可能的可复制构造类型，请使用 `std::any`。
- en: Many containers have `begin` and `end` member functions, but these are available
    as free functions too for more general use.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多容器都有 `begin` 和 `end` 成员函数，但它们也可以作为自由函数提供，以供更广泛的使用。
