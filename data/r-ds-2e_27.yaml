- en: Chapter 23\. Hierarchical Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第23章 层次数据
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, you’ll learn the art of data *rectangling*, taking data that
    is fundamentally hierarchical, or tree-like, and converting it into a rectangular
    data frame made up of rows and columns. This is important because hierarchical
    data is surprisingly common, especially when working with data that comes from
    the web.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习数据*矩形化*的艺术，将基本上是分层或类似树状的数据转换为由行和列组成的矩形数据框。这很重要，因为分层数据出人意料地常见，特别是在处理来自网络的数据时。
- en: 'To learn about rectangling, you’ll need to first learn about lists, the data
    structure that makes hierarchical data possible. Then you’ll learn about two crucial
    tidyr functions: [`tidyr::unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)
    and [`tidyr::unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml).
    We’ll then show you a few case studies, applying these simple functions again
    and again to solve real problems. We’ll finish off by talking about JSON, the
    most frequent source of hierarchical datasets and a common format for data exchange
    on the web.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解矩形化，您首先需要了解列表，这种数据结构使得分层数据成为可能。然后您将学习两个关键的tidyr函数：[`tidyr::unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)和[`tidyr::unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)。接着，我们将展示几个案例研究，一遍又一遍地应用这些简单函数来解决实际问题。最后，我们将讨论JSON，这是分层数据集的最常见来源，也是网络数据交换的常见格式。
- en: Prerequisites
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: In this chapter, we’ll use many functions from tidyr, a core member of the tidyverse.
    We’ll also use *repurrrsive* to provide some interesting datasets for rectangling
    practice, and we’ll finish by using *jsonlite* to read JSON files into R lists.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用许多来自tidyr的函数，这是tidyverse的核心成员之一。我们还将使用*repurrrsive*提供一些有趣的数据集用于矩形化练习，并且最后使用*jsonlite*将JSON文件读入R列表。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Lists
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'So far you’ve worked with data frames that contain simple vectors such as integers,
    numbers, characters, date-times, and factors. These vectors are simple because
    they’re homogeneous: every element is of the same data type. If you want to store
    elements of different types in the same vector, you’ll need a *list*, which you
    create with [`list()`](https://rdrr.io/r/base/list.xhtml):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经处理过包含简单向量（例如整数、数字、字符、日期时间和因子）的数据框。这些向量之所以简单，是因为它们是同构的：每个元素都是相同的数据类型。如果您想在同一个向量中存储不同类型的元素，您将需要一个*列表*，可以使用[`list()`](https://rdrr.io/r/base/list.xhtml)来创建：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It’s often convenient to name the components, or *children*, of a list, which
    you can do in the same way as naming the columns of a tibble:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 命名列表的组成部分或*子级*通常很方便，您可以像命名tibble的列一样做：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Even for these simple lists, printing takes up quite a lot of space. A useful
    alternative is [`str()`](https://rdrr.io/r/utils/str.xhtml), which generates a
    compact display of the *str*ucture, de-emphasizing the contents:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对于这些简单的列表，打印也会占用相当多的空间。一个有用的替代方法是[`str()`](https://rdrr.io/r/utils/str.xhtml)，它会生成一个*str*ucture的紧凑显示，弱化内容：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, [`str()`](https://rdrr.io/r/utils/str.xhtml) displays each child
    of the list on its own line. It displays the name, if present; then an abbreviation
    of the type; and then the first few values.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，[`str()`](https://rdrr.io/r/utils/str.xhtml)会在单独的行上显示列表的每个子级。如果存在名称，则显示名称；然后是类型的缩写；然后是前几个值。
- en: Hierarchy
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层次结构
- en: 'Lists can contain any type of object, including other lists. This makes them
    suitable for representing hierarchical (tree-like) structures:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以包含任何类型的对象，包括其他列表。这使它们适合表示分层（类似树状）结构：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is notably different from [`c()`](https://rdrr.io/r/base/c.xhtml), which
    generates a flat vector:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这与[`c()`](https://rdrr.io/r/base/c.xhtml)明显不同，后者生成一个平面向量：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As lists get more complex, [`str()`](https://rdrr.io/r/utils/str.xhtml) gets
    more useful, as it lets you see the hierarchy at a glance:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着列表变得更复杂，[`str()`](https://rdrr.io/r/utils/str.xhtml)变得更有用，因为它让您能一目了然地看到层次结构：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As lists get even larger and more complex, [`str()`](https://rdrr.io/r/utils/str.xhtml)
    eventually starts to fail, and you’ll need to switch to [`View()`](https://rdrr.io/r/utils/View.xhtml).^([1](ch23.xhtml#idm44771276868272))
    [Figure 23-1](#fig-view-collapsed) shows the result of calling `View(x5)`. The
    viewer starts by showing just the top level of the list, but you can interactively
    expand any of the components to see more, as in [Figure 23-2](#fig-view-expand-1).
    RStudio will also show you the code you need to access that element, as in [Figure 23-3](#fig-view-expand-2).
    We’ll come back to how this code works in [“Selecting a Single Element with $
    and [[”](ch27.xhtml#sec-subset-one).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随着列表变得越来越大和更复杂，[`str()`](https://rdrr.io/r/utils/str.xhtml)最终会开始失败，您将需要切换到[`View()`](https://rdrr.io/r/utils/View.xhtml)。^([1](ch23.xhtml#idm44771276868272))
    [图23-1](#fig-view-collapsed)展示了调用`View(x5)`的结果。查看器首先显示列表的顶层，但您可以交互地展开任何组件以查看更多内容，如[图23-2](#fig-view-expand-1)所示。RStudio还会显示访问该元素所需的代码，如[图23-3](#fig-view-expand-2)所示。我们将在[“使用
    $ 和 [[ 选择单个元素”](ch27.xhtml#sec-subset-one)]中回到这些代码的工作方式。
- en: '![A screenshot of RStudio showing the list-viewer. It shows the two children
    of x4: the first child is a double vector and the second child is a list. A rightward
    facing triable indicates that the second child itself has children but you can''t
    see them. ](assets/rds2_2301.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![RStudio显示列表查看器的截图。它显示了x4的两个子元素：第一个子元素是一个双向向量，第二个子元素是一个列表。右向三角形表示第二个子元素本身具有子元素，但您无法看到它们。](assets/rds2_2301.png)'
- en: Figure 23-1\. The RStudio view lets you interactively explore a complex list.
    The viewer opens showing only the top level of the list.
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图23-1。RStudio视图允许您交互式地探索复杂列表。查看器开始时只显示列表的顶层。
- en: '![Another screenshot of the list-viewer having expand the second child of x2\.
    It also has two children, a double vector and another list. ](assets/rds2_2302.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![另一个列表查看器的截图，展开了x2的第二个子元素。它也有两个子元素，一个双向向量和另一个列表。](assets/rds2_2302.png)'
- en: Figure 23-2\. Clicking the right-facing triangle expands that component of the
    list so that you can also see its children.
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图23-2。单击右向三角形展开列表的该组件，以便您还可以看到其子元素。
- en: '![Another screenshot, having expanded the grandchild of x4 to see its two children,
    again a double vector and a list. ](assets/rds2_2303.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![另一个截图，展开了x4的孙子以查看其两个子元素，再次是一个双向向量和一个列表。](assets/rds2_2303.png)'
- en: 'Figure 23-3\. You can repeat this operation as many times as needed to get
    to the data you’re interested in. Note the bottom-left corner: if you click an
    element of the list, RStudio will give you the subsetting code needed to access
    it, in this case `x5[[2]][[2]][[2]]`.'
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图23-3。您可以重复此操作多次以获取您感兴趣的数据。请注意左下角：如果单击列表的元素，RStudio将给出访问它所需的子集代码，在本例中为`x5[[2]][[2]][[2]]`。
- en: List Columns
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表列
- en: Lists can also live inside a tibble, where we call them list columns. List columns
    are useful because they allow you to place objects in a tibble that wouldn’t usually
    belong in there. In particular, list columns are used a lot in the [tidymodels
    ecosystem](https://oreil.ly/0giAa), because they allow you to store things like
    model outputs or resamples in a data frame.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表也可以存在于一个数据框中，我们称之为列表列。列表列非常有用，因为它允许您将对象放置在数据框中，这些对象通常不属于数据框。特别是在[tidymodels
    生态系统](https://oreil.ly/0giAa)中，列表列被广泛使用，因为它们允许您存储诸如模型输出或重采样之类的东西在数据框中。
- en: 'Here’s a simple example of a list column:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个列表列的简单示例：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There’s nothing special about lists in a tibble; they behave like any other
    column:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据框中，列表没有任何特殊之处；它们的行为就像任何其他列一样：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Computing with list columns is harder, but that’s because computing with lists
    is harder in general; we’ll come back to that in [Chapter 26](ch26.xhtml#chp-iteration).
    In this chapter, we’ll focus on unnesting list columns into regular variables
    so you can use your existing tools on them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表列进行计算更加困难，但这是因为通常情况下使用列表进行计算本身就比较困难；我们将在[第26章](ch26.xhtml#chp-iteration)回到这个话题。在本章中，我们将专注于将列表列展开成常规变量，这样您就可以在其上使用现有的工具。
- en: The default print method just displays a rough summary of the contents. The
    list column could be arbitrarily complex, so there’s no good way to print it.
    If you want to see it, you’ll need to pull out just the one list column and apply
    one of the techniques that you’ve learned previously, like `df |> pull(z) |> str()`
    or `df |> pull(z) |> View()`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 默认打印方法只显示内容的粗略摘要。列表列可能非常复杂，因此没有好的打印方法。如果您想查看它，您需要提取出一个列表列，并应用您之前学到的技术之一，例如`df
    |> pull(z) |> str()`或`df |> pull(z) |> View()`。
- en: Base R
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础R
- en: 'It’s possible to put a list in a column of a `data.frame`, but it’s a lot fiddlier
    because [`data.frame()`](https://rdrr.io/r/base/data.frame.xhtml) treats a list
    as a list of columns:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将列表放入`data.frame`的列中，但操作起来更复杂，因为[`data.frame()`](https://rdrr.io/r/base/data.frame.xhtml)将列表视为列的列表：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can force [`data.frame()`](https://rdrr.io/r/base/data.frame.xhtml) to
    treat a list as a list of rows by wrapping it in list [`I()`](https://rdrr.io/r/base/AsIs.xhtml),
    but the result doesn’t print particularly well:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将其包装在列表[`I()`](https://rdrr.io/r/base/AsIs.xhtml)中，强制[`data.frame()`](https://rdrr.io/r/base/data.frame.xhtml)将列表视为行列表，但结果并不打印得特别好：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It’s easier to use list columns with tibbles because [`tibble()`](https://tibble.tidyverse.org/reference/tibble.xhtml)
    treats lists like vectors and the print method has been designed with lists in
    mind.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用tibbles更容易使用列表列，因为[`tibble()`](https://tibble.tidyverse.org/reference/tibble.xhtml)将列表视为向量，并且打印方法已经设计了列表的处理方式。
- en: Unnesting
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展开列表
- en: Now that you’ve learned the basics of lists and list columns, let’s explore
    how you can turn them back into regular rows and columns. Here we’ll use simple
    sample data so you can get the basic idea; in the next section we’ll switch to
    real data.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了列表和列表列的基础知识，让我们探讨如何将它们转换回常规的行和列。这里我们将使用简单的样本数据，以便你可以基本了解；在下一节中，我们将切换到真实数据。
- en: 'List columns tend to come in two basic forms: named and unnamed. When the children
    are *named*, they tend to have the same names in every row. For example, in `df1`,
    every element of list column `y` has two elements named `a` and `b`. Named list
    columns naturally unnest into columns: each named element becomes a new named
    column.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表列通常有两种基本形式：命名和未命名。当子元素是*命名*时，在每一行中它们往往具有相同的名称。例如，在`df1`中，列表列`y`的每个元素都有两个名为`a`和`b`的元素。命名列表列自然地展开为列：每个命名元素成为一个新的命名列。
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the children are *unnamed*, the number of elements tends to vary from
    row to row. For example, in `df2`, the elements of list column `y` are unnamed
    and vary in length from one to three. Unnamed list columns naturally unnest into
    rows: you’ll get one row for each child.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当子元素是*未命名*时，元素的数量往往会从一行到另一行变化。例如，在`df2`中，列表列`y`的元素是未命名的，并且在长度上从一到三不等。未命名列表列自然地展开为行：每个子元素都会得到一行。
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'tidyr provides two functions for these two cases: [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)
    and [`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml).
    The following sections explain how they work.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: tidyr为这两种情况提供了两个函数：[`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)和[`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)。下面的部分将解释它们的工作原理。
- en: unnest_wider()
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: unnest_wider()
- en: 'When each row has the same number of elements with the same names, like `df1`,
    it’s natural to put each component into its own column with [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当每一行具有相同数量和相同名称的元素时，比如`df1`，使用[`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)将每个组件自然地放入自己的列中：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By default, the names of the new columns come exclusively from the names of
    the list elements, but you can use the `names_sep` argument to request that they
    combine the column name and the element name. This is useful for disambiguating
    repeated names.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，新列的名称仅来自列表元素的名称，但您可以使用`names_sep`参数要求它们结合列名和元素名。这对于消除重复名称很有用。
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: unnest_longer()
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: unnest_longer()
- en: 'When each row contains an unnamed list, it’s most natural to put each element
    into its own row with [`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当每一行包含一个未命名列表时，最自然的做法是使用[`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)将每个元素放入自己的行中：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note how `x` is duplicated for each element inside of `y`: we get one row of
    output for each element inside the list column. But what happens if one of the
    elements is empty, as in the following example?'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`x`如何对每个`y`内部的元素重复：我们为列表列内的每个元素获得一行输出。但是如果其中一个元素为空会发生什么，如下例所示？
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We get zero rows in the output, so the row effectively disappears. If you want
    to preserve that row, add `NA` in `y`, set `keep_empty = TRUE`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在输出中得到零行，因此行实际上消失了。如果想保留该行，在`y`中添加`NA`，设置`keep_empty = TRUE`。
- en: Inconsistent Types
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不一致的类型
- en: 'What happens if you unnest a list column that contains different types of vectors?
    For example, take the following dataset where list column `y` contains two numbers,
    a character, and a logical, which can’t normally be mixed in a single column:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你展开一个包含不同类型向量的列表列会发生什么？例如，考虑以下数据集，列表列`y`包含两个数字，一个字符和一个逻辑，通常不能混合在单个列中：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)
    always keeps the set of columns unchanged, while changing the number of rows.
    So what happens? How does [`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)
    produce five rows while keeping everything in `y`?'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)始终保持列集不变，同时更改行数。所以会发生什么？[`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)如何在保持`y`中所有内容的同时产生五行？'
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, the output contains a list column, but every element of the
    list column contains a single element. Because [`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)
    can’t find a common type of vector, it keeps the original types in a list column.
    You might wonder if this breaks the commandment that every element of a column
    must be the same type. It doesn’t: every element is a list, even though the contents
    are of different types.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，输出包含一个列表列，但列表列的每个元素都包含一个单一元素。因为[`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)找不到一个共同类型的向量，它将保留列表列中的原始类型。你可能会想知道这是否违反了每列元素必须是相同类型的命令。它不会：每个元素都是一个列表，尽管内容是不同类型的。
- en: Dealing with inconsistent types is challenging and the details depend on the
    precise nature of the problem and your goals, but you’ll most likely need tools
    from [Chapter 26](ch26.xhtml#chp-iteration).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 处理不一致类型是具有挑战性的，详细信息取决于问题的确切性质和你的目标，但你可能需要来自[第26章](ch26.xhtml#chp-iteration)的工具。
- en: Other Functions
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他函数
- en: 'tidyr has a few other useful rectangling functions that we’re not going to
    cover in this book:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: tidyr 还有一些其他有用的矩形函数，本书不打算覆盖：
- en: '[`unnest_auto()`](https://tidyr.tidyverse.org/reference/unnest_auto.xhtml)
    automatically picks between [`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)
    and [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)
    based on the structure of the list column. It’s great for rapid exploration, but
    ultimately it’s a bad idea because it doesn’t force you to understand how your
    data is structured and makes your code harder to understand.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`unnest_auto()`](https://tidyr.tidyverse.org/reference/unnest_auto.xhtml)根据列表列的结构自动选择[`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)和[`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)之间的操作。这对于快速探索很有用，但最终这是一个不好的想法，因为它不强制你理解数据结构，使你的代码更难理解。'
- en: '[`unnest()`](https://tidyr.tidyverse.org/reference/unnest.xhtml) expands both
    rows and columns. It’s useful when you have a list column that contains a 2D structure
    like a data frame, which you don’t see in this book, but you might encounter if
    you use the [tidymodels ecosystem](https://oreil.ly/ytJvP).'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`unnest()`](https://tidyr.tidyverse.org/reference/unnest.xhtml)扩展行和列。当你有一个列表列包含像数据框这样的二维结构时，这是有用的，尽管本书未涉及，但如果你使用[tidymodels生态系统](https://oreil.ly/ytJvP)可能会遇到。'
- en: These functions are good to know about as you might encounter them when reading
    other people’s code or tackling rarer rectangling challenges yourself.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读他人的代码或处理较少见的矩形化挑战时，你会遇到这些函数。
- en: Exercises
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: What happens when you use [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)
    with unnamed list columns like `df2`? What argument is now necessary? What happens
    to missing values?
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你像`df2`这样使用[`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)时，没有命名列表列会发生什么？现在需要什么参数？缺失值会发生什么？
- en: What happens when you use [`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)
    with named list columns like `df1`? What additional information do you get in
    the output? How can you suppress that extra detail?
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你像`df1`这样使用[`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)时，名为列表列会发生什么？输出中有什么额外信息？如何抑制这些额外细节？
- en: 'From time to time you encounter data frames with multiple list columns with
    aligned values. For example, in the following data frame, the values of `y` and
    `z` are aligned (i.e., `y` and `z` will always have the same length within a row,
    and the first value of `y` corresponds to the first value of `z`). What happens
    if you apply two [`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)
    calls to this data frame? How can you preserve the relationship between `x` and
    `y`? (Hint: Carefully read the docs.)'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不时地，您会遇到具有多个列表列和对齐值的数据框。例如，在以下数据框中，`y` 和 `z` 的值是对齐的（即 `y` 和 `z` 在同一行内始终具有相同的长度，`y`
    的第一个值对应于 `z` 的第一个值）。如果您对此数据框应用两次 [`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)，会发生什么？如何保持
    `x` 和 `y` 之间的关系？（提示：仔细阅读文档。）
- en: '[PRE19]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Case Studies
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: The main difference between the simple examples we used earlier and real data
    is that real data typically contains multiple levels of nesting that require multiple
    calls to [`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)
    and/or [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml).
    To show that in action, this section works through three real rectangling challenges
    using datasets from the repurrrsive package.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 早期使用的简单示例与真实数据之间的主要区别在于，真实数据通常包含多层嵌套，需要多次调用 [`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)
    和/或 [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)。为了展示实际情况，本节将通过
    repurrrsive 包中的数据集解决三个真实的矩形化挑战。
- en: Very Wide Data
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非常广泛的数据
- en: We’ll start with `gh_repos`. This is a list that contains data about a collection
    of GitHub repositories retrieved using the GitHub API. It’s a deeply nested list,
    so it’s difficult to show the structure in this book; we recommend exploring a
    little on your own with `View(gh_repos)` before we continue.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 `gh_repos` 开始。这是一个列表，其中包含使用 GitHub API 检索的一组 GitHub 仓库的数据。它是一个深度嵌套的列表，所以在本书中很难展示其结构；我们建议在继续之前稍微自行探索一下，使用
    `View(gh_repos)`。
- en: '`gh_repos` is a list, but our tools work with list columns, so we’ll begin
    by putting it into a tibble. We call this column `json` for reasons we’ll get
    to later.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`gh_repos` 是一个列表，但我们的工具适用于列表列，因此我们将首先将其放入一个 tibble 中。出于后续原因，我们称此列为 `json`。'
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This tibble contains six rows, one row for each child of `gh_repos`. Each row
    contains a unnamed list with either 26 or 30 rows. Since these are unnamed, we’ll
    start with [`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)
    to put each child in its own row:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 tibble 包含六行，每一行都包含一个未命名列表，其中每个列表包含 26 或 30 行。由于这些未命名，我们将使用 [`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)
    将每个子元素放入自己的行中：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'At first glance, it might seem like we haven’t improved the situation: while
    we have more rows (176 instead of 6), each element of `json` is still a list.
    However, there’s an important difference: now each element is a *named* list,
    so we can use [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)
    to put each element into its own column:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，可能会觉得我们没有改进情况：虽然我们有了更多的行（176 行而不是 6 行），但 `json` 的每个元素仍然是一个列表。然而，有一个重要的区别：现在每个元素都是一个
    *具名* 列表，所以我们可以使用 [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)
    将每个元素放入自己的列中：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This has worked, but the result is a little overwhelming: there are so many
    columns that tibble doesn’t even print all of them! We can see them all with [`names()`](https://rdrr.io/r/base/names.xhtml)
    and here we look at the first 10:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有效，但结果有点令人不知所措：列太多，tibble 甚至无法打印全部！我们可以使用 [`names()`](https://rdrr.io/r/base/names.xhtml)
    来查看它们，并且我们在这里查看前 10 个：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s pull out a few that look interesting:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们挑几个看起来有趣的出来：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can use this to work back to understand how `gh_repos` was structured:
    each child was a GitHub user containing a list of up to 30 GitHub repositories
    that they created.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此方法回溯以了解 `gh_repos` 的结构：每个子元素都是一个 GitHub 用户，包含他们创建的最多 30 个 GitHub 仓库的列表。
- en: '`owner` is another list column, and since it contains a named list, we can
    use [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)
    to get at the values:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`owner` 是另一个列表列，由于它包含一个具名列表，我们可以使用 [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)
    获取其值：'
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Uh-oh, this list column also contains an `id` column, and we can’t have two
    `id` columns in the same data frame. As suggested, let’s use `names_sep` to resolve
    the problem:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哦，这个列表列还包含一个 `id` 列，而且在同一个数据框中我们不能有两个 `id` 列。建议使用 `names_sep` 来解决这个问题：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This gives another wide dataset, but you can get the sense that `owner` appears
    to contain a lot of additional data about the person who “owns” the repository.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了另一个宽数据集，但你可以感觉到 `owner` 包含了关于“拥有”仓库的人的大量额外数据。
- en: Relational Data
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系数据
- en: 'Nested data is sometimes used to represent data that we’d usually spread across
    multiple data frames. For example, take `got_chars`, which contains data about
    characters that appear in the *Game of Thrones* books and TV series. Like `gh_repos`,
    it’s a list, so we start by turning it into a list column of a tibble:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套数据有时用于表示通常分布在多个数据框之间的数据。例如，考虑 `got_chars`，其中包含关于出现在 *权力的游戏* 书籍和电视系列中的角色的数据。像
    `gh_repos` 一样，它是一个列表，因此我们首先将其转换为一个 tibble 的列表列：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `json` column contains named elements, so we’ll start by widening it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`json` 列包含命名元素，因此我们将从扩展它开始：'
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then we select a few columns to make it easier to read:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们选择几列以便阅读更轻松：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This dataset also contains many list columns:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据集还包含许多列表列：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s explore the `titles` column. It’s an unnamed list column, so we’ll unnest
    it into rows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索 `titles` 列。它是一个未命名的列表列，因此我们将其展开为行：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You might expect to see this data in its own table because it would be easy
    to join to the characters data as needed. Let’s do that, which requires a little
    cleaning: removing the rows containing empty strings and renaming `titles` to
    `title` since each row now contains only a single title.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望看到这些数据在自己的表中，因为可以根据需要轻松地与字符数据连接。我们来做这个，需要进行一些清理：删除包含空字符串的行，并将 `titles`
    重命名为 `title`，因为现在每行只包含一个标题。
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You could imagine creating a table like this for each of the list columns and
    then using joins to combine them with the character data as you need it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象为每个列表列创建这样的表，并使用连接将它们与字符数据结合起来，根据需要使用。
- en: Deeply Nested
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深度嵌套
- en: 'We’ll finish off these case studies with a list column that’s very deeply nested
    and requires repeated rounds of [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)
    and [`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)
    to unravel: `gmaps_cities`. This is a two-column tibble containing five city names
    and the results of using Google’s [geocoding API](https://oreil.ly/cdBWZ) to determine
    their location:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一个非常深度嵌套的列表列结束这些案例研究，需要重复使用 [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)
    和 [`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)
    来解开：`gmaps_cities`。这是一个包含五个城市名称及其使用 Google 的 [geocoding API](https://oreil.ly/cdBWZ)
    确定位置的结果的两列 tibble：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`json` is a list column with internal names, so we start with an [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`json` 是一个包含内部名称的列表列，因此我们从 [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)
    开始：'
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This gives us the `status` and the `results`. We’ll drop the status column
    since they’re all `OK`; in a real analysis, you’d also want to capture all the
    rows where `status != "OK"` and figure out what went wrong. `results` is an unnamed
    list, with either one or two elements (we’ll see why shortly), so we’ll unnest
    it into rows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们了 `status` 和 `results`。我们将删除 `status` 列，因为它们都是 `OK`；在实际分析中，你还需要捕获所有 `status
    != "OK"` 的行，并找出问题所在。`results` 是一个未命名的列表，其中有一个或两个元素（我们很快就会看到原因），所以我们将其展开为行：
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now `results` is a named list, so we’ll use [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `results` 是一个命名列表，因此我们将使用 [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)：
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we can see why two cities got two results: Washington matched both Washington
    state and Washington, DC, and Arlington matched Arlington, Virginia, and Arlington,
    Texas.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到为什么两个城市得到了两个结果：Washington 匹配了华盛顿州和华盛顿特区，Arlington 匹配了弗吉尼亚州的阿灵顿和德克萨斯州的阿灵顿。
- en: 'There are a few different places we could go from here. We might want to determine
    the exact location of the match, which is stored in the `geometry` list column:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `geometry` 列中存储的是匹配项的确切位置，我们可以从这里几个不同的地方开始。
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'That gives us new `bounds` (a rectangular region) and `location` (a point).
    We can unnest `location` to see the latitude (`lat`) and longitude (`lng`):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们新的 `bounds`（一个矩形区域）和 `location`（一个点）。我们可以展开 `location` 看到纬度（`lat`）和经度（`lng`）：
- en: '[PRE38]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Extracting the bounds requires a few more steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 提取边界需要几个步骤：
- en: '[PRE39]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We then rename `southwest` and `northeast` (the corners of the rectangle) so
    we can use `names_sep` to create short but evocative names:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们重命名 `southwest` 和 `northeast`（矩形的角），这样我们可以使用 `names_sep` 创建简短但富有表现力的名称：
- en: '[PRE40]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note how we unnest two columns simultaneously by supplying a vector of variable
    names to [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何通过向[`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)提供变量名的向量来同时展开两列。
- en: 'Once you’ve discovered the path to get to the components you’re interested
    in, you can extract them directly using another tidyr function, [`hoist()`](https://tidyr.tidyverse.org/reference/hoist.xhtml):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发现了获取感兴趣组件的路径，你可以使用另一个tidyr函数[`hoist()`](https://tidyr.tidyverse.org/reference/hoist.xhtml)直接提取它们：
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If these case studies have whetted your appetite for more real-life rectangling,
    you can see a few more examples in `vignette("rectangling", package = "tidyr")`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些案例研究激起了你进一步了解实际整理的兴趣，你可以在`vignette("rectangling", package = "tidyr")`中看到更多例子。
- en: Exercises
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Roughly estimate when `gh_repos` was created. Why can you only roughly estimate
    the date?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大致估计`gh_repos`的创建时间。为什么你只能大致估计日期？
- en: 'The `owner` column of `gh_repo` contains a lot of duplicated information because
    each owner can have many repos. Can you construct an `owners` data frame that
    contains one row for each owner? (Hint: Does [`distinct()`](https://dplyr.tidyverse.org/reference/distinct.xhtml)
    work with `list-cols`?)'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gh_repo`的`owner`列包含大量重复信息，因为每个所有者可以有多个仓库。你能构建一个包含每个所有者一行的`owners`数据框吗？（提示：`distinct()`与`list-cols`一起使用会起作用吗？）'
- en: Follow the steps used for `titles` to create similar tables for the aliases,
    allegiances, books, and TV series for the *Game of Thrones* characters.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照用于`titles`的步骤来创建相似的表格，以列举*权力的游戏*角色的别名、效忠、书籍和电视系列。
- en: Explain the following code line by line. Why is it interesting? Why does it
    work for `got_chars` but might not work in general?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐行解释以下代码。为什么它有趣？为什么它对`got_chars`起作用但在一般情况下可能不起作用？
- en: '[PRE42]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In `gmaps_cities`, what does `address_components` contain? Why does the length
    vary between rows? Unnest it appropriately to figure it out. (Hint: `types` always
    appears to contain two elements. Does [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)
    make it easier to work with than [`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)?)'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`gmaps_cities`中，`address_components`包含什么？为什么长度在行之间变化？适当展开它来找出答案。（提示：`types`似乎总是包含两个元素。使用[`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)比[`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)更容易处理吗？）
- en: JSON
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: All of the case studies in the previous section were sourced from wild-caught
    JSON. JSON is short for JavaScript Object Notation and is the way that most web
    APIs return data. It’s important to understand it because while JSON and R’s data
    types are pretty similar, there isn’t a perfect one-to-one mapping, so it’s good
    to understand a bit about JSON if things go wrong.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中的所有案例研究都来自野生JSON。JSON是JavaScript对象表示法的简称，是大多数Web API返回数据的方式。了解它很重要，因为虽然JSON和R的数据类型非常相似，但并没有完美的一对一映射，所以如果出现问题，了解JSON的一些内容是很有帮助的。
- en: Data Types
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'JSON is a simple format designed to be easily read and written by machines,
    not humans. It has six key data types. Four of them are scalars:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是一种简单的格式，设计成易于机器读写，而不是人类。它有六种关键的数据类型。其中四种是标量：
- en: The simplest type is a null (`null`), which plays the same role as `NA` in R.
    It represents the absence of data.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最简单的类型是空值（`null`），在R中扮演与`NA`相同的角色。它表示数据的缺失。
- en: A *string* is much like a string in R but must always use double quotes.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串类似于R中的字符串，但必须始终使用双引号。
- en: 'A *number* is similar to R’s numbers: they can use integer (e.g., 123), decimal
    (e.g., 123.45), or scientific (e.g., 1.23e3) notation. JSON doesn’t support `Inf`,
    `-Inf`, or `NaN`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字类似于R的数字：它们可以使用整数（例如123）、小数（例如123.45）或科学计数法（例如1.23e3）表示。JSON不支持`Inf`、`-Inf`或`NaN`。
- en: A *boolean* is similar to R’s `TRUE` and `FALSE` but uses lowercase `true` and
    `false`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值类似于R的`TRUE`和`FALSE`，但使用小写的`true`和`false`。
- en: 'JSON’s strings, numbers, and Booleans are pretty similar to R’s character,
    numeric, and logical vectors. The main difference is that JSON’s scalars can represent
    only a single value. To represent multiple values you need to use one of the two
    remaining types: arrays and objects.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: JSON的字符串、数字和布尔值与R的字符、数值和逻辑向量非常相似。主要区别在于JSON的标量只能表示单个值。要表示多个值，需要使用其余两种类型之一：数组和对象。
- en: 'Both arrays and objects are similar to lists in R; the difference is whether
    they’re named. An *array* is like an unnamed list and is written with `[]`. For
    example, `[1, 2, 3]` is an array containing three numbers, and `[null, 1, "string",
    false]` is an array that contains a null, a number, a string, and a Boolean. An
    *object* is like a named list and is written with [`{}`](https://rdrr.io/r/base/Paren.xhtml).
    The names (keys in JSON terminology) are strings, so they must be surrounded by
    quotes. For example, `{"x": 1, "y": 2}` is an object that maps `x` to 1 and `y`
    to 2.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '数组和对象在 R 中类似于列表；它们的区别在于是否命名。*数组* 类似于未命名的列表，并用 `[]` 写出。例如，`[1, 2, 3]` 是一个包含三个数字的数组，`[null,
    1, "string", false]` 是一个包含 null、数字、字符串和布尔值的数组。*对象* 类似于命名列表，并用 [`{}`](https://rdrr.io/r/base/Paren.xhtml)
    写出。名称（在 JSON 术语中称为键）是字符串，因此必须用引号括起来。例如，`{"x": 1, "y": 2}` 是一个将 `x` 映射到 1 而 `y`
    映射到 2 的对象。'
- en: Note that JSON doesn’t have any native way to represent dates or date-times,
    so they’re often stored as strings, and you’ll need to use [`readr::parse_date()`](https://readr.tidyverse.org/reference/parse_datetime.xhtml)
    or [`readr::parse_datetime()`](https://readr.tidyverse.org/reference/parse_datetime.xhtml)
    to turn them into the correct data structure. Similarly, JSON’s rules for representing
    floating-point numbers in JSON are a little imprecise, so you’ll also sometimes
    find numbers stored in strings. Apply [`readr::parse_double()`](https://readr.tidyverse.org/reference/parse_atomic.xhtml)
    as needed to get the correct variable type.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，JSON 没有任何本地方式来表示日期或日期时间，因此它们通常作为字符串存储，您需要使用 [`readr::parse_date()`](https://readr.tidyverse.org/reference/parse_datetime.xhtml)
    或 [`readr::parse_datetime()`](https://readr.tidyverse.org/reference/parse_datetime.xhtml)
    将它们转换为正确的数据结构。同样，JSON 对浮点数的表示规则有些不精确，因此有时您会发现数字存储为字符串。根据需要应用 [`readr::parse_double()`](https://readr.tidyverse.org/reference/parse_atomic.xhtml)
    来获取正确的变量类型。
- en: jsonlite
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jsonlite
- en: 'To convert JSON into R data structures, we recommend the jsonlite package,
    by Jeroen Ooms. We’ll use only two jsonlite functions: [`read_json()`](https://rdrr.io/pkg/jsonlite/man/read_json.xhtml)
    and [`parse_json()`](https://rdrr.io/pkg/jsonlite/man/read_json.xhtml). In real
    life, you’ll use [`read_json()`](https://rdrr.io/pkg/jsonlite/man/read_json.xhtml)
    to read a JSON file from disk. For example, the repurrsive package also provides
    the source for `gh_user` as a JSON file, and you can read it with [`read_json()`](https://rdrr.io/pkg/jsonlite/man/read_json.xhtml):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 JSON 转换为 R 数据结构，我们推荐 Jeroen Ooms 的 jsonlite 包。我们仅使用两个 jsonlite 函数：[`read_json()`](https://rdrr.io/pkg/jsonlite/man/read_json.xhtml)
    和 [`parse_json()`](https://rdrr.io/pkg/jsonlite/man/read_json.xhtml)。在实际中，您会使用
    [`read_json()`](https://rdrr.io/pkg/jsonlite/man/read_json.xhtml) 从磁盘读取 JSON 文件。例如，repurrsive
    包还提供了 `gh_user` 的源作为 JSON 文件，您可以使用 [`read_json()`](https://rdrr.io/pkg/jsonlite/man/read_json.xhtml)
    读取它：
- en: '[PRE43]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In this book, we’ll also use [`parse_json()`](https://rdrr.io/pkg/jsonlite/man/read_json.xhtml),
    since it takes a string containing JSON, which makes it good for generating simple
    examples. To get started, here are three simple JSON datasets, starting with a
    number, then putting a few numbers in an array, and then putting that array in
    an object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们还将使用[`parse_json()`](https://rdrr.io/pkg/jsonlite/man/read_json.xhtml)，因为它接受包含
    JSON 的字符串，非常适合生成简单的示例。要开始，这里有三个简单的 JSON 数据集，首先是一个数字，然后将几个数字放入数组中，最后将该数组放入对象中：
- en: '[PRE44]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: jsonlite has another important function called [`fromJSON()`](https://rdrr.io/pkg/jsonlite/man/fromJSON.xhtml).
    We don’t use it here because it performs automatic simplification (`simplifyVector
    = TRUE`). This often works well, particularly in simple cases, but we think you’re
    better off doing the rectangling yourself so you know exactly what’s happening
    and can more easily handle the most complicated nested structures.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: jsonlite 还有另一个重要的函数叫做 [`fromJSON()`](https://rdrr.io/pkg/jsonlite/man/fromJSON.xhtml)。我们这里没有使用它，因为它执行自动简化
    (`simplifyVector = TRUE`)。这在简单情况下通常效果良好，但我们认为最好自己进行矩形化，这样您就可以准确知道发生了什么，并且更容易处理最复杂的嵌套结构。
- en: Starting the Rectangling Process
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始矩形化过程
- en: 'In most cases, JSON files contain a single top-level array, because they’re
    designed to provide data about multiple “things,” e.g., multiple pages, multiple
    records, or multiple results. In this case, you’ll start your rectangling with
    `tibble(json)` so that each element becomes a row:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，JSON 文件包含一个顶级数组，因为它们旨在提供关于多个“事物”的数据，例如多个页面、多个记录或多个结果。在这种情况下，您将以 `tibble(json)`
    开始您的矩形化，以便每个元素成为一行：
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In rarer cases, the JSON file consists of a single top-level JSON object, representing
    one “thing.” In this case, you’ll need to kick off the rectangling process by
    wrapping it in a list, before you put it in a tibble:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在更罕见的情况下，JSON 文件由单个顶级 JSON 对象组成，代表一个“事物”。在这种情况下，您需要通过将其包装在列表中来启动矩形化过程，然后将其放入一个
    tibble 中：
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Alternatively, you can reach inside the parsed JSON and start with the bit
    that you actually care about:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以深入解析的 JSON 并从您实际关心的部分开始：
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Exercises
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Rectangle the following `df_col` and `df_row`. They represent the two ways of
    encoding a data frame in JSON.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩形化以下 `df_col` 和 `df_row`。它们代表了在 JSON 中编码数据框的两种方式。
- en: '[PRE48]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned what lists are, how you can generate them from
    JSON files, and how to turn them into rectangular data frames. Surprisingly we
    need only two new functions: [`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)
    to put list elements into rows and [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)
    to put list elements into columns. It doesn’t matter how deeply nested the list
    column is; all you need to do is repeatedly call these two functions.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了什么是列表，如何从 JSON 文件生成列表，以及如何将它们转换为矩形数据框。令人惊讶的是，我们只需要两个新函数：[`unnest_longer()`](https://tidyr.tidyverse.org/reference/unnest_longer.xhtml)
    将列表元素放入行中，以及 [`unnest_wider()`](https://tidyr.tidyverse.org/reference/unnest_wider.xhtml)
    将列表元素放入列中。不管列表列嵌套多深，您只需重复调用这两个函数即可。
- en: 'JSON is the most common data format returned by web APIs. What happens if the
    website doesn’t have an API but you can see data you want on the website? That’s
    the topic of the next chapter: web scraping, extracting data from HTML web pages.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 是 Web API 返回的最常见数据格式。如果网站没有 API，但您可以在网站上看到所需数据，会发生什么？这是下一章节的主题：Web 抓取，从
    HTML 网页中提取数据。
- en: ^([1](ch23.xhtml#idm44771276868272-marker)) This is an RStudio feature.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch23.xhtml#idm44771276868272-marker)) 这是一个 RStudio 的特性。
