- en: 6 Mapping value types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 映射值类型
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Mapping basic properties
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射基本属性
- en: Mapping embeddable components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射可嵌入组件
- en: Controlling mapping between Java and SQL types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制 Java 和 SQL 类型之间的映射
- en: 'After spending the previous chapter almost exclusively on entities and their
    class- and identity-mapping options, we’ll now focus on value types in their various
    forms. Value types are frequently encountered in classes under development. We’ll
    separate value types into two categories: basic value-typed classes that come
    with the JDK, such as `String`, `Date`, primitives, and their wrappers; and developer-defined
    value-type classes, such as `Address` and `MonetaryAmount` in CaveatEmptor.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章几乎完全专注于实体及其类和身份映射选项之后，我们现在将关注各种形式的价值类型。在开发中的类中经常遇到值类型。我们将值类型分为两类：随 JDK 一起提供的基值类型类，如
    `String`、`Date`、原始类型及其包装器；以及开发者定义的值类型类，如 CaveatEmptor 中的 `Address` 和 `MonetaryAmount`。
- en: 'In this chapter, we’ll first map persistent properties with JDK types and discuss
    the basic mapping annotations. We’ll look at how you can work with various aspects
    of properties: overriding defaults, customizing access, and generated values.
    We’ll also see how SQL is used with derived properties and transformed column
    values. We’ll work with basic properties, temporal properties, and mapping enumerations.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先将使用 JDK 类型映射持久化属性，并讨论基本映射注解。我们将查看如何处理属性的各个方面：覆盖默认值、自定义访问和生成值。我们还将看到
    SQL 如何与派生属性和转换列值一起使用。我们将处理基本属性、时间属性和枚举映射。
- en: We’ll then examine custom value-type classes and map them as embeddable components.
    We’ll look at how classes relate to the database schema and we’ll make the classes
    embeddable while allowing for overriding embedded attributes. We’ll complete our
    look at embeddable components by mapping nested components. Finally, we’ll analyze
    how you can customize the loading and storing of property values at a lower level
    with flexible JPA converters, which are standardized extension points of every
    JPA provider.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将检查自定义值类型类并将它们作为可嵌入组件进行映射。我们将查看类如何与数据库模式相关联，并使类可嵌入，同时允许覆盖嵌入属性。通过映射嵌套组件，我们将完成对可嵌入组件的考察。最后，我们将分析如何使用灵活的
    JPA 转换器在较低级别自定义属性值的加载和存储，这些转换器是每个 JPA 提供商的标准扩展点。
- en: Major new features in JPA 2
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 2 中的主要新功能
- en: JPA 2.2 supports the Java 8 Date and Time API. There is no longer any need to
    use additional mapping annotations, such as `@Temporal`, that formerly were needed
    to annotate fields of type `java.util.Date`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 2.2 支持 Java 8 日期和时间 API。不再需要使用如 `@Temporal` 这样的额外映射注解，以前需要用这些注解来标注 `java.util.Date`
    类型的字段。
- en: 6.1 Mapping basic properties
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 映射基本属性
- en: Mapping is at the heart of the ORM technique. It makes the connection between
    the object-oriented world and the relational world. When we map a persistent class,
    whether it’s an entity or an embeddable type (more about these in section 6.2),
    all of its properties are considered persistent by default.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是 ORM 技术的核心。它连接了面向对象世界和关系世界。当我们映射一个持久化类，无论是实体还是可嵌入类型（更多内容请参考第 6.2 节），所有属性默认都被视为持久化。
- en: 'These are the default JPA rules for properties of persistent classes:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是持久化类属性的默认 JPA 规则：
- en: If the property is a primitive or a primitive wrapper, or of type `String`,
    `BigInteger`, `BigDecimal`, `java.time.LocalDateTime`, `java.time.LocalDate`,
    `java.time .LocalDate`, `java.util.Date`, `java.util.Calendar`, `java.sql.Date`,
    `java.sql .Time`, `java.sql.Timestamp`, `byte[]`, `Byte[]`, `char[]`, or `Character[]`,
    it’s automatically persistent. Hibernate or Spring Data JPA using Hibernate loads
    and stores the value of the property in a column with an appropriate SQL type
    and the same name as the property.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性是原始类型或原始类型包装器，或为 `String`、`BigInteger`、`BigDecimal`、`java.time.LocalDateTime`、`java.time.LocalDate`、`java.time.LocalTime`、`java.util.Date`、`java.util.Calendar`、`java.sql.Date`、`java.sql.Time`、`java.sql.Timestamp`、`byte[]`、`Byte[]`、`char[]`
    或 `Character[]` 类型，则它自动持久化。Hibernate 或使用 Hibernate 的 Spring Data JPA 会将属性的值加载和存储在具有适当
    SQL 类型且与属性同名的列中。
- en: Otherwise, if we annotate the class of the property as `@Embeddable`, or we
    map the property itself as `@Embedded`, the property is mapped as an embedded
    component of the owning class. We’ll analyze the embedding of components later
    in this chapter, when we look at the `Address` and `MonetaryAmount` embeddable
    classes of CaveatEmptor.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果我们将属性的类标注为 `@Embeddable`，或者将属性本身映射为 `@Embedded`，则该属性将被映射为拥有类的嵌入组件。我们将在本章后面分析组件的嵌入，当我们查看
    CaveatEmptor 的 `Address` 和 `MonetaryAmount` 嵌入类时。
- en: Otherwise, if the type of the property is `java.io.Serializable`, its value
    is stored in its serialized form. This may raise compatibility problems (we might
    have stored the information using one class format and would like to retrieve
    it later using another class format) and performance problems (the serialization/
    deserialization operations are costly). We should always map Java classes instead
    of storing a series of bytes in the database. Maintaining a database with this
    binary information when the application may be gone in a few years will mean that
    the classes that the serialized version maps to are no longer available.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果属性的类型是 `java.io.Serializable`，其值将存储在其序列化形式中。这可能会引起兼容性问题（我们可能使用一种类格式存储信息，而希望稍后使用另一种类格式检索它）以及性能问题（序列化/反序列化操作成本高昂）。我们应该始终映射
    Java 类，而不是在数据库中存储一系列字节。当应用程序可能在几年后消失时，维护包含这种二进制信息的数据库意味着映射到序列化版本的类将不再可用。
- en: Otherwise, an exception will be thrown on startup, complaining that the type
    of the property isn’t understood.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，启动时将抛出异常，抱怨属性的类型无法理解。
- en: This *configuration by exception* approach means we don’t have to annotate a
    property to make it persistent; we only have to configure the mapping in exceptional
    cases. Several annotations are available in JPA to customize and control basic
    property mappings.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 *异常配置* 方法意味着我们不必注解属性来使其持久化；我们只需在异常情况下配置映射即可。JPA 中有多个注解可用于自定义和控制基本属性映射。
- en: 6.1.1 Overriding basic property defaults
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.1 覆盖基本属性默认值
- en: We might not want all the properties of an entity class to be persistent. So
    which information ought to be persisted and which not? For example, although it
    makes sense to have a persistent `Item#initialPrice` property, an `Item#totalPriceIncludingTax`
    property shouldn’t be persisted in the database if we only compute and use its
    value at runtime. To exclude a property, mark the field or the getter method of
    the property with the annotation `@javax.persistence.Transient` or use the Java
    `transient` keyword. The `transient` keyword excludes fields both for Java serialization
    and for persistence, as it is also recognized by JPA providers. The `@javax.persistence.Transient`
    annotation will only exclude the field from being persisted.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能不希望实体类的所有属性都持久化。那么哪些信息应该持久化，哪些不应该？例如，虽然有一个持久的 `Item#initialPrice` 属性是有意义的，但如果我们在运行时仅计算和使用其值，则
    `Item#totalPriceIncludingTax` 属性不应该在数据库中持久化。要排除一个属性，请使用注解 `@javax.persistence.Transient`
    标记属性的字段或 getter 方法，或者使用 Java 的 `transient` 关键字。`transient` 关键字既排除 Java 序列化，也排除持久化，因为它也被
    JPA 提供者识别。`@javax.persistence.Transient` 注解将仅排除字段不被持久化。
- en: 'To decide whether a property should be persistent or not, ask yourself these
    questions: Is this a basic attribute that shapes the instance? Do we need it from
    the very beginning, or will we calculate it based on some other properties? Does
    it make sense to rebuild the information after some time, or will the information
    no longer be significant? Is it sensitive information that we would rather avoid
    persisting so it can’t later be revealed (such as a password in clear)? Is it
    information that does not have significance in some other environment (such as
    a local IP address that is meaningless in another network)?'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要决定一个属性是否应该持久化，请自问以下问题：这是一个塑造实例的基本属性吗？我们是否从一开始就需要它，还是将基于其他属性计算它？在一段时间后重建信息有意义吗，或者信息将不再重要？这是敏感信息，我们宁愿避免持久化以防止稍后泄露（例如明文密码）吗？这是在其他环境中没有意义的信息（例如在另一个网络中无意义的本地
    IP 地址）吗？
- en: We’ll come back to the placement of the annotation on fields or getter methods
    in a moment. First, let’s assume, as we have before, that Hibernate or Spring
    Data JPA using Hibernate will access fields directly because `@Id` has been placed
    on these fields. Therefore, all other JPA and Hibernate mapping annotations are
    also on fields.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会回到在字段或getter方法上放置注释的位置。首先，让我们假设，就像我们之前做的那样，Hibernate或使用Hibernate的Spring
    Data JPA将直接访问字段，因为这些字段上已经放置了`@Id`。因此，所有其他JPA和Hibernate映射注释也都在字段上。
- en: Note To execute the examples from the source code, you’ll first need to run
    the Ch06.sql script. The source code can be found in the `mapping-value-types`
    folder.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要执行源代码中的示例，您首先需要运行Ch06.sql脚本。源代码可以在`mapping-value-types`文件夹中找到。
- en: 'In our CaveatEmptor application, our goal is to not only take care of the persistence
    logic from the program, but also to build flexible and easy-to-change code. If
    we do not want to rely on property mapping defaults, we can apply the `@Basic`
    annotation to a particular property, such as the `initialPrice` of an `Item`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的CaveatEmptor应用程序中，我们的目标不仅是处理程序中的持久化逻辑，还要构建灵活且易于更改的代码。如果我们不想依赖于属性映射默认值，我们可以将`@Basic`注释应用于特定属性，例如`Item`的`initialPrice`：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This annotation doesn’t provide many alternatives. It only has two parameters:
    `optional` and `fetch`. We’ll talk the `fetch` option when we explore optimization
    strategies in section 12.1\. The option shown here, `optional`, marks the property
    as not optional at the Java object level.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注释没有提供很多替代方案。它只有两个参数：`optional`和`fetch`。当我们探索第12.1节中的优化策略时，我们将讨论`fetch`选项。这里显示的选项`optional`将属性标记为在Java对象级别上不是可选的。
- en: By default, all persistent properties are nullable and optional, which would
    mean an `Item` could have an unknown `initialPrice`. Mapping the `initialPrice`
    property as non-optional makes sense if you want a `NOT NULL` constraint on the
    `INITIALPRICE` column in the SQL schema. The generated SQL schema will automatically
    include a `NOT` `NULL` constraint for non-optional properties.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有持久化属性都是可空的和可选的，这意味着`Item`可能有一个未知的`initialPrice`。如果要在SQL模式中的`INITIALPRICE`列上有一个`NOT
    NULL`约束，将`initialPrice`属性映射为非可选的就有意义。生成的SQL模式将自动为非可选属性包含一个`NOT NULL`约束。
- en: Now if the application attempts to store an `Item` without setting a value on
    the `initialPrice` field, an exception will be thrown before an SQL statement
    is sent to the database. A value is required for `initialPrice` in order to perform
    an `INSERT` or `UPDATE`. If we do not mark the `initialPrice` property as optional
    and try to save a `NULL`, the database will reject the SQL statement, and a constraint-violation
    exception will be thrown.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果应用程序尝试存储一个未在`initialPrice`字段上设置值的`Item`，在将SQL语句发送到数据库之前，将会抛出一个异常。为了执行`INSERT`或`UPDATE`，`initialPrice`字段需要一个值。如果我们没有将`initialPrice`属性标记为可选，并尝试保存一个`NULL`值，数据库将拒绝SQL语句，并抛出一个约束违反异常。
- en: 'Instead of `@Basic`, we can use the `@Column` annotation to declare nullability:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`@Basic`之外，我们还可以使用`@Column`注释来声明可空性：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We’ve now demonstrated three ways to declare whether a property value is required:
    with the `@Basic` annotation, with the `@Column` annotation, and earlier with
    the Bean Validation `@NotNull` annotation (in section 3.3.2). All have the same
    effect on the JPA provider: a `null` check is performed when saving, and a `NOT`
    `NULL` constraint is generated in the database schema. We recommend using the
    Bean Validation `@NotNull` annotation so that you can manually validate an `Item`
    instance and have your user interface code in the presentation layer execute validation
    checks automatically. There isn’t much difference in the end result, but not hitting
    the database with a statement that fails is cleaner.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经展示了三种声明属性值是否必需的方法：使用`@Basic`注释、使用`@Column`注释，以及之前使用Bean Validation的`@NotNull`注释（在第3.3.2节中）。所有这些对JPA提供者都有相同的效果：在保存时执行`null`检查，并在数据库模式中生成`NOT
    NULL`约束。我们建议使用Bean Validation的`@NotNull`注释，这样您就可以手动验证`Item`实例，并让您的用户界面代码在表示层自动执行验证检查。最终结果没有太大差异，但避免使用失败的语句访问数据库会更干净。
- en: 'The `@Column` annotation can also override the mapping of the property name
    to the database column:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Column`注释也可以覆盖属性名到数据库列的映射：'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `@Column` annotation has a few other parameters, most of which control SQL-level
    details such as `catalog` and `schema` names. They’re rarely needed, and we only
    demonstrate them in this book when necessary.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Column` 注解有几个其他参数，其中大多数控制 SQL 级别的细节，例如 `catalog` 和 `schema` 名称。它们很少需要，我们仅在本书中在必要时演示它们。'
- en: Property annotations aren’t always on fields, and we may not want the JPA provider
    to access fields directly. Let’s look at customizing property access.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 属性注解不一定位于字段上，我们可能不希望 JPA 提供者直接访问字段。让我们看看如何自定义属性访问。
- en: 6.1.2 Customizing property access
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.2 自定义属性访问
- en: The persistence engine accesses the properties of a class either directly through
    fields or indirectly through getter and setter methods. We will try now to answer
    the question, “how should we access each persistent property?” An annotated entity
    inherits the default from the position of the mandatory `@Id` annotation. For
    example, if we declare `@Id` on a field, rather than using a getter method, all
    other mapping annotations for that entity are expected to be fields. Annotations
    are not supported on the setter methods.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化引擎通过字段直接或通过 getter 和 setter 方法间接访问类的属性。我们现在将尝试回答“我们应该如何访问每个持久属性？”的问题。注解实体从必需的
    `@Id` 注解的位置继承默认值。例如，如果我们在一个字段上声明 `@Id`，而不是使用 getter 方法，那么该实体的所有其他映射注解都应预期为字段。注解不支持在
    setter 方法上。
- en: The default access strategy isn’t only applicable to a single entity class.
    Any `@Embedded` class inherits the default or explicitly declared access strategy
    of its owning root entity class. We’ll cover embedded components later in this
    chapter. Furthermore, any `@MappedSuperclass` properties are accessed with the
    default or explicitly declared access strategy of the mapped entity class. Inheritance
    is the topic of chapter 7.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 默认访问策略不仅适用于单个实体类。任何 `@Embedded` 类都继承其拥有根实体类的默认或显式声明的访问策略。我们将在本章后面介绍嵌入式组件。此外，任何
    `@MappedSuperclass` 属性都使用默认或显式声明的访问策略来访问映射的实体类。继承是第7章的主题。
- en: The JPA specification offers the `@Access` annotation for overriding the default
    behavior, using the parameters `AccessType.FIELD` (access through fields) and
    `AccessType.PROPERTY` (access through getters). When you set `@Access` on the
    class or entity level, all properties of the class will be accessed according
    to the selected strategy. Any other mapping annotations, including the `@Id`,
    can be set on either fields or getter methods.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 规范提供了 `@Access` 注解来覆盖默认行为，使用参数 `AccessType.FIELD`（通过字段访问）和 `AccessType.PROPERTY`（通过
    getter）。当你在类或实体级别设置 `@Access` 时，类的所有属性都将根据所选策略进行访问。任何其他映射注解，包括 `@Id`，都可以设置在字段或
    getter 方法上。
- en: We can also use the `@Access` annotation to override the access strategy of
    individual properties, as in the following example. Note that the position of
    other mapping annotations, like `@Column`, doesn’t change—only how instances are
    accessed at runtime.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `@Access` 注解来覆盖单个属性的访问策略，如下例所示。请注意，其他映射注解（如 `@Column`）的位置没有改变——只有运行时实例的访问方式发生了变化。
- en: Listing 6.1 Overriding access strategy for the `name` property
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 覆盖 `name` 属性的访问策略
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Ⓐ The `Item` entity defaults to field access. The `@Id` is on the field.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `Item` 实体默认为字段访问。`@Id` 注解位于字段上。
- en: Ⓑ The `@Access(AccessType.PROPERTY)` setting on the `name` field switches this
    particular property to be accessed at runtime by the JPA provider through getter/setter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 在 `name` 字段上的 `@Access(AccessType.PROPERTY)` 设置将此特定属性切换为在运行时通过 getter/setter
    由 JPA 提供者访问。
- en: Ⓒ Hibernate or Spring Data JPA using Hibernate calls `getName()` and `setName()`
    when loading and storing items.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 使用 Hibernate 或 Spring Data JPA 的 Hibernate 在加载和存储项目时调用 `getName()` 和 `setName()`。
- en: 'Now turn it around: if the default (or explicit) access type of the entity
    were through property getter and setter methods, `@Access(AccessType.FIELD)` on
    a getter method would tell Hibernate or Spring Data JPA using Hibernate to access
    the field directly. All other mapping information would still have to be on the
    getter method, not the field.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在反过来：如果实体（默认或显式）的访问类型是通过属性 getter 和 setter 方法，则 getter 方法上的 `@Access(AccessType.FIELD)`
    将告诉 Hibernate 或使用 Hibernate 的 Spring Data JPA 直接访问字段。所有其他映射信息仍然必须位于 getter 方法上，而不是字段上。
- en: Some properties don’t map to a column. In particular, a derived property (like
    a calculated field) takes its value from an SQL expression.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性没有映射到列。特别是，派生属性（如计算字段）从 SQL 表达式中获取其值。
- en: 6.1.3 Using derived properties
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.3 使用派生属性
- en: We have now come to derived properties—properties resulting from some other
    properties. The value of a derived property is calculated at runtime by evaluating
    an SQL expression declared with the `@org.hibernate.annotations.Formula` annotation,
    as shown in the next listing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经来到了派生属性——由其他属性产生的属性。派生属性的值在运行时通过使用 `@org.hibernate.annotations.Formula`
    注解声明的 SQL 表达式进行计算，如下一列表所示。
- en: Listing 6.2 Two read-only derived properties
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.2 两个只读派生属性
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The SQL formulas are evaluated every time the `Item` entity is retrieved from
    the database and not at any other time, so the result can become outdated if other
    properties are modified. The properties never appear in an SQL `INSERT` or `UPDATE`,
    only in `SELECT`s. Evaluation occurs in the database; the SQL formula is embedded
    in the `SELECT` clause when loading the instance.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每次从数据库检索 `Item` 实体时都会评估 SQL 公式，而不是在其他任何时候，因此如果其他属性被修改，结果可能会过时。这些属性永远不会出现在 SQL
    `INSERT` 或 `UPDATE` 中，只出现在 `SELECT`s 中。评估发生在数据库中；SQL 公式在加载实例时嵌入到 `SELECT` 子句中。
- en: The SQL formulas may refer to columns of the database table, they can call specific
    database SQL functions, and they can even include SQL subselects. In the previous
    example, the `SUBSTR()` and `CONCAT()` functions are called.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 公式可以引用数据库表的列，它们可以调用特定的数据库 SQL 函数，甚至可以包括 SQL 子查询。在上一个示例中，调用了 `SUBSTR()` 和
    `CONCAT()` 函数。
- en: The SQL expression is passed to the underlying database as-is. Relying on vendor-specific
    operators or keywords may bind the mapping metadata to a particular database product.
    For example, the `CONCAT()` function in the preceding listing is specific to MySQL,
    so you should be aware that portability may be affected. Notice that unqualified
    column names refer to columns of the table of the class to which the derived property
    belongs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 表达式原样传递给底层数据库。依赖于特定数据库产品的特定运算符或关键字可能会将映射元数据绑定到特定的数据库产品。例如，前一个列表中的 `CONCAT()`
    函数是针对 MySQL 的，因此您应该意识到可移植性可能会受到影响。请注意，未指定列名引用的是派生属性所属的类表的列。
- en: Hibernate also supports a variation of formulas called *column transformers*,
    which allow you to write a custom SQL expression for reading *and* writing a property
    value. Let’s investigate this capability.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 还支持一种称为 *列转换器* 的公式变体，允许您为读取 *和* 写入属性值编写自定义 SQL 表达式。让我们调查这种功能。
- en: 6.1.4 Transforming column values
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.4 转换列值
- en: 'Let’s now deal with information that has different representations in the object-oriented
    system and the relational system. Suppose a database has a column called `IMPERIALWEIGHT`,
    storing the weight of an `Item` in pounds. The application, however, has the property
    `Item#metricWeight` in kilograms, so we would have to convert the value of the
    database column when reading a row from *and* writing it to the `ITEM` table.
    We can implement this with a Hibernate extension: the `@org.hibernate .annotations.ColumnTransformer`
    annotation.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来处理在面向对象系统和关系系统中具有不同表示的信息。假设一个数据库有一个名为 `IMPERIALWEIGHT` 的列，存储 `Item` 的重量（磅）。然而，应用程序有一个
    `Item#metricWeight` 属性，以千克为单位，因此我们必须在从 *读取* 和写入 `ITEM` 表时转换数据库列的值。我们可以通过 Hibernate
    扩展来实现这一点：`@org.hibernate.annotations.ColumnTransformer` 注解。
- en: Listing 6.3 Transforming column values with SQL expressions
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 使用 SQL 表达式转换列值
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When reading a row from the `ITEM` table, Hibernate or Spring Data JPA using
    Hibernate embeds the expression `IMPERIALWEIGHT` `/` `2.20462`, so the calculation
    occurs in the database, and the metric value is returned in the result to the
    application layer. For writing to the column, Hibernate or Spring Data JPA using
    Hibernate sets the metric value on the mandatory, single placeholder (the question
    mark), and the SQL expression calculates the actual value to be inserted or updated.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 `ITEM` 表中读取一行时，Hibernate 或使用 Hibernate 的 Spring Data JPA 会嵌入表达式 `IMPERIALWEIGHT`
    `/` `2.20462`，因此计算发生在数据库中，并且度量值作为结果返回到应用层。对于写入列，Hibernate 或使用 Hibernate 的 Spring
    Data JPA 设置度量值在强制性的单个占位符（问号）上，SQL 表达式计算要插入或更新的实际值。
- en: Hibernate also applies column converters in query restrictions. For example,
    the query in the following listing retrieves all items with a weight of 2 kilograms.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 还在查询限制中应用列转换器。例如，以下列表中的查询检索所有重量为 2 千克的项。
- en: Listing 6.4 Applying column converters in query restrictions
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 在查询限制中应用列转换器
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The actual SQL executed for this query contains the following restriction in
    the `WHERE` clause:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 实际执行此查询的 SQL 语句在 `WHERE` 子句中包含以下限制：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the database will probably not be able to rely on an index for this
    restriction; a full table scan would be performed because the weights for *all*
    `ITEM` rows have to be calculated to evaluate the restriction.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，数据库可能无法依赖于索引来执行此限制；将执行全表扫描，因为必须计算所有 `ITEM` 行的权重以评估限制。
- en: Another special kind of property relies on database-generated values.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种特殊的属性依赖于数据库生成的值。
- en: 6.1.5 Generated and default property values
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.5 生成和默认属性值
- en: The database sometimes generates a property value, and this usually happens
    when we insert a row for the first time. Examples of database-generated values
    are creation timestamps, a default price for an item, or a trigger that runs for
    every modification.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库有时会生成属性值，这通常发生在我们第一次插入行时。数据库生成的值的例子包括创建时间戳、项目的默认价格或每次修改时运行的触发器。
- en: Typically, Hibernate (or Spring Data JPA using Hibernate) applications need
    to refresh instances that contain properties for which the database generates
    values after saving. This means the application would have to make another round
    trip to the database to read the value after inserting or updating a row. Marking
    properties as generated, however, lets the application delegate this responsibility
    to Hibernate or Spring Data JPA using Hibernate. Essentially, whenever an SQL
    `INSERT` or `UPDATE` is issued for an entity that has declared generated properties,
    the SQL does a `SELECT` immediately afterward to retrieve the generated values.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Hibernate（或使用 Hibernate 的 Spring Data JPA）应用程序需要刷新包含数据库在保存后生成值的属性的实例。这意味着应用程序必须再次往返数据库以读取插入或更新行后的值。然而，将属性标记为生成值后，应用程序可以将此责任委托给
    Hibernate 或使用 Hibernate 的 Spring Data JPA。本质上，每当为声明了生成属性的实体发出 SQL `INSERT` 或 `UPDATE`
    语句时，SQL 会立即执行一个 `SELECT` 语句来检索生成的值。
- en: We use the `@org.hibernate.annotations.Generated` annotation to mark generated
    properties. For temporal properties, we use the `@CreationTimestamp` and `@UpdateTimestamp`
    annotations. The `@CreationTimestamp` annotation is used to mark the `createdOn`
    property. This tells Hibernate or Spring Data using Hibernate to generate the
    property value automatically. In this case, the value is set to the current date
    before the entity instance is inserted into the database. The other similar built-in
    annotation is `@UpdateTimestamp`, which generates the property value automatically
    when an entity instance is updated.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `@org.hibernate.annotations.Generated` 注解来标记生成属性。对于时间属性，我们使用 `@CreationTimestamp`
    和 `@UpdateTimestamp` 注解。`@CreationTimestamp` 注解用于标记 `createdOn` 属性。这告诉 Hibernate
    或使用 Hibernate 的 Spring Data JPA 自动生成属性值。在这种情况下，值在实体实例插入数据库之前设置为当前日期。另一个类似的内置注解是
    `@UpdateTimestamp`，它在实体实例更新时自动生成属性值。
- en: Listing 6.5 Database-generated property values
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.5 数据库生成的属性值
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Available settings for the `GenerationTime` enum are `ALWAYS` and `INSERT`.
    With `GenerationTime.ALWAYS`, Hibernate or Spring Data JPA using Hibernate refreshes
    the entity instance after every SQL `UPDATE` or `INSERT`. With `GenerationTime.INSERT`,
    the refreshing only occurs after an SQL `INSERT` to retrieve the default value
    provided by the database. We can also map the `initialPrice` property as not `insertable`.
    The `@ColumnDefault` annotation sets the default value of the column when Hibernate
    or Spring Data JPA using Hibernate exports and generates the SQL schema DDL.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerationTime` 枚举的可用设置是 `ALWAYS` 和 `INSERT`。使用 `GenerationTime.ALWAYS`，Hibernate
    或使用 Hibernate 的 Spring Data JPA 在每次 SQL `UPDATE` 或 `INSERT` 之后刷新实体实例。使用 `GenerationTime.INSERT`，刷新仅在
    SQL `INSERT` 之后发生，以检索数据库提供的默认值。我们还可以将 `initialPrice` 属性映射为不可插入的。`@ColumnDefault`
    注解设置列的默认值，当 Hibernate 或使用 Hibernate 的 Spring Data JPA 导出并生成 SQL 模式 DDL 时。'
- en: 'Timestamps are frequently automatically generated either by the database, as
    in the previous example, or by the application. As long as we are using JPA 2.2
    and the Java 8 `LocalDate`, `LocalDateTime,` and `LocalTime` classes, we don’t
    need to use the `@Temporal` annotation. The enumerated Java 8 classes from the
    `java.time` package include the temporal precision by themselves: the date, the
    date and the time, or only the time. Let’s take a look at the uses of the `@Temporal`
    annotation that you may still encounter.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳通常由数据库自动生成，如前例所示，或者由应用程序生成。只要我们使用 JPA 2.2 和 Java 8 的 `LocalDate`、`LocalDateTime`
    和 `LocalTime` 类，我们就不需要使用 `@Temporal` 注解。`java.time` 包中的枚举 Java 8 类本身就包含时间精度：日期、日期和时间，或者仅时间。让我们看看您可能仍然会遇到的使用
    `@Temporal` 注解的情况。
- en: 6.1.6 The @Temporal annotation
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.6 @Temporal 注解
- en: The JPA specification allows you to annotate temporal properties with `@Temporal`
    to declare the accuracy of the SQL data type of the mapped column. The Java temporal
    types before Java 8 are `java.util.Date`, `java.util.Calendar`, `java.sql.Date`,
    `java .sql.Time`, and `java.sql.Timestamp`. The following listing provides an
    example of using the `@Temporal` annotation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 规范允许您使用 `@Temporal` 注解来注解时间属性，以声明映射列的 SQL 数据类型的精度。Java 8 之前的 Java 时间类型包括
    `java.util.Date`、`java.util.Calendar`、`java.sql.Date`、`java.sql.Time` 和 `java.sql.Timestamp`。以下列表提供了一个使用
    `@Temporal` 注解的示例。
- en: Listing 6.6 Property of a temporal type that must be annotated with `@Temporal`
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6 必须使用 `@Temporal` 注解的时间类型属性
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Available `TemporalType` options are `DATE`, `TIME`, and `TIMESTAMP`, establishing
    which part of the temporal value should be stored in the database. The default
    is `TemporalType.TIMESTAMP` when no `@Temporal` annotation is present.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的 `TemporalType` 选项是 `DATE`、`TIME` 和 `TIMESTAMP`，确定时间值应存储在数据库中的哪一部分。如果没有 `@Temporal`
    注解，默认为 `TemporalType.TIMESTAMP`。
- en: Another special property type is represented by the enumerations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种特殊属性类型由枚举表示。
- en: 6.1.7 Mapping enumerations
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1.7 映射枚举
- en: 'An *enumeration type* is a common Java idiom where a class has a constant (small)
    number of immutable instances. In CaveatEmptor, for example, we can apply this
    to auctions having a limited number of types:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*枚举类型* 是一种常见的 Java 习惯用法，其中类具有一个（小量）不可变的实例常量。例如，在 CaveatEmptor 中，我们可以将此应用于具有有限类型的拍卖：'
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can now set the appropriate `auctionType` on each `Item`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以为每个 `Item` 设置适当的 `auctionType`：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Without the `@Enumerated` annotation, Hibernate or Spring Data JPA using Hibernate
    would store the `ORDINAL` position of the value. That is, it would store `1` for
    `HIGHEST_BID`, `2` for `LOWEST_BID`, and `3` for `FIXED_PRICE`. This is a brittle
    default; if you make changes to the `AuctionType` enum and add a new instance,
    existing values may no longer map to the same position and break the application.
    The `EnumType.STRING` option is, therefore, a better choice; Hibernate or Spring
    Data JPA using Hibernate can store the label of the enum value as is.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用 `@Enumerated` 注解，Hibernate 或使用 Hibernate 的 Spring Data JPA 会存储值的 `ORDINAL`
    位置。也就是说，它会为 `HIGHEST_BID` 存储 `1`，为 `LOWEST_BID` 存储 `2`，为 `FIXED_PRICE` 存储 `3`。这是一个脆弱的默认值；如果您更改
    `AuctionType` 枚举并添加一个新实例，现有值可能不再映射到相同的位置并破坏应用程序。因此，`EnumType.STRING` 选项是一个更好的选择；使用
    Hibernate 的 Hibernate 或 Spring Data JPA 可以按原样存储枚举值的标签。
- en: This completes our tour of basic properties and their mapping options. So far
    we have looked at the properties of JDK-supplied types such as `String`, `Date`,
    and `BigDecimal`. The domain model also has custom value-typed classes—those with
    a composition association in the UML diagram.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对基本属性及其映射选项的浏览。到目前为止，我们已经看到了 JDK 提供的类型（如 `String`、`Date` 和 `BigDecimal`）的属性。领域模型还有自定义值类型类——那些在
    UML 图中有组合关联的类。
- en: 6.2 Mapping embeddable components
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 映射可嵌入组件
- en: The mapped classes of our domain model have all been entity classes so far,
    each with its own lifecycle and identity. The `User` class, however, has a special
    kind of association with the `Address` class, as shown in figure 6.1.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们领域模型中的映射类到目前为止都是实体类，每个都有自己的生命周期和标识。然而，`User` 类与 `Address` 类有一种特殊的关联方式，如图 6.1
    所示。
- en: '![](../../OEBPS/Images/CH06_F01_Tudose2.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F01_Tudose2.png)'
- en: Figure 6.1 Composition of `User` and `Address`
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 `User` 和 `Address` 的组合
- en: In object-modeling terms, this association is a kind of *aggregation*—a *part-of*
    relationship. An aggregation is a form of association, but it has some additional
    semantics concerning the lifecycle of objects. In this case, we have an even stronger
    form, *composition*, where the lifecycle of the part is fully dependent on the
    lifecycle of the whole. An `Address` object cannot exist in the absence of the
    `User` object, so a composed class in UML, such as `Address`, is often a candidate
    value type for the object/relational mapping.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象建模术语中，这种关联是一种 *聚合*——一种 *部分* 关系。聚合是一种关联形式，但它有关对象生命周期的某些附加语义。在这种情况下，我们有一种更强的形式，*组合*，其中部分的生命周期完全依赖于整体的生命周期。`Address`
    对象不能在没有 `User` 对象的情况下存在，因此 UML 中的组合类，如 `Address`，通常是对象/关系映射的候选值类型。
- en: 6.2.1 The database schema
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 数据库架构
- en: We can map such a composition relationship with `Address` as a value type (with
    the same semantics as `String` or `BigDecimal`) and with `User` as an entity.
    The targeted SQL schema is shown in figure 6.2.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `Address` 作为值类型（与 `String` 或 `BigDecimal` 相同的语义）和 `User` 作为实体来映射这种组合关系。目标
    SQL 架构如图 6.2 所示。
- en: '![](../../OEBPS/Images/CH06_F02_Tudose2.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH06_F02_Tudose2.png)'
- en: Figure 6.2 The columns of the components are embedded in the entity table.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 组件的列嵌入在实体表中。
- en: There is only one mapped table, `USERS`, for the `User` entity. This table embeds
    all the details of the components, where a single row holds a particular `User`
    and their `homeAddress` and `billingAddress`. If another entity has a reference
    to an `Address`—such as `Shipment#deliveryAddress`—the `SHIPMENT` table will also
    have all the columns needed to store an `Address`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `User` 实体，只有一个映射表 `USERS`。此表嵌入所有组件的详细信息，其中一行包含特定的 `User` 以及他们的 `homeAddress`
    和 `billingAddress`。如果另一个实体引用了 `Address`（例如 `Shipment#deliveryAddress`），则 `SHIPMENT`
    表也将包含存储 `Address` 所需的所有列。
- en: 'This schema reflects value type semantics: a particular `Address` can’t be
    shared; it doesn’t have its own identity. Its primary key is the mapped database
    identifier of the owning entity. An embedded component has a dependent lifecycle:
    when the owning entity instance is saved, the component instance is saved. When
    the owning entity instance is deleted, the component instance is deleted. No special
    SQL needs to be executed for this; all the data is in a single row.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此架构反映了值类型语义：特定的 `Address` 无法共享；它没有自己的标识。其主键是拥有实体的映射数据库标识符。嵌入组件具有依赖的生命周期：当拥有实体的实例被保存时，组件实例也被保存。当拥有实体的实例被删除时，组件实例也被删除。为此不需要执行特殊的
    SQL；所有数据都在一行中。
- en: Having “more classes than tables” is how fine-grained domain models are supported.
    Let’s write the classes and mappings for this structure.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: “类多于表”是支持细粒度领域模型的方式。让我们为这个结构编写类和映射。
- en: 6.2.2 Making classes embeddable
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 使类可嵌入
- en: 'Java has no concept of composition—a class or property can’t be marked as a
    component. The only difference between a component and an entity is the database
    identifier: a component class has no individual identity, so the component class
    requires no identifier property or identifier mapping. It’s a simple POJO, as
    in the following listing.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Java 没有组合的概念——一个类或属性不能被标记为组件。组件和实体之间的唯一区别是数据库标识符：组件类没有单独的标识，因此组件类不需要标识符属性或标识符映射。它是一个简单的
    POJO，如下所示。
- en: 'Listing 6.7 `Address` class: An embeddable component'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7 `Address` 类：一个可嵌入的组件
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Ⓐ Instead of `@Entity`, this component POJO is marked with `@Embeddable`. It
    has no identifier property.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 与 `@Entity` 不同，这个组件 POJO 被标记为 `@Embeddable`。它没有标识符属性。
- en: Ⓑ The `@NotNull` annotation is ignored by the DDL generation.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `@NotNull` 注解在 DDL 生成中被忽略。
- en: Ⓒ `@Column(nullable=false)` is used for DDL generation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 使用 `@Column(nullable=false)` 用于 DDL 生成。
- en: Ⓓ The length argument of the `@Column` annotation will override the default
    generation of a column as `VARCHAR(255)`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ `@Column` 注解的长度参数将覆盖默认的列生成，作为 `VARCHAR(255)`。
- en: Ⓔ The type of the `city` column will by default be `VARCHAR(255)`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ `city` 列的默认类型将是 `VARCHAR(255)`。
- en: Ⓕ Hibernate or Spring Data JPA using Hibernate call this no-argument constructor
    to create an instance and then populate the fields directly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 使用 Hibernate 或 Spring Data JPA 的 Hibernate 调用这个无参数构造函数来创建实例，然后直接填充字段。
- en: Ⓖ We can have additional (public) constructors for convenience.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 为了方便，我们可以有额外的（公共）构造函数。
- en: In the preceding listing the properties of the embeddable class are all persistent
    by default, just like the properties of a persistent entity class. The property
    mappings can be configured with the same annotations, such as `@Column` or `@Basic`.
    The properties of the `Address` class map to the columns `STREET`, `ZIPCODE`,
    and `CITY,` and they are constrained with `NOT NULL`. That’s the entire mapping.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，嵌入类的属性默认都是持久的，就像持久实体类的属性一样。可以使用相同的注解配置属性映射，例如`@Column`或`@Basic`。`Address`类的属性映射到`STREET`、`ZIPCODE`和`CITY`列，并且它们被约束为`NOT
    NULL`。这就是整个映射。
- en: 'Problem: Hibernate Validator doesn’t generate `NOT` `NULL` constraints'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：Hibernate Validator不会生成`NOT NULL`约束
- en: 'At the time of writing, an open flaw remains with Hibernate Validator: Hibernate
    won’t map `@NotNull` constraints on embeddable component properties to `NOT NULL`
    constraints when generating the database schema. Hibernate will only use `@NotNull`
    on the components’ properties at runtime for Bean Validation. We have to map the
    property with `@Column(nullable` `=` `false)` to generate the constraint in the
    schema. The Hibernate bug database is tracking this problem as HVAL-3 (see [http://mng.bz/lR0R](http://mng.bz/lR0R)).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Hibernate Validator仍然存在一个开放缺陷：当生成数据库模式时，Hibernate不会将`@NotNull`约束映射到`NOT
    NULL`约束。Hibernate仅在运行时使用`@NotNull`对组件属性进行Bean Validation。我们必须使用`@Column(nullable
    = false)`映射属性以在模式中生成约束。Hibernate缺陷数据库正在跟踪此问题，编号为HVAL-3（见[http://mng.bz/lR0R](http://mng.bz/lR0R)）。
- en: There’s nothing special about the `User` entity.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`实体没有特别之处。'
- en: Listing 6.8 `User` class containing a reference to an `Address`
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.8 包含对`Address`引用的`User`类
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Ⓐ The `Address` is `@Embeddable` so no annotation is needed here.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `Address`是`@Embeddable`，因此这里不需要注解。
- en: In the preceding listing, Hibernate or Spring Data using Hibernate detects that
    the `Address` class is annotated with `@Embeddable`; the `STREET`, `ZIPCODE`,
    and `CITY` columns are mapped on the `USERS` table, the owning entity’s table.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，Hibernate或使用Hibernate的Spring Data检测到`Address`类被注解为`@Embeddable`；`STREET`、`ZIPCODE`和`CITY`列映射到`USERS`表，即拥有实体的表。
- en: 'When we talked about property access earlier in this chapter, we mentioned
    that embeddable components inherit their access strategy from their owning entity.
    This means Hibernate or Spring Data using Hibernate will access the properties
    of the `Address` class with the same strategy as for `User` properties. This inheritance
    also affects the placement of mapping annotations in embeddable component classes.
    The rules are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章前面讨论属性访问时，我们提到可嵌入组件从其所属实体继承其访问策略。这意味着Hibernate或使用Hibernate的Spring Data将以与`User`属性相同的策略访问`Address`类的属性。这种继承也影响了可嵌入组件类中映射注解的位置。规则如下：
- en: If the owning `@Entity` of an embedded component is mapped with field access,
    either implicitly with `@Id` on a field or explicitly with `@Access(AccessType
    .FIELD)` on the class, all mapping annotations of the embedded component class
    are expected on fields of the component class. Annotations are expected on the
    fields of the `Address` class, and the fields are directly read and written at
    runtime. Getter and setter methods on `Address` are optional.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果嵌入组件的拥有`@Entity`使用字段访问进行映射，无论是通过字段上的`@Id`隐式映射还是通过类上的`@Access(AccessType.FIELD)`显式映射，都期望嵌入组件类的所有映射注解位于组件类的字段上。期望在`Address`类的字段上使用注解，并且字段在运行时直接读取和写入。`Address`上的getter和setter方法可选。
- en: If the owning `@Entity` of an embedded component is mapped with property access,
    either implicitly with `@Id` on a getter method or explicitly with `@Access(AccessType.PROPERTY)`
    on the class, all mapping annotations of the embedded component class are expected
    on getter methods of the component class. Values are read and written by calling
    getter and setter methods on the embeddable component class.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果嵌入组件的拥有`@Entity`使用属性访问进行映射，无论是通过getter方法上的`@Id`隐式映射还是通过类上的`@Access(AccessType.PROPERTY)`显式映射，都期望嵌入组件类的所有映射注解位于组件类的getter方法上。值通过调用嵌入组件类上的getter和setter方法进行读取和写入。
- en: If the embedded property of the owning entity class—`User#homeAddress` in listing
    6.8—is marked with `@Access(AccessType.FIELD)`, annotations are expected on the
    fields of the `Address` class, and fields are accessed at runtime.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果拥有实体类的嵌入属性（如列表6.8中的`User#homeAddress`）被标记为`@Access(AccessType.FIELD)`，则预期在`Address`类的字段上使用注解，并且字段在运行时被访问。
- en: If the embedded property of the owning entity class—`User#homeAddress` in listing
    6.8—is marked with `@Access(AccessType.PROPERTY)`, annotations are expected on
    getter methods of the `Address` class, and access is made using getter and setter
    methods at runtime.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果拥有实体类的嵌入属性——列表6.8中的`User#homeAddress`——被标记为`@Access(AccessType.PROPERTY)`，则期望在`Address`类的getter方法上有注解，并且运行时使用getter和setter方法进行访问。
- en: If `@Access` annotates the embeddable class itself, the selected strategy will
    be used for reading mapping annotations on the embeddable class and runtime access.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`@Access`注解了可嵌入的类本身，所选策略将被用于读取嵌入类上的映射注解和运行时访问。
- en: Let’s now compare field-based and property-based access. Why should you use
    one or the other?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在比较基于字段和基于属性的访问。为什么你应该使用其中一个？
- en: '*Field-based access*—When you use field-based access, you can omit getter methods
    for the fields that should not be exposed. Also, fields are declared on a single
    line, while accessor methods are spread out on multiple lines, so field-based
    access will make the code more readable.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于字段的访问*——当你使用基于字段的访问时，你可以省略不应公开的字段的getter方法。此外，字段在单行上声明，而访问器方法分散在多行上，因此基于字段的访问会使代码更易读。'
- en: '*Property-based access*—Accessor methods may execute additional logic. If this
    is what you want to happen when persisting an object, you can use property-based
    access. If the persistence would like to avoid these additional actions, you can
    use field-based access.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基于属性的访问*——访问器方法可以执行额外的逻辑。如果你希望在持久化对象时发生这种情况，你可以使用基于属性的访问。如果持久化想要避免这些额外操作，你可以使用基于字段的访问。'
- en: 'There’s one more thing to remember: there’s no elegant way to represent a `null`
    reference to an `Address`. Consider what would happen if the columns `STREET`,
    `ZIPCODE`, and `CITY` were nullable. If you load a `User` without any address
    information, what should be returned by `someUser.getHomeAddress()`? A `null`
    would be returned in this case. Hibernate or Spring Data using Hibernate also
    stores a `null` embedded property as `NULL` values in all mapped columns of the
    component. Consequently, if you store a `User` with an “empty” `Address` (an `Address`
    instance exists, but all its properties are `null`), no `Address` instance will
    be returned when loading the `User`. This can be counterintuitive; you probably
    shouldn’t have nullable columns anyway, and avoid ternary logic, as you will most
    probably want your user to have a real address.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事要记住：没有优雅的方式来表示对`Address`的`null`引用。考虑如果`STREET`、`ZIPCODE`和`CITY`列是可空的会发生什么。如果你加载一个没有任何地址信息的`User`，`someUser.getHomeAddress()`应该返回什么？在这种情况下，将返回`null`。Hibernate或使用Hibernate的Spring
    Data也将`null`嵌入属性作为组件映射的所有列中的`NULL`值存储。因此，如果你存储一个具有“空”`Address`（`Address`实例存在，但所有属性都是`null`）的`User`，在加载`User`时将不会返回`Address`实例。这可能是不直观的；你可能根本不应该有可空列，并避免三重逻辑，因为你很可能希望你的用户有一个实际的地址。
- en: We should override the `equals()` and `hashCode()` methods of `Address` to compare
    instances by value. However, this isn’t critically important as long as we don’t
    have to compare instances, such as by putting them in a `HashSet`. We’ll discuss
    this problem in the context of collections in section 8.2.1.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该重写`Address`类的`equals()`和`hashCode()`方法，通过值来比较实例。然而，只要我们不需要比较实例，例如将它们放入`HashSet`中，这并不是至关重要的事情。我们将在第8.2.1节中讨论这个问题的集合上下文。
- en: 'In a realistic scenario, a user would probably have separate addresses for
    different purposes. Figure 6.1 showed an additional composition relationship between
    `User` and `Address`: the `billingAddress`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个现实场景中，用户可能为不同的目的拥有不同的地址。图6.1展示了`User`和`Address`之间的额外组合关系：`billingAddress`。
- en: 6.2.3 Overriding embedded attributes
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 重写嵌入属性
- en: 'The `billingAddress` is another embedded component property of the `User` class
    that we’ll need to use, so another `Address` has to be stored in the `USERS` table.
    This creates a mapping conflict: so far, we only have `STREET`, `ZIPCODE`, and
    `CITY` columns in the schema to store one `Address`.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`billingAddress`是`User`类中另一个需要使用的嵌入组件属性，因此必须在`USERS`表中存储另一个`Address`。这创建了一个映射冲突：到目前为止，我们只有`STREET`、`ZIPCODE`和`CITY`列在模式中存储一个`Address`。'
- en: We’ll need additional columns to store another `Address` for each `USERS` row.
    When we map the `billingAddress`, we can override the column names.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要额外的列来存储每个`USERS`行上的另一个`Address`。当我们映射`billingAddress`时，我们可以重写列名。
- en: Listing 6.9 Overriding the column names
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.9 重写列名
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Ⓐ The `billingAddress` field is marked as embedded. The `@Embedded` annotation
    actually isn’t necessary. You can mark either the component class or the property
    in the owning entity class (using both doesn’t hurt but it offers no advantage).
    The `@Embedded` annotation is useful if you want to map a third-party component
    class without a source and no annotations but using the right getter and setter
    methods (like regular JavaBeans).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `billingAddress` 字段被标记为嵌入。实际上，`@Embedded` 注解并不是必需的。你可以在拥有实体类中的组件类或属性上标记（同时使用两者不会造成伤害，但也不会提供任何优势）。当你想映射一个没有源代码、没有注解但使用正确的
    getter 和 setter 方法（如常规 JavaBeans）的第三方组件类时，`@Embedded` 注解是有用的。
- en: Ⓑ The repeatable `@AttributeOverride` annotation selectively overrides property
    mappings of the embedded class. In this example we override all three properties
    and provide different column names. Now we can store two `Address` instances in
    the `USERS` table, with each instance in a different set of columns (look back
    at the schema again in figure 6.2).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 可重复的 `@AttributeOverride` 注解有选择地覆盖了嵌入类的属性映射。在这个例子中，我们覆盖了所有三个属性并提供了不同的列名。现在我们可以在
    `USERS` 表中存储两个 `Address` 实例，每个实例在不同的列集中（再次查看图 6.2 中的模式）。
- en: Each `@AttributeOverride` annotation for a component property is “complete”;
    any JPA or Hibernate annotation on the overridden property is ignored. This means
    the `@Column` annotations on the `Address` class are ignored, so all `BILLING_*`
    columns are `NULL`able! (Bean Validation still recognizes the `@NotNull` annotation
    on the component property, though; only the persistence annotations are overridden.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于组件属性的每个 `@AttributeOverride` 注解都是“完整的”；任何在覆盖属性上的 JPA 或 Hibernate 注解都将被忽略。这意味着
    `Address` 类上的 `@Column` 注解将被忽略，因此所有 `BILLING_*` 列都是 `NULL` 可选的！（尽管 Bean Validation
    仍然识别组件属性上的 `@NotNull` 注解；只有持久化注解被覆盖。）
- en: We’ll create two Spring Data JPA repository interfaces to interact with the
    database. The `UserRepository` interface only extends `CrudRepository,` and it
    will inherit all the methods from this interface. It is generified by `User` and
    `Long`, as it manages `User` entities having `Long` IDs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个 Spring Data JPA 仓库接口以与数据库交互。`UserRepository` 接口仅扩展 `CrudRepository`，它将继承此接口的所有方法。它通过
    `User` 和 `Long` 进行泛型化，因为它管理具有 `Long` ID 的 `User` 实体。
- en: Listing 6.10 The `UserRepository` interface
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.10 `UserRepository` 接口
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `ItemRepository` interface extends `CrudRepository,` and it will inherit
    all the methods from this interface. Additionally, it declares the `findByMetricWeight`
    method, following the Spring Data JPA naming conventions. It is generified by
    `Item` and `Long`, as it manages `Item` entities having `Long` IDs.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemRepository` 接口扩展 `CrudRepository`，它将继承此接口的所有方法。此外，它声明了 `findByMetricWeight`
    方法，遵循 Spring Data JPA 命名约定。它通过 `Item` 和 `Long` 进行泛型化，因为它管理具有 `Long` ID 的 `Item`
    实体。'
- en: Listing 6.11 The `ItemRepository` interface
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.11 `ItemRepository` 接口
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We’ll test the functionality of the code we wrote using the Spring Data JPA
    framework, as demonstrated in the following listing. The source code for the book
    also contains testing code alternatives that use JPA and Hibernate.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Spring Data JPA 框架测试我们编写的代码的功能，如下所示。本书的源代码还包含使用 JPA 和 Hibernate 的测试代码替代方案。
- en: Listing 6.12 Testing the functionality of the persistence code
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.12 测试持久化代码的功能
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Ⓐ We extend the test using `SpringExtension`. This extension is used to integrate
    the Spring test context with the JUnit 5 Jupiter test.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 我们使用 `SpringExtension` 扩展测试。这个扩展用于将 Spring 测试上下文与 JUnit 5 Jupiter 测试集成。
- en: Ⓑ The Spring test context is configured using the beans defined in the `SpringDataConfiguration`
    class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 使用 `SpringDataConfiguration` 类中定义的 bean 配置 Spring 测试上下文。
- en: Ⓒ A `UserRepository` bean is injected by Spring through autowiring.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 通过自动装配，Spring 将 `UserRepository` 实例注入。
- en: Ⓓ An `ItemRepository` bean is injected by Spring through autowiring. This is
    possible as the `com.manning.javapersistence.ch06.repositories` package where
    `UserRepository` and `ItemRepository` are located was used as the argument of
    the `@EnableJpaRepositories` annotation on the `SpringDataConfiguration` class.
    You can look back at chapter 2 for a refresher on what the `SpringDataConfiguration`
    class looks like.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 通过自动装配，Spring 将 `ItemRepository` 实例注入。这是可能的，因为 `com.manning.javapersistence.ch06.repositories`
    包（其中包含 `UserRepository` 和 `ItemRepository`）被用作 `SpringDataConfiguration` 类上 `@EnableJpaRepositories`
    注解的参数。你可以回顾第 2 章以刷新 `SpringDataConfiguration` 类的外观。
- en: Ⓔ Create and set a user.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 创建并设置一个用户。
- en: Ⓕ Save it to the repository.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 将其保存到仓库中。
- en: Ⓖ Create and set an item.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 创建并设置一个项目。
- en: Ⓗ Save it to the repository.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓗ 保存到仓库中。
- en: Ⓘ Get the list of all users.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓘ 获取所有用户的列表。
- en: Ⓙ Get the list of items having the metric 2.0.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓙ 获取具有公制2.0的项目的列表。
- en: Ⓚ Check the size of the list of users.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓚ 检查用户列表的大小。
- en: Ⓛ Check the name.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓛ 检查名称。
- en: Ⓜ Check the street address.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓜ 检查街道地址。
- en: Ⓝ Check the ZIP code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓝ 检查ZIP代码。
- en: Ⓞ Check the city of the first user in the list.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓞ 检查列表中第一个用户的城市。
- en: Ⓟ Check the size of the list of items.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓟ 检查项目列表的大小。
- en: Ⓠ Check the name of the first item.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓠ 检查第一个项目的名称。
- en: Ⓡ Check its description.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓡ 检查其描述。
- en: Ⓢ Check the auction type.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓢ 检查拍卖类型。
- en: Ⓣ Check the short description.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓣ 检查简短描述。
- en: Ⓤ Check its metric weight.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓤ 检查其公制重量。
- en: Ⓥ Check the creation date.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓥ 检查创建日期。
- en: Ⓦ Check the last modification date and time.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓦ 检查最后修改日期和时间。
- en: Ⓧ Check the initial price of the first item in the list. The last modification
    date and time is checked against the current date and time, to ensure it is within
    1 second (allowing for the retrieval delay).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓧ 检查列表中第一个项目的初始价格。最后修改日期和时间与当前日期和时间进行比较，以确保它在1秒之内（考虑到检索延迟）。
- en: The domain model in the preceding listing can further improve reusability and
    be made more fine-grained by nesting embedded components.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 之前列出的领域模型可以通过嵌套嵌入组件进一步提高可重用性并变得更加精细。
- en: 6.2.4 Mapping nested embedded components
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.4 映射嵌套嵌入组件
- en: Let’s consider the `Address` class and how it encapsulates address details;
    instead of a having a simple `city` string, we can move this detail into a new
    `City` embeddable class. The revised domain model diagram is shown in figure 6.3\.
    The SQL schema targeted for the mapping still has only one `USERS` table, as shown
    in figure 6.4\. The source code that follows in listings 6.13 and 6.14 can be
    found in the mapping-value-types2 folder.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑 `Address` 类及其如何封装地址细节；而不是简单地有一个 `city` 字符串，我们可以将此细节移动到一个新的 `City` 可嵌入类中。修订后的领域模型图如图6.3所示。针对映射的SQL模式仍然只有一个
    `USERS` 表，如图6.4所示。接下来的源代码（列表6.13和6.14）可以在 mapping-value-types2 文件夹中找到。
- en: '![](../../OEBPS/Images/CH06_F03_Tudose2.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH06_F03_Tudose2.png)'
- en: Figure 6.3 Nested composition of `Address` and `City`
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 `Address` 和 `City` 的嵌套组合
- en: '![](../../OEBPS/Images/CH06_F04_Tudose2.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH06_F04_Tudose2.png)'
- en: Figure 6.4 Embedded columns hold `Address` and `City` details.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 嵌入列包含 `Address` 和 `City` 的细节。
- en: An embeddable class can have an embedded property, and `Address` has a `city`
    property.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可嵌入类可以有一个嵌入属性，`Address` 有一个 `city` 属性。
- en: Listing 6.13 The `Address` class with a `city` property
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.13 带有 `city` 属性的 `Address` 类
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We’ll create the embeddable `City` class with only basic properties.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只使用基本属性创建可嵌入的 `City` 类。
- en: Listing 6.14 The embeddable `City` class
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.14 可嵌入的 `City` 类
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We could continue this kind of nesting by creating a `Country` class, for example.
    All embedded properties, no matter how deep they are in the composition, are mapped
    to columns of the owning entity’s table, which here is the `USERS` table.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个 `Country` 类等来继续这种嵌套。所有嵌入属性，无论它们在组合中的深度如何，都映射到拥有实体的表的列，这里是指 `USERS`
    表。
- en: The `name` property of the `City` class is mapped to the `CITY` column. This
    can be achieved with either an `@AttributeOverride` in `Address` (as demonstrated)
    or an override in the root entity class, `User`. Nested properties can be referenced
    with dot notation; for example, on `User#address`, `@AttributeOverride(name` `=`
    `"city.name")` references the `Address#city#name` attribute.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`City` 类的 `name` 属性映射到 `CITY` 列。这可以通过在 `Address` 中使用 `@AttributeOverride`（如所示）或根实体类
    `User` 中的覆盖来实现。可以通过点符号引用嵌套属性；例如，在 `User#address` 上，`@AttributeOverride(name="city.name")`
    引用了 `Address#city#name` 属性。'
- en: We’ll come back to embedded components in section 8.2, where we’ll look at mapping
    collections of components and using references from a component to an entity.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第8.2节中回到嵌入组件，我们将探讨映射组件集合和使用从组件到实体的引用。
- en: At the beginning of this chapter, we analyzed basic properties and how Hibernate
    or Spring Data JPA using Hibernate can map a JDK type such as `java.lang.String`
    to an appropriate SQL type. Let’s find out more about this type system and how
    values are converted at a lower level.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头，我们分析了基本属性以及Hibernate或Spring Data JPA如何使用Hibernate将JDK类型（如 `java.lang.String`）映射到适当的SQL类型。让我们更深入地了解这个类型系统以及值是如何在较低级别转换的。
- en: 6.3 Mapping Java and SQL types with converters
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 使用转换器映射Java和SQL类型
- en: Until now, we’ve assumed that Hibernate or Spring Data JPA using Hibernate will
    select the right SQL type when we map a `java.lang.String` property. But what
    is the correct mapping between the Java and SQL types, and how can we control
    it? We’ll shape a correspondence between these types as we delve into the specifics.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们假设Hibernate或使用Hibernate的Spring Data JPA会在我们映射`java.lang.String`属性时选择正确的SQL类型。但Java和SQL类型之间的正确映射是什么，我们如何控制它？随着我们深入具体细节，我们将构建这些类型之间的对应关系。
- en: 6.3.1 Built-in types
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.1 内置类型
- en: Any JPA provider has to support a minimum set of Java-to-SQL type conversions.
    Hibernate and Spring Data JPA using Hibernate support all of these mappings, as
    well as some additional adapters that aren’t standard but are useful in practice.
    First let’s look at the Java primitives and their SQL equivalents.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 任何JPA提供者都必须支持一组Java到SQL类型转换的最小集合。Hibernate和Spring Data JPA使用Hibernate支持所有这些映射，以及一些在实践中有用的非标准适配器。首先，让我们看看Java原语及其SQL等效类型。
- en: Primitive and numeric types
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 原始和数值类型
- en: The built-in types shown in table 6.1 map Java primitives and their wrappers
    to appropriate SQL standard types. We’ve also included some other numeric types.
    The names in the Name column are Hibernate-specific; we’ll use them later when
    customizing type mappings.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1中显示的内置类型将Java原语及其包装器映射到适当的SQL标准类型。我们还包含了一些其他数值类型。名称列中的名称是Hibernate特定的；我们将在自定义类型映射时使用它们。
- en: Table 6.1 Java primitive types that map to SQL standard types
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1 映射到SQL标准类型的Java原语类型
- en: '| Name | Java type | ANSI SQL type |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | Java类型 | ANSI SQL类型 |'
- en: '| `integer` | `int`, `java.lang.Integer` | `INTEGER` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `integer` | `int`, `java.lang.Integer` | `INTEGER` |'
- en: '| `long` | `long`, `java.lang.Long` | `BIGINT` |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `long`, `java.lang.Long` | `BIGINT` |'
- en: '| `short` | `short`, `java.lang.Short` | `SMALLINT` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `short`, `java.lang.Short` | `SMALLINT` |'
- en: '| `float` | `float`, `java.lang.Float` | `FLOAT` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `float`, `java.lang.Float` | `FLOAT` |'
- en: '| `double` | `double`, `java.lang.Double` | `DOUBLE` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `double`, `java.lang.Double` | `DOUBLE` |'
- en: '| `byte` | `byte`, `java.lang.Byte` | `TINYINT` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | `byte`, `java.lang.Byte` | `TINYINT` |'
- en: '| `boolean` | `boolean`, `java.lang.Boolean` | `BOOLEAN` |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | `boolean`, `java.lang.Boolean` | `BOOLEAN` |'
- en: '| `big_decimal` | `java.math.BigDecimal` | `NUMERIC` |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `big_decimal` | `java.math.BigDecimal` | `NUMERIC` |'
- en: '| `big_integer` | `java.math.BigInteger` | `NUMERIC` |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `big_integer` | `java.math.BigInteger` | `NUMERIC` |'
- en: You probably noticed that your DBMS product doesn’t support some of the SQL
    types listed. These SQL type names are ANSI-standard type names. Most DBMS vendors
    ignore this part of the SQL standard, usually because their legacy type systems
    preceded the standard. However, JDBC provides a partial abstraction of vendor-specific
    data types, allowing Hibernate to work with ANSI-standard types when executing
    DML statements such as `INSERT` and `UPDATE`. For product-specific schema generation,
    Hibernate translates from the ANSI-standard type to an appropriate vendor-specific
    type using the configured SQL dialect. This means we usually don’t have to worry
    about SQL data types if we let Hibernate create the schema for us.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到你的DBMS产品不支持列出的某些SQL类型。这些SQL类型名称是ANSI标准类型名称。大多数DBMS供应商忽略了SQL标准的这一部分，通常是因为他们的遗产类型系统在标准之前。然而，JDBC提供了对供应商特定数据类型的部分抽象，允许Hibernate在执行如`INSERT`和`UPDATE`之类的DML语句时使用ANSI标准类型。对于特定产品的模式生成，Hibernate使用配置的SQL方言将ANSI标准类型转换为适当的供应商特定类型。这意味着如果我们让Hibernate为我们创建模式，我们通常不需要担心SQL数据类型。
- en: 'If we have an existing schema or we need to know the native data type for our
    DBMS, we can look at the source of our configured SQL dialect. For example, the
    `H2Dialect` that ships with Hibernate contains this mapping from the ANSI `NUMERIC`
    type to the vendor-specific `DECIMAL` type: `registerColumnType(Types.NUMERIC,
    "decimal($p,$s)")`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个现有的模式或者我们需要知道我们DBMS的原生数据类型，我们可以查看我们配置的SQL方言的源代码。例如，Hibernate附带提供的`H2Dialect`包含从ANSI
    `NUMERIC`类型到供应商特定`DECIMAL`类型的映射：`registerColumnType(Types.NUMERIC, "decimal($p,$s)")`。
- en: The `NUMERIC` SQL type supports decimal precision and scale settings. The default
    precision and scale setting for a `BigDecimal` property, for example, is `NUMERIC(19,`
    `2)`. To override this for schema generation, apply the `@Column` annotation on
    the property and set its `precision` and `scale` parameters.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`NUMERIC` SQL类型支持小数精度和比例设置。例如，`BigDecimal`属性的默认精度和比例设置是`NUMERIC(19,2)`。要覆盖此设置以生成模式，请在属性上应用`@Column`注解并设置其`precision`和`scale`参数。'
- en: Next are the types that map to strings in the database.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是映射到数据库字符串类型的类型。
- en: Character types
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 字符类型
- en: Table 6.2 shows types that map character and string value representations.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2 显示了映射字符和字符串值表示的类型。
- en: Table 6.2 Adapters for character and string values
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2 字符和字符串值适配器
- en: '| Name | Java type | ANSI SQL type |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | Java 类型 | ANSI SQL 类型 |'
- en: '| `string` | `java.lang.String` | `VARCHAR` |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `string` | `java.lang.String` | `VARCHAR` |'
- en: '| `character` | `char[]`, `Character[]`, `java.lang.String` | `CHAR` |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `character` | `char[]`, `Character[]`, `java.lang.String` | `CHAR` |'
- en: '| `yes_no` | `boolean`, `java.lang.Boolean` | `CHAR(1)`, `''Y''` or `''N''`
    |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `yes_no` | `boolean`, `java.lang.Boolean` | `CHAR(1)`, `''Y''` 或 `''N''`
    |'
- en: '| `true_false` | `boolean`, `java.lang.Boolean` | `CHAR(1)`, `''T''` or `''F''`
    |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `true_false` | `boolean`, `java.lang.Boolean` | `CHAR(1)`, `''T''` 或 `''F''`
    |'
- en: '| `class` | `java.lang.Class` | `VARCHAR` |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `class` | `java.lang.Class` | `VARCHAR` |'
- en: '| `locale` | `java.util.Locale` | `VARCHAR` |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `locale` | `java.util.Locale` | `VARCHAR` |'
- en: '| `timezone` | `java.util.TimeZone` | `VARCHAR` |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `timezone` | `java.util.TimeZone` | `VARCHAR` |'
- en: '| `currency` | `java.util.Currency` | `VARCHAR` |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `currency` | `java.util.Currency` | `VARCHAR` |'
- en: 'The Hibernate type system picks an SQL data type depending on the declared
    length of a string value: if the `String` property is annotated with `@Column(length
    = ...)` or `@Length` in Bean Validation, Hibernate selects the right SQL data
    type for the given string size. This selection also depends on the configured
    SQL dialect. For example, for MySQL, a length of up to 65,535 produces a regular
    `VARCHAR(length)` column when the schema is generated by Hibernate. For a length
    of up to 16,777,215, a MySQL- specific `MEDIUMTEXT` data type is produced, and
    even greater lengths use a `LONGTEXT`. The default length of Hibernate for all
    `java.lang.String` properties is 255, so without any further mapping, a `String`
    property maps to a `VARCHAR(255)` column. You can customize this type selection
    by extending the class of your SQL dialect; read the dialect documentation and
    source code to find out the details for your DBMS product.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 类型系统根据字符串值的声明长度选择一个 SQL 数据类型：如果 `String` 属性被注解为 `@Column(length =
    ...)` 或 Bean Validation 中的 `@Length`，Hibernate 将选择适合给定字符串大小的正确 SQL 数据类型。此选择还取决于配置的
    SQL 方言。例如，对于 MySQL，当模式由 Hibernate 生成时，长度最多为 65,535 将产生一个常规的 `VARCHAR(length)`
    列。对于长度最多为 16,777,215 的情况，将产生一个 MySQL 特定的 `MEDIUMTEXT` 数据类型，而更大的长度则使用 `LONGTEXT`。Hibernate
    为所有 `java.lang.String` 属性的默认长度是 255，因此在没有进一步映射的情况下，`String` 属性映射到 `VARCHAR(255)`
    列。您可以通过扩展您的 SQL 方言类来自定义此类型选择；阅读方言文档和源代码以了解您 DBMS 产品详情。
- en: A database usually enables the internationalization of text with a sensible
    (UTF-8) default character set for the entire database or at least whole tables.
    This is a DBMS-specific setting. If you need more fine-grained control and want
    to switch to the nationalized variants of character data types (e.g., `NVARCHAR`,
    `NCHAR`, or `NCLOB`), annotate the property mapping with `@org.hibernate.annotations.Nationalized.`
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库通常通过为整个数据库或至少整个表设置合理的（UTF-8）默认字符集来启用文本的国际化。这是一个 DBMS 特定的设置。如果您需要更精细的控制，并希望切换到字符数据类型的本土化变体（例如，`NVARCHAR`、`NCHAR`
    或 `NCLOB`），请使用 `@org.hibernate.annotations.Nationalized.` 注解属性映射。
- en: Also built in are some special converters for legacy databases or DBMSs with
    limited type systems, such as Oracle. The Oracle DBMS doesn’t even have a truth-valued
    data type; the only data type required by the relational model. Many existing
    Oracle schemas, therefore, represent Boolean values with `Y/N` or `T/F` characters.
    Or—and this is the default in Hibernate’s Oracle dialect—a column of type `NUMBER(1,0)`
    is expected and generated. Again, refer to the SQL dialect of the DBMS if you
    want to know all mappings from ANSI data type to vendor-specific type.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '对于具有有限类型系统的旧数据库或 DBMS（如 Oracle），也内置了一些特殊转换器。Oracle DBMS 甚至没有布尔值数据类型；关系模型所需的数据类型。因此，许多现有的
    Oracle 模式使用 `Y/N` 或 `T/F` 字符表示布尔值。或者——这是 Hibernate Oracle 方言的默认设置——期望并生成类型为 `NUMBER(1,0)`
    的列。再次提醒，如果您想了解从 ANSI 数据类型到供应商特定类型的所有映射，请参考 DBMS 的 SQL 方言。 '
- en: Next are the types that map to dates and times in the database.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是映射到数据库中日期和时间的类型。
- en: Date and time types
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 日期和时间类型
- en: Table 6.3 lists types associated with dates, times, and timestamps.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.3 列出了与日期、时间和时间戳相关的类型。
- en: Table 6.3 Date and time types
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.3 日期和时间类型
- en: '| Name | Java type | ANSI SQL type |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | Java 类型 | ANSI SQL 类型 |'
- en: '| `date` | `java.util.Date`, `java.sql.Date` | `DATE` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `date` | `java.util.Date`, `java.sql.Date` | `DATE` |'
- en: '| `time` | `java.util.Date`, `java.sql.Time` | `TIME` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `time` | `java.util.Date`, `java.sql.Time` | `TIME` |'
- en: '| `timestamp` | `java.util.Date`, `java.sql.Timestamp` | `TIMESTAMP` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `timestamp` | `java.util.Date`, `java.sql.Timestamp` | `TIMESTAMP` |'
- en: '| `calendar` | `java.util.Calendar` | `TIMESTAMP` |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `calendar` | `java.util.Calendar` | `TIMESTAMP` |'
- en: '| `calendar_date` | `java.util.Calendar` | `DATE` |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `calendar_date` | `java.util.Calendar` | `DATE` |'
- en: '| `duration` | `java.time.Duration` | `BIGINT` |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `duration` | `java.time.Duration` | `BIGINT` |'
- en: '| `instant` | `java.time.Instant` | `TIMESTAMP` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `instant` | `java.time.Instant` | `TIMESTAMP` |'
- en: '| `localdatetime` | `java.time.LocalDateTime` | `TIMESTAMP` |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `localdatetime` | `java.time.LocalDateTime` | `TIMESTAMP` |'
- en: '| `localdate` | `java.time.LocalDate` | `DATE` |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `localdate` | `java.time.LocalDate` | `DATE` |'
- en: '| `localtime` | `java.time.LocalTime` | `TIME` |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `localtime` | `java.time.LocalTime` | `TIME` |'
- en: '| `offsetdatetime` | `java.time.OffsetDateTime` | `TIMESTAMP` |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `offsetdatetime` | `java.time.OffsetDateTime` | `TIMESTAMP` |'
- en: '| `offsettime` | `java.time.OffsetTime` | `TIME` |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `offsettime` | `java.time.OffsetTime` | `TIME` |'
- en: '| `zoneddatetime` | `java.time.ZonedDateTime` | `TIMESTAMP` |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `zoneddatetime` | `java.time.ZonedDateTime` | `TIMESTAMP` |'
- en: In the domain model, we can represent date and time data as either `java.util.Date`,
    `java.util.Calendar`, or the subclasses of `java.util.Date` defined in the `java.sql`
    package, or the Java 8 classes from the `java.time` package. The best decision
    at this time is to use the Java 8 API in the `java.time` package. These classes
    may represent a date, a time, a date with a time, or they may even include the
    offset to the UTC zone (`OffsetDateTime` and `OffsetTime`). JPA 2.2 officially
    supports the Java 8 date and time classes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域模型中，我们可以将日期和时间数据表示为`java.util.Date`、`java.util.Calendar`或`java.sql`包中定义的`java.util.Date`的子类，或者Java
    8包中的Java 8类。此时的最佳选择是使用`java.time`包中的Java 8 API。这些类可以表示一个日期、一个时间、一个带时间的日期，甚至可能包括对UTC时区的偏移量（`OffsetDateTime`和`OffsetTime`）。JPA
    2.2官方支持Java 8日期和时间类。
- en: 'Hibernate’s behavior for `java.util.Date` properties might be a surprise at
    first: when storing a `java.util.Date`, Hibernate won’t return a `java.util.Date`
    after loading. It will return a `java.sql.Date`, a `java.sql.Time`, or a `java.sql.Timestamp`,
    depending on whether the property is mapped with `TemporalType.DATE`, `TemporalType
    .TIME`, or `TemporalType.TIMESTAMP`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate对于`java.util.Date`属性的行为一开始可能会让人感到惊讶：当存储一个`java.util.Date`时，Hibernate在加载后不会返回一个`java.util.Date`。它将返回一个`java.sql.Date`、一个`java.sql.Time`或一个`java.sql.Timestamp`，具体取决于属性是否与`TemporalType.DATE`、`TemporalType.TIME`或`TemporalType.TIMESTAMP`映射。
- en: Hibernate has to use the JDBC subclass when loading data from the database because
    the database types have higher accuracy than `java.util.Date`. A `java .util.Date`
    has millisecond accuracy, but a `java.sql.Timestamp` includes nanosecond information
    that may be present in the database. Hibernate won’t cut off this information
    to fit the value into `java.util.Date`, which may lead to problems when trying
    to compare `java.util.Date` values with the `equals()` method; it’s not symmetric
    with the `java.sql.Timestamp` subclass’s `equals()` method.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate在从数据库加载数据时必须使用JDBC子类，因为数据库类型比`java.util.Date`具有更高的精度。一个`java.util.Date`具有毫秒精度，但一个`java.sql.Timestamp`包含了数据库中可能存在的纳秒信息。Hibernate不会截断这些信息以适应`java.util.Date`的值，这可能导致在尝试使用`equals()`方法比较`java.util.Date`值时出现问题；它与`java.sql.Timestamp`子类的`equals()`方法不对称。
- en: 'The solution in such a case is simple and not even specific to Hibernate: don’t
    call `aDate.equals(bDate)`. You should always compare dates and times by comparing
    Unix time milliseconds (assuming you don’t care about the nanoseconds): `aDate.getTime()`
    `>` `bDate.getTime()`, for example, is `true` if `aDate` is a later time than
    `bDate`. But be careful: collections such as `HashSet` call the `equals()` method
    as well. Don’t mix `java .util.Date` and `java.sql.Date|Time|Timestamp` values
    in such a collection.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，解决方案简单且不仅限于Hibernate：不要调用`aDate.equals(bDate)`。你应该始终通过比较Unix时间毫秒数（假设你不在乎纳秒）来比较日期和时间：例如，如果`aDate.getTime()`
    `>` `bDate.getTime()`，则`aDate`是晚于`bDate`的时间。但请注意：像`HashSet`这样的集合也会调用`equals()`方法。不要在这样的集合中混合`java.util.Date`和`java.sql.Date|Time|Timestamp`值。
- en: You won’t have this kind of problem with a `Calendar` property. When storing
    a `Calendar` value, Hibernate will always return a `Calendar` value, created with
    `Calendar .getInstance()`—the actual type depends on locale and time zone.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会在`Calendar`属性上遇到这类问题。当存储`Calendar`值时，Hibernate将始终返回一个`Calendar`值，使用`Calendar
    .getInstance()`创建——实际类型取决于区域设置和时区。
- en: Alternatively, you can write your own *converter*, as shown in section 6.3.2,
    and transform any instance of a `java.sql` temporal type from Hibernate into a
    plain `java.util.Date` instance. A custom converter is also a good starting point
    if, for example, a `Calendar` instance should have a non-default time zone after
    the value is loaded from the database.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以像 6.3.2 节中展示的那样编写自己的 *转换器*，将 Hibernate 中的任何 `java.sql` 时间类型实例转换为普通的 `java.util.Date`
    实例。如果例如 `Calendar` 实例在从数据库加载值后应该有一个非默认时区，自定义转换器也是一个好的起点。
- en: All these concerns will go away if you choose to represent date and time data
    using the Java 8 classes `LocalDate`, `LocalTime`, `LocalDateTime`, as previously
    demonstrated in section 6.1.5\. As you may still encounter a lot of code that
    uses the old classes, you should be aware of the problems that these can raise.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择使用 Java 8 的类 `LocalDate`, `LocalTime`, `LocalDateTime` 来表示日期和时间数据，就像在 6.1.5
    节中之前演示的那样，那么所有这些担忧都将消失。你可能仍然会遇到大量使用旧类代码的情况，你应该意识到这些类可能引发的问题。
- en: Next are types that map to binary data and large values in the database.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是映射到数据库中二进制数据和大型值的类型。
- en: Binary and large value types
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制和大型值类型
- en: Table 6.4 lists types for handling binary data and large values. Note that only
    `binary` is supported as the type of an identifier property.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.4 列出了处理二进制数据和大型值的类型。请注意，只有 `binary` 支持作为标识符属性的类型。
- en: If a property in the persistent Java class is of type `byte[]`, Hibernate maps
    it to a `VARBINARY` column. The real SQL data type will depend on the dialect;
    for example, in PostgreSQL, the data type is `BYTEA`, and in Oracle DBMS it’s
    `RAW`. In some dialects, the `length` set with `@Column` also affects the selected
    native type; for example, `LONG RAW` is used for a length of 2,000 and greater
    in Oracle. In MySQL, the default SQL data type will be `TINYBLOB`. Depending on
    the `length` set with `@Column`, it may be `BLOB`, `MEDIUMBLOB,` or `LONGBLOB`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果持久化 Java 类中的属性类型为 `byte[]`，Hibernate 会将其映射到 `VARBINARY` 列。实际的 SQL 数据类型将取决于方言；例如，在
    PostgreSQL 中，数据类型是 `BYTEA`，在 Oracle DBMS 中是 `RAW`。在某些方言中，使用 `@Column` 设置的 `length`
    也会影响所选的本地类型；例如，Oracle 中长度为 2,000 及以上的使用 `LONG RAW`。在 MySQL 中，默认的 SQL 数据类型将是 `TINYBLOB`。根据
    `@Column` 设置的 `length`，它可能是 `BLOB`、`MEDIUMBLOB` 或 `LONGBLOB`。
- en: Table 6.4 Binary and large value types
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.4 二进制和大型值类型
- en: '| Name | Java type | ANSI SQL type |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | Java 类型 | ANSI SQL 类型 |'
- en: '| `binary` | `byte[]`, `java.lang.Byte[]` | `VARBINARY` |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `binary` | `byte[]`, `java.lang.Byte[]` | `VARBINARY` |'
- en: '| `text` | `java.lang.String` | `CLOB` |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `text` | `java.lang.String` | `CLOB` |'
- en: '| `clob` | `java.sql.Clob` | `CLOB` |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `clob` | `java.sql.Clob` | `CLOB` |'
- en: '| `blob` | `java.sql.Blob` | `BLOB` |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `blob` | `java.sql.Blob` | `BLOB` |'
- en: '| `serializable` | `java.io.Serializable` | `VARBINARY` |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `serializable` | `java.io.Serializable` | `VARBINARY` |'
- en: A `java.lang.String` property is mapped to an SQL `VARCHAR` column and the same
    is true for `char[]` and `Character[]`. As we’ve discussed, some dialects register
    different native types depending on the declared length.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.String` 属性映射到 SQL 的 `VARCHAR` 列，对于 `char[]` 和 `Character[]` 也是如此。正如我们之前讨论的，某些方言根据声明的长度注册不同的本地类型。'
- en: 'Hibernate initializes the property value right away when the entity instance
    that holds the property variable is loaded. This is inconvenient when you have
    to deal with potentially large values, so you’ll usually want to override this
    default mapping. The JPA specification has a convenient shortcut annotation for
    this purpose, `@Lob`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当包含属性变量的实体实例被加载时，Hibernate 会立即初始化属性值。当你必须处理可能的大型值时，这很不方便，所以你通常会想要覆盖这个默认映射。JPA
    规范为此目的提供了一个方便的快捷注解 `@Lob`：
- en: '[PRE20]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This maps the `byte[]` to an SQL `BLOB` data type and the `String` to a `CLOB`.
    Unfortunately, you still won’t get lazy loading with this design. Hibernate or
    Spring Data JPA using Hibernate would have to intercept field access and, for
    example, load the bytes of the `image` when you call `someItem.getImage()`. This
    approach requires bytecode instrumentation of the classes after compilation, for
    the injection of extra code. We’ll discuss lazy loading through bytecode instrumentation
    and interception in section 12.1.2.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `byte[]` 映射到 SQL 的 `BLOB` 数据类型，将 `String` 映射到 `CLOB`。不幸的是，你仍然无法使用这种设计实现延迟加载。Hibernate
    或使用 Hibernate 的 Spring Data JPA 必须拦截字段访问，例如，当你调用 `someItem.getImage()` 时，加载 `image`
    的字节。这种方法需要在编译后对类进行字节码仪器化，以注入额外的代码。我们将在 12.1.2 节中讨论通过字节码仪器化和拦截实现延迟加载。
- en: 'Alternatively, you can switch the type of property in the Java class. JDBC
    supports large objects (LOBs) directly. If the Java property is `java.sql.Clob`
    or `java.sql .Blob`, you’ll get lazy loading without bytecode instrumentation:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在 Java 类中切换属性的类型。JDBC 直接支持大型对象（LOBs）。如果 Java 属性是 `java.sql.Clob` 或 `java.sql.Blob`，您将获得无需字节码插装的懒加载：
- en: '[PRE21]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What does BLOB/CLOB mean?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: BLOB/CLOB 是什么意思？
- en: 'Jim Starkey, who came up with the idea of LOBs, says that the marketing department
    created the terms BLOB and CLOB. BLOB is interpreted as Binary Large Object: binary
    data (usually a multimedia object—image, video, or audio) stored as a single entity.
    CLOB means Character Large Object—character data stored in a separate location
    that the table only references.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 提出LOB概念的 Jim Starkey 表示，市场营销部门创造了 BLOB 和 CLOB 这些术语。BLOB 被解释为二进制大型对象：存储为单个实体的二进制数据（通常是多媒体对象——图像、视频或音频）。CLOB
    表示字符大型对象——存储在单独位置中的字符数据，该表仅引用。
- en: 'These JDBC classes include behavior for loading values on demand. When the
    owning entity instance is loaded, the property value is a placeholder, and the
    real value isn’t immediately materialized. Once you access the property, within
    the same transaction, the value is materialized or even streamed directly (to
    the client) without consuming temporary memory:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 JDBC 类包括按需加载值的操作。当拥有实体实例被加载时，属性值是一个占位符，实际值不会立即实现。一旦您访问属性，在同一个事务中，值就会被实现，甚至可以直接（发送到客户端）而不消耗临时内存：
- en: '[PRE22]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Ⓐ Stream the bytes directly.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 直接流式传输字节。
- en: Ⓑ Or materialize them into memory.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 或者将它们实现到内存中。
- en: Ⓒ `org.springframework.util.StreamUtils` is a class providing utility methods
    for dealing with streams.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `org.springframework.util.StreamUtils` 是一个提供处理流实用方法的类。
- en: The downside is that the domain model is then bound to JDBC; in unit tests you
    can’t access LOB properties without a database connection.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是，领域模型随后绑定到 JDBC；在单元测试中，没有数据库连接就无法访问 LOB 属性。
- en: 'To create and set a `Blob` or `Clob` value, Hibernate offers some convenience
    methods. This example reads `byteLength` bytes from an `InputStream` directly
    into the database, without consuming temporary memory:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和设置 `Blob` 或 `Clob` 值，Hibernate 提供了一些便利方法。此示例直接从 `InputStream` 读取 `byteLength`
    字节到数据库中，而不消耗临时内存：
- en: '[PRE23]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Ⓐ We need the native Hibernate API, so we have to unwrap the `Session` from
    the `EntityManager`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 我们需要原生 Hibernate API，因此我们必须从 `EntityManager` 中解包 `Session`。
- en: Ⓑ Then we need to know the number of bytes we want to read from the stream.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 然后我们需要知道从流中读取的字节数。
- en: Finally, Hibernate provides fallback serialization for any property type that
    is `java.io.Serializable`. This mapping converts the value of the property to
    a byte stream stored in a `VARBINARY` column. Serialization and deserialization
    occur when the owning entity instance is stored and loaded. Naturally, you should
    use this strategy with extreme caution because data lives longer than applications.
    One day, nobody will know what those bytes in the database mean. Serialization
    is sometimes useful for temporary data, such as user preferences, login session
    data, and so on.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Hibernate 为任何 `java.io.Serializable` 类型的属性提供回退序列化。此映射将属性值转换为存储在 `VARBINARY`
    列中的字节流。序列化和反序列化发生在拥有实体实例存储和加载时。自然地，您应该非常谨慎地使用此策略，因为数据比应用程序存活的时间更长。总有一天，没有人会知道数据库中那些字节的意思。序列化有时对临时数据很有用，例如用户偏好、登录会话数据等。
- en: Hibernate will pick the right type of adapter depending on the Java type of
    the property. If you don’t like the default mapping, read on to override it.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 将根据属性的 Java 类型选择正确的适配器类型。如果您不喜欢默认映射，请继续阅读以覆盖它。
- en: Selecting a type adapter
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 选择类型适配器
- en: 'You have seen many adapters and their Hibernate names in the previous sections.
    Use the name when overriding Hibernate’s default type selection and explicitly
    select a particular adapter:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您在前面的章节中已经看到了许多适配器和它们的 Hibernate 名称。当覆盖 Hibernate 的默认类型选择时，请使用该名称并显式选择特定的适配器：
- en: '[PRE24]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Instead of `BIT`, this `boolean` now maps to a `CHAR` column with values `Y`
    or `N`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是 `BIT`，这个 `boolean` 现在映射到一个包含值 `Y` 或 `N` 的 `CHAR` 列。
- en: 'You can also override an adapter globally in the Hibernate boot configuration
    with a custom user type, which we’ll demonstrate how to write in the next section:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在 Hibernate 启动配置中全局覆盖适配器，使用自定义用户类型，我们将在下一节中演示如何编写：
- en: '[PRE25]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This setting will override the built-in `date` type adapter and delegate value
    conversion for `java.util.Date` properties to the custom implementation.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置将覆盖内置的 `date` 类型适配器，并将 `java.util.Date` 属性的值转换委托给自定义实现。
- en: We consider this extensible type system to be one of Hibernate’s core features
    and an important aspect that makes it so flexible. Next we’ll explore the type
    system and JPA custom converters in more detail.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为这个可扩展的类型系统是 Hibernate 的核心特性之一，也是使其如此灵活的重要方面。接下来，我们将更详细地探讨类型系统和 JPA 自定义转换器。
- en: 6.3.2 Creating custom JPA converters
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.2 创建自定义 JPA 转换器
- en: A new requirement for the online auction system is using multiple currencies,
    and rolling out this kind of change can be complex. We have to modify the database
    schema, we may have to migrate existing data from the old to the new schema, and
    we have to update all applications that access the database. In this section,
    we’ll demonstrate how JPA converters and the extensible Hibernate type system
    can assist in this process, providing an additional, flexible buffer between the
    application and the database.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在在线拍卖系统中引入一个新的要求是使用多种货币，并且推出这种改变可能会很复杂。我们必须修改数据库模式，可能还需要将现有数据从旧模式迁移到新模式，并且必须更新所有访问数据库的应用程序。在本节中，我们将演示如何使用
    JPA 转换器和可扩展的 Hibernate 类型系统来协助这个过程，为应用程序和数据库之间提供额外的、灵活的缓冲区。
- en: 'To support multiple currencies, we’ll introduce a new class in the CaveatEmptor
    domain model: `MonetaryAmount`, shown in the following listing.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持多种货币，我们将在 CaveatEmptor 领域模型中引入一个新的类：`MonetaryAmount`，如下面的列表所示。
- en: Listing 6.15 Immutable `MonetaryAmount` value-type class
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.15 不可变的 `MonetaryAmount` 值类型类
- en: '[PRE26]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Ⓐ This value-typed class should be `java.io.Serializable`: When Hibernate stores
    entity instance data in the shared second-level cache, it *disassembles* the entity’s
    state. If an entity has a `MonetaryAmount` property, the serialized representation
    of the property value is stored in the second-level cache region. When entity
    data is retrieved from the cache region, the property value is deserialized and
    reassembled.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 这个值类型的类应该是 `java.io.Serializable`：当 Hibernate 将实体实例数据存储在共享的二级缓存中时，它会*分解*实体的状态。如果一个实体有一个
    `MonetaryAmount` 属性，属性值的序列化表示将存储在二级缓存区域中。当从缓存区域检索实体数据时，属性值将被反序列化和重新组装。
- en: Ⓑ The class defines the value and currency fields, a constructor using both
    of them, and getters on these fields.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 该类定义了值和货币字段，一个使用这两个字段的构造函数，以及这些字段的获取器。
- en: Ⓒ The class implements the `equals()` and `hashCode()` methods and compares
    monetary amounts “by value.”
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 该类实现了 `equals()` 和 `hashCode()` 方法，并通过“值”比较货币金额。
- en: Ⓓ The class implements the `toString()` method.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 该类实现了 `toString()` 方法。
- en: Ⓔ The class implements a static method to create an instance from a `String`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 该类实现了一个静态方法，可以从 `String` 创建一个实例。
- en: Converting basic property values
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 转换基本属性值
- en: As is often the case, the database folks can’t implement multiple currencies
    right away. All they can provide quickly is a column data type change in the database
    schema.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如通常情况那样，数据库人员不能立即实现多种货币。他们能快速提供的是数据库模式中列数据类型的变化。
- en: We’ll add the `buyNowPrice` field to the Item class.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向 Item 类添加 `buyNowPrice` 字段。
- en: '[PRE27]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We’ll store the `BUYNOWPRICE` in the `ITEM` table in a `VARCHAR` column and
    we’ll append the currency code of the monetary amount to its string value. We
    will store, for example, the value `11.23 USD` or `99 EUR`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `ITEM` 表中用 `VARCHAR` 列存储 `BUYNOWPRICE`，并将货币代码附加到货币金额的字符串值上。例如，我们将存储值 `11.23
    USD` 或 `99 EUR`。
- en: We’ll convert an instance of `MonetaryAmount` to such a `String` representation
    when storing data. When loading data, we’ll convert the `String` back into a `MonetaryAmount`.
    The simplest solution for this is to implement a standardized extension point
    in JPA, `javax.persistence.AttributeConverter`, in the `MonetaryAmoutConverter`
    class used in the `@Convert` annotation in the preceding snippet. It’s shown in
    the next listing.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在存储数据时将 `MonetaryAmount` 实例转换为这样的 `String` 表示形式。当加载数据时，我们将 `String` 转换回 `MonetaryAmount`。对此的最简单解决方案是在
    JPA 中实现一个标准化的扩展点，即 `javax.persistence.AttributeConverter`，在前面代码片段中使用的 `@Convert`
    注解的 `MonetaryAmoutConverter` 类中。它将在下一个列表中展示。
- en: Listing 6.16 Converting between strings and `MonetaryValue`
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.16 在字符串和 `MonetaryValue` 之间转换
- en: '[PRE28]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Ⓐ A converter has to implement the `AttributeConverter` interface; the two arguments
    are the type of the Java property and the type in the database schema. The Java
    type is `MonetaryAmount`, and the database type is `String`, which maps, as usual,
    to an SQL `VARCHAR`. We must annotate the class with `@Converter`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 转换器必须实现 `AttributeConverter` 接口；两个参数是 Java 属性的类型和数据库模式中的类型。Java 类型是 `MonetaryAmount`，数据库类型是
    `String`，通常映射到 SQL `VARCHAR`。我们必须用 `@Converter` 注解该类。
- en: Ⓑ The `convertToDatabaseColumn` method will convert from the `MonetaryAmount`
    entity type to the string database column.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `convertToDatabaseColumn` 方法将 `MonetaryAmount` 实体类型转换为字符串数据库列。
- en: Ⓒ The `convertToEntityAttribute` method will convert from the string database
    column to the `MonetaryAmount` entity type.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `convertToEntityAttribute` 方法将字符串数据库列转换为 `MonetaryAmount` 实体类型。
- en: To test the functionality of the persistence code, we’ll use the Spring Data
    JPA framework, as demonstrated in the following listing. The source code for this
    book also contains the testing code alternatives that use JPA and Hibernate.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试持久化代码的功能，我们将使用 Spring Data JPA 框架，如下所示。本书的源代码还包含了使用 JPA 和 Hibernate 的测试代码替代方案。
- en: Listing 6.17 Testing the functionality of the persistence code
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.17 测试持久化代码的功能
- en: '[PRE29]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Ⓐ Extend the test using `SpringExtension`. This extension is used to integrate
    the Spring test context with the JUnit 5 Jupiter test.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 使用 `SpringExtension` 扩展测试。此扩展用于将 Spring 测试上下文与 JUnit 5 Jupiter 测试集成。
- en: Ⓑ The Spring test context is configured using the beans defined in the `SpringDataConfiguration`
    class.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 使用 `SpringDataConfiguration` 类中定义的 bean 配置 Spring 测试上下文。
- en: Ⓒ A `UserRepository` bean is injected by Spring through autowiring.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 通过自动装配，Spring 注入了一个 `UserRepository` 实例。
- en: Ⓓ An `ItemRepository` bean is injected by Spring through autowiring. This is
    possible as the `com.manning.javapersistence.ch06.repositories` package where
    `UserRepository` and `ItemRepository` are located was used as the argument of
    the `@EnableJpaRepositories` annotation on the `SpringDataConfiguration` class.
    To recall what the `SpringDataConfiguration` class looks like, refer to chapter
    2.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 通过自动装配，Spring 注入了一个 `ItemRepository` 实例。这是可能的，因为 `com.manning.javapersistence.ch06.repositories`
    包（其中包含 `UserRepository` 和 `ItemRepository`）被用作 `SpringDataConfiguration` 类上 `@EnableJpaRepositories`
    注解的参数。要回忆 `SpringDataConfiguration` 类的样子，请参阅第 2 章。
- en: Ⓔ Create and set a city.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓜ 创建并设置一个城市。
- en: Ⓕ Create and set a user.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ 创建并设置一个用户。
- en: Ⓖ Save it to the repository.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 保存到仓库中。
- en: Ⓗ Create and set an item.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓗ 创建并设置一个项目。
- en: Ⓘ Save it to the repository.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓘ 保存到仓库中。
- en: Ⓙ Get the list of all users.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓙ 获取所有用户的列表。
- en: Ⓚ Get the list of items having the metric 2.0.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓚ 获取具有度量值 2.0 的项目列表。
- en: Ⓛ Check the size of the list of users.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓛ 检查用户列表的大小。
- en: Ⓜ Check the name of the first user in the list.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓜ 检查列表中第一个用户的名称。
- en: Ⓝ Check the street address of the first user in the list.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓝ 检查列表中第一个用户的街道地址。
- en: Ⓞ Check the city of the first user in the list.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓞ 检查列表中第一个用户的所在城市。
- en: Ⓟ Check the ZIP code of the first user in the list.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓟ 检查列表中第一个用户的邮政编码。
- en: Ⓠ Check the country of the first user in the list.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓠ 检查列表中第一个用户的国籍。
- en: Ⓡ Check the size of the list of items.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓡ 检查项目列表的大小。
- en: Ⓢ Check the name of the first item.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓢ 检查第一个项目的名称。
- en: Ⓣ Check its current buying price.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓣ 检查其当前购买价格。
- en: Ⓤ Check its description.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓤ 检查其描述。
- en: Ⓥ Check the auction type.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓥ 检查拍卖类型。
- en: Ⓦ Check its short description.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓦ 检查其简短描述。
- en: Ⓧ Check its metric weight.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓧ 检查其度量重量。
- en: Ⓨ Check the creation date.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓨ 检查创建日期。
- en: Ⓩ Check the last modification date and time and the initial price of the first
    item in the list. The last modification date and time is checked against the current
    date and time to be within 1 second (allowing for the retrieval delay).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓩ 检查列表中第一个项目的最后修改日期和时间以及初始价格。最后修改日期和时间与当前日期和时间进行比较，以确保在 1 秒内（允许有检索延迟）。
- en: ⓐ Check the initial price of the first item.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ⓐ 检查第一个项目的初始价格。
- en: Later, when the DBA upgrades the database schema and offers separate columns
    for the monetary amount and currency, we’ll only have to change the application
    in a few places. We’ll drop the `MonetaryAmountConverter` from the project and
    make `MonetaryAmount` an `@Embeddable`; it will then map automatically to two
    database columns. It’s easy to selectively enable and disable converters, too,
    if some tables in the schema haven’t been upgraded.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，当数据库管理员升级数据库模式并提供了货币金额和货币的单独列时，我们只需在应用程序的几个地方进行更改。我们将从项目中删除`MonetaryAmountConverter`，并将`MonetaryAmount`设为`@Embeddable`；它将自动映射到两个数据库列。如果某些表尚未升级，也可以轻松地选择性地启用和禁用转换器。
- en: The converter we just wrote is for `MonetaryAmount`, a new class in the domain
    model. Converters aren’t limited to custom classes—we can even override Hibernate’s
    built-in type adapters. For example, we could create a custom converter for some
    or even all `java.util.Date` properties in the domain model.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写的转换器是为`MonetaryAmount`，这是一个新的领域模型类。转换器不仅限于自定义类——我们甚至可以覆盖Hibernate的内置类型适配器。例如，我们可以为领域模型中的某些或所有`java.util.Date`属性创建自定义转换器。
- en: We can apply converters to properties of entity classes, like `Item#buyNowPrice`
    in listing 6.17\. We can also apply them to properties of embeddable classes.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将转换器应用于实体类的属性，如列表6.17中的`Item#buyNowPrice`。我们也可以将它们应用于可嵌入类的属性。
- en: Converting properties of components
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 转换组件属性
- en: We’ve been making a case for fine-grained domain models in this chapter. Earlier
    we isolated the address information of the `User` and mapped the embeddable `Address`
    class. We’ll continue the process and introduce inheritance with an abstract `Zipcode`
    class, as shown in figure 6.5\. The source code that follows can be found in the
    mapping-value-types3 folder.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一直在为细粒度领域模型进行辩护。之前，我们将`User`的地址信息隔离出来，并映射了可嵌入的`Address`类。我们将继续这个过程，并使用抽象的`Zipcode`类引入继承，如图6.5所示。随后的源代码可以在mapping-value-types3文件夹中找到。
- en: '![](../../OEBPS/Images/CH06_F05_Tudose2.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F05_Tudose2.png)'
- en: Figure 6.5 The abstract `Zipcode` class has two concrete subclasses.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 抽象类`Zipcode`有两个具体子类。
- en: 'The `Zipcode` class is trivial, but we have to implement equality by value:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`Zipcode`类很简单，但我们必须通过值实现相等性：'
- en: '[PRE30]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can now encapsulate domain subclasses, the difference between German and
    Swiss postal codes, and any processing:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以封装领域子类，德国和瑞士邮政编码之间的差异，以及任何处理：
- en: '[PRE31]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We haven’t implemented any special processing in the subclass. We’ll start
    with the most obvious difference: German ZIP codes are five numbers long, Swiss
    are four. A custom converter will take care of this.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在子类中没有实现任何特殊处理。我们将从最明显的区别开始：德国的ZIP代码是五位数字长，瑞士的是四位。自定义转换器将处理这一点。
- en: Listing 6.18 The `ZipcodeConverter` class
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.18 `ZipcodeConverter`类
- en: '[PRE32]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Ⓐ Hibernate calls the `convertToDatabaseColumn()` method of this converter when
    storing a property value; we return a `String` representation. The column in the
    schema is `VARCHAR`. When loading a value, we examine its length and create either
    a `GermanZipcode` or `SwissZipcode` instance. This is a custom type discrimination
    routine; we can pick the Java type of the given value.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 当Hibernate存储属性值时，会调用此转换器的`convertToDatabaseColumn()`方法；我们返回一个字符串表示。模式中的列是`VARCHAR`。当加载值时，我们检查其长度，并创建一个`GermanZipcode`或`SwissZipcode`实例。这是一个自定义类型区分例程；我们可以选择给定值的Java类型。
- en: Ⓑ Hibernate calls the `convertToEntityAttribute` method of this converter when
    loading a property from the database.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 当Hibernate从数据库加载属性时，会调用此转换器的`convertToEntityAttribute`方法。
- en: Ⓒ If the length of the string is 5, a new `GermanZipcode` is created.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 如果字符串长度为5，则创建一个新的`GermanZipcode`。
- en: Ⓓ If the length of the string is 4, a new `SwissZipcode` is created.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 如果字符串长度为4，则创建一个新的`SwissZipcode`。
- en: Ⓔ Otherwise, an exception is thrown—the ZIP code in the database is not supported.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 否则，将抛出异常——数据库中的ZIP代码不受支持。
- en: 'Now we’ll apply this converter on some `Zipcode` properties, such as the embedded
    `homeAddress` of a `User`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将此转换器应用于一些`Zipcode`属性，例如`User`的嵌入式`homeAddress`：
- en: '[PRE33]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `attributeName` declares the `zipcode` attribute of the embeddable `Address`
    class. This setting supports a dot syntax for the attribute path; if `zipcode`
    isn’t a property of the `Address` class but is a property of a nested embeddable
    `City` class, it is referenced with `city.zipcode`, its nested path.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`attributeName` 声明了可嵌入的 `Address` 类的 `zipcode` 属性。此设置支持属性路径的点语法；如果 `zipcode`
    不是 `Address` 类的属性而是嵌套的可嵌入 `City` 类的属性，则通过 `city.zipcode`，其嵌套路径来引用。'
- en: In JPA 2.2, we can apply several `@Convert` annotations on a single embedded
    property to convert several attributes of the `Address`. Up to JPA 2.1, we had
    to group them within a single `@Converts` annotation. We can also apply converters
    to values of collections, and maps if their values or keys are of basic or embeddable
    types. For example, we can add the `@Convert` annotation on a persistent `Set<Zipcode>`.
    We’ll demonstrate how to map persistent collections later, with `@ElementCollection`,
    in chapter 8.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JPA 2.2 中，我们可以在单个嵌入属性上应用多个 `@Convert` 注解来转换 `Address` 的多个属性。在 JPA 2.1 之前，我们必须将它们组合在单个
    `@Converts` 注解中。我们还可以将转换器应用于集合和映射的值，如果它们的值或键是基本类型或可嵌入类型。例如，我们可以在持久的 `Set<Zipcode>`
    上添加 `@Convert` 注解。我们将在第 8 章中演示如何使用 `@ElementCollection` 映射持久化集合。
- en: 'For persistent maps, the `attributeName` option of the `@Convert` annotation
    has some special syntax:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 对于持久化映射，`@Convert` 注解的 `attributeName` 选项有一些特殊语法：
- en: On a persistent `Map<Address,` `String>`, we can apply a converter for the `zipcode`
    property of each map key with the attribute name `key.zipcode`.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个持久的 `Map<Address, String>` 上，我们可以通过属性名 `key.zipcode` 为每个映射键的 `zipcode` 属性应用一个转换器。
- en: On a persistent `Map<String,` `Address>`, we can apply a converter for the `zipcode`
    property of each map value with the attribute name `value.zipcode`.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个持久的 `Map<String, Address>` 上，我们可以通过属性名 `value.zipcode` 为每个映射值的 `zipcode`
    属性应用一个转换器。
- en: On a persistent `Map<Zipcode,` `String>`, we can apply a converter for the key
    of each map entry with the attribute name `key`.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个持久的 `Map<Zipcode, String>` 上，我们可以通过属性名 `key` 为每个映射条目的键应用一个转换器。
- en: On a persistent `Map<String,` `Zipcode>`, we can apply a converter for the value
    of each map entry by not setting any `attributeName`.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个持久的 `Map<String, Zipcode>` 上，我们可以通过不设置任何 `attributeName` 来为每个映射条目的值应用一个转换器。
- en: As before, the attribute name can be a dot-separated path if the embeddable
    classes are nested; we can write `key.city.zipcode` to reference the `zipcode`
    property of the `City` class in a composition with the `Address` class.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果嵌套类是嵌套的，则属性名可以是点分隔的路径；我们可以编写 `key.city.zipcode` 来引用与 `Address` 类组合的 `City`
    类的 `zipcode` 属性。
- en: 'Some limitations of the JPA converters are as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 转换器的一些限制如下：
- en: We can’t apply them to identifier or version properties of an entity.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能将它们应用于实体的标识符或版本属性。
- en: We shouldn’t apply a converter on a property mapped with `@Enumerated` or `@Temporal`
    because these annotations already declare what kind of conversion has to occur.
    If we want to apply a custom converter for enums or date/time properties, we shouldn’t
    annotate them with `@Enumerated` or `@Temporal`.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不应该在用 `@Enumerated` 或 `@Temporal` 映射的属性上应用转换器，因为这些注解已经声明了必须发生的转换类型。如果我们想为枚举或日期/时间属性应用自定义转换器，则不应使用
    `@Enumerated` 或 `@Temporal` 注解它们。
- en: We’ll have to change the testing code we wrote a little. We’ll replace this
    line,
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不稍微修改我们编写的测试代码。我们将替换这一行，
- en: '[PRE34]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'with this one:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 为这一行：
- en: '[PRE35]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We’ll also replace this line,
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将替换这一行，
- en: '[PRE36]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'with this one:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 为这一行：
- en: '[PRE37]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The source code for the book contains these tests using Spring Data JPA, Hibernate,
    and JPA.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍的源代码包含使用 Spring Data JPA、Hibernate 和 JPA 的这些测试。
- en: Let’s get back to multiple currency support in CaveatEmptor. The database administrators
    have changed the schema again, and we now have to update the application.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 CaveatEmptor 的多货币支持。数据库管理员再次更改了模式，我们现在必须更新应用程序。
- en: 6.3.3 Extending Hibernate with UserTypes
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3.3 使用 UserTypes 扩展 Hibernate
- en: Finally, new columns have been added to the database schema to support multiple
    currencies. The `ITEM` table now has a `BUYNOWPRICE_AMOUNT` and a separate column
    for the currency of the amount, `BUYNOWPRICE_CURRENCY`. There are also `INITIALPRICE_
    AMOUNT` and `INITIALPRICE_CURRENCY` columns. We have to map these columns to the
    `MonetaryAmount` properties of the `Item` class, `buyNowPrice,` and `initialPrice`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，数据库模式中已添加新列以支持多种货币。`ITEM` 表现在有 `BUYNOWPRICE_AMOUNT` 和一个单独的金额货币列，`BUYNOWPRICE_CURRENCY`。还有
    `INITIALPRICE_AMOUNT` 和 `INITIALPRICE_CURRENCY` 列。我们必须将这些列映射到 `Item` 类的 `MonetaryAmount`
    属性，即 `buyNowPrice` 和 `initialPrice`。
- en: 'Ideally, we don’t want to change the domain model; the properties already use
    the `MonetaryAmount` class. Unfortunately, the standardized JPA converters don’t
    support the transformation of values from or to multiple columns. Another limitation
    of JPA converters is integration with the query engine. We can’t write the following
    query: `select` `i` `from` `Item` `i` `where` `i.buyNowPrice.amount` `>` `100`.
    Thanks to the converter from the previous section, Hibernate knows how to convert
    a `MonetaryAmount` to and from a string. However, it doesn’t know that `MonetaryAmount`
    has an `amount` attribute, so it can’t parse such a query.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们不想更改领域模型；现有的属性已经使用了`MonetaryAmount`类。不幸的是，标准化的JPA转换器不支持从或向多个列的值转换。JPA转换器的另一个限制是与查询引擎的集成。我们无法编写以下查询：`select`
    `i` `from` `Item` `i` `where` `i.buyNowPrice.amount` `>` `100`。多亏了上一节中的转换器，Hibernate知道如何将`MonetaryAmount`转换为字符串以及从字符串转换回来。然而，它不知道`MonetaryAmount`有一个`amount`属性，因此无法解析这样的查询。
- en: A simple solution would be to map `MonetaryAmount` as `@Embeddable`, as you
    saw earlier in this chapter for the `Address` class (listing 6.13). Each property
    of `MonetaryAmount`—`amount` and `currency`—maps to its respective database column.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的解决方案是将`MonetaryAmount`映射为`@Embeddable`，正如你在本章前面为`Address`类所看到的（列表6.13）。`MonetaryAmount`的每个属性——`amount`和`currency`——映射到其各自的数据库列。
- en: 'The database admins, however, added a twist to their requirements: because
    other old applications also access the database, we’ll have to convert each amount
    to a target currency before storing it in the database. For example, `Item#buyNowPrice`
    should be stored in US dollars, and `Item#initialPrice` should be stored in Euros.
    (If this example seems far-fetched, we can assure you that you’ll see worse in
    the real world. The evolution of a shared database schema can be costly but is,
    of course, necessary, because data always lives longer than applications.) Hibernate
    offers a native converter API: an extension point that allows much more detailed
    and low-level customization access.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，数据库管理员在其要求中增加了一个转折：由于其他旧应用程序也访问数据库，我们必须在将值存储到数据库之前将其转换为目标货币。例如，`Item#buyNowPrice`应存储为美元，而`Item#initialPrice`应存储为欧元。（如果这个例子看起来有些牵强，我们可以向你保证，在现实世界中你会看到更糟糕的情况。共享数据库模式的发展可能代价高昂，但当然是必要的，因为数据总是比应用程序存在的时间更长。）Hibernate提供了一个本机转换器API：一个允许更详细和低级定制的扩展点。
- en: The extension points
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展点
- en: 'Hibernate’s extension interfaces for its type system can be found in the `org.hibernate.usertype`
    package. The following interfaces are available:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate的类型系统扩展接口可以在`org.hibernate.usertype`包中找到。以下接口可用：
- en: '`UserType`—You can transform values by interacting with the plain JDBC: `PreparedStatement`
    (when storing data) and `ResultSet` (when loading data). By implementing this
    interface, you can also control how Hibernate caches and dirty-checks values.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserType`——你可以通过与原始JDBC的`PreparedStatement`（存储数据时）和`ResultSet`（加载数据时）交互来转换值。通过实现此接口，你还可以控制Hibernate如何缓存和脏检查值。'
- en: '`CompositeUserType`—You can tell Hibernate that the `MonetaryAmount` component
    has two properties: `amount` and `currency`. You can then reference these properties
    in queries with dot notation, such as `select` `avg(i.buyNowPrice .amount)` `from`
    `Item` `i`.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompositeUserType`——你可以告诉Hibernate，`MonetaryAmount`组件有两个属性：`amount`和`currency`。然后你可以在查询中使用点符号引用这些属性，例如`select`
    `avg(i.buyNowPrice .amount)` `from` `Item` `i`。'
- en: '`ParameterizedType`—This provides settings to the adapter in mappings. We could
    implement this interface for the `MonetaryAmount` conversion because, in some
    mappings we’ll want to convert the amount to US dollars and in other mappings
    to Euros. We’ll only have to write a single adapter and we can then customize
    its behavior when mapping a property.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParameterizedType`——这为映射中的适配器提供设置。我们可以为`MonetaryAmount`转换实现此接口，因为在某些映射中我们希望将金额转换为美元，在其他映射中转换为欧元。我们只需编写一个适配器，然后可以在映射属性时自定义其行为。'
- en: '`DynamicParameterizedType`—This more powerful settings API gives access to
    dynamic information in the adapter, such as the mapped column and table names.
    We might as well use this instead of `ParameterizedType`; there is no additional
    cost or complexity.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DynamicParameterizedType`——这个更强大的设置API提供了对适配器中动态信息的访问，例如映射的列和表名。我们不妨使用这个而不是`ParameterizedType`；这不会带来额外的成本或复杂性。'
- en: '`EnhancedUserType`—This is an optional interface for adapters of identifier
    properties and discriminators. Unlike JPA converters, a `UserType` in Hibernate
    can be an adapter for any kind of entity property. Because `MonetaryAmount` won’t
    be the type of an identifier property or discriminator, we won’t need it.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnhancedUserType`—这是一个可选接口，用于标识属性和区分符的适配器。与JPA转换器不同，Hibernate中的`UserType`可以是任何类型实体属性的适配器。因为`MonetaryAmount`不会是标识属性或区分符的类型，所以我们不需要它。'
- en: '`UserVersionType`—This is an optional interface for adapters of version properties.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserVersionType`—这是一个可选接口，用于版本属性的适配器。'
- en: '`UserCollectionType`—This rarely-needed interface is used to implement custom
    collections. We’ll have to implement it to persist a non-JDK collection (such
    as the Google Guava collections: `Multiset`, `Multimap`, `BiMap`, `Table,` etc.)
    and preserve additional semantics.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserCollectionType`—这个很少需要的接口用于实现自定义集合。我们必须实现它以持久化非JDK集合（例如Google Guava集合：`Multiset`、`Multimap`、`BiMap`、`Table`等）并保留额外的语义。'
- en: The custom type adapter for `MonetaryAmount` will implement several of these
    interfaces. The source code that follows can be found in the mapping-value-types4
    folder.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonetaryAmount`的自定义类型适配器将实现这些接口中的几个。接下来的源代码可以在`mapping-value-types4`文件夹中找到。'
- en: Implementing the UserType
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 实现UserType
- en: '`MonetaryAmountUserType` is a large class, as you can see in the following
    listing.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonetaryAmountUserType`是一个大类，正如你在下面的列表中可以看到的。'
- en: Listing 6.19 The `MonetaryAmountUserType` `class`
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.19 `MonetaryAmountUserType`类
- en: '[PRE38]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Ⓐ The interfaces we implement are `CompositeUserType` and `DynamicParameterizedType`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 我们实现的接口是`CompositeUserType`和`DynamicParameterizedType`。
- en: Ⓑ The target currency.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 目标货币。
- en: Ⓒ The `setParameterValues` method is inherited from the `DynamicParameterizedType`
    interface.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `setParameterValues`方法是从`DynamicParameterizedType`接口继承的。
- en: Ⓓ Use the `convertTo` parameter to determine the target currency when saving
    a value into the database.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 使用`convertTo`参数确定在将值保存到数据库时目标货币。
- en: Ⓔ If the parameter hasn’t been set, default to US dollars.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 如果参数尚未设置，则默认为美元。
- en: Ⓕ The `returnedClass` method adapts the given class, in this case, `MonetaryAmount`.
    This method and the ones to follow are inherited from the `CompositeUserType`
    interface.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓕ `returnedClass`方法适配给定的类，在这种情况下，是`MonetaryAmount`。这个方法和接下来的方法都是从`CompositeUserType`接口继承的。
- en: Ⓖ Hibernate can enable some optimizations if it knows that `MonetaryAmount`
    is immutable.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓖ 如果Hibernate知道`MonetaryAmount`是不可变的，它可以启用一些优化。
- en: Ⓗ If Hibernate has to make a copy of the value, it calls this `deepCopy` method.
    For simple immutable classes like `MonetaryAmount`, we can return the given instance.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓗ 如果Hibernate必须复制值，它会调用这个`deepCopy`方法。对于像`MonetaryAmount`这样的简单不可变类，我们可以返回给定的实例。
- en: Ⓘ Hibernate calls the `disassemble` method when it stores a value in the global
    shared second-level cache. We need to return a `Serializable` representation.
    For `MonetaryAmount`, a `String` representation is an easy solution. Or, because
    `MonetaryAmount` is `Serializable`, we could return it directly.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓘ 当Hibernate在全局共享的二级缓存中存储值时，它会调用`disassemble`方法。我们需要返回一个`Serializable`表示。对于`MonetaryAmount`，一个`String`表示是一个简单的解决方案。或者，因为`MonetaryAmount`是`Serializable`的，我们可以直接返回它。
- en: Ⓙ Hibernate calls the `assemble` method when it reads the serialized representation
    from the global shared second-level cache. We create a `MonetaryAmount` instance
    from the `String` representation. Or, if we stored a serialized `MonetaryAmount`,
    we could return it directly.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓙ 当Hibernate从全局共享的二级缓存中读取序列化表示时，它会调用`assemble`方法。我们从一个`String`表示中创建一个`MonetaryAmount`实例。或者，如果我们存储了一个序列化的`MonetaryAmount`，我们可以直接返回它。
- en: Ⓚ The `replace` method is called during `EntityManager#merge()` operations.
    We need to return a copy of the original. Or, if the value type is immutable,
    like `MonetaryAmount`, we can return the original.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓚ 在`EntityManager#merge()`操作期间调用`replace`方法。我们需要返回原始副本。或者，如果值类型是不可变的，如`MonetaryAmount`，我们可以返回原始值。
- en: Ⓛ Hibernate uses value equality to determine whether the value was changed and
    the database needs to be updated. We rely on the equality and hash code routines
    we have already written on the `MonetaryAmount` class.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓛ Hibernate使用值相等性来确定值是否已更改，数据库需要更新。我们依赖于我们在`MonetaryAmount`类上已经编写的相等性和哈希码例程。
- en: Ⓜ The `nullSafeGet` method is called to read the `ResultSet` when a `MonetaryAmount`
    value has to be retrieved from the database.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓜ 当需要从数据库中检索`MonetaryAmount`值时，会调用`nullSafeGet`方法来读取`ResultSet`。
- en: Ⓝ Take the `amount` and `currency` values as given in the query result.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓝ 将查询结果中给出的`amount`和`currency`值作为已知值。
- en: Ⓞ Create a new instance of `MonetaryAmount`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓞ 创建一个 `MonetaryAmount` 的新实例。
- en: Ⓟ The `nullSafeSet` method is called when a `MonetaryAmount` value has to be
    stored in the database.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓟ 当需要将 `MonetaryAmount` 值存储在数据库中时，会调用 `nullSafeSet` 方法。
- en: Ⓠ If `MonetaryAmount` was `null`, we call `setNull()` to prepare the statement.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓠ 如果 `MonetaryAmount` 为 `null`，我们调用 `setNull()` 来准备语句。
- en: Ⓡ Otherwise, we convert the value to the target currency.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓡ 否则，我们将值转换为目标货币。
- en: Ⓢ We then set the `amount` and `currency` on the provided `PreparedStatement`().
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓢ 然后我们在提供的 `PreparedStatement()` 上设置 `amount` 和 `currency`。
- en: Ⓣ We can implement whatever currency conversion routine we need.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓣ 我们可以实现所需的任何货币转换程序。
- en: Ⓤ For the sake of this example, we double the value so we can easily test whether
    the conversion was successful. We’d have to replace this code with a real currency
    converter in a real application. This `convert` method is not a method of the
    Hibernate `UserType` API.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓤ 为了这个示例，我们将值加倍，这样我们就可以轻松地测试转换是否成功。在实际应用中，我们必须用真正的货币转换器替换此代码。这个 `convert` 方法不是
    Hibernate `UserType` API 中的方法。
- en: Ⓥ The remaining methods inherited from `CompositeUserType` provide the details
    of the `MonetaryAmount` properties, so Hibernate can integrate the class with
    the query engine. The `getPropertyNames` method will return a `String` array with
    two elements, `value` and `currency`—the names of the properties of the `MonetaryAmount`
    class.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓥ 从 `CompositeUserType` 继承的剩余方法提供了 `MonetaryAmount` 属性的详细信息，因此 Hibernate 可以将此类与查询引擎集成。`getPropertyNames`
    方法将返回一个包含两个元素的 `String` 数组，`value` 和 `currency`——这是 `MonetaryAmount` 类属性的名称。
- en: Ⓦ The `getPropertyTypes` method will return a `Type` array with two elements,
    `BIG _DECIMAL` and `CURRENCY`—the types of the properties of the `MonetaryAmount`
    class.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓦ `getPropertyTypes` 方法将返回一个包含两个元素的 `Type` 数组，`BIG _DECIMAL` 和 `CURRENCY`——这是
    `MonetaryAmount` 类属性的类型。
- en: Ⓧ The `getPropertyValue` method will return either the `value` field or the
    `currency` field of the `MonetaryAmount` object, depending on the `property` index.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓧ `getPropertyValue` 方法将根据 `property` 索引返回 `MonetaryAmount` 对象的 `value` 字段或
    `currency` 字段。
- en: Ⓨ The `setPropertyValue` method will not allow any field of the `MonetaryAmount`
    object to be set, as this one is immutable.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓨ `setPropertyValue` 方法将不允许设置 `MonetaryAmount` 对象的任何字段，因为这个对象是不可变的。
- en: The `MonetaryAmountUserType` class is now complete, and we can already use it
    in mappings with its fully qualified class name in `@org.hibernate.annotations.Type`,
    as demonstrated in the “Selecting a type adapter” section (in section 6.3.1)`.`
    This annotation also supports parameters, so we can set the `convertTo` argument
    to the target currency.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonetaryAmountUserType` 类现在已经完成，我们可以在映射中使用它，在 `@org.hibernate.annotations.Type`
    中使用其完全限定类名，如“选择类型适配器”部分（在第 6.3.1 节中）所示。此注解还支持参数，因此我们可以将 `convertTo` 参数设置为目标货币。'
- en: However, we recommend creating *type definitions*, bundling the adapter with
    some parameters.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们建议创建 *类型定义*，将适配器与一些参数捆绑在一起。
- en: Using type definitions
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型定义
- en: 'We need an adapter that converts to US dollars, and another that converts to
    Euros. If we declare these parameters once as a *type definition*, we won’t have
    to repeat them in property mappings. A good location for type definitions is package
    metadata, in a package-info.java file:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个将货币转换为美元的适配器，另一个将货币转换为欧元。如果我们将这些参数作为 *类型定义* 一次性声明，我们就不必在属性映射中重复它们。类型定义的好位置是包元数据，在
    package-info.java 文件中：
- en: '[PRE39]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We are now ready to use the adapters in mappings, using the names `monetary_
    amount_usd` and `monetary_amount_eur`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好在映射中使用适配器，使用名称 `monetary_ amount_usd` 和 `monetary_amount_eur`。
- en: 'We can map the `buyNowPrice` and `initialPrice` of `Item`:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `Item` 的 `buyNowPrice` 和 `initialPrice` 进行映射：
- en: '[PRE40]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If `UserType` transforms values for only a single column, we don’t need an `@Column`
    annotation. `MonetaryAmountUserType`, however, accesses two columns, so we need
    to explicitly declare two columns in the property mapping. Because JPA doesn’t
    support multiple `@Column` annotations on a single property, we’ll have to group
    them with the proprietary `@org.hibernate.annotations.Columns` annotation. Note
    that the order of the annotations is now important! Recheck the code for `MonetaryAmountUserType`;
    many operations rely on indexed access of arrays. The order when accessing `PreparedStatement`
    or `ResultSet` is the same as that for the declared columns in the mapping. Also,
    note that the number of columns isn’t relevant for the choice of `UserType` versus
    `CompositeUserType`—only the desire to expose value type properties for queries.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `UserType` 只转换单个列的值，我们不需要 `@Column` 注解。然而，`MonetaryAmountUserType` 访问两个列，因此我们需要在属性映射中显式声明两个列。由于
    JPA 不支持在单个属性上使用多个 `@Column` 注解，我们将不得不使用专有的 `@org.hibernate.annotations.Columns`
    注解将它们分组。请注意，注解的顺序现在很重要！重新检查 `MonetaryAmountUserType` 的代码；许多操作依赖于数组的索引访问。访问 `PreparedStatement`
    或 `ResultSet` 的顺序与映射中声明的列的顺序相同。此外，请注意，列的数量对于选择 `UserType` 与 `CompositeUserType`
    并不重要——只有暴露值类型属性以供查询的愿望。
- en: 'We’ll have to change the testing code we wrote. We’ll add this line to set
    the `Item`:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不更改我们编写的测试代码。我们将添加这一行来设置 `Item`：
- en: '[PRE41]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We’ll replace this line,
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将替换这一行，
- en: '[PRE42]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'with this one:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个：
- en: '[PRE43]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We’ll also replace this line,
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将替换这一行，
- en: '[PRE44]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'with this one:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这一行替换：
- en: '[PRE45]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is because the `convert` method from the `MonetaryAmountUserType` class
    doubles the value of the amount (shown in listing 6.19 at Ⓤ). The source code
    for this book contains the tests using Spring Data JPA, Hibernate, and JPA.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `MonetaryAmountUserType` 类的 `convert` 方法将金额的值加倍（如列表 6.19 所示）。本书的源代码包含使用
    Spring Data JPA、Hibernate 和 JPA 的测试。
- en: With `MonetaryAmountUserType`, we’ve extended the buffer between the Java domain
    model and the SQL database schema. Both representations are now more robust with
    respect to changes, and we can handle even rather eccentric requirements without
    modifying the essence of the domain model classes.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `MonetaryAmountUserType`，我们扩展了 Java 领域模型和 SQL 数据库模式之间的缓冲区。现在，两种表示方法在变化方面都更加健壮，我们可以处理甚至相当古怪的要求，而无需修改领域模型类的本质。
- en: Summary
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: You can map the basic and embedded properties of an entity class.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将实体类的基元和嵌入属性映射。
- en: You can override basic mappings, change the name of a mapped column, use derived,
    default, temporal, and enumeration properties, and test them.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以覆盖基本映射，更改映射列的名称，使用派生、默认、时间和枚举属性，并对其进行测试。
- en: You can implement embeddable component classes and create fine-grained domain
    models.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以实现可嵌入的组件类并创建细粒度的领域模型。
- en: You can map the properties of several Java classes in a composition, such as
    `Address` and `City`, to one entity table.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将几个 Java 类的属性映射到一个实体表中，例如 `Address` 和 `City`。
- en: Any JPA provider supports a minimum set of Java-to-SQL type conversions, as
    well as some additional adapters.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何 JPA 提供商都支持一组基本的 Java 到 SQL 类型转换，以及一些额外的适配器。
- en: You can write a custom type converter, as we did for the `MonetaryAmount` class,
    with the standard JPA extension interfaces. You can also write a low-level adapter,
    as we did with the native Hibernate `UserType` API.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以编写一个自定义类型转换器，就像我们为 `MonetaryAmount` 类所做的那样，使用标准的 JPA 扩展接口。您还可以编写一个低级适配器，就像我们使用原生
    Hibernate `UserType` API 所做的那样。
