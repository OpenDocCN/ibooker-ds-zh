- en: 13 Middleware, HTTP routing, and HTTP responses
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 中间件、HTTP 路由和 HTTP 响应
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖了
- en: Routing HTTP requests to controllers and endpoints
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 HTTP 请求路由到控制器和端点
- en: Declaring HTTP routes with `HttpAttribute` method attributes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `HttpAttribute` 方法属性声明 HTTP 路由
- en: Injecting dependencies with middleware
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中间件注入依赖
- en: Using the `IActionResult` interface to return HTTP responses
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `IActionResult` 接口返回 HTTP 响应
- en: We are almost at the end of our journey. In chapters gone by, we implemented
    the database access layer, the repository layer, and the service layer. Our service
    is almost implemented but not yet usable by FlyTomorrow (our client). To interact
    with our service, we need to provide controllers that accept HTTP requests and
    kick off the necessary processing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎到达了旅程的终点。在过去的章节中，我们实现了数据库访问层、仓库层和服务层。我们的服务几乎实现了，但尚未可供 FlyTomorrow（我们的客户）使用。为了与我们的服务交互，我们需要提供接受
    HTTP 请求并启动必要处理的控制器。
- en: In section 13.1, we’ll discuss the controller’s place within our repository/service
    architecture. Following that, in section 13.2, we’ll determine which controllers
    we need to implement. In the following sections, we’ll start to implement the
    `FlightController` (section 13.3) and explore how to route HTTP requests to our
    endpoints (section 13.4).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 13.1 节中，我们将讨论控制器在我们仓库/服务架构中的位置。随后，在 13.2 节中，我们将确定需要实现哪些控制器。在接下来的章节中，我们将开始实现
    `FlightController`（13.3 节）并探讨如何将 HTTP 请求路由到我们的端点（13.4 节）。
- en: Figure 13.1 shows where are in the scheme of the book.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 展示了我们在本书架构中的位置。
- en: '![](../Images/13_01.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1](../Images/13_01.png)'
- en: Figure 13.1 In the previous chapters, we implemented the database access, repository,
    and service layers. In this chapter, we’ll start to implement all controllers
    needed for our service.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 在前面的章节中，我们实现了数据库访问、仓库和服务层。在本章中，我们将开始实现我们服务所需的所有控制器。
- en: After this chapter, we are only one more chapter away from having a fully implemented
    service that adheres to the API specification given to us by FlyTomorrow. In the
    next chapter, we’ll finish up by wrapping up our controllers and diving into acceptance
    testing with Swagger so we can prove we did our work correctly.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章节之后，我们只需再有一章就能拥有一个完全实现且遵循 FlyTomorrow 给出的 API 规范的服务。在下一章中，我们将通过封装我们的控制器并使用
    Swagger 进行验收测试来完成工作，以证明我们正确地完成了工作。
- en: 13.1 The controller class within the repository/service pattern
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 仓库/服务模式中的控制器类
- en: In section 5.2.4, I introduced you to the repository/service pattern. We have
    used this pattern throughout the book to implement the new FlyingDutchmanAirlines
    service with much success. But now that we are at the controller layer, you may
    ask, how does the controller fit into this pattern? After all, it is the repository/service
    pattern, not the controller/service/repository pattern.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 5.2.4 节中，我向您介绍了仓库/服务模式。我们一直在本书中使用这个模式，成功地实现了新的 FlyingDutchmanAirlines 服务。但现在我们到了控制器层，你可能想知道控制器如何融入这个模式？毕竟，这是仓库/服务模式，而不是控制器/服务/仓库模式。
- en: Sometimes a name can be misleading. One of my biggest pet peeves is when something
    (a method name or an architecture) is named incorrectly or incompletely. Unfortunately,
    I did not name this pattern, but if I had, it would be the “controller/ repository/service
    pattern.” Heck, perhaps even the controller/repository/service /database layer
    pattern, but that is even more of a mouthful. So where does the controller layer
    fit into the repository/service pattern?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候一个名称可能会误导人。我最痛恨的事情之一就是当某个东西（一个方法名称或一个架构）被错误或不完整地命名。不幸的是，我没有命名这个模式，但如果我命名了，它将是“控制器/仓库/服务模式”。嘿，也许甚至是控制器/仓库/服务/数据库层模式，但这更让人难以吞咽。那么控制器层在仓库/服务模式中是如何定位的呢？
- en: 'The quick answer is this: a controller is typically the public-facing, topmost
    layer in the repository/service pattern. This is not surprising: the controller
    is normally the topmost layer for a service because it is typically the only point
    exposed to clients, as shown in figure 13.2\. Examples of external systems include
    the FlyTomorrow website, a microservice requesting information for further processing,
    or a desktop application trying to load database information. Any consumer outside
    of your codebase is an external system. There is a caveat here: this assumes we
    live in a world where our service acts as a “server” for an external system calling
    our service. If you need to call any external HTTP services as part of the work
    in this service, you may end up doing this in the service or repository layer.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回答是：控制器通常是仓库/服务模式中面向公众、最顶层的一层。这并不奇怪：控制器通常是服务最顶层，因为它通常是唯一暴露给客户端的点，如图13.2所示。外部系统的例子包括FlyTomorrow网站、一个请求信息以进行进一步处理的微服务，或者一个尝试加载数据库信息的桌面应用程序。任何位于你的代码库之外的消费者都是一个外部系统。这里有一个注意事项：这假设我们生活在一个我们的服务作为外部系统调用我们的服务的“服务器”的世界。如果你需要在这个服务的工作中调用任何外部HTTP服务，你可能会在服务或仓库层中这样做。
- en: '![](../Images/13_02.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/13_02.png)'
- en: Figure 13.2 A controller is the outermost layer of our architecture and interacts
    with any potential external systems, if the service acts as a server. With this
    model in mind, we can easily model our repositories, services, and controllers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 控制器是我们架构的最外层，如果服务作为服务器，则与任何潜在的外部系统交互。有了这个模型在心中，我们可以轻松地建模我们的仓库、服务和控制器。
- en: So far, we have implemented the inner circles of our service. Right now, however,
    if FlyTomorrow were to send a request for information about all the flights in
    the database, we would have no way to accept that request. Consequently, without
    fully implemented controllers, nobody would use our service. You can have the
    cleanest, most performant, secure service, but if nobody uses (or can use) your
    product, it isn’t good enough.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了我们服务的内层圈。然而，现在如果FlyTomorrow要发送一个关于数据库中所有航班的请求，我们将无法接受这个请求。因此，如果没有完全实现的控制器，没有人会使用我们的服务。你可以拥有最干净、性能最高、最安全的服务，但如果没有人使用（或能够使用）你的产品，那就还不够好。
- en: 'A controller exposes methods we call *endpoint methods*. These methods accept
    HTTP requests and return HTTP responses. An HTTP response usually comprises the
    following three key items, as shown in figure 13.3:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器公开了我们称之为*端点方法*的方法。这些方法接受HTTP请求并返回HTTP响应。HTTP响应通常包含以下三个关键项，如图13.3所示：
- en: '*An HTTP status code like 200 (OK), 404 (Not Found), or 500 (Internal Server
    Error)* —The controller determines this status code based on the state of the
    service after processing the request.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个HTTP状态码，如200（OK）、404（未找到）或500（内部服务器错误）* ——控制器根据处理请求后的服务状态确定这个状态码。'
- en: '*Headers* —This is a collection of key-value pairs that often include the type
    of returned data and whether there are any cross-origin resource sharing (CORS)
    instructions. Unless you need to pass along an odd header, the ASP.NET can often
    take care of this step for you automatically.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*头部* ——这是一个键值对的集合，通常包括返回数据的类型以及是否有任何跨源资源共享（CORS）指令。除非你需要传递一个奇怪的头部，否则ASP.NET通常可以自动为你处理这一步骤。'
- en: '*A body* —Where appropriate, you can return data to the consumer. Often this
    data is returned as a JSON value and goes along with a 200 (OK) status code. Some
    HTTP status codes don’t allow for returning data (e.g., the 201 status code, which
    means “no content”). This data is returned in the “body” section.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个主体* ——在适当的情况下，你可以向消费者返回数据。通常，这些数据以JSON值的形式返回，并伴随200（OK）状态码。某些HTTP状态码不允许返回数据（例如，201状态码，表示“无内容”）。这些数据在“主体”部分返回。'
- en: '![](../Images/13_03.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/13_03.png)'
- en: Figure 13.3 An HTTP response typically comprises an HTTP status code, headers,
    and a body. We use these fields to return appropriate information to the caller.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 HTTP响应通常包含HTTP状态码、头部和主体。我们使用这些字段向调用者返回适当的信息。
- en: 'For more information on HTTP and web service interaction, see Barry Pollard’s
    *HTTP/2 in Action* (Manning, 2019). If you want to learn more about developing
    the architecture that goes along with creating multiple services interacting with
    each other as external services, see Chris Richardson’s *Microservices Patterns*
    (Manning, 2018), Sam Newman’s *Building Microservices: Designing Fine-Grained
    Systems* (O’Reilly Media, 2015), or Christian Harsdal Gammelgaard’s *Microservices
    in .NET Core* (2nd edition; Manning, 2020).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '关于 HTTP 和 Web 服务交互的更多信息，请参阅 Barry Pollard 的 *HTTP/2 in Action*（Manning，2019）。如果您想了解更多关于创建多个服务相互交互作为外部服务的架构开发，请参阅
    Chris Richardson 的 *Microservices Patterns*（Manning，2018），Sam Newman 的 *Building
    Microservices: Designing Fine-Grained Systems*（O''Reilly Media，2015），或 Christian
    Harsdal Gammelgaard 的 *Microservices in .NET Core*（第 2 版；Manning，2020）。'
- en: 13.2 Determining what controllers to implement
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 确定要实现的控制器
- en: As we implemented the service layer classes, we talked about how to determine
    whether a service layer class was necessary. We realized that we need to figure
    out whether we need a controller that calls said service layer. So, we can repeat
    that exercise once again and quickly figure out what controllers we need to implement.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现服务层类时，我们讨论了如何确定是否需要服务层类。我们意识到我们需要弄清楚是否需要一个调用该服务层的控制器。因此，我们可以再次进行这项练习，并快速确定我们需要实现哪些控制器。
- en: 'Once again, we look at the endpoints specified in the contract between FlyTomorrow
    and Flying Dutchman Airlines (first introduced in section 3.1 and 3.2, and shown
    in figure 13.4):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看 FlyTomorrow 和 Flying Dutchman Airlines 之间的合同中指定的端点（首次在 3.1 和 3.2 节中介绍，并在图
    13.4 中显示）：
- en: '`GET /Flight`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /Flight`'
- en: '`GET /Flight/{FlightNumber}`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /Flight/{FlightNumber}`'
- en: '`POST /Booking/{FlightNumber}`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST /Booking/{FlightNumber}`'
- en: '![](../Images/13_04.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13_04.png)'
- en: Figure 13.4 The endpoints required by the contract with FlyTomorrow. We need
    to implement our controllers to reflect these endpoints.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 FlyTomorrow 合同所需的端点。我们需要实现我们的控制器来反映这些端点。
- en: These endpoints form the basis of all we have done so far. In the database access,
    repository, and service layers, we did not have to do much with the actual endpoints,
    but that changes when we talk about controllers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些端点构成了我们迄今为止所做一切的基础。在数据库访问、存储库和服务层中，我们实际上并不需要与端点进行太多操作，但当谈到控制器时，情况就不同了。
- en: To determine what controllers we need to implement, we ask ourselves, what entities
    can we see in the required endpoints, as shown in figure 13.5? Remember, when
    we talk about entities, we’re talking about database entities (reflected in the
    codebase by model classes). Take a couple of seconds to look over the endpoints
    and see what you come up with. We have done this exercise before, so it shouldn’t
    be too challenging.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定我们需要实现哪些控制器，我们问自己，在所需的端点中我们可以看到哪些实体，如图 13.5 所示？记住，当我们谈论实体时，我们是在谈论数据库实体（通过代码库中的模型类反映）。花几分钟时间查看端点，看看你能得出什么结论。我们之前已经做过这个练习，所以这不应该太具挑战性。
- en: '![](../Images/13_05.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13_05.png)'
- en: Figure 13.5 The required endpoints with the potential controllers identified.
    We can determine what controllers we need to implement by looking at what entities
    appear in the required endpoints.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 确定所需端点及其潜在控制器。我们可以通过查看所需端点中出现的实体来确定需要实现哪些控制器。
- en: If we look at the first endpoint (`GET /Flight`), we see the `Flight` entity
    in the path. This is a clear-cut sign that we should implement a `FlightController`
    class. Similarly, when we look at the `GET /Flight/{FlightNumber}` endpoint, we
    realize we need a `FlightController` class for that one as well. That leaves the
    `POST /Booking/{FlightNumber}`, which shows the need for a `BookingController`.
    In the rest of this chapter, we’ll implement the `FlightController`. In the next
    chapter, we’ll fully implement the `BookingController`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看第一个端点（`GET /Flight`），我们会看到路径中的 `Flight` 实体。这是一个明确的迹象，表明我们应该实现一个 `FlightController`
    类。同样，当我们查看 `GET /Flight/{FlightNumber}` 端点时，我们意识到我们也需要一个 `FlightController` 类来处理它。这留下了
    `POST /Booking/{FlightNumber}`，它表明我们需要一个 `BookingController`。在本章的其余部分，我们将实现 `FlightController`。在下一章中，我们将完全实现
    `BookingController`。
- en: But what about controllers for the `Airport` and `Customer` entities? Because
    no endpoint paths need to go to a controller for the `Airport` and `Customer`
    entities, we do not need them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但关于 `Airport` 和 `Customer` 实体的控制器呢？因为不需要端点路径指向 `Airport` 和 `Customer` 实体的控制器，所以我们不需要它们。
- en: 13.3 Implementing the FlightController
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 实现 FlightController
- en: 'In section 13.1 we talked about the controller layer in our architecture. In
    section 13.2 we took that knowledge and discussed which controllers we need to
    implement. In this section, we’ll go ahead and actually implement a controller.
    How does one implement a controller layer class? Well, you know the drill: we
    first create our two skeleton classes. In this section, we’ll implement the `FlightController`
    class, so let’s create the `FlightController` and `FlightControllerTests` classes,
    shown in figure 13.6.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 13.1 节中，我们讨论了我们的架构中的控制器层。在 13.2 节中，我们利用了这些知识，讨论了我们需要实现哪些控制器。在本节中，我们将实际实现一个控制器。如何实现控制器层类？嗯，你知道的：我们首先创建我们的两个骨架类。在本节中，我们将实现
    `FlightController` 类，所以让我们创建 `FlightController` 和 `FlightControllerTests` 类，如图
    13.6 所示。
- en: '![](../Images/13_06.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 13_06](../Images/13_06.png)'
- en: 'Figure 13.6 We add two skeleton classes: `FlightController` and `FlightControllerTests`.
    These form the basis of our `FlightController` implementation.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 我们添加了两个骨架类：`FlightController` 和 `FlightControllerTests`。这些构成了我们 `FlightController`
    实现的基础。
- en: 'With the skeleton classes in place, we have to do only one additional thing
    before we can talk about how to create controller methods that are accessible
    from external systems: the `FlightController` needs to derive from the `Controller`
    class. This base class, shown in the next code sample, provides us with standard
    methods that we can use to return HTTP data to the consumer and allows us to set
    up routing to our endpoints:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好骨架类之后，在我们可以讨论如何创建外部系统可访问的控制器方法之前，我们还需要做一件额外的事情：`FlightController` 需要从 `Controller`
    类派生。这个基类，在接下来的代码示例中展示，为我们提供了标准方法，我们可以使用这些方法向消费者返回 HTTP 数据，并允许我们设置路由到我们的端点：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, we need to implement the following three pieces so we can hit our endpoint
    by an external system at run time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要实现以下三个部分，以便在运行时通过外部系统访问我们的端点。
- en: The `IActionResult` interface (section 13.3.1)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IActionResult` 接口（13.3.1 节）'
- en: Dependency injection in middleware (section 13.3.2)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件中的依赖注入（13.3.2 节）
- en: Routing endpoints (section 13.4)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由端点（13.4 节）
- en: After this chapter, we will have implemented the `FlightController`, along with
    the appropriate unit tests, and will be able to hit the endpoints through an external
    system simulator such as Postman or cURL.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，我们将实现 `FlightController` 以及相应的单元测试，并将能够通过外部系统模拟器（如 Postman 或 cURL）来访问端点。
- en: 13.3.1 Returning HTTP responses with the IActionResult interface (GetFlights)
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.1 使用 IActionResult 接口返回 HTTP 响应（GetFlights）
- en: In section 13.2, we discussed the composition of a typical HTTP response. Most
    of the time, an HTTP response contains an HTTP status code, headers, and a body
    containing some data. Think about how we would return something like that from
    a method. No primitive data types hold this information. We could use the lowest
    common denominator of any type in C#—`object`—but that would be a lazy workaround
    and somewhat tricky to deal with because it is still not in an acceptable form
    for the HTTP transport.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 13.2 节中，我们讨论了典型 HTTP 响应的组成。大多数情况下，HTTP 响应包含一个 HTTP 状态码、头部和一个包含一些数据的主体。想想我们如何从一个方法中返回这样的内容。没有原始数据类型可以持有这些信息。我们可以使用
    C# 中任何类型的最低共同分母——`object`——但这将是一个懒惰的解决方案，并且处理起来有些棘手，因为它仍然不是 HTTP 传输可接受的格式。
- en: The solution is ASP.NET’s `IActionResult` interface. The `IActionResult` interface
    is implemented by classes such as `ActionResult` and `ContentResult`, but in practice,
    we can leave the determination of which specific class to use to ASP.NET. This
    is another example of polymorphism and something we call “coding to interfaces.”
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是 ASP.NET 的 `IActionResult` 接口。`IActionResult` 接口由 `ActionResult` 和 `ContentResult`
    等类实现，但在实践中，我们可以将确定使用哪个具体类的决定留给 ASP.NET。这是多态的另一个例子，我们称之为“编码到接口”。
- en: '| ![](../Images/ThumbsUp.png)   |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| ![点赞](../Images/ThumbsUp.png)   |'
- en: Coding to interfaces
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 编码到接口
- en: In section 8.4, we talked about using polymorphism and the Liskov substitution
    principle. These allow us to write code that is generic instead of constrained
    to one particular implementation. To drive this point home, let me show you an
    example.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在 8.4 节中，我们讨论了使用多态和 Liskov 替换原则。这些原则允许我们编写通用的代码，而不是局限于特定的实现。为了说明这一点，让我给你举一个例子。
- en: Let’s imagine you are writing a service for a book publisher in the mid-2000s.
    The era of e-books is on the rise, but your code did not account for this possibility.
    As a result, your code is tightly coupled to the `Book` class. In the following
    snippet, the author finished writing the book, and we want to send it to the printer:[^a](#pgfId-1236586)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象你正在为2005年左右的图书出版社编写一个服务。电子书的时代正在兴起，但你的代码没有考虑到这一点。结果，你的代码与`Book`类紧密耦合。在下面的代码片段中，作者完成了书籍的写作，我们想要将其发送到打印机：[^a](#pgfId-1236586)
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code works fine when dealing only with regular, paper books. But what
    happens if we want to “print” an e-book? Well, the method does not accept a type
    of `EBook` as an input parameter. If we wrote the `BookToPrinter` method using
    an interface for the parameter’s type instead of a concrete type, our work would
    have been easier, as shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当仅处理常规、纸质书籍时，这段代码运行正常。但如果我们想“打印”一本电子书会发生什么？嗯，该方法不接受`EBook`类型的输入参数。如果我们使用参数类型的接口而不是具体类型来编写`BookToPrinter`方法，我们的工作会更容易，如下所示：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, printing an e-book does not make much sense. We may want to take things
    one step further and generalize the actual “printing” of the book, regardless
    of its medium type, as shown next:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打印电子书并没有太多意义。我们可能想要更进一步，将书籍的实际“打印”过程泛化，无论其介质类型如何，如下所示：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This way, we abstract away the implementation details to the derived classes
    of the `IWork` interface. The `ProduceWork` method does not care whether the book’s
    medium is paper or e-book. Implementing logic to change the state of an object
    inside the actual object is an important tenet of object-oriented design and makes
    code more readable and maintainable. For an excellent discussion on this and how
    it ties into the Open/Closed Principle, see Robert C. Martin and Micah Martin’s
    *Agile Principles, Patterns, and Practices in C#* (Prentice Hall, 2006).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们将实现细节抽象到`IWork`接口的派生类中。`ProduceWork`方法不关心书籍的介质是纸张还是电子书。在对象内部实现改变对象状态的逻辑是面向对象设计的一个重要原则，这使得代码更易于阅读和维护。关于这一点及其如何与开放/封闭原则联系起来的精彩讨论，请参阅Robert
    C. Martin和Micah Martin的《敏捷原则、模式与实践》（Prentice Hall，2006年）。
- en: ^a At the time of writing, this joyous occasion seems still very far out for
    this book.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ^a 在撰写本文时，这个愉快的时刻似乎对这个书来说还非常遥远。
- en: '|'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Let’s get cracking with our first endpoint: `/GET Flight`. We know our return
    type (`IActionResult`), but what should the access modifier, name, and arguments
    be? Because ASP.NET uses reflection to use the method, the access modifier should
    be public. As for the name, a good way to name endpoint methods is to take the
    HTTP action (`GET` in this case) and append the entity (`Flight` for us), making
    the term plural where necessary: `GetFlights`. That leaves us with the input parameter.
    This is a `GET` action, so we do not need an input parameter, as shown in the
    next code snippet. `GET` actions are not allowed to pass in any data to specific
    methods per the HTTP specification, so that makes our lives a bit easier at this
    point.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的第一个端点：`/GET Flight`。我们知道我们的返回类型是`IActionResult`，但访问修饰符、名称和参数应该是什么？因为ASP.NET使用反射来调用方法，所以访问修饰符应该是public。至于名称，一个给端点方法命名的好方法是取HTTP动作（在这种情况下是`GET`）并附加实体（对我们来说是`Flight`），在必要时使术语变为复数：`GetFlights`。这样我们就剩下了输入参数。这是一个`GET`动作，所以我们不需要输入参数，如下一代码片段所示。根据HTTP规范，不允许`GET`动作向特定方法传递任何数据，这使得我们在这个阶段的生活变得容易一些。
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What do we need to do to return some JSON data? As mentioned in section 13.1,
    in most situations we do not need to explicitly specify any header information,
    so that leaves the status code and any body data. The ASP.NET library gives us
    an easy-to-use static class that we can return and use as an `IActionResult`:
    `StatusCode`. This class lives in the `Controller` base class that `FlightController`
    derives from. At first glance (and judging by its name), you would think the `StatusCode`
    allows us to return only a status code and no body, but nothing is further from
    the truth! To illustrate, let’s return an HTTP status code of 200 (OK) and a string
    `“Hello, World!”` from the `GetFlights` method as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做什么来返回一些JSON数据？如第13.1节所述，在大多数情况下，我们不需要显式指定任何头信息，这样就留下了状态码和任何正文数据。ASP.NET库为我们提供了一个易于使用的静态类，我们可以返回并使用它作为`IActionResult`：`StatusCode`。这个类位于`FlightController`继承的`Controller`基类中。乍一看（并且根据其名称），你会认为`StatusCode`只允许我们返回状态码而没有正文，但事实并非如此！为了说明这一点，让我们从`GetFlights`方法返回HTTP状态码200（OK）和字符串`“Hello,
    World!”`，如下所示：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That code compiles and returns exactly what we want. There is an additional
    tip here that bears understanding: instead of using the magic (hardcoded) number
    of 200 for the status code, we should use the `HttpStatusCode` enum and cast its
    value to an integer. It is a little bit more code, but it removes the magic number,
    as shown in the following example. For more information on magic numbers and why
    they are bad, see section 9.6.1.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以编译并返回我们想要的结果。这里有一个额外的技巧需要理解：我们不应该使用硬编码的200这个状态码，而应该使用`HttpStatusCode`枚举并将其值转换为整数。这会稍微多写一点代码，但它消除了硬编码的数字，如下面的示例所示。有关魔法数字及其为什么不好的更多信息，请参阅第9.6.1节。
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Unfortunately, this code doesn’t satisfy our requirements. We need to return
    a collection of information on all the flights in the database from this endpoint
    method. We already implemented the service layer method to support this effort
    and created the `FlightView` class. In the `FlightController.GetFlights` method,
    we want to call that service layer method and return the collection along with
    a status code of 200 (OK). If something goes awry and the service layer throws
    an `Exception`, we want to return a status code of 500 (Internal Server Error)
    with no further data.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这段代码无法满足我们的需求。我们需要从这个端点方法返回数据库中所有航班的详细信息集合。我们已经实现了服务层方法来支持这项工作，并创建了`FlightView`类。在`FlightController.GetFlights`方法中，我们希望调用这个服务层方法，并返回集合以及状态码200（OK）。如果出现问题，服务层抛出`Exception`，我们希望返回状态码500（内部服务器错误）且不返回其他数据。
- en: Before we move on, let’s add a unit test, shown in the next listing, that verifies
    our expectations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们添加一个单元测试，如下一列表所示，以验证我们的预期。
- en: Listing 13.1 `GetFlights_Success` unit test, iteration 1
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.1 `GetFlights_Success`单元测试，第1次迭代
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Instantiates an instance of FlightController
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 实例化一个`FlightController`对象
- en: ❷ Mimics an HTTP GET call to /Flight, and casts a return to ObjectResult
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 模拟对/Flight的HTTP GET调用，并将返回值转换为`ObjectResult`
- en: ❸ Makes sure the HTTP response is not null
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 确保HTTP响应不为空
- en: ❹ Verifies the HTTP response has a status code of 200
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 验证HTTP响应的状态码为200
- en: ❺ Verifies the expected body exists in the HTTP response
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 验证预期的内容存在于HTTP响应中
- en: Because the `FlightController.GetFlights` method returns a type of `IActionResult`,
    and we cannot access the status code and body values directly from the interface,
    we cast the response to an `ObjectResult` type. The `ObjectResult` class implements
    the `IActionResult` interface, so we can downcast the return to the derived class.
    When we *downcast* something, we use the polymorphic relationship between two
    classes and use the parent as the derived class. It is the inverse of the Liskov
    substitution principle.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`FlightController.GetFlights`方法返回的是`IActionResult`类型，我们不能直接从接口访问状态码和正文值，所以我们将响应转换为`ObjectResult`类型。`ObjectResult`类实现了`IActionResult`接口，因此我们可以将返回值向下转换为派生类。当我们进行*向下转换*时，我们使用两个类之间的多态关系，并使用父类作为派生类。这是Liskov替换原则的逆过程。
- en: To adjust the logic in the `GetFlights` method so we can use the `FlightService`
    class to get information on all the flights in the database, we need to have access
    to an instance of `FlightService`. It should come as no surprise that we use dependency
    injection once again!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调整`GetFlights`方法中的逻辑，以便我们可以使用`FlightService`类获取数据库中所有航班的详细信息，我们需要访问`FlightService`的一个实例。我们再次使用依赖注入应该不会让人感到惊讶！
- en: 13.3.2 Injecting dependencies into a controller using middleware
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.2 使用中间件将依赖项注入到控制器中
- en: In the previous chapters, we used dependency injection to kick the can of instantiating
    new instances of said dependency down the road. For the repository layer, we used
    dependency injection to not worry about instantiating an instance of type `FlyingDutchmanAirlinesContext`.
    Similarly, in the service layer, we injected instances of repository layer classes.
    Finally, in the controller we are implementing in this chapter, we need to use
    an injected instance of `FlightService`. But where do these instances come from?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了依赖注入来推迟创建这种依赖项的新实例。对于仓储层，我们使用依赖注入来不必担心实例化`FlyingDutchmanAirlinesContext`类型的实例。同样，在服务层，我们注入了仓储层类的实例。最后，在本章中我们实现的控制器中，我们需要使用注入的`FlightService`实例。但这些实例从哪里来呢？
- en: We are finally at the point where we have to actually set up these dependencies.
    We do this by adding some logic to what we call middleware. *Middleware* is any
    code that can help process an HTTP request. You can think of middleware as a collection
    of individual middleware pieces, strung together in a chain, as shown in figure
    13.7.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终到了必须实际设置这些依赖项的阶段。我们通过向所谓的中间件中添加一些逻辑来实现这一点。*中间件* 是任何可以帮助处理 HTTP 请求的代码。你可以将中间件视为一系列单独的中间件组件，如图
    13.7 所示，这些组件被串联在一起。
- en: '![](../Images/13_07.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片 13_07](../Images/13_07.png)'
- en: Figure 13.7 An example of multiple middleware components and how they are executed.
    Middleware components are executed linearly and are often chained together to
    create the required processing story.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 多个中间件组件及其执行方式的示例。中间件组件是线性执行的，并且通常被链在一起以创建所需的处理故事。
- en: Before an HTTP request enters a controller (and proceeds down the architectural
    layers), the CLR executes any provided middleware, as shown in figure 13.8\. Examples
    of middleware components are routing (which we’ll see more of in section 13.4),
    authentication, and dependency injection.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 请求进入控制器（并继续向下通过架构层）之前，CLR 会执行任何提供的中间件，如图 13.8 所示。中间件组件的例子包括路由（我们将在第 13.4
    节中看到更多关于路由的内容）、身份验证和依赖注入。
- en: '![](../Images/13_08.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片 13_08](../Images/13_08.png)'
- en: Figure 13.8 Middleware takes place after receiving an HTTP request but before
    executing the controller (and subsequent service and repository) code. Examples
    of middleware components are routing, authentication, and dependency injection.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 中间件在接收到 HTTP 请求后执行控制器（以及后续的服务和存储库）代码之前发生。中间件组件的例子包括路由、身份验证和依赖注入。
- en: Typically, we find middleware code in the `Startup` class for ASP.NET services.
    In section 5.2 (and as shown in listing 13.2), we added code to the `Startup`
    class that allowed us to use controllers and routing with endpoints. These are
    examples of middleware code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会在 ASP.NET 服务的 `Startup` 类中找到中间件代码。在第 5.2 节（以及如图 13.2 所示），我们在 `Startup`
    类中添加了代码，使我们能够使用控制器和端点路由。这些都是中间件代码的例子。
- en: Listing 13.2 The `Startup` class
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.2 `Startup` 类
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: NOTE Injecting dependencies by writing middleware is not the only way to achieve
    DI in C#. Plenty of third-party (open source) DI frameworks for C# are out there,
    such as Autofac, Castle Windsor, and Ninject. For more information on some of
    these external frameworks, see Mark Seemann’s *Dependency Injection in .NET* (Manning,
    2011).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：通过编写中间件来注入依赖项不是在 C# 中实现依赖注入的唯一方法。市面上有大量的第三方（开源）C# 依赖注入框架，例如 Autofac、Castle
    Windsor 和 Ninject。有关这些外部框架的更多信息，请参阅 Mark Seemann 的 *Dependency Injection in .NET*（Manning，2011）。
- en: 'We can add dependencies to be injected in the `ConfigureServices` method in
    the following three ways:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下三种方式在 `ConfigureServices` 方法中添加要注入的依赖项：
- en: '*Singleton* —One instance across the entire lifetime of the service'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单例* —在整个服务生命周期中只有一个实例'
- en: '*Scoped* —One instance across the lifetime of a request'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*作用域* —在整个请求生命周期中只有一个实例'
- en: '*Transient* —A new instance every time a dependency is used'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*瞬态* —每次使用依赖项时都会创建一个新的实例'
- en: Using a singleton dependency to guarantee the same instance every time
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单例依赖项来保证每次都使用相同的实例
- en: Adding an injected dependency with the singleton option mimics a singleton design
    pattern. In a singleton design pattern, you have only one instance per application.
    The CLR reuses this instance repeatedly for as long as your application runs.
    The instance may start as a null pointer, but at first use, the code instantiates
    it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单例选项添加注入的依赖项模仿了单例设计模式。在单例设计模式中，每个应用程序只有一个实例。CLR 会重复使用此实例，直到应用程序运行结束。实例可能最初是一个空指针，但在第一次使用时，代码会实例化它。
- en: When we use a singleton dependency with dependency injection, the injected instance
    is always the same, no matter when or where it is injected. For example, if we
    were to add an injected singleton of type `BookingRepository`, we would always
    use the same instance for every request coming through our service.[¹](#pgfId-1227107)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用单例依赖项进行依赖注入时，注入的实例总是相同的，无论何时何地注入。例如，如果我们添加一个类型为 `BookingRepository` 的注入单例，我们将在每个通过我们服务的请求中始终使用相同的实例。[¹](#pgfId-1227107)
- en: Using a scoped dependency to guarantee the same instance on a per-request basis
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用作用域依赖项来保证每个请求的实例相同
- en: With a scoped dependency, every HTTP request instantiates its own version of
    the dependency that needs injecting. ASP.NET uses this instance for the entire
    request life cycle but instantiates a new instance for every new request that
    enters the hallowed halls of the service.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用作用域依赖项，每个HTTP请求都会实例化其自己的依赖项版本，需要注入。ASP.NET在整个请求生命周期中使用此实例，但为每个进入服务神圣殿堂的新请求实例化一个新的实例。
- en: For example, if we were to instantiate a `FlightRepository` instance and we
    inject the `FlightRepository` type in two service layer classes, both service
    layer classes would receive (and operate on) the same instance of `FlightRepository`,
    as long as we are dealing with the same HTTP request.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们实例化一个`FlightRepository`实例，并在两个服务层类中注入`FlightRepository`类型，只要我们处理的是同一个HTTP请求，这两个服务层类都会接收到（并操作）同一个`FlightRepository`实例。
- en: Using a transient dependency (DI) to always get a new instance
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用瞬态依赖项（DI）始终获取新实例
- en: Transient dependencies in DI are perhaps the most common way of dealing with
    dependency injection. When we add a transient dependency, every time that dependency
    needs to be injected, ASP.NET instantiates a new instance. This guarantees that
    we work on a fresh copy of the injected class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在DI中，瞬态依赖项可能是处理依赖注入最常见的方式。当我们添加瞬态依赖项时，每次该依赖项需要注入时，ASP.NET都会实例化一个新的实例。这保证了我们始终在注入类的全新副本上工作。
- en: Because transient dependencies are the most common, and easiest to use, types
    of dependency injection, we shall fall in line. To add a transient dependency
    to the `ConfigureServices` method in the `Startup` class, use the `services.[dependencyType]([Requested
    Type], [Injected Type])` syntax.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因为瞬态依赖项是使用依赖注入最常见的、最容易使用的方式，我们将遵循这一做法。要在`Startup`类的`ConfigureServices`方法中添加瞬态依赖项，使用`services.[dependencyType]([Requested
    Type], [Injected Type])`语法。
- en: 'Let’s see how we do this for the `FlightService` dependency for the `FlightController`
    class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是如何为`FlightController`类的`FlightService`依赖项实现这一点的：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We add the type of `FlightService` as both parameters to the `AddTransient`
    call. This tells us we want to have a type of `FlightService` added to the internal
    collection of instances whenever we request a type of `FlightService` to be injected.
    It’s a bit roundabout, but it is what we have to do. This is all you need to do
    to make sure the CLR can provide injected instances when you need them. Of course,
    we also want to add the dependencies that the `FlightService` class itself expects—`FlightRepository`
    and `AirportRepository`—as shown next:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`FlightService`的类型作为`AddTransient`调用的两个参数。这告诉我们，每当请求注入`FlightService`类型时，我们希望将`FlightService`类型添加到内部实例集合中。这有点绕，但这是我们必须要做的。这就是你需要做的所有事情，以确保CLR在你需要时可以提供注入的实例。当然，我们还想添加`FlightService`类本身期望的依赖项——`FlightRepository`和`AirportRepository`——如下所示：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Following that, what dependencies do we need to provide for the `FlightRepository`
    and `AirportRepository` classes? Both require the same dependency—an instance
    of the `FlyingDutchmanAirlinesContext` class, shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们需要为`FlightRepository`和`AirportRepository`类提供哪些依赖项？这两个类都需要相同的依赖项——`FlyingDutchmanAirlinesContext`类的一个实例，如下所示：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now add the injected dependency to the `FlightController` and call the
    `FlightService` as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将注入的依赖项添加到`FlightController`中，并按如下方式调用`FlightService`：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What are we trying to accomplish with the `GetFlights` method? We want to return
    to the caller a JSON response that contains information on all the flights, right?
    Let’s double-check with the OpenAPI specification we got from FlyTomorrow, as
    shown in figure 13.9\. There, we see that we have the following three return paths
    for the `GET /Flight` endpoint:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`GetFlights`方法试图实现什么？我们希望返回给调用者一个包含所有航班信息的JSON响应，对吗？让我们通过FlyTomorrow提供的OpenAPI规范来双重检查，如图13.9所示。在那里，我们看到`GET
    /Flight`端点有以下三个返回路径：
- en: The success case that returns an HTTP code of 200 along with information on
    all the flights in the database
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功情况返回HTTP代码200，并包含数据库中所有航班的详细信息
- en: A status code of 404 if no flights were found
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有找到航班，返回状态码404
- en: A status code of 500 for all other errors
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于所有其他错误，返回状态码500
- en: '![](../Images/13_09.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13_09.png)'
- en: Figure 13.9 The required response from the `GET` `/Flight` endpoint. This is
    a screenshot from a generated OpenAPI specification.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 `GET` `/Flight`端点所需响应。这是从生成的OpenAPI规范中截取的屏幕截图。
- en: Let’s work on the success case first, as shown in the following listing, and
    use the injected `FlightService` to iterate over the returned data from the `FlightService
    .GetFlights` method, wrapped in a `try-catch` block so we can catch any potential
    thrown errors.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先处理成功的情况，如下面的列表所示，并使用注入的`FlightService`遍历`FlightService.GetFlights`方法返回的数据，用`try-catch`块包装起来，这样我们就可以捕获任何潜在的抛出错误。
- en: Listing 13.3 `GetFlights` calling the `FlightService`
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.3 `GetFlights`调用`FlightService`
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Creates a Queue<FlightView> to hold returned FlightView instances
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个Queue<FlightView>来存储返回的FlightView实例
- en: ❷ Processes each FlightView as they come in from the service class
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 处理从服务类接收到的每个FlightView
- en: ❸ Adds flights to the queue
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将航班添加到队列中
- en: Because the `FlightService.GetFlights` method returns an `IAsyncEnumerable <FlightView>`
    and uses the `yield return` keywords, we don’t have to wait for all the processing
    to be done before being able to see the fruits of our labor. As the database returns
    flights and the service layer populates `FlightView`s, the controller layer receives
    the instances and adds them to a `Queue` data structure.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`FlightService.GetFlights`方法返回一个`IAsyncEnumerable<FlightView>`并使用`yield return`关键字，所以我们不需要等待所有处理完成才能看到我们的劳动成果。随着数据库返回航班，服务层填充`FlightView`，控制层接收这些实例并将它们添加到`Queue`数据结构中。
- en: 'How do we structure this queue of `FlightView` instances so we can return its
    contents along with an HTTP code of 200 to the user? The magic of ASP.NET, C#,
    and .NET makes this incredibly easy. Remember how we returned an HTTP code of
    200 along with a body that read `“Hello, World!”` simply by adding those two as
    argument values to the `StatusCode` constructor in section 13.3.1? We can repeat
    this exercise, swapping out the `“Hello, World!”` string for our queue as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何构建这个`FlightView`实例队列，以便我们可以返回其内容以及HTTP状态码200给用户？ASP.NET、C#和.NET的魔力使得这变得非常简单。记得我们在13.3.1节中如何通过将两个参数值添加到`StatusCode`构造函数中，简单地返回HTTP状态码200以及一个读取为`“Hello,
    World!”`的正文吗？我们可以重复这个练习，将`“Hello, World!”`字符串替换为我们的队列，如下所示：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Creates a Queue<FlightView> to hold returned FlightView instances
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个Queue<FlightView>来存储返回的FlightView实例
- en: ❷ Adds flights to the queue
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将航班添加到队列中
- en: ❸ Processes each FlightView as it comes in from the service class
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 处理从服务类接收到的每个FlightView
- en: But are you going to take my word that this works? Of course not. We should
    update our unit test to verify that assumption. To do this, we temporarily need
    to add some returns so that the `GetFlights` method compiles. I’ll leave this
    to you because it is not important what you return, as long as it meets the return
    type requirements based on the method signature.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但你会接受我的话，认为这有效吗？当然不会。我们应该更新我们的单元测试来验证这个假设。为此，我们暂时需要添加一些返回值，以便`GetFlights`方法可以编译。我会把这个留给你，因为你的返回值不重要，只要它符合基于方法签名的返回类型要求即可。
- en: To add a unit test that verifies the `FlightController.GetFlights` method, we
    need to mock the `FlightService` class (and as a result, we also need to set up
    a parameterless constructor for `FlightService` and make sure the `FlightService
    .GetFlights` method returns a correct response). First off, we need to make the
    `FlightService.GetFlights` virtual so the Moq framework can override it. But how
    do we return an instance of type `IAsyncEnumerable<FlightView>`? We can’t simply
    instantiate that type, because you cannot instantiate types based on an interface
    alone. The trick here is to create a test helper method inside the test class
    that returns an `IAsyncEnumerable<FlightView>` with some mock data, as shown next.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加一个验证`FlightController.GetFlights`方法的单元测试，我们需要模拟`FlightService`类（因此，我们还需要为`FlightService`设置一个无参构造函数，并确保`FlightService.GetFlights`方法返回一个正确的响应）。首先，我们需要将`FlightService.GetFlights`设置为虚拟的，这样Moq框架才能覆盖它。但我们要如何返回一个类型为`IAsyncEnumerable<FlightView>`的实例呢？我们不能简单地实例化这个类型，因为你不能仅基于接口来实例化类型。这里的技巧是在测试类内部创建一个测试辅助方法，该方法返回一个包含一些模拟数据的`IAsyncEnumerable<FlightView>`，如下所示。
- en: Listing 13.4 Finished `GetFlights_Success` unit test
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.4 完成的`GetFlights_Success`单元测试
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Creates an instance of a mock of FlightService
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建FlightService的模拟实例
- en: ❷ Defines the FlightViews used in the mock
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义模拟中使用的FlightViews
- en: ❸ Sets up the mock to return the list of FlightViews
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置模拟以返回FlightView列表
- en: ❹ Safely casts the returned data to a Queue<FlightView>, and checks for null
    if it was a bad cast
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 安全地将返回的数据转换为Queue<FlightView>，并检查是否为null
- en: ❺ For all entries in the FlightView list, checks if the returned data contains
    the entry (LINQ)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 对于 FlightView 列表中的所有条目，检查返回的数据是否包含该条目（LINQ）
- en: ❻ Returns an IAsyncEnumerable<FlightView> with the passed-in FlightView objects
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 返回一个包含传入的 FlightView 对象的 IAsyncEnumerable<FlightView>
- en: 'Great, that test passes. All we have left to do before wrapping up this method
    is to handle the exception cases. Earlier in this section, we identified (and
    added) two error conditions: the service layer throws an exception of type `FlightNotFoundException`,
    and the service layer throws an exception. Looking at the FlyTomorrow OpenAPI
    specification (shown in figure 13.10), we see that we should return an HTTP status
    code of 404 (Not Found) when the flights are not found and an HTTP status code
    of 500 (Internal Server Error) on all other errors.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，这个测试通过了。在完成这个方法之前，我们只剩下处理异常情况。在本节前面，我们识别（并添加）了两种错误条件：服务层抛出类型为 `FlightNotFoundException`
    的异常，以及服务层抛出异常。查看 FlyTomorrow OpenAPI 规范（如图 13.10 所示），我们看到当找不到航班时，我们应该返回 HTTP 状态码
    404（未找到），在其他所有错误上返回 HTTP 状态码 500（内部服务器错误）。
- en: 'Let’s start with the 404, and add a unit test to check for this as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 404 开始，并添加以下单元测试来检查这一点：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `GetFlights_Failure_FlightNotFoundException_404` unit test does not pass
    right now. Remember, when using test-driven development, we often want to create
    a unit test before implementing the actual method logic. This gives us a chance
    to think about how we want our code to be called, further decoupling the new functionality
    from other pieces of the codebase. In our case, we need to add some logic, shown
    in the next code sample, that returns the correct `StatusCode` object when the
    controller catches a `FlightNotFoundException` instance:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetFlights_Failure_FlightNotFoundException_404` 单元测试目前没有通过。记住，在使用测试驱动开发时，我们通常希望在实现实际方法逻辑之前创建单元测试。这给了我们思考我们希望代码如何被调用的机会，进一步将新功能与其他代码库的片段解耦。在我们的情况下，我们需要添加一些逻辑，如下一代码示例所示，当控制器捕获到
    `FlightNotFoundException` 实例时，返回正确的 `StatusCode` 对象：'
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our `GetFlights_Failure_FlightNotFoundException_404` unit test now passes.
    I’m sure you can imagine what comes next: the 500 error case. We mimic the approach
    we took for the 404 and add a unit test as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `GetFlights_Failure_FlightNotFoundException_404` 单元测试现在通过了。我确信你可以想象接下来会发生什么：500
    错误情况。我们模仿了处理 404 的方法，并添加了以下单元测试：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And to make the `GetFlights_Failure_ArgumentException_500` unit test pass,
    we add the appropriate return in the `GetFlights try-catch` as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `GetFlights_Failure_ArgumentException_500` 单元测试通过，我们在 `GetFlights try-catch`
    中添加了适当的返回值如下：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And that makes the unit test pass, plus it wraps up implementing the logic for
    the `GET /Flight` endpoint. Of course, we cannot call this endpoint yet from an
    external system, but we’ll look at setting up this routing in section 13.3.5.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就使单元测试通过，并且完成了 `GET /Flight` 端点的逻辑实现。当然，我们目前还不能从外部系统调用此端点，但我们将查看在 13.3.5 节中设置此路由。
- en: 13.3.3 Implementing the GET /Flight/{FlightNumber} endpoint
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.3 实现 GET /Flight/{FlightNumber} 端点
- en: So far in this chapter, you learned about using middleware to do dependency
    injection and how to call the service layer from the controller layer while handling
    errors and providing unit tests. In section 13.3.2, we implemented the `GET /Flight`
    endpoint. Now we come to the `GET /Flight/{FlightNumber}` endpoint.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，你学习了如何使用中间件进行依赖注入，以及如何在控制器层调用服务层的同时处理错误和提供单元测试。在 13.3.2 节中，我们实现了
    `GET /Flight` 端点。现在我们来到 `GET /Flight/{FlightNumber}` 端点。
- en: 'This endpoint should return information on an individual flight when given
    a flight number. To accomplish this, we need to do the following four things:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点应在提供航班号时返回单个航班的详细信息。为了完成这个任务，我们需要做以下四件事：
- en: Get the provided flight number from the path parameter.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从路径参数中获取提供的航班号。
- en: Call the service layer to request information on the flight.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用服务层以请求航班信息。
- en: Handle any potential exceptions thrown from the service layer.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理服务层可能抛出的任何潜在异常。
- en: Return the correct information to the caller.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将正确的信息返回给调用者。
- en: 'To get the value of a path parameter, we need to do some routing magic and
    add the `FlightNumber` URL path parameter as a method parameter. In section 13.4,
    we’ll look at the routing part, but for now, it suffices for us to create a new
    method in the `FlightController` called `GetFlightByFlightNumber` that requires
    a parameter representing a flight number, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取路径参数的值，我们需要进行一些路由魔术，并将 `FlightNumber` URL 路径参数作为方法参数添加。在第 13.4 节中，我们将查看路由部分，但就目前而言，我们只需要在
    `FlightController` 中创建一个新的方法 `GetFlightByFlightNumber`，该方法需要一个表示航班号的参数，如下所示：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This sets us up to call the `FlightService`’s `GetFlightByFlightByNumber` method
    and pass along the `flightNumber` parameter. Before we move on, let’s backtrack
    a bit and get back into the good graces of the test-driven development gods (more
    specifically, Kent Beck) by adding a unit test that we can build on, as shown
    here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够调用 `FlightService` 的 `GetFlightByFlightByNumber` 方法，并传递 `flightNumber`
    参数。在我们继续之前，让我们回顾一下，通过添加一个我们可以构建的单元测试来重新获得测试驱动开发之神（更具体地说，是 Kent Beck）的青睐，如下所示：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `GetFlightByFlightNumber_Success` unit test passes just fine in its current
    state. After all, the unit test only checks to see whether it can call a method
    called `GetFlightByFlightNumber` on the `FlightController` class with an input
    parameter of type `integer`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetFlightByFlightNumber_Success` 单元测试在其当前状态下运行良好。毕竟，这个单元测试只是检查它是否能够调用 `FlightController`
    类上的名为 `GetFlightByFlightNumber` 的方法，并传入一个类型为 `integer` 的输入参数。'
- en: 'To further implement our method, let’s add the following expected behavior
    to the unit test:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步实现我们的方法，让我们在单元测试中添加以下预期行为：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As expected, the `GetFlightByFlightNumber_Success` unit test does not pass
    now. The returned data from the `FlightController.GetFlightByFlightNumber` method
    call is incorrect. But we can fix that. For the actual method implementation,
    we can use the same `try-catch` pattern we used for the `GetFlights` method and
    swap out the asynchronous `foreach` loop that calls the `IAsyncEnumerable` returned
    by `FlightService .GetFlights` for a call to the service’s `GetFlightByFlightNumber`
    method (which returns a `FlightView` instance), as shown in the next code sample:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`GetFlightByFlightNumber_Success` 单元测试现在没有通过。从 `FlightController.GetFlightByFlightNumber`
    方法调用返回的数据是不正确的。但我们可以修复它。对于实际的方法实现，我们可以使用与 `GetFlights` 方法相同的 `try-catch` 模式，并用对服务
    `GetFlightByFlightNumber` 方法的调用（它返回一个 `FlightView` 实例）替换掉调用服务 `FlightService.GetFlights`
    返回的 `IAsyncEnumerable` 的异步 `foreach` 循环，如下一个代码示例所示：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we now run the `GetFlightByFlightNumber_Success` unit test again, we see
    it passes. That was pretty quick! In about a page and a half, we created a brand-new
    endpoint and have a success path unit test to back up the expected functionality.
    We are on a roll, so let’s add the two failure cases as well. Once again, they
    should be very similar to what we did with the `GetFlights` unit tests, as shown
    here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在再次运行 `GetFlightByFlightNumber_Success` 单元测试，我们会看到它通过了。这非常快！在不到一页半的时间里，我们创建了一个全新的端点，并有一个成功路径单元测试来支持预期的功能。我们正在取得进展，所以让我们也添加两个失败情况。再次强调，它们应该与我们之前对
    `GetFlights` 单元测试所做的工作非常相似，如下所示：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Go ahead and run all the tests; they should pass. So, what else do we need to
    do for this endpoint? Let’s have a quick look at the OpenAPI specification, shown
    in figure 3.10, and verify we have done all we need to do.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 继续运行所有测试；它们应该通过。那么，我们还需要为这个端点做些什么呢？让我们快速查看图 3.10 中显示的 OpenAPI 规范，并验证我们已经完成了所有需要做的事情。
- en: '![](../Images/13_10.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13_10.png)'
- en: Figure 13.10 The OpenAPI specification for the `GET` `/flight/{flightNumber}`
    endpoint. This is a screenshot from a generated OpenAPI specification.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10 `GET` `/flight/{flightNumber}` 端点的 OpenAPI 规范。这是从生成的 OpenAPI 规范中截取的屏幕截图。
- en: 'By looking at the OpenAPI specification, we see that we need to accept a parameter
    called `flightNumber`: check! We also have three returns: a 200 with the `FlightView`
    we constructed, a 404 when a flight cannot be found, and a 400 if an invalid flight
    number was supplied.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看 OpenAPI 规范，我们看到我们需要接受一个名为 `flightNumber` 的参数：检查！我们还有三个返回值：一个返回我们构建的 `FlightView`
    的 200 状态码，一个当找不到航班时的 404 状态码，以及一个当提供的航班号无效时的 400 状态码。
- en: Well, we have two out of three correct. We just need to change our 500 internal
    error to a 400 status code (Bad Request) and verify that the passed-in `flightNumber`
    is a valid number. A valid `flightNumber` is (for our purposes) any positive integer.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们已经完成了三分之二。我们只需要将我们的 500 内部错误更改为 400 状态码（Bad Request），并验证传入的 `flightNumber`
    是否是一个有效的数字。对于一个有效的 `flightNumber`（就我们的目的而言）来说，任何正整数都是有效的。
- en: 'Let’s first hop into our unit test and make these changes as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先跳到我们的单元测试中，并按照以下方式做出这些更改：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Of course, the unit test doesn’t pass anymore. We need to change the `FlightController
    .GetFlightByFlightNumber` method as well, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，单元测试不再通过了。我们需要修改 `FlightController.GetFlightByFlightNumber` 方法，如下所示：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And what have we learned? To always double-check our code and tests against
    the specification we are given.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到了什么？始终要对照我们收到的规范检查我们的代码和测试。
- en: So now that we have the `GetFlights` and `GetFlightByFlightNumber` methods in
    our `FlightController`, it’s time to expose them to external systems. After all,
    the code is currently not usable, so it’s somewhat worthless. To do this, we need
    to have a way for our service to accept an incoming HTTP request and route that
    request to the appropriate controller and method. In the next section, we’ll explore
    exactly how to do that.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经在 `FlightController` 中有了 `GetFlights` 和 `GetFlightByFlightNumber` 方法，是时候将它们暴露给外部系统了。毕竟，当前的代码是不可用的，所以它有些无用。为此，我们需要一种方法让我们的服务接受传入的
    HTTP 请求并将该请求路由到适当的控制器和方法。在下一节中，我们将探讨如何做到这一点。
- en: 13.4 Routing HTTP requests to controllers and methods
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 将 HTTP 请求路由到控制器和方法
- en: Now you have a bunch of repositories, services, and controllers. They are all
    filled to the brim with amazing methods that can do anything you ever wanted.
    But how do you use this stuff? Unlike a desktop application where you provide
    a GUI alongside the business logic, we are dealing with a web service that lives
    somewhere in a deployed environment. How do we ask or tell the server to do anything?
    We use HTTP requests.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一系列仓库、服务和控制器。它们都充满了可以实现你想要做的一切的精彩方法。但如何使用这些功能呢？与桌面应用程序不同，桌面应用程序中你会在业务逻辑旁边提供一个图形用户界面（GUI），我们处理的是一个存在于部署环境中的网络服务。我们如何请求或告诉服务器做什么？我们使用
    HTTP 请求。
- en: How does our service accept such a request? Well, right now the FlyingDutchmanAirlines
    service acts somewhat as a brick wall. If you were to send an HTTP request to
    it, the service would not know what to do with it. But if we introduce the concept
    of routing, shown in figure 13.11, the story changes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务如何接受这样的请求？目前，FlyingDutchmanAirlines 服务表现得有点像一堵砖墙。如果你向它发送 HTTP 请求，服务将不知道如何处理它。但如果我们引入路由的概念，如图
    13.11 所示，情况就改变了。
- en: '![](../Images/13_11.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13_11.png)'
- en: Figure 13.11 HTTP requests entering a service with and without routing. When
    we do not have any routing set up, HTTP requests bounce from the service unresolved.
    If we route to endpoints, the service can execute the appropriate logic.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11 带和不带路由的 HTTP 请求进入服务。当我们没有设置任何路由时，HTTP 请求在服务中无法解决而弹回。如果我们路由到端点，服务可以执行适当的逻辑。
- en: Routing allows us to map URLs to specific controllers and endpoints. The mapping
    between requests and controller endpoints makes the `GET /Flight` method in the
    `FlightController` execute when you send an HTTP `GET` request to the [*ServiceAddress*]/flight
    URL. What do we need to do to add routing support? In section 12.3.2, we talked
    about middleware. Routing is just another piece of middleware we can add to our
    service. In fact, most of what we need to do is already there.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 路由使我们能够将 URL 映射到特定的控制器和端点。请求与控制器端点之间的映射使得在 `FlightController` 中执行 `GET /Flight`
    方法时，当你向 [*ServiceAddress*]/flight URL 发送 HTTP `GET` 请求。为了添加路由支持，我们需要做什么？在 12.3.2
    节中，我们讨论了中间件。路由只是我们可以添加到我们的服务中的另一块中间件。实际上，我们需要的很多东西已经准备好了。
- en: 'In section 5.2, we built the internal routing table containing a list of endpoints
    the service can route to. All we need to do to start the routing is tell the CLR
    where to route the requests. We do this by giving “routes” to endpoint methods
    and controllers in a two-step process. First, we add a `[Route]` attribute to
    the `FlightController` class as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 5.2 节中，我们构建了内部路由表，其中包含服务可以路由到的端点列表。要开始路由，我们只需要告诉 CLR 将请求路由到何处。我们通过在两步过程中给端点方法和控制器提供“路由”来实现这一点。首先，我们像下面这样在
    `FlightController` 类中添加一个 `[Route]` 属性：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `[Route]` attribute accepts either a hardcoded route or a template. Here,
    I opted for the `"{controller}"` template.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Route]` 属性接受硬编码的路由或模板。在这里，我选择了 `"{{controller}}"` 模板。'
- en: '| ![](../Images/LightBulb.png)   | Controller Names in Routes When using the
    `"{controller}``"` template in the `route` attribute, the route is resolved to
    be the name of your controller class, minus the actual word *controller*. So,
    in our case, our class is called `FlightController`, so the route is `/Flight`.
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/LightBulb.png)   | 路由中的控制器名称 当在`route`属性中使用`"{controller}"`模板时，路由会被解析为你的控制器类名，去掉实际的单词*controller*。所以，在我们的例子中，我们的类被命名为`FlightController`，所以路由是`/Flight`。'
- en: 'The next step is to define method-specific routing. To do this, we use the
    following collection of attributes that map to HTTP actions:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义特定方法的路由。为此，我们使用以下映射到HTTP操作的属性集合：
- en: '`[HttpGet]`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[HttpGet]`'
- en: '`[HttpPost]`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[HttpPost]`'
- en: '`[HttpPut]`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[HttpPut]`'
- en: '`[HttpDelete]`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[HttpDelete]`'
- en: '`[HttpHead]`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[HttpHead]`'
- en: '`[HttpPatch]`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[HttpPatch]`'
- en: 'All these attributes produce routes that map to their corresponding HTTP actions.
    We can use these attributes on methods in two ways: as they are, or by providing
    an additional route. To illustrate, let’s use the `[HttpGet]` attribute on the
    `FlightController .GetFlights` method as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些属性都生成映射到它们对应HTTP操作的路由。我们可以以两种方式在这些方法上使用这些属性：直接使用，或者提供额外的路由。为了说明，让我们在`FlightController.GetFlights`方法上使用`[HttpGet]`属性，如下所示：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The method routes get added to the controller route. Using the `[HttpGet]`
    attribute on the `GetFlights` method produces a route of `GET /Flight` for this
    method, which is in line with what the FlyTomorrow OpenAPI specification would
    have us do. To test our endpoint, we can use either the cURL command-line tool
    (included in Windows, macOS, and Linux) or a dedicated HTTP tool such as Postman.
    I won’t take a stand on which one is better: they each have their pros and cons.
    For most commands in the book, I use cURL on Windows. The usage of cuRL should
    be the same (or very similar) across platforms.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 方法路由被添加到控制器路由中。使用`GetFlights`方法上的`[HttpGet]`属性生成一个`GET /Flight`的路由，这与FlyTomorrow
    OpenAPI规范要求我们做的相符。为了测试我们的端点，我们可以使用cURL命令行工具（包含在Windows、macOS和Linux中）或专门的HTTP工具，如Postman。我不会偏袒哪一个更好：它们各有优缺点。对于本书中的大多数命令，我在Windows上使用cURL。cuRL的使用在各个平台之间应该是相同的（或非常相似）。
- en: 'To reach our endpoint, we first need to launch it. Usually, we launch services
    locally on port 8080 (and this is the case with the provided source code). This
    works fine for most use cases, but sometimes you’ll have a conflict on that port
    and need to use a different one. If you find that you cannot access the service,
    and you are serving on port 8080, change the port to something else in `Startup.cs`.
    In this example, I used port 8081\. To launch our service, open a command-line
    window, point it to the FlyingDutchmanAirlines folder, and enter the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要达到我们的目标端点，我们首先需要启动它。通常，我们会在本地端口8080上启动服务（提供的源代码就是这种情况）。这对于大多数用例来说都很好，但有时你可能会在那个端口上遇到冲突，需要使用不同的端口。如果你发现你无法访问服务，而你正在端口8080上提供服务，请在`Startup.cs`中将端口更改为其他值。在这个例子中，我使用了端口8081。要启动我们的服务，打开一个命令行窗口，将其指向FlyingDutchmanAirlines文件夹，并输入以下命令：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once the service is up and running (the command line tells us if it is), we
    can use cURL to “curl” our endpoint. To curl an endpoint, in a separate command-line
    window, use the `[curl] -v [address]` syntax (the `-v` flag tells cURL to give
    us some more details or verbosity), as shown next:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务启动并运行（命令行会告诉我们是否启动），我们就可以使用cURL来“curl”我们的端点。要curl一个端点，在另一个命令行窗口中，使用`[curl]
    -v [address]`语法（`-v`标志告诉cURL提供更多详细信息或详细程度），如下所示：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If your service is running, you will receive a response containing all the flights
    in the database, as shown in figure 13.12.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的服务正在运行，你将收到一个包含数据库中所有航班的响应，如图13.12所示。
- en: '![](../Images/13_12.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13_12.png)'
- en: 'Figure 13.12 The response from our service to a `GET` `HTTP` `/Flight` request:
    a massive JSON array containing all flights in the database. FlyTomorrow can use
    this data to represent all flights by Flying Dutchman Airlines to customers.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12 我们的服务对`GET` `HTTP` `/Flight` 请求的响应：一个包含数据库中所有航班的巨大JSON数组。FlyTomorrow可以使用这些数据来向客户展示所有飞利浦荷兰航空公司的航班。
- en: As you can see in figure 13.12, the cURL tool does not format the returned JSON
    information. It displays the data unformatted, making it hard to read. In figure
    13.13, you can see part of the formatted response as shown in Postman, which formats
    the returned JSON. The wonderful news is that our endpoint worked! We did a full
    round trip from our HTTP request to the database and back to our command line.
    All the hard work we did in the previous chapters is finally paying off.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在图 13.12 中所见，cURL 工具不会格式化返回的 JSON 信息。它以未格式化的形式显示数据，这使得阅读变得困难。在图 13.13 中，您可以看到
    Postman 中格式化后的响应的一部分，它格式化了返回的 JSON。好消息是我们的端点工作正常！我们从 HTTP 请求到数据库，再到命令行的完整往返都成功了。我们在前几章所做的所有艰苦工作终于得到了回报。
- en: '![](../Images/13_13.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.13](../Images/13_13.png)'
- en: Figure 13.13 Part of the same JSON response data as shown in figure 13.12 but
    formatted. Formatted JSON is much more readable, and we can easily spot any issues.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.13 与图 13.12 中相同的 JSON 响应数据，但已格式化。格式化的 JSON 更易于阅读，我们可以轻松地发现任何问题。
- en: 'How do we reach our other endpoint: `/GET /Flight/{FlightNumber}`? After all,
    we are using a path parameter containing the flight number. When using an `HttpAttribute`
    method attribute (like `[HttpGet]`), we can provide additional routing instructions,
    as shown in the next code snippet. This is useful for when we want to provide
    some more route nesting (e.g., have an endpoint that goes to `/Flight/AmazingFlights/`)
    or for receiving a path parameter such as `{flightNumber})`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何到达我们的另一个端点：`/GET /Flight/{FlightNumber}`？毕竟，我们正在使用包含航班号的路径参数。当使用 `HttpAttribute`
    方法属性（如 `[HttpGet]`）时，我们可以提供额外的路由指令，如下一个代码片段所示。这在我们需要提供更多的路由嵌套（例如，有一个前往 `/Flight/AmazingFlights/`
    的端点）或接收路径参数（如 `{flightNumber}`）时非常有用。
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With the `GetFlightByFlightNumber` method, the template specified as part of
    the `[HttpGet``]` points the path parameter of `{flightNumber}` to the method’s
    input parameter of `flightNumber`. We can now use the path parameter and request
    information on a specific flight. For example, we can easily retrieve information
    on flight 23 from Salzburg to Groningen by using cURL as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `GetFlightByFlightNumber` 方法，`[HttpGet]` 中指定的模板将 `{flightNumber}` 路径参数指向方法输入参数
    `flightNumber`。我们现在可以使用路径参数并请求特定航班的详细信息。例如，我们可以使用 cURL 轻松检索萨尔茨堡飞往格罗宁根的航班 23 的信息，如下所示：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The endpoint returns a serialized (a data structure converted to a binary or
    JSON format) version of the `FlightView` class for flight 23\. Figure 13.14 shows
    the response data. We can also see in figure 13.15 what happens if we pass in
    an invalid flight number, such as `-1` (not a positive integer) or `93018` (flight
    does not exist in the database).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 端点返回了 `FlightView` 类的序列化（将数据结构转换为二进制或 JSON 格式）版本，用于航班 23。图 13.14 展示了响应数据。我们还可以在图
    13.15 中看到，如果我们传递一个无效的航班号，例如 `-1`（不是一个正整数）或 `93018`（航班在数据库中不存在），会发生什么。
- en: '![](../Images/13_14.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.14](../Images/13_14.png)'
- en: Figure 13.14 The data returned by the service when calling the `GET` `/Flight/23`
    endpoint. By passing in an appropriate flight parameter value, we can query the
    service for flight 23 by using the `GET` `/Flight/{FlightNumber}` endpoint.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '图 13.14 当调用 `GET` `/Flight/23` 端点时，服务返回的数据。通过传递适当的航班参数值，我们可以使用 `GET` `/Flight/{FlightNumber}`
    端点查询航班 23。 '
- en: '![](../Images/13_15.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.15](../Images/13_15.png)'
- en: Figure 13.15 We receive HTTP 400 and HTTP 404 back in our error conditions for
    the `/GET` `/Flight/{FlightNumber}` endpoint. These errors are useful to determine
    if the problem is on the client or server side.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.15 我们在 `/GET` `/Flight/{FlightNumber}` 端点错误条件下收到 HTTP 400 和 HTTP 404 错误。这些错误对于确定问题是在客户端还是服务器端非常有用。
- en: 'So, to summarize: we now have a fully implemented `FlightController` along
    with unit tests. We can hit the `GET /Flight` and `GET /Flight/{FlightNumber}`
    endpoints and retrieve data from the database successfully. In the next chapter,
    we’ll finish our refactoring journey and implement the last controller and endpoint:
    the `BookingController` and the `POST /Booking` endpoint.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下：我们现在已经完全实现了 `FlightController` 以及单元测试。我们可以访问 `GET /Flight` 和 `GET /Flight/{FlightNumber}`
    端点并成功从数据库中检索数据。在下一章中，我们将完成我们的重构之旅并实现最后一个控制器和端点：`BookingController` 和 `POST /Booking`
    端点。
- en: Exercises
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Exercise 13.1
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 13.1
- en: True or false? A controller is the only layer that should accept an HTTP request
    from an external system in a repository/service pattern architecture.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？在存储库/服务模式架构中，控制器是唯一应该接受来自外部系统的 HTTP 请求的层。
- en: Exercise 13.2
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 13.2
- en: 'A typical HTTP response comprises the following three attributes:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的HTTP响应包含以下三个属性：
- en: a. Sender information, routing information, IP destination
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: a. 发送者信息，路由信息，IP目标
- en: b. Name of sender, what programming language was used in the service, country
    of origin
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: b. 发送者名称，服务中使用的编程语言，原始国家
- en: c. Status code, headers, body
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: c. 状态码，头部，主体
- en: Exercise 13.3
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 练习13.3
- en: 'Which controller should you implement for this route: `GET /Books/Fantasy`?'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此路由，你应该实现哪个控制器：`GET /Books/Fantasy`？
- en: a. `BookController`
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: a. `BookController`
- en: b. `FantasyController`
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: b. `FantasyController`
- en: c. `BookShopController`
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: c. `BookShopController`
- en: Exercise 13.4
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 练习13.4
- en: True or false? Middleware is executed before any endpoint method logic.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对或错？中间件是在任何端点方法逻辑之前执行的。
- en: Exercise 13.5
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 练习13.5
- en: What type of injected dependency allows us to have a new instance of a dependency
    every time it is requested, regardless of whether we are still dealing with the
    same HTTP request?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种注入依赖项类型允许我们在每次请求时都获得一个新的依赖项实例，无论我们是否仍在处理相同的HTTP请求？
- en: a. Singleton
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: a. 单例
- en: b. Scoped
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: b. 范围限定
- en: c. Transient
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: c. 瞬态
- en: Exercise 13.6
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 练习13.6
- en: What type of injected dependency allows us to use the same instance of a dependency
    only for the duration of an HTTP request’s life cycle in our service?
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种注入依赖项类型允许我们在服务中仅在HTTP请求的生命周期内使用依赖项的同一实例？
- en: a. Singleton
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: a. 单例
- en: b. Scoped
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: b. 范围限定
- en: c. Transient
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: c. 瞬态
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The controller layer is the outer layer in terms of architecture when considering
    a repository/service pattern. A controller can accept HTTP requests and communicate
    with external systems. If we could not accept or talk with external systems, nobody
    could use our service.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在考虑存储库/服务模式时，控制器层是架构的外层。控制器可以接受HTTP请求并与外部系统通信。如果我们不能接受或与外部系统交谈，没有人能够使用我们的服务。
- en: An HTTP request always contains headers (CORS, authentication, etc.) and sometimes
    a body (JSON or XML).
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP请求始终包含头部信息（CORS、身份验证等），有时还包含主体（JSON或XML）。
- en: An HTTP response always contains headers, an HTTP status code (200 OK, 404 Not
    Found, etc.), and sometimes a body.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP响应始终包含头部信息、HTTP状态码（200 OK、404 Not Found等），有时还包含主体。
- en: ASP.NET’s `IActionResult` interface allows us to easily return HTTP responses
    from methods. This allows us to write clear and concise code that everybody can
    understand.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET的`IActionResult`接口允许我们轻松地从方法中返回HTTP响应。这使我们能够编写清晰简洁的代码，任何人都能理解。
- en: Coding to interfaces is a clean code principle that promotes the use of generic
    constructs over limiting concrete classes. This allows us to adhere to the Open/
    Closed Principle and easily extend our code without changing the existing class.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码到接口是一种干净的代码原则，它促进了使用泛型结构而不是限制具体类。这使我们能够遵循开/闭原则，并轻松扩展我们的代码而无需更改现有类。
- en: Middleware is any code that we execute before dealing with a provided HTTP request
    in a controller’s endpoint method. We can use middleware to execute things such
    as authentication checks, dependency injection, and routing.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件是我们执行在控制器端点方法处理提供的HTTP请求之前的任何代码。我们可以使用中间件来执行诸如身份验证检查、依赖注入和路由等操作。
- en: 'When injecting a dependency in middleware, you have the option of three types
    of injected dependencies: singleton, scoped, and transient. A singleton dependency
    mimics the singleton design pattern and guarantees all requests operate on a single
    instance of an injected dependency. With scoped, the injected dependency is shared
    across the same request but not across multiple requests. With transient, a new
    instance of a dependency is instantiated every time it is requested by a constructor.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在中间件中注入依赖项时，你有三种类型的注入依赖项可供选择：单例、范围限定和瞬态。单例依赖项模仿单例设计模式，并保证所有请求都在注入依赖项的单个实例上操作。范围限定时，注入的依赖项在同一请求内共享，但不在多个请求之间共享。瞬态时，每次构造函数请求依赖项时都会实例化一个新的依赖项实例。
- en: To route an HTTP request to an endpoint, we have to set up routing in middleware
    and add routing attributes to both the controller class and the methods. This
    allows granular control over what our routes should look like.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将HTTP请求路由到端点，我们必须在中间件中设置路由，并将路由属性添加到控制器类和方法中。这允许我们对我们的路由应该是什么样子进行细粒度控制。
- en: There are `HttpAttribute` routing method attributes for most common HTTP actions.
    You can either use them as is or provide an additional route and use path parameters.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大多数常见的HTTP操作，都有`HttpAttribute`路由方法属性。你可以直接使用它们，或者提供额外的路由并使用路径参数。
- en: '* * *'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '^(1.)For more information on the singleton pattern, see Robert C. Martin and
    Micah Martin’s *Agile Principles, Patterns, and Practices in C#*, chapter 24,
    “Singleton and Monostate” (Prentice Hall, 2006); or for a resource that also covers
    dependency injection in great detail, see Steven van Deursen and Mark Seemann’s
    *Dependency Injection: Principles, Practices, and Patterns* (Manning, 2019).'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: (1.)有关单例模式的更多信息，请参阅罗伯特·C·马丁和迈克·马丁的《敏捷原则、模式与实践：C#》第24章，“单例与单态”（普伦蒂斯·霍尔，2006年）；或者，如果您想了解一个也详细涵盖依赖注入的资源，请参阅斯蒂芬·范·德尔斯和马克·塞门恩的《依赖注入：原则、实践与模式》（曼宁，2019年）。
