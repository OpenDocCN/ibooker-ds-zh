- en: 19 Automating time series forecasting with Prophet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19 使用Prophet自动化时间序列预测
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖了
- en: Assessing different libraries for automated forecasting
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估不同的自动化预测库
- en: Exploring the functionality of Prophet
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Prophet的功能
- en: Forecasting with Prophet
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Prophet进行预测
- en: Throughout this book, we have built models involving many manual steps. For
    declinations of the SARIMAX models, for example, we had to develop a function
    to select the best model according to the Akaike information criterion (AIC) and
    a function to perform rolling forecasts. In the deep learning portion of the book,
    we had to build a class to create windows of data, as well as define all the deep
    learning models, although this was greatly facilitated by the use of Keras.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们构建了涉及许多手动步骤的模型。例如，对于SARIMAX模型的偏差，我们必须开发一个函数来根据赤池信息准则（AIC）选择最佳模型，以及一个函数来执行滚动预测。在本书的深度学习部分，我们必须构建一个类来创建数据窗口，以及定义所有深度学习模型，尽管这通过使用Keras得到了极大的简化。
- en: While manually building and tweaking our models allows for great flexibility
    and total control over our forecasting techniques, it is also useful to automate
    most of the forecasting process, making it easier to forecast time series and
    accelerating experiments. Therefore, it is important to understand the automation
    tools, as they are a fast way to obtain predictions, and they often facilitate
    the use of state-of-the-art models.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然手动构建和调整我们的模型可以提供极大的灵活性并完全控制我们的预测技术，但自动化预测过程的大部分工作也是很有用的，这使得预测时间序列变得更加容易，并加速了实验。因此，了解自动化工具非常重要，因为它们是快速获得预测的一种方式，并且它们通常有助于使用最先进模型。
- en: In this chapter, we’ll first look at the various libraries that automate the
    process of time series forecasting. Then we’ll focus specifically on the Prophet
    library, which is arguably the most well-known and widely used forecasting library.
    We’ll explore its functionality using a real-life dataset. Finally, we’ll conclude
    this chapter with a forecasting project so we can see Prophet in action.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先查看各种自动化时间序列预测过程的库。然后我们将专注于Prophet库，这可能是最知名和最广泛使用的预测库。我们将使用实际数据集来探索其功能。最后，我们将通过一个预测项目来结束本章，以便我们可以看到Prophet的实际应用。
- en: 19.1 Overview of the automated forecasting libraries
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.1 自动化预测库概述
- en: 'The data science community and companies have developed many libraries to automate
    the forecasting process and make it easier. Some of the most popular libraries
    and their websites are listed here:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学社区和公司已经开发了众多库来自动化预测过程并使其更加容易。以下列出了其中一些最受欢迎的库及其网站：
- en: '*Pmdarima* —[http://alkaline-ml.com/pmdarima/modules/classes.xhtml](http://alkaline-ml.com/pmdarima/modules/classes.xhtml)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pmdarima* —[http://alkaline-ml.com/pmdarima/modules/classes.xhtml](http://alkaline-ml.com/pmdarima/modules/classes.xhtml)'
- en: '*Prophet* —[https://facebook.github.io/prophet](https://facebook.github.io/prophet)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Prophet* —[https://facebook.github.io/prophet](https://facebook.github.io/prophet)'
- en: '*NeuralProphet* —[https://neuralprophet.com/html/index.xhtml](https://neuralprophet.com/html/index.xhtml)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NeuralProphet* —[https://neuralprophet.com/html/index.xhtml](https://neuralprophet.com/html/index.xhtml)'
- en: '*PyTorch Forecasting* —[https://pytorch-forecasting.readthedocs.io/en/stable](https://pytorch-forecasting.readthedocs.io/en/stable)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PyTorch Forecasting* —[https://pytorch-forecasting.readthedocs.io/en/stable](https://pytorch-forecasting.readthedocs.io/en/stable)'
- en: This is by no means an exhaustive list, and I wish to remain impartial in their
    use. As a data scientist, you have the knowledge and capacity to assess whether
    a particular library is suitable for your needs in a particular context.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对不是一份详尽的列表，我希望在它们的使用上保持公正。作为一名数据科学家，你拥有知识和能力来评估在特定情境下某个库是否适合你的需求。
- en: The pmdarima library is the Python implementation of the popular `auto.arima`
    library in R. Pmdarima is essentially a wrapper that generalizes many of the statistical
    models we have used, such as the ARMA, ARIMA, and SARIMA models. The main advantage
    of this library is that it provides an easy-to-use interface that automatically
    uses all the tools we’ve discussed for forecasting with statistical models, such
    as the augmented Dickey-Fuller (ADF) test to test for stationarity and selecting
    the orders *p*, *q*, *P*, and *Q* to minimize the AIC. It also comes with toy
    datasets, making it great for first-time learners to test different models on
    simple time series. This package is built and maintained by the community, but,
    most importantly, it is still being actively maintained at the time of writing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: pmdarima 库是 R 中流行的 `auto.arima` 库的 Python 实现。Pmdarima 实质上是一个包装器，它概括了我们使用过的许多统计模型，例如
    ARMA、ARIMA 和 SARIMA 模型。这个库的主要优势是它提供了一个易于使用的界面，可以自动使用我们讨论过的所有工具进行统计模型预测，例如使用增广迪基-富勒（ADF）测试来检验平稳性，以及选择
    *p*、*q*、*P* 和 *Q* 的阶数以最小化 AIC。它还附带了一些玩具数据集，非常适合初学者在简单的时序数据上测试不同的模型。这个包是由社区构建和维护的，但最重要的是，在撰写本文时，它仍在积极维护中。
- en: Prophet is an open source package from Meta Open Source, meaning that it is
    built and maintained by Meta. This library was built specifically for business
    forecasting at scale. It arose from the internal need at Facebook to produce accurate
    forecasts quickly, and the library was then made freely available. Prophet is
    arguably the best-known forecasting library in the industry, as it can fit nonlinear
    trends and combine the effect of multiple seasonalities. The remainder of this
    chapter and the next one will focus entirely on this library, and we’ll explore
    it in greater detail in the next section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 是 Meta Open Source 的开源包，这意味着它是由 Meta 构建和维护的。这个库专门为大规模商业预测而构建。它起源于 Facebook
    内部快速产生准确预测的需求，然后该库被免费提供给公众。Prophet 可以说是行业中最知名的预测库，因为它可以拟合非线性趋势，并结合多个季节性的影响。本章的剩余部分和下一章将完全专注于这个库，我们将在下一节中对其进行更详细的探讨。
- en: 'NeuralProphet builds on the Prophet library to automate the use of hybrid models
    for time series forecasting. This is a rather new project that is still in its
    beta phase at the time of writing. The library was built with the collaboration
    of people from different universities and Facebook. This package introduces a
    combination of classical models, such as ARIMA, and neural networks, to produce
    accurate forecasts. It uses PyTorch on the backend, meaning that experienced users
    can easily extend the library’s functionality. Most importantly, it uses an API
    similar to Prophet’s, so once you learn how to work with Prophet, you can seamlessly
    transition to working with NeuralProphet. To learn more, you can read their paper,
    “NeuralProphet: Explainable Forecasting at Scale” ([https://arxiv.org/abs/2111.15397](https://arxiv.org/abs/2111.15397)).
    It provides greater detail on NeuralProphet’s internal functions and performance
    benchmarks while still being an accessible article.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 'NeuralProphet 是基于 Prophet 库构建的，用于自动化使用混合模型进行时间序列预测。这是一个相对较新的项目，在撰写本文时仍处于测试阶段。该库是由来自不同大学和
    Facebook 的人合作开发的。这个包引入了经典模型（如 ARIMA）和神经网络相结合，以产生准确的预测。它使用 PyTorch 作为后端，这意味着有经验的用户可以轻松扩展库的功能。最重要的是，它使用与
    Prophet 相似的 API，所以一旦你学会了如何使用 Prophet，就可以无缝过渡到使用 NeuralProphet。要了解更多信息，你可以阅读他们的论文，“NeuralProphet:
    Explainable Forecasting at Scale” ([https://arxiv.org/abs/2111.15397](https://arxiv.org/abs/2111.15397))。它提供了关于
    NeuralProphet 内部功能和性能基准的更多细节，同时仍然是一篇易于阅读的文章。'
- en: Finally, PyTorch Forecasting facilitates the use of state-of-the-art deep learning
    models for time series forecasting. It, of course, uses PyTorch, and it provides
    a simple interface to implement models such as DeepAR, N-Beats, LSTM, and more.
    This package is built by the community and, at the time of writing, is being actively
    maintained.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，PyTorch Forecasting 促进了最先进的深度学习模型在时间序列预测中的应用。当然，它使用 PyTorch，并提供了一个简单的接口来实现
    DeepAR、N-Beats、LSTM 等模型。这个包是由社区构建的，在撰写本文时，它正在积极维护中。
- en: 'Note For more information about DeepAR, see David Salinas, Valentin Flunkert,
    Jan Gasthaus, Tim Januschowski, “DeepAR: Probabilistic forecasting with autoregressive
    recurrent networks,” *International Journal of Forecasting* 36:3 (2020), [http://mng.bz/z4Kr](http://mng.bz/z4Kr).
    For information about N-Beats, see Boris N. Oreshkin, Dmitri Carpov, Nicolas Chapados,
    Yoshua Bengio, “N-BEATS: Neural basis expansion analysis for interpretable time
    series forecasting,” arXiv:1905.10437 (2019), [https://arxiv.org/abs/1905.10437](https://arxiv.org/abs/1905.10437).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关 DeepAR 的更多信息，请参阅 David Salinas、Valentin Flunkert、Jan Gasthaus、Tim Januschowski
    的文章，“DeepAR：使用自回归循环网络的概率预测”，*国际预测杂志* 36:3 (2020)，[http://mng.bz/z4Kr](http://mng.bz/z4Kr)。有关
    N-Beats 的信息，请参阅 Boris N. Oreshkin、Dmitri Carpov、Nicolas Chapados、Yoshua Bengio
    的文章，“N-BEATS：用于可解释时间序列预测的神经网络基础扩展分析”，arXiv:1905.10437 (2019)，[https://arxiv.org/abs/1905.10437](https://arxiv.org/abs/1905.10437)。
- en: This gives you a brief overview of the automatic forecasting ecosystem. Note
    that this list is not exhaustive, as there are many more libraries for automated
    time series forecasting.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这为您提供了一个自动预测生态系统的简要概述。请注意，这份列表并不全面，因为还有许多更多用于自动时间序列预测的库。
- en: You do not need to learn how to use each of the libraries I’ve presented. This
    is meant to be an overview of the different tools available. Each time series
    forecasting problem can require a different set of tools, but knowing how to use
    one of the libraries usually makes it easier to use a new one. Thus, we’ll focus
    on the Prophet library for the rest of this book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要学习如何使用我展示的每个库。这旨在概述可用的不同工具。每个时间序列预测问题可能需要不同的工具集，但知道如何使用其中一个库通常会使使用新的库变得更容易。因此，我们将专注于本书剩余部分的
    Prophet 库。
- en: As I mentioned, Prophet is a well-known and widely used library in the industry,
    and anyone doing time series forecasting will likely come across Prophet. In the
    next section, we’ll explore the package in greater detail and learn about its
    advantages, limitations, and functionality before using it for forecasting.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我提到的，Prophet 是业界知名且广泛使用的库，任何进行时间序列预测的人很可能会遇到 Prophet。在下一节中，我们将更详细地探讨这个包，了解其优势、局限性和功能，然后再用它来进行预测。
- en: 19.2 Exploring Prophet
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.2 探索 Prophet
- en: Prophet is an open source library created by Meta that implements a forecasting
    procedure taking into account nonlinear trends with multiple seasonal periods,
    such as yearly, monthly, weekly, and daily. The package is available for use with
    Python. It allows you forecast rapidly with minimal manual work. More advanced
    users, such as ourselves, can fine tune the model to ensure that we get the best
    results possible.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 是由 Meta 创建的开源库，它实现了一个考虑多个季节性周期（如年度、月度、周度和日度）的非线性趋势预测过程。该包可用于与 Python
    一起使用。它允许您快速预测，而无需进行大量手动工作。对于像我们这样的高级用户，可以微调模型以确保获得最佳结果。
- en: Under the hood, Prophet implements a general additive model where each time
    series *y*(*t*) is modeled as the linear combination of a trend *g*(*t*), a seasonal
    component *s*(*t*), holiday effects *h*(*t*), and an error term *ϵ[*t*]*, which
    is normally distributed. Mathematically, this is expressed as equation 19.1.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，Prophet 实现了一个通用加性模型，其中每个时间序列 *y*(*t*) 被建模为趋势 *g*(*t*)、季节性成分 *s*(*t*)、假日效应
    *h*(*t*) 和误差项 *ϵ[*t*] 的线性组合，该误差项是正态分布的。数学上，这可以表示为方程式 19.1。
- en: '*y*(*t*) = *g*(*t*) + *s*(*t*) + *h*(*t*) + *ϵ[*t*]*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*(*t*) = *g*(*t*) + *s*(*t*) + *h*(*t*) + *ϵ[*t*]*'
- en: Equation 19.1
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式 19.1
- en: The trend component models the non-periodic long-term changes in the time series.
    The seasonal component models the periodic change, whether it is yearly, monthly,
    weekly, or daily. The holiday effect occurs irregularly and potentially on more
    than one day. Finally, the error term represents any change in value that cannot
    be explained by the previous three components.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 趋势成分模型时间序列的非周期性长期变化。季节性成分模型周期性变化，无论是年度、月度、周度还是日度。假日效应不规则地发生，可能发生在多天。最后，误差项代表任何无法由前三个成分解释的价值变化。
- en: Notice that this model does not take into account the time dependence of the
    data, unlike the ARIMA(*p*,*d*,*q*) model, where future values are dependent on
    past values. Thus, this process is closer to fitting a curve to the data, rather
    than finding the underlying process. Although there is some loss of predictive
    information using this method, it comes with the advantage that it is very flexible,
    since it can accommodate multiple seasonal periods and changing trends. Also,
    it is robust to outliers and missing data, which is a clear advantage in a business
    context.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个模型没有考虑数据的时变性，与ARIMA(*p*,*d*,*q*)模型不同，在ARIMA模型中，未来的值依赖于过去的值。因此，这个过程更接近于将曲线拟合到数据上，而不是寻找潜在的过程。虽然使用这种方法会有一些预测信息的损失，但它具有非常灵活的优点，因为它可以适应多个季节性周期和变化趋势。此外，它对异常值和缺失数据具有鲁棒性，这在商业环境中是一个明显的优势。
- en: The inclusion of multiple seasonal periods was motivated by the observation
    that human behavior produced multi-period seasonal time series. For example, the
    five-day work week can produce a pattern that repeats every week, while school
    break can produce a pattern that repeats every year. Thus, to take multiple seasonal
    periods into account, Prophet uses the Fourier series to model multiple periodic
    effects. Specifically, the seasonal component *s*(*t*) is expressed as equation
    19.2, where *P* is the length of the seasonal period in days, and *N* is the number
    of terms in the Fourier series.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 包含多个季节性周期是由观察到的现象所激发的，即人类行为产生了多周期季节性时间序列。例如，五天工作周可以产生每周重复一次的模式，而学校假期可以产生每年重复一次的模式。因此，为了考虑多个季节性周期，Prophet使用傅里叶级数来模拟多个周期性效应。具体来说，季节性成分
    *s*(*t*) 表示为方程19.2，其中*P*是季节性周期的天数长度，*N*是傅里叶级数中的项数。
- en: '![](../../OEBPS/Images/19-2_Equation.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![方程19.2](../../OEBPS/Images/19-2_Equation.png)'
- en: Equation 19.2
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 方程19.2
- en: In equation 19.2, if we have a yearly seasonality, *P* = 365.25, as there are
    365.25 days in a year. For a weekly seasonality, *P* = 7. *N* is simply the number
    of parameters we wish to use to estimate the seasonal component. This has the
    added benefit that the seasonal component’s sensitivity can be tweaked depending
    on how many parameters *N* are estimated to model the seasonality. We’ll look
    at this in section 19.4 when we explore the different functions of Prophet. By
    default, Prophet uses 10 terms to model the yearly seasonality and 3 terms to
    model the weekly seasonality.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在方程19.2中，如果我们有一个年度季节性，*P* = 365.25，因为一年中有365.25天。对于每周季节性，*P* = 7。*N*简单地是我们希望用来估计季节性成分的参数数量。这还有一个额外的优点，即可以根据估计的参数数量*N*来调整季节性成分的敏感性。我们将在第19.4节中探讨这一点，当我们探索Prophet的不同功能时。默认情况下，Prophet使用10个项来模拟年度季节性，使用3个项来模拟每周季节性。
- en: Finally, this model allows us to consider the effect of holidays. Holidays are
    irregular events that can have a clear impact on a time series. For example, events
    such as Black Friday in the United States can dramatically increase the attendance
    in stores or the sales on an ecommerce website. Similarly, Valentine’s Day is
    probably a strong indicator of an increase in sales of chocolates and flowers.
    Therefore, to model the impact of holidays in a time series, Prophet lets us define
    a list of holidays for a specific country. Holiday effects are then incorporated
    in the model, assuming that they are all independent. If a data point falls on
    a holiday date, a parameter *K*[i] is calculated to represent the change in the
    time series at that point in time. The larger the change, the greater the holiday
    effect.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个模型允许我们考虑节假日的影响。节假日是不规则事件，可以对时间序列产生明显的影响。例如，美国黑色星期五等事件可以显著增加商店的客流量或电子商务网站的销售额。同样，情人节可能是巧克力和鲜花销售额增加的强烈指标。因此，为了在时间序列中模拟节假日的影响，Prophet允许我们为特定国家定义一个节假日列表。然后，将这些节假日效应纳入模型中，假设它们都是独立的。如果一个数据点落在节假日日期上，就会计算一个参数*K*[i]来表示该时间点时间序列的变化。变化越大，节假日的影响就越大。
- en: Note For more information on the inner workings of Prophet, I highly suggest
    that you read the official paper, Sean J. Taylor and Benjamin Letham, “Forecasting
    at Scale,” *PeerJ Preprints* 5:e3190v2 (2017), [https://peerj.com/preprints/3190/](https://peerj.com/preprints/3190/).
    It contains a more detailed explanation of the library, including mathematical
    expressions and test results, while remaining accessible.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关 Prophet 内部工作原理的更多信息，我强烈建议您阅读官方论文，Sean J. Taylor 和 Benjamin Letham，“大规模预测”，*PeerJ
    Preprints* 5:e3190v2 (2017)，[https://peerj.com/preprints/3190/](https://peerj.com/preprints/3190/)。它包含对库的更详细解释，包括数学表达式和测试结果，同时保持易于理解。
- en: The flexibility of Prophet can make it an attractive choice for rapid and accurate
    forecasting. However, it must not be considered to be a one-size-fits-all solution.
    The documentation itself specifies that Prophet works best with time series that
    have a strong seasonal effect with several seasons of historical data. Therefore,
    there may be situations where Prophet is not the ideal choice, but that’s okay,
    since you have a variety of statistical and deep learning models in your tool
    belt to produce forecasts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 的灵活性使其成为快速准确预测的有吸引力的选择。然而，不应将其视为一刀切解决方案。文档本身指定 Prophet 在具有强烈季节性效应和多个历史季节数据的时间序列上表现最佳。因此，可能存在
    Prophet 不是理想选择的情况，但这没关系，因为您工具箱中有各种统计和深度学习模型来生成预测。
- en: Let’s now dive deeper into Prophet and explore its functionality.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在更深入地了解 Prophet 并探索其功能。
- en: 19.3 Basic forecasting with Prophet
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.3 使用 Prophet 进行基本预测
- en: To accompany our exploration of Prophet’s functionality, we’ll use a dataset
    containing the historical daily minimum temperature recorded in Melbourne, Australia,
    between 1981 and 1990\. Besides predicting the weather, this dataset can also
    help us identify long-term climate trends and determine if the daily minimum temperature
    is, for example, increasing over time. Our forecast horizon will be 1 year or
    365 days. We thus wish to build a model that forecasts the next year of daily
    minimum temperatures.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配合我们对 Prophet 功能的探索，我们将使用包含 1981 年至 1990 年间在澳大利亚墨尔本记录的历史每日最低温度的数据集。除了预测天气外，这个数据集还可以帮助我们识别长期气候趋势，并确定每日最低温度是否随着时间的推移而增加。我们的预测范围将是
    1 年或 365 天。因此，我们希望构建一个模型来预测下一年每日最低温度。
- en: 'Note At any time, feel free to consult the source code for this chapter on
    GitHub: [https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH19](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH19).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您随时可以查阅 GitHub 上本章的源代码：[https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH19](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH19)。
- en: Prophet is as easy to install as any other Python package. It can then be imported
    in a Jupyter Notebook or Python script with the same syntax as when you use `pandas`
    or `numpy`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 的安装与任何其他 Python 包一样简单。然后，您可以使用与使用 `pandas` 或 `numpy` 相同的语法在 Jupyter
    Notebook 或 Python 脚本中导入它。
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A note on installing Prophet on Windows
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 关于在 Windows 上安装 Prophet 的注意事项
- en: If you are using a Windows machine, it is highly recommended that you use Anaconda
    to perform any data science task. Trying to install Prophet through Anaconda the
    first time might result in an error. This is because a compiler must be installed
    in order for the package to function correctly on Windows.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Windows 机器，强烈建议您使用 Anaconda 来执行任何数据科学任务。第一次尝试通过 Anaconda 安装 Prophet
    可能会导致错误。这是因为为了使该包在 Windows 上正确运行，必须安装编译器。
- en: 'If you are using Anaconda, you can run the following commands in your Anaconda
    prompt to install Prophet successfully:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Anaconda，您可以在您的 Anaconda 提示符中运行以下命令以成功安装 Prophet：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The next step is, of course, to read the CSV file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步当然是读取 CSV 文件。
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can now plot our time series.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以绘制我们的时间序列图。
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The result is shown in figure 19.1\. You’ll see a clear yearly seasonality,
    which is expected, as temperature is generally higher during summer and lower
    during winter. We thus have a fairly large dataset with 10 seasons of data, which
    is a perfect scenario for using Prophet, as the library performs best when there
    is a strong seasonal effect with many historical seasonal periods.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如图 19.1 所示。您将看到明显的年度季节性，这是预期的，因为温度通常在夏季较高，在冬季较低。因此，我们有一个相当大的数据集，包含 10 个季节的数据，这对于使用
    Prophet 是一个完美的场景，因为当存在强烈的季节性效应和许多历史季节周期时，该库表现最佳。
- en: '![](../../OEBPS/Images/19-01.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/19-01.png)'
- en: Figure 19.1 Daily minimum temperature recorded in Melbourne from 1981 to 1991\.
    There is a yearly seasonality, as expected, since it is hotter in the summer and
    colder in the winter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.1 显示了 1981 年至 1991 年在墨尔本记录的每日最低温度。正如预期的那样，存在年度季节性，因为夏季更热，冬季更冷。
- en: We can now move on to forecasting with Prophet. You will see how quickly you
    can obtain accurate forecasts using Prophet with very few manual steps.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续使用 Prophet 进行预测。您将看到如何快速地使用 Prophet 获得准确的预测，而几乎不需要手动操作。
- en: 'The first step is to rename our columns. Prophet expects to have a `DataFrame`
    with two columns: a date column named ds and a value column named y. The date
    column must have a format accepted by `pandas`—usually YYYY-MM-DD or YYYY-MM-DD
    HH:MM:SS. The y column contains the values to be forecast, and those values must
    be numeric, whether float or integer. In our case, the dataset has only two columns
    that are already in the correct format, so we only need to rename them.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是重命名我们的列。Prophet 预期有一个包含两列的 `DataFrame`：一列名为 ds 的日期列和一列名为 y 的值列。日期列必须使用 `pandas`
    接受的格式——通常是 YYYY-MM-DD 或 YYYY-MM-DD HH:MM:SS。y 列包含要预测的值，这些值必须是数值型，无论是浮点数还是整数。在我们的案例中，数据集只有两列，格式已经正确，所以我们只需要重命名它们。
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, we’ll split our data into train and test sets. We’ll keep the last 365
    days for the test set, as this represents a full year. We’ll then take the first
    9 years of data for training.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将数据分为训练集和测试集。我们将保留最后 365 天作为测试集，因为这代表了一整年。然后我们将前 9 年的数据用于训练。
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Prophet follows the `sklearn` API, where a model is initialized by creating
    an instance of the `Prophet` class, the model is trained using the `fit` method,
    and predictions are generated using the `predict` method. Therefore, we’ll first
    initialize a Prophet model by creating an instance of the `Prophet` class. Note
    that throughout this chapter, we’ll code using Prophet’s naming convention.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet 遵循 `sklearn` API，其中模型通过创建 `Prophet` 类的实例来初始化，使用 `fit` 方法训练模型，并使用 `predict`
    方法生成预测。因此，我们将首先通过创建 `Prophet` 类的实例来初始化一个 Prophet 模型。注意，在本章中，我们将使用 Prophet 的命名约定进行编码。
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once it’s initialized, we’ll then fit the model on the train set.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化完成后，我们将在训练集上拟合模型。
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We now have a model that is ready to produce forecasts, with only two lines
    of code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个模型，只需两行代码就可以生成预测。
- en: The next step is to create a `DataFrame` to hold the predictions from Prophet.
    We’ll use the `make_future_dataframe` method and specify the number of periods,
    which is the number of days in our forecast horizon. In this case, we want 365
    days of forecast, so that they can be compared to the actual values observed in
    the test set.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个 `DataFrame` 来存储 Prophet 的预测结果。我们将使用 `make_future_dataframe` 方法并指定周期数，即预测范围的天数。在这种情况下，我们想要
    365 天的预测，这样它们可以与测试集中观察到的实际值进行比较。
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All that’s left to do is to generate the forecast using the `predict` method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是使用 `predict` 方法生成预测。
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Take some time to appreciate the fact that we trained a model and obtained predictions
    using only four lines of code. One of the main benefits of automated forecasting
    libraries is that we can experiment quickly and fine-tune the models later to
    tailor them to the task at hand.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间来欣赏这样一个事实：我们只用了四行代码就训练了一个模型并获得了预测。自动化预测库的主要好处之一是我们可以快速实验，并在以后调整模型以适应手头的任务。
- en: However, our work is not done, since we wish to evaluate the model and measure
    its performance. The `forecast DataFrame` holds many columns with a lot of information,
    as shown in figure 19.2.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的工作还没有完成，因为我们希望评估模型并衡量其性能。`forecast DataFrame` 包含许多列，包含大量信息，如图 19.2 所示。
- en: '![](../../OEBPS/Images/19-02.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/19-02.png)'
- en: Figure 19.2 The `forecast DataFrame` containing the different components of
    the prediction. Note that if you add trend with additive_terms, you get the prediction
    yhat, which is hidden in the figure because the `DataFrame` has too many columns.
    Note also that additive_terms is the sum of weekly and yearly, indicating that
    we have both weekly and yearly seasonality.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.2 显示了包含预测不同成分的 `forecast DataFrame`。注意，如果您将趋势与加性项一起添加，您将得到预测 yhat，它在图中被隐藏，因为
    `DataFrame` 有太多列。还要注意，加性项是每周和每年的总和，这表明我们既有每周季节性也有年度季节性。
- en: 'We are only interested in these four columns: ds, yhat, yhat_lower, and yhat_upper.
    The ds column simply has the datestamp of the forecast. The yhat column contains
    the value of the forecast. You can see how Prophet uses y for the actual value
    and yhat for the predicted value as a naming convention. Then, yhat_lower and
    yhat_upper represent the lower and upper bounds of the 80% confidence interval
    of the forecast. This means that there is an 80% chance that the forecast will
    fall between yhat_lower and yhat_upper, with yhat being the value that we expect
    to obtain.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只对这四个列感兴趣：ds、yhat、yhat_lower 和 yhat_upper。ds 列简单地包含预测的日期戳。yhat 列包含预测的值。你可以看到
    Prophet 如何使用 y 表示实际值，使用 yhat 表示预测值作为命名约定。然后，yhat_lower 和 yhat_upper 代表预测 80% 置信区间的下限和上限。这意味着有
    80% 的可能性预测值将落在 yhat_lower 和 yhat_upper 之间，其中 yhat 是我们期望获得的价值。
- en: We can now join test and forecast together, to create a single `DataFrame` holding
    both the actual and predicted values.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将测试和预测合并在一起，创建一个包含实际值和预测值的单个 `DataFrame`。
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Before evaluating our mode, let’s implement a baseline, as our model can only
    be better in relation to a certain benchmark. Here, let’s apply the last season
    naive forecasting method, meaning that the last year of the training set is repeated
    as the forecast for next year.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估我们的模型之前，让我们先实现一个基线，因为我们的模型只有在与某个基准相比时才能变得更好。在这里，我们将应用上一个季度的简单预测方法，这意味着训练集的最后一年将被重复作为下一年的预测。
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Everything is set up to easily evaluate our model. We’ll use the mean absolute
    error (MAE) for its ease of interpretation. Note that the mean absolute percentage
    error (MAPE) is not suitable in this situation, because we have values that are
    close to 0, in which case the MAPE gets inflated.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的设置都是为了轻松评估我们的模型。我们将使用平均绝对误差（MAE）来评估其易于解释性。请注意，平均绝对百分比误差（MAPE）在这种情况下不适用，因为我们有接近0的值，在这种情况下，MAPE会被放大。
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This returns a baseline MAE of 2.87, while the MAE achieved by the Prophet model
    is 1.94\. Therefore, we achieve a lower MAE using Prophet, meaning that it is
    indeed better than the baseline. This means that, on average, our model predicts
    the daily minimum temperature with a difference of 1.94 degrees Celsius, either
    above or below the observed value.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了一个基线 MAE 为 2.87，而 Prophet 模型实现的 MAE 为 1.94。因此，我们使用 Prophet 实现了更低的 MAE，这意味着它确实比基线更好。这意味着，平均而言，我们的模型预测的每日最低温度与观察值之间的差异为
    1.94 摄氏度，要么高于，要么低于观察值。
- en: We can optionally plot the forecasts, as well as the confidence interval from
    Prophet. The result is shown in figure 19.3.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择绘制预测图，以及 Prophet 的置信区间。结果如图 19.3 所示。
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![](../../OEBPS/Images/19-03.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/19-03.png)'
- en: Figure 19.3 Forecasting the daily minimum temperature for the year 1990\. We
    can see that the forecast from Prophet, shown as a dashed line, is smoother than
    the baseline, clearly demonstrating the curve-fitting property of Prophet.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.3 预测 1990 年的每日最低温度。我们可以看到，Prophet 的预测（以虚线表示）比基线更平滑，这清楚地展示了 Prophet 的曲线拟合特性。
- en: You’ll see that the Prophet forecast looks more like a curve-fitting procedure,
    since its forecast, shown as a dashed line in figure 19.3, is a smooth curve that
    seems to filter the noisier fluctuations in the data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到 Prophet 的预测看起来更像是一个曲线拟合过程，因为其预测（如图 19.3 中的虚线所示）是一条平滑的曲线，似乎过滤了数据中的噪声波动。
- en: Using Prophet allowed us to generate accurate forecasts with very few lines
    of code. However, we have only scratched the surface in terms of Prophet’s functionality.
    This is only the basic workflow of using Prophet. In the next section, we’ll explore
    more advanced Prophet functions, such as visualization techniques and fine-tuning
    procedures, as well as cross-validation and evaluation methods.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Prophet 允许我们用很少的代码行生成准确的预测。然而，我们在 Prophet 的功能方面只是触及了皮毛。这仅仅是使用 Prophet 的基本工作流程。在下一节中，我们将探索更多高级的
    Prophet 功能，例如可视化技术和微调过程，以及交叉验证和评估方法。
- en: 19.4 Exploring Prophet’s advanced functionality
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.4 探索 Prophet 的高级功能
- en: 'We’ll now explore Prophet’s more advanced functionality. These advanced functions
    can be separated into three categories: visualization, performance diagnosis,
    and hyperparameter tuning. We’ll work with the same dataset as in the previous
    section, and I highly recommend that you work in the same Jupyter Notebook or
    Python script as before.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探索Prophet的更高级功能。这些高级功能可以分为三个类别：可视化、性能诊断和超参数调整。我们将使用与上一节相同的dataset，并且我强烈建议你在之前的Jupyter
    Notebook或Python脚本中继续工作。
- en: 19.4.1 Visualization capabilities
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.4.1 可视化功能
- en: Prophet comes with many methods that allow us to quickly visualize a model’s
    predictions or its different components.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet提供了许多方法，使我们能够快速可视化模型预测或其不同成分。
- en: First of all, we can quickly generate a plot of our forecasts simply by using
    the `plot` method. The result is shown in figure 19.4.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以通过简单地使用`plot`方法快速生成我们的预测图表。结果如图19.4所示。
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](../../OEBPS/Images/19-04.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/19-04.png)'
- en: Figure 19.4 Plotting our predictions using Prophet. The black dots represent
    the training data, while the solid continuous line represents the model’s predictions.
    The shaded band surrounding the line represents an 80% confidence interval.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.4 使用Prophet绘制我们的预测。黑色点代表训练数据，而实线代表模型的预测。围绕线的阴影带代表80%的置信区间。
- en: We can also display the different components used in our model with the `plot_
    components` method.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`plot_components`方法显示我们模型中使用的不同成分。
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The resulting plot is shown in figure 19.5\. The top plot shows the trend component,
    as well as the uncertainty in the trend for the forecast period. Looking closely,
    you’ll see that the trend changes over time, with there being six different trends.
    We’ll explore that in more detail later.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的图表显示在图19.5中。顶部图表显示了趋势成分以及预测期间趋势的不确定性。仔细观察，你会发现趋势随时间变化，共有六个不同的趋势。我们将在稍后更详细地探讨这一点。
- en: '![](../../OEBPS/Images/19-05.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/19-05.png)'
- en: Figure 19.5 Displaying the components of our model. Here our model uses a trend
    component and two different seasonal components—one with a weekly period and the
    other with a yearly period.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.5显示了我们的模型成分。在这里，我们的模型使用了一个趋势成分和两个不同的季节成分——一个具有每周周期，另一个具有年度周期。
- en: 'The two bottom plots in figure 19.5 show two different seasonal components:
    one with a weekly period and the other with a yearly period. The yearly seasonality
    makes sense, as the summer months (December to February, since Australia is in
    the southern hemisphere) see hotter temperatures than the winter months (June
    to August). However, the weekly seasonal component is rather odd. While it may
    help the model produce a better forecast, I doubt there is a meteorological phenomenon
    that can explain weekly seasonality in daily minimum temperatures. Thus, this
    component likely helps the model achieve a better fit and a better forecast, but
    it is hard to explain its presence.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.5的底部两个图表显示了两个不同的季节成分：一个具有每周周期，另一个具有年度周期。年度季节性是有意义的，因为夏季月份（12月至2月，因为澳大利亚位于南半球）比冬季月份（6月至8月）更热。然而，每周的季节性成分相当奇怪。虽然这可能有助于模型产生更好的预测，但我怀疑没有气象现象可以解释每日最低温度的每周季节性。因此，这个成分可能有助于模型达到更好的拟合和更好的预测，但很难解释其存在。
- en: Alternatively, Prophet allows us to plot only the seasonal component. Specifically,
    we can plot the weekly seasonality using the `plot_weekly` method or the yearly
    seasonality with the `plot_yearly` method. The result for the latter is shown
    in figure 19.6.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，Prophet允许我们仅绘制季节成分。具体来说，我们可以使用`plot_weekly`方法绘制每周的季节性，或者使用`plot_yearly`方法绘制年度季节性。后者的结果如图19.6所示。
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![](../../OEBPS/Images/19-06.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/19-06.png)'
- en: Figure 19.6 Plotting the yearly seasonal component of our data. This is equivalent
    to the third plot in figure 19.5.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.6展示了我们数据的年度季节成分。这相当于图19.5中的第三个图表。
- en: You’ll recognize the yearly seasonal component of our data, as it is the same
    plot as the third plot in figure 19.5\. However, this method allows us to visualize
    how changing the number of terms to estimate the seasonal component can impact
    our model. Recall that Prophet uses 10 terms in the Fourier series to estimate
    the yearly seasonality. Now let’s visualize the seasonal component if 20 terms
    are used for the estimation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你会认出我们数据的年度季节性成分，因为它与图19.5中的第三个图是相同的。然而，这种方法允许我们可视化改变估计季节性成分的项数如何影响我们的模型。回想一下，Prophet使用傅里叶级数中的10个项来估计年度季节性。现在让我们可视化如果使用20个项进行估计的季节性成分。
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In figure 19.7 the yearly seasonal component shows more fluctuation than in
    figure 19.6, meaning that it is more sensitive. Tuning this parameter can lead
    to overfitting if too many terms are used, or to underfitting if we reduce the
    number of terms in the Fourier series. This parameter is rarely changed, but it
    is interesting to see that Prophet comes with this fine-tuning functionality.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在图19.7中，年度季节性成分的波动比图19.6中更大，这意味着它更敏感。如果使用过多的项，调整此参数可能导致过度拟合；如果我们减少傅里叶级数中的项数，则可能导致欠拟合。这个参数很少改变，但有趣的是看到Prophet附带这种微调功能。
- en: '![](../../OEBPS/Images/19-07.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/19-07.png)'
- en: Figure 19.7 Using 20 terms to estimate the yearly seasonal component in our
    data. Compared to figure 19.6, this view of the seasonal component is more sensitive,
    since it shows more variation across time. This can potentially lead to overfitting.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.7使用20个项来估计我们数据中的年度季节性成分。与图19.6相比，这种季节性成分的视图更敏感，因为它显示了更多的时间变化。这可能导致过度拟合。
- en: Finally, we saw in figure 19.5 that the trend changed over time, and we could
    identify six unique trends. Prophet can identify these trend *changepoints*. We
    can visualize them using the `add_changepoints_to_plot` method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在图19.5中看到趋势随时间变化，并且我们可以识别出六个独特趋势。Prophet可以识别这些趋势的*变化点*。我们可以使用`add_changepoints_to_plot`方法来可视化它们。
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The result is shown in figure 19.8\. Notice that Prophet identifies points in
    time where the trend changes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如图19.8所示。请注意，Prophet识别出趋势变化的时间点。
- en: '![](../../OEBPS/Images/19-08.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/19-08.png)'
- en: Figure 19.8 Showing trend changepoints in our model. Each point where the trend
    changes is identified by a vertical dashed line. Notice that there are six vertical
    dashed lines, matching the six different trend slopes in the top plot of figure
    19.5.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.8展示了模型中的趋势变化点。每个趋势变化点都由一条垂直虚线标识。请注意，有六条垂直虚线，与图19.5顶部图中的六个不同的趋势斜率相匹配。
- en: We’ve explored the most important visualization capabilities of Prophet, so
    let’s move on to using cross-validation to diagnose our model in more detail.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了Prophet最重要的可视化功能，现在让我们继续使用交叉验证来更详细地诊断我们的模型。
- en: 19.4.2 Cross-validation and performance metrics
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.4.2 交叉验证和性能指标
- en: Prophet comes with an important cross-validation capability, allowing us to
    forecast over multiple periods in our dataset to ensure that we have a stable
    model. This is similar to a rolling forecast procedure.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet附带一个重要的交叉验证功能，允许我们在数据集的多个时期进行预测，以确保我们有一个稳定的模型。这类似于滚动预测程序。
- en: '![](../../OEBPS/Images/19-09.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/19-09.png)'
- en: Figure 19.9 Illustrating the cross-validation procedure in Prophet. The entire
    rectangle represents the training set, and an initial subset of the set is identified
    to fit the model. At a certain cutoff date, the model produces a forecast over
    a set horizon. In the next step, more data is added to the training subset, and
    the model makes predictions over another period of time. The process is then repeated
    until the horizon exceeds the length of the training set.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.9展示了Prophet中的交叉验证过程。整个矩形代表训练集，并确定集合的一个初始子集来拟合模型。在某个截止日期，模型在一定的预测范围内进行预测。在下一步中，更多的数据被添加到训练子集中，模型在另一个时间段内进行预测。然后重复此过程，直到预测范围超过训练集的长度。
- en: Recall that with time series, the order of the data must remain the same. Therefore,
    cross-validation is performed by training the model on a subset of the training
    data and forecasting on a certain horizon. Figure 19.9 shows how we start by defining
    a subset within the training set and use it to fit the model and generate predictions.
    Then we add more data to the initial subset, and predict for another period of
    time. This process is repeated until the entire training set is used.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，对于时间序列，数据的顺序必须保持不变。因此，交叉验证是通过在训练数据的一个子集上训练模型并在一定预测期限上进行预测来进行的。图19.9显示了我们是怎样首先在训练集中定义一个子集，并使用它来拟合模型和生成预测。然后我们向初始子集添加更多数据，并预测另一个时间段。这个过程会重复进行，直到整个训练集都被使用。
- en: You’ll notice the resemblance to rolling forecasts, but this time we are using
    this technique for cross-validation, to ensure that we have a stable model. A
    stable model is one with an evaluation metric that is fairly constant over each
    forecast period, keeping the horizon constant. In other words, the performance
    of our model should be constant, whether it must forecast 365 days starting in
    January or starting in July.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这与滚动预测相似，但这次我们使用这种技术进行交叉验证，以确保我们有一个稳定的模型。一个稳定的模型是指在每个预测期间，评估指标相对恒定，保持预测期限不变。换句话说，无论模型必须从1月还是从7月开始预测365天，我们的模型性能都应该保持恒定。
- en: Prophet’s `cross_validation` function requires a Prophet model that has been
    fit to training data. Then we must specify an initial length for the training
    set in the cross-validation process, denoted as `initial`. The next parameter
    is the length of time separating each cutoff date, denoted as `period`. Finally,
    we must specify the horizon of the forecast, denoted as `horizon`. These three
    parameters must have units that are compatible with the `pandas.Timedelta` class
    ([https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.xhtml](https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.xhtml)).
    In other words, the largest unit is days, and the smallest unit is nanoseconds.
    Anything in between, such as hours, minutes, seconds, or milliseconds, will work
    as well.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet的`cross_validation`函数需要一个已经拟合到训练数据的Prophet模型。然后我们必须在交叉验证过程中指定训练集的初始长度，表示为`initial`。下一个参数是每个截止日期之间的时间长度，表示为`period`。最后，我们必须指定预测期限，表示为`horizon`。这三个参数必须与`pandas.Timedelta`类的单位兼容([https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.xhtml](https://pandas.pydata.org/docs/reference/api/pandas.Timedelta.xhtml))。换句话说，最大的单位是天，最小的单位是纳秒。介于两者之间的任何单位，如小时、分钟、秒或毫秒，都可以正常工作。
- en: By default, Prophet uses `horizon` to determine the length of `initial` and
    `period`. It sets `initial` to three times the length of `horizon` and `period`
    to half the length of `horizon`. Of course, we can tweak this behavior to meet
    our needs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Prophet使用`horizon`来确定`initial`和`period`的长度。它将`initial`设置为`horizon`长度的三倍，将`period`设置为`horizon`长度的一半。当然，我们可以调整这种行为以满足我们的需求。
- en: Let’s start with an initial training period of 730 days, which represents two
    years of data. The horizon will be 365 days, and each cutoff date will be separated
    by 180 days, which is roughly half a year. Given our training set size, our cross-validation
    procedure has 13 steps. The output of the procedure is a `DataFrame` with the
    datestamp, the forecast, its upper and lower bounds, the actual value, and the
    cutoff date, as shown in figure 19.10.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从730天的初始训练期开始，这代表了两年的数据。预测的期限将是365天，每个截止日期之间相隔180天，大约是半年。考虑到我们的训练集大小，我们的交叉验证过程有13个步骤。该过程的输出是一个包含日期戳、预测值、上下限、实际值和截止日期的`DataFrame`，如图19.10所示。
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ The initial training set has 2 years of data. Each cutoff date is separated
    by 180 days, or half a year. The forecast horizon is 365 days, which is a year.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始训练集包含2年的数据。每个截止日期之间相隔180天，即半年。预测期限是365天，即一年。
- en: '![](../../OEBPS/Images/19-10.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/19-10.png)'
- en: Figure 19.10 The first five rows of our cross-validation `DataFrame`. We can
    see the predictions, the upper and lower bounds, as well as the cutoff date.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.10 我们交叉验证`DataFrame`的前五行。我们可以看到预测值、上下限以及截止日期。
- en: With cross-validation done, we can use the `performance_metrics` function to
    evaluate the performance of the model over the multiple forecasting periods. We
    pass in the output of cross-validation, which is `df_cv`, and we set the `rolling_window`
    parameter. This parameter determines the portion of data over which we want to
    compute the error metric. Setting it to 0 means that each evaluation metric is
    computed for each forecast point. Setting it to 1 averages the evaluation metrics
    over the entire horizon. Here, let’s set it to 0.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉验证完成后，我们可以使用`performance_metrics`函数评估模型在多个预测周期内的性能。我们传入交叉验证的输出，即`df_cv`，并设置`rolling_window`参数。此参数确定我们想要计算误差度量数据的一部分。将其设置为0表示为每个预测点计算每个评估指标。将其设置为1表示在整个时间跨度上平均评估指标。在这里，让我们将其设置为0。
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output of this procedure is shown in figure 19.11\. The MAPE is not included,
    since Prophet automatically detected that we have values close to 0, which makes
    the MAPE an unsuitable evaluation metric.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程的输出如图19.11所示。MAPE不包括在内，因为Prophet自动检测到我们有一些接近0的值，这使得MAPE成为一个不合适的评估指标。
- en: '![](../../OEBPS/Images/19-11.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片19-11](../../OEBPS/Images/19-11.png)'
- en: Figure 19.11 The first five rows of the evaluation `DataFrame`. We can see different
    performance metrics over different horizons, allowing us to visualize how the
    performance varies according to the horizon.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.11 评估`DataFrame`的前五行。我们可以看到在不同时间跨度上的不同性能指标，这使我们能够可视化性能如何随时间跨度而变化。
- en: Finally, we can visualize the evolution of an evaluation metric over the horizon.
    This allows us to determine whether the error increases as the model predicts
    further in time or if it remains relatively stable. Again, we’ll use the MAE,
    as this is how we first evaluated our model.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以可视化评估指标随时间跨度的演变。这使我们能够确定误差是否会随着模型预测时间的进一步增加而增加，或者它是否保持相对稳定。再次，我们将使用MAE，因为这是我们最初评估模型的方式。
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The result is shown in figure 19.12\. Ideally, we will see a fairly flat line,
    like in figure 19.12, as it means that the error in our predictions does not increase
    as the model predicts further in time. If the error increases, we should revise
    the forecast horizon or make sure that we are comfortable with an increasing error.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如图19.12所示。理想情况下，我们将看到一条相当平坦的线，如图19.12所示，这意味着我们的预测误差不会随着模型预测时间的进一步增加而增加。如果误差增加，我们应该修改预测时间跨度或确保我们能够接受误差的增加。
- en: '![](../../OEBPS/Images/19-12.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片19-12](../../OEBPS/Images/19-12.png)'
- en: Figure 19.12 Evolution of the MAE over the forecast horizon. Each dot represents
    the absolute error for one of the 13 forecast periods, while the solid line averages
    them over time. The line is fairly flat, meaning that we have a stable model where
    the error does not increase as it predicts further in time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.12 预测时间跨度上MAE的演变。每个点代表13个预测周期中的一个预测期的绝对误差，而实线则是随时间平均这些误差。线相当平坦，这意味着我们有一个稳定的模型，其中误差不会随着预测时间的进一步增加而增加。
- en: Now that you’ve seen Prophet’s cross-validation capability, we’ll look at hyperparameter
    tuning. Combining the two will result in a robust way of finding an optimal model
    for our problem.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了Prophet的交叉验证能力，我们将探讨超参数调整。将这两者结合起来将为我们找到问题的最佳模型提供一种稳健的方法。
- en: 19.4.3 Hyperparameter tuning
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.4.3 超参数调整
- en: We can combine hyperparameter tuning and cross-validation in Prophet to design
    a robust process that automatically identifies the best parameter combination
    to fit our data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Prophet中将超参数调整和交叉验证结合起来，设计一个健壮的过程，该过程可以自动识别最佳的参数组合以适应我们的数据。
- en: 'Prophet comes with many parameters that can be fine-tuned by more advanced
    users in order to produce better forecasts. Four parameters are usually tuned:
    `changepoint_prior_scale`, `seasonality_prior_scale`, `holidays_prior_scale`,
    and `seasonality_mode`. Other parameters can technically be changed, but they
    are often redundant forms of the preceding parameters:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet附带了许多参数，这些参数可以通过更高级的用户进行微调以产生更好的预测。通常调整四个参数：`changepoint_prior_scale`、`seasonality_prior_scale`、`holidays_prior_scale`和`seasonality_mode`。技术上可以更改其他参数，但它们通常是前面参数的冗余形式：
- en: '`changepoint_prior_scale`—The `changepoint_prior_scale` parameter is said to
    be the most impactful parameter in Prophet. It determines the flexibility of the
    trend, and particularly how much the trend changes at the trend changepoints.
    If the parameter is too small, the trend will underfit, and the variance observed
    in the data will be treated as noise. If it is set too high, the trend will overfit
    to noisy fluctuations. Using the range [0.001, 0.01, 0.1, 0.5] is enough to have
    a well-fitted model.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`changepoint_prior_scale`—据说`changepoint_prior_scale`参数是Prophet中最有影响力的参数。它决定了趋势的灵活性，特别是趋势变化点处的趋势变化程度。如果参数太小，趋势将欠拟合，数据中观察到的方差将被视为噪声。如果设置得太高，趋势将过度拟合噪声波动。使用范围[0.001,
    0.01, 0.1, 0.5]就足以得到一个拟合良好的模型。'
- en: '`seasonality_prior_scale`—The `seasonality_prior_scale` parameter sets the
    flexibility of the seasonality. A large value allows the seasonal component to
    fit smaller fluctuations, while a small value will result in a smoother seasonal
    component. Using the range [0.01, 0.1, 1.0, 10.0] generally works well to find
    a good model.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seasonality_prior_scale`—`seasonality_prior_scale`参数设置季节性的灵活性。大值允许季节性成分拟合较小的波动，而小值将导致更平滑的季节性成分。使用范围[0.01,
    0.1, 1.0, 10.0]通常可以找到良好的模型。'
- en: '`holidays_prior_scale`—The `holidays_prior_scale` parameter sets the flexibility
    of the holiday effects and works just like `seasonality_prior_scale`. It can be
    tuned using the same range, [0.01, 0.1, 1.0, 10.0].'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`holidays_prior_scale`—`holidays_prior_scale`参数设置假日效应的灵活性，它的工作方式与`seasonality_prior_scale`相同。它可以使用相同的范围进行微调，即[0.01,
    0.1, 1.0, 10.0]。'
- en: '`seasonality_mode`—The `seasonality_mode` parameter can be either `additive`
    or `multiplicative`. By default, it is additive, but it can be set to multiplicative
    if you see that the seasonal fluctuation gets larger over time. This can be observed
    by plotting the time series, but when in doubt, you can include it in the hyperparameter
    tuning process. Our current dataset of historical daily minimum temperature is
    a great example of additive seasonality, as the yearly fluctuations do not increase
    over time. An example of multiplicative seasonality is shown in figure 19.13.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seasonality_mode`—`seasonality_mode`参数可以是`additive`或`multiplicative`。默认情况下，它是加性的，但如果您发现季节性波动随时间增大，则可以将其设置为乘法。这可以通过绘制时间序列来观察，但在有疑问的情况下，您可以将它包含在超参数调整过程中。我们当前的历史每日最低温度数据集是一个很好的加性季节性示例，因为年波动随时间不会增加。图19.13展示了乘性季节性的一个示例。'
- en: '![](../../OEBPS/Images/19-13.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/19-13.png)'
- en: Figure 19.13 Example of multiplicative seasonality. This is taken from the capstone
    project in chapter 11, where we predicted the monthly volume of antidiabetic drug
    prescriptions in Australia. We not only saw a yearly seasonality, but we also
    noticed that the fluctuations get larger as we move through time.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.13示例：乘法季节性。此图取自第11章的终期项目，其中我们预测了澳大利亚抗糖尿病药物处方的月度数量。我们不仅看到了年度季节性，而且还注意到随着时间的推移，波动幅度越来越大。
- en: Let’s combine hyperparameter tuning and cross-validation to find the best model
    parameters for forecasting the daily minimum temperature. We’ll use only `changepoint_prior_scale`
    and `seasonality_prior_scale` in this example, since we do not have any holiday
    effects and our seasonal component is additive.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将超参数调整和交叉验证结合起来，以找到预测每日最低温度的最佳模型参数。在这个例子中，我们只使用`changepoint_prior_scale`和`seasonality_prior_scale`，因为我们没有假日效应，我们的季节性成分是加性的。
- en: We’ll first define the range of values to try for each parameter and generate
    a list of unique combinations of parameters. Then, for each unique combination
    of parameters, we’ll train a model and perform cross-validation. We will then
    evaluate the model using a `rolling_window` of 1 to speed up the process and average
    the evaluation metric over the entire forecasting period. We’ll finally store
    the parameter combinations and their associated MAE to find the best parameter
    combination. The combination with the lowest MAE will be deemed to be the best.
    We’ll use the MAE because we have been using it since the beginning of this project.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义每个参数尝试的值范围，并生成一个参数唯一组合列表。然后，对于每个唯一的参数组合，我们将训练一个模型并执行交叉验证。我们将使用1个`rolling_window`来评估模型，以加快过程并在整个预测期间平均评估指标。最后，我们将存储参数组合及其相关的MAE，以找到最佳参数组合。MAE最低的组合将被认为是最佳的。我们将使用MAE，因为我们从项目开始就一直使用它。
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Create a list of unique parameter combinations.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个唯一参数组合列表。
- en: ❷ For each unique combination, do the next three steps.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对于每个独特的组合，执行接下来的三个步骤。
- en: ❸ Fit a model.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 拟合模型。
- en: ❹ Perform cross-validation. We can speed up the process by using parallelization.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 执行交叉验证。我们可以通过使用并行化来加速这个过程。
- en: ❺ Evaluate the model with a rolling_window of 1\. This averages the performance
    over the entire forecast horizon.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用 1 的滚动窗口评估模型。这将在整个预测范围内平均性能。
- en: ❻ Organize the results in a DataFrame.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将结果组织到 DataFrame 中。
- en: 'The parameters achieving the lowest MAE can now be found:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以找到实现最低 MAE 的参数：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this case, both `changepoint_prior_scale` and `seasonality_prior_scale` should
    be set to 0.01.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`changepoint_prior_scale` 和 `seasonality_prior_scale` 都应设置为 0.01。
- en: This concludes our exploration of Prophet’s advanced functionality. We have
    mostly worked with them in discovery mode, so let’s solidify what you’ve learned
    by designing and implementing a forecast that uses Prophet’s more advanced functions,
    such as cross-validation and hyperparameter tuning, to automate the forecasting
    process.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们对 Prophet 高级功能的探索结束。我们主要在发现模式下使用它们，因此让我们通过设计和实施一个使用 Prophet 更高级功能的预测来巩固你所学的知识，例如交叉验证和超参数调整，以自动化预测流程。
- en: 19.5 Implementing a robust forecasting process with Prophet
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.5 使用 Prophet 实现稳健的预测流程
- en: Having explored Prophet’s advanced functionality, we’ll now design a robust
    and automated forecasting process with Prophet. This step-by-step system will
    allow us to automatically find the best model that Prophet can build for a particular
    problem.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 探索了 Prophet 的高级功能后，我们现在将使用 Prophet 设计一个强大且自动化的预测流程。这个逐步的系统将使我们能够自动找到 Prophet
    为特定问题构建的最佳模型。
- en: Keep in mind that finding the best Prophet model does not mean that Prophet
    is the optimal solution to all problems. This process will simply identify the
    best possible outcome when using Prophet. It is recommended that you test various
    models, using either deep learning or statistical techniques, along with a baseline
    model, of course, to ensure that you find the best possible solution to your forecasting
    problem.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，找到最佳的 Prophet 模型并不意味着 Prophet 是解决所有问题的最佳解决方案。这个过程只是在使用 Prophet 时确定最佳可能的结果。建议您测试各种模型，无论是深度学习还是统计技术，当然，还包括基线模型，以确保您找到解决预测问题的最佳解决方案。
- en: '![](../../OEBPS/Images/19-14.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/19-14.png)'
- en: Figure 19.14 Forecasting process using Prophet. First, we’ll ensure that the
    dataset has the right column names for Prophet and that the date is expressed
    correctly as a datestamp or a timestamp. Then, we’ll combine hyperparameter tuning
    with cross-validation to obtain the optimal parameters for our model. We’ll finally
    fit the model using the optimal parameters and evaluate it on a test set.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.14 使用 Prophet 的预测过程。首先，我们将确保数据集具有 Prophet 正确的列名，并且日期以日期戳或时间戳正确表达。然后，我们将超参数调整与交叉验证结合起来，以获得我们模型的最佳参数。最后，我们将使用最佳参数拟合模型，并在测试集上评估它。
- en: Figure 19.14 illustrates the forecasting process with Prophet to ensure that
    we obtain the optimal Prophet model. We’ll first ensure that the columns are named
    and formatted correctly for Prophet. Then we’ll combine cross-validation and hyperparameter
    tuning to obtain the best parameter combination, fit the model, and evaluate it
    on a test set. It is a fairly straightforward process, which is to be expected.
    Prophet does much of the heavy lifting for us, allowing us to quickly experiment
    and come up with a model.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.14 展示了使用 Prophet 的预测过程，以确保我们获得最佳的 Prophet 模型。我们首先确保列名和格式正确，以便 Prophet 使用。然后，我们将交叉验证和超参数调整结合起来，以获得最佳参数组合，拟合模型，并在测试集上评估它。这是一个相当直接的过程，这是可以预料的。Prophet
    为我们做了很多繁重的工作，使我们能够快速实验并制定出模型。
- en: Let’s apply this procedure to yet another forecasting project. It involves monthly
    data, which Prophet handles in a particular way. Furthermore, we’ll work with
    data that is potentially affected by holiday effects, giving us the opportunity
    to work with a function of Prophet that we have not explored yet.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个程序应用到另一个预测项目上。该项目涉及月度数据，Prophet 以特定方式处理这些数据。此外，我们将处理可能受节假日影响的数据，这为我们提供了一个机会，去探索我们尚未探索过的
    Prophet 的一个函数。
- en: '19.5.1 Forecasting project: Predicting the popularity of “chocolate” searches
    on Google'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.5.1 预测项目：预测 Google 上“巧克力”搜索的热度
- en: For this project, we’ll try to predict the popularity of the search term “chocolate”
    on Google. Predicting the popularity of search terms can help marketing teams
    better optimize their bidding for a particular keyword, which of course impacts
    the cost-per-click on an ad, ultimately affecting the entire return on investment
    of a marketing campaign. It can also give insight into consumer behavior. For
    example, if we know that next month is likely to see a surge in people searching
    for chocolate, it can make sense for a chocolate shop to offer discounts and ensure
    that they have enough supply to meet the demand.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将尝试预测谷歌上搜索词“巧克力”的流行度。预测搜索词的流行度可以帮助营销团队更好地优化特定关键词的出价，这当然会影响广告的点击成本，最终影响整个营销活动的投资回报率。它还可以提供对消费者行为的洞察。例如，如果我们知道下个月可能会看到人们搜索巧克力的激增，那么巧克力店提供折扣并确保有足够的供应来满足需求是有意义的。
- en: The data for this project comes directly from Google Trends ([https://trends.google.com/trends/explore?date=all&geo=US&q=chocolate](https://trends.google.com/trends/explore?date=all&geo=US&q=chocolate)),
    and it shows the monthly popularity of the keyword “chocolate” in the United States,
    from 2004 to today. Note that this chapter was written before the end of 2021,
    so visiting the link now will not result in the exact same dataset. I have included
    the dataset I used as a CSV file on GitHub to ensure that you can recreate the
    work presented here.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的数据直接来自谷歌趋势（[https://trends.google.com/trends/explore?date=all&geo=US&q=chocolate](https://trends.google.com/trends/explore?date=all&geo=US&q=chocolate)），它显示了从2004年到今天美国“巧克力”关键词的月度流行度。请注意，本章是在2021年底之前编写的，所以现在访问该链接不会得到完全相同的数据库。我已经在GitHub上包含了我使用的CSV文件，以确保您可以重现这里展示的工作。
- en: We’ll kick off this project by reading the data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个项目开始，读取数据。
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The dataset contains 215 rows of data from January 2014 to December 2021\.
    The dataset also has two columns: one with the year and month, and one with the
    measured popularity of “chocolate” searches. We can plot the evolution of the
    keyword searches over time—the result is shown in figure 19.15\. The plot shows
    strongly seasonal data with repeated peaks every year. We can also see a clear
    trend, as the data increases over time.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该数据集包含从2014年1月到2021年12月的215行数据。数据集还包括两列：一列是年份和月份，另一列是“巧克力”搜索的测量流行度。我们可以绘制关键词搜索随时间演化的图表——结果如图19.15所示。该图表显示了具有每年重复峰值的高度季节性数据。我们还可以看到明显的趋势，因为随着时间的推移，数据在增加。
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![](../../OEBPS/Images/19-15.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图19.15](../../OEBPS/Images/19-15.png)'
- en: Figure 19.15 Popularity of the keyword “chocolate” in Google searches in the
    United States from January 2004 to December 2021\. The values are expressed as
    a proportion relative to the period where the search term was the most popular,
    which occurs in December 2020 and has a value of 100\. Therefore, a value of 50
    for a particular month means that the keyword “chocolate” was searched for half
    as often, relative to the month of December 2020.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.15展示了从2004年1月到2021年12月美国谷歌搜索中“巧克力”关键词的流行度。数值表示相对于搜索词在2020年12月最流行的时期（值为100）的比例。因此，特定月份的值为50意味着相对于2020年12月，“巧克力”关键词的搜索频率减半。
- en: There are two elements that make this dataset very interesting to model with
    Prophet. First, it is likely that we have holiday effects in action. For example,
    Christmas is a holiday in the United States, and it is quite common to offer chocolate
    for Christmas. The next element is that we have monthly data. While Prophet can
    be used to model monthly data, some tweaking must be done to ensure that we get
    good results. Out of the box, Prophet can work with daily and sub-daily data,
    but monthly data requires a bit of extra work.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据集有两个元素使得它非常适合用Prophet进行建模。首先，我们可能存在假日效应。例如，圣诞节在美国是一个假日，而且提供巧克力作为圣诞礼物是很常见的。下一个元素是我们有月度数据。虽然Prophet可以用来建模月度数据，但必须进行一些调整以确保我们得到好的结果。Prophet默认可以处理日和亚日数据，但月度数据需要一些额外的工作。
- en: Following our forecasting process with Prophet, shown earlier in figure 19.14,
    we’ll start by renaming our columns following Prophet’s naming convention. Recall
    that Prophet expects the date column to be named ds, while the value column must
    be named y.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Prophet的预测流程中，如前图19.14所示，我们首先将根据Prophet的命名约定重命名我们的列。回想一下，Prophet期望日期列命名为ds，而值列必须命名为y。
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can now move on to verifying that the date is correctly formatted. In this
    case, we only have the year and the month, which does not respect the YYYY-MM-DD
    format expected by Prophet for a datestamp. We’ll therefore add a day to our date
    column. In this case, we have monthly data, which can only be obtained at the
    end of the month, so we’ll add the last day of the month to the datestamp.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续验证日期是否正确格式化。在这种情况下，我们只有年份和月份，这不符合Prophet期望的YYYY-MM-DD格式。因此，我们将向我们的日期列添加一天。在这种情况下，我们拥有月度数据，这些数据只能在月底获得，所以我们将月底的最后一天添加到日期戳中。
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Before we dive into hyperparameter tuning, we’ll first split our data into train
    and test sets, so we can perform hyperparameter tuning on the training set only
    and avoid data leakage. In this case, we’ll keep the last twelve months for the
    test set.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入超参数调整之前，我们首先将数据分为训练集和测试集，这样我们就可以只在训练集上执行超参数调整，避免数据泄露。在这种情况下，我们将保留最后十二个月作为测试集。
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We’ll now move on to the next step, where we’ll combine hyperparameter tuning
    and cross-validation to find the optimal parameter combination for our model.
    Just as we did before, we’ll define a range of values for each parameter we wish
    to tune and build a list containing each unique combination of values.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进入下一步，我们将结合超参数调整和交叉验证来找到我们模型的最佳参数组合。就像我们之前做的那样，我们将为每个我们希望调整的参数定义一个值范围，并构建一个包含每个唯一值组合的列表。
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note We will not optimize for `holidays_prior_scale` to save on time here,
    but feel free to add it as a tunable parameter with the following range of values:
    [0.01, 0.1, 1.0, 10.0].'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这里，我们将不会优化`holidays_prior_scale`以节省时间，但您可以将它作为一个具有以下值范围的可调整参数添加：[0.01, 0.1,
    1.0, 10.0]。
- en: Next, we’ll create a list to hold the evaluation metric that we’ll use to decide
    on the set of optimal parameters. We’ll use the MSE, because it penalizes large
    errors during the fitting process.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个列表来保存我们将使用的评估指标，以决定最优参数集。我们将使用均方误差（MSE），因为它在拟合过程中惩罚大误差。
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, because we are working with monthly data, we must define our own cutoff
    dates. Recall that the cutoff dates define the training and testing periods during
    cross-validation, as shown in figure 19.16\. Therefore, when working with monthly
    data, we must define our own list of cutoff dates to specify the initial training
    period and forecasting period for each step during the cross-validation process.
    This is a workaround that allows us to work with monthly data using Prophet.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们正在处理月度数据，我们必须定义我们自己的截止日期。回想一下，截止日期在交叉验证期间定义了训练期和测试期，如图19.16所示。因此，当我们处理月度数据时，我们必须定义我们自己的截止日期列表，以指定交叉验证过程中每一步的初始训练期和预测期。这是一个允许我们使用Prophet处理月度数据的解决方案。
- en: '![](../../OEBPS/Images/19-16.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/19-16.png)'
- en: Figure 19.16 The cutoff date sets a boundary between the training period and
    the forecast horizon during cross-validation. By defining a list of cutoff dates,
    we can specify the initial training period and forecast period for each step during
    cross-validation.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.16 截止日期在交叉验证期间设置了训练期和预测期之间的边界。通过定义一个截止日期列表，我们可以指定交叉验证过程中每一步的初始训练期和预测期。
- en: Here we’ll set the initial training period to be the first 5 years of data.
    Therefore, our first cutoff date will be 2009-01-31\. The last cutoff date can
    be set as the last row of the training set, and we’ll separate each cutoff date
    by 12 months, so that we have a model that forecasts a full year.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将初始训练期设置为数据的前5年。因此，我们的第一个截止日期将是2009-01-31。最后一个截止日期可以设置为训练集的最后一行，我们将每12个月分隔一个截止日期，以便我们有一个可以预测整年的模型。
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ The first cutoff date is 2009-01-31, giving us 5 years of initial training
    data on the first step of cross-validation. Each cutoff is separated by 12 months
    until the end of the training set, resulting in a forecast horizon of 1 year.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 第一个截止日期是2009-01-31，为我们提供了交叉验证第一步的5年初始训练数据。每个截止日期之间相隔12个月，直到训练集的末尾，从而实现了1年的预测期。
- en: With this step done, we can test each parameter combination using cross-validation
    and store their MSEs in a `DataFrame`. Note that we’ll add the holidays effect
    with the simple `add_country_holidays` method, and we’ll specify the country,
    which is the United States in this case.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一步后，我们可以使用交叉验证测试每个参数组合，并将它们的均方误差（MSEs）存储在一个`DataFrame`中。请注意，我们将使用简单的`add_country_holidays`方法添加节假日效应，并且我们将指定国家，在这种情况下是美国。
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Add the dates of the holidays in the United States.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加美国的节假日日期。
- en: The full code for hyperparameter tuning is shown in the following listing.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 超参数调整的完整代码如下所示。
- en: Listing 19.1 Hyperparameter tuning in Prophet with monthly data
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.1 使用月度数据在Prophet中进行超参数调整
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once this process is over, we can extract the optimal parameter combination.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个过程完成，我们就可以提取最佳参数组合。
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The result is that `changepoint_prior_scale` must be set to 0.01, and `seasonality_
    prior_scale` must be set to 0.01.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是`changepoint_prior_scale`必须设置为0.01，而`seasonality_prior_scale`也必须设置为0.01。
- en: Now that we have the optimal values for each parameter, we can fit the model
    on the entire training set to evaluate it later on the test set.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了每个参数的最佳值，我们可以在整个训练集上拟合模型，以便稍后在测试集上评估它。
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The next step is to obtain the forecast of our model for the same period as
    the test set and merge them with the test set for easier evaluation and plotting.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是获取与测试集相同时期的模型预测，并将它们与测试集合并，以便更容易评估和绘图。
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Before evaluating our model, we must have a benchmark, so we’ll use the last
    season as a baseline model.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估我们的模型之前，我们必须有一个基准，因此我们将使用上一个季节作为基线模型。
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We are now ready to evaluate our model from Prophet. We’ll use the MAE for its
    ease of interpretation.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以评估Prophet模型了。我们将使用MAE来评估其易于解释性。
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Prophet achieves an MAE of 7.42, while our baseline gets an MAE of 10.92\. Since
    the MAE of Prophet is lower, the model is better than the baseline.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Prophet实现了7.42的MAE，而我们的基线模型实现了10.92的MAE。由于Prophet的MAE较低，因此模型优于基线。
- en: We can optionally plot the forecasts, as shown in figure 19.17\. Note that this
    plot also shows the confidence interval of the Prophet model.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择绘制预测图，如图19.17所示。请注意，此图还显示了Prophet模型的置信区间。
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Plot 80% confidence interval of the Prophet model.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 绘制Prophet模型的80%置信区间。
- en: In figure 19.17 it is clear that the forecast from Prophet, shown as a dashed
    line, is closer to the actual values than the forecast from the baseline model,
    shown as a dotted line. This translates to a lower MAE for Prophet.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在图19.17中，很明显，Prophet的预测（以虚线表示）比基线模型的预测（以虚线表示）更接近实际值。这转化为Prophet的MAE更低。
- en: '![](../../OEBPS/Images/19-17.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/19-17.png)'
- en: Figure 19.17 Forecasting the popularity of “chocolate” searches on Google in
    the United States. The forecast from Prophet, shown as a dashed line, is much
    closer to the actual values than the baseline model, shown as a dotted line.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.17 预测美国Google上“巧克力”搜索的流行度。Prophet的预测，以虚线表示，比以虚线表示的基线模型更接近实际值。
- en: We can further discover how Prophet modeled our data by plotting the components
    of the model, as shown in figure 19.18.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过绘制模型组件，如图19.18所示，进一步了解Prophet如何模拟我们的数据。
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![](../../OEBPS/Images/19-18.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/19-18.png)'
- en: Figure 19.18 Components of the Prophet model. The trend component increases
    over time, as expected. We can also see the holidays component, which shows signals
    in the negatives. This is interesting, because it means that Prophet used holidays
    to determine when “chocolate” was not a popular search term. Finally, we have
    the yearly seasonal component, with peaks in January.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.18 Prophet模型的组成部分。趋势成分随时间增加，正如预期的那样。我们还可以看到节假日成分，它显示出负面的信号。这很有趣，因为它意味着Prophet使用了节假日来确定“巧克力”不是一个流行的搜索词。最后，我们有年度季节性成分，在1月份有峰值。
- en: In figure 19.18 you’ll see that the trend component in the first plot increases
    over time, just as we noted when we first plotted our data. The second plot shows
    the holiday effects, which is interesting because there are troughs in the negative.
    This means that Prophet used the list of holidays to determine when “chocolate”
    searches were likely to decrease. This counters our first intuition when we thought
    that holidays might determine when chocolate would be more popular. Finally, the
    third plot shows the yearly seasonality, with peaks occurring toward the end and
    beginning of the year, which corresponds to Christmas, New Year, and Valentine’s
    Day.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在图19.18中，您将看到第一个图中的趋势成分随时间增加，正如我们在首次绘制数据时所指出的。第二个图显示了节假日效应，这很有趣，因为负值中有低谷。这意味着Prophet使用了节假日列表来确定“巧克力”搜索可能减少的时间。这与我们最初的直觉相反，当时我们认为节假日可能决定巧克力更受欢迎的时间。最后，第三个图显示了年度季节性，峰值出现在年初和年末，这与圣诞节、新年和情人节相对应。
- en: '19.5.2 Experiment: Can SARIMA do better?'
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.5.2 实验：SARIMA能否做得更好？
- en: In the previous section, we used Prophet to forecast the popularity of searches
    on Google involving the keyword “chocolate” in the United States. Our model achieved
    a better performance than our baseline, but it would be interesting to see how
    a SARIMA model compares to Prophet in this situation. This section is optional,
    but it is a great occasion to revisit our modeling skills using statistical models,
    and it ultimately is a fun experiment.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用Prophet来预测美国涉及关键词“巧克力”的Google搜索的流行度。我们的模型比基线模型表现更好，但看到SARIMA模型在这种情况下与Prophet相比如何会很有趣。本节是可选的，但这是一个很好的机会，用统计模型回顾我们的建模技能，最终也是一个有趣的实验。
- en: Let’s start by importing the libraries that we need.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先导入我们需要的库。
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Next, we’ll check whether the data is stationary using the augmented Dickey-Fuller
    (ADF) test.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用增强迪基-富勒（ADF）测试来检查数据是否平稳。
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We get an ADF statistic of –2.03 and a p-value of 0.27\. Since the p-value is
    greater than 0.05, we fail to reject the null hypothesis and conclude that our
    series is not stationary.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个ADF统计量为-2.03和一个p值为0.27。由于p值大于0.05，我们未能拒绝零假设，并得出结论，我们的序列不是平稳的。
- en: Let’s difference our time series and test for stationarity again.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次对时间序列进行差分，并测试其平稳性。
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We now obtain an ADF statistic of –7.03 and a p-value that is much smaller than
    0.05, so we reject the null hypothesis and conclude that our series is now stationary.
    Since we differenced only once and did not take a seasonal difference, we set
    *d* = 1 and *D* = 0. Also, since we have monthly data, the frequency is *m* =
    12. As you can see, having seasonal data does not mean that we have to take a
    seasonal difference to make it stationary.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们得到了一个ADF统计量为-7.03，p值远小于0.05，因此我们拒绝零假设，并得出结论，我们的序列现在是平稳的。由于我们只差分了一次，没有进行季节差分，我们设置*d*
    = 1和*D* = 0。由于我们有月度数据，频率是*m* = 12。正如你所看到的，有季节数据并不意味着我们必须进行季节差分来使其平稳。
- en: Now we’ll use the `optimize_SARIMAX` function, as shown in listing 19.2, to
    find the values of *p*, *q*, *P*, and *Q* that minimize the Akaike information
    criterion (AIC). Note that although the function has SARIMAX in its name, we can
    use it to optimize any declination of the SARIMAX mode. In this case, we’ll optimize
    a SARIMA model simply by setting the exogenous variables to `None`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用`optimize_SARIMAX`函数，如列表19.2所示，来找到使赤池信息准则（AIC）最小化的*p*，*q*，*P*和*Q*的值。请注意，尽管该函数的名称中有SARIMAX，但我们可以使用它来优化SARIMAX模式的任何变体。在这种情况下，我们将通过将外生变量设置为`None`来优化一个SARIMA模型。
- en: Listing 19.2 Function to minimize the AIC of a SARIMAX model
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.2最小化SARIMAX模型AIC的函数
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To find the optimal parameters, we’ll first define a range of values for each
    and create a list of unique combinations. We can then pass that list to the `optimize_SARIMAX`
    function.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到最佳参数，我们首先为每个参数定义一个值范围，并创建一个唯一组合的列表。然后我们可以将此列表传递给`optimize_SARIMAX`函数。
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The resulting `DataFrame`, shown in figure 19.19, is interesting. The lowest
    AIC is 143.51 and the second-lowest AIC is 1,127.75\. The difference is very large,
    which hints that something is wrong with the first *p*, *d*, *P*, *Q* values.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的`DataFrame`（如图19.19所示）很有趣。最低的AIC是143.51，第二低的AIC是1,127.75。差异非常大，这表明第一组*p*，*d*，*P*，*Q*值有问题。
- en: '![](../../OEBPS/Images/19-19.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/19-19.png)'
- en: Figure 19.19 Ordering the parameters (*p*, *d*, *P*, *Q*) in ascending order
    of AIC. We can see a large difference between the first two entries of the `DataFrame`.
    This indicates that something is wrong with the first set of parameters, and we
    should choose the second set.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.19按AIC升序排列参数（*p*，*d*，*P*，*Q*）。我们可以看到`DataFrame`的前两个条目之间存在很大差异。这表明第一组参数有问题，我们应该选择第二组。
- en: We’ll thus use the second set of values, which sets the values *p*, *q*, *P*,
    and *Q* to 1, resulting in a SARIMA(1,1,1)(1,0,1)[12] model. We can fit a model
    on the training set using those values and study its residuals, which are shown
    in figure 19.20.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用第二组值，将*p*，*q*，*P*和*Q*的值设置为1，得到SARIMA(1,1,1)(1,0,1)[12]模型。我们可以使用这些值在训练集上拟合模型，并研究其残差，如图19.20所示。
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![](../../OEBPS/Images/19-20.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/19-20.png)'
- en: Figure 19.20 Residuals of the SARIMA(1,1,1)(1,0,1)[12] model. At the top left,
    you can see that the residuals are random, with no trend. At the top right, the
    distribution is close to a normal distribution, but there is some deviation on
    the right. This is further supported by the Q-Q plot at the bottom left, where
    we see a fairly straight line that lies on *y* = *x*, but there is a clear departure
    at the end. Finally, the correlogram at the bottom right shows no significant
    coefficients after lag 0, just like white noise.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.20 SARIMA(1,1,1)(1,0,1)[12]模型的残差。在左上角，你可以看到残差是随机的，没有趋势。在右上角，分布接近正态分布，但在右侧有一些偏差。这一点在左下角的Q-Q图中得到了进一步的支持，我们看到了一条相当直的线，它位于*y*
    = *x*上，但末端有明显的偏离。最后，右下角的 correlogram显示在滞后0之后没有显著系数，就像白噪声一样。
- en: At this point, it is hard to determine whether the residuals are close enough
    to white noise, so we’ll use the Ljung-Box test to determine if the residuals
    are independent and uncorrelated.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，很难确定残差是否足够接近白噪声，因此我们将使用Ljung-Box测试来确定残差是否独立且不相关。
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The returned p-values are all greater than 0.05, except the first one, which
    stands at 0.044\. Since all other nine p-values are greater than 0.05, we’ll assume
    we can reject the null hypothesis and conclude that this is as close as we can
    get our residuals to white noise.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的p值都大于0.05，除了第一个，它为0.044。由于其他九个p值都大于0.05，我们可以假设我们可以拒绝零假设，并得出结论，这是我们残差接近白噪声所能达到的极限。
- en: Next, let’s generate the predictions from the SARIMA model over the period of
    the test set.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们从测试集的时期生成SARIMA模型的预测。
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Finally, we’ll measure the MAE of the SARIMA model. Remember that our Prophet
    model had an MAE of 7.42, and the baseline achieved an MAE of 10.92.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将测量SARIMA模型的MAE。记住，我们的Prophet模型MAE为7.42，基线模型的MAE为10.92。
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, SARIMA achieves an MAE of 10.09\. It is better than the baseline, but
    it does not perform better than Prophet in this case.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，SARIMA模型实现了10.09的MAE。它比基线模型好，但在这个情况下并不比Prophet模型表现更好。
- en: 19.6 Next steps
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.6 下一步
- en: In this chapter, we explored the use of the Prophet library for automatic time
    series forecasting. Prophet uses a general additive model that combines a trend
    component, a seasonal component, and holiday effects.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用Prophet库进行自动时间序列预测的应用。Prophet使用一个组合趋势成分、季节成分和假日效应的广义加性模型。
- en: The main advantage of this library is that it allows us to quickly experiment
    and generate predictions. Many functions are available for visualizing and understanding
    our models, and more advanced functions are also available, allowing us to perform
    cross-validation and hyperparameter tuning.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个库的主要优势在于它允许我们快速实验并生成预测。许多函数可用于可视化和理解我们的模型，而且还有更多高级功能，允许我们执行交叉验证和超参数调整。
- en: While Prophet is widely used in the industry, it must not be considered a one-size-fits-all
    solution. Prophet works particularly well with strongly seasonal data that has
    many historical seasons. Thus, it is to be treated as another tool in our forecasting
    tool belt that can be tested along with other statistical or deep learning models.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Prophet在业界被广泛使用，但它不能被视为一种万能的解决方案。Prophet特别适用于具有许多历史季节的强季节性数据。因此，它应该被视为我们预测工具包中的另一个工具，可以与其他统计或深度学习模型一起测试。
- en: We’ve explored the fundamentals of time series forecasting throughout this book,
    and now you’ve seen one way to automate most of the manual work we did with statistical
    and deep learning models. I highly encourage you to browse through Prophet’s documentation
    for more granular information, as well as to explore the other libraries for automatic
    forecasting. Now that you know how to work with one library, transitioning to
    another is very easy.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们探讨了时间序列预测的基础，现在你已经看到了一种自动化我们使用统计和深度学习模型所做的大部分手动工作的方法。我强烈建议你浏览Prophet的文档以获取更详细的信息，并探索其他自动预测库。现在你已经知道如何使用一个库，转向另一个库是非常容易的。
- en: In the next chapter, we’ll work through a final capstone project and forecast
    the price of beef in Canada. This is a great occasion to apply the forecasting
    procedure we developed using Prophet, as well as to experiment with the other
    models you have learned so far to develop the best solution possible.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将完成一个最终的综合项目，并预测加拿大牛肉的价格。这是一个很好的机会来应用我们使用Prophet开发的预测程序，以及尝试你迄今为止学到的其他模型，以开发最佳解决方案。
- en: 19.7 Exercises
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.7 练习
- en: 'Here we’ll revisit problems from previous chapters but use Prophet to make
    forecasts. We can then compare the performance of Prophet to the previously built
    models. As always, the solution is available on GitHub: [https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH19](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH19).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将回顾前几章的问题，但使用 Prophet 进行预测。然后我们可以比较 Prophet 与之前构建的模型的性能。一如既往，解决方案可在 GitHub
    上找到：[https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH19](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH19)。
- en: 19.7.1 Forecast the number of air passengers
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.7.1 预测航空乘客数量
- en: In chapter 8 we used a dataset that tracks the number of monthly air passengers
    between 1949 and 1960\. We developed a SARIMA model that achieved a MAPE of 2.85%.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8 章中，我们使用了一个追踪 1949 年至 1960 年间每月航空乘客数量的数据集。我们开发了一个 SARIMA 模型，实现了 2.85% 的
    MAPE。
- en: 'Use Prophet to forecast the last 12 months of the dataset:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Prophet 预测数据集的最后 12 个月：
- en: Does it make sense to add holiday effects?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加节假日效应是否有意义？
- en: Looking at the data, is the seasonality additive or multiplicative?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察数据，季节性是加性的还是乘性的？
- en: Use hyperparameter tuning and cross-validation to find the optimal parameters.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用超参数调整和交叉验证来寻找最佳参数。
- en: Fit the model with the optimal parameters and evaluate its predictions for the
    last 12 months. Does it achieve a lower MAPE?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用最佳参数拟合模型，并评估其对过去 12 个月的预测。是否实现了更低的 MAPE？
- en: 19.7.2 Forecast the volume of antidiabetic drug prescriptions
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.7.2 预测抗糖尿病药物处方的数量
- en: In chapter 11 we worked through a capstone project to predict the monthly volume
    of antidiabetic drug prescriptions in Australia. We developed a SARIMA model that
    achieved a MAPE of 7.9%.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 11 章中，我们完成了一个综合项目，预测澳大利亚每月抗糖尿病药物处方的月度数量。我们开发了一个 SARIMA 模型，实现了 7.9% 的 MAPE。
- en: 'Use Prophet to forecast the last 36 months of the dataset:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Prophet 预测数据集的最后 36 个月：
- en: Does it make sense to add holiday effects?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加节假日效应是否有意义？
- en: Looking at the data, is the seasonality additive or multiplicative?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察数据，季节性是加性的还是乘性的？
- en: Use hyperparameter tuning and cross-validation to find the optimal parameters.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用超参数调整和交叉验证来寻找最佳参数。
- en: Fit the model with the optimal parameters and evaluate its predictions for the
    last 36 months. Does it achieve a lower MAPE?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用最佳参数拟合模型，并评估其对过去 36 个月的预测。是否实现了更低的 MAPE？
- en: 19.7.3 Forecast the popularity of a keyword on Google Trends
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.7.3 预测 Google Trends 上关键词的流行度
- en: Google Trends ([https://trends.google.com/trends/](https://trends.google.com/trends/))
    is a great place to generate time series datasets. This is where you can see the
    popular searches on Google around the world.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Google Trends ([https://trends.google.com/trends/](https://trends.google.com/trends/))
    是生成时间序列数据集的好地方。这里你可以看到全球范围内在 Google 上流行的搜索。
- en: Choose a keyword and a country of your choice, and generate a time series dataset.
    Then use Prophet to predict its popularity in the future. This is a very open-ended
    project with no solutions to it. Take this opportunity to explore the Google Trends
    tool, and experiment with Prophet to learn what works and what does not.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个关键词和您选择的任何国家，生成一个时间序列数据集。然后使用 Prophet 预测其未来的流行度。这是一个非常开放的项目，没有解决方案。利用这个机会探索
    Google Trends 工具，并实验 Prophet 来了解什么有效，什么无效。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: There are many libraries that automate the forecasting process, such as pmdarima,
    Prophet, NeuralProphet, and PyTorch Forecasting.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多库可以自动化预测过程，例如 pmdarima、Prophet、NeuralProphet 和 PyTorch Forecasting。
- en: Prophet is one of the most widely known and used libraries in the industry for
    automatic time series forecasting. Knowing how to use it is important for any
    data scientist doing time series forecasting.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prophet 是行业内最广为人知且广泛使用的自动时间序列预测库之一。了解如何使用它对于任何进行时间序列预测的数据科学家来说都很重要。
- en: Prophet uses a general additive model that combines a trend component, a seasonal
    component, and holiday effects.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prophet 使用一个组合趋势成分、季节成分和节假日效应的通用加性模型。
- en: Prophet is not the optimal solution to all problems. It works best on strongly
    seasonal data with multiple historical seasons for training. Therefore, it must
    be regarded as one of several tools for forecasting.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Prophet 并不是所有问题的最优解决方案。它在具有多个历史季节训练数据的强季节性数据上表现最佳。因此，它必须被视为预测的几种工具之一。
