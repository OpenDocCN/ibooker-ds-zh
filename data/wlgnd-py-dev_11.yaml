- en: 9 What can you do? Authorization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 你能做什么？授权
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Adding login/logout to page navigation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将登录/退出添加到页面导航
- en: Confirming new users with email
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过电子邮件确认新用户
- en: Allowing users to reset forgotten passwords
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户重置忘记的密码
- en: Allowing existing users to change passwords
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许现有用户更改密码
- en: Adding authorization roles to users
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户添加授权角色
- en: Securing routes in the application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中确保路由安全
- en: In the previous chapter, you created functionality to support users logging
    in and out of the MyBlog application. Logging in and out is essential functionality
    we need to make easily accessible to users. Therefore, you’ll add this navigation
    functionality to the parent `base.xhtml` template so that it’s available everywhere
    on the MyBlog application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您创建了支持用户在MyBlog应用程序中登录和退出的功能。登录和退出是用户必须能够轻松访问的基本功能。因此，您将此导航功能添加到父`base.xhtml`模板中，以便在MyBlog应用程序的任何地方都可以使用。
- en: 9.1 Login/logout navigation
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 登录/退出导航
- en: You’ve created a working authentication system, but, currently, it’s accessible
    primarily by entering the URL into the browser navigation bar. Let’s add the login/logout
    URL routes to the Bootstrap navigation system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您已创建了一个工作的认证系统，但目前它主要通过在浏览器导航栏中输入URL来访问。让我们将登录/退出URL路由添加到Bootstrap导航系统中。
- en: 'The authentication system has two mutually exclusive states as a user; you
    can only be logged in or logged out. Because of this, the authentication system
    is represented in the navigation menu as a single item that toggles between states
    depending on the user’s current authentication status. Keeping with the idea of
    single responsibility and not overcomplicating the `base.xhtml` template, the
    login/logout menu functionality will exist as a Jinja macro in the `examples/CH_09/examples/01/app/templates/macros.jinja`
    file:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 认证系统有两个相互排斥的状态，作为用户；您只能登录或注销。因此，认证系统在导航菜单中表现为一个单项目，根据用户的当前认证状态在状态之间切换。遵循单一责任和不过度复杂化`base.xhtml`模板的理念，登录/退出菜单功能将作为`examples/CH_09/examples/01/app/templates/macros.jinja`文件中的Jinja宏存在：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ① Begins the build_login_logout_items macro, passing in the current user from
    the base.xhtml template
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ① 开始构建`build_login_logout_items`宏，从`base.xhtml`模板传递当前用户
- en: ② Is the current user unauthenticated?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ② 当前用户是否未认证？
- en: ③ Presents the login menu item and route as highlighted or not depending on
    the current route
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 根据当前路由，突出显示或未突出显示登录菜单项和路由
- en: ④ Otherwise, if the current user is authenticated
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 否则，如果当前用户已认证
- en: ⑤ Presents the logout menu item and route
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 显示退出菜单项和路由
- en: The `build_login_logout_items()` macro will toggle the navigation display to
    show “login” or “logout,” depending on the user’s authentication state. The two
    menu items are tied to the login and logout URL endpoints.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`build_login_logout_items()`宏将根据用户的认证状态切换导航显示，显示“登录”或“退出”。这两个菜单项与登录和退出URL端点相关联。'
- en: 'The macro is added to the `base.xhtml` template so the system can render it
    on any page the MyBlog application presents. Modify the section of code in the
    `base.xhtml` template that creates the navigation menu to add this functionality:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 该宏被添加到`base.xhtml`模板中，以便系统可以在MyBlog应用程序展示的任何页面上渲染它。修改`base.xhtml`模板中创建导航菜单的代码部分，以添加此功能：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ① Right and left justify the two navbar-nav sections
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将两个`navbar-nav`部分右对齐和左对齐
- en: ② Creates the second navbar-nav section and calls the macro to render the login/logout
    items
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建第二个`navbar-nav`部分并调用宏以渲染登录/退出项
- en: With the above changes in place, the MyBlog web application will display a highlighted
    login menu item when the login menu item is clicked and rendered. Run the application
    from the `examples/CH_09/examples/01` directory and see the login menu item rendered.
    Figure 9.1 is a screenshot of the updated login page.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述更改到位后，当点击并渲染登录菜单项时，MyBlog网络应用程序将显示突出显示的登录菜单项。从`examples/CH_09/examples/01`目录运行应用程序，并查看渲染的登录菜单项。图9.1是更新后的登录页面的截图。
- en: '![](../../OEBPS/Images/CH09_F01_Farrell.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F01_Farrell.png)'
- en: Figure 9.1 The user login registration form, including the newly added login
    menu item
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 用户登录注册表单，包括新添加的登录菜单项
- en: 9.2 Confirming new friends
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 确认新朋友
- en: When a potential user of the MyBlog application registers with the system, it’s
    important to confirm who they are. This is often done by sending an email with
    a confirmation link to the email address they registered with. Since the MyBlog
    application uses the user’s email address as a unique identifier, sending a confirmation
    email to that address closes the loop that the user intended to register with
    the MyBlog application. We’ll add the ability to send emails from the MyBlog application
    so we can send the confirmation emails.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个潜在用户在MyBlog应用程序中注册系统时，确认他们的身份是很重要的。这通常是通过向他们注册的电子邮件地址发送带有确认链接的电子邮件来完成的。由于MyBlog应用程序使用用户的电子邮件地址作为唯一标识符，向该地址发送确认电子邮件就完成了用户意图注册MyBlog应用程序的闭环。我们将添加从MyBlog应用程序发送电子邮件的功能，以便我们可以发送确认电子邮件。
- en: 9.2.1 Sending email
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 发送电子邮件
- en: Similar to using SQLite as the database, we’ll implement a straightforward email
    system that works for MyBlog. To help keep things focused on MyBlog, I’m using
    an email service provider called SendInBlue ([https://www.sendinblue.com/](https://www.sendinblue.com/)).
    I’ve set up a free account that lets the MyBlog application send 300 emails a
    month for free (300 is more than enough for this book).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用SQLite作为数据库类似，我们将实现一个简单的电子邮件系统，适用于MyBlog。为了帮助将重点放在MyBlog上，我使用了一个名为SendInBlue的电子邮件服务提供商([https://www.sendinblue.com/](https://www.sendinblue.com/))。我已经设置了一个免费账户，允许MyBlog应用程序每月免费发送300封电子邮件（对于这本书来说，300封已经足够了）。
- en: 'SendInBlue provides an installable API module that lets Python applications
    send emails by making function calls. This module can be installed with this command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: SendInBlue提供了一个可安装的API模块，允许Python应用程序通过函数调用发送电子邮件。此模块可以使用以下命令安装：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: However, the module is included in the `requirements.txt` file for this chapter
    and was installed when you ran
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，该模块包含在这一章的`requirements.txt`文件中，并在你运行时安装了它。
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: at the time you built the Python virtual environment for this chapter. The SendInBlue
    service handles all the details of sending emails and simplifies the code we need
    to write for the MyBlog application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在你为这一章构建Python虚拟环境的时候。SendInBlue服务处理发送电子邮件的所有细节，简化了我们需要为MyBlog应用程序编写的代码。
- en: Tip By using an external service like SendInBlue, we avoid having to set up
    an SMTP (Simple Mail Transfer Protocol) server. Not a small task, and outside
    the scope of this book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：通过使用像SendInBlue这样的外部服务，我们避免了需要设置SMTP（简单邮件传输协议）服务器。这不是一个小任务，并且超出了这本书的范围。
- en: 'When a new user registers with the MyBlog application on the New User Registration
    form, we want to add two things:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当新用户在MyBlog应用程序的新用户注册表单中注册时，我们想要添加两个功能：
- en: A Boolean field called `confirmed` on the user database model, initially set
    to `False`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户数据库模型中添加一个名为`confirmed`的布尔字段，初始设置为`False`
- en: The functionality to send an email with a confirmation link to the registering
    user’s email address
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向注册用户电子邮件地址发送带有确认链接的电子邮件的功能
- en: Adding a `confirmed` field to the user model is simple enough and is shown in
    the `examples/CH_09/examples/02/app/models.py` code in the repository for this
    chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户模型中添加一个`confirmed`字段很简单，可以在这一章代码库中的`examples/CH_09/examples/02/app/models.py`代码示例中看到。
- en: Emailer
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 邮件发送器
- en: We could send the email directly from the `auth.py` module’s `register_new_
    user()` function, which would work fine. However, we’ll likely want to send emails
    from elsewhere in the MyBlog application, so we’ll embed the functionality into
    a new module that can be reused.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接从`auth.py`模块的`register_new_user()`函数发送电子邮件，这会工作得很好。然而，我们可能希望从MyBlog应用程序的其他地方发送电子邮件，所以我们将该功能嵌入到一个新的模块中，以便可以重用。
- en: 'We’ll create a new module as follows called `app/emailer.py` that has a single
    function, `send_mail()`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的模块，如下所示，名为`app/emailer.py`，它包含一个名为`send_mail()`的单个函数：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① Imports the SendInBlue API module
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ① 导入SendInBlue API模块
- en: ② Configures the API with your API key
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用你的API密钥配置API
- en: ③ Creates an instance of the API
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 创建API实例
- en: ④ Creates the email object
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建邮件对象
- en: ⑤ Sends the email object to be emailed
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 将要发送的邮件对象发送出去
- en: This code creates an instance of the SendInBlue API and configures it with the
    user’s API key. I received the API key—which is in the `secrets.toml` file—when
    I created my account with SendInBlue.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个SendInBlue API实例，并使用用户的API密钥进行了配置。我在使用SendInBlue创建账户时收到了API密钥——它位于`secrets.toml`文件中。
- en: The API instance variable `api_instance` is used to send the email object. The
    API expects the email contents to be in HTML, so the messages sent must include
    some basic HTML tags to render the email correctly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: API 实例变量 `api_instance` 用于发送电子邮件对象。API 预期电子邮件内容为 HTML 格式，因此发送的消息必须包含一些基本的 HTML
    标签以正确渲染电子邮件。
- en: Confirmation email
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 确认电子邮件
- en: Now that MyBlog can send emails, let’s use it to send a confirmation email to
    newly registered users. The confirmation email will contain a link back to the
    MyBlog application. The link includes encrypted information sent along when the
    user clicks the link. When MyBlog handles a call to the link, it decrypts the
    information to determine if the request is valid. If it is, the user is confirmed
    in the database.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 MyBlog 可以发送电子邮件，让我们用它来向新注册用户发送确认电子邮件。确认电子邮件将包含一个链接回 MyBlog 应用程序。该链接包含用户点击链接时发送的加密信息。当
    MyBlog 处理对链接的调用时，它会解密信息以确定请求是否有效。如果是，则用户在数据库中被确认。
- en: The encoded information also contains a current timestamp. When the link is
    clicked and the application handles that request, the timestamp is compared to
    the current time. The user has confirmed if the application handles the request
    within a timeout period. However, if the user waited longer than the defined timeout
    period, the confirmation link is considered expired, and the user isn’t confirmed.
    The timeout value is set in the `settings.toml` file as 12 hours, which can be
    changed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 编码的信息还包含当前时间戳。当点击链接并且应用程序处理该请求时，时间戳将与当前时间进行比较。如果应用程序在超时期间处理请求，则用户已确认。然而，如果用户等待时间超过定义的超时时间，则确认链接被视为过期，用户不会被确认。超时值在
    `settings.toml` 文件中设置为 12 小时，可以更改。
- en: 'We’ll add two function calls to the `register_new_user()` function handler
    to send the new user confirmation email. The first is a call to a new function,
    `send_ confirmation_email(user)`, and the second is a call to the Flask `flash()`
    function, notifying the user with a toast message to check for the confirmation
    email:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `register_new_user()` 函数处理程序中添加两个函数调用以发送新用户确认电子邮件。第一个是调用新函数 `send_confirmation_email(user)`，第二个是调用
    Flask 的 `flash()` 函数，通过弹窗消息通知用户检查确认电子邮件：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ① Calls to new send_confirmation_email(user) function to send email
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ① 调用新的 send_confirmation_email(user) 函数发送电子邮件
- en: ② Calls Flask flash() functionality to notify the user to check their email
    within the confirmation link timeout
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ② 调用 Flask 的 flash() 功能来通知用户在确认链接超时时间内检查他们的电子邮件
- en: 'Let’s take a look at the `send_confirmation_email()` function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `send_confirmation_email()` 函数：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ① Calls the new user method to construct a confirmation token
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ① 调用新的用户方法来构建确认令牌
- en: ② Constructs a URL to insert in the email that, when clicked, will inform MyBlog
    that the user has confirmed
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ② 构建一个要插入电子邮件中的 URL，当点击时，将通知 MyBlog 用户已确认
- en: ③ Constructs and sends an email with the confirmation URL to the user
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 构建并发送带有确认 URL 的电子邮件给用户
- en: The `send_confirmation_email()` function calls a new method of the `User` model
    `confirmation_token()` to build a unique token with an expiration timeout. It
    then builds a URL to a new URL handler, `auth_bp.confirm`. Finally, the `_external
    =True` parameter causes `url_for()` to create a full URL that will work when a
    user clicks the link from their email client context.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_confirmation_email()` 函数调用 `User` 模型的新方法 `confirmation_token()` 来构建一个带有过期超时的唯一令牌。然后构建一个指向新
    URL 处理器的 URL，即 `auth_bp.confirm`。最后，`_external = True` 参数导致 `url_for()` 创建一个完整的
    URL，当用户从他们的电子邮件客户端上下文点击链接时，该 URL 将会工作。'
- en: Once the confirmation link is created, an email is created inline containing
    the confirmation link is sent to the new user. If the new user clicks the confirmation
    link within the 12-hour time limit, their account is confirmed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建确认链接，就会创建一个包含确认链接的电子邮件并发送给新用户。如果新用户在 12 小时时间限制内点击确认链接，则他们的账户将被确认。
- en: Notice the `<br /><br />` HTML line-break elements in the email message. These
    HTML elements help format the message, so it’s easily readable by the user.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意电子邮件消息中的 `<br /><br />` HTML 换行元素。这些 HTML 元素有助于格式化消息，使其易于用户阅读。
- en: User confirmation token
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 用户确认令牌
- en: 'Because the confirmation token is unique for each user, it’s generated by a
    new method attached to the `User` model class:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于确认令牌对每个用户都是唯一的，因此它是由附加到 `User` 模型类的新的方法生成的：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method uses the `URLSafeTimedSerializer()` function to create a serializing
    instance based on the Flask `SECRET_KEY` and includes the current timestamp. Then,
    the serializer instance is used to create the unique token based on the new user’s
    `user_id` value.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用`URLSafeTimedSerializer()`函数根据Flask的`SECRET_KEY`创建一个序列化实例，并包括当前时间戳。然后，使用序列化实例根据新用户的`user_id`值创建唯一的令牌。
- en: Confirm user handler
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 确认用户处理器
- en: 'When a new user clicks the confirmation link in their email, this action makes
    a request to a new URL handler in the `auth` module to confirm that the token
    passed in the request is valid:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当新用户点击他们电子邮件中的确认链接时，此操作会向`auth`模块中的新URL处理器发出请求，以确认请求中传递的令牌是有效的：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ① Registers new/confirm URL route with Blueprint
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用Blueprint注册新的/确认URL路由
- en: ② Confirms a token, requires the user to log in
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ② 确认令牌，要求用户登录
- en: ③ If the user is already confirmed, redirect them to the home page.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 如果用户已经确认，则将其重定向到主页。
- en: ④ Confirms the token is valid
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 确认令牌有效
- en: ⑤ If the token is valid, set the current user’s confirmation status to True
    and save it in the database.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 如果令牌有效，将当前用户的确认状态设置为True，并将其保存在数据库中。
- en: ⑥ If confirming the token raises an exception, log it, inform the user, and
    redirect them to the resend confirmation page.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 如果确认令牌引发异常，则记录它，通知用户，并将他们重定向到重新发送确认页面。
- en: User confirm token
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 用户确认令牌
- en: 'The application needs to confirm a token received in response to clicking the
    link in the email is valid to verify that the user completed the registration
    process. This code acts as part of the confirmation process:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要确认通过点击电子邮件中的链接收到的令牌是有效的，以验证用户已完成注册过程。此代码作为确认过程的一部分：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `confirm_token()` URL handler creates a serializer instance just as the
    `confirmation_token()` creator method did. It then enters a database context manager
    and gets the confirmation timeout value and the confirmation data sent in the
    request.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`confirm_token()` URL处理器创建一个序列化实例，就像`confirmation_token()`创建方法一样。然后，它进入数据库上下文管理器，获取确认超时值和请求中发送的确认数据。'
- en: The code then compares the "`confirm`" value of the data dictionary to the user’s
    `user_id` value. If the values match, the user who clicked the link is the user
    who sent the confirmation link. The code to confirm the token is wrapped in an
    exception handler to return `False` if the token has expired or is invalid.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码将数据字典中的"`confirm`"值与用户的`user_id`值进行比较。如果值匹配，点击链接的用户就是发送确认链接的用户。确认令牌的代码被包裹在异常处理器中，如果令牌已过期或无效，则返回`False`。
- en: 9.3 Resetting passwords
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 重置密码
- en: We’re at a point where new users can register and confirm their email and existing
    users can log in to use the MyBlog application. We need to create a way for existing
    users to reset their password if they’ve forgotten it. In some ways, a password
    reset request is similar to confirming a new user; it sends a link to the user’s
    email. A handler exists to present the user with the password reset form when
    the user clicks the associated link.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到了新用户可以注册并确认他们的电子邮件，现有用户可以登录使用MyBlog应用程序的点。我们需要为现有用户提供一种方法，以便他们在忘记密码时可以重置密码。在某种程度上，密码重置请求与确认新用户相似；它向用户的电子邮件发送一个链接。存在一个处理器，当用户点击相关链接时，它会向用户呈现密码重置表单。
- en: 'The link sent in the reset password email contains the encrypted `user_uid`
    value of the requesting user, along with an expiration timeout. The timeout value
    is set in the `settings.toml` file at 10 minutes and is configurable:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到重置密码电子邮件中的链接包含请求用户的加密`user_uid`值，以及过期超时。超时值在`settings.toml`文件中设置为10分钟，并可配置：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ① Registers the request_reset_password function for both GET and POST HTTP methods
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为GET和POST HTTP方法注册request_reset_password函数
- en: ② Creates an instance of the request password form
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建请求密码表单的实例
- en: ③ Gets the user associated with the email from the form
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 从表单中获取与电子邮件关联的用户
- en: ④ Sends the password reset email and notifies the current user to check for
    it within the timeout
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 发送密码重置电子邮件，并通知当前用户在超时内检查它
- en: The application in the `examples/CH_09/examples/03` directory presents the reset
    password form, as shown in figure 9.2 when it receives an HTTP `GET` request.
    The Password Reset form only presents a single field for the user’s email that
    will be used to generate an email with the password reset link.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`examples/CH_09/examples/03`目录中的应用程序在接收到HTTP `GET`请求时呈现重置密码表单，如图9.2所示。密码重置表单仅呈现一个用于用户电子邮件的单个字段，该字段将用于生成包含密码重置链接的电子邮件。
- en: '![](../../OEBPS/Images/CH09_F02_Farrell.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F02_Farrell.png)'
- en: Figure 9.2 The form that allows registered users to reset their password
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 允许注册用户重置密码的表单
- en: 'If a user is found for the email entered in the form, that user is passed as
    a parameter to a new function, `send_password_reset()`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在表单中输入的电子邮件找到了用户，则将该用户作为参数传递给新的函数`send_password_reset()`：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① Creates the encrypted reset token with the expiration timeout
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用过期超时创建加密的重置令牌
- en: ② Builds the email content
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ② 构建电子邮件内容
- en: ③ Sends the email to the passed-in user’s email address
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将电子邮件发送到传入用户电子邮件地址
- en: 'When the user clicks the link in the reset password email, a new URL endpoint
    function, `reset_password(),` is invoked:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击重置密码电子邮件中的链接时，会调用一个新的URL端点函数`reset_password()`：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① Registers the request_reset_password function for both GET and POST HTTP methods
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为GET和POST HTTP方法注册了`request_reset_password`函数
- en: ② Gets the user_uid from the encrypted token passed with the URL
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ② 从与URL一起传递的加密令牌中获取`user_uid`
- en: ③ Finds a user matching the user_uid
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 找到与`user_uid`匹配的用户
- en: ④ Updates and saves the user’s new password
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 更新并保存用户的新密码
- en: The form shown in figure 9.3 lets the user enter and confirm a new password.
    When they click the Reset Password button, the handler is called with the HTTP
    `POST` method. The `user_uid` is decrypted from the token passed with the URL,
    and that user is searched for in the database. If the user is found and the form
    validates, the user’s password is updated and saved in the database.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3所示的形式允许用户输入并确认新密码。当用户点击重置密码按钮时，处理程序会使用HTTP `POST`方法被调用。`user_uid`从与URL一起传递的令牌中解密，然后在数据库中搜索该用户。如果找到用户且表单验证通过，则用户的密码将在数据库中更新并保存。
- en: '![](../../OEBPS/Images/CH09_F03_Farrell.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F03_Farrell.png)'
- en: Figure 9.3 The Reset Password form accepts a new password and a matching confirmation
    password.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 重置密码表单接受新密码和匹配的确认密码。
- en: 9.4 User profiles
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 用户资料
- en: 'The MyBlog application currently saves only a few pieces of information about
    registered users: first name, last name, email, and password; whether they are
    confirmed; and if they are active. In addition to being able to reset their passwords
    if forgotten, users also want to change their passwords. So, we’ll add a profile
    page that shows most of the user information and allows for password changes.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog应用目前仅保存有关注册用户的一些信息：名字、姓氏、电子邮件和密码；是否已确认；以及是否活跃。除了在忘记密码时能够重置密码外，用户还希望更改密码。因此，我们将添加一个资料页面，显示大部分用户信息，并允许更改密码。
- en: 'The profile is a form that presents and gathers information. It shows the user’s
    name and email and has input fields to enter and confirm a new password. The form
    class that presents the profile information is added to the `auth/forms.py` file:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 资料是一个展示和收集信息的表单。它显示了用户的名字和电子邮件，并具有输入字段以输入和确认新密码。展示资料信息的表单类被添加到`auth/forms.py`文件中：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To generate the HTML to display on the browser requires a new URL handler in
    the `auth/auth.py` module:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要在浏览器上生成显示的HTML，需要在`auth/auth.py`模块中添加一个新的URL处理程序：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ① Registers the profile function for both GET and POST HTTP methods
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为GET和POST HTTP方法注册了资料功能
- en: ② To view a profile, the user must be logged in (as discussed in the next section).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ② 要查看资料，用户必须登录（如下一节所述）。
- en: ③ Gets the user associated with the user_uid in the URL path
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 获取URL路径中与`user_uid`关联的用户
- en: ④ If no user is found, this notifies the user and aborts with a 404 error.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 如果未找到用户，则通知用户并使用404错误终止。
- en: ⑤ Prevents users from viewing profiles other than their own
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 防止用户查看除自己资料外的其他资料
- en: ⑥ For a valid form submission, this updates the user’s password.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 对于有效的表单提交，此操作将更新用户的密码。
- en: The HTML template to render the profile form isn’t shown here but can be seen
    in the `examples/CH_09/examples/03/auth/templates/profile.xhtml` template file.
    The rendered profile page, presented in figure 9.4, shows the user’s information
    and provides a means to change the user’s password.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 展示用户资料的HTML模板在此处未显示，但可以在`examples/CH_09/examples/03/auth/templates/profile.xhtml`模板文件中找到。如图9.4所示的渲染后的资料页面显示了用户信息，并提供了一种更改用户密码的方式。
- en: '![](../../OEBPS/Images/CH09_F04_Farrell.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH09_F04_Farrell.png)'
- en: Figure 9.4 The user profile page shows everything the MyBlog application knows
    about the user.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 用户资料页面显示了MyBlog应用了解的所有用户信息。
- en: 9.5 Security
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 安全性
- en: The goal of building an authentication system is to provide security for an
    application’s users, features, and functions. Security includes the features and
    functions that a user can perform when using the application. It also includes
    protecting the application by maintaining control and only allowing known users
    to access protected features and functions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 构建身份验证系统的目标是提供对应用程序用户、功能和功能的保护。安全包括用户在使用应用程序时可以执行的功能和功能。它还包括通过维护控制和仅允许已知用户访问受保护的功能和功能来保护应用程序。
- en: 9.5.1 Protecting routes
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.1 保护路由
- en: Authenticated users have a cryptographically secure session cookie that the
    application identifies. In addition, we can use the session and `flask_login`
    module to protect routes in the application so that only users who are logged
    in and authenticated can navigate to those routes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 已验证的用户有一个应用程序可以识别的加密安全会话cookie。此外，我们可以使用会话和`flask_login`模块来保护应用程序中的路由，以确保只有登录并验证的用户才能导航到这些路由。
- en: 'Currently, the MyBlog application only has two routes that aren’t associated
    with authentication—the home page and the about page. Therefore, you’ll temporarily
    create two new routes to demonstrate how to protect a route. Protecting a page
    is done by adding another decorator provided by the `flask_login` module to a
    URL route page handler. Add this to the import section of the `app/intro.py` module:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，MyBlog应用程序只有两个与身份验证无关的路由——主页和关于页面。因此，你将暂时创建两个新的路由来演示如何保护路由。通过向URL路由页面处理程序添加`flask_login`模块提供的另一个装饰器来保护页面。将此添加到`app/intro.py`模块的导入部分：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ① Imports the login_required decorator functionality from the flask_login module
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ① 从`flask_login`模块导入`login_required`装饰器功能
- en: 'Add a new route and handler to the `app/intro.py` module:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app/intro.py`模块中添加一个新的路由和处理程序：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ① Adds a new route for "/auth_required"
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为"/auth_required"添加一个新的路由
- en: ② Decorates the auth_required handler with the login_required functionality
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用`login_required`功能装饰`auth_required`处理程序
- en: 'The `auth_required()` handler has two decorators: `@intro_bp.route()` and `@login_required`.
    Stacking decorators this way is absolutely fine. The decorator functionality wraps
    around other decorator functionality, working from the inner level outward. In
    this case, the `@login_required` decorator must be placed after the `@intro_bp.route()`
    (or any Blueprint instance routing) to make sure the `@login_ required` functionality
    wraps the `auth_required()` handler functionality.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth_required()`处理程序有两个装饰器：`@intro_bp.route()`和`@login_required`。以这种方式堆叠装饰器是完全可行的。装饰器功能围绕其他装饰器功能包装，从内部级别向外工作。在这种情况下，必须将`@login_required`装饰器放在`@intro_bp.route()`（或任何蓝图实例路由）之后，以确保`@login_required`功能包装`auth_required()`处理程序功能。'
- en: With the `auth_required()` handler protected by the `@login_required` decorator,
    an unauthenticated user will be redirected to the login page and unable to access
    the protected `auth_required` page. This is useful when you only allow authenticated
    users to see sensitive or private information or prevent access to forms that
    could change server data or functionality. An example use case for this security
    is allowing only authenticated users to create and post blog content to the MyBlog
    application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`@login_required`装饰器保护`auth_required()`处理程序，未验证的用户将被重定向到登录页面，无法访问受保护的`auth_required`页面。这在您只想允许验证用户查看敏感或私人信息或防止访问可能更改服务器数据或功能的功能表单时非常有用。这种安全性的一个示例用例是仅允许验证用户在MyBlog应用程序中创建和发布博客内容。
- en: 9.6 User authorization roles
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 用户授权角色
- en: The other side of the authentication coin is authorization. Where authentication
    provides a mechanism to identify a user, authorization offers a way to control
    the user’s capabilities.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证硬币的另一面是授权。当身份验证提供了一个识别用户的机制时，授权提供了一种控制用户能力的方式。
- en: One of the requirements of the MyBlog application is to give users roles in
    the application. A role would allow users with specific roles to perform actions
    not available to other users. For example, a user with an administrator role could
    update, activate, or deactivate any content in the system, not just content created
    by that user. Likewise, an administrator could also activate or deactivate a user.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog应用程序的一个要求是为用户提供角色。一个角色将允许具有特定角色的用户执行其他用户无法执行的操作。例如，具有管理员角色的用户可以更新、激活或停用系统中的任何内容，而不仅仅是该用户创建的内容。同样，管理员也可以激活或停用用户。
- en: A user with the editor role could update any content in the system, not just
    the content they created. However, an editor can’t deactivate a user or their
    content.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有编辑者角色的用户可以更新系统中的任何内容，而不仅仅是他们创建的内容。然而，编辑者不能停用用户或他们的内容。
- en: 'A registered user can create content and activate or deactivate it but can’t
    change the active state of another user or their content. We will add three roles
    to the MyBlog application: administrator, editor, and registered user.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 已注册的用户可以创建内容并激活或停用它们，但不能更改其他用户的活跃状态或他们的内容。我们将在 MyBlog 应用程序中添加三个角色：管理员、编辑者和注册用户。
- en: 9.6.1 Creating the roles
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.1 创建角色
- en: The roles will be initialized by the application and maintained in the database.
    The users in the database have a relationship to the defined roles. Because many
    users can have a certain role, but each user can only have one role, we have a
    one-to-many relationship concerning roles to users. The ERD shown in figure 9.5
    illustrates this relationship.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 角色将由应用程序初始化并在数据库中维护。数据库中的用户与定义的角色有关联。因为许多用户可以拥有某个角色，但每个用户只能有一个角色，所以我们有一个关于角色到用户的单向多对一关系。图
    9.5 中显示的 ERD 阐述了这种关系。
- en: '![](../../OEBPS/Images/CH09_F05_Farrell.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F05_Farrell.png)'
- en: Figure 9.5 The new `Role` table and its relationship to the existing `User`
    table
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 新的 `Role` 表及其与现有 `User` 表的关系
- en: 'The `Role` model is defined in the `examples/CH_09/examples/03/app/models .py`
    file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Role` 模型定义在 `examples/CH_09/examples/03/app/models .py` 文件中：'
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ① Creates the Role class model
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建角色类模型
- en: ② Creates the Permissions class internal to the Role class
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ② 在角色类内部创建权限类
- en: ③ Defines the table name for roles in the database
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 定义数据库中角色的表名
- en: ④ Creates the columns for a Role record
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 为角色记录创建列
- en: ⑤ Establishes the one-to-many relationship with the User table
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 建立与用户表的单一多对一关系
- en: ⑥ Creates a read property for a role’s permissions
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 为角色的权限创建一个只读属性
- en: This code creates the `Role` database definition class. Notice the definition
    of the `Permissions` class inside the scope of the `Role` class definition. This
    is acceptable Python syntax and puts the `Permission` class inside the scope of
    the `Role` class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了 `Role` 数据库定义类。注意 `Permissions` 类在 `Role` 类定义的作用域内定义。这是可接受的 Python 语法，并将
    `Permission` 类放在 `Role` 类的作用域内。
- en: The `Permissions` class is a `Flag` enum and gives the names `REGISTERED`, `EDITOR`,
    and `ADMINISTRATOR` automatically generated values. This class helps refer to
    the values by name, even though the `permission` value is stored as an integer
    in the `raw_permissions` column of the database.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`Permissions` 类是一个 `Flag` 枚举，并自动生成 `REGISTERED`、`EDITOR` 和 `ADMINISTRATOR`
    名称值。这个类帮助通过名称引用值，尽管 `permission` 值存储在数据库的 `raw_permissions` 列中作为整数。'
- en: The values in the roles database table need to exist for the life of the MyBlog
    application and act as a lookup table to constants. A method called `initialize_
    role_table()` in the `Role` class definition accomplishes this. This method is
    decorated with a `@staticmethod`, meaning it can be called without a `Role` instance
    variable. The method’s purpose is to populate the `Roles` table at application
    startup. The method isn’t included here but can be found in the `examples/CH_09/examples/03/app/models.py`
    file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 角色数据库表中的值需要在 MyBlog 应用程序的生命周期内存在，并作为常量的查找表。`Role` 类定义中的一个名为 `initialize_role_table()`
    的方法实现了这一点。该方法用 `@staticmethod` 装饰，意味着它可以不通过 `Role` 实例变量来调用。该方法的目的是在应用程序启动时填充 `Roles`
    表。该方法在此处未包含，但可以在 `examples/CH_09/examples/03/app/models.py` 文件中找到。
- en: 'To initialize the `Roles` table, the following code is added to the `examples/CH_09/examples/03/app/__init__.py`
    file at the bottom of the `create_app()` function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化 `Roles` 表，以下代码被添加到 `examples/CH_09/examples/03/app/__init__.py` 文件中 `create_app()`
    函数的底部：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'These lines import the `Role` table class and then use it to call the `initialize_
    role_table()` static method to populate the `Roles` database table. In anticipation
    of upcoming functionality, the following code is also added to the end of the
    `create_ app()` function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行导入 `Role` 表类，然后使用它来调用 `initialize_role_table()` 静态方法以填充 `Roles` 数据库表。为了预期即将到来的功能，以下代码也被添加到
    `create_app()` 函数的末尾：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These lines of code add the `Role.Permissions` property into the template context.
    This makes the `Role.Permissions` available for all templates as `Permissions`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码行将 `Role.Permissions` 属性添加到模板上下文中。这使得 `Role.Permissions` 在所有模板中作为 `Permissions`
    可用。
- en: 9.6.2 Authorizing routes
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.2 授权路由
- en: Besides protecting URL routes in the MyBlog application so only authenticated
    users can access them, you’ll also want to protect URL routes so only authenticated
    users with specific permissions can access them. This will be useful in later
    chapters when forms are created that should only be accessed by editors or administrators.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了保护 MyBlog 应用程序中的 URL 路由，只允许经过身份验证的用户访问它们之外，你还希望保护 URL 路由，只允许具有特定权限的经过身份验证的用户访问它们。这在后续章节中创建仅应由编辑或管理员访问的表单时将很有用。
- en: 'To create this functionality, you’ll need to create a decorator similar to
    `@login_ required` but, instead, it should examine the user’s authorization. To
    do this, create another module inside of the app directory, `app/decorators.py`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此功能，你需要创建一个类似于 `@login_required` 的装饰器，但它应该检查用户的授权。为此，在应用目录内创建另一个模块，`app/decorators.py`：
- en: '[PRE20]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① Creates the decorator function expecting to pass a permissions bitmask
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ① 创建一个装饰器函数，期望传递一个权限掩码
- en: ② Creates the wrapper to receive the wrapped function
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个包装器来接收包装的函数
- en: ③ Uses the @wraps(func) decorator to maintain the wrapped function signature
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用 @wraps(func) 装饰器来保持包装函数的签名
- en: ④ Creates the wrapper to receive the wrapped function’s parameters
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 创建一个包装器来接收包装的函数的参数
- en: ⑤ Determines if the current user has the permissions necessary for this route
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 确定当前用户是否具有访问此路由所需的权限
- en: ⑥ Aborts with an HTTP 403 error code if the user doesn’t have the required permissions
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 如果用户没有所需的权限，则使用 HTTP 403 错误代码中止
- en: 'Let’s demonstrate the `authorization_required()` decorator function. Update
    the `app/intro/intro.py` module and add this code to the bottom of the import
    section:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们演示 `authorization_required()` 装饰器函数。更新 `app/intro/intro.py` 模块，并将此代码添加到导入部分的底部：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With these lines added, create a new URL route and handler:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这些行后，创建一个新的 URL 路由和处理程序：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ① Adds a new route for "/admin_required"
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ① 为 "/admin_required" 添加一个新的路由
- en: ② Decorates the admin_required handler with the login_required functionality
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用 login_required 功能装饰 admin_required 处理程序
- en: ③ Decorates the admin_required handler with the authorization_required functionality
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用 authorization_required 功能装饰 admin_required 处理程序
- en: With this route in place, you can run the application and try to navigate to
    the URL http:/ /127.0.0.1/admin_required. The system will generate a 403 error
    (`Forbidden`) for all users except those with administrator permissions. How to
    create an administrator will be covered next.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在此路由就绪后，你可以运行应用程序并尝试导航到 URL http:/ /127.0.0.1/admin_required。系统将为除具有管理员权限的用户外的所有用户生成一个
    403 错误（`Forbidden`）。如何创建管理员将在下一章中介绍。
- en: Creating administrator users
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 创建管理员用户
- en: 'The MyBlog application has a relatively easy way to create an administrator
    user. In the `secrets.toml` file, there’s a section of code like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: MyBlog 应用程序有一个相对简单的方法来创建管理员用户。在 `secrets.toml` 文件中，有一个类似这样的代码段：
- en: '[PRE23]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This creates a configuration variable `admin_users,` which is a list of email
    addresses. When a new user registers with an email in this list, they will have
    the administrator role assigned to them. By making the `admin_users` variable
    a list, you can have more than one administrator for the MyBlog application.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个配置变量 `admin_users`，它是一个电子邮件地址列表。当新用户使用此列表中的电子邮件注册时，将为他们分配管理员角色。通过将 `admin_users`
    变量设置为列表，你可以在 MyBlog 应用程序中拥有多个管理员。
- en: Tip Creating the administrator(s) roles in the way described works well enough
    for the MyBlog application. It can also be used to create editors, though you’d
    have to know editor users ahead of time to put them in the `secrets.toml` file.
    Creating an admin interface to the application would create forms to allow for
    the creation and updating of additional roles. That’s work for another day.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 以描述的方式创建管理员（或管理员）角色在 MyBlog 应用程序中效果很好。它也可以用来创建编辑者，但你必须提前知道编辑者用户才能将他们放入 `secrets.toml`
    文件中。创建一个应用程序的管理界面将创建表单，允许创建和更新其他角色。那是另一天的工作。
- en: 'With the previous configuration in place, we can make this active by modifying
    the `examples/CH_09/examples/03/app/auth/auth.py` file and adding three lines
    to the `register_new_user()` function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配置就绪后，我们可以通过修改 `examples/CH_09/examples/03/app/auth/auth.py` 文件并添加三行到 `register_new_user()`
    函数来激活此功能：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ① If the registered user’s email is in the admin_users list, it gives them the
    administrator role.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ① 如果注册用户的电子邮件在 admin_users 列表中，则赋予他们管理员角色。
- en: ② Gets the assigned role from the roles table
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ② 从角色表中获取分配的角色
- en: ③ Adds the registered user to the role collection, connecting the relationship
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将注册用户添加到角色集合中，连接关系
- en: The new code looks for the currently registering user in the `admin_user` configuration
    variable and creates the `role_name` variable with the appropriate value. It then
    uses the `role_name` variable to perform a lookup in the `Roles` table to obtain
    the designated `role`. The user is then added to the `role.users` collection to
    connect the role to the user, establishing the relationship. If you create a new
    user with the email in the `admin_users` list in the `secrets.toml` file and navigate
    to the `/admin_required` URL created earlier, you’ll be able to navigate to that
    page successfully.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 新代码在`admin_user`配置变量中查找当前注册的用户，并使用适当的值创建`role_name`变量。然后，它使用`role_name`变量在`Roles`表中执行查找以获取指定的`role`。然后，用户被添加到`role.users`集合中，将角色与用户连接起来，建立关系。如果你在`secrets.toml`文件中的`admin_users`列表中创建一个新用户，并导航到之前创建的`/admin_required`
    URL，你将能够成功导航到该页面。
- en: 9.7 Protecting forms
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7 保护表单
- en: 'There’s another protection relevant to forms that we’ve glossed over. In both
    the `login.xhtml` and `register_new_user.xhtml` templates, there’s a field within
    the form context that looks like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还忽略了一种与表单相关的保护。在`login.xhtml`和`register_new_user.xhtml`模板中，表单上下文中有一个看起来像这样的字段：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'What is the `{{form.csrf_token}}` Jinja substitution element? If you view the
    source of either the `login` or `register_new_user` pages, you’ll see an `<input...>`
    element that looks something like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{form.csrf_token}}` Jinja替换元素是什么？如果你查看`login`或`register_new_user`页面的源代码，你会看到一个看起来像这样的`<input...>`元素：'
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The element is a hidden input element (not shown on the browser page) with a
    strange-looking value. The MyBlog application server generates the value using
    the Flask `SECRET_KEY` configuration value and the user session unique identifier.
    This element aims to prevent cross-site request forgery (CSRF) attacks. The `form.csrf_
    token` is intended to protect a request that would take action (like an HTTP `POST`).
    When the server receives a protected form, it will validate both the session and
    `form.csrf_token` to ensure a malicious user hasn’t altered it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 该元素是一个隐藏的输入元素（不会在浏览器页面上显示）并具有一个看起来很奇怪的值。MyBlog应用程序服务器使用Flask的`SECRET_KEY`配置值和用户会话的唯一标识符来生成这个值。这个元素的目的是防止跨站请求伪造（CSRF）攻击。`form.csrf_token`旨在保护将要执行操作（如HTTP
    `POST`）的请求。当服务器收到受保护的表单时，它将验证会话和`form.csrf_token`以确保恶意用户没有修改它。
- en: This protection is provided automatically by using the `Flask-WTF` module. You
    simply need to include the `{{form.csrf_token}}` in any form you want to protect.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这种保护是通过使用`Flask-WTF`模块自动提供的。你只需在你想保护的任何表单中包含`{{form.csrf_token}}`即可。
- en: 9.8 Closing thoughts
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8 总结
- en: You’ve created an effective authentication and authorization system by using
    the new modules you’ve learned about—`flask_login`, `Flask_bcrypt`, `Flask-WTF`,
    and `Flask-SQLAlchemy`. Ensuring user security is a decisive step toward having
    an application accepted by users. The authorization system you’ve created is functional
    and valuable to the MyBlog application. However, it is far from the last word
    in security. For example, suppose you need to secure a web application more tightly.
    You’ll need to consider two-factor authentication or, more realistically, use
    a third-party service to host your authentication.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过使用你所学的新模块——`flask_login`、`Flask_bcrypt`、`Flask-WTF`和`Flask-SQLAlchemy`——创建了一个有效的认证和授权系统。确保用户安全是应用程序被用户接受的关键步骤。你创建的授权系统对MyBlog应用程序来说是功能性和有价值的。然而，它远非安全领域的终结。例如，假设你需要更紧密地保护一个Web应用程序。你需要考虑双因素认证，或者更现实的是，使用第三方服务来托管你的认证。
- en: You’ve focused on authenticating/authorizing users of your application to an
    almost microscopic level. This level of detail helped create a useful and serviceable
    login/logout system to safeguard the users of MyBlog and the MyBlog system itself.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将你的应用程序的用户认证/授权聚焦到了几乎微观的程度。这种详细程度有助于创建一个有用且实用的登录/注销系统，以保护MyBlog及其系统本身的用户。
- en: The next chapter will magnify your view of the database information introduced
    here. Then, you’ll dive deeper into designing database tables and their relationships
    and how SQLAlchemy integrates the Python and database worlds.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将放大你对这里介绍的数据库信息的视野。然后，你将更深入地了解设计数据库表及其关系以及SQLAlchemy如何整合Python和数据库世界。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Taking advantage of the `base.xhtml` template and inheritance allows us to add
    the login/logout functionality to every page in the MyBlog application.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 `base.xhtml` 模板和继承功能，我们可以将登录/注销功能添加到 MyBlog 应用程序中的每个页面。
- en: Interacting with an external service through their API lets us send emails to
    our users to confirm who they are and reset their passwords. Using such services
    helps scale the MyBlog application and eliminates the work of configuring, running,
    and maintaining an email server.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过他们的 API 与外部服务交互，我们可以向用户发送电子邮件以确认他们的身份并重置他们的密码。使用此类服务有助于扩展 MyBlog 应用程序，并消除了配置、运行和维护电子邮件服务器的劳动。
- en: A user’s authorization is the other side of the coin to authenticating a user.
    The authorization information determines the user’s role—what they can do while
    logged into a web application.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的授权是验证用户的另一面。授权信息决定了用户的角色——他们在登录到网络应用程序时可以做什么。
- en: Authentication and authorization can be used with Flask to only allow logged-in
    users with specific roles access to particular MyBlog pages. Pages that allow
    users to make system-wide changes, or changes created by other users, are usually
    protected in this way.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Flask 进行身份验证和授权，可以仅允许具有特定角色的已登录用户访问特定的 MyBlog 页面。允许用户进行系统级更改或由其他用户创建的更改的页面通常以这种方式进行保护。
