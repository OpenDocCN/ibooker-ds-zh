- en: 2 asyncio basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 asyncio基础知识
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: The basics of `async` `await` syntax and coroutines
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async` `await` 语法和协程的基本知识'
- en: Running coroutines concurrently with tasks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用任务并行运行协程
- en: Canceling tasks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消任务
- en: Manually creating the event loop
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动创建事件循环
- en: Measuring a coroutine’s execution time
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量协程的执行时间
- en: Keeping eyes open for problems when running coroutines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行协程时保持警惕，注意可能出现的问题
- en: Chapter 1 dived into concurrency, looking at how we can achieve it with both
    processes and threads. We also explored how we could utilize non-blocking I/O
    and an event loop to achieve concurrency with only one thread. In this chapter,
    we’ll cover the basics of how to write programs using this single-threaded concurrency
    model with asyncio. Using the techniques in this chapter, you’ll be able to take
    long-running operations, such as web requests, database queries, and network connections
    and execute them in tandem.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 第一章深入探讨了并发，探讨了如何通过进程和线程实现并发。我们还探讨了如何利用非阻塞I/O和事件循环仅使用一个线程来实现并发。在本章中，我们将介绍如何使用asyncio编写使用单线程并发模型的程序的基础。使用本章中的技术，您将能够将长时间运行的操作，如Web请求、数据库查询和网络连接，同时执行。
- en: We’ll learn more about the *coroutine* construct and how to use `async` `await`
    syntax to define and run coroutines. We’ll also examine how to run coroutines
    concurrently by using tasks and examine the time savings we get from running concurrently
    by creating a reusable timer. Finally, we’ll look at common errors software engineers
    may make when using asyncio and how to use debug mode to spot these problems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更深入地了解协程结构以及如何使用`async` `await`语法来定义和运行协程。我们还将检查如何通过使用任务来并行运行协程，并检查通过创建可重用计时器从并行运行中获得的节省的时间。最后，我们将探讨软件工程师在使用asyncio时可能犯的常见错误，以及如何使用调试模式来发现这些问题。
- en: 2.1 Introducing coroutines
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 介绍协程
- en: Think of a coroutine like a regular Python function but with the superpower
    that it can pause its execution when it encounters an operation that could take
    a while to complete. When that long-running operation is complete, we can “wake
    up” our paused coroutine and finish executing any other code in that coroutine.
    While a paused coroutine is waiting for the operation it paused for to finish,
    we can run other code. This running of other code while waiting is what gives
    our application concurrency. We can also run several time-consuming operations
    concurrently, which can give our applications big performance improvements.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将协程想象成普通的Python函数，但它拥有一个超级能力，即当它遇到可能需要较长时间完成的操作时可以暂停其执行。当长时间运行的操作完成时，我们可以“唤醒”暂停的协程并完成该协程中任何其他代码的执行。当暂停的协程等待其暂停的操作完成时，我们可以运行其他代码。这种在等待时运行其他代码的能力为我们提供了并发性。我们还可以并行运行多个耗时操作，这可以为我们的应用程序带来显著的性能提升。
- en: To both create and pause a coroutine, we’ll need to learn to use Python’s `async`
    and `await` keywords. The `async` keyword will let us define a coroutine; the
    `await` keyword will let us pause our coroutine when we have a long-running operation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和暂停协程，我们需要学习如何使用Python的`async`和`await`关键字。`async`关键字将允许我们定义协程；`await`关键字将允许我们在遇到可能需要较长时间完成的操作时暂停我们的协程。
- en: Which Python version should I use?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该使用哪个Python版本？
- en: The code in this book assumes you are using the latest version of Python at
    the time of writing, which is Python 3.10\. Running code with versions earlier
    than this may have certain API methods missing, may function differently, or may
    have bugs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的代码假设您正在使用编写时的最新Python版本，即Python 3.10。使用早于此版本的代码可能缺少某些API方法，可能功能不同，或者可能存在错误。
- en: 2.1.1 Creating coroutines with the async keyword
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 使用`async`关键字创建协程
- en: Creating a coroutine is straightforward and not much different from creating
    a normal Python function. The only difference is that, instead of using the `def`
    keyword, we use `async` `def`. The `async` keyword marks a function as a coroutine
    instead of a normal Python function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建协程很简单，与创建普通Python函数没有太大区别。唯一的区别是，我们不是使用`def`关键字，而是使用`async` `def`。`async`关键字将函数标记为协程而不是普通Python函数。
- en: Listing 2.1 Using the async keyword
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1 使用`async`关键字
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The coroutine in the preceding listing does nothing yet other than print “Hello
    world!” It’s also worth noting that this coroutine does not perform any long-running
    operations; it just prints our message and returns. This means that, when we put
    the coroutine on the event loop, it will execute immediately because we don’t
    have any blocking I/O, and nothing is pausing execution yet.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表中的协程目前什么也没做，只是打印“Hello world！”也值得注意，这个协程不执行任何长时间运行的操作；它只是打印我们的消息并返回。这意味着，当我们把协程放在事件循环上时，它将立即执行，因为我们没有阻塞
    I/O，而且还没有任何操作暂停执行。
- en: This syntax is simple, but we’re creating something very different from a plain
    Python function. To illustrate this, let’s create a function that adds one to
    an integer as well as a coroutine that does the same and compare the results of
    calling each. We’ll also use the `type` convenience function to look at the type
    returned by calling a coroutine as compared to calling our normal function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法很简单，但我们正在创建与普通 Python 函数非常不同的东西。为了说明这一点，让我们创建一个函数，它将一个整数加一，以及一个执行相同操作的协程，并比较调用每个的结果。我们还将使用
    `type` 便利函数来查看调用协程返回的类型与调用我们的正常函数返回的类型进行比较。
- en: Listing 2.2 Comparing coroutines to normal functions
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 比较协程与普通函数
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we run this code, we’ll see output like the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此代码时，我们将看到以下输出：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how when we call our normal `add_one` function it executes immediately
    and returns what we would expect, another integer. However, when we call `coroutine_
    add_one` we don’t get our code in the coroutine executed at all. We get a *coroutine
    object* instead.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们调用我们的正常 `add_one` 函数时，它立即执行并返回我们预期的结果，即另一个整数。然而，当我们调用 `coroutine_add_one`
    时，我们根本不会执行协程中的代码。我们得到的是一个 *协程对象*。
- en: This is an important point, as coroutines aren’t executed when we call them
    directly. Instead, we create a coroutine object that can be run later. To run
    a coroutine, we need to explicitly run it on an event loop. So how can we create
    an event loop and run our coroutine?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的观点，因为当我们直接调用协程时，协程不会执行。相反，我们创建了一个协程对象，稍后可以运行。要运行一个协程，我们需要显式地在事件循环上运行它。那么我们如何创建事件循环并运行我们的协程呢？
- en: In versions of Python older than 3.7, we had to create an event loop if one
    did not already exist. However, the asyncio library has added several functions
    that abstract the event loop management. There is a convenience function, `asyncio.run`,
    we can use to run our coroutine. This is illustrated in the following listing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.7 之前的版本中，如果我们没有创建一个事件循环，我们必须创建一个。然而，asyncio 库添加了几个抽象事件循环管理的函数。有一个便利函数
    `asyncio.run`，我们可以用它来运行我们的协程。以下是一个示例。
- en: Listing 2.3 Running a coroutine
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 运行一个协程
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Running listing 2.3 will print “2,” as we would expect for returning the next
    integer. We’ve properly put our coroutine on the event loop, and we have executed
    it!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 运行列表 2.3 将打印出“2，”正如我们预期的那样，用于返回下一个整数。我们已经正确地将协程放在事件循环上，并且已经执行了它！
- en: '`asyncio.run` is doing a few important things in this scenario. First, it creates
    a brand-new event. Once it successfully does so, it takes whichever coroutine
    we pass into it and runs it until it completes, returning the result. This function
    will also do some cleanup of anything that might be left running after the main
    coroutine finishes. Once everything has finished, it shuts down and closes the
    event loop.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，`asyncio.run` 做了几件重要的事情。首先，它创建了一个全新的事件。一旦成功创建，它就会运行我们传递给它的任何协程，直到它完成，并返回结果。此函数还会清理主协程完成后可能留下的任何东西。一旦一切完成，它就会关闭并关闭事件循环。
- en: Possibly the most important thing about `asyncio.run` is that it is intended
    to be the main entry point into the asyncio application we have created. It only
    executes one coroutine, and that coroutine should launch all other aspects of
    our application. As we progress further, we will use this function as the entry
    point into nearly all our applications. The coroutine that `asyncio.run` executes
    will create and run other coroutines that will allow us to utilize the concurrent
    nature of asyncio.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio.run` 最重要的一点可能是，它打算成为我们创建的 asyncio 应用程序的主要入口点。它只执行一个协程，而这个协程应该启动我们应用程序的所有其他方面。随着我们进一步学习，我们将使用此函数作为几乎所有应用程序的入口点。`asyncio.run`
    执行的协程将创建并运行其他协程，这将使我们能够利用 asyncio 的并发特性。'
- en: 2.1.2 Pausing execution with the await keyword
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 使用 await 关键字暂停执行
- en: The example we saw in listing 2.3 did not need to be a coroutine, as it executed
    only non-blocking Python code. The real benefit of asyncio is being able to pause
    execution to let the event loop run other tasks during a long-running operation.
    To pause execution, we use the `await` keyword. The `await` keyword is usually
    followed by a call to a coroutine (more specifically, an object known as an *awaitable*,
    which is not always a coroutine; we’ll learn more about awaitables later in the
    chapter).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在列表 2.3 中看到的示例不需要是协程，因为它只执行了非阻塞的 Python 代码。asyncio 的真正好处是能够在长时间运行的操作期间暂停执行，让事件循环运行其他任务。为了暂停执行，我们使用
    `await` 关键字。`await` 关键字通常后跟对协程的调用（更具体地说，是一个称为 *awaitable* 的对象，它不总是协程；我们将在本章后面了解更多关于
    awaitable 的内容）。
- en: Using the `await` keyword will cause the coroutine following it to be run, unlike
    calling a coroutine directly, which produces a coroutine object. The `await` expression
    will also pause the coroutine where it is contained in until the coroutine we
    awaited finishes and returns a result. When the coroutine we awaited finishes,
    we’ll have access to the result it returned, and the containing coroutine will
    “wake up” to handle the result.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `await` 关键字会导致其后的协程运行，与直接调用协程不同，后者会产生一个协程对象。`await` 表达式还会暂停包含它的协程，直到我们等待的协程完成并返回结果。当我们等待的协程完成时，我们将能够访问它返回的结果，并且包含的协程将“醒来”以处理该结果。
- en: We can use the `await` keyword by putting it in front of a coroutine call. Expanding
    on our earlier program, we can write a program where we call the `add_one` function
    inside of a “main” async function and get the result.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在协程调用前放置 `await` 关键字来使用 `await` 关键字。扩展我们之前的程序，我们可以编写一个程序，在其中我们调用“main”异步函数内的
    `add_one` 函数并获取结果。
- en: Listing 2.4 Using await to wait for the result of coroutine
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 使用 await 等待协程的结果
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Pause, and wait for the result of add_one(1).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 暂停，等待 add_one(1) 的结果。
- en: ❷ Pause, and wait for the result of add_one(2).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 暂停，等待 add_one(2) 的结果。
- en: In listing 2.4, we pause execution twice. We first `await` the call to `add_one(1)`.
    Once we have the result, the main function will be “unpaused,” and we will assign
    the return value from `add_one(1)` to the variable `one_plus_one`, which in this
    case will be two. We then do the same for `add_one(2)` and then print the results.
    We can visualize the execution flow of our application, as shown in figure 2.1\.
    Each block of the figure represents what is happening at any given moment for
    one or more lines of code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 2.4 中，我们暂停执行两次。我们首先 `await` 对 `add_one(1)` 的调用。一旦我们有了结果，主函数将“暂停”，我们将 `add_one(1)`
    的返回值分配给变量 `one_plus_one`，在这种情况下将是 2。然后我们对 `add_one(2)` 做同样的操作，然后打印结果。我们可以可视化应用程序的执行流程，如图
    2.1 所示。图中的每个块代表在任何给定时刻一个或多个代码行正在发生的事情。
- en: '![02-01](Images/02-01.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![02-01](Images/02-01.png)'
- en: Figure 2.1 When we hit an await expression, we pause our parent coroutine and
    run the coroutine in the await expression. Once it is finished, we resume the
    parent coroutine and assign the return value.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 当我们遇到 await 表达式时，我们会暂停父协程并运行 await 表达式中的协程。一旦它完成，我们将恢复父协程并分配返回值。
- en: As it stands now, this code does not operate differently from normal, sequential
    code. We are, in effect, mimicking a normal call stack. Next, let’s look at a
    simple example of how to run other code by introducing a dummy sleep operation
    while we’re waiting.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，这段代码与正常、顺序代码的操作没有不同。实际上，我们正在模拟一个正常的调用栈。接下来，让我们看看一个简单的例子，说明如何在等待时通过引入一个模拟的
    sleep 操作来运行其他代码。
- en: 2.2 Introducing long-running coroutines with sleep
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 使用 sleep 引入长时间运行的协程
- en: Our previous examples did not use any slow operations and were used to help
    us learn the basic syntax of coroutines. To fully see the benefits and show how
    we can run multiple events simultaneously, we’ll need to introduce some long-running
    operations. Instead of making web API or database queries right away, which are
    nondeterministic as to how much time they will take, we’ll simulate long-running
    operations by specifying how long we want to wait. We’ll do this with the `asyncio.sleep`
    function.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的例子没有使用任何慢速操作，它们被用来帮助我们学习协程的基本语法。为了完全看到好处并展示我们如何同时运行多个事件，我们需要引入一些长时间运行的操作。我们不会立即进行网络
    API 或数据库查询，因为它们在所需时间上是不确定的，我们将通过指定我们想要等待多长时间来模拟长时间运行的操作。我们将使用 `asyncio.sleep`
    函数来完成此操作。
- en: We can use `asyncio.sleep` to make a coroutine “sleep” for a given number of
    seconds. This will pause our coroutine for the time we give it, simulating what
    would happen if we had a long-running call to a database or web API.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `asyncio.sleep` 使一个协程“睡眠”给定的时间数。这将暂停我们的协程，持续给定的时间，模拟如果有一个长时间运行的数据库或 Web
    API 调用会发生的情况。
- en: '`asyncio.sleep` is itself a coroutine, so we must use it with the `await` keyword.
    If we call it just by itself, we’ll get a coroutine object. Since `asyncio.sleep`
    is a coroutine, this means that when a coroutine awaits it, other code will be
    able to run.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio.sleep` 本身就是一个协程，因此我们必须使用 `await` 关键字来使用它。如果我们只调用它本身，我们将得到一个协程对象。由于
    `asyncio.sleep` 是一个协程，这意味着当一个协程等待它时，其他代码将能够运行。'
- en: Let’s examine a simple example, shown in the following listing, that sleeps
    for 1 second and then prints a `'Hello` `World!'` message.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一个简单的示例，如以下列表所示，该示例睡眠 1 秒然后打印一个 `'Hello` `World!'` 消息。
- en: Listing 2.5 A first application with sleep
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.5 使用 sleep 的第一个应用程序
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Pause hello_world_message for 1 second.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 暂停 `hello_world_message` 1 秒。
- en: ❷ Pause main until hello_world_message finishes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 暂停主程序，直到 `hello_world_message` 完成。
- en: When we run this application, our program will wait 1 second before printing
    our `'Hello` `World!'` message. Since `hello_world_message` is a coroutine and
    we pause it for 1 second with `asyncio.sleep`, we now have 1 second where we could
    be running other code concurrently.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个应用程序时，我们的程序将在打印 `'Hello` `World!'` 消息之前等待 1 秒。由于 `hello_world_message`
    是一个协程，并且我们使用 `asyncio.sleep` 暂停它 1 秒，我们现在有 1 秒的时间可以运行其他代码并发执行。
- en: We’ll be using `sleep` a lot in the next few examples, so let’s invest the time
    to create a reusable coroutine that sleeps for us and prints out some useful information.
    We’ll call this coroutine `delay`. This is shown in the following listing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个示例中，我们将大量使用 `sleep`，因此让我们花时间创建一个可重用的协程，它为我们睡眠并打印一些有用的信息。我们将把这个协程称为 `delay`。这将在下面的列表中展示。
- en: Listing 2.6 A reusable delay function
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 可重用延迟函数
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`delay` will take in an integer of the duration in seconds that we’d like the
    function to sleep and will return that integer to the caller once it has finished
    sleeping. We’ll also print when sleep begins and ends. This will help us see what
    other code, if any, is running concurrently while our coroutines are paused.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`delay` 将接收一个整数，表示我们希望函数睡眠的秒数，并在完成睡眠后将其返回给调用者。我们还将打印睡眠开始和结束的时间。这将帮助我们了解在协程暂停时，是否有其他代码正在并发运行。'
- en: 'To make referencing this utility function easier in future code listings, we’ll
    create a module that we’ll import in the remainder of this book when needed. We’ll
    also add to this module as we create additional reusable functions. We’ll call
    this module `util`, and we’ll put our delay function in a file called `delay_functions.py`.
    We’ll also add an `__init__.py` file with the following line, so we can nicely
    import the timer:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使在未来的代码列表中引用这个实用函数更容易，我们将创建一个模块，在本书的其余部分需要时我们将导入它。我们还将在此模块中添加额外的可重用函数。我们将把这个模块称为
    `util`，并将我们的延迟函数放在一个名为 `delay_functions.py` 的文件中。我们还将添加一个 `__init__.py` 文件，其中包含以下行，这样我们就可以很好地导入计时器：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: From now on in this book, we’ll use `from` `util` `import` `delay` whenever
    we need to use the `delay` function. Now that we have a reusable delay coroutine,
    let’s combine it with the earlier coroutine `add_one` to see if we can get our
    simple addition to run concurrently while `hello_world_message` is paused.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，在这本书中，每当我们需要使用 `delay` 函数时，我们将使用 `from` `util` `import` `delay`。现在我们有了可重用的延迟协程，让我们将其与之前的协程
    `add_one` 结合起来，看看我们是否可以使简单的加法在 `hello_world_message` 暂停时并发运行。
- en: Listing 2.7 Running two coroutines
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.7 运行两个协程
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Pause main until hello_world_message returns.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 暂停主程序，直到 `hello_world_message` 返回。
- en: ❷ Pause main until add_one returns.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 暂停主程序，直到 `add_one` 返回。
- en: When we run this, 1 second passes before the results of both function calls
    are printed. What we really want is the value of `add_one(1)` to be printed immediately
    while `hello_world_message()`runs concurrently. So why isn’t this happening with
    this code? The answer is that `await` pauses our current coroutine and won’t execute
    any other code inside that coroutine until the `await` expression gives us a value.
    Since it will take 1 second for our `hello_world_message` function to give us
    a value, the main coroutine will be paused for 1 second. Our code behaves as if
    it were sequential in this case. This behavior is illustrated in figure 2.2.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，在打印出两个函数调用的结果之前，需要经过1秒钟。我们真正想要的是在`hello_world_message()`并发运行的同时立即打印出`add_one(1)`的值。那么为什么这段代码没有这样做呢？答案是`await`会暂停当前的协程，并且不会执行该协程内的任何其他代码，直到`await`表达式返回一个值。由于`hello_world_message`函数需要1秒钟才能返回一个值，主协程将会暂停1秒钟。在这种情况下，我们的代码表现得就像它是顺序执行的。这种行为在图2.2中得到了说明。
- en: '![02-02](Images/02-02.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![02-02](Images/02-02.png)'
- en: Figure 2.2 Execution flow of listing 2.7
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 列表2.7的执行流程
- en: Both `main` and `hello_world` paused while we wait for `delay(1)` to finish.
    After it has finished, `main` resumes and can execute `add_one`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们等待`delay(1)`完成时，`main`和`hello_world`都被暂停了。一旦它完成，`main`就会恢复并可以执行`add_one`。
- en: We’d like to move away from this sequential model and run `add_one` concurrently
    with `hello_world`. To achieve this, we’ll need to introduce a concept called
    *tasks*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望摆脱这种顺序模型，并使`add_one`与`hello_world`并发运行。为了实现这一点，我们需要引入一个称为*任务*的概念。
- en: 2.3 Running concurrently with tasks
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 使用任务进行并发运行
- en: Earlier we saw that, when we call a coroutine directly, we don’t put it on the
    event loop to run. Instead, we get a coroutine object that we then need to either
    use the `await` keyword on it or pass it in to `asyncio.run` to run and get a
    value. With only these tools we can write async code, but we can’t run anything
    concurrently. To run coroutines concurrently, we’ll need to introduce *tasks*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们看到，当我们直接调用一个协程时，我们不会将其放入事件循环中运行。相反，我们得到一个协程对象，然后我们需要在它上面使用`await`关键字或者将其传递给`asyncio.run`来运行并获取一个值。仅使用这些工具，我们可以编写异步代码，但我们不能并发运行任何东西。为了并发运行协程，我们需要引入*任务*。
- en: Tasks are wrappers around a coroutine that schedule a coroutine to run on the
    event loop as soon as possible. This scheduling and execution happen in a non-blocking
    fashion, meaning that, once we create a task, we can execute other code instantly
    while the task is running. This contrasts with using the `await` keyword that
    acts in a blocking manner, meaning that we pause the entire coroutine until the
    result of the `await` expression comes back.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 任务是围绕一个协程的包装器，它会在事件循环上尽可能快地调度一个协程的运行。这种调度和执行是非阻塞的，这意味着一旦我们创建了一个任务，我们就可以在任务运行的同时立即执行其他代码。这与使用`await`关键字的行为形成对比，`await`关键字是阻塞的，意味着我们会暂停整个协程，直到`await`表达式的结果返回。
- en: The fact that we can create tasks and schedule them to run instantly on the
    event loop means that we can execute multiple tasks at roughly the same time.
    When these tasks wrap a long-running operation, any waiting they do will happen
    concurrently. To illustrate this, let’s create two tasks and try to run them at
    the same time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建任务并将它们调度到事件循环上立即运行的事实意味着我们可以大致同时执行多个任务。当这些任务包装了长时间运行的操作时，任何等待都会并发发生。为了说明这一点，让我们创建两个任务并尝试同时运行它们。
- en: 2.3.1 The basics of creating tasks
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 创建任务的基本知识
- en: Creating a task is achieved by using the `asyncio.create_task` function. When
    we call this function, we give it a coroutine to run, and it returns a task object
    instantly. Once we have a task object, we can put it in an `await` expression
    that will extract the return value once it is complete.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个任务是通过使用`asyncio.create_task`函数实现的。当我们调用这个函数时，我们给它一个要运行的协程，它会立即返回一个任务对象。一旦我们有了任务对象，我们可以将其放入一个`await`表达式中，一旦它完成，就会提取返回值。
- en: Listing 2.8 Creating a task
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8 创建任务
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding listing, we create a task that requires 3 seconds to complete.
    We also print out the type of the task, in this case, `<class` `'_asyncio.Task'>`,
    to show that it is different from a coroutine.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们创建了一个需要3秒钟才能完成的任务。我们还打印出了任务的类型，在这种情况下，`<class '_asyncio.Task'>`，以表明它与协程不同。
- en: One other thing to note here is that our print statement is executed immediately
    after we run the task. If we had simply used await on the delay coroutine we would
    have waited 3 seconds before outputting the message.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个需要注意的事项，那就是我们的打印语句在我们运行任务后立即执行。如果我们只是对延迟协程使用了`await`，我们将在输出消息之前等待3秒钟。
- en: Once we’ve printed our message, we apply an `await` expression to the task `sleep_
    for_three`. This will suspend our `main` coroutine until we have a result from
    our task.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们打印了我们的消息，我们就将`await`表达式应用于任务`sleep_for_three`。这将挂起我们的`main`协程，直到我们从任务中获得结果。
- en: It is important to know that we should usually use an `await` keyword on our
    tasks at some point in our application. In listing 2.8, if we did not use `await`,
    our task would be scheduled to run, but it would almost immediately be stopped
    and “cleaned up” when `asyncio.run` shut down the event loop. Using `await` on
    our tasks in our application also has implications for how exceptions are handled,
    which we’ll look at in chapter 3\. Now that we’ve seen how to create a task and
    allow other code to run concurrently, we can learn how to run multiple long-running
    operations at the same time.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，我们通常应该在应用程序的某个地方使用`await`关键字在我们的任务上。在列表2.8中，如果我们没有使用`await`，我们的任务将被安排运行，但几乎在`asyncio.run`关闭事件循环时立即停止并“清理”。在我们的应用程序中使用`await`任务也有对异常处理的影响，我们将在第3章中探讨。现在我们已经看到了如何创建任务并允许其他代码并发运行，我们可以学习如何同时运行多个长时间运行的操作。
- en: 2.3.2 Running multiple tasks concurrently
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 并发运行多个任务
- en: Given that tasks are created instantly and are scheduled to run as soon as possible,
    this allows us to run many long-running tasks concurrently. We can do this by
    sequentially starting multiple tasks with our long-running coroutine.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任务可以立即创建并且被安排为尽可能快地运行，这使我们能够并发运行许多长时间运行的任务。我们可以通过按顺序启动多个长时间运行的协程来实现这一点。
- en: Listing 2.9 Running multiple tasks concurrently
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.9 并发运行多个任务
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding listing we start three tasks, each taking 3 seconds to complete.
    Each call to `create_task` returns instantly, so we reach the `await` `sleep_for_three`
    statement right away. Previously, we mentioned that tasks are scheduled to run
    “as soon as possible.” Generally, this means the first time we hit an `await`
    statement after creating a task, any tasks that are pending will run as `await`
    triggers an iteration of the event loop.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们启动了三个任务，每个任务需要3秒钟来完成。每次调用`create_task`都会立即返回，因此我们立即到达`await` `sleep_for_three`语句。之前我们提到，任务被安排为“尽可能快地”运行。通常情况下，这意味着在创建任务后第一次遇到`await`语句时，任何挂起的任务都会在`await`触发事件循环迭代时运行。
- en: Since we’ve hit `await` `sleep_for_three`, all three tasks start running and
    will carry out any sleep operations concurrently. This means that the program
    in listing 2.9 will complete in about 3 seconds. We can visualize the concurrency
    as shown in figure 2.3, noting that all three tasks are running their sleep coroutines
    at the same time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们遇到了`await` `sleep_for_three`，所有三个任务开始运行，并将并发执行任何睡眠操作。这意味着列表2.9中的程序将在大约3秒内完成。我们可以通过图2.3可视化并发性，注意所有三个任务都在同时运行它们的睡眠协程。
- en: '![02-03](Images/02-03.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![02-03](Images/02-03.png)'
- en: Figure 2.3 Execution flow of listing 2.9
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 列表2.9的执行流程
- en: Note that in figure 2.3 the code in the tasks labeled RUN delay(3) (in this
    case, some print statements) does not run concurrently with other tasks; only
    the sleep coroutines run concurrently. If we were to run these delay operations
    sequentially, we’d have an application runtime of just over 9 seconds. By doing
    this concurrently, we’ve decreased the total runtime of this application three-fold!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在图2.3中，标记为RUN delay(3)（在这种情况下，一些打印语句）的任务中的代码不会与其他任务并发运行；只有睡眠协程会并发运行。如果我们按顺序运行这些延迟操作，我们的应用程序运行时间将略超过9秒。通过这种方式并发运行，我们已经将这个应用程序的总运行时间减少了三倍！
- en: Note This benefit compounds as we add more tasks; if we had launched 10 of these
    tasks, we would still take roughly 3 seconds, giving us a 10-fold speedup.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：随着我们添加更多任务，这种好处会累积；如果我们启动了10个这样的任务，我们仍然需要大约3秒钟，这将给我们带来10倍的速度提升。
- en: Executing these long-running operations concurrently is where asyncio really
    shines and delivers drastic improvements in our application’s performance, but
    the benefits don’t stop there. In listing 2.9, our application was actively doing
    nothing, while it was waiting for 3 seconds for our delay coroutines to complete.
    While our code is waiting, we can execute other code. As an example, let’s say
    we wanted to print out a status message every second while we were running some
    long tasks.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 并行执行这些长时间运行的操作是asyncio真正发光发热的地方，它为我们应用程序的性能带来了显著的提升，但好处并不止于此。在2.9列表中，我们的应用程序在积极做些无用功，同时它等待3秒钟以完成我们的延迟协程。当我们的代码等待时，我们可以执行其他代码。作为一个例子，让我们假设我们想在运行一些长时间任务的同时每秒打印一条状态信息。
- en: Listing 2.10 Running code while other operations complete
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.10 在其他操作完成时运行代码
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding listing, we create two tasks, each of which take 3 seconds
    to complete. While these tasks are waiting, our application is idle, which gives
    us the opportunity to run other code. In this instance, we run a coroutine `hello_every_second`,
    which prints a message every second 2 times. While our two tasks are running,
    we’ll see messages being output, giving us the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们创建了两个任务，每个任务需要3秒钟来完成。当这些任务等待时，我们的应用程序处于空闲状态，这给了我们运行其他代码的机会。在这个例子中，我们运行了一个协程`hello_every_second`，每秒打印一条信息2次。当我们的两个任务运行时，我们会看到输出信息，如下所示：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can imagine the execution flow as shown in figure 2.4.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将执行流程想象成图2.4所示的那样。
- en: '![02-04](Images/02-04.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![02-04](Images/02-04.png)'
- en: Figure 2.4 Execution flow of listing 2.10
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 列表2.10的执行流程
- en: First, we start two tasks that sleep for 3 seconds; then, while our two tasks
    are idle, we start to see `I’m` `running` `other` `code` `while` `I’m` `waiting!`
    being printed every second. This means that even when we’re running time-intensive
    operations, our application can still be performing other tasks.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们启动两个睡眠3秒钟的任务；然后，当我们的两个任务空闲时，我们开始看到每秒打印出`I’m` `running` `other` `code` `while`
    `I’m` `waiting!`的信息。这意味着即使我们在运行耗时操作时，我们的应用程序仍然可以执行其他任务。
- en: One potential issue with tasks is that they can take an indefinite amount of
    time to complete. We could find ourselves wanting to stop a task if it takes too
    long to finish. Tasks support this use case by allowing cancellation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 任务的一个潜在问题是它们可能需要不定的时间来完成。我们可能会希望停止一个耗时太长的任务。任务通过允许取消来支持这种用例。
- en: 2.4 Canceling tasks and setting timeouts
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 取消任务和设置超时
- en: Network connections can be unreliable. A user’s connection may drop because
    of a network slowdown, or a web server may crash and leave existing requests in
    limbo. When making one of these requests, we need to be especially careful that
    we don’t wait indefinitely. Doing so could lead to our application hanging, waiting
    forever for a result that may never come. It could also lead to a poor user experience;
    if we allow a user to make a request that takes too long, they are unlikely to
    wait forever for a response. Additionally, we may want to allow our users a choice
    if a task continues to run. A user may proactively decide things are taking too
    long, or they may want to stop a task they made in error.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 网络连接可能不可靠。用户的连接可能因为网络减速而断开，或者一个Web服务器可能崩溃，留下现有的请求处于悬而未决的状态。当我们发起这类请求时，我们需要特别注意不要无限期地等待。这样做可能会导致我们的应用程序挂起，永远等待可能永远不会到来的结果。这也可能导致用户体验不佳；如果我们允许用户发起耗时太长的请求，他们不太可能永远等待响应。此外，我们可能希望允许用户在任务继续运行时有所选择。用户可能会主动决定事情耗时太长，或者他们可能想要停止他们错误发起的任务。
- en: In our previous examples, if our tasks took forever, we would be stuck waiting
    for the `await` statement to finish with no feedback. We also had no way to stop
    things if we wanted to. asyncio supports both these situations by allowing tasks
    to be canceled as well as allowing them to specify a timeout.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，如果我们的任务需要无限期的时间，我们会陷入等待`await`语句完成而没有反馈的状态。如果我们想停止它们，我们也无法做到。asyncio通过允许任务被取消以及允许它们指定超时来支持这两种情况。
- en: 2.4.1 Canceling tasks
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 取消任务
- en: Canceling a task is straightforward. Each task object has a method named `cancel`,
    which we can call whenever we’d like to stop a task. Canceling a task will cause
    that task to raise a `CancelledError` when we `await` it, which we can then handle
    as needed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 取消任务很简单。每个任务对象都有一个名为`cancel`的方法，我们可以随时调用它来停止任务。取消任务会导致当我们在`await`它时，该任务抛出一个`CancelledError`，然后我们可以根据需要处理它。
- en: To illustrate this, let’s say we launch a long-running task that we don’t want
    to run for longer than 5 seconds. If the task is not completed within 5 seconds,
    we’d like to stop that task, reporting back to the user that it took too long
    and we’re stopping it. We also want a status update printed every second, to provide
    up-to-date information to our user, so they aren’t left without information for
    several seconds.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们假设我们启动了一个我们不想运行超过5秒钟的长时间运行的任务。如果任务在5秒内未完成，我们希望停止该任务，向用户报告它花费了太长时间，我们正在停止它。我们还希望每秒打印一个状态更新，以便向用户提供最新的信息，这样他们就不会在没有信息的情况下等待几秒钟。
- en: Listing 2.11 Canceling a task
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.11 取消任务
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding listing, we create a task that will take 10 seconds to run.
    We then create a `while` loop to check if that task is done. The `done` method
    on the task returns `True` if a task is finished and `False` otherwise. Every
    second, we check to see if the task has finished, keeping track of how many seconds
    we’ve checked so far. If our task has taken 5 seconds, we cancel the task. Then,
    we will go on to `await` `long_task`, and we’ll see `Our` `task` `was` `cancelled`
    printed out, indicating we’ve caught a `CancelledError`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们创建了一个需要10秒钟来运行的任务。然后我们创建了一个`while`循环来检查该任务是否完成。任务上的`done`方法如果任务已完成则返回`True`，否则返回`False`。每秒钟，我们检查任务是否完成，并记录我们已经检查了多少秒。如果我们的任务已经进行了5秒，我们将取消该任务。然后，我们将继续`await`
    `long_task`，我们会看到打印出`我们的任务已被取消`，这表明我们已经捕获了一个`CancelledError`。
- en: Something important to note about cancellation is that a `CancelledError` can
    only be thrown from an await statement. This means that if we call cancel on a
    task when it is executing plain Python code, that code will run until completion
    until we hit the next await statement (if one exists) and a `CancelledError` can
    be raised. Calling cancel won’t magically stop the task in its tracks; it will
    only stop the task if you’re currently at an await point or its next await point.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关于取消的一个重要注意事项是，`CancelledError`只能从一个`await`语句中抛出。这意味着如果我们在一个任务执行纯Python代码时调用取消，该代码将一直运行到完成，直到我们遇到下一个`await`语句（如果有的话），然后可以抛出`CancelledError`。调用取消不会神奇地停止任务；它只会停止任务，如果你当前处于一个`await`点或其下一个`await`点。
- en: 2.4.2 Setting a timeout and canceling with wait_for
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 使用`wait_for`设置超时和取消
- en: Checking every second or at some other time interval, and then canceling a task,
    as we did in the previous example, isn’t the easiest way to handle a timeout.
    Ideally, we’d have a helper function that would allow us to specify this timeout
    and handle cancellation for us.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒或在某些其他时间间隔检查，然后取消任务，就像我们在前面的例子中所做的那样，并不是处理超时的最简单方法。理想情况下，我们会有一个辅助函数，允许我们指定这个超时并为我们处理取消。
- en: asyncio provides this functionality through a function called `asyncio.wait_for`.
    This function takes in a coroutine or task object, and a timeout specified in
    seconds. It then returns a coroutine that we can `await`. If the task takes more
    time to complete than the timeout we gave it, a `TimeoutException` will be raised.
    Once we have reached the timeout threshold, the task will automatically be canceled.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: asyncio通过一个名为`asyncio.wait_for`的函数提供此功能。此函数接受一个协程或任务对象，以及以秒为单位指定的超时。然后它返回一个我们可以`await`的协程。如果任务完成所需时间超过我们给出的超时时间，将引发`TimeoutException`。一旦达到超时阈值，任务将自动取消。
- en: To illustrate how `wait_for` works, we’ll look at a case where we have a task
    that will take 2 seconds to complete, but we’ll only allow it 1 second to finish.
    When we get a `TimeoutError` raised, we’ll catch the exception and check to see
    if the task was canceled.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`wait_for`的工作原理，我们将查看一个案例，其中我们有一个需要2秒钟才能完成的任务，但我们只允许它1秒钟完成。当我们遇到`TimeoutError`异常时，我们将捕获该异常并检查任务是否被取消。
- en: Listing 2.12 Creating a timeout for a task with wait_for
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.12 使用`wait_for`为任务创建超时
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we run the preceding listing, our application will take roughly 1 second
    to complete. After 1 second our `wait_for` statement will raise a `TimeoutError`,
    which we then handle. We’ll then see that our original `delay` task was canceled,
    giving the following output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的列表时，我们的应用程序将大约需要1秒钟才能完成。1秒后，我们的`wait_for`语句将引发一个`TimeoutError`，然后我们处理它。然后我们会看到我们的原始`delay`任务已被取消，以下输出如下：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Canceling tasks automatically if they take longer than expected is normally
    a good idea. Otherwise, we may have a coroutine waiting indefinitely, taking up
    resources that may never be released. However, in certain circumstances we may
    want to keep our coroutine running. For example, we may want to inform a user
    that something is taking longer than expected after a certain amount of time but
    not cancel the task when the timeout is exceeded.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务执行时间超过预期，自动取消任务通常是一个好主意。否则，我们可能有一个协程无限期地等待，占用可能永远不会释放的资源。然而，在某些情况下，我们可能希望让我们的协程继续运行。例如，我们可能希望在经过一段时间后通知用户某事比预期花费的时间更长，但在超时时不取消任务。
- en: To do this we can wrap our task with the `asyncio.shield` function. This function
    will prevent cancellation of the coroutine we pass in, giving it a “shield,” which
    cancellation requests then ignore.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以使用`asyncio.shield`函数来包装我们的任务。这个函数将防止取消我们传递的协程，给它一个“护盾”，这样取消请求就会被忽略。
- en: Listing 2.13 Shielding a task from cancellation
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.13 保护任务免受取消
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding listing, we first create a task to wrap our coroutine. This
    differs from our first cancellation example because we’ll need to access the task
    in the `except` block. If we had passed in a coroutine, `wait_for` would have
    wrapped it in a task, but we wouldn’t be able to reference it, as it is internal
    to the function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们首先创建一个任务来包装我们的协程。这与我们的第一个取消示例不同，因为我们需要在`except`块中访问任务。如果我们传递了一个协程，`wait_for`会将其包装在任务中，但我们无法引用它，因为它在函数内部是内部的。
- en: 'Then, inside of a `try` block, we call `wait_for` and wrap the task in `shield`,
    which will prevent the task from being canceled. Inside our exception block, we
    print a useful message to the user, letting them know that the task is still running
    and then we `await` the task we initially created. This will let it finish in
    its entirety, and the program’s output will be as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`try`块内部，我们调用`wait_for`并将任务包装在`shield`中，这将防止任务被取消。在我们的异常块中，我们向用户打印一条有用的消息，让他们知道任务仍在运行，然后我们`await`最初创建的任务。这将允许它完整地完成，程序的输出将如下所示：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Cancellation and shielding are somewhat tricky subjects with several cases that
    are noteworthy. We introduce the basics below, but as we get into more complicated
    cases, we’ll explore how cancellation works in greater depth.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 取消和屏蔽是有些棘手的话题，有几个值得注意的情况。我们下面介绍基础知识，但随着我们进入更复杂的情况，我们将更深入地探讨取消的工作原理。
- en: We’ve now introduced the basics of tasks and coroutines. These concepts are
    intertwined with one another. In the following section, we’ll look at how tasks
    and coroutines are related to one another and understand a bit more about how
    asyncio is structured.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经介绍了任务和协程的基础知识。这些概念相互交织。在下一节中，我们将探讨任务和协程之间的关系，并更深入地了解asyncio的结构。
- en: 2.5 Tasks, coroutines, futures, and awaitables
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 任务、协程、futures和awaitables
- en: Coroutines and tasks can both be used in `await` expressions. So what is the
    common thread between them? To understand, we’ll need to know about both a `future`
    as well as an `awaitable`. You normally won’t need to use futures, but understanding
    them is a key to understanding the inner workings of asyncio. As some APIs return
    futures, we will reference them in the rest of the book.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 协程和任务都可以用在`await`表达式中。那么它们之间的共同点是什么呢？为了理解这一点，我们需要了解`future`以及`awaitable`。通常你不需要使用`future`，但了解它们是理解asyncio内部工作原理的关键。由于一些API返回`future`，我们将在本书的其余部分引用它们。
- en: 2.5.1 Introducing futures
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 介绍 futures
- en: A `future` is a Python object that contains a single value that you expect to
    get at some point in the future but may not yet have. Usually, when you create
    a `future`, it does not have any value it wraps around because it doesn’t yet
    exist. In this state, it is considered incomplete, unresolved, or simply not done.
    Then, once you get a result, you can set the value of the `future`. This will
    complete the `future`; at that time, we can consider it finished and extract the
    result from the `future`. To understand the basics of futures, let’s try creating
    one, setting its value and extracting that value back out.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`future`是一个Python对象，它包含一个你预期在未来某个时刻获得但可能尚未有的单一值。通常，当你创建一个`future`时，它围绕的值没有值，因为它还不存在。在这个状态下，它被认为是未完成的、未解决的或简单地未完成。然后，一旦你得到一个结果，你可以设置`future`的值。这将完成`future`；那时，我们可以认为它是完成的，并从`future`中提取结果。为了了解`future`的基本知识，让我们尝试创建一个，设置其值并提取该值。'
- en: Listing 2.14 The basics of futures
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.14 `future`的基本知识
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can create a `future` by calling its constructor. At this time, the `future`
    will have no result set on it, so calling its `done` method will return `False`.
    We then set the value of the `future` with its `set_result` method, which will
    mark the `future` as `done`. Alternatively, if we had an exception we wanted to
    set on the `future`, we could call `set_exception`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用其构造函数来创建一个`future`。在这个时候，`future`上还没有结果集，因此调用其`done`方法将返回`False`。然后我们使用`set_result`方法设置`future`的值，这将标记`future`为`done`。或者，如果我们想在`future`上设置一个异常，我们可以调用`set_exception`。
- en: Note We don’t call the result method before the result is set because the `result`
    method will throw an invalid state exception if we do so.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在设置结果之前我们不调用结果方法，因为如果这样做，`result`方法将抛出一个无效状态异常。
- en: Futures can also be used in `await` expressions. If we `await` a `future`, we’re
    saying “pause until the `future` has a value set that I can work with, and once
    I have a value, wake up and let me process it.”
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`future`也可以用在`await`表达式中。如果我们`await`一个`future`，这意味着“暂停直到`future`有一个可以工作的值被设置，一旦我有了值，醒来并让我处理它。”'
- en: To understand this, let’s consider an example of making a web request that returns
    a `future`. Making a request that returns a `future` should complete instantly,
    but as the request will take some time, the `future` will not yet be defined.
    Then, later, once the request has finished, the result will be set, then we can
    access it. If you have used JavaScript in the past, this concept is analogous
    to *promises*. In the Java world, these are known as *completable futures*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点，让我们考虑一个创建返回`future`的Web请求的例子。返回`future`的请求应该立即完成，但由于请求需要一些时间，`future`尚未定义。然后，稍后，一旦请求完成，结果将被设置，然后我们可以访问它。如果你以前使用过JavaScript，这个概念类似于*promises*。在Java世界中，这些被称为*completable
    futures*。
- en: Listing 2.15 Awaiting a future
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.15 等待一个`future`
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Create a task to asynchronously set the value of the future.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个任务以异步设置`future`的值。
- en: ❷ Wait 1 second before setting the value of the future.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在设置`future`的值之前等待1秒钟。
- en: ❸ Pause main until the future’s value is set.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 暂停主函数直到`future`的值被设置。
- en: In the preceding listing, we define a function `make_request``.` In that function
    we create a `future` and create a `task` that will asynchronously set the result
    of the `future` after 1 second. Then, in the main function, we call `make_request`.
    When we call this, we’ll instantly get a `future` with no result; it is, therefore,
    undone. Then, we `await` the `future`. Awaiting this `future` will pause `main`
    for 1 second while we wait for the value of the future to be set. Once this completes,
    `value` will be `42` and the `future` is `done`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们定义了一个函数`make_request`。在那个函数中，我们创建了一个`future`并创建了一个`task`，该`task`将在1秒后将`future`的结果异步设置。然后，在主函数中，我们调用`make_request`。当我们调用这个函数时，我们会立即得到一个没有结果的`future`；因此，它是未完成的。然后，我们`await`这个`future`。等待这个`future`将暂停`main`函数1秒钟，直到我们等待`future`的值被设置。一旦完成，`value`将是`42`，`future`是`done`的。
- en: In the world of asyncio, you should rarely need to deal with futures. That said,
    you will run into some asyncio APIs which return futures, and you may need to
    work with callback-based code, which can require futures. You may also need to
    read or debug some asyncio API code yourself. The implementation of these asyncio
    APIs heavily rely on futures, so it is ideal to have a basic understanding of
    how they work.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在`asyncio`的世界里，你很少需要处理`future`。尽管如此，你可能会遇到一些返回`future`的`asyncio` API，你可能需要与基于回调的代码一起工作，这可能需要`future`。你也可能需要自己阅读或调试一些`asyncio`
    API代码。这些`asyncio` API的实现高度依赖于`future`，因此了解它们是如何工作的非常有用。
- en: 2.5.2 The relationship between futures, tasks, and coroutines
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 `future`、`task`和协程之间的关系
- en: There is a strong relationship between tasks and futures. In fact, `task` directly
    inherits from `future`. A `future` can be thought as representing a value that
    we won’t have for a while. A `task` can be thought as a combination of both a
    coroutine and a `future`. When we create a `task`, we are creating an empty `future`
    and running the coroutine. Then, when the coroutine has completed with either
    an exception or a result, we set the result or exception of the `future`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 任务和`future`之间存在紧密的关系。实际上，`task`直接继承自`future`。`future`可以被视为代表我们暂时不会拥有的一个值。`task`可以被视为一个协程和`future`的组合。当我们创建一个`task`时，我们创建了一个空的`future`并运行协程。然后，当协程完成，无论是异常还是结果，我们都会设置`future`的结果或异常。
- en: Given the relationship between futures and tasks, is there a similar relationship
    between tasks and coroutines? After all, all these types can be used in `await`
    expressions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到未来和任务之间的关系，任务和协程之间是否存在类似的关系？毕竟，所有这些类型都可以用在 `await` 表达式中。
- en: The common thread between these is the `Awaitable` abstract base class. This
    class defines one abstract double underscore method __`await`__. We won’t go into
    the specifics about how to create our own awaitables, but anything that implements
    the `__await__` method can be used in an `await` expression. Coroutines inherit
    directly from `Awaitable`, as do `futures`. Tasks then extend futures, which gives
    us the inheritance diagram shown in figure 2.5.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些之间的共同点是 `Awaitable` 抽象基类。这个类定义了一个抽象的双下划线方法 __`await`__。我们不会深入讨论如何创建我们自己的 awaitables，但任何实现了
    `__await__` 方法的对象都可以用在 `await` 表达式中。协程直接继承自 `Awaitable`，`futures` 也是如此。任务然后扩展了
    `futures`，这给我们带来了如图 2.5 所示的继承图。
- en: '![02-05](Images/02-05.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![02-05](Images/02-05.png)'
- en: Figure 2.5 The class inheritance hierarchy of Awaitable
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 Awaitable 的类继承层次结构
- en: Going forward, we’ll start to refer to objects that can be used in await expressions
    as *awaitables*. You’ll frequently see the term *awaitable* referenced in the
    asyncio documentation, as many API methods don’t care if you pass in coroutines,
    tasks, or futures.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将开始使用可以在 `await` 表达式中使用的对象称为 *awaitables*。你会在 asyncio 文档中经常看到 *awaitable*
    这个术语被引用，因为许多 API 方法并不关心你传递的是协程、任务还是未来。
- en: Now that we understand the basics of coroutines, tasks, and futures, how do
    we assess their performance? So far, we’ve only theorized about how long they
    take. To make things more rigorous, let’s add some functionality to measure execution
    time.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了协程、任务和未来的基础知识，我们如何评估它们的性能呢？到目前为止，我们只理论化了它们所需的时间。为了使事情更加严谨，让我们添加一些功能来测量执行时间。
- en: 2.6 Measuring coroutine execution time with decorators
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 使用装饰器测量协程执行时间
- en: So far, we’ve talked about roughly how long our applications take to run without
    timing them. To really understand and profile things we’ll need to introduce some
    code to keep track of this for us.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了大致了解应用程序运行所需时间的方法，而没有进行计时。要真正理解和分析这些内容，我们需要引入一些代码来帮助我们跟踪这些信息。
- en: 'As a first try we could wrap every `await` statement and keep track of the
    start and end time of the coroutine:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一次尝试，我们可以包装每个 `await` 语句并跟踪协程的开始和结束时间：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: However, this will get messy quickly when we have multiple `await` statements
    and tasks to keep track of. A better approach is to come up with a reusable way
    to keep track of how long any coroutine takes to finish. We can do this by creating
    a decorator that will run an `await` statement for us (listing 2.16). We’ll call
    this decorator `async_timed`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们有多个 `await` 语句和需要跟踪的任务时，这会很快变得混乱。一个更好的方法是找到一个可重用的方法来跟踪任何协程完成所需的时间。我们可以通过创建一个装饰器来实现这一点，该装饰器将为我们运行
    `await` 语句（列表 2.16）。我们将这个装饰器称为 `async_timed`。
- en: What is a decorator?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是装饰器？
- en: A *decorator* is a pattern in Python that allows us to add functionality to
    existing functions without changing that function’s code. We can “intercept” a
    function as it is being called and apply any decorator code we’d like before or
    after that call. Decorators are one way to tackle cross-cutting concerns. The
    following listing illustrates a sample decorator.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*装饰器* 是 Python 中的一种模式，它允许我们在不改变现有函数代码的情况下为其添加功能。我们可以“拦截”一个函数在调用时的行为，并在该调用之前或之后应用我们想要的任何装饰器代码。装饰器是解决横切关注点的一种方式。以下列表展示了示例装饰器。'
- en: Listing 2.16 A decorator for timing coroutines
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.16 用于计时协程的装饰器
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this decorator, we create a new coroutine called *wrapped*. This is a wrapper
    around our original coroutine that takes its arguments, `*args` and `**kwargs`,
    calls an `await` statement, and then returns the result. We surround that `await`
    statement with one message when we start running the function and another message
    when we end running the function, keeping track of the start and end time in much
    the same way that we did in our earlier start-time and end-time example. Now,
    as shown in listing 2.17, we can put this annotation on any coroutine, and any
    time we run it, we’ll see how long it took to run.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个装饰器中，我们创建了一个名为 *wrapped* 的新协程。这是一个围绕我们的原始协程的包装器，它接受其参数 `*args` 和 `**kwargs`，调用一个
    `await` 语句，然后返回结果。我们在开始运行函数时围绕那个 `await` 语句发送一条消息，在结束运行函数时发送另一条消息，以记录开始和结束时间，这与我们在早期开始时间和结束时间示例中所做的方式非常相似。现在，如列表
    2.17 所示，我们可以在任何协程上放置这个注解，每次运行它时，我们都会看到它运行了多长时间。
- en: Listing 2.17 Timing two concurrent tasks with a decorator
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.17 使用装饰器计时两个并发任务
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When we run the preceding listing, we’ll see console output similar to the
    following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的列表时，我们会看到类似于以下内容的控制台输出：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can see that our two `delay` calls were both started and finished in roughly
    2 and 3 seconds, respectively, for a total of 5 seconds. Notice, however, that
    our main coroutine only took 3 seconds to complete because we were waiting concurrently.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的两个`delay`调用分别在大约2秒和3秒内开始和完成，总共5秒。然而，请注意，我们的主协程只用了3秒就完成了，因为我们是在并发等待。
- en: We’ll use this decorator and the resulting output throughout the next several
    chapters to illustrate how long our coroutines are taking to execute as well as
    when they start and complete. This will give us a clear picture of where we see
    performance gains by executing our operations concurrently.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的几章中使用这个装饰器和产生的输出来说明我们的协程执行所需的时间，以及它们何时开始和完成。这将给我们一个清晰的画面，了解我们在并发执行操作时看到性能提升的地方。
- en: 'To make referencing this utility decorator easier in future code listings,
    let’s add this to our `util` module. We’ll put our timer in a file called `async_timer.py`.
    We’ll also add a line to the module’s `__init__.py` file with the following line
    so we can nicely import the timer:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使在未来的代码列表中引用这个实用装饰器更容易，让我们将其添加到我们的`util`模块中。我们将把我们的计时器放在一个名为`async_timer.py`的文件中。我们还将向模块的`__init__.py`文件中添加一行，如下所示，以便我们可以优雅地导入计时器：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the rest of this book, we’ll use `from` `util` `import` `async_timed` whenever
    we need to use the timer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，每当我们需要使用计时器时，我们将使用`from util import async_timed`。
- en: Now that we can use our decorator to understand the performance gains that asyncio
    can provide when running tasks concurrently, we may be tempted to try and use
    asyncio all over our existing applications. This can work, but we need to be careful
    that we aren’t running into any of the common pitfalls with asyncio that can degrade
    our application’s performance.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们的装饰器来理解asyncio在并发运行任务时可以提供的性能提升，我们可能会想尝试在我们的现有应用程序中到处使用asyncio。这可以行得通，但我们需要小心，不要遇到任何可能降低我们应用程序性能的asyncio常见陷阱。
- en: 2.7 The pitfalls of coroutines and tasks
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7 协程和任务的陷阱
- en: When seeing the performance improvements we can obtain from running some of
    our longer tasks concurrently, we can be tempted to start to use coroutines and
    tasks everywhere in our applications. While it depends on the application you’re
    writing, simply marking functions `async` and wrapping them in tasks may not help
    application performance. In certain cases, this may degrade performance of your
    applications.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到通过并发运行一些较长的任务可以获得性能提升时，我们可能会被诱惑在我们的应用程序的每个地方开始使用协程和任务。虽然这取决于你正在编写的应用程序，但仅仅将函数标记为`async`并将它们包装在任务中可能不会帮助提高应用程序的性能。在某些情况下，这可能会降低你应用程序的性能。
- en: Two main errors occur when trying to turn your applications asynchronous. The
    first is attempting to run CPU-bound code in tasks or coroutines without using
    multiprocessing; the second is using blocking I/O-bound APIs without using multithreading.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试将你的应用程序异步化时，会出现两个主要错误。第一个是在不使用多进程的情况下尝试在任务或协程中运行CPU密集型代码；第二个是使用阻塞I/O密集型API而不使用多线程。
- en: 2.7.1 Running CPU-bound code
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.7.1 运行CPU密集型代码
- en: We may have functions that perform computationally expensive calculations, such
    as looping over a large dictionary or doing a mathematical computation. Where
    we have several of these functions with the potential to run concurrently, we
    may get the idea to run them in separate tasks. In concept, this is a good idea,
    but remember that asyncio has a single-threaded concurrency model. This means
    we are still subject to the limitations of a single thread and the global interpreter
    lock.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有一些执行计算量大的函数，例如遍历一个大的字典或进行数学计算。当我们有多个这样的函数，并且它们有可能并发运行时，我们可能会想到将它们分别运行在不同的任务中。从概念上讲，这是一个好主意，但请记住，asyncio有一个单线程的并发模型。这意味着我们仍然受到单线程和全局解释器锁的限制。
- en: To prove this to ourselves, let’s try to run some CPU-bound functions concurrently.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，让我们尝试并发运行一些CPU密集型函数。
- en: Listing 2.18 Attempting to run CPU-bound code concurrently
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.18 尝试并发运行CPU密集型代码
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When we run the preceding listing, we’ll see that, despite creating two tasks,
    our code still executes sequentially. First, we run Task 1, then we run Task 2,
    meaning our total runtime will be the sum of the two calls to `cpu_bound_work`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的列表时，我们会看到，尽管创建了两个任务，但我们的代码仍然顺序执行。首先，我们运行任务1，然后运行任务2，这意味着我们的总运行时间将是两次调用`cpu_bound_work`的总和：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Looking at the output above, we may be tempted to think that there are no drawbacks
    to making all our code use `async` and `await`. After all, it ends up taking the
    same amount of time as if we had run things sequentially. However, by doing this
    we can run into situations where our application’s performance can degrade. This
    is especially true when we have other coroutines or tasks that have `await` expressions.
    Consider creating two CPU-bound tasks alongside a long-running task, such as our
    `delay` coroutine.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 观察上面的输出，我们可能会认为将所有代码都使用`async`和`await`没有缺点。毕竟，它最终花费的时间与顺序运行相同。然而，通过这样做，我们可能会遇到应用程序性能下降的情况。这在我们有其他包含`await`表达式的协程或任务时尤其如此。考虑创建两个CPU密集型任务与一个长时间运行的任务（如我们的`delay`协程）一起。
- en: Listing 2.19 CPU-bound code with a task
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.19 CPU密集型代码与任务
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Running the preceding listing, we might expect to take the same amount of time
    as in listing 2.18\. After all, won’t `delay_task` run concurrently alongside
    the CPU-bound work? In this instance it won’t because we create the two CPU-bound
    tasks first, which, in effect, blocks the event loop from running anything else.
    This means the runtime of our application will be the sum of time it took for
    our two `cpu_bound_work` tasks to finish plus the 4 seconds that our `delay` task
    took.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的列表，我们可能会期望花费的时间与列表2.18相同。毕竟，`delay_task`不会与CPU密集型工作并行运行吗？在这个例子中不会，因为我们首先创建了两个CPU密集型任务，这实际上阻止了事件循环运行任何其他任务。这意味着我们应用程序的运行时间将是我们的两个`cpu_bound_work`任务完成所需时间的总和加上我们的`delay`任务所花费的4秒钟。
- en: If we need to perform CPU-bound work and still want to use `async` / `await`
    syntax, we can do so. To do this we’ll still need to use multiprocessing, and
    we need to tell asyncio to run our tasks in a *process pool*. We’ll learn how
    to do this in chapter 6.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要执行CPU密集型工作，同时还想使用`async` / `await`语法，我们可以这样做。为此，我们仍然需要使用多进程，并需要告诉asyncio在*进程池*中运行我们的任务。我们将在第6章学习如何做到这一点。
- en: 2.7.2 Running blocking APIs
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.7.2 运行阻塞API
- en: We may also be tempted to use our existing libraries for I/O-bound operations
    by wrapping them in coroutines. However, this will generate the same issues that
    we saw with CPU-bound operations. These APIs block the `main` thread. Therefore,
    when we run a blocking API call inside a coroutine, we’re blocking the event loop
    thread itself, meaning that we stop any other coroutines or tasks from executing.
    Examples of blocking API calls include libraries such as `requests`, or `time.sleep`.
    Generally, any function that performs I/O that is not a coroutine or performs
    time-consuming CPU operations can be considered blocking.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可能倾向于通过将它们包装在协程中来使用现有的用于I/O密集型操作的库。然而，这会产生与CPU密集型操作相同的问题。这些API会阻塞`main`线程。因此，当我们在一个协程中运行阻塞的API调用时，我们实际上是在阻塞事件循环线程本身，这意味着我们阻止了任何其他协程或任务的执行。阻塞API调用的例子包括`requests`库或`time.sleep`。一般来说，任何不是协程且执行I/O操作或进行耗时CPU操作的函数都可以被认为是阻塞的。
- en: As an example, let’s try getting the status code of [www.example.com](http://www.example.com)
    three times concurrently, using the `requests` library. When we run this, since
    we’re running concurrently we’ll be expecting this application to finish in about
    the length of time necessary to get the status code once.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们尝试三次并发获取[www.example.com](http://www.example.com)的状态码，使用`requests`库。当我们运行这个时，由于我们是在并发运行，我们预计这个应用程序将花费大约获取状态码一次所需的时间来完成。
- en: Listing 2.20 Incorrectly using a blocking API in a coroutine
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.20 在协程中不正确地使用阻塞API
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When running the preceding listing, we’ll see output similar to the following.
    Note how the total runtime of the main coroutine is roughly the sum of time for
    all the tasks to get the status we ran, meaning that we did not have any concurrency
    advantage:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行前面的列表时，我们将看到类似于以下输出的内容。注意，主协程的总运行时间大致是所有任务获取我们运行的状态所需时间的总和，这意味着我们没有获得任何并发优势：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is again because the `requests` library is blocking, meaning it will block
    whichever thread it is run on. Since asyncio only has one thread, the `requests`
    library blocks the event loop from doing anything concurrently.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次是因为 `requests` 库是阻塞的，这意味着它将阻塞运行在其上的任何线程。由于 asyncio 只有一个线程，因此 `requests` 库会阻止事件循环进行并发操作。
- en: As a rule, most APIs you employ now are blocking and won’t work out of the box
    with asyncio. You need to use a library that supports coroutines and utilizes
    non-blocking sockets. This means that if the library you are using does not return
    coroutines and you aren’t using `await` in your own coroutines, you’re likely
    making a blocking call.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你现在使用的多数 API 都是阻塞的，并且不能与 asyncio 无缝工作。你需要使用支持协程并利用非阻塞套接字的库。这意味着，如果你使用的库不返回协程，并且你自己的协程中没有使用
    `await`，那么你很可能会进行阻塞调用。
- en: In the above example we can use a library such as aiohttp, which uses non-blocking
    sockets and returns coroutines to get proper concurrency. We’ll introduce this
    library later in chapter 4.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们可以使用像 aiohttp 这样的库，它使用非阻塞套接字并返回协程以获得适当的并发性。我们将在第 4 章中介绍这个库。
- en: If you need to use the `requests` library, you can still use `async` syntax,
    but you’ll need to explicitly tell asyncio to use multithreading with a *thread
    pool executor*. We’ll see how to do this in chapter 7.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要使用 `requests` 库，你仍然可以使用 `async` 语法，但你需要明确告诉 asyncio 使用带有 *线程池执行器* 的多线程。我们将在第
    7 章中看到如何做到这一点。
- en: We’ve now seen a few things to look for when using asyncio and have built a
    few simple applications. So far, we have not created or configured the event loop
    ourselves but relied on convenience methods to do it for us. Next, we’ll learn
    to create the event loop, which will allow us to access lower-level asyncio functionality
    and event loop configuration properties.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了在使用 asyncio 时需要注意的一些事情，并构建了一些简单的应用程序。到目前为止，我们还没有自己创建或配置事件循环，而是依赖便利的方法来为我们完成这些工作。接下来，我们将学习如何创建事件循环，这将使我们能够访问更底层的
    asyncio 功能和事件循环配置属性。
- en: 2.8 Accessing and manually managing the event loop
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.8 访问和手动管理事件循环
- en: Until now, we have used the convenient `asyncio.run` to run our application
    and create the event loop for us behind the scenes. Given the ease of use, this
    is the preferred method to create the event loop. However, there may be cases
    in which we don’t want the functionality that `asyncio.run` provides. As an example,
    we may want to execute custom logic to stop tasks that differ from what `asyncio.run`
    does, such as letting any remaining tasks finish instead of stopping them.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用方便的 `asyncio.run` 来运行我们的应用程序，并在幕后为我们创建事件循环。鉴于其易用性，这是创建事件循环的首选方法。然而，可能存在我们不想使用
    `asyncio.run` 提供的功能的情况。例如，我们可能想要执行自定义逻辑来停止与 `asyncio.run` 所做不同的任务，例如让任何剩余的任务完成而不是停止它们。
- en: In addition, we may want to access methods available on the event loop itself.
    These methods are typically lower level and, as such, should be used sparingly.
    However, if you want to perform tasks, such as working directly with sockets or
    scheduling a task to run at a specific time in the future, you’ll need to access
    the event loop. While we won’t, and shouldn’t, be managing the event loop extensively,
    this will be necessary from time to time.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可能还想访问事件循环本身上的方法。这些方法通常是低级别的，因此应该谨慎使用。然而，如果你想要执行任务，例如直接与套接字工作或安排在未来的某个时间运行的任务，你需要访问事件循环。虽然我们不会，也不应该，大量管理事件循环，但有时这将是必要的。
- en: 2.8.1 Creating an event loop manually
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.8.1 手动创建事件循环
- en: We can create an event loop by using the `asyncio.new_event_loop` method. This
    will return an event loop instance. With this, we have access to all the low-level
    methods that the event loop has to offer. With the event loop we have access to
    a method named `run_until_complete`, which takes a coroutine and runs it until
    it finishes. Once we are done with our event loop, we need to close it to free
    any resources it was using. This should normally be in a `finally` block so that
    any exceptions thrown don’t stop us from closing the loop. Using these concepts,
    we can create a loop and run an asyncio application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `asyncio.new_event_loop` 方法来创建事件循环。这将返回一个事件循环实例。有了这个，我们就有了访问事件循环提供的所有底层方法。有了事件循环，我们可以访问一个名为
    `run_until_complete` 的方法，它接受一个协程并在其完成前运行它。一旦我们完成事件循环，我们需要关闭它以释放它所使用的任何资源。这通常应该在
    `finally` 块中完成，这样任何抛出的异常都不会阻止我们关闭循环。使用这些概念，我们可以创建一个循环并运行 asyncio 应用程序。
- en: Listing 2.21 Manually creating the event loop
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.21 手动创建事件循环
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The code in this listing is similar to what happens when we call `asyncio.run`
    with the difference being that this does not perform canceling any remaining tasks.
    If we want any special cleanup logic, we would do so in our `finally` clause.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的代码与我们调用`asyncio.run`时发生的情况类似，区别在于这不会取消任何剩余的任务。如果我们想要任何特殊的清理逻辑，我们将在`finally`子句中这样做。
- en: 2.8.2 Accessing the event loop
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.8.2 访问事件循环
- en: From time to time, we may need to access the currently running event loop. asyncio
    exposes the `asyncio.get_running_loop` function that allows us to get the current
    event loop. As an example, let’s look at `call_soon`, which will schedule a function
    to run on the next iteration of the event loop.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要访问当前运行的事件循环。asyncio公开了`asyncio.get_running_loop`函数，允许我们获取当前事件循环。作为一个例子，让我们看看`call_soon`，它将在事件循环的下一个迭代上安排一个函数运行。
- en: Listing 2.22 Accessing the event loop
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.22 访问事件循环
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding listing, our main coroutine gets the event loop with `asyncio.get`
    `_running_loop` and tells it to run `call_later`, which takes a function and will
    run it on the next iteration of the event loop. In addition, there is an `asyncio.get_event`
    `_loop` function that lets you access the event loop.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们的主协程使用`asyncio.get` `_running_loop`获取事件循环，并告诉它运行`call_later`，该函数将在事件循环的下一个迭代上运行。此外，还有一个`asyncio.get_event`
    `_loop`函数，允许你访问事件循环。
- en: This function can potentially create a new event loop if it is called when one
    is not already running, leading to strange behavior. It is recommended to use
    `get_ running_loop`, as this will throw an exception if an event loop isn’t running,
    avoiding any surprises.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在未运行事件循环时调用此函数，它可能会创建一个新的事件循环，从而导致奇怪的行为。建议使用`get_ running_loop`，因为它会在事件循环未运行时抛出异常，避免任何意外。
- en: While we shouldn’t use the event loop frequently in our applications, there
    are times when we will need to configure settings on the event loop or use low-level
    functions. We’ll see an example of configuring the event loop in the next section
    on *debug* *mode*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不应该在我们的应用程序中频繁使用事件循环，但有时我们仍需要配置事件循环的设置或使用底层函数。我们将在下一节关于*调试* *模式*中看到一个配置事件循环的例子。
- en: 2.9 Using debug mode
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.9 使用调试模式
- en: In previous sections, we mentioned how coroutines should always be awaited at
    some point in the application. We also saw the drawbacks of running CPU-bound
    and other blocking code inside coroutines and tasks. It can, however, be hard
    to tell if a coroutine is taking too much time on CPU, or if we accidently forgot
    an `await` somewhere in our application. Luckily, asyncio gives us a debug mode
    to help us diagnose these situations.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们提到了协程应该在应用程序的某个点上始终被等待。我们也看到了在协程和任务中运行CPU密集型和其他阻塞代码的缺点。然而，判断一个协程是否在CPU上花费了太多时间，或者我们是否在应用程序中不小心遗漏了一个`await`，可能有些困难。幸运的是，asyncio为我们提供了一个调试模式来帮助我们诊断这些情况。
- en: When we run in `debug` mode, we’ll see a few helpful log messages when a coroutine
    or task takes more than 100 milliseconds to run. In addition, if we don’t `await`
    a coroutine, an exception is thrown, so we can see where to properly add an `await`.
    There are a few different ways to run in debug mode.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`debug`模式下运行时，如果协程或任务运行时间超过100毫秒，我们会看到一些有用的日志消息。此外，如果我们没有`await`一个协程，会抛出一个异常，因此我们可以看到在哪里正确添加`await`。有几种不同的方式可以在调试模式下运行。
- en: 2.9.1 Using asyncio.run
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.9.1 使用asyncio.run
- en: 'The `asyncio.run` function we have been using to run coroutines exposes a `debug`
    parameter. By default, this is set to `False`, but we can set this to `True` to
    enable debug mode:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来运行协程的`asyncio.run`函数公开了一个`debug`参数。默认情况下，这个参数设置为`False`，但我们可以将其设置为`True`以启用调试模式：
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 2.9.2 Using command-line arguments
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.9.2 使用命令行参数
- en: 'Debug mode can be enabled by passing a command-line argument when we start
    our Python application. To do this we apply `-X` `dev`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在启动Python应用程序时传递命令行参数，我们可以启用调试模式。为此，我们应用`-X` `dev`：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 2.9.3 Using environment variables
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.9.3 使用环境变量
- en: 'We can also use environment variables to enable debug mode by setting the `PYTHONASYNCIODEBUG`
    variable to `1`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过设置`PYTHONASYNCIODEBUG`变量为`1`来使用环境变量启用调试模式：
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note In versions of Python older than 3.9, there is a bug within debug mode.
    When using `asyncio.run,` only the `boolean` debug parameter will work. Command-line
    arguments and environment variables will only work when manually managing the
    event loop.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在Python 3.9之前的版本中，调试模式下存在一个错误。当使用`asyncio.run`时，只有`boolean`调试参数将工作。命令行参数和环境变量只有在手动管理事件循环时才会工作。
- en: In debug mode, we’ll see informative messages logged when a coroutine takes
    too long. Let’s test this out by trying to run CPU-bound code in a task to see
    if we get a warning, as shown in the following listing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试模式下，当协程运行时间过长时，我们会看到记录的具有信息性的消息。让我们通过尝试在任务中运行CPU密集型代码来测试这一点，看看是否会收到警告，如下列所示。
- en: Listing 2.23 Running CPU-bound code in debug mode
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.23在调试模式下运行CPU密集型代码
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When running this, we’ll see a helpful message that `task_one` was taking too
    long, therefore blocking the event loop from running any other tasks:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此操作时，我们会看到一个有用的消息，表明`task_one`花费了太多时间，因此阻止了事件循环运行任何其他任务：
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This can be helpful for debugging issues where we may inadvertently be making
    a call that is blocking. The default settings will log a warning if a coroutine
    takes longer than 100 milliseconds, but this may be longer or shorter than we’d
    like. To change this value, we can set the slow callback duration by accessing
    the event loop as we do in listing 2.24 and setting `slow_callback_duration`.
    This is a floating-point value representing the seconds we want the slow callback
    duration to be.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于调试可能无意中进行的阻塞调用的问题很有帮助。默认设置会在协程运行时间超过100毫秒时记录一个警告，但这可能比我们希望的更长或更短。要更改此值，我们可以通过像列表2.24中那样访问事件循环并设置`slow_callback_duration`来设置慢速回调持续时间。这是一个表示我们希望慢速回调持续时间秒数的浮点值。
- en: Listing 2.24 Changing the slow callback duration
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.24更改慢速回调持续时间
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding listing will set the slow callback duration to 250 milliseconds,
    meaning we’ll get a message printed out if any coroutine takes longer than 250
    milliseconds of CPU time to run.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表将慢速回调持续时间设置为250毫秒，这意味着如果任何协程运行时间超过250毫秒的CPU时间，我们将得到一条打印出来的消息。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve learned how to create coroutines with the `async` keyword. Coroutines
    can suspend their execution on a blocking operation. This allows for other coroutines
    to run. Once the operation where the coroutine suspended completes, our coroutine
    will wake up and resume where it left off.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用`async`关键字创建协程。协程可以在阻塞操作上挂起其执行。这允许其他协程运行。一旦协程挂起的操作完成，我们的协程将醒来并从上次离开的地方继续执行。
- en: We learned to use `await` in front of a call to a coroutine to run it and wait
    for it to return a value. To do so, the coroutine with the `await` inside it will
    suspend its execution, while waiting for a result. This allows other coroutines
    to run while the first coroutine is awaiting its result.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学会了在协程调用前使用`await`来运行它并等待它返回一个值。为此，包含`await`的协程将挂起其执行，等待结果。这允许其他协程在第一个协程等待其结果时运行。
- en: We’ve learned how to use `asyncio.run` to execute a single coroutine. We can
    use this function to run the coroutine that is the main entry point into our application.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用`asyncio.run`来执行单个协程。我们可以使用此函数来运行作为我们应用程序主要入口点的协程。
- en: We’ve learned how to use tasks to run multiple long-running operations concurrently.
    Tasks are wrappers around coroutines that will then be run on the event loop.
    When we create a task, it is scheduled to run on the event loop as soon as possible.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用任务来并发运行多个长时间运行的操作。任务是对协程的封装，将在事件循环上运行。当我们创建一个任务时，它将被安排在尽可能早的时间在事件循环上运行。
- en: We’ve learned how to cancel tasks if we want to stop them and how to add a timeout
    to a task to prevent them from taking forever. Canceling a task will make it raise
    a `CancelledError` while we await it. If we have time limits on how long a task
    should take, we can set timeouts on it by using `asycio.wait_for`.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学会了如何取消任务以停止它们，以及如何为任务添加超时以防止它们无限期地运行。取消任务将在我们等待它时引发`CancelledError`。如果我们对任务应该运行多长时间有限制，我们可以通过使用`asycio.wait_for`来设置超时。
- en: We’ve learned to avoid common issues that newcomers make when using asyncio.
    The first is running CPU-bound code in coroutines. CPU-bound code will block the
    event loop from running other coroutines since we’re still single-threaded. The
    second is blocking I/O, since we can’t use normal libraries with asyncio, and
    you must use asyncio-specific ones that return coroutines. If your coroutine does
    not have an `await` in it, you should consider it suspicious. There are still
    ways to use CPU-bound and blocking I/O with asyncio, which we will address in
    chapters 6 and 7.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学会了避免在使用 asyncio 时新手常犯的常见问题。第一个问题是将 CPU 密集型代码运行在协程中。由于我们仍然是单线程的，CPU 密集型代码会阻塞事件循环运行其他协程。第二个问题是阻塞
    I/O，因为我们不能使用常规库与 asyncio 一起使用，你必须使用返回协程的 asyncio 特定库。如果你的协程中没有 `await`，你应该考虑它是可疑的。尽管如此，我们仍然有方法在使用
    asyncio 时使用 CPU 密集型和阻塞 I/O，这些方法将在第 6 章和第 7 章中讨论。
- en: We’ve learned how to use debug mode. Debug mode can help us diagnose common
    issues in asyncio code, such as running CPU-intensive code in a coroutine.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用调试模式。调试模式可以帮助我们诊断 asyncio 代码中的常见问题，例如在协程中运行 CPU 密集型代码。
