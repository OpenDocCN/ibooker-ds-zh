- en: Part 1\. Warming up
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分\. 热身
- en: This part of the book will set the stage for your JavaScript ninja training.
    In [chapter 1](kindle_split_011.html#ch01), we’ll look at the current state of
    JavaScript and explore some of the environments in which JavaScript code can be
    executed. We’ll put a special focus on the environment where it all began—*the
    browser*—and we’ll discuss some of the best practices when developing JavaScript
    applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的这一部分将为您的JavaScript忍者训练做好准备。在[第一章](kindle_split_011.html#ch01)中，我们将探讨JavaScript的现状，并探索JavaScript代码可以执行的一些环境。我们将特别关注一切开始的地方——*浏览器*——并讨论开发JavaScript应用程序的一些最佳实践。
- en: Because our exploration of JavaScript will be done in the context of browsers,
    in [chapter 2](kindle_split_012.html#ch02) we’ll teach you about the lifecycle
    of client-side web applications and how executing JavaScript code fits into this
    lifecycle.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的JavaScript探索将在浏览器环境中进行，在[第二章](kindle_split_012.html#ch02)中，我们将向您介绍客户端Web应用程序的生命周期以及执行JavaScript代码如何融入这个生命周期。
- en: When you’re finished with this part of the book, you’ll be ready to embark on
    your training as a JavaScript ninja!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成这本书的这一部分后，你将准备好开始你的JavaScript忍者训练！
- en: Chapter 1\. JavaScript is everywhere
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一章\. JavaScript无处不在
- en: '*This chapter covers*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: The core language features of JavaScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript的核心语言特性
- en: The core items of a JavaScript engine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript引擎的核心项目
- en: Three best practices in JavaScript development
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript开发中的三个最佳实践
- en: Let’s talk about Bob. After spending a few years learning how to create desktop
    applications in C++, he graduated as a software developer in the early 2000s and
    then went out into the wide world. At that point, the web had just hit its stride,
    and everybody wanted to be the next Amazon. So the first thing he did was learn
    web development.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈鲍勃。在花了几年的时间学习如何用C++创建桌面应用程序后，他在2000年代初以软件工程师的身份毕业，然后进入了广阔的世界。那时，网络刚刚步入正轨，每个人都想成为下一个亚马逊。所以他做的第一件事就是学习Web开发。
- en: He learned some PHP so that he could dynamically generate web pages, which he
    usually sprinkled with JavaScript in order to achieve complex functionality such
    as form validation and even dynamic on-page clocks! Fast-forward a couple of years,
    and smartphones had become a thing, so anticipating a large new market opening
    up, Bob went ahead and learned Objective-C and Java to develop mobile apps that
    run on iOS and Android.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 他学习了一些PHP，以便能够动态生成网页，他通常会在网页上添加JavaScript以实现复杂的功能，如表单验证甚至动态页面时钟！快进几年，智能手机已经成为一种潮流，因此预见一个巨大的新市场即将开放，鲍勃提前学习了Objective-C和Java来开发在iOS和Android上运行的移动应用。
- en: Over the years, Bob has created many successful applications that all have to
    be maintained and extended. Unfortunately, jumping daily between all these different
    programming languages and application frameworks has really started to wear down
    poor Bob.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些年来，鲍勃创建了许多成功的应用程序，所有这些都需要维护和扩展。不幸的是，每天在所有这些不同的编程语言和应用框架之间跳转，真的开始让可怜的鲍勃感到疲惫。
- en: Now let’s talk about Ann. Two years ago, Ann graduated with a degree in software
    development, specializing in web- and cloud-based applications. She has created
    a few medium-sized web applications based on modern Model–view–controller (MVC)
    frameworks, along with accompanying mobile applications that run on iOS and Android.
    She has created a desktop application that runs on Linux, Windows, and OS X, and
    has even started building a serverless version of that application entirely based
    in the cloud. And *everything she has done has been written in JavaScript*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈安。两年前，安以软件开发学位毕业，专攻基于Web和云的应用程序。她基于现代模型-视图-控制器（MVC）框架创建了一些中型Web应用程序，以及相应的在iOS和Android上运行的移动应用程序。她创建了一个在Linux、Windows和OS
    X上运行的桌面应用程序，甚至还开始构建一个完全基于云的无服务器版本的应用程序。而且*她所做的一切都是用JavaScript编写的*。
- en: That’s extraordinary! What took Bob 10 years and 5 languages to do, Ann has
    achieved in 2 years and in *just one language*. Throughout the history of computing,
    it has been rare for a particular knowledge set to be so easily transferable and
    useful across so many different domains.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那太棒了！鲍勃用10年和5种语言才做到的事情，安在2年内只用一种语言就实现了。在计算机历史的整个过程中，某个特定的知识集能够在如此多的不同领域轻松转移和有用是罕见的。
- en: What started as a humble 10-day project back in 1995 is now one of the most
    widely used programming languages in the world. JavaScript is quite literally
    *everywhere*, thanks to more-powerful JavaScript engines and the introduction
    of frameworks such as Node, Apache Cordova, Ionic, and Electron, which have taken
    the language beyond the humble web page. And, like HTML, the language itself is
    now getting long overdue upgrades intended to make JavaScript even more suitable
    for modern application development.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 1995 年开始的一个简短的 10 天项目，现在已经成为世界上最广泛使用的编程语言之一。JavaScript 实际上 *无处不在*，这得益于更强大的 JavaScript
    引擎以及 Node、Apache Cordova、Ionic 和 Electron 等框架的引入，这些框架将语言的应用范围扩展到了简单的网页之外。而且，就像
    HTML 一样，这门语言本身现在也正在进行长期期待已久的升级，旨在使 JavaScript 更适合现代应用程序开发。
- en: In this book, we’re going to make sure you know all you need to know about JavaScript
    so that, whether you’re like Ann or like Bob, you can develop all sorts of applications
    on a green field or a brown field.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将确保你了解所有关于 JavaScript 的知识，无论你是像 Ann 还是像 Bob，你都可以在绿色或棕色土地上开发各种应用程序。
- en: Do you know?
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: '**Q1:**'
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q1:**'
- en: ''
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are Babel and Traceur, and why are they important to today’s JavaScript
    developers?
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Babel 和 Traceur 是什么，为什么它们对今天的 JavaScript 开发者来说很重要？
- en: '**Q2:**'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q2:**'
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the core parts of any web browser’s JavaScript API used by web applications?
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 任何网络浏览器中用于网络应用程序的 JavaScript API 的核心部分是什么？
- en: 1.1\. Understanding the JavaScript language
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1. 理解 JavaScript 语言
- en: As they advance through their careers, many JavaScript coders like Bob and Ann
    reach the point where they’re actively using the vast number of elements that
    form the language. In many cases, however, those skills may not be taken beyond
    fundamental levels. Our guess is that this is often because JavaScript, using
    a C-like syntax, bears a surface resemblance to other widespread C-like languages
    (such as C# and Java), and thus leaves the impression of familiarity.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 随着他们职业生涯的推进，许多像 Bob 和 Ann 这样的 JavaScript 开发者会达到一个积极使用构成语言的大量元素的阶段。然而，在许多情况下，这些技能可能并没有被提升到基本水平以上。我们的猜测是，这通常是因为
    JavaScript 使用类似于 C 的语法，与广泛使用的类似 C 语言（如 C# 和 Java）在外观上有一定的相似性，因此给人留下了熟悉的感觉。
- en: People often feel that if they know C# or Java, they already have a pretty solid
    understanding of how JavaScript works. But it’s a trap! When compared to other
    mainstream languages, JavaScript is much more *functionally* oriented. Some JavaScript
    concepts differ fundamentally from those of most other languages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常常觉得，如果他们了解 C# 或 Java，他们已经对 JavaScript 的工作原理有了相当牢固的理解。但这是一个陷阱！与其他主流语言相比，JavaScript
    要更加 *函数式*。一些 JavaScript 概念与大多数其他语言的基本概念有根本性的区别。
- en: 'These differences include the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些差异包括以下内容：
- en: '***Functions are first-class objects—*** In JavaScript, functions coexist with,
    and can be treated like, any other JavaScript object. They can be created through
    literals, referenced by variables, passed around as function arguments, and even
    returned as function return values. We devote much of [chapter 3](kindle_split_014.html#ch03)
    to exploring some of the wonderful benefits that functions as first-class objects
    bring to our JavaScript code.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***函数是一等公民——*** 在 JavaScript 中，函数与其他 JavaScript 对象共存，并且可以像其他 JavaScript 对象一样被对待。它们可以通过字面量创建，通过变量引用，作为函数参数传递，甚至作为函数返回值返回。我们在第
    3 章 [chapter 3](kindle_split_014.html#ch03) 中投入了大量篇幅来探讨函数作为一等公民为我们的 JavaScript
    代码带来的许多美妙好处。'
- en: '***Function closures—*** The concept of function closures is generally poorly
    understood, but at the same time it fundamentally and irrevocably exemplifies
    the importance of functions to JavaScript. For now, it’s enough to know that a
    function is *a closure when it actively maintains (“closes over”) the external
    variables used in its body*. Don’t worry for now if you don’t see the many benefits
    of closures; we’ll make sure all is crystal clear in [chapter 5](kindle_split_016.html#ch05).
    In addition to closures, we’ll thoroughly explore the many aspects of functions
    themselves in [chapters 3](kindle_split_014.html#ch03) and [4](kindle_split_015.html#ch04),
    as well as identifier scopes in [chapter 5](kindle_split_016.html#ch05).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***函数闭包——*** 函数闭包的概念通常理解得不好，但与此同时，它从根本上和不可逆转地证明了函数对 JavaScript 的重要性。目前，只需知道函数是
    *当它积极维护（“封闭”）其主体中使用的外部变量时，就是一个闭包*。现在如果你没有看到闭包的许多好处，请不要担心；我们将在第 5 章 [chapter 5](kindle_split_016.html#ch05)
    中确保一切都很清晰。除了闭包之外，我们还将彻底探讨第 3 章 [chapters 3](kindle_split_014.html#ch03) 和第 4 章
    [chapters 4](kindle_split_015.html#ch04) 中函数本身的许多方面，以及第 5 章 [chapters 5](kindle_split_016.html#ch05)
    中的标识符作用域。'
- en: '***Scopes—*** Until recently, JavaScript didn’t have block-level variables
    (as in other C-like languages); instead, we had to rely only on global variables
    and function-level variables.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作用域——** 直到最近，JavaScript没有块级变量（如其他C语言类似的语言）；相反，我们只能依赖全局变量和函数级变量。'
- en: '***Prototype-based object orientation—*** Unlike other mainstream programming
    languages (such as C#, Java, and Ruby), which use class-based object orientation,
    JavaScript uses prototypes. Often, when developers come to JavaScript from class-based
    languages (such as Java), they try to use JavaScript as if it were Java, essentially
    writing Java’s class-based code using the syntax of JavaScript. Then, for some
    reason, they’re surprised when the results differ from what they expect. This
    is why we’ll go deep into prototypes, how prototype-based object-orientation works,
    and how it’s implemented in JavaScript.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于原型的面向对象——** 与其他主流编程语言（如C#、Java和Ruby）使用基于类的面向对象不同，JavaScript使用原型。通常，当开发者从基于类的语言（如Java）转向JavaScript时，他们试图将JavaScript当作Java来使用，本质上是用JavaScript的语法编写Java的基于类的代码。然后，由于某种原因，当结果与预期不符时，他们会感到惊讶。这就是为什么我们将深入探讨原型，了解基于原型的面向对象是如何工作的，以及它在JavaScript中的实现方式。'
- en: JavaScript consists of a close relationship between objects and prototypes,
    and functions and closures. Understanding the strong relationships between these
    concepts can vastly improve your JavaScript programming ability, giving you a
    strong foundation for any type of application development, regardless of whether
    your JavaScript code will be executed in a web page, in a desktop app, in a mobile
    app, or on the server.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript由对象和原型、函数和闭包之间的紧密关系组成。理解这些概念之间的强大关系可以极大地提高你的JavaScript编程能力，为你提供任何类型的应用程序开发的基础，无论你的JavaScript代码将在网页、桌面应用程序、移动应用程序还是服务器上执行。
- en: 'In addition to these fundamental concepts, other JavaScript features can help
    you write more elegant and more efficient code. Some of these are features that
    seasoned developers like Bob will recognize from other languages, such as Java
    and C++. In particular, we focus on the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些基本概念之外，其他JavaScript特性可以帮助你编写更优雅、更高效的代码。其中一些是经验丰富的开发者如Bob从其他语言（如Java和C++）中认识到的特性。特别是，我们关注以下内容：
- en: '*Generators*, which are functions that can generate multiple values on a per-request
    basis and can suspend their execution between requests'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成器*，它们是可以在每次请求的基础上生成多个值并可以在请求之间暂停执行的函数'
- en: '*Promises*, which give us better control over asynchronous code'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*承诺*，它让我们更好地控制异步代码'
- en: '*Proxies,* which allow us to control access to certain objects'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代理*，它允许我们控制对某些对象的访问'
- en: '*Advanced array methods,* which make array-handling code much more elegant'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高级数组方法*，使数组处理代码更加优雅'
- en: '*Maps*, which we can use to create dictionary collections; and *sets*, which
    allow us to deal with collections of unique items'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*映射*，我们可以用它来创建字典集合；以及*集合*，它允许我们处理唯一项的集合'
- en: '*Regular expressions,* which let us simplify what would otherwise be complicated
    pieces of code'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正则表达式*，它让我们可以简化原本可能很复杂的代码片段'
- en: '*Modules*, which we can use to break code into smaller, relatively self-contained
    pieces that make projects more manageable'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模块*，我们可以用它将代码分解成更小、相对自包含的部分，使项目更易于管理'
- en: Having a deep understanding of the fundamentals and learning how to use advanced
    language features to their best advantage can elevate your code to higher levels.
    Honing your skills to tie these concepts and features together will give you a
    level of understanding that puts the creation of any type of JavaScript application
    within your reach.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 深入理解基础知识并学习如何使用高级语言特性以最佳方式提升你的代码水平。将这些概念和特性结合起来，将使你达到一个层次，使创建任何类型的JavaScript应用程序成为可能。
- en: 1.1.1\. How will JavaScript evolve?
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1. JavaScript将如何演变？
- en: The ECMAScript committee, in charge of standardizing the language, has just
    finished the ES7/ES2016 version of JavaScript. The ES7 version is a relatively
    small upgrade to JavaScript (at least, when compared to ES6), because the committee’s
    goal going forward is to focus on smaller, yearly incremental changes to the language.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 负责标准化语言的ECMAScript委员会刚刚完成了JavaScript的ES7/ES2016版本。ES7版本是对JavaScript的相对较小的升级（至少与ES6相比），因为委员会未来的目标是专注于语言的小型、年度增量变化。
- en: In this book we thoroughly explore ES6 but also focus on ES7 features, such
    as the new async function, which will help you deal with asynchronous code (discussed
    in [chapter 6](kindle_split_017.html#ch06)).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们全面探讨了ES6，同时也关注ES7的新特性，例如新的异步函数，这将帮助你处理异步代码（在第6章中讨论）。
- en: '|  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '![](006fig01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](006fig01.jpg)'
- en: When we cover features of JavaScript defined in ES6/ES2015 or ES7/ES2016, you’ll
    see these icons alongside a link to information about whether they’re supported
    by your browser.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们介绍ES6/ES2015或ES7/ES2016中定义的JavaScript特性时，你会在链接旁边看到这些图标，以了解它们是否被你的浏览器支持。
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Yearly incremental updates to the language specification are excellent news,
    but this doesn’t mean that web developers will instantly have access to the new
    features after the specification has been released. JavaScript code has to be
    executed by a Java-Script engine, so we’re often left waiting impatiently for
    updates to our favorite JavaScript engines that incorporate these new and exciting
    features.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 语言规范的年度增量更新是好消息，但这并不意味着在规范发布后，Web开发者会立即获得新特性的访问权限。JavaScript代码必须由JavaScript引擎执行，所以我们经常不得不焦急地等待我们最喜欢的JavaScript引擎更新，以包含这些新而令人兴奋的特性。
- en: Unfortunately, although the JavaScript engine developers are trying to keep
    up and are doing better all the time, there’s always a chance that you’ll run
    into features that you are dying to use but that are yet to be supported.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，尽管JavaScript引擎开发者正在努力跟上，并且一直在做得更好，但总有可能遇到你迫切想要使用但尚未得到支持的特性。
- en: Luckily, you can keep up with the state of feature support in the various browsers
    via the lists at [https://kangax.github.io/compat-table/es6/](https://kangax.github.io/compat-table/es6/),
    [http://kangax.github.io/compat-table/es2016plus/](http://kangax.github.io/compat-table/es2016plus/),
    and [https://kangax.github.io/compat-table/esnext/](https://kangax.github.io/compat-table/esnext/).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以通过 [https://kangax.github.io/compat-table/es6/](https://kangax.github.io/compat-table/es6/)、[http://kangax.github.io/compat-table/es2016plus/](http://kangax.github.io/compat-table/es2016plus/)
    和 [https://kangax.github.io/compat-table/esnext/](https://kangax.github.io/compat-table/esnext/)
    上的列表来跟踪各种浏览器中特性支持的状态。
- en: 1.1.2\. Transpilers give us access to tomorrow’s JavaScript today
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2\. 转译器让我们今天就能使用明天的JavaScript
- en: 'Because of the rapid release cycles of browsers, we usually don’t have to wait
    long for a JavaScript feature to be supported. But what happens if we want to
    take advantage of all the benefits of the newest JavaScript features but are taken
    hostage by a harsh reality: The users of our web applications may still be using
    older browsers?'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器快速发布周期，我们通常不需要等待很长时间就能看到JavaScript特性的支持。但如果我们想利用最新JavaScript特性的所有好处，却受到残酷现实的束缚：我们的Web应用的用户可能仍在使用较旧的浏览器？
- en: One answer to this problem is to use *transpilers* (“transformation + compiling”),
    tools that take cutting-edge JavaScript code and transform it into equivalent
    (or, if that’s not possible, similar) code that works properly in most current
    browsers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是使用 *转译器*（“转换+编译”），这些工具可以将前沿的JavaScript代码转换成在大多数当前浏览器中正确运行的等效（或，如果不可能，相似）代码。
- en: Today’s most popular transpilers are Traceur ([https://github.com/google/traceur-compiler](https://github.com/google/traceur-compiler))
    and Babel ([https://babeljs.io/](https://babeljs.io/)). Setting them up is easy;
    just follow one of the tutorials, such as [https://github.com/google/traceur-compiler/wiki/Getting-Started](https://github.com/google/traceur-compiler/wiki/Getting-Started)
    or [http://babeljs.io/docs/setup/](http://babeljs.io/docs/setup/).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 今天最受欢迎的转译器是Traceur ([https://github.com/google/traceur-compiler](https://github.com/google/traceur-compiler))
    和Babel ([https://babeljs.io/](https://babeljs.io/))。设置它们非常简单；只需遵循其中一个教程，例如 [https://github.com/google/traceur-compiler/wiki/Getting-Started](https://github.com/google/traceur-compiler/wiki/Getting-Started)
    或 [http://babeljs.io/docs/setup/](http://babeljs.io/docs/setup/)。
- en: In this book, we put a special focus on running JavaScript code in the browser.
    To effectively use the browser platform, you have to get your hands dirty and
    study the inner workings of browsers. Let’s get started!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们特别关注在浏览器中运行JavaScript代码。为了有效地使用浏览器平台，你必须亲自动手研究浏览器的内部工作原理。让我们开始吧！
- en: 1.2\. Understanding the browser
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2\. 理解浏览器
- en: These days, JavaScript applications can be executed in many environments. But
    the environment from which it all began, the environment from which all other
    environments have taken ideas, and the environment on which we’ll focus, is the
    *browser*. The browser provides various concepts and APIs to thoroughly explore;
    see [figure 1.1](#ch01fig01).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，JavaScript 应用程序可以在许多环境中执行。但所有这一切开始的环境，所有其他环境从中汲取灵感的来源，以及我们将要关注的环境，是 *浏览器*。浏览器提供了各种概念和
    API 以供彻底探索；参见 [图 1.1](#ch01fig01)。
- en: Figure 1.1\. Client-side web applications rely on the infrastructure provided
    by the browser. We’ll particularly focus on the DOM, events, timers, and browser
    APIs.
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.1\. 客户端 Web 应用程序依赖于浏览器提供的架构。我们将特别关注 DOM、事件、计时器和浏览器 API。
- en: '![](01fig01_alt.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig01_alt.jpg)'
- en: 'We’ll concentrate on the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点关注以下内容：
- en: '***The Document Object Model (DOM)—*** The DOM is a structured representation
    of the UI of a client-side web application that is, at least initially, built
    from the HTML code of a web application. To develop great applications, you need
    to not only have a deep understanding of the core JavaScript mechanics, but also
    study how the DOM is constructed ([chapter 2](kindle_split_012.html#ch02)) and
    how to write effective code that manipulates the DOM ([chapter 12](kindle_split_025.html#ch12)).
    This will put the creation of advanced, highly dynamic UIs at your fingertips.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***文档对象模型 (DOM) —*** DOM 是客户端 Web 应用程序 UI 的结构化表示，至少最初是由 Web 应用的 HTML 代码构建的。要开发出色的应用程序，你不仅需要深入理解核心
    JavaScript 机制，还需要研究 DOM 的构建方式 ([第 2 章](kindle_split_012.html#ch02)) 以及如何编写有效代码来操作
    DOM ([第 12 章](kindle_split_025.html#ch12))。这将使你能够轻松创建高级、高度动态的 UI。'
- en: '***Events—*** A huge majority of JavaScript applications are *event-driven*
    applications, meaning that most of the code is executed in the context of a response
    to a particular event. Examples of events include network events, timers, and
    user-generated events such as clicks, mouse moves, keyboard presses, and so on.
    For this reason, we’ll thoroughly explore the mechanisms behind events in [chapter
    13](kindle_split_026.html#ch13). We’ll pay special attention to *timers*, which
    are frequently a mystery but let us tackle complex coding tasks such as long-running
    computations and smooth animations.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***事件 —*** 大多数 JavaScript 应用程序都是 *事件驱动* 应用程序，这意味着大部分代码都是在响应特定事件的上下文中执行的。事件示例包括网络事件、计时器和用户生成的事件，如点击、鼠标移动、键盘按键等。因此，我们将彻底探讨第
    13 章 [chapter 13](kindle_split_026.html#ch13) 中事件背后的机制。我们将特别关注 *计时器*，它们通常是谜团，但让我们处理复杂编码任务，如长时间计算和流畅动画。'
- en: '***Browser API—*** To help us interact with the world, the browser offers an
    API that allows us to access information about devices, store data locally, or
    communicate with remote servers. We’ll explore some of these APIs throughout the
    book.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***浏览器 API —*** 为了帮助我们与世界互动，浏览器提供了一个 API，允许我们访问有关设备的信息、本地存储数据或与远程服务器通信。本书中我们将探讨一些这些
    API。'
- en: Perfecting your JavaScript programming skills and achieving deep understanding
    of APIs offered by the browser will take you far. But sooner, rather than later,
    you’ll run face first into *the browsers* and their various issues and inconsistencies.
    In a perfect world, all browsers would be bug-free and would support web standards
    in a consistent fashion; unfortunately, we don’t live in that world.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 精通 JavaScript 编程技能并深入理解浏览器提供的 API 将带你走得很远。但 sooner, rather than later, you’ll
    run face first into *the browsers* and their various issues and inconsistencies.
    在一个完美的世界里，所有浏览器都不会有错误，并且会以一致的方式支持 Web 标准；不幸的是，我们并不生活在这个世界里。
- en: The quality of browsers has improved greatly as of late, but they all still
    have some bugs, missing APIs, and browser-specific quirks that we need to deal
    with. Developing a comprehensive strategy for tackling these browser issues, and
    becoming intimately familiar with their differences and quirks, can be almost
    as important as proficiency in JavaScript itself.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器的质量最近有了很大的提升，但它们仍然存在一些错误、缺失的API和浏览器特有的怪癖，我们需要处理这些问题。制定一个全面策略来解决这些浏览器问题，并深入了解它们之间的差异和怪癖，这几乎和掌握JavaScript本身一样重要。
- en: When we’re writing browser applications or JavaScript libraries to be used in
    them, choosing which browsers to support is an important consideration. We’d like
    to support them all, but limitations on development and testing resources dictate
    otherwise. For this reason, we’ll thoroughly explore strategies for cross-browser
    development in [chapter 14](kindle_split_027.html#ch14).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写浏览器应用或用于其中的JavaScript库时，选择支持哪些浏览器是一个重要的考虑因素。我们希望支持所有浏览器，但开发和测试资源的限制决定了否则。因此，我们将彻底探讨第14章中跨浏览器开发的策略。[第14章](kindle_split_027.html#ch14)。
- en: Developing effective, cross-browser code can depend significantly on the skill
    and experience of the developers. This book is intended to boost that skill level,
    so let’s get to it by looking at current best practices.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 开发有效的、跨浏览器的代码在很大程度上取决于开发者的技能和经验。本书旨在提高这一技能水平，因此让我们通过查看当前的最佳实践来着手进行。
- en: 1.3\. Using current best practices
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3\. 使用当前最佳实践
- en: Mastery of the JavaScript language and a grasp of cross-browser coding issues
    are important parts of becoming an expert web application developer, but they’re
    not the complete picture. To enter the big leagues, you also need to exhibit the
    traits that scores of previous developers have proven are beneficial to the development
    of quality code. These traits are known as *best practices*, and in addition to
    mastery of the language, they include such elements as
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握JavaScript语言和了解跨浏览器编码问题，是成为一名专家Web应用开发者的重要部分，但它们并不是全部。要进入高级别，你还需要展现出许多前开发者证明对编写高质量代码有益的特质。这些特质被称为*最佳实践*，除了语言掌握之外，还包括如下元素：
- en: Debugging skills
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试技能
- en: Testing
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试
- en: Performance analysis
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析
- en: It’s vitally important to adhere to these practices when coding, and we’ll use
    them throughout the book. Let’s examine some of them next.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码时坚持这些实践至关重要，我们将在整本书中使用它们。接下来，让我们考察其中的一些。
- en: 1.3.1\. Debugging
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.1\. 调试
- en: 'Debugging JavaScript used to mean using `alert` to verify the value of variables.
    Fortunately, the ability to debug JavaScript code has dramatically improved, in
    no small part because of the popularity of the Firebug developer extension for
    Firefox. Similar tools have been developed for all major browsers:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 调试JavaScript过去意味着使用`alert`来验证变量的值。幸运的是，调试JavaScript代码的能力已经大幅提高，这在很大程度上得益于Firefox的Firebug开发者扩展的流行。为所有主要浏览器都开发了类似的工具：
- en: '***Firebug—*** The popular developer extension for Firefox that got the ball
    rolling ([http://getfirebug.com/](http://getfirebug.com/))'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Firebug—*** Firefox中流行的开发者扩展，它推动了这一进程([http://getfirebug.com/](http://getfirebug.com/))'
- en: '***Chrome DevTools—*** Developed by the Chrome team and used in Chrome and
    Opera'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Chrome DevTools—*** Chrome团队开发，用于Chrome和Opera'
- en: '***Firefox Developer Tools—*** A tool included in Firefox, built by the Firefox
    team'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Firefox开发者工具—*** Firefox团队开发的一个工具'
- en: '***F12 Developer Tools—*** Included in Internet Explorer and Microsoft Edge'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***F12开发者工具—*** 包含在Internet Explorer和Microsoft Edge中'
- en: '***WebKit Inspector—*** Used by Safari'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***WebKit Inspector—*** Safari使用的工具'
- en: As you can see, every major browser offers developer tools that we can use to
    debug our web applications. The days of using JavaScript alerts for debugging
    are long gone!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，每个主要浏览器都提供了我们可以用来调试我们的Web应用的开发者工具。使用JavaScript弹窗进行调试的日子已经一去不复返了！
- en: 'All of these tools are based on similar ideas, which were mostly introduced
    by Firebug, so they offer similar functionality: exploring the DOM, debugging
    JavaScript, editing CSS styles, tracking network events, and so on. Any of them
    will do a fine job; use the one offered by your browser of choice, or in the browser
    in which you’re investigating bugs.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些工具都基于类似的思想，这些思想大多由Firebug引入，因此它们提供了类似的功能：探索DOM、调试JavaScript、编辑CSS样式、跟踪网络事件等。任何一种都能很好地完成任务；使用您浏览器提供的工具，或者在使用中调查bug的浏览器中。
- en: In addition, you can use some of them, such as Chrome Dev Tools, to debug other
    kinds of applications, like Node.js apps. (We’ll introduce you to some debugging
    techniques in [appendix B](kindle_split_029.html#app02).)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以使用其中的一些，例如Chrome Dev Tools，来调试其他类型的应用程序，如Node.js应用。（我们将在附录B中介绍一些调试技术。[附录B](kindle_split_029.html#app02)）
- en: 1.3.2\. Testing
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.2\. 测试
- en: Throughout this book, we’ll apply testing techniques to ensure that the example
    code operates as intended and to serve as examples of how to test code in general.
    The primary tool we’ll use for testing is an `assert` function, whose purpose
    is to assert that a premise is either true or false. By specifying assertions,
    we can check whether the code is behaving as expected.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将应用测试技术来确保示例代码按预期运行，并作为如何测试代码的一般示例。我们将使用的主要测试工具是一个 `assert` 函数，其目的是断言一个前提是正确还是错误。通过指定断言，我们可以检查代码是否按预期运行。
- en: 'The general form of this function is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数的一般形式如下：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first parameter is a condition that should be true, and the second is a
    message that will be displayed if it’s not.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个应该为真的条件，第二个参数是在它不为真时将显示的消息。
- en: 'Consider this, for example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下内容：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If the value of variable `a` isn’t equal to `1`, the assertion fails, and the
    somewhat overly dramatic message is displayed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量 `a` 的值不等于 `1`，则断言失败，并显示一个有些过于夸张的消息。
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `assert` function isn’t a standard feature of the language, so we’ll implement
    it ourselves in [appendix B](kindle_split_029.html#app02).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert` 函数不是语言的标准功能，因此我们将自己在 [附录 B](kindle_split_029.html#app02) 中实现它。'
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 1.3.3\. Performance analysis
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.3. 性能分析
- en: Another important practice is performance analysis. The JavaScript engines have
    made astounding strides in the performance of JavaScript, but that’s no excuse
    for writing sloppy and inefficient code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的实践是性能分析。JavaScript 引擎在 JavaScript 性能方面取得了惊人的进步，但这并不是编写马虎和低效代码的借口。
- en: 'We’ll use code such as the following later in this book to collect performance
    information:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书后面使用如下代码来收集性能信息：
- en: '![](010fig01_alt.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](010fig01_alt.jpg)'
- en: Here, we bracket the execution of the code to be measured with two calls to
    the `time` and `timeEnd` methods of the built-in `console` object.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用内置的 `console` 对象的 `time` 和 `timeEnd` 方法的两次调用将待测代码的执行括起来。
- en: Before the operation begins executing, the call to `console.time` starts a timer
    with a name (in this case, `My operation`). Then we run the code in the `for`
    loop a certain number of times (in this case, `maxCount` times). Because a single
    operation of the code happens much too quickly to measure reliably, we need to
    perform the code many times to get a measurable value. Frequently, this count
    can be in the tens of thousands, or even millions, depending on the nature of
    the code being measured. A little trial and error lets us choose a reasonable
    value.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作开始执行之前，对 `console.time` 的调用以一个名称（在这种情况下，`My operation`）启动计时器。然后我们运行 `for`
    循环中的代码一定次数（在这种情况下，`maxCount` 次）。由于代码的单个操作发生得太快而无法可靠地测量，我们需要多次执行代码以获得可测量的值。通常，这个计数可以是成千上万，甚至数百万，这取决于被测量的代码的性质。一点尝试和错误让我们选择一个合理的值。
- en: When the operation ends, we call the `console.timeEnd` method with the same
    name. This causes the browser to output the time that elapsed since the timer
    was started.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作结束时，我们使用相同名称的 `console.timeEnd` 方法。这会导致浏览器输出自计时器开始以来经过的时间。
- en: These best-practice techniques, along with others you’ll learn along the way,
    will greatly enhance your JavaScript development. Developing applications with
    the restricted resources that a browser provides, coupled with the increasingly
    complex world of browser capability and compatibility, requires a robust and complete
    set of skills.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些最佳实践技术，以及你将在学习过程中了解的其他技术，将极大地提高你的 JavaScript 开发技能。使用浏览器提供的受限资源开发应用程序，结合浏览器功能和兼容性的日益复杂，需要一套强大而完整的技能。
- en: 1.4\. Boosting skill transferability
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4. 提高技能迁移性
- en: When Bob was first learning web development, each browser had its own way of
    interpreting script and UI styles, preaching that their way was the best way and
    making every developer grind their teeth in frustration. Fortunately, the browser
    wars ended with HTML, CSS, the DOM API, and JavaScript all being standardized,
    and developer focus turning toward effective cross-browser JavaScript applications.
    Indeed, this focus on treating websites as applications led to many ideas, tools,
    and techniques crossing over from desktop applications to web applications. And
    now, that knowledge and tools transfer has happened again as ideas, tools, and
    techniques that originated in client-side web development have also permeated
    other application domains.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当鲍勃刚开始学习网页开发时，每个浏览器都有自己解释脚本和UI样式的独特方式，宣扬自己的方法是最佳方法，这让每个开发者都感到沮丧。幸运的是，随着HTML、CSS、DOM
    API和JavaScript的标准化，浏览器大战终于结束，开发者的关注点转向了有效的跨浏览器JavaScript应用。确实，这种将网站视为应用的关注导致了众多想法、工具和技术从桌面应用跨越到Web应用。现在，这种知识和工具的迁移再次发生，因为起源于客户端Web开发的想法、工具和技术也已经渗透到其他应用领域。
- en: 'Achieving a deep understanding of fundamental JavaScript principles with the
    knowledge of core APIs can therefore make you a more versatile developer. By using
    the browsers and Node.js (an environment derived from the browser), you can develop
    almost any type of application imaginable:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过核心API的知识来深入理解基本的JavaScript原则可以使你成为一个更灵活的开发者。通过使用浏览器和Node.js（一个从浏览器衍生出来的环境），你可以开发几乎任何类型的应用程序：
- en: '*Desktop applications*, by using, for example, NW.js ([http://nwjs.io/](http://nwjs.io/))
    or Electron ([http://electron.atom.io/](http://electron.atom.io/)). These technologies
    usually wrap the browser so that we can build desktop UIs with standard HTML,
    CSS, and JavaScript (that way, we can rely on our core JavaScript and browser
    knowledge), with additional support that makes it possible to interact with the
    filesystem. We can build truly platform-independent desktop applications that
    have the same look and feel on Windows, Mac, and Linux.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*桌面应用程序*，例如使用NW.js ([http://nwjs.io/](http://nwjs.io/)) 或 Electron ([http://electron.atom.io/](http://electron.atom.io/))。这些技术通常封装浏览器，这样我们就可以使用标准的HTML、CSS和JavaScript（这样我们就可以依赖我们的核心JavaScript和浏览器知识）来构建桌面UI，并提供了额外的支持，使得我们可以与文件系统交互。我们可以构建真正平台独立的桌面应用程序，在Windows、Mac和Linux上具有相同的视觉和感觉。'
- en: '*Mobile apps with frameworks*, such as Apache Cordova ([https://cordova.apache.org/](https://cordova.apache.org/)).
    Similar to desktop apps built with web technologies, frameworks for mobile apps
    use a wrapped browser but with additional platform-specific APIs that let us interact
    with the mobile platform.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用框架的移动应用*，例如Apache Cordova ([https://cordova.apache.org/](https://cordova.apache.org/))。与使用Web技术构建的桌面应用类似，移动应用框架使用封装的浏览器，但增加了特定平台的API，使我们能够与移动平台交互。'
- en: '*Server-side applications and applications for embedded devices with Node.js*,
    an environment derived from the browser that uses many of the same underlying
    principles as the browser. For example, Node.js executes JavaScript code and relies
    on events.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Node.js的Server-side应用程序和嵌入式设备应用程序*，Node.js是一个从浏览器衍生出来的环境，它使用了许多与浏览器相同的底层原则。例如，Node.js执行JavaScript代码并依赖于事件。'
- en: Ann doesn’t know how lucky she is (although Bob has a pretty good idea). It
    doesn’t matter whether she needs to build a standard desktop application, a mobile
    application, a server-side application, or even an embedded application—all these
    types of applications share some of the same underlying principles of standard
    client-side web applications. By understanding how the core mechanics of JavaScript
    work, and by understanding the core APIs provided by browsers (such as events,
    which also have a lot in common with mechanisms provided by Node.js), she can
    boost her development skills across the board. As can you. In the process, you’ll
    become a more versatile developer and gain the knowledge and understanding to
    tackle a wide variety of problems. You’ll even be able to build your own serverless
    applications based in the cloud by using JavaScript APIs for services such as
    AWS Lambda to deploy, maintain, and control your application’s cloud components.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 安妮不知道她有多幸运（尽管鲍勃有一个相当好的想法）。无论她是否需要构建标准桌面应用程序、移动应用程序、服务器端应用程序，甚至嵌入式应用程序——所有这些类型的应用程序都共享一些标准客户端Web应用程序的相同的基本原则。通过理解JavaScript的核心机制如何工作，以及理解浏览器提供的核心API（例如事件，这些事件也与Node.js提供的机制有很多共同之处），她可以全面提升她的开发技能。你也是如此。在这个过程中，你将成为一个更全能的开发者，并获得解决各种问题的知识和理解。你甚至能够使用基于云的AWS
    Lambda等服务提供的JavaScript API来构建自己的无服务器应用程序，以部署、维护和控制应用程序的云组件。
- en: 1.5\. Summary
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5. 概述
- en: Client-side web applications are among the most popular today, and the concepts,
    tools, and techniques once used only for their development have permeated other
    application domains. Understanding the foundations of client-side web applications
    will help you develop applications for a wide variety of domains.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端Web应用程序是目前最受欢迎的，曾经仅用于其开发的理念、工具和技术已经渗透到其他应用领域。理解客户端Web应用程序的基础将帮助你在广泛的领域开发应用程序。
- en: To improve your development skills, you have to gain a deep understanding of
    the core mechanics of JavaScript, as well as the infrastructure provided by the
    browsers.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高你的开发技能，你必须深入理解JavaScript的核心机制以及浏览器提供的基础设施。
- en: This book focuses on core JavaScript mechanisms such as functions, function
    closures, and prototypes, as well as on new JavaScript features such as generators,
    promises, proxies, maps, sets, and modules.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书重点关注核心JavaScript机制，如函数、函数闭包和原型，以及新的JavaScript特性，如生成器、承诺、代理、映射、集合和模块。
- en: JavaScript can be executed in a large number of environments, but the environment
    where it all began, and the environment we’ll concentrate on, is the browser.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript可以在大量环境中执行，但所有这一切开始的地方，以及我们将集中关注的环境，是浏览器。
- en: In addition to JavaScript, we’ll explore browser internals such as the DOM (a
    structured representation of the web page UI) and events, because client-side
    web applications are event-driven applications.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了JavaScript之外，我们还将探索浏览器内部结构，如DOM（网页UI的结构化表示）和事件，因为客户端Web应用程序是事件驱动应用程序。
- en: 'We’ll do this exploration with best practices in mind: debugging, testing,
    and performance analysis.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将带着最佳实践进行这次探索：调试、测试和性能分析。
- en: Chapter 2\. Building the page at runtime
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章. 在运行时构建页面
- en: '*This chapter covers*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Steps in the lifecycle of a web application
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web应用程序生命周期中的步骤
- en: Processing HTML code to produce a web page
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理HTML代码以生成网页
- en: Order of executing JavaScript code
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行JavaScript代码的顺序
- en: Achieving interactivity with events
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过事件实现交互性
- en: The event loop
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环
- en: Our exploration of JavaScript is performed in the context of client-side web
    applications and the browser as the engine that executes JavaScript code. In order
    to have a strong base from which to continue exploring JavaScript as a language
    and the browser as a platform, first we have to understand the complete web application
    lifecycle, and especially how our JavaScript code fits into this lifecycle.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的JavaScript探索是在客户端Web应用程序和浏览器（作为执行JavaScript代码的引擎）的背景下进行的。为了有一个强大的基础，继续探索JavaScript作为一门语言和浏览器作为平台，我们首先必须理解完整的Web应用程序生命周期，特别是我们的JavaScript代码如何适应这个生命周期。
- en: In this chapter, we’ll thoroughly explore the lifecycle of client-side web applications
    from the moment the page is requested, through various interactions performed
    by the user, all the way until the page is closed down. First we’ll explore how
    the page is built by processing the HTML code. Then we’ll focus on the execution
    of JavaScript code, which adds much-needed dynamicity to our pages. And finally
    we’ll look into how events are handled in order to develop interactive applications
    that respond to users’ actions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将彻底探讨客户端网络应用程序的生命周期，从页面请求开始，到用户执行的各种交互，直到页面关闭。首先，我们将探索如何通过处理 HTML 代码来构建页面。然后，我们将关注
    JavaScript 代码的执行，它为我们的页面增添了必要的动态性。最后，我们将研究如何处理事件，以开发对用户操作做出响应的交互式应用程序。
- en: During this process, we’ll explore some fundamental web application concepts
    such as the DOM (a structured representation of a web page) and the event loop
    (determines how events are handled by applications). Let’s dive in!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们将探讨一些基本的网络应用程序概念，如 DOM（网页的结构化表示）和事件循环（确定应用程序如何处理事件）。让我们深入探讨！
- en: Do you know?
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: '**Q1:**'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q1:**'
- en: ''
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Does the browser always build the page exactly according to the given HTML?
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 浏览器是否总是按照给定的 HTML 准确构建页面？
- en: '**Q2:**'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q2:**'
- en: ''
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many events can a web application handle at once?
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 网络应用程序一次可以处理多少个事件？
- en: '**Q3:**'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Q3:**'
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why must browsers use an event queue to process events?
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么浏览器必须使用事件队列来处理事件？
- en: 2.1\. The lifecycle overview
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 生命周期概述
- en: The lifecycle of a typical client-side web application begins with the user
    typing a URL into the browser’s address bar or clicking a link. Let’s say we want
    to look up a term and go to Google’s homepage. We type in the URL [www.google.com](http://www.google.com),
    as shown at upper left in [figure 2.1](#ch02fig01).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的客户端网络应用程序的生命周期始于用户在浏览器的地址栏中输入 URL 或点击链接。假设我们想查找一个术语并访问谷歌的主页。我们输入 URL [www.google.com](http://www.google.com)，如[图
    2.1](#ch02fig01) 上方所示。
- en: 'Figure 2.1\. The lifecycle of a client-side web application starts with the
    user specifying a website address (or clicking a link) and ends when the user
    leaves the web page. It’s composed of two steps: *page building* and *event handling*.'
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.1\. 客户端网络应用程序的生命周期始于用户指定网站地址（或点击链接），并在用户离开网页时结束。它由两个步骤组成：*页面构建* 和 *事件处理*。
- en: '![](02fig01_alt.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![生命周期概述](02fig01_alt.jpg)'
- en: On behalf of the user, the browser formulates a request that is sent to a server
    ![](num-02.jpg), which processes the request ![](num-03.jpg) and formulates a
    response that is usually composed of HTML, CSS, and JavaScript code. The moment
    the browser receives this response ![](num-04.jpg) is when our client-side web
    application truly starts coming to life.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 代表用户，浏览器制定一个请求发送到服务器 ![服务器](num-02.jpg)，服务器处理请求 ![处理请求](num-03.jpg) 并制定一个通常由
    HTML、CSS 和 JavaScript 代码组成的响应。当浏览器接收到这个响应 ![响应](num-04.jpg) 时，我们的客户端网络应用程序真正开始活跃起来。
- en: 'Because client-side web applications are Graphical User Interface (GUI) applications,
    their lifecycle follows similar phases as other GUI applications (think standard
    desktop applications or mobile applications) and is carried out in the following
    two steps:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于客户端网络应用程序是图形用户界面 (GUI) 应用程序，它们的生命周期遵循与其他 GUI 应用程序（如标准桌面应用程序或移动应用程序）相似的阶段，并在以下两个步骤中执行：
- en: '***Page building—*** Set up the user interface.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***页面构建—*** 设置用户界面。'
- en: '***Event handling—*** Enter a loop ![](num-05.jpg) waiting for events to occur
    ![](num-06.jpg), and start invoking event handlers.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***事件处理—*** 进入循环 ![事件处理](num-05.jpg) 等待事件发生 ![事件发生](num-06.jpg)，并开始调用事件处理器。'
- en: The lifecycle of the application ends when the user closes or leaves the web
    page ![](num-07.jpg).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的生命周期在用户关闭或离开网页 ![关闭网页](num-07.jpg) 时结束。
- en: 'Now let’s look at an example web application with a simple UI that reacts to
    user actions: Every time a user moves a mouse or clicks the page, a message is
    displayed. We’ll use this application throughout the chapter.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个具有简单 UI 并对用户操作做出响应的示例网络应用程序：每次用户移动鼠标或点击页面时，都会显示一条消息。我们将在这个章节中使用这个应用程序。
- en: Listing 2.1\. Small web application with a GUI reacting to events
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.1\. 带有 GUI 并对事件做出响应的小型网络应用程序
- en: '![](ch02ex01-0.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![步骤 1](ch02ex01-0.jpg)'
- en: '![](ch02ex01-1.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![示例 1](ch02ex01-1.jpg)'
- en: '[Listing 2.1](#ch02ex01) first defines two CSS rules, `#first` and `#second`,
    that specify the text color for the elements with the IDs `first` and `second`
    (so that we can easily distinguish between them). We continue by defining a list
    element with the id `first`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码列表2.1](#ch02ex01) 首先定义了两个CSS规则，`#first` 和 `#second`，它们指定了具有ID `first` 和
    `second` 的元素的文本颜色（这样我们可以轻松地区分它们）。然后我们定义一个具有id `first` 的列表元素：'
- en: '[PRE2]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then we define an `addMessage` function that, when invoked, creates a new list
    item element, sets its text content, and appends it to an existing element:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义了一个 `addMessage` 函数，当被调用时，创建一个新的列表项元素，设置其文本内容，并将其追加到一个现有元素中：
- en: '[PRE3]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We follow this by using the built-in `getElementById` method to fetch an element
    with the ID `first` from the document, and adding a message to it that notifies
    us that the page is loading:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们使用内置的 `getElementById` 方法从文档中获取ID为 `first` 的元素，并向其添加一条消息，通知我们页面正在加载：
- en: '[PRE4]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next we define another list element, now with the attribute ID `second`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们定义另一个列表元素，现在具有属性ID `second`：
- en: '[PRE5]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally we attach two event handlers to the body of the web page. We start
    with the `mousemove` event handler, which is executed every time the user moves
    the mouse, and adds a message `"Event: mousemove"` to the `second` list element
    by calling the `addMessage` function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我们将两个事件处理器附加到网页的主体上。我们首先从 `mousemove` 事件处理器开始，它在用户移动鼠标时执行，并通过调用 `addMessage`
    函数将一条消息 `"Event: mousemove"` 添加到 `second` 列表元素中：'
- en: '[PRE6]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We also register a `click` event handler, which, whenever the user clicks the
    page, logs a message `"Event: click"`, also to the `second` list element:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还注册了一个 `click` 事件处理器，每当用户点击页面时，都会记录一条消息 `"Event: click"`，也记录到 `second` 列表元素中：'
- en: '[PRE7]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The result of running and interacting with this application is shown in [figure
    2.2](#ch02fig02).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行和与该应用程序交互的结果显示在[图2.2](#ch02fig02)中。
- en: Figure 2.2\. When the code from [listing 2.1](#ch02ex01) runs, messages are
    logged depending on user actions.
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2. 当[代码列表2.1](#ch02ex01)中的代码运行时，根据用户操作记录消息。
- en: '![](02fig02.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2](02fig02.jpg)'
- en: We’ll use this example application to explore and illustrate the differences
    between different phases of the web application lifecycle. Let’s start with the
    page-building phase.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个示例应用程序来探索和说明不同阶段之间的差异。让我们从页面构建阶段开始。
- en: 2.2\. The page-building phase
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2. 页面构建阶段
- en: 'Before a web application can be interacted with or even displayed, the page
    must be built from the information in the response received from the server (usually
    HTML, CSS, and JavaScript code). The goal of this page-building phase is to set
    up the UI of a web application, and this is done in two distinct steps:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个Web应用程序可以交互或甚至显示之前，页面必须从从服务器收到的信息（通常是HTML、CSS和JavaScript代码）构建。页面构建阶段的目标是设置Web应用程序的UI，这是通过两个不同的步骤完成的：
- en: Parsing the HTML and building the Document Object Model (DOM)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析HTML和构建文档对象模型（DOM）
- en: Executing JavaScript code
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行JavaScript代码
- en: Step 1 is performed when the browser is processing HTML nodes, and step 2 is
    performed whenever a special type of HTML element—the `script` element (that contains
    or refers to JavaScript code)—is encountered. During the page-building phase,
    the browser can switch between these two steps as many times as necessary, as
    shown in [figure 2.3](#ch02fig03).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在浏览器处理HTML节点时执行，第二步是在遇到一种特殊的HTML元素——`script` 元素（包含或引用JavaScript代码）时执行。在页面构建阶段，浏览器可以根据需要在这两个步骤之间切换，如图2.3所示。
- en: 'Figure 2.3\. The page-building phase starts when the browser receives the code
    of the page. It’s performed in two steps: parsing the HTML and building the DOM,
    and executing JavaScript code.'
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.3. 页面构建阶段开始于浏览器接收到页面代码时。它分为两个步骤：解析HTML和构建DOM，以及执行JavaScript代码。
- en: '![](02fig03_alt.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3_替代](02fig03_alt.jpg)'
- en: 2.2.1\. Parsing the HTML and building the DOM
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.1. 解析HTML和构建DOM
- en: The page-building phase starts with the browser receiving the HTML code, which
    is used as a base on top of which the browser builds the page’s UI. The browser
    does this by parsing the HTML code, one HTML element at a time, and building a
    DOM, a structured representation of the HTML page in which every HTML element
    is represented as a node. For example, [figure 2.4](#ch02fig04) shows the DOM
    of the example page that’s built until the first `script` element is reached.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 页面构建阶段始于浏览器接收到HTML代码，该代码作为浏览器构建页面UI的基础。浏览器通过逐个解析HTML代码，并构建一个DOM，即HTML页面的结构化表示，其中每个HTML元素都表示为一个节点来完成这一操作。例如，[图2.4](#ch02fig04)显示了构建到第一个`script`元素时的示例页面DOM。
- en: Figure 2.4\. By the time the browser encounters the first `script` element,
    it has already created a DOM with multiple HTML elements (the nodes on the right).
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4\. 当浏览器遇到第一个`script`元素时，它已经创建了一个包含多个HTML元素的DOM（右侧的节点）。
- en: '![](02fig04_alt.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![02fig04_alt.jpg]'
- en: 'Notice how the nodes in [figure 2.4](#ch02fig04) are organized such that each
    node except the first one (the root `html` node ![](num-01.jpg)) has exactly one
    parent. For example, the `head` node ![](num-02.jpg) has the `html` node ![](num-01.jpg)
    as its parent. At the same time, a node can have any number of children. For example,
    the `html` node ![](num-01.jpg) has two children: the `head` node ![](num-02.jpg)
    and the `body` node ![](num-07.jpg). Children of the same element are called *siblings*.
    (The `head` node ![](num-02.jpg) and the `body` node ![](num-07.jpg) are siblings.)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意[图2.4](#ch02fig04)中的节点是如何组织的，使得除了第一个节点（根`html`节点 ![num-01.jpg]）之外，每个节点恰好有一个父节点。例如，`head`节点
    ![num-02.jpg] 的父节点是`html`节点 ![num-01.jpg]。同时，一个节点可以有任意数量的子节点。例如，`html`节点 ![num-01.jpg]
    有两个子节点：`head`节点 ![num-02.jpg] 和`body`节点 ![num-07.jpg]。同一元素的孩子被称为*兄弟节点*。（`head`节点
    ![num-02.jpg] 和`body`节点 ![num-07.jpg] 是兄弟节点。）
- en: It’s important to emphasize that, although the HTML and the DOM are closely
    linked, with the DOM being constructed from HTML, they aren’t one and the same.
    You should think of the HTML code as a *blueprint* the browser follows when constructing
    the initial DOM—the UI—of the page. The browser can even fix problems that it
    finds with this blueprint in order to create a valid DOM. Let’s consider the example
    shown in [figure 2.5](#ch02fig05).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，尽管HTML和DOM紧密相关，DOM是由HTML构建的，但它们并不相同。您应该将HTML代码视为浏览器在构建页面初始DOM（即UI）时遵循的*蓝图*。浏览器甚至可以修复它在这个蓝图中发现的问题，以创建一个有效的DOM。让我们考虑[图2.5](#ch02fig05)中显示的示例。
- en: Figure 2.5\. An example of invalid HTML that is fixed by the browser
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.5\. 浏览器修复的无效HTML示例
- en: '![](02fig05_alt.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![02fig05_alt.jpg]'
- en: '[Figure 2.5](#ch02fig05) gives a simple example of erroneous HTML code in which
    a paragraph element is placed in the `head` element. The intention of the `head`
    element is that it is used for providing general page information: for example,
    the page title, character encodings, and external styles and scripts. It isn’t
    intended for defining page content, as in this example. Because this is an error,
    the browser silently fixes it by constructing the correct DOM (at right in [figure
    2.5](#ch02fig05)), in which the paragraph element is placed in the `body` element,
    where the page content ought to be.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.5](#ch02fig05) 展示了一个简单的错误HTML代码示例，其中段落元素被放置在`head`元素中。`head`元素的本意是用于提供页面的一般信息：例如，页面标题、字符编码和外部样式和脚本。它并不用于定义页面内容，正如这个例子所示。因为这个错误，浏览器通过构建正确的DOM（如图2.5中的右侧所示）来静默地修复它，其中段落元素被放置在`body`元素中，这是页面内容应该放置的地方。'
- en: '|  |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**HTML specification and DOM specification**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTML规范和DOM规范**'
- en: The current version of HTML is HTML5, whose specification is available at [https://html.spec.whatwg.org/](https://html.spec.whatwg.org/).
    If you need something more readable, we recommend Mozilla’s HTML5 guide, available
    at [https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的HTML是HTML5，其规范可在[https://html.spec.whatwg.org/](https://html.spec.whatwg.org/)找到。如果您需要更易读的内容，我们推荐Mozilla的HTML5指南，可在[https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5](https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5)找到。
- en: The DOM, on the other hand, is evolving a bit more slowly. The current version
    is DOM3, whose specification is available at [https://dom.spec.whatwg.org/](https://dom.spec.whatwg.org/).
    Again, Mozilla has prepared a report that can be found at [https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，DOM 的演变要慢一些。当前版本是 DOM3，其规范可在 [https://dom.spec.whatwg.org/](https://dom.spec.whatwg.org/)
    找到。同样，Mozilla 准备了一份报告，可在 [https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model)
    找到。
- en: '|  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: During page construction, the browser can encounter a special type of HTML element,
    the `script` element, which is used for including JavaScript code. When this happens,
    the browser pauses the DOM construction from HTML code and starts executing JavaScript
    code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面构建过程中，浏览器可能会遇到一种特殊的 HTML 元素，即 `script` 元素，它用于包含 JavaScript 代码。当这种情况发生时，浏览器会暂停从
    HTML 代码构建 DOM，并开始执行 JavaScript 代码。
- en: 2.2.2\. Executing JavaScript code
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.2.2\. 执行 JavaScript 代码
- en: All JavaScript code contained in the `script` element is executed by the browser’s
    JavaScript engine; for example, Firefox’s Spidermonkey, Chrome and Opera’s V8,
    or Edge’s (IE’s) Chakra. Because the primary purpose of JavaScript code is to
    provide dynamicity to the page, the browser provides an API through a global object
    that can be used by the JavaScript engine to interact with and modify the page.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在 `script` 元素中的所有 JavaScript 代码都由浏览器的 JavaScript 引擎执行；例如，Firefox 的 Spidermonkey、Chrome
    和 Opera 的 V8，或者 Edge 的 (IE 的) Chakra。由于 JavaScript 代码的主要目的是为页面提供动态性，浏览器通过一个全局对象提供了一个
    API，该 API 可以由 JavaScript 引擎用来与页面交互和修改页面。
- en: Global objects in JavaScript
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: JavaScript 中的全局对象
- en: The primary global object that the browser exposes to the JavaScript engine
    is the `window` object, which represents the window in which a page is contained.
    The `window` object is *the* global object through which all other global objects,
    global variables (even user-defined ones), and browser APIs are accessible. One
    of the most important properties of the global `window` object is the `document`,
    which represents the DOM of the current page. By using this object, the JavaScript
    code can alter the DOM of the page to any degree, by modifying or removing existing
    elements, and even by creating and inserting new ones.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器向 JavaScript 引擎暴露的主要全局对象是 `window` 对象，它代表了包含网页的窗口。`window` 对象是 *唯一的* 全局对象，通过它所有其他全局对象、全局变量（甚至用户定义的变量）和浏览器
    API 都可以访问。全局 `window` 对象的一个重要属性是 `document`，它代表了当前页面的 DOM。通过使用这个对象，JavaScript
    代码可以修改页面的 DOM 到任何程度，通过修改或删除现有元素，甚至创建和插入新的元素。
- en: 'Let’s look at a snippet of code from [listing 2.1](#ch02ex01):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 [列表 2.1](#ch02ex01) 中的代码片段：
- en: '[PRE8]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This example uses the global `document` object to select an element with the
    ID `first` from the DOM and assign it to a variable `first`. We can then use JavaScript
    code to make all sorts of modifications to that element, such as changing its
    textual content, modifying its attributes, dynamically creating and adding new
    children to it, and even removing the element from the DOM.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用全局 `document` 对象从 DOM 中选择具有 ID `first` 的元素并将其分配给变量 `first`。然后我们可以使用 JavaScript
    代码对该元素进行各种修改，例如更改其文本内容、修改其属性、动态创建并添加新的子元素，甚至从 DOM 中删除该元素。
- en: '|  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Browser APIs**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**浏览器 API**'
- en: Throughout the book, we use a number of browser built-in objects and functions
    (for example, `window` and `document`). Unfortunately, covering everything supported
    by the browser lies beyond the scope of a JavaScript book. Luckily, Mozilla again
    has our backs with [https://developer.mozilla.org/en-US/docs/Web/API](https://developer.mozilla.org/en-US/docs/Web/API),
    where you can find the current status of the Web API Interfaces.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们使用了许多浏览器内置对象和函数（例如，`window` 和 `document`）。不幸的是，涵盖浏览器支持的所有内容超出了 JavaScript
    书籍的范围。幸运的是，Mozilla 再次为我们提供了支持，在 [https://developer.mozilla.org/en-US/docs/Web/API](https://developer.mozilla.org/en-US/docs/Web/API)
    上，你可以找到 Web API 接口的当前状态。
- en: '|  |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: With this basic understanding of the global objects provided by the browser,
    let’s look at two different types of JavaScript code that define exactly when
    that code is executed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了浏览器提供的全局对象的基本知识之后，让我们看看两种不同类型的 JavaScript 代码，它们定义了代码的确切执行时间。
- en: Different types of JavaScript code
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不同类型的 JavaScript 代码
- en: 'We broadly differentiate between two different types of JavaScript code: *global
    code* and *function code*. The following listing will help you understand the
    differences between these two types of code.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们广泛区分两种不同的 JavaScript 代码类型：*全局代码* 和 *函数代码*。以下列表将帮助您理解这两种类型代码之间的差异。
- en: Listing 2.2\. Global and function JavaScript code
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2\. 全局和函数 JavaScript 代码
- en: '![](021fig01_alt.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](021fig01_alt.jpg)'
- en: 'The main difference between these two types of code is their placement: the
    code contained in a function is called *function code*, whereas the code placed
    outside all functions is called *global code*.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型代码之间的主要区别在于它们的放置位置：函数中包含的代码称为 *函数代码*，而放置在所有函数之外的代码称为 *全局代码*。
- en: These two code types also differ in their execution (you’ll see some additional
    differences later on, especially in [chapter 5](kindle_split_016.html#ch05)).
    Global code is executed automatically by the JavaScript engine (more on that soon)
    in a straightforward fashion, line by line, as it’s encountered. For example,
    in [listing 2.2](#ch02ex02), the pieces of global code that define the `addMessage`
    function use the built-in `getElementById` method to fetch the element with ID
    `first` and call the `addMessage` function; they are executed one after another
    as they’re encountered, as shown in [figure 2.6](#ch02fig06).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种代码类型在执行上也有所不同（你将在后面看到一些额外的差异，尤其是在 [第 5 章](kindle_split_016.html#ch05) 中）。全局代码由
    JavaScript 引擎自动按顺序逐行执行，就像遇到它时那样。例如，在 [列表 2.2](#ch02ex02) 中，定义 `addMessage` 函数的全局代码使用内置的
    `getElementById` 方法获取 ID 为 `first` 的元素并调用 `addMessage` 函数；它们按顺序遇到时执行，如图 2.6 所示。
- en: Figure 2.6\. Program execution flow when executing JavaScript code
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.6\. 执行 JavaScript 代码时的程序执行流程
- en: '![](02fig06_alt.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig06_alt.jpg)'
- en: 'On the other hand, function code, in order to be executed, has to be called
    by something else: either by global code (for example, the `addMessage` function
    call in the global code causes the execution of the `addMessage` function code),
    by some other function, or by the browser (more on this soon).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，函数代码为了执行，必须被其他东西调用：要么是全局代码（例如，全局代码中的 `addMessage` 函数调用导致 `addMessage` 函数代码的执行），要么是其他函数，或者由浏览器（很快就会详细介绍）。
- en: Executing JavaScript code in the page-building phase
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在页面构建阶段执行 JavaScript 代码
- en: When the browser reaches the `script` node in the page-building phase, it pauses
    the DOM construction based on HTML code and starts executing JavaScript code instead.
    This means executing the global JavaScript code contained in the `script` element
    (and functions called by the global code are also executed). Let’s go back to
    the example from [listing 2.1](#ch02ex01).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器在页面构建阶段到达 `script` 节点时，它会暂停基于 HTML 代码的 DOM 构建并开始执行 JavaScript 代码。这意味着执行
    `script` 元素中包含的全球 JavaScript 代码（以及由全球代码调用的函数也会执行）。让我们回到 [列表 2.1](#ch02ex01) 的例子。
- en: '[Figure 2.7](#ch02fig07) shows the state of the DOM after the global JavaScript
    code has been executed. Let’s walk slowly through its execution. First a function
    `addMessage` is defined:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.7](#ch02fig07) 展示了全局 JavaScript 代码执行后的 DOM 状态。让我们慢慢分析其执行过程。首先定义一个函数 `addMessage`：'
- en: '[PRE9]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Figure 2.7\. The DOM of the page after executing the JavaScript code contained
    in the `script` element
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.7\. 执行 `script` 元素中包含的 JavaScript 代码后的页面 DOM
- en: '![](02fig07_alt.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig07_alt.jpg)'
- en: 'Then an existing element is fetched from the DOM by using the global `document`
    object and its `getElementById` method:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用全局 `document` 对象及其 `getElementById` 方法从 DOM 中获取现有元素：
- en: '[PRE10]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is followed by a call to the `addMessage` function
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这之后是对 `addMessage` 函数的调用
- en: '[PRE11]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: which causes the creation of a new `li` element, the modification of its text
    content, and finally its insertion into the DOM.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致创建一个新的 `li` 元素，修改其文本内容，并将其最终插入到 DOM 中。
- en: 'In this example, the JavaScript code modifies the current DOM by creating a
    new element and inserting it into the DOM. But in general, JavaScript code can
    modify the DOM to any degree: It can create new nodes and modify or remove existing
    DOM nodes. But there are also some things it can’t do, such as select and modify
    elements that haven’t yet been created. For example, we can’t select and modify
    the `ul` element with the ID `second`, because that element is found after the
    current `script` node and hasn’t yet been reached and created. That’s one of the
    reasons people tend to put their `script` elements at the bottom of the page.
    That way, we don’t have to worry about whether a particular HTML element has been
    reached.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，JavaScript 代码通过创建一个新元素并将其插入到 DOM 中来修改当前 DOM。但一般来说，JavaScript 代码可以修改 DOM
    到任何程度：它可以创建新节点，修改或删除现有的 DOM 节点。但也有一些它做不到的事情，例如选择和修改尚未创建的元素。例如，我们无法选择和修改具有 ID `second`
    的 `ul` 元素，因为该元素是在当前 `script` 节点之后找到的，尚未到达并创建。这就是人们倾向于将 `script` 元素放在页面底部的原因之一。这样，我们就不必担心特定的
    HTML 元素是否已经被到达。
- en: Once the JavaScript engine executes the last line of JavaScript code in the
    `script` element (in [figure 2.5](#ch02fig05), this means returning from the `addMessage`
    function), the browser exits the JavaScript execution mode and continues building
    DOM nodes by processing the remaining HTML code. If, during that processing, the
    browser again encounters a `script` element, the DOM creation from HTML code is
    again paused, and the JavaScript runtime starts executing the contained JavaScript
    code. It’s important to note that the global state of the JavaScript application
    persists in the meantime. All user-defined global variables created during the
    execution of JavaScript code in one `script` element are normally accessible to
    JavaScript code in other `script` elements. This happens because the global `window`
    object, which stores all global JavaScript variables, is alive and accessible
    during the entire lifecycle of the page.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JavaScript 引擎执行 `script` 元素中最后一行 JavaScript 代码（在 [图 2.5](#ch02fig05) 中，这意味着从
    `addMessage` 函数返回），浏览器退出 JavaScript 执行模式，并继续通过处理剩余的 HTML 代码来构建 DOM 节点。如果在处理过程中，浏览器再次遇到
    `script` 元素，则从 HTML 代码创建 DOM 再次暂停，JavaScript 运行时开始执行包含的 JavaScript 代码。重要的是要注意，在此期间
    JavaScript 应用程序的全球状态持续存在。在单个 `script` 元素中执行 JavaScript 代码期间创建的所有用户定义的全局变量通常都可以在其他
    `script` 元素中的 JavaScript 代码中访问。这是因为存储所有全局 JavaScript 变量的全局 `window` 对象在整个页面生命周期中都是活跃且可访问的。
- en: These two steps
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个步骤
- en: Building the DOM from HTML
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 HTML 构建DOM
- en: Executing JavaScript code
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 JavaScript 代码
- en: are repeated as long as there are HTML elements to process and JavaScript code
    to execute.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 只要还有要处理的 HTML 元素和要执行的 JavaScript 代码，这两个步骤就会重复。
- en: 'Finally, when the browser runs out of HTML elements to process, the page-building
    phase is complete. The browser then moves on to the second part of the web application
    lifecycle: *event handling*.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当浏览器处理完所有 HTML 元素后，页面构建阶段就完成了。然后，浏览器继续进入 Web 应用程序生命周期的第二部分：*事件处理*。
- en: 2.3\. Event handling
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3\. 事件处理
- en: 'Client-side web applications are GUI applications, which means they react to
    different kinds of events: mouse moves, clicks, keyboard presses, and so on. For
    this reason, the JavaScript code executed during the page-building phase, in addition
    to influencing the global application state and modifying the DOM, can also register
    event listeners (or handlers): functions that are executed by the browser when
    an event occurs. With these event handlers, we provide interactivity to our applications.
    But before taking a closer look at registering event handlers, let’s go through
    the general ideas behind event handling.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端 Web 应用程序是 GUI 应用程序，这意味着它们会对不同类型的事件做出反应：鼠标移动、点击、键盘按键等。因此，在页面构建阶段执行的 JavaScript
    代码，除了影响全局应用程序状态和修改 DOM 之外，还可以注册事件监听器（或处理程序）：当事件发生时由浏览器执行的功能。通过这些事件处理程序，我们为我们的应用程序提供交互性。但在深入了解注册事件处理程序之前，让我们先了解一下事件处理背后的基本思想。
- en: 2.3.1\. Event-handling overview
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1\. 事件处理概述
- en: 'The browser execution environment is, at its core, based on the idea that only
    a single piece of code can be executed at once: the so-called *single-threaded*
    execution model. Think of a line at the bank. Everyone gets into a single line
    and has to wait their turn to be “processed” by the tellers. But with JavaScript,
    only *one* teller window is open! Customers (events) are processed only one at
    a time, as their turn comes. All it takes is one person who thinks it’s appropriate
    to do their financial planning for the entire fiscal year while they’re at the
    teller’s window (we’ve all run into them!) to gum up the works.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器执行环境的核心思想是：一次只能执行一段代码：所谓的*单线程*执行模型。想象一下银行排队。每个人都排成单行，必须等待轮到自己被柜员“处理”。但使用JavaScript时，只有一个柜员窗口是开放的！客户（事件）在轮到他们时才会被处理，一次只处理一个。只需一个人认为在柜员窗口时做整个财年的财务规划是合适的（我们都有遇到过这种情况！）就会让整个流程变得混乱。
- en: Whenever an event occurs, the browser should execute the associated event-handler
    function. But there’s no guarantee that we have extremely patient users who will
    always wait an appropriate amount of time before triggering another event. For
    this reason, the browser needs a way to keep track of the events that have occurred
    but have yet to be processed. To do this, the browser uses an *event queue,* as
    shown in [figure 2.8](#ch02fig08).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 每当发生事件时，浏览器都应该执行相关的事件处理函数。但我们无法保证用户有极大的耐心，总是在触发另一个事件之前等待适当的时间。因此，浏览器需要一种方式来跟踪已经发生但尚未处理的事件。为此，浏览器使用一个*事件队列*，如图2.8所示。
- en: Figure 2.8\. In the event-handling phase, all events (whether coming from the
    user, such as mouse clicks and key presses, or coming from the server, such as
    Ajax events) are queued up as they occur and are processed as the single thread
    of execution allows.
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.8。在事件处理阶段，所有事件（无论是来自用户，如鼠标点击和按键，还是来自服务器，如Ajax事件）都会在发生时排队，并按照执行的单线程顺序进行处理。
- en: '![](02fig08_alt.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8](02fig08_alt.jpg)'
- en: 'All generated events (it doesn’t matter if they’re user-generated, like mouse
    moves or key presses, or server-generated, such as Ajax events) are placed in
    the same event queue, in the order in which they’re detected by the browser. As
    shown in the middle of [figure 2.8](#ch02fig08), the event-handling process can
    then be described with a simple flowchart:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的生成事件（无论是用户生成的，如鼠标移动或按键，还是服务器生成的，如Ajax事件）都会按照浏览器检测到的顺序放入同一个事件队列中。如图2.8的中间部分所示，事件处理过程可以用一个简单的流程图来描述：
- en: The browser checks the head of the event queue.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器检查事件队列的头部。
- en: If there are no events, the browser keeps checking.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有事件，浏览器会持续检查。
- en: If there’s an event at the head of the event queue, the browser takes it and
    executes the associated handler (if one exists). During this execution, the rest
    of the events patiently wait in the event queue for their turn to be processed.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果事件队列的头部有事件，浏览器会取走它并执行相关处理程序（如果有的话）。在执行过程中，其余的事件会耐心地等待在事件队列中，等待轮到自己被处理。
- en: Because only one event is handled at a time, we have to be extra careful about
    the amount of time needed for handling events; writing event handlers that take
    a lot of time to execute leads to unresponsive web applications! (Don’t worry
    if this sounds a bit vague; we’ll come back to the event loop in [chapter 13](kindle_split_026.html#ch13)
    and see exactly how it impacts the perceived performance of web applications).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一次只能处理一个事件，我们必须格外注意处理事件所需的时间；编写执行时间很长的处理程序会导致Web应用无响应！（如果这听起来有点模糊，不要担心；我们将在第13章[chapter
    13](kindle_split_026.html#ch13)中回到事件循环，并确切地了解它如何影响Web应用的感知性能）。
- en: It’s important to note that the browser mechanism that puts events *onto* the
    queue is external to the page-building and event-handling phases. The processing
    that’s necessary to determine when events have occurred and that pushes them onto
    the event queue doesn’t participate in the thread that’s *handling* the events.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，将事件*放入*队列的浏览器机制是独立于页面构建和事件处理阶段的。确定事件何时发生并将它们推入事件队列所需的处理不参与处理事件的线程。
- en: Events are asynchronous
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 事件是异步的
- en: Events, when they happen, can occur at unpredictable times and in an unpredictable
    order (it’s tricky to force users to press keys or click in some particular order).
    We say that the handling of events, and therefore the invocation of their handling
    functions, is *asynchronous*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件发生时，它们可能在不可预测的时间和顺序中发生（强制用户以特定顺序按键或点击是有点棘手的）。我们说事件的处理，以及因此调用其处理函数，是*异步的*。
- en: 'The following types of events can occur, among others:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类型的事件可能发生，等等：
- en: Browser events, such as when a page is finished loading or when it’s to be unloaded
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器事件，例如页面加载完成或即将卸载时
- en: Network events, such as responses coming from the server (Ajax events, server-side
    events)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络事件，例如来自服务器的响应（Ajax事件，服务器端事件）
- en: User events, such as mouse clicks, mouse moves, and key presses
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户事件，例如鼠标点击、鼠标移动和按键
- en: Timer events, such as when a timeout expires or an interval fires
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器事件，例如超时到期或间隔触发
- en: The vast majority of code executes as a result of such events!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数代码都是由于此类事件而执行的！
- en: 'The concept of event handling is central to web applications, and it’s something
    you’ll see again and again throughout the examples in this book: Code is set up
    in advance in order to be executed at a later time. Except for global code, the
    vast majority of the code we place on a page will execute as the result of some
    event.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理的概念是网络应用的核心，你将在本书的示例中反复看到：代码是在事先设置好以便在稍后执行。除了全局代码外，我们放置在页面上的绝大多数代码都将作为某些事件的结果执行。
- en: Before events can be handled, our code has to notify the browser that we’re
    interested in handling particular events. Let’s look at how to register event
    handlers.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件可以被处理之前，我们的代码必须通知浏览器我们感兴趣处理特定事件。让我们看看如何注册事件处理器。
- en: 2.3.2\. Registering event handlers
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2\. 注册事件处理器
- en: 'As we’ve already mentioned, event handlers are functions that we want executed
    whenever a particular event occurs. In order for this to happen, we have to notify
    the browser that we’re interested in an event. This is called *event-handler registration*.
    In client-side web applications, there are two ways to register events:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，事件处理器是我们希望在特定事件发生时执行的函数。为了实现这一点，我们必须通知浏览器我们对事件感兴趣。这被称为*事件处理器注册*。在客户端网络应用中，有两种方式可以注册事件：
- en: By assigning functions to special properties
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将函数分配给特殊属性
- en: By using the built-in `addEventListener` method
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用内置的`addEventListener`方法
- en: 'For example, writing the following code assigns a function to the special `onload`
    property of the `window` object:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，编写以下代码将函数分配给`window`对象的特殊`onload`属性：
- en: '[PRE12]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'An event handler for the `load` event (when the DOM is ready and fully built)
    is registered. (Don’t worry if the notation on the right side of the assignment
    operator looks a bit funky; we’ll talk at great length about functions in later
    chapters.) Similarly, if we want to register a handler for the `click` event on
    the document’s body, we can write something along these lines:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为`load`事件（当DOM准备就绪且完全构建时）注册了事件处理器。（如果赋值操作符右侧的符号看起来有点奇怪，请不要担心；我们将在后面的章节中详细讨论函数。）同样，如果我们想在文档的`body`上注册`click`事件的处理器，我们可以写类似以下的内容：
- en: '[PRE13]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Assigning functions to special properties is an easy and straightforward way
    of registering event handlers, and you’ve probably run into it already. But we
    don’t recommend that you register event handlers this way, because doing so comes
    with a drawback: It’s only possible to register one function handler for a particular
    event. This means it’s easy to overwrite previous event-handler functions, which
    can be a little frustrating. Luckily, there’s an alternative: The `addEventListener`
    method enables us to register as many event-handler functions as we need. To show
    you an example, the following listing goes back to an excerpt of the example from
    [listing 2.1](#ch02ex01).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数分配给特殊属性是注册事件处理器的一种简单直接的方法，你可能已经遇到过。但我们不建议你以这种方式注册事件处理器，因为这样做有一个缺点：只能为特定事件注册一个函数处理器。这意味着很容易覆盖先前的事件处理器函数，这可能会有些令人沮丧。幸运的是，有一个替代方案：`addEventListener`方法使我们能够注册所需数量的事件处理器函数。为了给你一个例子，以下列表回到[列表2.1](#ch02ex01)的示例摘录。
- en: Listing 2.3\. Registering event handlers
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.3\. 注册事件处理器
- en: '![](026fig01_alt.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](026fig01_alt.jpg)'
- en: 'This example uses the built-in `addEventListener` method on an HTML element
    to specify the type of event (`mousemove` or `click`) and the event-handler function.
    This means whenever the mouse is moved over the page, the browser calls a function
    that adds a message, `"Event: mousemove"`, to the list element with the ID `second`
    (a similar message, `"Event: click"`, is added to the same element whenever the
    body is clicked).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '这个例子使用HTML元素上的内置`addEventListener`方法来指定事件类型（`mousemove`或`click`）和事件处理器函数。这意味着每当鼠标移动到页面上时，浏览器都会调用一个函数，将消息`"Event:
    mousemove"`添加到ID为`second`的列表元素中（当点击主体时，向同一元素添加类似的消息`"Event: click"`）。'
- en: Now that you know how to set up event handlers, let’s recall the simple flowchart
    you saw earlier and take a closer look at how events are handled.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何设置事件处理器，让我们回顾一下你之前看到的简单流程图，并更仔细地看看事件是如何被处理的。
- en: 2.3.3\. Handling events
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3\. 处理事件
- en: The main idea behind event handling is that when an event occurs, the browser
    calls the associated event handler. As we’ve already mentioned, due to the single-threaded
    execution model, only a single event handler can be executed at once. Any following
    events are processed only after the execution of the current event handler is
    fully complete!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理背后的主要思想是，当事件发生时，浏览器调用相关的事件处理器。正如我们之前提到的，由于单线程执行模型，一次只能执行一个事件处理器。任何后续的事件都只有在当前事件处理器完全执行完毕后才会被处理！
- en: Let’s go back to the application from [listing 2.1](#ch02ex01). [Figure 2.9](#ch02fig09)
    shows an example execution in which a quick user has moved and clicked a mouse.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到[列表2.1](#ch02ex01)的应用。![图2.9](#ch02fig09)展示了用户快速移动并点击鼠标的一个示例执行过程。
- en: Figure 2.9\. Example of an event-handling phase in which two events—`mousemove`
    and `click`—are handled
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '![图2.9\. 事件处理阶段的示例，其中处理了两个事件—`mousemove`和`click`]'
- en: '![](02fig09_alt.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![02fig09_alt.jpg](02fig09_alt.jpg)'
- en: 'Let’s examine what’s going on here. As a response to these user actions, the
    browser puts the `mousemove` and `click` events onto the event queue in the order
    in which they have occurred: first the `mousemove` event and then the `click`
    event ![](num-01.jpg).'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这里发生了什么。作为对这些用户行为的响应，浏览器按照它们发生的顺序将`mousemove`和`click`事件放入事件队列中：首先是`mousemove`事件，然后是`click`事件![num-01.jpg](num-01.jpg)。
- en: In the event-handling phase, the event loop then checks the queue, sees that
    there’s a `mousemove` event at the front of the queue, and executes the associated
    event handler ![](num-02.jpg). While the `mousemove` handler is being processed,
    the `click` event waits in the queue for its turn. When the last line of the `mousemove`
    handler function has finished executing and the JavaScript engine exits the handler
    function, the `mousemove` event is fully processed ![](num-03.jpg), and the event
    loop again checks the queue. This time, at the front of the queue, the event loop
    finds the `click` event and processes it. Once the `click` handler has finished
    executing, there are no new events in the queue, and the event loop keeps looping,
    waiting for new events to handle. This loop will continue executing until the
    user closes the web application.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件处理阶段，事件循环随后检查队列，看到队列前面有一个`mousemove`事件，并执行相关的事件处理器![num-02.jpg](num-02.jpg)。当`mousemove`处理器正在处理时，`click`事件在队列中等待它的轮次。当`mousemove`处理器函数的最后一行执行完毕并且JavaScript引擎退出处理器函数后，`mousemove`事件就被完全处理![num-03.jpg](num-03.jpg)，事件循环再次检查队列。这次，在队列前面，事件循环找到了`click`事件并处理它。一旦`click`处理器执行完成，队列中没有新的事件，事件循环继续循环，等待处理新事件。这个循环将一直执行，直到用户关闭Web应用。
- en: 'Now that we have a sense of the overall steps that happen in the event-handling
    phase, let’s see how this execution influences the DOM ([figure 2.10](#ch02fig10)).
    The execution of the `mousemove` handler selects the second list element with
    ID `second` and, by using the `addMessage` function, adds a new list item element
    ![](num-01.jpg) with the text `"Event: mousemove"`. Once the execution of the
    `mousemove` handler is finished, the event loop executes the `click` handler,
    which leads to the creation of another list item element ![](num-02.jpg), which
    is also appended to the second list element with the ID `second`.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们对事件处理阶段发生的整体步骤有了感觉，让我们看看这个执行是如何影响DOM的（[图2.10](#ch02fig10)）。`mousemove`处理器的执行选择了ID为`second`的第二个列表元素，并通过使用`addMessage`函数，添加了一个新的列表项元素![num-01.jpg](num-01.jpg)，其文本为`"Event:
    mousemove"`。一旦`mousemove`处理器的执行完成，事件循环执行`click`处理器，这导致创建另一个列表项元素![num-02.jpg](num-02.jpg)，该元素也被添加到ID为`second`的第二个列表元素中。'
- en: Figure 2.10\. The DOM of the example application after handling the `mousemove`
    and `click` events
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.10. 处理了`mousemove`和`click`事件后的示例应用的DOM
- en: '![](02fig10_alt.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig10_alt.jpg)'
- en: Armed with this solid understanding of the lifecycle of client-side web applications,
    in the next part of the book, we’ll start focusing on JavaScript the language,
    by learning the ins and outs of functions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '带着对客户端Web应用生命周期的扎实理解，在本书的下一部分，我们将开始关注JavaScript语言，通过学习函数的细节来深入了解。 '
- en: 2.4\. Summary
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4. 概述
- en: The HTML code received by the browser is used as a blueprint for creating the
    DOM, an internal representation of the structure of a client-side web application.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器接收到的HTML代码用作创建DOM的蓝图，DOM是客户端Web应用结构的内部表示。
- en: We use JavaScript code to dynamically modify the DOM to bring dynamic behavior
    to web applications.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用JavaScript代码动态修改DOM，为Web应用带来动态行为。
- en: 'The execution of client-side web applications is performed in two phases:'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端Web应用的执行分为两个阶段：
- en: '***Page building—*** HTML code is processed to create the DOM, and global JavaScript
    code is executed when script nodes are encountered. During this execution, the
    JavaScript code can modify the current DOM to any degree and can even register
    event handlers—functions that are executed when a particular event occurs (for
    example, a mouse click or a keyboard press). Registering event handlers is easy:
    Use the built-in `addEventListener` method.'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***页面构建—*** 处理HTML代码以创建DOM，并在遇到脚本节点时执行全局JavaScript代码。在执行过程中，JavaScript代码可以修改当前DOM到任何程度，甚至可以注册事件处理程序—在特定事件发生时执行（例如，鼠标点击或键盘按键）。注册事件处理程序很简单：使用内置的`addEventListener`方法。'
- en: '***Event handling—*** Various events are processed one at a time, in the order
    in which they were generated. The event-handling phase relies heavily on the event
    queue, in which all events are stored in the order in which they occurred. The
    event loop always checks the top of the queue for events, and if an event is found,
    the matching event-handler function is invoked.'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***事件处理—*** 各种事件按它们生成的顺序逐个处理。事件处理阶段高度依赖于事件队列，其中所有事件都按它们发生的顺序存储。事件循环始终检查队列的顶部以查找事件，如果找到事件，则调用匹配的事件处理函数。'
- en: 2.5\. Exercises
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5. 练习
- en: '**1**'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**'
- en: ''
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What are the two phases in the lifecycle of a client-side web application?
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 客户端Web应用的生命周期中有哪两个阶段？
- en: '**2**'
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**'
- en: ''
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the main advantage of using the `addEventListener` method to register
    an event handler versus assigning a handler to a specific element property?
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用`addEventListener`方法注册事件处理程序与将处理程序分配给特定元素属性相比，主要优势是什么？
- en: '**3**'
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**'
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many events can be processed at once?
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一次可以处理多少个事件？
- en: '**4**'
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**'
- en: ''
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In what order are events from the event queue processed?
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 事件队列中的事件是按什么顺序处理的？
