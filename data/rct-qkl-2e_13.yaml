- en: '13 Project: Task manager'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 项目：任务管理器
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating the necessary scaffolding for a task manager
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为任务管理器创建必要的框架
- en: Implementing a simple list of tasks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现简单的任务列表
- en: 'Homework: Adding advanced features to the task manager'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作业：为任务管理器添加高级功能
- en: Welcome to the third and final project for this book. You’ll now have to wield
    all the magic and spells that you’ve learned so far as well as some extra knowledge
    about JavaScript and HTML that you’ve hopefully picked up elsewhere—however, that’s
    only required for the very advanced homework at the end of this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到本书的第三个也是最后一个项目。现在你必须运用你迄今为止所学到的所有魔法和咒语，以及你可能在其他地方学到的关于 JavaScript 和 HTML
    的额外知识——然而，这仅适用于本章末尾的非常高级的作业。
- en: In this project, we’ll build a task manager. By *task manager*, we mean a slightly
    more complex variant of a to-do list. The task manager at first consists of a
    simple to-do list implemented as cards that can be started and completed. We then
    add in substeps to each task, so the user can add some finer details to their
    tasks at hand. Next, we add in the option of changing the order of the steps in
    each task, first only using buttons, but then also using drag and drop. It’s that
    last bit in step 5, the drag and drop part, that’s going to be tricky to complete.
    You can see this development in figure 13.1, where we’ll use advanced events to
    get to the final step 5.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将构建一个任务管理器。当我们说“任务管理器”时，我们指的是一个稍微复杂一点的待办事项列表变体。任务管理器最初是一个简单的待办事项列表，以卡片的形式实现，可以开始和完成。然后我们为每个任务添加子步骤，以便用户可以为手头的任务添加一些更详细的细节。接下来，我们添加了改变每个任务步骤顺序的选项，最初只使用按钮，但后来也使用了拖放。这就是步骤
    5 中的最后一部分，拖放部分，这将是一个棘手的完成部分。你可以在图 13.1 中看到这一发展，我们将使用高级事件来完成最终步骤 5。
- en: '![13-01](../Images/13-01.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![13-01](../Images/13-01.png)'
- en: Figure 13.1 As you implement the task manager, you’ll go through these five
    steps to add more and more functionality and complexity to the application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 在实现任务管理器时，你将通过这五个步骤添加更多功能和复杂性到应用程序中。
- en: Once again, we’ll set up the foundations for the project in the first step so
    you don’t have to mess around too much with HTML, icons, and CSS to get the basics
    to work. However, the foundation created in step 1 will be completely inert and
    won’t do anything. To add functionality, you’ll have to go through the steps to
    increase the complexity of the project as we go along.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们将在第一步中为项目打下基础，这样你就不必过多地与HTML、图标和CSS打交道，以便让基本功能正常工作。然而，第一步中创建的基础将完全无效，不会做任何事情。为了添加功能，你必须随着项目的进行逐步增加项目的复杂性。
- en: We’ve also listed the steps in table 13.1 with some more detail about what you’ll
    be doing and which chapters you’ll be referring to when completing the exercises.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在表 13.1 中列出了步骤，并提供了更多关于你将做什么以及完成练习时将参考哪些章节的详细信息。
- en: Table 13.1 The five steps of the task manager project
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表 13.1 任务管理器项目的五个步骤
- en: '| Step | Feature | Additional React API used | Difficulty |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 | 功能 | 使用的额外 React API | 难度 |'
- en: '| Step 1: Scaffold | Create the basic component structure for a list of tasks
    and a form for adding new tasks. | Chapters 1-4: Functional components using JSX
    | ★☆☆☆☆ |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 1：搭建 | 创建任务列表和添加新任务表单的基本组件结构。 | 第一章至第四章：使用 JSX 的函数式组件 | ★☆☆☆☆ |'
- en: '| Step 2: List | Convert static structure to a dynamic list of tasks stored
    in state, with options for editing and deleting tasks as well. | Chapter 5: StateChapter
    8: EventsChapter 9: Forms | ★★★☆☆ |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 2：列表 | 将静态结构转换为存储在状态中的动态任务列表，包括编辑和删除任务的选项。 | 第五章：状态，第八章：事件，第九章：表单 | ★★★☆☆
    |'
- en: '| Step 3: Steps | Add steps and progress to each task, including the option
    of deleting and completing steps. The task list also works as an accordion, where
    only one is expanded at a time.Note: This is homework. You have to create this
    step *yourself*! | Chapter 10: Context | ★★★★☆ |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 3：步骤 | 为每个任务添加步骤和进度，包括删除和完成步骤的选项。任务列表还作为一个手风琴工作，一次只展开一个。注意：这是作业。你必须自己创建这个步骤！
    | 第十章：上下文 | ★★★★☆ |'
- en: '| Step 4: Priority | Add the option to prioritize the steps of a task by reordering
    items. This is made simpler by converting the state to a reducer.Note: This is
    homework. You have to create this step *yourself*! | Chapter 10: Reducer and custom
    hook | ★★★★☆ |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 4：优先级 | 通过重新排序项来添加任务步骤的优先级选项。通过将状态转换为reducer，这变得更容易。注意：这是作业。你必须自己创建这个步骤！
    | 第十章：reducer 和自定义钩子 | ★★★★☆ |'
- en: '| Step 5: Dragging | Allow the user to drag the steps around to change the
    prioritization, rather than only use the arrows to move one step up and down.Note:
    This is homework. You have to create this step *yourself*! | Chapter 8: Event
    handlers | ★★★★★ |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 步骤 5：拖动 | 允许用户拖动步骤以改变优先级，而不仅仅是使用箭头上下移动一个步骤。注意：这是作业。您必须自己创建这个步骤！ | 第 8 章：事件处理器
    | ★★★★★ |'
- en: The first iteration of this exercise, which you’ll reach after completing step
    2, is a very simple task manager, as shown in figure 13.2.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成步骤 2 后，您将进入这个练习的第一个迭代，它是一个非常简单的任务管理器，如图 13.2 所示。
- en: '![13-02](../Images/13-02.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![13-02](../Images/13-02.png)'
- en: Figure 13.2 The first iteration of the task manager simply has a list where
    you can add, delete, and edit the tasks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 任务管理器的第一个迭代仅仅有一个可以添加、删除和编辑任务的列表。
- en: However, when you complete this project all the way through step 5, you’ll have
    a much more advanced application, as you can see in figure 13.3, with a lot more
    options.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当您完成这个项目直到步骤 5，您将拥有一个更高级的应用程序，如图 13.3 所示，有更多的选项。
- en: '![13-03](../Images/13-03.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![13-03](../Images/13-03.png)'
- en: Figure 13.3 Now each task has a list of steps, and you can add, complete, edit,
    delete, and reprioritize these steps inside the task.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 现在每个任务都有一个步骤列表，您可以在任务内添加、完成、编辑、删除和重新排序这些步骤。
- en: You can even drag the steps around inside each task, as you can see in figure
    13.4.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以在每个任务内部拖动步骤，如图 13.4 所示。
- en: '![13-04](../Images/13-04.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![13-04](../Images/13-04.png)'
- en: Figure 13.4 You can drag steps in the list for easier reprioritization.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 您可以拖动列表中的步骤以方便重新排序。
- en: With all that to get through, let’s get started with this final project of the
    last chapter of the book.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些要完成的事情中，让我们开始这本书最后一章的最后一个项目。
- en: Note The source code for the scaffolding as well as suggested solutions to all
    the steps in this chapter is available at [https://rq2e.com/ch13](https://rq2e.com/ch13).
    But as you learned in chapter 2, you can instantiate all the examples and solutions
    directly from the command line using a single command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中支架的源代码以及所有步骤的建议解决方案可在[https://rq2e.com/ch13](https://rq2e.com/ch13)找到。但如您在第二章中学到的，您可以使用单个命令直接从命令行实例化所有示例和解决方案。
- en: 13.1 Scaffolding for the task manager
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 任务管理器的支架
- en: Once again, we’re going to get you started with a basic scaffold for this application.
    We’re going to create the HTML output for a static task manager and provide all
    the styles necessary as well. It won’t be dynamic nor even functional, but it’ll
    look like the finished thing; it just needs some React magic to get going.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们将为您提供一个基本支架来启动这个应用程序。我们将创建静态任务管理器的 HTML 输出，并提供所有必要的样式。它不会是动态的，甚至也不是功能性的，但它看起来就像成品；它只需要一点
    React 魔法来启动。
- en: We’re also going to provide you with some icons that you’ll need for some icon
    buttons through the solution.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为您提供一些图标，您将通过解决方案需要这些图标来创建一些图标按钮。
- en: 13.1.1 Component hierarchy
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.1 组件层次结构
- en: In this step for this project, we’re going to cheat a bit. We’re creating the
    entire (static) application in a single component. We could split things up, but
    we feel that this allows you to decide better how to split things up into components
    yourself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目的这个步骤中，我们将稍微作弊一下。我们将在一个组件中创建整个（静态）应用程序。我们可以分割这些内容，但我们觉得这可以让您更好地决定如何自己将内容分割成组件。
- en: With a single component returning all the JSX for the entire application in
    a static, fixed setup, you can see exactly how the whole thing is created and
    how best to move forward from here. That leaves a trivially simple component diagram
    for this application, as you can see in figure 13.5.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个组件中返回整个应用程序的 JSX，并以静态、固定的设置，您可以清楚地看到整个创建过程以及如何从这里开始最佳地前进。正如您在图 13.5 中看到的，这留下了这个应用程序的一个极其简单的组件图。
- en: '![13-05](../Images/13-05.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![13-05](../Images/13-05.png)'
- en: Figure 13.5 Although we mentioned that the component tree in figure 12.5 was
    our simplest yet, we think we have it beat with this one!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 虽然我们提到图 12.5 中的组件树是我们最简单的，但我们认为这个更胜一筹！
- en: 13.1.2 Project structure
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.2 项目结构
- en: With such a simple component hierarchy in this step, there’s not much to say
    about the source folder. We have a main application file and a CSS file as usual,
    along with our single application-specific component, TaskList.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，组件层次结构如此简单，关于源文件夹没有太多可说的。我们有一个主应用程序文件和一个 CSS 文件，就像往常一样，以及我们的单个应用程序特定组件，TaskList。
- en: 'We do, however, also have some icons for this project, and we’ve added eight
    different SVGs in the public folder that we’ll need throughout the project. That
    leaves us with the following file structure:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也有一些图标用于这个项目，我们在公共文件夹中添加了八个不同的SVG文件，这些文件将在整个项目中使用。这使我们有了以下文件结构：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Repository: rq13-scaffold'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq13-scaffold
- en: 'This example can be seen in repository rq13-scaffold. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可在rq13-scaffold存储库中看到。您可以通过创建基于相关模板的新应用程序来使用该存储库：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站浏览代码，直接在浏览器中查看应用程序的运行情况，或下载源代码的zip文件：
- en: '[https://rq2e.com/rq13-scaffold](https://rq2e.com/rq13-scaffold)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq13-scaffold](https://rq2e.com/rq13-scaffold)'
- en: 13.1.3 Source code
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.3 源代码
- en: There are only two source files of significance to list in this step. We have
    the main application file, which is almost identical to all the other ones we’ve
    been using, and then the application-specific task list.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，只有两个重要的源文件需要列出。我们有主应用程序文件，它与我们所使用的其他文件几乎完全相同，然后是特定于应用程序的任务列表。
- en: The main application
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 主要应用程序
- en: The main application is included in src/App.js, and it should look very familiar
    to you by now. The file is shown in the following listing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 主要应用程序包含在src/App.js中，到现在您应该已经很熟悉这个文件了。文件如下所示。
- en: Listing 13.1 src/App.js in the scaffolding
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.1 框架中的src/App.js
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Loads the CSS file
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 加载CSS文件
- en: ❷ Loads the top-level component of the application
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 加载应用程序的最高级组件
- en: ❸ Renders that component in the relevant JSX tree
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在相关的JSX树中渲染该组件
- en: The task list
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 任务列表
- en: The file src/TaskList.js is displayed in listing 13.2\. It contains all the
    JSX to render a list of two tasks as well as a form for adding a new task at the
    bottom. All of it is completely inactive though, so nothing (interesting) happens
    when you click the buttons.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 文件src/TaskList.js在列表13.2中显示。它包含渲染两个任务列表以及底部添加新任务表单的所有JSX。尽管如此，所有这些都是完全不可用的，所以当你点击按钮时，不会发生任何（有趣）的事情。
- en: Listing 13.2 src/TaskList.js in the scaffolding
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.2 框架中的src/TaskList.js
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The lane of tasks is an ordered list.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 任务通道是一个有序列表。
- en: ❷ Each task is a list item.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 每个任务都是一个列表项。
- en: ❸ A task has a header with a title.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一个任务有一个包含标题的标题。
- en: ❹ Below the task title is an unordered list of buttons.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在任务标题下方是一个无序列表按钮。
- en: ❺ A task has a header with a title.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 一个任务有一个包含标题的标题。
- en: ❻ The last task in the list is slightly different, as it contains a form to
    add a new task using an input and an icon button
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 列表中的最后一个任务略有不同，因为它包含一个表单，用于使用输入和图标按钮添加新任务
- en: 13.1.4 Running the application
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.4 运行应用程序
- en: The scaffold results in a nice-looking but otherwise completely useless application
    with a static list of tasks and a form at the bottom, as you can see in figure
    13.6.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的结果是一个看起来不错但其他方面完全无用的应用程序，它包含一个静态的任务列表和底部的表单，如图13.6所示。
- en: '![13-06](../Images/13-06.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![13-06](../Images/13-06.png)'
- en: Figure 13.6 If only the buttons actually worked, this would be a somewhat useful
    application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 如果按钮实际上能工作，这将是一个有点有用的应用程序。
- en: 13.2 A simple list of tasks
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 一个简单的任务列表
- en: Now that we have all the basics out of the way—that is, we have the JSX, styles,
    and icons all under control—we go to the next step of creating the actual task
    manager application. What we have so far is “just” regular web development, and
    all that work required skills mostly outside the scope of this book. What comes
    now is React development, and this is where we have to apply all the skills we’ve
    learned so far in this book.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了所有基本工作——也就是说，我们已经控制了JSX、样式和图标——我们进入创建实际任务管理应用程序的下一步。到目前为止，我们只是常规的Web开发，所有这些工作所需技能大多超出了本书的范围。接下来是React开发，这正是我们必须应用本书中迄今为止所学到的所有技能的地方。
- en: 13.2.1 The goal of this exercise
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.1 本练习的目标
- en: 'In this step of the project, we’ll add the actual functionality to the structure
    that was outlined in the scaffold. After completing this step, we want to have
    a simple task manager that can do the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目步骤中，我们将向框架中概述的结构添加实际的功能。完成这一步骤后，我们希望有一个简单的任务管理器，能够执行以下操作：
- en: Show a list of tasks
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示任务列表
- en: Allow the user to add a new task by writing the task title
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户通过编写任务标题添加新任务
- en: Allow the user to delete a task
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户删除任务
- en: Allow the user to rename a task
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户重命名任务
- en: 'We’ll do this in two steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两步进行：
- en: Split the single big component into multiple smaller components that make sense
    in terms of component size, responsibility, and visual representation.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将单个大组件拆分为多个更小的组件，这些组件在组件大小、责任和视觉表示方面都有意义。
- en: Make the application stateful, so it starts with a predefined list, and users
    can then append, delete, and update tasks as they see fit.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使应用程序具有状态，因此它从一个预定义的列表开始，然后用户可以根据需要添加、删除和更新任务。
- en: 13.2.2 Component hierarchy
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.2 组件层次结构
- en: While we only had a single component, TaskList, related to the actual task manager
    in the scaffold, we’ll extend that to multiple components in this step. You can
    see the breakdown in figure 13.7.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们只有一个与实际任务管理器相关的组件TaskList时，我们将在这一步扩展到多个组件。你可以在图13.7中看到分解。
- en: '![13-07](../Images/13-07.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![13-07](../Images/13-07.png)'
- en: 'Figure 13.7 The task manager in this step breaks down neatly into five different
    components: the task header with the title or input to edit the title; the task,
    including the header and some controls; the form to add new tasks; an icon button;
    and, finally, the full task list.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 在这个步骤中，任务管理器被巧妙地分解为五个不同的组件：带有标题或编辑标题的输入框的任务标题；包括标题和一些控制的任务；添加新任务的表单；一个图标按钮；最后，完整的任务列表。
- en: To start at the innermost level, the title of a task can be a large paragraph
    or an input where you can edit the title and click to submit that new title. We’ll
    create that as our first component, TaskHeader. Building on top of this, each
    task is then an individual component, Task, which handles the state of a task,
    namely, whether the title is being edited or not.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从最内层开始，任务的标题可以是一个大段落或一个可以编辑标题并点击提交新标题的输入框。我们将创建这个组件作为我们的第一个组件，TaskHeader。在此基础上，每个任务都是一个单独的组件，Task，它处理任务的州，即标题是否正在编辑。
- en: At the bottom of the task list, we’ll create a new component for adding a new
    task. That’s where our third new component, TaskAdd, will be, which contains a
    form and will invoke a callback once submitted.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务列表的底部，我们将创建一个新的组件来添加新任务。这就是我们的第三个新组件TaskAdd的位置，它包含一个表单，并在提交后会调用一个回调函数。
- en: Finally, we need to add an icon button for this project, so we might as well
    add that now. Let’s be super inventive and call this component Button. We’ll only
    need the icon button inside the new task form, but we have many future uses for
    it in the next steps. This all comes together as you can see in figure 13.8, where
    the component tree is laid out.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要为这个项目添加一个图标按钮，所以我们不妨现在就添加。让我们非常创新，把这个组件命名为Button。我们只需要在新的任务表单中用图标按钮，但我们预计在下一步中会有很多用途。所有这些都可以在图13.8中看到，其中组件树被布局出来。
- en: '![13-08](../Images/13-08.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![13-08](../Images/13-08.png)'
- en: Figure 13.8 The component tree of step 2 of this project has five components.
    The task component in particular is used several times depending on the number
    of actual tasks to display.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 本项目第二步的组件树有五个组件。特别是任务组件，根据要显示的实际任务数量，会使用多次。
- en: 13.2.3 Updated project structure
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.3 更新的项目结构
- en: As mentioned earlier, in this step of the project, we’re adding some new components
    as well as updating others. As a new thing, we’re also adding a plain JavaScript
    file for setting up the initial value of our stateful task array. We’re naming
    this file fixture .js, as *fixture* is often used as the term for “fixed” data
    that you want to populate your application with.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在这个项目步骤中，我们不仅添加了一些新组件，还更新了其他组件。作为一个新事物，我们还添加了一个用于设置状态化任务数组初始值的纯JavaScript文件。我们将这个文件命名为fixture.js，因为*fixture*通常被用作“固定”数据的术语，你希望用这些数据填充你的应用程序。
- en: Finally, as another new improvement, we’ll use a nested file structure. We aren’t
    adding a lot of components yet, but we’re expecting more components to be added
    later, so we’ll encapsulate the four components related to tasks specifically,
    to go in their own folder. To make these easier to import, we’re adding an index
    file to this folder as well that will export only the necessary components from
    this folder.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为另一个新的改进，我们将使用嵌套的文件结构。我们目前还没有添加很多组件，但我们预计以后会添加更多组件，因此我们将特定于任务的四个组件封装到一个文件夹中。为了使这些组件更容易导入，我们还将添加一个索引文件到这个文件夹，该文件将只从这个文件夹导出必要的组件。
- en: 'This leads to the following updated file structure after completing this step:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一步后，将得到以下更新的文件结构：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Unchanged files
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 未更改的文件
- en: ❷ Updated files
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 更新的文件
- en: ❸ New files
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 新文件
- en: We recommend that you try to implement this step yourself, and you can do so
    either by starting from your own implementation of the scaffolding in step 1 of
    this project or from our implementation in rq13-scaffold. Once completed, feel
    free to compare your solution to ours.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您尝试自己实现这一步，您可以从本项目的第一步中自己的脚手架实现开始，或者从rq13-scaffold中的我们的实现开始。一旦完成，您可以自由地比较您的解决方案与我们的解决方案。
- en: 'Repository: rq13-list'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库：rq13-list
- en: 'This example can be seen in repository rq13-list. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq13-list存储库中看到。您可以通过创建一个基于相关模板的新应用程序来使用该存储库：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问这个网站来浏览代码，直接在浏览器中查看应用程序的实际应用，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq13-list](https://rq2e.com/rq13-list)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq13-list](https://rq2e.com/rq13-list)'
- en: 13.2.4 Source code
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.4 源代码
- en: In this section, we’ll provide the full source code for all the updated and
    new files added in this step along with some implementation details that will
    be relevant for understanding our choices.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提供所有在本步骤中添加的更新和新文件的完整源代码，以及一些与理解我们的选择相关的实现细节。
- en: The main application file
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用程序文件
- en: The only change to the main application component is the location of the imported
    task list. Instead of importing the task list as a default import from a file
    named TaskList, we instead import it as a named import from the folder named task.
    You can see this change in the next listing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对主应用程序组件的唯一更改是导入任务列表的位置。我们不是从名为TaskList的文件中作为默认导入导入任务列表，而是从名为task的文件夹中作为命名导入导入它。您可以在下一个列表中看到这个更改。
- en: Listing 13.3 src/App.js in the simple task list
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.3简单任务列表中的src/App.js
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ The only change here is the location and import style of the task list component.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这里唯一的变化是任务列表组件的位置和导入方式。
- en: The icon button
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图标按钮
- en: We create a very simple icon button in the file src/Button.js.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在文件src/Button.js中创建了一个非常简单的图标按钮。
- en: Listing 13.4 src/Button.js in the simple task list
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.4简单任务列表中的src/Button.js
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ We can pass in a number of named properties and then any other properties
    that can go on a link.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们可以传递多个命名属性，然后是任何可以放在链接上的其他属性。
- en: ❷ The only thing that's a bit special here is the draggable attribute on the
    image. This is done in preparation for the last step, where we don't want our
    icon buttons to drag independently of the entire step.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这里唯一有点特殊的是图像上的可拖动属性。这是为最后一步做准备，我们不想让我们的图标按钮独立于整个步骤进行拖动。
- en: The public interface for the task folder
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 任务文件夹的公共接口
- en: We use the task folder as a kind of separated module, in which we use a number
    of components internally as we see fit, but to the outside world we only expose
    the task list component as the “public” component. This isn’t a technical limitation,
    though, as you could import any component from the task folder, but it’s a first
    step toward a packaged project structure. This leaves src/task/index.js as a very
    simple index file, as you can see in the following listing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将任务文件夹作为一种分离的模块，在其中我们根据需要使用多个组件，但对于外部世界，我们只公开任务列表组件作为“公共”组件。这并不是一个技术限制，因为您可以从任务文件夹中导入任何组件，但这是一个打包项目结构的初步步骤。正如您在下面的列表中可以看到的，这使src/task/index.js成为一个非常简单的索引文件。
- en: Listing 13.5 src/task/index.js in the simple task list
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.5简单任务列表中的src/task/index.js
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ We only expose the task list component from this folder, and we do so as a
    named export.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们只从这个文件夹中公开任务列表组件，并且我们以命名导出的方式这样做。
- en: The fixture with default tasks
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 默认任务的固定装置
- en: We store the task list in local storage in the browser, but the first time you
    visit the application, you won’t have a task list to restore, so we need some
    default content for the application to function. We could use an empty list, but
    you’ll often see apps populate an application with some sample data to inspire
    you.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在浏览器中本地存储任务列表，但第一次访问应用程序时，您将没有要恢复的任务列表，因此我们需要一些默认内容让应用程序能够运行。我们可以使用一个空列表，但您通常会看到应用程序使用一些示例数据来激发您。
- en: While our sample data might not be all that inspiring, we’ve definitely set
    you up for a quick start. You can see the file src/task/fixture.js in the next
    listing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的示例数据可能并不那么鼓舞人心，但我们确实为您提供了一个快速启动。您可以在下一个列表中看到文件src/task/fixture.js。
- en: Listing 13.6 src/task/fixture.js in the simple task list
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.6简单任务列表中的src/task/fixture.js
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The task header
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 任务标题
- en: The task header seems simple because it’s just the title. However, the title
    can be edited, and if it’s editable, the header changes to a form with a checkmark
    icon as a Submit button. You can see src/task/TaskHeader.js implemented next.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 任务标题看起来很简单，因为它只是标题。然而，标题是可以编辑的，如果它可编辑，则标题会变为一个带有勾选图标作为提交按钮的表单。您可以在 src/task/TaskHeader.js
    中看到接下来的实现。
- en: Listing 13.7 src/task/TaskHeader.js in the simple task list
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.7 简单任务列表中的 src/task/TaskHeader.js
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ This component accepts some properties necessary to make the header editable.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此组件接受一些必要的属性以使标题可编辑。
- en: ❷ When the edit form is submitted, we prevent the default action (i.e., reload
    the page), update the current task with the new value, and, finally, set the header
    to be not editable again.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当编辑表单提交时，我们阻止默认操作（即重新加载页面），使用新值更新当前任务，最后将标题设置为不可再次编辑。
- en: ❸ If the header is editable, we return one set of JSX.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果标题是可编辑的，我们返回一组 JSX。
- en: ❹ This JSX includes a form with our submit handler defined earlier.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 此 JSX 包含了一个我们之前定义的提交处理程序表单。
- en: ❺ If the header isn’t editable, we simply return some static JSX with the current
    header.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果标题不可编辑，我们简单地返回一些包含当前标题的静态 JSX。
- en: The entire task
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 整个任务
- en: The preceding task header is included inside each task. A task can be edited
    and deleted. When a task is edited, the header is updated with the relevant properties,
    including the callback to update the task as passed from the parent component.
    When a task is deleted, we simply invoke the delete callback directly. All of
    this is implemented in src/task/Task.js.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的任务标题包含在每个任务内部。任务可以被编辑和删除。当任务被编辑时，标题会更新为相关的属性，包括从父组件传递过来的更新任务的回调。当任务被删除时，我们直接调用删除回调。所有这些都在
    src/task/Task.js 中实现。
- en: Listing 13.8 src/task/Task.js in the simple task list
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.8 简单任务列表中的 src/task/Task.js
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ The task takes all the information about the current task to display, as well
    as two callbacks to edit and delete a task, respectively.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 任务接受关于当前任务的所有信息以显示，以及两个回调，分别用于编辑和删除任务。
- en: ❷ Keeps a local state inside each task capturing whether the user is currently
    trying to edit the task title or not
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在每个任务内部保持一个本地状态，以捕获用户当前是否正在尝试编辑任务标题。
- en: ❸ Renders the previously defined task header component with all relevant properties
    at the top of the component
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在组件顶部渲染之前定义的任务标题组件及其所有相关属性
- en: ❹ Below the header we have two buttons; the first toggles the local editable
    flag to true.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在标题下方有两个按钮；第一个将本地可编辑标志切换为 true。
- en: ❺ The second button invokes the delete callback.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 第二个按钮调用删除回调。
- en: The new task form
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 新任务表单
- en: When we want to add a new task, we do so in a form with a single uncontrolled
    input for the task title and a Submit button in the form of an icon button. See
    file src/ task/TaskAdd.js in the following listing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要添加一个新任务时，我们通过一个表单来完成，该表单包含一个用于任务标题的单个非受控输入和一个图标按钮形式的提交按钮。请参阅以下列表中的文件 src/task/TaskAdd.js。
- en: Listing 13.9 src/task/TaskAdd.js in the simple task list
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.9 简单任务列表中的 src/task/TaskAdd.js
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ The task form component takes a single property, which is the callback to
    invoke with the new task to be added.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 任务表单组件接受一个单一属性，即用于调用新添加任务的回调。
- en: '❷ When the task form is submitted, we do three things: cancel the default action,
    invoke the callback, and reset the form so it''s ready for a new task to be added.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当任务表单提交时，我们执行三个操作：取消默认操作，调用回调，并将表单重置以便添加新的任务。
- en: ❸ This submit handler is added to the form node.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 此提交处理程序被添加到表单节点。
- en: The complete and stateful list of tasks
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 完整且具有状态的任务列表
- en: 'The last component in this step—the task list—is both the most important one
    and the one with the most responsibilities. It takes care of three different things:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在此步骤中最后一个组件——任务列表——既是最重要的一个，也是责任最重的一个。它负责三件事情：
- en: Manages the state of all the tasks and provides callbacks to add, edit, and
    delete tasks
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理所有任务的状态，并提供添加、编辑和删除任务的回调
- en: Initializes the task list either from local storage or from the fixture
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本地存储或从固定装置初始化任务列表
- en: Displays all the tasks in a list, followed by the new task form
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表中显示所有任务，然后是新任务表单
- en: This is a lot of responsibility for a single component, and it could make sense
    to move a part of it (especially items 1 and 2) to a custom hook to simplify the
    overview of this component. However, we’ll keep it as a single file for now, but
    this is one of the things that we recommend you change in future steps in this
    project. The file src/task/ TaskList.js is implemented in the next listing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于一个单一组件来说责任重大，可能将其中一部分（尤其是第1和第2项）移动到自定义钩子中，以简化该组件的概览是有意义的。然而，我们现在将其保持为一个单独的文件，但这是我们在项目未来步骤中推荐您更改的事项之一。文件src/task/TaskList.js的实现将在下一列表中展示。
- en: Listing 13.10 src/task/TaskList.js in the simple task list
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.10 src/task/TaskList.js中的简单任务列表
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ The initial state of the task list is a parsed value from local storage if
    it exists or the initial state as returned by the fixture.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 任务列表的初始状态是如果存在则从本地存储解析的值，或者由固定装置返回的初始状态。
- en: ❷ We use this function that returns the initial state as an argument for the
    stateful hook. Remember that this function will then only be invoked on the first
    render of this component and not on subsequent re-renders.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们使用此函数作为状态钩子的参数返回初始状态。请记住，这个函数将在该组件第一次渲染时被调用，而不是在后续的重新渲染中。
- en: ❸ Adds an effect to store the task list in local storage every time the task
    list changes
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 每当任务列表更改时，添加效果以将任务列表存储在本地存储中。
- en: ❹ First, the first of three callbacks is the function to add a new task. It
    appends the argument to the task list using the update function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 首先，三个回调中的第一个是添加新任务的函数。它使用更新函数将参数追加到任务列表中。
- en: ❺ Second, the callback to edit a task maps the entire task list to a new array
    and updates the relevant task as it loops over all the items.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 第二，编辑任务的回调将整个任务列表映射到一个新数组，并在遍历所有项目时更新相关的任务。
- en: ❻ Third, the callback to delete a task filters the existing task list to remove
    the now-irrelevant task.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 第三，删除任务的回调将现有的任务列表过滤掉现在不再相关的任务。
- en: ❼ Two callbacks are passed to a task component for each task in the list of
    all tasks.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 对于所有任务列表中的每个任务，传递两个回调到任务组件中。
- en: ❽ Finally, the new task form is added at the end of the list.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 最后，在列表末尾添加新的任务表单。
- en: 13.2.5 Running the application
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.5 运行应用程序
- en: Let’s see this in action in figure 13.9 and then start creating some tasks that
    we can delete later.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在图13.9中看到这个效果，然后开始创建一些我们可以稍后删除的任务。
- en: '![13-09](../Images/13-09.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![13-09](../Images/13-09.png)'
- en: Figure 13.9 The first iteration of our application that actually works. We can
    create, delete, and edit tasks.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 我们应用程序的第一个迭代，实际上可以工作。我们可以创建、删除和编辑任务。
- en: '13.3 Homework: Task steps and progress'
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 家庭作业：任务步骤和进度
- en: 'The goal for this step is to complete the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本步骤的目标是完成以下内容：
- en: Add an ordered list of *“completable”* steps inside each task.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个任务中添加一个有序的“可完成”步骤列表。
- en: At the bottom of the list, always include an input field to allow the user to
    add a new item to the end of the list.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表底部，始终包含一个输入字段，以允许用户将新项目添加到列表的末尾。
- en: For each step in the list, add a checkbox to mark the step as completed or not,
    as well as a button to delete the step.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于列表中的每个步骤，添加一个复选框以标记步骤是否完成，以及一个按钮以删除步骤。
- en: Allow the user to hide and show the steps of a task (hidden by default).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户隐藏和显示任务的步骤（默认隐藏）。
- en: Summarize the completion of the task with a progress bar that shows the ratio
    of the steps in the task that have been completed. This progress bar should be
    visible even if the list of steps is hidden.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用进度条总结任务的完成情况，该进度条显示任务中已完成步骤的比例。即使步骤列表被隐藏，此进度条也应可见。
- en: 'Here are a few hints to help you complete this objective:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提示可以帮助您完成这个目标：
- en: 'While we could get away with keeping the state as a simple array maintained
    by a useState hook, we need more fine-grained control of the state now, so convert
    the state to a reducer, and add actions for the different updates necessary, for
    example: addTask, editTask, deleteTask, addStep, editStep, and deleteStep.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然我们可以通过保持状态为一个由useState钩子维护的简单数组来完成任务，但现在我们需要对状态有更精细的控制，因此将状态转换为reducer，并为不同的更新添加操作，例如：addTask（添加任务）、editTask（编辑任务）、deleteTask（删除任务）、addStep（添加步骤）、editStep（编辑步骤）和deleteStep（删除步骤）。
- en: You might also want to wrap the task list in a context provider to make access
    to the preceding actions easier inside nested components.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能还希望将任务列表包裹在一个上下文提供者中，以便在嵌套组件内部更容易访问前面的操作。
- en: To add a progress bar, use the <progress /> HTML element. It’s simple to use
    and already styled in the existing CSS file in the scaffold.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加进度条，请使用<progress />HTML元素。它使用简单，并且已经在现有的CSS文件中进行了样式设置。
- en: To display a list of steps with a checkbox, use the proper semantic HTML elements
    for all of those things (<ol />, <li />, <label />, and <input type="checkbox"
    /> would be a good start).
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示带有复选框的步骤列表，请使用所有这些内容的适当语义HTML元素（<ol />, <li />, <label />和<input type="checkbox"
    />是一个不错的开始）。
- en: Adding a new step requires a form with an input and a button. That should be
    pretty straightforward at this point.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新步骤需要一个带有输入和按钮的表单。在这个阶段，这应该相当直接。
- en: Of course, we want you to work from your existing application that you developed
    in the previous step, but if you want to start from our solution to that step,
    you can do so by checking out this application in rq13-list. Once completed, feel
    free to compare your solution to ours.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们希望你在上一步中开发的应用程序基础上工作，但如果你想从我们对那个步骤的解决方案开始，你可以通过检出rq13-list中的应用程序来这样做。完成后，请随意比较你的解决方案和我们的。
- en: 'Repository: rq13-steps'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq13-steps
- en: 'This example can be seen in repository rq13-steps. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq13-steps仓库中看到。你可以通过基于相关模板创建一个新应用来使用该仓库：
- en: '[PRE14]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以访问这个网站来浏览代码，直接在浏览器中查看应用程序的实际运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq13-steps](https://rq2e.com/rq13-steps)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[rq13-steps](https://rq2e.com/rq13-steps)'
- en: '13.4 Homework: Prioritization of steps'
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 家庭作业：步骤优先级
- en: 'The goal for this step is to complete the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本步骤的目标是完成以下内容：
- en: Add a button to rename a step inside a task.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任务内添加一个按钮来重命名步骤。
- en: Add buttons to reprioritize the steps inside each task.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个任务内添加按钮来重新排序步骤。
- en: 'Here are a few hints to help you complete this objective:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些提示可以帮助你完成这个目标：
- en: If you didn’t already convert the data structure to a reducer rather than a
    simple state array in the previous step, you definitely want to do so now. Moving
    elements in an array isn’t too complex, but remember that you have to create a
    new array every time; you can never mutate the existing one. That’s why it can
    be nice to centralize and organize the functionality in a reducer function.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有在上一步中将数据结构转换为reducer而不是简单的状态数组，你现在绝对应该这样做。在数组中移动元素并不太复杂，但请记住，你必须每次都创建一个新的数组；你永远不能修改现有的一个。这就是为什么在reducer函数中集中和组织功能可能很棒的原因。
- en: Allowing a step to be renamed works exactly as allowing the overall task to
    be renamed—set a local state value that the text should be replaced with, and
    input and update the data using the provider once the input form is submitted.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许步骤被重命名的工作方式与允许整体任务被重命名的工作方式完全相同——设置一个本地状态值，用文本替换它，并在提交输入表单后使用provider输入和更新数据。
- en: Other than that, adding the three extra buttons next to each step and calling
    the right functions in the reducer should be a piece of cake at this point.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了那个之外，在这个阶段，在每个步骤旁边添加三个额外的按钮并在reducer中调用正确的函数应该轻而易举。
- en: 'For added bonus and ease of development, consider this: All the functions to
    be invoked inside a single task (e.g., adding steps, moving steps, deleting steps,
    etc.) need the ID of the task to be able to reference the correct object in the
    overall task object. You might be able to use an additional provider around each
    single task that abstracts this task ID away from the individual calls inside
    the task itself.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了额外的奖励和开发便利，请考虑这一点：在单个任务内部要调用的所有函数（例如，添加步骤、移动步骤、删除步骤等）需要任务的ID来引用整体任务对象中的正确对象。你可能能够在每个单个任务周围使用一个额外的provider来抽象出这个任务ID，从而从任务内部的单独调用中将其抽象出来。
- en: Of course, we want you to work from your existing application that you developed
    in the previous step, but if you want to start from our solution to that step,
    you can do so by checking out this application in rq13-steps. Once completed,
    feel free to compare your solution to ours.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们希望你在上一步中开发的应用程序基础上工作，但如果你想从我们对那个步骤的解决方案开始，你可以通过检出rq13-steps中的应用程序来这样做。完成后，请随意比较你的解决方案和我们的。
- en: 'Repository: rq13-priority'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq13-priority
- en: 'This example can be seen in repository rq13-priority. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在rq13-priority仓库中看到。你可以通过基于相关模板创建一个新应用来使用该仓库：
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站来浏览代码，直接在浏览器中查看应用程序的实际运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq13-priority](https://rq2e.com/rq13-priority)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq13-priority](https://rq2e.com/rq13-priority)'
- en: '13.5 Homework: Drag and drop'
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5 作业：拖放
- en: 'The goal for this step is to make the steps draggable inside each task. Here
    are a few hints to help you complete this objective:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本步骤的目标是在每个任务内使步骤可拖放。以下是一些帮助您完成此目标的提示：
- en: Drag and drop can be implemented in two ways in HTML. You can either use the
    built-in functionality in HTML5 with the draggable attribute and the dragstart,
    dragover, dragenter, dragleave, and drop events (all of which are supported in
    React), or you can roll your own functionality using pure mouse events, for example,
    mousedown, mousemove, and mouseup.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML中，拖放可以有两种实现方式。您可以使用HTML5内置的功能，包括draggable属性和dragstart、dragover、dragenter、dragleave和drop事件（所有这些都在React中得到支持），或者您可以使用纯鼠标事件（例如mousedown、mousemove和mouseup）来创建自己的功能。
- en: 'Whichever way you go, this won’t be an easy task to complete. There are many
    things to consider. For instance: If you start dragging element number 3 in a
    list, you have to be able to drop it into any other position in the list, including
    before the first item and after the last item. You must make sure that your application
    supports this correctly.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论您选择哪种方式，这都不会是一个容易完成的任务。有许多事情需要考虑。例如：如果您开始拖动列表中的第3个元素，您必须能够将其拖放到列表中的任何其他位置，包括第一个项目之前和最后一个项目之后。您必须确保您的应用程序正确支持这一点。
- en: You also have to update your reducer to allow moving a step to an arbitrary
    position inside the list of steps for the given task. A possible interface could
    be moveStepTo({ taskId, step, position }). In addition, consider the difference
    between moving a step to an earlier position in the list versus to a later position.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还必须更新您的reducer以允许将步骤移动到给定任务步骤列表中的任意位置。一个可能的接口可以是moveStepTo({ taskId, step,
    position })。此外，考虑将步骤移动到列表中的较早位置与移动到较晚位置之间的区别。
- en: In the rq13-dragging application repository, we’ve used the HTML5 native drag-and-drop
    functionality. To have a place to drop an item when dragging a step around, we
    display new elements between all the existing steps in the list with an onDrop
    handler attached, so the user is able to drop the items there. Note that you also
    have to attach onDragEnter, onDragLeave, and onDragOver event handlers (where
    you prevent the default action, which is to not allow dropping) for an element
    to be considered a valid drop target.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在rq13-dragging应用程序仓库中，我们使用了HTML5的本地拖放功能。为了在拖动步骤时有一个放置项的地方，我们在列表中的所有现有步骤之间显示新元素，并附加onDrop处理程序，以便用户能够将项目放在那里。请注意，您还必须为元素附加onDragEnter、onDragLeave和onDragOver事件处理程序（其中您阻止默认操作，即不允许放置），以便该元素被视为有效的放置目标。
- en: Don’t worry if you find this to be a difficult exercise. It is! Our implementation
    isn’t particularly clean either, but it works and looks okay.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您发现这个练习很难，不要担心。它确实很难！我们的实现并不特别干净，但它可以工作，看起来也不错。
- en: Of course, we want you to work from your existing application that you developed
    in the previous step, but if you want to start from our solution to that step,
    you can do so by checking out this application in rq13-priority. Once completed,
    feel free to compare your solution to ours.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们希望您从上一步中开发的现有应用程序开始工作，但如果您想从我们的解决方案开始，您可以通过检出rq13-priority中的应用程序来这样做。一旦完成，您可以自由地比较您的解决方案与我们的。
- en: 'Repository: rq13-dragging'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库：rq13-dragging
- en: 'This example can be seen in repository rq13-dragging. You can use that repository
    by creating a new app based on the associated template:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以在rq13-dragging仓库中看到。您可以通过创建基于相关模板的新应用程序来使用该仓库：
- en: '[PRE16]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Alternatively, you can go to this website to browse the code, see the application
    in action directly in your browser, or download the source code as a zip file:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以访问此网站来浏览代码，直接在浏览器中查看应用程序的实际运行情况，或者下载源代码的zip文件：
- en: '[https://rq2e.com/rq13-dragging](https://rq2e.com/rq13-dragging)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://rq2e.com/rq13-dragging](https://rq2e.com/rq13-dragging)'
- en: 13.6 Conclusion
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.6 结论
- en: This third project in the book is the most challenging yet. We gave you a solid
    foundation, but you still had to do a lot of engineering and apply a lot of common
    sense as well as computer science intuition to solve the steps.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的第三个项目是最具挑战性的。我们为您提供了一个坚实的基础，但您仍然需要进行大量的工程工作，并应用许多常识以及计算机科学直觉来解决步骤。
- en: This project is an example of a real-world project situation, including the
    iterated increase in complexity as well as utilizing useful and transferable React
    coding patterns. For this final project, you were definitely thrown into the deep
    end of the pool if you tried to go all the way and complete step 5\. Sometimes,
    we need a push to go that extra mile—we might be mixing metaphors here, though.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目是一个真实世界项目情况的例子，包括复杂性的迭代增加以及利用有用的和可转移的 React 编码模式。对于这个最终项目，如果你尝试完成第 5 步，你肯定被扔进了深水区。有时，我们需要额外的推动力去走那最后一英里——我们可能在这里混合了比喻。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Breaking a design down into visual parts and then converting each part to a
    separate React component is a great practice that will come in handy often.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将设计分解为视觉部分，然后将每个部分转换为单独的 React 组件是一种很好的实践，它经常派上用场。
- en: Choosing between useState and useReducer can be difficult at times because the
    line between them is blurry, and it comes down to personal preference. In this
    project, we started out with useState, but moved to a reducer as things got more
    complex for convenience, even though we didn’t strictly have to.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时在 useState 和 useReducer 之间做出选择可能很困难，因为它们之间的界限模糊，这取决于个人偏好。在这个项目中，我们最初使用了 useState，但随着事情变得更加复杂，为了方便起见，我们转向了
    reducer，尽管我们并不严格需要这样做。
- en: The provider pattern is so versatile that we managed to use it again for this
    project, but in a slightly different way than earlier. Try to remember this pattern
    because it will often prove useful.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者模式非常灵活，我们设法再次使用它来完成这个项目，但与之前的方式略有不同。尽量记住这个模式，因为它经常会证明是有用的。
- en: Writing state updates can be tricky when you need to remember to keep objects
    and arrays immutable. Array manipulation can be especially tricky, moving elements
    around by copying all the elements to a new array in the correct order.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要记住保持对象和数组不可变时，编写状态更新可能很棘手。数组操作可能特别棘手，通过将所有元素复制到一个新数组中并按正确顺序移动元素来移动元素。
- en: Single events are easy to work with in React, but complex event patterns, such
    as drag and drop, are still annoyingly difficult to manage even in a nice system
    like React. This might become easier in the future, but for now, it’s a lot of
    work.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 React 中处理单个事件很容易，但像拖放这样的复杂事件模式，即使在像 React 这样良好的系统中，仍然令人烦恼地难以管理。这可能在将来会变得更容易，但就目前而言，这是一项大量工作。
