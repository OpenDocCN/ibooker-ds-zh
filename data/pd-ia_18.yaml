- en: Appendix B. Python crash course
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B. Python入门教程
- en: The pandas library is built on top of Python, a popular programming language
    first released in 1991 by Dutch developer Guido van Rossum. A *library* (also
    called a *package*) is a toolbox of features that expands the core functionalities
    of a programming language. Libraries accelerate developer productivity by providing
    solutions to everyday problems such as database connections, code quality, and
    testing. Most Python projects use libraries. After all, why solve a problem from
    scratch if somebody has already solved it? More than 300,000 libraries are available
    to download from the Python Package Index (PyPi), a centralized online repository
    of Python packages. Pandas is one of those 300,000 libraries; it implements complex
    data structures that excel at storing and manipulating multidimensional data.
    Before we explore what pandas adds to Python, it’s important to see what’s available
    in the base language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: pandas库建立在Python之上，Python是一种流行的编程语言，由荷兰开发者Guido van Rossum于1991年首次发布。*库*（也称为*包*）是一组功能工具箱，它扩展了编程语言的核心功能。库通过提供解决方案来加速开发者的生产力，例如数据库连接、代码质量和测试。大多数Python项目都使用库。毕竟，如果有人已经解决了问题，为什么还要从头开始解决问题呢？Python包索引（PyPi）是一个集中在线仓库，有超过300,000个库可供下载。Pandas是这300,000个库之一；它实现了复杂的数据结构，擅长存储和操作多维数据。在我们探索pandas为Python添加了什么之前，了解基础语言中有什么是很重要的。
- en: Python is an object-oriented programming (OOP) language. The OOP paradigm views
    a software program as being a collection of objects that talk to one another.
    An *object* is a digital data structure that stores information and provides ways
    for it to be accessed and manipulated. Each object has a responsibility or purpose
    for existing. We can think of each object as being an actor in a play and the
    software program as being a performance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种面向对象编程（OOP）语言。面向对象范式将软件程序视为一组相互通信的对象。*对象*是一个数字数据结构，用于存储信息并提供访问和操作该信息的方式。每个对象都有其存在的原因或目的。我们可以将每个对象想象成戏剧中的一个演员，而软件程序则是一场表演。
- en: A helpful way to think of objects is as digital building blocks. Consider a
    spreadsheet software like Excel. As users, we can discern the differences among
    a workbook, a worksheet, and a cell. A workbook holds worksheets, a worksheet
    holds cells, and cells hold values. We view these three entities as three distinct
    containers of business logic, each with a designated responsibility, and we interact
    with them in different ways. When building object-oriented computer programs,
    developers think in the same manner, identifying and building the “blocks” that
    need to exist for a program to run.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象视为数字构建块是一种有用的思考方式。以电子表格软件如Excel为例。作为用户，我们可以区分工作簿、工作表和单元格之间的差异。工作簿包含工作表，工作表包含单元格，单元格包含值。我们将这三个实体视为三个不同的业务逻辑容器，每个容器都有指定的职责，并且我们以不同的方式与之交互。当构建面向对象的计算机程序时，开发者会以同样的方式思考，识别并构建程序运行所需的“块”。
- en: You’ll often hear the expression “Everything is an object” in the Python community.
    The statement means that the language implements all its data types, even simple
    ones such as numbers and text, as objects. Libraries like pandas add a new collection
    of objects—an additional set of building blocks—to the language.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python社区中，你经常会听到“万物皆对象”的表达。这个说法意味着该语言实现了所有数据类型，即使是像数字和文本这样的简单类型，也作为对象实现。像pandas这样的库添加了新的对象集合——一组额外的构建块——到语言中。
- en: As a data analyst turned software engineer, I’ve witnessed the Python proficiency
    requirements for many roles in the industry. I can state from experience that
    you do not need to be an advanced programmer to be productive with pandas. Basic
    understanding of Python’s core mechanics, however, will significantly accelerate
    the speed at which you can pick up the library. This appendix highlights the key
    language essentials you need to know to be successful.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名从数据分析师转变为软件工程师的人，我见证了行业内许多角色的Python熟练度要求。我可以从经验中提出，你不需要成为一名高级程序员就能有效地使用pandas。然而，对Python核心机制的基本理解将显著加快你掌握该库的速度。本附录强调了你需要了解的关键语言要素，以便取得成功。
- en: B.1 Simple data types
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.1 简单数据类型
- en: Data comes in a variety of types. A whole number like 5 is of a different type
    than a decimal number like 8.46\. Both 5 and 8.46 are different from a text value
    like `"Bob"`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 数据有多种类型。例如，整数5与十进制数8.46的类型不同。5和8.46都与文本值“Bob”不同。
- en: Let’s begin with an exploration of the core data types built into Python. Make
    sure that you’ve installed the Anaconda distribution and set up a `conda` environment
    that includes the Jupyter Notebook coding environment. If you need help, see the
    installation instructions in appendix A. Activate the `conda` environment you
    created for this book, execute the command `jupyter notebook`, and create a new
    Notebook.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索 Python 中内置的核心数据类型开始。确保您已安装 Anaconda 发行版，并设置了一个包含 Jupyter Notebook 编码环境的
    `conda` 环境。如果您需要帮助，请参阅附录 A 中的安装说明。激活为本书创建的 `conda` 环境，执行命令 `jupyter notebook`，并创建一个新的
    Notebook。
- en: 'A quick note before we start: in Python, the hashtag symbol (`#)` creates a
    comment. A *comment* is a line of text that Python ignores when it processes the
    code. Developers use comments to provide inline documentation for their code.
    Here’s an example:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前的一个快速提示：在 Python 中，井号符号（`#`）创建一个注释。一个*注释*是 Python 在处理代码时忽略的文本行。开发者使用注释为他们的代码提供内联文档。以下是一个示例：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can also add a comment after a piece of code. Python ignores everything
    after the hashtag symbol. The rest of the line executes normally:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在一段代码后面添加注释。Python 会忽略井号符号之后的所有内容。该行的其余部分会正常执行：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Although the previous example evaluates to 2, the next example produces no
    output. The comment effectively disables the line, so Python ignores the addition:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的例子计算结果为 2，但下一个例子不会产生任何输出。注释有效地禁用了该行，因此 Python 忽略了加法操作：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I’ve used comments in code cells throughout the book to provide supplemental
    commentary on the operations at hand. You do not need to copy the comments into
    your Jupyter Notebook.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本书中的代码单元中使用了注释，以提供对当前操作补充说明。您不需要将注释复制到您的 Jupyter Notebook 中。
- en: B.1.1 Numbers
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.1.1 数字
- en: 'An *integer* is a whole number; it has no fractional or decimal component.
    An example is 20:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*整数*是一个整数；它没有分数或小数部分。20 是一个例子：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'An integer can be any positive number, negative number, or zero. Negative numbers
    are prefixed by a minus sign (`-`):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个整数可以是任何正数、负数或零。负数前面有一个负号（`-`）：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A *floating-point number* (colloquially called a *float*) is a number with
    a fractional or decimal component. We use a dot to declare a decimal point. 7.349
    is an example of a float:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*浮点数*（俗称*浮点*）是一个带有分数或小数部分的数字。我们使用点来声明小数点。7.349 是一个浮点数的例子：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Integers and floating-point numbers represent different data types in Python
    or, equivalently, different objects. Look for the presence of a decimal point
    to distinguish between the two. The value `5.0` is a floating-point object, for
    example, whereas `5` is an integer object.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 整数和浮点数在 Python 中代表不同的数据类型，或者说代表不同的对象。通过查找小数点的存在来区分这两个。例如，`5.0` 是一个浮点对象，而 `5`
    是一个整数对象。
- en: B.1.2 Strings
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.1.2 字符串
- en: 'A *string* is a collection of zero or more text characters. We declare a string
    by wrapping a piece of text in a pair of single, double, or triple quotes. There
    are differences among the three options, but they are insignificant for beginners.
    We’ll be sticking with double quotes throughout the book. Jupyter Notebook’s output
    for the three syntax options is identical:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*字符串*是由零个或多个文本字符组成的集合。我们通过将一段文本包裹在单引号、双引号或三重引号中来声明一个字符串。这三个选项之间有区别，但对于初学者来说并不重要。本书中我们将坚持使用双引号。Jupyter
    Notebook 对三种语法选项的输出是相同的：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Strings are not limited to alphabetic characters; they can include digits,
    spaces, and symbols. Consider the next example, which includes seven alphabetic
    characters, a dollar sign, two digits, a space, and an exclamation point:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串不仅限于字母字符；它们可以包括数字、空格和符号。考虑下一个例子，它包括七个字母字符、一个美元符号、两个数字、一个空格和一个感叹号：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Use the presence of quotes to identify a string visually. Many beginners are
    confused by a value like `"5"`, which is a string that holds a single numeric
    character. `"5"` is not an integer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引号的存在来识别字符串。许多初学者对像 `"5"` 这样的值感到困惑，这是一个包含单个数字字符的字符串。`"5"` 不是一个整数。
- en: 'An *empty string* has no characters. We create it with a pair of quotes with
    nothing between them:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*空字符串*没有字符。我们通过在两个引号之间不放置任何内容来创建它：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The length of a string refers to the count of its characters. The string `"Monkey`
    `business"`, for example, has a length of 15 characters; there are six characters
    in `Monkey`, eight characters in `business`, and one space between the two words.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的长度指的是其字符的数量。例如，字符串 `"Monkey` `business"` 的长度为 15 个字符；其中 `Monkey` 有六个字符，`business`
    有八个字符，两个单词之间有一个空格。
- en: Python assigns a number to every string character based on its order in line.
    The number is called the *index*, and it starts counting from 0\. In the string
    `"car"`,
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Python 根据每个字符串字符在行中的顺序为其分配一个数字。这个数字称为*索引*，它从0开始计数。在字符串 `"car"` 中，
- en: '`"c"` is at index position 0.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"c"` 位于索引位置0。'
- en: '`"a"` is at index position 1.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"a"` 位于索引位置1。'
- en: '`"r"` is at index position 2.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"r"` 位于索引位置2。'
- en: A string’s final index position is always one less than its length. The string
    `"car"` has a length of 3, so its final index position is 2\. Zero-based indexes
    tend to confuse new developers; it’s a difficult mental shift to make because
    we have been taught since grade school to start counting from 1.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的最后一个索引位置总是比其长度少1。字符串 `"car"` 的长度为3，因此其最后一个索引位置是2。基于0的索引可能会让新开发者感到困惑；这是一个难以进行的心智转变，因为我们从小学就被教导从1开始计数。
- en: 'We can extract any character from a string by its index position. After the
    string, enter a pair of square brackets with the index value. The next example
    pulls out the `"h"` character in `"Python"`. The `"h"` character is the fourth
    character in sequence, so it has an index of 3:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过索引位置提取字符串中的任何字符。在字符串后，输入一对带有索引值的方括号。下一个示例提取了 `"Python"` 中的 `"h"` 字符。`"h"`
    字符是序列中的第四个字符，因此它的索引是3：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To pull from the end of the string, provide a negative value within the square
    brackets. A value of `-1` extracts the last character, `-2` extracts the second-to-last
    character, and so on. The next example targets the fourth-to-last character in
    Python, the `"t"`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字符串的末尾提取，在方括号内提供一个负值。`-1` 的值提取最后一个字符，`-2` 提取倒数第二个字符，依此类推。下一个示例针对 Python 中的第四个倒数字符，即
    `"t"`：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, `"Python"[2]` would yield the same `"t"` output.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`"Python"[2]` 会产生相同的 `"t"` 输出。
- en: We can use a special syntax to extract multiple characters from a string. The
    process is called *slicing*. Place two numbers inside the square brackets, separated
    by a colon. The left-side value sets the starting index. The right-side value
    sets the final index. The starting index is inclusive; Python includes the character
    at that index. The ending index is exclusive; Python excludes the character at
    that index. Tricky, I know.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用特殊的语法从字符串中提取多个字符。这个过程称为*切片*。在方括号内放置两个数字，用冒号分隔。左侧的值设置起始索引。右侧的值设置最终索引。起始索引是包含的；Python
    包含该索引处的字符。结束索引是不包含的；Python 不包含该索引处的字符。我知道这很棘手。
- en: 'The next example pulls all characters from index position 2 (inclusive) up
    to index position 5 (exclusive). The slice includes the characters `"t"` at index
    2, `"h"` at index 3, and `"o"` at index 4:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例从索引位置2（包含）到索引位置5（不包含）提取所有字符。切片包括索引位置2的 `"t"`、索引位置3的 `"h"` 和索引位置4的 `"o"`：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If 0 is the starting index, we can remove it from the square brackets and get
    the same result. Choose whatever syntax option fits you better:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果0是起始索引，我们可以从方括号中移除它并得到相同的结果。选择最适合你的语法选项：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here’s another shortcut: to extract characters from an index to the string’s
    end, remove the ending index. The following example shows two options for pulling
    out the characters from `"h"` (index 3) to the end of the `"Python"` string:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个快捷方式：要从一个索引提取到字符串的末尾，移除结束索引。以下示例显示了两种从 `"h"`（索引3）提取到 `"Python"` 字符串末尾字符的方法：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also remove both numbers. A single colon tells Python “Go from the beginning
    to the end.” The result is a copy of the string:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以移除两个数字。单个冒号告诉 Python “从开头到结尾。”结果是字符串的副本：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can mix and match positive and negative index positions in a string slice.
    Let’s pull from index 1 (`"y"`) up to the last character in the string (`"n"`):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在字符串切片中混合使用正索引和负索引位置。让我们从索引1（`"y"`) 提取到最后一个字符（`"n"`）：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also pass an optional third number to set the *step interval*—the gap
    to jump between every two index positions. The next example pulls out the characters
    from index positions 0 (inclusive) up to 6 (exclusive) in intervals of 2\. This
    slice includes the characters `"P"`, `"t"`, and `"o"`, which are at index positions
    0, 2, and 4:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以传递一个可选的第三个数字来设置*步长间隔*——两个索引位置之间的间隔。下一个示例以2的间隔从索引位置0（包含）到6（不包含）提取字符。这个切片包括索引位置0的
    `"P"`、索引位置2的 `"t"` 和索引位置4的 `"o"`：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here’s a cool trick: we can pass in -1 as the third number to proceed backward
    from the end of the list to the beginning. The result is a reversed string:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个酷技巧：我们可以将-1作为第三个数字传递，以便从列表的末尾向前推进到开头。结果是反转的字符串：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Slicing comes in handy for extracting snippets of text from larger strings—a
    topic we cover extensively in chapter 6.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 切片对于从较大的字符串中提取文本片段非常有用——这是我们在第 6 章中详细讨论的主题。
- en: B.1.3 Booleans
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.1.3 布尔
- en: 'The *Boolean* data type represents the logical idea of truth. It can be only
    one of two values: `True` or `False.` The Boolean is named after English mathematician
    and philosopher George Boole. It usually models an either-or relationship: yes
    or no, on or off, valid or invalid, active or inactive, and so on.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*布尔* 数据类型代表逻辑上的真值概念。它只能有两个值之一：`True` 或 `False`。布尔数据类型是以英国数学家和哲学家乔治·布尔的名字命名的。它通常表示一种非此即彼的关系：是或否，开或关，有效或无效，活跃或非活跃，等等。'
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We often arrive at a Boolean data type through a calculation or comparison,
    which we’ll see in section B.2.2.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常通过计算或比较得到布尔数据类型，我们将在 B.2.2 节中看到。
- en: B.1.4 The None object
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.1.4 `None` 对象
- en: The `None` object represents nothingness or the absence of a value. Like a Boolean,
    it’s a tricky type to wrap our heads around because it’s more abstract than a
    concrete value such as an integer.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`None` 对象代表无或值的缺失。与布尔类型一样，这是一个难以理解的概念，因为它比整数等具体值更抽象。'
- en: 'Suppose that we decide to measure our town’s daily temperature for a week but
    forget to take a reading on Friday. The temperatures for six of the seven days
    would be integers. How could we log the temperature for the missing day? We might
    enter something like “missing” or “unknown” or “null”. The `None` object models
    the same idea in Python. The language needs something to communicate the absence
    of a value. It requires an object that stands in and announces that a value is
    missing, does not exist, or is not needed. Jupyter Notebook outputs nothing when
    we execute a cell with `None`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们决定测量我们城镇一周的每日气温，但忘记了在星期五进行测量。七天的气温中有六天是整数。我们如何记录缺失的那一天的气温？我们可能会输入“缺失”、“未知”或“null”。在
    Python 中，`None` 对象模拟了同样的概念。语言需要某种东西来传达值的缺失。它需要一个对象来代表并宣布值是缺失的、不存在的或不需要的。当我们执行包含
    `None` 的单元格时，Jupyter Notebook 不会输出任何内容：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As with a Boolean, we’ll usually arrive at a `None` value rather than create
    it manually. We’ll explore the object in greater detail as we work through the
    book.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与布尔类型一样，我们通常会得到一个 `None` 值，而不是手动创建它。随着我们阅读本书，我们将更详细地探讨该对象。
- en: B.2 Operators
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.2 运算符
- en: 'An *operator* is a symbol that performs an operation. One classic example from
    elementary school is the addition operator: the plus sign (+). The values that
    an operator works on are called *operands*. In the expression 3 + 5,'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*运算符* 是执行操作的符号。一个经典的例子来自小学的加法运算符：加号 (+)。运算符作用的值称为 *操作数*。在表达式 3 + 5 中，'
- en: + is the operator.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: + 是运算符。
- en: 3 and 5 are the operands.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 和 5 是操作数。
- en: In this section, we’ll explore the various mathematical and logical operators
    built into Python.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Python 中内置的各种数学和逻辑运算符。
- en: B.2.1 Mathematical operators
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.2.1 数学运算符
- en: 'Let’s write out the mathematical expression from the introduction. Jupyter
    will output the calculation directly below the cell:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写出介绍中的数学表达式。Jupyter 将直接在单元格下方输出计算结果：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is conventional to add a space on both sides of an operator to make the
    code easier to read. The next two examples illustrate subtraction (`-`) and multiplication
    (`*`):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在运算符两侧添加空格是一种惯例，可以使代码更容易阅读。接下来的两个示例说明了减法 (`-`) 和乘法 (`*`)：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`**` is the exponentiation operator. The next example raises 3 to the power
    of 5 (3 multiplied by itself 5 times):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`**` 是指数运算符。下一个示例将 3 提到 5 次幂（3 自身乘以 5 次）：'
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `/` symbol performs division. The next example divides 3 by 5:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`/` 符号执行除法。下一个示例将 3 除以 5：'
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In mathematical terminology, the *quotient* is the result of dividing one number
    by another. Division with the `/` operator always returns a floating-point quotient,
    even if the divisor fits evenly into the dividend:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学术语中，*商* 是一个数除以另一个数的结果。使用 `/` 运算符的除法始终返回一个浮点数商，即使除数可以整除被除数：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Floor division* is an alternative type of division that removes the decimal
    remainder from a quotient. It requires two forward slashes (`//`) and returns
    an integer quotient. The next example demonstrates the differences between the
    two operators:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*地板除法* 是一种替代的除法类型，它会从商中移除小数余数。它需要两个正斜杠 (`//`)，并返回一个整数商。下一个示例演示了这两个运算符之间的区别：'
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The *modulo* operator (`%`) returns the remainder of a division. 2 is the remainder
    when 5 is divided by 3:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*取模* 运算符 (`%`) 返回除法的结果余数。当 5 除以 3 时，2 是余数：'
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can also use the addition and multiplication operators with strings. The
    plus sign joins two strings. The technical word for this process is *concatenation*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用加法和乘法运算符与字符串。加号用于连接两个字符串。这个过程的技术术语是 *连接*。
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The multiplication sign repeats a string a given number of times:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 乘号会重复字符串给定次数：
- en: '[PRE28]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: An object’s type determines the operations and operators that it supports. We
    can divide integers, for example, but we cannot divide strings. The primary skill
    in OOP is identifying the object you’re working with and the actions it can perform.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的类型决定了它支持的运算符和操作。例如，我们可以除以整数，但不能除以字符串。面向对象编程的主要技能是识别你正在处理的对象以及它可以执行的操作。
- en: We can concatenate a string to another string, and we can add a number to another
    number. But what happens when we try to add a string and a number?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个字符串连接到另一个字符串，我们也可以将一个数字加到另一个数字上。但当我们尝试将一个字符串和一个数字相加时会发生什么？
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Uh-oh. This example is our first exposure to a Python error—one of several dozen
    built into the language. The technical name for an error is an *exception*. Like
    everything else in Python, an exception is an object. Whenever we make a syntactical
    or logical mistake, Jupyter Notebook displays an analysis that includes the name
    of the error and the line number that triggered it. The technical term *raise*
    is often used to indicate that Python encountered an exception. We could say,
    “I tried to add a number and a string, and Python raised an exception.”
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀。这是我们第一次接触到 Python 错误——语言中内置的几十种错误之一。错误的技术名称是 *异常*。像 Python 中的其他一切一样，异常也是一个对象。每当我们在语法或逻辑上犯错误时，Jupyter
    Notebook 会显示一个分析，其中包括错误的名称和触发它的行号。技术术语 *raise* 常用来表示 Python 遇到了异常。我们可以这样说：“我尝试将一个数字和一个字符串相加，Python
    抛出了一个异常。”
- en: Python raises a `TypeError` exception when we use a wrong data type in an operation.
    In the preceding example, Python observed a number and a plus sign, and assumed
    that another number would follow. Instead, it received a string, which it cannot
    add to an integer. We’ll see how we can convert an integer to a string (and vice
    versa) in section B.4.1.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在操作中使用错误的数据类型时，Python 会抛出一个 `TypeError` 异常。在上面的示例中，Python 观察到一个数字和一个加号，并假设将跟随另一个数字。然而，它接收到一个字符串，它无法将字符串添加到整数中。我们将在
    B.4.1 节中看到如何将整数转换为字符串（反之亦然）。
- en: B.2.2 Equality and inequality operators
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.2.2 等于和不等于运算符
- en: Python considers two objects to be equal if they hold the same value. We can
    compare the equality of two objects by placing them on opposite sides of the equality
    operator (`==`). The operator returns `True` if the two objects are equal. As
    a reminder, `True` is a Boolean value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Python 认为两个对象相等，如果它们持有相同的值。我们可以通过将它们放在等于运算符的两侧来比较两个对象的相等性（`==`）。如果两个对象相等，则运算符返回
    `True`。提醒一下，`True` 是一个布尔值。
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Be careful: the equality operator has two equal signs. Python reserves a single
    equal sign for a completely different operation that we’ll cover in section B.3.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 小心：等于运算符有两个等号。Python 为一个完全不同的操作保留了单个等号，我们将在 B.3 节中介绍。
- en: 'The equality operator returns `False` if the two objects are unequal. `True`
    and `False` are the only valid values for Booleans:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个对象不相等，等于运算符返回 `False`。`True` 和 `False` 是布尔值的有效值：
- en: '[PRE31]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here are some examples of the equality operator with strings:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些等于运算符与字符串的示例：
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Case sensitivity matters when comparing two strings. In the next example, one
    string starts with a capital `"H"`, and the other starts with a lowercase `"h"`,
    so Python considers the two strings to be unequal:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较两个字符串时，大小写敏感很重要。在下一个示例中，一个字符串以大写 `"H"` 开头，而另一个以小写 `"h"` 开头，因此 Python 认为这两个字符串不相等：
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The inequality operator (`!=`) is the inverse of the equality operator; it
    returns `True` if two objects are unequal. It is `True`, for example, that 10
    is not equal to 20:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 不等于运算符（`!=`）是等于运算符的逆运算；如果两个对象不相等，则返回 `True`。例如，10 不等于 20：
- en: '[PRE34]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Similarly, the string `"Hello"` is not equal to the string `"Goodbye"`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，字符串 `"Hello"` 不等于字符串 `"Goodbye"`：
- en: '[PRE35]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The inequality operator returns `False` if the two objects are equal:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个对象相等，不等于运算符返回 `False`：
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Python supports mathematical comparisons between numbers. The `<` operator
    checks whether the operand on the left side is smaller than the operand on the
    right side. The next example checks whether -5 is less than 3:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持数字之间的数学比较。`<` 运算符检查左侧的操作数是否小于右侧的操作数。以下示例检查 -5 是否小于 3：
- en: '[PRE37]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `>` operator checks whether the operand on the left side is greater than
    the operand on the right side. The next example evaluates whether 5 is greater
    than 7; the result is `False`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`>`运算符检查左侧的操作数是否大于右侧的操作数。下一个示例评估5是否大于7；结果是`False`。'
- en: '[PRE38]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `<=` operand checks whether the left-side operand is less than or equal
    to the right-side operand. Here, we check whether 11 is less than or equal to
    11:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`<=`操作符检查左侧操作数是否小于或等于右侧操作数。在这里，我们检查11是否小于或等于11：'
- en: '[PRE39]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The complementary `>=` operand checks whether the left-side operand is greater
    than or equal to the right-side operand. The next example checks whether 4 is
    greater than or equal to 5:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 相补的`>=`操作符检查左侧操作数是否大于或等于右侧操作数。下一个示例检查4是否大于或等于5：
- en: '[PRE40]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Pandas enables us to apply comparisons like these to whole columns of data,
    a topic we cover in chapter 5.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas使我们能够将这些比较应用于整个数据列，这是我们在第5章中讨论的主题。
- en: B.3 Variables
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.3 变量
- en: A *variable* is a name we assign to an object; we can compare it with the address
    of a house, because it is a label, a reference, and an identifier. Variable names
    should be clear and descriptive, describing the data that the object is storing
    and the purpose it serves in our application. `revenues_for_quarter4` is a better
    variable name than `r` or `r4`, for example.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量*是我们分配给对象的名称；我们可以将其与房屋地址进行比较，因为它是标签、引用和标识符。变量名应该是清晰且描述性的，描述对象存储的数据以及它在我们的应用程序中扮演的用途。例如，`revenues_for_quarter4`比`r`或`r4`更好的变量名。'
- en: 'We assign a variable to an object with the assignment operator, a single equal
    sign (`=`). The next example assigns four variables (`name`, `age`, `high_school_gpa`,
    and `is_handsome`) to four different data types (string, integer, floating-point,
    and Boolean):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用赋值运算符（单个等号`=`）将变量赋给对象。下一个示例将四个变量（`name`、`age`、`high_school_gpa`和`is_handsome`）赋给四种不同的数据类型（字符串、整数、浮点数和布尔值）：
- en: '[PRE41]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The execution of a cell with a variable assignment does not yield any output
    in Jupyter Notebook, but afterward we are able to use the variable in any cell
    in the Notebook. The variable is a substitute for the value it holds:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jupyter Notebook中，对带有变量赋值的单元格执行不会产生任何输出，但之后我们可以在笔记本中的任何单元格中使用该变量。变量是它所持有值的替代品：
- en: '[PRE42]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: A variable name must start with a letter or an underscore. After the first letter,
    it can hold only letters, numbers, or underscores.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名必须以字母或下划线开头。在第一个字母之后，它只能包含字母、数字或下划线。
- en: 'As their name suggests, variables can hold values that vary over a program’s
    execution. Let’s reassign the `age` variable to a new value of `35`. After we
    execute the cell, the `age` variable’s reference to its former value, `28`, will
    be lost:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如它们的名称所暗示的，变量可以存储在程序执行过程中变化的值。让我们将`age`变量重新赋值为新的值`35`。在我们执行单元格之后，`age`变量对其先前值`28`的引用将丢失：
- en: '[PRE43]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can use the same variable on both sides of the assignment operator. Python
    always evaluates the right side of the equal sign first. In the next example,
    Python adds the value of `age` at the start of the cell’s execution, `35`, to
    `10`. The resulting sum, `45`, is saved to the `age` variable:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在赋值运算符的两侧使用相同的变量。Python始终首先评估等号右侧的值。在下一个示例中，Python将单元格执行开始时`age`的值`35`加到`10`上。得到的总和`45`被保存到`age`变量中：
- en: '[PRE44]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Python is a *dynamically typed* language, which means that variables do not
    know anything about data types. A variable is a placeholder name for any object
    in the program. Only the object knows its data type. Therefore, we can reassign
    variables from an object of one type to another. The next example reassigns the
    `high_school_gpa` variable from its original floating-point value of `3.7` to
    a string of `"A+"`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种*动态类型*语言，这意味着变量对数据类型一无所知。变量是程序中任何对象的占位符名称。只有对象知道它的数据类型。因此，我们可以将变量从一种类型重新赋值到另一种类型。下一个示例将`high_school_gpa`变量从其原始的浮点值`3.7`重新赋值为字符串`"A+"`：
- en: '[PRE45]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Python raises a `NameError` exception when a variable does not exist in the
    program:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序中不存在变量时，Python会引发`NameError`异常：
- en: '[PRE46]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You’ll typically encounter a `NameError` exception when you mistype a variable
    name. This exception is nothing to fear; correct the spelling, and execute the
    cell again.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当你误拼变量名时，通常会遇到`NameError`异常。这种异常不必害怕；更正拼写，然后再次执行单元格。
- en: B.4 Functions
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.4 函数
- en: A *function* is a procedure consisting of one or more steps. Think of a function
    as being a cooking recipe in a programming language—a series of instructions that
    yields a consistent result. Functions enable reusability in software. Because
    a function captures a piece of business logic from start to finish, we can reuse
    it when we have to perform the same operation multiple times.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *函数* 是由一个或多个步骤组成的程序。将函数想象成编程语言中的烹饪食谱——一系列产生一致结果的指令。函数使软件具有可重用性。因为函数从开始到结束捕获了一部分业务逻辑，所以当我们需要多次执行相同的操作时，我们可以重用它。
- en: We declare a function and then execute it. In the declaration, we write the
    steps that the function should take. In the execution, we run the function. Sticking
    to our cooking analogy, declaring a function is equivalent to writing down a recipe,
    and executing a function is equivalent to cooking the recipe. The technical term
    for executing a function is *calling* it or *invoking* it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个函数然后执行它。在声明中，我们写下函数应该采取的步骤。在执行中，我们运行函数。按照我们的烹饪类比，声明一个函数相当于写下食谱，执行一个函数相当于烹饪食谱。执行函数的技术术语是
    *调用* 或 *调用*。
- en: B.4.1 Arguments and return values
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.4.1 参数和返回值
- en: Python ships with more than 65 built-in functions. We can also declare our own
    custom functions. Let’s dive into an example. The built-in `len` function returns
    the length of a given object. The concept of length varies from data type to data
    type; for a string, it’s a count of its characters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Python 随带提供了超过 65 个内置函数。我们也可以声明我们自己的自定义函数。让我们深入一个例子。内置的 `len` 函数返回给定对象的长度。长度的概念因数据类型而异；对于字符串，它是字符的计数。
- en: We invoke a function by entering its name and a pair of opening and closing
    parentheses. Much as a cooking recipe can accept ingredients, a function invocation
    can accept inputs called *arguments*. We pass arguments sequentially inside the
    parentheses, separated by commas.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过输入函数名和一对开闭括号来调用一个函数。就像烹饪食谱可以接受配料一样，函数调用可以接受称为 *参数* 的输入。我们按顺序在括号内传递参数，参数之间用逗号分隔。
- en: 'The `len` function expects one argument: the object whose length it should
    calculate. The next example passes a string argument of `"Python` `is` `fun"`
    to the function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`len` 函数期望一个参数：它应该计算长度的对象。下一个示例将 `"Python` `is` `fun"` 字符串参数传递给函数：'
- en: '[PRE47]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: A cooking recipe produces a final output of a meal. Similarly, a Python function
    produces a final output called a *return value*. In the preceding example, `len`
    was the invoked function, `"Python` `is` `fun"` was its single argument, and `13`
    was the return value.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 烹饪食谱产生最终输出——一顿饭。同样，Python 函数产生一个称为 *返回值* 的最终输出。在上一个示例中，`len` 是被调用的函数，`"Python`
    `is` `fun"` 是它的单个参数，`13` 是返回值。
- en: That’s all there is to it! A function is a procedure that is invoked with zero
    or more arguments and produces a return value.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！函数是一个可以调用零个或多个参数并产生返回值的程序。
- en: 'Here are three more popular built-in functions in Python:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Python 中三个更受欢迎的内置函数：
- en: '`int`, which converts its argument to an integer'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`，它将它的参数转换为整数'
- en: '`float`, which converts its argument to a floating-point number'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`，它将它的参数转换为浮点数'
- en: '`str`, which converts its argument to a string'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str`，它将它的参数转换为字符串'
- en: The next three examples showcase these functions in action. The first example
    invokes the `int` function with a string argument of `"20"` and produces a return
    value of `20`. Can you identify the arguments and return values for the remaining
    two functions?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下三个示例展示了这些函数的实际应用。第一个示例使用 `"20"` 字符串参数调用 `int` 函数，并产生返回值 `20`。你能识别剩余两个函数的参数和返回值吗？
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here’s another common error: Python raises a `ValueError` exception when a
    function receives an argument with the right data type but an inappropriate value.
    In the next example, the `int` function receives a string (an appropriate type),
    but the string is one from which it is impossible to extract an integer:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个常见的错误：当函数接收到正确数据类型但不适用的值时，Python 会抛出一个 `ValueError` 异常。在下一个示例中，`int` 函数接收了一个字符串（一个合适的类型），但这个字符串无法从中提取出整数：
- en: '[PRE49]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Another popular built-in function is `print`, which outputs text to the screen.
    It accepts any number of arguments. The function often proves to be helpful when
    we want to observe a variable’s value throughout a program’s execution. The next
    example invokes the `print` function four times with the `value` variable, whose
    value changes several times:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的内置函数是 `print`，它将文本输出到屏幕。它接受任意数量的参数。当我们在程序执行过程中想要观察变量的值时，该函数通常非常有用。下一个示例四次调用
    `print` 函数，使用 `value` 变量，其值变化了几次：
- en: '[PRE50]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If a function accepts multiple arguments, we must separate every two subsequent
    ones with a comma. Developers often add a space after the comma for readability.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数接受多个参数，我们必须用逗号分隔每两个后续参数。开发者经常在逗号后添加一个空格以提高可读性。
- en: 'When we pass the `print` function multiple arguments, it outputs all of them
    in sequence. In the next example, notice that Python separates the three printed
    elements with a space:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向 `print` 函数传递多个参数时，它会按顺序输出所有参数。在下一个示例中，请注意 Python 使用空格分隔三个打印的元素：
- en: '[PRE51]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: A *parameter* is a name given to an expected function argument. Each argument
    in an invocation corresponds to a parameter. In previous examples, we passed in
    arguments to the `print` function sequentially without specifying their parameter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数**是为预期函数参数赋予的名称。调用中的每个参数都对应一个参数。在之前的示例中，我们向 `print` 函数传递了参数，但没有指定它们的参数。'
- en: 'We have to write parameter names out explicitly for certain arguments. The
    `print` function’s `sep` (separator) parameter, for example, customizes the string
    that Python inserts between every two printed values. We have to explicitly write
    out the `sep` parameter if we’d like to pass it a custom argument. We assign an
    argument to a function’s keyword parameter with an equal sign. The next example
    outputs the same three strings but instructs the `print` function to separate
    them with exclamation points:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些参数，我们必须明确写出参数名称。例如，`print` 函数的 `sep`（分隔符）参数自定义 Python 在每个打印值之间插入的字符串。如果我们想传递一个自定义参数，我们必须明确写出
    `sep` 参数。我们使用等号将参数分配给函数的关键字参数。下一个示例输出相同的三个字符串，但指示 `print` 函数用感叹号分隔它们：
- en: '[PRE52]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Let’s come back to the example before the last one. Why were the three values
    printed with a space in between every two subsequent values?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到上一个示例之前。为什么三个值之间用空格隔开？
- en: 'A *default argument* is a fallback value that Python passes to a parameter
    if the function invocation does not explicitly provide one. The `sep` parameter
    to the `print` function has a default argument of `" "`. If we invoke the `print`
    function without an argument for the `sep` parameter, Python will automatically
    pass in a string with one space. The following two lines of code produce the same
    output:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数是一个后备值，当函数调用没有明确提供一个值时，Python会将它传递给参数。`print` 函数的 `sep` 参数有一个默认参数 `" "`。如果我们调用
    `print` 函数而没有为 `sep` 参数提供参数，Python 将自动传递一个包含一个空格的字符串。以下两行代码产生相同的输出：
- en: '[PRE53]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We call parameters like `sep` *keyword arguments***.** We have to write their
    specific parameter name when passing arguments to them. Python requires us to
    pass keyword arguments after sequential arguments. Here’s another example of a
    `print` function invocation that passes a different string argument to the `sep`
    parameter:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称像 `sep` 这样的参数为**关键字参数**。在传递参数时，我们必须写出它们的特定参数名称。Python 要求我们在传递顺序参数之后传递关键字参数。以下是一个
    `print` 函数调用的另一个示例，它向 `sep` 参数传递了不同的字符串参数：
- en: '[PRE54]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `print` function’s `end` parameter customizes the string Python adds to
    the end of all output. The parameter’s default argument is `"\n"`, a special character
    that Python recognizes as a line break. In the next example, we explicitly pass
    the same `"\n"` argument to the `end` parameter:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 函数的 `end` 参数自定义 Python 添加到所有输出末尾的字符串。该参数的默认参数是 `"\n"`，这是一个 Python 识别为换行符的特殊字符。在下一个示例中，我们明确地将相同的
    `"\n"` 参数传递给 `end` 参数：'
- en: '[PRE55]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can pass multiple keyword arguments to a function invocation. The technical
    rules still apply: separate every two arguments with a comma. The next example
    invokes the `print` function twice. The first invocation separates its three arguments
    with a `"!"` and ends the output with a `"***"`. Because the first invocation
    does not force a line break, the second invocation’s output continues where the
    first one concludes:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在函数调用中传递多个关键字参数。技术规则仍然适用：用逗号分隔每两个参数。下一个示例两次调用了 `print` 函数。第一次调用用 `"!"` 分隔其三个参数，并以
    `"***"` 结束输出。因为第一次调用没有强制换行，所以第二次调用的输出从第一个调用结束的地方继续：
- en: '[PRE56]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Take a second to reflect on the code formatting in the preceding example. Long
    lines of code can be difficult to read, especially when we clump multiple parameters
    together. The Python community favors several formatting solutions. One option
    is placing all arguments on a separate line:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请花点时间思考一下前面示例中的代码格式。长行代码可能难以阅读，尤其是当我们把多个参数放在一起时。Python 社区倾向于几种格式化解决方案。一个选项是将所有参数放在单独的一行上：
- en: '[PRE57]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Another option is adding a line break between arguments:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是在参数之间添加换行符：
- en: '[PRE58]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: All three of these code samples are technically valid. There are multiple ways
    to format Python code. I use several formatting options throughout the book. My
    ultimate goal is readability. You do not have to follow the formatting conventions
    I use. I will do my best to communicate which differences are technical and which
    ones are aesthetic.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个代码示例在技术上都是有效的。Python 代码的格式化有多种方式。我在整本书中使用了多种格式化选项。我的最终目标是可读性。你不必遵循我使用的格式化约定。我会尽我所能说明哪些差异是技术性的，哪些是美学的。
- en: B.4.2 Custom functions
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.4.2 自定义函数
- en: We can declare custom functions in our programs. The goal of a function is to
    capture a distinct piece of business logic in a single, reusable procedure. A
    common mantra in software engineering circles is *DRY*, an acronym for *don’t
    repeat yourself*. This acronym is a warning that duplication of the same logic
    or behavior can lead to an unstable program. The more places you repeat code,
    the more places you have to edit if requirements change. A function solves the
    DRY problem.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在程序中声明自定义函数。函数的目标是将一个独特的业务逻辑捕获在单一、可重用的过程中。软件工程领域的一个常见格言是 *DRY*，它是 *不要重复自己*
    的缩写。这个缩写是一个警告，表明重复相同的逻辑或行为可能导致程序不稳定。你重复代码的地方越多，如果需求发生变化，你需要编辑的地方就越多。函数解决了 DRY
    问题。
- en: Let’s explore an example. Suppose that we are meteorologists working with weather
    data. Our work requires us to convert temperatures in our program from Fahrenheit
    to Celsius. There is a simple, consistent formula to the conversion. Writing a
    function to convert *one* temperature from °F to °C is a good idea because we
    can isolate the conversion logic and reuse it as needed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例。假设我们是气象学家，正在处理天气数据。我们的工作要求我们在程序中将温度从华氏度转换为摄氏度。转换有一个简单、一致的公式。编写一个函数来将
    *一个* 温度从华氏度转换为摄氏度是个好主意，因为我们可以隔离转换逻辑并在需要时重复使用它。
- en: 'We begin a function definition with the `def` keyword. We follow `def` with
    the function’s name, a pair of opening and closing parentheses, and a colon. Function
    names and variable names with multiple words follow a `snake_case` naming convention.
    The convention separates every two words with an underscore, which causes the
    name to resemble a snake. Let’s call our function `convert_to_fahrenheit`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一个 `def` 关键字开始函数定义。我们在 `def` 后面跟函数的名称，一对开括号和闭括号，以及一个冒号。多单词的函数名和变量名遵循 `snake_case`
    命名约定。这个约定将每两个单词用下划线分隔，使得名称看起来像蛇。让我们称我们的函数为 `convert_to_fahrenheit`：
- en: '[PRE59]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To review, a *parameter* is a name for an expected function argument. We want
    the `convert_to_fahrenheit` function to accept a single parameter: a Celsius temperature.
    Let’s call the parameter `celsius_temp`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了复习，一个 *参数* 是一个预期函数参数的名称。我们希望 `convert_to_fahrenheit` 函数接受一个单一参数：摄氏温度。让我们称这个参数为
    `celsius_temp`：
- en: '[PRE60]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If we define a parameter when we declare a function, we must pass an argument
    for that parameter when invoking it. Thus, we must always provide a value for
    `celsius_ temp` whenever we run `convert_to_fahrenheit`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在声明函数时定义了一个参数，那么在调用它时必须为该参数传递一个参数。因此，每次运行 `convert_to_fahrenheit` 时，我们都必须为
    `celsius_temp` 提供一个值。
- en: 'Our next step is defining what the function does. We declare a function’s steps
    in its body, an indented section of code below its name. Python uses indentation
    to establish relationships between constructs in the program. A function’s body
    is an example of a *block*, a section of code nested within another section of
    code. According to PEP-8,[¹](#pgfId-1109604) the Python community’s style guide,
    we should indent each line in a block with four spaces:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是定义函数的功能。我们在函数体中声明函数的步骤，这是位于其名称下方的一个缩进代码部分。Python 使用缩进来建立程序中构造之间的关系。函数体是
    *块* 的一个例子，它是嵌套在另一个代码部分中的代码段。根据 PEP-8[¹](#pgfId-1109604)，Python 社区的风格指南，我们应该使用四个空格来缩进块中的每一行：
- en: '[PRE61]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We can use a function’s parameters in its body. In our example, we can use the
    `celsius_temp` parameter anywhere in the body of the `convert_to_fahrenheit` function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在函数体中使用函数的参数。在我们的例子中，我们可以在 `convert_to_fahrenheit` 函数的任何地方使用 `celsius_temp`
    参数。
- en: We can declare variables in a function body. These variables are called *local
    variables* because they are bound to the scope of the function execution. Python
    throws local variables out of memory as soon as the function is done running.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在函数体中声明变量。这些变量被称为 *局部变量*，因为它们绑定到函数执行的范围内。Python 在函数运行完成后立即将局部变量从内存中移除。
- en: 'Let’s write out the logic for the conversion! The formula to convert a Celsius
    temperature to Fahrenheit is to multiply it by 9/5 and add 32:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写出转换的逻辑！将摄氏温度转换为华氏温度的公式是将它乘以 9/5 并加 32：
- en: '[PRE62]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'At this juncture, our function correctly calculates the Fahrenheit temperature,
    but it does not send the evaluation back to the main program. We need to use the
    `return` keyword to mark the Fahrenheit temperature as the final output of the
    function. We are returning it to the outside world:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的函数正确地计算了华氏温度，但它并没有将评估结果发送回主程序。我们需要使用 `return` 关键字来标记华氏温度为函数的最终输出。我们将它返回到外部世界：
- en: '[PRE63]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Our function is complete, so let’s test it! We invoke custom functions with
    a pair of parentheses, the same syntax we use for Python’s built-in functions.
    The next example invokes the `convert_to_fahrenheit` function with a sample argument
    of `10`. Python runs through the function body with the `celsius_temp` parameter
    set to `10`. The function returns a value of `50.0`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的功能已经完成，现在让我们来测试它！我们使用一对括号来调用自定义函数，这与我们用于 Python 内置函数的语法相同。下一个示例使用 `10` 作为样本参数调用了
    `convert_to_fahrenheit` 函数。Python 将 `celsius_temp` 参数设置为 `10` 并运行函数体。该函数返回值为 `50.0`：
- en: '[PRE64]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can provide keyword arguments instead of positional ones. The next example
    writes the `celsius_temp` parameter name out explicitly. The following code is
    equivalent to the preceding code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供关键字参数而不是位置参数。下一个示例明确写出了 `celsius_temp` 参数的名称。以下代码与前面的代码等效：
- en: '[PRE65]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Although they are not required, keyword arguments help add clarity to our program.
    The preceding example better communicates what the `convert_to_fahrenheit` function’s
    input represents.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们不是必需的，但关键字参数有助于使我们的程序更清晰。前面的示例更好地说明了 `convert_to_fahrenheit` 函数的输入代表什么。
- en: B.5 Modules
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.5 模块
- en: A *module* is a single Python file. The Python *standard library* is a collection
    of more than 250 modules built into the language to accelerate productivity. The
    modules assist with technical operations such as mathematics, audio analysis,
    and URL requests. To reduce a program’s memory consumption, Python does not load
    these modules by default. We have to import the specific modules we want manually
    when our program requires them.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *模块* 是一个单独的 Python 文件。Python 的 *标准库* 是一个包含超过 250 个模块的语言集合，这些模块内置到语言中以加速生产力。这些模块帮助进行技术操作，如数学、音频分析和
    URL 请求。为了减少程序的内存消耗，Python 默认不会加载这些模块。当我们的程序需要时，我们必须手动导入我们想要的特定模块。
- en: 'The syntax to import built-in modules and external packages is identical: enter
    the `import` keyword, followed by the module or package’s name. Let’s import Python’s
    `datetime` module, which helps us work with dates and times:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 导入内置模块和外部包的语法是相同的：输入 `import` 关键字，然后是模块或包的名称。让我们导入 Python 的 `datetime` 模块，它帮助我们处理日期和时间：
- en: '[PRE66]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'An *alias* is an alternative name for an import—a shortcut that we can assign
    to a module so we don’t have to write out its complete name when we reference
    it. The alias is technically up to us, but certain nicknames have established
    themselves as favorites among Python developers. A popular alias for the `datetime`
    module, for example, is `dt`. We assign aliases with the `as` keyword:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*别名* 是导入的替代名称——一个我们可以分配给模块的快捷方式，这样在引用它时就不必写出其完整名称。别名实际上取决于我们，但某些昵称已经在 Python
    开发者中确立了自己作为最受欢迎的。例如，`datetime` 模块的流行别名是 `dt`。我们使用 `as` 关键字来分配别名：'
- en: '[PRE67]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now we can reference the module with `dt` instead of `datetime`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以用 `dt` 而不是 `datetime` 来引用模块。
- en: B.6 Classes and objects
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.6 类和对象
- en: All the data types that we’ve explored so far—integers, floats, Booleans, strings,
    exceptions, functions, and even modules—are objects. An *object* is a digital
    data structure, a container for storing, accessing, and manipulating a type of
    data.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止探索的所有数据类型——整数、浮点数、布尔值、字符串、异常、函数，甚至模块——都是对象。*对象* 是一种数字数据结构，用于存储、访问和操作一种类型的数据。
- en: A *class* is a blueprint for creating objects. Think of it as being a schematic
    or template from which Python builds the objects.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*类* 是创建对象的蓝图。将其视为一个图表或模板，Python 从中构建对象。'
- en: We call an object constructed from a class an *instance* of the class. The act
    of creating an object from a class is called *instantiation*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称从类构建的对象为该类的 *实例*。从类创建对象的行为称为 *实例化*。
- en: 'Python’s built-in `type` function returns the class of the object we pass in
    as an argument. The next example invokes the `type` function twice with two different
    strings: `"peanut` `butter"` and `"jelly"`. Although their content is unequal,
    the strings are made from the same blueprint, the same class, the `str` class.
    They are both strings:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的内置 `type` 函数返回我们作为参数传递给它的对象的类。下一个例子两次调用 `type` 函数，使用两个不同的字符串：`"peanut
    butter"` 和 `"jelly"`。尽管它们的内容不同，但这两个字符串是由相同的蓝图、相同的类、`str` 类构建的。它们都是字符串：
- en: '[PRE68]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: These examples are fairly simple. The `type` function is helpful when we are
    unsure what kind of object we’re working with. If we invoke a custom function
    and are unsure what type of object it returns, we can pass its return value to
    `type` to find out.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子相当简单。当我们不确定正在处理什么类型的对象时，`type` 函数很有帮助。如果我们调用一个自定义函数并且不确定它返回什么类型的对象，我们可以将它的返回值传递给
    `type` 来找出。
- en: A *literal* is a shorthand syntax that creates an object from a class. One example
    we’ve encountered so far is double quotes, which create strings (`"hello"`)`.`
    For more-complex objects, we need to use a different creation process.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*字面量* 是创建从类创建对象的简写语法。我们迄今为止遇到的一个例子是双引号，它创建字符串（`"hello"`）。对于更复杂的对象，我们需要使用不同的创建过程。'
- en: The `datetime` module we imported in section B.5 has a `date` class that models
    a date in time. Suppose that we’re trying to represent Leonardo da Vinci’s birthday,
    April 15, 1452, as a `date` object.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 B.5 节中导入的 `datetime` 模块有一个 `date` 类，它模拟时间中的日期。假设我们正在尝试将列奥纳多·达·芬奇的生日，1452 年
    4 月 15 日，表示为一个 `date` 对象。
- en: 'To create an instance from a class, write the class name followed by a pair
    of parentheses. `date``()`, for example, creates a `date` object from the `date`
    class. The syntax is identical to invoking a function. When instantiating an object,
    we can sometimes pass arguments to the constructor, the function that creates
    the objects. The first three arguments to the `date` constructor represent the
    year, month, and day the `date` object will hold. The three arguments are required:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要从类创建一个实例，写上类名后跟一对括号。例如，`date()` 创建了一个来自 `date` 类的 `date` 对象。语法与调用函数相同。在实例化对象时，我们有时可以向构造函数传递参数，即创建对象的函数。`date`
    构造函数的前三个参数代表 `date` 对象将包含的年、月和日。这三个参数是必需的：
- en: '[PRE69]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now we have a `da_vinci_birthday` variable that holds a `date` object representing
    April 15, 1452.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个 `da_vinci_birthday` 变量，它包含一个代表 1452 年 4 月 15 日的 `date` 对象。
- en: B.7 Attributes and methods
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.7 属性和方法
- en: 'An *attribute* is a piece of internal data belonging to an object, a characteristic
    or detail that exposes information about the object. We access an object’s attributes
    with dot syntax. Three sample attributes on a `date` object are `day`, `month`,
    and `year`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*属性* 是属于对象、特征或细节的内部数据片段，它揭示了关于对象的信息。我们使用点符号来访问对象的属性。一个 `date` 对象上的三个示例属性是 `day`、`month`
    和 `year`：'
- en: '[PRE70]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: A *method* is an action or command that we can issue to the object. Think of
    a method as being a function that belongs to an object. *Attributes* make up the
    object’s *state*, and methods represent the object’s behavior. Like a function,
    a method can accept arguments and produce a return value.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法*是我们可以向对象发出的动作或命令。将方法视为属于对象的函数。*属性*构成了对象的状态，而方法代表了对象的行为。像函数一样，方法可以接受参数并产生返回值。'
- en: 'We invoke a method with a pair of parentheses after its name. Be sure to add
    a dot between the object and the method name. One sample method a `date` object
    has is `weekday`. The `weekday` method returns the date’s day of the week as an
    integer. `0` denotes Sunday, and `6` denotes Saturday:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在方法名称后面使用一对括号来调用方法。确保在对象和方法名称之间添加一个点。`date`对象的一个示例方法是一个`weekday`。`weekday`方法返回日期的星期几作为整数。`0`表示星期日，`6`表示星期六：
- en: '[PRE71]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Leonardo was born on a Wednesday!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 莱昂纳多出生于星期三！
- en: The easiness and reusability of methods such as `weekday` is why `date` objects
    exist. Imagine how difficult it would be to model date logic with a text string.
    Imagine if every developer built their own custom solution. Ouch. Python’s developers
    anticipated that users would need to work with dates, so they built a reusable
    `date` class to model that real-world construct.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`weekday`等方法的简便性和可重用性是`date`对象存在的原因。想象一下，如果用文本字符串来模拟日期逻辑会有多困难。想象一下，如果每个开发者都构建他们自己的定制解决方案。哎呀。Python的开发者预计用户将需要处理日期，因此他们构建了一个可重用的`date`类来模拟这个现实世界的结构。'
- en: 'The key takeaway is that the Python standard library offers developers many
    utility classes and functions to solve common problems. As programs grow in complexity,
    however, it becomes difficult to model real-world ideas with only Python’s core
    objects. To solve this problem, developers add custom objects to the language.
    These objects model business logic pertinent to a specific domain. Developers
    bundle these objects into libraries. That’s all pandas is: a bundle of additional
    classes to solve specific problems in the domain of data analysis.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 关键要点是Python标准库为开发者提供了许多实用类和函数来解决常见问题。然而，随着程序复杂性的增加，仅使用Python的核心对象来模拟现实世界思想变得困难。为了解决这个问题，开发者向语言中添加自定义对象。这些对象模拟特定领域的业务逻辑。开发者将这些对象打包成库。这就是pandas的全部：一组用于解决数据分析领域特定问题的额外类。
- en: B.8 String methods
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.8 字符串方法
- en: A string object has its own set of methods. Here are a few examples.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串对象有一套自己的方法。这里有一些例子。
- en: 'The `upper` method returns a new string with all characters in uppercase:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`upper`方法返回一个所有字符都为大写的新的字符串：'
- en: '[PRE72]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We can invoke methods on variables. Recall that a *variable* is a placeholder
    name for an object. Python will substitute the variable for the object that it
    references. The next example invokes the `upper` method on the string that the
    `greeting` variable references. The output is the same as that of the preceding
    code example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在变量上调用方法。回想一下，*变量*是对象的占位符名称。Python会将变量替换为它引用的对象。下一个示例在`greeting`变量引用的字符串上调用`upper`方法。输出与前面的代码示例相同：
- en: '[PRE73]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'There are two categories of objects: mutable and immutable. A *mutable* object
    is capable of change. An *immutable* object is incapable of change. Strings, numbers,
    and Booleans are examples of immutable objects; we cannot modify them after we
    create them. The string `"Hello"` will always be the string `"Hello"`. The number
    5 will always be the number 5.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的对象：可变和不可变。*可变*对象可以改变。*不可变*对象不能改变。字符串、数字和布尔值是不可变对象的例子；我们创建后不能修改它们。字符串`"Hello"`始终是字符串`"Hello"`。数字5始终是数字5。
- en: 'In the preceding example, the `upper` method call did not modify the original
    `"Hello"` string assigned to the `greeting` variable. Rather, the method invocation
    returned a new string with all capital letters. We can output the `greeting` variable
    to confirm that the characters have their original casing:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`upper`方法调用没有修改分配给`greeting`变量的原始`"Hello"`字符串。相反，方法调用返回了一个所有字母都为大写的新的字符串。我们可以输出`greeting`变量来确认字符保留了原始的大小写：
- en: '[PRE74]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: A string is immutable, so its methods will not modify the original object. We’ll
    explore some mutable objects starting in section B.9.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是不可变的，所以它的方法不会修改原始对象。我们将在B.9节开始探索一些可变对象。
- en: 'The complementary `lower` method returns a new string with all characters in
    lowercase:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 相补的`lower`方法返回一个所有字符都转换为小写的新的字符串：
- en: '[PRE75]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'There’s even a `swapcase` method that returns a new string with each character
    case inverted. Uppercase letters become lowercase, and lowercase letters become
    uppercase:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至还有一个 `swapcase` 方法，它返回一个新字符串，其中每个字符的大小写都被反转。大写字母变为小写，小写字母变为大写：
- en: '[PRE76]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'A method can accept arguments. Let’s take a peek at the `replace` method, which
    swaps all occurrences of a substring with a specified character sequence. The
    functionality is similar to the Find and Replace feature in a word processing
    program. The `replace` method accepts two arguments:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法可以接受参数。让我们看看 `replace` 方法，它将所有子字符串的出现次数与指定的字符序列交换。该功能类似于文字处理程序中的查找和替换功能。`replace`
    方法接受两个参数：
- en: The substring to look for
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查找的子字符串
- en: The value to replace it with
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要替换的值
- en: 'The next example replaces all occurrences of `"S"` with `"$"`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例将所有 `"S"` 出现替换为 `"$"`：
- en: '[PRE77]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In this example,
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，
- en: '`"Sally Sells Seashells by the Seashore"` is the original string *object*.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Sally Sells Seashells by the Seashore"` 是原始的字符串 *对象*。'
- en: '`replace` is the *method* invoked on the string.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace` 是对字符串调用的 *方法*。'
- en: '`"S"` is the *first argument* passed to the `replace` method invocation.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"S"` 是传递给 `replace` 方法调用的 *第一个参数*。'
- en: '`"$"` is the *second argument* passed to the `replace` method invocation.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"$"` 是传递给 `replace` 方法调用的 *第二个参数*。'
- en: '`"$ally $ells $eashells by the $eashore"` is the *return value* of the `replace`
    method.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"$ally $ells $eashells by the $eashore"` 是 `replace` 方法的 *返回值*。'
- en: A method’s return value can be of a different data type than the original object.
    The `isspace` method, for example, is invoked on a string but returns a Boolean.
    The method returns `True` if the string consists of only spaces; otherwise, it
    returns `False`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法返回值的数据类型可以与原始对象不同。例如，`isspace` 方法作用于字符串，但返回一个布尔值。如果字符串仅由空格组成，则方法返回 `True`；否则，返回
    `False`。
- en: '[PRE78]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Strings have a family of methods for removing whitespace. The `rstrip` (right
    strip) method removes whitespace from the end of a string:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串有一系列用于删除空白的方法。`rstrip`（右删除）方法从字符串的末尾删除空白：
- en: '[PRE79]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `lstrip` (left strip) method removes whitespace from the beginning of a
    string:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`lstrip`（左删除）方法从字符串的开始删除空白：'
- en: '[PRE80]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `strip` method removes whitespace from both ends of the string:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`strip` 方法从字符串的两端删除空白：'
- en: '[PRE81]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `capitalize` method capitalizes the first character of a string. This method
    often proves to be helpful for working with lowercase names, places, or organizations:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`capitalize` 方法将字符串的第一个字符大写。此方法通常在处理小写名称、地点或组织时非常有用：'
- en: '[PRE82]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `title` method capitalizes the first letter of every word in a string,
    using a space to identify where each word begins and ends:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`title` 方法将字符串中每个单词的首字母大写，使用空格来标识每个单词的开始和结束位置：'
- en: '[PRE83]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We can invoke multiple methods in sequence on a single line. This technique
    is called *method chaining*. In the next example, the `lower` method returns a
    new string object upon which we invoke the `title` method. The return value from
    `title` is yet another new string object:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一行中连续调用多个方法。这种技术称为 *方法链*。在下一个示例中，`lower` 方法返回一个新的字符串对象，然后我们调用 `title` 方法。`title`
    的返回值又是另一个新的字符串对象：
- en: '[PRE84]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `in` keyword checks whether a substring exists in another string. Enter
    the string to search for before the keyword and the string to search within after
    the keyword. The operation returns a Boolean:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`in` 关键字检查子字符串是否存在于另一个字符串中。在关键字之前输入要搜索的字符串，在关键字之后输入要搜索的字符串。操作返回一个布尔值：'
- en: '[PRE85]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `startswith` method checks whether a substring exists at the beginning
    of a string:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`startswith` 方法检查子字符串是否存在于字符串的开头：'
- en: '[PRE86]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `endswith` method checks whether a substring exists at the end of a string:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`endswith` 方法检查子字符串是否存在于字符串的末尾：'
- en: '[PRE87]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `count` method counts the occurrences of a substring within a string. The
    next example counts the number of `"e"` characters in `"celebrate"`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`count` 方法计算字符串中子字符串的出现次数。下一个示例计算 `"celebrate"` 中 `"e"` 字符的数量：'
- en: '[PRE88]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The `find` and `index` methods locate the index position of a character or
    substring. The methods return the first index position at which the argument occurs.
    Recall that index positions start counting at 0\. The next example searches for
    the index of the first `"e"` in `"celebrate"`. Python locates it at index 1:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 和 `index` 方法定位字符或子字符串的索引位置。这些方法返回参数首次出现的位置索引。回想一下，索引位置从 0 开始计数。下一个示例搜索
    `"celebrate"` 中第一个 `"e"` 的索引。Python 在索引 1 处定位它：'
- en: '[PRE89]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'What’s the difference between the `find` and `index` methods? If the string
    does not contain the argument, `find` will return `-1`, and `index` will raise
    a `ValueError` exception:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 和 `index` 方法有什么区别？如果字符串不包含参数，`find` 将返回 `-1`，而 `index` 将引发 `ValueError`
    异常：'
- en: '[PRE90]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Each method exists for a specific situation; neither option is better than the
    other. If your program depends on a substring existing within a larger string,
    for example, you may use the `index` method and react to the error. By comparison,
    if the absence of a substring does not prohibit your program from executing, you
    can use the `find` method to avoid crashing.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都适用于特定的情况；两种选择没有哪种比另一种更好。如果你的程序依赖于一个子字符串存在于更大的字符串中，例如，你可以使用 `index` 方法并处理错误。相比之下，如果子字符串的缺失不会阻止你的程序执行，你可以使用
    `find` 方法来避免崩溃。
- en: B.9 Lists
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.9 列表
- en: 'A *list* is a container for storing objects in order. The purpose of lists
    is twofold: to provide a “box” to store values and to keep them in sequence. We
    refer to the items within a list as *elements*. In other programming languages,
    this data structure is often called an *array*.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表* 是一个按顺序存储对象的容器。列表的目的是双重的：提供一个“盒子”来存储值，并保持它们的顺序。我们称列表中的项目为 *元素*。在其他编程语言中，这种数据结构通常被称为
    *数组*。'
- en: 'We declare a list with a pair of opening and closing square brackets. We write
    our elements inside the square brackets, separating every two with a comma. The
    next example creates a list of five strings:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一对开方括号和闭方括号来声明一个列表。我们在方括号内写下我们的元素，每两个元素之间用逗号分隔。下一个示例创建了一个包含五个字符串的列表：
- en: '[PRE91]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The length of a list is equal to its number of elements. Remember the trusty
    `len` function? It can help us figure how many members are in the greatest boy
    band of all time:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的长度等于其元素的数量。还记得那个可靠的 `len` 函数吗？它可以帮助我们确定史上最伟大的男孩乐队有多少成员：
- en: '[PRE92]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'An *empty list* is a list without elements. It has a length of `0`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*空列表* 是一个没有元素的列表。它的长度为 `0`：'
- en: '[PRE93]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'A list can store elements of any data type: strings, numbers, floats, Booleans,
    and more. A *homogeneous* list is one in which all elements have the same type.
    The following three lists are homogeneous. The first holds integers, the second
    holds floating-points, and the third holds Booleans:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以存储任何数据类型的元素：字符串、数字、浮点数、布尔值等等。一个 *同质* 列表是指所有元素都具有相同类型的列表。以下三个列表是同质的。第一个包含整数，第二个包含浮点数，第三个包含布尔值：
- en: '[PRE94]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Lists can also store elements of different data types. A *heterogeneous* list
    is one in which elements have different data types. The following list has a string,
    an integer, a Boolean, and a floating-point number:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 列表也可以存储不同数据类型的元素。一个 *异质* 列表是指元素具有不同数据类型的列表。以下列表包含一个字符串、一个整数、一个布尔值和一个浮点数：
- en: '[PRE95]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Much as it does for each character in a string, Python assigns each list element
    an index position. The index represents an element’s place in line and starts
    counting from 0\. In the following three-item `favorite_foods` list,
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Python 为字符串中的每个字符分配索引位置一样，Python 为列表中的每个元素分配一个索引位置。索引表示元素在行中的位置，并从 0 开始计数。在以下三个元素的
    `favorite_foods` 列表中，
- en: '`"Sushi"` occupies index position 0.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Sushi"` 占据索引位置 0。'
- en: '`"Steak"` occupies index position 1.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Steak"` 占据索引位置 1。'
- en: '`"Barbeque"` occupies index position 2.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Barbeque"` 占据索引位置 2。'
- en: '[PRE96]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Two quick notes on list formatting. First, Python permits us to insert a comma
    after a list’s last element. The comma does not affect the list whatsoever; it
    is an alternative syntax:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 关于列表格式的两个快速说明。首先，Python 允许我们在列表的最后一个元素后插入一个逗号。逗号根本不影响列表；它是一种替代语法：
- en: '[PRE97]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Second, some Python style guides recommend breaking up long lists so that each
    element occupies a single line. This format also does not affect the list in any
    technical way. The syntax looks like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，一些 Python 风格指南建议将长列表拆分，以便每个元素占据一行。这种格式也不会以任何技术方式影响列表。语法看起来是这样的：
- en: '[PRE98]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Throughout the examples in this book, I’ve used whatever formatting style I
    believe best enhances readability. You are welcome to use whichever format feels
    best to you.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的示例中，我使用了我认为最能增强可读性的格式化风格。你可以使用你觉得最舒服的格式。
- en: 'We can access a list element by its index position. Pass the index between
    a pair of square brackets after the list (or the variable that references it):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过索引位置访问列表元素。在列表（或引用它的变量）后面传递索引，放在一对方括号中：
- en: '[PRE99]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'In section B.1.2, we introduced a slicing syntax to extract characters from
    a string. We can use the same syntax to extract elements from a list. The next
    example pulls out the elements from index positions 1 to 3\. Remember that in
    a list slice, the starting index is inclusive, and the ending index is exclusive:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在B.1.2节中，我们介绍了一种切片语法来从字符串中提取字符。我们可以使用相同的语法从列表中提取元素。下一个示例从索引位置1到3提取元素。记住，在列表切片中，起始索引是包含的，而结束索引是不包含的：
- en: '[PRE100]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We can remove the number before the colon to pull from the beginning of the
    list. The next example extracts elements from the start of the list to index 2
    (exclusive):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以移除冒号前的数字来从列表的开头提取。下一个示例从列表的开头提取到索引2（不包括）的元素：
- en: '[PRE101]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We can remove the number after the colon to pull to the end of the list. The
    next example extracts elements from index 2 to the end of the list:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以移除冒号后的数字来提取到列表的末尾。下一个示例从索引2提取到列表的末尾：
- en: '[PRE102]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Leave out both numbers to create a copy of the list:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略两个数字以创建列表的副本：
- en: '[PRE103]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Finally, we can provide an optional third number in the square brackets to
    extract elements in intervals. The next example pulls elements from index position
    0 (inclusive) to index position 3 (exclusive) in increments of 2:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在方括号中提供一个可选的第三个数字来以间隔提取元素。下一个示例以2的增量从索引位置0（包含）到索引位置3（不包含）提取元素：
- en: '[PRE104]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: All slicing options return a new list.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 所有切片选项都返回一个新的列表。
- en: 'Let’s walk through some list methods. The `append` method adds a new element
    to the end of a list:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一了解一些列表方法。`append` 方法将新元素添加到列表的末尾：
- en: '[PRE105]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Do you recall our discussion on mutability versus immutability? A list is an
    example of a mutable object, an object that is *capable* of change. We can add,
    remove, or replace elements within a list after we create it. In the preceding
    example, the `append` method mutated the list referenced by the `favorite_foods`
    variable. We did not create a new list.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们关于可变性和不可变性的讨论吗？列表是一个可变对象的例子，是一个*能够*改变的对象。在创建列表后，我们可以添加、删除或替换列表中的元素。在前面的例子中，`append`
    方法修改了由 `favorite_foods` 变量引用的列表。我们没有创建一个新的列表。
- en: By comparison, a string is an example of an immutable object. When we invoke
    a method like `upper`, Python returns a new string; the original string remains
    unaffected. Immutable objects cannot change.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，字符串是一个不可变对象的例子。当我们调用像 `upper` 这样的方法时，Python返回一个新的字符串；原始字符串保持不变。不可变对象不能改变。
- en: 'Lists include a variety of mutational methods. The `extend` method adds multiple
    elements to the end of a list. It accepts one argument, a list with the values
    to add:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 列表包含多种变异方法。`extend` 方法将多个元素添加到列表的末尾。它接受一个参数，即要添加值的列表：
- en: '[PRE106]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The `insert` method adds an element to the list at a specific index position.
    Its first argument is the index where we want to inject the element, and its second
    argument is the new element. Python pushes values at and after the specified index
    position to the next slot. The next example inserts the string `"Pasta"` at index
    position 2\. The list shifts the value `"Barbeque"` and all subsequent elements
    up one index position:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert` 方法将元素添加到列表的特定索引位置。它的第一个参数是我们想要插入元素的位置，第二个参数是新的元素。Python会将指定索引位置及其后的值推到下一个槽位。下一个示例将字符串
    `"Pasta"` 插入到索引位置2。列表将 `"Barbeque"` 和所有后续元素向上移动一个索引位置：'
- en: '[PRE107]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The `in` keyword can check whether a list includes an element. `"Pizza"` exists
    in our `favorite_foods` list, and `"Caviar"` does not:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`in` 关键字可以检查列表是否包含一个元素。`"Pizza"` 在我们的 `favorite_foods` 列表中存在，而 `"Caviar"` 不存在：'
- en: '[PRE108]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The `not in` operator confirms the absence of an element from a list. It returns
    the inverse Boolean of the `in` operator:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`not in` 操作符确认列表中不存在一个元素。它返回 `in` 操作符的逆布尔值：'
- en: '[PRE109]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The `count` method counts the number of times an element appears in the list:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`count` 方法计算元素在列表中出现的次数：'
- en: '[PRE110]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The `remove` method deletes the first occurrence of an element from the list.
    Note that Python does not remove subsequent occurrences of the element:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove` 方法从列表中删除第一个出现的元素。注意，Python不会删除该元素的后续出现：'
- en: '[PRE111]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Let’s get rid of the other `"Pasta"` string at the end of the list. The `pop`
    method removes and returns the last element from the list:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去除列表末尾的其他 `"Pasta"` 字符串。`pop` 方法从列表中移除并返回最后一个元素：
- en: '[PRE112]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The `pop` method also accepts an integer argument with the index position of
    the value Python should delete. The next example removes the `"Barbeque"` value
    at index position 2\. The `"Burrito"` string slides into index position 2, and
    the elements after it also shift down by one index:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop`方法也接受一个整数参数，表示Python应该删除的值的索引位置。在下一个示例中，我们删除了索引位置2的`"Barbeque"`值。`"Burrito"`字符串滑入索引位置2，并且它后面的元素也向下移动一个索引：'
- en: '[PRE113]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'A list can hold any object, including other lists. The next example declares
    a list with three nested lists. Each nested list contains three integers:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 列表可以存储任何对象，包括其他列表。在下一个示例中，我们声明了一个包含三个嵌套列表的列表。每个嵌套列表包含三个整数：
- en: '[PRE114]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Let’s take a second to reflect on the preceding visual. Can you see any parallels
    with a spreadsheet? A nested list is one way we can represent a multidimensional,
    tabular collection of data. We can view the outermost list as being a worksheet
    and each internal list as being a row of data.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间反思一下前面的视觉表示。你能看到任何与电子表格的相似之处吗？嵌套列表是我们表示多维、表格化数据集合的一种方式。我们可以将最外层的列表视为工作表，每个内部列表视为数据行。
- en: B.9.1 List iteration
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.9.1 列表迭代
- en: A list is an example of a collection object. It is capable of storing multiple
    values—a *collection* of values. To *iterate* means to move over a collection
    object’s elements one at a time.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是集合对象的一个例子。它能够存储多个值——一个*集合*的值。*迭代*意味着逐个移动集合对象的元素。
- en: 'The most common way to iterate over a list’s items is with a `for` loop. Its
    syntax looks like this:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历列表项最常见的方式是使用`for`循环。其语法看起来像这样：
- en: '[PRE115]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'A `for` loop consists of several components:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环由几个组件组成：'
- en: The `for` keyword.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`关键字。'
- en: A variable name that will store each list element one at a time as the iteration
    runs.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个变量名，在迭代过程中将逐个存储列表元素。
- en: The `in` keyword.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in`关键字。'
- en: The list to iterate over.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要迭代的列表。
- en: A block of code that Python will run during each iteration. We can use the variable
    name in this block of code.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python在每次迭代期间将运行的代码块。我们可以在代码块中使用变量名。
- en: As a reminder, a *block* is a section of indented code. Python uses indentation
    to associate constructs in our program. The block below a function name defines
    what the function does. Similarly, the block below a `for` loop defines what happens
    during each iteration.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，一个*块*是缩进代码的部分。Python使用缩进来关联程序中的结构。位于函数名下方的块定义了函数的功能。同样，位于`for`循环下方的块定义了每次迭代期间发生的事情。
- en: 'The next example iterates over a list of four strings, printing the length
    of each one:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们迭代一个包含四个字符串的列表，打印出每个字符串的长度：
- en: '[PRE116]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The preceding iteration consists of four loops. The `season` variable holds
    the values `"Winter"`, `"Spring"`, `"Summer"`, and `"Fall"` in sequence. During
    each iteration, we pass the current string to the `len` function. The `len` function
    returns a number, which we print out.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的迭代包含四个循环。`season`变量按顺序持有`"Winter"`、`"Spring"`、`"Summer"`和`"Fall"`的值。在每次迭代中，我们将当前字符串传递给`len`函数。`len`函数返回一个数字，我们将它打印出来。
- en: 'Suppose that we want to add the lengths of the strings together. We have to
    combine a `for` loop with some other Python concepts. In the next example, we
    first initialize a `letter_count` variable to hold a cumulative sum. Inside the
    `for` loop block, we calculate the length of the current string with the `len`
    function and then overwrite the running total. Finally, we output the value of
    `letter_count` after the loop completes:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将字符串的长度相加。我们必须将`for`循环与其他Python概念结合起来。在下一个示例中，我们首先初始化一个`letter_count`变量来保存累积总和。在`for`循环块内部，我们使用`len`函数计算当前字符串的长度，然后覆盖运行总和。最后，在循环完成后输出`letter_count`的值：
- en: '[PRE117]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The `for` loop is the most conventional option for iterating over a list. Python
    also supports another syntax, which we discuss in section B.9.2.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环是迭代列表最传统的方法。Python还支持另一种语法，我们将在B.9.2节中讨论。'
- en: B.9.2 List comprehension
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.9.2 列表推导式
- en: '*List* *comprehension* is a shorthand syntax to create a list from a collection
    object. Suppose that we have a list of six numbers:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表* *推导式*是创建列表的简写语法，从集合对象中生成。假设我们有一个包含六个数字的列表：'
- en: '[PRE118]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Let’s say that we want to create a new list with the squares of those numbers.
    In other words, we want to apply a consistent operation to each element in the
    original list. One solution is to iterate over each integer in `numbers`, take
    its square, and add the result to a new list. As a reminder, the `append` method
    adds an element to the end of a list:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个包含那些数字平方的新列表。换句话说，我们想要对原始列表中的每个元素应用一个一致的运算。一个解决方案是遍历`numbers`中的每个整数，取其平方，并将结果添加到新列表中。提醒一下，`append`方法将元素添加到列表的末尾：
- en: '[PRE119]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: List comprehension can produce the same list of squares in a single line of
    code. Its syntax requires a pair of opening and closing square brackets. Inside
    the brackets, we first describe what we’d like to do with each element we iterate
    over and then the collection from which the iterable items will come.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导可以单行生成相同的平方列表。其语法需要一个成对的开放和闭合方括号。在括号内，我们首先描述我们想要对迭代的每个元素做什么，然后是从中获取可迭代项的集合。
- en: 'The next example still iterates over the `numbers` list and assigns each list
    element to a `number` variable. We declare what we’d like to do with each `number`
    before the `for` keyword. We move the `number ** 2` calculation to the beginning
    and the `for in` logic to the end:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例仍然遍历`numbers`列表，并将每个列表元素分配给一个`number`变量。我们在`for`关键字之前声明我们想要对每个`number`做什么。我们将`number
    ** 2`计算移到开始，将`for in`逻辑移到末尾：
- en: '[PRE120]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: List comprehension is considered to be the more Pythonic way to create a new
    list from an existing data structure. The *Pythonic way* describes the collection
    of recommended practices adopted by Python developers over time.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导被认为是创建新列表的更Pythonic方式，从现有的数据结构中创建。*Pythonic方式*描述了Python开发者随着时间的推移所采用的推荐实践集合。
- en: B.9.3 Converting a string to a list and vice versa
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.9.3 将字符串转换为列表及其相反操作
- en: 'We’re familiar with lists and strings now, so let’s see how we can use them
    together. Suppose that we have a string in our program that holds an address:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在熟悉列表和字符串了，让我们看看我们如何可以将它们一起使用。假设我们的程序中有一个包含地址的字符串：
- en: '[PRE121]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'What if we want to break the address into smaller components: street, city,
    state, and zip code? Notice that the string uses a comma to separate the four
    pieces.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将地址分解成更小的组成部分：街道、城市、州和邮政编码呢？请注意，该字符串使用逗号来分隔这四个部分。
- en: 'A string’s `split` method breaks a string apart by using a *delimiter*, a sequence
    of one or more characters marking a boundary. The next example asks the `split`
    method to split `empire_state_building` on every occurrence of a comma. The method
    returns a list consisting of the smaller strings:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的`split`方法通过使用*分隔符*，一个或多个字符的序列来标记边界，将字符串分解。下一个示例要求`split`方法在`empire_state_building`的每个逗号出现处进行分割。该方法返回一个由较小的字符串组成的列表：
- en: '[PRE122]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This code is a step in the right direction. But notice that the last three
    elements in the list have a leading space. Although we could iterate over the
    list’s elements and call the `strip` on each one to remove its whitespace, a more
    optimal solution is to add the space to the `split` method’s delimiter argument:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是朝着正确方向迈出的一步。但请注意，列表中的最后三个元素前面有一个前置空格。虽然我们可以遍历列表的元素并对每个元素调用`strip`方法来移除其空白字符，但一个更优的解决方案是将空格添加到`split`方法的分隔符参数中：
- en: '[PRE123]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: We’ve successfully broken the string into a list of strings.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功将字符串分解成字符串列表。
- en: 'The process also works in reverse. Suppose that we stored our address in a
    list and want to concatenate the list’s elements into a single string:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程也可以反向进行。假设我们将地址存储在一个列表中，并希望将列表的元素连接成一个单独的字符串：
- en: '[PRE124]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'First, we must declare the string that we’d like Python to inject between every
    two list elements. Then we can invoke the `join` method on the string and pass
    in a list as the argument. Python will join the list’s elements, separating each
    two with the delimiter. The next example uses a delimiter of a comma and a space:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须声明我们希望Python在两个列表元素之间注入的字符串。然后我们可以对字符串调用`join`方法，并将列表作为参数传入。Python会将列表的元素连接起来，每个元素之间用分隔符分隔。下一个示例使用逗号和空格作为分隔符：
- en: '[PRE125]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The `split` and `join` methods are helpful for working with text data, which
    often needs to be separated and remerged.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`split`和`join`方法对于处理文本数据很有帮助，这些数据通常需要被分离和重新合并。'
- en: B.10 Tuples
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.10 元组
- en: A *tuple* is a similar data structure to a Python list. A tuple also stores
    elements in order, but unlike a list, it is immutable. We cannot add, remove,
    or replace elements within the tuple after we create it.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *元组* 与 Python 列表类似的数据结构。元组也按顺序存储元素，但与列表不同，它是不可变的。一旦创建了元组，我们就不能添加、删除或替换其中的元素。
- en: 'The only technical requirement for defining a tuple is to declare multiple
    elements and separate every subsequent two with a comma. The following example
    declares a three-element tuple:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 定义元组的唯一技术要求是声明多个元素，并且用逗号分隔每个后续的两个元素。以下示例声明了一个包含三个元素的元组：
- en: '[PRE126]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Usually, however, we declare a tuple with a pair of parentheses. The syntax
    makes it easier to identify the object visually:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常我们使用一对括号来声明元组。这种语法使得从视觉上识别对象变得更容易：
- en: '[PRE127]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The `len` function returns the length of a tuple:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`len` 函数返回元组的长度：'
- en: '[PRE128]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: To declare a tuple with one element, we must include a comma after the element.
    Python needs the comma to identify the tuple. Compare the differences in the next
    two outputs. The first example does not use a comma; Python reads the value as
    a string.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个只有一个元素的元组，我们必须在元素后面包含一个逗号。Python 需要逗号来识别元组。比较以下两个输出的差异。第一个示例没有使用逗号；Python
    将值读取为字符串。
- en: '[PRE129]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'By comparison, the syntax here returns a tuple. Yes, one symbol can make a
    world of difference in Python:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，这里的语法返回一个元组。是的，一个符号在 Python 中可以产生巨大的差异：
- en: '[PRE130]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Use the `tuple` function to create an *empty tuple*, which is one without elements:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `tuple` 函数创建一个 *空元组*，即一个没有元素的元组：
- en: '[PRE131]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: As with a list, you can access tuple elements by index position. As with a list,
    you can iterate over tuple elements with a `for` loop. The only thing you can’t
    do is modify the tuple. Because of its immutability, a tuple doesn’t include mutational
    methods such as `append`, `pop`, and `insert`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表一样，你可以通过索引位置访问元组元素。与列表一样，你可以使用 `for` 循环遍历元组元素。唯一不能做的是修改元组。由于其不可变性，元组不包含如
    `append`、`pop` 和 `insert` 这样的突变方法。
- en: If you have a collection of elements in order, and you know that it will not
    change, you can prefer a tuple over a list to store it.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一组有序的元素，并且知道它不会改变，你可以选择使用元组而不是列表来存储它。
- en: B.11 Dictionaries
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.11 字典
- en: 'Lists and tuples are optimal data structures for storing objects in order.
    We need another data structure to solve a different kind of problem: establishing
    associations between objects.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和元组是存储有序对象的最佳数据结构。我们需要另一种数据结构来解决不同类型的问题：在对象之间建立关联。
- en: Consider a restaurant menu. Each menu item is a unique identifier that we use
    to look up a corresponding price. The menu item and its cost are associated. The
    order of items is not what’s important; it’s the *connection* between two pieces
    of data.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一家餐厅的菜单。每个菜单项都是一个唯一的标识符，我们用它来查找相应的价格。菜单项和其成本是关联的。项目的顺序并不重要；重要的是两份数据之间的 *联系*。
- en: A *dictionary* is a mutable, unordered collection of key-value pairs. A pair
    consists of a key and a value. Each key serves as an identifier for a value. Keys
    must be unique. Values can contain duplicates.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *字典* 是一个可变、无序的键值对集合。一对由一个键和一个值组成。每个键都是一个值的标识符。键必须是唯一的。值可以包含重复项。
- en: 'We declare a dictionary with a pair of curly braces (`{}`). The following example
    creates an empty dictionary:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一对花括号 (`{}`) 声明字典。以下示例创建了一个空字典：
- en: '[PRE132]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Let’s model a sample restaurant menu in Python. Inside the curly braces, we
    assign a key to its value with a colon (`:`). The following example declares a
    dictionary with one key-value pair. The string key `"Cheeseburger"` is assigned
    the floating-point value `7.99`:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Python 中模拟一个示例餐厅菜单。在花括号内，我们使用冒号 (`:`) 为其值分配一个键。以下示例声明了一个包含一个键值对的字典。字符串键
    `"Cheeseburger"` 被分配了浮点值 `7.99`：
- en: '[PRE133]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'When declaring a dictionary with multiple key-value pairs, separate every two
    pairs with a comma. Let’s expand our `menu` dictionary to hold three key-value
    pairs. Notice that the values for the `"French Fries"` and `"Soda"` keys are identical:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明包含多个键值对的字典时，用逗号分隔每个两个键值对。让我们扩展我们的 `menu` 字典以包含三个键值对。注意 `"French Fries"` 和
    `"Soda"` 键的值是相同的：
- en: '[PRE134]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'We can count the number of key-value pairs in a dictionary by passing it to
    Python’s built-in `len` function:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将其传递给 Python 的内置 `len` 函数来计算字典中键值对的数量：
- en: '[PRE135]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'We use keys to retrieve values from dictionaries. Place a pair of square brackets
    with the key immediately after the dictionary. The syntax is identical to accessing
    a list element by index position. The following example extracts the value for
    the `"French Fries"` key:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用键从字典中检索值。在字典后面立即放置一对方括号，并紧跟键。语法与通过索引位置访问列表元素相同。以下示例提取了 `"French Fries"`
    键的值：
- en: '[PRE136]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'In a list, the index position is always a number. In a dictionary, a key can
    be any immutable data type: integers, floats, strings, Booleans, and more.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中，索引位置始终是数字。在字典中，键可以是任何不可变的数据类型：整数、浮点数、字符串、布尔值等等。
- en: 'Python raises a `KeyError` exception if the key does not exist in the dictionary.
    `KeyError` is another example of a native Python error:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键在字典中不存在，Python 将引发一个 `KeyError` 异常。`KeyError` 是原生 Python 错误的另一个例子：
- en: '[PRE137]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'As always, case sensitivity matters. If a single character is mismatched, Python
    will not be able to find a key. The key `"soda"` does not exist in our dictionary.
    Only `"Soda"` does:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 总是注意大小写敏感。如果单个字符不匹配，Python 将无法找到键。在我们的字典中不存在 `"soda"` 这个键。只有 `"Soda"`：
- en: '[PRE138]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The `get` method also extracts a dictionary value by using a key:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 方法也可以通过键提取字典值：'
- en: '[PRE139]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The `get` method’s advantage is that it returns `None` if the key does not
    exist rather than raise an error. Remember that `None` is an object that Python
    uses to represent the idea of absence or nullness. The `None` value produces no
    visual output in Jupyter Notebook. But we can wrap the invocation in a `print`
    function to force Python to print `None`’s string representation:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 方法的优势是，如果键不存在，它返回 `None` 而不是引发错误。记住，`None` 是 Python 用来表示不存在或空值的概念的一个对象。`None`
    值在 Jupyter Notebook 中不会产生任何视觉输出。但我们可以用 `print` 函数包裹调用，强制 Python 打印 `None` 的字符串表示：'
- en: '[PRE140]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The second argument to the `get` method is a custom value to return if the
    key does not exist in the dictionary. In the next example, the string `"Steak"`
    does not exist as a key in the `menu` dictionary, so Python returns `99.99` instead:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 方法的第二个参数是在字典中键不存在时返回的自定义值。在下一个示例中，字符串 `"Steak"` 并不是 `menu` 字典中的键，所以 Python
    返回 `99.99`：'
- en: '[PRE141]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'A dictionary is a mutable data structure. We can add key-value pairs to or
    remove key-value pairs from the dictionary after we create it. To add a new key-value
    pair, provide the key in square brackets, and assign a value to it with the assignment
    operator (`=`):'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是一个可变的数据结构。在创建字典后，我们可以向其中添加键值对或从字典中删除键值对。要添加一个新的键值对，提供键并用赋值运算符（`=`）为其赋值：
- en: '[PRE142]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'If the key already exists in the dictionary, Python will overwrite its original
    value. The next example changes the value of the `"Cheeseburger"` key from `7.99`
    to `9.99`:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键已经存在于字典中，Python 将覆盖其原始值。在下一个示例中，将 `"Cheeseburger"` 键的值从 `7.99` 更改为 `9.99`：
- en: '[PRE143]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The `pop` method removes a key-value pair from a dictionary; it accepts a key
    as an argument and returns its value. Python will raise a `KeyError` exception
    if the key does not exist in the dictionary:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop` 方法从一个字典中移除一个键值对；它接受一个键作为参数并返回其值。如果键在字典中不存在，Python 将引发一个 `KeyError` 异常：'
- en: '[PRE144]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The `in` keyword checks whether an element exists in the dictionary’s keys:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`in` 关键字检查一个元素是否存在于字典的键中：'
- en: '[PRE145]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'To check for inclusion among the dictionary’s values, invoke the `values` method
    on the dictionary. The method returns a listlike object that contains the dictionary’s
    values. We can use the `in` operator in combination with the `values` method’s
    return value:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查字典值中的包含情况，在字典上调用 `values` 方法。该方法返回一个类似列表的对象，包含字典的值。我们可以将 `in` 操作符与 `values`
    方法的返回值结合使用：
- en: '[PRE146]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: The `values` method returns a different type of object from the lists, tuples,
    and dictionaries we’ve already seen. We don’t necessarily need to know what the
    object is, however. All we care about is how we can work with it. The `in` operator
    checks for the inclusion of a value in an object, and the object returned by the
    `values` method knows how to handle it.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`values` 方法返回的对象类型与我们之前看到的列表、元组和字典不同。我们不一定需要知道这个对象是什么，然而。我们只关心我们如何与之交互。`in`
    操作符检查一个值是否在对象中，而 `values` 方法返回的对象知道如何处理它。'
- en: B.11.1 Dictionary Iteration
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: B.11.1 字典迭代
- en: We should always assume that a dictionary’s key-value pairs are unordered. If
    you need a data structure that maintains order, use a list or a tuple. If you
    need to create associations between objects, use a dictionary.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终假设字典的键值对是无序的。如果您需要一个保持顺序的数据结构，请使用列表或元组。如果您需要创建对象之间的关联，请使用字典。
- en: 'Even if we cannot guarantee a deterministic iteration order, we can still loop
    over a dictionary one key-value pair at a time with a `for` loop. The dictionary’s
    `items` method yields a two-item tuple on each iteration. The tuple holds a key
    and its respective value. We can declare multiple variables after the `for` keyword
    to store each key and value. In the next example, the `state` variable holds each
    dictionary key, and the `capital` variable holds each value:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们不能保证迭代顺序的确定性，我们仍然可以使用 `for` 循环一次迭代一个键值对来遍历字典。字典的 `items` 方法在每次迭代时返回一个包含两个元素的元组。该元组包含一个键及其相应的值。我们可以在
    `for` 关键字之后声明多个变量来存储每个键和值。在下一个示例中，`state` 变量包含每个字典键，而 `capital` 变量包含每个值：
- en: '[PRE147]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: In the first iteration, Python yields a tuple of `("New York", "Albany")`. In
    the second iteration, it yields a tuple of `("Florida", "Tallahassee")`, and so
    on.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次迭代中，Python 返回一个包含 `("New York", "Albany")` 的元组。在第二次迭代中，它返回一个包含 `("Florida",
    "Tallahassee")` 的元组，依此类推。
- en: B.12 Sets
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: B.12 集合
- en: 'List and dictionary objects help solve the problems of order and association.
    A set assists with another common need: uniqueness. A *set* is an unordered, mutable
    collection of unique elements. It prohibits duplicates.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和字典对象有助于解决顺序和关联的问题。集合帮助解决另一个常见需求：唯一性。一个 *集合* 是一个无序、可变且元素唯一的集合。它禁止重复。
- en: 'We declare a set with a pair of curly braces. We populate the braces with elements,
    separating every two with a comma. The next example declares a set of six numbers:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一对花括号声明一个集合。我们在花括号中填充元素，每两个元素之间用逗号分隔。下一个示例声明了一个包含六个数字的集合：
- en: '[PRE148]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Readers with a sharp eye may notice that the curly-brace syntax for declaring
    a set is identical to the syntax for declaring a dictionary. Python can distinguish
    between the two types of objects based on the presence or absence of key-value
    pairs.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 眼光敏锐的读者可能会注意到，声明集合的花括号语法与声明字典的语法相同。Python 可以根据键值对的存在与否来区分这两种类型的对象。
- en: 'Because Python interprets an empty pair of curly braces as an empty dictionary,
    the only way to create an empty set is with the built-in `set` function:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Python 将空的一对花括号解释为空字典，所以创建空集合的唯一方法是使用内置的 `set` 函数：
- en: '[PRE149]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Here are some helpful set methods. The `add` method adds a new element to the
    set:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有用的集合方法。`add` 方法向集合中添加一个新元素：
- en: '[PRE150]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Python will add an element to a set only if the set does not already have it.
    The next example attempts to add 15 to `favorite_numbers`. Python sees that 15
    already exists within the set, so the object remains unchanged:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: Python 只会在集合中不存在该元素的情况下向集合中添加一个元素。下一个示例尝试将 15 添加到 `favorite_numbers` 中。Python
    发现 15 已经存在于集合中，因此对象保持不变：
- en: '[PRE151]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'A set has no concept of order. Python will raise a `TypeError` exception if
    we attempt to access a set element by index position:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 集合没有顺序的概念。如果我们尝试通过索引位置访问集合元素，Python 会引发 `TypeError` 异常：
- en: '[PRE152]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Python raises a `TypeError` exception when we attempt to apply an operation
    to an invalid object. Set elements are unordered, so elements do not have index
    positions.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试对一个无效对象应用操作时，Python 会引发 `TypeError` 异常。集合元素是无序的，因此元素没有索引位置。
- en: 'In addition to preventing duplicates, sets are ideal for identifying similarities
    and differences between two collections of data. Let’s define two sets of strings:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 除了防止重复外，集合非常适合识别两个数据集合之间的相似性和差异性。让我们定义两个字符串集合：
- en: '[PRE153]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The `intersection` method returns a new set with elements found in both of
    the original sets. The `&` symbol performs the same logic. In the next example,
    `"Snickers"` is the only string in common between `candy_bars` and `sweet_things`:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`intersection` 方法返回一个新集合，其中包含在两个原始集合中都找到的元素。`&` 符号执行相同的逻辑。在下一个示例中，`"Snickers"`
    是 `candy_bars` 和 `sweet_things` 之间唯一的字符串：'
- en: '[PRE154]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'The `union` method returns a set that combines all elements of the two sets.
    The `|` symbol performs the same logic. Keep in mind that duplicate values such
    as `"Snickers"` will appear only once:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`union` 方法返回一个集合，该集合包含两个集合的所有元素。`|` 符号执行相同的逻辑。请注意，像 `"Snickers"` 这样的重复值只会出现一次：'
- en: '[PRE155]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'The `difference` method returns a set of elements that are present in the set
    the method is called on but not present in the set passed in as an argument. We
    can use the `-` symbol as a shortcut. In the next example, `"100 Grand"` and `"Milky
    Way"` are present in `candy_bars` but not in `sweet_things`:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`difference`方法返回一个集合，其中包含在调用该方法时在集合中存在的元素，但不包含在作为参数传递的集合中。我们可以使用`-`符号作为快捷方式。在下一个例子中，“100
    Grand”和“Milky Way”存在于`candy_bars`中，但不在`sweet_things`中：'
- en: '[PRE156]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'The `symmetric_difference` method returns a set with elements found in either
    of the sets but not both. The `^` syntax accomplishes the same result:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`symmetric_difference`方法返回一个集合，其中包含在任一集合中找到的元素，但不包含在两个集合中。`^`语法可以达到相同的结果：'
- en: '[PRE157]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'And that’s all there is to cover! We’ve learned quite a bit of Python: data
    types, functions, iterations, and more. It’s OK if you don’t remember all the
    details. Rather, come back to this appendix whenever you need a refresher on the
    core mechanics of Python. We’ll be using and reviewing a lot of these ideas as
    we work with the pandas library.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！我们已经学到了很多Python知识：数据类型、函数、迭代等等。如果你记不住所有细节也没关系。相反，当你需要复习Python核心机制时，随时回到这个附录。在我们使用pandas库的过程中，我们会用到并回顾很多这些想法。
- en: '* * *'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: ¹ See “PEP 8—Style Guide for Python Code,” [https://www.python.org/dev/peps/pep-0008](https://www.python.org/dev/peps/pep-0008).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 请参阅“PEP 8—Python代码风格指南”，[https://www.python.org/dev/peps/pep-0008](https://www.python.org/dev/peps/pep-0008)。
