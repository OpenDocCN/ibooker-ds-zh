- en: Chapter 2\. First steps with Docker and Kubernetes
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 第二章：Docker和Kubernetes的第一步
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating, running, and sharing a container image with Docker
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker创建、运行和共享容器镜像
- en: Running a single-node Kubernetes cluster locally
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地运行单节点Kubernetes集群
- en: Setting up a Kubernetes cluster on Google Kubernetes Engine
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Google Kubernetes Engine上设置Kubernetes集群
- en: Setting up and using the `kubectl` command-line client
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和使用`kubectl`命令行客户端
- en: Deploying an app on Kubernetes and scaling it horizontally
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes上部署应用程序并水平扩展
- en: Before you start learning about Kubernetes concepts in detail, let’s see how
    to create a simple application, package it into a container image, and run it
    in a managed Kubernetes cluster (in Google Kubernetes Engine) or in a local single-node
    cluster. This should give you a slightly better overview of the whole Kubernetes
    system and will make it easier to follow the next few chapters, where we’ll go
    over the basic building blocks and concepts in Kubernetes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始详细了解Kubernetes概念之前，让我们看看如何创建一个简单的应用程序，将其打包到容器镜像中，并在管理的Kubernetes集群（在Google
    Kubernetes Engine中）或本地单节点集群中运行。这应该会给你提供一个对整个Kubernetes系统的略微更好的概述，并使你更容易跟随接下来的几章，我们将介绍Kubernetes中的基本构建块和概念。
- en: 2.1\. Creating, running, and sharing a container image
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1\. 创建、运行和共享容器镜像
- en: As you’ve already learned in the previous chapter, running applications in Kubernetes
    requires them to be packaged into container images. We’ll do a basic introduction
    to using Docker in case you haven’t used it yet. In the next few sections you’ll
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一章中学到的，在Kubernetes中运行应用程序需要将它们打包到容器镜像中。如果你还没有使用过Docker，我们将对其进行基本介绍。在接下来的几节中，你将
- en: Install Docker and run your first “Hello world” container
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Docker并运行您的第一个“Hello world”容器
- en: Create a trivial Node.js app that you’ll later deploy in Kubernetes
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的Node.js应用程序，你稍后将在Kubernetes中部署它
- en: Package the app into a container image so you can then run it as an isolated
    container
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序打包到容器镜像中，以便您可以将其作为隔离的容器运行
- en: Run a container based on the image
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于镜像运行容器
- en: Push the image to Docker Hub so that anyone anywhere can run it
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将镜像推送到Docker Hub，以便任何人都可以在任何地方运行它
- en: 2.1.1\. Installing Docker and running a Hello World container
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1.1\. 安装Docker并运行Hello World容器
- en: First, you’ll need to install Docker on your Linux machine. If you don’t use
    Linux, you’ll need to start a Linux virtual machine (VM) and run Docker inside
    that VM. If you’re using a Mac or Windows and install Docker per instructions,
    Docker will set up a VM for you and run the Docker daemon inside that VM. The
    Docker client executable will be available on your host OS, and will communicate
    with the daemon inside the VM.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在你的Linux机器上安装Docker。如果你不使用Linux，你需要启动一个Linux虚拟机（VM），并在该VM中运行Docker。如果你使用Mac或Windows，并按照说明安装Docker，Docker会为你设置一个VM，并在该VM中运行Docker守护进程。Docker客户端可执行文件将可用在你的主机操作系统上，并与VM内的守护进程进行通信。
- en: To install Docker, follow the instructions at [http://docs.docker.com/engine/installation/](http://docs.docker.com/engine/installation/)
    for your specific operating system. After completing the installation, you can
    use the Docker client executable to run various Docker commands. For example,
    you could try pulling and running an existing image from Docker Hub, the public
    Docker registry, which contains ready-to-use container images for many well-known
    software packages. One of them is the `busybox` image, which you’ll use to run
    a simple `echo "Hello world"` command.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Docker，请遵循[http://docs.docker.com/engine/installation/](http://docs.docker.com/engine/installation/)中针对您特定操作系统的说明。完成安装后，您可以使用Docker客户端可执行文件运行各种Docker命令。例如，您可以尝试从Docker
    Hub拉取并运行一个现有的镜像，Docker Hub是公共Docker注册库，其中包含许多知名软件包的现成容器镜像。其中之一是`busybox`镜像，您将使用它来运行简单的`echo
    "Hello world"`命令。
- en: Running a Hello World container
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Hello World容器
- en: If you’re unfamiliar with busybox, it’s a single executable that combines many
    of the standard UNIX command-line tools, such as `echo`, `ls`, `gzip`, and so
    on. Instead of the `busybox` image, you could also use any other full-fledged
    OS container image such as Fedora, Ubuntu, or other similar images, as long as
    it includes the `echo` executable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉busybox，它是一个包含许多标准UNIX命令行工具的单个可执行文件，例如`echo`、`ls`、`gzip`等。除了`busybox`镜像外，您还可以使用任何其他完整的OS容器镜像，如Fedora、Ubuntu或其他类似镜像，只要它包含`echo`可执行文件即可。
- en: How do you run the `busybox` image? You don’t need to download or install anything.
    Use the `docker run` command and specify what image to download and run and (optionally)
    what command to execute, as shown in the following listing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何运行`busybox`镜像？你不需要下载或安装任何东西。使用`docker run`命令并指定要下载和运行的镜像以及（可选）要执行的命令，如下所示。
- en: Listing 2.1\. Running a Hello world container with Docker
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.1\. 使用Docker运行“Hello world”容器
- en: '`$ docker run busybox echo "Hello world"` `Unable to find image ''busybox:latest''
    locally latest: Pulling from docker.io/busybox 9a163e0b8d13: Pull complete fef924a0204a:
    Pull complete Digest: sha256:97473e34e311e6c1b3f61f2a721d038d1e5eef17d98d1353a513007cf46ca6bd
    Status: Downloaded newer image for docker.io/busybox:latest Hello world`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker run busybox echo "Hello world"` `无法在本地找到镜像 ''busybox:latest'' latest:
    正在从 docker.io/busybox 拉取 9a163e0b8d13: 拉取完成 fef924a0204a: 拉取完成 Digest: sha256:97473e34e311e6c1b3f61f2a721d038d1e5eef17d98d1353a513007cf46ca6bd
    状态: 下载了较新的镜像 for docker.io/busybox:latest Hello world`'
- en: This doesn’t look that impressive, but when you consider that the whole “app”
    was downloaded and executed with a single command, without you having to install
    that app or anything else, you’ll agree it’s awesome. In your case, the app was
    a single executable (busybox), but it might as well have been an incredibly complex
    app with many dependencies. The whole process of setting up and running the app
    would have been exactly the same. What’s also important is that the app was executed
    inside a container, completely isolated from all the other processes running on
    your machine.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来并不那么令人印象深刻，但当你考虑到整个“应用”都是通过单个命令下载和执行的，而你无需安装该应用或任何其他东西，你就会同意这真是太棒了。在你的情况下，应用是一个单独的可执行文件（busybox），但它也可能是一个具有许多依赖关系的极其复杂的应用。设置和运行应用的全过程将完全相同。同样重要的是，应用是在容器内执行的，完全隔离于你机器上运行的所有其他进程。
- en: Understanding what happens behind the scenes
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 理解幕后发生的事情
- en: '[Figure 2.1](#filepos191987) shows exactly what happened when you performed
    the `docker run` command. First, Docker checked to see if the `busybox:latest`
    image was already present on your local machine. It wasn’t, so Docker pulled it
    from the Docker Hub registry at [http://docker.io](http://docker.io). After the
    image was downloaded to your machine, Docker created a container from that image
    and ran the command inside it. The `echo` command printed the text to STDOUT and
    then the process terminated and the container stopped.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.1](#filepos191987)展示了当你执行`docker run`命令时发生了什么。首先，Docker检查`busybox:latest`镜像是否已经存在于你的本地机器上。它不在，所以Docker从Docker
    Hub注册表[http://docker.io](http://docker.io)中拉取了它。镜像下载到你的机器后，Docker从该镜像创建了一个容器并在其中运行了命令。`echo`命令将文本打印到STDOUT，然后进程终止，容器停止。'
- en: Figure 2.1\. Running echo “Hello world” in a container based on the busybox
    container image
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1\. 在基于busybox容器镜像的容器中运行echo “Hello world”
- en: '![](images/00019.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00019.jpg)'
- en: Running other images
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 运行其他镜像
- en: 'Running other existing container images is much the same as how you ran the
    `busybox` image. In fact, it’s often even simpler, because you usually don’t need
    to specify what command to execute, the way you did in the example (`echo "Hello
    world"`). The command that should be executed is usually baked into the image
    itself, but you can override it if you want. After searching or browsing through
    the publicly available images on [http://hub.docker.com](http://hub.docker.com)
    or another public registry, you tell Docker to run the image like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 运行其他现有的容器镜像与运行`busybox`镜像的方式非常相似。实际上，它通常甚至更简单，因为你通常不需要指定要执行什么命令，就像在示例中那样（`echo
    "Hello world"`）。应该执行的命令通常已经嵌入到镜像本身中，但如果你想的话，可以覆盖它。在搜索或浏览了[http://hub.docker.com](http://hub.docker.com)或另一个公共注册表上公开可用的镜像后，你告诉Docker这样运行镜像：
- en: '`$ docker run <image>`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker run <image>`'
- en: Versioning container images
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像的版本控制
- en: 'All software packages get updated, so more than a single version of a package
    usually exists. Docker supports having multiple versions or variants of the same
    image under the same name. Each variant must have a unique tag. When referring
    to images without explicitly specifying the tag, Docker will assume you’re referring
    to the so-called latest tag. To run a different version of the image, you may
    specify the tag along with the image name like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有软件包都会更新，因此通常存在一个软件包的多个版本。Docker支持在相同名称下拥有同一镜像的多个版本或变体。每个变体都必须有一个唯一的标签。当引用未明确指定标签的镜像时，Docker将假设你指的是所谓的最新标签。要运行镜像的不同版本，你可以像这样指定标签和镜像名称：
- en: '`$ docker run <image>:<tag>`'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker run <image>:<tag>`'
- en: 2.1.2\. Creating a trivial Node.js app
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1.2\. 创建一个简单的Node.js应用
- en: Now that you have a working Docker setup, you’re going to create an app. You’ll
    build a trivial Node.js web application and package it into a container image.
    The application will accept HTTP requests and respond with the hostname of the
    machine it’s running in. This way, you’ll see that an app running inside a container
    sees its own hostname and not that of the host machine, even though it’s running
    on the host like any other process. This will be useful later, when you deploy
    the app on Kubernetes and scale it out (scale it horizontally; that is, run multiple
    instances of the app). You’ll see your HTTP requests hitting different instances
    of the app.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个工作的Docker设置，你将创建一个应用。你将构建一个简单的Node.js网络应用并将其打包成容器镜像。该应用将接受HTTP请求并返回运行在其中的机器的主机名。这样，你就会看到容器中的应用看到的是它自己的主机名，而不是宿主机的，尽管它像任何其他进程一样在宿主机上运行。这将在你部署应用在Kubernetes上并扩展它（水平扩展；也就是说，运行应用的多个实例）时很有用。你会看到你的HTTP请求击中应用的不同实例。
- en: Your app will consist of a single file called app.js with the contents shown
    in the following listing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用将包含一个名为app.js的单个文件，其内容如下所示。
- en: 'Listing 2.2\. A simple Node.js app: app.js'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.2\. 一个简单的Node.js应用：app.js
- en: '`const http = require(''http''); const os = require(''os'');  console.log("Kubia
    server starting...");  var handler = function(request, response) {   console.log("Received
    request from " + request.connection.remoteAddress);   response.writeHead(200);
      response.end("You''ve hit " + os.hostname() + "\n"); };  var www = http.createServer(handler);
    www.listen(8080);`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`const http = require(''http''); const os = require(''os'');  console.log("Kubia服务器启动...");  var
    handler = function(request, response) {   console.log("收到来自 " + request.connection.remoteAddress
    + " 的请求");   response.writeHead(200);   response.end("您已击中 " + os.hostname() +
    "\n"); };  var www = http.createServer(handler); www.listen(8080);`'
- en: It should be clear what this code does. It starts up an HTTP server on port
    8080\. The server responds with an HTTP response status code `200 OK` and the
    text `"You've hit <hostname>"` to every request. The request handler also logs
    the client’s IP address to the standard output, which you’ll need later.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很清楚这段代码的作用。它启动了8080端口的HTTP服务器。服务器对每个请求返回HTTP响应状态码`200 OK`和文本`"您已击中 <hostname>"`。请求处理程序还将客户端的IP地址记录到标准输出，这你以后会用到。
- en: '|  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The returned hostname is the server’s actual hostname, not the one the client
    sends in the HTTP request’s `Host` header.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的主机名是服务器的实际主机名，而不是客户端在HTTP请求的`Host`头中发送的那个。
- en: '|  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You could now download and install Node.js and test your app directly, but this
    isn’t necessary, because you’ll use Docker to package the app into a container
    image and enable it to be run anywhere without having to download or install anything
    (except Docker, which does need to be installed on the machine you want to run
    the image on).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以下载并安装Node.js并直接测试你的应用，但这不是必需的，因为你会使用Docker将应用打包成容器镜像，并使其能够在任何地方运行，无需下载或安装任何东西（除了Docker，它确实需要在你想运行镜像的机器上安装）。
- en: 2.1.3\. Creating a Dockerfile for the image
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1.3\. 为镜像创建Dockerfile
- en: To package your app into an image, you first need to create a file called Dockerfile,
    which will contain a list of instructions that Docker will perform when building
    the image. The Dockerfile needs to be in the same directory as the app.js file
    and should contain the commands shown in the following listing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你的应用打包成镜像，你首先需要创建一个名为Dockerfile的文件，该文件将包含Docker在构建镜像时将执行的指令列表。Dockerfile需要与app.js文件在同一个目录中，并应包含以下列表中显示的命令。
- en: Listing 2.3\. A Dockerfile for building a container image for your app
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3\. 为你的应用构建容器镜像的Dockerfile
- en: '`FROM node:7 ADD app.js /app.js ENTRYPOINT ["node", "app.js"]`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM node:7 ADD app.js /app.js ENTRYPOINT ["node", "app.js"]`'
- en: The `FROM` line defines the container image you’ll use as a starting point (the
    base image you’re building on top of). In your case, you’re using the `node` container
    image, tag `7`. In the second line, you’re adding your app.js file from your local
    directory into the root directory in the image, under the same name (app.js).
    Finally, in the third line, you’re defining what command should be executed when
    somebody runs the image. In your case, the command is `node app.js`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`行定义了你将用作起始点的容器镜像（你将在其上构建的基础镜像）。在你的情况下，你使用的是`node`容器镜像，标签`7`。在第二行，你将你的app.js文件从本地目录添加到镜像的根目录下，使用相同的名称（app.js）。最后，在第三行，你定义了当有人运行镜像时应执行什么命令。在你的情况下，命令是`node
    app.js`。'
- en: '|  |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Choosing a base image
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 选择基础镜像
- en: You may wonder why we chose this specific image as your base. Because your app
    is a Node.js app, you need your image to contain the `node` binary executable
    to run the app. You could have used any image that contains that binary, or you
    could have even used a Linux distro base image such as `fedora` or `ubuntu` and
    installed Node.js into the container at image build time. But because the `node`
    image is made specifically for running Node.js apps, and includes everything you
    need to run your app, you’ll use that as the base image.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们选择了这个特定的镜像作为基础。因为你的应用是一个Node.js应用，你需要你的镜像包含 `node` 二进制可执行文件来运行应用。你可以使用包含该二进制的任何镜像，或者甚至可以使用像
    `fedora` 或 `ubuntu` 这样的Linux发行版基础镜像，并在镜像构建时将Node.js安装到容器中。但是，因为 `node` 镜像是专门为运行Node.js应用而制作的，并且包含了运行你的应用所需的一切，所以你会使用它作为基础镜像。
- en: '|  |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.1.4\. Building the container image
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1.4\. 构建容器镜像
- en: 'Now that you have your Dockerfile and the app.js file, you have everything
    you need to build your image. To build it, run the following Docker command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了Dockerfile和app.js文件，你已经拥有了构建镜像所需的一切。要构建它，运行以下Docker命令：
- en: '`$ docker build -t kubia .`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker build -t kubia .`'
- en: '[Figure 2.2](#filepos199146) shows what happens during the build process. You’re
    telling Docker to build an image called `kubia` based on the contents of the current
    directory (note the dot at the end of the build command). Docker will look for
    the Dockerfile in the directory and build the image based on the instructions
    in the file.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.2](#filepos199146) 展示了构建过程中的情况。你正在告诉Docker基于当前目录的内容构建一个名为 `kubia` 的镜像（注意构建命令末尾的点）。Docker将在目录中查找Dockerfile，并根据文件中的说明构建镜像。'
- en: Figure 2.2\. Building a new container image from a Dockerfile
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2\. 从Dockerfile构建新的容器镜像
- en: '![](images/00040.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00040.jpg)'
- en: Understanding how an image is built
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 理解镜像的构建过程
- en: The build process isn’t performed by the Docker client. Instead, the contents
    of the whole directory are uploaded to the Docker daemon and the image is built
    there. The client and daemon don’t need to be on the same machine at all. If you’re
    using Docker on a non-Linux OS, the client is on your host OS, but the daemon
    runs inside a VM. Because all the files in the build directory are uploaded to
    the daemon, if it contains many large files and the daemon isn’t running locally,
    the upload may take longer.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程不是由Docker客户端执行的。相反，整个目录的内容被上传到Docker守护进程，并在那里构建镜像。客户端和守护进程不需要在同一个机器上。如果你在非Linux操作系统上使用Docker，客户端位于你的宿主操作系统上，但守护进程在虚拟机内部运行。因为构建目录中的所有文件都上传到了守护进程，如果它包含许多大文件且守护进程没有本地运行，上传可能需要更长的时间。
- en: '|  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don’t include any unnecessary files in the build directory, because they’ll
    slow down the build process—especially when the Docker daemon is on a remote machine.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在构建目录中包含任何不必要的文件，因为它们会减慢构建过程——尤其是在Docker守护进程在远程机器上时。
- en: '|  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: During the build process, Docker will first pull the base image (node:7) from
    the public image repository (Docker Hub), unless the image has already been pulled
    and is stored on your machine.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，Docker将首先从公共镜像仓库（Docker Hub）拉取基础镜像（node:7），除非该镜像已经被拉取并存储在你的机器上。
- en: Understanding image layers
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 理解镜像层
- en: An image isn’t a single, big, binary blob, but is composed of multiple layers,
    which you may have already noticed when running the busybox example (there were
    multiple `Pull complete` lines—one for each layer). Different images may share
    several layers, which makes storing and transferring images much more efficient.
    For example, if you create multiple images based on the same base image (such
    as `node:7` in the example), all the layers comprising the base image will be
    stored only once. Also, when pulling an image, Docker will download each layer
    individually. Several layers may already be stored on your machine, so Docker
    will only download those that aren’t.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像不是一个单一的、大的二进制块，而是由多个层组成，你可能已经在运行busybox示例时注意到了这一点（有多个 `Pull complete` 行——每一行对应一个层）。不同的镜像可能共享几个层，这使得存储和传输镜像变得更加高效。例如，如果你基于相同的基镜像创建了多个镜像（例如示例中的
    `node:7`），构成基镜像的所有层将只存储一次。此外，在拉取镜像时，Docker将单独下载每一层。可能已经有几个层存储在你的机器上，所以Docker只会下载那些尚未下载的层。
- en: You may think that each Dockerfile creates only a single new layer, but that’s
    not the case. When building an image, a new layer is created for each individual
    command in the Dockerfile. During the build of your image, after pulling all the
    layers of the base image, Docker will create a new layer on top of them and add
    the app.js file into it. Then it will create yet another layer that will specify
    the command that should be executed when the image is run. This last layer will
    then be tagged as `kubia:latest`. This is shown in [figure 2.3](#filepos202243),
    which also shows how a different image called `other:latest` would use the same
    layers of the Node.js image as your own image does.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能会认为每个Dockerfile只创建一个新层，但这并不是事实。在构建镜像时，Dockerfile中的每个单独命令都会创建一个新的层。在你的镜像构建过程中，在拉取所有基础镜像层之后，Docker将在它们之上创建一个新的层并将app.js文件添加进去。然后它将创建另一个层，该层将指定在运行镜像时应执行的命令。这个最后的层将被标记为`kubia:latest`。这如图2.3[figure
    2.3](#filepos202243)所示，它还显示了另一个名为`other:latest`的不同镜像如何使用与你的镜像相同的Node.js镜像层。 '
- en: Figure 2.3\. Container images are composed of layers that can be shared among
    different images.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3\. 容器镜像由可以供不同镜像共享的层组成。
- en: '![](images/00058.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/00058.jpg)'
- en: When the build process completes, you have a new image stored locally. You can
    see it by telling Docker to list all locally stored images, as shown in the following
    listing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建过程完成后，你将在本地存储一个新镜像。你可以通过告诉Docker列出所有本地存储的镜像来查看它，如下面的列表所示。
- en: Listing 2.4\. Listing locally stored images
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4\. 列出本地存储的镜像
- en: '`$ docker images` `REPOSITORY   TAG      IMAGE ID           CREATED            
    VIRTUAL SIZE kubia        latest   d30ecc7419e7       1 minute ago        637.1
    MB ...`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker images` `REPOSITORY   TAG      IMAGE ID           CREATED            
    VIRTUAL SIZE kubia        latest   d30ecc7419e7       1 minute ago        637.1
    MB ...`'
- en: Comparing building images with a Dockerfile vs. manually
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 比较使用Dockerfile构建镜像与手动构建
- en: Dockerfiles are the usual way of building container images with Docker, but
    you could also build the image manually by running a container from an existing
    image, executing commands in the container, exiting the container, and committing
    the final state as a new image. This is exactly what happens when you build from
    a Dockerfile, but it’s performed automatically and is repeatable, which allows
    you to make changes to the Dockerfile and rebuild the image any time, without
    having to manually retype all the commands again.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile是使用Docker构建容器镜像的常用方式，但你也可以通过从现有镜像运行一个容器、在容器中执行命令、退出容器并将最终状态提交为新的镜像来手动构建镜像。这正是从Dockerfile构建时发生的情况，但它会自动执行且可重复，这允许你随时修改Dockerfile并重新构建镜像，而无需再次手动输入所有命令。
- en: 2.1.5\. Running the container image
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1.5\. 运行容器镜像
- en: 'You can now run your image with the following command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以使用以下命令运行你的镜像：
- en: '`$ docker run --name kubia-container -p 8080:8080 -d kubia`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker run --name kubia-container -p 8080:8080 -d kubia`'
- en: This tells Docker to run a new container called `kubia-container` from the `kubia`
    image. The container will be detached from the console (`-d` flag), which means
    it will run in the background. Port 8080 on the local machine will be mapped to
    port 8080 inside the container (`-p 8080:8080` option), so you can access the
    app through http://localhost:8080\.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Docker从一个名为`kubia`的镜像运行一个新的容器`kubia-container`。容器将从控制台分离（`-d`标志），这意味着它将在后台运行。本地机器上的8080端口将被映射到容器内的8080端口（`-p
    8080:8080`选项），因此你可以通过http://localhost:8080访问应用。
- en: If you’re not running the Docker daemon on your local machine (if you’re using
    a Mac or Windows, the daemon is running inside a VM), you’ll need to use the hostname
    or IP of the VM running the daemon instead of localhost. You can look it up through
    the `DOCKER_HOST` environment variable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在本地机器上运行Docker守护进程（如果你使用Mac或Windows，守护进程在虚拟机中运行），你需要使用运行守护进程的虚拟机的主机名或IP地址而不是localhost。你可以通过`DOCKER_HOST`环境变量来查找它。
- en: Accessing your app
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 访问你的应用
- en: 'Now try to access your application at http://localhost:8080 (be sure to replace
    localhost with the hostname or IP of the Docker host if necessary):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试通过http://localhost:8080访问你的应用（如果需要，请确保将localhost替换为Docker主机的主机名或IP地址）：
- en: '`$ curl localhost:8080` `You''ve hit 44d76963e8e1`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ curl localhost:8080` `您已访问44d76963e8e1`'
- en: That’s the response from your app. Your tiny application is now running inside
    a container, isolated from everything else. As you can see, it’s returning `44d76963e8e1`
    as its hostname, and not the actual hostname of your host machine. The hexadecimal
    number is the ID of the Docker container.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是您应用程序的响应。您的小型应用程序现在正在容器内运行，与其他所有内容隔离。如您所见，它正在返回`44d76963e8e1`作为其主机名，而不是您主机机的实际主机名。这个十六进制数是Docker容器的ID。
- en: Listing all running containers
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列出所有正在运行的容器
- en: Let’s list all running containers in the following listing, so you can examine
    the list (I’ve edited the output to make it more readable—imagine the last two
    lines as the continuation of the first two).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下面的列表中列出所有正在运行的容器，这样您就可以检查列表（我已经编辑了输出以使其更易于阅读——想象最后两行是前两行的延续）。
- en: Listing 2.5\. Listing running containers
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5\. 列出正在运行的容器
- en: '`$ docker ps` `CONTAINER ID  IMAGE         COMMAND               CREATED       
    ... 44d76963e8e1  kubia:latest  "/bin/sh -c ''node ap  6 minutes ago  ...  ... 
    STATUS              PORTS                    NAMES ...  Up 6 minutes        0.0.0.0:8080->8080/tcp  
    kubia-container`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker ps` `CONTAINER ID  IMAGE         COMMAND               CREATED       
    ... 44d76963e8e1  kubia:latest  "/bin/sh -c ''node ap  6 minutes ago  ...  ... 
    STATUS              PORTS                    NAMES ...  Up 6 minutes        0.0.0.0:8080->8080/tcp  
    kubia-container`'
- en: A single container is running. For each container, Docker prints out its ID
    and name, the image used to run the container, and the command that’s executing
    inside the container.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 单个容器正在运行。对于每个容器，Docker都会打印出其ID和名称、运行容器的镜像以及容器内正在执行的命令。
- en: Getting additional information about a container
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 获取关于容器的额外信息
- en: 'The `docker ps` command only shows the most basic information about the containers.
    To see additional information, you can use `docker inspect`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps`命令只显示关于容器最基本的信息。要查看更多信息，您可以使用`docker inspect`：'
- en: '`$ docker inspect kubia-container`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker inspect kubia-container`'
- en: Docker will print out a long JSON containing low-level information about the
    container.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将打印出一个包含关于容器低级信息的长JSON。
- en: 2.1.6\. Exploring the inside of a running container
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1.6\. 探索正在运行的容器内部
- en: What if you want to see what the environment is like inside the container? Because
    multiple processes can run inside the same container, you can always run an additional
    process in it to see what’s inside. You can even run a shell, provided that the
    shell’s binary executable is available in the image.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想看看容器内部的环境是什么样的呢？因为多个进程可以在同一个容器内运行，所以您总是可以在其中运行一个额外的进程来查看内部情况。如果您提供的镜像中包含shell的二进制可执行文件，您甚至可以运行一个shell。
- en: Running a shell inside an existing container
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有容器内运行shell
- en: 'The Node.js image on which you’ve based your image contains the bash shell,
    so you can run the shell inside the container like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您基于的Node.js镜像包含bash shell，因此您可以在容器内部像这样运行shell：
- en: '`$ docker exec -it kubia-container bash`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker exec -it kubia-container bash`'
- en: 'This will run `bash` inside the existing `kubia-container` container. The `bash`
    process will have the same Linux namespaces as the main container process. This
    allows you to explore the container from within and see how Node.js and your app
    see the system when running inside the container. The `-it` option is shorthand
    for two options:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在现有的`kubia-container`容器内部运行`bash`。`bash`进程将具有与主容器进程相同的Linux命名空间。这允许您从容器内部探索容器，并查看Node.js和您的应用程序在容器内运行时如何看待系统。`-it`选项是两个选项的缩写：
- en: '`-i`, which makes sure STDIN is kept open. You need this for entering commands
    into the shell.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i`，这确保STDIN保持打开。您需要这个来向shell输入命令。'
- en: '`-t`, which allocates a pseudo terminal (TTY).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t`，这会分配一个伪终端（TTY）。'
- en: You need both if you want the use the shell like you’re used to. (If you leave
    out the first one, you can’t type any commands, and if you leave out the second
    one, the command prompt won’t be displayed and some commands will complain about
    the `TERM` variable not being set.)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想像平时一样使用shell，您需要两者。 （如果您省略了第一个，您就不能输入任何命令，如果您省略了第二个，命令提示符将不会显示，并且某些命令会抱怨`TERM`变量未设置。）
- en: Exploring the container from within
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从容器内部探索容器
- en: Let’s see how to use the shell in the following listing to see the processes
    running in the container.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在以下列表中使用shell来查看容器内正在运行的进程。
- en: Listing 2.6\. Listing processes from inside a container
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.6\. 从容器内部列出进程
- en: '`root@44d76963e8e1:/# ps aux` `USER  PID %CPU %MEM    VSZ   RSS TTY STAT START
    TIME COMMAND root    1  0.0  0.1 676380 16504 ?   Sl   12:31 0:00 node app.js
    root   10  0.0  0.0  20216  1924 ?   Ss   12:31 0:00 bash root   19  0.0  0.0 
    17492  1136 ?   R+   12:38 0:00 ps aux`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`root@44d76963e8e1:/# ps aux` `USER  PID %CPU %MEM    VSZ   RSS TTY STAT START
    TIME COMMAND root    1  0.0  0.1 676380 16504 ?   Sl   12:31 0:00 node app.js
    root   10  0.0  0.0  20216  1924 ?   Ss   12:31 0:00 bash root   19  0.0  0.0 
    17492  1136 ?   R+   12:38 0:00 ps aux`'
- en: You see only three processes. You don’t see any other processes from the host
    OS.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能看到三个进程。你看不到宿主OS上的任何其他进程。
- en: Understanding that processes in a container run in the host operating system
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 了解容器中的进程是在宿主操作系统上运行的
- en: If you now open another terminal and list the processes on the host OS itself,
    you will, among all other host processes, also see the processes running in the
    container, as shown in [listing 2.7](#filepos210585).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在打开另一个终端并列出宿主OS上的进程，你将在所有其他宿主进程之间，也会看到容器中运行的进程，如[列表2.7](#filepos210585)所示。
- en: '|  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re using a Mac or Windows, you’ll need to log into the VM where the Docker
    daemon is running to see these processes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Mac或Windows，你需要登录到Docker守护进程正在运行的虚拟机中，才能看到这些进程。
- en: '|  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 2.7\. A container’s processes run in the host OS
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.7\. 容器的进程在宿主OS上运行
- en: '`$ ps aux | grep app.js USER  PID %CPU %MEM    VSZ   RSS TTY STAT START TIME
    COMMAND root  382  0.0  0.1 676380 16504 ?   Sl   12:31 0:00 node app.js`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ ps aux | grep app.js USER  PID %CPU %MEM    VSZ   RSS TTY STAT START TIME
    COMMAND root  382  0.0  0.1 676380 16504 ?   Sl   12:31 0:00 node app.js`'
- en: This proves that processes running in the container are running in the host
    OS. If you have a keen eye, you may have noticed that the processes have different
    IDs inside the container vs. on the host. The container is using its own PID Linux
    namespace and has a completely isolated process tree, with its own sequence of
    numbers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了在容器中运行的进程是在宿主OS上运行的。如果你有敏锐的观察力，你可能已经注意到容器内部与宿主上的进程ID不同。容器正在使用自己的PID Linux命名空间，并且有一个完全隔离的进程树，有自己的数字序列。
- en: The container’s filesystem is also isolated
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的文件系统也是隔离的
- en: Like having an isolated process tree, each container also has an isolated filesystem.
    Listing the contents of the root directory inside the container will only show
    the files in the container and will include all the files that are in the image
    plus any files that are created while the container is running (log files and
    similar), as shown in the following listing.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 就像有一个隔离的进程树一样，每个容器也有一个隔离的文件系统。列出容器内根目录的内容只会显示容器中的文件，并将包括镜像中的所有文件以及容器运行期间创建的任何文件（日志文件等），如下面的列表所示。
- en: Listing 2.8\. A container has its own complete filesystem
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8\. 容器拥有自己的完整文件系统
- en: '`root@44d76963e8e1:/# ls /` `app.js  boot  etc   lib    media  opt   root 
    sbin  sys  usr bin     dev   home  lib64  mnt    proc  run   srv   tmp  var`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`root@44d76963e8e1:/# ls /` `app.js  boot  etc   lib    media  opt   root 
    sbin  sys  usr bin     dev   home  lib64  mnt    proc  run   srv   tmp  var`'
- en: It contains the app.js file and other system directories that are part of the
    `node:7` base image you’re using. To exit the container, you exit the shell by
    running the `exit` command and you’ll be returned to your host machine (like logging
    out of an ssh session, for example).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含`app.js`文件和其他系统目录，这些目录是`node:7`基础镜像的一部分。要退出容器，通过运行`exit`命令退出shell，你将返回到宿主机器（例如，从ssh会话注销）。
- en: '|  |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Entering a running container like this is useful when debugging an app running
    in a container. When something’s wrong, the first thing you’ll want to explore
    is the actual state of the system your application sees. Keep in mind that an
    application will not only see its own unique filesystem, but also processes, users,
    hostname, and network interfaces.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式进入正在运行的容器非常有用，当你调试容器中运行的程序时。当出现问题的时候，你首先想探索的是应用程序所看到的实际系统状态。请记住，应用程序不仅会看到它自己的唯一文件系统，还会看到进程、用户、主机名和网络接口。
- en: '|  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.1.7\. Stopping and removing a container
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1.7\. 停止和删除容器
- en: 'To stop your app, you tell Docker to stop the `kubia-container` container:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止你的应用程序，你告诉Docker停止`kubia-container`容器：
- en: '`$ docker stop kubia-container`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker stop kubia-container`'
- en: 'This will stop the main process running in the container and consequently stop
    the container, because no other processes are running inside the container. The
    container itself still exists and you can see it with `docker ps -a`. The `-a`
    option prints out all the containers, those running and those that have been stopped.
    To truly remove a container, you need to remove it with the `docker rm` command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将停止容器中运行的主进程，从而停止容器，因为容器内没有其他进程在运行。容器本身仍然存在，你可以使用`docker ps -a`来查看它。`-a`选项会打印出所有容器，包括正在运行的和已经停止的。要真正删除一个容器，你需要使用`docker
    rm`命令来删除它：
- en: '`$ docker rm kubia-container`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker rm kubia-container`'
- en: This deletes the container. All its contents are removed and it can’t be started
    again.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除容器。所有内容都将被删除，并且无法再次启动。
- en: 2.1.8\. Pushing the image to an image registry
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 2.1.8\. 将图像推送到图像注册表
- en: The image you’ve built has so far only been available on your local machine.
    To allow you to run it on any other machine, you need to push the image to an
    external image registry. For the sake of simplicity, you won’t set up a private
    image registry and will instead push the image to Docker Hub ([http://hub.docker.com](http://hub.docker.com)),
    which is one of the publicly available registries. Other widely used such registries
    are Quay.io and the Google Container Registry.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你构建的图像到目前为止只在你本地机器上可用。为了允许你在任何其他机器上运行它，你需要将图像推送到外部图像注册表。为了简化，你不会设置私有图像注册表，而是将图像推送到Docker
    Hub ([http://hub.docker.com](http://hub.docker.com))，这是公开可用的注册表之一。其他广泛使用的注册表包括Quay.io和Google
    Container Registry。
- en: Before you do that, you need to re-tag your image according to Docker Hub’s
    rules. Docker Hub will allow you to push an image if the image’s repository name
    starts with your Docker Hub ID. You create your Docker Hub ID by registering at
    [http://hub.docker.com](http://hub.docker.com). I’ll use my own ID (`luksa`) in
    the following examples. Please change every occurrence with your own ID.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在你这样做之前，你需要根据Docker Hub的规则重新标记你的图像。如果图像的仓库名称以你的Docker Hub ID开头，Docker Hub将允许你推送图像。你通过在[http://hub.docker.com](http://hub.docker.com)注册来创建你的Docker
    Hub ID。在下面的示例中，我将使用我的ID（`luksa`）。请将所有出现的地方都替换为你的ID。
- en: Tagging an image under an additional tag
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在附加标签下标记图像
- en: 'Once you know your ID, you’re ready to rename your image, currently tagged
    as `kubia`, to `luksa/kubia` (replace `luksa` with your own Docker Hub ID):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道你的ID，你就可以准备重命名你的图像，当前标记为`kubia`，为`luksa/kubia`（将`luksa`替换为你的Docker Hub
    ID）：
- en: '`$ docker tag kubia luksa/kubia`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker tag kubia luksa/kubia`'
- en: This doesn’t rename the tag; it creates an additional tag for the same image.
    You can confirm this by listing the images stored on your system with the `docker
    images` command, as shown in the following listing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会重命名标签；它为相同的图像创建了一个额外的标签。你可以通过使用`docker images`命令列出你系统上存储的图像来确认这一点，如下面的列表所示。
- en: Listing 2.9\. A container image can have multiple tags
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.9\. 一个容器图像可以有多个标签
- en: '`$ docker images | head` `REPOSITORY        TAG      IMAGE ID        CREATED            
    VIRTUAL SIZE luksa/kubia       latest   d30ecc7419e7    About an hour ago   654.5
    MB kubia             latest   d30ecc7419e7    About an hour ago   654.5 MB docker.io/node   
    7.0      04c0ca2a8dad    2 days ago          654.5 MB ...`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker images | head` `REPOSITORY        TAG      IMAGE ID        CREATED            
    VIRTUAL SIZE luksa/kubia       latest   d30ecc7419e7    大约一个小时前   654.5 MB kubia            
    latest   d30ecc7419e7    大约一个小时前   654.5 MB docker.io/node    7.0      04c0ca2a8dad   
    两天前          654.5 MB ...`'
- en: As you can see, both `kubia` and `luksa/kubia` point to the same image ID, so
    they’re in fact one single image with two tags.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`kubia`和`luksa/kubia`都指向相同的图像ID，因此它们实际上是一个带有两个标签的单个图像。
- en: Pushing the image to Docker Hub
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像推送到Docker Hub
- en: 'Before you can push the image to Docker Hub, you need to log in under your
    user ID with the `docker login` command. Once you’re logged in, you can finally
    push the `yourid/kubia` image to Docker Hub like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以将图像推送到Docker Hub之前，你需要使用`docker login`命令以你的用户ID登录。一旦登录，你就可以像这样最终将`yourid/kubia`图像推送到Docker
    Hub：
- en: '`$ docker push luksa/kubia`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker push luksa/kubia`'
- en: Running the image on a different machine
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同机器上运行图像
- en: 'After the push to Docker Hub is complete, the image will be available to everyone.
    You can now run the image on any machine running Docker by executing the following
    command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在将图像推送到Docker Hub完成后，图像将对每个人可用。你现在可以在任何运行Docker的机器上运行该图像，只需执行以下命令：
- en: '`$ docker run -p 8080:8080 -d luksa/kubia`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker run -p 8080:8080 -d luksa/kubia`'
- en: It doesn’t get much simpler than that. And the best thing about this is that
    your application will have the exact same environment every time and everywhere
    it’s run. If it ran fine on your machine, it should run as well on every other
    Linux machine. No need to worry about whether the host machine has Node.js installed
    or not. In fact, even if it does, your app won’t use it, because it will use the
    one installed inside the image.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比这更简单了。而且，最好的事情是，你的应用程序每次运行时都会在相同的环境中运行。如果它在你的机器上运行良好，它也应该在其他任何 Linux 机器上运行良好。无需担心主机机器是否安装了
    Node.js。实际上，即使安装了，你的应用程序也不会使用它，因为它将使用镜像内部安装的版本。
- en: 2.2\. Setting up a Kubernetes cluster
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 2.2\. 设置 Kubernetes 集群
- en: Now that you have your app packaged inside a container image and made available
    through Docker Hub, you can deploy it in a Kubernetes cluster instead of running
    it in Docker directly. But first, you need to set up the cluster itself.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将你的应用程序打包在容器镜像中并通过 Docker Hub 提供了，你可以在 Kubernetes 集群中部署它，而不是直接在 Docker
    中运行。但首先，你需要设置集群本身。
- en: Setting up a full-fledged, multi-node Kubernetes cluster isn’t a simple task,
    especially if you’re not well-versed in Linux and networking administration. A
    proper Kubernetes install spans multiple physical or virtual machines and requires
    the networking to be set up properly, so that all the containers running inside
    the Kubernetes cluster can connect to each other through the same flat networking
    space.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个完整的、多节点的 Kubernetes 集群不是一项简单的任务，尤其是如果你不熟悉 Linux 和网络管理。一个合适的 Kubernetes 安装跨越多个物理或虚拟机器，并需要正确设置网络，以便
    Kubernetes 集群内部运行的所有容器都能通过相同的扁平网络空间相互连接。
- en: A long list of methods exists for installing a Kubernetes cluster. These methods
    are described in detail in the documentation at [http://kubernetes.io](http://kubernetes.io).
    We’re not going to list all of them here, because the list keeps evolving, but
    Kubernetes can be run on your local development machine, your own organization’s
    cluster of machines, on cloud providers providing virtual machines (Google Compute
    Engine, Amazon EC2, Microsoft Azure, and so on), or by using a managed Kubernetes
    cluster such as Google Kubernetes Engine (previously known as Google Container
    Engine).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Kubernetes 集群的方法有很多。这些方法在 [http://kubernetes.io](http://kubernetes.io) 的文档中有详细描述。我们不会在这里列出所有方法，因为列表不断在变化，但
    Kubernetes 可以运行在你的本地开发机器上，你自己的组织机器集群上，在提供虚拟机的云服务提供商（如 Google Compute Engine、Amazon
    EC2、Microsoft Azure 等）上，或者通过使用管理的 Kubernetes 集群，例如 Google Kubernetes Engine（之前称为
    Google Container Engine）。
- en: In this chapter, we’ll cover two simple options for getting your hands on a
    running Kubernetes cluster. You’ll see how to run a single-node Kubernetes cluster
    on your local machine and how to get access to a hosted cluster running on Google
    Kubernetes Engine (GKE).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍两种简单的方法来获取一个正在运行的 Kubernetes 集群。你将看到如何在你的本地机器上运行一个单节点 Kubernetes 集群，以及如何访问运行在
    Google Kubernetes Engine（GKE）上的托管集群。
- en: A third option, which covers installing a cluster with the `kubeadm` tool, is
    explained in [appendix B](index_split_138.html#filepos1737471). The instructions
    there show you how to set up a three-node Kubernetes cluster using virtual machines,
    but I suggest you try it only after reading the first 11 chapters of the book.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项，涵盖了使用 `kubeadm` 工具安装集群，在 [附录 B](index_split_138.html#filepos1737471) 中有解释。那里的说明展示了如何使用虚拟机设置一个三节点
    Kubernetes 集群，但我建议你在阅读本书的前 11 章后再尝试。
- en: Another option is to install Kubernetes on Amazon’s AWS (Amazon Web Services).
    For this, you can look at the `kops` tool, which is built on top of `kubeadm`
    mentioned in the previous paragraph, and is available at [http://github.com/kubernetes/kops](http://github.com/kubernetes/kops).
    It helps you deploy production-grade, highly available Kubernetes clusters on
    AWS and will eventually support other platforms as well (Google Kubernetes Engine,
    VMware, vSphere, and so on).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是将 Kubernetes 安装在亚马逊的 AWS（Amazon Web Services）上。为此，你可以查看 `kops` 工具，它建立在前面提到的
    `kubeadm` 之上，可在 [http://github.com/kubernetes/kops](http://github.com/kubernetes/kops)
    找到。它可以帮助你在 AWS 上部署生产级别的、高可用的 Kubernetes 集群，并最终支持其他平台（如 Google Kubernetes Engine、VMware、vSphere
    等）。
- en: 2.2.1\. Running a local single-node Kubernetes cluster with Minikube
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 2.2.1\. 使用 Minikube 运行本地单节点 Kubernetes 集群
- en: The simplest and quickest path to a fully functioning Kubernetes cluster is
    by using Minikube. Minikube is a tool that sets up a single-node cluster that’s
    great for both testing Kubernetes and developing apps locally.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Minikube 是实现一个完全功能化的 Kubernetes 集群最简单、最快的方法。Minikube 是一个工具，它设置了一个单节点集群，非常适合测试
    Kubernetes 和本地开发应用程序。
- en: Although we can’t show certain Kubernetes features related to managing apps
    on multiple nodes, the single-node cluster should be enough for exploring most
    topics discussed in this book.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们无法展示与多节点上管理应用程序相关的某些 Kubernetes 功能，但单节点集群应该足以探索本书中讨论的大多数主题。
- en: Installing Minikube
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Minikube
- en: Minikube is a single binary that needs to be downloaded and put onto your path.
    It’s available for OSX, Linux, and Windows. To install it, the best place to start
    is to go to the Minikube repository on GitHub ([http://github.com/kubernetes/minikube](http://github.com/kubernetes/minikube))
    and follow the instructions there.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube 是一个单二进制文件，需要下载并放置到你的路径中。它适用于 OSX、Linux 和 Windows。要安装它，最佳做法是访问 GitHub
    上的 Minikube 仓库 ([http://github.com/kubernetes/minikube](http://github.com/kubernetes/minikube))
    并遵循那里的说明。
- en: 'For example, on OSX and Linux, Minikube can be downloaded and set up with a
    single command. For OSX, this is what the command looks like:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 OSX 和 Linux 上，Minikube 可以通过单个命令下载和设置。对于 OSX，命令如下所示：
- en: '`$ curl -Lo minikube https://storage.googleapis.com/minikube/releases/`![](images/00006.jpg)`v0.23.0/minikube-darwin-amd64
    && chmod +x minikube && sudo mv minikube`![](images/00006.jpg)`/usr/local/bin/`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ curl -Lo minikube https://storage.googleapis.com/minikube/releases/`![](images/00006.jpg)`v0.23.0/minikube-darwin-amd64
    && chmod +x minikube && sudo mv minikube`![](images/00006.jpg)`/usr/local/bin/`'
- en: On Linux, you download a different release (replace “darwin” with “linux” in
    the URL). On Windows, you can download the file manually, rename it to minikube.exe,
    and put it onto your path. Minikube runs Kubernetes inside a VM run through either
    VirtualBox or KVM, so you also need to install one of them before you can start
    the Minikube cluster.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上，你需要下载不同的版本（在 URL 中将“darwin”替换为“linux”）。在 Windows 上，你可以手动下载文件，将其重命名为
    minikube.exe，并将其放置到你的路径中。Minikube 在通过 VirtualBox 或 KVM 运行的 VM 内运行 Kubernetes，因此在你开始
    Minikube 集群之前，你还需要安装其中一个。
- en: Starting a Kubernetes cluster with Minikube
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Minikube 启动 Kubernetes 集群
- en: Once you have Minikube installed locally, you can immediately start up the Kubernetes
    cluster with the command in the following listing.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在本地安装了 Minikube，你就可以立即使用以下列表中的命令启动 Kubernetes 集群。
- en: Listing 2.10\. Starting a Minikube virtual machine
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.10\. 启动 Minikube 虚拟机
- en: '`$ minikube start` `Starting local Kubernetes cluster... Starting VM... SSH-ing
    files into VM... ... Kubectl is now configured to use the cluster.`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ minikube start` `Starting local Kubernetes cluster... Starting VM... SSH-ing
    files into VM... ... Kubectl is now configured to use the cluster.`'
- en: Starting the cluster takes more than a minute, so don’t interrupt the command
    before it completes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 启动集群需要超过一分钟，所以不要在命令完成之前中断它。
- en: Installing the Kubernetes client (kubectl)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Kubernetes 客户端（kubectl）
- en: 'To interact with Kubernetes, you also need the `kubectl` CLI client. Again,
    all you need to do is download it and put it on your path. The latest stable release
    for OSX, for example, can be downloaded and installed with the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要与 Kubernetes 交互，你还需要 `kubectl` CLI 客户端。同样，你所需要做的只是下载它并将其放置到你的路径中。例如，OSX 的最新稳定版本可以通过以下命令下载和安装：
- en: '`$ curl -LO https://storage.googleapis.com/kubernetes-release/release`![](images/00006.jpg)`/$(curl
    -s https://storage.googleapis.com/kubernetes-release/release`![](images/00006.jpg)`/stable.txt)/bin/darwin/amd64/kubectl`![](images/00006.jpg)`&&
    chmod +x kubectl`![](images/00006.jpg)`&& sudo mv kubectl /usr/local/bin/`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ curl -LO https://storage.googleapis.com/kubernetes-release/release`![](images/00006.jpg)`/$(curl
    -s https://storage.googleapis.com/kubernetes-release/release`![](images/00006.jpg)`/stable.txt)/bin/darwin/amd64/kubectl`![](images/00006.jpg)`&&
    chmod +x kubectl`![](images/00006.jpg)`&& sudo mv kubectl /usr/local/bin/`'
- en: To download `kubectl` for Linux or Windows, replace `darwin` in the URL with
    either `linux` or `windows`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载 Linux 或 Windows 的 `kubectl`，将 URL 中的 `darwin` 替换为 `linux` 或 `windows`。
- en: '|  |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you’ll be using multiple Kubernetes clusters (for example, both Minikube
    and GKE), refer to [appendix A](index_split_135.html#filepos1721130) for information
    on how to set up and switch between different `kubectl` contexts.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将使用多个 Kubernetes 集群（例如，同时使用 Minikube 和 GKE），请参阅附录 A（index_split_135.html#filepos1721130）以获取有关如何设置和在不同
    `kubectl` 上下文之间切换的信息。
- en: '|  |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Checking to see the cluster is up and kubectl can talk to it
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 检查集群是否启动并且 kubectl 可以与之通信
- en: To verify your cluster is working, you can use the `kubectl cluster-info` command
    shown in the following listing.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证您的集群是否正常工作，您可以使用以下列表中的 `kubectl cluster-info` 命令。
- en: Listing 2.11\. Displaying cluster information
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.11\. 显示集群信息
- en: '`$ kubectl cluster-info` `Kubernetes master is running at https://192.168.99.100:8443
    KubeDNS is running at https://192.168.99.100:8443/api/v1/proxy/... kubernetes-dashboard
    is running at https://192.168.99.100:8443/api/v1/...`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl cluster-info` `Kubernetes master is running at https://192.168.99.100:8443
    KubeDNS is running at https://192.168.99.100:8443/api/v1/proxy/... kubernetes-dashboard
    is running at https://192.168.99.100:8443/api/v1/...`'
- en: This shows the cluster is up. It shows the URLs of the various Kubernetes components,
    including the API server and the web console.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明集群正在运行。它显示了各种 Kubernetes 组件的 URL，包括 API 服务器和网页控制台。
- en: '|  |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can run `minikube ssh` to log into the Minikube VM and explore it from the
    inside. For example, you may want to see what processes are running on the node.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行 `minikube ssh` 登录到 Minikube 虚拟机并从内部探索它。例如，您可能想查看节点上正在运行哪些进程。
- en: '|  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.2.2\. Using a hosted Kubernetes cluster with Google Kubernetes Engine
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 2.2.2\. 使用 Google Kubernetes Engine 托管 Kubernetes 集群
- en: If you want to explore a full-fledged multi-node Kubernetes cluster instead,
    you can use a managed Google Kubernetes Engine (GKE) cluster. This way, you don’t
    need to manually set up all the cluster nodes and networking, which is usually
    too much for someone making their first steps with Kubernetes. Using a managed
    solution such as GKE makes sure you don’t end up with a misconfigured, non-working,
    or partially working cluster.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想探索一个完整的、多节点的 Kubernetes 集群，您可以使用托管 Google Kubernetes Engine (GKE) 集群。这样，您就不需要手动设置所有集群节点和网络，这对于刚开始使用
    Kubernetes 的人来说通常太多。使用像 GKE 这样的托管解决方案可以确保您不会得到一个配置错误、无法工作或部分工作的集群。
- en: Setting up a Google Cloud project and downloading the necessary client binaries
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Google Cloud 项目并下载必要的客户端二进制文件
- en: Before you can set up a new Kubernetes cluster, you need to set up your GKE
    environment. Because the process may change, I’m not listing the exact instructions
    here. To get started, please follow the instructions at [https://cloud.google.com/container-engine/docs/before-you-begin](https://cloud.google.com/container-engine/docs/before-you-begin).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在您设置新的 Kubernetes 集群之前，您需要设置您的 GKE 环境。因为过程可能会改变，所以我这里没有列出具体的指令。要开始，请遵循[https://cloud.google.com/container-engine/docs/before-you-begin](https://cloud.google.com/container-engine/docs/before-you-begin)上的说明。
- en: Roughly, the whole procedure includes
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 大概来说，整个过程包括
- en: Signing up for a Google account, in the unlikely case you don’t have one already.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不太可能的情况下，如果您还没有 Google 账户，请注册一个。
- en: Creating a project in the Google Cloud Platform Console.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Google Cloud Platform 控制台中创建一个项目。
- en: Enabling billing. This does require your credit card info, but Google provides
    a 12-month free trial. And they’re nice enough to not start charging automatically
    after the free trial is over.)
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用计费。这确实需要您的信用卡信息，但 Google 提供了 12 个月的免费试用期。而且他们足够好，不会在免费试用期结束后自动开始收费。）
- en: Enabling the Kubernetes Engine API.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用 Kubernetes Engine API。
- en: Downloading and installing Google Cloud SDK. (This includes the gcloud command-line
    tool, which you’ll need to create a Kubernetes cluster.)
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并安装 Google Cloud SDK。（这包括 gcloud 命令行工具，您需要它来创建 Kubernetes 集群。）
- en: Installing the `kubectl` command-line tool with `gcloud components install kubectl`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `gcloud components install kubectl` 安装 `kubectl` 命令行工具。
- en: '|  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Certain operations (the one in step 2, for example) may take a few minutes to
    complete, so relax and grab a coffee in the meantime.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 某些操作（例如步骤 2 中的操作）可能需要几分钟才能完成，所以请放松，同时喝杯咖啡。
- en: '|  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Creating a Kubernetes cluster with three nodes
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含三个节点的 Kubernetes 集群
- en: After completing the installation, you can create a Kubernetes cluster with
    three worker nodes using the command shown in the following listing.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以使用以下列表中的命令创建一个包含三个工作节点的 Kubernetes 集群。
- en: Listing 2.12\. Creating a three-node cluster in GKE
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.12\. 在 GKE 中创建一个三节点集群
- en: '`$ gcloud container clusters create kubia --num-nodes 3`![](images/00006.jpg)`--machine-type
    f1-micro` `Creating cluster kubia...done. Created [https://container.googleapis.com/v1/projects/kubia1-
         1227/zones/europe-west1-d/clusters/kubia]. kubeconfig entry generated for
    kubia. NAME   ZONE   MST_VER MASTER_IP     TYPE     NODE_VER NUM_NODES STATUS
    kubia  eu-w1d 1.5.3   104.155.92.30 f1-micro 1.5.3    3         RUNNING`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ gcloud container clusters create kubia --num-nodes 3`![](images/00006.jpg)`--machine-type
    f1-micro` `Creating cluster kubia...done. Created [https://container.googleapis.com/v1/projects/kubia1-1227/zones/europe-west1-d/clusters/kubia].
    kubeconfig entry generated for kubia. NAME   ZONE   MST_VER MASTER_IP     TYPE    
    NODE_VER NUM_NODES STATUS kubia  eu-w1d 1.5.3   104.155.92.30 f1-micro 1.5.3   
    3         RUNNING`'
- en: You should now have a running Kubernetes cluster with three worker nodes as
    shown in [figure 2.4](#filepos230225). You’re using three nodes to help better
    demonstrate features that apply to multiple nodes. You can use a smaller number
    of nodes, if you want.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该有一个运行中的Kubernetes集群，其中包含三个工作节点，如[图2.4](#filepos230225)所示。您使用三个节点来更好地展示适用于多个节点的功能。如果您想的话，可以使用更少的节点。
- en: Figure 2.4\. How you’re interacting with your three-node Kubernetes cluster
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4\. 您如何与您的三节点Kubernetes集群交互
- en: '![](images/00078.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00078.jpg)'
- en: Getting an overview of your cluster
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 获取集群概览
- en: To give you a basic idea of what your cluster looks like and how to interact
    with it, see [figure 2.4](#filepos230225). Each node runs Docker, the Kubelet
    and the kube-proxy. You’ll interact with the cluster through the `kubectl` command
    line client, which issues REST requests to the Kubernetes API server running on
    the master node.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您对集群的外观和如何与之交互有一个基本的了解，请参阅[图2.4](#filepos230225)。每个节点都运行Docker、Kubelet和kube-proxy。您将通过`kubectl`命令行客户端与集群交互，该客户端向运行在主节点上的Kubernetes
    API服务器发出REST请求。
- en: Checking if the cluster is up by listing cluster nodes
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过列出集群节点来检查集群是否启动
- en: You’ll use the `kubectl` command now to list all the nodes in your cluster,
    as shown in the following listing.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在将使用`kubectl`命令列出您集群中的所有节点，如下所示。
- en: Listing 2.13\. Listing cluster nodes with `kubectl`
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.13\. 使用`kubectl`列出集群节点
- en: '`$ kubectl get nodes` `NAME                      STATUS  AGE  VERSION gke-kubia-85f6-node-0rrx 
    Ready   1m    v1.5.3 gke-kubia-85f6-node-heo1  Ready   1m    v1.5.3 gke-kubia-85f6-node-vs9f 
    Ready   1m    v1.5.3`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get nodes` `NAME                      STATUS  AGE  VERSION gke-kubia-85f6-node-0rrx 
    Ready   1m    v1.5.3 gke-kubia-85f6-node-heo1  Ready   1m    v1.5.3 gke-kubia-85f6-node-vs9f 
    Ready   1m    v1.5.3`'
- en: The `kubectl get` command can list all kinds of Kubernetes objects. You’ll use
    it constantly, but it usually shows only the most basic information for the listed
    objects.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl get`命令可以列出各种Kubernetes对象。您将经常使用它，但它通常只显示列出对象的最低级信息。'
- en: '|  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can log into one of the nodes with `gcloud compute ssh <node-name>` to explore
    what’s running on the node.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`gcloud compute ssh <node-name>`登录到其中一个节点，以探索节点上正在运行的内容。
- en: '|  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Retrieving additional details of an object
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 获取对象的额外详细信息
- en: 'To see more detailed information about an object, you can use the `kubectl
    describe` command, which shows much more:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看关于对象的更详细信息，您可以使用`kubectl describe`命令，它显示的信息更多：
- en: '`$ kubectl describe node gke-kubia-85f6-node-0rrx`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl describe node gke-kubia-85f6-node-0rrx`'
- en: I’m omitting the actual output of the `describe` command, because it’s fairly
    wide and would be completely unreadable here in the book. The output shows the
    node’s status, its CPU and memory data, system information, containers running
    on the node, and much more.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我省略了`describe`命令的实际输出，因为它相当宽，在这里的书本中会完全无法阅读。输出显示了节点的状态、其CPU和内存数据、系统信息、节点上运行的容器以及更多内容。
- en: In the previous `kubectl describe` example, you specified the name of the node
    explicitly, but you could also have performed a simple `kubectl describe node`
    without typing the node’s name and it would print out a detailed description of
    all the nodes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的`kubectl describe`示例中，您明确指定了节点的名称，但您也可以简单地执行一个不带节点名称的`kubectl describe node`，它将打印出所有节点的详细描述。
- en: '|  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Running the `describe` and `get` commands without specifying the name of the
    object comes in handy when only one object of a given type exists, so you don’t
    waste time typing or copy/pasting the object’s name.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有一个特定类型的对象存在时，不指定对象名称来运行`describe`和`get`命令会很有用，这样您就不会浪费时间输入或复制粘贴对象的名称。
- en: '|  |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: While we’re talking about reducing keystrokes, let me give you additional advice
    on how to make working with `kubectl` much easier, before we move on to running
    your first app in Kubernetes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论减少按键次数时，让我在继续运行你的第一个 Kubernetes 应用程序之前，给你一些额外的建议，让你使用 `kubectl` 的工作变得更简单。
- en: 2.2.3\. Setting up an alias and command-line completion for kubectl
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 2.2.3. 为 `kubectl` 设置别名和命令行补全
- en: You’ll use `kubectl` often. You’ll soon realize that having to type the full
    command every time is a real pain. Before you continue, take a minute to make
    your life easier by setting up an alias and tab completion for `kubectl`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常使用 `kubectl`。很快你就会意识到每次都必须输入完整的命令真的很痛苦。在你继续之前，花一分钟时间设置一个别名和 `kubectl` 的自动补全，让你的生活变得更轻松。
- en: Creating an alias
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 创建别名
- en: 'Throughout the book, I’ll always be using the full name of the `kubectl` executable,
    but you may want to add a short alias such as `k`, so you won’t have to type `kubectl`
    every time. If you haven’t used aliases yet, here’s how you define one. Add the
    following line to your `~/.bashrc` or equivalent file:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我都会使用 `kubectl` 可执行文件的完整名称，但你可能想添加一个简短的别名，比如 `k`，这样你就不必每次都输入 `kubectl`。如果你还没有使用过别名，这里是如何定义一个别名的方法。将以下行添加到你的
    `~/.bashrc` 或等效文件中：
- en: '`alias k=kubectl`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`alias k=kubectl`'
- en: '|  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may already have the `k` executable if you used `gcloud` to set up the cluster.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `gcloud` 设置集群，你可能已经有了 `k` 可执行文件。
- en: '|  |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Configuring tab completion for kubectl
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `kubectl` 配置自动补全
- en: Even with a short alias such as `k`, you’ll still need to type way more than
    you’d like. Luckily, the `kubectl` command can also output shell completion code
    for both the bash and zsh shell. It doesn’t enable tab completion of only command
    names, but also of the actual object names. For example, instead of having to
    write the whole node name in the previous example, all you’d need to type is
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是像 `k` 这样简短的别名，你仍然需要输入比你想的多的内容。幸运的是，`kubectl` 命令还可以为 bash 和 zsh shell 输出自动补全代码。它不仅启用了命令名称的自动补全，还启用了实际对象名称的自动补全。例如，在先前的例子中，你不需要输入整个节点名称，你只需要输入
- en: '`$ kubectl desc<TAB> no<TAB> gke-ku<TAB>`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl desc<TAB> no<TAB> gke-ku<TAB>`'
- en: 'To enable tab completion in bash, you’ll first need to install a package called
    `bash-completion` and then run the following command (you’ll probably also want
    to add it to `~/.bashrc` or equivalent):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 bash 中启用自动补全，你首先需要安装一个名为 `bash-completion` 的包，然后运行以下命令（你可能还希望将其添加到 `~/.bashrc`
    或等效文件中）：
- en: '`$ source <(kubectl completion bash)`'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ source <(kubectl completion bash)`'
- en: 'But there’s one caveat. When you run the preceding command, tab completion
    will only work when you use the full `kubectl` name (it won’t work when you use
    the `k` alias). To fix this, you need to transform the output of the `kubectl
    completion` command a bit:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个注意事项。当你运行前面的命令时，自动补全只会在你使用完整的 `kubectl` 名称时才起作用（使用 `k` 别名时不会起作用）。为了解决这个问题，你需要稍微修改一下
    `kubectl completion` 命令的输出：
- en: '`$ source <(kubectl completion bash | sed s/kubectl/k/g)`'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ source <(kubectl completion bash | sed s/kubectl/k/g)`'
- en: '|  |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Unfortunately, as I’m writing this, shell completion doesn’t work for aliases
    on MacOS. You’ll have to use the full `kubectl` command name if you want completion
    to work.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在我写这篇文章的时候，在 MacOS 上，shell 自动补全对别名不起作用。如果你想使用自动补全，你必须使用完整的 `kubectl` 命令名称。
- en: '|  |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now you’re all set to start interacting with your cluster without having to
    type too much. You can finally run your first app on Kubernetes.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好开始与你的集群交互，而无需输入太多。你终于可以在 Kubernetes 上运行你的第一个应用程序了。
- en: 2.3\. Running your first app on Kubernetes
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 2.3. 运行你的第一个 Kubernetes 应用程序
- en: Because this may be your first time, you’ll use the simplest possible way of
    running an app on Kubernetes. Usually, you’d prepare a JSON or YAML manifest,
    containing a description of all the components you want to deploy, but because
    we haven’t talked about the types of components you can create in Kubernetes yet,
    you’ll use a simple one-line command to get something running.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这可能是你的第一次，你将使用最简单的方法在 Kubernetes 上运行应用程序。通常，你会准备一个 JSON 或 YAML 清单，其中包含你想要部署的所有组件的描述，但由于我们还没有讨论你可以在
    Kubernetes 中创建的组件类型，你将使用一个简单的单行命令来运行一些内容。
- en: 2.3.1\. Deploying your Node.js app
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 2.3.1. 部署你的 Node.js 应用程序
- en: 'The simplest way to deploy your app is to use the `kubectl run` command, which
    will create all the necessary components without having to deal with JSON or YAML.
    This way, we don’t need to dive into the structure of each object yet. Try to
    run the image you created and pushed to Docker Hub earlier. Here’s how to run
    it in Kubernetes:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 部署您的应用程序最简单的方法是使用`kubectl run`命令，该命令将创建所有必要的组件，而无需处理JSON或YAML。这样，我们就不必深入研究每个对象的架构。尝试运行您之前创建并推送到Docker
    Hub的镜像。以下是您如何在Kubernetes中运行它的方法：
- en: '`$ kubectl run kubia --image=luksa/kubia --port=8080 --generator=run/v1` `replicationcontroller
    "kubia" created`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl run kubia --image=luksa/kubia --port=8080 --generator=run/v1` `replicationcontroller
    "kubia" created`'
- en: The `--image=luksa/kubia` part obviously specifies the container image you want
    to run, and the `--port=8080` option tells Kubernetes that your app is listening
    on port 8080\. The last flag (`--generator`) does require an explanation, though.
    Usually, you won’t use it, but you’re using it here so Kubernetes creates a ReplicationController
    instead of a Deployment. You’ll learn what ReplicationControllers are later in
    the chapter, but we won’t talk about Deployments until [chapter 9](index_split_074.html#filepos865425).
    That’s why I don’t want `kubectl` to create a Deployment yet.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`--image=luksa/kubia`部分显然指定了您想要运行的容器镜像，而`--port=8080`选项告诉Kubernetes您的应用程序正在监听8080端口。最后一个标志（`--generator`）确实需要解释。通常，您不会使用它，但在这里您使用它，以便Kubernetes创建一个ReplicationController而不是Deployment。您将在本章后面了解ReplicationController是什么，但我们不会在[第9章](index_split_074.html#filepos865425)之前讨论Deployment。这就是为什么我不想让`kubectl`现在就创建一个Deployment。'
- en: As the previous command’s output shows, a ReplicationController called `kubia`
    has been created. As already mentioned, we’ll see what that is later in the chapter.
    For now, let’s start from the bottom and focus on the container you created (you
    can assume a container has been created, because you specified a container image
    in the `run` command).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个命令的输出所示，已创建了一个名为`kubia`的ReplicationController。如前所述，我们将在本章后面了解它是什么。现在，让我们从底部开始，关注您创建的容器（您可以根据在`run`命令中指定的容器镜像来假设已经创建了一个容器）。
- en: Introducing Pods
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Pod介绍
- en: You may be wondering if you can see your container in a list showing all the
    running containers. Maybe something such as `kubectl get containers`? Well, that’s
    not exactly how Kubernetes works. It doesn’t deal with individual containers directly.
    Instead, it uses the concept of multiple co-located containers. This group of
    containers is called a Pod.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道您是否可以在显示所有运行容器的列表中看到您的容器。也许像`kubectl get containers`这样的命令？嗯，这并不是Kubernetes的工作方式。它不会直接处理单个容器。相反，它使用多个协同定位容器的概念。这个容器组被称为Pod。
- en: A pod is a group of one or more tightly related containers that will always
    run together on the same worker node and in the same Linux namespace(s). Each
    pod is like a separate logical machine with its own IP, hostname, processes, and
    so on, running a single application. The application can be a single process,
    running in a single container, or it can be a main application process and additional
    supporting processes, each running in its own container. All the containers in
    a pod will appear to be running on the same logical machine, whereas containers
    in other pods, even if they’re running on the same worker node, will appear to
    be running on a different one.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Pod是一组紧密相关的容器，这些容器将始终在同一个工作节点和同一个Linux命名空间（s）上一起运行。每个Pod就像一个独立的逻辑机器，拥有自己的IP地址、主机名、进程等，运行单个应用程序。该应用程序可以是一个单独的进程，在单个容器中运行，或者它可以是主应用程序进程和附加的辅助进程，每个进程都在自己的容器中运行。Pod中的所有容器看起来就像在同一个逻辑机器上运行，而其他Pod中的容器，即使它们运行在同一个工作节点上，看起来就像在另一个节点上运行。
- en: To better understand the relationship between containers, pods, and nodes, examine
    [figure 2.5](#filepos241044). As you can see, each pod has its own IP and contains
    one or more containers, each running an application process. Pods are spread out
    across different worker nodes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解容器、Pod和节点之间的关系，请查看[图2.5](#filepos241044)。正如您所看到的，每个Pod都有自己的IP地址，并包含一个或多个容器，每个容器运行一个应用程序进程。Pod被分散在不同的工作节点上。
- en: Figure 2.5\. The relationship between containers, pods, and physical worker
    nodes
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5\. 容器、Pod和物理工作节点之间的关系
- en: '![](images/00096.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/00096.jpg)'
- en: Listing pods
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 列出Pod
- en: Because you can’t list individual containers, since they’re not standalone Kubernetes
    objects, can you list pods instead? Yes, you can. Let’s see how to tell `kubectl`
    to list pods in the following listing.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您不能列出单个容器，因为它们不是独立的 Kubernetes 对象，您能否列出 pods？是的，您可以。让我们看看如何告诉 `kubectl` 列出
    pods，如下面的列表所示。
- en: Listing 2.14\. Listing pods
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.14\. 列出 pods
- en: '`$ kubectl get pods` `NAME          READY     STATUS    RESTARTS   AGE kubia-4jfyf  
    0/1       Pending   0          1m`'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get pods` `NAME          READY     STATUS    RESTARTS   AGE kubia-4jfyf  
    0/1       Pending   0          1m`'
- en: This is your pod. Its status is still `Pending` and the pod’s single container
    is shown as not ready yet (this is what the `0/1` in the `READY` column means).
    The reason why the pod isn’t running yet is because the worker node the pod has
    been assigned to is downloading the container image before it can run it. When
    the download is finished, the pod’s container will be created and then the pod
    will transition to the `Running` state, as shown in the following listing.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你的 pod。其状态仍然是 `Pending`，pod 的单个容器显示为尚未就绪（这就是 `READY` 列中的 `0/1` 的含义）。pod 尚未运行的原因是因为分配给
    pod 的工作节点正在下载容器镜像，以便运行它。下载完成后，pod 的容器将被创建，然后 pod 将过渡到 `Running` 状态，如下面的列表所示。
- en: Listing 2.15\. Listing pods again to see if the pod’s status has changed
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.15\. 再次列出 pods 以查看 pod 的状态是否已更改
- en: '`$ kubectl get pods` `NAME          READY     STATUS    RESTARTS   AGE kubia-4jfyf  
    1/1       Running   0          5m`'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get pods` `NAME          READY     STATUS    RESTARTS   AGE kubia-4jfyf  
    1/1       Running   0          5m`'
- en: To see more information about the pod, you can also use the `kubectl describe
    pod` command, like you did earlier for one of the worker nodes. If the pod stays
    stuck in the Pending status, it might be that Kubernetes can’t pull the image
    from the registry. If you’re using your own image, make sure it’s marked as public
    on Docker Hub. To make sure the image can be pulled successfully, try pulling
    the image manually with the `docker pull` command on another machine.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看有关 pod 的更多信息，您还可以使用 `kubectl describe pod` 命令，就像您之前为工作节点之一所做的那样。如果 pod 一直处于
    `Pending` 状态，可能是因为 Kubernetes 无法从注册表中拉取镜像。如果您使用的是自己的镜像，请确保它在 Docker Hub 上标记为公共。为了确保镜像可以成功拉取，请尝试在另一台机器上使用
    `docker pull` 命令手动拉取镜像。
- en: Understanding what happened behind the scenes
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 理解幕后发生的事情
- en: To help you visualize what transpired, look at [figure 2.6](#filepos243941).
    It shows both steps you had to perform to get a container image running inside
    Kubernetes. First, you built the image and pushed it to Docker Hub. This was necessary
    because building the image on your local machine only makes it available on your
    local machine, but you needed to make it accessible to the Docker daemons running
    on your worker nodes.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你可视化所发生的事情，请查看 [图 2.6](#filepos243941)。它显示了您必须执行的两个步骤，以便在 Kubernetes 内运行容器镜像。首先，您构建了镜像并将其推送到
    Docker Hub。这是必要的，因为仅在您的本地机器上构建镜像只会使其在本地机器上可用，但您需要使其对运行在工作节点上的 Docker 守护进程可访问。
- en: Figure 2.6\. Running the `luksa/kubia` container image in Kubernetes
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6\. 在 Kubernetes 中运行 `luksa/kubia` 容器镜像
- en: '![](images/00113.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00113.jpg)'
- en: When you ran the `kubectl` command, it created a new ReplicationController object
    in the cluster by sending a REST HTTP request to the Kubernetes API server. The
    ReplicationController then created a new pod, which was then scheduled to one
    of the worker nodes by the Scheduler. The Kubelet on that node saw that the pod
    was scheduled to it and instructed Docker to pull the specified image from the
    registry because the image wasn’t available locally. After downloading the image,
    Docker created and ran the container.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行 `kubectl` 命令时，它通过向 Kubernetes API 服务器发送 REST HTTP 请求，在集群中创建了一个新的 ReplicationController
    对象。然后 ReplicationController 创建了一个新的 pod，该 pod 由调度器调度到工作节点之一。该节点上的 Kubelet 看到pod被调度到它，并指示
    Docker 从注册表中拉取指定的镜像，因为镜像在本地不可用。下载镜像后，Docker 创建并运行了容器。
- en: The other two nodes are displayed to show context. They didn’t play any role
    in the process, because the pod wasn’t scheduled to them.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 显示其他两个节点是为了提供上下文。它们在过程中没有发挥作用，因为 pod 没有被调度到它们。
- en: '|  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 定义
- en: The term scheduling means assigning the pod to a node. The pod is run immediately,
    not at a time in the future as the term might lead you to believe.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 术语调度意味着将 pod 分配到节点。pod 将立即运行，而不是像术语可能让你认为的那样在未来某个时间运行。
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.3.2\. Accessing your web application
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 2.3.2\. 访问您的 Web 应用程序
- en: With your pod running, how do you access it? We mentioned that each pod gets
    its own IP address, but this address is internal to the cluster and isn’t accessible
    from outside of it. To make the pod accessible from the outside, you’ll expose
    it through a Service object. You’ll create a special service of type `LoadBalancer`,
    because if you create a regular service (a `ClusterIP` service), like the pod,
    it would also only be accessible from inside the cluster. By creating a `LoadBalancer`-type
    service, an external load balancer will be created and you can connect to the
    pod through the load balancer’s public IP.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的Pod运行时，您如何访问它？我们提到每个Pod都有自己的IP地址，但这个地址是集群内部的，并且无法从集群外部访问。为了使Pod可以从外部访问，您将通过服务对象将其公开。您将创建一个特殊的服务类型`LoadBalancer`，因为如果您创建一个普通的服务（一个`ClusterIP`服务），就像Pod一样，它也只可以从集群内部访问。通过创建`LoadBalancer`类型的服务，将创建一个外部负载均衡器，您可以通过负载均衡器的公网IP连接到Pod。
- en: Creating a Service object
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务对象
- en: 'To create the service, you’ll tell Kubernetes to expose the ReplicationController
    you created earlier:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建服务，您将告诉Kubernetes公开您之前创建的ReplicationController：
- en: '`$ kubectl expose rc kubia --type=LoadBalancer --name kubia-http` `service
    "kubia-http" exposed`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl expose rc kubia --type=LoadBalancer --name kubia-http` `service
    "kubia-http" exposed`'
- en: '|  |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We’re using the abbreviation `rc` instead of `replicationcontroller`. Most resource
    types have an abbreviation like this so you don’t have to type the full name (for
    example, `po` for `pods`, `svc` for `services`, and so on).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用缩写`rc`代替`replicationcontroller`。大多数资源类型都有这样的缩写，这样您就不必输入完整的名称（例如，`po`代表`pods`，`svc`代表`services`等）。
- en: '|  |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing services
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 列出服务
- en: The `expose` command’s output mentions a service called `kubia-http`. Services
    are objects like Pods and Nodes, so you can see the newly created Service object
    by running the `kubectl get services` command, as shown in the following listing.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`expose`命令的输出提到了一个名为`kubia-http`的服务。服务是像Pod和Node这样的对象，因此您可以通过运行`kubectl get
    services`命令来查看新创建的服务对象，如下所示。'
- en: Listing 2.16\. Listing Services
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.16\. 列出服务
- en: '`$ kubectl get services` `NAME         CLUSTER-IP     EXTERNAL-IP   PORT(S)        
    AGE kubernetes   10.3.240.1     <none>        443/TCP         34m kubia-http  
    10.3.246.185   <pending>     8080:31348/TCP  4s`'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get services` `NAME         CLUSTER-IP     EXTERNAL-IP   PORT(S)        
    AGE kubernetes   10.3.240.1     <none>        443/TCP         34m kubia-http  
    10.3.246.185   <pending>     8080:31348/TCP  4s`'
- en: The list shows two services. Ignore the `kubernetes` service for now and take
    a close look at the `kubia-http` service you created. It doesn’t have an external
    IP address yet, because it takes time for the load balancer to be created by the
    cloud infrastructure Kubernetes is running on. Once the load balancer is up, the
    external IP address of the service should be displayed. Let’s wait a while and
    list the services again, as shown in the following listing.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 列表显示了两个服务。现在忽略`kubernetes`服务，仔细查看您创建的`kubia-http`服务。它还没有外部IP地址，因为云基础设施创建负载均衡器需要时间。一旦负载均衡器启动，服务的公网IP地址应该会显示出来。让我们稍等片刻，再次列出服务，如下所示。
- en: Listing 2.17\. Listing services again to see if an external IP has been assigned
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.17\. 再次列出服务以查看是否已分配外部IP
- en: '`$ kubectl get svc` `NAME         CLUSTER-IP     EXTERNAL-IP   PORT(S)        
    AGE kubernetes   10.3.240.1     <none>        443/TCP         35m kubia-http  
    10.3.246.185   104.155.74.57 8080:31348/TCP  1m`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get svc` `NAME         CLUSTER-IP     EXTERNAL-IP   PORT(S)        
    AGE kubernetes   10.3.240.1     <none>        443/TCP         35m kubia-http  
    10.3.246.185   104.155.74.57 8080:31348/TCP  1m`'
- en: Aha, there’s the external IP. Your application is now accessible at http://104.155.74.57:8080
    from anywhere in the world.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，这就是外部IP。现在您的应用程序可以从世界任何地方通过http://104.155.74.57:8080访问。
- en: '|  |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Minikube doesn’t support `LoadBalancer` services, so the service will never
    get an external IP. But you can access the service anyway through its external
    port. How to do that is described in the next section’s tip.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube不支持`LoadBalancer`类型的服务，因此服务永远不会获得外部IP。但您仍然可以通过其外部端口访问该服务。如何在下一节的提示中描述。
- en: '|  |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Accessing your service through its external IP
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 通过其外部IP访问您的服务
- en: 'You can now send requests to your pod through the service’s external IP and
    port:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过服务的公网IP和端口向您的Pod发送请求：
- en: '`$ curl 104.155.74.57:8080` `You''ve hit kubia-4jfyf`'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ curl 104.155.74.57:8080` `您已访问kubia-4jfyf`'
- en: Woohoo! Your app is now running somewhere in your three-node Kubernetes cluster
    (or a single-node cluster if you’re using Minikube). If you don’t count the steps
    required to set up the whole cluster, all it took was two simple commands to get
    your app running and to make it accessible to users across the world.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 哇哦！你的应用程序现在正在你的三个节点 Kubernetes 集群（或者如果你使用 Minikube，则是一个单节点集群）的某个地方运行。如果你不计入设置整个集群所需的步骤，只需两个简单的命令就能让你的应用程序运行起来，并使其对全球用户可访问。
- en: '|  |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: When using Minikube, you can get the IP and port through which you can access
    the service by running `minikube service kubia-http`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Minikube 时，你可以通过运行 `minikube service kubia-http` 来获取访问服务的 IP 地址和端口。
- en: '|  |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: If you look closely, you’ll see that the app is reporting the name of the pod
    as its hostname. As already mentioned, each pod behaves like a separate independent
    machine with its own IP address and hostname. Even though the application is running
    in the worker node’s operating system, to the app it appears as though it’s running
    on a separate machine dedicated to the app itself—no other processes are running
    alongside it.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会看到应用程序正在报告 Pod 的名称作为其主机名。正如之前提到的，每个 Pod 都像一台独立的机器，拥有自己的 IP 地址和主机名。尽管应用程序运行在工作节点的操作系统上，但对于应用程序来说，它似乎是在一个专门为该应用程序本身运行的独立机器上运行——没有其他进程与它并行运行。
- en: 2.3.3\. The logical parts of your system
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 2.3.3. 系统的逻辑部分
- en: Until now, I’ve mostly explained the actual physical components of your system.
    You have three worker nodes, which are VMs running Docker and the Kubelet, and
    you have a master node that controls the whole system. Honestly, we don’t know
    if a single master node is hosting all the individual components of the Kubernetes
    Control Plane or if they’re split across multiple nodes. It doesn’t really matter,
    because you’re only interacting with the API server, which is accessible at a
    single endpoint.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我主要解释了系统的实际物理组件。你有三个工作节点，它们是运行 Docker 和 Kubelet 的虚拟机，你还有一个控制整个系统的主节点。老实说，我们不知道是否单个主节点托管了
    Kubernetes 控制平面的所有单个组件，或者它们分散在多个节点上。这并不重要，因为你只与 API 服务器交互，该服务器可以通过单个端点访问。
- en: Besides this physical view of the system, there’s also a separate, logical view
    of it. I’ve already mentioned Pods, ReplicationControllers, and Services. All
    of them will be explained in the next few chapters, but let’s quickly look at
    how they fit together and what roles they play in your little setup.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个系统的物理视图之外，还有一个独立的逻辑视图。我已经提到了 Pod、ReplicationController 和 Service。所有这些内容将在接下来的几章中解释，但让我们快速看一下它们是如何结合在一起以及它们在你的小配置中扮演的角色。
- en: Understanding how the ReplicationController, the Pod, and the Ser- rvice fit
    together
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 ReplicationController、Pod 和 Service 如何结合
- en: As I’ve already explained, you’re not creating and working with containers directly.
    Instead, the basic building block in Kubernetes is the pod. But, you didn’t really
    create any pods either, at least not directly. By running the `kubectl run` command
    you created a ReplicationController, and this ReplicationController is what created
    the actual Pod object. To make that pod accessible from outside the cluster, you
    told Kubernetes to expose all the pods managed by that ReplicationController as
    a single Service. A rough picture of all three elements is presented in [figure
    2.7](#filepos252852).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我已经解释的，你并不是直接创建和操作容器。相反，Kubernetes 的基本构建块是 Pod。但是，你也没有真正创建任何 Pod，至少不是直接创建。通过运行
    `kubectl run` 命令，你创建了一个 ReplicationController，而这个 ReplicationController 就是创建实际
    Pod 对象的东西。为了使该 Pod 从集群外部可访问，你告诉 Kubernetes 将该 ReplicationController 管理的所有 Pod
    作为单个 Service 公开。这三个元素的大致图示在[图 2.7](#filepos252852) 中展示。
- en: Figure 2.7\. Your system consists of a ReplicationController, a Pod, and a Service.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7. 你的系统由 ReplicationController、Pod 和 Service 组成。
- en: '![](images/00133.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图片](images/00133.jpg)'
- en: Understanding the pod and its container
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Pod 及其容器
- en: The main and most important component in your system is the pod. It contains
    only a single container, but generally a pod can contain as many containers as
    you want. Inside the container is your Node.js process, which is bound to port
    8080 and is waiting for HTTP requests. The pod has its own unique private IP address
    and hostname.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你系统中的主要和最重要的组件是 Pod。它只包含一个容器，但通常 Pod 可以包含你想要的任意数量的容器。在容器内部是你的 Node.js 进程，它绑定到
    8080 端口，并等待 HTTP 请求。Pod 有其唯一的私有 IP 地址和主机名。
- en: Understanding the role of the ReplicationController
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 ReplicationController 的作用
- en: The next component is the `kubia` ReplicationController. It makes sure there’s
    always exactly one instance of your pod running. Generally, ReplicationControllers
    are used to replicate pods (that is, create multiple copies of a pod) and keep
    them running. In your case, you didn’t specify how many pod replicas you want,
    so the Replication-Controller created a single one. If your pod were to disappear
    for any reason, the Replication-Controller would create a new pod to replace the
    missing one.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个组件是`kubia` ReplicationController。它确保始终有一个Pod实例在运行。通常，ReplicationControllers用于复制Pod（即创建Pod的多个副本）并保持它们运行。在您的例子中，您没有指定您想要多少个Pod副本，所以ReplicationController创建了一个单一的副本。如果您的Pod因任何原因消失，ReplicationController将创建一个新的Pod来替换缺失的Pod。
- en: Understanding why you need a service
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 理解为什么你需要一个服务
- en: The third component of your system is the `kubia-http` service. To understand
    why you need services, you need to learn a key detail about pods. They’re ephemeral.
    A pod may disappear at any time—because the node it’s running on has failed, because
    someone deleted the pod, or because the pod was evicted from an otherwise healthy
    node. When any of those occurs, a missing pod is replaced with a new one by the
    Replication-Controller, as described previously. This new pod gets a different
    IP address from the pod it’s replacing. This is where services come in—to solve
    the problem of ever-changing pod IP addresses, as well as exposing multiple pods
    at a single constant IP and port pair.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 您系统的第三个组件是`kubia-http`服务。要了解为什么你需要服务，你需要了解关于Pod的一个关键细节。它们是短暂的。Pod可能在任何时候消失——因为运行它的节点失败了，因为有人删除了Pod，或者因为Pod被从其他健康的节点驱逐出去。当这些情况中的任何一种发生时，ReplicationController将用新的Pod替换缺失的Pod，如前所述。这个新的Pod将获得一个与被替换的Pod不同的IP地址。这就是服务发挥作用的地方——解决不断变化的Pod
    IP地址的问题，以及在一个单一的恒定IP和端口对中公开多个Pod。
- en: When a service is created, it gets a static IP, which never changes during the
    lifetime of the service. Instead of connecting to pods directly, clients should
    connect to the service through its constant IP address. The service makes sure
    one of the pods receives the connection, regardless of where the pod is currently
    running (and what its IP address is).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建服务时，它会获得一个静态IP，在整个服务生命周期中都不会改变。客户端不应直接连接到Pod，而应通过其恒定的IP地址连接到服务。服务确保其中一个Pod接收连接，无论Pod当前运行在哪里（以及它的IP地址是什么）。
- en: Services represent a static location for a group of one or more pods that all
    provide the same service. Requests coming to the IP and port of the service will
    be forwarded to the IP and port of one of the pods belonging to the service at
    that moment.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 服务代表了一组一个或多个提供相同服务的Pod的静态位置。发送到服务IP和端口的请求将被转发到该服务当时属于的一个Pod的IP和端口。
- en: 2.3.4\. Horizontally scaling the application
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 2.3.4. 横向扩展应用程序
- en: You now have a running application, monitored and kept running by a ReplicationController
    and exposed to the world through a service. Now let’s make additional magic happen.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在有一个正在运行的应用程序，由ReplicationController监控并保持运行，并通过服务向世界公开。现在让我们看看会发生什么额外的魔法。
- en: One of the main benefits of using Kubernetes is the simplicity with which you
    can scale your deployments. Let’s see how easy it is to scale up the number of
    pods. You’ll increase the number of running instances to three.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes的主要好处之一是您可以轻松地扩展您的部署。让我们看看扩展Pod数量的过程有多简单。您将增加运行实例的数量到三个。
- en: 'Your pod is managed by a ReplicationController. Let’s see it with the `kubectl
    get` command:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Pod由ReplicationController管理。让我们用`kubectl get`命令来看看：
- en: '`$ kubectl get replicationcontrollers` `NAME        DESIRED    CURRENT   AGE
    kubia       1          1         17m`'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get replicationcontrollers` `NAME        DESIRED    CURRENT   AGE
    kubia       1          1         17m`'
- en: '|  |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing all the resource types with kubectl get
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用kubectl get列出所有资源类型
- en: You’ve been using the same basic `kubectl get` command to list things in your
    cluster. You’ve used this command to list Node, Pod, Service and Replication-Controller
    objects. You can get a list of all the possible object types by invoking `kubectl
    get` without specifying the type. You can then use those types with various `kubectl`
    commands such as `get`, `describe`, and so on. The list also shows the abbreviations
    I mentioned earlier.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您一直在使用相同的`kubectl get`命令来列出集群中的内容。您已经使用此命令列出Node、Pod、Service和ReplicationController对象。您可以通过不指定类型来调用`kubectl
    get`以获取所有可能的对象类型的列表。然后您可以使用这些类型与各种`kubectl`命令，如`get`、`describe`等。列表还显示了之前提到的缩写。
- en: '|  |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The list shows a single ReplicationController called `kubia`. The `DESIRED`
    column shows the number of pod replicas you want the ReplicationController to
    keep, whereas the `CURRENT` column shows the actual number of pods currently running.
    In your case, you wanted to have a single replica of the pod running, and exactly
    one replica is currently running.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中显示了一个名为 `kubia` 的单个 ReplicationController。`DESIRED` 列显示了您希望 ReplicationController
    保持的 pod 副本数量，而 `CURRENT` 列显示了当前实际运行的 pod 数量。在您的例子中，您希望运行单个 pod 副本，并且目前正好有一个副本正在运行。
- en: Increasing the desired replica count
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 增加期望副本计数
- en: 'To scale up the number of replicas of your pod, you need to change the desired
    replica count on the ReplicationController like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要增加 pod 副本的数量，您需要像这样更改 ReplicationController 上的期望副本计数：
- en: '`$ kubectl scale rc kubia --replicas=3` `replicationcontroller "kubia" scaled`'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl scale rc kubia --replicas=3` '
- en: You’ve now told Kubernetes to make sure three instances of your pod are always
    running. Notice that you didn’t instruct Kubernetes what action to take. You didn’t
    tell it to add two more pods. You only set the new desired number of instances
    and let Kubernetes determine what actions it needs to take to achieve the requested
    state.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已告诉 Kubernetes 确保始终运行三个 pod 实例。请注意，您没有指示 Kubernetes 应采取什么行动。您没有告诉它添加两个额外的
    pod。您只是设置了新的期望实例数量，并让 Kubernetes 确定需要采取哪些行动来实现请求的状态。
- en: This is one of the most fundamental Kubernetes principles. Instead of telling
    Kubernetes exactly what actions it should perform, you’re only declaratively changing
    the desired state of the system and letting Kubernetes examine the current actual
    state and reconcile it with the desired state. This is true across all of Kubernetes.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Kubernetes 最基本的原则之一。您不是告诉 Kubernetes 应该执行哪些具体操作，而是仅声明性地更改系统的期望状态，并让 Kubernetes
    检查当前的实际情况，并将其与期望状态进行协调。这在 Kubernetes 的所有方面都是如此。
- en: Seeing the results of the scale-out
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 查看扩展后的结果
- en: 'Back to your replica count increase. Let’s list the ReplicationControllers
    again to see the updated replica count:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 回到您的副本计数增加。让我们再次列出 ReplicationControllers 以查看更新的副本计数：
- en: '`$ kubectl get rc` `NAME        DESIRED    CURRENT   READY   AGE kubia      
    3          3         2       17m`'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get rc` '
- en: 'Because the actual number of pods has already been increased to three (as evident
    from the `CURRENT` column), listing all the pods should now show three pods instead
    of one:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实际的 pod 数量已经增加到三个（如 `CURRENT` 列所示），现在列出所有 pod 应该显示三个 pod 而不是一个：
- en: '`$ kubectl get pods` `NAME          READY     STATUS    RESTARTS   AGE kubia-hczji  
    1/1       Running   0          7s kubia-iq9y6   0/1       Pending   0         
    7s kubia-4jfyf   1/1       Running   0          18m`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get pods` '
- en: As you can see, three pods exist instead of one. Two are already running, one
    is still pending, but should be ready in a few moments, as soon as the container
    image is downloaded and the container is started.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，现在存在三个 pod 而不是一个。其中两个已经运行，一个仍在挂起状态，但应该在几秒钟内准备好，一旦容器镜像下载完成并且容器启动。
- en: As you can see, scaling an application is incredibly simple. Once your app is
    running in production and a need to scale the app arises, you can add additional
    instances with a single command without having to install and run additional copies
    manually.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，扩展应用程序非常简单。一旦您的应用程序在生产环境中运行，并且需要扩展应用程序，您就可以通过单个命令添加额外的实例，而无需手动安装和运行额外的副本。
- en: Keep in mind that the app itself needs to support being scaled horizontally.
    Kubernetes doesn’t magically make your app scalable; it only makes it trivial
    to scale the app up or down.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，应用程序本身需要支持水平扩展。Kubernetes 并不会神奇地使您的应用程序可扩展；它只是使扩展应用程序变得非常简单。
- en: Seeing requests hit all three pods when hitting the service
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问服务时，看到请求击中所有三个 pod
- en: Because you now have multiple instances of your app running, let’s see what
    happens if you hit the service URL again. Will you always hit the same app instance
    or not?
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您现在有多个应用程序实例正在运行，让我们看看再次访问服务 URL 时会发生什么。您是否会始终击中相同的应用程序实例？
- en: '`$ curl 104.155.74.57:8080` `You''ve hit kubia-hczji` `$ curl 104.155.74.57:8080`
    `You''ve hit kubia-iq9y6` `$ curl 104.155.74.57:8080` `You''ve hit kubia-iq9y6`
    `$ curl 104.155.74.57:8080` `You''ve hit kubia-4jfyf`'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ curl 104.155.74.57:8080` `您已访问 kubia-hczji` `$ curl 104.155.74.57:8080`
    `您已访问 kubia-iq9y6` `$ curl 104.155.74.57:8080` `您已访问 kubia-iq9y6` `$ curl 104.155.74.57:8080`
    `您已访问 kubia-4jfyf`'
- en: Requests are hitting different pods randomly. This is what services in Kubernetes
    do when more than one pod instance backs them. They act as a load balancer standing
    in front of multiple pods. When there’s only one pod, services provide a static
    address for the single pod. Whether a service is backed by a single pod or a group
    of pods, those pods come and go as they’re moved around the cluster, which means
    their IP addresses change, but the service is always there at the same address.
    This makes it easy for clients to connect to the pods, regardless of how many
    exist and how often they change location.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 请求随机地击中不同的 pods。当有多个 pod 实例支持服务时，这就是 Kubernetes 中的服务所做的事情。它们充当多个 pod 前面的负载均衡器。当只有一个
    pod 时，服务为单个 pod 提供一个静态地址。无论服务是由单个 pod 还是多个 pod 支持，这些 pod 在集群中移动时来来去去，这意味着它们的 IP
    地址会改变，但服务始终在同一个地址上。这使得客户端很容易连接到 pods，无论存在多少个以及它们的位置如何频繁变化。
- en: Visualizing the new state of your system
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化您系统的最新状态
- en: Let’s visualize your system again to see what’s changed from before. [Figure
    2.8](#filepos262715) shows the new state of your system. You still have a single
    service and a single Replication-Controller, but you now have three instances
    of your pod, all managed by the ReplicationController. The service no longer sends
    all requests to a single pod, but spreads them across all three pods as shown
    in the experiment with `curl` in the previous section.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次可视化您的系统，看看与之前相比有什么变化。[图 2.8](#filepos262715) 显示了您系统的最新状态。您仍然只有一个服务和一个 Replication-Controller，但现在您有三个
    pod 实例，所有这些实例都由 ReplicationController 管理。服务不再将所有请求发送到单个 pod，而是像前一小节中用 `curl` 实验所示，将它们分散到所有三个
    pod 上。
- en: Figure 2.8\. Three instances of a pod managed by the same ReplicationController
    and exposed through a single service IP and port.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8\. 由同一个 ReplicationController 管理、通过单个服务 IP 和端口暴露的三个 pod 实例。
- en: '![](images/00150.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00150.jpg)'
- en: As an exercise, you can now try spinning up additional instances by increasing
    the ReplicationController’s replica count even further and then scaling back down.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项练习，您现在可以通过增加 ReplicationController 的副本计数来启动更多实例，然后再将其缩小。
- en: 2.3.5\. Examining what nodes your app is running on
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 2.3.5\. 检查您的应用运行在哪些节点上
- en: You may be wondering what nodes your pods have been scheduled to. In the Kubernetes
    world, what node a pod is running on isn’t that important, as long as it gets
    scheduled to a node that can provide the CPU and memory the pod needs to run properly.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道您的 pods 被调度到了哪些节点。在 Kubernetes 世界里，pod 运行在哪个节点上并不是那么重要，只要它被调度到了一个可以提供
    pod 正常运行所需的 CPU 和内存的节点。
- en: Regardless of the node they’re scheduled to, all the apps running inside containers
    have the same type of OS environment. Each pod has its own IP and can talk to
    any other pod, regardless of whether that other pod is also running on the same
    node or on a different one. Each pod is provided with the requested amount of
    computational resources, so whether those resources are provided by one node or
    another doesn’t make any difference.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 无论它们被调度到哪个节点，容器内运行的所有应用都具有相同类型的操作系统环境。每个 pod 都有自己的 IP 地址，并且可以与任何其他 pod 通信，无论该
    pod 是否也在同一个节点上运行或在不同的节点上。每个 pod 都提供了请求的计算资源量，因此这些资源是由一个节点还是另一个节点提供并不重要。
- en: Displaying the pod IP and the pod’s node when listing pods
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 列出 pods 时显示 pod IP 和 pod 的节点
- en: If you’ve been paying close attention, you probably noticed that the `kubectl
    get pods` command doesn’t even show any information about the nodes the pods are
    scheduled to. This is because it’s usually not an important piece of information.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直很注意，您可能已经注意到 `kubectl get pods` 命令甚至没有显示任何关于 pods 被调度到哪些节点的信息。这是因为这通常不是一条重要的信息。
- en: 'But you can request additional columns to display using the `-o wide` option.
    When listing pods, this option shows the pod’s IP and the node the pod is running
    on:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 但您可以使用 `-o wide` 选项请求显示额外的列。当列出 pods 时，此选项会显示 pod 的 IP 地址以及 pod 运行的节点：
- en: '`$ kubectl get pods -o wide` `NAME          READY   STATUS    RESTARTS   AGE  
    IP         NODE kubia-hczji   1/1     Running   0          7s    10.1.0.2   gke-kubia-85...`'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl get pods -o wide` `NAME          READY   STATUS    RESTARTS   AGE  
    IP         NODE kubia-hczji   1/1     Running   0          7s    10.1.0.2   gke-kubia-85...`'
- en: Inspecting other details of a pod with kubectl describe
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 kubectl describe 检查 pod 的其他详细信息
- en: You can also see the node by using the `kubectl describe` command, which shows
    many other details of the pod, as shown in the following listing.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `kubectl describe` 命令查看节点，该命令显示了 pod 的许多其他详细信息，如下所示。
- en: Listing 2.18\. Describing a pod with `kubectl describe`
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.18\. 使用 `kubectl describe` 描述 pod
- en: '`$ kubectl describe pod kubia-hczji` `Name:        kubia-hczji Namespace:  
    default Node:        gke-kubia-85f6-node-vs9f/10.132.0.3` `1` `Start Time:  Fri,
    29 Apr 2016 14:12:33 +0200 Labels:      run=kubia Status:      Running IP:         
    10.1.0.2 Controllers: ReplicationController/kubia Containers:  ... Conditions:
      Type       Status   Ready      True Volumes: ... Events: ...`'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl describe pod kubia-hczji` `Name:        kubia-hczji Namespace:  
    default Node:        gke-kubia-85f6-node-vs9f/10.132.0.3` `1` `Start Time:  Fri,
    29 Apr 2016 14:12:33 +0200 Labels:      run=kubia Status:      Running IP:         
    10.1.0.2 Controllers: ReplicationController/kubia Containers:  ... Conditions:
      Type       Status   Ready      True Volumes: ... Events: ...`'
- en: 1 Here’s the node the pod has been scheduled to.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 这里是 pod 被调度到的节点。
- en: This shows, among other things, the node the pod has been scheduled to, the
    time when it was started, the image(s) it’s running, and other useful information.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了包括节点在内的其他信息，例如 pod 被调度到的节点、启动时间、运行的镜像（们）以及其他有用的信息。
- en: 2.3.6\. Introducing the Kubernetes dashboard
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 2.3.6\. 介绍 Kubernetes 仪表板
- en: Before we wrap up this initial hands-on chapter, let’s look at another way of
    exploring your Kubernetes cluster.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这个初步的实践章节之前，让我们看看另一种探索 Kubernetes 集群的方法。
- en: Up to now, you’ve only been using the `kubectl` command-line tool. If you’re
    more into graphical web user interfaces, you’ll be glad to hear that Kubernetes
    also comes with a nice (but still evolving) web dashboard.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只使用过 `kubectl` 命令行工具。如果你更喜欢图形化网页用户界面，你将很高兴听到 Kubernetes 还附带了一个很好的（但仍在发展中）网页仪表板。
- en: The dashboard allows you to list all the Pods, ReplicationControllers, Services,
    and other objects deployed in your cluster, as well as to create, modify, and
    delete them. [Figure 2.9](#filepos267175) shows the dashboard.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板允许你列出集群中部署的所有 Pods、ReplicationControllers、Services 以及其他对象，以及创建、修改和删除它们。[图
    2.9](#filepos267175) 展示了仪表板。
- en: Figure 2.9\. Screenshot of the Kubernetes web-based dashboard
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9\. Kubernetes 网页仪表板的截图
- en: '![](images/00168.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00168.jpg)'
- en: Although you won’t use the dashboard in this book, you can open it up any time
    to quickly see a graphical view of what’s deployed in your cluster after you create
    or modify objects through `kubectl`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这本书中你不会使用仪表板，但你随时可以打开它，以便快速查看通过 `kubectl` 创建或修改对象后集群中部署的图形视图。
- en: Accessing the dashboard when running Kubernetes in GKE
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GKE 中运行 Kubernetes 时访问仪表板
- en: 'If you’re using Google Kubernetes Engine, you can find out the URL of the dashboard
    through the `kubectl cluster-info` command, which we already introduced:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 Google Kubernetes Engine，你可以通过 `kubectl cluster-info` 命令找到仪表板的 URL，我们之前已经介绍过：
- en: '`$ kubectl cluster-info | grep dashboard` `kubernetes-dashboard is running
    at https://104.155.108.191/api/v1/proxy/` ![](images/00006.jpg) `namespaces/kube-system/services/kubernetes-dashboard`'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl cluster-info | grep dashboard` `kubernetes-dashboard is running
    at https://104.155.108.191/api/v1/proxy/` ![](images/00006.jpg) `namespaces/kube-system/services/kubernetes-dashboard`'
- en: 'If you open this URL in a browser, you’re presented with a username and password
    prompt. You’ll find the username and password by running the following command:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个 URL 中打开浏览器，你会看到一个用户名和密码提示。你可以通过运行以下命令找到用户名和密码：
- en: '`$ gcloud container clusters describe kubia | grep -E "(username|password):"`
    `password: 32nENgreEJ632A12` `1` `username: admin` `1`'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ gcloud container clusters describe kubia | grep -E "(username|password):"`
    `password: 32nENgreEJ632A12` `1` `username: admin` `1`'
- en: 1 The username and password for the dashboard
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 仪表板的用户名和密码
- en: Accessing the dashboard when using Minikube
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Minikube 访问仪表板
- en: 'To open the dashboard in your browser when using Minikube to run your Kubernetes
    cluster, run the following command:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Minikube 运行 Kubernetes 集群时，在浏览器中打开仪表板的命令如下：
- en: '`$ minikube dashboard`'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ minikube dashboard`'
- en: The dashboard will open in your default browser. Unlike with GKE, you won’t
    need to enter any credentials to access it.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板将在你的默认浏览器中打开。与 GKE 不同，你访问它时不需要输入任何凭证。
- en: 2.4\. Summary
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 2.4\. 摘要
- en: Hopefully, this initial hands-on chapter has shown you that Kubernetes isn’t
    a complicated platform to use, and you’re ready to learn in depth about all the
    things it can provide. After reading this chapter, you should now know how to
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个初步的实践章节已经向你展示了Kubernetes不是一个复杂的平台，你准备好深入学习它所能提供的一切。在阅读这一章之后，你现在应该知道如何
- en: Pull and run any publicly available container image
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取并运行任何公开可用的容器镜像
- en: Package your apps into container images and make them available to anyone by
    pushing the images to a remote image registry
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的应用打包成容器镜像，并通过将镜像推送到远程镜像仓库使任何人都可以访问
- en: Enter a running container and inspect its environment
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入一个正在运行的容器并检查其环境
- en: Set up a multi-node Kubernetes cluster on Google Kubernetes Engine
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Google Kubernetes Engine上设置一个多节点Kubernetes集群
- en: Configure an alias and tab completion for the `kubectl` command-line tool
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`kubectl`命令行工具配置别名和Tab补全
- en: List and inspect Nodes, Pods, Services, and ReplicationControllers in a Kubernetes
    cluster
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes集群中列出并检查Nodes、Pods、Services和ReplicationControllers
- en: Run a container in Kubernetes and make it accessible from outside the cluster
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes中运行一个容器并使其可以从集群外部访问
- en: Have a basic sense of how Pods, ReplicationControllers, and Services relate
    to one another
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Pods、ReplicationControllers和Services三者之间的关系有一个基本的认识
- en: Scale an app horizontally by changing the ReplicationController’s replica count
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过更改ReplicationController的副本数量水平扩展应用
- en: Access the web-based Kubernetes dashboard on both Minikube and GKE
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Minikube和GKE上访问基于Web的Kubernetes仪表板
