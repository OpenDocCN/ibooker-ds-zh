- en: 4 Caesarean cipher
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 凯撒密码
- en: Caesar wrote, “Gallia est omnis divisa in partes tres.” If he had wanted the
    message to be a secret, he would have written, “Tnyyvn rfg bzavf qvivfn va cnegrf
    gerf.” This subtle encryption was easy to concoct, yet even a literate spy would
    be unable to translate the scrambled Latin without knowing the key. On the receiving
    end, where the deciphering method is known, the message is quickly decoded and
    . . . pity poor Gaul. This method of encoding is today known as the Caesarean
    cipher.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒写道，“Gallia est omnis divisa in partes tres。”如果他想要这条信息保密，他会写成，“Tnyyvn rfg bzavf
    qvivfn va cnegrf gerf。”这种微妙的加密很容易构思，但即使是有文化的间谍，如果没有密钥，也无法翻译这种混乱的拉丁文。在接收端，当解密方法已知时，信息会迅速解码，……可怜的高卢人。这种编码方法今天被称为凯撒密码。
- en: 'The Caesarean cipher is by no means secure, but it’s a fun programming exercise.
    It also opens the door to the concepts of filters and filter programming in C.
    This chapter covers the concept of a filter, including stuff like this:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码绝对不安全，但它是一个有趣的编程练习。它还打开了C语言中过滤器和过滤器编程的概念之门。本章涵盖了过滤器的概念，包括如下内容：
- en: Dealing with streaming input and output
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理流输入和输出
- en: Programming a simple input/output (I/O) filter
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程一个简单的输入/输出（I/O）过滤器
- en: Rotating characters 13 places
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转字符13个位置
- en: Shifting characters in specific increments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定增量中移动字符
- en: Coding a hex input filter
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个十六进制输入过滤器
- en: Creating a NATO phonetic alphabet filter
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个北约音标字母过滤器
- en: Writing a filter to find words
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个查找单词的过滤器
- en: Filters abide in the command prompt’s realm. Special command characters are
    used to apply the filter at the prompt, redirecting input and output away from
    the standard I/O devices. Therefore, I strongly suggest you eschew your beloved
    IDE for this chapter and dive headfirst into the realm of command-line programming.
    Doing so makes you almost an über nerd, plus it gives you boasting rights at those
    few parties you’re invited to attend.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器存在于命令提示符的领域。使用特殊的命令字符在提示符处应用过滤器，将输入和输出从标准I/O设备中重定向。因此，我强烈建议你在这个章节中放弃你钟爱的IDE，一头扎入命令行编程的领域。这样做让你几乎成为超级极客，而且在你受邀参加的少数几次聚会上，你可以吹嘘自己的成就。
- en: 4.1 I/O filters
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 I/O过滤器
- en: Do you remember singing about I/O back at computer camp? The reason for such
    merriment was to drive home the point that the computer beehive exists for the
    purpose of absorbing input and creating modified output. The key is what happens
    between the I and the O, and not just the slash character. No, what’s important
    are the mechanics of modifying input to generate some type of useful output.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得在计算机营里唱关于I/O的歌吗？这样欢乐的原因是为了强调计算机蜂巢的存在是为了吸收输入并创建修改后的输出。关键是I和O之间发生了什么，而不仅仅是斜杠字符。不，重要的是修改输入以生成某种有用输出的机制。
- en: 'An I/O filter is a program that consumes standard input, does something to
    it, then spews forth the modified output. It’s not an interactive program: input
    flows into the filter like a gentle stream. The filter does something magical,
    like remove all the bugs and dirt, and then generates output: pure, clean water
    (though all this action takes place at a digital level, even the bugs).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: I/O过滤器是一个消耗标准输入的程序，对其进行一些操作，然后输出修改后的结果。它不是一个交互式程序：输入像一股温柔的溪流流入过滤器。过滤器做一些神奇的事情，比如去除所有的虫子和污垢，然后生成输出：纯净、干净的水（尽管所有这些动作都在数字级别上发生，即使是虫子）。
- en: 4.1.1 Understanding stream I/O
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 理解流I/O
- en: To best implement a filter, you must embrace the concept of stream I/O, which
    is difficult for many C programmers to understand. That’s because your experience
    with computer programs is on an interactive level. Yet in C, input and output
    work at the stream level.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要最好地实现一个过滤器，你必须接受流I/O的概念，这对许多C程序员来说很难理解。那是因为你与计算机程序的经验是在交互层面上的。然而，在C语言中，输入和输出是在流级别上工作的。
- en: '*Stream I/O* means that all I/O gurgles through a program without pause, like
    water from a garden hose. The code doesn’t know when you’ve paused or stopped
    typing. It only recognizes when the stream ends as identified by the end-of-file
    (EOF) character.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*流I/O*意味着所有I/O都在程序中连续流动，没有停顿，就像花园水管中的水一样。代码不知道你何时暂停或停止输入。它只识别到文件结束（EOF）字符时流结束。'
- en: Thanks to line buffering, the code may pay only casual attention to the appearance
    of the newline character, \n (when you press the Enter key). Once encountered,
    the newline may flush an output buffer, but otherwise stream I/O doesn’t strut
    or crow about what text is input or how it was generated; all that’s processed
    is the stream, which you can imagine as one long parade of characters, as illustrated
    in figure 4.1.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了行缓冲，代码可能只是随意关注换行字符（\n，当你按下Enter键时）的出现。一旦遇到，换行符可能会刷新输出缓冲区，但否则流I/O不会炫耀输入了什么文本或它是如何生成的；所有处理的是流，你可以想象它就像一个长长的字符游行，如图4.1所示。
- en: '![04-01](Images/04-01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![04-01](Images/04-01.png)'
- en: Figure 4.1 A stream of text—not as jubilant as a parade, but you get the idea.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 一串文本——不像游行那样欢快，但你能理解这个概念。
- en: Stream I/O may frustrate you, but it has its place. To help you accept it, understand
    that input may not always come from the standard input device (the keyboard).
    Likewise, output may not always go to the standard output device (the display).
    The standard input device, stdin, is just one of several sources of input. For
    example, input can also come from a file, another program, or a specific device,
    like a modem.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 流I/O可能会让你感到沮丧，但它有自己的位置。为了帮助你接受它，理解输入可能并不总是来自标准输入设备（键盘）。同样，输出可能并不总是发送到标准输出设备（显示器）。标准输入设备stdin只是几个输入源之一。例如，输入也可以来自文件、另一个程序或特定的设备，如调制解调器。
- en: The code in listing 4.1 demonstrates how many C beginners craft a wannabe interactive
    program. The assumption made is that input is interactive. Instead, input is read
    from the stream (refer to figure 4.1). Though the code may prompt for a single
    letter, it’s really reading the next character from the input stream. Nothing
    else matters—no other considerations are made.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1中的代码演示了许多C语言初学者如何构建一个假想交互式程序。假设输入是交互式的。相反，输入是从流中读取的（参见图4.1）。尽管代码可能会提示输入单个字母，但它实际上是在读取输入流中的下一个字符。其他事情无关紧要——没有考虑其他因素。
- en: Listing 4.1 stream_demo.c
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.1 stream_demo.c
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Reads a single character from standard input
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从标准输入读取单个字符
- en: ❷ Reads the next single character from standard input
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从标准输入读取下一个单个字符
- en: 'The programmer’s desire is to read two characters, each typed at its own prompt.
    What happens instead is that the *getchar()* function plucks each character from
    the input stream, which includes the first letter typed *plus* the Enter key press
    (newline). Here’s a sample run:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员的愿望是读取两个字符，每个字符都在自己的提示符下输入。但实际情况是，*getchar()* 函数从输入流中取出每个字符，这包括第一个输入的字母*加上*Enter键的按下（换行符）。以下是一个示例运行：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first character is read by *getchar()*, the letter a. Then the user presses
    Enter, which becomes the next character read by the second *getchar()* statement.
    You see this character in the output for b (split between two lines). Take a gander
    at figure 4.2, which illustrates what the user typed as the input stream and how
    the code read it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符由 *getchar()* 读取，即字母a。然后用户按下Enter键，这成为第二个 *getchar()* 语句读取的下一个字符。你可以在输出中的b处看到这个字符（分为两行）。看看图4.2，它说明了用户输入的输入流以及代码是如何读取它的。
- en: '![04-02](Images/04-02.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![04-02](Images/04-02.png)'
- en: Figure 4.2 The input stream contains two characters read by two *getchar()*
    functions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 输入流包含两个由两个 *getchar()* 函数读取的字符。
- en: 'If you type **ab** at the first prompt, you see this output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在第一个提示符中输入**ab**，你会看到以下输出：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The two *getchar()* functions read characters from the stream, one after the
    other. If the user types **a** and **b**, these characters are plucked from the
    stream regardless of the onscreen prompt, lovingly illustrated in figure 4.3\.
    The newline (which appears in the input stream in the figure) isn’t read by the
    code but is used to flush the buffer. It allows the code to process input without
    the user having to sit and wait for an EOF.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 *getchar()* 函数依次从流中读取字符。如果用户输入**a**和**b**，这些字符会从流中取出，无论屏幕上的提示如何，如图4.3所示。图中的换行符（在输入流中显示）不会被代码读取，但用于刷新缓冲区。它允许代码在用户无需等待EOF的情况下处理输入。
- en: '![04-03](Images/04-03.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![04-03](Images/04-03.png)'
- en: Figure 4.3 Two more characters are read from the input stream.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 从输入流中读取了另外两个字符。
- en: 'Understanding stream I/O helps you properly code C programs and also appreciate
    how an I/O filter works. Even so, you probably remain curious about how interactive
    programs are constructed. The secret is to avoid stream I/O and access the terminal
    directly. The Ncurses library is one tool you can use to make programs fully interactive.
    This library is the foundation upon which full-screen text-mode programs like
    vi, top, and others are built. Check out Ncurses if you want to code interactive,
    full-screen text mode programs for Linux. And, of course, I wrote a book on the
    topic, which you can order from Amazon: *Dan Gookin’s Guide to Ncurses Programming*.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 理解流I/O有助于你正确编写C程序，并欣赏I/O过滤器是如何工作的。即便如此，你可能仍然对如何构建交互程序感到好奇。秘密在于避免流I/O并直接访问终端。Ncurses库是你可以使用的一个工具，可以使程序完全交互。这个库是vi、top和其他全屏文本模式程序的基础。如果你想为Linux编写交互式全屏文本模式程序，请查看Ncurses。当然，我为此主题写了一本书，你可以在亚马逊上订购：*Dan
    Gookin的Ncurses编程指南*。
- en: '*Enough self-promotion.—Editor*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*自我推销够了。——编辑*'
- en: 'Another aspect of stream I/O is buffering. You see a bit of this when you press
    the Enter key to process input for a wannabe interactive program like stream_demo.c.
    In fact, an aspect of I/O buffering is present when the program’s first prompt
    is output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 流I/O的另一个方面是缓冲。当你按下Enter键处理stream_demo.c这样的拟交互程序输入时，你会看到一些这样的缓冲。事实上，当程序首次提示输出时，I/O缓冲的一个方面就存在了：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This text appears and output stops because of buffering. Output to the standard
    output device (stdout) is *line buffered* in C. This configuration means that
    stream output is stored in a buffer until the buffer gets full or when a newline
    character is encountered in the stream, after which the text is output. It’s the
    presence of the newline that makes output stop in the stream_demo.c program.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这段文本出现并且输出停止是因为缓冲。在C语言中，输出到标准输出设备（stdout）是*按行缓冲*的。这种配置意味着流输出存储在缓冲区中，直到缓冲区满了或者流中遇到换行符，之后文本才会输出。正是换行符的存在使得在stream_demo.c程序中输出停止。
- en: Another type of buffer is *block buffering*. When this mode is active, output
    doesn’t appear until the buffer is full—or when the program ends. Even if a newline
    appears in the stream, block buffering stores the character in the stream, la-di-da.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的缓冲是*块缓冲*。当此模式激活时，输出不会出现直到缓冲区满了或者程序结束。即使流中出现换行符，块缓冲也会将字符存储在流中，la-di-da。
- en: Buffering for an I/O device is set by using the *setbuf()* function, defined
    in the stdio.h header file. This function overrides the terminal’s default line
    buffering and establishes block buffering using a specific chunk of memory. In
    effect, it disables line buffering for the given file handle (or standard I/O
    device) and activates block buffering.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用定义在stdio.h头文件中的*setbuf()*函数设置I/O设备的缓冲。此函数覆盖了终端的默认行缓冲，并使用特定的内存块建立块缓冲。实际上，它禁用了给定文件句柄（或标准I/O设备）的行缓冲，并激活了块缓冲。
- en: The code in the next listing uses the *setbuf()* function to alter output from
    line buffering to block buffering. The *setbuf()* statement helps demonstrate
    how the output stream (stdout) is affected.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表中的代码使用*setbuf()*函数将输出从行缓冲更改为块缓冲。*setbuf()*语句有助于展示输出流（stdout）是如何受到影响的。
- en: Listing 4.2 buffering.c
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 buffering.c
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ A holding bin for standard output; BUFSIZ is defined in stdio.h.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 标准输出的一个存储库；BUFSIZ在stdio.h中定义。
- en: ❷ Commits standard output to block buffering
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将标准输出提交到块缓冲
- en: If you build and run buffering.c, you see no output. Instead, the *getchar()*
    function prompts for input, so the program waits. The output is held back, stored
    in the character array buffer, waiting for text to fill the buffer or for the
    program to end.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你构建并运行buffering.c，你将看不到输出。相反，*getchar()*函数提示输入，因此程序等待。输出被保留，存储在字符数组缓冲区中，等待文本填满缓冲区或程序结束。
- en: 'Here is a sample run of the code, where no prompt appears. Still, the user
    is somehow prescient enough to provide input, typing ab at the blinking cursor.
    Only after the Enter key is pressed does the program end and the buffer is flushed,
    revealing standard output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码的一个示例运行，其中没有出现提示。然而，用户似乎足够有先见之明，在闪烁的光标处输入ab。只有在按下Enter键后，程序才会结束，缓冲区才会刷新，从而揭示标准输出：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By the way, some C programmers use the *fflush()* function to force output or
    to clear the input stream. This function, defined in the stdio.h header file,
    dumps the stream for the named file handle, such as stdin or stdout. I find it
    unreliable and an awkward method to force stream I/O to somehow feign an interactive
    C program. Using this technique (which I confess to recommending in some of my
    other books) is known as a *kludge*. This term implies that using *fflush()* to
    empty an input or output buffer may be a workable solution but not the best.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，一些 C 程序员使用 *fflush()* 函数强制输出或清除输入流。这个函数在 stdio.h 头文件中定义，将名为文件句柄的流（如 stdin
    或 stdout）清空。我发现它不可靠，并且强制流 I/O 以某种方式模拟交互式 C 程序的方法很笨拙。使用这种技术（我承认我在其他一些书中推荐过）被称为
    *kludge*。这个术语意味着使用 *fflush()* 清空输入或输出缓冲区可能是一个可行的解决方案，但不是最好的。
- en: 4.1.2 Writing a simple filter
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 编写简单的过滤器
- en: 'Filters modify stream input and generate stream output. They manipulate the
    stream at the character level: a tiny character pops in, it’s somehow manipulated,
    and then something else pops out or not at all. The two functions most commonly
    used to perform the filter’s magic are *getchar()* and *putchar()*, both defined
    in the stdio.h header file.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器修改流输入并生成流输出。它们在字符级别操作流：一个微小的字符进入，以某种方式被处理，然后另一个字符出来，或者什么也不出来。执行过滤器魔法的两个最常用的函数是
    *getchar()* 和 *putchar()*，这两个函数都在 stdio.h 头文件中定义。
- en: 'The *getchar()* function reads a single character from standard input. For
    most compilers, *getchar()* is a macro, equivalent to the *fgetc()* function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*getchar()* 函数从标准输入读取单个字符。对于大多数编译器，*getchar()* 是一个宏，等同于 *fgetc()* 函数：'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The *fgetc()* function reads a single character (byte) from an open file handle.
    On the preceding line, stdin is used as the standard input device. The integer
    value returned is stored in the int variable c. This variable *must* be declared
    of the integer data type, not character. The reason is that important values,
    specifically the end-of-file (EOF) marker, are integer values. Assigning the function’s
    return value to a *char* variable means the EOF won’t be interpreted properly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*fgetc()* 函数从一个打开的文件句柄中读取单个字符（字节）。在上行中，stdin 被用作标准输入设备。返回的整数值存储在 int 变量 c 中。这个变量
    *必须* 声明为整数数据类型，而不是字符。原因是重要的值，特别是文件结束（EOF）标记，是整数值。将函数的返回值赋给 *char* 变量意味着 EOF 不会被正确解释。'
- en: 'The *putchar()* function sends a single character to standard output. As with
    *getchar()*, *putchar()* is often defined as a macro that expands to the *fputc()*
    function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*putchar()* 函数将单个字符发送到标准输出。与 *getchar()* 类似，*putchar()* 通常定义为展开为 *fputc()*
    函数的宏：'
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The *fputc()* function sends an integer value c to the open file handle represented
    by stdout, the standard output device. The return value, r, is the character written
    or EOF for an error. As with *fgetc()*, both variables r and c must be integers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*fputc()* 函数将整数值 c 发送到由 stdout 表示的打开文件句柄，即标准输出设备。返回值 r 是写入的字符或错误时的 EOF。与 *fgetc()*
    类似，变量 r 和 c 必须是整数。'
- en: A do-nothing filter is presented in listing 4.3\. It uses a *while* loop to
    process input until the EOF (end-of-file) marker is encountered. In this configuration,
    a character is read from standard input and stored in an *int* variable ch. The
    value of this character is then compared with the EOF defined constant. Providing
    that the character read isn’t the EOF, the loop spins. Such a loop can be constructed
    in other ways, but by using this method, you ensure that the EOF isn’t output
    accidentally.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 中提供了一个什么也不做的过滤器。它使用 *while* 循环处理输入，直到遇到 EOF（文件结束）标记。在这个配置中，从标准输入读取一个字符并存储在
    *int* 变量 ch 中。然后比较这个字符的值与定义的 EOF 常量。只要读取的字符不是 EOF，循环就会继续。这种循环可以用其他方式构建，但使用这种方法可以确保不会意外地输出
    EOF。
- en: Listing 4.3 io_filter.c
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 io_filter.c
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ I/O deals with integers, not characters.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ I/O 处理整数，而不是字符。
- en: ❷ Reads input until the end of file is encountered; EOF is an integer value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 读取输入直到遇到文件结束；EOF 是一个整数值。
- en: ❸ Spews output
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输出
- en: 'The result of the io_filter.c program is to do nothing. It works just like
    plumbing: water goes in, water comes out. No modification is made to the characters;
    the *putchar()* function outputs the character input, ch. Even so, the program
    demonstrates the basic structure for creating a filter that does something useful.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: io_filter.c 程序的结果是不做任何事情。它的工作方式就像管道：水进去，水出来。字符没有经过修改；*putchar()* 函数输出输入的字符 ch。即便如此，该程序展示了创建一个执行有用操作的过滤器的基本结构。
- en: 'If you run the filter program by itself, you see input echoed to output: pressing
    Enter flushes the output buffer, causing the echoed text to appear:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你单独运行过滤器程序，你会看到输入被回显到输出：按下 Enter 清空输出缓冲区，导致回显文本出现：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Press the EOF key to halt the program. In Linux, the EOF key is Ctrl+D. In Windows,
    press Ctrl+Z for the EOF.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 EOF 键来停止程序。在 Linux 中，EOF 键是 Ctrl+D。在 Windows 中，按 Ctrl+Z 作为 EOF。
- en: 'To make the filter do something, build up the *while* loop in the io_filter.c
    source code. The goal is to modify the characters’ input before sending them to
    output. (Otherwise: plumping.)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要让过滤器执行某些操作，请在 io_filter.c 源代码中构建 *while* 循环。目标是修改字符输入，在发送到输出之前。否则：膨胀。
- en: 'As an example, you could modify the input so that all vowels are detected and
    replaced with an asterisk character. This modification takes place within the
    while loop, as it processes the input stream. Here is one way to accomplish this
    task:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以修改输入，以便检测并替换所有元音字母为星号字符。这种修改在 while 循环中进行，因为它处理输入流。以下是完成此任务的一种方法：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The full source code for this modification is available in this book’s GitHub
    repository as censored.c. Here’s a sample run:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此修改的完整源代码可在本书的 GitHub 仓库中找到，名为 censored.c。以下是一个示例运行：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Exercise 4.1
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.1
- en: 'Now that you have the basic filter skeleton in io_filter.c, you can perform
    your own modifications, testing your filter programming skills. Here is such a
    challenge you can code on your own: write a filter that converts lowercase characters
    to uppercase. The effect of such a filter is to generate output in ALL CAPS. My
    solution to this exercise is found in this book’s GitHub repository as allcaps.c.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了 io_filter.c 中的基本过滤器框架，你可以进行自己的修改，测试你的过滤器编程技能。这里有一个你可以自己编写的挑战：编写一个将小写字符转换为大写的过滤器。这种过滤器的效果是生成全大写输出。这个练习的解决方案可以在本书的
    GitHub 仓库中找到，名为 allcaps.c。
- en: Exercise 4.2
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.2
- en: Write a filter that randomizes character text, modifying standard input to generate
    output in either upper- or lowercase, regardless of the original character’s case.
    I have included my potential solution to this exercise in this book’s GitHub repository
    as ransom.c.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个过滤器，随机化字符文本，修改标准输入以生成大写或小写输出，而不考虑原始字符的大小写。我已经将这个练习的潜在解决方案包含在这本书的 GitHub
    仓库中，名为 ransom.c。
- en: 4.1.3 Working a filter at the command prompt
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 在命令提示符下使用过滤器
- en: You can’t test a filter from within an IDE, so banish yourself to the command
    prompt if you haven’t already. The I/O redirection tools you need are shown in
    table 4.1\. These single-character commands modify the stream, altering the flow
    of input or output—or both!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在 IDE 中测试过滤器，所以如果你还没有这样做，请转到命令提示符。你需要使用的 I/O 重定向工具如表 4.1 所示。这些单字符命令修改流，改变输入或输出的流程——或者两者都改变！
- en: Table 4.1 I/O redirection characters and their functions
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 I/O 重定向字符及其功能
- en: '| Character | Name | What it does |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 名称 | 功能 |'
- en: '| > | Greater than | Redirects output (not really used for filters) |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| > | 大于 | 重定向输出（实际上不用于过滤器） |'
- en: '| < | Less than | Redirects input |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| < | 小于 | 重定向输入 |'
- en: '| &#124; | Pipe | Sends output through another program |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| &#124; | 管道 | 通过另一个程序发送输出 |'
- en: 'Assume that you’ve completed exercise 4.2, where you create a filter to randomize
    character text. This filter program is named hostage. To use this filter, you
    must specify the program’s full pathname. For the following commands, it’s assumed
    that the filter is stored in the same directory where the command is typed; the
    ./ prefix directs the operating system to find the program in the current directory:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经完成了练习 4.2，其中你创建了一个随机化字符文本的过滤器。这个过滤器程序名为 hostage。要使用这个过滤器，你必须指定程序的完整路径名。对于以下命令，假设过滤器存储在输入命令的同一目录中；./
    前缀指示操作系统在当前目录中查找程序：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The *echo* command sends a string of text to standard output. However, the
    pipe character intercepts standard output, sending it away from the standard output
    device (the terminal window). Instead, the *echo* command’s output is provided
    as input to the named program, ransom. The result is that the filter processes
    the string of text as its input:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*echo* 命令将一串文本发送到标准输出。然而，管道字符拦截了标准输出，将其从标准输出设备（终端窗口）发送出去。相反，*echo* 命令的输出被提供给名为
    ransom 的程序作为输入。结果是，过滤器将文本字符串作为其输入进行处理：'
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Another way to churn text through a filter is to use input redirection. In
    this configuration, the filter program name comes first. It’s followed by the
    input redirection character, < (less than), and the source of input, such as a
    text file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种将文本通过过滤器的方式是使用输入重定向。在这个配置中，过滤器程序名称首先出现。然后是输入重定向字符 <（小于），以及输入源，例如一个文本文件：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Above, the contents of file.txt are redirected as input for the hostage program,
    which outputs the file’s text using random upper- and lowercase letters.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，file.txt 的内容被重定向为人质程序的输入，该程序使用随机的大写和小写字母输出文件的文本。
- en: 'The output redirection character doesn’t really play a role with a filter.
    Instead, it takes a program’s output and sends it to a file or a device: The program
    (or construction’s) output supplies text for the file. If the file exists, it’s
    overwritten. Otherwise, a new file is created:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输出重定向字符在过滤器中实际上不起作用。相反，它将程序的输出发送到文件或设备：程序（或构造）的输出为文件提供文本。如果文件存在，它将被覆盖。否则，将创建一个新文件：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Above, the *echo* command’s text is processed through the hostage filter. The
    output would normally go to the standard output device, but instead it’s redirected
    and saved into the file ransom_note.txt.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，*echo* 命令的文本通过人质过滤器进行处理。输出通常会发送到标准输出设备，但相反，它被重定向并保存到 ransom_note.txt 文件中。
- en: Remember that output redirection doesn’t supply input for a filter. Use the
    pipe to send output from one program (or some other source) into the filter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，输出重定向不会为过滤器提供输入。请使用管道将一个程序（或某些其他来源）的输出发送到过滤器。
- en: 4.2 On the front lines with Caesar
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 与凯撒并肩作战前线
- en: 'Julius Caesar didn’t invent the cipher that’s been given his name. The technique
    is old but effective with a mostly illiterate population: Caesar could send an
    encrypted letter and—should it fall into enemy hands—the bad guys would be clueless.
    Silly Belgae. Yet once received by the right person, the text was instantly deciphered
    and pity poor Gaul again.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 朱利叶斯·凯撒并没有发明以他的名字命名的密码。这项技术虽然古老但有效，尤其是在一个大部分文盲的人群中：凯撒可以发送一个加密的信件，如果它落入敌人手中，坏蛋们将毫无头绪。愚蠢的比利时人。然而，一旦被正确的人收到，文本立即被解密，可怜的高卢人再次受到同情。
- en: 'Figure 4.4 illustrates how the cipher works, which is a simple letter shift.
    It’s based upon a starting pair, such as A to D, shown in the figure. This relationship
    continues throughout the alphabet, shifting letters based on the initial pair:
    A to D, B to E, C to F, and so on.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 展示了密码的工作原理，它是一种简单的字母移位。它基于一个起始对，如图中所示，例如 A 到 D。这种关系在整个字母表中继续，根据起始对来移位字母：A
    到 D，B 到 E，C 到 F，以此类推。
- en: '![04-04](Images/04-04.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![04-04](Images/04-04.png)'
- en: Figure 4.4 The Caesarean cipher is based upon a letter shift.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 凯撒密码基于字母移位。
- en: 'When you know the initial pair of the cipher, the message is easily decoded.
    In fact, you may have used this type of cipher if you have ever obtained a secret
    decoder ring: the initial pair is given and then rest of the message is encoded
    or decoded, letter by letter:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道密码的起始对时，信息很容易被解码。实际上，如果你曾经获得过一个秘密解码环，你可能已经使用过这种类型的密码：起始对是给出的，然后整个信息逐字进行编码或解码：
- en: '*EH VXUH WR GULQN BRXU RYDOWLQH.*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*EH VXUH WR GULQN BRXU RYDOWLQH.*'
- en: Surprisingly, the Caesarean cipher, also called a substitution cipher, is still
    used today. It’s admittedly weak, but don’t tell the neighbors. The *rot13* filter
    is perhaps the most common, which you can read about in the next section. Still,
    it’s a fun filter to program, and it has its place in the realm of encryption
    techniques.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 惊讶的是，凯撒密码，也称为替换密码，至今仍在使用。诚然，它很脆弱，但请不要告诉邻居。*rot13* 过滤器可能是最常见的，你可以在下一节中了解到它。然而，编写这样的过滤器很有趣，它在加密技术领域也有其位置。
- en: 4.2.1 Rotating 13 characters
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 旋转 13 个字符
- en: The most common Caesarean cipher known to Unix mavens is the *rot13* filter.
    Please say “rote 13” and not “rot 13.” Thank you.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 高手们所熟知的最常见的凯撒密码是 *rot13* 过滤器。请说“rote 13”，而不是“rot 13”。谢谢。
- en: The *rot13* program works as a filter. If it’s not included with your Linux
    distro, use your package manager to locate it as well as other ancient and nifty
    command-line tools.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*rot13* 程序作为一个过滤器工作。如果它没有包含在你的 Linux 发行版中，请使用你的包管理器找到它以及其他古老而巧妙的命令行工具。'
- en: 'The name *rot13* comes from the character substitution pattern: the Latin alphabet
    (and ASCII) holds 26 characters, A to Z. If you perform an A-to-N character substitution,
    the upper half of the alphabet is swapped with the lower, as illustrated in figure
    4.5\. The program “rotates 13” characters. The beauty of this translation is that
    running that *rot13* filter twice restores text to the original. This way, the
    same filter is used to both encrypt and decrypt messages.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*rot13* 这个名字来源于字符替换模式：拉丁字母（和ASCII）有26个字符，从A到Z。如果你执行A到N的字符替换，字母表的上半部分与下半部分互换，如图4.5所示。程序“旋转13”个字符。这种翻译的美丽之处在于，运行两次*rot13*过滤器可以将文本恢复到原始状态。这样，相同的过滤器既可以加密也可以解密消息。'
- en: '![04-05](Images/04-05.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![04-05](Images/04-05.png)'
- en: Figure 4.5 The *rot13* filter swaps the upper half of the alphabet with the
    lower half, effectively “rotating” the characters by 13 positions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 *rot13*过滤器将字母表的上半部分与下半部分互换，有效地将字符“旋转”了13个位置。
- en: Back on the old ARPANET, as well as on early internet, *rot13* was used as a
    filter in messaging services to hide spoilers, punchlines, and other information
    people may not want to read right away. Figure 4.6 shows a run of the *rot13*
    filter on a message. In the original text, the joke appears in standard text with
    the punchline concealed. After applying the *rot13* filter, the joke text is concealed
    but the punchline is revealed, for a hearty har-har.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧ARPANET以及早期的互联网上，*rot13* 被用作消息服务中的过滤器，以隐藏剧透、笑点和其他人们可能不想立即阅读的信息。图4.6展示了消息上*rot13*过滤器的运行情况。在原始文本中，笑话以标准文本形式出现，笑点被隐藏。应用*rot13*过滤器后，笑话文本被隐藏，但笑点被揭示，让人忍俊不禁。
- en: '![04-06](Images/04-06.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![04-06](Images/04-06.png)'
- en: Figure 4.6 The effect of applying the *rot13* filter to text, scrambled and
    unscrambled
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 应用*rot13*过滤器到文本的效果，乱序和还原
- en: 'This type of Caesarean cipher is easy to code, because you either add or subtract
    13 from a given character’s ASCII value, depending on where the character squats
    in the alphabet: upper or lower half. The addition or subtraction operation works
    for both upper- and lowercase letters.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的凯撒密码很容易编写，因为你要么从给定字符的ASCII值中加上或减去13，这取决于字符在字母表中的位置：上半部分或下半部分。加法或减法运算适用于大写和小写字母。
- en: 'In listing 4.4, the code for caesar01.c uses the isalpha() function to weed
    out letters of the alphabet. The *toupper()* function converts the letters to
    uppercase so that it can test for characters in the range from A through M. If
    so, these characters are shifted up 13 places: ch+= 13. Otherwise, the else statement
    catches the higher letters of the alphabet, shifting them down.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表4.4中，caesar01.c的代码使用isalpha()函数来排除字母表中的字母。*toupper()*函数将字母转换为大写，以便测试从A到M范围内的字符。如果是这样，这些字符将向上位移13个位置：ch+=
    13。否则，else语句会捕获字母表中的高字母，将它们向下位移。
- en: Listing 4.4 caesar01.c
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4 caesar01.c
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Only processes alphabet characters
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 只处理字母字符
- en: ❷ Searches for “A” through “M” or “a” through “m”
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 搜索“A”到“M”或“A”到“m”
- en: ❸ Rotates (shift) up for the lower half of the alphabet
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对字母表下半部分向上旋转（位移）
- en: ❹ Otherwise, rotates (shift) down
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 否则，向下旋转（位移）
- en: 'As with all filters, you can employ I/O redirection commands (characters) to
    see it in action at the command prompt. Refer to section 4.1.3 for the specifics.
    If the program for the caesar01.c source code is named caesar01, here’s a sample
    run:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有过滤器一样，你可以使用I/O重定向命令（字符）在命令提示符下看到它的实际效果。具体细节请参阅4.1.3节。如果caesar01.c源代码的程序命名为caesar01，以下是一个示例运行：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When the program is run directly, it processes the text you type as standard
    input:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序直接运行时，它处理你输入的文本作为标准输入：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Because the *rot13* filter decodes and encodes the same text, you can put the
    program to the test by running text through it twice. In the command-line construction
    below, text is echoed through the program once and then again. The result is the
    original text, thanks to the magic of the *rot13* process:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*rot13*过滤器对相同的文本进行解码和编码，你可以通过将文本通过它运行两次来测试程序。在下面的命令行构造中，文本通过程序运行一次，然后再次运行。由于*rot13*过程的神奇之处，结果是原始文本：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Remember that the *rot13* filter isn’t designed to keep information completely
    secure. Still, it provides a handy and common way to keep something concealed
    but not necessarily encrypted beyond reach:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，*rot13* 过滤器并不是为了完全保护信息安全而设计的。尽管如此，它提供了一个方便且常见的方法来隐藏某些内容，但不一定是加密到无法触及：
- en: '*Why did Caesar cross the Rubicon?*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*凯撒为什么越过鲁比孔河？*'
- en: '*Gb trg gb gur bgure fvqr.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*Gb trg gb gur bgure fvqr.*'
- en: 4.2.2 Devising a more Caesarean cipher
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 设计更复杂的凯撒密码
- en: Caesar didn’t use the *rot13* filter to encrypt his messages, mostly because
    he never upgraded to Linux from his trusty Commodore 64\. No, he preferred the
    A-to-D shift. Sometimes it was just an A-to-B shift. Regardless, coding such a
    beast is a bit more involved than the convenient 13-character shift of the *rot13*
    filter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒没有使用 *rot13* 过滤器来加密他的信息，主要是因为他从可靠的 Commodore 64 系统升级到 Linux 的过程中从未升级过。不，他更喜欢
    A 到 D 的移位。有时它只是一个 A 到 B 的移位。无论如何，编写这样的程序比 *rot13* 过滤器方便的 13 个字符移位要复杂得多。
- en: Properly transposing letters based on a value other than 13 means the letters
    will wrap. For example, an A-to-D translation means that Z would wrap to some
    character Z+3 in the ASCII table. Therefore, to keep the translation going, the
    letter shift must wrap from Z back to C (refer to figure 4.4). You must account
    for such wrapping in your code, confirming that characters are contained within
    the 26-letter change of the alphabet—both upper- and lowercase.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 根据除 13 之外的其他值正确转换字母意味着字母会回绕。例如，A 到 D 的转换意味着 Z 会回绕到 ASCII 表中 Z+3 的某个字符。因此，为了使转换继续进行，字母移位必须从
    Z 回绕到 C（参见图 4.4）。你必须在代码中考虑这种回绕，确保字符包含在字母表的 26 个字母变化中——包括大写和小写。
- en: To account for such wrapping, specifically with an A-to-D translation, your
    code must construct a complex *if* condition using logical comparisons to account
    for characters that shift out of range. Figure 4.7 illustrates how such an expression
    works. It tests for values greater than 'Z' and less than 'a', but also greater
    than 'z'. This arrangement exists due to how characters are encoded with the ASCII
    standard. (See chapter 5 for more details on ASCII.)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这种回绕，特别是对于 A 到 D 的转换，你的代码必须构建一个复杂的 *if* 条件，使用逻辑比较来处理超出范围的字符。图 4.7 展示了这种表达式是如何工作的。它测试值大于
    'Z' 且小于 'a'，但也大于 'z'。这种排列是由于字符按照 ASCII 标准进行编码。（有关 ASCII 的更多详细信息，请参阅第 5 章。）
- en: '![04-07](Images/04-07.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![04-07](Images/04-07.png)'
- en: Figure 4.7 Detecting overflow characters when performing an A-to-D shift
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 在执行 A 到 D 移位时检测溢出字符
- en: When a character is detected as out of range by the *if* statement, its value
    must be reduced by 26, wrapping it back to 'A' or 'a', depending on the letter’s
    original case.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *if* 语句检测到字符超出范围时，其值必须减少 26，将其回绕到 'A' 或 'a'，具体取决于字母的原始大小写。
- en: Due to the proximity of uppercase 'Z' to lowercase 'a', this *if* statement
    test works because this particular shift is only three characters. From figure
    4.7, you see that the ASCII table sets only six characters between uppercase Z
    and lowercase a. For larger character shifts, more complex testing must be performed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大写字母 'Z' 与小写字母 'a' 的接近，这个 *if* 语句测试之所以有效，是因为这种特定的移位只有三个字符。从图 4.7 中，你可以看到 ASCII
    表只在大写字母 'Z' 和小写字母 'a' 之间设置了六个字符。对于更大的字符移位，必须进行更复杂的测试。
- en: Listing 4.5 shows how the A-to-D character shift cipher is coded, complete with
    the complex *if* statement that wraps overflow characters. Otherwise, the character
    is shifted by the value of variable shift, calculated as 'D' - 'A'. This shift
    is expressed backward to properly calculate as three. Therefore, three is added
    to each alphabetic character in the code—unless the character is out of range.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 展示了如何编码 A 到 D 字符移位密码，包括将溢出字符回绕的复杂 *if* 语句。否则，字符将根据变量 shift 的值进行移位，该值计算为
    'D' - 'A'。这种移位以反向表达，以便正确计算为三。因此，代码中的每个字母字符都加三——除非字符超出范围。
- en: Listing 4.5 caesar02.c
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 caesar02.c
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Shifts from A to D, which is done backward here because math
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 A 移动到 D，这里之所以反向操作，是因为数学
- en: ❷ Handles letters specifically
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 特殊处理字母
- en: ❸ Shifts the letter
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 移动字母
- en: ❹ Determines whether the new character is out of range
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 确定新字符是否超出范围
- en: ❺ If so, adjusts its value back within range
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果是这样，则调整其值回到范围内
- en: 'Here is a sample run:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例运行：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Unlike with a *rot13* filter, you can’t run the same program twice to decode
    the A-to-D shift. Instead, to decode the message, you must shift from D back to
    A. Two changes are required to make this change. In the code shown in listing
    4.5, first alter the shift calculation:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与 *rot13* 过滤器不同，你不能运行相同的程序两次来解码 A 到 D 的移位。相反，为了解码信息，你必须从 D 移回到 A。为此需要两个更改。在列表
    4.5 中显示的代码中，首先更改移位计算：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Second, the out-of-bounds testing must check the underside of the alphabet,
    so see whether a character’s value has dipped below ''A'' or ''a'':'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，越界测试必须检查字母表的底部，看看字符的值是否已经低于 'A' 或 'a'：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the character wraps on the underside of the alphabet, its value is increased
    by 26, which wraps it back up to the Z end, correcting the overflow.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符在字母表的底部回绕，其值将增加26，这样它就会回绕到Z的末尾，纠正溢出。
- en: 'The final program is available as caesar03.c in this book’s GitHub repository.
    Here is a sample run:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最终程序作为caesar03.c存储在这个书的GitHub仓库中。以下是一个示例运行：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first two lines show the D-to-A shift of normal text, how the filter encodes
    plain text. The second two lines show how the D-to-A shift decrypts the original
    A-to-D shift of the caesar02.c code. (Refer to the output shown earlier.)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行显示了D到A的转换，即过滤器如何编码纯文本。接下来的两行显示了D到A的转换如何解密caesar02.c代码的原始A到D转换。（参考之前显示的输出。）
- en: 'As with any filter, you can pipe output through both filters to recover the
    original text:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何过滤器一样，您可以将输出通过两个过滤器来恢复原始文本：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Of course, the best way to code a more Caesarean cipher is to let the user determine
    which letters to shift. To make this filter work, command-line arguments are required;
    filters are not interactive, so the user isn’t given the opportunity to provide
    input otherwise.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，编写更凯撒密码的最佳方式是让用户确定要转换的字母。为了让这个过滤器工作，需要命令行参数；过滤器不是交互式的，所以用户没有机会提供其他输入。
- en: The command-line arguments provide the two letters for the shift, from argument
    1 to argument 2\. The code then works out the process, performing the shift on
    whatever text is flung into standard input.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数提供了转换的两个字母，从参数1到参数2。然后代码计算出这个过程，对投入标准输入的任何文本执行转换。
- en: 'Letting the user decide options is always good. Providing this feature means
    that the bulk of the code is used to interpret the command-line options: you must
    check to see whether the options are present and then confirm that both are letters
    of the alphabet. Such code is available in the GitHub repository as caesar04.c.
    The extra step of checking for two command-line arguments in this source code
    file consumes 16 lines of code.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让用户决定选项总是好的。提供这个功能意味着大部分代码都用于解释命令行选项：你必须检查选项是否存在，然后确认这两个选项都是字母表中的字母。这样的代码可以在GitHub仓库中的caesar04.c文件中找到。在这个源代码文件中检查两个命令行参数的额外步骤消耗了16行代码。
- en: Once the two shifting characters are set, they’re saved in *char* variables
    a and b. A *while* loop then processes the text based on the shift value of the
    two characters supplied. Because the shift can be up or down, and to best check
    for out-of-range values, the loop must separate upper- and lowercase characters.
    This approach is best to detect shift overflow and deal with it properly. The
    program’s core *while* loop and the various tests from my caesar04.c program are
    shown in the next listing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了两个转换字符，它们就被保存在*char*变量a和b中。然后一个*while*循环根据提供的两个字符的转换值处理文本。因为转换可以是向上或向下，为了最好地检查范围外的值，循环必须分别处理大写和小写字符。这种方法最好用于检测转换溢出并正确处理它。程序的核心*while*循环和caesar04.c程序中的各种测试在下一列表中显示。
- en: Listing 4.6 The *while* loop in caesar04.c that performs the character shift
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6 caesar04.c中的*while*循环执行字符转换
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Upper- and lowercase characters must be handled differently.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 大小写字符必须以不同的方式处理。
- en: ❷ Adjusts appropriately for overflow in either direction
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 适当调整双向溢出
- en: 'Here is a sample run of the *caesar04* program with an A-to-R shift:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是*caesar04*程序的一个A到R转换的示例运行：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And to reverse, the R-to-A shift is specified as command line arguments:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要反转，R 到 A 的转换由命令行参数指定：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As an improvement, it might be better to have a single argument that specifies
    the character shift, such as **RA** instead of the separate R and A just shown.
    Then again, as with most programmers, messing with code is an eternal process.
    I leave this task up to you.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 作为改进，可能更好的是有一个单独的参数来指定字符转换，比如**RA**而不是像刚才那样分开的R和A。然而，就像大多数程序员一样，修改代码是一个永恒的过程。我把这个任务留给你。
- en: 4.3 Deep into filter madness
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 深入过滤器疯狂
- en: 'I’ve created a slew of filters over my programming career. It’s amazing to
    think of the fun things you can accomplish. Well, fun for nerds. Non-nerds are
    reading a romance novel right now. Let me spoil it: his work is more important
    to him than she is. There. Saved you 180 dreary pages.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的编程生涯中，我创建了许多过滤器。想到你可以完成的一些有趣的事情，真是令人惊讶。嗯，对那些书呆子来说很有趣。非书呆子现在正在读一本浪漫小说。让我来破坏一下：他的工作对他来说比她更重要。就这样。帮你省下了180页无聊的内容。
- en: 'Regardless of what a filter does, the method for composing a filter is always
    the same: read standard input, modify it, and then generate standard output.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 无论过滤器做什么，编写过滤器的方法总是相同的：读取标准输入，修改它，然后生成标准输出。
- en: Before the chapter closes (and I must hurry because my work is important), I
    offer a few different filter ideas to help churn your creative juices. The possibilities
    are endless.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束之前（我必须快点，因为我的工作很重要），我提供了一些不同的过滤器想法，以帮助激发你的创造力。可能性是无限的。
- en: 4.3.1 Building the hex output filter
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 构建十六进制输出过滤器
- en: Just because one character flows into a filter doesn’t mean another character
    must always flow out. Some filters may spew out several characters of output for
    each character input. Other filters may not output any modification of text, such
    as the *more* filter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 就算一个字符流入过滤器，并不意味着另一个字符必须始终流出。一些过滤器可能对每个输入字符输出多个字符。其他过滤器可能不会输出任何文本修改，例如 *more*
    过滤器。
- en: 'The *more* filter is a handy text-reading utility. It’s used to page output.
    Shoving output through the *more* filter prompts for input after each screen of
    text:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*more* 过滤器是一个方便的文本阅读工具。它用于分页输出。将输出通过 *more* 过滤器后，每满一屏文本会提示输入：'
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Above, the contents of file long.txt are output via the *cat* command. The *more*
    filter pauses the display after every screenful of text. This filter was popular
    enough in Unix that Microsoft “borrowed” it for inclusion with its text-mode operating
    system, MS-DOS.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，文件 long.txt 的内容通过 *cat* 命令输出。*more* 过滤器在每满一屏文本后暂停显示。这个过滤器在 Unix 中足够流行，以至于微软“借用”它并将其包含在其文本模式操作系统
    MS-DOS 中。
- en: For a filter that generates more output than input, consider the following listing.
    The code accepts standard input and outputs the hex values for each character.
    The *printf()* statement generates two-digit hex values.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生成比输入更多输出的过滤器，考虑以下列表。该代码接受标准输入，并输出每个字符的十六进制值。*printf()* 语句生成两位十六进制值。
- en: Listing 4.7 hexfilter01.c
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 hexfilter01.c
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Outputs character as two-digit hex byte, with a leading zero
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 以两位十六进制字节输出字符，带前导零
- en: 'The code for hexfilter01.c works well, but it does have a problem with its
    output: the two-digit character format appears as a long string of text. Often
    a text value is split between two lines. A better approach would be to monitor
    output to avoid splitting a hex value at the end of a line.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: hexfilter01.c 的代码运行良好，但它输出时确实存在一个问题：两位字符格式显示为长字符串文本。通常文本值会分布在两行之间。更好的方法是监控输出，以避免在行尾分割十六进制值。
- en: Exercise 4.3
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.3
- en: Assuming that the terminal screen is 80 characters wide, modify the code to
    hexfilter01.c so that output doesn’t split a hex value between two lines. Further,
    when a newline character is encountered, have the line of output terminated with
    a newline. My solution for this exercise can be found in the GitHub repository
    as hexfilter02.c. Please try this exercise on your own before you peek at my solution.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设终端屏幕宽度为 80 个字符，修改 hexfilter01.c 代码，使输出不会在两行之间分割十六进制值。此外，当遇到换行符时，输出行应以换行符结束。这个练习的解决方案可以在
    GitHub 仓库中找到，作为 hexfilter02.c。请在查看我的解决方案之前自己尝试这个练习。
- en: 4.3.2 Creating a NATO filter
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 创建北约过滤器
- en: Chapter 3 covered the NATO phonetic alphabet, which—surprise—can also be applied
    as a filter. For example, the filter reads standard input, plucking out all the
    alphabetic characters. For each one, the filter outputs the corresponding NATO
    term. This program is another example of a filter that does more than a single-character
    exchange.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 章介绍了北约音标字母表，它——惊喜——也可以用作过滤器。例如，过滤器读取标准输入，提取所有字母字符。对于每一个，过滤器输出相应的北约术语。这个程序是另一个过滤器，它不仅仅进行单字符交换的例子。
- en: To make the phonetic alphabet translation, the code must borrow the nato[] array
    of terms presented in chapter 3\. This array is shown in listing 4.8\. It’s coupled
    with the standard I/O filter *while* loop. In the loop, the *isalpha()* function
    detects alphabetic characters. Some math is performed to obtain the proper term
    offset in the array, which outputs the correct term for each letter processed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行音标字母表的翻译，代码必须借用第 3 章中提到的 nato[] 术语数组。该数组在列表 4.8 中显示。它与标准 I/O 过滤器 *while*
    循环结合使用。在循环中，*isalpha()* 函数检测字母字符。进行一些数学运算以获得数组中正确的术语偏移量，从而输出每个处理的字母的正确术语。
- en: Listing 4.8 nato01.c
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.8 nato01.c
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Translates a character into an offset within the nato[] array
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将字符转换为 nato[] 数组中的偏移量
- en: ❷ Outputs a newline when encountered to keep the output clean
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遇到时输出换行符以保持输出整洁
- en: 'Here’s a sample run:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例运行：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It’s important to know that any nonalphabetic characters (aside from newline)
    are ignored by this filter. Ignoring input in a filter is legitimate; a filter
    need not generate one-to-one output based on input.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，此过滤器会忽略任何非字母字符（除换行符外）。在过滤器中忽略输入是合法的；过滤器不需要根据输入生成一对一的输出。
- en: 4.3.3 Filtering words
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 过滤单词
- en: Filters operate on character I/O, but this limitation doesn’t restrict a filter
    from affecting words, sentences, or other chunks of text. The key is to store
    input as it arrives. Once the proper text chunks are assembled, such as a word
    or sentence, the filter can process it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器在字符输入/输出上操作，但这种限制并不阻止过滤器影响单词、句子或其他文本块。关键是存储到达的输入。一旦适当的文本块（如单词或句子）被组装好，过滤器就可以对其进行处理。
- en: For example, to slice standard input by word, you write a filter that collects
    characters until a word boundary—a space, comma, tab, or period, for example—is
    encountered. The input must be stored, so further testing must be done to ensure
    that the storage doesn’t overflow. Once the buffer contains a word (or whatever
    size text chunk you need), it can be sent to standard output or manipulated in
    whatever way the filter needs to massage the data.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了按单词切割标准输入，你编写一个过滤器，收集字符直到遇到单词边界——例如空格、逗号、制表符或句号。输入必须被存储，因此必须进行进一步的测试以确保存储不会溢出。一旦缓冲区包含一个单词（或你需要的任何大小的文本块），它就可以发送到标准输出或以过滤器需要的方式处理数据。
- en: In listing 4.9, a 64-character buffer word[] stores words. The *while* loop
    is split into *if-else* conditions. The *if* test marks the end of a word, capping
    the word[] buffer with a null character, confirming that a full word is ready
    to output, and then outputting the word. The *else* test builds the word, ensuring
    that the buffer doesn’t overflow. The result is a filter that pulls out words
    and sets each one on a line by itself.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表4.9中，一个64字符的缓冲区word[]存储单词。*while*循环被分成*if-else*条件。*if*测试标记单词的结束，使用空字符首字母大写word[]缓冲区，确认一个完整的单词准备输出，然后输出单词。*else*测试构建单词，确保缓冲区不会溢出。结果是提取单词并将每个单词单独放在一行上的过滤器。
- en: Listing 4.9 word_filter.c
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.9 word_filter.c
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ The word size is set here; this way, you can update the buffer size in a single
    spot, and various other parts of the code are updated to reflect the change.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 单词大小在这里设置；这样，你可以在一个地方更新缓冲区大小，并且代码的其他部分也会更新以反映这一变化。
- en: ❷ Initializes the offset value
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 初始化偏移量值
- en: ❸ The *isspace()* function returns TRUE for whitespace characters, marking the
    end of a word.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ *isspace()*函数对空白字符返回TRUE，标记单词的结束。
- en: ❹ Always cap your strings!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 总是首字母大写你的字符串！
- en: ❺ Ensures that the buffer has text in it to print
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 确保缓冲区中有文本可以打印
- en: ❻ Outputs the buffer’s contents (a word, hopefully) on a line by itself
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将缓冲区的内容（一个单词，希望如此）单独输出到一行
- en: ❼ Resets the offset
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 重置偏移量
- en: ❽ Printable characters are handled here, filling the buffer.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 处理可打印字符，填充缓冲区。
- en: ❾ Stores the character
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 存储字符
- en: ❿ Increments the offset
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 增加偏移量
- en: ⓫ Checks for potential overflow, a full buffer
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 检查潜在的溢出，缓冲区已满
- en: ⓬ Cap the string!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 首字母大写字符串！
- en: ⓭ Outputs the word, dumping the buffer
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ⓭ 输出单词，清空缓冲区
- en: ⓮ Resets the offset
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ⓮ 重置偏移量
- en: To build words, the code in word_filter.c replies upon the *isspace()* function,
    defined in the ctype.h header file. This function returns TRUE when a whitespace
    character is encountered on input. These characters include space, tab, and newline.
    These whitespace characters trigger a word boundary, though the code could be
    modified to account for other characters as well.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建单词，word_filter.c中的代码依赖于ctype.h头文件中定义的*isspace()*函数。当输入遇到空白字符时，该函数返回TRUE。这些字符包括空格、制表符和换行符。这些空白字符触发单词边界，尽管代码可以被修改以考虑其他字符。
- en: 'Here’s a sample run:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例运行：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Twice in the code you see statements that cap the word[] buffer with a null
    character:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中两次看到使用空字符首字母大写word[]缓冲区的语句：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It’s vital that all strings in C end with the null character, \0. Especially
    when you build your own strings, as is done in the word_filter.c code, confirm
    that the string that’s created is capped. If not, you get an overflow and all
    kinds of ugly output—and potential bad things happening.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，所有字符串都必须以空字符结尾，即\0。特别是当你构建自己的字符串时，就像在word_filter.c代码中所做的那样，确认创建的字符串已首字母大写。如果没有，你会得到溢出和各种丑陋的输出——以及可能发生的不良后果。
