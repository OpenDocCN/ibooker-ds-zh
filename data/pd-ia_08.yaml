- en: 6 Working with text data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 处理文本数据
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Removing whitespace from strings
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字符串中移除空白字符
- en: Uppercasing and lowercasing strings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串转换为大写或小写
- en: Finding and replacing characters in strings
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在字符串中查找和替换字符
- en: Slicing a string by character index positions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过字符索引位置切片字符串
- en: Splitting text by a delimiter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过分隔符拆分文本
- en: Text data can get quite messy. Real-world data sets are riddled with incorrect
    characters, improper letter casings, whitespace, and more. The process of cleaning
    data is called *wrangling* or *munging*. Often, the majority of our data analysis
    is dedicated to munging. We may know the insight we want to derive early on, but
    the difficulty lies in arranging the data in a suitable shape for the manipulation.
    Luckily for us, one of the primary motivations behind pandas was easing the difficulty
    of cleaning up improperly formatted text values. The library is battle-tested
    and flexible. In this chapter, we’ll learn how to use pandas to fix all sorts
    of imperfections in our text data sets. There’s a lot of ground to cover, so let’s
    dive right in.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 文本数据可能会非常混乱。现实世界的数据集充满了错误的字符、不正确的字母大小写、空白字符等等。清理数据的过程被称为*整理*或*修补*。通常，我们的大部分数据分析都致力于修补。我们可能一开始就知道我们想要得出的见解，但困难在于将数据整理成适合操作的形式。幸运的是，pandas背后的一个主要动机是简化清理格式不正确的文本值的过程。这个库经过实战检验且灵活。在本章中，我们将学习如何使用pandas来修复我们文本数据集中的各种缺陷。有很多内容要介绍，所以让我们直接进入正题。
- en: 6.1 Letter casing and whitespace
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 字母大小写和空白字符
- en: 'We’ll begin by importing pandas in a new Jupyter Notebook:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在新的Jupyter Notebook中导入pandas：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This chapter’s first data set, chicago_food_inspections.csv, is a listing of
    more than 150,000 food inspections conducted across the city of Chicago. The CSV
    includes only two columns: one with an establishment’s name and the other with
    its risk ranking. The four risk levels are Risk 1 (High), Risk 2 (Medium), Risk
    3 (Low), and a special All for the worst offenders:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一个数据集，chicago_food_inspections.csv，是芝加哥市进行的超过150,000次食品检查的列表。CSV文件只包含两列：一列是机构的名称，另一列是风险评级。四个风险等级是风险1（高）、风险2（中）、风险3（低），以及针对最严重违规者的特殊等级“所有”：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: NOTE chicago_food_inspections.csv is a modified version of a data set available
    from the city of Chicago ([http://mng.bz/9N60](http://mng.bz/9N60)). There are
    typos and inconsistencies within the data; we have preserved them so that you
    can see the data irregularities that appear in the real world. I encourage you
    to consider how you can optimize this data with the techniques you’ll learn in
    this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：chicago_food_inspections.csv是芝加哥市提供的数据集的一个修改版本（[http://mng.bz/9N60](http://mng.bz/9N60)）。数据中存在拼写错误和不一致性；我们保留了它们，以便您可以看到现实世界中出现的各种数据不规则性。我鼓励您考虑如何使用本章中学习的技巧来优化这些数据。
- en: 'We immediately see an issue in the Name column: inconsistency in letter casing.
    Most row values are uppercase, some are lowercase (`"mr.daniel''s"`), and some
    are normal case (`"Café 608"`).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立即在名称列中看到一个问题：字母大小写不一致。大多数行值是大写的，一些是小写的（`"mr.daniel's"`），还有一些是正常情况（`"Café
    608"`）。
- en: 'The preceding output does not show another problem hiding in `inspections`:
    the Name column’s values are surrounded by whitespace. We can spot the extra spacing
    more easily if we isolate the Name `Series` with square-bracket syntax. Notice
    that the ends of the rows do not align:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出没有显示`inspections`中隐藏的另一个问题：名称列的值被空白字符包围。如果我们使用方括号语法单独检查名称`Series`，我们可以更容易地发现额外的间隔。注意行尾没有对齐：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can use the `values` attribute on the `Series` to get the underlying NumPy
    `ndarray` storing the values. The whitespace is present at the ends and the beginnings
    of the values:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Series`上的`values`属性来获取存储值的底层NumPy `ndarray`。空白字符出现在值的开始和结束处：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let’s focus on the whitespace first. We’ll deal with the letter casings a little
    later.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先关注空白字符。我们稍后会处理字母大小写问题。
- en: 'The `Series` object’s `str` attribute exposes a `StringMethods` object, a powerful
    toolbox of methods for working with strings:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series`对象的`str`属性暴露了一个`StringMethods`对象，这是一个强大的字符串处理方法工具箱：'
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Any time we’d like to perform string manipulations, we invoke a method on the
    `StringMethods` object rather than the `Series` itself. Some methods work like
    Python’s native string methods, whereas other methods are exclusive to pandas.
    For a comprehensive review of Python’s string methods, see appendix B.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想要执行字符串操作时，我们都会在`StringMethods`对象上调用一个方法，而不是在`Series`本身上。一些方法类似于Python的本地字符串方法，而其他方法则是pandas独有的。有关Python字符串方法的全面回顾，请参阅附录B。
- en: 'We can use the `strip` family of methods to remove whitespace from a string.
    The `lstrip` (left strip) method removes whitespace from the beginning of a string.
    Here’s a basic example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`strip`方法族来从字符串中删除空白字符。`lstrip`（左删除）方法从字符串的开始处删除空白字符。以下是一个基本示例：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `rstrip` (right strip) method removes whitespace from the end of a string:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`rstrip`（右删除）方法从字符串的末尾删除空白字符：'
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `strip` method removes whitespace from both ends of a string:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`strip`方法从字符串的两端删除空白字符：'
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These three `strip` methods are available on the `StringMethods` object. Each
    one returns a new `Series` object with the operation applied to every column value.
    Let’s invoke each of them:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个`strip`方法都可在`StringMethods`对象上使用。每个方法都会返回一个新的`Series`对象，其中每个列值都应用了该操作。让我们调用它们：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we can overwrite our existing `Series` with the new one that has no extra
    whitespace. On the right side of an equal sign, we’ll use the `strip` code to
    create the new `Series`. On the left side, we’ll use square-bracket syntax to
    denote the column we’d like to overwrite. Python processes the right side of the
    equal sign first. In summary, we use the Name column to create a new `Series`
    without whitespace and then overwrite the Name column with that new `Series`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用没有额外空白的新`Series`覆盖现有的`Series`。在等号的右侧，我们将使用`strip`代码创建新的`Series`。在等号的左侧，我们将使用方括号语法来表示我们想要覆盖的列。Python首先处理等号右侧的部分。总之，我们使用“名称”列创建一个没有空白的新`Series`，然后用这个新`Series`覆盖“名称”列：
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This one-line solution is suitable for a small data set, but it may quickly
    become tedious for one with a large number of columns. How can we quickly apply
    the same logic to all `DataFrame` columns? You may recall the `columns` attribute,
    which exposes the iterable `Index` object that holds the `DataFrame`’s column
    names:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一行解决方案适用于小数据集，但对于拥有大量列的数据集来说可能会很快变得繁琐。我们如何快速将相同的逻辑应用到所有`DataFrame`列上？你可能还记得`columns`属性，它公开了包含`DataFrame`列名的可迭代`Index`对象：
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can use Python’s `for` loop to iterate over each column, extract it dynamically
    from the `DataFrame`, invoke the `str.strip` method to return a new `Series`,
    and overwrite the original column. The logic requires only two lines:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Python的`for`循环遍历每一列，从`DataFrame`中动态提取它，调用`str.strip`方法返回一个新的`Series`，并覆盖原始列。这个逻辑只需要两行代码：
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'All of Python’s character casing methods are available on the `StringMethods`
    object. The `lower` method, for example, lowercases all string characters:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Python的所有字符大小写方法都可在`StringMethods`对象上使用。例如，`lower`方法会将所有字符串字符转换为小写：
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The complementary `str.upper` method returns a `Series` with uppercase strings.
    The next example invokes the method on a different `Series` because the Name column
    is mostly uppercase already:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的`str.upper`方法返回一个包含大写字符串的`Series`。下一个示例在另一个`Series`上调用该方法，因为“名称”列已经大多是 uppercase
    的：
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Suppose that we want to get the establishments’ names in a more standardized,
    readable format. We can use the `str.capitalize` method to capitalize the first
    letter of each string in the `Series`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要以更标准、可读的格式获取机构的名称。我们可以使用`str.capitalize`方法将`Series`中每个字符串的第一个字母大写：
- en: '[PRE14]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That’s a step in the right direction, but perhaps the best method available
    is `str.title`, which capitalizes each word’s first letter. Pandas uses spaces
    to identify where one word ends and the next begins:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个正确的步骤，但可能最好的方法是`str.title`，它将每个单词的第一个字母大写。Pandas使用空格来识别一个单词的结束和下一个单词的开始：
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `title` method is a fantastic option for dealing with locations, countries,
    cities, and people’s full names.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`title`方法是一个处理地点、国家、城市和人们全名的绝佳选项。'
- en: 6.2 String slicing
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 字符串切片
- en: 'Let’s turn our focus to the Risk column. Each row’s value includes both a numeric
    and categorical representation of the risk (such as 1 and `"High"`). Here’s a
    reminder of what the column looks like:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把注意力转向“风险”列。每一行的值都包含风险的数值和分类表示（例如1和`"高"`）。以下是该列的提醒：
- en: '[PRE16]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s say we want to extract the numeric risk value from each row. This operation
    may appear simple, given the seemingly consistent format of each row, but we have
    to tread carefully. There is always room for deception in a data set this large:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想从每一行中提取数值风险值。鉴于每行看似一致的格式，这个操作可能看起来很简单，但我们必须小心行事。在一个如此大的数据集中，总会有欺骗的空间：
- en: '[PRE17]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Do all rows follow a `"Risk` `Number` `(Risk` `Level)"` format? We can find
    out by invoking the `unique` method, which returns a NumPy `ndarray` consisting
    of the column’s unique values:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有行都遵循`"风险" `数字` "(风险` `等级)"`格式吗？我们可以通过调用`unique`方法来找出答案，该方法返回一个包含列唯一值的NumPy
    `ndarray`：
- en: '[PRE18]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We have to account for two additional values: missing `NaNs` and the `''All''`
    string. How we deal with these values is ultimately up to the analyst and the
    business. Are the values significant, or can they be discarded? In this scenario,
    let’s propose a compromise: we’ll remove the missing `NaN` values and replace
    the `"All"` values with `"Risk 4 (Extreme)"`. We’ll pick this approach to ensure
    that all Risk values have a consistent format.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须考虑两个额外的值：缺失的`NaNs`和`'全部'`字符串。我们如何处理这些值最终取决于分析师和业务。这些值是否重要，或者可以丢弃？在这种情况下，让我们提出一个折衷方案：我们将删除缺失的`NaN`值，并将`"全部"`值替换为`"风险
    4 (极端)"`。我们将选择这种方法以确保所有风险值具有一致的格式。
- en: 'We can remove missing values from a `Series` with the `dropna` method introduced
    in chapter 5\. We’ll pass its `subset` parameter a list of the `DataFrame` columns
    in which pandas should look for `NaN`s. The next example removes rows in `inspections`
    with a `NaN` value in the Risk column:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用第5章中引入的`dropna`方法从`Series`中删除缺失值。我们将传递其`subset`参数一个包含`DataFrame`列的列表，pandas将在这个列表中查找`NaN`s。下一个示例从`inspections`中删除风险列中包含`NaN`值的行：
- en: '[PRE19]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s check in on unique values in the Risk column:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查风险列中的唯一值：
- en: '[PRE20]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can use the `DataFrame`’s helpful `replace` method to replace all occurrences
    of one value with another. The method’s first parameter, `to_replace,` sets the
    value to search for, and its second parameter, `value`, specifies what to replace
    each occurrence of it with. The next example replaces the `"All"` string values
    with `"Risk 4 (Extreme)"`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`DataFrame`的有用`replace`方法将一个值的所有出现替换为另一个值。该方法的第一参数`to_replace`设置要搜索的值，第二个参数`value`指定将每个出现替换为什么值。下一个示例将`"全部"`字符串值替换为`"风险
    4 (极端)"`：
- en: '[PRE21]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we have a consistent format for all values in the Risk column:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在风险列中的所有值都有了一致的格式：
- en: '[PRE22]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, let’s continue with our original goal of extracting each row’s risk number.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续我们的原始目标，即提取每一行的风险数字。
- en: 6.3 String slicing and character replacement
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 字符串切片和字符替换
- en: We can use the `slice` method on the `StringMethods` object to extract a substring
    from a string by index position. The method accepts a starting index and an ending
    index as arguments. The lower bound (the starting point) is inclusive, whereas
    the upper bound (the endpoint) is exclusive.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`StringMethods`对象上使用`slice`方法通过索引位置提取字符串的子串。该方法接受起始索引和结束索引作为参数。下限（起点）是包含的，而上限（终点）是排除的。
- en: 'Our risk number starts at index position 5 in each string. The next example
    pulls the characters from index position 5 up to (but not including) index position
    6:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的风险数字从每个字符串的索引位置5开始。下一个示例从索引位置5开始提取字符，直到（但不包括）索引位置6：
- en: '[PRE23]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can also replace the `slice` method with Python’s list-slicing syntax (see
    appendix B). The following code returns the same result as the preceding code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以用Python的列表切片语法（见附录B）替换`slice`方法。以下代码返回与前面代码相同的结果：
- en: '[PRE24]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: What if we want to extract the categorical ranking (`"High"`, `"Medium"`, `"Low"`,
    and `"All"`) from each row? This challenge is made difficult by the different
    lengths of the words; we cannot extract the same number of characters from a starting
    index position. A few solutions are available. We’ll discuss the most resilient
    option, regular expressions, in section 6.7.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从每一行中提取分类排名（`"高"`，`"中"`，`"低"`和`"全部"`)，这个挑战由于单词长度的不同而变得困难；我们不能从起始索引位置提取相同数量的字符。有几个解决方案可用。我们将讨论最健壮的选项，正则表达式，在第6.7节中。
- en: For now, let’s attack the problem step by step. We can start by using the `slice`
    method to extract each row’s risk category. If we pass the `slice` method a single
    value, pandas will use it as the lower bound and extract until the end of the
    string.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们一步一步地解决这个问题。我们可以从使用`slice`方法提取每行的风险类别开始。如果我们向`slice`方法传递一个单一值，pandas将使用它作为下限，并提取到字符串的末尾。
- en: 'The next example pulls the characters from index position 8 to the end of each
    string. The character at index position 8 is the first letter in each risk type
    (the `"H"` in `"High"`, the `"M"` in `"Medium",` the `"L"` in `"Low"`, and the
    `"E"` in `"Extreme"`):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例从每个字符串的索引位置 8 开始提取字符，直到字符串的末尾。索引位置 8 的字符是每种风险类型的第一个字母（例如，“High”中的“H”，“Medium”中的“M”，“Low”中的“L”，以及“Extreme”中的“E”）：
- en: '[PRE25]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can use Python’s list-slicing syntax, too. Inside the square brackets, provide
    a starting index position followed by a single colon. The result is identical:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 Python 的列表切片语法。在方括号内，提供一个起始索引位置，后跟一个单冒号。结果是相同的：
- en: '[PRE26]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We still have to deal with the pesky closing parentheses. Here’s a cool solution:
    pass a negative argument to the `str.slice` method. A negative argument sets the
    index bound relative to the end of the string: -1 extracts up to the last character,
    -2 extracts up to the second-to-last character, and so on. Let’s extract a substring
    from index position 8 up until the last character in each string:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要处理那些讨厌的闭合括号。这里有一个酷解决方案：将负数参数传递给 `str.slice` 方法。负数参数设置索引界限相对于字符串的末尾：-1
    提取到最后一个字符，-2 提取到倒数第二个字符，依此类推。让我们从索引位置 8 提取到每个字符串的最后一个字符：
- en: '[PRE27]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We’ve got it! If you prefer list-slicing syntax, you can pass the -1 after
    the colon inside the square brackets:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做到了！如果你更喜欢列表切片语法，你可以在方括号内冒号后面传递 -1：
- en: '[PRE28]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Another strategy we can use to remove the closing parentheses is the `str.replace`
    method. We can replace each closing parentheses with an empty string—a string
    without characters.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种移除闭合括号的策略是使用 `str.replace` 方法。我们可以将每个闭合括号替换为一个空字符串——一个没有字符的字符串。
- en: 'Each `str` method returns a new `Series` object with its own `str` attribute.
    This aspect allows us to chain multiple string methods in sequence, as long as
    we reference the `str` attribute in each method invocation. The next example chains
    the `slice` and `replace` methods:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `str` 方法都会返回一个新的 `Series` 对象，并具有自己的 `str` 属性。这一特性允许我们在调用每个方法时引用 `str` 属性，从而按顺序链式调用多个字符串方法。以下示例展示了如何链式调用
    `slice` 和 `replace` 方法：
- en: '[PRE29]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: By slicing from a middle index position and removing the ending parenthesis,
    we were able to isolate the Risk level for each row.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从中间索引位置切片并移除结束括号，我们能够隔离每行的风险级别。
- en: 6.4 Boolean methods
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 布尔方法
- en: Section 6.3 introduced methods such as `upper` and `slice` that return a `Series`
    of strings. Other methods available on the `StringMethods` object return a `Series`
    of Booleans. These methods can prove to be particularly helpful for filtering
    a `DataFrame`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6.3 节介绍了 `upper` 和 `slice` 等返回字符串 `Series` 的方法。`StringMethods` 对象上可用的其他方法返回布尔值
    `Series`。这些方法在过滤 `DataFrame` 时可能特别有用。
- en: 'Suppose that we want to isolate all establishments with the word `"Pizza"`
    in their names. In vanilla Python, we use the `in` operator to search for a substring
    with a string:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要隔离所有名称中包含单词 `"Pizza"` 的机构。在纯 Python 中，我们使用 `in` 操作符来搜索字符串中的子字符串：
- en: '[PRE30]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The biggest challenge in string matching is case sensitivity. Python will not
    find the string `"pizza"` in `"Jets Pizza"`, for example, because of the mismatch
    in casing of the `"p"` character:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串匹配的最大挑战是大小写敏感性。例如，Python 不会在 `"Jets Pizza"` 中找到字符串 `"pizza"`，因为 `"p"` 字符的大小写不匹配：
- en: '[PRE31]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To solve this problem, we need to ensure consistent casing across all column
    values before we check for the presence of a substring. We can look for a lowercase
    `"pizza"` in an all-lowercase `Series` or an uppercase `"PIZZA"` in an all-uppercase
    `Series`. Let’s go with the former approach.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要在检查子字符串的存在之前确保所有列值的大小写一致。我们可以在全小写的 `Series` 中查找 `"pizza"`，或者在全部大写的
    `Series` 中查找 `"PIZZA"`。让我们选择前者。
- en: 'The `contains` method checks for a substring’s inclusion in each `Series` value.
    The method returns `True` when pandas finds the method’s argument within the row’s
    string and `False` when it does not. The next example first lowercases the Name
    column with the `lower` method and then searches for `"pizza"` within each row:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`contains` 方法检查每个 `Series` 值中是否包含子字符串。当 pandas 在行的字符串中找到方法参数时，该方法返回 `True`；如果没有找到，则返回
    `False`。以下示例首先使用 `lower` 方法将名称列转换为小写，然后在每行中搜索 `"pizza"`：'
- en: '[PRE32]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We have a Boolean `Series`, which we can use to extract all establishments
    with `"Pizza"` in their name:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个布尔 `Series`，我们可以用它来提取所有名称中包含 `"Pizza"` 的机构：
- en: '[PRE33]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that pandas preserves the original letter casing of the values in Name.
    The `inspections` `DataFrame` is never mutated. The `lower` method returns a new
    `Series`, and the `contains` method we invoke on it returns another new `Series`,
    which pandas uses to filter rows from the original `DataFrame`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 pandas 保留了姓名中的原始字母大小写。`inspections` `DataFrame` 从未改变。`lower` 方法返回一个新的 `Series`，而我们对其调用的
    `contains` 方法返回另一个新的 `Series`，pandas 使用它来从原始 `DataFrame` 中过滤行。
- en: 'What if we want to be more precise in our targeting, perhaps extracting all
    establishments beginning with the string `"tacos"`? Now we care about the position
    of the substring within each string. The `str.startswith` method solves the problem,
    returning `True` if a string begins with its argument:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在目标上更加精确，也许提取所有以字符串 `"tacos"` 开头的机构？现在我们关注子字符串在每个字符串中的位置。`str.startswith`
    方法解决了这个问题，如果字符串以它的参数开头则返回 `True`：
- en: '[PRE34]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The complementary `str.endswith` method checks for a substring at the end of
    each `Series` string:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 补充的 `str.endswith` 方法检查每个 `Series` 字符串的末尾是否有子字符串：
- en: '[PRE35]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Whether you’re looking for text at the beginning, middle, or end of a string,
    the `StringMethods` object has a helper method to assist you.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是在寻找字符串的开头、中间还是结尾的文本，`StringMethods` 对象都有一个辅助方法来帮助您。
- en: 6.5 Splitting strings
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 分割字符串
- en: 'Our next data set is a collection of fictional customers. Each row includes
    the customer’s Name and Address. Let’s import the customers.csv file with the
    `read_csv` function and assign the `DataFrame` to a `customers` variable:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个数据集是一组虚构的客户。每一行包括客户的姓名和地址。让我们使用 `read_csv` 函数导入 customers.csv 文件，并将 `DataFrame`
    赋值给 `customers` 变量：
- en: '[PRE36]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can use the `str.len` method to return the length of each row’s string.
    Row 0’s value of `"Frank Manning"`, for example, has a length of 13 characters:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `str.len` 方法来返回每行字符串的长度。例如，行 0 的 `"Frank Manning"` 值的长度为 13 个字符：
- en: '[PRE37]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Suppose that we want to isolate each customer’s first and last names in two
    separate columns. You may be familiar with Python’s `split` method, which separates
    a string by using a specified delimiter. The method returns a list consisting
    of all the substrings after the split. The next example splits a phone number
    into a list of three strings by using a hyphen delimiter:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将每个客户的第一个和最后一个名字分别放在两个单独的列中。您可能熟悉 Python 的 `split` 方法，该方法使用指定的分隔符来分割字符串。该方法返回一个由所有分割后的子字符串组成的列表。下一个示例使用连字符分隔符将电话号码分割成三个字符串列表：
- en: '[PRE38]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `str.split` method performs the same operation on each row in a `Series`;
    its return value is a `Series` of lists. We pass the delimiter to the method’s
    first parameter, `pat` (short for *pattern*). The next example splits the values
    in Name by the presence of a space:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.split` 方法对 `Series` 中的每一行执行相同的操作；它的返回值是一个列表的 `Series`。我们将分隔符传递给方法的第一个参数，`pat`（代表
    *pattern*）。下一个示例通过空格的存在来分割 `Name` 中的值：'
- en: '[PRE39]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, let’s reinvoke the `str.len` method on this new `Series` of lists to
    get the length of each list. Pandas reacts dynamically to whatever data type a
    `Series` is storing:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们重新调用这个新的列表 `Series` 上的 `str.len` 方法来获取每个列表的长度。Pandas 会根据 `Series` 存储的数据类型动态反应：
- en: '[PRE40]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We have a small issue. Due to suffixes such as `"MD"` and `"Jr"`, some names
    have more than two words. We can see an example at index position 3: Michael Vincent
    III, which pandas splits into a list of three elements. To ensure an equal number
    of elements per list, we can limit the number of splits. If we set a maximum threshold
    of one split, pandas will split a string at the first space and stop. Then we’ll
    have a `Series` consisting of two-element lists. Each list will hold the customer’s
    first name and anything that follows it.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个小问题。由于 `"MD"` 和 `"Jr"` 这样的后缀，一些名字有多于两个单词。我们可以在索引位置 3 看到一个例子：Michael Vincent
    III，pandas 会将其分割成三个元素的列表。为了确保每个列表有相同数量的元素，我们可以限制分割的数量。如果我们设置一个最大分割阈值为一次，pandas
    将会在第一个空格处分割字符串并停止。然后我们将有一个由两个元素的列表组成的 `Series`。每个列表将包含客户的第一个名字以及随后的任何内容。
- en: 'The next example passes an argument of `1` to the `split` method’s `n` parameter,
    which sets the maximum number of splits. Take a look at how pandas deals with
    `"Michael Vincent III"` at index 3:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例将 `1` 作为参数传递给 `split` 方法的 `n` 参数，这设置了最大分割次数。看看 pandas 如何处理索引 3 的 `"Michael
    Vincent III"`：
- en: '[PRE41]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now all our lists have equal lengths. We can use `str.get` to pull out a value
    from each row’s list based on its index position. We can target index 0, for example,
    to pull out the first element of each list, which is the customer’s first name:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的列表长度都相等了。我们可以使用 `str.get` 来根据每行的列表的索引位置提取一个值。例如，我们可以定位到索引 0，来提取每个列表的第一个元素，也就是客户的第一个名字：
- en: '[PRE42]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To pull the last name from each list, we could pass the `get` method an index
    position of 1:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要从每个列表中提取姓氏，我们可以将 `get` 方法传递一个索引位置为 1：
- en: '[PRE43]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `get` method also supports negative arguments. An argument of `-1` extracts
    the last element from each row’s list, regardless of how many elements the list
    holds. The following code produces the same result as the preceding code and is
    a bit more versatile in scenarios in which the lists have different lengths:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 方法也支持负参数。参数 `-1` 从每行的列表中提取最后一个元素，无论列表有多少元素。以下代码产生与前面代码相同的结果，并且在列表长度不同的情况下更灵活：'
- en: '[PRE44]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'So far, so good. We’ve used two separate `get` method calls to extract the
    first and last names in two separate `Series`. Wouldn’t it be nice to perform
    the same logic in a single method call? Luckily, the `str.split` method accepts
    an `expand` parameter, and when we pass it an argument of `True`, the method returns
    a new `DataFrame` instead of a `Series` of lists:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。我们已经使用两个单独的 `get` 方法调用来提取两个单独的 `Series` 中的第一个和最后一个名字。不是很好吗？在单个方法调用中执行相同的逻辑？幸运的是，`str.split`
    方法接受一个 `expand` 参数，当我们传递一个 `True` 参数时，该方法返回一个新的 `DataFrame` 而不是列表的 `Series`：
- en: '[PRE45]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We’ve got a new `DataFrame`! Because we did not provide custom names for the
    columns, pandas defaulted to a numeric index on the column axis.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个新的 `DataFrame`！因为我们没有为列提供自定义名称，pandas 默认在列轴上使用数字索引。
- en: 'Be careful in these scenarios. If we do not limit the number of splits with
    the `n` parameter, pandas will place `None` values in rows that do not have sufficient
    elements:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下要小心。如果我们不使用 `n` 参数限制拆分的次数，pandas 将在元素不足的行中放置 `None` 值：
- en: '[PRE46]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now that we’ve isolated the customers’ names, let’s attach the new two-column
    `DataFrame` to the existing customers `DataFrame`. On the right side of an equal
    sign, we’ll use the `split` code to create the `DataFrame`. On the left side of
    the equal sign, we’ll provide a list of column names inside a pair of square brackets.
    Pandas will append these columns to customers. The next example adds two new columns,
    First Name and Last Name, and populates them with the `DataFrame` returned by
    the `split` method:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经隔离了客户的姓名，让我们将新的两列 `DataFrame` 附接到现有的客户 `DataFrame` 上。在等号的右边，我们将使用 `split`
    代码来创建 `DataFrame`。在等号的左边，我们将提供一个列名列表，放在一对方括号内。Pandas 将将这些列附加到客户上。下一个示例添加了两个新列，即“First
    Name”和“Last Name”，并用 `split` 方法返回的 `DataFrame` 来填充它们：
- en: '[PRE47]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let’s take a look at the result:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看结果：
- en: '[PRE48]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Excellent! Now that we’ve extracted the customers’ names to separate columns,
    we can delete the original Name column. One way is to use the `drop` method on
    our customers `DataFrame`. We’ll pass the column’s name to the `labels` parameter
    and an argument of `"columns"` to the `axis` parameter. We need to include the
    `axis` parameter to tell pandas to look for the Name label in the columns instead
    of the rows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们已经将客户的姓名提取到单独的列中，我们可以删除原始的姓名列。一种方法是使用我们客户的 `DataFrame` 上的 `drop` 方法。我们将传递列的名称到
    `labels` 参数，并将 `"columns"` 作为 `axis` 参数的参数。我们需要包含 `axis` 参数来告诉 pandas 在列中而不是行中查找姓名标签：
- en: '[PRE49]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Remember that mutational operations do not produce output in Jupyter Notebook.
    We must print the `DataFrame` to see the result:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，突变操作在 Jupyter Notebook 中不会产生输出。我们必须打印 `DataFrame` 来查看结果：
- en: '[PRE50]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There we go. The Name column is gone, and we have split its contents across
    two new columns.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，姓名列已经消失了，我们已经将其内容拆分到了两个新的列中。
- en: 6.6 Coding challenge
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 编程挑战
- en: Here’s your chance to practice the concepts introduced in this chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是你练习本章引入的概念的机会。
- en: 6.6.1 Problems
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.1 问题
- en: Our customers data set includes an Address column. Each address consists of
    a street, a city, a state, and a zip code. Your challenge is to separate these
    four values; assign them to new Street, City, State, and Zip columns; and then
    remove the Address column. Give the problem a shot, and then review the solution.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的客户数据集包括一个地址列。每个地址由街道、城市、州和邮政编码组成。你的挑战是将这四个值分开；将它们分配给新的街道、城市、州和邮政编码列；然后删除地址列。尝试解决这个问题，然后查看解决方案。
- en: 6.6.2 Solutions
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6.2 解决方案
- en: 'Our first step is splitting the address strings with a delimiter, using the
    `split` method. A comma by itself seems to be a good argument:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是使用 `split` 方法通过分隔符拆分地址字符串。单独的逗号似乎是一个好的参数：
- en: '[PRE51]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Unfortunately, this split keeps the spaces after the commas. We could perform
    additional cleanup by using a method such as `strip`, but a better solution is
    available. If we think about it, each portion of the address is separated by a
    comma and a space. Therefore, we can pass the `split` method a delimiter of both
    characters:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个分割操作保留了逗号后面的空格。我们可以通过使用 `strip` 等方法进行额外的清理，但有一个更好的解决方案。如果我们仔细思考，地址的每一部分都是由逗号和空格分隔的。因此，我们可以将这两个字符作为分隔符传递给
    `split` 方法：
- en: '[PRE52]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now there is no extra whitespace at the start of each substring within the lists.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在列表中的每个子字符串开头都没有多余的空格了。
- en: 'By default, the `split` method returns a `Series` of lists. We can make the
    method return a `DataFrame` by passing the `expand` parameter an argument of `True`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`split` 方法返回一个列表的 `Series`。我们可以通过传递 `expand` 参数一个值为 `True` 的参数来使方法返回一个
    `DataFrame`：
- en: '[PRE53]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We have a couple more steps left. Let’s add the new four-column `DataFrame`
    to our existing customers `DataFrame`. We’ll define a list with the new column
    names. This time around, let’s assign the list to a variable to simplify readability.
    Next, we’ll pass the list in square brackets before an equal sign. On the right
    side of the equal sign, we’ll use the preceding code to create the new `DataFrame`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些步骤要做。让我们将新的四列 `DataFrame` 添加到现有的客户 `DataFrame` 中。我们将定义一个包含新列名称的列表。这次，让我们将列表赋给一个变量以简化可读性。接下来，我们将在等号前传递列表，并在等号右侧使用前面的代码创建新的
    `DataFrame`：
- en: '[PRE54]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The last step is deleting the original Address column. The `drop` method is
    a good solution here. To alter the `DataFrame` permanently, make sure to overwrite
    customers with the returned `DataFrame`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是删除原始的 Address 列。`drop` 方法在这里是一个很好的解决方案。为了永久更改 `DataFrame`，请确保用返回的 `DataFrame`
    覆盖 customers：
- en: '[PRE55]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Another option is to use Python’s built-in `del` keyword before the target
    column. This syntax mutates the `DataFrame`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是在目标列之前使用 Python 的内置 `del` 关键字。这个语法会修改 `DataFrame`：
- en: '[PRE56]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let’s take a look at the final product:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看最终产品：
- en: '[PRE57]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We’ve successfully extracted the contents of the Address column to four new
    columns. Congratulations on completing the coding challenge!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地将地址列的内容提取到了四个新的列中。恭喜你完成了编码挑战！
- en: 6.7 A note on regular expressions
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 关于正则表达式的说明
- en: Any discussion of working with text data is incomplete without mentioning regular
    expressions, also known as RegEx. A *regular expression* is a search pattern that
    looks for a sequence of characters within a string.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 任何关于处理文本数据的讨论如果没有提到正则表达式（也称为 RegEx）都是不完整的。正则表达式是一种搜索模式，用于在字符串中查找字符序列。
- en: We declare regular expressions with a special syntax consisting of symbols and
    characters. `\d`, for example, matches any numeric digit between 0 and 9\. With
    regular expressions, we can define complex search patterns by targeting lowercase
    characters, uppercase characters, digits, slashes, whitespace, string boundaries,
    and more.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用特殊的语法来声明正则表达式，该语法由符号和字符组成。例如，`\d` 匹配介于 0 和 9 之间的任何数字。通过正则表达式，我们可以通过针对小写字母、大写字母、数字、斜杠、空白、字符串边界等来定义复杂的搜索模式。
- en: Suppose that a phone number like 555-555-5555 is hidden in a larger string.
    We can use regular expressions to define a search algorithm that extracts sequences
    of three sequential digits, a dash, three sequential digits, another dash, and
    four more sequential digits. That level of granularity grants regular expressions
    their power.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个像 555-555-5555 这样的电话号码隐藏在一个更长的字符串中。我们可以使用正则表达式来定义一个搜索算法，提取由三个连续数字、一个破折号、三个连续数字、另一个破折号和四个更多连续数字组成的序列。这种粒度级别赋予了正则表达式其强大的功能。
- en: 'Here’s a quick example that shows the syntax in action. The next code sample
    uses the `replace` method on the Street column to swap all occurrences of four
    sequential digits with an asterisk character:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个快速示例，展示了语法在实际中的应用。接下来的代码示例使用 Street 列上的 `replace` 方法，将所有连续四个数字替换为星号字符：
- en: '[PRE58]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Regular expressions are a highly specialized technical topic. Whole books are
    written on the complexities of RegEx. For now, it’s important to note that pandas
    supports RegEx arguments for most of its string methods. You can check out appendix
    E for a more comprehensive introduction to the domain.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一个高度专业化的技术主题。关于正则表达式的复杂性，已经有许多书籍被撰写。目前，重要的是要注意，pandas 支持大多数字符串方法的正则表达式参数。你可以查看附录
    E 以获得该领域的更全面介绍。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The `str` attribute holds a `StringMethods` object with methods for performing
    string manipulations on `Series` values.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str` 属性包含一个 `StringMethods` 对象，该对象具有对 `Series` 值执行字符串操作的方法。'
- en: The `strip` family of methods removes whitespace from the start of a string,
    the end of a string, or both sides.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strip` 方法族用于从字符串的开始、结束或两侧移除空白字符。'
- en: Methods such as `upper`, `lower`, `capitalize`, and `title` modify the letter
    casing of string characters.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upper`、`lower`、`capitalize` 和 `title` 等方法用于修改字符串字符的大小写。'
- en: The `contains` method checks for the presence of a substring within another
    string.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains` 方法用于检查另一个字符串中是否存在子字符串。'
- en: The `startswith` method checks for a substring at the beginning of a string.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startswith` 方法用于检查字符串开头是否存在子字符串。'
- en: The complementary `endswith` method checks for a substring at the end of a string.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补充的 `endswith` 方法用于检查字符串末尾是否存在子字符串。
- en: The `split` method splits a string into a list by using a specified delimiter.
    We can use it to split a `DataFrame` column’s text across several `Series`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`split` 方法通过使用指定的分隔符将字符串分割成列表。我们可以用它来分割 `DataFrame` 列中的文本，跨越多个 `Series`。'
