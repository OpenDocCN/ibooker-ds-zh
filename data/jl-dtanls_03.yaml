- en: 2 Getting started with Julia
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 Julia入门
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Understanding values and variables
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解值和变量
- en: Defining loops, conditional expressions, and functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义循环、条件表达式和函数
- en: Variable scoping rules in Julia
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia中的变量作用域规则
- en: If you are new to the Julia language, in this chapter, you will learn its basic
    syntax and most important concepts. We’ll focus on the aspects that are different
    from those in Python and R. Even if you already know Julia, I recommend that you
    quickly go through this chapter to make sure you have a complete understanding
    of the basic concepts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触Julia语言，在本章中，你将学习其基本语法和最重要的概念。我们将关注与Python和R不同的方面。即使你已经知道Julia，我也建议你快速浏览本章，以确保你对基本概念有完整的理解。
- en: If you are not sure how to install, set up, and use your working environment,
    how to get help, or how to install and manage packages, refer to appendix A.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定如何安装、设置和使用你的工作环境，如何获取帮助，或者如何安装和管理包，请参阅附录A。
- en: Note that the chapters in part 1 are not meant to be a full course on Julia.
    They contain only essential information required for you to start doing data science
    in Julia. I recommend you refer to the books listed on the Julia project “Books”
    page ([https://julialang.org/learning/books/](https://julialang.org/learning/books/))
    or to the Julia Manual ([https://docs.julialang.org/en/v1/](https://docs.julialang.org/en/v1/))
    for a complete introduction to Julia programming.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一部分中的章节并不是为了成为Julia的完整课程。它们只包含你开始使用Julia进行数据科学所需的必要信息。我建议你参考Julia项目“Books”页面上的书籍（[https://julialang.org/learning/books/](https://julialang.org/learning/books/)）或Julia手册（[https://docs.julialang.org/en/v1/](https://docs.julialang.org/en/v1/)）以获得对Julia编程的全面介绍。
- en: In this chapter, our goal is to write a function that calculates a winsorized
    mean of a vector. Informally speaking, a *winsorized mean* replaces the smallest
    and largest values with the less extreme observations closest to them. This is
    done to limit the effect of outliers on the result ([http://mng.bz/m2yM](https://shortener.manning.com/m2yM)).
    Let me start with explaining how you can compute this mean.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的目标是编写一个函数来计算向量的winsorized均值。非正式地说，winsorized均值是将最小值和最大值替换为最接近它们的较不极端的观测值。这样做是为了限制异常值对结果的影响（[http://mng.bz/m2yM](https://shortener.manning.com/m2yM)）。让我先解释一下你如何计算这个均值。
- en: Assume you have a sequence of numbers stored as a vector and want to compute
    its mean. However, you are aware that your data might include extreme values (outliers)
    that could significantly affect the result. In this situation, you can use the
    winsorized mean, which is a modification of a standard mean. The idea is to replace
    the most extreme observed values with less extreme ones. Let’s start with a definition
    that we will want to implement.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个存储为向量的数字序列，并想计算其均值。然而，你知道你的数据可能包含极端值（异常值），这些值可能会显著影响结果。在这种情况下，你可以使用winsorized均值，这是标准均值的修改版。想法是将最极端的观测值替换为较不极端的值。让我们从一个我们将要实现的定义开始。
- en: The *k-times winsorized mean* of a vector x is the mean of the elements of this
    vector, where each of its k smallest elements is replaced by the (k + 1)st smallest
    element, and similarly, each of the k largest elements is replaced by the (k +
    1)st largest element ([http://mng.bz/5mWD](https://shortener.manning.com/5mWD)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 向量x的*k次winsorized均值*是替换了其k个最小元素为(k + 1)次最小元素，以及类似地，每个最大的k个元素被(k + 1)次最大的元素替换后的均值（[http://mng.bz/5mWD](https://shortener.manning.com/5mWD)）。
- en: If we assume that the vector x is sorted in ascending order and has length n,
    as is done, for example, at the Xycoon Statistics-Econometrics-Forecasting site
    ([www.xycoon.com/winsorized_mean.htm](http://www.xycoon.com/winsorized_mean.htm)),
    then when calculating the k-times winsorized mean, we replace the elements x[1],
    x[2], . . . , x[k] with element x[k + 1] and elements x[n], x[n - 1], . . . ,
    x[n - k + 1] with element x[n - k].
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设向量x按升序排序且长度为n，就像在Xycoon Statistics-Econometrics-Forecasting网站上所做的那样（[www.xycoon.com/winsorized_mean.htm](http://www.xycoon.com/winsorized_mean.htm)），那么在计算k次winsorized均值时，我们将x[1]、x[2]、...、x[k]这些元素替换为x[k
    + 1]元素，并将x[n]、x[n - 1]、...、x[n - k + 1]这些元素替换为x[n - k]元素。
- en: Here is an example. Assuming we want to calculate the two-times winsorized mean
    of the vector [1, 2, 3, 4, 5, 6, 7, 8], we replace 1 and 2 with 3; similarly,
    7 and 8 are replaced by 6. This operation gives us a vector [3, 3, 3, 4, 5, 6,
    6, 6], whose mean is equal to 4.5. Now you know what we need to implement. The
    question is how to do it in Julia.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子。假设我们想要计算向量 [1, 2, 3, 4, 5, 6, 7, 8] 的两次winsorized均值，我们将 1 和 2 替换为 3；同样，7
    和 8 被替换为 6。这个操作给我们一个向量 [3, 3, 3, 4, 5, 6, 6, 6]，其平均值等于 4.5。现在你知道我们需要实现什么了。问题是如何在
    Julia 中实现它。
- en: To develop a function calculating the winsorized mean, we need to introduce
    various important parts of the Julia language, starting from values and variables,
    and continuing with control flow and functions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发一个计算winsorized均值的函数，我们需要介绍 Julia 语言的各种重要部分，从值和变量开始，然后继续到控制流和函数。
- en: 2.1 Representing values
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 表示值
- en: To create a function calculating the winsorized mean, we first need to learn
    how Julia represents numbers and vectors. More generally, it is important to understand
    how Julia handles values.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个计算winsorized均值的函数，我们首先需要了解 Julia 如何表示数字和向量。更普遍地说，了解 Julia 如何处理值是非常重要的。
- en: A *value* is a representation of an entity that is stored in a computer’s memory
    and can be manipulated by a Julia program. In this book, I also use the term *object*
    to refer to values, especially when referring to values that have a complex internal
    structure (for example, data frames, which are discussed in part 2). However,
    Julia is not an object-oriented programming language, and objects do not have
    methods attached to them. Instead, Julia supports multiple dispatch, as we will
    briefly discuss later in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *值* 是计算机内存中存储的实体的表示，可以被 Julia 程序操作。在这本书中，我也使用术语 *对象* 来指代值，尤其是在指代具有复杂内部结构的值时（例如，在第
    2 部分中讨论的数据帧）。然而，Julia 不是一个面向对象的编程语言，对象没有附加到它们的方法。相反，Julia 支持多态，我们将在本章后面简要讨论。
- en: Before discussing how to manipulate values, let’s see how to create them in
    the next listing. Every value is a result of evaluating a Julia expression. Here
    are a few basic example values created by the evaluation of *literals* (which
    represent values in the source code).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何操作值之前，让我们看看如何在下一列表中创建它们。每个值都是通过评估 Julia 表达式得到的结果。以下是一些通过评估 *字面量*（在源代码中表示值）创建的基本示例值。
- en: Listing 2.1 Creating values by evaluating literals
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 通过评估字面量创建值
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These values are, consecutively, an integer 1, Boolean true, string "Hello world!",
    floating-point number 0.1, and a three-element vector [1, 2, 3].
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值依次是一个整数 1、布尔值 true、字符串 "Hello world!"、浮点数 0.1 和一个包含三个元素的向量 [1, 2, 3]。
- en: In Julia, an extremely important property of each value is its type, which you
    can check by using the typeof function. In Julia, when you define a function,
    you can optionally declare the types of arguments that the function accepts. For
    example, in our k-times winsorized mean function of a vector x, we will want to
    make sure that k is an integer and x is a vector. Let’s try using the typeof function
    on the values from listing 2.1 in the next listing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，每个值的一个重要属性是其类型，您可以通过使用 typeof 函数来检查。在 Julia 中，当您定义一个函数时，您可以可选地声明函数接受的参数类型。例如，在我们的
    k 次winsorized均值函数中，我们希望确保 k 是一个整数，x 是一个向量。让我们尝试在下一列表中使用 typeof 函数检查 2.1 列表中的值。
- en: Listing 2.2 Checking types of values
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 检查值的类型
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You might notice two things here. First, for integer and floating-point values,
    you have a number 64 that is a part of the type name—namely, Int64 and Float64.
    This value is important. It signals to the user that both these values take up
    64 bits of memory. In general, you have flexibility here if needed. You could,
    for example, use Int8 values that use only 8 bits of memory at the cost of being
    able to represent a narrower range of values: from -128 to 127\. You can create
    an Int8 value by writing Int8(1).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在这里注意到两件事。首先，对于整数和浮点值，你会在类型名称中看到一个数字 64，即 Int64 和 Float64。这个值很重要。它向用户表明这两个值都占用
    64 位内存。一般来说，如果需要，您在这里有灵活性。例如，您可以使用只占用 8 位内存的 Int8 值，但这会牺牲能够表示的值的范围：从 -128 到 127。您可以通过编写
    Int8(1) 来创建一个 Int8 值。
- en: 'In Julia, you can check, if needed, the exact memory layout of numbers by using
    the bitstring function, producing a string holding a sequence of bits that make
    the passed value. I show this in the following code to convince you that, indeed,
    1 and 1.0 take 64 bits on my machine, and Int8(1) takes 8 bits. Note that although
    these three values represent the number 1, they all have different storage in
    computer memory because they have different types (if you would like to learn
    more about how floating-point numbers, like 1.0, are stored in computer memory,
    check out [http://mng.bz/aPDo](http://mng.bz/aPDo)):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，你可以通过使用bitstring函数来检查（如果需要的话），数字的确切内存布局，该函数生成一个包含通过值生成的位序列的字符串。我在下面的代码中展示了这一点，以让你相信，确实在我的机器上，1和1.0占用64位，而Int8(1)占用8位。注意，尽管这三个值代表数字1，但它们在计算机内存中的存储都不同，因为它们的类型不同（如果你想了解更多关于像1.0这样的浮点数在计算机内存中是如何存储的，请查看[http://mng.bz/aPDo](http://mng.bz/aPDo))：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this book, we will typically use the default 64-bit numbers. It is useful
    to know that on 64-bit machines (the kind of computer you are most likely using),
    you can refer to the Int64 type more briefly by just typing Int:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们通常会使用默认的64位数字。了解在64位机器（你最可能使用的计算机类型）上，你可以通过只输入Int来更简洁地引用Int64类型是有用的：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The second thing to notice is the type of the [1, 2, 3] vector, which is Vector{Int64}
    (alias for Array{Int64, 1}). It seems quite verbose. Let’s dissect this.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个需要注意的事情是[1, 2, 3]向量的类型，它是Vector{Int64}（Array{Int64, 1}的别名）。这似乎相当冗长。让我们来分析一下。
- en: 'Start with Array{Int64, 1}. We see that our vector is of the Array type. In
    the curly brackets, we get the *parameters* of this type: {Int64, 1}. The subtypes
    of AbstractArray normally take two parameters, and Array takes exactly two parameters.
    The first parameter is the type of elements that the array can store (in our case,
    Int64). The second parameter is the dimension of the array, which is 1 in this
    example.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从Array{Int64, 1}开始。我们看到我们的向量是Array类型。在花括号中，我们得到这个类型的*参数*：{Int64, 1}。AbstractArray的子类型通常需要两个参数，而Array正好需要两个参数。第一个参数是数组可以存储的元素类型（在我们的例子中，是Int64）。第二个参数是数组的维度，在这个例子中是1。
- en: Because one-dimensional arrays are typically called *vectors* in mathematics,
    Julia allows you to just write Vector{Int64}, which means the same as Array{Int64,
    1}. Since the type name is Vector, which means it is a one-dimensional array,
    we can omit passing the dimension parameter. However, we still need to pass the
    element type that the vector is allowed to store so it gets one parameter, in
    this case, {Int64}. Figure 2.1 illustrates these concepts.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在数学中，一维数组通常被称为*向量*，Julia允许你只写Vector{Int64}，这意味着与Array{Int64, 1}相同。由于类型名是Vector，这意味着它是一维数组，我们可以省略传递维度参数。然而，我们仍然需要传递向量可以存储的元素类型，因此它有一个参数，在这种情况下，是{Int64}。图2.1说明了这些概念。
- en: '![CH02_F01_Kaminski2](../Images/CH02_F01_Kaminski2.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F01_Kaminski2](../Images/CH02_F01_Kaminski2.png)'
- en: Figure 2.1 Rules of reading the names of types having parameters. Both definitions
    are equivalent, as vectors are one-dimensional arrays; the second parameter of
    Array{Int64, 1} is an array dimension (in this case, 1), so this is a vector.
    Type parameters are wrapped in curly brackets.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 参数类型名称的阅读规则。这两个定义是等价的，因为向量是一维数组；Array{Int64, 1}的第二个参数是数组维度（在这种情况下，1），因此这是一个向量。类型参数被括在花括号中。
- en: 'In addition to getting the type of a value with the typeof function, you can
    conveniently test whether a value is of a particular type by using the isa operator.
    Let’s check this [1, 2, 3] vector:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用typeof函数获取值的类型外，你还可以通过使用isa运算符方便地测试一个值是否为特定类型。让我们检查这个[1, 2, 3]向量：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that in this example, in Vector{Int}, both Vector and Int are aliases,
    and Array{Int64, 1} is the same type.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，在Vector{Int}中，Vector和Int都是别名，而Array{Int64, 1}是相同的类型。
- en: When writing your own code, you will most likely not use the typeof function
    and the isa operator often since Julia automatically uses type information when
    running your code. However, it is important to learn how to manually inspect the
    type of a value to build your understanding of how Julia works. For example, knowing
    types of variables is important when debugging your code. In chapter 3, you will
    learn how the information about the type of a variable is used when defining functions
    in Julia.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写自己的代码时，你很可能不会经常使用 typeof 函数和 isa 操作符，因为 Julia 在运行代码时会自动使用类型信息。然而，了解如何手动检查值的类型对于理解
    Julia 的工作方式非常重要。例如，了解变量的类型在调试代码时很重要。在第 3 章，你将学习在 Julia 中定义函数时如何使用变量类型的有关信息。
- en: 2.2 Defining variables
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 定义变量
- en: Now that you know what a value is, you are ready to learn about variables. In
    our winsorized mean function, we need variables to refer to the values passed
    by the user to the function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了什么是值，你就可以学习关于变量的知识了。在我们的 winsorized mean 函数中，我们需要变量来引用用户传递给函数的值。
- en: 'A *variable* is a name that is bound to a value. The simplest way to bind a
    value to a variable name is to use the assignment operator = (equals sign):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量* 是绑定到值的名称。将值绑定到变量名的最简单方法就是使用赋值运算符 =（等号）：'
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we have bound the integer 1 to the variable name x and the
    vector [1, 2, 3] to the variable name y.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将整型 1 绑定到变量名 x，并将向量 [1, 2, 3] 绑定到变量名 y。
- en: Binding vs. copying values
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 值绑定与复制
- en: It is important to highlight that in Julia, the assignment operator (=) performs
    only binding of values to variables. The process of binding does not involve copying
    values. Python also follows this approach. However, in R, this is not the case.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，在 Julia 中，赋值运算符 (=) 仅执行将值绑定到变量的操作。绑定过程不涉及复制值。Python 也遵循这种方法。然而，在 R 中情况并非如此。
- en: This distinction is most important when working with collections of data, like
    vectors, if you mutate them (for example, adding or changing stored elements).
    In Julia, if a vector is bound to two different variables and you mutate it, the
    change will be visible in both variables. For example, in Julia, if you write
    x = [1, 2] and then y = x, then the x and y variables are bound to the same value.
    If you next write x[1] = 10, both the x and y variables have the value [10, 2].
    If you would like to bind to a variable y a copy of a value bound to variable
    x, write y = copy(x). In this case, changing the value bound to x will not affect
    y.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别在处理数据集合，例如向量时最为重要，尤其是当你对它们进行修改（例如，添加或更改存储的元素）时。在 Julia 中，如果一个向量绑定到两个不同的变量，并且你对其进行了修改，那么这个变化将在两个变量中都可见。例如，在
    Julia 中，如果你写下 x = [1, 2] 然后y = x，那么 x 和 y 变量绑定到相同的值。如果你接下来写 x[1] = 10，那么 x 和 y
    变量的值都将变为 [10, 2]。如果你想将变量 y 绑定到变量 x 绑定的值的副本，请写 y = copy(x)。在这种情况下，修改绑定到 x 的值将不会影响
    y。
- en: Understanding when value binding versus copying happens is especially important
    when working with columns of a data frame. In my experience as a maintainer of
    the DataFrames.jl package, this issue is one of the major sources of bugs in users’
    code. In part 2, you will learn how, when working with DataFrames.jl, to decide
    whether the operation you perform should copy data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 理解何时发生值绑定与复制特别重要，尤其是在处理数据框的列时。在我的经验中，作为 DataFrames.jl 包的维护者，这个问题是用户代码中主要错误来源之一。在第二部分，你将学习在处理
    DataFrames.jl 时，如何决定你执行的操作是否应该复制数据。
- en: 'It is important to highlight here that Julia is a dynamically typed language,
    so it does not need to know the types bound to variables during compile time.
    The practical consequence of this fact is that you can bind values of different
    types to the same variable name in your code. Here is an example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，Julia 是一种动态类型语言，因此在编译时它不需要知道绑定到变量的类型。这一事实的实践后果是，你可以在代码中将不同类型的值绑定到相同的变量名。以下是一个例子：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we first bind an integer 1 of type Int64 to the variable x.
    Next, we assign 0.1 of type Float64 to the same variable name. This behavior is
    something that users of R or Python naturally expect, as they also belong to the
    class of dynamically typed programming languages.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先将一个整型 1（类型为 Int64）绑定到变量 x。接下来，我们将 0.1（类型为 Float64）赋值给同一个变量名。这种行为是
    R 或 Python 的用户自然期望的，因为它们也属于动态类型编程语言的类别。
- en: Avoid binding values of different types to the same variable name
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 避免将不同类型的值绑定到相同的变量名
- en: For convenience, Julia allows you to bind values of different types to the same
    variable name. However, that is not recommended for performance reasons.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，Julia允许你将不同类型的值绑定到相同的变量名。然而，出于性能考虑，这并不推荐。
- en: As we discussed in chapter 1, Julia is a compiled language. During compilation,
    Julia tries to automatically find all possible types of values that can be bound
    to a given variable name. If the Julia compiler can prove that this is a single
    type (or, in some cases, a closed list of a few types), then Julia is able to
    generate more-efficient code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第1章中讨论的，Julia是一种编译型语言。在编译过程中，Julia会尝试自动找到所有可能的值类型，这些值可以被绑定到给定的变量名。如果Julia编译器可以证明这是一个单一类型（或者在某些情况下，是一系列几个类型），那么Julia就能够生成更高效的代码。
- en: In the Julia Manual, code that avoids changing the type of values bound to a
    variable is called *type stable*. Writing type-stable code is one of the most
    important performance recommendations in Julia ([http://mng.bz/69N6](http://mng.bz/69N6)).
    We will get back to the topic of writing type-stable code in the context of working
    with DataFrames.jl in part 2.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia手册中，避免改变绑定到变量上的值类型的代码被称为*类型稳定的*。编写类型稳定的代码是Julia中最重要性能建议之一（[http://mng.bz/69N6](http://mng.bz/69N6)）。我们将在第2部分中回到编写类型稳定代码的话题，在处理DataFrames.jl的上下文中。
- en: 'Julia offers a lot of flexibility in naming your variables. You can use Unicode
    characters in variable names, and they are case-sensitive. Here are three examples:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Julia在变量命名方面提供了很多灵活性。你可以在变量名中使用Unicode字符，并且它们是大小写敏感的。以下有三个例子：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first example uses ń (a letter in the Polish alphabet) in the variable name.
    The second example has a subscript 1 in the name of the variable x[1]. The last
    example uses the Greek letter ε. This flexibility is most useful when you have
    source material (for example, documentation or a research paper) and want to use
    the same symbols in the code as are used in the text to make it easier to understand
    the code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子在变量名中使用了ń（波兰字母表中的一个字母）。第二个例子在变量x[1]的名称中有一个下标1。最后一个例子使用了希腊字母ε。这种灵活性在你有源材料（例如，文档或研究论文）并且想在代码中使用与文本中相同的符号以使代码更容易理解时最有用。
- en: 'You might ask how we can type characters such as [1] or ε. It is easy to check.
    In the Julia REPL, switch to help mode by pressing the question mark key (?) on
    your keyboard (appendix A explains how to use help in Julia), and then paste the
    character you want to investigate. Here is the truncated output you will get:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问我们如何输入像[1]或ε这样的字符。这很容易检查。在Julia的REPL中，通过按键盘上的问号键（？）切换到帮助模式（附录A解释了如何在Julia中使用帮助），然后粘贴你想要调查的字符。以下是你会得到的截断输出：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, typing in these characters is convenient, especially if you
    are a LaTeX user. This method of input is supported in all standard environments
    under which you can expect to write Julia code—for example, Julia REPL, Visual
    Studio Code, and Jupyter Notebook. In the Julia Manual, you can find a complete
    list of Unicode characters that can be entered via tab completion in the Julia
    REPL ([http://mng.bz/o5Gv](http://mng.bz/o5Gv)).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，输入这些字符很方便，尤其是如果你是LaTeX用户。这种输入方法在所有标准环境中都得到了支持，在这些环境中你可以编写Julia代码——例如，Julia
    REPL、Visual Studio Code和Jupyter Notebook。在Julia手册中，你可以找到可以通过tab补全输入的Unicode字符的完整列表（[http://mng.bz/o5Gv](http://mng.bz/o5Gv)）。
- en: 2.3 Using the most important control-flow constructs
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 使用最重要的控制流结构
- en: As explained in this chapter’s introduction, to write a function calculating
    a winsorized mean, we need to iterate over values stored in a vector and conditionally
    change them. In this section, you will learn how to perform these operations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言中所述，要编写一个计算winsorized平均值的函数，我们需要遍历存储在向量中的值并条件性地更改它们。在本节中，你将学习如何执行这些操作。
- en: 'The three kinds of control-flow constructs that we will often use in this book
    are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将经常使用的三种控制流结构如下：
- en: Conditional evaluation
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件评估
- en: Loops
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环
- en: Compound expressions
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合表达式
- en: For a complete list, see the “Control Flow” section of the Julia Manual ([http://mng.bz/ne24](http://mng.bz/ne24)).
    I will now explain how you can use each of them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取完整列表，请参阅Julia手册中的“控制流”部分（[http://mng.bz/ne24](http://mng.bz/ne24)）。我现在将解释你如何使用它们中的每一个。
- en: 2.3.1 Computations depending on a Boolean condition
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 依赖于布尔条件的计算
- en: Conditional evaluation is used when we want to take different actions depending
    on the value of a particular condition. In this section, I’ll show you how to
    use conditional expressions in Julia and the common patterns you should know when
    working with Boolean conditions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要根据特定条件的值采取不同的行动时，会使用条件评估。在本节中，我将向你展示如何在Julia中使用条件表达式，以及当你处理布尔条件时应了解的常见模式。
- en: The conditional expression
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 条件表达式
- en: In Julia, *conditional expressions* are written using the if-elseif-else-end
    syntax. Figure 2.2 illustrates an example of a conditional expression.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，*条件表达式*使用if-elseif-else-end语法编写。图2.2展示了条件表达式的示例。
- en: '![CH02_F02_Kaminski2](../Images/CH02_F02_Kaminski2.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F02_Kaminski2](../Images/CH02_F02_Kaminski2.png)'
- en: Figure 2.2 Explanation of how the code in listing 2.3 works
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 列表2.3中代码的工作原理说明
- en: The following listing shows how to implement the conditional expression presented
    in figure 2.2 in Julia. Note that we test two values for equality in Julia by
    using the == operator.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了如何在Julia中实现图2.2中展示的条件表达式。请注意，在Julia中，我们通过使用==运算符来测试两个值是否相等。
- en: Listing 2.3 Defining a conditional expression
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3 定义条件表达式
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because x is negative, x > 0 produces false, and x < 0 produces true, so negative
    is printed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因为x是负数，所以x > 0产生false，而x < 0产生true，所以打印出负数。
- en: 'In this syntax, the elseif and else parts can be omitted. It is important to
    stress that the expression passed after if must have a logical value. The type
    of the value of the expression must be Bool; otherwise, an error is thrown:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种语法中，可以省略elseif和else部分。重要的是要强调，传递给if的表达式必须有一个逻辑值。表达式的值类型必须是Bool；否则，会抛出错误：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Code indentation in Julia
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Julia中的代码缩进
- en: In listing 2.3, I indented the code four spaces. This is a standard practice
    in Julia and is also used in other cases that we discuss later in this chapter
    (loops, functions, etc.).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表2.3中，我缩进了四格代码。这是Julia中的标准做法，也用于我们将在本章后面讨论的其他情况（循环、函数等）。
- en: In Julia, as opposed to Python, using indentation is optional and serves the
    purpose of improving code readability. In general, Julia identifies the end of
    a code block when it encounters the end keyword or other keywords that are specific
    to a given statement (for example, in a conditional expression, these additional
    keywords are else and elseif).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python不同，在Julia中，使用缩进是可选的，它旨在提高代码的可读性。一般来说，Julia在遇到end关键字或其他特定于给定语句的关键字（例如，在条件表达式中，这些额外的关键字是else和elseif）时，会识别代码块的结束。
- en: Rules for comparing floating-point numbers
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 比较浮点数的规则
- en: In listing 2.3, when we checked whether x was positive, negative, or zero, you
    might have been surprised that I included the else part printing unexpected condition.
    It would seem natural to expect that if x is a number, it must meet one of these
    conditions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表2.3中，当我们检查x是正数、负数还是零时，你可能惊讶地发现我包括了else部分打印出意外条件。如果x是一个数字，它似乎应该满足这些条件之一。
- en: 'Unfortunately, things are more complex than that. The Institute of Electrical
    and Electronics Engineers (IEEE) 754 standard for floating-point arithmetic defines
    a special NaN (*not a number*) value that, when compared to other values using
    <, <=, >, >=, and ==, always produces false, as you can see here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，事情比这更复杂。电气和电子工程师协会（IEEE）754标准的浮点算术定义了一个特殊的NaN（*不是一个数字*）值，当使用<、<=、>、>=和==与其他值比较时，总是产生false，正如你所看到的：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'According to the IEEE 754 standard, comparing NaN to a value produces true
    only when the not-equal operator (!=) is used:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据IEEE 754标准，当使用不等于运算符(!=)时，将NaN与值比较才会产生true：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This shows us that we must be careful when using common knowledge from mathematics
    in the context of programming language—not all things work the same way in theory
    and when implemented on a computer. Also, in general, different programming languages
    might implement different rules for working with numbers. When working with floating-point
    numbers, Julia follows the IEEE 754 standard.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，在编程语言的环境中应用数学中的常识时必须小心——在理论和在计算机上实现时，并非所有事物都以相同的方式工作。此外，通常不同的编程语言可能会为处理数字实现不同的规则。当处理浮点数时，Julia遵循IEEE
    754标准。
- en: Consequences of inexact representation of numbers by floating-point values
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点值表示数字不精确的后果
- en: 'Another similar problem arises because floating-point numbers only approximately
    represent real numbers. Therefore, for instance, we have this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浮点数只是近似表示实数，因此出现了另一个类似的问题。例如，我们有：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is surprising. The reason for this is that none of the Float64 values created
    by the evaluation of literals 0.1, 0.2, and 0.3 exactly represent the written
    real numbers. What Julia does is store the Float64 values that are the closest
    representation of the requested numbers. Therefore, we have a small, but often
    nonzero, error. By writing this
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这很令人惊讶。原因是，由字面量 0.1、0.2 和 0.3 的评估创建的 Float64 值没有一个能精确地表示所写的实数。Julia 所做的是存储最接近请求数字的
    Float64 值。因此，我们有一个小但通常是非零的错误。通过写下这个
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'we can see that the sum of 0.1 and 0.2 is a bit more than 0.3. What should
    a data scientist do in such a case? In Julia, you can use the isapprox function
    to perform an approximate comparison:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 0.1 和 0.2 的和略大于 0.3。在这种情况下，数据科学家应该怎么办？在 Julia 中，您可以使用 isapprox 函数执行近似比较：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can control how isapprox treats the *approximately equals* statement by
    passing appropriate arguments; see the Julia Manual ([http://mng.bz/gR4x](http://mng.bz/gR4x))
    for details. You can also conveniently use the isapprox function with a default
    tolerance level, which defaults to around 1.5e-8 relative tolerance for Float64
    values via an infix operator:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过传递适当的参数来控制 isapprox 如何处理 *近似等于* 语句；有关详细信息，请参阅 Julia 手册 ([http://mng.bz/gR4x](http://mng.bz/gR4x))。您还可以方便地使用默认容差级别的
    isapprox 函数，该容差级别对于 Float64 值默认为大约 1.5e-8 的相对容差，通过中缀运算符：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Do not confuse the ≈ character with the = character.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不要将 ≈ 字符与 = 字符混淆。
- en: You can get the approx (≈) character in the Julia REPL by typing \approx and
    pressing Tab.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Julia REPL 中通过输入 \approx 并按 Tab 键来获取约等于（≈）字符。
- en: Combining several logical conditions
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 结合多个逻辑条件
- en: 'You should now be comfortable with writing a single condition. However, we
    often want to test several conditions at once. For example, we might want to check
    whether a number is both positive and less than 10\. In Julia, you can combine
    conditions by using the && (and) and || (or) operators. Here are two examples:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该熟悉编写单个条件。然而，我们经常想要同时测试多个条件。例如，我们可能想要检查一个数字是否既是正数又小于 10。在 Julia 中，您可以通过使用
    &&（和）和 ||（或）运算符来组合条件。以下有两个示例：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As a convenience, when comparisons against the same value are joined using the
    && operator, they can be written more concisely. Therefore, instead of writing
    x > 0 && x < 10, you could write 0 < x < 10, just as you would do when writing
    a condition in a mathematical text.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，当使用 && 运算符将针对相同值的比较连接起来时，可以更简洁地书写。因此，您不必写成 x > 0 && x < 10，而可以写成 0 < x
    < 10，就像在数学文本中书写条件一样。
- en: Short-circuit evaluation of conditions in Julia
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 中条件的短路评估
- en: 'Another important feature of && and || operators in Julia is that they perform
    *short-circuit* evaluation: they evaluate only as many conditions (starting from
    the leftmost) as are needed to determine the logical value of the whole expression.
    You have already seen this feature at work when we evaluated the expression x
    < 0 || log(x) > 10. The reason is that log(x) throws an error if x has a negative
    real value, as you can see here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 中 && 和 || 运算符的另一个重要特性是它们执行 *短路* 评估：它们只评估足够多的条件（从最左边开始），以确定整个表达式的逻辑值。您已经在评估表达式
    x < 0 || log(x) > 10 时看到了这个特性的工作。原因是，如果 x 有负实数值，log(x) 会抛出错误，正如您在这里看到的：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The reason we have not seen this error when evaluating x < 0 || log(x) > 10
    is that since x is equal to -7, the first condition x < 0 is true, so Julia never
    checks the second condition. Therefore, if you write
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在评估 x < 0 || log(x) > 10 时没有看到这个错误的原因是，由于 x 等于 -7，第一个条件 x < 0 是正确的，所以 Julia
    从不检查第二个条件。因此，如果您写下
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Julia interprets it in the same way as
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 以相同的方式解释它，即
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Similarly,
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: is the same as
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 等于
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As a consequence, the && and || operators can be used to conveniently write
    one-liners performing conditional evaluation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，&& 和 || 运算符可以方便地编写执行条件评估的单行代码：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This pattern is used in Julia to improve code readability when simple conditions
    are used.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在 Julia 中用于在简单条件被使用时提高代码的可读性。
- en: 'Let me highlight that in these scenarios, the second part of the expression
    does not have to produce a Bool value. The reason for this is that the short-circuiting
    behavior of && and || in our examples is equivalent to writing the following if
    expressions:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我强调，在这些情况下，表达式的第二部分不需要产生布尔值。这是因为我们例子中 && 和 || 的短路行为等同于编写以下 if 表达式：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Remember, however, that as I have explained, using an expression that does
    not produce a Bool value in a normal if condition is not allowed and throws an
    error:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，正如我解释的那样，在正常 if 条件中使用不产生布尔值的表达式是不允许的，并且会抛出错误：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Ternary operator
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 三元运算符
- en: Before we wrap up the discussion on checking conditions, let’s introduce the
    *ternary operator*, borrowed from the C programming language. Writing
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束对检查条件的讨论之前，让我们介绍从 C 编程语言借来的 *三元运算符*。编写
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: is equivalent to writing
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于编写
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, before the ? symbol, we pass the expression that is the condition.
    Then, after ?, we pass two expressions separated by :, of which only one is evaluated,
    depending on whether the passed condition is true or false.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '如你所见，在 ? 符号之前，我们传递的是条件表达式。然后，在 ? 之后，我们传递两个由 : 分隔的表达式，其中只有一个会被评估，这取决于传递的条件是
    true 还是 false。'
- en: 'The ternary operator is used in short one-line conditions. Here is one more
    example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 三元运算符用于简短的单行条件。这里有一个更多示例：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Conditional expressions return a value
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 条件表达式返回一个值
- en: The if-elseif-else-end expressions and the ternary operator return a value that
    is the return value of the last executed expression in the branch that was chosen.
    This is often useful if you want to bind this return value to a variable.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: if-elseif-else-end 表达式和三元运算符返回一个值，这是所选分支中最后一个执行的表达式的返回值。如果你想要将这个返回值绑定到一个变量上，这通常很有用。
- en: 'As an example, assume that we want to compute the square root of an absolute
    value of a given number x and store the result in variable y. You could write
    this operation as y = sqrt(abs(x)), but let me show you how to do it by using
    a conditional expression:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要计算给定数字 x 的绝对值的平方根，并将结果存储在变量 y 中。你可以将这个操作写成 y = sqrt(abs(x))，但让我通过使用条件表达式来展示如何做：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The same rule applies to the ternary operator:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的规则适用于三元运算符：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 2.3.2 Loops
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 循环
- en: 'In Julia, you can use two kinds of loops: for-end and while-end. The for loop
    is arguably the more common one in practice. It iterates over values of a collection.
    The next listing shows a working example.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Julia 中，你可以使用两种类型的循环：for-end 和 while-end。for 循环在实践上可能是更常见的一种。它遍历集合的值。下一个列表显示了一个工作示例。
- en: Listing 2.4 Defining a for loop
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.4 定义 for 循环
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here we have a vector [1, 2, 3] containing three values. The i variable in
    each iteration of the loop takes the consecutive values from this vector, and
    the body of the loop is executed. The isodd(i) ? "odd" : "even" expression is
    a ternary operator (introduced in section 2.3.1).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里我们有一个包含三个值的向量 [1, 2, 3]。循环中的每个迭代变量 i 都从这个向量中取连续的值，并执行循环体。isodd(i) ? "odd"
    : "even" 表达式是一个三元运算符（在第 2.3.1 节中介绍）。'
- en: On the other hand, the while loop produces values as long as a certain condition
    is met, as the following listing shows.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，while 循环只要满足某个条件就会产生值，如下面的列表所示。
- en: Listing 2.5 Defining a while loop
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.5 定义 while 循环
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here we have a variable i. If the condition following the while keyword is true,
    the body of the loop is executed. In this case, we test whether i is less than
    4. Note that in the body of the loop, we increment i by 1 so eventually the loop
    terminates.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们有一个变量 i。如果 while 关键字后面的条件为真，则执行循环体。在这种情况下，我们测试 i 是否小于 4。请注意，在循环体中，我们将 i
    增加 1，因此最终循环会终止。
- en: In this example, you can see the global keyword, which I will explain when we
    discuss variable scoping rules in section 2.5\. For now, it is enough to understand
    that this keyword signals Julia that it should use the i variable that we defined
    outside the while loop.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到全局关键字，我将在我们讨论变量作用域规则的第 2.5 节中解释它。现在，只需理解这个关键字通知 Julia 应该使用我们在 while
    循环外部定义的 i 变量就足够了。
- en: Another style that I have not explained yet is i += 1. This statement means
    the same as writing i = i + 1 but is a bit shorter to type. In this case, it increments
    the variable i by 1. You can use shorthand for other operators as well—for example,
    -=, *=, or /=.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有解释的另一种风格是 i += 1。这个语句的意思等同于写作 i = i + 1，但打字更短。在这种情况下，它将变量 i 增加 1。你也可以使用其他运算符的缩写，例如
    -=、*= 或 /=。
- en: 'In both for and while loops, you can use two special keywords:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for 和 while 循环中，你可以使用两个特殊的关键字：
- en: continue immediately stops an iteration and moves to the next one.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: continue 立即停止一个迭代并移动到下一个迭代。
- en: break immediately terminates the loop.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即中断循环。
- en: 'It is easiest to understand how these keywords work by example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过示例可以最容易地理解这些关键字是如何工作的：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Observe that we write while true to set up the loop. Since this condition is
    always true, unless we have another means to interrupt the loop, it would run
    infinitely many times. This is exactly what the break keyword achieves. To understand
    this, let’s review the body of the loop line by line.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们写 while true 来设置循环。由于这个条件始终为真，除非我们有其他中断循环的方法，否则它将无限次地运行。这正是 break 关键字所实现的。为了理解这一点，让我们逐行回顾循环体。
- en: In this loop, in each iteration, the variable i gets incremented by 1. Next,
    we check whether we have reached a value greater than 6, and if so, terminate
    the loop. If i is less than or equal to 6, we check whether it is odd. If this
    is the case, we skip the rest of the body of the loop; otherwise, (if i is even),
    we execute println(i, " is even").
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环中，在每次迭代中，变量 i 增加 1。接下来，我们检查是否达到了大于 6 的值，如果是，则终止循环。如果 i 小于或等于 6，我们检查它是否为奇数。如果是这种情况，我们跳过循环体的其余部分；否则，（如果
    i 是偶数），我们执行 println(i, " 是偶数")。
- en: 2.3.3 Compound expressions
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 复合表达式
- en: When processing data, it is often useful to perform several operations but bundle
    them together so that from the outside, they look like one expression returning
    the value of the last expression inside it. In Julia, you have two options for
    packing several expressions into one.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据时，执行多个操作但将它们捆绑在一起，以便从外部看它们像是一个返回其内部最后一个表达式值的单一表达式，这通常很有用。在 Julia 中，你有两种方法可以将多个表达式打包成一个。
- en: The first is using begin-end blocks. The second is more lightweight and allows
    chaining expressions by using the semicolon (;). Often, we need to wrap a chain
    of expressions separated by ; in parentheses to delimit the range of the compound
    expression. The next listing shows some examples.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是使用 begin-end 块。第二种方法更轻量级，允许通过使用分号 (;) 来链表达式。通常，我们需要将用分号分隔的表达式链用括号括起来，以界定复合表达式的范围。下面的列表显示了几个示例。
- en: Listing 2.6 Defining compound expressions using begin-end blocks or a semicolon
    (;)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 使用 begin-end 块或分号 (;) 定义复合表达式
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Prints -7
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打印 -7
- en: ❷ Prints -6
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打印 -6
- en: ❸ The value of the whole code block is -12, which Julia displays.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 整个代码块的价值是 -12，这是 Julia 显示的。
- en: ❹ First prints -5, and since the whole compound expression is also -5, Julia
    displays it
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 首先打印 -5，由于整个复合表达式也是 -5，Julia 显示了它
- en: In the first case, we use the short-circuiting && operator. However, it requires
    a single expression on both its left and right side. In this example, we use a
    begin-end block to conveniently create a single expression from a sequence of
    expressions spanning multiple lines. Observe that apart from printing two values,
    the whole expression returns -12, which is the value of 2 * x , the last expression
    in the chain. The expression on the right-hand side of && does not have to produce
    a Boolean value, as opposed to the expression on the left-hand side of &&.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们使用短路运算符 &&。然而，它需要在它的左右两边都有一个单一的表达式。在这个例子中，我们使用 begin-end 块来方便地将跨越多行的表达式序列创建成一个单一的表达式。注意，除了打印两个值之外，整个表达式返回
    -12，这是链中的最后一个表达式 2 * x 的值。与 && 左侧的表达式不同，右侧的表达式不需要产生布尔值。
- en: In the second example, we use a ternary operator. It similarly requires passing
    single expressions to all of its parts to work correctly. Since our code is relatively
    short, we use the semicolon to create a single expression from several expressions.
    We use parentheses to clearly delimit the range of the chain of expressions. Using
    the enclosing parentheses is not always strictly required by the Julia parser,
    but it is a good practice, so I recommend you always use them when chaining several
    expressions together.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们使用三元运算符。它同样需要将单个表达式传递给其所有部分才能正确工作。由于我们的代码相对较短，我们使用分号来将多个表达式组合成一个单一的表达式。我们使用括号来清楚地界定表达式链的范围。使用括号包围并不是
    Julia 解析器严格要求的，但这是一个好的实践，所以我建议你总是在将多个表达式链在一起时使用它们。
- en: In summary, compound expressions are useful when you are required to pass a
    single expression in part of the code, but you need to perform several operations.
    Typically, the begin-end block is used for longer expressions that span multiple
    lines, while chaining with the semicolon is preferred for shorter cases fitting
    onto a single line.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，复合表达式在你需要在一个代码部分传递单个表达式但需要执行多个操作时是有用的。通常，begin-end 块用于跨越多行的长表达式，而使用分号进行链式操作则更适合单行的情况。
- en: In practice, you should not overuse compound expressions as they might lead
    to less readable code. Often it is better, for example, to use the standard conditional
    expression or define a helper function to improve code clarity. However, you are
    likely to encounter compound expressions in the source code of various packages,
    so it is important that you know how to interpret them.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你不应该过度使用复合表达式，因为它们可能会导致代码可读性降低。通常，例如，使用标准的条件表达式或定义辅助函数来提高代码清晰度会更好。然而，你很可能会在各种包的源代码中遇到复合表达式，因此了解如何解释它们是很重要的。
- en: Let me again highlight the stylistic convention that we used in the preceding
    code. In Julia, code blocks use four spaces for indentation. However, this is
    only a convention. Proper code formatting is not enforced by Julia and does not
    affect how code is executed, but it is highly recommended to follow this convention
    as it greatly improves code readability.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我再强调一下我们在前面的代码中使用的风格约定。在 Julia 中，代码块使用四个空格进行缩进。然而，这只是一种约定。Julia 并不强制执行正确的代码格式，它也不会影响代码的执行方式，但强烈建议遵循此约定，因为它极大地提高了代码的可读性。
- en: Comments in code
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的注释
- en: A special part of the source code that we often need is comments. They are not
    a control-flow construct but affect how Julia interprets code, so I include this
    note here.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要源代码的一个特殊部分是注释。它们不是控制流结构，但会影响 Julia 如何解释代码，因此我在这里包含了这个说明。
- en: If you put a hash character (#) in your code, everything from the point where
    this character is placed until the end of the line is ignored by the Julia parser.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在代码中放入一个井号字符 (#)，Julia 解析器将忽略从该字符放置位置到行尾的所有内容。
- en: 2.3.4 A first approach to calculating the winsorized mean
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 计算winsorized均值的第一种方法
- en: 'We are now ready to calculate the k-times winsorized mean of a vector. For
    now, we''ll do that without using functions, but only in the Julia REPL. Let’s
    try to compute it for the vector [8, 3, 1, 5, 7] by using what you have already
    learned. In our calculation, we want to perform the following steps:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好计算向量的 k 次winsorized均值。目前，我们将在 Julia REPL 中不使用函数，仅通过这种方式进行。让我们尝试使用你已学到的知识来计算向量
    [8, 3, 1, 5, 7] 的均值。在我们的计算中，我们想要执行以下步骤：
- en: Initialize the input data. Vector x holds the data for which we want to compute
    the mean, and integer k indicates the number of smallest and largest values to
    replace.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化输入数据。向量 x 包含我们想要计算均值的数值，整数 k 表示要替换的最小和最大值的数量。
- en: Sort the vector x and store the result in a variable y. This way, k smallest
    values are at the beginning of the vector y, and k largest are at its end.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对向量 x 进行排序，并将结果存储在一个变量 y 中。这样，k 个最小的值就在向量 y 的开头，而 k 个最大的值就在其末尾。
- en: Replace k smallest values by the (k + 1)st smallest value in vector y by using
    a loop. Similarly, replace k largest values by the (k + 1)st largest value.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用循环将向量 y 中的 k 个最小值替换为第 (k + 1) 个最小的值。同样，将 k 个最大值替换为第 (k + 1) 个最大的值。
- en: Calculate the mean of vector y by first summing its elements and then dividing
    the result by the length of the vector. The obtained result is the k-times winsorized
    mean of the original vector x.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过首先求和向量 y 的元素，然后将结果除以向量的长度来计算向量 y 的均值。得到的结果是原始向量 x 的 k 次winsorized均值。
- en: 'First, bind variable x to the input vector, and let k be equal to 1:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将变量 x 绑定到输入向量，并让 k 等于 1：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the simplest approach (we will discuss more advanced methods in chapter
    3), as the next step, we sort this vector and bind the result to a variable:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的方法中（我们将在第 3 章讨论更高级的方法），作为下一步，我们将对这个向量进行排序，并将其结果绑定到一个变量上：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we replace k smallest values with the (k + 1)st smallest one. We do the
    same with largest values and inspect the y vector after the change:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 k 个最小的值替换为第 (k + 1) 个最小的值。对于最大的值也进行同样的操作，并在变化后检查 y 向量：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here we additionally see two new constructs. First, when we write 1:k, we create
    a range of values starting from 1 and then containing all integer values up to
    k inclusive (as opposed to Python, in which the last element of the range is not
    included).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还可以看到两个新的结构。首先，当我们写1:k时，我们创建一个从1开始并包含所有整数值直到k（包括k）的范围（与Python不同，Python中的范围最后一个元素不包括在内）。
- en: 'The second feature is vector indexing. We discuss this in more detail in chapter
    4, but for now, it is important to note the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个特性是向量索引。我们将在第4章中更详细地讨论这个问题，但在此，重要的是要注意以下几点：
- en: Vectors in Julia use 1-based indexing.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia中的向量使用基于1的索引。
- en: You get the i-th element of a vector x by using the syntax x[i].
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用语法x[i]来获取向量x的第i个元素。
- en: As a convenience, when doing indexing, if you write end inside square brackets,
    it gets replaced by the length of the vector; so, x[end] refers to the last element
    of the vector x.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为便利，在索引时，如果你在方括号内写end，它将被替换为向量的长度；因此，x[end]指的是向量x的最后一个元素。
- en: 'We now can calculate the mean of the vector y:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以计算向量y的平均值：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At this point, you are most likely eager to wrap our code in a function to make
    it reusable. This is the topic of the next section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你很可能渴望将我们的代码封装在函数中以便重用。这是下一节的主题。
- en: 2.4 Defining functions
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 定义函数
- en: You already know how to work with variables and use control-flow constructs,
    so the next step is to understand how functions are defined in Julia. This is
    a broad topic, and if you are interested in all the details about defining and
    calling functions, I recommend checking the Julia Manual ([http://mng.bz/vX4r](http://mng.bz/vX4r)).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何使用变量和使用控制流结构，所以下一步是理解如何在Julia中定义函数。这是一个广泛的话题，如果你对定义和调用函数的所有细节都感兴趣，我建议查看Julia手册([http://mng.bz/vX4r](http://mng.bz/vX4r))。
- en: This section covers the most common patterns used in practice so you can learn
    how to define your own function calculating a winsorized mean.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了实践中最常用的模式，这样你可以学习如何定义自己的函数来计算加权平均值。
- en: 2.4.1 Defining functions using the function keyword
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 使用function关键字定义函数
- en: Let’s start with a basic definition of a function taking a single positional
    argument in the next listing.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从下一个列表中一个基本定义的单个位置参数函数开始。
- en: Listing 2.7 Defining functions by using the function keyword
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.7 使用function关键字定义函数
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This function takes a single argument x and returns a twice-as-big value. As
    you can see, the definition starts with the function keyword. Next, we pass a
    function name, followed by a list of its arguments wrapped in parentheses. The
    function body follows.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受单个参数x并返回一个两倍大的值。正如你所看到的，定义从function关键字开始。接下来，我们传递一个函数名，然后是括号内其参数的列表。函数体随后。
- en: The function definition is finished when the end keyword is reached. You can
    use the return keyword to return the value of the expression following it. Defining
    a function without the return keyword is allowed, in which case the value of the
    last expression in the body of the function is returned (just as in R). In this
    book, I use the return keyword in functions to explicitly signal which value I
    want to be returned from the function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到end关键字时，函数定义完成。你可以使用return关键字来返回其后表达式的值。在不使用return关键字的情况下定义函数是允许的，在这种情况下，函数体中最后一个表达式的值将被返回（就像在R中一样）。在这本书中，我在函数中使用return关键字来明确表示我希望从函数中返回哪个值。
- en: 2.4.2 Positional and keyword arguments of functions
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 函数的位置和关键字参数
- en: In general, Julia allows you to define functions with positional arguments and
    keyword arguments that optionally can get a default value. Also, a function can
    return more than one value. The following listing shows an example of a definition
    using these features and several ways the function can be called.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Julia允许你使用位置参数和关键字参数定义函数，这些参数可以可选地具有默认值。此外，一个函数可以返回多个值。以下列表显示了使用这些特性的定义示例以及函数可以调用的几种方式。
- en: Listing 2.8 Using positional and keyword arguments and providing their default
    values
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8 使用位置和关键字参数并提供它们的默认值
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Figure 2.3 explains the meaning of each argument in the compose function definition.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3解释了在组合函数定义中每个参数的含义。
- en: '![CH02_F03_Kaminski2](../Images/CH02_F03_Kaminski2.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F03_Kaminski2](../Images/CH02_F03_Kaminski2.png)'
- en: Figure 2.3 Definition of the compose function
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 组合函数的定义
- en: 'The rules of function definitions are as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义的规则如下：
- en: Multiple positional arguments (in this example, x and y) are separated by a
    comma. When you call a function, you pass only the values of positional arguments
    (without their names) in the sequence in which they were defined. The argument
    position matters; you are allowed to set a default value of a positional argument
    by using the assignment syntax (like y=10 in this example). If you give a positional
    argument a default value, all positional arguments that follow it also must be
    given a default value; in other words, all positional arguments without a default
    value must be placed before any positional argument that has a default value.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个位置参数（在这个例子中是x和y）通过逗号分隔。当你调用函数时，你只需按它们定义的顺序传递位置参数的值（不包含它们的名称）。参数位置很重要；你可以使用赋值语法（如本例中的y=10）为位置参数设置默认值。如果你为位置参数指定了默认值，所有随后的位置参数也必须指定默认值；换句话说，所有没有默认值的位置参数必须放在任何有默认值的位置参数之前。
- en: To create keyword arguments (in this example, a and b), you use a semicolon
    (;) to separate them from the positional arguments. When you call a function,
    you need to pass the name of the keyword argument and then its value linked by
    the = character. Here, default values are also allowed. When calling a function,
    you can pass keyword arguments in any order.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建关键字参数（在这个例子中是a和b），你使用分号（;）将它们与位置参数分开。当你调用一个函数时，你需要传递关键字参数的名称，然后通过等号（=）连接其值。这里也允许使用默认值。在调用函数时，你可以按任何顺序传递关键字参数。
- en: If an argument (positional or keyword) has a default value, you can omit passing
    it when you call a function.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个参数（位置参数或关键字参数）有一个默认值，当你调用函数时可以省略传递它。
- en: When calling a function that takes both positional and keyword arguments, it
    is good practice to separate them by using a semicolon (;), just as when you define
    a function. This is the convention that I use in this book; however, using a comma
    is also allowed.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用同时接受位置参数和关键字参数的函数时，使用分号（;）分隔它们是一个好习惯，就像定义函数时一样。这是我在本书中使用的约定；然而，使用逗号也是允许的。
- en: You can omit passing a value of arguments (positional or keyword) that have
    a default value defined. However, you must always pass values for all arguments
    that do not have a default value specified.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以省略传递具有默认值的参数（位置参数或关键字参数）的值。然而，你必须始终为所有没有指定默认值的参数传递值。
- en: If you want to return multiple values from a function, separate them by a comma
    (,). In chapter 4, you will learn that technically, Julia creates a Tuple from
    these values and returns it.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要从函数中返回多个值，请使用逗号（,）将它们分开。在第4章中，你将了解到技术上，Julia会从这些值创建一个元组（Tuple）并返回它。
- en: You can find additional information about optional arguments and keyword arguments
    in the Julia Manual at [http://mng.bz/49Kv](http://mng.bz/49Kv) and [http://mng.bz/QnqQ](http://mng.bz/QnqQ).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Julia手册中找到有关可选参数和关键字参数的更多信息，请参阅[http://mng.bz/49Kv](http://mng.bz/49Kv)和[http://mng.bz/QnqQ](http://mng.bz/QnqQ)。
- en: 2.4.3 Rules for passing arguments to functions
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 函数参数传递规则
- en: The way default values of the arguments are defined via the = assignment also
    highlights one important feature of Julia. If you pass a value to a function,
    Julia binds the function argument name to this value, just as it would if you
    performed an assignment (see section 2.2 for a discussion of how binding of a
    variable to a value works).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过等号（=）定义参数的默认值的方式也突出了Julia的一个重要特性。如果你向函数传递一个值，Julia会将函数参数名称绑定到这个值，就像你执行赋值操作一样（有关变量绑定到值的讨论，请参阅第2.2节）。
- en: 'This feature, called *pass-by-sharing*, means that Julia never copies data
    when arguments are passed to a function. Here is an example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性被称为*按共享传递*，意味着当将参数传递给函数时，Julia永远不会复制数据。以下是一个例子：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We name this function f!. Adding ! as a suffix to a function name is a stylistic
    convention that signals its users that it may mutate its arguments (we will discuss
    this convention in more detail later in this chapter).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个函数命名为f!。在函数名称后添加!作为后缀是一种风格约定，它向用户表明该函数可能会修改其参数（我们将在本章后面更详细地讨论这个约定）。
- en: This is a behavior that you might know from Python, but is different from, for
    example, R, in which copying function arguments is performed. One of the benefits
    of pass-by-sharing behavior is that function calls in Julia are very fast. In
    general, you can safely split your code into multiple functions without fearing
    that it will significantly degrade its performance. The downside of pass-by-sharing
    is that if you pass mutable objects to a function (we discuss mutability in more
    detail in chapter 4) and modify it inside this function, this modification will
    be, in effect, after the function finishes its execution.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种你可能从Python中知道的行为，但与例如R不同，在R中会执行函数参数的复制。pass-by-sharing行为的一个好处是Julia中的函数调用非常快。一般来说，你可以安全地将你的代码拆分成多个函数，而不必担心它会显著降低其性能。pass-by-sharing的缺点是，如果你将可变对象传递给一个函数（我们将在第4章中更详细地讨论可变性）并在该函数内部修改它，这种修改实际上会在函数执行完毕后发生。
- en: 2.4.4 Short syntax for defining simple functions
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.4 定义简单函数的简短语法
- en: To define short functions, Julia allows you to use a shorter syntax that uses
    the assignment = operator. You can then omit the function and end keyword arguments
    in the definition, subject to a limitation that the body of the function must
    be a single expression.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义简短函数，Julia允许你使用一个更短的语法，该语法使用赋值运算符=。然后你可以省略函数和end关键字参数在定义中的使用，但有一个限制，即函数体必须是单个表达式。
- en: The next listing shows an example of defining the functions times_two and compose,
    again using this syntax.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了定义times_two和compose函数的例子，再次使用这种语法。
- en: Listing 2.9 Defining short functions by using the assignment syntax
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.9 使用赋值语法定义简短函数
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Let me give you a warning about a common typing mistake that significantly changes
    the meaning of the code. If you type times_two(x) = 2 * x, you define a new function;
    however, if you type times_two(x) == 2 * x, you perform a logical comparison of
    equality of f(x) and 2 * x. As you can see, the code examples differ only in =
    versus ==. The potential pitfall is that both are valid, so you might not get
    what you want, while Julia would still accept and execute the code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我提醒你一个常见的打字错误，这个错误会显著改变代码的含义。如果你输入times_two(x) = 2 * x，你定义了一个新的函数；然而，如果你输入times_two(x)
    == 2 * x，你执行了f(x)和2 * x相等性的逻辑比较。正如你所看到的，代码示例仅在=与==之间有所不同。潜在的陷阱是两者都是有效的，所以你可能不会得到你想要的结果，而Julia仍然会接受并执行这段代码。
- en: Functions can be passed as arguments to other functions in Julia
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在Julia中，函数可以作为参数传递给其他函数
- en: 'A useful feature of Julia is that functions are first-class objects, as in
    functional programming. Therefore, they can be passed around and assigned to variables,
    and each function has its distinct type. Here is an example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的一个有用特性是函数是一等对象，就像在函数式编程中一样。因此，它们可以被传递并分配给变量，每个函数都有其独特的类型。以下是一个例子：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In this code, we use the map function that takes two arguments: a function
    (times_two, in this case, defined previously) and a collection (a vector [1, 2,
    3], in this example). The returned value is the passed collection transformed
    by applying the times_two function to each element.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用了map函数，它接受两个参数：一个函数（在这个例子中是times_two，之前已定义）和一个集合（在这个例子中是一个向量[1, 2,
    3]）。返回值是通过将times_two函数应用于每个元素来转换传递的集合。
- en: 2.4.5 Anonymous functions
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.5 匿名函数
- en: When you pass a function as an argument to another function, you’ll often want
    to define a function that does not need a name. You just want to temporarily define
    this function and pass it to another function. In Julia, you can define nameless
    functions, which are called *anonymous functions*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个函数作为参数传递给另一个函数时，你通常会想要定义一个不需要名称的函数。你只想临时定义这个函数并将其传递给另一个函数。在Julia中，你可以定义无名的函数，这些函数被称为*匿名函数*。
- en: The syntax is similar to the short syntax introduced previously, except that
    you skip the function name and replace = with ->, as the next listing shows.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 语法与之前介绍的简短语法类似，不同之处在于你省略了函数名，并将=替换为->，如以下列表所示。
- en: Listing 2.10 Defining anonymous functions by using the -> syntax
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.10 使用->语法定义匿名函数
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In this example, the anonymous function is x -> 2 * x. In Python, an equivalent
    would be to use a lambda function with the following syntax: lambda x: 2 * x.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，匿名函数是x -> 2 * x。在Python中，等效的做法是使用具有以下语法的lambda函数：lambda x: 2 * x。'
- en: 'Note that in the x -> 2 * x definition, we skip the parentheses around the
    argument. But in general, if we use more than one argument, parentheses are needed,
    as in this definition: (x, y) -> x + y.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 x -> 2 * x 的定义中，我们省略了参数周围的括号。但通常，如果我们使用多个参数，则需要括号，就像这个定义一样：(x, y) -> x
    + y。
- en: 'Julia has many functions that take functions as their arguments. Here’s one
    more example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 有许多接受函数作为其参数的函数。这里还有一个例子：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We calculate the sum of squares of the values stored in the vector. In this
    case, the key benefit of being able to use a function as a first argument of the
    sum function is the following. A natural way to compute the sum of squares of
    a vector is to first square its elements, store the result in a temporary vector,
    and then calculate its sum. However, this approach is expensive because it needs
    to allocate this temporary vector. When sum(x -> x ^ 2, [1, 2, 3]) is executed,
    no allocations are performed.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算存储在向量中的值的平方和。在这种情况下，能够将函数用作 sum 函数的第一个参数的关键好处如下。计算向量平方和的自然方式是首先平方其元素，将结果存储在一个临时向量中，然后计算其总和。然而，这种方法成本很高，因为它需要分配这个临时向量。当执行
    sum(x -> x ^ 2, [1, 2, 3]) 时，不会执行任何分配。
- en: Multiple dispatch when calling the sum function
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 sum 函数时的多重分派
- en: In the preceding sum(x -> x ^ 2, [1, 2, 3]) example, you saw Julia use multiple
    dispatch. We discuss this topic in chapter 3, but I describe it briefly here because
    it is one of the fundamental design concepts in Julia.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 sum(x -> x ^ 2, [1, 2, 3]) 示例中，你看到了 Julia 使用了多重分派。我们将在第 3 章讨论这个主题，但我在这里简要描述它，因为它是在
    Julia 中的一个基本设计概念。
- en: Normally, you pass to the sum function a single collection and get its sum in
    return. For example, executing sum([1, 2, 3]) produces 6. However, for a single
    function, like sum in the preceding example, Julia allows you to define multiple
    *methods*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你将单个集合传递给 sum 函数，并返回其总和。例如，执行 sum([1, 2, 3]) 产生 6。然而，对于像前面示例中的 sum 这样的单个函数，Julia
    允许你定义多个 *方法*。
- en: Each method of a function takes a different set of arguments. When we write
    sum([1, 2, 3]), Julia invokes the method taking a single argument. However, when
    we write sum(x -> x ^ 2, [1, 2, 3]), another method of the sum function is called.
    In this case, the method expects that the first argument is a function, and the
    second argument is a collection and returns a sum of elements of this collection
    after they are transformed by the function passed as a first argument.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的每种方法都接受不同的一组参数。当我们编写 sum([1, 2, 3]) 时，Julia 调用接受单个参数的方法。然而，当我们编写 sum(x ->
    x ^ 2, [1, 2, 3]) 时，sum 函数的另一种方法被调用。在这种情况下，该方法期望第一个参数是一个函数，第二个参数是一个集合，并且通过将作为第一个参数传递的函数转换这些集合的元素后，返回这些元素的求和。
- en: 2.4.6 Do blocks
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.6 Do 块
- en: One last convenience syntax that you should learn is the do-end block. These
    blocks are used if (1) you use a function that accepts another function as its
    first positional argument and (2) you want to pass an anonymous function composed
    of several expressions (so a standard anonymous function definition style is not
    convenient).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该学习的一个最后的便利语法是 do-end 块。这些块在以下情况下使用：(1) 如果你使用一个接受另一个函数作为其第一个位置参数的函数，并且(2)
    你想要传递一个由多个表达式组成的匿名函数（因此标准的匿名函数定义方式不方便）。
- en: 'Here is an example of a do-end block:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 do-end 块的示例：
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ A do-end block defines an anonymous function taking a single argument x. This
    anonymous function is passed as a first argument to the sum function.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个 do-end 块定义了一个接受单个参数 x 的匿名函数。这个匿名函数被作为第一个参数传递给 sum 函数。
- en: 'As you can see, in this case, we use the sum function. As I have explained,
    one of its methods expects two arguments: the first should be a function, and
    the second a collection. When using the do-end syntax, you skip the function that
    you want to pass in the arguments of the called function and instead add the do
    keyword argument followed by an argument name of the anonymous function you want
    to define. Then the function body is normally defined as for any other function
    and is terminated by the end keyword argument.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这种情况下，我们使用了 sum 函数。正如我解释的那样，其中一种方法期望两个参数：第一个应该是一个函数，第二个是一个集合。当使用 do-end
    语法时，你省略了想要传递给被调用函数的函数，而是添加了 do 关键字参数，后跟一个匿名函数的参数名称，你想要定义这个匿名函数。然后函数体通常像任何其他函数一样定义，并以
    end 关键字参数结束。
- en: 2.4.7 Function-naming convention in Julia
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.7 Julia 中的函数命名约定
- en: Before we wrap up this section, let’s discuss one convention that is related
    to the way functions are named in Julia. Often you will see an exclamation mark
    (!) at the end of the function name—for example, sort!. Users sometimes think
    this means that Julia treats these functions in a nonstandard way; for example,
    in Rust, the ! suffix indicates a macro. This is not the case; such a name gets
    no special treatment.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在我們結束這一節之前，讓我們討論一個與 Julia 中函數命名方式相關的傳統。你經常會看到函數名稱的末尾有一個感叹號 (!) ——例如，sort!。用戶有時會認為這意味著
    Julia 以非標準的方式處理這些函數；例如，在 Rust 中，! 後綴表示一個宏。這不是真的；這樣的名稱不會得到特殊處理。
- en: 'However, a Julia convention recommends that developers add ! at the end of
    functions they create if those functions modify their arguments. Here is an example
    comparison of how the sort and sort! functions work. Both return a sorted collection.
    However, sort does not change its argument, while sort! modifies it in place:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一個 Julia 總結推薦開發者在它們創建的函數末尾添加 !，如果這些函數修改了他們的參數。以下是一個比較 sort 和 sort! 函數如何工作的例子。它們都返回一個排序後的集合。然而，sort
    不改變它的參數，而 sort! 在原地修改它：
- en: '[PRE47]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You might wonder why this convention is useful. Although most functions do not
    modify their arguments, Julia uses pass-by-sharing when passing arguments to functions,
    so all functions potentially could modify their arguments. Therefore, it is useful
    to visually warn the user that a given function indeed takes advantage of pass-by-sharing
    and modifies its arguments (usually the benefit of modifying the arguments in
    place is improved performance).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能會想知道這個傳統為什麼有價值。儘管大多數函數不會修改它們的參數，但 Julia 在將參數傳遞給函數時使用共享傳遞，所以所有函數都有可能修改它們的參數。因此，用於視覺上提醒用戶給定的函數確實利用了共享傳遞並修改了它的參數（通常在原地修改參數的優勢是提高性能）。
- en: 2.4.8 A simplified definition of a function computing the winsorized mean
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.8 一個計算 winsorized 均值的函數的簡化定義
- en: 'Now we are ready to create and test our first version of the function calculating
    the winsorized mean. We follow the same steps as in section 2.3.4, but this time,
    we wrap the code in a function:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 現在我們準備創建和測試我們計算 winsorized 均值的函數的第一個版本。我們遵循與 2.3.4 节相同的步驟，但這次，我們將代碼包裝在一個函數中：
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In defining the winsorized_mean function, an important difference from the code
    in section 2.3.4 is that the line s += v has no global prefix (in section 2.3.4,
    this line is global s += v). The reason is that this time, the s variable is local
    since it is defined in the body of the function.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在定義 winsorized_mean 函數時，與 2.3.4 节中的代碼的重要差別是這行 s += v 沒有全局前綴（在 2.3.4 节中，這行是 global
    s += v）。原因是這次，s 參數是局部的，因為它在函數體中定義。
- en: We now have a working function allowing us to calculate the k-times winsorized
    mean. It could be used in practice. I reused the steps from section 2.3.4 on purpose
    to show you how to wrap code in a function. However, this implementation can be
    improved both in terms of correctness (think of how it would behave if we passed
    inappropriate values for x or k) and in terms of performance. In chapter 3, after
    you learn more about how Julia programs are written, you will see how this code
    can be improved.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 現在我們已經有一個可以讓我們計算 k 次winsorized均值的函數。它在實踐中可以應用。我故意重用了 2.3.4 节中的步驟來展示如何將代碼包裝在函數中。然而，這個實現可以在正確性和性能兩個方面進行改進。在第三章，在你學習更多有關如何編寫
    Julia 程序之後，你將看到這段代碼如何進行改進。
- en: 2.5 Understanding variable scoping rules
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 理解變數作用域規則
- en: You have learned the basic constructs of the Julia language. A natural question
    is how these constructs interact with variables. In other words, what are the
    rules that allow Julia to determine which variables are visible in which regions
    of code? This topic is fundamentally important for any programmer, and since the
    way scoping works in Julia is different from, for example, Python, it should be
    discussed here.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学习了 Julia 语言的基礎結構。一個自然的問題是這些結構如何與變數互動。換句話說，有哪些規則允許 Julia 確定哪些變數在代碼的哪些區域是可見的？這個主題對任何程序員來說都是基礎性的，而且由於
    Julia 中作用域的運作方式與 Python 等語言不同，這裡應該進行討論。
- en: We won’t develop any new features of our winsorized mean function in this section
    (we will get back to that in chapter 3). However, we already implicitly relied
    on Julia’s variable scoping rules in our code in the preceding section, so it
    is important to explicitly explain how scoping works.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不会开发 winsorized 均值函数的任何新特性（我们将在第 3 章中回到这个话题）。然而，在前一节中，我们已经在代码中隐式地依赖于
    Julia 的变量作用域规则，因此明确解释作用域是如何工作的是很重要的。
- en: In general, the rules of variable scoping are complex, as they need to cover
    many possible scenarios. This section concentrates on the major concepts that
    are sufficient to deal with most situations. If you want to learn more details,
    check out the Julia Manual ([http://mng.bz/Xarp](http://mng.bz/Xarp)).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，变量作用域的规则很复杂，因为它们需要涵盖许多可能的场景。本节集中讨论了处理大多数情况所需的主要概念。如果你想了解更多细节，请查看 Julia 手册（[http://mng.bz/Xarp](http://mng.bz/Xarp)）。
- en: If you define a variable in a top-level scope of your code (outside any construct
    introducing local scope, such as functions), that variable is created in a *global
    scope*. Julia allows users to define global variables, as this is often convenient,
    especially when working interactively with the Julia REPL. However, using global
    variables is discouraged, as it can have a negative impact on code execution speed.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个代码的最高级别作用域中定义一个变量（在引入局部作用域的任何结构之外，例如函数），那么这个变量将在一个*全局作用域*中创建。Julia 允许用户定义全局变量，因为这通常很方便，尤其是在与
    Julia REPL 交互式工作的时候。然而，使用全局变量是不被推荐的，因为它可能会对代码执行速度产生负面影响。
- en: Using global variables can have a negative impact on code execution speed
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局变量可能会对代码执行速度产生负面影响
- en: A call to avoid global variables is one of the first rules listed in the “Performance
    Tips” section of the Julia Manual ([http://mng.bz/epPP](http://mng.bz/epPP)).
    Through Julia 1.7, this is a general rule. In Julia 1.8, a possibility of fixing
    the type of a global variable is introduced, so starting from Julia 1.8, the limitations
    I describe here apply only to untyped global variables.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用全局变量的一个规则是 Julia 手册“性能提示”部分中列出的第一条规则之一（[http://mng.bz/epPP](http://mng.bz/epPP)）。通过
    Julia 1.7，这是一个通用规则。在 Julia 1.8 中，引入了修复全局变量类型的可能性，因此从 Julia 1.8 开始，这里描述的限制仅适用于未类型化的全局变量。
- en: Let me explain why global variables have a negative impact on code execution
    speed. As you have already learned, Julia compiles functions before executing
    them. We also discussed in section 2.2 that to ensure that compilation results
    in fast native code, the variables used inside a function must be type stable.
    Finally, you also know that Julia is dynamically typed, which means that you can
    bind values of any type to a variable.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我来解释为什么全局变量会对代码执行速度产生负面影响。正如你已经学到的，Julia 在执行函数之前会编译函数。我们在第 2.2 节中也讨论过，为了确保编译结果生成快速的本地代码，函数内部使用的变量必须是类型稳定的。最后，你也知道
    Julia 是动态类型的，这意味着你可以将任何类型的值绑定到一个变量上。
- en: Now assume that you reference a global variable inside a function. To produce
    fast code, Julia would have to be sure of the variable’s type. However, since
    the variable is global, no such guarantee is possible. Therefore, the Julia compiler
    must assume that the global variable is not type stable, and consequently, the
    code will be slow.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你在函数内部引用了一个全局变量。为了生成快速代码，Julia 必须确信变量的类型。然而，由于变量是全局的，不可能有这样的保证。因此，Julia
    编译器必须假设全局变量不是类型稳定的，因此代码将会变慢。
- en: A crucial question is why the Julia compiler can’t determine the type of the
    global variable when it compiles the function. The answer is that it could, but
    this type can change after Julia compiles the function.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键问题是为什么 Julia 编译器在编译函数时不能确定全局变量的类型。答案是，它可以，但这个类型在 Julia 编译函数之后可能会改变。
- en: Let me give you an example. As mentioned in chapter 1, Julia comes with built-in
    support for multithreading. This powerful feature allows you to use all cores
    of your CPU when doing computations. However, this power comes at a price. Assume
    you have two threads running in parallel. In the first thread, you run a function
    using a global variable. In the second thread, another function is executed in
    parallel that changes the same global variable. Therefore, the function running
    in the second thread could alter the type of the global variable used in thread
    one after the function running in this thread was compiled.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你一个例子。如第1章所述，Julia自带对多线程的支持。这个强大的功能允许你在进行计算时使用CPU的所有核心。然而，这种力量是有代价的。假设你有两个并行运行的线程。在第一个线程中，你使用全局变量运行一个函数。在第二个线程中，另一个函数并行执行，并更改相同的全局变量。因此，在第一个线程中运行的函数在编译后，第二个线程中运行的函数可能会改变在第一个线程中使用的全局变量的类型。
- en: You probably want to know how to avoid the problems caused by using global variables
    inside function definitions. The simplest solution is to pass these variables
    as function arguments.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道如何避免在函数定义中使用全局变量引起的问题。最简单的解决方案是将这些变量作为函数参数传递。
- en: 'The following types of constructs that you have learned already create a new
    scope (called *local scope*). In the list, I omit several more advanced constructs
    that we do not use in this book):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学习过的以下类型的构造（称为*局部作用域*）会创建一个新的作用域。在列表中，我省略了几个我们在这本书中不使用的更高级的构造）：
- en: Functions, anonymous functions, do-end blocks
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数、匿名函数、do-end块
- en: for and while loops
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: for和while循环
- en: try-catch-end blocks (discussed in section chapter 7)
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: try-catch-end块（在第7章中讨论）
- en: Comprehensions (discussed in chapter 4)
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解（在第4章中讨论）
- en: Notably, the if blocks and begin-end blocks *do not* introduce a new scope.
    Variables defined in these blocks leak out to the enclosing scope.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，if块和begin-end块*不会*引入新的作用域。在这些块中定义的变量会泄漏到外部作用域。
- en: For completeness of the discussion, let me add that modules, which are discussed
    in chapter 3, introduce a new global scope.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了讨论的完整性，让我补充一下，在第3章中讨论的模块引入了一个新的全局作用域。
- en: 'Let’s look at several examples of these rules in action. Start a fresh Julia
    REPL, and follow these code examples. In each, we define a function with a slightly
    different scoping behavior. We begin with a basic scenario:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些规则在实际应用中的几个例子。启动一个新的Julia REPL，并遵循以下代码示例。在每个示例中，我们定义一个具有略微不同的作用域行为的函数。我们从一个基本场景开始：
- en: '[PRE49]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This example shows that a variable defined within a function (local scope)
    does not get to the enclosing scope if it is not defined there. Next, I will illustrate
    the consequences of if blocks not introducing a new scope:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子表明，在函数（局部作用域）内部定义的变量如果没有在那里定义，则不会到达外部作用域。接下来，我将说明if块不引入新作用域的后果：
- en: '[PRE50]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: By executing fun2(), you can see that the x variable is defined in an if block,
    but since the if block does not introduce a scope, the x variable is also visible
    outside of the block.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行fun2()，你可以看到x变量定义在if块中，但由于if块不引入作用域，x变量在块外也是可见的。
- en: 'Unlike if blocks, loops introduce a new local scope. The most important scenarios
    of a loop introducing a new local scope are shown in the following four examples:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 与if块不同，循环引入一个新的局部作用域。循环引入新局部作用域的最重要场景如下四个示例所示：
- en: '[PRE51]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'From the result of the fun3() call, you can see that if we nest local scopes
    and variable x is defined in the outer local scope, it is reused by the inner
    local scope (introduced by the for loop, in this case). If we omit x = 0 in the
    definition, the function will not work:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 从fun3()调用的结果中，你可以看到，如果我们嵌套局部作用域，并且变量x在外部局部作用域中定义，它将被内部局部作用域（在这种情况下由for循环引入）重用。如果我们省略定义中的x
    = 0，函数将无法工作：
- en: '[PRE52]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The reason for the error in the fun4() call is that the for loop introduces
    a new local scope, and since x is not defined in the outer scope of the fun4 function,
    it does not leak out of the for loop.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: fun4()调用中错误的原因是for循环引入了一个新的局部作用域，并且由于x没有在fun4函数的外部作用域中定义，它不会从for循环中泄漏出来。
- en: 'Moreover, a loop-local variable, like x in the preceding example, is freshly
    defined for each iteration of the loop, so the following code also fails:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，像前一个例子中的x这样的循环局部变量，在循环的每次迭代中都会被重新定义，因此以下代码也会失败：
- en: '[PRE53]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Let’s try to understand what happens in the code when we call fun5(). In the
    first iteration of the loop, we perform the x = 1 assignment and print 1. In the
    second iteration, x from the first iteration is discarded (it is freshly allocated
    in each iteration), so its value is not available when the x += 1 operation is
    attempted. The workaround for this problem is to reintroduce the variable x in
    the scope enclosing the for loop, as shown in the following listing.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解在调用 fun5() 时代码中发生了什么。在循环的第一次迭代中，我们执行 x = 1 赋值并打印 1。在第二次迭代中，第一次迭代中的 x
    被丢弃（它在每次迭代中都是新分配的），因此在尝试 x += 1 操作时其值不可用。解决这个问题的一种方法是，在 for 循环的作用域中重新引入变量 x，如下面的列表所示。
- en: Listing 2.11 Updating a local variable defined in the enclosing scope of the
    for loop
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.11 更新 for 循环外部作用域中定义的局部变量
- en: '[PRE54]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now all works as expected when we call fun6(), as the x variable is stored in
    the scope of the fun6 function and thus is not freshly allocated in each iteration.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们调用 fun6() 时，所有操作都按预期工作，因为 x 变量存储在 fun6 函数的作用域中，因此在每次迭代中不是新分配的。
- en: The nothing value
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 无值（nothing）值
- en: In listing 2.11, we define the function fun6 that does not return any value
    by using the return keyword. Also, the last part of the function body is a for
    loop that does not produce a value that would be returned by the function in the
    absence of the return keyword. In such cases, the return value of the function
    is nothing, which is used by convention when there is no value to return.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 2.11 中，我们定义了一个函数 fun6，它不使用 return 关键字返回任何值。此外，函数体最后一部分是一个不产生函数在没有 return
    关键字时将返回的值的 for 循环。在这种情况下，函数的返回值是 nothing，这是在不需要返回值时按照惯例使用的。
- en: Before I finish this section, let me stress again that what we have discussed
    here are simplified scoping rules used by Julia. All the details about how scoping
    works in Julia are given in the Julia Manual ([http://mng.bz/Xarp](http://mng.bz/Xarp)),
    along with an explanation of the rationale behind the design.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在我完成这一节之前，让我再次强调，我们在这里讨论的是 Julia 使用的简化作用域规则。关于 Julia 中作用域如何工作的所有细节都可在 Julia
    手册([http://mng.bz/Xarp](http://mng.bz/Xarp))中找到，其中还包括了对设计背后原理的解释。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Every value in Julia has a type. Examples of numeric types are Int64 and Float64.
    Values that are collections, like vectors, have types that have parameters; Vector{Float64}
    is an example of a type indicating a vector that can store Float64 numbers.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 中的每个值都有一个类型。数值类型的例子有 Int64 和 Float64。像向量这样的集合值有带参数的类型；Vector{Float64}
    是一个表示可以存储 Float64 数字的向量的类型的例子。
- en: Julia is dynamically typed, which means that only values have types. Variable
    names are dynamically bound to values, which implies that, in general, variables
    can change the type of value that is bound to them.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 是动态类型的，这意味着只有值才有类型。变量名是动态绑定到值的，这意味着通常变量可以改变绑定到它们的值的类型。
- en: Julia provides great flexibility in naming your variables. Additionally, the
    Julia REPL and common editors make it easy to use nonstandard characters using
    LaTeX completions.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 在变量命名方面提供了很大的灵活性。此外，Julia REPL 和常见的编辑器使得使用非标准字符（通过 LaTeX 完成补全）变得容易。
- en: 'Julia provides all the standard control-flow constructs. For user convenience,
    it also introduces several syntaxes to make it easier to write code: ternary operator,
    short-circuit evaluation, single-expression function definitions, anonymous functions,
    and the do-end block syntax.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Julia 提供了所有标准的控制流结构。为了方便用户，它还引入了几个语法，使编写代码更加容易：三元运算符，短路评估，单表达式函数定义，匿名函数，以及 do-end
    块语法。
- en: 'In Julia, you can define functions in three ways: using the function keyword,
    using the assignment operator =, and defining an anonymous function with the ->
    operator.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Julia 中，你可以通过三种方式定义函数：使用函数关键字，使用赋值运算符 =，以及使用箭头运算符 -> 定义匿名函数。
- en: In Julia, functions and for and while loops introduce a new scope, but if and
    begin-end blocks do not.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Julia 中，函数和 for 以及 while 循环会引入一个新的作用域，但 if 和 begin-end 块则不会。
