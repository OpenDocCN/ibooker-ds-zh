- en: '9 Modularity for ML: Writing testable and legible code'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 机器学习的模块化：编写可测试和可读的代码
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Demonstrating why monolithic script-coding patterns make ML projects more complex
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阐述为什么单体脚本编码模式使机器学习项目更复杂
- en: Understanding the complexity of troubleshooting non-abstracted code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解调试非抽象代码的复杂性
- en: Applying basic abstraction to ML projects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基本抽象应用于机器学习项目
- en: Implementing testable designs in ML code bases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在机器学习代码库中实现可测试的设计
- en: Precious few emotions are more soul-crushing than those forced upon you when
    you’re handed a complex code base that someone else wrote. Reading through a mountain
    of unintelligible code after being told that you are responsible for fixing, updating,
    and supporting it is demoralizing. The only worse situation when inheriting a
    fundamentally broken code base to maintain occurs when your name is the one on
    the commit history.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当你被交给一个别人编写的复杂代码库时，几乎没有比这更让人心灵崩溃的情感。在被告知你负责修复、更新和支持它之后，阅读一大堆难以理解的代码是令人沮丧的。当你继承了一个本质上已经损坏的代码库来维护时，唯一更糟糕的情况是你的名字出现在提交历史中。
- en: 'This isn’t to say that the code doesn’t work. It may run perfectly fine. The
    fact that code *runs* isn’t the issue. It’s that a human can’t easily figure out
    *how*(or, more disastrously, *why*) it works. I believe this problem was most
    eloquently described by Martin Fowler in 2008:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说代码不起作用。它可能运行得很好。代码能运行的事实并不是问题。问题是人类无法轻易地弄清楚它是如何（或者，更糟糕的是，为什么）工作的。我相信这个问题在2008年由马丁·福勒最生动地描述了：
- en: '*Any fool can write code that a computer can understand. Good programmers write
    code that humans can understand.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*任何傻瓜都能写出计算机能理解的代码。优秀的程序员写出人类能理解的代码。*'
- en: A large portion of ML code is not aligned with good software engineering practices.
    With our focus on algorithms, vectors, indexers, models, loss functions, optimization
    solvers, hyperparameters, and performance metrics, we, as a profession of practitioners,
    generally don’t spend much time adhering to strict coding standards. At least,
    most of us don’t.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分机器学习代码不符合良好的软件工程实践。由于我们专注于算法、向量、索引器、模型、损失函数、优化求解器、超参数和性能指标，我们作为实践者的一个职业，通常不会花太多时间遵守严格的编码标准。至少，我们中的大多数是这样的。
- en: I can proudly claim that I was one such person for many years, writing some
    truly broken code (it worked when I released it, most of the time). Focused solely
    on eking the slightest of accuracy improvements or getting clever with feature-engineering
    tasks, I would end up creating a veritable Frankenstein’s monster of unmaintainable
    code. To be fair to that misunderstood reanimated creature, some of my early projects
    were far more horrifying. (I wouldn’t have blamed my peers if they chased me with
    torches and pitchforks.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以自豪地说，我多年来就是这样一个人，编写了一些真正糟糕的代码（大多数时候它在我发布时是能工作的）。我专注于尽可能小的精度改进或是在特征工程任务中变得巧妙，结果我创造了一个真正的弗兰肯斯坦怪物，是难以维护的代码。为了公正地对待这个被误解的复活的生物，我的一些早期项目要恐怖得多。（如果我的同伴拿着火把和长柄叉追赶我，我不会责怪他们。）
- en: This chapter and the next are devoted to the lessons in coding standards that
    I’ve learned over the years. It is by no means an exhaustive treatise on the topic
    of software engineering; there are books for that. Rather, these are the most
    important aspects that I’ve learned in order to create simpler and easier-to-maintain
    code bases for ML project work. We will cover these best practices in five key
    areas, as shown in figure 9.1.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和下一章致力于我在多年中学习到的编码标准教训。这绝对不是关于软件工程的详尽论述；有书是关于这个话题的。相反，这些是我为了创建更简单、更容易维护的机器学习项目代码库而学到的最重要的方面。我们将按照图9.1所示的五个关键领域来介绍这些最佳实践。
- en: The sections in this chapter, reflected in figure 9.1, demonstrate examples
    of the horrible things that I’ve done, the terrifying elements that I’ve seen
    in others’ code, and, most important, ways to address them. Our goal in this chapter
    is to avoid the Frankenstein’s monster of convoluted and overly complex code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的部分内容，如图9.1所示，展示了我所做的可怕事情、我在他人代码中看到的可怕元素，以及最重要的是，如何解决这些问题。我们本章的目标是避免复杂的和过度复杂的代码的弗兰肯斯坦怪物。
- en: '![09-01](../Images/09-01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![09-01](../Images/09-01.png)'
- en: Figure 9.1 Comparing extremes of coding practices for ML project work
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1比较了机器学习项目工作中的编码实践极端
- en: Complicated vs. complex code
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂代码与复杂代码
- en: 'This phrase *complicated vs. complex* may seem like a poor interpretation of
    grammar—the two terms seem to mean the same thing, after all. But, applied to
    code, each is markedly different. A *complex code base* is an empirical assessment
    of the branching paths that a particular piece of encapsulated code (think: function
    or method) can traverse. The `for`loops, conditional statements, matching switch
    statements, and passed-in argument-functionality state changes are all elements
    that add to the complexity of code. With many “things” that a bit of contained
    code can do, the number of results that could come out of that code is very high.
    Code bases that are complex typically require a great deal of testing to ensure
    that they function correctly under all conditions possible. This complexity also
    makes the code base more difficult to understand than those that have fewer branching
    paths of functionality.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个短语**复杂与复杂**可能看起来是对语法的一个糟糕解释——毕竟这两个词似乎意味着相同的意思。但是，当应用于代码时，每个词都有明显的不同。一个**复杂的代码库**是对特定封装代码（例如：函数或方法）可以遍历的分支路径的经验性评估。`for`循环、条件语句、匹配的`switch`语句以及传入的参数功能状态变化都是增加代码复杂性的元素。由于包含的代码可以执行许多“事情”，因此从这个代码中可能产生的结果数量非常高。复杂的代码库通常需要大量的测试来确保它们在所有可能的情况下都能正确运行。这种复杂性也使得代码库比那些功能分支路径更少的代码库更难以理解。
- en: A *complicated code base*, however, is one that is written in such a way that
    makes it difficult to ascertain how the code functions. This highly subjective
    assessment of “how hard it is to read and figure out” is a measurement that depends
    heavily on the person reading the code. Be that as it may, a general consensus
    can be agreed upon by most experienced developers on what constitutes a complicated
    code base as compared to an uncomplicated one.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个**复杂的代码库**是这样编写的，使得很难确定代码的功能。这种高度主观的评估“阅读和弄懂有多难”是一个很大程度上取决于阅读代码的人的衡量标准。不管怎样，大多数经验丰富的开发者可以就复杂代码库与简单代码库的区别达成一般共识。
- en: A highly complicated code base may have gotten to that state after repeated
    patching of the code (retrofitting code to fix deferred technical debt). This
    code may be chained, use poor naming conventions, include repeated use of conditional
    logic in a difficult-to-read manner, or just liberally use uncommon shorthand
    notation (I’m looking at you, Scala wildcard, `_`).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个高度复杂的代码库可能是在代码反复修补（重构代码以修复延迟的技术债务）之后达到这种状态的。这种代码可能链式连接，使用糟糕的命名约定，以难以阅读的方式重复使用条件逻辑，或者只是自由地使用不常见的缩写符号（我看着你，Scala通配符，`_`）。
- en: 'A code base can be a mixture of these elements:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库可以是由以下这些元素混合而成的：
- en: '*Complex and not complicated*—A challenging but acceptable state for ML code
    bases.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂但不复杂**——对于机器学习代码库来说是一个具有挑战性但可接受的状态。'
- en: '*Not complex and not complicated*—Also acceptable, but typically not seen outside
    of analytics use cases in DS work.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不复杂也不复杂**——也是可接受的，但在数据科学工作中的应用案例中通常不常见。'
- en: '*Not complex and complicated*—We’ll see an example in section 9.1.1.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不复杂也不复杂**——我们将在第9.1.1节中看到一个例子。'
- en: '*Complex and complicated*—The bane of our existence as ML practitioners when
    inheriting a code base.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂且复杂**——作为机器学习实践者在继承代码库时存在的烦恼。'
- en: The goal in developing ML projects is to focus first on keeping the measure
    of *complicated* for the code base as low as possible, while also focusing on
    reducing the complexity as much as is practicable. The lower the measure of both
    of these concepts, the greater the chances that the project you’re working on
    will not only get to production but stay as a maintainable and extensible solution
    to a business need.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发机器学习项目时，目标是首先尽可能降低代码库的**复杂度**，同时也要尽可能减少复杂性。这两个概念的衡量标准越低，你正在工作的项目不仅能够进入生产阶段，而且更有可能成为一个可维护和可扩展的解决方案，以满足业务需求。
- en: 'To make things easier, we’re going to look at a single relatively simple example
    throughout this chapter, something that we should all be rather familiar with:
    a distribution estimation for univariate data. We’ll stick with this example because
    it is simple and approachable. We’ll look at the same effective solution through
    the lens of different programming problems, discussing how important it is to
    focus on maintainability and utility above all other considerations.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让事情变得简单，我们将在本章中通过一个相对简单的例子来进行分析，这是我们所有人都应该相当熟悉的内容：单变量数据的分布估计。我们将坚持使用这个例子，因为它简单且易于接近。我们将从不同编程问题的角度来审视相同的有效解决方案，讨论在所有考虑因素中，关注可维护性和实用性是多么重要。
- en: 9.1 Understanding monolithic scripts and why they are bad
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 理解单体脚本及其为何不好
- en: '*Inheritance*, in the world of computing, can mean a few different things.
    The topic first comes to mind when thinking of crafting extensible code through
    abstraction (code reuse in object-oriented design to reduce copied functionality
    and decrease complexity). While this type of inheritance is undeniably good, a
    different type of inheritance can range from good to nightmarish. This is the
    inheritance we get when assuming responsibility for someone else’s code base.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机的世界里，“继承”可以意味着几件事情。这个话题首先出现在我们思考通过抽象（面向对象设计中代码的重用，以减少复制的功能并降低复杂性）来构建可扩展代码时。虽然这种类型的继承无疑是好的，但另一种类型的继承可以从好到噩梦般。这是我们承担他人代码库责任时所获得的继承。
- en: Let’s imagine that you start at a new company. After indoctrination is done,
    you’re given a token to access the DS repository (repo). This moment of traversing
    the repo for the first time is either exciting or terrifying, depending on the
    number of times you’ve done this before. What are you going to find? What have
    your predecessors at this company built? How easy is the code going to be to debug,
    modify, and support? Is it filled with technical debt? Is it consistent in style?
    Does it adhere to language standards?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，你加入了一家新公司。经过培训后，你被分配了一个令牌来访问DS存储库（repo）。当你第一次穿越这个repo时，这种感觉要么令人兴奋，要么令人恐惧，这取决于你之前做过多少次。你将发现什么？你的前任在这个公司都建立了什么？代码的调试、修改和支持将有多容易？它是否充满了技术债务？它的风格是否一致？它是否遵循语言标准？
- en: At first glance, you feel a sinking in your stomach as you look through the
    directory structure. There are dozens of directories, each with a project name.
    Within each of these directories is a single file. You know you are in for a world
    of frustration in figuring out how any of these monolithic and messy scripts work.
    Any on-call support you’ll be tasked with providing for these is going to be incredibly
    challenging. Each issue that comes up, after all, will involve reverse engineering
    these confusing and complicated scripts for even the most trivial of errors that
    occur.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 初看目录结构时，你会感到胃里一阵恶心。有数十个目录，每个目录都有一个项目名称。在这些目录中，每个目录都只有一个文件。你知道在弄清楚这些庞大且混乱的脚本如何工作时，你将面临一个充满挫折的世界。你将负责提供这些脚本的支持，这将是极其具有挑战性的。毕竟，每个出现的问题都将涉及对这些令人困惑和复杂的脚本进行逆向工程，即使是发生最微不足道的错误也是如此。
- en: 9.1.1 How monoliths come into being
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 单体是如何形成的
- en: If we were to dig into the commit history of our new team’s repository, we’d
    likely find a seamless transition from prototype to experimentation. The first
    commit would likely be the result of a bare-bones experiment, filled with `TODO`
    comments and placeholder functionality. As we move through the commit history,
    the script begins to take shape, piece by piece, finally arriving at the production
    version of the code that you see in the master branch.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要深入研究我们新团队存储库的提交历史，我们可能会发现从原型到实验的无缝过渡。第一个提交很可能是裸骨实验的结果，充满了`TODO`注释和占位符功能。随着我们通过提交历史前进，脚本开始逐渐成形，最终到达你在主分支中看到的代码的生产版本。
- en: The problem here is not that scripting was used. The vast majority of professional
    ML engineers, myself included, do our prototyping and experimentation in notebooks
    (scripts). The dynamic nature of notebooks and the ability to rapidly try out
    new ideas makes them an ideal platform for this stage of work. Upon accepting
    a prototype as a path to develop, however, all of that prototype code is thrown
    out in favor of creating modularized code during MVP development.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题并不是使用了脚本。包括我在内的绝大多数专业机器学习工程师，我们在原型设计和实验中都在笔记本（脚本）中工作。笔记本的动态性质和快速尝试新想法的能力使其成为这一工作阶段的理想平台。然而，在将原型作为开发路径接受之后，所有这些原型代码都会被丢弃，以便在最小可行产品（MVP）开发期间创建模块化代码。
- en: The evolution of a script from a prototype is understandable. ML development
    is notorious for having countless changes, needing rapid feedback of results,
    and pivoting dramatically in approaches during the MVP phase. Even during early
    phases, however, the code can be structured such that it is much easier to decouple
    functionality, abstract away complexity, and create a more testable (and debug-friendly)
    code base.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从原型到脚本的演变是可以理解的。机器学习开发因其无数的变化、需要快速的结果反馈以及在最小可行产品阶段方法上的重大转变而臭名昭著。即使在早期阶段，代码的结构也可以设计得更容易解耦功能、抽象复杂性，并创建一个更容易测试（且易于调试）的代码库。
- en: The way a monolithic production code base comes into being is by shipping a
    prototype to production. This is never advisable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 单一的生产代码库的形成是通过将原型部署到生产环境中实现的。这从来都不是一个明智的选择。
- en: 9.1.2 Walls of text
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 文本墙
- en: If there was one thing that I learned relatively early in my career as a data
    scientist, it was that I truly hate debugging. It wasn’t the act of tracking down
    a bug in my code that frustrated me; rather, it was the process that I had to
    go through to figure out what went wrong in what I was telling the computer to
    do.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果说在我的数据科学家职业生涯早期我学到了什么，那就是我真的很讨厌调试。让我感到沮丧的并不是追踪代码中的错误这一行为，而是为了找出我在告诉计算机做什么时出了什么问题而必须经历的过程。
- en: Like many DS practitioners at the start of their career, when I began working
    on solving problems with software, I would write a lot of declarative code. I
    wrote my solutions much in the way that I logically thought about the problem
    (“I pull my data, then I do some statistical tests, then I make a decision, then
    I manipulate the data, then I put it in a vector, then into a model . . . ”).
    This materialized as a long list of actions that flowed directly, one into another.
    What this programming model meant in the final product was a massive wall of code
    with no separation or isolation of actions, let alone encapsulation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多数据科学从业者在其职业生涯开始时一样，当我开始用软件解决问题时，我会写很多声明性代码。我按照逻辑思考问题的方法来编写解决方案（“我拉取数据，然后进行一些统计测试，然后做出决定，然后操作数据，然后将其放入向量，然后放入模型……”）。这体现为一系列直接依次流动的动作列表。这种编程模型在最终产品中的意义是一个没有分离或隔离动作，更不用说封装的大块代码墙。
- en: Finding the needle in the haystack for any errors in code written in that manner
    is an exercise in pure, unadulterated torture. The architecture of the code was
    not conducive to allowing me to figure out which of the hundreds of steps contained
    therein was causing an issue.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种方式的代码中寻找任何错误就像是在干草堆里找针一样，是一项纯粹且未受污染的折磨。代码的架构并不利于我找出其中数百个步骤中哪一个导致了问题。
- en: Troubleshooting *walls of text* (*WoT*, pronounced *What?!*) is an exercise
    in patience that bears few parallels in depth and requisite effort. If you’re
    the original author of such a display of code, it’s an annoying endeavor (you
    have no one to hate other than yourself for creating the monstrosity), depressing
    activity (see prior comment), and time-consuming slog that can be so easily avoided—provided
    you know how, what, and where to isolate elements within your ML code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 解决“文本墙”（*WoT*，发音为 *What?!*）是一项需要耐心且深度和所需努力很少能与之相比的练习。如果你是这种代码展示的原作者，那么这是一项令人烦恼的任务（你除了自己之外没有其他人可以恨，因为你创造了这个怪物），是一项令人沮丧的活动（参见前面的评论），而且是一项耗时的工作，可以轻易避免——只要你知道如何、在哪里以及如何隔离你机器学习代码中的元素。
- en: If written by someone else, and you’re the unfortunate heir to the code base,
    I extend to you my condolences and a hearty “Welcome to the club.” Perhaps a worthy
    expenditure of your time after fixing the code base would be to mentor the author,
    provide them with an ample reading list, and help them to never produce such rage-inducing
    code again.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码是别人编写的，而您不幸成为了代码库的继承人，我向您表示哀悼，并热情地欢迎您加入“俱乐部”。也许在修复代码库之后，值得您花时间指导作者，提供丰富的阅读清单，并帮助他们永远不再编写如此令人愤怒的代码。
- en: To have a frame of reference for our discussion, let’s take a look at what one
    of these WoTs could look like. While the examples in this section are rather simplistic,
    the intention is to imagine what a complete end-to-end ML project would look like
    in this format, without having to read through hundreds of lines. (I imagine that
    you wouldn’t like to flip through dozens of pages of code in a printed book.)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们讨论有一个参考框架，让我们看看这些长篇大论的脚本之一可能是什么样子。虽然本节中的示例相当简单，但目的是想象一个完整的端到端机器学习项目在这个格式下会是什么样子，而不必阅读数百行代码。（我想您不会喜欢在印刷书籍中翻阅数十页的代码。）
- en: A quick note about the code in listing 9.1
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 关于列表 9.1 中代码的简要说明
- en: The last thing that I’d like to infer by putting this example in this book is
    that I’ve never created code like this. I can assure you that I’ve written far
    more horrifying code early in my career. I’ve written scripts, functions, and
    entire classes filled with methods that are so horrifically bad and impossible
    or confusing to read that upon revisiting my “work” less than two weeks after
    having written it, I couldn’t follow along with what I had created.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这个示例放入本书的最后一个目的是想表明我从未编写过这样的代码。我可以向您保证，在我职业生涯的早期，我写过更多令人毛骨悚然的代码。我编写过脚本、函数和整个类，其中包含的方法非常糟糕，难以阅读，以至于在写完它不到两周后，我无法理解我所创造的内容。
- en: It’s a terrifying feeling when this happens, since for all intents and purposes,
    the original author of code should be the singular person on the planet who can
    figure out how it works. When that fails, whether through complexity or just the
    sheer mountain of code that needs to be modified to make an improvement to the
    code base, I’ve frequently started over from scratch.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，会感到非常可怕，因为从所有意义上讲，代码的原始作者应该是地球上唯一能够弄清楚它是如何工作的那个人。当这一点失败时，无论是由于复杂性还是需要修改的大量代码以改进代码库，我常常是从头开始的。
- en: My intention in showing these examples is to illuminate things that I learned
    the hard way, why they made my life very difficult at the time (missing deadlines,
    angering others when I realized I needed to completely rewrite hundreds upon hundreds
    of lines of code), and how you can learn my hard-earned lessons in a much simpler
    way. Bask in the glory, dear reader, of my previous ineptitude and ignorance,
    and please don’t repeat my mistakes. I promise that you’ll end up thanking me—and
    your future self will thank your present self as well.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我展示这些示例的目的是为了阐明我是如何艰难地学到这些知识的，为什么它们当时让我的生活非常困难（错过截止日期，当我意识到需要完全重写数百行代码时，让其他人感到愤怒），以及您如何以更简单的方式学习我辛苦赚来的教训。亲爱的读者，请沉浸在我过去的无能和无知所带来的荣耀中，请不要重复我的错误。我保证您最终会感谢我——而且您的未来自我也会感谢您的现在自我。
- en: Listing 9.1 presents a relatively simple block of script that is intended to
    be used to determine the nearest standard distribution type to a passed-in series
    of continuous data. The code contains some normalcy checks at the top, comparisons
    to the standard distributions, followed by the generation of a plot.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 展示了一个相对简单的脚本块，该脚本块旨在用于确定传递的连续数据序列最近的标准化分布类型。代码在顶部包含一些正常性检查，然后是标准分布的比较，最后生成一个图表。
- en: NOTE The code examples in this chapter are provided in the accompanying repository
    for this book. However*,* I do *not* recommend that you run them. They take a
    very long time to execute.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中的代码示例提供在本书的配套仓库中。然而，*我不建议*您运行它们。它们执行时间非常长。
- en: Listing 9.1 A wall-of-text script
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.1 一段长篇大论的脚本
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ pval? That’s not a standard naming convention. It should be p_value_shapiro
    or something similar.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ pval？这不是一个标准的命名约定。它应该是 p_value_shapiro 或类似的东西。
- en: ❷ String concatenation is difficult to read, can create issues in execution,
    and requires more things to type. Don’t do it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 字符串连接难以阅读，可能会在执行时出现问题，并且需要输入更多内容。不要这样做。
- en: ❸ Mutating the variable pval makes the original one from shapiro inaccessible
    for future usage. This is a bad habit to adopt and makes more complex code bases
    nigh impossible to follow.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 修改变量 pval 使得原始的 shapiro 变量在未来使用中不可访问。这是一个不好的习惯，使得更复杂的代码库几乎不可能被跟踪。
- en: ❹ With such a general variable name, we have to search through the code to find
    out what this is for.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用这样的通用变量名，我们必须在代码中搜索以找出它是用来做什么的。
- en: ❺ Mutating x here makes sense, but again, we have no indication of what this
    is for.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在这里修改 x 是有意义的，但同样，我们没有指示这是用来做什么的。
- en: ❻ bl? What is that?! Abbreviations don’t help the reader understand what is
    going on.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ bl？那是什么？！缩写并不能帮助读者理解正在发生的事情。
- en: ❼ All of these single-letter variable names are impossible to figure out without
    reverse engineering the code. It may make for concise code, but it’s really hard
    to follow. With a lack of comments, this shorthand becomes difficult to read.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 所有这些单字母变量名在没有逆向工程代码的情况下是无法理解的。这可能会使代码更简洁，但确实很难理解。缺乏注释，这种简写变得难以阅读。
- en: ❽ All of these hardcoded variables (the bins in particular) mean that if this
    needs to be adjusted, the source code needs to be edited. All of this should be
    abstracted in a function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 所有这些硬编码的变量（尤其是这些箱子）意味着如果需要调整，源代码需要被编辑。所有这些都应该在函数中抽象化。
- en: My most sincere apologies for what you just had to look at. Not only is this
    code confusing, dense, and amateurish, but it’s written in such a way that its
    style is approaching intentional obfuscation of functionality.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您刚才不得不看的内容，我表示最诚挚的歉意。这不仅代码令人困惑、密集和业余，而且它的编写方式使得其风格接近于有意混淆功能。
- en: The variable names are horrific. Single-letter values? Extreme shorthand notation
    in variable names? *Why?* It doesn’t make the program run faster. It just makes
    it harder to understand. Tunable values are hardcoded, requiring modification
    of the script for each test, which can be exceedingly prone to errors and typos.
    No stopping points are set in the execution that would make it easy to figure
    out why something isn’t working as intended.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名很糟糕。单字母值？变量名中的极端简写符号？*为什么？* 这并不会使程序运行得更快。它只是使它更难以理解。可调值被硬编码，需要修改脚本以进行每个测试，这可能会极其容易出错和出现打字错误。没有设置停止点，这使得找出为什么某些事情没有按预期工作变得容易。
- en: 9.1.3 Considerations for monolithic scripts
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 单一脚本考虑事项
- en: Aside from being hard to read, listing 9.1’s biggest flaw is that it’s monolithic.
    Although it is a script, the principles of WoT development can apply to both functions
    and methods within classes. This example comes from a notebook, which increasingly
    is the declarative vehicle used to execute ML code, but the concept applies in
    a general sense.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了难以阅读之外，9.1 的最大缺陷是它是单一的。虽然它是一个脚本，但 WoT 开发的原则可以应用于类中的函数和方法。这个例子来自一个笔记本，它越来越多地被用作执行
    ML 代码的声明性载体，但这个概念在一般意义上是适用的。
- en: 'Having too much logic within the bounds of an execution encapsulation creates
    problems (since this is a script run in a notebook, the entire code is one encapsulated
    block). I invite you to think about these issues through the following questions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行封装的范围内包含过多的逻辑会引发问题（因为这是一个在笔记本中运行的脚本，整个代码是一个封装的块）。我邀请您通过以下问题来思考这些问题：
- en: What would it look like if you had to insert new functionality in this block
    of code?
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你必须在这个代码块中插入新功能，那会是什么样子？
- en: Would it be easy to test if your changes are correct?
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你的更改是否正确是否容易？
- en: What if the code threw an exception?
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果代码抛出了异常怎么办？
- en: How would you go about figuring out what went wrong with the code from an exception
    being thrown?
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会如何找出代码抛出异常时出了什么问题？
- en: What if the structure of the data changed? How would you go about updating the
    code to reflect those changes?
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据结构发生了变化？你会如何更新代码以反映这些变化？
- en: Before we get into answering some of these questions, let’s look at what this
    code actually does. Because of the confusing variable names, dense coding structure,
    and tight coupling of references, we would have to run it to figure out what it’s
    doing. The next listing shows the first aspect of listing 9.1.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们回答这些问题之前，让我们看看这段代码实际上做了什么。由于变量名混乱、编码结构密集和引用紧密耦合，我们必须运行它来找出它在做什么。下一个列表显示了
    9.1 列表的第一个方面。
- en: Listing 9.2 Stdout results from listing 9.1 print statements
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 9.1 列表的打印语句的 Stdout 结果
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ That is, perhaps, a few too many significant digits to be useful.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这可能是有一些太多有效数字，以至于没有实际用途。
- en: ❷ These pvalue elements are potentially confusing. Without some sort of explanation
    of what they signify, a user has to look up these tests in the API documentation
    to understand what they are.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这些pvalue元素可能会让人感到困惑。如果没有某种解释说明它们代表什么，用户不得不查阅API文档来理解它们是什么。
- en: ❸ With no explanation about these significances and critical levels, this data
    is meaningless to anyone unfamiliar with the Anderson-Darling test.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 没有关于这些意义和临界水平的解释，这些数据对于不熟悉安德森-达尔林测试的人来说毫无意义。
- en: This code is doing normalcy tests for a univariate series (a column within a
    `DataFrame` here). These are definitely worthwhile tests to conduct on a target
    variable for a regression problem. The image shown in figure 9.2 is the result
    of the first of the plots that are generated by the remainder of the script (apart
    from the very last line).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码正在对一个单变量序列（在这里是一个`DataFrame`中的列）进行正常性测试。这些测试对于回归问题的目标变量来说绝对是有价值的。图9.2中显示的是由脚本剩余部分生成的第一个图表的结果（除了最后一行之外）。
- en: '![09-02](../Images/09-02.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![09-02](../Images/09-02.png)'
- en: Figure 9.2 The first plot that is generated from listing 9.1
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 列表9.1生成的第一个图表
- en: NOTE Chapter 8 covered the power of logging information to MLflow and other
    such utilities, and how bad of an idea it is to print important information to
    stdout. However, this example is the exception. MLflow stands as a comprehensive
    utility tool that aids in model-based experimentation, development, and production
    monitoring. For our example, in which we are performing a one-off validation check,
    utilizing a tool like MLflow is simply not appropriate. If the information that
    we need to see is relevant for only a short period of time (while deciding a particular
    development approach, for instance), maintaining an indefinite persistence of
    this information is confusing and pointless.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：第8章介绍了将日志信息记录到MLflow和其他类似工具的强大功能，以及将重要信息打印到stdout是多么糟糕的想法。然而，这个例子是个例外。MLflow作为一个综合性的工具，有助于基于模型的实验、开发和生产监控。在我们的例子中，我们正在进行一次性的验证检查，使用像MLflow这样的工具显然是不合适的。如果我们需要看到的信息只与短时间内（例如，决定特定的开发方法时）相关，那么保持这种信息的无限期持久性既令人困惑又毫无意义。
- en: Figure 9.3 shows the last plot that is generated from listing 9.1.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3显示了从列表9.1生成的最后一个图表。
- en: '![09-03](../Images/09-03.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![09-03](../Images/09-03.png)'
- en: Figure 9.3 The tacked-on-at-the-end plot generation from listing 9.1
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 列表9.1中附加在末尾的图表生成
- en: This quantile-quantile plot is a similarly useful exploratory aid in determining
    the normalcy (or goodness of fit to different distributions) by plotting the quantile
    values from a series against those of another series. In this example, the quantiles
    of the price series from the dataset are plotted against those of the standard
    normal distribution.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分位数-分位数图是一个同样有用的探索性辅助工具，通过绘制一个序列的分位数值与另一个序列的分位数值来决定正常性（或与不同分布的拟合度）。在这个例子中，数据集的价格序列的分位数被绘制在与标准正态分布的分位数上。
- en: With no callout in the code or indication of what this plot is, however, the
    end user of this script can be left a bit confused about what is going on. It’s
    rarely ever a good practice to place evaluations into code in this manner; they
    are easily overlooked, and users may be perplexed about why they are included
    in that location in the code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果没有在代码中的注释或对这张图的指示，这个脚本的最终用户可能会对正在发生的事情感到有些困惑。将评估放入代码中的这种做法很少是好的实践；它们很容易被忽略，用户可能会对为什么它们会出现在代码的这个位置感到困惑。
- en: Let’s pretend for a moment that we aren’t restricted to the medium of print
    here. Let’s say that instead of a simple statistical analysis of a single target
    variable example, we are looking at a full project written as a monolithic script,
    as was shown in listing 9.1\. Something on the order of, say, 1,500 lines. What
    would happen if the code broke? Can we clearly see and understand everything that’s
    happening in the code in such a format? Where would we begin to troubleshoot the
    issue?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时假设我们不受打印媒介的限制。假设我们不是在分析单个目标变量的简单统计分析示例，而是在查看一个作为单体脚本编写的完整项目，就像列表9.1中所示的那样。比如说，大约有1,500行。如果代码出错了会发生什么？我们能否在这样格式下清楚地看到并理解代码中发生的一切？我们会在哪里开始调试问题？
- en: Isn’t encapsulation of actions just moving around complexity, though?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，封装动作不就是在移动复杂性吗？
- en: Well, yes, and no.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，是的，也不是。
- en: It’s undebatable that if we wrap common functionality of code from within the
    script into functions or methods, the refactoring doesn’t do much for the code
    complexity (the same logic will be processed in the same order as the CPU sees
    it, after all). The refactoring will, however, dramatically reduce the complicated
    nature of the code. It will allow us, the human developers, to see smaller chunks
    of the code, allow us to debug functionality, test that the isolated (encapsulated)
    groupings of code function as we intend them to, and dramatically increase our
    ability to modify the code in the future.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将脚本内的代码的常见功能包装成函数或方法，那么重构对代码复杂性的影响并不大（毕竟，逻辑将按照CPU看到的顺序以相同的顺序处理）。然而，重构将显著减少代码的复杂性。它将使我们，作为人类开发者，能够看到更小的代码块，允许我们调试功能，测试隔离（封装）的代码分组是否按我们的意图工作，并显著提高我们未来修改代码的能力。
- en: 'Converting a script into functional (FP) or object-oriented (OO) code may seem
    like it’s adding complexity: the code will have more lines, will have more elements
    to keep track of, and may be harder for those unfamiliar with FP or OO concepts
    to read the code initially. But once those team members become more fluent with
    the design practices of these paradigms, it will be far easier to maintain a structured
    and isolation-of-functionality design than a giant WoT code base.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本转换为功能性（FP）或面向对象（OO）代码可能看起来像是增加了复杂性：代码将包含更多行，将有更多元素需要跟踪，并且对于那些不熟悉FP或OO概念的人来说，最初阅读代码可能更困难。但一旦团队成员对这些范式的设计实践更加熟练，维护结构化和功能隔离的设计将比维护庞大的WoT代码库要容易得多。
- en: 9.2 Debugging walls of text
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 调试文本墙
- en: If we fast-forward a bit in our theoretical new job, after having seen the state
    of the code base, we’d eventually be in the position of maintaining it. Perhaps
    we were tasked with integrating a new feature into one of the preexisting scripts.
    After reverse engineering the code, and commenting it for our own understanding,
    we progress to putting in the new functionality. The only way, at this point,
    to test our code is to run the entire script.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在理论上快速前进到新工作，在看到代码库的状态后，我们最终将处于维护它的位置。也许我们被分配到将新功能集成到现有脚本之一。在逆向工程代码并为我们自己的理解添加注释后，我们继续添加新功能。在这个阶段，测试我们代码的唯一方法就是运行整个脚本。
- en: We’re inevitably going to have to work through some bugs in the process of changing
    the script to accommodate the new features. If we’re dealing with a script or
    notebook environment with a long list of actions being taken in succession, how
    can we troubleshoot what went wrong with the code? Figure 9.4 shows the troubleshooting
    process that would have to happen to correct an issue in the WoT in listing 9.1.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在将脚本更改为适应新功能的过程中，我们不可避免地会遇到一些错误。如果我们处理的是一个执行一系列操作的脚本或笔记本环境，我们如何调试代码中的错误？图9.4显示了纠正列表9.1中WoT问题的故障排除过程。
- en: '![09-04](../Images/09-04.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![09-04](../Images/09-04.png)'
- en: Figure 9.4 The time-consuming and patience-testing process of binary troubleshooting
    complicates (not necessarily complex) monolithic code bases.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 二进制故障排除的耗时且考验耐心的过程使单体代码库变得复杂（不一定是复杂的）。
- en: This process, as frustrating as it is to go through, is complicated enough without
    having poor variable names and confusing shorthand notation as in listing 9.1\.
    The more difficult the code is to read and follow, the deeper the cognitive load
    required, both to select binary boundary points for isolation while testing the
    code and to figure out which variable states will need to be reported out to stdout.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程虽然进行起来很令人沮丧，但如果没有像列表9.1中的那样糟糕的变量名和令人困惑的缩写符号，就已经足够复杂了。代码越难以阅读和跟踪，在测试代码时选择二进制边界点进行隔离以及确定哪些变量状态需要报告到stdout所需的认知负荷就越大。
- en: This halving process of evaluating and testing portions of the code means that
    we’re having to actually *change the source code to do our testing*. Whether we’re
    adding `print` statements, debugging comments, or commenting out code, a lot of
    work is involved in testing faults with this paradigm. Mistakes will likely be
    made, and there is no guarantee that you won’t add in a new issue through manipulating
    the code in this way.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种评估和测试代码部分的过程意味着我们必须实际上*更改源代码来进行测试*。无论我们是添加`print`语句、调试注释还是注释掉代码，使用这种范式进行故障测试都需要做大量工作。很可能会出错，而且无法保证通过这种方式操作代码不会引入新的问题。
- en: A note on monolithic code
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 关于单体代码的注意事项
- en: Listing 9.1 may seem as though it’s a hyperbolic example of poor development
    practices. You might read through it, scoffing, and think that no one would ever
    write an entire ML solution to a problem in such a way. Before I entered consulting,
    I probably would have thought the same thing.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1可能看起来像是一个夸张的例子，展示了不良的开发实践。你可能会读一遍，嘲笑，并认为没有人会以这种方式编写整个ML解决方案。在我进入咨询之前，我可能也会这样想。
- en: The truth, based on seeing how hundreds of companies’ ML teams develop solutions,
    is that writing code in monolithic blocks is remarkably common. Typically, this
    arises from an isolated DS department that has no outside contact with other members
    of the engineering teams within the company and no one on the team who has worked
    with software developers before. These teams are effectively shipping their prototype
    PoC solutions (which, from an algorithm implementation perspective, do solve the
    problem) to production.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 根据观察数百家公司ML团队开发解决方案的事实，编写单体块代码是非常常见的。通常，这源于一个孤立的DS部门，该部门与公司内其他工程团队的成员没有外部联系，并且团队中没有人与软件开发者合作过。这些团队实际上是在将他们的原型PoC解决方案（从算法实现的角度来看，确实解决了问题）推向生产。
- en: 'In actuality, I’ve seen code bases (which are, for lack of a better term, “running”
    in production with frequent errors and failures) that are far more difficult to
    read than what was shown in listing 9.1\. The large majority of these companies
    that have ML code that looks like this end up doing one of two things:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我见过一些代码库（由于缺乏更好的术语，它们在生产中“运行”，但经常出现错误和故障），它们的可读性比列表9.1中展示的要差得多。这些大多数拥有类似这样ML代码的公司最终会做以下两件事之一：
- en: Hire an expensive consulting firm to refactor the code and make it production
    ready. Your mileage may vary here with respect to the maintainability of their
    solution, the technical sophistication of the consultants, and the total cost
    to hire a quality team to do this.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聘请一家昂贵的咨询公司来重构代码并使其准备好生产。在这里，你可能会根据他们解决方案的可维护性、咨询人员的专业技术水平以及聘请一个高质量团队来完成这项工作的总成本而有所不同。
- en: Keep the code limping along until resourcing limitations (do you really want
    your team constantly fixing the same project code to keep it running?) and the
    cost of constantly fixing it outweighs the benefits that the solution brings,
    thereupon abandoning the project completely.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在资源限制（你真的希望你的团队不断修复相同的项目代码以保持其运行吗？）和不断修复的成本超过解决方案带来的好处之前，让代码艰难地继续运行。在此之后，完全放弃项目。
- en: The intention of calling out these practices is to illuminate the issues with
    developing code like this and to help those who are not aware of why writing code
    like this is a bad idea.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 提出这些做法的目的是阐明像这样开发代码的问题，并帮助那些不了解为什么编写这样的代码是一个坏主意的人。
- en: Surely, there must be a better way to organize code (complex or not) to reduce
    the levels of complication. Listing 9.3 shows an alternative in the form of an
    OO version of the script from listing 9.1.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，组织代码（无论复杂与否）肯定有更好的方法来减少复杂度。列表9.3展示了9.1列表中脚本的一个面向对象版本的替代方案。
- en: 9.3 Designing modular ML code
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 设计模块化ML代码
- en: After going through such a painful exercise of finding, fixing, and validating
    our change to this massive script, we’ve hit our breaking point. We communicate
    to the team that the code’s technical debt is too high, and we need to pay it
    down before any other work continues. Accepting this, the team agrees to breaking
    up the script by functionality, abstracting the complexity into smaller pieces
    that can be understood and tested in isolation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在经历了寻找、修复和验证我们对这个庞大脚本更改的痛苦过程之后，我们达到了临界点。我们向团队传达，代码的技术债务过高，在继续任何其他工作之前，我们需要偿还它。接受这一点后，团队同意根据功能拆分脚本，将复杂性抽象成更小的部分，这些部分可以单独理解和测试。
- en: Before we look at the code, let’s analyze the script to see its main groupings
    of functionality. This functionality-based analysis can help inform what methods
    to create in order to achieve functionality isolation (aiding our ability to troubleshoot,
    test, and insert new features in the future). Figure 9.5 illustrates the core
    functionality contained within the script and how we can extract, encapsulate,
    and create single-purpose code groupings to define what belongs in our methods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看代码之前，让我们分析脚本以查看其主要的功能分组。这种基于功能的分析可以帮助我们了解要创建哪些方法以实现功能隔离（有助于我们将来进行故障排除、测试和插入新功能）。图9.5展示了脚本中包含的核心功能以及我们如何提取、封装和创建单一用途的代码分组来定义我们的方法。
- en: '![09-05](../Images/09-05.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![09-05](../Images/09-05.png)'
- en: Figure 9.5 Code architecture refactoring for listing 9.1
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 列表9.1的代码架构重构
- en: This structural and functional analysis of the code helps us rationalize the
    elements of common functionality. From this inspection, elements are identified,
    isolated, and encapsulated to aid in both legibility (to help us, the humans)
    and maintainability (troubleshooting and extensibility) of the code. Notice the
    private (internal functionality that the end user doesn’t need to use to get value
    from the module) and public (the user-facing methods that will generate specific
    actions from the code based on what they need) methods. Hiding internal functionality
    from users of this module will help reduce the cognitive load placed on the user,
    while minimizing the code complexity as much as possible.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的结构和功能分析帮助我们合理化常见功能的元素。从这个检查中，我们确定了元素，将其隔离并封装，以帮助代码的可读性（帮助我们，人类）和可维护性（故障排除和可扩展性）。注意私有（内部功能，最终用户不需要使用它来从模块中获取值）和公共（面向用户的、基于用户需求从代码中生成特定动作的方法）。隐藏此模块的内部功能将有助于减少用户所承受的认知负荷，同时尽可能减少代码复杂性。
- en: Now that we have a plan for refactoring the code from the nigh-unintelligible
    script into something easier to follow and maintain, let’s look at the final product
    of the refactoring and modularization in the next listing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个计划，将代码从几乎无法理解的脚本重构为更容易遵循和维护的形式，让我们来看看重构和模块化的最终产品，在下一部分列表中。
- en: Listing 9.3 An object-oriented version of the scripted code from listing 9.1
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.3 列表9.1中脚本的对象化版本
- en: '[PRE2]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Encapsulates the entire module as a class since all of the functionality within
    is focused on distribution analysis
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将整个模块封装为一个类，因为其中所有的功能都集中在分布分析上。
- en: ❷ Passes in a **kwargs argument so defined defaults within the class initialization
    method can be overridden with a key-value combination (the script had these all
    hardcoded)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 通过传递**kwargs参数，可以在类初始化方法中定义默认值，并通过键值组合来覆盖这些默认值（脚本中这些都是硬编码的）。
- en: ❸ These values are left as static but could be wrapped into kwargs overrides
    if needed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这些值被保留为静态的，但在需要的情况下可以包装到kwargs覆盖中。
- en: ❹ Private utility method to keep the callee locations cleaner and easier to
    read
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 私有实用方法，以保持调用者位置更干净、更容易阅读。
- en: ❺ A static method is effectively an encapsulated function; no references to
    the initialized arguments are passed into the class, nor are there dependencies
    on any other methods. Most code bases have quite a few of these, and it’s considered
    a better practice than defining global functions to prevent issues with mutable
    state in a global context.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 静态方法实际上是一个封装的函数；没有将初始化参数的引用传递到类中，也没有依赖于任何其他方法。大多数代码库都有很多这样的方法，并且被认为比定义全局函数是一种更好的实践，以防止全局上下文中可变状态的问题。
- en: ❻ Version checks switch statement since the SciPy API changed (a frequent occurrence
    in Python open source libraries as these libraries are improved over time). Newer
    versions of SciPy have protected the access to the distribution listing and have
    created an access method to retrieve them
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 由于SciPy API发生了变化（Python开源库在改进过程中经常发生这种情况），版本检查的switch语句。SciPy的新版本已经保护了分布列表的访问，并创建了一个访问方法来检索它们。
- en: ❼ Method for extracting the parameters from a distribution fit, putting them
    into a dictionary structure (this is known as currying, an eponymous reference
    to Haskell Curry, which condenses complex return types into a single reference
    to make code much cleaner).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 从分布拟合中提取参数的方法，将它们放入字典结构中（这被称为currying，是对Haskell Curry的命名引用，它将复杂的返回类型压缩成一个单一引用，使代码更加简洁）。
- en: ❽ Recall that this exact reference logic was copied multiple times throughout
    listing 9.1\. Providing a single reference to extract this information reduces
    the chances of typo-induced bugs in code, which are frustrating to troubleshoot.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 记住，这个确切的引用逻辑在列表9.1中复制了多次。提供单个引用以提取此信息可以减少代码中因打字错误引起的错误的机会，这些错误在调试时令人沮丧
- en: ❾ Private method to generate the starting and ending points of the generated
    standard histograms through the percent point function (the inverse of the cumulative
    distribution function) for a distribution
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 私有方法通过分布的百分位数函数（累积分布函数的逆函数）生成生成标准直方图的起始和结束点
- en: ❿ Switch logic to handle some distributions requiring only two arguments (location
    and scale), while others require additional arguments
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 切换逻辑用于处理一些只需要两个参数（位置和尺度）的分布，而其他分布则需要额外的参数
- en: ⓫ Private method for building the probability density function (pdf) based on
    the fit parameters found. The switch conditional is due to the varying number
    of arguments among the distribution families.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ⓫ 私有方法基于找到的拟合参数构建概率密度函数（pdf）。条件切换是由于分布家族中参数数量的不同
- en: ⓬ A public method for generating the Q-Q plot comparing the series against the
    standard normal distribution. For future work, this could be expanded or refactored
    to allow plotting against any distribution within scipy.stats.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ⓬ 一个公共方法，用于生成比较系列与标准正态分布的Q-Q图。对于未来的工作，这可以扩展或重构，以允许与scipy.stats中的任何分布进行比较绘图
- en: ⓭ The stdout print functions for reporting on normalcy tests to the three primary
    families. The interpolation here is a bit different than in the script, and the
    human-readable nature of the decision of normalcy based on a passed-in alpha significance
    level makes the final report more interpretable and less prone to error in making
    assumptions about the series.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ⓭ 标准输出打印函数，用于向三个主要家族报告正常性测试。这里的插值与脚本中的插值略有不同，而基于传入的alpha显著性水平的正常性决策的可读性使得最终报告更容易理解，并且更不容易在假设系列时出错
- en: ⓮ A method-private method. Since this functionality is solely intended to make
    the code easier to read and less dense, and has no external uses, making it private
    within this method is a preferred methodology.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ⓮ 一个私有方法。由于此功能仅旨在使代码更容易阅读和更简洁，并且没有外部用途，因此将其作为此方法中的私有方法是首选的方法
- en: ⓯ Private method to score the fit of the histogram of the data series under
    test to the standard histograms in scipy.stats, using SSE
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ⓯ 私有方法用于评估测试数据系列的直方图与scipy.stats中的标准直方图的拟合度，使用SSE（均方误差）
- en: ⓰ Private method for generating the pdf and converting it to a series of data
    points to compare against the raw passed-in data series
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ⓰ 私有方法用于生成pdf（概率密度函数）并将其转换为一系列数据点，以与原始传入的数据系列进行比较
- en: ⓱ Primary raw method for finding the closest (and all other) standard distributions
    to the series passed in. From an end-user perspective, exposing the raw data from
    the results of a module is sometimes worthwhile (often marked as a developer API)
    so that the user can use such data to perform additional actions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ⓱ 寻找与传入系列最接近（以及所有其他）标准分布的主要原始方法。从最终用户的角度来看，暴露模块的结果中的原始数据有时是有价值的（通常标记为开发者API），这样用户就可以使用这些数据执行其他操作。
- en: ⓲ Currying again so we don’t have to return a complex n-valued tuple as a return
    statement. Dictionaries in Python (and case classes in Scala) are preferable to
    positional-encoded return statements to make debugging and end-user experiences
    much more seamless, even if it means more typing for the developer of the module.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ⓲ 再次使用柯里化（Currying），这样我们就不需要返回一个复杂的n值元组作为返回语句。在Python中（以及Scala中的case类）中的字典比位置编码的返回语句更可取，这使得调试和最终用户的使用体验更加无缝，即使这意味着模块开发者需要更多输入
- en: ⓲ Public method for plotting the best fit found to the series data passed in
    for evaluation to the class
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ⓲ 公共方法用于绘制最佳拟合曲线，该曲线与评估过程中传递给类的系列数据进行拟合
- en: ⓴ Additional method to plot all the distributions against the passed-in series
    data as an aid to visualize similarities between standard distributions
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ⓴ 一个额外的公共方法，用于将所有分布与传入的系列数据绘制出来，以帮助可视化标准分布之间的相似性
- en: This code is functionally identical to that of the script. It produces the same
    results in the same amount of runtime and will just-in-time (JIT) compile to the
    exact same byte code as the script in listing 9.1 (minus the additional method
    for plotting all standard reference distributions against the series data). The
    primary difference in this code is in its utility.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在功能上与脚本相同。它在相同的时间内产生相同的结果，并且会即时（JIT）编译成与列表 9.1 中的脚本相同的字节码（除了用于将所有标准参考分布与系列数据对比的附加方法）。这段代码的主要区别在于其实用性。
- en: While there are significantly more lines of code here than in the script, we
    now have isolation in the processing of the core logic of the code. We can walk
    through the code, method by method, to trace any issues that might arise, aiding
    any troubleshooting that may need to be done by a very large degree. We also now
    have the ability to unit test the code. With data mock-ups of predictable and
    readily understandable data, we can verify each of these methods against known
    functionality as a sort of litmus test.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里的代码行数比脚本多得多，但我们现在在处理代码的核心逻辑方面有了隔离。我们可以逐个方法地遍历代码，以追踪可能出现的任何问题，从而极大地帮助进行故障排除。我们现在还有能力对代码进行单元测试。通过预测性和易于理解的数据的模拟，我们可以将这些方法与已知的功能进行验证，作为一种试金石。
- en: 'The benefit of writing code in this manner means that we can, after a single
    up-front investment in slightly more complex development actions, potentially
    save ourselves countless frustrating hours of troubleshooting faults in the code.
    This frees us up to do what we should be doing: *solving business problems*.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式编写代码的好处在于，我们可以在进行一次初步的、稍微复杂一些的开发行动投资之后，可能节省自己无数令人沮丧的故障排除时间。这使我们能够去做我们应该做的事情：*解决商业问题*。
- en: NOTE If this solution were for a real code base, the statistical calculations
    would be put into their own class in a statistics module, while the visualization
    code would be put in another module. All of the methods shown in listing 9.3 are
    collapsed into a single class to make them easier to read in this book.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** 如果这个解决方案是针对真实代码库的，统计计算将被放入统计模块中的自己的类中，而可视化代码将被放入另一个模块中。列表 9.3 中显示的所有方法都被折叠到一个类中，以便在这本书中更容易阅读。'
- en: Machine-readable vs. human-readable code
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性机器代码与可读性人类代码
- en: An important point to bring up about code design and structure is that it’s
    primarily for the benefit of humans and not the machine executing the code. While
    it may seem as though it is more efficient for execution to chain operations together
    in dense and complicated blocks, the truth is that, to the computer, provided
    that the executable logic is the same, the manner in which code is written (with
    respect to functional versus object-oriented versus scripted) is purely for the
    benefit of the people maintaining the code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代码设计和结构的一个重要观点是，它主要是为了人类的利益，而不是执行代码的机器的利益。虽然将操作链在一起以形成密集和复杂的块在执行上可能看起来更有效率，但事实是，对于计算机来说，只要可执行逻辑相同，代码的编写方式（就功能、面向对象和脚本而言）纯粹是为了维护代码的人的利益。
- en: A high-quality code base should read like written text. It should be clear,
    concise, and easy enough to follow by looking at variable, function, method, class,
    and module names and the standard manipulation actions within the language. Someone
    proficient in that programming language should be able to understand the functionality
    of the code as easily as if they were reading a written-text description of the
    code base.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一个高质量的代码库应该像书面文本一样易于阅读。它应该是清晰、简洁的，并且足够容易通过查看变量、函数、方法、类和模块名称以及语言中的标准操作来理解。精通该编程语言的人应该能够像阅读代码库的书面文本描述一样轻松地理解代码的功能。
- en: Shorthand notations, confusing acronyms, and overly dense control flows do no
    one any favors in helping to indicate how code works. After all, to the computer
    executing the byte code that is compiled from your high-level language code, a
    variable named `h` means the same as `standard_distribution_histogram` when referring
    to the same object in memory. The same can’t be said about a human evaluating
    the code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 简写符号、令人困惑的缩写词以及过于密集的控制流程并不能帮助任何人更好地理解代码的工作方式。毕竟，对于执行从您的高级语言代码编译而来的字节码的计算机来说，一个名为
    `h` 的变量在引用内存中的相同对象时与 `standard_distribution_histogram` 意义相同。而对于评估代码的人类来说，情况并非如此。
- en: An entire design philosophy exists for writing code, which is applicable to
    ML project work. Known as *test driven development* (*TDD*), it can help structure
    code solutions in an efficient manner. In the next section, we’ll go through the
    principles of TDD as it applies to ML development.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一种针对编写代码的设计哲学，它适用于机器学习项目工作。被称为*测试驱动开发*（TDD），它可以帮助以高效的方式构建代码解决方案。在下一节中，我们将探讨TDD在机器学习开发中的应用原则。
- en: 9.4 Using test-driven development for ML
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 使用测试驱动开发进行机器学习
- en: As part of the follow-up to the refactoring work that we did for a problematic
    script with our new team, we should probably discuss how to work through MVP development
    in a different way. Many philosophies and patterns of software development have
    been developed over the years, and one that I’ve used and seen work remarkably
    well for ML project work is TDD.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对我们为新团队解决一个有问题的脚本所做重构工作的后续工作，我们可能需要讨论如何以不同的方式处理MVP（最小可行产品）开发。多年来已经发展了许多软件开发哲学和模式，而我使用并看到在机器学习项目工作中特别有效的一个是TDD。
- en: TDD, as a principle, is great for general software development. At its core,
    TDD approaches development efforts by focusing on writing tests first, followed
    by creating a functional and elegant code base to support the passing of those
    tests. It approaches the creation of minimal functionality from the viewpoint
    of, “I need to perform operation *x* that I expect to generate result *y*, so
    I will create a test that asserts *y* and then build the code for *x* that makes
    the *y* test pass.” For most software engineering done today, TDD is considered
    one of the foundational approaches to developing software in an Agile paradigm.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种原则，TDD（测试驱动开发）非常适合通用软件开发。其核心是通过首先编写测试，然后创建一个功能强大且优雅的代码库来支持测试通过，来关注开发工作。它从“我需要执行操作*x*，我期望得到结果*y*，因此我将创建一个断言*y*的测试，然后构建*x*的代码，使得*y*测试通过”的角度来创建最小功能。对于今天大多数软件工程实践，TDD被认为是敏捷范式下软件开发的基础方法之一。
- en: While pure TDD is incredibly challenging as a development strategy for ML use
    cases (particularly if trying to test results from non- or semi-non-deterministic
    algorithms), the basic principles, when applied to ML project work, can dramatically
    improve the functionality, readability, and stability of your code. Your assertions
    may change from the way a traditional software developer would write theirs, but
    the intentions and foundation remain the same. It’s all about having intentional
    and predictable behavior that can be confirmed as functioning correctly during
    your development process.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然纯TDD作为机器学习用例的开发策略极具挑战性（尤其是如果尝试测试非确定性或半非确定性算法的结果），但当应用于机器学习项目工作时，其基本原理可以显著提高代码的功能性、可读性和稳定性。您的断言可能与传统软件开发者编写的方式不同，但意图和基础保持相同。这全部关于在开发过程中有意和可预测的行为，这些行为可以在开发过程中得到验证，以确保其正确性。
- en: When looking at the refactoring that happened between code listings 9.1 and
    9.3, the decisions on where to split out functionality were informed more by the
    question, “How can I test this block of code?” than by, “What looks nice?” Figure
    9.6 covers the thought process that I went through in creating listing 9.3.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看代码列表9.1和9.3之间的重构时，关于在哪里分割功能的决定更多地是由问题“我如何测试这段代码？”而不是“什么看起来不错？”来指导的。图9.6涵盖了我在创建代码列表9.3时经历的思维过程。
- en: '![09-06](../Images/09-06.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![09-06](../Images/09-06.png)'
- en: Figure 9.6 The design process for listing 9.3, focusing on testability and isolable
    code structure
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 列表9.3的设计过程，重点关注可测试性和可隔离的代码结构
- en: Each of the boxes to the right of the leftmost column in figure 9.6 represents
    distinct logical operations that have been separated out for the purposes of testing.
    Breaking up the components in this way enables us to have fewer places that we
    have to search through. We also reduce the code complexity by isolating individual
    functionality, making a complicated series of actions little more than a path
    of complex actions, each stage capable of being checked and validated for proper
    functionality independent of one another.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6左侧列最右侧的每个框代表为测试目的而分离出的不同逻辑操作。以这种方式分解组件使我们能够减少需要搜索的地方。我们还通过隔离单个功能来降低代码复杂性，使得一系列复杂的动作变成了一条复杂的动作路径，每个阶段都能够独立于其他阶段进行检查和验证，以确保其功能正确。
- en: NOTE While writing these examples, I actually wrote listing 9.3 first, and then
    later adapted listing 9.1 from that code. Writing from the perspective of generating
    unit-testable code from the start helps keep your solutions easier to read, modify,
    and, of course, test (or, in this case, convert into a hard-to-read script). When
    getting started in writing abstract code, the process of creating abstraction
    may seem foreign. As with anything else in this profession, you will naturally
    gravitate toward more efficient methods over time. Don’t be discouraged if you
    feel that you are going from script to abstraction in refactoring. Before you
    know it, you’ll be leaving the world of scripting behind.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在编写这些示例时，我实际上首先编写了列表9.3，然后后来从该代码中改编了列表9.1。从一开始就编写可生成单元测试的代码的视角有助于使你的解决方案更容易阅读、修改，当然，测试（或者在这种情况下，将其转换为难以阅读的脚本）。当你开始编写抽象代码时，创建抽象的过程可能看起来很陌生。就像这个职业中的任何其他事情一样，随着时间的推移，你自然会倾向于更有效的方法。如果你觉得你在重构过程中从脚本到抽象的转变感到沮丧，请不要气馁。很快你就会发现自己已经离开了脚本的世界。
- en: To further explain how the thought process in figure 9.6 translates from structural
    design into creating testable code in succinct and isolable groupings of functionality,
    let’s take a look at the private method `_generate_boundaries``()` as an example.
    The following listing shows what a simple unit test for this private method would
    look like.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步解释图9.6中的思维过程是如何从结构设计转化为创建可测试代码的简洁且可隔离的功能分组，让我们以私有方法`_generate_boundaries()`为例。以下列表显示了对此私有方法进行简单单元测试的外观。
- en: Listing 9.4 An example unit test for the _generate_boundaries() method
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 对`_generate_boundaries()`方法的单元测试示例
- en: '[PRE3]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ A unit test definition function for testing the _generate_boundaries() method
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用于测试`_generate_boundaries()`方法的单元测试定义函数
- en: ❷ Static test values that we’re expecting as a result to ensure proper functionality
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们期望作为结果确保正确功能的静态测试值
- en: ❸ Object instantiation of our class DistributionAnalysis()
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们类`DistributionAnalysis()`的对象实例化
- en: ❹ Calls the protected method _generate_boundaries with the lower boundary value
    of 0.01
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用下限值为0.01调用受保护的`_generate_boundaries`方法
- en: ❺ Asserts that the return from the _generate_boundaries method equals our expected
    value
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 断言`_generate_boundaries`方法的返回值等于我们期望的值
- en: ❻ Allows for all tests for the module to be run (in practice, multiple unit
    test functions will be called here). If all tests pass (assertions don’t throw
    assertion exceptions), this script will exit, printing that tests passed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 允许运行模块的所有测试（实际上，这里将调用多个单元测试函数）。如果所有测试都通过（断言不会抛出断言异常），这个脚本将退出，打印测试通过。
- en: In this approach, we’re testing several conditions to ensure that our method
    works as we expect. It’s important to note from this example that, if this block
    of code were not isolated from the remainder of the actions going on in this module,
    it would be incredibly challenging (or impossible) to test. If this portion of
    the code was causing a problem (if one arose) or another tightly coupled action
    that preceded or followed this code, we wouldn’t have any way of determining the
    culprit without modifying the code. However, by separating out this functionality,
    we can test at this boundary and determine whether it is behaving correctly, thereby
    reducing the number of things we need to evaluate if the module does not do what
    it is intended to do.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们测试了几个条件以确保我们的方法按预期工作。重要的是要注意，从这个例子中可以看出，如果这段代码没有从这个模块中其余的动作中隔离出来，那么测试将极其困难（或者不可能）。如果这段代码的部分导致了问题（如果出现了问题）或者另一个与这段代码紧密耦合的动作，我们就没有任何方法来确定罪魁祸首，除非修改代码。然而，通过分离出这个功能，我们可以在这一边界进行测试，并确定它是否表现正确，从而减少我们需要评估的项目数量，如果模块没有按预期工作。
- en: Note Many Python unit-test frameworks exist, each with its own interface and
    behavior (pytest, for instance, relies heavily on fixture annotations). JVM-based
    languages generally rely on standards set by xUnit, which look dramatically different
    from those in Python. The point here is not to use one particular style, but rather
    to write code that is testable and stick to a particular standard of testing.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：存在许多Python单元测试框架，每个框架都有自己的接口和行为（例如，pytest严重依赖于固定装置注释）。基于JVM的语言通常依赖于由xUnit设定的标准，这些标准与Python中的标准截然不同。这里的重点不是使用特定的风格，而是编写可测试的代码并坚持特定的测试标准。
- en: To demonstrate what this paradigm will do for us in practice, let’s see what
    happens when we switch the second assertion statement from equality to non-equality.
    When we run this test suite, we get the following output as an `AssertionError`,
    detailing exactly what (and where) things went wrong with our code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这种范式在实践中将为我们做什么，让我们看看当我们将第二个断言语句从相等切换到非相等时会发生什么。当我们运行这个测试套件时，我们得到以下输出，作为`AssertionError`，详细说明了我们的代码中（以及在哪里）出了什么问题。
- en: Listing 9.5 An intentional unit-test failure
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.5 故意制造的单元测试失败
- en: '[PRE4]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ The caret at the edge of this report shows the line in our unit test that
    failed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 报告边缘的撇号显示了单元测试中失败的行。
- en: ❷ The return of the top-level exception (the AssertionError) and the message
    that we put within the test to ensure we can track down what went wrong
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 顶级异常（`AssertionError`）的返回以及我们在测试中放入的消息，以确保我们可以追踪到出了什么问题
- en: ❸ The actual evaluation that the assertion attempted to perform
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断言尝试执行的实际评估
- en: Designing, writing, and running effective unit tests is absolutely critical
    for production stability, particularly when thinking of future code refactoring
    or extending the functionality of this utility module, since additional work may
    change the way that this method or others that feed data into this module function.
    We do, however, want to know before we merge code into the master (or main) branch
    that the changes being made will not introduce issues to the rest of the methods
    in this module (as well as giving us direct insight into where a problem may lie
    since the functionality is isolated from other code in the module). By having
    this security blanket of knowing that things work as originally intended, we can
    confidently maintain complex (and hopefully not complicated) code bases.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 设计、编写和运行有效的单元测试对于生产稳定性至关重要，尤其是在考虑未来的代码重构或扩展此实用模块的功能时，因为额外的工作可能会改变此方法或其他向此模块提供数据的方法的功能。然而，我们在将代码合并到主分支（或主分支）之前，确实想知道所做的更改不会给此模块中的其他方法引入问题（同时，由于功能与其他模块代码隔离，这还让我们能够直接了解问题可能出在哪里）。通过拥有这种安全网，即知道事情按原意工作，我们可以自信地维护复杂（并且希望不是复杂的）代码库。
- en: NOTE For more information on TDD, I highly encourage you to check out Kent Beck’s
    book, *Test-Driven Development by Example* (Addison-Wesley Professional, 2002).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关TDD的更多信息，我强烈建议您查看Kent Beck的书籍，《通过示例进行测试驱动开发》（Addison-Wesley Professional，2002年）。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Monolithic scripts are not only difficult to read but also force inefficient
    and error-prone debugging techniques.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一脚本不仅难以阅读，而且迫使采用低效且易出错的调试技术。
- en: Large, eagerly evaluated scripts are incredibly challenging in terms of modifying
    behavior and introducing new features. Troubleshooting failures in these becomes
    an exercise in frustration.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型、急切评估的脚本在修改行为和引入新功能方面极具挑战性。在这些脚本中排除故障变成了一种令人沮丧的练习。
- en: Defining logical separation of tasks by using abstraction within an ML code
    base greatly aids legibility for other team members who will need to maintain
    and improve a solution over time.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ML代码库中使用抽象来定义任务逻辑分离，极大地帮助其他团队成员在维护和改进解决方案的过程中提高可读性。
- en: Designing project code architecture to support discrete testable interfaces
    to functionality greatly helps in debugging, feature enhancement work, and continued
    maintenance updates to long-lived ML projects.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计项目代码架构以支持对功能进行离散的可测试接口，这在调试、功能增强工作以及长期ML项目的持续维护更新方面非常有帮助。
