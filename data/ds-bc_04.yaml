- en: 3 Running random simulations in NumPy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 在NumPy中运行随机模拟
- en: This section covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖
- en: Basic usage of the NumPy library
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy库的基本用法
- en: Simulating random observations using NumPy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NumPy模拟随机观察
- en: Visualizing simulated data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化模拟数据
- en: Estimating unknown probabilities from simulated observations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从模拟观察中估计未知概率
- en: NumPy, which stands for Numerical Python, is the engine that powers Pythonic
    data science. Python, despite its many virtues, is simply not suited for large-scale
    numeric analysis. Hence, data scientists must rely on the external NumPy library
    to efficiently manipulate and store numeric data. NumPy is an incredibly powerful
    tool for processing large collections of raw numbers. Thus, many of Python’s external
    data processing libraries are NumPy compatible. One such library is Matplotlib,
    which we introduced in the previous section. Other NumPy-driven libraries are
    discussed in later portions of the book. This section focuses on randomized numerical
    simulations. We will use NumPy to analyze billions of random data points; these
    random observations will allow us to learn hidden probabilities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy，代表数值Python，是驱动Python数据科学的引擎。尽管Python有许多优点，但它并不适合大规模的数值分析。因此，数据科学家必须依赖外部NumPy库来高效地操作和存储数值数据。NumPy是处理大量原始数字的强大工具。因此，许多Python的外部数据处理库都与NumPy兼容。其中一个库是我们在上一节中介绍的Matplotlib。本书后面的部分将讨论其他由NumPy驱动的库。本节重点介绍随机数值模拟。我们将使用NumPy来分析数十亿个随机数据点；这些随机观察将使我们能够学习隐藏的概率。
- en: 3.1 Simulating random coin flips and die rolls using NumPy
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 使用NumPy模拟随机抛硬币和掷骰子
- en: NumPy should already be installed in your working environment as one of the
    Matplotlib requirements. Let’s import NumPy as `np` based on common NumPy usage
    convention.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy应该已经作为Matplotlib的要求之一安装在你的工作环境中。让我们根据NumPy的常用约定导入NumPy为`np`。
- en: Note NumPy can also be installed independently of Matplotlib by calling `pip
    install numpy` from the command line terminal.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意NumPy也可以通过在命令行终端中调用`pip install numpy`独立于Matplotlib进行安装。
- en: Listing 3.1 Importing NumPy
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 导入NumPy
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that NumPy is imported, we can carry out random simulations using the `np.random`
    module. That module is useful for generating random values and simulating random
    processes. For instance, calling `np.random.randint(1, 7)` produces a random integer
    between 1 and 6\. The method chooses from the six possible integers with equal
    likelihood, thus simulating a single roll of a standard die.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经导入了NumPy，我们可以使用`np.random`模块进行随机模拟。该模块用于生成随机值和模拟随机过程。例如，调用`np.random.randint(1,
    7)`会生成一个介于1到6之间的随机整数。该方法从六个可能的整数中以相等的概率进行选择，从而模拟掷一个标准骰子的单次滚动。
- en: Listing 3.2 Simulating a randomly rolled die
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2 模拟掷骰子
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The generated `die_roll` value is random, and its assigned value will vary among
    the readers of this book. The inconsistency could make it difficult to perfectly
    re-create certain random simulations in this section. We need a way of ensuring
    that all our random outputs can be reproduced at home. Conveniently, consistency
    can easily be maintained by calling `np.random.seed(0)`; this method call makes
    sequences of randomly chosen values reproducible. After the call, we can directly
    guarantee that our first three dice rolls will land on values 5, 6, and 1.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`die_roll`值是随机的，其分配的值将在本书的读者之间有所不同。这种不一致性可能会使本节中某些随机模拟的完美重现变得困难。我们需要一种确保我们所有的随机输出都可以在家重现的方法。方便的是，通过调用`np.random.seed(0)`可以轻松地保持一致性；这个方法调用使得随机选择的值序列可重现。调用后，我们可以直接保证我们的前三次骰子滚动将落在值5、6和1上。
- en: Listing 3.3 Seeding reproducible random die rolls
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.3 设置可重现的随机骰子滚动
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Adjusting the inputted `x` into `np.random.randint(0, x)` allows us to simulate
    any number of discrete outcomes. For instance, setting `x` to 52 will simulate
    a randomly drawn card. Alternatively, setting `x` to 2 will simulate a single
    flip of an unbiased coin. Let’s generate that coin flip by calling `np.random.randint(0,
    2)`; this method call returns a random value equal to either 0 or 1\. We assume
    that 0 stands for tails and 1 stands for heads.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将输入的`x`调整为`np.random.randint(0, x)`可以使我们模拟任何数量的离散结果。例如，将`x`设置为52将模拟随机抽取一张牌。或者，将`x`设置为2将模拟掷一枚公平的硬币。让我们通过调用`np.random.randint(0,
    2)`来生成这次硬币翻转；这个方法调用返回一个等于0或1的随机值。我们假设0代表反面，1代表正面。
- en: Listing 3.4 Simulating one fair coin flip
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4 模拟一次公平的硬币翻转
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we simulate a sequence of 10 coin flips and then compute the observed
    frequency of heads.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们模拟10次硬币抛掷，然后计算观察到的正面频率。
- en: Listing 3.5 Simulating 10 fair coin flips
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5 模拟10次公平硬币抛掷
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Note that we can compute the head count more efficiently by running sum(coin_flip_sequence).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注意，我们可以通过运行`sum(coin_flip_sequence)`来更有效地计算正面计数。
- en: The observed frequency is 0.8, which is quite disproportionate to the actual
    probability of heads. However, as we have learned, 10 coin flips will produce
    such extreme frequencies approximately 10% of the time. More coin flips are required
    to estimate the actual probability.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到的频率是0.8，这与实际的正面概率相当不成比例。然而，正如我们所学的，10次硬币抛掷大约有10%的时间会产生这样的极端频率。需要更多的抛掷次数来估计实际概率。
- en: Let’s see what happens when we flip the coin 1,000 times. After each flip, we
    record the total frequency of heads observed in the sequence. Once the coin flips
    are completed, we visualize our output by plotting the coin-flip count versus
    the frequency count (figure 3.1). Our plot also includes a horizontal line along
    the actual probability of 0.5\. We generate that line by calling `plt.axhline(0.5,
    color='k')`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们抛掷1,000次硬币时会发生什么。每次抛掷后，我们记录序列中观察到的总正面频率。一旦硬币抛掷完成，我们通过绘制硬币抛掷次数与频率计数的关系（图3.1）来可视化我们的输出。我们的图表还包括一条沿实际概率0.5的水平线。我们通过调用`plt.axhline(0.5,
    color='k')`来生成这条线。
- en: Listing 3.6 Plotting simulated fair coin-flip frequencies
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6 绘制模拟的公平硬币抛掷频率
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](../Images/03-01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03-01.png)'
- en: Figure 3.1 The number of fair coin flips plotted against the observed head-count
    frequency. The frequency fluctuates wildly before stabilizing at around 0.5.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 公平硬币抛掷次数与观察到的正面计数频率的对比。频率在稳定在大约0.5之前波动得很厉害。
- en: The probability of heads slowly converges to 0.5\. Thus, the law of large numbers
    appears to hold up.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正面的概率缓慢地收敛到0.5。因此，大数定律似乎得到了证实。
- en: 3.1.1 Analyzing biased coin flips
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 分析有偏硬币抛掷
- en: 'We’ve simulated a sequence of unbiased coin flips, but what if we wish to simulate
    a coin that falls on heads 70% of the time? Well, we can generate that biased
    output by calling `np.random.binomial(1, 0.7)`. The binomial method name refers
    to the generic coin-flip distribution, which mathematicians call the *binomial
    distribution*. The method takes as input two parameters: the number of coin flips
    and the probability of the desired coin-flip outcome. The method executes the
    specified number of biased coin flips and then counts the instances when the desired
    outcome was observed. When the number of coin flips is set to 1, the method returns
    a binary value of 0 or 1\. In our case, a value of 1 represents our desired observation
    of heads.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经模拟了一系列无偏硬币抛掷，但如果我们希望模拟一个70%概率落在正面的硬币呢？嗯，我们可以通过调用`np.random.binomial(1, 0.7)`来生成这种有偏输出。二项式方法名称指的是通用的硬币抛掷分布，数学家称之为*二项分布*。该方法接受两个参数：抛掷硬币的次数和期望的硬币抛掷结果概率。该方法执行指定次数的有偏硬币抛掷，然后计算观察到的期望结果出现的实例数。当抛掷硬币的次数设置为1时，该方法返回0或1的二进制值。在我们的情况下，1代表我们期望观察到的正面。
- en: Listing 3.7 Simulating biased coin flips
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7 模拟有偏硬币抛掷
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let’s generate a sequence of 1,000 biased coin flips. We then check if the frequency
    converges to 0.7.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们生成1,000次有偏硬币抛掷的序列。然后我们检查频率是否收敛到0.7。
- en: Listing 3.8 Computing coin-flip-frequency convergence
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.8 计算硬币抛掷频率收敛
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The frequency of heads approximates 0.7 but is not actually equal to 0.7\. In
    fact, the frequency value is 0.003 units smaller than the true probability of
    heads. Suppose we recompute the frequency of 1,000 coin flips five more times.
    Will all the frequencies be lower than 0.7? Will certain frequencies hit the exact
    value of 0.7? We’ll find out by executing `np.random.binomial(1000, 0.7)` over
    five looped iterations.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正面的频率大约为0.7，但并不等于0.7。实际上，频率值比真正的正面概率小0.003个单位。假设我们重新计算1,000次硬币抛掷的频率五次。所有的频率都会低于0.7吗？某些频率会达到精确的0.7值吗？我们将通过执行五次循环迭代的`np.random.binomial(1000,
    0.7)`来找出答案。
- en: Listing 3.9 Recomputing coin-flip-frequency convergence
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.9 重新计算硬币抛掷频率收敛
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ As a reminder, we seeded our random number generator to maintain consistent
    output. Thus, our first pseudorandom sampling will return the previously observed
    frequency of 0.697\. We’ll skip over this result to generate five fresh frequencies.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 作为提醒，我们设置了随机数生成器的种子以保持输出的一致性。因此，我们的第一次伪随机采样将返回之前观察到的频率0.697。我们将跳过这个结果以生成五个新的频率。
- en: Just one of the five iterations produced a measurement that equaled the real
    probability. Twice the measured frequency was slightly too low, and twice it was
    slightly too high. The observed frequency appears to fluctuate over every sampling
    of 1,000 coin flips. It seems that even though the law of large numbers allows
    us to approximate the actual probability, some uncertainty still remains. Data
    science is somewhat messy, and we cannot always be certain of the conclusions
    we draw from our data. Nevertheless, our uncertainty can be measured and contained
    using what mathematicians call a *confidence interval*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 五次迭代中只有一次的测量值等于实际概率。两次测量的频率略低，两次略高。观察到的频率似乎在每次1,000次抛掷的抽样中都会波动。这似乎表明，尽管大数定律允许我们近似实际概率，但仍然存在一些不确定性。数据科学有些混乱，我们并不能总是对我们的数据得出的结论有绝对的把握。然而，我们可以使用数学家所说的*置信区间*来衡量和限制我们的不确定性。
- en: 3.2 Computing confidence intervals using histograms and NumPy arrays
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 使用直方图和NumPy数组计算置信区间
- en: Suppose we’re handed a biased coin whose bias we don’t know. We flip the coin
    1,000 times and observe a frequency of 0.709\. We know the frequency approximates
    the actual probability, but by how much? More precisely, what are the chances
    of the actual probability falling within an interval close to 0.709 (such as an
    interval between 0.7 and 0.71)? To find out, we must do additional sampling.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们得到了一枚我们不知道其偏差的硬币。我们抛掷这枚硬币1,000次，观察到频率为0.709。我们知道频率近似于实际概率，但近似程度是多少？更精确地说，实际概率落在接近0.709的区间（例如0.7和0.71之间的区间）内的概率有多大？为了找出答案，我们必须进行额外的抽样。
- en: We’ve previously sampled our coin over five iterations of 1,000 coin flips each.
    The sampling produced some fluctuations in the frequency. Let’s explore these
    fluctuations by increasing our frequency count from 5 to 500\. We can execute
    this supplementary sampling by running `[np.random.binomial(1000, 0.7) for _ in
    range(500)]`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经对硬币进行了五次1,000次抛掷的迭代抽样。抽样产生了频率的一些波动。让我们通过将频率计数从5增加到500来探索这些波动。我们可以通过运行`[np.random.binomial(1000,
    0.7) for _ in range(500)]`来进行这项补充抽样。
- en: Listing 3.10 Computing frequencies with 500 flips per sample
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.10 每个样本500次抛掷计算频率
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, we can more efficiently sample over 500 iterations by running `np.random.binomial(coin_flip_count,
    0.7, size=500)`. The optional `size` parameter allows us to execute `np.random.binomial(coin_flip_count,
    0.7)` 500 times while using NumPy’s internal optimizations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以通过运行`np.random.binomial(coin_flip_count, 0.7, size=500)`来更有效地在500次迭代中进行抽样。可选的`size`参数允许我们执行`np.random.binomial(coin_flip_count,
    0.7)` 500次，同时使用NumPy的内部优化。
- en: Listing 3.11 Optimizing the coin-flip-frequency computation
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.11 优化抛掷硬币频率的计算
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The output is not a Python list but a NumPy array data structure. As previously
    noted, NumPy arrays can more efficiently store numeric data. The actual numeric
    quantities stored in both `head_count_array` and `head_count_list` remain the
    same. We prove this by converting the array into a list using the `head_count_array.tolist()`
    method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输出不是一个Python列表，而是一个NumPy数组数据结构。正如之前提到的，NumPy数组可以更有效地存储数值数据。`head_count_array`和`head_count_list`中存储的实际数值量保持不变。我们通过使用`head_count_array.tolist()`方法将数组转换为列表来证明这一点。
- en: Listing 3.12 Converting a NumPy array to a Python list
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.12 将NumPy数组转换为Python列表
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Conversely, we can also convert our Python list into a value-equivalent NumPy
    array by calling `np.array(head_count_list)`. The equality between the converted
    array and `head_count_array` can be confirmed using the `np.array_equal` method.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们也可以通过调用`np.array(head_count_list)`将我们的Python列表转换为等价的价值NumPy数组。转换后的数组和`head_count_array`之间的等价性可以使用`np.array_equal`方法来确认。
- en: Listing 3.13 Converting a Python list to a NumPy array
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.13 将Python列表转换为NumPy数组
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Why should we prefer to use a NumPy array over a standard Python list? Well,
    besides the aforementioned memory optimizations and analysis speed-ups, NumPy
    makes it easier to implement clean code. For instance, NumPy offers more straightforward
    multiplication and division. Dividing a NumPy array directly by `x` creates a
    new array whose elements are all divided by `x`. Thus, executing `head_count_array
    / 1000` will automatically transform our head counts into frequencies. By contrast,
    frequency calculation across `head_count_list` requires that we either iterate
    over all elements in the list or use Python’s convoluted `map` function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们应该优先使用NumPy数组而不是标准的Python列表？好吧，除了上述内存优化和分析速度提升之外，NumPy使编写干净的代码变得更加容易。例如，NumPy提供了更直接的乘法和除法。直接将NumPy数组除以`x`会创建一个新的数组，其元素都被除以`x`。因此，执行`head_count_array
    / 1000`将自动将我们的头数转换为频率。相比之下，计算`head_count_list`的频率需要我们遍历列表中的所有元素或使用Python复杂的`map`函数。
- en: Listing 3.14 Computing frequencies using NumPy
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.14 使用NumPy计算频率
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Useful NumPy methods for running random simulations
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的NumPy随机模拟方法
- en: '`np.random.randint(x, y)`—Returns a random integer between `x` and `y-1`, inclusive.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.random.randint(x, y)`—返回一个介于`x`和`y-1`之间的随机整数（包含`y-1`）。'
- en: '`np.random.binomial(1, p)`—Returns a single random value equal to 0 or 1\.
    The probability that the value equals 1 is `p`.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.random.binomial(1, p)`—返回一个等于0或1的单个随机值。该值等于1的概率是`p`。'
- en: '`np.random.binomial(x, p)`—Runs `x` instances of `np.random.binomial (1, p)`
    and returns the summed result. The returned value represents the number of nonzero
    observations across `x` samples.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.random.binomial(x, p)`—运行`x`个`np.random.binomial(1, p)`实例，并返回总和结果。返回值表示`x`个样本中非零观察值的数量。'
- en: '`np.random.binomial(x, p, size=y)`—Returns an array of `y` elements. Each array
    element is equal to a random output of `np.random.binomial(x, p)`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.random.binomial(x, p, size=y)`—返回一个包含`y`个元素的数组。每个数组元素等于`np.random.binomial(x,
    p)`的随机输出。'
- en: '`np.random.binomial(x, p, size=y) / x`—Returns an array of `y` elements. Each
    element represents the frequency of nonzero observations across `x` samples.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.random.binomial(x, p, size=y) / x`—返回一个包含`y`个元素的数组。每个元素代表`x`个样本中非零观察值的频率。'
- en: We’ve converted our head-count array into a frequency array using a simple division
    operation. Let’s explore the contents of `frequency_array` in greater detail.
    We start by outputting the first 20 sampled frequencies using the same `:` index-slicing
    delimiter utilized by Python lists. Note that unlike a printed list, the NumPy
    array does not contain commas in its output.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过简单的除法操作将头数数组转换为频率数组。让我们更详细地探索`frequency_array`的内容。我们首先使用与Python列表相同的`:`索引切片分隔符输出前20个样本频率。请注意，与打印的列表不同，NumPy数组在其输出中不包含逗号。
- en: Listing 3.15 Printing a NumPy frequency array
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.15 打印NumPy频率数组
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The sampled frequencies fluctuate from 0.69 to approximately 0.731\. Of course,
    an additional 480 frequencies remain in `frequency_array`. Let’s extract the minimum
    and maximum array values by calling the `frequency_array.min()` and `frequency_
    array.max()` methods.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 样本频率在0.69到约0.731之间波动。当然，`frequency_array`中还有额外的480个频率。让我们通过调用`frequency_array.min()`和`frequency_array.max()`方法来提取最小和最大数组值。
- en: Listing 3.16 Finding the largest and smallest frequency values
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.16 查找最大和最小频率值
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Somewhere in the frequency range of 0.656 to 0.733 lies the true probability
    of heads. That interval span is noticeably large, with a more than 7% difference
    between the largest and smallest sampled values. Perhaps we can narrow the frequency
    range by plotting all unique frequencies against their occurrence counts (figure
    3.2).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 真实概率的头数位于0.656到0.733的频率范围内。这个区间跨度明显很大，最大和最小样本值之间有超过7%的差异。也许我们可以通过将所有唯一频率与其出现次数（图3.2）相对应来缩小频率范围。
- en: '![](../Images/03-02.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03-02.png)'
- en: Figure 3.2 A scatter plot of 500 head-count frequencies plotted against the
    frequency counts. The frequencies are centered around 0.7\. Certain proximate
    frequencies appear as overlapping dots in the plot.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 500个头数频率的散点图，与频率计数相对应。频率集中在0.7附近。某些接近的频率在图中表现为重叠的点。
- en: Listing 3.17 Plotting measured frequencies
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.17 绘制测量频率
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The visualization is informative: frequencies close to 0.7 occur more commonly
    than other, more distant values. However, our plot is also flawed, since nearly
    identical frequencies appear as overlapping dots in the chart. We should group
    these proximate frequencies together instead of treating them as individual points.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可视化很有信息量：接近 0.7 的频率比其他更远的值更常见。然而，我们的图表也存在缺陷，因为几乎相同的频率在图表中表现为重叠的点。我们应该将这些邻近频率分组在一起，而不是将它们视为单独的点。
- en: 3.2.1 Binning similar points in histogram plots
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 在直方图图中分组相似点
- en: Let’s try a more nuanced visualization by binning together frequencies that
    are in close proximity to each other. We subdivide our frequency range into *N*
    equally spaced bins and then place all frequency values into one of those bins.
    By definition, the values in any given bin are at most 1/*N* units apart. Then
    we count the total values in each bin and visualize the counts using a plot.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一种更细致的视觉化方法，通过将彼此接近的频率分组在一起。我们将频率范围细分为 *N* 个等间距的组，然后将所有频率值放入这些组中的一个。根据定义，任何给定组中的值最多相隔
    1/*N* 个单位。然后我们计算每个组中的总值，并使用图表来可视化这些计数。
- en: The bin-based plot we just described is called a *histogram*. We can generate
    histograms in Matplotlib by calling `plt.hist`. The method takes as input the
    sequence of values to be binned and an optional `bins` parameter, which specifies
    the total number of bins. Thus, calling `plt.hist(frequency_array, bins=77)` will
    split our data across 77 bins, each covering a width of .01 units. Alternatively,
    we can pass in `bins=auto`, and Matplotlib will select an appropriate bin width
    using a common optimization technique (the details of which are beyond the scope
    of this book). Let’s plot a histogram while optimizing bin width by calling `plt.hist(frequency_array,
    bins='auto')` (figure 3.3).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才描述的基于组的图表称为 *直方图*。我们可以通过调用 `plt.hist` 在 Matplotlib 中生成直方图。该方法接受要分组的值的序列和一个可选的
    `bins` 参数，该参数指定总的组数。因此，调用 `plt.hist(frequency_array, bins=77)` 将将我们的数据分布在 77 个组中，每个组覆盖
    0.01 个单位的宽度。或者，我们可以传递 `bins=auto`，Matplotlib 将使用一种常见的优化技术（其细节超出了本书的范围）选择合适的组宽。让我们通过调用
    `plt.hist(frequency_array, bins='auto')`（图 3.3）来优化组宽并绘制直方图。
- en: Note In listing 3.18, we also include an `edgecolor='black'` parameter. This
    helps us visually distinguish the boundaries between bins by coloring the bin
    edges black.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在列表 3.18 中，我们还包括了一个 `edgecolor='black'` 参数。这有助于我们通过将组边框着色为黑色来在视觉上区分组之间的边界。
- en: Listing 3.18 Plotting a frequency histogram using `plt.hist`
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.18 使用 `plt.hist` 绘制频率直方图
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In our plotted histogram, the bin with the highest frequency count falls between
    0.69 and 0.70\. This bin rises noticeably higher than the dozen or so other bins.
    We can obtain a more precise bin count using `counts`, which is a NumPy array
    returned by `plt.hist`. The array holds the y-axis frequency counts for each binned
    group. Let’s call `plt.hist` to return `counts` and subsequently access `counts.size`
    to find the total number of binned groups.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的绘制直方图中，频率计数最高的组位于 0.69 和 0.70 之间。这个组比其他大约十个组明显高。我们可以使用 `counts` 获得更精确的组计数，这是
    `plt.hist` 返回的 NumPy 数组。该数组包含每个分组组的 y 轴频率计数。让我们调用 `plt.hist` 返回 `counts`，然后通过访问
    `counts.size` 来找到分组组的总数。
- en: Listing 3.19 Counting bins in a plotted histogram
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.19 在绘制的直方图中计数组
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ counts is one of three variables returned by plt.hist. The other variables
    are discussed later in this section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `counts` 是 `plt.hist` 返回的三个变量之一。其他变量将在本节后面讨论。
- en: There are 16 bins in the histogram. How wide is each bin? We can find out by
    dividing the total frequency range by 16\. Alternatively, we can use the `bin_edges`
    array, which is the second variable returned by `plt.hist`. This array holds the
    x-axis positions of the vertical bin edges in the plot. Thus, the difference between
    any two consecutive edge positions equals the bin width.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图中有 16 个组。每个组的宽度是多少？我们可以通过将总频率范围除以 16 来找出答案。或者，我们可以使用 `bin_edges` 数组，这是 `plt.hist`
    返回的第二个变量。这个数组包含图表中垂直组边界的 x 轴位置。因此，任何两个连续边界位置之间的差值等于组宽。
- en: Listing 3.20 Finding the width of bins in a histogram
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.20 在直方图中查找组宽
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](../Images/03-03.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03-03.png)'
- en: Figure 3.3 A histogram of 500 binned frequencies plotted against the number
    of elements in each bin. The bin with the most elements is centered around a frequency
    of 0.7.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 500 个分组频率的直方图，与每个组中的元素数量相对应。元素最多的组位于频率 0.7 附近。
- en: 'Note The size of `bin_edges` is always one greater than the size of the `counts`.
    Why is that the case? Imagine if we had only one rectangular bin: it would be
    bounded by two vertical lines. Adding an additional bin would also increase the
    boundary size by 1\. If we extrapolate that logic to *N* bins, then we’d expect
    to see *N* + 1 boundary lines.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`bin_edges` 的大小总是比 `counts` 的大小多一个。这是为什么？想象一下，如果我们只有一个矩形箱子：它将被两条垂直线所界定。添加一个额外的箱子也会增加边界大小
    1。如果我们将这个逻辑外推到 *N* 个箱子，那么我们预计会看到 *N* + 1 条边界线。
- en: The `bin_edges` array can be used in tandem with `counts` to output the element
    count and coverage range for any specified bin. Let’s define an `output_bin_coverage`
    function that prints the count and coverage for any bin at position `i`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 `bin_edges` 数组与 `counts` 结合使用，以输出任何指定箱子的元素计数和覆盖范围。让我们定义一个 `output_bin_coverage`
    函数，该函数打印任何位置 `i` 的箱子的计数和覆盖范围。
- en: Listing 3.21 Getting a bin’s frequency and size
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.21 获取一个箱子的频率和大小
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ A bin at position i contains counts[i] frequencies.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 位置 i 的箱子包含 counts[i] 个频率。
- en: ❷ A bin at position i covers a frequency range of bin_edges[i] through bin_edges[i+1].
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 位置 i 的箱子覆盖的频率范围是从 bin_edges[i] 到 bin_edges[i+1]。
- en: Now, let’s compute the count and frequency range for the highest peak in our
    histogram. For this, we need the index of `counts.max()`. Conveniently, NumPy
    arrays have a built-in `argmax` method, which returns the index of the maximum
    value in an array.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们计算我们直方图中最高的峰值对应的计数和频率范围。为此，我们需要 `counts.max()` 的索引。方便的是，NumPy 数组有一个内置的
    `argmax` 方法，它返回数组中最大值的索引。
- en: Listing 3.22 Finding the index of an array’s maximum value
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.22 查找数组最大值的索引
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Thus, calling `output_bin_coverage(counts.argmax())` should provide us with
    the output we’ve requested.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，调用 `output_bin_coverage(counts.argmax())` 应该会提供我们请求的输出。
- en: Listing 3.23 Using `argmax` to return a histogram’s peak
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.23 使用 `argmax` 返回直方图的峰值
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 3.2.2 Deriving probabilities from histograms
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 从直方图中推导概率
- en: The most-occupied bin in the histogram contains 72 elements and covers a frequency
    range of approximately 0.694 to 0.699\. How can we determine whether the actual
    probability of heads falls within that range (without knowing the answer in advance)?
    One option is to calculate the likelihood that a randomly measured frequency falls
    within 0.694 to 0.699\. If that likelihood were 1.0, then 100% of measured frequencies
    would be covered by the range. These measured frequencies would occasionally include
    the actual probability of heads, so we would be 100% confident that our true probability
    lay somewhere between 0.694 and 0.699\. Even if the likelihood were lower, at
    95%, we would still be fairly confident that the range enclosed our true probability
    value.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在直方图中，最常占据的箱子包含 72 个元素，覆盖的频率范围大约在 0.694 到 0.699 之间。我们如何确定实际的正面概率是否落在这个范围内（在不事先知道答案的情况下）？一个选择是计算随机测量的频率落在
    0.694 到 0.699 之间的可能性。如果这个可能性是 1.0，那么 100% 的测量频率都会被这个范围覆盖。这些测量频率偶尔会包括实际的正面概率，因此我们可以
    100% 确信我们的真实概率位于 0.694 和 0.699 之间。即使可能性较低，在 95% 的情况下，我们仍然可以相当自信地认为这个范围包含了我们的真实概率值。
- en: How should we calculate the likelihood? Earlier, we showed that the likelihood
    of an interval equals its area under a curve, but only when the total plotted
    area sums to 1.0\. The area under our histogram is greater than 1.0 and thus must
    be modified by passing `density=True` into `plt.hist`. The passed parameter maintains
    the histogram’s shape while forcing its area’s sum to equal 1.0.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何计算可能性？之前，我们展示了区间可能性的等于曲线下的面积，但只有当总绘制的面积加起来等于 1.0 时。我们直方图下的面积大于 1.0，因此必须通过将
    `density=True` 传递给 `plt.hist` 来修改它。传递的参数保持直方图的形状，同时强制其面积的总和等于 1.0。
- en: Listing 3.24 Plotting a histogram’s relative likelihoods
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.24 绘制直方图的相对可能性
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The binned counts have now been replaced by relative likelihoods, which are
    stored in the `likelihoods` array (figure 3.4). As we’ve discussed, *relative
    likelihood* is a term applied to the y-values of a plot whose area sums to 1.0\.
    Of course, the area beneath our histogram now sums to 1.0\. We can prove this
    by summing the rectangular area of each bin, which equals the bin’s vertical likelihood
    value multiplied by `bin_width`. Hence, the area beneath the histogram is equal
    to the summed likelihoods multiplied by `bin_width`. Consequently, calling `likelihoods.sum()
    * bin_width` should return an area of 1.0.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已将分箱计数替换为相对似然性，这些似然性存储在`likelihoods`数组中（图3.4）。正如我们讨论的，*相对似然性*是一个应用于面积总和为1.0的图表y值的术语。当然，我们直方图下的面积现在总和为1.0。我们可以通过求和每个区间的矩形面积来证明这一点，这等于区间的垂直似然值乘以`bin_width`。因此，直方图下的面积等于总和似然性乘以`bin_width`。因此，调用`likelihoods.sum()
    * bin_width`应该返回面积为1.0。
- en: '![](../Images/03-04.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/03-04.png)'
- en: Figure 3.4 A histogram of 500 binned frequencies plotted against their associated
    relative likelihoods. The area of the histogram sums to 1.0\. That area can be
    computed by summing over the rectangular areas of each bin.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 500个分箱频率的直方图，与它们相关的相对似然性绘制。直方图的面积总和为1.0。该面积可以通过对每个区间的矩形面积求和来计算。
- en: Note The total area equals the summed rectangle areas in the histogram. In figure
    3.4, the length of the longest rectangles is quite large, so we visually estimate
    that the total area is greater than 1.0.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：总面积等于直方图中矩形面积的总和。在图3.4中，最长矩形的长度相当大，所以我们直观地估计总面积大于1.0。
- en: Listing 3.25 Computing the total area under a histogram
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.25 计算直方图下的总面积
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The histogram’s total area sums to 1.0\. Thus, the area beneath the histogram’s
    peak now equals the probability of a randomly sampled frequency falling within
    the 0.694 to 0.699 interval range. Let’s compute this value by calculating the
    area of the bin positioned at `likelihoods.argmax()`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图的总面积等于1.0。因此，直方图峰值下的面积现在等于随机采样频率落在0.694到0.699区间范围内的概率。让我们通过计算位于`likelihoods.argmax()`的区间的面积来计算这个值。
- en: Listing 3.26 Computing the probability of the peak frequencies
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.26 计算峰值频率的概率
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The probability is approximately 14%. That value is low, but we can increase
    it by expanding our interval range beyond one bin. We stretch the range to cover
    neighboring bins at indices `likelihoods.argmax() - 1` and `likelihoods.argmax()
    + 1`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 概率大约为14%。这个值较低，但我们可以通过将区间范围扩展到超过一个区间来增加它。我们将范围扩展以覆盖索引为`likelihoods.argmax()
    - 1`和`likelihoods.argmax() + 1`的相邻区间。
- en: Note As a reminder, Python’s indexing notation is inclusive of the start index
    and exclusive of the end index. Hence, we set the end index to equal `likelihoods.argmax()
    + 2` to include `likelihoods.argmax() + 1`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了提醒，Python的索引表示法包含起始索引，但不包含结束索引。因此，我们将结束索引设置为等于`likelihoods.argmax() + 2`，以便包括`likelihoods.argmax()
    + 1`。
- en: Listing 3.27 Increasing the probability of a frequency range
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.27 增加频率范围的概率
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The three bins cover a frequency range of approximately 0.689 to 0.704\. Their
    associated probability is 0.464\. Thus, the three bins represent what statisticians
    call a 46.4% *confidence interval*, which means we are 46.4% confident that our
    true probability falls within the three-bin range. That confidence percentage
    is too low. Statisticians prefer a confidence interval of 95% or more. We reach
    that confidence interval by iteratively expanding our leftmost bin and rightmost
    bin until the interval area stretches past 0.95.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 三个区间覆盖的频率范围大约为0.689到0.704。它们相关的概率是0.464。因此，这三个区间代表了统计学家所说的46.4%的*置信区间*，这意味着我们有46.4%的信心认为我们的真实概率落在三个区间的范围内。这个置信百分比太低。统计学家更喜欢95%或更高的置信区间。我们通过迭代扩展最左侧的区间和最右侧的区间，直到区间面积超过0.95，以达到这个置信区间。
- en: Listing 3.28 Computing a high confidence interval
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.28 计算高置信区间
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The frequency range of roughly 0.670 to 0.723 represents a 95.4% confidence
    interval. Thus, a sampled sequence of 1,000 biased coin flips should fall within
    that range 95.4% of the time. We’re fairly confident that the true probability
    lies somewhere between 0.670 and 0.723\. However, we still cannot tell for sure
    whether the true probability is closer to 0.67 or 0.72\. We need to somehow narrow
    that range to obtain a more informative probability estimation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 大约为0.670到0.723的频率范围代表95.4%置信区间。因此，1,000次有偏硬币翻转的样本序列应该有95.4%的时间落在该范围内。我们有相当大的信心认为真实概率位于0.670和0.723之间。然而，我们仍然不能确定真实概率更接近0.67还是0.72。我们需要以某种方式缩小这个范围以获得更准确的概率估计。
- en: 3.2.3 Shrinking the range of a high confidence interval
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 缩小高置信区间的范围
- en: How can we taper down our range while maintaining a 95% confidence interval?
    Perhaps we should try elevating the frequency count from 500 to something noticeably
    larger. Previously, we’ve sampled 500 frequencies, where each frequency represented
    1,000 biased coin flips. Instead, let’s sample 100,000 frequencies while keeping
    the coin-flip count constant at 1,000.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何缩小范围同时保持95%的置信区间？或许我们应该尝试将频率计数从500提升到一个明显更大的数值。之前，我们已经采样了500个频率，其中每个频率代表1,000次有偏硬币翻转。相反，让我们采样10万个频率，同时保持硬币翻转次数恒定在1,000次。
- en: Listing 3.29 Sampling 100,000 frequencies
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.29 采样10万个频率
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We will recompute the histogram on the updated `frequency_array`, which now
    holds 200-fold more frequency elements. Then we visualize that histogram while
    also searching for a high confidence interval. Let’s incorporate the confidence
    interval into our visualization by coloring the histogram bars in its range (figure
    3.5). The histogram bars can be visually modified by relying on `patches`, which
    is the third variable returned by `plt.hist`. The graphical details of each bin
    at index `i` are accessible through `patches[i]`. If we wish to color the *i*th
    bin yellow, we can simply call `patches[i].set_facecolor('yellow')`. In this manner,
    we can highlight all the specified histogram bars that fall within the updated
    interval range.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在更新的`frequency_array`上重新计算直方图，该数组现在包含200倍更多的频率元素。然后我们可视化该直方图，同时寻找高置信区间。让我们通过将直方图条形在其范围内着色来将置信区间纳入我们的可视化（图3.5）。可以通过依赖于`patches`来修改直方图条形，这是`plt.hist`返回的第三个变量。可以通过`patches[i]`访问索引`i`处的每个箱子的图形细节。如果我们想将第*i*个箱子的颜色设置为黄色，我们可以简单地调用`patches[i].set_facecolor('yellow')`。以这种方式，我们可以突出显示所有位于更新后的区间范围内的指定直方图条形。
- en: '![](../Images/03-05.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-05.png)'
- en: Figure 3.5 A histogram of 100,000 binned frequencies plotted against their associated
    relative likelihoods. Highlighted bars delineate the 95% confidence interval,
    which represents 95% of the histogram’s area. That interval covers a frequency
    range of roughly 0.670–0.727.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 将10万个分箱频率绘制在与它们相关的相对似然性上。高亮条表示95%置信区间，该区间代表直方图面积的95%。该区间覆盖的频率范围大约为0.670–0.727。
- en: Listing 3.30 Coloring histogram bars over an interval
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.30 在区间上着色直方图条形
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The recomputed histogram resembles a symmetric bell-shaped curve. Many of its
    bars have been highlighted using the `set_facecolor` method. The highlighted bars
    represent a 95% confidence interval. The interval covers a frequency range of
    roughly 0.670 to 0.727\. This new frequency range is nearly identical to the one
    we saw before: increasing the frequency sample size did not reduce the range.
    Perhaps we should also increase the number of coin flips per frequency sample
    from 1,000 to 50,000 (figure 3.6). We keep the frequency sample size steady at
    100,000, thus leading to 5 billion flipped coins.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 重新计算后的直方图类似于对称的钟形曲线。许多条形使用`set_facecolor`方法进行了高亮。高亮条形代表95%置信区间。该区间覆盖的频率范围大约为0.670到0.727。这个新的频率范围几乎与我们之前看到的一样：增加频率样本大小并没有减少范围。也许我们也应该将每个频率样本的硬币翻转次数从1,000增加到50,000（图3.6）。我们保持频率样本大小稳定在100,000，因此导致50亿次翻转硬币。
- en: Listing 3.31 Sampling 5 billion flipped coins
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.31 采样50亿次翻转硬币
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![](../Images/03-06.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/03-06.png)'
- en: Figure 3.6 A histogram of 100,000 binned frequencies plotted against their associated
    relative likelihoods. Highlighted bars delineate the 95% confidence interval,
    which represents 95% of the histogram’s area. That interval covers a frequency
    range of roughly 0.695–0.703.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 将10万个分箱频率绘制在与它们相关的相对似然性上。高亮条表示95%置信区间，该区间代表直方图面积的95%。该区间覆盖的频率范围大约为0.695–0.703。
- en: The new 95.06% confidence interval covers a frequency range of roughly 0.695
    to 0.703\. If we round the range to two decimal places, it equals 0.70 to 0.70\.
    We are thus exceedingly confident that our true probability is approximately 0.70\.
    By increasing the coin flips per sample, we’ve successfully narrowed the range
    of our 95% confidence interval.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 新的95.06%置信区间覆盖了大约0.695到0.703的频率范围。如果我们把这个范围四舍五入到两位小数，它等于0.70到0.70。因此，我们非常确信我们的真实概率大约是0.70。通过增加每个样本的抛硬币次数，我们已经成功缩小了95%置信区间的范围。
- en: 'On a separate note, our updated histogram once again resembles a bell-shaped
    curve. That curve is referred to as either the *Gaussian distribution* or the
    *normal distribution*. The normal distribution is incredibly important to probability
    theory and statistics due to the *central limit theorem*. According to this theorem,
    sampled frequency distributions take the shape of a normal distribution when the
    number of samples is large. Furthermore, the theorem predicts a narrowing of likely
    frequencies as the size of each frequency sample increases. This is perfectly
    consistent with our observations, which are summarized here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们更新的直方图再次呈现出类似钟形曲线。这条曲线被称为**高斯分布**或**正态分布**。正态分布由于**中心极限定理**在概率论和统计学中非常重要。根据这个定理，当样本数量大时，样本频率分布呈现出正态分布的形状。此外，该定理预测随着每个频率样本大小的增加，可能的频率范围会变窄。这与我们的观察完全一致，总结如下：
- en: Initially, we sampled 1,000 coin flips 500 times.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最初，我们进行了500次1,000次抛硬币的采样。
- en: Each sequence of 1,000 coin flips was converted to a frequency.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个包含1,000次抛硬币的序列被转换为一个频率。
- en: We plotted the histogram of 500 frequencies representing 50,000 total coin flips.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们绘制了表示50,000次总抛硬币次数的500个频率的直方图。
- en: The histogram shape was not symmetric. It peaked at approximately 0.7.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直方图形状不对称。它在大约0.7处达到峰值。
- en: We increased the frequency count from 500 to 100,000.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将频率计数从500增加到100,000。
- en: We plotted the histogram of 100,000 frequencies representing 1 million total
    coin flips.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们绘制了表示1,000,000次总抛硬币次数的100,000个频率的直方图。
- en: The new histogram’s shape resembled a normal curve. It continued peaking at
    0.7.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的直方图形状类似于正态曲线。它继续在0.7处达到峰值。
- en: We summed the rectangular area of bins around the peak. We stopped once the
    added bins covered 95% of the area under the histogram.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们计算了围绕峰值周围的矩形bin面积的总和。一旦添加的bin覆盖了直方图下方的95%面积，我们就停止了计算。
- en: These bins represented a frequency range of approximately 0.670–0.723.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些bin代表了大约0.670–0.723的频率范围。
- en: We increased the coin flips per sample from 1,000 to 50,000.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将每个样本的抛硬币次数从1,000增加到50,000。
- en: We plotted the histogram of 100,000 frequencies representing 5 billion total
    coin flips.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们绘制了表示50亿次总抛硬币次数的100,000个频率的直方图。
- en: The updated histogram’s shape continued to resemble a normal curve.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新后的直方图的形状继续类似于正态曲线。
- en: We recomputed the range covering 95% of the histogram’s area.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重新计算了覆盖直方图95%面积的区间。
- en: The range width shrank to approximately 0.695–0.703.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 范围宽度缩小到大约0.695–0.703。
- en: Thus, when we increased our per-frequency flip count, the range of likely frequencies
    began to narrow at around 0.7\.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，当我们增加每次频率的抛硬币次数时，可能的频率范围开始在大约0.7处变窄。
- en: 3.2.4 Computing histograms in NumPy
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.4 在NumPy中计算直方图
- en: 'Calling the `plt.hist` method automatically generates a histogram plot. Can
    we obtain the histogram likelihoods and bin edges without creating a plot? Yes,
    because `plt.hist` uses NumPy’s non-visual `np.histogram` function. This function
    takes as input all parameters that don’t relate to histogram visualization, such
    as `frequency_arrays`, `bins= ''auto''`, and `density=True`. It then returns two
    variables not associated with plot manipulation: `likelihoods` and `bin_edges`.
    Therefore, we can run `compute_high_ confidence_interval` while bypassing visualization
    simply by calling `np.histogram`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`plt.hist`方法会自动生成直方图。我们能否在不创建图表的情况下获得直方图似然性和bin边缘？是的，因为`plt.hist`使用NumPy的非可视化`np.histogram`函数。此函数接受所有与直方图可视化无关的参数，例如`frequency_arrays`、`bins='auto'`和`density=True`。然后它返回两个与绘图操作无关的变量：`likelihoods`和`bin_edges`。因此，我们可以通过调用`np.histogram`来运行`compute_high_confidence_interval`，而无需进行可视化。
- en: Listing 3.32 Computing a histogram using `np.histogram`
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.32 使用`np.histogram`计算直方图
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ We no longer store the start and end index variables returned by this function
    since there is no longer a need to highlight an interval range in a histogram
    plot.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们不再存储此函数返回的起始和结束索引变量，因为不再需要在直方图图中突出显示一个区间范围。
- en: Useful histogram functions
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的直方图函数
- en: '`plt.hist(data, bins=10)`—Plots a histogram in which the elements of `data`
    are distributed across 10 equally spaced bins.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plt.hist(data, bins=10)`—绘制一个直方图，其中`data`的元素分布在10个等间距的箱中。'
- en: '`plt.hist(data, bins=''auto'')`—Plots a histogram whose bin count is determined
    automatically, based on the data distribution. `auto` is the default setting of
    `_bins`.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plt.hist(data, bins=''auto'')`—绘制一个直方图，其箱计数根据数据分布自动确定。`auto`是`_bins`的默认设置。'
- en: '`plt.hist(data, edges=''black'')`—In the plotted histogram, the edges of each
    bin are marked by black vertical lines.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plt.hist(data, edges=''black'')`—在绘制的直方图中，每个箱的边界由黑色垂直线标记。'
- en: '`counts, _, _ = plt.hist(data)`—The `counts` array is the first of the three
    variables returned by `plt.hist`. It holds the count of elements contained in
    each bin. These counts appear on the y-axis of the histogram plot.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`counts, _, _ = plt.hist(data)`—`counts`数组是`plt.hist`返回的三个变量中的第一个。它包含了每个箱中包含的元素计数。这些计数出现在直方图图的y轴上。'
- en: '`_, bin_edges, _ = plt.hist(data)`—The `bin_edges` array is the second of the
    three variables returned by `plt.hist`. It holds the x-axis positions of the vertical
    bin edges in the plot. Subtracting `bin_edges[i]` from `bin_edges[i + 1]` returns
    the width of every bin. Multiplying the width by `counts[i]` returns the area
    of the rectangular bin at position `i`.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_, bin_edges, _ = plt.hist(data)`—`bin_edges`数组是`plt.hist`返回的三个变量中的第二个。它包含了图表中垂直箱边界的x轴位置。从`bin_edges[i]`减去`bin_edges[i
    + 1]`可以得到每个箱的宽度。将宽度乘以`counts[i]`可以得到位置为`i`的矩形箱的面积。'
- en: '`likelihoods, _, _ = plt.hist(data, density=True)`—The binned counts are transformed
    into likelihoods so that the area beneath the histogram sums to 1.0\. Thus, the
    histogram is transformed into a probability distribution. Multiplying the bin
    width by `likelihoods[i]` returns the probability of a random outcome falling
    within a range of `bin_edges[i]` - `bin_edges[i +1]`.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`likelihoods, _, _ = plt.hist(data, density=True)`—将箱计数转换为似然值，使得直方图下方的面积总和为1.0。因此，直方图被转换成概率分布。将箱宽度乘以`likelihoods[i]`可以得到随机结果落在`bin_edges[i]`
    - `bin_edges[i +1]`范围内的概率。'
- en: '`_, _, patches = plt.hist(data)`—The `patches` list is the third of the three
    variables returned by `plt.hist`. The graphical settings of each bin at index
    `i` are stored in `patches[i]`. Calling `patches[i].set_facecolor(''yellow'')`
    changes the color of the histogram bin at position `i`.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_, _, patches = plt.hist(data)`—`patches`列表是`plt.hist`返回的三个变量中的第三个。每个索引`i`的箱的图形设置存储在`patches[i]`中。调用`patches[i].set_facecolor(''yellow'')`可以改变位置为`i`的直方图箱的颜色。'
- en: '`likelihoods, bin_edges = np.histogram(data, density=True)`—Returns the histogram
    likelihoods and bin edges without actually plotting the results.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`likelihoods, bin_edges = np.histogram(data, density=True)`—返回直方图似然值和箱边界，而不实际绘制结果。'
- en: 3.3  Using confidence intervals to analyze a biased deck of cards
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 使用置信区间分析有偏见的牌组
- en: Suppose you’re shown a biased 52-card deck. Each card is either red or black,
    but the color counts aren’t equal. How many red cards are present in the deck?
    You could find out by counting all the red cards one by one, but that would be
    too easy. Let’s add a constraint to make the problem more interesting. You are
    only allowed to see the first card in the deck! If you wish to see a new card,
    you must first reshuffle. You’re permitted to reshuffle as many times as you like
    and to view the top card after each shuffle.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被展示了一个有偏见的52张牌的牌组。每张牌要么是红色要么是黑色，但颜色的数量并不相等。牌组中存在多少张红牌？你可以逐个计数所有红牌，但这会太简单了。让我们添加一个约束条件，使问题更有趣。你只能看到牌组中的第一张牌！如果你想要看到一张新牌，你必须首先洗牌。你可以随意洗牌，并在每次洗牌后查看顶部的牌。
- en: Given these constraints, we must solve the problem using random sampling. Let’s
    begin by modeling a 52-card deck with an unknown number of red cards. That red
    count is an integer between 0 and 52, which we can generate using `np.random.randint`.
    We’ll keep the value of our random `red_card_count` value hidden until we’ve found
    a solution using sampling.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这些约束条件，我们必须使用随机抽样来解决问题。让我们首先用未知数量的红牌来模拟一个52张牌的牌组。这个红牌数量是一个介于0到52之间的整数，我们可以使用`np.random.randint`来生成。我们将隐藏我们的随机`red_card_count`值，直到我们通过抽样找到解决方案。
- en: Listing 3.33 Generating a random red card count
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.33 生成随机红牌计数
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now let’s compute `black_card_count` by using the constraint that `red_card_count`
    and `black_card_count` must sum to 52 cards total. We also maintain bias by ensuring
    that the two counts are not equal.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过使用约束条件`red_card_count`和`black_card_count`的总和必须等于52张牌来计算`black_card_count`。我们还通过确保两个计数不相等来维持偏差。
- en: Listing 3.34 Generating a black card count
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.34 生成黑牌计数
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'During the modeling phase, we’ll shuffle the deck and flip over the first card.
    What is the probability the card will be red? Well, a red card represents one
    of two possible outcomes: red or black. These outcomes can be characterized by
    the sample space `{''red_card'', ''black_card''}`, but only when the two outcomes
    are equally likely. However, in our biased deck, the outcomes are weighted by
    `red_card_count` and `black_card_count`. A weighted sample space `dict` is therefore
    required, in which the dictionary values equal the count variables. We label the
    associated keys `''red_card''` and `''black_card''`. Passing `weighted_sample_space`
    into `compute_event_probability` will allow us to compute the probability of drawing
    a red card.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在建模阶段，我们将洗牌并翻转第一张牌。这张牌是红色的概率是多少？嗯，红牌代表两种可能的结果之一：红色或黑色。这些结果可以通过样本空间`{'red_card',
    'black_card'}`来描述，但只有当两种结果等可能时。然而，在我们的偏差牌组中，结果是通过`red_card_count`和`black_card_count`加权的。因此，需要一个加权的样本空间`dict`，其中字典值等于计数变量。我们用`'red_card'`和`'black_card'`标记相关的键。将`weighted_sample_space`传递给`compute_event_probability`函数将允许我们计算抽到红牌的概率。
- en: Listing 3.35 Computing card probabilities using a sample space
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.35 使用样本空间计算牌的概率
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As a reminder, the `compute_event_probability` function divides the `red_card_count`
    variable by the sum of `red_card_count` and `black_card_count` to compute the
    probability. Furthermore, the sum of `red_card_count` and `black_card_count` is
    equal to `total_cards`. Therefore, the probability of drawing a red card is equal
    to `red_ card_count` divided by `total_cards`. Let’s verify that.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，`compute_event_probability`函数通过将`red_card_count`变量除以`red_card_count`和`black_card_count`的总和来计算概率。此外，`red_card_count`和`black_card_count`的总和等于`total_cards`。因此，抽到红牌的概率等于`red_card_count`除以`total_cards`。让我们验证这一点。
- en: Listing 3.36 Computing card probabilities using division
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.36 使用除法计算牌的概率
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'How should we utilize `prob_red` to model a flipped-over first card? Well,
    the card flip will produce one of two possible outputs: red or black. These two
    outcomes can be modeled as coin flips in which heads and tails are replaced by
    colors. Therefore, we can model the flipped card using the binomial distribution.
    Calling `np.random.binomial (1, prob_red)` returns 1 if the first card is red
    and 0 otherwise.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何利用`prob_red`来模拟翻到的第一张牌？嗯，牌翻转将产生两种可能的结果之一：红色或黑色。这两种结果可以建模为硬币翻转，其中正面和反面被颜色所取代。因此，我们可以使用二项分布来模拟翻转的牌。调用`np.random.binomial(1,
    prob_red)`如果第一张牌是红色则返回1，否则返回0。
- en: Listing 3.37 Simulating a random card
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.37 模拟一张随机牌
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We shuffle the deck 10 times and flip over the first card after each shuffle.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将牌组洗10次，并在每次洗牌后翻转第一张牌。
- en: Listing 3.38 Simulating 10 random cards
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.38 模拟10张随机牌
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A red card appeared at the top of the deck in 8 out of 10 random shuffles. Does
    this mean that 80% of the cards are red? Of course not. We’ve previously shown
    how such outcomes are common when the sampling size is low. Instead of shuffling
    the deck 10 times, let’s shuffle it 50,000 times. Then we compute the frequency
    and then redo the shuffling procedure another 100,000 times. We execute these
    steps by calling `np.random .binomial(50000, prob_red, 100000)` and dividing by
    50,000\. The resulting frequency array can be transformed into a histogram that
    will allow us to compute a 95% confidence interval for flipping over a red card.
    We compute the confidence interval by expanding the range of bins around the histogram’s
    peak until that range covers 95% of the histogram’s area.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在10次随机洗牌中，红牌出现在牌顶的有8次。这难道意味着80%的牌是红色的吗？当然不是。我们之前已经展示了当抽样规模较小时，这样的结果是很常见的。与其洗牌10次，不如洗牌50,000次。然后我们计算频率，然后再将洗牌过程重复100,000次。我们通过调用`np.random.binomial(50000,
    prob_red, 100000)`并除以50,000来执行这些步骤。结果频率数组可以被转换成直方图，这将允许我们计算翻到红牌的95%置信区间。我们通过扩展直方图峰值周围的bin范围，直到该范围覆盖直方图面积的95%来计算置信区间。
- en: Listing 3.39 Computing card probability confidence intervals
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.39 计算牌概率置信区间
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Counts the observed red cards out of 50,000 shuffles; repeats 100,000 times
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算在50,000次洗牌中观察到的红牌数量；重复100,000次
- en: ❷ Converts 100,000 red counts into 100,000 frequencies
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将100,000个红色计数转换为100,000个频率
- en: ❸ Computes the frequency histogram
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算频率直方图
- en: ❹ Computes the 95% confidence interval for the histogram
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 计算直方图的95%置信区间
- en: We are very confident that `prob_red` lies between 0.842865 and 0.849139\. We
    also know that `prob_red` equals `red_card_count / total_cards`, and therefore
    `red_card_ count` equals `prob_red * total_cards`. Thus, we are highly confident
    that `red_card_ count` lies between `0.842865 * total_cards` and `0.849139 * total_cards`.
    Let’s compute the likely range of `red_card_count`. We round the end points of
    the range to the nearest integers because `red_card_count` corresponds to an integer
    value.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常确信`prob_red`位于0.842865和0.849139之间。我们还知道`prob_red`等于`red_card_count / total_cards`，因此`red_card_count`等于`prob_red
    * total_cards`。因此，我们有很高的信心认为`red_card_count`位于`0.842865 * total_cards`和`0.849139
    * total_cards`之间。让我们计算`red_card_count`的可能范围。我们将范围端点四舍五入到最接近的整数，因为`red_card_count`对应一个整数值。
- en: Listing 3.40 Estimating the red card count
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.40 估计红色牌的数量
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We are very confident that there are 44 red cards in the deck. Let’s check if
    our solution is correct.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常确信牌堆中有44张红色牌。让我们检查我们的解决方案是否正确。
- en: Listing 3.41 Validating the red card count
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.41 验证红色牌的数量
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There are indeed 44 red cards in the deck. We were able to determine this without
    manually counting all the cards. Our use of random card-shuffle sampling and confidence
    interval calculations proved sufficient to uncover the solution.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 确实有44张红色牌在牌堆中。我们没有手动数所有牌就能确定这一点。我们使用随机牌洗抽样和置信区间计算来揭示解决方案是足够的。
- en: 3.4 Using permutations to shuffle cards
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 使用排列来洗牌
- en: Card shuffling requires us to randomly reorder the elements of a card deck.
    That random reordering can be carried out using the `np.random.shuffle` method.
    The function takes as input an ordered array or list and shuffles its elements
    in place. The following code randomly shuffles a deck of cards containing two
    red cards (represented by 1s) and two black cards (represented by 0s).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 洗牌需要我们随机重新排列牌堆的元素。这种随机重新排列可以使用`np.random.shuffle`方法来实现。该函数接受一个有序数组或列表作为输入，就地打乱其元素。以下代码随机洗牌一个包含两张红色牌（用1表示）和两张黑色牌（用0表示）的牌堆。
- en: Listing 3.42 Shuffling a four-card deck
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.42 洗牌四张牌的牌堆
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The shuffle method has rearranged the elements in `card_deck`. If we prefer
    to carry out the shuffle while retaining a copy of the original unshuffled deck,
    we can do so using `np.random.permutation`. The method returns a NumPy array containing
    a random ordering of cards. Meanwhile, the elements of the original inputted deck
    remain unchanged.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 洗牌方法已经重新排列了`card_deck`中的元素。如果我们希望在保留原始未洗牌牌堆副本的同时进行洗牌，我们可以使用`np.random.permutation`。该方法返回一个包含随机排列的牌的NumPy数组。同时，原始输入的牌堆元素保持不变。
- en: Listing 3.43 Returning a copy of the shuffled deck
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.43 返回洗牌牌堆的副本
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The random ordering of elements returned by `np.random.permutation` is mathematically
    called a *permutation*. Random permutations vary from the original ordering most
    of the time. On rare occasions, they may equal the original, unshuffled permutation.
    What is the probability that a shuffled permutation will exactly equal `unshuffled_deck`?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.random.permutation`返回的元素随机排列在数学上称为排列。随机排列通常与原始顺序不同。在罕见的情况下，它们可能与原始的未洗牌排列相等。洗牌排列恰好等于`unshuffled_deck`的概率是多少？'
- en: 'We can of course find out through sampling. However, the four-element deck
    is small enough to be analyzed using sample spaces. Composing the sample space
    requires us to cycle through all possible permutations of the deck. We can do
    so using the `itertools.permutations` function. Calling `itertools.permutations(unshuffled_deck)`
    will return an iterable over every possible permutation of the deck. Let’s use
    the function to output the first three permutations. Note that these permutations
    are printed as Python tuples, not as arrays or lists. Tuples, unlike arrays or
    lists, cannot be modified in place: they are represented using parentheses.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以通过抽样来找出答案。然而，四元素牌堆足够小，可以使用样本空间来分析。组成样本空间需要我们遍历牌堆的所有可能的排列。我们可以使用`itertools.permutations`函数来实现。调用`itertools.permutations(unshuffled_deck)`将返回一个遍历牌堆所有可能排列的可迭代对象。让我们使用这个函数来输出前三个排列。请注意，这些排列以Python元组的形式打印出来，而不是数组或列表。与数组或列表不同，元组不能就地修改：它们使用括号表示。
- en: Listing 3.44 Iterating over card permutations
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.44 遍历牌排列
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first two generated permutations are identical to each other. Why is that
    the case? Well, the first permutation is just the original `unshuffled_deck` with
    no rearranged elements. Meanwhile, the second permutation was generated by swapping
    the third and fourth elements of the first permutation. However, both those elements
    were zeros, so the swap did not impact the list. We can confirm that the swap
    actually took place by examining the first three permutations of `[0, 1, 2, 3]`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的第一个和第二个排列是相同的。这是为什么？好吧，第一个排列只是原始的`unshuffled_deck`，没有任何重新排列的元素。同时，第二个排列是通过交换第一个排列的第三和第四个元素生成的。然而，这两个元素都是零，所以交换没有影响列表。我们可以通过检查`[0,
    1, 2, 3]`的前三个排列来确认交换实际上已经发生。
- en: Listing 3.45 Monitoring permutation swaps
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.45 监控排列交换
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Certain permutations of the four-card deck occur more than once. Thus, we can
    hypothesize that certain permutations might occur more frequently than others.
    Let’s check this hypothesis by storing the permutation counts in a `weighted_sample_space`
    dictionary.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 四张牌的某些排列出现不止一次。因此，我们可以假设某些排列可能比其他排列更频繁地出现。让我们通过将排列计数存储在`weighted_sample_space`字典中来检验这个假设。
- en: Listing 3.46 Computing permutation counts
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.46 计算排列计数
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: All the permutations occur with equal frequency. Consequently, all card arrangements
    are equally likely, and a weighted sample space is not required. An unweighted
    sample space equal to `set(itertools.permutations(unshuffled_deck))` should sufficiently
    resolve the problem.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的排列以相同的频率发生。因此，所有的牌排列都是等可能的，不需要加权样本空间。一个等于`set(itertools.permutations(unshuffled_deck))`的未加权样本空间应该足以解决该问题。
- en: Listing 3.47 Computing permutation probabilities
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.47 计算排列概率
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ The unweighted sample space equals the set of all the unique permutations
    of the deck.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 未加权的样本空间等于牌组所有唯一排列的集合。
- en: ❷ Defines a lambda function that takes as input some x and returns True if x
    equals our unshuffled deck. This one-line lambda function serves as our event
    condition.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义一个lambda函数，该函数接受一些x作为输入，如果x等于我们的未洗牌的牌组则返回True。这个单行lambda函数作为我们的事件条件。
- en: ❸ Computes the probability of observing an event that satisfies our event condition
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算满足我们事件条件的事件的概率
- en: 'Suppose we are handed a generic `unshuffled_deck` of size *N* containing *N*/2
    red cards. Mathematically, it can be shown that all the color permutations of
    the deck will occur with equal likelihood. Thus, we can compute probabilities
    directly using the deck’s unweighted sample space. Unfortunately, creating this
    sample space is not feasible for a 52-card deck since the number of possible permutations
    is astronomically large: 8.06 × 10^(67), which is larger than the number of atoms
    on Earth. If we attempted to compute a 52-card sample space, our program would
    run for many days before eventually running out of memory. However, such a sample
    space can easily be computed for a smaller 10-card deck.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们得到了一个包含*N*/2张红牌的通用`unshuffled_deck`，大小为*N*。从数学上可以证明，牌组的所有颜色排列将以相同的可能性发生。因此，我们可以直接使用牌组的未加权样本空间来计算概率。不幸的是，对于52张牌的牌组来说，创建这样的样本空间是不切实际的，因为可能的排列数量是天文数字：8.06
    × 10^(67)，这比地球上的原子数量还要多。如果我们尝试计算一个52张牌的样本空间，我们的程序将运行很多天，最终耗尽内存。然而，对于较小的10张牌牌组，这样的样本空间可以很容易地计算出来。
- en: Listing 3.48 Computing a 10-card sample space
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.48 计算一个10张牌的样本空间
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We have been tasked with finding the best strategy for drawing a red card.
    The 10-card `sample_space` set could prove useful in these efforts: the set allows
    us to compute the probabilities of various competing strategies directly. We can
    thus rank our strategies based on their 10-card deck performance and then apply
    the top-ranking strategies to a 52-card deck.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是找到绘制红牌的最佳策略。10张牌的`sample_space`集合可能在这些努力中很有用：这个集合允许我们直接计算各种竞争策略的概率。因此，我们可以根据它们10张牌牌组的性能来排名我们的策略，然后将排名最高的策略应用到52张牌的牌组中。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The `np.random.binomial` method can simulate random coin flips. The method gets
    its name from the *binomial distribution*, which is a generic distribution that
    captures coin-flip probabilities.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.random.binomial`方法可以模拟随机抛硬币。这个方法的名字来源于**二项分布**，这是一个通用的分布，它捕捉了抛硬币的概率。'
- en: When a coin is flipped repeatedly, its frequency of heads converges toward the
    actual probability of heads. However, the final frequency may differ slightly
    from the actual probability.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当硬币反复抛掷时，其出现正面的频率会趋向于实际的正面概率。然而，最终频率可能略有不同。
- en: We can visualize the variability of recorded coin-flip frequencies by plotting
    a *histogram*. A histogram shows binned counts of observed numeric values. The
    counts can be transformed into relative likelihoods so that the area beneath the
    histogram sums to 1.0\. Effectively, the transformed histogram becomes a probability
    distribution. The area around the distribution’s peak represents a *confidence
    interval*. A confidence interval is the likelihood that an unknown probability
    falls within a certain frequency range. Generally, we prefer a confidence interval
    that is at 95% or higher.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过绘制*直方图*来可视化记录的抛硬币频率的变异性。直方图显示了观察到的数值的分组计数。这些计数可以转换为相对可能性，使得直方图下方的面积总和为1.0。实际上，转换后的直方图变成了一个概率分布。分布峰值周围的面积代表一个*置信区间*。置信区间是未知概率落在某个频率范围内的可能性。通常，我们更喜欢95%或更高的置信区间。
- en: The shape of a frequency histogram resembles a bell-shaped curve when the number
    of sampled frequencies is high. That curve is referred to as either the *Gaussian
    distribution* or the *normal distribution*. According to the *central limit theorem*,
    the 95% confidence interval associated with the bell curve becomes narrower as
    the size of each frequency sample increases.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当样本频率的数量很高时，频率直方图的形状类似于钟形曲线。这条曲线被称为*高斯分布*或*正态分布*。根据*中心极限定理*，与钟形曲线相关的95%置信区间随着每个频率样本大小的增加而变窄。
- en: Simulated card shuffles can be carried out using the `np.random.permutation`
    method. This method returns a random permutation of the inputted deck of cards.
    The *permutation* represents a random ordering of card elements. We can iterate
    over every possible permutation by calling `itertools.permutations`. Iterating
    over all the permutations for a 52-card deck is computationally impossible. However,
    we can easily capture all the permutations of a smaller 10-card deck. These permutations
    can be used to compute the small deck’s sample space.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟洗牌可以通过使用`np.random.permutation`方法来实现。此方法返回输入牌组的一个随机排列。*排列*代表卡片元素的随机顺序。我们可以通过调用`itertools.permutations`来遍历所有可能的排列。遍历一副52张牌的所有排列在计算上是不可行的。然而，我们可以轻松地捕获一副较小10张牌的所有排列。这些排列可以用来计算小牌组的样本空间。
