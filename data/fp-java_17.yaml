- en: Appendix C. Where to go from here
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录C. 从这里开始去哪里
- en: You’ve now had some experience writing functional programs in Java. The extent
    to which you apply what you’ve learned to everyday Java programming is up to you.
    Aiming to be 100% functional is probably too much for many Java programmers. Using
    fully functional I/O, for example, is probably not something that every reader
    will want to do in their production code. But if you want to adopt the functional
    programming paradigm for professional projects, you have choices to make.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经有了一些在 Java 中编写函数式程序的经验。你将把学到的东西应用到日常 Java 编程中的程度取决于你自己。试图做到 100% 函数式可能对许多
    Java 程序员来说太多了一些。例如，使用完全函数式的 I/O，可能不是每个读者都希望在他们的生产代码中做的事情。但如果你想在专业项目中采用函数式编程范式，你有选择。
- en: C.1\. Choosing a new language
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.1\. 选择一门新语言
- en: 'The first choice is the language you’ll use. Often, choosing a different (more
    functional-friendly) language isn’t an option. But sometimes it is. We’ve only
    scratched the surface of the subject, and with the right tools you can go much
    further. Choosing a functional language may seem complex, but it’s not. Switching
    to a different language will only be interesting if you choose a much more powerful
    language in the domain. If you’ve read this book and want to go further, you won’t
    be interested in a weakly typed language. So you have three possible choices:
    Haskell, Scala, and Kotlin (or possibly a fourth, Frege).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选择是你要使用的语言。通常，选择不同的（更友好的函数式语言）并不是一个选项。但有时是。我们只是触及了这个主题的表面，有了合适的工具，你可以走得更远。选择一种函数式语言可能看起来很复杂，但实际上并不复杂。如果你选择了一个在该领域更强大的语言，切换到另一种语言才会变得有趣。如果你已经阅读了这本书并想更进一步，你不会对弱类型语言感兴趣。所以你有三种可能的选择：Haskell、Scala
    和 Kotlin（或者可能是第四种，Frege）。
- en: C.1.1\. Haskell
  id: totrans-4
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.1.1\. Haskell
- en: 'Haskell is the de facto standard language for functional programming. Haskell
    is a strongly typed, lazy functional language, with nearly all the features an
    aspiring functional programmer might dream of, and many more-sophisticated features
    that you’ll have trouble understanding at first. Most of the modern articles and
    books about functional programming use Haskell for their examples. Moreover, they
    use a specific version of Haskell: the Glasgow Haskell Compiler (GHC).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell 是函数式编程的事实标准语言。Haskell 是一种强类型、惰性函数式语言，拥有几乎所有有抱负的函数式程序员可能梦想拥有的特性，以及许多你一开始难以理解的更复杂特性。大多数关于函数式编程的现代文章和书籍都使用
    Haskell 作为示例。此外，它们使用的是 Haskell 的特定版本：格拉斯哥 Haskell 编译器（GHC）。
- en: Whether or not you get to pick the language of your choice, which is unlikely
    if you work in a team or if you have to use legacy code, learning Haskell will
    be profitable. When you use Java to write functional programs, you often have
    to fight against the language. Using Haskell, you’ll have to fight against it
    to write imperative programs. Learning Haskell will train your mind into functional
    thinking like no other language can do. Even if you continue using Java, prototyping
    functions with Haskell is really rewarding.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否能选择你喜欢的语言，如果你在一个团队工作或者必须使用遗留代码，这通常是不可能的，学习 Haskell 将是有益的。当你使用 Java 编写函数式程序时，你经常不得不与语言本身作斗争。使用
    Haskell，你将不得不与之作斗争来编写命令式程序。学习 Haskell 将训练你的思维进入一种只有其他语言无法做到的函数式思维。即使你继续使用 Java，用
    Haskell 原型化函数也是非常有益的。
- en: The main problem with Haskell (for a Java programmer) is that everything is
    new. You won’t be able to use any of your regular Java tools (besides your code
    editor) or any of the numerous libraries you’ve been used to. Of course, there
    are lots of Haskell libraries, but you’ll have to learn everything anew, including
    how to find, download, and manage them, how to build your programs, how to handle
    documentation, and everything else.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Java 程序员来说，Haskell 的主要问题在于一切都是新的。你将无法使用你习惯的任何常规 Java 工具（除了代码编辑器）或你习惯的众多库。当然，有很多
    Haskell 库，但你将不得不从头开始学习一切，包括如何查找、下载和管理它们，如何构建你的程序，如何处理文档，以及其他所有事情。
- en: C.1.2\. Scala
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.1.2\. Scala
- en: Another solution is to switch to Scala. Scala is not a strictly functional language.
    With Scala, you can write programs in both imperative and functional styles. Switching
    to Scala is easy because you can write Scala programs with a Java-like design,
    much as it was possible, when Java first appeared, to write Java programs exactly
    as C programs were written. Of course, this isn’t the best way to go, and many
    of the problems we have in Java are due to this C heritage. And as more and more
    Java programmers switch to Scala, we’ll see more and more imperative programs
    written in this language.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案是切换到 Scala。Scala 不是一个严格的功能性语言。使用 Scala，你可以以命令式和函数式风格编写程序。切换到 Scala 很容易，因为你可以用类似
    Java 的设计编写 Scala 程序，就像 Java 首次出现时，可以像编写 C 程序一样编写 Java 程序。当然，这不是最好的方法，我们许多在 Java
    中的问题都源于这种 C 遗产。随着越来越多的 Java 程序员转向 Scala，我们将看到越来越多的命令式程序用这种语言编写。
- en: As a result, writing functional programs in Scala is a discipline, but nearly
    nothing is missing (if you use some advanced functional libraries). And the great
    advantage is that you’ll be able to reuse most of what you know. You can write
    Scala programs in Eclipse, NetBeans, or IntelliJ. Although Scala has its own build
    tool (sbt), you can build Scala programs with Gradle, or even with Maven or Ant
    (although who would ever want to do this?). Moreover, you can use all the existing
    Java libraries from a Scala program. (And, of course, Scala libraries can be used
    from Java.) These features make Scala a good first choice if you need to deal
    with legacy Java code and tools.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 Scala 中编写函数式程序是一种纪律，但几乎没有什么缺失（如果你使用一些高级函数库）。巨大的优势是，你将能够重用你大部分已知的知识。你可以在
    Eclipse、NetBeans 或 IntelliJ 中编写 Scala 程序。尽管 Scala 有自己的构建工具（sbt），但你也可以使用 Gradle
    构建 Scala 程序，甚至可以使用 Maven 或 Ant（尽管没有人会想这样做？）。此外，你可以在 Scala 程序中使用所有现有的 Java 库。（当然，Scala
    库也可以从 Java 中使用。）这些特性使得 Scala 成为处理遗留 Java 代码和工具时的一个很好的首选。
- en: C.1.3\. Kotlin
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.1.3\. Kotlin
- en: Kotlin is a new language designed by JetBrains, the publisher of the IntelliJ
    IDE, which is the best IDE for Java as well as many other languages. Kotlin is
    what Java should have become. It has many functional-friendly features such as
    function types (allowing you to write `(A) -> (B) -> C` instead of `Function<A,
    Function<B, C>>`), data classes (automatically generating constructors, accessors,
    and `equals` and `hashCode` methods), and implicit method calls (allowing you
    to call a function as `f(x)` instead of the more verbose Java syntax `f.apply(x)`).
    Moreover, Kotlin is fully compatible with Java, and it’s possible to mix Java
    and Kotlin in the same project. Since nothing is perfect (yet!), Kotlin has no
    functional collections (meaning immutable, persistent, and data-sharing), but
    uses the Java standard collections with a special mechanism—*extension functions*—that
    allows you to “add” methods to existing classes. (In fact, it allows calling static
    methods as if they were instance methods and using the `this` reference to refer
    to the “extended” instance.) Kotlin is so well integrated with Java that it’s
    possible to start by adding a Kotlin class to a Java project. All you have to
    do is modify your build system to add Kotlin compilation. And for development,
    even that isn’t necessary because IntelliJ allows compiling and running mixed
    Java/Kotlin projects transparently. As of this writing, Kotlin is in version 1.0.5,
    so many things will change in the near future. Version 1.1 is in beta and should
    be available by the time you read this. This is really something you should look
    at if you’re interested in functional programming in the Java ecosystem.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 是由 IntelliJ IDE 的出版商 JetBrains 设计的一种新语言，IntelliJ IDE 是 Java 以及许多其他语言的最佳
    IDE。Kotlin 是 Java 应该成为的样子。它拥有许多功能友好的特性，例如函数类型（允许你编写 `(A) -> (B) -> C` 而不是 `Function<A,
    Function<B, C>>`），数据类（自动生成构造函数、访问器以及 `equals` 和 `hashCode` 方法），以及隐式方法调用（允许你以 `f(x)`
    的形式调用函数，而不是更冗长的 Java 语法 `f.apply(x)`）。此外，Kotlin 与 Java 完全兼容，可以在同一个项目中混合使用 Java
    和 Kotlin。由于（目前）没有什么完美的事物，Kotlin 没有功能集合（意味着不可变、持久和共享数据的集合），但它使用特殊的机制——*扩展函数*——来使用
    Java 标准集合。实际上，它允许以实例方法的方式调用静态方法，并使用 `this` 引用来引用“扩展”的实例。Kotlin 与 Java 的集成如此紧密，以至于你可以从向
    Java 项目添加 Kotlin 类开始。你只需修改你的构建系统以添加 Kotlin 编译即可。对于开发来说，甚至这也不是必需的，因为 IntelliJ 允许透明地编译和运行混合的
    Java/Kotlin 项目。截至本文撰写时，Kotlin 的版本是 1.0.5，因此在未来会有很多变化。版本 1.1 正在测试中，你应该在阅读本文时就可以使用。如果你对
    Java 生态系统中的函数式编程感兴趣，这真的是你应该关注的事情。
- en: C.1.4\. Frege
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.1.4\. Frege
- en: Another promising solution is the Frege language (named after the German mathematician
    and philosopher Gottlob Frege, and pronounced somewhat like “frey-guh”). Frege
    is a very young language and might not be mature enough for production code, but
    it’s evolving rapidly and could become the language of choice for pure functional
    programming on the JVM. Frege is in fact “Haskell on the JVM.” It’s as close to
    Haskell as it can be, while retaining the possibility of using all existing Java
    libraries. Because it can mix with Java (like Scala can), it’s a very good choice
    for a smooth transition. And if you decide to learn Haskell or Kotlin as a prototyping
    language, why not also use Frege? You can find more information about Frege at
    [https://github.com/Frege/fregeandhttp://fregepl.blogspot.fr/](https://github.com/Frege/fregeandhttp://fregepl.blogspot.fr/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有潜力的解决方案是弗雷格语言（以德国数学家和哲学家戈特洛布·弗雷格的名字命名，发音类似于“frey-guh”）。弗雷格是一种非常年轻的语言，可能还不够成熟，不适合用于生产代码，但它正在快速发展，并可能成为JVM上纯函数式编程的首选语言。弗雷格实际上是“JVM上的Haskell”。它与Haskell尽可能接近，同时保留了使用所有现有Java库的可能性。因为它可以与Java混合（就像Scala一样），所以它是一个很好的平滑过渡选择。而且，如果你决定学习Haskell或Kotlin作为原型设计语言，为什么不也使用弗雷格呢？你可以在[https://github.com/Frege/fregeandhttp://fregepl.blogspot.fr/](https://github.com/Frege/fregeandhttp://fregepl.blogspot.fr/)找到更多关于弗雷格的信息。
- en: C.1.5\. What about dynamically typed functional languages?
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.1.5. 动态类型函数式语言怎么样？
- en: Dynamically typed functional languages are different from the previous ones
    because, instead of relying on the type system to help the programmer write correct
    programs, they free the programmer from the tyranny of types, allowing them to
    write ill-typed programs that compile.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型函数式语言与之前的语言不同，因为它们不是依赖于类型系统来帮助程序员编写正确的程序，而是让程序员摆脱类型的束缚，允许他们编写类型错误的程序，这些程序可以编译。
- en: 'To make this sound like a benefit, such languages are often called “Dynamically
    typed languages.” Everyone knows that being dynamic is better than being static,
    so it should be a quality feature. Unfortunately, these languages would be better
    called “weakly typed” in contrast with “strongly typed” languages such as Java,
    Haskell, or Scala. This isn’t to say that weakly typed languages are bad. They
    just have a very important difference: if you mess with the types, you won’t generally
    be warned by the compiler. The program will only crash at runtime. This is a choice.
    See for yourself.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这种语言听起来像是一种好处，这类语言通常被称为“动态类型语言”。众所周知，动态类型比静态类型更好，所以这应该是一个质量特性。不幸的是，与Java、Haskell或Scala等“强类型”语言相比，这些语言最好被称为“弱类型”语言。这并不是说弱类型语言不好。它们只是有一个非常重要的区别：如果你与类型搞混，编译器通常不会警告你。程序只会在运行时崩溃。这是一个选择。你自己看看吧。
- en: C.2\. Staying with Java
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.2. Staying with Java
- en: You could stick to Java. To make the transition from learning the functional
    paradigm to applying it in Java production code, you’ll need a Java functional
    library. You can use the one you developed while reading this book, but you need
    to be aware that maintaining a library is a huge task. If you’re the only user,
    this is probably the best choice, because you’ll be able to tailor the library
    to your own needs. Every time you discover a new function that could be abstracted
    into the library, you’ll be free to do it. But if you’re working in a team, it’s
    another story. You’ll have to take care of everyone’s needs, be careful you don’t
    break anything, and be backward compatible at all times. This is a really heavy
    job.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择坚持使用Java。为了从学习函数式范式过渡到将其应用于Java生产代码，你需要一个Java函数式库。你可以使用你在阅读这本书时开发的库，但你需要意识到维护一个库是一项巨大的任务。如果你是唯一的用户，这可能是最好的选择，因为你可以根据你的需求定制库。每次你发现一个可以抽象到库中的新函数时，你都可以自由地这样做。但如果你在一个团队中工作，那就另当别论了。你必须照顾到每个人的需求，小心不要破坏任何东西，并且始终保持向后兼容。这是一项非常繁重的工作。
- en: The alternative is to use one of the existing open source libraries developed
    and tested by many people. You won’t have the same freedom to add new features
    you might need, but you’ll be productive in no time. And if you really want a
    new feature, you can add it yourself and propose it to the community.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用由许多人开发和测试的现有开源库。你不会拥有添加所需新功能的相同自由度，但你很快就能变得高效。而且，如果你真的需要新功能，你可以自己添加并提议给社区。
- en: C.2.1\. Functional Java
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.2.1. 函数式Java
- en: Functional Java was one of the earliest open source Java functional libraries
    that’s still in use. It predates Java 8 and was first written using anonymous
    classes to represent functions. It’s probably the functional library with the
    most fundamentalist approach. This is a good thing if you aim to become a fundamentalist
    functional programmer yourself. And even if you don’t, using it and looking at
    how it’s coded is a very rewarding experience. Note, however, that the documentation
    is scarce. You’ll have to figure out by yourself how to use it, although what
    you’ve learned in this book will help you greatly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式Java是早期使用至今的开源Java函数式库之一。它早于Java 8，最初是用匿名类来表示函数编写的。如果你旨在成为一名极端的函数式程序员，这无疑是一个好事。即使你不是，使用它并查看其编码方式也是一种非常有益的经历。然而，请注意，文档很少。你将不得不自己弄清楚如何使用它，尽管这本书中学到的知识将大大帮助你。
- en: 'Also note that this library has been developed by many great functional programmers,
    some of whom have now turned their interest toward more functional-friendly languages.
    You can find more information on this site: [http://www.functionaljava.org/](http://www.functionaljava.org/).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，这个库是由许多伟大的函数式程序员开发的，其中一些人现在将他们的兴趣转向了更友好的函数式语言。你可以在本网站上找到更多信息：[http://www.functionaljava.org/](http://www.functionaljava.org/).
- en: C.2.2\. Javaslang
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.2.2\. Javaslang
- en: 'Javaslang is a more recent, less extreme functional library for Java. It has
    much better documentation, including basic examples, although the documentation
    is only a single (big) page. Here again, what you’ve learned in this book will
    be a great help when using Javaslang. As I said, Javaslang’s approach is less
    fundamentalist, which probably makes it an easier transition, particularly for
    teams with various level of interest in the functional paradigm. One little glitch
    is that, although it has streams, those streams suffer one of the same problems
    of Java 8 streams: they don’t have lazy folds. However, the issues state that
    there are plans to implement them. On the other hand, it offers a usable pattern-matching
    mechanism. You can find information about this library at [http://javaslang.io/](http://javaslang.io/).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Javaslang是一个较新的、不那么极端的Java函数式库。它有更好的文档，包括基本示例，尽管文档只有一页（大页）。在这里，你在这本书中学到的知识在使用Javaslang时将非常有帮助。正如我所说，Javaslang的方法不那么极端，这可能使其更容易过渡，尤其是对于对函数式范式兴趣各异的团队。有一点小问题，尽管它有流，但这些流也面临着Java
    8流的一个相同问题：它们没有懒折叠。然而，问题声明有计划实现它们。另一方面，它提供了一个可用的模式匹配机制。你可以在[http://javaslang.io/](http://javaslang.io/)找到有关这个库的信息。
- en: C.2.3\. Cyclops
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.2.3\. Cyclops
- en: Cyclops is presented as “powerful, lightweight & modular extensions for JDK
    8,” but it’s more than this. It is, in fact, full, functional libraries for Java
    with additional support for leveraging the standard Java data types to make them
    really usable. For example, it adds functional methods to standard Java collections,
    and it also provides immutable persistent collections like those you developed
    in this book. Cyclops also offers the missing methods for the Java 8 `Stream`
    interface, such as `takeWhile` and `dropWhile`. Cyclops is really full of interesting
    stuff, such as replayable streams, memoization, trampolining, pattern matching,
    tuples, and more. And it has probably the best documentation of all the available
    Java functional libraries. Finally, it’s designed to work hand in hand with other
    libraries like Functional Java or Javaslang (or even Guava). Cyclops can be found
    at [https://github.com/aol/cyclops](https://github.com/aol/cyclops).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Cyclops被描述为“强大的、轻量级的和模块化的JDK 8扩展”，但它不仅仅是这样。实际上，它是Java的完整函数式库，并提供了利用标准Java数据类型以使其真正可用的额外支持。例如，它向标准Java集合添加了函数式方法，并且还提供了类似于你在本书中开发的不可变持久集合。Cyclops还提供了Java
    8 `Stream`接口缺失的方法，如`takeWhile`和`dropWhile`。Cyclops充满了有趣的东西，如可重放流、记忆化、跳跃、模式匹配、元组等。它可能拥有所有可用Java函数式库中最好的文档。最后，它被设计成与其他库（如Functional
    Java或Javaslang或Guava）协同工作。Cyclops可以在[https://github.com/aol/cyclops](https://github.com/aol/cyclops)找到。
- en: C.2.4\. Other functional libraries
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.2.4\. 其他函数式库
- en: There were once other Java functional libraries, such as Fun4j, LambdaJ, op4j,
    and Apache Commons Functor. All these libraries appeared before Java 8, and none
    have evolved since the release of Java 8, which mostly made them obsolete.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经还有其他Java函数式库，例如Fun4j、LambdaJ、op4j和Apache Commons Functor。所有这些库都在Java 8之前出现，并且自Java
    8发布以来都没有进化，这使它们大多变得过时。
- en: Guava has continued to evolve because it’s not a functional library but a library
    that, among other things, contained functions. But the functional features of
    Guava haven’t evolved much and are now obsolete.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Guava库之所以持续发展，是因为它不仅仅是一个函数式库，而是一个包含函数在内的库。但Guava的函数式特性并没有太多发展，现在已经过时了。
- en: C.3\. Further reading
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.3. 进一步阅读
- en: If you want to learn more about functional programming, you’ll find lots of
    resources on the internet. Many articles and books have been written about functional
    programming, but not so many about functional programming in Java. You might,
    however, find some useful articles written about general functional programming
    with examples in “functional languages,” because many concepts are applicable
    to Java.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于函数式编程的信息，你可以在互联网上找到很多资源。关于函数式编程的文章和书籍已经有很多，但关于Java函数式编程的却不多。然而，你可能找到一些关于通用函数式编程的文章，这些文章以“函数式语言”为例，因为许多概念都适用于Java。
- en: 'Here’s a non-exhaustive list of articles that you might find interesting:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个可能感兴趣的文献列表，但不全面：
- en: John Hughes, “Why Functional Programming matters,” from “Research Topics in
    Functional Programming,” ed. D. Turner (Addison-Wesley, 1990), [http://mng.bz/qp3B](http://mng.bz/qp3B).
    This very interesting article is mainly about higher-order functions and laziness
    and explains why these features are so important if you want to write better and
    safer programs.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: John Hughes, “为什么函数式编程很重要,” 来自“函数式编程研究主题”，D. Turner 编著（Addison-Wesley，1990年),
    [http://mng.bz/qp3B](http://mng.bz/qp3B)。这篇文章非常有趣，主要讨论了高阶函数和惰性，并解释了为什么这些特性对于编写更好、更安全的程序至关重要。
- en: Philip Walder,“Theorems for free!” (University of Glasgow, 1989), [http://mng.bz/my25](http://mng.bz/my25).
    This article is more difficult to read, but worth the effort if you want to determine
    what a strong type system can offer you as a programmer.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Philip Walder,“免费定理！” (格拉斯哥大学，1989年), [http://mng.bz/my25](http://mng.bz/my25)。这篇文章比较难读，但如果你想知道强大的类型系统作为程序员能为你提供什么，那么这份努力是值得的。
- en: Chris Okasaki, “Purely Functional Data Structures” (thesis, School of Computer
    Science, Carnegie Mellon University, 1996), [http://mng.bz/8Gz4](http://mng.bz/8Gz4).
    This easier-to-read university thesis is about how to build purely functional
    data structures. Examples are written in Standard ML, a functional language. Okasaki
    has written a book based on this paper that is even easier to read and has examples
    in Haskell. If you’re interested in functional (immutable and persistent) data
    structures, this is the book you must read.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chris Okasaki, “纯函数式数据结构” (论文，卡内基梅隆大学计算机科学学院，1996年), [http://mng.bz/8Gz4](http://mng.bz/8Gz4).
    这篇更容易阅读的大学论文讲述了如何构建纯函数式数据结构。示例是用标准ML编写的，这是一种函数式语言。Okasaki基于这篇论文写了一本书，这本书更容易阅读，并且有Haskell语言的示例。如果你对函数式（不可变和持久）数据结构感兴趣，这本书是你必须阅读的。
- en: 'Kimball Germane and Matthew Might, “Deletion: the curse of the red-black tree,”
    *JFP* 24, 4 (2014): 423–433, [http://mng.bz/yl57](http://mng.bz/yl57). This paper
    complements Okasaki’s presentation of the functional red-black tree. In his book,
    Okasaki doesn’t give the implementation of element removal from this structure,
    and leaves it as an exercise for the reader. This article is about that implementation.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kimball Germane 和 Matthew Might, “删除：红黑树的诅咒,” *《函数式编程杂志》* 24, 4 (2014): 423–433,
    [http://mng.bz/yl57](http://mng.bz/yl57)。这篇论文补充了Okasaki关于函数式红黑树的介绍。在他的书中，Okasaki没有给出从该结构中删除元素的实现，而是将其留作读者的练习。这篇文章就是关于那个实现的。'
- en: 'Graham Hutton, “A tutorial on the universality and expressiveness of fold,”
    *J. Functional Programming* 9, 4 (1999): 355–372, [http://mng.bz/me7Z](http://mng.bz/me7Z).
    This is one of the most interesting articles about functional programming, and
    very easy to read. A must if you want to fully understand folds.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Graham Hutton, “关于折叠的普遍性和表达性的教程,” *《函数式编程杂志》* 9, 4 (1999): 355–372, [http://mng.bz/me7Z](http://mng.bz/me7Z).
    这是最有趣的关于函数式编程的文章之一，而且非常易于阅读。如果你想要全面理解折叠，这是一篇必读的文章。'
- en: 'Ralf Hinze and Ross Patterson, “Finger trees: a simple general-purpose data
    structure,” [http://mng.bz/AYZS](http://mng.bz/AYZS). An article about a very
    interesting functional data structure that allows all types of accesses and operations
    with good performance, although it’s not as simple as the title says. Implementing
    it in Java is a rewarding challenge. (There are several known implementations.)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ralf Hinze 和 Ross Patterson, “指针树：一种简单通用的数据结构,” [http://mng.bz/AYZS](http://mng.bz/AYZS)。这篇文章介绍了一种非常有趣的函数式数据结构，它允许以良好的性能进行所有类型的访问和操作，尽管它并不像标题所说的那么简单。在Java中实现它是一个有价值的挑战。（有几种已知的实现。）
