- en: 19 Dynamic graph theory techniques for node ranking and social network analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 19 动态图论技术在节点排名和社会网络分析中的应用
- en: This section covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖
- en: Finding the most central network locations
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找最中心的网络位置
- en: Clustering the connections in a network
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络中连接的聚类
- en: Understanding social graph analysis
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解社交图分析
- en: In the previous section, we investigated several types of graphs. We examined
    web pages connected by directed links and also a network of roads spanning multiple
    counties. In our analysis, we’ve mostly treated the network as frozen, static
    objects—we’ve counted neighboring nodes as though they were frozen clouds in a
    photograph. In real life, clouds are constantly in motion, and so are many networks.
    Most networks worth studying are perpetually buzzing with dynamic activity. Cars
    race across networks of roads, causing traffic congestion near popular towns.
    In that same vein, web traffic flows across the internet as billions of users
    explore the many web links. Our social networks are also flowing with activity
    as gossip, rumors, and cultural memes spread across tight circles of close friends.
    Understanding this dynamic flow can help uncover friend groups in an automated
    manner. Understanding the flow can also help us identify the most heavily trafficked
    web pages on the internet. Such modeling of dynamic network activity is critical
    to the function of many large tech organizations. In fact, one of the modeling
    methods presented in this section led to the founding of a trillion-dollar company.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们研究了多种类型的图。我们考察了通过有向链接连接的网页，以及跨越多个县的道路网络。在我们的分析中，我们主要将网络视为静止的、静态的对象——我们像计算照片中的静止云朵一样计算邻近节点。在现实生活中，云朵不断在运动，许多网络也是如此。大多数值得研究的网络都始终充满动态活动。汽车在道路网络上疾驰，导致热门城镇附近的交通拥堵。同样，当数十亿用户探索互联网上的众多网页时，网络流量也会在互联网上流动。我们的社交网络也在活动中流动，流言、谣言和文化梗在紧密的亲密朋友圈子中传播。理解这种动态流动可以帮助我们以自动化的方式揭示朋友群体。理解流量还可以帮助我们识别互联网上最繁忙的网页。这种动态网络活动的建模对于许多大型科技组织的功能至关重要。事实上，本节中提出的一种建模方法导致了一家价值万亿美元公司的成立。
- en: The dynamic flow (of people, cars, etc.) across a graph is an inherently random
    process, so it can be studied using random simulations similar to those presented
    in section 3\. In the early part of this section, we utilize random simulations
    to study the traffic flow of cars. Then we attempt to compute the traffic probabilities
    more efficiently using matrix multiplication. Later, we use our matrix analysis
    to uncover clusters of communities with heavy traffic. We then apply our clustering
    technique to uncover groups of friends in social networks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图上的动态流动（如人流、车流等）是一个固有的随机过程，因此可以使用类似于第3节中展示的随机模拟来研究。在本节的前部分，我们利用随机模拟来研究汽车流量。然后我们尝试使用矩阵乘法更有效地计算流量概率。稍后，我们使用我们的矩阵分析来揭示交通繁忙的社区集群。然后我们将我们的聚类技术应用于揭示社交网络中的朋友群体。
- en: Let’s get started. We begin with the straightforward problem of uncovering heavily
    trafficked towns based on traffic simulations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。我们从一个简单的问题开始，即根据交通模拟揭示交通繁忙的城镇。
- en: 19.1 Uncovering central nodes based on expected traffic in a network
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.1 基于网络预期流量揭示中心节点
- en: In the previous section, we simulated a road network connecting 31 towns in
    6 different counties (figure 19.1). We stored that network in a graph called `G`.
    Our goal was to optimize business delivery travel times across the 31 towns. Let’s
    explore this scenario further.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们模拟了一个连接6个不同县31个城镇的道路网络（图19.1）。我们将该网络存储在一个名为`G`的图中。我们的目标是优化31个城镇之间的商业配送旅行时间。让我们进一步探讨这个场景。
- en: Suppose our business is growing at an impressive rate. We wish to expand our
    customer base by putting up a billboard advertisement in one of the local towns
    represented by `G.nodes`. To maximize billboard views, we’ll choose the town with
    the heaviest traffic. Intuitively, traffic is determined by the number of cars
    that pass through town every day. Can we rank the 31 towns in `G.nodes` based
    on the expected daily traffic? Yes, we can! Using simple modeling, we can predict
    traffic flow from the network of roads between the towns. Later, we’ll expand
    on these traffic-flow techniques to identify local counties in an automated manner.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的业务正在以令人印象深刻的速度增长。我们希望通过在`G.nodes`表示的当地城镇之一投放广告牌来扩大我们的客户群。为了最大化广告牌的观看次数，我们将选择交通流量最大的城镇。直观地说，交通流量是由每天通过城镇的汽车数量决定的。我们能否根据预期的每日交通量对`G.nodes`中的31个城镇进行排名？是的，我们可以！通过简单的建模，我们可以预测城镇之间道路网络中的交通流量。稍后，我们将扩展这些交通流量技术，以自动识别本地县。
- en: '![](../Images/19-01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/19-01.png)'
- en: Figure 19.1 A simulated node network from section 18, which is stored in graph
    `G`. The roads connect 31 towns that are spread across six counties. Each town
    is colored based on its county ID.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.1：第18节中模拟的节点网络，存储在图`G`中。道路连接了31个城镇，这些城镇分布在六个县。每个城镇根据其县ID着色。
- en: 'We need a way of ranking the towns based on expected traffic. Naively, we could
    simply count the inbound roads into each town: a town with five roads can receive
    traffic from five different directions, while a town with just one road is more
    limited in its traffic flow. The road count is analogous to our in-degree ranking
    of websites introduced in section 18\. As a reminder, the in-degree of a node
    is the number of directed edges pointing at a node. However, unlike the website
    graph, our network of roads is undirected: there’s no distinction between inbound
    edges and outbound edges. Thus, there’s no distinction between a node’s in-degree
    and out-degree; both values are equal, so the edge count of a node in an undirected
    graph is simply called the node’s *degree*. We can compute the degree of any node
    `i` by summing over the *i*th column of the graph’s adjacency matrix, or we can
    measure the degree by running `len(G.nodes[i])`. Alternatively, we can utilize
    the NetworkX `degree` method by calling `G.degree(i)`. Here, we use all these
    techniques to count the roads passing through Town 0.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来根据预期的交通量对城镇进行排名。天真地，我们可以简单地计算每个城镇进入的道路数量：一个有五条道路的城镇可以从五个不同的方向接收交通，而只有一条道路的城镇在交通流量上更为有限。道路数量与我们在第18节中介绍的网站的入度排名类似。提醒一下，一个节点的入度是指指向该节点的有向边的数量。然而，与网站图不同，我们的道路网络是无向的：没有区分进入边和出去边。因此，没有区分节点的入度和出度；这两个值相等，所以无向图中节点的边数简单地称为节点的*度*。我们可以通过计算图的邻接矩阵的第*i*列的总和来计算任何节点`i`的度，或者我们可以通过运行`len(G.nodes[i])`来测量度。或者，我们可以通过调用`G.degree(i)`来利用NetworkX的`degree`方法。在这里，我们使用所有这些技术来计算穿过城镇0的道路数量。
- en: Listing 19.1 Computing the degree of a single node
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.1：计算单个节点的度
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using their degrees, we rank our nodes based on importance. In graph theory,
    any measure of a node’s importance is commonly called *node centrality*, and ranked
    importance based on a node’s degree is called the *degree of centrality*. We now
    select the node with the highest degree of centrality in `G`: this central node
    will serve as our initial choice for the billboard’s location (figure 19.2).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它们的度，我们根据重要性对节点进行排名。在图论中，任何关于节点重要性的度量通常称为*节点中心性*，基于节点度的排名称为*度中心性*。我们现在选择`G`中具有最高度中心性的节点：这个中心节点将作为广告牌位置的初始选择（图19.2）。
- en: Listing 19.2 Selecting a central node using degree of centrality
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.2：使用中心度选择中心节点
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Town 3 is our most central town. Roads connect it to nine different towns and
    three different counties. How does Town 3 compare with the second-most-central
    town? We’ll quickly check by outputting the second-highest degree in `G`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 城镇3是我们最中心的城镇。道路连接它到九个不同的城镇和三个不同的县。城镇3与第二中心城镇相比如何？我们将通过输出`G`中的第二高度来快速检查。
- en: Listing 19.3 Selecting a node with the second-highest degree of centrality
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.3：选择具有第二高中心度的节点
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Town 12 has eight connecting roads—it lags behind Town 3 by just one road. What
    would we do if these two towns had equal degrees? Let’s challenge ourselves to
    find out. In figure 19.2, we see a road connecting Town 3 and Town 9\. Suppose
    that road is closed due to disrepair. That closure necessitates the removal of
    an edge in `G`. Running `G.remove(3, 9)` removes the edge between nodes 3 and
    9, so the degree of Town 3 shifts to equal the degree of Town 12\. There are also
    other important structural changes to the network. Here, we visualize these changes
    (figure 19.3).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 12镇有八条连接道路——它比3镇少一条道路。如果这两个城镇的度数相等，我们会怎么做？让我们挑战自己来找出答案。在图19.2中，我们看到一条连接3镇和9镇的道路。假设这条道路因为损坏而关闭。这种关闭需要从`G`中移除一条边。运行`G.remove(3,
    9)`移除了节点3和9之间的边，因此3镇的度数变为与12镇相等。网络中还有其他重要的结构变化。在这里，我们可视化这些变化（图19.3）。
- en: '![](../Images/19-02.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/19-02.png)'
- en: Figure 19.2 A network of roads between different towns. Town 3 has the highest
    degree of centrality and is colored black.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.2 不同城镇之间的道路网络。3镇具有最高的度数中心性，被涂成黑色。
- en: Listing 19.4 Removing an edge from the most central node
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.4 从最中心节点移除边
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ After edge deletion, Towns 3 and 12 share the same degree of centrality.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在删除边之后，3镇和12镇的中心度数相同。
- en: '![](../Images/19-03.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/19-03.png)'
- en: Figure 19.3 A network of roads between different towns after a road closure.
    Towns 3 and 12 now share the same degree of centrality. Despite their shared degree,
    Town 12 appears to be in a more central position in the graph. Its county borders
    multiple other counties. Meanwhile, the closed road has partially isolated Town
    3 from the outside world.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.3 在道路关闭后不同城镇之间的道路网络。3镇和12镇现在具有相同度数中心性。尽管它们的度数相同，但在图中12镇似乎处于更中心的位置。它的县界与多个其他县接壤。同时，关闭的道路部分地将3镇与外界隔离开来。
- en: Removal of the road has partially isolated Town 3 as well as its neighboring
    towns. Town 3 is in County 0, which encompasses Towns 0 through 7\. Previously,
    a single road passing through Town 3 linked County 0 to County 1; now that road
    has been eliminated, so Town 3 is less accessible than it was before. This is
    in contrast to Town 12, which continues to be the neighbor of multiple different
    counties.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 道路的移除也部分地将3镇及其邻近城镇与外界隔离开来。3镇位于县0，该县包括0镇到7镇。之前，一条穿过3镇的道路将县0与县1连接起来；现在这条道路已被消除，因此3镇比以前更难到达。这与继续成为多个不同县邻居的12镇形成对比。
- en: 'Town 3 is now less central than Town 12, but the degrees of both towns are
    equal. We’ve exposed a significant flaw of the degree of centrality: connecting
    roads don’t matter if they don’t lead anywhere important.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在3镇的中心性不如12镇，但两个城镇的度数相等。我们暴露了度数中心性的一个重大缺陷：如果连接的道路不通往任何重要的地方，那么这些道路就不重要。
- en: Imagine if a town has 1,000 roads, all of which lead to dead ends. Now imagine
    a town with just four roads, but each road leads to a large metropolitan city.
    We would expect the second town to have heavier traffic than the first, despite
    the extreme difference in degrees. Similarly, we expect Town 12 to garner more
    traffic than Town 3, even though their degrees are equal. In fact, we can quantitate
    these differences using random simulations. In the next subsection, we measure
    town centrality by simulating traffic flows between towns.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果一座城镇有1000条道路，所有这些道路都通向死胡同。现在想象一座只有四条道路的城镇，但每条道路都通往一个大都市。我们预计第二个城镇的交通量会比第一个城镇大，尽管它们的度数差异极大。同样，我们预计12镇会比3镇吸引更多的交通量，尽管它们的度数相等。实际上，我们可以使用随机模拟来量化这些差异。在下一小节中，我们将通过模拟城镇之间的交通流量来测量城镇的中心性。
- en: 19.1.1 Measuring centrality using traffic simulations
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.1.1 使用交通模拟测量中心性
- en: We’ll shortly simulate traffic in our network by having 20,000 simulated cars
    drive randomly around our 31 towns. However, first we need to simulate the random
    path of a single car. The car will start its journey in a random town `i`. Then
    the driver will randomly select one of the `G.degree(i)` roads that cut through
    town and pay a visit to a random neighboring town of `i`. Next, another random
    road will be selected. The process will repeat until the car has driven through
    10 towns. Let’s define a `random_drive` function to run this simulation on graph
    `G`; the function returns the final location of the car.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过让20,000辆模拟汽车在我们的31个城镇中随机驾驶来模拟网络中的交通。然而，首先我们需要模拟单辆汽车的随机路径。汽车将从随机城镇`i`开始其旅程。然后驾驶员将随机选择一条穿过城镇的`G.degree(i)`条道路，并访问`i`的随机邻近城镇。接下来，将选择另一条随机道路。这个过程将重复进行，直到汽车穿过10个城镇。让我们定义一个`random_drive`函数，在图`G`上运行这个模拟；该函数返回汽车的最终位置。
- en: Note In graph theory, this type of random traversal between nodes is called
    a *random walk*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在图论中，这种在节点之间随机遍历的类型被称为*随机游走*。
- en: Listing 19.5 Simulating the random route of a single car
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.5 模拟单辆车的随机路线
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ The function simulates the random path of a car across num_paths towns.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 该函数模拟了汽车在num_paths个城镇之间的随机路径。
- en: ❷ The car’s starting location is chosen at random.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 随机选择汽车的起始位置。
- en: ❸ The car drives to a random neighboring town.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 汽车驶向一个随机的邻近城镇。
- en: Listing 19.6 repeats this simulation with 20,000 cars and counts the number
    of cars in each of the 31 towns. That car count represents the traffic in each
    town. We print the traffic in the most heavily visited town. We also time our
    20,000 iterations to get a sense of the running-time costs associated with traffic
    simulations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.6 使用20,000辆汽车重复此模拟，并计算31个城镇中每个城镇的汽车数量。这个汽车计数代表了每个城镇的交通。我们打印了访问最频繁城镇的交通情况。我们还对20,000次迭代进行了计时，以了解与交通模拟相关的运行时成本。
- en: 'Note Our simulation is greatly oversimplified. In real life, people don’t drive
    randomly from town to town: there is a lot of traffic in certain areas because
    they are between places people must regularly go, where they find lots of housing,
    employment opportunities, retailers, etc. But our simplification isn’t detrimental;
    it’s beneficial! Our model generalizes beyond just car traffic. It can be applied
    to web traffic and also to the flow of social interactions. Shortly, we’ll expand
    our analysis to these other categories of graphs—and that expansion would not
    have been possible if our model was less simple and more concrete.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们的模拟被大大简化了。在现实生活中，人们不会随意从一个城镇开车到另一个城镇：某些地区交通繁忙，因为它们位于人们必须定期前往的地方，那里有许多住宅、就业机会、零售商等。但我们的简化并不损害模型；相反，它是有益的！我们的模型不仅适用于汽车交通，还可以推广到网络交通和社会互动的流动。简而言之，我们将扩展我们的分析到这些其他类别的图——如果我们的模型不那么简单、更具体，这种扩展将是不可能的。
- en: Listing 19.6 Simulating traffic using 20,000 cars
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.6 使用20,000辆汽车模拟交通
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Stores the traffic counts in an array rather than a dictionary to more easily
    vectorize these counts in subsequent code
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将交通计数存储在数组中，而不是字典中，以便在后续代码中更容易对这些计数进行向量化
- en: Town 12 has the most traffic, with over 1,000 cars. This is not surprising,
    given that Town 12 and Town 3 share the highest degree of centrality. Based on
    our previous discussion, we also expect Town 12 to have heavier traffic than Town
    3\. Let’s confirm.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第12个城镇的交通最为繁忙，有超过1000辆车。考虑到第12个城镇和第3个城镇共享最高的中心度，这一点并不令人惊讶。根据我们之前的讨论，我们也预计第12个城镇的交通比第3个城镇更繁忙。让我们来确认一下。
- en: Listing 19.7 Checking the traffic in Town 3
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.7 检查第3个城镇的交通
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Our expectations are verified. Town 3 has fewer than 1000 cars. We should note
    that car counts can be cumbersome to compare, especially when `num_cars` is large.
    Hence, it’s preferable to replace these direct counts with probabilities through
    division by the simulation count. If we execute `car_counts / num_cars`, we obtain
    a probability array: each *i*th probability equals the likelihood that a randomly
    traveling car winds up in Town `i`. Let’s print these probabilities for Towns
    12 and 3.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的预期得到了验证。第3个城镇的汽车数量少于1000辆。我们应该注意，汽车计数在比较时可能很麻烦，尤其是当`num_cars`很大时。因此，最好通过除以模拟计数将这些直接计数替换为概率。如果我们执行`car_counts
    / num_cars`，我们将获得一个概率数组：每个*i*的概率等于随机行驶的汽车最终到达城镇`i`的可能性。让我们打印出第12个和第3个城镇的概率。
- en: Listing 19.8 Converting traffic counts to probabilities
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.8 将交通计数转换为概率
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: According to our random simulation, we’ll wind up in Town 12 5.1% of the time
    and Town 3 just 4.7% of the time. Hence, we’ve shown that Town 12 is more central
    than Town 3\. Unfortunately, our simulation process is slow and doesn’t scale
    well to larger graphs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的随机模拟，我们将在5.1%的时间内到达城镇12，而在4.7%的时间内到达城镇3。因此，我们已经表明城镇12比城镇3更中心。不幸的是，我们的模拟过程速度慢，并且不适合更大的图。
- en: Note Our simulations took 3.47 seconds to run. This seems like a reasonable
    running time, but larger graphs will require more simulations to estimate travel
    probabilities. This is due to the law of large numbers, which we introduced in
    section 4\. A graph with 1,000 times more nodes would require 1,000 times more
    simulations, which would increase our running time to approximately one hour.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们的模拟运行了3.47秒。这似乎是一个合理的运行时间，但更大的图将需要更多的模拟来估计旅行概率。这是由于大数定律，我们在第4节中介绍了它。具有1,000倍更多节点的图将需要1,000倍更多的模拟，这将使我们的运行时间增加到大约一小时。
- en: Can we compute these probabilities directly without simulating the flow of 20,000
    cars? Yes! In the next section, we show how to compute the traffic probabilities
    using straightforward matrix multiplication.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否直接计算这些概率而不模拟20,000辆车的流量？是的！在下一节中，我们将展示如何使用简单的矩阵乘法来计算交通概率。
- en: 19.2 Computing travel probabilities using matrix multiplication
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.2 使用矩阵乘法计算旅行概率
- en: Our traffic simulation can be modeled mathematically using matrices and vectors.
    We’ll break this process into simple, manageable parts. Consider, for instance,
    a car that is about to leave Town 0 for one of the neighboring towns. There are
    `G.degree(0)` neighboring towns to choose from, so the probability of traveling
    from Town 0 to any neighboring town is `1 / G.degree(0)`. Let’s compute this probability.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用矩阵和向量数学地模拟交通模拟。我们将这个过程分解成简单、可管理的部分。例如，考虑一辆即将离开城镇0前往邻近城镇的汽车。有 `G.degree(0)`
    个邻近城镇可以选择，因此从城镇0到任何邻近城镇旅行的概率是 `1 / G.degree(0)`。让我们计算这个概率。
- en: Listing 19.9 Computing the probability of travel to a neighboring town
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.9 计算前往邻近城镇的旅行概率
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we’re in Town 0 and Town *i* is a neighboring town, there’s a 20% chance
    of us traveling from Town 0 to Town *i*. Of course, if Town *i* is not a neighboring
    town, the probability drops to 0.0\. We can track the probabilities for every
    possible `i` using a vector `v`. The value of `v[i]` will equal 0.2 if `i` is
    in `G[0]` and 0 otherwise. Vector `v` is called a *transition vector* since it
    tracks the probability of transitioning from Town 0 to other towns. There are
    multiple ways to compute the transition vector:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在城镇0，而城镇 *i* 是一个邻近城镇，我们有20%的几率从城镇0前往城镇 *i*。当然，如果城镇 *i* 不是一个邻近城镇，概率将降至0.0。我们可以使用向量
    `v` 跟踪每个可能的 `i` 的概率。如果 `i` 在 `G[0]` 中，`v[i]` 的值将等于0.2，否则为0。向量 `v` 被称为 *过渡向量*，因为它跟踪从城镇0过渡到其他城镇的概率。有多种方法可以计算过渡向量：
- en: Run `np.array([0.2 if i in G[0] else 0 for i in G.nodes])`. Each *i*th element
    will equal 0.2 if `i` is in `G[0]` and 0 otherwise.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 `np.array([0.2 if i in G[0] else 0 for i in G.nodes])`。每个 *i*th 元素将等于0.2，如果
    `i` 在 `G[0]` 中，否则为0。
- en: Run `np.array([1 if i in G[0] else 0 for i in G.nodes]) * 0.2`. Here, we are
    simply multiplying 0.2 by the binary vector that tracks the presence or absence
    of edges linking to `G[0]`.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 `np.array([1 if i in G[0] else 0 for i in G.nodes]) * 0.2`。在这里，我们只是将0.2乘以跟踪连接到
    `G[0]` 的边的存在或不存在二进制向量。
- en: Run `M[:,0] * 0.2`, where `M` is the adjacency matrix. Each adjacency matrix
    column tracks the binary presence or absence of edges between nodes, so column
    `0` of `M` will equal the array in the previous example.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 `M[:,0] * 0.2`，其中 `M` 是邻接矩阵。每个邻接矩阵列跟踪节点之间边的二进制存在或不存在，因此 `M` 的列 `0` 将等于前一个示例中的数组。
- en: The third computation is the simplest. Of course, `0.2` is equal to `1 / G.degree(0)`.
    As we discussed at the beginning of this section, the degree can also be computed
    by summing across an adjacency matrix column. Thus, we can also compute the transitional
    vector by running `M[:,0] / M[:,0].sum()`. Listing 19.10 computes the transition
    vector using all the listed methodologies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种计算是最简单的。当然，`0.2` 等于 `1 / G.degree(0)`。正如我们在本节开头讨论的那样，度也可以通过求邻接矩阵列的和来计算。因此，我们也可以通过运行
    `M[:,0] / M[:,0].sum()` 来计算过渡向量。列表19.10使用所有列出的方法计算过渡向量。
- en: Note Currently, an adjacency matrix `M` is stored with an `adjacency_matrix`
    variable. However, that matrix does not take into account the deleted edge between
    Town 3 and Town 9, so we recompute the matrix by running `adjacency_matrix = nx.to_numpy_array(G)`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：目前，一个邻接矩阵 `M` 存储在 `adjacency_matrix` 变量中。然而，该矩阵没有考虑到城镇3和城镇9之间的删除边，因此我们通过运行
    `adjacency_matrix = nx.to_numpy_array(G)` 重新计算矩阵。
- en: Listing 19.10 Computing a transition vector
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.10 计算过渡向量
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Recomputes the adjacency matrix to take into account our earlier edge deletion
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 重新计算邻接矩阵以考虑我们之前删除的边
- en: ❷ Computes the transition vector directly from the adjacency matrix column
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 直接从邻接矩阵列计算过渡向量
- en: ❸ All four computed versions of the transition vector are identical.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 所有四种过渡向量的计算版本都是相同的。
- en: 'We can compute the transition vector for any Town *i* by running `M[:,i] /
    M[:,i] .sum()`, where `M` is the adjacency matrix. Furthermore, we can compute
    these vectors all at once by running `M / M.sum(axis=0)`. The operation divides
    each column of the adjacency matrix by the associated degree. The end result is
    a matrix whose columns correspond to transition vectors. This matrix, which is
    illustrated in figure 19.4, is referred to as a *transition matrix*. It is also
    commonly called the *Markov matrix*, named after Andrey Markov, a Russian mathematician
    who studied random processes. We now compute the transition matrix: based on our
    expectation, the output’s column 0 should equal Town 0’s `transition_vector`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行 `M[:,i] / M[:,i] .sum()` 来计算任何城镇 *i* 的过渡向量，其中 `M` 是邻接矩阵。此外，我们可以通过运行
    `M / M.sum(axis=0)` 一次性计算这些向量。这个操作将邻接矩阵的每一列除以相关的度。最终结果是列对应于过渡向量的矩阵。这个在图19.4中展示的矩阵被称为
    *过渡矩阵*。它也常被称为 *马尔可夫矩阵*，以纪念研究随机过程的俄罗斯数学家安德烈·马尔可夫。我们现在计算过渡矩阵：根据我们的预期，输出的第0列应该等于城镇0的
    `transition_vector`。
- en: '![](../Images/19-04.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/19-04.png)'
- en: Figure 19.4 If `M` is the adjacency matrix, then `M / M.sum(axis=0)` equals
    the transition matrix, even if the adjacencies are directed. This figure shows
    a directed graph. Edges are marked with the transition probabilities. These probabilities
    are also displayed in a matrix equal to `M / M.sum(axis=0)`. Each column in the
    matrix is a transition vector whose probabilities sum to 1.0\. According to the
    matrix, the probability of travel from A to C is `1/2`, and the probability of
    travel from C to A is `1/3`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.4 如果 `M` 是邻接矩阵，那么 `M / M.sum(axis=0)` 等于过渡矩阵，即使邻接关系是定向的。此图显示了一个有向图。边用过渡概率标记。这些概率也显示在等于
    `M / M.sum(axis=0)` 的矩阵中。矩阵中的每一列都是一个概率之和为1.0的过渡向量。根据矩阵，从A到C的旅行概率是 `1/2`，从C到A的旅行概率是
    `1/3`。
- en: Listing 19.11 Computing a transition matrix
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.11 计算过渡矩阵
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our transition matrix has a fascinating property: it allows us to compute the
    traveling probability to every town in just a few lines of code! If we want to
    know the probability of winding up in Town *i* after 10 stops, then we simply
    need to do the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的过渡矩阵有一个迷人的特性：它允许我们仅用几行代码就计算到每个城镇的旅行概率！如果我们想知道在10次停留后最终停留在城镇 *i* 的概率，我们只需做以下操作：
- en: Initialize a vector `v`, where `v` equals `np.ones(31) / 31`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个向量 `v`，其中 `v` 等于 `np.ones(31) / 31`。
- en: Update `v` to equal `transition_matrix @ v` over 10 iterations.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `v` 更新为 `transition_matrix @ v`，迭代10次。
- en: Return `v[i]`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 `v[i]`。
- en: Later, we derive this amazing property from scratch. For now, let’s prove our
    claims by computing the travel probabilities to Towns 12 and 3 using matrix multiplication.
    We expect these probabilities to equal 0.051 and 0.047, based on our previous
    observations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将从头推导这个惊人的特性。现在，让我们通过矩阵乘法计算前往城镇12和3的旅行概率来证明我们的论断。根据我们之前的观察，我们预计这些概率将等于0.051和0.047。
- en: Listing 19.12 Computing travel probabilities using the transition matrix
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.12 使用过渡矩阵计算旅行概率
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our expectations are confirmed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的预期得到了证实。
- en: We can model traffic flow using a series of matrix multiplications. These multiplications
    serve as the basis for *PageRank centrality*, which is the most profitable node-importance
    measure in history. PageRank centrality was invented by the founders of Google;
    they used it to rank web pages by modeling a user’s online journey as a series
    of random clicks through the internet’s graph. These page clicks are analogous
    to a car that drives through randomly chosen towns. More popular web pages have
    a higher likelihood of visits. This insight allowed Google to uncover relevant
    websites in a purely automated manner. Google was thus able to outperform its
    competition and become a trillion-dollar company. Sometimes, data science can
    pay off nicely.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一系列矩阵乘法来模拟交通流量。这些乘法是 *PageRank 中心性* 的基础，这是历史上最有利可图的节点重要性度量。PageRank 中心性是由
    Google 的创始人发明的；他们使用它通过将用户的在线旅程建模为一系列通过互联网图进行随机点击来对网页进行排名。这些页面点击类似于一辆在随机选择的城镇中行驶的车。更受欢迎的网页有更高的访问可能性。这一洞察使
    Google 能够以完全自动化的方式发现相关网站。因此，Google 能够超越其竞争对手，成为一家价值万亿美元的公司。有时，数据科学可以带来丰厚的回报。
- en: PageRank centrality is easy to compute but not so easy to derive. Nonetheless,
    with basic probability theory, we can demonstrate why repeated `transition_matrix`
    multiplications directly yield the travel probabilities.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank 中心性容易计算但不容易推导。尽管如此，借助基本的概率理论，我们可以证明为什么重复的 `transition_matrix` 乘法直接产生旅行概率。
- en: Note If you’re not interested in the PageRank centrality derivation, skip ahead
    to the next subsection. It describes PageRank usage in NetworkX.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您对 PageRank 中心性的推导不感兴趣，请跳到下一小节。它描述了 NetworkX 中 PageRank 的使用。
- en: 19.2.1 Deriving PageRank centrality from probability theory
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.2.1 从概率论推导 PageRank 中心性
- en: We know that `transition_matrix[i][j]` equals the probability of traveling from
    Town *j* directly to Town *i*, but this assumes that our car is actually located
    in Town *j*. What if the car’s location is not certain? For instance, what if
    there is just a 50% chance that the car is located in Town *j* ? Under such circumstances,
    the travel probability equals `0.5 * transition_matrix[i][j]`. Generally, if the
    probability of our current location is `p`, then the probability of travel from
    the current location `j` to new location `i` equals `p * transition_matrix[i][j]`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 `transition_matrix[i][j]` 等于从城镇 *j* 直接旅行到城镇 *i* 的概率，但这假设我们的车实际上位于城镇 *j*。如果车的位置不确定怎么办？例如，如果只有
    50% 的可能性车位于城镇 *j*，在这种情况下，旅行概率等于 `0.5 * transition_matrix[i][j]`。一般来说，如果我们当前的位置概率是
    `p`，那么从当前位置 `j` 到新位置 `i` 的旅行概率等于 `p * transition_matrix[i][j]`。
- en: Suppose a car begins its journey in a random town and travels one town over.
    What is the probability that the car will travel from Town 3 to Town 0? Well,
    the car can start the journey in any of 31 different towns, so the probability
    of starting in Town 3 is `1 / 31`. Thus the probability of traveling from Town
    3 to Town 0 is `transition_ matrix[0][3] / 31`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一辆车从一个随机的城镇开始旅行，并前往下一个城镇。这辆车从城镇 3 旅行到城镇 0 的概率是多少？嗯，车可以从 31 个不同的城镇中的任何一个开始旅行，所以从城镇
    3 开始旅行的概率是 `1 / 31`。因此，从城镇 3 旅行到城镇 0 的概率是 `transition_matrix[0][3] / 31`。
- en: Listing 19.13 Computing a travel likelihood from a random starting location
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.13 从随机起始位置计算旅行可能性
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There are multiple ways of reaching Town 0 directly from a random starting location.
    Let’s print all nonzero instances of `transition_matrix[0][i] / 31` for every
    possible Town *i*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从随机起始位置直接到达城镇 0 有多种方式。让我们打印出每个可能的城镇 *i* 的 `transition_matrix[0][i] / 31` 的所有非零实例。
- en: Listing 19.14 Computing travel likelihoods of random routes leading to Town
    0
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.14 计算通向城镇 0 的随机路线的旅行可能性
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Five different routes take us to Town 0\. Each route has a different probability,
    and the sum of these probabilities equals the likelihood of starting at any random
    town and traveling directly to Town 0 (figure 19.5). We’ll now compute that likelihood.
    Furthermore, we’ll compare the likelihood to the result of random simulations.
    We run the simulations by executing `random_drive(num_stops=1)` 50,000 times,
    which yields the frequency with which Town 0 appears as the first stop on a randomized
    journey. We expect that frequency to approximate our probability sum.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 五条不同的路线通向城镇 0。每条路线有不同的概率，这些概率的总和等于从任何随机城镇出发直接到达城镇 0 的可能性（图 19.5）。我们现在将计算这个可能性。此外，我们将将其与随机模拟的结果进行比较。我们通过执行
    `random_drive(num_stops=1)` 50,000 次来运行模拟，这会产生在随机旅程中城镇 0 作为第一次停靠出现的频率。我们预计这个频率将近似于我们的概率总和。
- en: '![](../Images/19-05.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/19-05.png)'
- en: Figure 19.5 Five different routes take us from a random initial town directly
    to Town 0\. Each route has a small probability assigned. Summing these values
    gives the probability of starting at a random town and traveling directly to Town
    0.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.5 五条不同的路线直接从随机初始城镇到达城镇 0。每条路线都分配了一个小概率。将这些值相加得到从随机城镇出发直接到达城镇 0 的概率。
- en: Listing 19.15 Computing the probability that the first stop is Town 0
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.15 计算第一次停靠在城镇 0 的概率
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our computed probability is consistent with the observed frequency: we will
    make the first stop of our journey in Town 0 approximately 2.6% of the time. It’s
    worth noting that the probability can be computed more concisely as a vector dot-product
    operation—we just need to run `transition_matrix[0] @ v`, where `v` is a 31-element
    vector whose elements all equal `1 / 31`. Let’s execute this computation shortcut.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算的概率与观察到的频率一致：我们的旅程第一次停靠在城镇 0 大约是 2.6%。值得注意的是，这个概率可以更简洁地计算为一个向量点积操作——我们只需要运行
    `transition_matrix[0] @ v`，其中 `v` 是一个包含 31 个元素的向量，其元素都等于 `1 / 31`。让我们执行这个计算快捷方式。
- en: Listing 19.16 Computing a travel probability using a vector dot product
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.16 使用向量点积计算旅行概率
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Executing `transition_matrix[i] @ v` returns the likelihood of making our first
    stop in Town *i*. We can compute this likelihood for every town by running `[transition_
    matrix[i] @ v for i in range(31)`. Of course, this operation is equivalent to
    the matrix product between `transition_matrix` and `v`, so `transition_matrix
    @ v` returns all first-stop probabilities. Listing 19.17 computes this `stop_1_probabilities`
    array and prints the probability of making our first stop in Town 12\. That probability
    should approximate the frequency computed through random simulations.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `transition_matrix[i] @ v` 返回在城镇 *i* 停靠第一次的可能性。我们可以通过运行 `[transition_matrix[i]
    @ v for i in range(31)]` 来计算每个城镇的可能性。当然，这个操作等同于 `transition_matrix` 和 `v` 的矩阵乘积，所以
    `transition_matrix @ v` 返回所有第一次停靠的概率。列表 19.17 计算了 `stop_1_probabilities` 数组，并打印了在城镇
    12 停靠第一次的概率。这个概率应该近似于通过随机模拟计算出的频率。
- en: Listing 19.17 Computing all first stop probabilities
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.17 计算所有第一次停靠概率
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We’ve established that `transition_matrix @ v` returns a vector of first-stop
    probabilities. Now we need to prove that iteratively repeating this operation
    will eventually yield a vector of tenth-stop probabilities. However, first let’s
    answer a simpler question: what is the probability of making our second stop in
    Town *i* ? Based on our previous discussions, we know the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经证明 `transition_matrix @ v` 返回一个第一次停靠概率的向量。现在我们需要证明迭代重复这个操作最终会得到一个第十次停靠概率的向量。然而，首先让我们回答一个更简单的问题：在城镇
    *i* 停靠第二次的概率是多少？根据我们之前的讨论，我们知道以下内容：
- en: The probability of making our first stop in Town *j* equals `stop_1_probabilities[j]`.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在城镇 *j* 停靠第一次的概率等于 `stop_1_probabilities[j]`。
- en: If the probability of our current location is `p`, then the probability of travel
    from the current location `j` to new location `i` equals `p * transition_matrix[i][j]`.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果当前位置的概率是 `p`，那么从当前位置 `j` 到新位置 `i` 的旅行概率等于 `p * transition_matrix[i][j]`。
- en: Hence, the probability of first stopping in Town *j* and then travelling to
    Town *i* is `p * transition_matrix[i][j]`, where `p = stop_1_probabilities[j]`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，第一次停靠在城镇 *j* 然后前往城镇 *i* 的概率是 `p * transition_matrix[i][j]`，其中 `p = stop_1_probabilities[j]`。
- en: We can compute this travel probability for every possible Town *j*.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以计算每个可能的城镇 *j* 的旅行概率。
- en: The sum of these probabilities equals the likelihood of making our first stop
    at a random town and then traveling directly to Town *i*. The sum equals `sum(p
    * transition_matrix[i][j] for j, p in enumerate(stop_1_probabilities))`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些概率的总和等于在随机城镇进行第一次停留然后直接前往城镇 *i* 的可能性。总和等于 `sum(p * transition_matrix[i][j]
    for j, p in enumerate(stop_1_probabilities))`。
- en: We can compute this likelihood more concisely as a vector dot-product operation.
    That operation equals `transition_matrix[i] @ stop_1_probabilities`.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将这个似然性更简洁地表示为向量点积操作。该操作等于 `transition_matrix[i] @ stop_1_probabilities`。
- en: The probability of making our second stop in Town *i* equals `transition_matrix[i]
    @ stop_1_probabilities`. We can compute this likelihood for every town using a
    matrix-vector product. Thus, `transition_matrix @ stop_1_probabilities` returns
    all second-stop probabilities. However, `stop_1_probabilities` is equal to `transition_
    matrix @ v`, so the second-stop probabilities are also equal to `transition_matrix
    @ transition_matrix @ v`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在城镇 *i* 进行第二次停留的概率等于 `transition_matrix[i] @ stop_1_probabilities`。我们可以通过矩阵-向量积计算每个城镇的这种可能性。因此，`transition_matrix
    @ stop_1_probabilities` 返回所有第二次停留的概率。然而，`stop_1_probabilities` 等于 `transition_matrix
    @ v`，因此第二次停留的概率也等于 `transition_matrix @ transition_matrix @ v`。
- en: Let’s confirm our calculations by obtaining the second-stop probabilities. Then
    we print the probability of making our second stop in Town 12, which should approximate
    the frequency computed through random simulations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过获取第二次停留的概率来确认我们的计算。然后我们打印在城镇12进行第二次停留的概率，这应该近似于通过随机模拟计算出的频率。
- en: Listing 19.18 Computing all second-stop probabilities
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.18 计算所有第二次停留的概率
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We were able to derive our second-stop probabilities directly from our first-stop
    probabilities. In a similar vein, we can derive the third-stop probabilities.
    If we repeat our derivation, we can easily show that `stop_3_probabilities` equals
    `transition_matrix @ stop_2_probabilities`. Of course, this vector also equals
    `M @ M @ M @ v`, where `M` is the transition matrix.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够直接从第一次停留的概率推导出第二次停留的概率。类似地，我们可以推导出第三次停留的概率。如果我们重复推导，我们可以很容易地证明 `stop_3_probabilities`
    等于 `transition_matrix @ stop_2_probabilities`。当然，这个向量也等于 `M @ M @ M @ v`，其中 `M`
    是转换矩阵。
- en: We can repeat this process to compute the fourth-stop probabilities, then the
    fifth-stop probabilities, and eventually the *N*th-stop probabilities. To compute
    the *N*th-stop probabilities, we simply need to execute `M @ v` across *N* iterations.
    Let’s define a function that computes all *N*th-stop probabilities directly from
    transition matrix `M`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重复这个过程来计算第四次停留的概率，然后是第五次停留的概率，最终是第 *N* 次停留的概率。要计算第 *N* 次停留的概率，我们只需要在 *N*
    次迭代中执行 `M @ v`。让我们定义一个函数，该函数可以直接从转换矩阵 `M` 计算所有第 *N* 次停留的概率。
- en: Note We’re dealing with a random process composed of *N* distinct steps, in
    which *N*th-step probabilities can be computed directly from the *N* &#8211; 1
    step. Such processes are called *Markov chains*, after the mathematician Andrey
    Markov.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们处理的是一个由 *N* 个不同步骤组成的随机过程，其中第 *N* 步的概率可以直接从第 *N* - 1 步计算得出。这样的过程被称为 *马尔可夫链*，以数学家安德烈·马尔可夫的名字命名。
- en: Listing 19.19 Computing the *N*th-stop probabilities
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.19 计算第 *N* 次停留的概率
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we’ve discussed, our iterative matrix multiplications form the basis for
    PageRank centrality. In the next subsection, we compare our outputs to the NetworkX
    PageRank implementation. This comparison will give us deeper insights into the
    PageRank algorithm.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，我们的迭代矩阵乘法是PageRank中心性的基础。在下一个小节中，我们将比较我们的输出与NetworkX的PageRank实现。这种比较将使我们更深入地了解PageRank算法。
- en: 19.2.2 Computing PageRank centrality using NetworkX
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 19.2.2 使用 NetworkX 计算PageRank中心性
- en: A function to compute PageRank centrality is included in NetworkX. Calling `nx.pagerank(G)`
    returns a dictionary mapping between the node IDs and their centrality values.
    Let’s print the PageRank centrality of Town 12\. Will it equal 0.051?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: NetworkX中包含一个用于计算PageRank中心性的函数。调用 `nx.pagerank(G)` 返回一个字典，将节点ID映射到它们的中心性值。让我们打印城镇12的PageRank中心性。它是否等于0.051？
- en: Listing 19.20 Computing PageRank centrality using NetworkX
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.20 使用 NetworkX 计算PageRank中心性
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The printed PageRank value is 0.048, which is slightly lower than expected.
    The difference is due to a slight tweak that ensures PageRank works on all possible
    networks. As a reminder: PageRank was initially intended to model random clicks
    through a web link graph. A web link graph has directed edges, which means certain
    web pages might not have any outbound links. Thus, an internet user might get
    stuck on a dead-end page if they rely on outbound links to traverse the web (figure
    19.6). To counter this, the PageRank designers assumed that a user would eventually
    get tired of clicking web links and would reboot their journey by going to a totally
    random web page—in other words, they’d teleport to one of the `len(G.nodes)` nodes
    in the internet graph. The PageRank designers programmed teleportation to occur
    in 15% of transversal instances. Teleportation ensures that a user will never
    get stranded on a node with no outbound links.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 打印的PageRank值是0.048，略低于预期。这种差异是由于一个细微的调整，确保PageRank可以在所有可能的网络上工作。提醒一下：PageRank最初旨在通过网页链接图模拟随机点击。网页链接图有有向边，这意味着某些网页可能没有任何出站链接。因此，如果用户依赖出站链接来浏览网络，他们可能会卡在死胡同页面（图19.6）。为了解决这个问题，PageRank的设计者假设用户最终会厌倦点击网页链接，并通过访问一个完全随机的网页来重新开始他们的旅程——换句话说，他们会通过互联网图中的`len(G.nodes)`个节点之一进行传送。PageRank的设计者将传送编程为在15%的横跨实例中发生。传送确保用户永远不会被困在没有出站链接的节点上。
- en: '![](../Images/19-06.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/19-06.png)'
- en: Figure 19.6 A directed graph containing four nodes. We can freely travel between
    interconnected nodes A, B, and C, but node D has no outbound edges. Sooner or
    later, a random traversal will take us from C to D. We will then be stuck forever
    at node D. Teleportation prevents this from happening. In 15% of our traversals,
    we’ll teleport to a randomly chosen node. Even if we travel to node D, we can
    still teleport back to nodes A, B, and C.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.6 包含四个节点的有向图。我们可以自由地在相互连接的节点A、B和C之间旅行，但节点D没有出站边。迟早，随机遍历会带我们从C到D。然后我们将永远被困在节点D上。传送防止这种情况发生。在我们的15%的遍历中，我们将传送到一个随机选择的节点。即使我们到达节点D，我们仍然可以传送回节点A、B和C。
- en: In our road network example, teleportation is analogous to calling a helicopter
    service. Imagine that in 15% of our town visits, we get bored with the local area.
    We then call for a helicopter, which swoops in and takes us to a totally random
    town. Once in the air, our probability of flying to any town equals 1 / 31\. After
    we land, we rent a car and continue our journey using the existing network of
    roads. Hence, 15% of the time, we fly from Town *i* to Town *j* with a probability
    of 1 / 31\. In the remaining 85% of instances, we drive from Town *i* to Town
    *j* with a probability of `transition_matrix[j][i]`. Consequently, the actual
    travel probability equals the weighted mean of `transition_matrix[j][i]` and 1
    / 31\. The respective weights are 0.85 and 0.15\. As discussed in section 5, we
    can compute the weighted average using the `np.average` function. We can also
    compute that mean directly by running `0.85 * transition_matrix[j][i] + 0.15 /
    31`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的道路网络示例中，传送类似于呼叫直升机服务。想象一下，在我们的15%的城镇访问中，我们对当地地区感到厌烦。然后我们呼叫直升机，它飞来并将我们带到完全随机的城镇。一旦在空中，我们飞往任何城镇的概率都是1
    / 31。我们着陆后，我们租一辆车，继续使用现有的道路网络继续我们的旅程。因此，15%的时间内，我们以1 / 31的概率从城镇*i*飞到城镇*j*。在剩余的85%的情况下，我们以`transition_matrix[j][i]`的概率从城镇*i*开车到城镇*j*。因此，实际的旅行概率等于`transition_matrix[j][i]`和1
    / 31的加权平均值。相应的权重是0.85和0.15。如第5节所述，我们可以使用`np.average`函数计算加权平均值。我们也可以通过运行`0.85 *
    transition_matrix[j][i] + 0.15 / 31`直接计算那个平均值。
- en: Taking the weighted mean across all elements of the transition matrix will produce
    an entirely new transition matrix. Let’s input that new matrix into our `compute_
    stop_likelihoods` function and print Town 12’s new travel probability. We expect
    that probability to drop from 0.051 to 0.048.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对转换矩阵的所有元素取加权平均值将产生一个新的转换矩阵。让我们将这个新矩阵输入到我们的`compute_stop_likelihoods`函数中，并打印城镇12的新旅行概率。我们预计这个概率将从0.051下降到0.048。
- en: Listing 19.21 Incorporating randomized teleportation into our model
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.21 将随机传送引入我们的模型
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Multiplies transition_matrix by 0.85 and then adds 0.15 / 31 to every element.
    See section 13 for a more in-depth discussion of arithmetic operations on 2D NumPy
    arrays.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将transition_matrix乘以0.85，然后向每个元素添加0.15 / 31。参见第13节，了解更多关于2D NumPy数组上的算术运算的讨论。
- en: Our new output is consistent with the NetworkX result. Will that output remain
    consistent if we increase the number of stops from 10 to 1,000? Let’s find out.
    We’ll input 1,000 stops into `compute_stop_likelihoods` and check whether Town
    12’s PageRank is still equal to 0.048.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新输出与 NetworkX 的结果一致。如果我们把停止次数从 10 增加到 1,000，输出还会保持一致吗？让我们找出答案。我们将输入 1,000
    个停止点到 `compute_stop_likelihoods` 中，并检查城镇 12 的 PageRank 是否仍然等于 0.048。
- en: Listing 19.22 Computing the probability after 1,000 stops
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.22 计算 1,000 次停止后的概率
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The centrality is still 0.048\. Ten iterations were sufficient for convergence
    to a stable value. Why is this the case? Well, our PageRank computation is nothing
    more than the repeated multiplication of a matrix and a vector. The elements of
    the multiplied vector are all values between 0 and 1\. Perhaps this sounds familiar:
    our PageRank computation is nearly identical to the power iteration algorithm
    that we presented in section 14\. Power iteration repeatedly takes the product
    of a matrix and a vector; eventually, the product converges to an eigenvector
    of the matrix. As a reminder, the eigenvector `v` of a matrix `M` is a special
    vector where `norm(v) == norm(M @ v)`. Usually, 10 iterations are sufficient to
    achieve convergence. Hence, our PageRank values converge because we’re running
    power iteration! This proves that our centrality vector is an eigenvector of the
    transition matrix. Thus, PageRank centrality is inexplicably linked to the beautiful
    mathematics behind dimensional reduction.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 中心性仍然是 0.048。10 次迭代足以收敛到一个稳定的值。为什么是这样呢？好吧，我们的 PageRank 计算不过是矩阵和向量的重复乘法。乘积向量的元素都是介于
    0 和 1 之间的值。也许这听起来很熟悉：我们的 PageRank 计算几乎与我们在第 14 节中介绍的幂迭代算法相同。幂迭代反复取矩阵和向量的乘积；最终，乘积收敛到矩阵的特征向量。作为提醒，矩阵
    `M` 的特征向量 `v` 是一个特殊的向量，其中 `norm(v) == norm(M @ v)`。通常，10 次迭代就足以实现收敛。因此，我们的 PageRank
    值收敛是因为我们在运行幂迭代！这证明了我们的中心性向量是转移矩阵的特征向量。因此，PageRank 中心性与降维背后的美丽数学不可分割地联系在一起。
- en: 'Given any graph `G`, we compute its PageRank centralities using the following
    series of steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何图 `G`，我们通过以下一系列步骤计算其 PageRank 中心性：
- en: Obtain the graph’s adjacency matrix `M`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取图的邻接矩阵 `M`。
- en: Convert the adjacency matrix into the transition matrix by running `M = M /
    M.sum(axis=0)`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行 `M = M / M.sum(axis=0)` 将邻接矩阵转换为转移矩阵。
- en: Update `M` to allow for random teleportation. This is done by taking the weighted
    mean of `M` and `1 / n`, where `n` equals the number of nodes in the graph. The
    weights are usually set to 0.85 and 0.15, so the weighted mean equals `0.85 *
    M + 0.15 / n`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `M` 以允许随机跳跃。这是通过取 `M` 和 `1 / n` 的加权平均来完成的，其中 `n` 等于图中的节点数。权重通常设置为 0.85 和
    0.15，因此加权平均等于 `0.85 * M + 0.15 / n`。
- en: Return the largest (and only) eigenvector of `M`. We can compute the eigenvector
    by running `v = M @ v` across approximately 10 iterations. Initially, vector `v`
    is set to `np.ones(n) / n`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回矩阵 `M` 的最大（且仅有一个）特征向量。我们可以通过运行 `v = M @ v` 大约 10 次迭代来计算特征向量。初始时，向量 `v` 被设置为
    `np.ones(n) / n`。
- en: Markov matrices tie graph theory together with probability theory and matrix
    theory. They can also be used to cluster network data using a procedure called
    *Markov clustering*. In the next subsection, we utilize Markov matrices to cluster
    communities in graphs.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫矩阵将图论与概率论和矩阵论联系在一起。它们还可以通过称为 *马尔可夫聚类* 的程序来聚类网络数据。在下一小节中，我们将利用马尔可夫矩阵来聚类图中的社区。
- en: Common NetworkX centrality computations
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的 NetworkX 中心性计算
- en: '`G.in_degree(i)`—Returns the in-degree of node `i` in a directed graph'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G.in_degree(i)`—返回有向图中节点 `i` 的入度'
- en: '`G.degree(i)`—Returns the degree of node `i` in an undirected graph'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G.degree(i)`—返回无向图中节点 `i` 的度'
- en: '`nx.pagerank(G)`—Returns a dictionary mapping between node IDs and their PageRank
    centralities'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nx.pagerank(G)`—返回一个字典，将节点 ID 映射到它们的 PageRank 中心性'
- en: 19.3 Community detection using Markov clustering
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.3 使用马尔可夫聚类进行社区检测
- en: Graph `G` represents a network of towns, some of which fall into localized counties.
    Currently, we know the county IDs, but what if we didn’t? How would we identify
    the counties? Let’s ponder this question by visualizing `G` without any sort of
    color mapping (figure 19.7).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 `G` 表示一个城镇网络，其中一些城镇属于本地县。目前，我们知道县 ID，但如果我们不知道呢？我们将如何识别县？让我们通过可视化 `G` 而不进行任何形式的颜色映射来思考这个问题（图
    19.7）。
- en: '![](../Images/19-07.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/19-07.png)'
- en: 'Figure 19.7 A network of roads between different towns. The towns have not
    been colored based on their counties. But we can still spot certain counties in
    our network: they appear as spatially clustered clumps.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.7 不同城镇之间的道路网络。城镇没有根据其县区着色。但我们在网络中仍然可以识别出某些县区：它们以空间聚集的团块形式出现。
- en: Listing 19.23 Plotting `G` without county-based coloring
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.23 不基于县区着色的 `G` 绘图
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Our plotted graph has neither colors nor labels. Still, we can spot potential
    counties: they look like tightly connected node clusters in the network. In graph
    theory, such clusters are formally referred to as *communities*. Graphs with clearly
    visible communities contain a *community structure*. Many types of graphs contain
    a community structure, including graphs of towns and graphs of social media friends.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绘制的图既没有颜色也没有标签。尽管如此，我们仍然可以识别出潜在的县区：它们在网络中看起来像是紧密连接的节点簇。在图论中，这样的簇正式被称为 *社区*。具有明显可见社区的图包含
    *社区结构*。许多类型的图都包含社区结构，包括城镇图和社交媒体朋友的图。
- en: Note Some common graphs do not contain a community structure. For instance,
    the internet lacks tightly clustered communities of web pages.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一些常见的图不包含社区结构。例如，互联网缺少紧密聚集的网页社区。
- en: The process of uncovering graph communities is called *community detection*
    or *graph clustering*. Multiple graph-clustering algorithms exist, some of which
    depend on simulations of traffic flow.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 揭示图社区的过程被称为 *社区检测* 或 *图聚类*。存在多种图聚类算法，其中一些依赖于交通流量的模拟。
- en: How can we use traffic to uncover clusters of counties in our network? Well,
    we know that towns in the same country are more likely to share a road than towns
    in different counties, so if we drive to a neighboring town, we are likely to
    remain in the same county. In community-structured graphs, this logic holds even
    if we drive two towns over. Suppose, for instance, that we drive from Town *i*
    to Town *j* and then to Town *k*. Based on our network structure, Towns *i* and
    *k* are more likely to be in the same county. We will confirm this statement shortly;
    however, first we need to compute the probability of a transition from Town *i*
    to Town *k* after two stops. This probability is called the *stochastic flow*,
    or *flow* for short. Flow is closely related to the transition probability; but
    unlike the transition probability, flow covers towns that aren’t directly connected.
    We need to calculate the flow between each pair of towns and store that output
    in a *flow matrix*. Later, we show that the average flow is higher in towns that
    share the same community.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何利用交通来揭示网络中县区的聚类？嗯，我们知道同一国家的城镇比不同县区的城镇更有可能共享道路，所以如果我们开车去邻近的城镇，我们很可能会留在同一个县。在具有社区结构的图中，即使我们开车穿越两个城镇，这个逻辑也是成立的。例如，假设我们开车从城镇
    *i* 到城镇 *j*，然后再到城镇 *k*。根据我们的网络结构，城镇 *i* 和 *k* 更有可能位于同一个县。我们很快就会证实这个说法；然而，首先我们需要计算从城镇
    *i* 到城镇 *k* 经过两站后的转换概率。这个概率被称为 *随机流量* 或简称为 *流量*。流量与转换概率密切相关；但与转换概率不同，流量覆盖了没有直接连接的城镇。我们需要计算每对城镇之间的流量，并将该输出存储在
    *流量矩阵* 中。稍后，我们将展示平均流量在共享同一社区城镇中更高。
- en: Note Generally, in network theory, flow is a very loosely defined concept. But
    in Markov clustering, that definition is constrained to the probability of eventual
    travel between nodes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一般来说，在网络理论中，流量是一个定义非常宽泛的概念。但在马尔可夫聚类中，这个定义被限制在节点之间最终旅行的概率。
- en: How do we calculate a matrix of flow values? One strategy is to simulate a two-stop
    journey between random towns. The simulated frequencies can then be converted
    into probabilities. However, it’s far easier to compute these probabilities directly.
    With a bit of math, we can show that the flow matrix is equal to `transition_matrix
    @ transition_matrix`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何计算流量值的矩阵？一种策略是在随机城镇之间模拟一次两站旅程。然后可以将模拟的频率转换为概率。然而，直接计算这些概率要容易得多。通过一点数学，我们可以证明流量矩阵等于
    `transition_matrix @ transition_matrix`。
- en: Note We can prove this statement as follows. Previously, we showed that the
    second-stop probabilities equal `transition_matrix @ transition_matrix @ v`. Furthermore,
    `transition_matrix @ transition_matrix` produces a new matrix, `M`. So, the second-stop
    probabilities equal `M @ v`. Essentially, `M` serves the same purpose as the `transition_matrix`,
    but it tracks two stops and not one; so `M` fits our definition of the flow matrix.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们可以如下证明这个陈述。之前，我们证明了第二站概率等于 `transition_matrix @ transition_matrix @ v`。此外，`transition_matrix
    @ transition_matrix` 产生一个新的矩阵，`M`。因此，第二站概率等于 `M @ v`。本质上，`M` 执行与 `transition_matrix`
    相同的功能，但它跟踪两个站点而不是一个；因此 `M` 符合我们对于流矩阵的定义。
- en: Basically, the random simulation approximates the product of the transition
    matrix with itself. Let’s quickly verify before proceeding.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，随机模拟近似了转换矩阵与其自身的乘积。在继续之前，让我们快速验证一下。
- en: Listing 19.24 Comparing computed flow to random simulations
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.24 比较计算流量与随机模拟
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Tracks the frequency with which we travel from Town i to Town k after two
    stops
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 跟踪两次停留后从城镇 i 到城镇 k 的频率
- en: ❷ Ensures that our simulated frequencies closely resemble the directly computed
    flow
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 确保我们的模拟频率与直接计算的流量非常相似
- en: 'Our `flow_matrix` is consistent with random simulations. Now, let’s test our
    theory that flow is higher between towns in the same county. As a reminder, each
    town in `G.nodes` has been assigned a county ID. We believe that the average flow
    between Towns *i* and *j* is higher if `G.nodes[i][''county_id'']` equals `G.nodes[j][''county_
    id'']`. We can confirm by separating all flows into two lists: `county_flows`
    and `between_county_flows`. The two lists track intra-county flows and inter-county
    flows, respectively. We’ll plot a histogram for each of the lists and compare
    their mean flow values (figure 19.8). If we are correct, then `np.mean(county_flows)`
    should be noticeably higher than the mean flow of the second list. We’ll also
    check whether any inter-county flows are explicitly less than `np.min(county_flows)`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `flow_matrix` 与随机模拟结果一致。现在，让我们测试我们的理论，即同一县内的城镇之间的流量更高。提醒一下，`G.nodes` 中的每个城镇都已被分配了一个县ID。我们相信，如果
    `G.nodes[i]['county_id']` 等于 `G.nodes[j]['county_id']`，那么城镇 *i* 和 *j* 之间的平均流量会更高。我们可以通过将所有流量分为两个列表来确认：`county_flows`
    和 `between_county_flows`。这两个列表分别跟踪县内流量和县间流量。我们将为每个列表绘制直方图并比较它们的平均流量值（图19.8）。如果我们正确，那么
    `np.mean(county_flows)` 应该明显高于第二个列表的平均流量。我们还将检查是否有任何县间流量明确小于 `np.min(county_flows)`。
- en: '![](../Images/19-08.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/19-08.png)'
- en: 'Figure 19.8 Two histograms representing all nonzero inter-county flows and
    intra-county flows. A separation between flow types is clearly visible. The inter-county
    flows skew strongly to the left: a threshold of approximately 0.042 is sufficient
    to separate 132 inter-county flows from the intra-county flow distribution.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.8 表示所有非零县间流量和县内流量的两个直方图。流量类型之间的分离非常明显。县间流量强烈偏向左侧：大约 0.042 的阈值足以将 132 个县间流量从县内流量分布中分离出来。
- en: Note that for a fair comparison, we should consider only the nonzero flows.
    So, we must skip over `flow_matrix[j][i]` if it has a zero value. A zero value
    implies that it’s impossible to travel from `i` to `j` in just two stops (the
    probability of this occurring is zero). At least three stops are required, which
    indicates that the towns are far away from each other. This practically guarantees
    that they are in different counties. Hence, the inclusion of zero flows would
    unfairly skew our distribution of inter-county values toward zero. Let’s challenge
    ourselves to examine the flows between only those towns that are in close proximity.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了进行公平的比较，我们应该只考虑非零流量。因此，如果 `flow_matrix[j][i]` 有零值，我们必须跳过 `flow_matrix[j][i]`。零值意味着仅用两次停留从
    `i` 到 `j` 是不可能的（这种情况发生的概率为零）。至少需要三次停留，这表明城镇相距很远。这实际上保证了它们位于不同的县。因此，包含零流量将不公平地使我们的县间值分布偏向零。让我们挑战自己，只检查那些城镇之间的流量，这些城镇地理位置相近。
- en: Listing 19.25 Comparing intra- and inter-county flow distributions
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.25 比较县内和县间流量分布
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Tracks nonzero intra-county flows
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 跟踪两次停留后从城镇 i 到城镇 k 的非零县内流量
- en: ❷ Tracks nonzero inter-county flows
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 跟踪非零县间流量
- en: ❸ We only iterate over nonzero rows in column i.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们只遍历列 i 中的非零行。
- en: ❹ Checks if two towns are in the same county
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查两个城镇是否位于同一县
- en: ❺ Tracks all inter-county flows that are below the minimum intra-county flows
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 跟踪所有低于最小县内流量的县间流量
- en: ❻ A histogram plot of intra-county flows
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 县内流量的直方图
- en: ❼ A histogram plot of inter-county flows
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 县际流量的直方图
- en: 'The mean flow between counties is three times lower than the mean flow between
    towns in different counties. This difference is clearly visible in the plotted
    distribution: flows below a threshold of approximately 0.04 are guaranteed to
    represent inter-county values. Thus, we can isolate inter-county towns using an
    explicit threshold cutoff. Of course, we’re only able to observe this threshold
    due to our advance knowledge of county identities. In a real-world scenario, the
    actual county IDs would not be known, so the separation cutoff would be impossible
    to explicitly determine. We’d be forced to assume that the cutoff is a low value,
    like 0.01\. Suppose we made that assumption with our data. How many nonzero inter-county
    flows are less than 0.01? Let’s find out.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 县际间的平均流量是不同县镇间平均流量的三分之一。这种差异在绘制的分布图中清晰可见：低于约0.04阈值的流量保证代表县际值。因此，我们可以使用显式的阈值截止来隔离县际镇。当然，我们之所以能够观察到这个阈值，是因为我们事先知道了县的身份。在现实世界的场景中，实际的县ID是未知的，因此分离截止无法明确确定。我们被迫假设截止值是一个低值，比如0.01。假设我们用我们的数据做出了这个假设。有多少非零县际流量小于0.01？让我们来看看。
- en: Listing 19.26 Decreasing the separation threshold
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.26 降低分离阈值
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: None of the flow values fall below the stringent threshold of 0.01\. What should
    we do? One option is to manipulate the flow distribution to exaggerate the difference
    between large and small values. Ideally, we’ll force small values to fall below
    0.01 while ensuring that larger flows do not drop in value. This manipulation
    can be carried out with a simple process called *inflation*. Inflation is intended
    to influence the values of a vector while keeping its mean constant. Values below
    the mean drop, while the remaining values increase. We’ll demonstrate inflation
    with a simple example. Suppose we’re inflating some vector `v`, which is equal
    to `[0.7, 0.3]`. The mean of `v` is 0.5\. We want to increase `v[0]` while decreasing
    `v[1]`. A partial solution is to square each element of `v` by running `v ** 2`.
    Doing so decreases `v[1]` from 0.3 to 0.09\. Unfortunately, it also decreases
    `v[0]` from 0.7 to 0.49, so `v[0]` drops below the original vector mean. We can
    alleviate the drop by dividing the squared vector by its sum to produce an inflated
    vector `v2`, whose sum is 1\. It follows that `v2.mean()` equals `v.mean()`. Furthermore,
    `v2[0]` is greater than `v[0]`, and `v2[1]` is less than `v[1]`. Let’s confirm.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 没有流量值低于严格的0.01阈值。我们应该怎么办？一个选择是操纵流量分布来夸大大小值之间的差异。理想情况下，我们将迫使小值低于0.01，同时确保较大的流量不会降低。这种操纵可以通过一个简单的过程来实现，称为*通货膨胀*。通货膨胀的目的是影响向量的值，同时保持其平均值不变。低于平均值的值会下降，而剩余的值会增加。我们将通过一个简单的例子来演示通货膨胀。假设我们正在膨胀一个向量`v`，其等于`[0.7,
    0.3]`。`v`的平均值是0.5。我们希望增加`v[0]`同时减少`v[1]`。一个部分解决方案是通过运行`v ** 2`对`v`的每个元素进行平方。这样做将`v[1]`从0.3降低到0.09。不幸的是，它也将`v[0]`从0.7降低到0.49，因此`v[0]`低于原始向量的平均值。我们可以通过将平方向量除以其和来减轻下降，从而产生一个膨胀向量`v2`，其和为1。因此，`v2.mean()`等于`v.mean()`。此外，`v2[0]`大于`v[0]`，而`v2[1]`小于`v[1]`。让我们来确认。
- en: Listing 19.27 Exaggerating value differences through vector inflation
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.27 通过向量通货膨胀夸大值差异
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Like vector `v`, the columns of our flow matrix are vectors whose elements sum
    to 1\. We can inflate each column by squaring its elements and then dividing by
    the subsequent column sum. Let’s define an `inflate` function for this purpose.
    Then we’ll inflate the flow matrix and rerun `compare_flow_distributions()` to
    check whether our inter-county threshold has decreased (figure 19.9).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与向量`v`一样，我们的流量矩阵的列也是元素之和为1的向量。我们可以通过平方其元素然后除以下一个列和来膨胀每一列。让我们为此定义一个`inflate`函数。然后我们将膨胀流量矩阵，并重新运行`compare_flow_distributions()`来检查我们的县际阈值是否降低（图19.9）。
- en: Listing 19.28 Exaggerating flow differences through vector inflation
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.28 通过向量通货膨胀夸大流量差异
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![](../Images/19-09.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/19-09.png)'
- en: 'Figure 19.9 Two histograms representing all nonzero inter-county flows and
    intra-county flows after inflation. The separation between flows has become more
    visible: inflation has decreased the separation threshold from 0.042 to 0.012.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.9展示了所有非零县际流量和县内流量在通货膨胀后的两个直方图。流量的分离变得更加明显：通货膨胀将分离阈值从0.042降低到0.012。
- en: 'After inflation, our threshold has decreased from 0.042 to 0.012, but it still
    remains above 0.01\. How do we further exaggerate the difference between inter-county
    and intra-county edges? The answer is surprisingly simple, although its reasoning
    is not immediately obvious: all we need to do is take the product of `flow_matrix`
    with itself and then inflate the results. In other words, setting the flow matrix
    to equal `inflate (flow_matrix @ flow_matrix)` will cause the threshold to drastically
    decrease. Let’s verify this claim before discussing the intuitive reasons behind
    the threshold drop (figure 19.10).'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 膨胀后，我们的阈值从0.042降低到了0.012，但仍然高于0.01。我们如何进一步放大县际和县内边之间的差异？答案是出人意料的简单，尽管其推理并不立即明显：我们只需要将`flow_matrix`与自身相乘，然后膨胀结果。换句话说，将流量矩阵设置为等于`inflate
    (flow_matrix @ flow_matrix)`将导致阈值急剧下降。在讨论阈值下降背后的直观原因之前，让我们验证这个说法（图19.10）。
- en: Listing 19.29 Inflating the product of `flow_matrix` with itself
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.29膨胀`flow_matrix`的乘积
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Before this step, flow_matrix was equal to inflate(transition_matrix @ transition_matrix).
    We are essentially repeating a matrix product that is then coupled with inflation.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在这一步之前，流量矩阵等于inflate(transition_matrix @ transition_matrix)。我们实际上是在重复一个矩阵乘法，然后将其与膨胀相结合。
- en: '![](../Images/19-10.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/19-10.png)'
- en: Figure 19.10 Two histograms representing all nonzero inter-county flows and
    intra-county flows after inflating `flow_matrix @ flow_matrix`. Most of the inter-county
    flows now fall below the very small separation threshold of 0.001.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.10展示了在将`flow_matrix @ flow_matrix`进行膨胀后，所有非零的县际流量和县内流量的两个直方图。现在，大部分的县际流量都低于非常小的分离阈值0.001。
- en: The threshold decreased to 0.001\. More than 500 inter-county roads fall below
    that threshold. Why was our strategy successful? We can answer with a straightforward
    analogy. Suppose that we can build new roads between the towns, but all built
    roads require some annual maintenance. A poorly maintained road will develop cracks
    and fissures. Drivers will be more reluctant to go down a damaged road, so periodic
    repairs are very important. However, in our analogy, there isn’t enough money
    to build new roads while repairing all existing roads in `G`. A local transportation
    bureau is given the difficult task of deciding
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值降低到了0.001。超过500条县际道路低于这个阈值。我们的策略为什么成功？我们可以用一个简单的类比来回答。假设我们可以在城镇之间建设新的道路，但所有建设的道路都需要进行一些年度维护。维护不当的道路会发展出裂缝和裂缝。驾驶员会更不愿意走上一条损坏的道路，因此定期的维修非常重要。然而，在我们的类比中，没有足够的资金来同时修复`G`中所有现有的道路并建设新的道路。一个地方交通局被赋予了决定
- en: Which new roads are built
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些新的道路被建设
- en: Which existing roads are maintained
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些现有的道路得到了维护
- en: Which existing roads are ignored
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些现有的道路被忽略
- en: 'The bureau makes the following assumption: pairs of towns with heavy flows
    require a better transportation infrastructure. Hence, a road between Towns *i*
    and *j* will be maintained only if `flow_matrix[i][j]` or `flow_matrix[j][i]`
    is high. If `flow_ matrix[i][j]` is high but there is no road between `i` and
    `j`, then resources will be allocated to connect Towns *i* and *j* directly.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 局部做出以下假设：流量大的城镇对需要更好的交通基础设施。因此，只有当`flow_matrix[i][j]`或`flow_matrix[j][i]`值高时，城镇*i*和*j*之间才会维护道路。如果`flow_matrix[i][j]`值高但*i*和*j*之间没有道路，那么资源将被分配以直接连接城镇*i*和*j*。
- en: Note A pair of non-neighboring towns will still have a high flow if multiple
    short detours exist between them. Building a road between that pair of towns makes
    sense since doing so will alleviate traffic along the detours.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注释：如果存在多条短途绕行，一对非相邻城镇之间仍然会有高流量。在这对城镇之间建设一条道路是有意义的，因为这样做可以缓解绕行的交通。
- en: Regrettably, not all existing roads will be maintained. Less-traveled inter-county
    roads will have a lower flow and will not receive attention from the bureau. Therefore,
    these roads will partially decay, and drivers will be less likely to travel between
    counties. Instead, the drivers will prefer to take the well-maintained intra-county
    roads, as well as newly built roads between the towns.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，并非所有现有的道路都会得到维护。较少使用的县际道路流量较低，不会引起局部的注意。因此，这些道路将部分退化，驾驶员之间穿越县份的可能性会降低。相反，驾驶员会更倾向于选择维护良好的县内道路，以及城镇之间新建的道路。
- en: Note As a reminder, we’re assuming that drivers travel randomly, without a particular
    destination in mind. Their aimless cruising is determined solely by the quality
    of road conditions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：作为提醒，我们假设司机随机旅行，没有特定的目的地。他们的漫无目的的驾驶完全由道路条件的质量决定。
- en: Road construction, maintenance, and decay will inevitably alter our transition
    matrix. Transition probabilities between decaying low-flow roads will drop. Meanwhile,
    the transition probabilities between well-maintained high-flow roads will increase.
    We need to somehow model the alteration to our matrix while ensuring that matrix
    columns still sum to 1\. How? With inflation, of course! Our `inflation` function
    exaggerates the differences between values in the matrix while maintaining a column
    sum of 1\. Thus, we’ll model the consequences of the bureau’s decision making
    by updating our transition matrix `M` to equal `inflation(flow_matrix)`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 道路建设、维护和退化不可避免地会改变我们的转移矩阵。低流量道路的退化之间的转移概率将下降。同时，维护良好的高流量道路之间的转移概率将增加。我们需要以某种方式模拟矩阵的变化，同时确保矩阵的列仍然总和为1。如何做？当然是通过通货膨胀！我们的`通货膨胀`函数放大矩阵中值的差异，同时保持列总和为1。因此，我们将通过更新我们的转移矩阵`M`等于`通货膨胀(flow_matrix)`来模拟局部的决策结果。
- en: 'But the story isn’t over. By changing the transition matrix, we also change
    the flow within the graph. Flow is equal to `M @ M`, where `M` is the flow matrix
    after inflation. Of course, the change will alter local resource allocation: after
    a new round of road construction and decay, the transition probabilities will
    come to equal `inflate(M @ M)`. We can model the impact of the iterative road
    work as `M = inflate(M @ M)`. Note that in the current version of our code, `M`
    is set to `flow_matrix`. Thus, running `flow_matrix = inflate(flow_matrix @ flow_matrix)`
    will reinforce well-traveled roads even as less popular roads wither away (figure
    19.11).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 但故事还没有结束。通过改变转移矩阵，我们也改变了图中的流量。流量等于`M @ M`，其中`M`是通货膨胀后的流量矩阵。当然，这种变化将改变局部资源分配：在新的道路建设和退化一轮之后，转移概率将等于`通货膨胀(M
    @ M)`。我们可以将迭代道路工作的影响建模为`M = 通货膨胀(M @ M)`。请注意，在当前版本的代码中，`M`被设置为`flow_matrix`。因此，运行`flow_matrix
    = 通货膨胀(flow_matrix @ flow_matrix)`将加强常走的道路，即使不太受欢迎的道路正在枯萎（图19.11）。
- en: '![](../Images/19-11.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/19-11.png)'
- en: Figure 19.11 Modeling changes to a road graph using inflation. Roads between
    tightly connected towns are reinforced. Meanwhile, resources are diverted from
    less trafficked roads, which causes these roads to decay. Eventually, only the
    roads within the graph’s communities remain.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.11 使用通货膨胀模拟道路图的变化。紧密相连的城镇之间的道路得到加强。同时，资源被从交通较少的道路上转移，这导致这些道路退化。最终，只有图中的社区内的道路仍然存在。
- en: 'This iterative feedback loop has unexpected ramifications: every year, the
    inter-county roads get worse and worse. As a result, more drivers stay within
    the boundaries of their county. More resources are allocated to the internal county
    roads, and the inter-county roads get less support and crumble further. It’s a
    vicious cycle—eventually, the inter-county roads will crumble to dust, and it
    will no longer be possible to travel from county to county. Each separate county
    will become like an isolated island that is completely cut off from its neighbors.
    This isolation makes for terrible transportation policy, but it greatly simplifies
    the process of community detection. An isolated town cluster is easy to detect
    since it lacks boundaries with any other cluster. Consequently, our model of road
    build-up and decay serves as a basis for a network clustering algorithm: the *Markov
    Cluster Algorithm* (MCL), also referred to as *Markov clustering*.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迭代反馈循环有出乎意料的后果：每年，县际道路的状况都会越来越差。结果，更多的司机选择留在他们所在县的边界内。更多的资源被分配到内部县道路，而县际道路得到的支持减少，进一步崩溃。这是一个恶性循环——最终，县际道路将化为尘土，从县到县的旅行将不再可能。每个单独的县将变成一个完全与邻居隔绝的孤立岛屿。这种隔离导致糟糕的交通政策，但它极大地简化了社区检测的过程。一个孤立的城镇集群很容易检测，因为它与其他集群没有边界。因此，我们的道路建设与退化模型成为网络聚类算法的基础：*马尔可夫聚类算法*（MCL），也称为*马尔可夫聚类*。
- en: MCL is executed by running `inflate(flow_matrix @ flow_matrix)` over many repeating
    iterations. With each iteration, the inter-county flows get smaller and smaller;
    eventually they drop to zero. Meanwhile, the intra-county flows maintain their
    positive values. This binary difference allows us to identify tightly connected
    county clusters. Listing 19.30 attempts to execute MCL by running `flow_matrix
    = inflate (flow_matrix @ flow_matrix)` across 20 iterations.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: MCL 通过多次重复迭代运行 `inflate(flow_matrix @ flow_matrix)` 来执行。随着每次迭代的进行，跨县流量会越来越小；最终它们会降至零。与此同时，内县流量保持正值。这种二进制差异使我们能够识别紧密连接的县集群。列表
    19.30 尝试通过在 20 次迭代中运行 `flow_matrix = inflate (flow_matrix @ flow_matrix)` 来执行
    MCL。
- en: Listing 19.30 Inflating the product of `flow_matrix` repeatedly with itself
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.30 重复使用自身膨胀 `flow_matrix` 的乘积
- en: '[PRE29]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Based on our discussion, certain edges in graph `G` should now have a flow of
    zero. We expect these edges to connect diverging counties. Let’s isolate the suspected
    inter-county edges. We iterate over every edge `(i, j)` by calling the `G.edges()`
    method. Then we track each edge `(i, j)` for which the flow is nonexistent and
    sort all the tracked edges in a `suspected_inter_county` edges list.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的讨论，图 `G` 中的某些边现在应该有零流量。我们预计这些边将连接分叉县。让我们隔离可疑的跨县边。我们通过调用 `G.edges()` 方法遍历每个边
    `(i, j)`。然后我们跟踪每个边 `(i, j)`，其中流量不存在，并将所有跟踪到的边按 `suspected_inter_county` 边列表排序。
- en: Listing 19.31 Selecting suspected inter-county edges
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.31 选择可疑跨县边
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 57 edges lack any flow. We suspect that these edges connect towns between diverging
    counties. Deleting the suspected edges from our graph should sever all cross-county
    connections, so only clustered counties should remain if we visualize the graph
    after edge deletion. Let’s verify by deleting the suspected edges from a copy
    of our graph (figure 19.12). We utilize the NetworkX `remove_edge_from` method
    to delete all edges in the `suspected_inter_county` list.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 57 条边没有任何流量。我们怀疑这些边连接着分叉县之间的城镇。从我们的图中删除这些可疑边应该切断所有跨县连接，因此如果我们在删除边后可视化图，应该只剩下集群县。让我们通过从我们图的副本（图
    19.12）中删除可疑边来验证这一点。我们使用 NetworkX 的 `remove_edge_from` 方法来删除 `suspected_inter_county`
    列表中的所有边。
- en: Listing 19.32 Deleting suspected inter-county edges
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.32 删除可疑跨县边
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Running G.copy() returns a copied version of graph G. We can delete the edges
    in the copy while preserving edges in the original graph.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用 G.copy() 返回图 G 的副本。我们可以在副本中删除边，同时保留原始图中的边。
- en: '![](../Images/19-12.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片 19-12](../Images/19-12.png)'
- en: Figure 19.12 A network of towns after the deletion of all suspected inter-county
    edges. All counties have been fully isolated from each other. Four of the six
    counties have been fully preserved, but the remaining two counties are no longer
    fully connected.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.12 删除所有可疑跨县边后的城镇网络。所有县之间都已完全隔离。六个县中有四个已完全保留，但剩下的两个县不再完全相连。
- en: 'All inter-county edges have been eliminated. Unfortunately, a few key intra-county
    edges have also been deleted. Towns 8, 10, and 20 are no longer connected to any
    other towns. Our algorithm acted too aggressively. Why is this the case? The problem
    is due to a minor error in our model: it assumes that travelers can drive to neighboring
    towns, but it does not allow travelers to remain in their current location. This
    has unexpected consequences.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 所有跨县边都已消除。不幸的是，一些关键的内县边也被删除了。城镇 8、10 和 20 现在不再与其他城镇相连。我们的算法过于激进。为什么会出现这种情况？问题源于我们模型的一个小错误：它假设旅行者可以开车去邻近的城镇，但不允许旅行者停留在当前位置。这产生了意外的后果。
- en: 'We’ll illustrate with a simple two-node network. Imagine that a single road
    connects Towns A and B. In our current model, a driver in Town A has no choice
    except to travel to Town B. But the driver cannot stay: they must turn around
    and go back to Town A. A two-stop path does not exist between the towns, even
    though they are connected. Consequently, the flow between the towns will equal
    zero, and their connecting road will be eliminated. Of course, this situation
    is ridiculous—we should give the driver an option of remaining in Town B. How?
    One solution is to add an edge from Town B to itself. That edge is like a looping
    road, which takes you back to your current destination (figure 19.13). In other
    words, the edge is a self-loop. Adding self-loops to a graph will limit unexpected
    model behavior. Listing 19.33 illustrates the impact of self-loops in a simple
    two-node adjacency matrix.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一个简单的双节点网络来说明。想象一下，一条单独的道路连接着A镇和B镇。在我们的当前模型中，A镇的司机除了去B镇别无选择。但司机不能停留：他们必须掉头回到A镇。两个城镇之间不存在两站点的路径，尽管它们是相连的。因此，城镇之间的流量将等于零，连接它们的道路将被消除。当然，这种情况是荒谬的——我们应该给司机一个留在B镇的选择。怎么办？一个解决方案是从B镇到B镇添加一条边。这条边就像一条环路，带你回到你的当前位置（图19.13）。换句话说，这条边是一个自环。向图中添加自环将限制意外的模型行为。列表19.33展示了在简单的双节点邻接矩阵中自环的影响。
- en: Listing 19.33 Improving flow by adding self-loops
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.33 通过添加自环改进流量
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![](../Images/19-13.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/19-13.png)'
- en: Figure 19.13 A graph indicating possible travel paths between Town A and Town
    B. Circular self-loops in each of the nodes allow a traveler to remain in place
    rather than journeying to a neighboring town. Without these loops, the traveler
    is forced to journey nonstop from A to B and back. If this happens, the flow between
    the towns will equal zero.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.13 A镇和B镇之间可能的旅行路径图。每个节点中的圆形自环允许旅行者停留在原地而不是前往邻近的城镇。如果没有这些环，旅行者被迫不间断地从A镇到B镇再返回。如果发生这种情况，城镇之间的流量将等于零。](../Images/19-13.png)'
- en: 'Adding self-loops to graph `G` should limit inappropriate edge deletions. We
    can add the loops by running `G.add_edge(i, i)` for every `i` in `G.nodes`. With
    this in mind, let’s now define a `run_mcl` function that runs MCL on an inputted
    graph by executing the following steps:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 向图 `G` 添加自环应限制不适当的边删除。我们可以通过为 `G.nodes` 中的每个 `i` 运行 `G.add_edge(i, i)` 来添加这些环。考虑到这一点，现在让我们定义一个
    `run_mcl` 函数，该函数通过执行以下步骤在输入的图上运行MCL：
- en: Add a self-loop to each node in the graph.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向图中每个节点添加一个自环。
- en: Compute the graph’s transition matrix by dividing the adjacency matrix by its
    column sums.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将邻接矩阵除以其列和来计算图的转移矩阵。
- en: Calculate the flow matrix from `transition_matrix @ transition_matrix`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `transition_matrix @ transition_matrix` 计算流量矩阵。
- en: Set `flow_matrix` to equal `inflate(flow_matrix @ flow_matrix)` over the course
    of 20 iterations.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在20次迭代过程中将 `flow_matrix` 设置为等于 `inflate(flow_matrix @ flow_matrix)`。
- en: Delete all edges in the graph that lack a flow.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除图中所有没有流量的边。
- en: After defining `run_mcl`, we execute the function on a copy of graph `G`. The
    plotted output should retain all relevant intra-county edges while also deleting
    all edges between the communities (figure 19.14).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 `run_mcl` 之后，我们在图 `G` 的副本上执行该函数。绘制的输出应保留所有相关的县内边，同时删除社区之间的所有边（图19.14）。
- en: Listing 19.34 Defining an MCL function
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.34 定义MCL函数
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Adds self-loops to each node in the graph
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为图中每个节点添加自环
- en: '![](../Images/19-14.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/19-14.png)'
- en: Figure 19.14 A network of towns after MCL was used to delete all inter-county
    edges. All counties have been fully isolated from each other. The internal connections
    within each county have also been fully preserved.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.14 使用MCL删除所有跨县边后的城镇网络。所有县之间已经完全隔离。每个县内的内部连接也已完全保留。](../Images/19-14.png)'
- en: 'Our graph has clustered perfectly into six secluded counties. The towns in
    each country are accessible to each other while remaining isolated from the outside
    world. In graph theory, such isolated clusters are referred to as *connected components*
    : two nodes are in the same connected component if a path exists between them.
    Otherwise, the nodes exist in different components (and thus in different communities).
    To compute the full component of a node, it is sufficient to run `nx.shortest_path_length`
    on that node. The shortest path length algorithm returns only those nodes that
    are accessible within a clustered community. The following code uses `nx.shortest_path_
    length` to compute all towns that remain accessible from Town 0 and confirm that
    all these towns share the same county ID.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将图完美地聚类成六个隐蔽的县。每个县内的城镇之间可以互相访问，同时与外界保持隔离。在图论中，这样的孤立集群被称为*连通分量*：如果两个节点之间存在路径，则它们属于同一个连通分量。否则，节点存在于不同的分量（因此存在于不同的社区）。要计算一个节点的完整分量，只需在该节点上运行`nx.shortest_path_length`即可。最短路径长度算法仅返回那些在聚类社区内可访问的节点。以下代码使用`nx.shortest_path_length`计算所有从城镇0可访问的城镇，并确认所有这些城镇共享相同的县ID。
- en: Listing 19.35 Using path lengths to uncover a county cluster
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.35 使用路径长度揭示县集群
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With minor modifications to the shortest path length algorithm, we can extract
    a graph’s connected components. For brevity’s sake, we will not discuss these
    modifications, but you’re encouraged to try to work them out for yourself. This
    modified component algorithm is incorporated into NetworkX: calling `nx.connected_components(G)`
    returns an iterable over all connected components in `G`. Each connected component
    is stored as a set of node IDs. Let’s utilize this function to output all the
    county clusters.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对最短路径长度算法进行轻微修改，我们可以提取图的连通分量。为了简洁起见，我们不会讨论这些修改，但鼓励你自己尝试解决这些问题。这个修改后的分量算法已集成到NetworkX中：调用`nx.connected_components(G)`返回`G`中所有连通分量的可迭代对象。每个连通分量存储为节点ID的集合。让我们利用这个函数输出所有县集群。
- en: Listing 19.36 Extracting all the clustered connected components
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.36 提取所有聚类连通分量
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Common network matrix computations
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的网络矩阵计算
- en: '`adjaceny_matrix = nx.to_numpy_array(G)`—Returns the graph’s adjacency matrix.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adjaceny_matrix = nx.to_numpy_array(G)`—返回图的邻接矩阵。'
- en: '`degrees = adjaceny_matrix.sum(axis=0)`—Computes the degree vector using the
    adjacency matrix.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`degrees = adjaceny_matrix.sum(axis=0)`—使用邻接矩阵计算度向量。'
- en: '`transition_matrix = adjacency_matrix / degrees`—Computes the graph’s transition
    matrix.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transition_matrix = adjacency_matrix / degrees`—计算图的转移矩阵。'
- en: '`stop_1_probabilities = transition_matrix @ v`—Computes the probabilities of
    making a first stop at each node. Here, we assume that `v` is a vector of equally
    likely starting probabilities.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop_1_probabilities = transition_matrix @ v`—计算在每个节点处第一次停下的概率。在这里，我们假设`v`是一个具有等可能起始概率的向量。'
- en: '`stop_2_probabilities = transition_matrix @ stop_1_probabilities`—Computes
    the probabilities of making a second stop at each node.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop_2_probabilities = transition_matrix @ stop_1_probabilities`—计算在每个节点处第二次停下的概率。'
- en: '`transition_matrix @ stop_n_probabilities`—Returns the probabilities of making
    an *N* + 1 stop at each node.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transition_matrix @ stop_n_probabilities`—返回在每个节点处进行*N* + 1次停下的概率。'
- en: '`flow_matrix = transition_matrix @ transition_matrix`—Computes the probability
    matrix of transitioning between `i` and `j` in two stops.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flow_matrix = transition_matrix @ transition_matrix`—计算在两次停留中从`i`到`j`的转移概率矩阵。'
- en: '`(flow_matrix ** 2) / (flow_matrix ** 2).sum(axis=0)`—Inflates the flows in
    the flow matrix.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(flow_matrix ** 2) / (flow_matrix ** 2).sum(axis=0)`—在流量矩阵中膨胀流量。'
- en: 'We’ve successfully uncovered the communities in our graph using very little
    code. Unfortunately, our MCL implementation will not scale to very large networks.
    Further optimizations are required for successful scaling; these optimizations
    have been integrated into the external Markov clustering library. Let’s install
    the library and import two functions from the installed `markov_clustering` module:
    `get_clusters` and `run_mcl`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功使用很少的代码揭示了图中的社区。不幸的是，我们的MCL实现无法扩展到非常大的网络。需要进一步的优化才能成功扩展；这些优化已集成到外部马尔可夫聚类库中。让我们安装库并从已安装的`markov_clustering`模块导入两个函数：`get_clusters`和`run_mcl`。
- en: Note Call `pip install markov_clustering` from the command line terminal to
    install the Markov clustering library.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：从命令行终端调用`pip install markov_clustering`以安装马尔可夫聚类库。
- en: Listing 19.37 Importing from the Markov clustering library
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.37 从马尔可夫聚类库导入
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Given an adjacency matrix `M`, we can efficiently execute Markov clustering
    by running `get_clusters(run_mcl(M))`. The nested function call returns a `clusters`
    list. Each element in `clusters` equals a tuple of nodes that form a clustered
    community. Let’s carry out this clustering on our original graph `G`. The outputted
    clusters should remain consistent with the connected components in `G_copy`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个邻接矩阵 `M`，我们可以通过运行 `get_clusters(run_mcl(M))` 来高效地执行马尔可夫聚类。嵌套函数调用返回一个 `clusters`
    列表。`clusters` 中的每个元素都是一个节点元组，这些节点形成一个聚类社区。让我们在我们的原始图 `G` 上执行这个聚类。输出的聚类应该与 `G_copy`
    中的连通分量保持一致。
- en: Listing 19.38 Clustering with the Markov clustering library
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.38 使用马尔可夫聚类库进行聚类
- en: '[PRE37]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With Markov clustering, we can detect communities in community-structured graphs.
    This will prove useful when we search for groups of friends in social networks.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过马尔可夫聚类，我们可以在社区结构图中检测社区。当我们搜索社交网络中的朋友群体时，这将非常有用。
- en: 19.4 Uncovering friend groups in social networks
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 19.4 在社交网络中揭示朋友群体
- en: We can represent many processes as networks, including relationships between
    people. In these *social networks*, nodes represent individual people. An edge
    exists between two people if they somehow socially interact. For instance, we
    can connect two people by an edge if they are friends.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将许多过程表示为网络，包括人与人之间的关系。在这些 *社交网络* 中，节点代表个人。如果两个人在社会上有某种互动，则它们之间存在边。例如，如果两个人是朋友，我们可以通过边连接他们。
- en: 'Many different types of social networks are possible. Some networks are digital:
    for example, FriendHook’s service is structured around online connections. However,
    social networks were studied for many decades before the rise of social media.
    One of the most-studied social networks originated in the 1970s: *Zachery’s Karate
    Club*, based on the social structure of a university karate club, recorded by
    a scientist named Wayne Zachery. Over the course of three years, Zachery tracked
    friendships between the 34 members of the club. Edges were assigned to track friends
    who frequently met up outside the club. After three years, something unexpected
    happened: a karate instructor named Mr. Hi left to start a new club of his own,
    and half of the karate club went with him. Much to Zachery’s surprise, most of
    the departing members could be identified solely from network structure.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在许多不同类型的社交网络。有些网络是数字化的：例如，FriendHook 的服务是围绕在线连接构建的。然而，在社交媒体兴起之前，社交网络已经被研究了数十年。最被研究的社会网络之一起源于
    20 世纪 70 年代：*Zachery 的空手道俱乐部*，这是由一位名叫 Wayne Zachery 的科学家根据一所大学空手道俱乐部的社交结构记录下来的。在三年时间里，Zachery
    跟踪了俱乐部 34 名成员之间的友谊。边被分配来追踪在俱乐部外频繁聚会的朋友。三年后，发生了一些意想不到的事情：一位名叫 Mr. Hi 的空手道教练离开了，去创立他自己的新俱乐部，一半的空手道俱乐部成员随他而去。让
    Zachery 意外的是，大多数离开的成员仅从网络结构中就可以被识别出来。
- en: We’ll now repeat Zachery’s experiment. First we’ll load his famous karate network,
    which is available through NetworkX. Calling `nx.karate_club_graph()` returns
    that graph. The following code prints the graph nodes along with their attributes.
    As a reminder, we can output nodes with attributes by calling `G.nodes(data=True)`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将重复 Zachery 的实验。首先，我们将加载他著名的空手道网络，该网络可通过 NetworkX 获得。调用 `nx.karate_club_graph()`
    返回该图。以下代码打印出图节点及其属性。作为提醒，我们可以通过调用 `G.nodes(data=True)` 来输出带有属性的节点。
- en: Listing 19.39 Loading the karate club graph
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.39 加载空手道俱乐部图
- en: '[PRE38]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our nodes track 34 people. Each node has a `club` attribute set to `Mr. Hi`
    if the person joined `Mr. Hi`’s new club or `Officer` otherwise. Let’s visualize
    the network: we color each node based on `club` attribute type (figure 19.15).'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跟踪 34 个人。如果一个人加入了 Mr. Hi 的新俱乐部，则每个节点都有一个设置为 `Mr. Hi` 的 `club` 属性；否则设置为 `Officer`。让我们可视化这个网络：我们根据
    `club` 属性类型给每个节点着色（图 19.15）。
- en: '![](../Images/19-15.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/19-15.png)'
- en: Figure 19.15 The visualized karate club graph. The node colors correspond to
    the splitting of the club. These colors overlap with the graph’s community structure.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 19.15 可视化的空手道俱乐部图。节点颜色对应于俱乐部的分裂。这些颜色与图的社区结构重叠。
- en: Listing 19.40 Visualizing the karate club graph
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 19.40 可视化空手道俱乐部图
- en: '[PRE39]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The karate club graph has a clear community structure. This is not surprising;
    many social networks contain detectable communities. In this case, the communities
    correspond to the splitting of the club: the black-colored cluster on the left
    side of the plot represents the club members who left to join with Mr. Hi, and
    the right-side cluster represents students who stayed behind. These clusters represent
    friend groups that formed over multiple years. When the split happened, most members
    simply went along with their preferred group of friends.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 空手道俱乐部图具有清晰的社区结构。这并不令人惊讶；许多社交网络都包含可检测的社区。在这种情况下，社区对应于俱乐部的分裂：图表左侧的黑色簇代表离开加入希先生的那部分俱乐部成员，右侧的簇代表留下来的学生。这些簇代表了在多年中形成的友谊群体。当发生分裂时，大多数成员只是跟随他们偏好的朋友群体。
- en: Can we extract these friend clusters automatically? We can try, using MCL. First
    we run the algorithm on the graph’s adjacency matrix and print all the resulting
    clusters.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否自动提取这些友谊簇？我们可以尝试使用MCL。首先，我们在图的邻接矩阵上运行算法，并打印出所有生成的簇。
- en: Listing 19.41 Clustering the karate club graph
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.41 对空手道俱乐部图进行聚类
- en: '[PRE40]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Two clusters have been outputted, as expected. We now replot the graph while
    coloring each node based on cluster ID (figure 19.16).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，输出了两个簇。我们现在重新绘制图表，同时根据簇ID着色每个节点（图19.16）。
- en: Listing 19.42 Coloring the plotted graph based on cluster
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.42 根据簇着色绘制的图表
- en: '[PRE41]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![](../Images/19-16.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/19-16.png)'
- en: Figure 19.16 The visualized karate club graph. The node colors correspond to
    the community clusters. These colors overlap with the eventual splitting of the
    club.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.16 可视化的空手道俱乐部图。节点颜色对应社区簇。这些颜色与俱乐部最终的分裂重叠。
- en: 'Our clusters are nearly identical to the two splintered clubs. MCL has capably
    extracted the friend groups in the social network, so the algorithm should serve
    us well as we pursue our case study solution. In our case study, we’re asked to
    analyze a digital social network. Extracting existing friend groups could prove
    invaluable to that analysis. Of course, in a large network, the number of groups
    will be greater than two—we can expect to encounter a dozen (or perhaps a few
    dozen) friend clusters. We’ll also probably want to visualize these clusters in
    the graph. Manually assigning colors to a dozen clusters is a tedious task, so
    we’ll want to generate the cluster colors automatically. In NetworkX, we can automate
    color assignment as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成的簇几乎与两个分裂的俱乐部相同。MCL成功地从社交网络中提取了友谊群体，因此该算法在追求我们的案例研究解决方案时应该会很有用。在我们的案例研究中，我们被要求分析一个数字社交网络。提取现有的友谊群体可能对分析非常有价值。当然，在一个大型网络中，组数将大于两个——我们可以预期会遇到一打（或许更多）的友谊簇。我们还可能想要在图中可视化这些簇。手动为十几个簇分配颜色是一项繁琐的任务，因此我们希望自动生成簇颜色。在NetworkX中，我们可以如下自动化颜色分配：
- en: Create a mapping between each node and its cluster ID by adding a `cluster_id`
    attribute to each node.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在每个节点上添加一个`cluster_id`属性，创建每个节点与其簇ID之间的映射。
- en: Set each element of `node_colors` to equal a cluster ID, rather than the color.
    This can be done by running `[G.nodes[n]['cluster_id'] for n in G.nodes]`, where
    `G` is the clustered social graph.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`node_colors`中的每个元素设置为等于簇ID，而不是颜色。这可以通过运行`[G.nodes[n]['cluster_id'] for n in
    G.nodes]`来完成，其中`G`是聚类社交图。
- en: Pass `cmap=plt.cm.tab20` into `nx.draw`, along with the numeric `node_colors`
    list. The `cmap` parameter assigns a color mapping to each cluster ID. `plt.cm.tab20`
    represents the color palette used to generate that mapping; we’ve previously used
    color palette mappings to generate heatmap plots (see section 8 for details).
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`cmap=plt.cm.tab20`传递给`nx.draw`，以及数字`node_colors`列表。`cmap`参数为每个簇ID分配颜色映射。`plt.cm.tab20`代表生成该映射的颜色调色板；我们之前已经使用颜色调色板映射来生成热图（见第8节详情）。
- en: Let’s execute these steps to color our clusters automatically (figure 19.17).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行这些步骤来自动着色我们的簇（图19.17）。
- en: Listing 19.43 Coloring social graph clusters automatically
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 列表19.43 自动着色社交图簇
- en: '[PRE42]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: ❶ Assigns a cluster ID to every node
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为每个节点分配簇ID
- en: ❷ Maps node colors to numeric cluster IDs
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将节点颜色映射到数字簇ID
- en: ❸ Uses the plt.cm.tab20 color palette to assign a color mapping to each cluster
    ID
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用plt.cm.tab20颜色调色板为每个簇ID分配颜色映射
- en: '![](../Images/19-17.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/19-17.png)'
- en: Figure 19.17 The visualized karate club graph. The node colors correspond to
    the community clusters. These colors were generated in an automated manner.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.17 可视化的空手道俱乐部图。节点颜色对应社区簇。这些颜色是自动生成的。
- en: We’ve completed our deep dive into graph theory. In the next section, we use
    our newfound knowledge to derive a simple, graph-based prediction algorithm.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了对图论的深入研究。在下一节中，我们将利用我们新获得的知识来推导一个简单基于图的预测算法。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: The edge count of a node in an undirected graph is simply called the node’s
    *degree*. We can compute the degree of every node by summing over the columns
    of the graph’s adjacency matrix.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在无向图中，节点的边数简单地称为节点的*度*。我们可以通过计算图的邻接矩阵的列的和来计算每个节点的度。
- en: In graph theory, any measure of a node’s importance is commonly called *node
    centrality*. Ranked importance based on a node’s degree is called the *degree
    of centrality*.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图论中，任何衡量节点重要性的度量通常称为*节点中心性*。基于节点度的排名重要性称为*中心度*。
- en: Sometimes, the degree of centrality is an inadequate measure of node importance.
    We can better derive centrality by simulating random traffic in the network. The
    traffic can be converted into a probability of randomly winding up at a particular
    node.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，中心度的大小不足以衡量节点的重要性。我们可以通过在网络中模拟随机流量来更好地推导中心度。流量可以被转换成随机到达特定节点的概率。
- en: Traffic probability can be computed directly from the graph’s *transition matrix*.
    The transition matrix tracks the likelihood of randomly traveling from node `i`
    to node `j`. Repeatedly taking the product of the transition matrix and a probability
    vector produces a vector of final end-point likelihoods. Higher likelihoods correspond
    to more central nodes. This measure of centrality is known as *PageRank centrality*;
    mathematically, it is equal to the eigenvector of the transition matrix.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量概率可以直接从图的*转移矩阵*中计算得出。转移矩阵跟踪从节点`i`随机旅行到节点`j`的可能性。重复将转移矩阵与概率向量相乘会产生一个最终端点可能性的向量。较高的可能性对应于更中心的节点。这种中心性度量称为*PageRank中心性*；从数学上讲，它等于转移矩阵的特征向量。
- en: Certain graphs, when visualized, show tightly connected clusters. These clusters
    of nodes are called *communities*. Graphs with clearly visible communities are
    said to contain a *community structure*. The process of uncovering communities
    in graphs is called *community detection*.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些图在可视化时显示出紧密连接的集群。这些节点集群被称为*社区*。具有明显可见社区的图被称为包含*社区结构*。在图中揭示社区的过程称为*社区检测*。
- en: We can detect communities using the *Markov Cluster Algorithm* (MCL). This algorithm
    requires us to compute a *stochastic flow*, which is a multistop transition probability.
    Taking the product of the transition matrix with itself produces a flow matrix.
    Lower flow values are more likely to correspond with inter-community edges. This
    difference between low and high flow values can be further amplified via *inflation*.
    Iteratively repeating matrix multiplication and inflation causes inter-community
    flows to drop to zero. Then, deleting zero-flow edges completely isolates the
    graph’s communities. These isolated components can be identified with a variant
    of the shortest path length algorithm.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用*马尔可夫聚类算法*（MCL）来检测社区。此算法要求我们计算一个*随机流量*，这是一个多站过渡概率。通过将转移矩阵与其自身相乘产生流量矩阵。较低的流量值更有可能与社区间的边相对应。这种低流量值和高流量值之间的差异可以通过*膨胀*进一步放大。通过迭代重复矩阵乘法和膨胀，社区间的流量会降至零。然后，删除零流量边可以完全隔离图中的社区。这些隔离的组件可以通过最短路径长度算法的变体来识别。
- en: In *social networks*, edges represent relationships between people. Social networks
    commonly contain a community structure, so we can use MCL to detect clusters of
    friends in these networks.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*社交网络*中，边代表人与人之间的关系。社交网络通常包含社区结构，因此我们可以使用MCL来检测这些网络中朋友的集群。
