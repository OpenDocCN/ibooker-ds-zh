- en: Appendix C. Picking your build tool
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录C. 选择你的构建工具
- en: 'Deciding on a technology is always difficult. You don’t want to make commitments
    you can’t back out of, but eventually you have to choose something. Committing
    to a build technology is no different in this regard: it’s an important choice
    and you should treat it as such.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 决定一项技术总是困难的。你不想做出无法撤销的承诺，但最终你必须做出选择。在构建技术方面的承诺在这方面没有不同：这是一个重要的选择，你应该这样对待它。
- en: 'For the purposes of this book, I decided on Grunt as my build tool of choice.
    I made an effort to not go overboard on Grunt-specific concepts, but rather to
    explain build processes in the grand scheme of things, using Grunt as an accessory—the
    means to an end. I chose Grunt for several reasons; a few of these are shown in
    the following list:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这本书的目的，我决定选择 Grunt 作为我的首选构建工具。我努力不偏重于 Grunt 特定的概念，而是从更广泛的角度解释构建过程，将 Grunt
    作为一种辅助手段——达到目的的手段。我选择 Grunt 的原因有几个；以下列表中展示了其中的一些：
- en: Grunt has a healthy community around it, even on Windows.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grunt 在 Windows 上也有一个健康的社区。
- en: It’s widely popular; it’s even used beyond the Node community.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它非常受欢迎；它甚至被 Node 社区之外的人使用。
- en: It’s easy to learn; you pick plugins and configure them. No advanced concepts
    are used and no prior knowledge is needed.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它很容易学习；你选择插件并配置它们。不需要使用高级概念，也不需要任何先前的知识。
- en: These are all good reasons to use Grunt to teach build processes in a book,
    but I want to make it clear I don’t think Grunt is the single best option out
    there; other popular build tools might fit your needs better than Grunt.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是使用 Grunt 在书中教授构建过程的好理由，但我想明确指出，我不认为 Grunt 是唯一最佳选择；其他流行的构建工具可能比 Grunt 更适合你的需求。
- en: 'I wrote this appendix to help you understand the differences between the three
    build tools I use most often in front-end development workflows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我写这个附录是为了帮助你理解我在前端开发工作流程中最常用的三个构建工具之间的区别：
- en: Grunt, the configuration-driven build tool that you use throughout this book
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书所使用的配置驱动型构建工具 Grunt
- en: npm, a package manager that can also double as a build tool
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: npm，一个也可以作为构建工具使用的包管理器
- en: Gulp, a code-driven build tool that’s somewhere between Grunt and npm
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gulp，一个介于 Grunt 和 npm 之间的代码驱动型构建工具
- en: I’ll also lay out the situations in which a particular tool may be better than
    the others.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我还会列出一些特定工具可能比其他工具更好的情况。
- en: You should read [part 1](kindle_split_011.html#part01) and [appendix A](kindle_split_022.html#app01)
    of the book before going through this appendix. Grunt is introduced in [appendix
    A](kindle_split_022.html#app01) and covered throughout [part 1](kindle_split_011.html#part01).
    I assume basic knowledge of Grunt in this appendix. As a first step, let’s discuss
    where Grunt excels.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这个附录之前，你应该阅读这本书的[第1部分](kindle_split_011.html#part01)和[附录A](kindle_split_022.html#app01)。Grunt
    在[附录A](kindle_split_022.html#app01)中介绍，并在[第1部分](kindle_split_011.html#part01)中进行了全面介绍。在这个附录中，我假设你对
    Grunt 有基本了解。作为第一步，让我们讨论 Grunt 优于其他工具的地方。
- en: 'C.1\. Grunt: the good parts'
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.1. Grunt：优点
- en: The single best aspect of Grunt is its ease of use. It enables programmers to
    develop build flows using JavaScript almost effortlessly. All that’s required
    is searching for the appropriate plugin, reading its documentation, and then installing
    and configuring it. This ease of use means members of large development teams,
    who are often of varying skill levels, don’t have any trouble tweaking the build
    flow to meet the latest needs of the project. The team doesn’t need to be fluent
    in Node, either; they need to add properties to the configuration object and task
    names to the different arrays that make up the build flow.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 的最佳特性是其易用性。它使程序员能够几乎毫不费力地使用 JavaScript 开发构建流程。所需做的只是搜索合适的插件，阅读其文档，然后安装和配置它。这种易用性意味着大型开发团队中的成员，他们的技能水平往往不同，在调整构建流程以满足项目最新的需求时不会有任何困难。团队也不需要精通
    Node；他们只需要向配置对象添加属性，并将任务名称添加到构建流程的不同数组中。
- en: Grunt’s plugin base is large enough that you’ll rarely find yourself developing
    your own build tasks, which also enables you and your team to rapidly develop
    a build process. This rapid development is crucial if you’re going for a build
    first approach, even when taking small steps and progressively developing your
    build flows.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt 的插件库足够大，你很少需要自己开发构建任务，这也使得你和你的团队能够快速开发构建过程。如果你采取的是先构建的方法，即使只是小步骤和逐步开发构建流程，这种快速开发也是至关重要的。
- en: It’s also feasible to manage deployments through Grunt, as many packages exist
    to accommodate for those tasks, such as `grunt-git`, `grunt-rsync`, and `grunt-ec2`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Grunt管理部署也是可行的，因为存在许多用于这些任务的包，例如`grunt-git`、`grunt-rsync`和`grunt-ec2`。
- en: 'C.2\. Grunt: the bad parts'
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.2\. Grunt：缺点
- en: Where does Grunt fall short? It may get too verbose if you have a significantly
    large build flow. It’s often hard to make sense of the build flow as a whole once
    it has been in development for a while. When the task count in your build flows
    gets to the double digits, it’s almost guaranteed that you’ll find yourself having
    to run targets that belong to the same task individually, so you can compose the
    flow in the right order.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt的不足之处在哪里？如果你有一个相当大的构建流程，它可能会变得过于冗长。一旦开发了一段时间，通常很难理解整个构建流程。当你的构建流程中的任务数量达到两位数时，几乎可以肯定你会发现自己需要单独运行属于同一任务的目标，以便以正确的顺序组合流程。
- en: Because tasks are configured declaratively, you’ll also have a hard time figuring
    out the order in which tasks get executed. In addition, your team should be dedicated
    to writing maintainable code when it comes to your builds. In the case of Grunt,
    you’ll maintain separate files for the configuration of each task, or at least
    for each of the build flows that your team uses.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任务是声明性配置的，你也会很难弄清楚任务的执行顺序。此外，当涉及到构建时，你的团队应该致力于编写可维护的代码。在Grunt的情况下，你将维护每个任务的配置文件，或者至少是团队使用的每个构建流程的配置文件。
- en: 'Now that we’ve identified the good and the bad in Grunt, as well as the situations
    in which it might be a good fit for your project, let’s talk about npm: how it
    can be used as a build tool and its differences from Grunt.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了Grunt的优点和缺点，以及它可能适合你项目的场景，让我们谈谈npm：它如何作为构建工具使用以及它与Grunt的不同之处。
- en: C.3\. npm as a build tool
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C.3\. npm作为构建工具
- en: 'To use npm as a build tool, you’ll need a package.json file and npm itself.
    Defining tasks for npm is as easy as adding properties to a `scripts` object in
    your package manifest. The name of the property will be used as the task name,
    and the value will be the command you want to execute. The following snippet represents
    a typical package.json file, using the JSHint command-line interface to run a
    linter through your JavaScript files and check for errors. Using npm, you can
    run any shell command at your disposal:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要将npm用作构建工具，你需要一个package.json文件和npm本身。为npm定义任务就像在你的包清单中添加`scripts`对象的属性一样简单。属性名将用作任务名，值将是你要执行的命令。以下代码片段代表一个典型的package.json文件，使用JSHint命令行界面通过JavaScript文件运行lint器并检查错误。使用npm，你可以运行任何可用的shell命令：
- en: '|  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Grunt in a nutshell**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**Grunt概述**'
- en: 'Grunt has the following benefits:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt有以下优点：
- en: Thousands of plugins that do what you need.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数千个插件可以满足你的需求。
- en: Easy-to-understand and tweak configuration.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于理解和调整的配置。
- en: Only a basic understanding of JavaScript is necessary.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只需要基本的JavaScript理解。
- en: Supports cross-platform development. Yes, even Windows!
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持跨平台开发。是的，甚至是Windows！
- en: Works great for most teams.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大多数团队来说效果很好。
- en: 'Grunt has a few drawbacks:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Grunt有一些缺点：
- en: Configuration-based build definitions become increasingly unwieldy as they grow
    larger.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着配置的构建定义越来越大，它们变得越来越难以管理。
- en: It’s hard to follow build flows when there are many multitarget task definitions
    involved.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当涉及许多多目标任务定义时，很难跟踪构建流程。
- en: Grunt is considerably slower than other build tools.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grunt比其他构建工具慢得多。
- en: '|  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the task is defined, it can be executed in your command line by running
    the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了任务，你就可以通过运行以下命令在你的命令行中执行它：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that npm provides shortcuts for specific task names. In the case of `test`,
    you can do `npm test` and omit the `run` verb. You can compose build flows by
    chaining `npm run` commands together in your script declarations. The following
    listing allows you to run the `unit` task right after the `lint` task by executing
    the `npm test` command.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，npm为特定的任务名提供了快捷方式。在`test`的情况下，你可以执行`npm test`并省略`run`动词。你可以在脚本声明中通过链式`npm
    run`命令来组合构建流程。以下列表允许你在执行`lint`任务后立即运行`unit`任务，通过执行`npm test`命令。
- en: Listing C.1\. Chaining npm `run` commands together to make build flows
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表C.1\. 将npm `run`命令链起来以创建构建流程
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can also schedule tasks as background jobs, making them asynchronous. Suppose
    you have the following package file, where you’ll copy a directory in your JavaScript
    build flow and compile a Stylus style sheet during your CSS build flow (Stylus
    is a CSS preprocessor). In this case, running the tasks asynchronously is ideal.
    You can achieve that using `&` as a separator, or after a command, as shown in
    the following listing of your package manifest. Afterward, you can execute `npm
    run build` to process both steps concurrently.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将任务作为后台作业来调度，使其异步执行。假设你有一个以下这样的包文件，其中你将在你的 JavaScript 构建流程中复制一个目录，并在你的 CSS
    构建流程中编译 Stylus 样式表（Stylus 是 CSS 预处理器）。在这种情况下，异步运行任务是最理想的。你可以使用 `&` 作为分隔符，或者在命令之后，如你的包描述文件中的以下列表所示。之后，你可以执行
    `npm run build` 来并发处理这两个步骤。
- en: Listing C.2\. Using Stylus
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 C.2\. 使用 Stylus
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Sometimes a shell command won’t suffice, and you may need a Node package such
    as `stylus` or `jshint`, as you saw in the last few examples. These dependencies
    should be installed through npm.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候一个 shell 命令是不够的，你可能需要一个 Node 包，比如 `stylus` 或 `jshint`，正如你在最后几个例子中看到的。这些依赖应该通过
    npm 安装。
- en: C.3.1\. Installing npm task dependencies
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.3.1\. 安装 npm 任务依赖
- en: 'The JSHint CLI isn’t necessarily available in your system, and you have two
    ways to install it:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: JSHint CLI 并不一定在你的系统中可用，你有两种安装它的方法：
- en: Globally, when using it from your command line
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在全局范围内，当你从命令行使用它时
- en: Adding it as a devDependency, when using it in an `npm run` task
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在 `npm run` 任务中使用时将其添加为 devDependency
- en: 'If you want to use the tool directly from your command line, and not in an
    `npm run` task, you should install it globally using the `-g` flag in the following
    command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要直接从命令行使用这个工具，而不是在 `npm run` 任务中，你应该使用以下命令中的 `-g` 标志全局安装它：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you’re using the package in an `npm run` task, then you should add it as
    a `dev-Dependency`, as shown in the following command. That allows npm to find
    the JSHint package on any system where the package dependencies are installed,
    rather than expecting the environment to have JSHint installed globally. This
    applies to any CLI tools that aren’t readily available in operating systems.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个 `npm run` 任务中使用这个包，那么你应该将其添加为 `dev-Dependency`，如下面的命令所示。这允许 npm 在任何已安装包依赖的系统上找到
    JSHint 包，而不是期望环境全局安装了 JSHint。这适用于任何在操作系统中不可直接使用的 CLI 工具。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You aren’t limited to using only CLI tools. In fact, npm can run any shell script.
    Let’s dig into that!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅限于使用 CLI 工具。实际上，npm 可以运行任何 shell 脚本。让我们深入探讨这一点！
- en: C.3.2\. Using shell scripts in npm tasks
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.3.2\. 在 npm 任务中使用 shell 脚本
- en: The following example is a script that runs on Node and displays a random emoji
    string. The first line tells the environment that the script is in Node.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个在 Node 上运行并显示随机表情字符串的脚本示例。第一行告诉环境脚本是在 Node 环境中。
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you place that script in a file named `emoji` at the root of your project,
    you’d have to declare `emoji-random` as a dependency and add the command to the
    `scripts` object in the package manifest:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这个脚本放在项目根目录下名为 `emoji` 的文件中，你将不得不将 `emoji-random` 声明为依赖，并将命令添加到包描述文件中的 `scripts`
    对象：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once that’s out of the way, running the command is merely a matter of invoking
    `npm run emoji` in your terminal, which will execute the command you specified
    as the value for `emoji` in the `scripts` property of your package manifest.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些问题解决，运行命令就只是在你终端中调用 `npm run emoji` 的事情，这将执行你在包描述文件 `scripts` 属性中为 `emoji`
    指定的命令。
- en: 'C.3.3\. npm and Grunt compared: the good and the bad'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C.3.3\. npm 与 Grunt 对比：优点与缺点
- en: 'Using npm as a build tool has several advantages over Grunt:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 npm 作为构建工具相较于 Grunt 有几个优势：
- en: You aren’t constrained to Grunt plugins, and you can take advantage of all of
    npm, which hosts tens of thousands of packages.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不受 Grunt 插件的限制，可以利用 npm 的所有功能，npm 上托管了成千上万的包。
- en: You won’t need any additional CLI tooling or files other than `npm`, which you’re
    already using to manage dependencies and your `package.json` manifest, where dependencies
    and your build commands are listed. Because `npm` runs CLI tools and Bash commands
    directly, it’ll perform way better than Grunt could.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要除了 `npm` 以外的任何额外的 CLI 工具或文件，你已经在使用 `npm` 来管理依赖和你的 `package.json` 描述文件，其中列出了依赖和你的构建命令。因为
    `npm` 直接运行 CLI 工具和 Bash 命令，所以它的性能将远远优于 Grunt。
- en: Take into account that one of the biggest disadvantages of Grunt is the fact
    that it’s I/O bound. Most Grunt tasks read from disk and then write to disk. If
    you have several tasks working on the same files, chances are that the file will
    be read from disk multiple times. In Bash, commands can pipe the output of a command
    directly into the next one, avoiding the extra I/O overhead in Grunt.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 Grunt 最大的缺点之一是它是 I/O 密集型的。大多数 Grunt 任务都是从磁盘读取然后写入磁盘。如果你有多个任务在处理相同的文件，那么文件可能会被多次从磁盘读取。在
    Bash 中，命令可以直接将一个命令的输出管道传输到下一个命令，从而避免了 Grunt 中额外的 I/O 负载。
- en: Probably the biggest disadvantage to npm is the fact that Bash doesn’t play
    well with Windows environments. Open source projects using `npm run` might run
    into issues when people try to fiddle with them on Windows. In a similar light,
    Windows developers will try to use alternatives to npm. That drawback pretty much
    rules out npm for projects that need to run on Windows.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: npm 可能最大的缺点是 Bash 在 Windows 环境中表现不佳。使用 `npm run` 的开源项目在人们尝试在 Windows 上修改它们时可能会遇到问题。类似地，Windows
    开发者会尝试使用 npm 的替代品。这个缺点几乎排除了 npm 在需要运行在 Windows 上的项目中的应用。
- en: Gulp, another build tool, presents similarities to both Grunt and npm, as you’ll
    discover in a moment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp，另一个构建工具，与 Grunt 和 npm 都有相似之处，你很快就会发现。
- en: 'C.4\. Gulp: the streaming build tool'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'C.4\. Gulp: 流式构建工具'
- en: 'Gulp is similar to Grunt in that it relies on plugins and it’s cross-platform,
    supporting Windows users as well. Gulp is a code-driven build tool, in contrast
    with Grunt’s declarative approach to task definition, making your task definitions
    a bit easier to read. Gulp is also similar to `npm run` in that it uses Node streams
    to read files and pipe data through functions that transform it into output that
    will end up written to disk. This means Gulp doesn’t have the disk-intensive I/O
    issues you may observe when using Grunt. It’s also faster than Grunt for the same
    reason: less time spent in I/O.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp 与 Grunt 类似，因为它依赖于插件并且是跨平台的，也支持 Windows 用户。Gulp 是一个代码驱动的构建工具，与 Grunt 的声明式任务定义方法相比，使你的任务定义更容易阅读。Gulp
    也类似于 `npm run`，因为它使用 Node 流来读取文件并通过函数将数据转换为最终写入磁盘的输出。这意味着 Gulp 没有你在使用 Grunt 时可能观察到的磁盘密集型
    I/O 问题。它也比 Grunt 快，原因相同：减少了 I/O 的时间。
- en: The main disadvantage to using Gulp is that it relies heavily on streams, pipes,
    and asynchronous code. Don’t get me wrong; if you’re into Node, that’s definitely
    an advantage. But the issue with those concepts is that unless you and your team
    are well versed in Node, you’ll probably run into issues dealing with streams
    if you have to build your own Gulp task plugins.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Gulp 的主要缺点是它严重依赖于流、管道和异步代码。请别误会；如果你喜欢 Node，那确实是一个优点。但问题是，除非你和你的团队对 Node 非常熟悉，否则如果你必须构建自己的
    Gulp 任务插件，你可能会遇到处理流的难题。
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Gulp**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gulp**'
- en: 'There are a few things that are great about Gulp:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Gulp 有几点是很好的：
- en: High-quality plugins are readily available.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高质量的插件很容易获得。
- en: Code-driven means your Gulpfile will be easier to follow than a configuration-driven
    Gruntfile.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码驱动意味着你的 Gulpfile 比配置驱动的 Gruntfile 更容易理解。
- en: Faster than Grunt because it uses stream pipes rather than read and write to
    disk every time.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比 Grunt 快，因为它使用流管道而不是每次都读写磁盘。
- en: Supports cross-platform development, the way Grunt does.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Grunt 一样，支持跨平台开发。
- en: 'Gulp has drawbacks as well:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp 也有一些缺点：
- en: It might be hard to learn if you don’t have experience with Node.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你没有 Node 的经验，学习起来可能有些困难。
- en: Developing quality plugins is hard for similar reasons.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于类似的原因，开发高质量的插件也很困难。
- en: All of your team (current members and prospects) should be comfortable with
    streams and asynchronous code.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的整个团队（现有成员和潜在成员）都应该熟悉流和异步代码。
- en: The task dependency system leaves much to be desired.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务依赖系统还有许多需要改进的地方。
- en: '|  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: When working in teams, Gulp isn’t as prohibitive as npm. Most of your front-end
    team probably knows JavaScript, although chances are they’re not that fluent in
    Bash scripting, and some of them may be using Windows! That’s why I usually suggest
    keeping `npm run` to your personal projects and maybe using Gulp in projects where
    the team is comfy with Node, and Grunt everywhere else. That’s my personal opinion;
    figure out what works best for you and your team. Also, you shouldn’t constrain
    yourself to Grunt, Gulp, or `npm run` because those tools work for me. Do research
    and maybe you’ll find a tool that you like even better than those three.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当团队协作时，Gulp 并不像 npm 那样具有约束性。你们前端团队中的大多数人可能知道 JavaScript，尽管他们可能不太擅长 Bash 脚本编写，而且有些人可能在使用
    Windows！这就是为什么我通常建议将 `npm run` 保留在个人项目中，并在团队对 Node 感到舒适的项目中使用 Gulp，在其他所有地方使用 Grunt。这是我个人的观点；找出对你和你的团队最有效的方法。此外，你不应该将自己局限于
    Grunt、Gulp 或 `npm run`，因为那些工具对我有用。进行研究，也许你会找到一个你甚至比这三个更好的工具。
- en: Let’s walk through several examples to get a feel for what Gulp tasks look like.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过几个示例来了解 Gulp 任务的模样。
- en: Running Tests in Gulp
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 Gulp 中运行测试
- en: 'Gulp is similar to Grunt in its conventions. In Grunt there’s a `Gruntfile.js`
    file, used to define your build tasks, and in Gulp the file needs to be named
    `Gulpfile.js` instead. The other minor difference is that in the case of Gulp,
    the CLI is contained in the same package as the task runner, so you have to install
    the `gulp` package from npm both locally and globally:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp 在其约定上与 Grunt 类似。在 Grunt 中有一个 `Gruntfile.js` 文件，用于定义你的构建任务，而在 Gulp 中文件需要命名为
    `Gulpfile.js`。其他小的区别是，在 Gulp 的情况下，CLI 包含在同一个包中，因此你必须在本地和全局范围内从 npm 安装 `gulp` 包：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To get started, I’ll create a Gulp task to lint a JavaScript file, using JSHint
    the way you’ve already seen with Grunt and `npm run.` In the case of Gulp, you
    have to install the `gulp-jshint` Gulp plugin for JSHint:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我将创建一个 Gulp 任务来检查 JavaScript 文件，使用 JSHint 的方式，就像你已经用 Grunt 和 `npm run` 看到的那样。在
    Gulp 的情况下，你必须安装 `gulp-jshint` Gulp 插件用于 JSHint：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that you’re fully equipped with the CLI that you globally installed, the
    local `gulp` installation, and the `gulp-jshint` plugin, you can put together
    the build task to run the linter. To define build tasks with Gulp, you have to
    write them programmatically in the `Gulpfile.js` file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完全配备了全局安装的 CLI、本地的 `gulp` 安装和 `gulp-jshint` 插件，你可以组合构建任务来运行检查器。要使用 Gulp
    定义构建任务，你必须以编程方式在 `Gulpfile.js` 文件中编写它们。
- en: 'First, use `gulp.task`, passing it a task name and a function. The function
    contains all of the code necessary to run that task. Here you should use `gulp.src`
    to create a read stream into your source files. You can provide the paths to individual
    files, or use a globbing pattern such as the ones you’ve seen in your experiences
    learning about Grunt. That same stream should be piped into the JSHint plugin,
    which you can configure or use with the defaults it comes with. Then all you have
    to do is pipe the results of the JSHint task through a reporter and have it print
    the results to your terminal. All of what I described results in the following
    Gulpfile:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `gulp.task`，传递给它一个任务名称和一个函数。该函数包含运行该任务所需的所有代码。在这里，你应该使用 `gulp.src` 来创建一个读取流到你的源文件。你可以提供单个文件的路径，或者使用你学习
    Grunt 时看到的 globbing 模式。相同的流应该被管道输入到 JSHint 插件中，你可以配置或使用它自带默认设置。然后你只需要将 JSHint
    任务的输出通过一个报告器管道，并将其打印到你的终端。我描述的所有内容都导致了以下 Gulpfile：
- en: '![](290fig01_alt.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![290fig01_alt.jpg](290fig01_alt.jpg)'
- en: 'I should also mention that you’re returning the stream so Gulp understands
    that it should wait for the data to stop flowing before it considers the task
    completed. You can use a custom JSHint reporter to make the output more concise
    and easier to read by humans. JSHint reporters don’t need to be Gulp plugins,
    so you can use `jshint-stylish` for example. Let’s install it locally:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该提到，你正在返回流，这样 Gulp 就会明白在它认为任务完成之前，它应该等待数据停止流动。你可以使用自定义的 JSHint 报告器来使输出更简洁，更易于人类阅读。JSHint
    报告器不需要是 Gulp 插件，所以你可以使用 `jshint-stylish` 这样的工具。让我们在本地上安装它：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The updated Gulpfile should look like the following code. It’ll load the `jshint-stylish`
    module to format the reporting output.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的 Gulpfile 应该看起来像以下代码。它将加载 `jshint-stylish` 模块来格式化报告输出。
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You’re done! That’s all you have to do to declare a Gulp task named `test.`
    It can be run using the following command, provided you installed the `gulp` CLI
    globally:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！这就是你需要做的所有事情来声明一个名为 `test` 的 Gulp 任务。如果你全局安装了 `gulp` CLI，则可以使用以下命令运行它：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That was a trivial example. You can pipe the output of the JSHint linter through
    a reporter that will print the results of the linting test. You can also write
    output to disk using gulp.dest, which creates a write stream. Let’s step through
    another build task.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那只是一个简单的例子。你可以将 JSHint 检查器的输出通过一个报告器传递，该报告器会打印出 linting 测试的结果。你还可以使用 gulp.dest
    将输出写入磁盘，它创建了一个写入流。让我们逐步分析另一个构建任务。
- en: Building a Library in Gulp
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 Gulp 中构建库
- en: 'To get started, let’s do the bare minimum—read from disk with `gulp.src` and
    write back to disk piping the contents of the source file into `gulp.dest`, effectively
    copying the file into another directory:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们做最基本的事情——使用 `gulp.src` 从磁盘读取，并将源文件的内容通过 `gulp.dest` 写回磁盘，实际上是将文件复制到另一个目录：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Copying the file is nice, but it doesn’t minify its contents. To do that, you
    have to use a Gulp plugin. In this case you can use `gulp-uglify,` a plugin for
    the popular UglifyJS minifier:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 复制文件是件好事，但它不会压缩其内容。要这样做，你必须使用一个 Gulp 插件。在这种情况下，你可以使用 `gulp-uglify`，这是一个流行的 UglifyJS
    压缩器的插件：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you probably realized, streams let you add more plugins while only reading
    and writing to disk once. As an example, let’s pipe through `gulp-size` as well,
    which will calculate the size of the contents in the buffer and print that to
    the terminal. Note that if you add it before Uglify then you get the unminified
    size, and if you add it after, you get the minified size. You could also do both!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经意识到的，流允许你在只读取和写入磁盘一次的情况下添加更多插件。作为一个例子，让我们通过 `gulp-size` 也进行管道处理，这将计算缓冲区内容的尺寸并将其打印到终端。请注意，如果你在
    Uglify 之前添加它，你会得到未压缩的尺寸，如果在之后添加，你会得到压缩后的尺寸。你也可以两者都做！
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To reinforce the point on the ability to add or remove pipes as needed, let’s
    add one last plugin. This time you’ll use `gulp-header` to add license information
    to the minified piece of code, such as the name, the package version, and the
    license type. To run the example shown in the following listing, enter `gulp build`
    in your command line.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调根据需要添加或删除管道的能力，让我们添加最后一个插件。这次你将使用 `gulp-header` 为压缩后的代码片段添加许可信息，例如名称、包版本和许可类型。要运行以下列表中显示的示例，请在命令行中输入
    `gulp build`。
- en: Listing C.3\. Using `gulp-header` to add license information
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 C.3\. 使用 `gulp-header` 添加许可信息
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As in Grunt, in Gulp you can define flows by passing in an array of task names
    to `gulp.task,` instead of a function. The main difference between Grunt and Gulp
    in this regard is that Gulp executes these dependencies asynchronously, while
    Grunt executes them synchronously.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Grunt 一样，在 Gulp 中，你可以通过传递一个任务名称数组到 `gulp.task` 来定义流程，而不是一个函数。在这方面，Grunt 和
    Gulp 的主要区别在于 Gulp 以异步方式执行这些依赖项，而 Grunt 以同步方式执行。
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In Gulp, if you want to run tasks synchronously you have to declare a task as
    a dependency and then define your own task. All dependencies are executed before
    your task starts.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Gulp 中，如果你想同步运行任务，你必须将任务声明为一个依赖项，然后定义你自己的任务。所有依赖项都在你的任务开始之前执行。
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you take anything away from this appendix, it should be that it doesn’t matter
    which tool you use, as long as it allows you to compose the build flows you need
    in a way that doesn’t make you work too hard for it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从这个附录中带走任何东西，那应该是这样的：无论你使用哪种工具，只要它能让你以不让你过于费力的方式组合所需的构建流程即可。
