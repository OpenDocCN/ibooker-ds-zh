- en: '15 The Kentucky Friar: More regular expressions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15 肯塔基修士：更多正则表达式
- en: '| I grew up in the American Deep South where we tend to drop the final “g”
    of words ending in “ing,” like “cookin’” instead of “cooking.” We also tend to
    say “y’all” for the second-person plural pronoun, which makes sense because Standard
    English is missing a distinctive word for this. In this exercise, we’ll write
    a program called friar.py that will accept some input as a single positional argument
    and transform the text by replacing the final “g” with an apostrophe (’) for two-syllable
    words ending in “ing” and changing “you” to “y’all.” Granted, we have no way to
    know if we’re changing the first- or second-person “you,” but it makes for a fun
    challenge nonetheless. | ![](../Images/15-unnumb-1.png)  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| 我在美国南部长大，那里我们倾向于省略以“ing”结尾的单词的最后一个“g”，比如用“cookin’”而不是“cooking”。我们还说“y’all”作为第二人称复数代词，这很有道理，因为标准英语缺少一个独特的词来表示这个。在这个练习中，我们将编写一个名为friar.py的程序，它将接受一些输入作为单个位置参数，并通过将两个音节以“ing”结尾的单词的最后一个“g”替换为撇号（''）以及将“you”改为“y’all”来转换文本。诚然，我们无法知道我们是在改变第一人称还是第二人称的“you”，但这仍然是一个有趣的挑战。
    | ![](../Images/15-unnumb-1.png)  |'
- en: 'Figure 15.1 is a string diagram that will help you see the inputs and outputs.
    When run with no arguments or with the `-h` or `--help` flags, your program should
    present the following usage statement:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1是一个字符串图，它将帮助你看到输入和输出。当没有参数或使用`-h`或`--help`标志运行时，你的程序应该显示以下用法说明：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](../Images/15-1.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15-1.png)'
- en: Figure 15.1 Our program will modify the input text to give it a Southern lilt.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1我们的程序将修改输入文本，使其带有南方口音。
- en: 'We will only change “-ing” words with *two syllables*, so “cooking” becomes
    “cookin’” but “swing” will stay the same. Our heuristic for identifying two-syllable
    “-ing” words is to inspect the part of the word before the “-ing” ending to see
    if it contains a vowel, which in this case will include “y.” We can split “cooking”
    into “cook” and “ing,” and because there is an “o” in “cook,” we should drop the
    final “g”:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会改变带有*两个音节*的“-ing”单词，所以“cooking”变成“cookin’”，但“swing”将保持不变。我们识别两个音节“-ing”单词的启发式方法是检查单词中“-ing”结尾之前的部分，看看它是否包含元音，在这个例子中包括“y”。我们可以将“cooking”分成“cook”和“ing”，因为“cook”中有一个“o”，所以我们应该去掉最后的“g”：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we remove “ing” from “swing,” though, we’re left with “sw,” which contains
    no vowel, so it will remain the same:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从“swing”中移除“ing”时，我们剩下的是“sw”，它不包含元音，所以它将保持不变：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When changing “you” to “y’all,” be mindful to keep the case the same on the
    first letter. For example, “You” should become “Y’all”:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当将“you”改为“y’all”时，请注意保持第一个字母的大小写不变。例如，“You”应该变成“Y’all”：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As in several previous exercises, the input may name a file, in which case you
    should read the file for the input text. To pass the tests, you will need to preserve
    the line structure of the input, so I recommend you read the file line by line.
    Given this input,
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的几个练习一样，输入可能指定了一个文件，在这种情况下，你应该读取该文件以获取输入文本。为了通过测试，你需要保留输入的行结构，所以我建议你逐行读取文件。给定这个输入，
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'the output should have the same line breaks:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该有相同的换行符：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To me, it’s quite amusing to transform texts this way, but maybe I’m just weird:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，以这种方式转换文本非常有趣，但也许我只是有点奇怪：
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this exercise you will
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将
- en: '|'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Learn more about using regular expressions
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解更多关于使用正则表达式的信息
- en: Use both `re.match()` and `re.search()` to find patterns anchored to the beginning
    of a string or anywhere in the string, respectively
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`re.match()`和`re.search()`分别找到锚定到字符串开头或字符串任何位置的图案
- en: Learn how the `$` symbol in a regex anchors a pattern to the *end* of a string
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习正则表达式中的`$`符号如何将模式锚定到字符串的*末尾*
- en: Learn how to use `re.split()` to split a string
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用`re.split()`来分割字符串
- en: Explore how to write a manual solution for finding two-syllable “-ing” words
    or the word “you”
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索如何编写一个手动解决方案来查找两个音节的“-ing”单词或单词“you”
- en: '| ![](../Images/15-unnumb-2.png)  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/15-unnumb-2.png)  |'
- en: 15.1 Writing friar.py
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1 编写friar.py
- en: 'As usual, I recommend you start with `new.py` `friar.py` or copy the template/template.py
    file to 15_friar/friar.py. I suggest you start with a simple version of the program
    that echoes back the input from the command line:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，我建议你从`new.py` `friar.py`开始，或者将模板/模板.py文件复制到15_friar/friar.py。我建议你从一个简单的程序版本开始，该程序会回显命令行中的输入：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or from a file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或者从一个文件中：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We need to process the input line by line, and then word by word. You can use
    the `str.splitlines()` method to get each line of the input, and then use the
    `str.split()` method to break the line on spaces into word-like units. This code,
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要逐行逐字地处理输入。你可以使用`str.splitlines()`方法来获取输入的每一行，然后使用`str.split()`方法在空格上拆分行，将其拆分为类似单词的单元。这段代码，
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'should create this output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 应该生成以下输出：
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you look closely, it’s going to be difficult to handle some of these word-like
    units because the adjacent punctuation is still attached to the words, as in `'Father,'`
    and `'going?'` Splitting the text on spaces is not sufficient, so I’ll show you
    how to split the text *using a regular expression*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，处理这些类似单词的单元将会很困难，因为相邻的标点符号仍然附着在单词上，例如`'Father,'`和`'going?'`。在空格上拆分文本是不够的，所以我将向你展示如何使用正则表达式拆分文本。
- en: 15.1.1 Splitting text using regular expressions
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.1 使用正则表达式拆分文本
- en: 'As in chapter 14, we need to `import` `re` to use regexes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如第14章所述，我们需要`import` `re`来使用正则表达式：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For demonstration purposes, I’m going to set `text` to the first line:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我将`text`设置为第一行：
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By default, `str.split()` breaks text on spaces. Note that whatever text is
    used for splitting will be missing from the result, so here there are no spaces:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`str.split()`在空格上拆分文本。请注意，用于拆分的任何文本都将从结果中缺失，因此这里没有空格：
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can pass an optional value to `str.split()` to indicate the string you
    want to use for splitting. If we choose the comma, we’ll end up with three strings
    instead of six. Note that there are no commas in the resulting list, as that is
    the argument to `str.split()`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向`str.split()`传递一个可选值来指示你想要用于拆分的字符串。如果我们选择逗号，我们将得到三个字符串而不是六个。注意，结果列表中没有逗号，因为那是`str.split()`的参数：
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `re` module has a function called `re.split()` that works similarly. I
    recommend you read `help(re.split)`, as this is a very powerful and flexible function.
    Like `re.match()`, which we used in chapter 14, this function wants at least a
    `pattern` and a `string`. We can use `re.split()` with a comma to get the same
    output as `str.split()`, and, as before, the commas are missing from the result:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`re`模块有一个名为`re.split()`的函数，其工作方式类似。我建议你阅读`help(re.split)`，因为这个函数非常强大且灵活。就像我们在第14章中使用的`re.match()`函数一样，这个函数至少需要一个`pattern`和一个`string`。我们可以使用`re.split()`与逗号一起使用，以获得与`str.split()`相同的输出，并且，像之前一样，结果中没有逗号：'
- en: '[PRE15]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 15.1.2 Shorthand classes
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.2 简写类
- en: 'We are after the things that look like “words,” in that they are composed of
    the characters that normally occur in words. The characters that *don’t* normally
    occur in words (things like punctuation) are what we want to use for splitting.
    You’ve seen before that we can create a *character class* by putting literal values
    inside square brackets, like `''[aeiou]''` for the vowels. What if we create a
    character class where we enumerate all the non-letter characters? We could do
    something like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们寻找的是看起来像“单词”的东西，因为它们由通常出现在单词中的字符组成。那些*不*通常出现在单词中的字符（如标点符号）是我们想要用于拆分的。你之前已经看到，我们可以通过在方括号内放置字面值来创建一个*字符类*，例如`'[aeiou]'`用于元音。如果我们创建一个包含所有非字母字符的字符类会怎样？我们可以这样做：
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That won’t be necessary, because almost every implementation of regular expression
    engines define shorthand character classes. Table 15.1 lists some of the most
    common shorthand classes and how they can be written longhand.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将不是必要的，因为几乎每个正则表达式引擎的实现都定义了简写字符类。表15.1列出了一些最常见的简写类以及它们如何以长写形式表示。
- en: Table 15.1 Regex shorthand classes
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.1 正则表达式简写类
- en: '| Character class | Shorthand | Other ways to write the class |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 字符类 | 简写 | 其他写法 |'
- en: '| Digits | `\d` | `[0123456789]`, `[0-9]` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 数字 | `\d` | `[0123456789]`，`[0-9]` |'
- en: '| Whitespace | `\s` | `[ \t\n\r\x0b\x0c]`, same as `string.whitespace` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 空白字符 | `\s` | `[ \t\n\r\x0b\x0c]`，与`string.whitespace`相同 |'
- en: '| Word characters | `\w` | `[a-zA-Z0-9_-]` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 单词字符 | `\w` | `[a-zA-Z0-9_-]` |'
- en: Note There is a basic flavor of regular expression syntax that is recognized
    by everything from Unix command-line tools like `awk` to regex support inside
    of languages like Perl, Python, and Java. Some tools add extensions to their regexes
    that may not be understood by other tools. For example, there was a time when
    Perl’s regex engine added many new ideas that eventually became a dialect known
    as “PCRE” (Perl-Compatible Regular Expressions). Not every tool that understands
    regexes will understand every flavor of regex, but in all my years of writing
    and using regexes, I’ve rarely found this to be a problem.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，正则表达式语法的基本风味被从Unix命令行工具如`awk`到像Perl、Python和Java这样的语言中的正则表达式支持所识别。一些工具为它们的正则表达式添加了扩展，这些扩展可能不会被其他工具理解。例如，曾经有一段时间，Perl的正则表达式引擎添加了许多新想法，这些想法最终成为了一个被称为“PCRE”（Perl兼容正则表达式）的方言。并不是所有理解正则表达式的工具都会理解每种正则表达式的风味，但在我多年的正则表达式编写和使用经验中，我很少遇到这个问题。
- en: 'The shorthand `\d` means any *digit* and is equivalent to `''[0123456789]''`.
    I can use the `re.search()` method to look anywhere in a string for any digit.
    In the following example, it will find the character `''1''` in the string `''abc123!''`
    because this is the first digit in the string (see figure 15.2):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 简写`\d`表示任何*数字*，等同于`'[0123456789]'`。我可以使用`re.search()`方法在字符串的任何位置查找任何数字。在下面的例子中，它会在字符串`'abc123!'`中找到字符`'1'`，因为这是字符串中的第一个数字（见图15.2）：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](../Images/15-2.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/15-2.png)'
- en: Figure 15.2 The digit shorthand will match any single digit.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 数字简写将匹配任何单个数字。
- en: 'That is the same as using the longhand version (see figure 15.3):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这与使用长版本相同（见图15.3）：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![](../Images/15-3.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/15-3.png)'
- en: Figure 15.3 We can also create a character class enumerating all the digits.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 我们也可以创建一个包含所有数字的字符类。
- en: 'It’s also the same as the version that uses the range of characters `''[0-9]''`
    (see figure 15.4):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它也等同于使用字符范围`'[0-9]'`的版本（见图15.4）：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](../Images/15-4.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/15-4.png)'
- en: Figure 15.4 Character classes can use a range of contiguous values, like 0-9.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4 字符类可以使用一系列连续的值，如0-9。
- en: 'To have it find *one or more digits in a row*, add the `+` (see figure 15.5):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到一行中的*一个或多个连续的数字*，请添加加号（见图15.5）：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](../Images/15-5.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/15-5.png)'
- en: Figure 15.5 The plus signs means to match one or more of the preceding expression.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5 加号意味着匹配前面表达式的*一个或多个*。
- en: 'The `\w` shorthand means “any word-like character.” It includes all the Arabic
    numbers, the letters of the English alphabet, the dash (`''-''`), and the underscore
    (`''_''`). The first match in the string is `''a''` (see figure 15.6):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`\w`简写意味着“任何类似单词的字符。”它包括所有的阿拉伯数字，英语字母表中的字母，破折号（`''-''`）和下划线（`''_''`）。字符串中的第一个匹配是`''a''`（见图15.6）：'
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](../Images/15-6.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/15-6.png)'
- en: Figure 15.6 The shorthand for word characters is `\w`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6 简写为单词字符的是`\w`。
- en: 'If you add the `+` as in figure 15.7, it matches one or more word characters
    in a row, which includes `abc123` but not the exclamation mark (`!`):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像图15.7中那样添加加号，它将匹配一行中的一个或多个单词字符，包括`abc123`但不包括感叹号（`!`）：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](../Images/15-7.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/15-7.png)'
- en: Figure 15.7 Add the plus sign to match one or more word characters.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7 添加加号以匹配一个或多个单词字符。
- en: 15.1.3 Negated shorthand classes
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.3 否定简写类
- en: 'You can complement or “negate” a character class by putting the caret (`^`)
    *immediately inside* the character class as in figure 15.8\. One or more of any
    character *not* a digit is `''[^0-9]+''`. With it, `''abc''` is found:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在字符类中立即放置撇号来补充或“否定”一个字符类，如图15.8所示。一个或多个不是数字的字符是`'[^0-9]+'`。有了它，就能找到`'abc'`：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](../Images/15-8.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/15-8.png)'
- en: Figure 15.8 A caret just inside a character class will negate or complement
    the characters. This regex matches non-digits.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8 在字符类中紧挨着字符的地方放置一个撇号将否定或补充字符。这个正则表达式匹配非数字。
- en: 'The shorthand class of non-digits `[^0-9]+` can also be written as `\D+` as
    in figure 15.9:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 非数字的简写类`[^0-9]+`也可以写成`\D+`，如图15.9所示：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](../Images/15-9.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/15-9.png)'
- en: Figure 15.9 The shorthand `\D+` matches one or more non-digits.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9 简写`\D+`匹配一个或多个非数字。
- en: 'The shorthand for non-word characters is `\W`, which will match the exclamation
    point (see figure 15.10):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 非单词字符的简写是`\W`，它将匹配感叹号（见图15.10）：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![](../Images/15-10.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/15-10.png)'
- en: Figure 15.10 The `\W` will match anything that is not a letter, digit, underscore,
    or dash.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10 `\W`将匹配任何不是字母、数字、下划线或破折号的字符。
- en: Table 15.2 summarizes these shorthand classes and how they can be expanded.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.2总结了这些简写类以及它们如何扩展。
- en: Table 15.2 Negated regex shorthand classes
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.2 否定正则表达式简写类
- en: '| Character class | Shorthand | Other ways to write the class |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 字符类 | 简写 | 其他写法 |'
- en: '| Not a digit | `\D` | `[^0123456789]`, `[^0-9]` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 非数字 | `\D` | `[^0123456789]`, `[^0-9]` |'
- en: '| Not whitespace | `\S` | `[^ \t\n\r\x0b\x0c]` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 非空白字符 | `\S` | `[^ \t\n\r\x0b\x0c]` |'
- en: '| Not word characters | `\W` | `[^a-zA-Z0-9_-]` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 非单词字符 | `\W` | `[^a-zA-Z0-9_-]` |'
- en: 15.1.4 Using re.split() with a captured regex
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.4 使用 re.split() 和捕获的正则表达式
- en: 'We can use `\W` as the argument to `re.split()`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `\W` 作为 `re.split()` 的参数：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note Pylint will complain if we use `''\W''` in a regular expression in our
    program, returning the message “Anomalous backslash in string: `''\W''`. String
    constant might be missing an `r` prefix.” We can use the `r` prefix to create
    a “raw” string, one where Python does not try to interpret the `\W` as it will,
    for instance, interpret `\n` to mean a newline or `\r` to mean a carriage return.
    From this point on, I will use the r-string syntax to create a raw string.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们在程序中的正则表达式中使用 `'\W'`，Pylint 会抱怨，返回消息“字符串中的异常反斜杠：`'\W'`。字符串常量可能缺少 `r`
    前缀。”我们可以使用 `r` 前缀来创建一个“原始”字符串，其中 Python 不会像解释 `\n` 为换行符或 `\r` 为回车符那样解释 `\W`。从现在开始，我将使用
    r-string 语法来创建原始字符串。
- en: 'There is a problem, though, because the result of `re.split()`*omits those
    strings matching the pattern*. Here we’ve lost the exclamation point! If we read
    `help(re.split)` closely, we can find the solution:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题，因为 `re.split()` 的结果 *省略了匹配模式的字符串*。这里我们丢失了感叹号！如果我们仔细阅读 `help(re.split)`，我们可以找到解决方案：
- en: If **capturing parentheses are used in [the] pattern**, then the text of all
    groups in the pattern are also returned as part of the resulting list.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 [模式] 中使用 **捕获括号**，那么模式中所有组的文本也将作为结果列表的一部分返回。
- en: 'We used capturing parentheses in chapter 14 to tell the regex engine to “remember”
    certain patterns, like the consonant(s), vowel, and the rest of a word. When the
    regex matched, we were able to use `match.groups()` to retrieve strings that were
    found by the patterns. Here we will use the parentheses around the pattern to
    `re.split()` so that the strings matching the pattern will also be returned:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在第14章中，我们使用了捕获括号来告诉正则表达式引擎“记住”某些模式，比如辅音(s)、元音以及单词的其余部分。当正则表达式匹配时，我们能够使用 `match.groups()`
    来检索由模式找到的字符串。在这里，我们将使用括号围绕模式来 `re.split()`，这样匹配模式的字符串也将被返回：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we try that on our `text`, the result is a `list` of strings that match
    and do not match the regular expression:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 `text` 上尝试这样做，结果是匹配和不匹配正则表达式的字符串的 `list`：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'I’d like to group all the non-word characters together by adding `+` to the
    regex (see figure 15.11):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我想通过在正则表达式中添加 `+` 来将所有非单词字符组合在一起（见图15.11）：
- en: '[PRE29]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](../Images/15-11.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15-11.png)'
- en: Figure 15.11 The `re.split()` function can use a captured regex to return both
    the parts that match the regex and those that do not.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11 `re.split()` 函数可以使用捕获的正则表达式返回匹配正则表达式和不匹配的部分。
- en: That is so cool! Now we have a way to process each *actual* word and the bits
    in between them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是太酷了！现在我们有了处理每个 *实际* 单词及其之间位的方法。
- en: 15.1.5 Writing the fry() function
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.5 编写 fry() 函数
- en: Our next step is to write a function that will decide whether and how to modify
    *just one word*. That is, rather than thinking about how to handle all the text
    at once, we’ll think about how to handle one word at a time. We can call this
    function `fry()`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步要编写一个函数，该函数将决定是否以及如何修改 **仅一个单词**。也就是说，我们不会考虑如何一次性处理所有文本，而是会考虑一次处理一个单词。我们可以称这个函数为
    `fry()`。
- en: 'To help us think about how this function should work, let’s start off by writing
    the `test_fry()` function and a stub for the actual `fry()` function that contains
    just the single command `pass`, which tells Python to do nothing. To get started
    on this, you can paste this into your program:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们思考这个函数应该如何工作，让我们先编写 `test_fry()` 函数和实际 `fry()` 函数的存根，该存根只包含单个命令 `pass`，它告诉
    Python 不做任何事情。为了开始这个，你可以将以下内容粘贴到你的程序中：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ① pass is a way to do nothing. You might call it a “no-operation” or “NO-OP,”
    which kind of looks like “NOPE,” which is another way to remember that it does
    nothing. We’re just defining this fry() function as a placeholder so we can write
    the test.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ① `pass` 是一种什么也不做的做法。你可以称之为“无操作”或“NO-OP”，它看起来有点像“NOPE”，这也是另一种记住它什么也不做的记忆方法。我们只是将这个
    `fry()` 函数定义为占位符，这样我们就可以编写测试。
- en: ② The test_fry() function will pass in words we expect to be changed or not.
    We can’t check every word, so we’ll rely on spot-checking the major cases.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ② `test_fry()`函数将通过我们期望改变或不变的单词。我们无法检查每个单词，所以我们将依赖于抽查主要情况。
- en: ③ The word “you” should become “y’all.”
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ③ “you”这个词应该变成“y’all”。
- en: ④ Ensure the word’s capitalization is preserved.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 确保保留单词的大写形式。
- en: ⑤ This is a two-syllable “-ing” word that should be changed by dropping the
    final “g” for an apostrophe.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 这是一个双音节“-ing”词，应该通过去掉最后的“g”来改为撇号形式。
- en: ⑥ This is a two-syllable “-ing” word that starts with a vowel. It should likewise
    be changed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 这是一个以元音开头的双音节“-ing”词，也应该同样进行修改。
- en: ⑦ This is a one-syllable “-ing” word that should not be changed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 这是一个单音节“-ing”词，不应该改变。
- en: 'Now run `pytest` `friar.py` to see that, as expected, the test will fail:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`pytest` `friar.py`来查看，正如预期的那样，测试将失败：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ① The first test is failing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ① 第一个测试失败了。
- en: ② The result of fry('you') was None, which does not equal “y’all.”
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ② `fry('you')`的结果是None，这不等于“y’all”。
- en: 'Let’s change our `fry()` function to handle that string:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的`fry()`函数修改一下来处理这个字符串：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now let’s run our tests again:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再次运行我们的测试：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ① Now the first test passes.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ① 现在第一个测试通过了。
- en: ② The second test fails because the “You” is capitalized.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ② 第二个测试失败，因为“You”是大写的。
- en: ③ The function returned None but should have returned “Y’all.”
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 函数返回了None，但应该返回“Y’all”。
- en: 'Let’s handle those:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们处理这些问题：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you run the tests now, you’ll see that the first two tests pass; however,
    I’m definitely not happy with that solution. There is already a good bit of duplicated
    code. Can we find a more elegant way to match both “you” and “You” and still return
    the correctly capitalized answer? Yes, we can!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行测试，你会看到前两个测试通过；然而，我肯定对这个解决方案不满意。代码中已经有很多重复的部分。我们能找到一个更优雅的方式来匹配“you”和“You”，并且仍然返回正确的大写答案吗？是的，我们可以！
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Better still, we can write a regular expression! There is one difference between
    “you” and “You”--the “y” or “Y”--that we can represent using the character class
    `''[yY]''` (see figure 15.12). This will match the lowercase version:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，我们可以写一个正则表达式！在“you”和“You”之间有一个区别——即“y”或“Y”，我们可以使用字符类`'[yY]'`来表示（见图15.12）。这将匹配小写版本：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![](../Images/15-12.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图15-12](../Images/15-12.png)'
- en: Figure 15.12 We can use a character class to match lower- and uppercase Y.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12 我们可以使用字符类来匹配小写和大写的Y。
- en: 'It will also match the capitalized version (see figure 15.13):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它也会匹配大写版本（见图15.13）：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![](../Images/15-13.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图15-13](../Images/15-13.png)'
- en: Figure 15.13 This regex will match “you” and “You.”
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.13 这个正则表达式将匹配“you”和“You”。
- en: 'Now we want to reuse the initial character (either “y” or “Y”) in the return
    value. We could *capture* it by placing it into parentheses. Try to rewrite your
    `fry()` function using this idea, and getting it to pass the first two tests again,
    before moving on:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想在返回值中重用初始字符（无论是“y”还是“Y”）。我们可以通过将其放入括号中来*捕获*它。尝试使用这个想法重写你的`fry()`函数，并在通过前两个测试后再继续：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The next step is to handle a word like “fishing”:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是处理像“fishing”这样的单词：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ① The third test fails.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ① 第三个测试失败了。
- en: ② The return from fry('fishing') was None, but the value “fishin’” was expected.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ② `fry('fishing')`的返回值是None，但预期的值是“fishin’”。
- en: 'How can we identify a word that ends with “ing”? With the `str.endswith()`
    function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何识别以“ing”结尾的单词？使用`str.endswith()`函数：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A regular expression to find “ing” at the end of a string would use `$` (pronounced
    “dollar”) at the end of the expression to *anchor* the expression to the end of
    the string (see figure 15.14):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于在字符串末尾查找“ing”的正则表达式会在表达式的末尾使用`$`（发音为“美元”）来*锚定*表达式，使其与字符串的末尾对齐（见图15.14）：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![](../Images/15-14.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图15-14](../Images/15-14.png)'
- en: Figure 15.14 The dollar sign indicates the end of the word.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.14 美元符号表示单词的结束。
- en: As shown in figure 15.15, we can use a string slice to get all the characters
    up to the last at index `-1` and then append an apostrophe.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如图15.15所示，我们可以使用字符串切片来获取最后一个索引`-1`之前的所有字符，然后添加一个撇号。
- en: 'Add this to your `fry()` function and see how many tests you pass:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到你的`fry()`函数中，看看你能通过多少测试：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![](../Images/15-15.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图15-15](../Images/15-15.png)'
- en: Figure 15.15 Use a string slice to get all the letters up to the last one and
    add an apostrophe.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.15 使用字符串切片获取最后一个字母之前的所有字母并添加撇号。
- en: 'Or you could use a group within the regex to capture the first part of the
    word (see figure 15.16):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以在正则表达式中使用一个分组来捕获单词的前半部分（见图15.16）：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![](../Images/15-16.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图15-16](../Images/15-16.png)'
- en: Figure 15.16 Using a capture group so we can access the matching string
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.16 使用捕获组以便我们可以访问匹配的字符串
- en: 'You should be able to get results like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够得到这样的结果：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ① This test failed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ① 这个测试失败了。
- en: ② The result of fry('swing') was “swin’,” but it should have been “swing.”
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ② fry('swing')的结果是“swin'”，但它应该是“swing”。
- en: ③ Sometimes the test results will be able to highlight the exact point of failure.
    Here you are being shown that there is an apostrophe (’) where there should be
    a “g.”
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 有时测试结果能够突出显示失败的确切点。这里你被展示出有一个撇号（'）而不是应该有的“g”。
- en: 'We need a way to identify words that have two syllables. I mentioned before
    that we’ll use a heuristic that looks for a vowel, `''[aeiouy]''`, in the part
    of the word *before* the “ing” ending, as shown in figure 15.17\. Another regex
    could do the trick:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来识别有两个音节的单词。我之前提到我们将使用一种启发式方法，该方法查找单词“ing”结尾部分之前的元音`'[aeiouy]'`，如图15.17所示。另一个正则表达式可以做到这一点：
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ① The (.+) will match and capture one or more of anything followed by the characters
    “ing.” The return from re.search() will either be a re.Match object if the pattern
    was found or None to indicate it was not.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ① 正则表达式中的(.+)将匹配并捕获一个或多个紧跟“ing”字符的任何字符。re.search()的返回值将是一个re.Match对象，如果找到了模式，或者None，表示没有找到。
- en: ② Here we know there will be a match value, so we can use match.group(`1`) to
    get the first capture group, which will be anything immediately before “ing.”
    In actual code, we should check that match is not None or we’d trigger an exception
    by trying to execute the group method on a None.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们知道这里将有一个匹配值，所以我们可以使用match.group(`1`)来获取第一个捕获组，它将是“ing”之前立即的任何内容。在实际代码中，我们应该检查match是否不是None，否则尝试在None上执行group方法会引发异常。
- en: ③ We can use re.search() on the first part of the string to look for a vowel.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们可以在字符串的前部分使用re.search()来查找元音。
- en: ④ As the return from re.search() is a re.Match object, we know there is a vowel
    in the first part, so the word looks to have two syllables.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 由于re.search()的返回值是一个re.Match对象，我们知道第一部分有一个元音，所以这个单词看起来有两个音节。
- en: '![](../Images/15-17.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15-17.png)'
- en: Figure 15.17 A possible way to find two-syllable words ending in “ing” is to
    look for a vowel in the first part of the word.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.17 寻找以“ing”结尾的双音节词的一种可能方法是查找单词前部分的元音。
- en: If the word matches this test, return the word with the final “g” replaced with
    an apostrophe; otherwise, return the word unchanged. I suggest you not proceed
    until you are passing all of `test_fry()`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单词匹配这个测试，则返回将最终“g”替换为撇号的单词；否则，返回未更改的单词。我建议你完成所有`test_fry()`测试后再继续。
- en: 15.1.6 Using the fry() function
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1.6 使用fry()函数
- en: Now your program should be able to
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的程序应该能够
- en: Read input from the command line or a file
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从命令行或文件读取输入
- en: Read the input line by line
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐行读取输入
- en: Split each line into words and non-words
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每一行拆分为单词和非单词
- en: '`fry()` any individual word'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fry()`任何单个单词'
- en: 'The next step is to apply the `fry()` function to all the word-like units.
    I hope you can see a familiar pattern emerging--applying a function to all elements
    of a list! You can use a `for` loop:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将`fry()`函数应用于所有类似单词的单元。我希望你能看到一种熟悉的模式出现——将函数应用于列表的所有元素！你可以使用一个`for`循环：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ① Preserve the structure of the newlines in args.text by using str.splitlines().
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用str.splitlines()保留args.text中的换行结构。
- en: ② Create a words variable to hold the transformed words.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ② 创建一个words变量来存储转换后的单词。
- en: ③ Split each line into words and non-words.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将每一行拆分为单词和非单词。
- en: ④ Add the fried word to the words list.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将炸过的单词添加到words列表中。
- en: ⑤ Print a new string of the joined words.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 打印一个由连接的单词组成的新字符串。
- en: That (or something like it) should work well enough to pass the tests. Once
    you have a version that works, see if you can rewrite the `for` loop as a list
    comprehension and a `map()`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: （或者类似的东西）应该足够好，可以通过测试。一旦你有一个版本可以工作，看看你是否可以将其重写为列表推导式和`map()`。
- en: Alrighty! Time to bear down and write this.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧！现在是时候全力以赴写这个了。
- en: 15.2 Solution
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2 解决方案
- en: This reminds me of when Robin Hood’s mate Friar Tuck was captured by the Sheriff
    of Nottingham. The Friar was sentenced to be boiled in oil, to which he replied
    “You can’t boil me, I’m a friar!”
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我想起了罗宾汉的伙伴弗莱尔·图克被诺丁汉郡长逮捕的时候。弗莱尔被判在油中煮沸，他回答说“你不能煮我，我是一个修士！”
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ① If the argument is a file, replace the text value with the contents from the
    file.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ① 如果参数是文件，则用文件内容替换文本值。
- en: ② Get the command-line arguments. The text value will either be the command-line
    text or the contents of a file by this point.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ② 获取命令行参数。此时文本值将是命令行文本或文件内容。
- en: ③ Use the str.splitlines() method to preserve the line breaks in the input text.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 使用str.splitlines()方法来保留输入文本中的换行符。
- en: ④ Map the pieces of text split by the regular expression through the fry() function,
    which will return the words modified as needed. Use str.join() to turn that resulting
    list back into a string to print.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 将通过正则表达式分割的文本片段通过fry()函数映射，该函数将返回所需修改的单词。使用str.join()将结果列表转换回字符串以打印。
- en: ⑤ Define a fry() function that will handle one word.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 定义一个fry()函数，该函数将处理一个单词。
- en: ⑥ Search for “ing” anchored to the end of word. Use a capture group to remember
    the part of the string before the “ing.”
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 搜索锚定在单词末尾的“ing”。使用捕获组来记住“ing”之前的字符串部分。
- en: ⑦ Search for “you” or “You” starting from the beginning of word. Capture the
    [yY] alternation in a group.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 从单词的开头搜索“you”或“You”，并将[yY]的交替捕获在组中。
- en: ⑧ Check if the search for “ing” returned a match.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 检查“ing”的搜索是否返回了匹配项。
- en: ⑨ Get the prefix (the bit before the “ing”), which is in group number 1.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 获取前缀（“ing”之前的部分），它在组号1中。
- en: ⑩ Perform a case-insensitive search for a vowel (plus “y”) in the prefix. If
    nothing is found, None will be returned, which evaluates to False in this Boolean
    context. If a match is returned, the not-None value will evaluate to True.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 在前缀中执行对元音（加上“y”）的不区分大小写的搜索。如果没有找到任何内容，None将被返回，这在布尔上下文中评估为False。如果返回了匹配项，则非None值将评估为True。
- en: ⑪ Append “in’” to the prefix and return it to the caller.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 将“in”附加到前缀上并将其返回给调用者。
- en: ⑫ Check if the match for “you” succeeded.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 检查“you”的匹配是否成功。
- en: ⑬ Return the captured first character plus “’all.”
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 返回捕获的第一个字符加上“’all。”
- en: ⑭ Otherwise, return the word unaltered.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 否则，返回未更改的单词。
- en: ⑮ The tests for the fry() function
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ fry()函数的测试
- en: 15.3 Discussion
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3 讨论
- en: 'Again, there is nothing new in `get_args()`, so let’s just move to breaking
    the text into lines. In several previous exercises, I used a technique of reading
    an input file into the `args.text` value. If the input is coming from a file,
    there will be newlines separating each line of text. I suggested using a `for`
    loop to handle each line of input text returned by `str.splitlines()` to preserve
    the newlines in the output. I also suggested you start with a second `for` loop
    to handle each word-like unit returned by the `re.split()`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`get_args()`中没有新的内容，所以我们直接转到将文本拆分为行。在几个先前的练习中，我使用了一种将输入文件读取到`args.text`值的技术。如果输入来自文件，则每行文本之间将有新行分隔。我建议使用`for`循环来处理`str.splitlines()`返回的每一行输入文本以保留输出中的换行符。我还建议你从一个`for`循环开始，以处理`re.split()`返回的每个单词单元：
- en: '[PRE48]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'That’s five lines of code that could be written in two if we replace the second
    `for` with a list comprehension:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将第二个`for`循环替换为列表推导式，那么这五行代码可以缩减为两行：
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Or it could be slightly shorter using a `map()`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用`map()`可能会稍微短一些：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'One other way to slightly improve readability is to use the `re.compile()`
    function to compile the regular expression. When you use the `re.split()` function
    inside the `for` loop, the regex must be compiled anew each iteration. By compiling
    the regex first, the compilation happens just once, so your code is (maybe just
    slightly) faster. More importantly, though, I think this is slightly easier to
    read, and the benefits are greater when the regex is more complicated:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种稍微提高可读性的方法是使用`re.compile()`函数来编译正则表达式。当你在`for`循环中使用`re.split()`函数时，正则表达式必须每次迭代重新编译。通过首先编译正则表达式，编译只发生一次，所以你的代码（可能只是稍微）更快。更重要的是，我认为这稍微容易阅读一些，而且当正则表达式更复杂时，好处更大：
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 15.3.1 Writing the fry() function manually
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.1 手动编写fry()函数
- en: You were not required, of course, to write a `fry()` function. However you wrote
    your solution, I hope you wrote tests for it!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不需要编写一个`fry()`函数。但无论你如何编写解决方案，我希望你为它编写了测试！
- en: 'The following version is fairly close to some of the suggestions I made earlier
    in the chapter. This version uses no regular expressions:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下版本与我之前在章节中提出的一些建议相当接近。这个版本没有使用正则表达式：
- en: '[PRE52]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ① Force the word to lowercase and see if it matches “you.”
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ① 将单词转换为小写并查看它是否匹配“you。”
- en: ② If so, return the first character (to preserve the case) plus “’all.”
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ② 如果是这样，则返回第一个字符（以保留大小写）加上“’all。”
- en: ③ Check if the word ends with “ing.”
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 检查单词是否以“ing”结尾。
- en: ④ Check if it’s True that any of the vowels are in the word up to the “ing”
    suffix.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 检查是否确实有任何元音在“ing”后缀之前的单词中。
- en: ⑤ If so, return the word up to the last index plus the apostrophe.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 如果是这样，则返回从最后一个索引加上的撇号之前的单词。
- en: ⑥ Otherwise, return the word unchanged.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 否则，返回未改变的单词。
- en: ⑦ If the word is neither an “ing” or “you” word, return it unchanged.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 如果单词既不是“ing”结尾也不是“you”结尾，则返回其未改变的形式。
- en: 'Let’s take a moment to appreciate the `any()` function as it’s one of my favorites.
    The preceding code uses a `map()` to check if each of the vowels exists in the
    portion of the `word` before the “ing” ending:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间来欣赏 `any()` 函数，因为它是我最喜欢的之一。前面的代码使用 `map()` 来检查每个元音是否存在于“ing”结尾的 `word`
    部分中：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The first character of “cooking” is “c,” and it does not appear in the string
    of vowels. The next two characters (“o”) do appear in the vowels, but “k” does
    not.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: “cooking”的第一个字符是“c”，它不在元音字符串中。接下来的两个字符（“o”）在元音中存在，但“k”不在。
- en: 'Let’s reduce this to just the `True`/`False` values:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其简化为仅包含 `True`/`False` 值：
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now we can use `any` to tell us if *any* of the values are `True`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 `any` 来告诉我们是否有任何值是 `True`：
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'It’s the same as joining the values with `or`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这与使用 `or` 连接值相同：
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `all()` function returns `True` only if *all* the values are true:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`all()` 函数仅在所有值都为真时返回 `True`：'
- en: '[PRE57]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'That’s the same as joining those values on `and`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这与使用 `and` 连接这些值相同：
- en: '[PRE58]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If it’s `True` that one of the vowels appears in the first part of the `word`,
    we have determined that this is (probably) a two-syllable word, and we can return
    the `word` with the final “g” replaced with an apostrophe. Otherwise, we return
    the unaltered `word`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个元音出现在 `word` 的第一部分，我们就确定这是一个（可能是）双音节词，并且我们可以返回将最后的“g”替换为撇号的 `word`。否则，我们返回未改变的
    `word`：
- en: '[PRE59]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This approach works fine, but it’s quite manual as we have to write quite a
    bit of code to find our patterns.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法工作得很好，但它相当手动，因为我们必须编写相当多的代码来找到我们的模式。
- en: 15.3.2 Writing the fry() function with regular expressions
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3.2 使用正则表达式编写 `fry()` 函数
- en: 'Let’s revisit the version of the `fry()` function that uses regular expressions:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下使用正则表达式版本的 `fry()` 函数：
- en: '[PRE60]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ① The pattern '(.+)ing$' matches one or more of anything followed by “ing.”
    The dollar sign anchors the pattern to the end of the string, so this is looking
    for a string that ends in “ing,” but the string cannot just be “ing” as it has
    to have at least one of something before it. The parentheses capture the part
    before the “ing.”
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ① 模式 '(.+)ing$' 匹配一个或多个任何字符后跟“ing”。美元符号将模式锚定到字符串的末尾，因此这是在寻找以“ing”结尾的字符串，但字符串不能仅仅是“ing”，因为它前面至少要有一些内容。括号捕获了“ing”之前的部分。
- en: ② The re.match() starts matching at the beginning of the given word, and it
    is looking for either an upper- or lowercase “y” followed by “ou” and then the
    end of the string ($).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ② `re.match()` 从给定单词的开头开始匹配，它正在寻找一个大小写字母“y”后跟“ou”，然后是字符串的结尾（$）。
- en: ③ If ing_word is None, that means it failed to match. If it is not None (so
    it is “truthy”), that means it is a re.Match object we can use.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 如果 `ing_word` 是 `None`，这意味着它没有匹配成功。如果它不是 `None`（所以它是“真值”），这意味着它是一个我们可以使用的
    `re.Match` 对象。
- en: ④ The prefix is the bit before the “ing” that we wrapped in parentheses. Because
    it is the first set of parentheses, we can fetch it with ing_word.group(1).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 前缀是我们在括号中包装的部分。因为它是最先的一组括号，我们可以使用 `ing_word.group(1)` 来获取它。
- en: ⑤ We use re.search() to look anywhere in the prefix for any of the vowels (plus
    “y”) in a case-insensitive fashion. Remember that re.match() would start at the
    beginning of word, which is not what we want.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们使用 `re.search()` 在前缀中搜索任何元音（加上“y”），并且以不区分大小写的方式进行。记住，`re.match()` 会从单词的开头开始匹配，这不是我们想要的。
- en: ⑥ Return the prefix plus the string “in’” so as to drop the final “g.”
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 返回前缀加上字符串“in”，以去除最后的“g”。
- en: ⑦ If re.match() for the “you” pattern fails, then “you” will be None. If it
    is not None, then it matched, and “you” is a re.Match object.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 如果对“you”模式的 `re.match()` 失败，则“you”将为 `None`。如果它不是 `None`，则表示匹配成功，“you”是一个
    `re.Match` 对象。
- en: ⑧ We used parentheses to capture the first character so as to maintain the case.
    That is, if the word was “You,” we want to return “Y’all.” Here we return that
    first group plus the string “’all.”
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 我们使用括号来捕获第一个字符，以保持大小写。也就是说，如果单词是“You”，我们希望返回“Y’all”。在这里，我们返回第一个组加上字符串“’all”。
- en: ⑨ If the word matched neither a two-syllable “ing” pattern or the word “you,”
    we return the word unchanged.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 如果单词既没有匹配到双音节“ing”模式也没有匹配到单词“you”，则返回未改变的单词。
- en: '| I’ve been using regexes for maybe 20 years, so this version seems much simpler
    to me than the manual version. You may feel differently. If you are completely
    new to regexes, trust me that they are so very worth the effort to learn. I absolutely
    would not be able to do much of my work without them. | ![](../Images/15-unnumb-15.png)
    |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: 我可能已经使用正则表达式有20年了，所以这个版本对我来说似乎比手动版本简单得多。你可能感觉不同。如果你是正则表达式的新手，相信我，它们非常值得努力去学习。没有它们，我绝对无法完成我的大部分工作。|
    ![图片](../Images/15-unnumb-15.png) |
- en: 15.4 Going further
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.4 进一步学习
- en: You could also replace “your” with “y’all’s.” For instance, “Where are your
    britches?” could become “Where are y’all’s britches?”
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以将“your”替换为“y’all’s”。例如，“你的裤子在哪里？”可以变成“y’all’s裤子在哪里？”
- en: Change “getting ready” or “preparing” to “fixin’,” as in “I’m getting ready
    to eat” to “I’m fixin’ to eat.” Also change the string “think” to “reckon,” as
    in “I think this is funny” to “I reckon this is funny.” You should also change
    “thinking” to “reckoning,” which then should become “reckonin’.” That means you
    either need to make two passes for the changes or find both “think” and “thinking”
    in the one pass.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将“准备”或“准备中”改为“fixin’”，例如，“我正在准备吃饭”改为“我fixin’要吃饭”。同时，将字符串“think”改为“reckon”，例如，“我觉得这个很有趣”改为“我reckon这个很有趣。”你也应该将“thinking”改为“reckoning”，然后它应该变成“reckonin’”。这意味着你需要进行两次遍历来更改，或者在一次遍历中找到“think”和“thinking”。
- en: Make a version of the program for another regional dialect. I lived in Boston
    for a while and really enjoyed saying “wicked” all the time instead of “very,”
    as in “IT’S WICKED COLD OUT!”
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为另一种地区方言制作程序的版本。我在波士顿住了一段时间，真的很喜欢一直说“wicked”而不是“very”，就像“IT’S WICKED COLD OUT！”一样。
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Regular expressions can be used to find patterns in text. The patterns can be
    quite complicated, like a grouping of non-word characters in between groupings
    of word characters.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式可以用来在文本中查找模式。这些模式可能相当复杂，比如在单词字符分组之间非单词字符的分组。
- en: The `re` module has seriously handy functions like `re.match()` to find a pattern
    at the beginning of some text, `re.search()` to find a pattern anywhere inside
    some text, `re.split()` to break text on a pattern, and `re.compile()` to compile
    a regex so you can use it repeatedly.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`re`模块有一些非常实用的函数，如`re.match()`，用于在文本的开始处查找模式，`re.search()`用于在文本的任何位置查找模式，`re.split()`用于在模式上分割文本，以及`re.compile()`用于编译正则表达式，这样你可以重复使用它。'
- en: If you use capturing parentheses on the pattern for `re.split()`, the captured
    split pattern will be included in the returned values. This allows you to reconstruct
    the original string with the strings that are described by the pattern.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用捕获括号在`re.split()`的模式上，捕获的分割模式将包含在返回值中。这允许你使用由模式描述的字符串来重建原始字符串。
