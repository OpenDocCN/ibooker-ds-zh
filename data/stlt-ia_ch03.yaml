- en: 4 Streamlit's execution model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 Streamlit的执行模型
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating apps that require maintaining state between page updates
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建需要在页面更新之间维护状态的应用程序
- en: Troubleshooting your apps effectively
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效解决你的应用程序问题
- en: The all important `st.session_state` and `st.rerun`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常重要的`st.session_state`和`st.rerun`
- en: Streamlit's execution model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Streamlit的执行模型
- en: 'In the last two chapters, you''ve gotten your feet wet with Streamlit by building
    two fully-functional apps: a password checker and a unit converter. You''ve learned
    the basics of Streamlit''s syntax and how to create interactive elements. But
    what happens behind the scenes when you run a Streamlit app? Understanding this
    is key to building more complex applications.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的最后两章中，你已经通过构建两个功能齐全的应用程序（密码检查器和单位转换器）开始了Streamlit的实践。你已经学习了Streamlit的语法基础以及如何创建交互元素。但是当你运行一个Streamlit应用时，幕后发生了什么？理解这一点对于构建更复杂的应用程序至关重要。
- en: This chapter delves into the heart of Streamlit's execution model, where we'll
    explore how to manage an app's state.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了Streamlit的执行模型的核心，我们将探讨如何管理应用程序的状态。
- en: This chapter also takes a slightly different approach than the previous ones.
    While we'll still build a practical application – a daily to-do list app – the
    primary focus is on equipping you with troubleshooting skills. We'll intentionally
    introduce some bugs into the app to simulate real-world situations where things
    might not go according to plan. By following along and fixing these issues, you'll
    gain a deeper understanding of Streamlit's inner workings and how to debug your
    own apps effectively.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章也采取了与前几章略有不同的方法。虽然我们仍然会构建一个实用的应用程序——每日待办事项应用——但主要重点是让你具备解决问题的技能。我们将故意在应用程序中引入一些错误来模拟现实世界中的情况，在这些情况下事情可能不会按计划进行。通过跟随并修复这些问题，你将更深入地了解Streamlit的内部工作原理以及如何有效地调试自己的应用程序。
- en: '4.1 A more complex app: Daily to-dos'
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 更复杂的应用：每日待办事项
- en: Ever juggled multiple deadlines at work while mentally planning a vacation for
    your family, while *also* trying to remember to buy bread on the way home? Regardless
    of your specific situation, the frenzy of modern life has a way of getting you
    in its grip, pulling you into a whirlwind of endless activity and demands. Hopefully
    this chapter's Streamlit app helps you manage the chaos even if it can't actually
    deliver the bread to your doorstep.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 是否曾经在工作时同时处理多个截止日期，同时在心理上为家人计划假期，同时*也*试图记得在回家的路上买面包？无论你的具体情况如何，现代生活的狂潮总有一种方式让你陷入其中，把你拉入无尽的活动中和需求中。希望这一章的Streamlit应用能帮助你管理混乱，即使它实际上不能把面包送到你家门口。
- en: We're going to be making a to-do list app that lets a user track the various
    things they have to get done in a day.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将制作一个待办事项应用，让用户跟踪他们在一天内需要完成的各项事务。
- en: Since the primary point of this chapter is to get you familiar with Streamlit's
    execution model, we won't go through the entire six-step development process in
    detail as we did in the last chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章的主要目的是让你熟悉Streamlit的执行模型，我们不会像上一章那样详细地介绍整个六步开发过程。
- en: Instead, we'll breeze through the concept, the requirements and a mock design,
    and then jump straight to implementation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将快速浏览概念、要求和模拟设计，然后直接跳到实现阶段。
- en: 4.1.1 Stating the concept
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 陈述概念
- en: 'As you hopefully remember from the last chapter, the concept is a succinct
    statement of what our app is. Here it is for our app:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如你希望从上一章中记住的，概念是对我们的应用的一个简洁陈述。以下是我们的应用：
- en: Concept
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 概念
- en: A Streamlit app that lets users add tasks to a daily to-do list and track their
    status.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Streamlit应用，让用户能够将任务添加到每日待办事项列表中并跟踪其状态。
- en: That seems pretty crisp and clear, so let's dive into the detailed requirements.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来非常清晰明了，那么让我们深入详细的要求。
- en: 4.1.2 Defining the requirements
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 定义要求
- en: To recap from Chapter 3, while the concept provides a general idea of your app,
    it's your requirements that make it concrete, laying out what the user needs from
    it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾第3章，虽然概念提供了你对应用的一般想法，但正是你的要求使其具体化，阐述了用户需要从它那里得到什么。
- en: 'The requirements for the to-do list app we''re building are the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的待办事项应用的要求如下：
- en: 'Requirements:'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 要求：
- en: 'The user should be able to:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应该能够：
- en: view their daily to-do list, made up of tasks
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看他们的每日待办事项列表，由任务组成
- en: add a task to their to-do list
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任务添加到他们的待办事项列表中
- en: remove a task from their list
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从他们的列表中删除任务
- en: mark a task in their list as done
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在他们的列表中标记任务为完成
- en: undo marking a task as done
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消标记任务为完成
- en: see their overall task completion status, i.e., their total number of tasks
    and the number they've completed
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看他们的整体任务完成状态，即他们的总任务数和已完成的任务数
- en: 'It''s just as important, if not even more so, to clarify what our app *won''t*
    do, so let''s specify that as well:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要，甚至可能更重要，的是明确我们的应用*不会*做什么，所以让我们也明确这一点：
- en: What's out of scope
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 范围之外的内容
- en: Retrieving a to-do list when the user refreshes or reopens the page
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户刷新或重新打开页面时检索待办事项列表
- en: Exporting a to-do list to an external file or format
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将待办事项列表导出到外部文件或格式
- en: Saving the history of added or completed to-dos
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存添加或完成的待办事项的历史记录
- en: 'The two lists above should give you a sense of what we''re trying to build
    in this chapter: it''s a fairly basic daily to-do list that lives entirely within
    a single browser session.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的两个列表应该让你对我们的本章要构建的内容有一个概念：这是一个相当基本的每日待办事项列表，完全存在于单个浏览器会话中。
- en: Essentially, the way we expect the user to interact with our app is to open
    it in a browser window at the beginning of the day, add their tasks, and mark
    them as done/not done as their day progresses, *keeping the window open until
    the end of the day and never refreshing it*. Rinse and repeat the next day.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们期望用户与我们的应用交互的方式是在每天开始时在一个浏览器窗口中打开它，添加他们的任务，并在他们的一天进展中标记为完成/未完成，*保持窗口打开直到一天结束，并且不要刷新它*。第二天重复同样的步骤。
- en: We're not going to build the ability to *persist* (or save) any tasks outside
    of the browser session. If you refresh the page, you lose your data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会构建在浏览器会话之外*持久化*（或保存）任何任务的能力。如果你刷新页面，你会丢失你的数据。
- en: '*"Doesn''t that limit the usefulness of the app somewhat?"* you might ask.
    Absolutely. It''s just that we don''t want to introduce the complexity of external
    storage just yet. We''ll explore that later on in the book, especially in Part
    2.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*“这不会限制应用的一些有用性吗？”你可能会问。当然。只是我们不想现在就引入外部存储的复杂性。我们将在本书的后面部分探讨这一点，特别是在第二部分中。'
- en: However, one might also argue that giving users a blank slate at the start of
    each day makes them *more* productive. So you see, not being able to save your
    tasks is a *feature*, not a bug!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有人也可能认为，在每天开始时给用户提供一张白纸会使他们*更*有效率。所以你看，无法保存你的任务是*功能*，而不是错误！
- en: It's mostly the complexity thing. Still, you should know that spinning the limitations
    of your product into positives is practically a survival skill in the industry!
    I bet your other frontend tech manuals don't also give you free life advice.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是关于复杂性的事情。尽管如此，你应该知道，将你产品的局限性转化为积极因素在行业中几乎是一种生存技能！我敢打赌你的其他前端技术手册也不会给你提供免费的生活建议。
- en: 4.1.3 Visualizing the user experience
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 可视化用户体验
- en: We now know with a fair amount of precision what our app needs to be able to
    do, so with that in mind and keeping with the principle we introduced in the last
    chapter of putting the user experience front and center, let's turn our attention
    to the mock UI design shown in figure 4.1.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们相当精确地知道我们的应用需要能够做什么，因此考虑到这一点，并遵循我们在上一章中介绍的原则，即把用户体验放在首位，让我们将注意力转向图4.1所示的模拟UI设计。
- en: '![image](../Images/04__image001.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image001.png)'
- en: Figure 4.1 The mock UI design for our daily to-do list app
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.1 我们每日待办事项应用的模拟UI设计
- en: 'Our design has two sections: a sidebar where you can enter new tasks, and a
    "main" area where you can view the tasks you''ve added and update their status.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设计有两个部分：一个侧边栏，您可以在其中输入新任务，以及一个“主要”区域，您可以在其中查看您添加的任务并更新它们的状态。
- en: Once you add a task by entering the task text and clicking the button on the
    left, it appears on the right. Each task is rendered as a checkbox. You mark a
    task as "done" by checking the box, which also satisfyingly strikes through the
    task. You can delete a task entirely by clicking the button to its right.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你通过输入任务文本并点击左侧的按钮添加任务，它就会出现在右侧。每个任务都以复选框的形式呈现。你通过勾选框标记任务为“完成”，这也会满意地划掉任务。你可以通过点击右侧的按钮完全删除一个任务。
- en: There's also a tracker at the top which tells you how many tasks you've completed
    out of the total.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部还有一个跟踪器，告诉你你完成了多少任务，总共是多少。
- en: 4.1.4 Brainstorming the implementation
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.4 实施方案头脑风暴
- en: You may have realized that our to-do list app is somewhat more complex than
    the password checker we built in Chapter 2 or even the unit conversion app in
    Chapter 3\. In both of those cases, there was ultimately a single primary action
    the user could take—to evaluate the entered password in the case of the former,
    and to perform the conversion in the case of the latter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经意识到，我们的待办事项应用比第二章中构建的密码检查器或第三章中的单位转换应用要复杂得多。在这两种情况下，用户最终只能执行一个主要操作——在前一种情况下，评估输入的密码；在后一种情况下，执行转换。
- en: 'Our to-do list has *four* different actions the user can take:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务列表有*四个*不同的用户可以执行的操作：
- en: add a task
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加任务
- en: mark it as done
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为完成
- en: mark it as not done
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记为未完成
- en: delete it
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除它
- en: Let's take a moment to brainstorm how we're going to make this happen.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间来头脑风暴一下我们如何实现这一点。
- en: 'Central to our implementation is the notion of a *task*, and by extension a
    *task list*. For the purposes of our app, a task is an object with two properties:
    a name, and a status which can be "done" or "not done.” A task list is simply
    an ordered list of tasks.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的核心是*任务*的概念，以及由此扩展的*任务列表*。在我们的应用中，一个任务是一个具有两个属性的实体：一个名称和一个状态，状态可以是“完成”或“未完成”。任务列表仅仅是任务的有序列表。
- en: The four user actions mentioned above are simply different ways in which you
    can modify the task list; adding a task adds an item to the list, marking it as
    done/not done updates the status of an item in the list, and deleting a task removes
    it from the list.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上文提到的四个用户操作只是修改任务列表的不同方式；添加任务会将项目添加到列表中，标记为完成/未完成会更新列表中项目的状态，删除任务会将其从列表中移除。
- en: At every point, the app should show the latest state of the task list to the
    user.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个点上，应用都应该向用户展示任务列表的最新状态。
- en: 'We can therefore divide our app into three parts:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将我们的应用分为三个部分：
- en: The task list
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务列表
- en: Actions, which are wired up to buttons and checkboxes, and modify the task list
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作，这些动作连接到按钮和复选框，并修改任务列表
- en: Display logic, which renders the task list on the screen
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示逻辑，它在屏幕上渲染任务列表
- en: Whenever an action is performed, the task list is modified, and the display
    logic automatically updates what's shown on the screen.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每当执行一个操作时，任务列表都会被修改，并且显示逻辑会自动更新屏幕上显示的内容。
- en: Figure 4.2 shows what happens when a new task is added; the task is appended
    to the task list, and the display logic loops through all the tasks again and
    renders them on the screen based on a number of rules such as "strikethrough if
    done.”
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2显示了添加新任务时会发生什么；任务被附加到任务列表中，显示逻辑再次遍历所有任务，并根据诸如“完成则划掉”等规则在屏幕上渲染它们。
- en: '![image](../Images/04__image002.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image002.png)'
- en: Figure 4.2 Adding a task appends an item to the task list and the display logic
    renders the updated task list
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.2 添加任务会将项目附加到任务列表中，并且显示逻辑会再次遍历所有任务，并根据诸如“完成则划掉”等规则在屏幕上渲染它们
- en: Something very similar happens when a task is checked off, as shown in figure
    4.3\. This time, the status of the task is updated in the task list. Everything
    else goes the same way; the display logic once again loops through every task.
    The "checked if done" and "strikethrough if done" rule are picked up to give the
    completed "Buy bread" task the appearance we want.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务被勾选时，会发生非常类似的情况，如图4.3所示。这次，任务的状态在任务列表中被更新。其他一切照旧；显示逻辑再次遍历每个任务。根据“如果完成则勾选”和“如果完成则划掉”的规则，给完成的“购买面包”任务赋予我们想要的样式。
- en: '![image](../Images/04__image003.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image003.png)'
- en: Figure 4.3 Checking off a task updates the status of the item in the task list
    and the same display logic re-renders the updated task list
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.3 标记任务会更新任务列表中项目的状态，并且相同的显示逻辑会重新渲染更新后的任务列表
- en: Deleting a task or un-checking one works pretty much the same way; the task
    list stored in memory is updated and re-rendered by the display logic.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 删除任务或取消勾选操作基本上是以相同的方式进行；存储在内存中的任务列表被更新，并由显示逻辑重新渲染。
- en: At this point, we've identified how we'll represent the key entities in our
    app, and what effect each user action will have. It's now time to implement our
    logic.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经确定了如何在应用中表示关键实体，以及每个用户操作会产生什么效果。现在是时候实现我们的逻辑了。
- en: 4.2 Implementing and troubleshooting our app
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 实现和调试我们的应用
- en: 'When we built the unit conversion app in Chapter 3, we took the scenic route,
    walking through each step of the app development process in detail. However, there''s
    a part of the process we didn''t really dwell on: what happens when things go
    wrong, and how to troubleshoot the problem. It was a fairly smooth ride.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第3章构建单位转换应用时，我们走了一条风景优美的路线，详细地走过了应用开发过程的每一步。然而，在这个过程中，我们并没有真正深入探讨的一个部分是：当事情出错时会发生什么，以及如何调试问题。这是一段相当顺利的旅程。
- en: This time around, we'll take a bumpier path that you'll find to be more representative
    of the real world. We'll run into various issues and errors as we implement our
    to-do list app. Just as in the real world, these errors will prompt us to learn
    about Streamit in more depth. And we'll use our deeper understanding to power
    through and fix the problems.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将走一条更崎岖的道路，你会发现这更符合现实世界。在我们实现待办事项应用的过程中，我们会遇到各种问题和错误。就像在现实世界中一样，这些错误会促使我们更深入地了解Streamit。我们将利用我们的深入理解来克服并解决问题。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Since the focus of this chapter is to give you experience in troubleshooting
    problems with your apps, we'll eschew some of the best practices we learned in
    Chapter 3 ( such as maintaining a strict separation between backend and frontend,
    or defining a clear API), in favor of more concise code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章的重点是让你在调试应用问题方面获得经验，我们将放弃在第3章中学到的一些最佳实践（例如，在前后端之间保持严格的分离，或定义清晰的API），以便编写更简洁的代码。
- en: To begin, spin up a new file in your code editor and name it `todo_list.py`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在你的代码编辑器中创建一个新的文件，并将其命名为`todo_list.py`。
- en: 4.2.1 Displaying the task list
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 显示任务列表
- en: While we've done our planning up front in one shot, when it comes to writing
    the actual code, we're going to be building our app iteratively as we did in Chapter
    3, going part-by-part and viewing the results in Streamlit along the way.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在一开始就一次性完成了规划，但在编写实际代码时，我们将像第3章中那样迭代地构建我们的应用，一部分一部分地构建，并在Streamlit中查看结果。
- en: So where do we start? What's the first iteration?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们从哪里开始？第一次迭代是什么？
- en: As discussed in the previous section, the notion of a task list is central to
    our app's implementation. The display logic component of our app always needs
    to show the latest state of the task list.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，任务列表的概念是我们应用实现的核心。我们应用显示逻辑组件始终需要显示任务列表的最新状态。
- en: Our very first step can be as simple as creating the heading for the task list.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步可以简单到只是创建任务列表的标题。
- en: st.header
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: st.header
- en: Streamlit has several different text elements which simply display text in various
    sizes and formatting. We've used `st.title` before to render large titles.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit有几种不同的文本元素，它们以各种大小和格式简单地显示文本。我们之前已经使用`st.title`来渲染大标题。
- en: '`st.header` is pretty similar, but it displays text that''s a bit smaller than
    `st.title`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.header`非常相似，但它显示的文本比`st.title`小一些。'
- en: Use it by putting the code in Listing 4.1 into `todo_list.py`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将列表 4.1 中的代码放入`todo_list.py`来使用它。
- en: Listing 4.1 todo_list.py with just a header
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1 todo_list.py 仅包含标题
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that we've included a divider argument, which simply displays a gray
    line beneath your header. Neat, huh?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们包括了分隔线参数，它只是在你的标题下方显示一条灰色线条。不错吧？
- en: As always, to see your work in action, save your file and run `streamlit run
    todo_list.py` or `streamlit run <path to frontend.py>` if you're in a different
    working directory.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，为了看到你的工作效果，保存你的文件并运行`streamlit run todo_list.py`，或者如果你在另一个工作目录中，运行`streamlit
    run <path to frontend.py>`。
- en: When your browser window opens, you should see something like figure 4.4.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的浏览器窗口打开时，你应该会看到类似于图 4.4 的内容。
- en: '![image](../Images/04__image004.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image004.png)'
- en: Figure 4.4 st.header with a divider
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.4 st.header 带分隔线
- en: If you happen to have multiple headers in your app, you can even cycle between
    divider colors by setting `divider` to `True` instead of a specific color.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在你的应用中恰好有多个标题，你甚至可以通过将`divider`设置为`True`而不是特定颜色来循环切换分隔线颜色。
- en: Creating a task list
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建任务列表
- en: Next, let's turn to our notion of a task. As mentioned earlier, a task has a
    name and a done/not-done status.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们转向任务的概念。如前所述，任务有一个名称和完成/未完成状态。
- en: 'We can therefore use a dataclass to represent a task with exactly those two
    fields: a string `name` and a boolean `is_done` to represent the task status.
    Listing 4.2 shows the `Task` class. Go ahead and save this into a new file called
    `task.py` in the same directory as `todo_list.py`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用数据类来表示具有恰好这两个字段的任务：一个字符串`name`和一个布尔值`is_done`来表示任务状态。列表4.2显示了`Task`类。请将其保存到一个名为`task.py`的新文件中，与`todo_list.py`位于同一目录下。
- en: Listing 4.2 task.py
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.2 task.py
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Notice the line `is_done: bool = False`. Here, we''re setting `is_done` to
    `False` by default, in case it''s not specified while creating an instance of
    `Task`. This will come in handy momentarily.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '注意到`is_done: bool = False`这一行。在这里，我们默认将`is_done`设置为`False`，以防在创建`Task`实例时未指定。这很快就会派上用场。'
- en: 'Now that we have a task, our task list is literally a Python list of `Task`
    objects. You can create this in `todo_list.py` with a couple of dummy tasks to
    test it out like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了任务，我们的任务列表实际上是一个包含`Task`对象的Python列表。您可以在`todo_list.py`中使用几个虚拟任务来测试它，如下所示：
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since we've specified a default value of `False` for `is_done`, there's no need
    to specify it for each instance of `Task`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经为`is_done`指定了默认值`False`，因此不需要为`Task`的每个实例指定它。
- en: 'Don''t forget to import your `Task` class at the top of the file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在文件顶部导入您的`Task`类：
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Checkboxes for tasks
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务复选框
- en: 'Starting out, our display logic can be simple: let''s just display a checkbox
    for each task. We know how to create a static checkbox with a string label; recall
    that we used `st.checkbox` to make a checkbox that rounds the results of our unit
    conversion in Chapter 3.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时，我们的显示逻辑可以很简单：只需为每个任务显示一个复选框。我们知道如何使用字符串标签创建静态复选框；回想一下，我们在第3章中使用`st.checkbox`来创建一个将单位转换结果四舍五入的复选框。
- en: But here, we don't know the labels for each checkbox beforehand. Instead we
    have to infer them from `task_list`. How do we do that?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这里，我们事先不知道每个复选框的标签。相反，我们必须从`task_list`中推断它们。我们如何做到这一点？
- en: The answer, of course, is a loop. When a Streamlit element is placed in a loop,
    a new element is rendered each time the loop runs. We've actually already encountered
    this in our initial password checker example in Chapter 2, where we used `st.success`
    and `st.error` in a loop to display the green and red boxes that indicated the
    pass/fail status of each condition.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 答案当然是循环。当一个Streamlit元素放置在循环中时，每次循环运行时都会渲染一个新的元素。我们实际上在第2章的初始密码检查器示例中已经遇到过这种情况，我们在循环中使用`st.success`和`st.error`来显示表示每个条件通过/失败状态的绿色和红色框。
- en: 'We can create checkboxes from our task list like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从任务列表中创建复选框，如下所示：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Recall that the first argument passed to `st.checkbox` is the label (the task's
    name in this case) and the second is a boolean that indicates whether the checkbox
    should be rendered as checked or not. We want each checkbox to be checked if the
    task is done, so it makes sense to pass the task's `is_done` field here directly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，传递给`st.checkbox`的第一个参数是标签（在这种情况下是任务的名称），第二个是一个布尔值，表示复选框是否应该渲染为选中状态。我们希望如果任务已完成，则每个复选框都被选中，因此直接传递任务的`is_done`字段是有意义的。
- en: Listing 4.3 shows what `todo_list.py` should look like at this point.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3显示了此时`todo_list.py`应该看起来像什么。
- en: Listing 4.3 task.py with checkboxes for each task
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.3 task.py带有每个任务的复选框
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Save and run to get the output shown in figure 4.5
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并运行以获取图4.5所示的输出
- en: '![image](../Images/04__image005.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image005.png)'
- en: Figure 4.5 Using st.checkbox in a loop to display one for each task
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.5 在循环中使用st.checkbox显示每个任务
- en: Our checkboxes don't actually do anything yet. We'll get to that in a minute,
    but first let's add a "delete" button to each task.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的复选框目前实际上并没有做什么。我们稍后会解决这个问题，但首先让我们为每个任务添加一个“删除”按钮。
- en: Adding delete buttons
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加删除按钮
- en: We want a button to delete each task in the list, situated to its right. Similar
    to how we did it for the checkboxes, we're going to be generating these buttons
    dynamically, so they should go into the loop we wrote earlier.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要一个按钮来删除列表中的每个任务，位于其右侧。类似于我们为复选框所做的那样，我们将动态生成这些按钮，因此它们应该放入我们之前编写的循环中。
- en: But if we simply tack on the button inside the loop, Streamlit will put it *under*
    the checkbox for the task, not to the *right* of the task, because Streamlit renders
    elements vertically by default as we saw in Chapter 3.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们简单地将按钮附加到循环中，Streamlit会将它放在任务的*下方*，而不是*右侧*，因为Streamlit默认按垂直方式渲染元素，正如我们在第3章中看到的。
- en: 'As before, we''ll use `st.columns` to work around this. Here, we''ll make two
    columns—one for the checkbox and task text and another for the button. Go ahead
    and replace your existing `for task in task_list` loop with this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们将使用`st.columns`来解决这个问题。在这里，我们将创建两列——一列用于复选框和任务文本，另一列用于按钮。将你现有的`for task
    in task_list`循环替换为以下内容：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice that we''re calling `st.columns` a little differently from how we did
    in the previous chapter: `st.columns([0.8, 0.2])`. Instead of passing the number
    of columns, we''re passing a list of numbers. This list has the *relative widths*
    of each column. We''re saying that the column with the task should take up 80%
    of the horizontal space and the column with the button should take 20%. If we
    had simply passed the number of columns, i.e., `st.columns(2)`, Streamlit would
    have made the two columns equally wide, which doesn''t make sense because the
    task text can be arbitrarily long, while the button can''t.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们调用`st.columns`的方式与上一章有所不同：`st.columns([0.8, 0.2])`。我们不是传递列数，而是传递一个数字列表。这个列表包含了每列的相对宽度。我们表示，带有任务的列应该占据80%的水平空间，而带有按钮的列应该占据20%。如果我们只是传递列数，即`st.columns(2)`，Streamlit会使得两列宽度相等，这没有意义，因为任务文本可以任意长，而按钮不能。
- en: We're not making the button do anything just yet, so we just wrote `pass`, which
    is a keyword in Python that means "do nothing.”
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前还没有让按钮做任何事情，所以我们只是写了`pass`，这是Python中的一个关键字，意味着“什么都不做”。
- en: Widget keys
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 小部件键
- en: Let's go ahead and run our app again to see how it looks. Figure 4.6 depicts
    what you'll likely see.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行我们的应用，看看它的样子如何。图4.6展示了你可能会看到的内容。
- en: '![image](../Images/04__image006.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image006.png)'
- en: Figure 4.6 Streamlit throws an error when there are multiple identical widgets
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.6 当存在多个相同的小部件时，Streamlit会抛出错误
- en: There's a button to the right of the first task but not the second. Most importantly,
    there's an error message big red box underneath; Streamlit is complaining because
    we tried to create multiple `st.button` widgets with the same *key*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个任务右侧有一个按钮，但在第二个任务中没有。最重要的是，下面有一个大红色的错误信息框；Streamlit在抱怨我们尝试创建多个具有相同*键*的`st.button`小部件。
- en: A key is a piece of text that Streamlit uses to identify a *widget*—essentially
    what we've been calling a Streamlit element, like `st.button`, `st.checkbox` etc.
    Widget keys need to be unique so that Streamlit can distinguish between any two
    widgets.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 键是Streamlit用来识别*小部件*的一段文本——本质上就是我们所说的Streamlit元素，如`st.button`、`st.checkbox`等。小部件键需要是唯一的，这样Streamlit才能区分任何两个小部件。
- en: You don't have to specify the key for a widget in your code manually most of
    the time because Streamlit specifies one internally based on its characteristics.
    For a button, Streamlit's internal key is based on the text in it. So when you
    have two buttons that say "Delete,” their keys are identical, which breaks the
    uniqueness constraint.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你不需要手动指定小部件的键，因为Streamlit会根据其特性内部指定一个。对于一个按钮，Streamlit的内部键基于其文本。所以当你有两个按钮都写着“删除”时，它们的键是相同的，这违反了唯一性约束。
- en: The way around this, as the error suggests, is to manually specify a unique
    key for each button we create.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案，正如错误提示所建议的，是为我们创建的每个按钮手动指定一个唯一的键。
- en: 'Since we need a unique delete-button key for every task in our list, one way
    of ensuring a unique key might be to include the list index for the task within
    the key. For instance, the key for the first task''s delete-button could be `delete_0`,
    the key for the second could be `delete_1,` and so on:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要为列表中的每个任务创建一个唯一的删除按钮键，确保唯一键的一种方法是在键中包含任务的列表索引。例如，第一个任务的删除按钮键可以是`delete_0`，第二个的可以是`delete_1`，依此类推：
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since we need both the index of the task and the task itself, we've changed
    the for-loop's header to `for idx, task in enumerate(task_list)`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要任务索引和任务本身，我们已经将for循环的标题更改为`for idx, task in enumerate(task_list)`。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`enumerate`, as you may know, is a handy little function in Python that lets
    you iterate through a list in an elegant way, obtaining both the index and the
    element in one shot. The less elegant alternative would have been to write:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate`，如你所知，是Python中的一个实用的小函数，它允许你以优雅的方式遍历列表，一次获得索引和元素。不那么优雅的替代方案是编写：'
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we discussed, we form each button''s unique key using its index: `key=f"delete_{idx}"`.
    If you run your code now, you should see the error disappear, as shown in figure
    4.7'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论的，我们使用每个按钮的索引来形成其唯一的键：`key=f"delete_{idx}"`。如果你现在运行你的代码，你应该会看到错误消失，如图4.7所示
- en: '![image](../Images/04__image007.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image007.png)'
- en: Figure 4.7 Passing a unique key to each button allows Streamlit to distinguish
    between otherwise identical buttons
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.7 向每个按钮传递一个唯一的键允许 Streamlit 区分其他方面相同的按钮
- en: You may now be wondering, "why didn't we need to pass a key to the checkboxes
    then?"
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能想知道，“为什么我们当时不需要向复选框传递一个键？”
- en: Well, because the checkboxes already had unique internal keys since their labels
    (the task names) were different. We'll actually face the same issue if we try
    to put two identical tasks in our list. For instance, if we change our task list
    to `task_list = [Task("Buy milk"), Task("Buy milk")]`, we'll see an error similar
    to what we saw for the buttons.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，因为复选框已经有了唯一的内部键，因为它们的标签（任务名称）是不同的。如果我们尝试在我们的列表中放入两个相同的任务，我们实际上会面临相同的问题。例如，如果我们将我们的任务列表更改为
    `task_list = [Task("Buy milk"), Task("Buy milk")]`，我们将看到类似于我们之前为按钮看到的错误。
- en: 'It''s probably a good idea to let the user enter the same task twice if they
    want to, so let''s fix the problem by passing a unique key to each checkbox as
    well:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户想要重复输入相同的任务，这可能是一个好主意，所以让我们通过向每个复选框传递一个唯一的键来解决这个问题：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This lets us have two tasks with the same name if we like without issues.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以让我们在不出现问题的前提下拥有两个具有相同名称的任务。
- en: 4.2.2 Enabling actions
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 启用操作
- en: So far, we've set up our app to display our tasks in roughly the way we want
    them to appear, using dummy tasks to test it. We haven't actually provided a way
    for users to interact with or modify their tasks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设置了我们的应用，以大致的方式显示我们想要的任务，使用虚拟任务来测试它。我们实际上并没有提供用户与任务交互或修改任务的方法。
- en: That's what we'll do in this section. We'll start by defining functions that
    update our task list, and then hook them up to Streamlit UI elements.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中这样做。我们首先定义更新我们的任务列表的函数，然后将它们连接到 Streamlit UI 元素。
- en: Adding a task
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加任务
- en: To add a task to our task list, we need a task name. Once we have that, adding
    it is as simple as creating a `Task` object and appending it to our list.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要将任务添加到我们的任务列表中，我们需要一个任务名称。一旦我们有了这个名称，添加它就像创建一个 `Task` 对象并将其追加到我们的列表中一样简单。
- en: 'We can write this out in a simple `add_task` function in `todo_list.py`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `todo_list.py` 中的简单 `add_task` 函数中写出这个功能：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Marking a task done or not done
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标记任务完成或未完成
- en: 'A task''s status is denoted by the `is_done` field of the `Task` instance.
    Therefore, marking it done or not done involves updating this field. Let''s create
    two functions for this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个任务的完成状态由 `Task` 实例的 `is_done` 字段表示。因此，标记为完成或未完成涉及更新这个字段。让我们为此创建两个函数：
- en: '[PRE11]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that the argument to these functions is the `Task` instance itself, not
    the task name string.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些函数的参数是 `Task` 实例本身，而不是任务名称字符串。
- en: Deleting a task
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 删除任务
- en: Deleting a task is also straightforward. For this function, we need the index
    of the task in our list, so we can remove it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 删除任务也是直接的。对于这个函数，我们需要任务在我们列表中的索引，以便我们可以删除它。
- en: '[PRE12]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Enabling users to add tasks
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启用用户添加任务
- en: 'As we now have an `add_task` function, we no longer have to seed our task list
    with dummy tasks. Let''s replace the line `task_list = [Task("Buy milk"), Task("Walk
    the dog")]` with an empty list:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在有了 `add_task` 函数，我们不再需要用虚拟任务初始化我们的任务列表。让我们将行 `task_list = [Task("Buy milk"),
    Task("Walk the dog")]` 替换为空列表：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, we'll add Streamlit elements to let the user call our `add_task` function.
    We'll need an `st.text_input` for the user to enter the task name, and an `st.button`
    to trigger the addition. We'll wrap both of these in `st.sidebar` so they appear
    in a left-hand-side panel in our app. Again, if any of this sounds unfamiliar,
    you should review Chapter 3.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加 Streamlit 元素，以便用户可以调用我们的 `add_task` 函数。我们需要一个 `st.text_input` 让用户输入任务名称，以及一个
    `st.button` 来触发添加操作。我们将这两个元素都包裹在 `st.sidebar` 中，这样它们就会出现在我们应用左侧的面板中。再次提醒，如果这些内容听起来不熟悉，你应该回顾第
    3 章。
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note the `type="primary"` in `st.button`. The `type` parameter lets you add
    emphasis to a button (in the form of a different color) by denoting that it's
    linked to a "primary action.” In UI design, it's a good idea to have your user's
    eyes be drawn to the actions that they would commonly perform. Here, adding a
    task is something we'd expect the user to do all the time, so using a primary
    button makes sense. If you don't specify this parameter (which we've been doing
    all along until now), it defaults to "secondary,” which—at the time of writing—results
    in a white button.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `st.button` 中的 `type="primary"`。`type` 参数允许你通过表示它链接到“主要操作”来给按钮添加强调（以不同颜色形式）。在
    UI 设计中，让用户的注意力集中在他们通常会执行的操作上是一个好主意。在这里，添加任务是我们期望用户会经常执行的操作，所以使用主要按钮是有意义的。如果你没有指定这个参数（我们一直做到现在），它默认为“secondary”，在撰写本文时，这会导致按钮为白色。
- en: Note also that we didn't add a widget key to the button because we only have
    one "Add task" button and Streamlit doesn't need any extra help to distinguish
    it from other buttons.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们并没有给按钮添加一个 widget key，因为我们只有一个“添加任务”按钮，Streamlit 不需要任何额外的帮助来区分它和其他按钮。
- en: At this point, your `todo_list.py` file should like what's shown in listing
    4.4.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你的 `todo_list.py` 文件应该看起来像列表 4.4 中所示的那样。
- en: Listing 4.4 todo_list.py so far
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4 到目前为止的 todo_list.py
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Save and run your code. To check the result (see figure 4.8), enter a new task
    called "Clean garage" and click "Add task.”
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并运行你的代码。为了检查结果（见图 4.8），输入一个名为“清理车库”的新任务并点击“添加任务”。
- en: '![image](../Images/04__image008.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image008.png)'
- en: Figure 4.8 To-do list app with one to-do added
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.8 添加了一个待办事项的待办事项应用
- en: So far so good, but when we try adding another task, say "Finalize project proposal,”
    we see the problematic output shown in figure 4.9.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利，但当我们尝试添加另一个任务，比如“完成项目提案”时，我们看到了图 4.9 中显示的问题输出。
- en: '![image](../Images/04__image009.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image009.png)'
- en: Figure 4.9 When a new task is added, the old one disappears
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.9 当添加新任务时，旧的任务消失
- en: We see our new task alright but the old one, "Clean garage,” is gone. Something
    seems wrong, but we don't see an error as we did for the widget key issue.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的新任务，但旧的任务“清理车库”不见了。似乎有些不对劲，但我们没有看到像 widget key 问题那样的错误。
- en: Oddly, clicking "Delete" removes the remaining task (see figure 4.10), even
    though we didn't actually wire it up to anything; recall that we used `pass` to
    make the button do nothing—something that's commonly referred to as a *no-op.*
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，点击“删除”会删除剩余的任务（见图 4.10），即使我们没有将其连接到任何东西；回想一下，我们使用了 `pass` 来使按钮不执行任何操作——这通常被称为
    *no-op*。
- en: '![image](../Images/04__image010.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image010.png)'
- en: Figure 4.10 Clicking "Delete" removes the task even though we didn't hook it
    up to anything.
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.10 点击“删除”删除了任务，尽管我们没有将其连接到任何东西。
- en: 'The same thing happens if you add a task again and click the checkbox: the
    task just disappears. Feel free to try that out as well.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次添加一个任务并点击复选框，也会发生同样的事情：任务就会消失。你也可以随意尝试一下。
- en: What's gone wrong?
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 发生了什么问题？
- en: Clearly, our app isn't working as we intended. Streamlit doesn't show an error,
    so it's up to us to figure out what's happening. Is our display logic only showing
    the last task added? Or is there something wrong with the task list itself?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们的应用并没有按照我们的预期工作。Streamlit 不会显示错误，所以我们必须找出发生了什么。我们的显示逻辑是否只显示了最后添加的任务？或者任务列表本身有什么问题？
- en: Let's find out. One of the most important parts of troubleshooting code is inspecting
    the value of variables while a program is running. In a normal Python script (i.e.,
    one that you would run from the command-line rather than using Streamlit), you
    might include `print` statements to display the value of a variable. You could
    also use your IDE's debugger or the `pdb` module, but let's keep things simple.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出问题所在。调试代码最重要的部分之一是在程序运行时检查变量的值。在一个正常的 Python 脚本中（即你会在命令行中运行的脚本，而不是使用 Streamlit），你可能会包含
    `print` 语句来显示变量的值。你也可以使用你的 IDE 的调试器或 `pdb` 模块，但让我们保持简单。
- en: '`print` statements don''t show up on the browser window of your Streamlit app,
    however. Instead, let''s use an appropriate Streamlit element. We''re interested
    in the `task_list` variable, so go ahead and write the following right under the
    line `st.header("Today''s to-dos:", divider="gray")`, before our display logic
    for-loop.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`print` 语句不会出现在你的 Streamlit 应用程序的浏览器窗口中。相反，让我们使用一个合适的 Streamlit 元素。我们感兴趣的是
    `task_list` 变量，所以请在 `st.header("Today''s to-dos:", divider="gray")` 行的下面写下以下内容，在我们的显示逻辑循环之前。'
- en: '[PRE16]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`st.info` is an element that displays some text in a colored box. It''s part
    of a family of elements we''ve seen already in Chapter 2: `st.success`, `st.error`,
    and `st.warning`, which also display text in colored boxes. For `st.info`, the
    box is blue.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`st.info` 是一个显示一些文本的彩色框的元素。它是我们在第 2 章中已经看到过的元素家族的一部分：`st.success`、`st.error`
    和 `st.warning`，这些元素也以彩色框显示文本。对于 `st.info`，框是蓝色的。'
- en: 'When you save and run (or refresh the page), you''ll see a box with the text
    task_list: [], since there are no tasks yet. Add a task like before and you''ll
    see the output in figure 4.11.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '当你保存并运行（或刷新页面）时，你会看到一个带有文本 task_list: [] 的框，因为没有任务。添加一个任务，就像之前一样，你会在图 4.11
    中看到输出。'
- en: '![image](../Images/04__image011.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image011.png)'
- en: Figure 4.11 task_list contains a single Task instance
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.11 task_list 包含一个 Task 实例
- en: As you can see, `task_list` now contains a single instance of `Task`, corresponding
    to "Clean garage.” When we add a second task, our `task_list` variable only has
    the new task. That shows that it's not our display logic that's faulty; the `task_list`
    variable itself has lost the "Clean garage" task. .
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`task_list` 现在包含一个 `Task` 实例的单个实例，对应于“清理车库”。当我们添加第二个任务时，我们的 `task_list`
    变量只有新的任务。这表明问题不在于我们的显示逻辑有误；`task_list` 变量本身已经丢失了“清理车库”任务。
- en: When we try either checking the box next to the task or pressing "Delete” `task_list`
    is now empty again, which is why no tasks are displayed.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试勾选任务旁边的复选框或按下“删除”按钮时，`task_list` 现在又变空了，这就是为什么没有显示任何任务的原因。
- en: 'Okay, so here''s what we know: adding a task seems to add a task to `task_list`
    correctly, but whenever you do *anything* else afterwards, whether it''s adding
    another task or clicking a checkbox or the "Delete" button, it removes the previously
    added task from `task_list`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以这是我们所知道的：添加任务似乎正确地将任务添加到了 `task_list` 中，但无论之后你做什么，无论是添加另一个任务还是点击复选框或“删除”按钮，它都会从
    `task_list` 中移除之前添加的任务。
- en: Before we can fix this, we'll need to understand why this is happening. For
    this, let's review how a Streamlit app actually works.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够解决这个问题之前，我们需要了解为什么会发生这种情况。为此，让我们回顾一下 Streamlit 应用实际上是如何工作的。
- en: 4.3 How Streamlit executes an app
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 Streamlit 如何执行应用程序
- en: In the last two chapters, we've learned how to use Streamlit and even developed
    a couple of non-trivial apps with it. However, we've mostly focused on syntax
    and a surface-level understanding of how apps work.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们学习了如何使用 Streamlit，甚至用它开发了一些非平凡的程序。然而，我们主要关注的是语法和对应用程序工作原理的表面理解。
- en: 'To be successful in writing more complex Streamlit apps, we''ll need to diver
    deeper than that. To go further, we need to talk about something quite fundamental
    to Streamlit: its execution model.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功编写更复杂的 Streamlit 应用程序，我们需要比这更深入地了解。为了更进一步，我们需要讨论 Streamlit 的一个相当基础的概念：它的执行模型。
- en: 4.3.1 Frontend and server
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 前端和服务器
- en: 'A Streamlit app actually has two parts: a backend *Streamlit server* and a
    *frontend*.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 应用实际上有两个部分：一个后端 *Streamlit 服务器* 和一个 *前端*。
- en: A server, for our purposes, is a software program that runs on your computer,
    waiting for requests to be sent to it. In technical terms, we say that a server
    is *listening* at a *port*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的来说，服务器是在你的电脑上运行的软件程序，等待接收发送给它的请求。从技术角度来说，我们说服务器是在一个 *端口* 上 *监听*。
- en: A port is a virtual designation that identifies a particular kind of communication
    channel, kind of like an extension number in a large office. Just as an extension
    allows you to reach a specific person within a company, a port allows network
    communication to reach a specific program running on your computer.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 端口是一个虚拟标识符，用于识别特定的通信通道，就像大型办公室中的分机号一样。正如分机可以帮助你联系公司内的特定人员，端口允许网络通信到达你电脑上运行的特定程序。
- en: 'When you enter `streamlit run <filename.py>` in your terminal, you may have
    noticed output that looks something like the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在终端中输入 `streamlit run <filename.py>` 时，你可能已经注意到了类似以下输出的内容：
- en: '[PRE17]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What's actually happening here is that a Streamlit server starts up and starts
    listening for requests on the port 8502 (the exact port number may differ for
    you).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上发生的情况是，一个 Streamlit 服务器启动并开始监听端口 8502（端口号可能因你而异）上的请求。
- en: When you now open a browser and navigate to the given address (i.e., `http://localhost:8502`)
    or just wait until the server automatically does this for you, the browser sends
    a request to the Streamlit server on port 8502.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在打开浏览器并导航到给定的地址（即 `http://localhost:8502`）或等待服务器自动为你完成此操作时，浏览器会向端口 8502 上的
    Streamlit 服务器发送请求。
- en: In response, the Streamlit server executes your Python script from top to bottom
    and sends a message back to the browser, telling it what to display, i.e., the
    frontend.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回应，Streamlit 服务器从顶部到底部执行您的 Python 脚本，并向浏览器发送一个消息，告诉它显示什么，即前端。
- en: The frontend is thus the front-facing part of your app that users can see and
    interact with, and it runs on your web browser. It consists of HTML, CSS, and
    Javascript code that your browser understands.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前端是用户可以看到并与之交互的应用程序的前端部分，它运行在您的网页浏览器上。它由浏览器理解的 HTML、CSS 和 JavaScript 代码组成。
- en: 4.3.2 App re-runs
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 应用程序重新运行
- en: 'Now, here''s the important part: the Streamlit server runs your Python script
    in its entirety *every* time the page needs to change. This includes each time
    the user interacts with a widget in your app.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里是重要的部分：Streamlit 服务器每次页面需要更改时都会运行您的 Python 脚本，这包括每次用户与您的应用程序中的小部件交互时。
- en: For example, figure 4.12 details what happens when a user clicks a button in
    your app.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，图 4.12 详细说明了当用户在您的应用程序中点击按钮时会发生什么。
- en: '![image](../Images/04__image012.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/04__image012.png)'
- en: Figure 4.12 Every time the user interacts with the app, the Python script is
    re-run
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.12 每次用户与应用程序交互时，Python 脚本都会重新运行
- en: Once the frontend detects the button-click, it sends a message to the server,
    informing it about the click. The server reacts to this information by re-running
    the Python code, setting the button to evaluate to `True`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦前端检测到按钮点击，它会向服务器发送一个消息，告知服务器点击信息。服务器通过重新运行 Python 代码并对按钮进行评估来响应此信息，将其设置为 `True`。
- en: When that's done, the server sends the frontend a message with the changes that
    need to be made to the display. The frontend then makes those changes and the
    user sees the updated display.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，服务器向前端发送一个包含需要更改的显示的消息。前端随后进行这些更改，用户看到更新后的显示。
- en: Note that this isn't unique to button clicks; it applies for *any* interaction
    or *any* time Streamlit determines the display needs to change. This means that
    every single time the user clicks a button or selects a different item from a
    dropdown or moves a slider, the cycle repeats and the server re-runs your whole
    Python script.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这并不仅限于按钮点击；它适用于 *任何* 交互或 Streamlit 确定显示需要更改的 *任何* 时间。这意味着每次用户点击按钮、从下拉菜单中选择不同的项目或移动滑块时，循环都会重复，服务器会重新运行您的整个
    Python 脚本。
- en: 4.3.3 Applying this to our app
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 将此应用于我们的应用程序
- en: Let's see if we can figure out what's happening in our to-do list app with this
    knowledge of app re-runs.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们能否利用应用程序重新运行的知识来了解我们的待办事项应用程序中发生了什么。
- en: Listing 4.5 shows the code as it exists at the moment.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 显示了当前存在的代码。
- en: Listing 4.5 todo_list.py
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.5 todo_list.py
- en: '[PRE18]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We're now going to walk through how this code executes at various points in
    the app's usage.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将逐步讲解这段代码在应用程序使用过程中的各个执行点。
- en: First run
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 首次运行
- en: The very first time our app runs, i.e., when the user first loads it, `task_list`
    is set to an empty list.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行我们的应用程序时，即当用户首次加载它时，`task_list` 被设置为空列表。
- en: 'Now consider this line within the `st.sidebar` context manager:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑 `st.sidebar` 管理器内的这一行：
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is an `if` statement, so the line under it, i.e., `add_task(task)`, will
    only be executed if the `st.button` expression evaluates to `True`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `if` 语句，因此其下的行，即 `add_task(task)`，只有在 `st.button` 表达式评估为 `True` 时才会执行。
- en: So far the button hasn't been clicked, so it evaluates to `False` and `add_task`
    is not called. `task_list` is therefore still an empty list.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，按钮尚未被点击，因此它评估为 `False`，`add_task` 不会被调用。因此，`task_list` 仍然是一个空列表。
- en: The code then proceeds to the `st.info` box and display logic, but since there
    are no tasks, `st.info` shows an empty list, and the loop never executes, so there
    are no checkboxes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码继续执行到 `st.info` 框和显示逻辑，但由于没有任务，`st.info` 显示一个空列表，循环从未执行，因此没有复选框。
- en: User adds a task
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用户添加任务
- en: Let's now say the user has entered a task, "Clean garage,” and clicked the "Add
    task" button. As mentioned earlier, this triggers a re-run of the entire Python
    code.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设用户已经输入了一个任务，“清理车库”，并点击了“添加任务”按钮。如前所述，这会触发整个 Python 代码的重新运行。
- en: Note
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Technically, a re-run may already have occurred at this point even *before*
    the user clicks the button. When the user has finished entering "Clean garage,”
    if they shift focus outside of the textbox by clicking outside it, that would
    qualify as an interaction (since the value in the textbox has changed) and trigger
    a re-run of the code. This doesn't lead to any interesting changes though, so
    let's ignore it for now.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，重新运行可能已经在这个点发生，甚至在用户点击按钮之前。当用户完成输入“清洁车库”后，如果他们通过点击文本框外部将焦点移出文本框，这将被视为一个交互（因为文本框中的值已更改）并触发代码的重新运行。但这不会导致任何有趣的变化，所以我们现在忽略它。
- en: Starting from the top of the script again, `task_list` is set to the empty list.
    Due to the line `task = st.text_input("Enter a task")`, the variable task now
    holds the string "Clean garage" as that's what's in the textbox.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 再次从脚本顶部开始，`task_list` 被设置为空列表。由于行 `task = st.text_input("Enter a task")`，变量
    `task` 现在持有字符串“清洁车库”，因为这是文本框中的内容。
- en: Since the button has just been clicked, `st.button` evaluates to `True`, so
    the `if` statement is triggered and `add_task` is called.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于按钮刚刚被点击，`st.button` 评估为 `True`，因此触发 `if` 语句并调用 `add_task`。
- en: '`add_task` creates a `Task` instance for "Clean garage" and appends it to `task_list`
    so it''s no longer empty. This is what `st.info` shows.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_task` 为“清洁车库”创建一个 `Task` 实例并将其追加到 `task_list` 中，使其不再为空。这就是 `st.info` 显示的内容。'
- en: The display logic loop thus runs once, and proceeds to render a checkbox and
    delete-button. This concludes the re-run, producing the results shown in figure
    4.13.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，显示逻辑循环运行一次，并继续渲染复选框和删除按钮。这完成了重新运行，产生了图 4.13 中所示的结果。
- en: '![image](../Images/04__image011.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image011.png)'
- en: Figure 4.13 When the user clicks "Add task,” st.button evaluates to True and
    task_list has a task
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.13 当用户点击“添加任务”时，st.button 评估为 True，并且 task_list 有一个任务
- en: User clicks the task checkbox
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用户点击任务复选框
- en: So far so good. Everything seems like it's working. But when the user clicks
    the checkbox for "Clean garage,” it triggers another re-run.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。一切似乎都在正常工作。但当用户点击“清洁车库”的复选框时，会触发另一个重新运行。
- en: Once again, we start from the top, where we have the line `task_list = []`,
    which again sets it to the empty list, discarding the "Clean garage" task that
    was in there before!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 再次从头开始，我们有行 `task_list = []`，它再次将其设置为空列表，丢弃了之前存在的“清洁车库”任务！
- en: But let's assume that the *textbox* hasn't been cleared yet, and still says
    "Clean garage.” This means that once the line `task = st.text_input("Enter a task")`
    has been executed, the variable `task` still contains the string "Clean garage.”
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们假设文本框尚未清除，仍然显示“清洁车库。”这意味着一旦执行了行 `task = st.text_input("Enter a task")`，变量
    `task` 仍然包含字符串“清洁车库。”
- en: What happens when we get to the `st.button` line? The button has been clicked
    before, so does that mean it would evaluate to `True`? If it does, then `add_task`
    would be triggered again, appending "Clean garage" to `task_list`, restoring its
    earlier state, and everything would be fine.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达 `st.button` 行时会发生什么？按钮之前已经被点击，那么这意味着它会被评估为 `True` 吗？如果是这样，那么 `add_task`
    将再次被触发，将“清洁车库”追加到 `task_list` 中，恢复其早期状态，一切都会正常。
- en: But that's not how `st.button` works. In reality, `st.button` evaluates to `True`
    only in the re-run that happens *immediately* after a click. In all later re-runs,
    it reverts to its original `False` value. In this case, clicking the checkbox
    triggered an all new re-run, so `st.button` now evaluates to `False`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `st.button` 的工作方式并非如此。实际上，`st.button` 只在点击后立即发生的重新运行中评估为 `True`。在所有后续的重新运行中，它将恢复到其原始的
    `False` 值。在这种情况下，点击复选框触发了一个全新的重新运行，因此 `st.button` 现在评估为 `False`。
- en: This means that `add_task` is never called and `task_list` is never updated.
    It remains an empty list, so in turn, the for-loop is never executed and there
    are no displayed tasks.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `add_task` 从未被调用，`task_list` 也从未更新。它保持为空列表，因此循环从未执行，没有显示任何任务。
- en: User adds another task instead of clicking the task checkbox
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用户添加另一个任务而不是点击任务复选框
- en: Just to close out this discussion, let's consider the scenario where, instead
    of clicking the task checkbox, the user tries to add another task (by entering
    "Finalize project proposal" in the task-entry textbox and clicking "Add task").
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这次讨论，让我们考虑这样一个场景：用户没有点击任务复选框，而是尝试添加另一个任务（通过在任务输入文本框中输入“完成项目提案”并点击“添加任务”）。
- en: The execution proceeds similarly in this case. `st_task` is set to the empty
    list at the top, so we lose the previous "Clean garage" task.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，执行过程类似。`st_task` 在顶部被设置为空列表，因此我们失去了之前的“清理车库”任务。
- en: Since we entered a new task, the textbox now holds "Finalize project proposal,”
    so that's what the `task` variable holds.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们输入了一个新任务，文本框现在包含“最终化项目提案”，因此这就是 `task` 变量所持有的内容。
- en: This time, our `st.button` does evaluate to `True` by virtue of our latest button-click,
    and `add_task` is called with "Finalize project proposal" as the value of the
    passed argument. This adds the new `Task` to our otherwise empty list.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，由于我们最新的按钮点击，我们的 `st.button` 通过了评估，并且 `add_task` 被调用，传递的参数值为“最终化项目提案”。这将在我们原本为空的列表中添加新的
    `Task`。
- en: 'At the end of this, `task_list` contains just one element: "Finalize project
    proposal,” which is what''s displayed by `st.info` and our display logic loop,
    as seen in figure 4.14.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，`task_list` 只包含一个元素：“最终化项目提案”，这正是 `st.info` 和我们的显示逻辑循环所显示的内容，如图 4.14 所示。
- en: '![image](../Images/04__image013.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image013.png)'
- en: Figure 4.14 When the user adds a different task, st.button evaluates to True
    again, and "Finalize project proposal" is added to task_list which was empty at
    the start.
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.14 当用户添加不同的任务时，st.button 再次评估为 True，并将“最终化项目提案”添加到最初为空的 task_list 中。
- en: We can finally explain the weird results we were seeing. The problem boils down
    to the fact that since our script re-runs each time, `task_list` keeps getting
    reset.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于可以解释我们看到的奇怪结果了。问题归结为，由于我们的脚本每次都会重新运行，`task_list` 不断被重置。
- en: 4.4 Persisting variables across re-runs
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 在多次运行间持久化变量
- en: In the last section, we were able to explain the unexpected output we were getting
    by reviewing Streamlit's execution model and stepping through our app's execution
    at various stages with our newfound understanding. In this section, we'll try
    and identify an approach to actually solve the issue.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们能够通过审查 Streamlit 的执行模型并在各个阶段逐步执行我们的应用程序来解释我们得到的不预期的输出。在本节中，我们将尝试确定一个实际解决问题的方法。
- en: 'To recap, our dilemma is that the app we wrote is behaving like a goldfish:
    it has no memory of anything that happened in any previous run. And since Streamlit
    re-runs the entirety of our code every chance it gets, our app''s memory gets
    wiped out repeatedly, resetting the `task_list` variable that we''re using to
    hold the user''s tasks.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，我们面临的困境是我们编写的应用程序表现得像金鱼：它对任何之前的运行中发生的事情都没有记忆。由于 Streamlit 每次都有机会重新运行我们的全部代码，我们的应用程序的内存就会反复被清除，重置我们用来保存用户任务的
    `task_list` 变量。
- en: 4.4.1 st.session_state
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 st.session_state
- en: As it turns out, Streamlit has a solution for this, in the form of `st.session_state`.
    In a nutshell, `st.session_state` is a container for variables whose values will
    persist across re-runs.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Streamlit 有一个解决方案，那就是 `st.session_state`。简而言之，`st.session_state` 是一个容器，用于存储将在多次运行间持久化的变量。
- en: '*Session* here refers to an app session, which you can loosely think about
    as the time between when you open an app and either refresh the page or close
    it.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 *Session* 指的是应用程序会话，你可以将其大致理解为从打开应用程序到刷新页面或关闭应用程序之间的时间。
- en: When you need to remember a value, you can just save it into `st.session_state`,
    and retrieve that value in the next run, as shown in figure 4.15.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要记住一个值时，你只需将其保存到 `st.session_state`，然后在下一次运行中检索该值，如图 4.15 所示。
- en: '![image](../Images/04__image014.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image014.png)'
- en: Figure 4.15 st.session_state can be used to save and retrieve values between
    re-runs
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.15 使用 st.session_state 在多次运行间保存和检索值
- en: '`st.session_state` is thus a rock of stability in an ocean of change. Or if
    you want a more technical metaphor, a store for the variables you want to persist
    across re-runs.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`st.session_state` 是变化海洋中的一块岩石。或者，如果你想有一个更技术的比喻，它是一个存储你想要在多次运行间持久化的变量的仓库。
- en: So how do we actually make use of it? Well, `st.session_state` acts almost exactly
    like a Python dictionary though it technically isn't one. Just as in the case
    of a dictionary, you can add key-value pairs to it, check if a particular key
    exists, look up its value, or remove it altogether. Even the syntax used is identical
    to that of a dictionary for the most part.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们实际上如何利用它呢？嗯，`st.session_state` 在技术上虽然不是，但几乎完全像是一个 Python 字典。就像在字典的情况下，你可以向其中添加键值对，检查是否存在特定的键，查找其值，或者完全删除它。甚至大部分使用的语法都与字典相同。
- en: For instance, if you wanted to store a variable `x` with a value of 5 in `st.session_state`,
    you would write `st.session_state["x"] = 5`, and then retrieve the value using
    `st.session_state["x"]`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想在`st.session_state`中存储一个值为5的变量`x`，你会写`st.session_state["x"] = 5`，然后使用`st.session_state["x"]`检索该值。
- en: To check if `x` exists in the session state, you would write `if "x" in st.session_state`.
    You can even iterate through the items in `st.session_state` using `for key, value
    in st.session_state.items()`, and delete a key using `del st.session_state`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查`x`是否存在于会话状态中，你会写`if "x" in st.session_state`。你甚至可以使用`for key, value in st.session_state.items()`遍历`st.session_state`中的项，并使用`del
    st.session_state`删除一个键。
- en: 'Unlike a dictionary though, you can also use dot-notation to refer to the value
    of a key `x` like this: `st.session_state.x.`'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 与字典不同，你还可以使用点符号来引用键`x`的值，如下所示：`st.session_state.x.`。
- en: 'Listing 4.6 shows a toy Streamlit app using `st.session_state` whose job is
    to simply keep track of and increment a number:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6显示了一个使用`st.session_state`的玩具Streamlit应用，其任务是简单地跟踪和增加一个数字：
- en: Listing 4.6 A simple number-increment app
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.6 一个简单的数字增加应用
- en: '[PRE20]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We start by checking if the key `"number"` exists in the session state and adding
    it with a value of zero if it doesn't.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查会话状态中是否存在键`"number"`，如果不存在，则将其添加，值为零。
- en: Then we have a button that increments the value of "number" each time it's clicked,
    and an `st.info` box to retrieve and display the value of number.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有一个按钮，每次点击都会增加“number”的值，还有一个`st.info`框来检索并显示number的值。
- en: Figure 4.16 shows the output after pressing the "Increment" button five times.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16显示了按下“增加”按钮五次后的输出。
- en: '![image](../Images/04__image015.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image015.png)'
- en: Figure 4.16 A toy Streamlit app using st.session_state to keep track of and
    increment a number
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.16 使用st.session_state跟踪和增加数字的玩具Streamlit应用
- en: If we hadn't used `st.session_state` here and had simply stored `number` in
    its own variable (or in a regular dictionary), it wouldn't have worked because
    the value (or the dictionary itself) would have gotten reset each time the app
    re-ran. `st.session_state` is the only thing that retains its state across re-runs
    of an app.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有在这里使用`st.session_state`，而是简单地将`number`存储在其自己的变量中（或在一个常规字典中），那么它将不会工作，因为每次应用重新运行时，值（或字典本身）都会被重置。`st.session_state`是唯一能够在应用重新运行之间保留其状态的东西。
- en: Why do we need the initial check to see if "number" already exists in the session
    state before adding it? Well, without this, we'd run into the same problem as
    before. Each time the app runs, it would set `st.session_state.number` to zero,
    overriding whatever value it had been incremented to in the earlier run, and we'd
    never see the number actually change.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要在添加之前检查“number”是否已经存在于会话状态中？嗯，如果没有这个检查，我们会遇到之前的问题。每次应用运行时，它都会将`st.session_state.number`设置为零，覆盖之前运行中增加到的任何值，我们永远不会看到数字实际上发生变化。
- en: By checking to see if "number" exists, we're ensuring that the line `st.session_state.number
    = 0` is only executed once—in the very first run when `"number"` hasn't been added
    yet.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查“number”是否存在，我们确保只有一次执行`st.session_state.number = 0`这一行——在第一次运行时，`"number"`尚未添加。
- en: 4.5 Completing our app
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 完成我们的应用
- en: We now know how to give our app a "memory.” When you start writing Streamlit
    apps for your own purposes, you'll quickly realize that this knowledge is absolutely
    crucial—to the point that you couldn't write anything but the simplest apps without
    it.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何给我们的应用一个“记忆。”当你开始为你自己的目的编写Streamlit应用时，你会很快意识到这个知识是绝对关键的——到了没有它你甚至无法编写除了最简单的应用之外的应用的程度。
- en: Armed with the powerful `st.session_state`, we're ready to take another crack
    at getting our to-do list app to work!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 借助强大的`st.session_state`，我们准备好再次尝试让我们的待办事项列表应用工作！
- en: 4.5.1 Adding session state
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.1 添加会话状态
- en: When we last ran our app, our main problem was the fact that the `task_list`
    variable, which holds all our tasks, was getting reset with every re-run.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上次运行我们的应用时，我们面临的主要问题是`task_list`变量，它包含所有我们的任务，每次重新运行都会被重置。
- en: 'Let''s fix this by adding `task_list` to `st.session_state`. Replace the line
    `task_list = []` in your earlier code with this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将`task_list`添加到`st.session_state`来解决这个问题。将你之前代码中的`task_list = []`行替换为以下内容：
- en: '[PRE21]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This mirrors the toy example we walked through in the last section. The only
    difference is that we're storing `task_list` in `st.session_state` rather than
    a single number.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在上一节中讨论的玩具示例相似。唯一的区别是我们将`task_list`存储在`st.session_state`中，而不是一个单独的数字。
- en: 'We could now modify the rest of our code to reference `st.session_state.task_list`
    everywhere it''s currently referencing `task_list`, but that seems tedious and
    rather clunky. Instead, let''s just point the variable `task_list` to the version
    in `st.session_state` like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以修改我们代码的其余部分，使其在当前引用 `task_list` 的所有地方都引用 `st.session_state.task_list`，但这似乎很繁琐，而且相当笨拙。相反，让我们只是将变量
    `task_list` 指向 `st.session_state` 中的版本，如下所示：
- en: '[PRE22]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now the rest of our code should work fine since they're referring to `task_list`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在其余的代码应该可以正常工作，因为它们都引用了 `task_list`。
- en: Listing 4.7 shows what our code should contain now.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 显示了我们的代码现在应该包含的内容。
- en: Listing 4.7 todo_list.py with st.session_state
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.7 todo_list.py 与 st.session_state
- en: '[PRE23]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Save, re-run, and try adding multiple tasks. Figure 4.17 shows what you get
    when you do this.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 保存、重新运行，并尝试添加多个任务。图 4.17 显示了你这样做会得到的结果。
- en: '![image](../Images/04__image016.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image016.png)'
- en: Figure 4.17 With st.session_state, Streamlit remembers our old tasks
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.17 使用 st.session_state，Streamlit 记住了我们的旧任务
- en: And voila! `task_list` can finally be updated with multiple tasks, and our display
    logic shows everything.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！`task_list` 终于可以更新为包含多个任务了，我们的显示逻辑也显示了所有内容。
- en: 4.5.2 Wiring up the "Delete" buttons
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.2 连接“删除”按钮
- en: With that in place, let's get our "Delete" buttons working. Recall that we had
    previously set them up to do nothing by writing `pass` under the code for the
    buttons within the display loop.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，让我们让我们的“删除”按钮开始工作。回想一下，我们之前通过在显示循环中的按钮代码下写 `pass` 来设置它们什么也不做。
- en: '[PRE24]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since then, we''ve created a `delete_task` function, so let''s call that here
    instead:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，我们创建了一个 `delete_task` 函数，所以让我们在这里调用它：
- en: '[PRE25]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we now click “Delete” next to “Buy Bread” after saving and re-running (and
    adding the three tasks back in order if you refreshed the page), we see... no
    changes! If we click the button a second time, however, the task disappears. Something
    still isn’t right.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在保存和重新运行（如果你刷新了页面，请按顺序重新添加三个任务）后点击“删除”旁边的“买面包”，我们会看到...没有变化！但是，如果你第二次点击按钮，任务就会消失。但似乎仍然有问题。
- en: I won't detail all of it with screenshots, but if you play around with the app
    at this point, you'll notice more odd behavior. The first time you click the "Delete"
    button against the last task in the list, it doesn't do anything. But if you then
    immediately click a checkbox (*any* checkbox), the task disappears.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会用截图详细说明所有内容，但如果你现在在这个阶段玩一下这个应用，你会注意到更多奇怪的行为。当你第一次点击列表中最后一个任务的“删除”按钮时，它没有任何反应。但是，如果你紧接着点击一个复选框（*任何*复选框），任务就会消失。
- en: Or if you delete a task from the middle of the list, the *next* one disappears,
    not the one you deleted! But if you *then* do something else, like clicking a
    checkbox or adding another task, that task comes back and the one you actually
    deleted is correctly removed and everything is the way it should be.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你从列表中间删除一个任务，下一个任务会消失，而不是你删除的那个！但是，如果你*然后*做些其他事情，比如点击一个复选框或添加另一个任务，那个任务就会回来，而你实际删除的那个任务会正确地被移除，一切都会恢复正常。
- en: All in all, there seems to be a *lag* between when you actually click the "Delete"
    button and when the task is removed. You seem to need to do something else (anything
    else, like clicking one of the checkboxes, or editing the text in the task entry
    textbox and clicking outside) *after* clicking the button for the correct results
    to be displayed.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，似乎在实际上点击“删除”按钮和任务被删除之间存在一定的*延迟*。你似乎需要在点击按钮后做些其他事情（任何其他事情，比如点击一个复选框，或者编辑任务输入框中的文本并点击外部），才能显示正确的结果。
- en: 4.5.3 What's happening behind the scenes
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.3 背后发生的事情
- en: 'To understand what''s going on, we need to do a deep-dive into our app''s execution
    once again. Let''s assume we''re at the stage in the app where the user has entered
    three tasks in order: "Clean garage.” "Finalize project proposal.” and "Buy bread.”'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解发生了什么，我们需要再次深入挖掘我们的应用执行。让我们假设我们处于应用的一个阶段，用户已经按顺序输入了三个任务：“清理车库。”、“最终确定项目提案。”和“买面包。”
- en: At this point, `task_list` has been populated with these three tasks.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`task_list` 已经被填充了这三个任务。
- en: Stepping through the app's execution
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 步骤遍历应用执行
- en: Let's say the user tries to delete the third task. Figure 4.18 shows diagrammatically
    what happens in the app. The delete buttons are identified by the Streamlit widget
    keys assigned to them, i.e., `delete_0`, `delete_1`, etc.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户尝试删除第三个任务。图 4.18 以图解方式显示了应用中发生的情况。删除按钮由分配给它们的 Streamlit 小部件键标识，即 `delete_0`、`delete_1`
    等。
- en: '![image](../Images/04__image017.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image017.png)'
- en: 'Figure 4.18 Step-by-step app execution: the delete button evaluates to True
    in the second run, but the task and button are displayed *before* delete_task
    is called'
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.18 步骤分解应用执行：在第二次运行中，删除按钮评估为True，但任务和按钮在调用`delete_task`之前就已经显示
- en: The first run is the one that happens before the button is clicked. Streamlit
    simply loops through our task list, displaying each task along with its checkbox
    and delete button. As we discussed earlier in the chapter, each `st.button` evaluates
    to `False`, since none of them have been pressed yet.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行是在点击按钮之前发生的。Streamlit简单地遍历我们的任务列表，显示每个任务及其复选框和删除按钮。正如我们在本章前面讨论的那样，每个`st.button`都评估为`False`，因为它们还没有被按下。
- en: When the user clicks the delete button for "Buy bread.” it triggers a re-run
    of the app. Everything remains the same until after we have displayed the third
    task's `st.button`. This time, this button evaluates to `True` since it was just
    clicked. As the condition is true, the app enters the code nested under `st.button`,
    `delete_task(idx)`. Since `idx` is 2 in this iteration of the loop, `delete_task(2)`
    is called, and "Buy bread" is removed from `task_list`. Execution stops at this
    point.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击“买面包”的删除按钮时，它触发了应用的重新运行。一切保持不变，直到我们显示第三个任务的`st.button`。这次，由于它刚刚被点击，这个按钮评估为`True`。由于条件为真，应用进入嵌套在`st.button`下的代码，调用`delete_task(idx)`。由于在这个循环迭代中`idx`是2，所以调用`delete_task(2)`，从`task_list`中移除“买面包”。执行在此处停止。
- en: See the problem? All three buttons had *already* been displayed *before* `delete_task`
    was executed, updating `task_list`. And since there are no other user actions,
    no more re-runs are triggered. So `task_list` is updated all right, but the display
    logic has already been executed on the old version of `task_list`. That's why
    we still see the three tasks after clicking "Delete.”
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 看到问题了吗？所有三个按钮在执行`delete_task`之前就已经显示，更新了`task_list`。由于没有其他用户操作，没有更多的重新运行被触发。所以`task_list`确实被更新了，但显示逻辑已经在旧的`task_list`版本上执行了。这就是为什么我们点击“删除”后仍然看到三个任务。
- en: But at this point, if the user does something else, like clicking a checkbox
    or even clicking the "Delete" button again, it triggers another re-run. This time,
    the display logic runs over the latest version of `task_list`, so we finally see
    the third task and its checkbox and delete button removed.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这个时候，如果用户执行其他操作，比如点击复选框或者再次点击“删除”按钮，就会触发另一个重新运行。这次，显示逻辑运行在`task_list`的最新版本上，所以我们最终看到了第三个任务及其复选框和删除按钮被移除。
- en: Note
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Stepping through the execution like this can also explain the other odd behavior
    we noticed, such as when you click the delete button for a task in the middle
    of the list, and the *next* task disappears. This happens because when delete_task
    is called, the list indices all get moved up by one, and the next display loop
    iteration ends up skipping a task because its index changed.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式逐步执行也可以解释我们注意到的其他奇怪行为，例如当你点击列表中间任务的删除按钮时，下一个任务消失。这是因为当调用`delete_task`时，列表索引都会向上移动一个位置，下一个显示循环迭代最终跳过一个任务，因为它的索引已经改变。
- en: 4.5.4 Triggering re-runs automatically
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.4 自动触发重新运行
- en: As we've seen, though our delete button doesn't work correctly immediately,
    Streamlit does get the results right eventually, provided the user takes an extra
    action, triggering a re-run.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，尽管我们的删除按钮最初没有正确工作，但Streamlit最终确实得到了正确的结果，前提是用户采取额外的行动，触发重新运行。
- en: 'We can use this knowledge to our advantage. All we need is a way to trigger
    a re-run of the app through code, rather than through a user action. Streamlit
    offers this functionality through `st.rerun`, and you can call it at any time
    without any arguments, like so:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这个知识来发挥我们的优势。我们需要的只是一个通过代码触发应用重新运行的方法，而不是通过用户操作。Streamlit通过`st.rerun`提供这个功能，并且可以在任何时候不带任何参数调用它，如下所示：
- en: '[PRE26]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When you call `st.rerun`, you're essentially telling Streamlit, "Quit the current
    run and start again from the top."
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`st.rerun`时，你实际上是在告诉Streamlit，“退出当前运行并从头开始。”
- en: 'In our case, we should trigger the re-run once a task has been deleted:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，一旦任务被删除，我们应该触发一次重新运行：
- en: '[PRE27]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you make this change, re-run and recreate the tasks as before, and try deleting
    "Buy bread" again, you'll see the output in figure 4.19.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做出这个更改，重新运行并像以前一样重新创建任务，然后再次尝试删除“买面包”，你将看到图4.19中的输出。
- en: '![image](../Images/04__image018.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image018.png)'
- en: Figure 4.19 Pressing "Delete" works as expected with st.rerun
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.19 使用st.rerun时按下“删除”按钮按预期工作
- en: It worked! "Buy bread" is no more, and it's also missing from `task_list` as
    you can see from the `st.info` box in the screenshot.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 它成功了！“买面包”不再存在，你也可以从截图中的`st.info`框中看到它已从`task_list`中消失。
- en: 4.5.5 Wiring up the checkboxes
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.5 连接复选框
- en: 'Let''s move on to the next part of our app: the checkboxes. We''ve added them
    in the display and you can check them, but they don''t actually do anything. Our
    next step, then, is to hook them up to the functionality we''ve defined for changing
    the status of a task.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到我们应用的下一个部分：复选框。我们已经将它们添加到显示中，你可以勾选它们，但它们实际上并没有做任何事情。因此，我们的下一步是将它们连接到我们为更改任务状态定义的功能。
- en: 'Our current checkbox code is a single line:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的复选框代码是一行：
- en: '[PRE28]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When the user checks a task checkbox, we want to achieve two things:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户勾选任务复选框时，我们想要实现两个目标：
- en: Mark the task as done, and
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记任务为完成，并
- en: Strike it through
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除线
- en: We also want to reverse the above changes if the user unchecks a box.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望如果用户取消勾选框，则撤销上述更改。
- en: To change the task's status, we can use the functions we created earlier for
    the purpose, `mark_done` and `mark_not_done`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改任务的状态，我们可以使用我们之前为该目的创建的函数，`mark_done`和`mark_not_done`。
- en: How do we achieve the strikethrough? For this formatting effect (and several
    others), Streamlit supports a language called *markdown*.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实现删除线？为了这种格式化效果（以及其他几种效果），Streamlit支持一种叫做*markdown*的语言。
- en: Markdown is a special text-based notation to add various kinds of formatting.
    It has ways to display text in bold or italic, to create links, lists, headings,
    and much more. We'll encounter these in later chapters, but for now let's focus
    on the strikethrough effect.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown是一种特殊的基于文本的标记语言，用于添加各种类型的格式。它有显示文本加粗或斜体、创建链接、列表、标题等功能。我们将在后面的章节中遇到这些功能，但就目前而言，让我们专注于删除线效果。
- en: 'To strike a piece of text through in markdown, you surround it with two pairs
    of tildes, like this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在markdown中，要删除一段文本，你可以用两个波浪号将其包围，如下所示：
- en: '[PRE29]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This plugs into our checkbox through the label parameter, which supports markdown.
    We''ll define a variable that contains the name of a task by itself if the task
    has not been done, and the name with a markdown strikethrough if it does:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过标签参数连接到我们的复选框，该参数支持markdown。我们将定义一个变量，如果任务未完成，则包含任务名称本身，如果已完成，则包含带有markdown删除线的名称：
- en: '[PRE30]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can then feed it into our checkbox:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将其输入到我们的复选框中：
- en: '[PRE31]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finally, let's also wire up our checkboxes to our `mark_*` functions. We want
    to call `mark_done` if the checkbox is checked, or `mark_not_done` otherwise.
    Our overall code should now be as shown in listing 4.8.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们也将我们的复选框连接到我们的`mark_*`函数。如果我们勾选了复选框，则调用`mark_done`，否则调用`mark_not_done`。我们的整体代码现在应如列表4.8所示。
- en: Listing 4.8 todo_list.py after wiring up the task checkboxes
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 连接任务复选框后的4.8 todo_list.py
- en: '[PRE32]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '#A Add a strikethrough effect to the label if the task is done'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 如果任务已完成，则在标签上添加删除线效果'
- en: '#B Call mark_done if the checkbox happens to be checked and therefore evaluates
    to True'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 如果复选框被勾选并因此评估为True，则调用 mark_done'
- en: '#C Call mark_not_done if the checkbox is not checked'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 如果复选框未勾选，则调用 mark_not_done'
- en: Save, re-run, and add your tasks back, then check one of the tasks to get results
    similar to what's shown in figure 4.20.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 保存，重新运行，并添加你的任务，然后勾选一项任务以获得类似于图4.20所示的结果。
- en: '![image](../Images/04__image019.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image019.png)'
- en: Figure 4.20 Checking a task doesn't immediately work as expected
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图4.20 勾选任务并不立即按预期工作
- en: Once again, we didn't get the results we expected. "Clean garage" remains unstruck,
    and our info box shows that `task_list` hasn't changed. Before you throw your
    computer out the window and dedicate the rest of your existence to sheep-farming,
    try checking off another task.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们没有得到预期的结果。“清理车库”仍然没有删除线，我们的信息框显示`task_list`没有变化。在你把电脑扔出窗外并致力于余生放牧羊群之前，试着勾选另一个任务。
- en: You'll see that now the original task we checked has its strikethrough, and
    its `is_done` field is `True` as per our `st.info` box.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到现在我们勾选的原任务有了删除线，并且根据我们的`st.info`框，其`is_done`字段为`True`。
- en: Sound familiar? Looks like there's a lag of one user action between when we
    click a checkbox and when the result of that action shows up.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来熟悉吗？看起来在我们点击复选框和该动作的结果显示之间有一个用户动作的延迟。
- en: What's going on here is very similar to what we saw in the case of the delete
    button. Clicking the checkbox does trigger our function and sets `is_done` to
    `True`, but by that point, the task and its label have already been displayed.
    Only in the *next* re-run is the *actual display* updated, and that re-run is
    only triggered when the user takes a further action.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况与我们在删除按钮的情况中看到的情况非常相似。点击复选框确实触发了我们的函数并将 `is_done` 设置为 `True`，但到那时，任务及其标签已经显示。只有在
    *下一次* 重运行中，*实际显示* 才会更新，而这个重运行只有在用户采取进一步行动时才会触发。
- en: 'The solution to this is the same as before: we can trigger a manual re-run
    each time one of our `mark_*` functions runs:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案与之前相同：我们可以在每次我们的 `mark_*` 函数运行时触发一个手动重运行：
- en: '[PRE33]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Save the output, refresh the page, and let's try again. Figure 4.21 shows the
    output.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 保存输出，刷新页面，然后再次尝试。图 4.21 展示了输出。
- en: '![image](../Images/04__image020.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image020.png)'
- en: Figure 4.21 Our app hangs and never stops loading
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.21 我们的应用挂起并且永远不会停止加载
- en: Something's very wrong here. Our app seems to stop responding entirely once
    we add our first task. The screen's grayed out, and there's the "RUNNING…" indicator
    at the top.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这里出了大问题。一旦我们添加了第一个任务，我们的应用似乎就完全停止响应了。屏幕变灰，顶部出现“正在运行…”的指示符。
- en: 4.5.6 An infinite re-run loop
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.6 无限重运行循环
- en: You've just encountered your first Streamlit infinite re-run loop. Let's try
    to understand what went wrong by stepping through the execution one more time.
    Figure 4.22 shows this in a diagram.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚遇到了你的第一个 Streamlit 无限重运行循环。让我们通过再次逐步执行来尝试理解出了什么问题。图 4.22 以图表形式展示了这一点。
- en: '![image](../Images/04__image021.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image021.png)'
- en: 'Figure 4.22 Step-by-step app execution: A chain of st.reruns leads to an infinite
    loop'
  id: totrans-372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.22 步骤分解应用执行：一系列的 `st.rerun()` 导致无限循环
- en: Once we've added our "Clean garage" task, `task_list` contains a single `Task`
    instance with its `is_done` field set to `False`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了“清理车库”任务，`task_list` 包含一个单独的 `Task` 实例，其 `is_done` 字段被设置为 `False`。
- en: Since `task_list` is non-empty, we enter the display loop, and the checkbox
    for "Clean garage" is displayed.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `task_list` 不为空，我们进入了显示循环，并显示了“清理车库”的复选框。
- en: 'Now our task has branching logic:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的任务有了分支逻辑：
- en: '[PRE34]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The checkbox evaluates to `False` since it's not checked, which means the app
    enters the `else` clause.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 复选框评估结果为 `False`，因为它没有被勾选，这意味着应用进入了 `else` 子句。
- en: '`mark_not_done` is called, which sets `is_done` to `False` (even though it''s
    already `False`), and then `st.rerun()` forces Streamit to stop the current run
    and start again from the top.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 调用了 `mark_not_done`，将 `is_done` 设置为 `False`（尽管它已经是 `False`），然后 `st.rerun()`
    强制 Streamit 停止当前运行并从头开始。
- en: Once again, in the second run, we enter the loop. The checkbox is still not
    checked, so `mark_not_done` is called again, and `st.rerun()` after that, which
    begins a third run, and so on and on.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在第二次运行中，我们进入了循环。复选框仍然没有被勾选，所以 `mark_not_done` 再次被调用，然后调用 `st.rerun()`，这开始第三次运行，以此类推。
- en: Since this never stops, Streamlit chokes and stops responding.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这永远不会停止，Streamlit 会卡住并停止响应。
- en: 4.5.7 Preventing the infinite re-run
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.7 防止无限重运行
- en: The trouble here is that `mark_done` is getting called even when there's no
    need for it. Reviewing the execution steps we saw just now, you'll notice that
    the "Clean garage" task's `is_done` field was already set to `False`, so there
    was no actual need to call `mark_not_done` again.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是 `mark_done` 即使在没有必要的情况下也会被调用。回顾我们刚才看到的执行步骤，你会注意到“清理车库”任务的 `is_done` 字段已经被设置为
    `False`，因此实际上没有必要再次调用 `mark_not_done`。
- en: The way our code is set up right now, once we enter our display for-loop, there's
    no exiting it. If our checkbox evaluates to `True`, `st.rerun()` is called after
    the `mark_done` function. If it evaluates to `False`, `st.rerun()` is called after
    the `mark_not_done` function.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前的代码设置中，一旦我们进入显示循环，就无法退出。如果我们的复选框评估结果为 `True`，则在 `mark_done` 函数之后调用 `st.rerun()`。如果评估结果为
    `False`，则在 `mark_not_done` 函数之后调用 `st.rerun()`。
- en: We need to make sure that this only happens when it absolutely needs to. `mark_done`
    (and the associated `st.rerun`) should only be called if the checkbox is checked
    *and* the task is not already marked as "done.” Similarly, `mark_not_done` and
    *its* `st.rerun` should only be called if the checkbox is not checked and the
    task is currently marked as "done.”
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保这只有在绝对需要时才会发生。`mark_done`（以及相关的 `st.rerun`）只有在复选框被勾选且任务尚未标记为“完成”时才应被调用。同样，`mark_not_done`
    和其 `st.rerun` 应只有在复选框未被勾选且任务当前标记为“完成”时才被调用。
- en: 'We can make this happen by editing our code like this:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过像这样编辑我们的代码来实现这一点：
- en: '[PRE35]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '#A Save the checkbox''s value in a new variable called checked, for readability.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 将复选框的值保存在一个名为 checked 的新变量中，以提高可读性。'
- en: '#B Only call mark_done if the checkbox is checked AND the task is not yet marked
    as done.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 只有当复选框被勾选且任务尚未标记为完成时，才调用 mark_done。'
- en: '#C Only call mark_not_done if the checkbox is not checked AND the task is still
    marked as done.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 只有当复选框未勾选且任务仍然标记为完成时，才调用 mark_not_done。'
- en: This way, when the checkbox is checked, the task's status is set to `is_done`,
    but in the next re-run, both the if and elif clauses evaluate to `False`, and
    `st.rerun` never executes.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当复选框被勾选时，任务的状态设置为 `is_done`，但在下一次重新运行中，if 和 elif 子句都评估为 `False`，并且 `st.rerun`
    永远不会执行。
- en: Go ahead and try it out. Our checkboxes should now be working correctly, as
    shown in figure 4.23.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。现在我们的复选框应该可以正常工作，如图 4.23 所示。
- en: '![image](../Images/04__image022.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image022.png)'
- en: Figure 4.23 Our checkboxes now work as expected
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.23 我们复选框现在按预期工作
- en: 4.5.8 Adding the completion progress indicator
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5.8 添加完成进度指示器
- en: We're *almost* done with our app. The only thing that remains from our earlier
    mock design is to add a progress indicator to give the user that extra sense of
    accomplishment.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了我们的应用程序。从我们早期的模拟设计中剩下的唯一事情是为用户提供额外的成就感感，添加一个进度指示器。
- en: This is quite straightforward. We want the indicator to be nice and large, so
    `st.metric`, which we encountered first in Chapter 3, seems ideal.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当直接。我们希望指示器既大又漂亮，所以我们在第 3 章中首次遇到的 `st.metric` 看起来很理想。
- en: 'We''ll need to show two things: the total number of tasks, and the number of
    completed tasks, both of which we can get from `task_list`. Our code for `st.metric`
    could look like this:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要展示两个东西：任务总数和已完成任务数，这两个都可以从 `task_list` 获取。我们的 `st.metric` 代码可能看起来像这样：
- en: '[PRE36]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To get `completed_tasks`, we use a list comprehension (you can skip the square
    brackets when it's wrapped in a function like sum) for conciseness.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 `completed_tasks`，我们使用列表推导（当它被函数如 sum 包裹时，可以省略方括号）以实现简洁。
- en: Oh, and we can probably get rid of our info box (`st.info`) since we're no longer
    in troubleshooting mode.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，我们可能可以去掉我们的信息框（`st.info`），因为我们不再处于故障排除模式。
- en: Our final code should look like what's shown in Listing 4.9.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的代码应该看起来像列表 4.9 中所示的那样。
- en: Listing 4.9 The final version of todo_list.py
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.9 todo_list.py 的最终版本
- en: '[PRE37]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Figure 4.24 provides a final glance at our app in all its glory.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.24 提供了对我们应用程序的最终审视。
- en: '![image](../Images/04__image023.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/04__image023.png)'
- en: Figure 4.24 The final to-do list app
  id: totrans-406
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.24 最终待办事项列表应用程序
- en: With that, you have another full app under your belt, and maybe even a tool
    you can use every day to stay productive! You're now already in a position to
    start using Streamlit in your own projects. In the next chapter, we'll see how
    to publish them for other people to use.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就有了一个完整的应用程序在你的掌握之中，也许甚至是一个你可以每天使用的工具来保持高效！你现在已经处于可以使用 Streamlit 在自己的项目中开始使用的位置。在下一章中，我们将看到如何将它们发布供其他人使用。
- en: 4.6 Summary
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 总结
- en: In the real world, the development process is not smooth; much of your time
    will be spent troubleshooting things that don't work as expected.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现实世界中，开发过程并不顺利；你大部分的时间将花在解决那些不符合预期的事情上。
- en: '`st.header` is used to display headings in large font.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.header` 用于以大字体显示标题。'
- en: Streamlit identifies UI widgets using a unique widget key based on its characteristics.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Streamlit 使用基于其特性的唯一小部件键来识别 UI 小部件。
- en: When two widgets are identical in every respect, you have to specify a widget
    key manually to enable Streamlit to tell them apart.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当两个小部件在各个方面都相同的时候，你必须手动指定小部件键，以便 Streamlit 能够区分它们。
- en: A good way to keep track of the values of variables as the app executes is to
    display them on the app's screen using `st.info`.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用执行过程中跟踪变量值的一个好方法是使用 `st.info` 在应用屏幕上显示它们。
- en: Whenever the page needs to change, the Streamlit server re-runs your Python
    code from top to bottom.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当页面需要更改时，Streamlit 服务器都会从头到尾重新运行你的 Python 代码。
- en: Re-runs reset all the regular variables in your app.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新运行将重置应用程序中所有常规变量。
- en: '`st.session_state` is used to store variables that you want Streamlit to remember
    between re-runs.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`st.session_state` 用于存储你希望 Streamlit 在重新运行之间记住的变量。'
- en: It's a good idea to step through the app's execution when you see unexpected
    results.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你看到意外结果时，逐步执行应用程序的执行是一个好主意。
- en: You can trigger a re-run of your app using `st.rerun.`
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `st.rerun` 触发应用程序的重新运行。
- en: While using `st.rerun`, your app may end up in an infinite re-run loop if you
    don't provide a path for your script to exit.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 `st.rerun` 时，如果你的脚本没有提供退出路径，你的应用可能会陷入无限重跑循环。
