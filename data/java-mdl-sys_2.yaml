- en: Part 3
  id: totrans-0
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第3部分
- en: Advanced module system features
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 高级模块系统功能
- en: Whereas parts 1 and 2 were akin to four-course dinners, this part of the book
    is more like a buffet. It covers the module system’s advanced features, and you’re
    free to pick whatever interests you the most in whatever order you prefer.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 而第1部分和第2部分类似于四道菜的晚餐，这本书的这一部分更像是一个自助餐。它涵盖了模块系统的先进功能，你可以自由选择你最喜欢的内容，以你喜欢的顺序进行选择。
- en: Chapter 10 introduces services, a great mechanism to decouple users and implementations
    of an API. If you’re more interested in refining `requires` and `exports`—for
    example, to model optional dependencies—check out chapter 11\. Look into chapter
    12 to prepare your modules for reflective access by your favorite framework and
    to learn how to update your own reflecting code.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第10章介绍了服务，这是一种将用户与API的实现解耦的强大机制。如果你对精炼 `requires` 和 `exports` 更感兴趣——例如，用于建模可选依赖项——请查看第11章。查看第12章，以准备你的模块供你喜欢的框架进行反射访问，并学习如何更新你自己的反射代码。
- en: The module system doesn’t process module version information, but you can record
    it when building modules and to evaluate them at run time. Chapter 13 explores
    that as well as the reasons why there is no further support for versions, for
    example to run multiple versions of the same module.
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块系统不处理模块版本信息，但在构建模块时可以记录它，并在运行时评估它。第13章也探讨了这一点，以及为什么没有进一步支持版本的原因，例如运行同一模块的多个版本。
- en: Chapter 14 takes a step back from developing modules and instead sees them as
    input for creating custom run-time images that contain just the modules you need
    to run your project. Going one step further, you can include your entire application
    and create a single deployable unit to ship to your customers or servers.
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第14章从开发模块退后一步，而是将它们视为创建自定义运行时图像的输入，这些图像仅包含运行你的项目所需的模块。更进一步，你可以包括你的整个应用程序，创建一个可部署的单个单元，以便发送给你的客户或服务器。
- en: 'Finally, chapter 15 puts all the pieces together. It shows you a variant of
    the ServiceMonitor application that uses most of the advanced features and then
    gives some tips for designing and maintaining modular applications before daring
    to portray Java’s future: a modular ecosystem.'
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，第15章将所有这些内容整合在一起。它展示了ServiceMonitor应用程序的一个变体，该变体使用了大多数高级功能，然后给出了一些设计和维护模块化应用程序的技巧，在勇敢地描绘Java的未来：一个模块化生态系统之前。
- en: By the way, these features aren’t advanced in the sense that they’re more complicated
    than the basic mechanisms. It’s that they build on top of those mechanisms and
    thus require a little more background knowledge of the module system. If you’ve
    read part 1, particularly chapter 3, you’re good to go.
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 顺便说一句，这些功能在复杂程度上并不先进，它们只是比基本机制更复杂。它们建立在那些机制之上，因此需要更多关于模块系统的背景知识。如果你已经阅读了第1部分，特别是第3章，你就准备好了。
- en: (I know, I’ve said it a couple of times already, but remember that the module
    names I’ve chosen were cut short to make them more amenable. Use the reverse-domain
    naming scheme as described in section 3.1.3.)
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: （我知道，我已经说过几次了，但请记住，我选择的模块名称被缩短了，以便更容易使用。请使用3.1.3节中描述的反域名命名方案。）
- en: '10'
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '10'
- en: Using services to decouple modules
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用服务解耦模块
- en: This chapter covers
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Improving project designs with services
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用服务改进项目设计
- en: Creating services, consumers, and providers in the JPMS
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JPMS中创建服务、消费者和提供者
- en: Using the `ServiceLoader` to consume services
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ServiceLoader` 消费服务
- en: Developing well-designed services
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发设计良好的服务
- en: Deploying services in plain and modular JARs across different Java versions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同Java版本中部署普通和模块化的JAR文件
- en: Up to now, we represented relationships between modules with `requires` directives
    where the depending module has to reference each specific dependency by name.
    As section 3.2 explains in depth, this lies at the heart of reliable configuration.
    But sometimes you want a higher level of abstraction.
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用 `requires` 指令来表示模块之间的关系，其中依赖模块必须通过名称引用每个特定的依赖项。正如3.2节深入解释的那样，这位于可靠配置的核心。但有时你想要一个更高层次的抽象。
- en: This chapter explores services in the module system and how to use them to decouple
    modules by removing direct dependencies between them. The first step to solving
    any problems with services is to get the basics down. Following that, we look
    at the details, particularly how to properly design services (section 10.3) and
    how to use the JDK’s API to consume them (section 10.4). (To see services in practice,
    check out the `feature-services` branch in ServiceMonitor's repository.)
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章探讨了模块系统中的服务以及如何通过消除它们之间的直接依赖来使用它们解耦模块。解决服务问题的第一步是掌握基础知识。在此基础上，我们查看细节，特别是如何正确设计服务（第10.3节）以及如何使用JDK的API来消费它们（第10.4节）。（要查看服务的实际应用，请查看ServiceMonitor存储库中的`feature-services`分支。）
- en: By the end of this chapter, you’ll know how to design services well, how to
    write declarations for modules that use or provide services, and how to load services
    at run time. You can use these skills to connect with services in the JDK or third-party
    dependencies as well as to remove direct dependencies in your own project.
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何设计良好的服务，如何为使用或提供服务的模块编写声明，以及如何在运行时加载服务。你可以使用这些技能来连接JDK或第三方依赖项中的服务，以及在你自己的项目中消除直接依赖。
- en: 10.1 Exploring the need for services
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.1 探索服务需求
- en: If we were talking about classes instead of modules, would you be happy with
    always depending on concrete types? Or with having to instantiate each dependency
    in the class that needs it? If you like design patterns like inversion of control
    and dependency injection, you should be vigorously shaking your head at this point.
    Compare listings 10.1 and 10.2—doesn’t the second one look better? It allows the
    caller to pick the stream that gets to be awesome and even gives the caller the
    freedom to choose any `InputStream` implementation.
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果我们谈论的是类而不是模块，你会对总是依赖于具体类型感到满意吗？或者需要为需要它的每个类实例化每个依赖？如果你喜欢像控制反转和依赖注入这样的设计模式，你现在应该强烈地摇头。比较列表10.1和10.2——第二个看起来不是更好吗？它允许调用者选择成为出色的流，甚至给调用者选择任何`InputStream`实现的自由。
- en: Listing 10.1 Depends on a concrete type and establishes the dependency
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表10.1 依赖于具体类型并建立依赖
- en: '`public class InputStreamAwesomizer {` `private final ByteArrayInputStream
    stream;` [`①`](part0025.html#filepos1196269) `public AwesomeInputStream(byte[]
    buffer) {` `stream = new ByteArrayInputStream(buffer);` [`②`](part0025.html#filepos1196603)
    `}  // [... awesome methods ...]  }`'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public class InputStreamAwesomizer {` `private final ByteArrayInputStream
    stream;` [`①`](part0025.html#filepos1196269) `public AwesomeInputStream(byte[]
    buffer) {` `stream = new ByteArrayInputStream(buffer);` [`②`](part0025.html#filepos1196603)
    `}  // [... 精彩方法 ...]  }`'
- en: ①
  id: totrans-24
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Depends on a concrete type
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 依赖于具体类型
- en: ②
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Establishes the dependency directly
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 直接建立依赖
- en: Listing 10.2 Depends on an abstract type; caller establishes the dependency
  id: totrans-28
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表10.2 依赖于抽象类型；调用者建立依赖
- en: '`public class InputStreamAwesomizer {` `private final InputStream stream;`
    [`①`](part0025.html#filepos1197963) `public AwesomeInputStream(InputStream stream)
    {` `this.stream = stream;` [`②`](part0025.html#filepos1198298) `}  // [... awesome
    methods ...]  }`'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public class InputStreamAwesomizer {` `private final InputStream stream;`
    [`①`](part0025.html#filepos1197963) `public AwesomeInputStream(InputStream stream)
    {` `this.stream = stream;` [`②`](part0025.html#filepos1198298) `}  // [... 精彩方法
    ...]  }`'
- en: ①
  id: totrans-30
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Depends on an abstract type
  id: totrans-31
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 依赖于抽象类型
- en: ②
  id: totrans-32
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Dependency established by the caller
  id: totrans-33
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 调用者建立的依赖
- en: Another important benefit of depending on interfaces or abstract classes and
    letting someone else pick the concrete instance is that doing so inverts the direction
    of dependencies. Instead of high-level concepts (let’s say `Department`) depending
    on low-level details (`Secretary`, `Clerk`, and `Manager`), both can depend on
    an abstraction (`Employee`). As [figure 10.1](part0025.html#filepos1199882) shows,
    this breaks the dependency between high-and low-level concepts and thus decouples
    them.
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 依赖于接口或抽象类并让其他人选择具体实例的另一个重要好处是，这样做反转了依赖的方向。不是高级概念（比如说`Department`）依赖于低级细节（`Secretary`、`Clerk`和`Manager`），两者都可以依赖于一个抽象（`Employee`）。如图10.1所示，这打破了高级和低级概念之间的依赖关系，从而将它们解耦。
- en: '![](../images/00006.jpeg)'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00006.jpeg)'
- en: '[Figure 10.1](part0025.html#filepos1199475) If a type establishes its own dependencies
    (top), users can’t influence them. If a type’s dependencies are passed during
    construction (bottom), users can pick the implementation that best fits their
    use case.'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图10.1](part0025.html#filepos1199475) 如果一个类型建立了自己的依赖（顶部），用户无法影响它们。如果一个类型的依赖在构建过程中传递（底部），用户可以选择最适合其用例的实现。'
- en: 'Turning back to modules, `requires` directives are much like the code in [listing
    10.1](part0025.html#filepos1195355), just on a different level of abstraction:'
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 回到模块，`requires`指令与[列表10.1](part0025.html#filepos1195355)中的代码类似，只是在不同的抽象级别上：
- en: Modules depend on other concrete modules.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块依赖于其他具体模块。
- en: There is no way for the user to exchange dependencies.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户无法交换依赖项。
- en: There is no way to invert the direction of dependencies.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法反转依赖项的方向。
- en: Fortunately, the module system doesn’t leave it at that. It offers services,
    a way for modules to express that they depend on an abstract type or provide a
    concrete type that fulfills such a dependency, with the module system in the middle,
    negotiating between them. (If you’re now thinking about the service locator pattern,
    you’re spot on!) As you’ll see, services don’t perfectly solve all the mentioned
    issues, but they go a long way. [Figure 10.4](part0025.html#filepos1211579) shows
    two types of dependencies.
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 幸运的是，模块系统并没有止步于此。它提供了服务，这是一种模块表达它们依赖于抽象类型或提供满足此类依赖的具体类型的方式，模块系统在其中居中协调。（如果您现在正在考虑服务定位器模式，您完全正确！）正如您将看到的，服务并不完美地解决所有提到的问题，但它们已经走了很长的路。[图10.4](part0025.html#filepos1211579)展示了两种类型的依赖。
- en: '![](../images/00002.jpeg)'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00002.jpeg)'
- en: Figure 10.2 If a module requires another (top), the dependency is fixed; it
    can’t be changed from the outside. On the other hand, if a module uses a service
    (bottom), the concrete implementation is chosen at run time.
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图10.2 如果一个模块需要另一个（顶部），则依赖项是固定的；它不能从外部更改。另一方面，如果一个模块使用服务（底部），则具体的实现是在运行时选择的。
- en: 10.2 Services in the Java Platform Module System
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.2 Java平台模块系统中的服务
- en: When we talk about a service in the context of the JPMS, it comes down to a
    specific type, usually an interface, that we want to use, but for which we don’t
    instantiate implementations. Instead, the module system pulls in implementations
    from other modules that said they would provide them and instantiates those implementations.
    This section shows in detail how that process works so you know what to put into
    module descriptors and how to get instances at run time as well as how that impacts
    module resolutions).
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我们在JPMS的上下文中谈论一个服务时，它通常指的是我们想要使用的一个特定类型，通常是一个接口，但我们不实例化其实现。相反，模块系统会从其他模块中拉入它们提供的实现，并实例化这些实现。本节详细展示了这一过程，以便您知道应该将什么放入模块描述符中，以及如何在运行时获取实例，以及这对模块解析有何影响）。
- en: 10.2.1 USING, PROVIDING, AND CONSUMING SERVICES
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.2.1 使用、提供和消费服务
- en: 'A service is an accessible type that one module wants to use and another module
    provides an instance of:'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 服务是一个可访问的类型，一个模块想要使用，而另一个模块提供其实例：
- en: The module consuming the service expresses its requirement with a `uses ${service}`directive
    in its module descriptor, where `${service}` is the fully qualified name of the
    service type.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费服务的模块使用其模块描述符中的`uses ${service}`指令来表达其需求，其中`${service}`是服务类型的完全限定名。
- en: 'The module providing the service expresses its offer with a `provides ${service}
    with ${provider}`directive, where `${service}` is the same type as in the `uses`
    directive and `${provider}` the fully qualified name of another class, which is
    one or the other of the following:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供服务的模块使用`provides ${service} with ${provider}`指令来表达其提供，其中`${service}`与`uses`指令中的类型相同，而`${provider}`是另一个类的完全限定名，该类是以下之一：
- en: A concrete class that extends or implements `${service}` and has a public, parameterless
    constructor (called a provider constructor)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个扩展或实现`${service}`的具体系列，并且有一个公共、无参数的构造函数（称为提供者构造函数）
- en: An arbitrary type with a public, static, parameterless method `provide` that
    returns a type that extends or implements `${service}` (called a provider method)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有公共、静态、无参数方法`provide`的任意类型，该方法返回一个扩展或实现`${service}`的类型（称为提供者方法）
- en: At run time, the depending module can use the `ServiceLoader` class to get all
    provided implementations of a service by calling `ServiceLoader.load(${service}.class)`.
    The module system then returns a `Provider<${service}>` for each provider any
    module in the module graph declares. [Figure 10.3](part0025.html#filepos1207149)
    illustrates implementing a `Provider`.
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在运行时，依赖模块可以使用`ServiceLoader`类通过调用`ServiceLoader.load(${service}.class)`来获取服务的所有提供实现。然后，模块系统为模块图中声明的每个提供者返回一个`Provider<${service}>`。[图10.3](part0025.html#filepos1207149)说明了实现`Provider`的方法。
- en: '![](../images/00084.jpeg)'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00084.jpeg)'
- en: '[Figure 10.3](part0025.html#filepos1206703) At the center of using services
    is a specific type, here called `Service`. The class `Provider` implements it,
    and the module containing it declares that with a `provides — with` directive.
    Modules consuming services need to declare that with a `uses` directive. At run
    time, they can then use the `ServiceLoader` to get instances of all providers
    for a given service.'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图10.3](part0025.html#filepos1206703) 使用服务的核心是一个特定的类型，这里称为`Service`。`Provider`类实现了它，包含它的模块通过`provides
    — with`指令声明了这一点。需要使用服务的模块需要通过`uses`指令声明。在运行时，它们可以使用`ServiceLoader`来获取给定服务的所有提供者的实例。'
- en: There are a lot of details to consider around services; but generally speaking,
    they’re a good abstraction and straightforward to use in practice, so let’s start
    with that. Settle in; going through the motions takes longer than typing out a
    `requires` or `exports` directive.
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在服务周围有很多细节需要考虑；但一般来说，它们是一个很好的抽象，并且在实践中使用起来很直接，所以让我们从这里开始。请坐好；走流程比输入`requires`或`exports`指令要花的时间长。
- en: 'The ServiceMonitor application provides a perfect example for a good use of
    services. The `Monitor` class from the monitormodule needs a `List<ServiceObserver>`
    to contact the services it’s supposed to monitor. So far, `Main` has done this
    as follows:'
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ServiceMonitor应用程序提供了一个很好的服务使用示例。来自`monitormodule`的`Monitor`类需要一个`List<ServiceObserver>`来联系它应该监控的服务。到目前为止，`Main`是这样做的：
- en: '`private static Optional<ServiceObserver> createObserver(String serviceName)
    { return AlphaServiceObserver.createIfAlphaService(serviceName) .or(() -> BetaServiceObserver.createIfBetaService(serviceName));
    }`'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`private static Optional<ServiceObserver> createObserver(String serviceName)
    { return AlphaServiceObserver.createIfAlphaService(serviceName) .or(() -> BetaServiceObserver.createIfBetaService(serviceName));
    }`'
- en: It isn’t overly important how exactly the code works. What’s relevant is that
    it uses the concrete types `AlphaServiceObserver` from monitor.observer.alpha
    and `BetaServiceObserver` from monitor.observer.beta. Hence monitor needs to depend
    on those modules, and they need to export the corresponding packages—[figure 10.4](part0025.html#filepos1211579)
    shows the matching section of the module graph.
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 代码的具体工作原理并不是特别重要。重要的是它使用了来自`monitor.observer.alpha`的具体系列类型`AlphaServiceObserver`和来自`monitor.observer.beta`的`BetaServiceObserver`。因此，monitor需要依赖于这些模块，并且它们需要导出相应的包——[图10.4](part0025.html#filepos1211579)显示了模块图中匹配的部分。
- en: '![](../images/00004.jpeg)'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00004.jpeg)'
- en: '[Figure 10.4](part0025.html#filepos1201857) Without services, the monitor module
    needs to depend on all other involved modules: observer, alpha, and beta, as shown
    in this partial module graph.'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图10.4](part0025.html#filepos1201857) 没有服务的情况下，monitor模块需要依赖于所有其他涉及的模块：observer、alpha和beta，如图中部分模块图所示。'
- en: 'Now let’s turn this into services. First, the module creating those observers
    needs to declare that it plans to use a service. Start by using `ServiceObserver`
    for that, so monitor''s module declaration looks like this:'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，让我们将其转换为服务。首先，创建这些观察者的模块需要声明它打算使用一个服务。首先使用`ServiceObserver`，所以monitor的模块声明看起来像这样：
- en: '`module monitor { // [... truncated requires directives ...] // removed dependencies
    on monitor.observer.alpha and beta - yay! uses monitor.observer.ServiceObserver;
    }`'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor { // [...省略的requires指令...] // 移除了对monitor.observer.alpha和beta的依赖
    - 好耶！使用monitor.observer.ServiceObserver; }`'
- en: 'The second step is to declare the `provides` directives in the provider modules
    monitor.observer.alpha and monitor.observer.beta:'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第二步是在提供者模块monitor.observer.alpha和monitor.observer.beta中声明`provides`指令：
- en: '`module monitor.observer.alpha { requires monitor.observer; // removed export
    of monitor.observer.alpha - yay! provides monitor.observer.ServiceObserver with
    monitor.observer.alpha.AlphaServiceObserver; }`'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.observer.alpha { requires monitor.observer; // 移除了monitor.observer.alpha的导出
    - 好耶！提供monitor.observer.ServiceObserver，使用monitor.observer.alpha.AlphaServiceObserver;
    }`'
- en: 'This doesn’t work, though—the compiler throws an error:'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然这样不行——编译器抛出了一个错误：
- en: '`> The service implementation does not have > a public default constructor:
    > AlphaServiceObserver`'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 服务实现没有 > 公共默认构造函数： > AlphaServiceObserver`'
- en: Provider constructors and provider methods need to be parameterless, but `AlphaServiceObserver`
    expects the URL of the service it’s supposed to observe. What to do? You could
    set the URL after creation, but that would make the class mutable, and raises
    the question of what to do if the service isn’t alpha. No, it’s cleaner to create
    a factory for observers that returns an instance only if the URL is correct and
    make that factory the service.
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 提供者构造函数和提供者方法需要是无参数的，但`AlphaServiceObserver`期望观察的服务URL。怎么办？你可以在创建后设置URL，但这会使类可变，并引发如果服务不是alpha时应该怎么办的问题。不，创建一个观察者工厂更干净，该工厂仅在URL正确时返回一个实例，并将该工厂作为服务。
- en: So, create a new interface, `ServiceObserverFactory`, in monitor.observer. It
    has a single method, `createIfMatchingService`, that expects the service URL and
    returns an `Optional<ServiceObserver>`. In monitor.observer.alpha and monitor.observer.beta,
    create implementations that do what the static factory methods on `AlphaServiceObserver`
    and `BetaServiceObserver` used to do. [Figure 10.5](part0025.html#filepos1217053)
    shows the corresponding portion of the module graph.
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，在monitor.observer中创建一个新的接口，`ServiceObserverFactory`。它有一个单独的方法，`createIfMatchingService`，该方法期望服务URL并返回一个`Optional<ServiceObserver>`。在monitor.observer.alpha和monitor.observer.beta中，创建实现，这些实现与`AlphaServiceObserver`和`BetaServiceObserver`上的静态工厂方法曾经执行的操作相同。[图10.5](part0025.html#filepos1217053)显示了模块图的相应部分。
- en: '![](../images/00065.jpeg)'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00065.jpeg)'
- en: '[Figure 10.5](part0025.html#filepos1216689) With services, monitor only depends
    on the module defining the service: observer. The providing modules, alpha and
    beta, are no longer directly required.'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图10.5](part0025.html#filepos1216689) 使用服务，监控器只依赖于定义服务的模块：observer。提供模块alpha和beta不再直接需要。'
- en: With those classes, you can provide and consume the `ServiceObserverFactory`
    as a service. The following listing shows the module declarations for monitor,
    monitor.observer, monitor.observer.alpha, and monitor.observer.beta.
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用这些类，你可以作为服务提供和消耗`ServiceObserverFactory`。以下列表显示了monitor、monitor.observer、monitor.observer.alpha和monitor.observer.beta的模块声明。
- en: Listing 10.3 Four modules that work with `ServiceObserverFactory`
  id: totrans-72
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表10.3 与`ServiceObserverFactory`一起工作的四个模块
- en: '`module monitor {` `requires monitor.observer;` [`①`](part0025.html#filepos1220950)
    `// [... truncated other requires directives ...]` `uses monitor.observer.ServiceObserverFactory;`
    [`②`](part0025.html#filepos1221412) `}` `module monitor.observer {` [`③`](part0025.html#filepos1221799)
    `exports monitor.observer; }  module monitor.observer.alpha {` `requires monitor.observer;`
    [`④`](part0025.html#filepos1222300) `provides monitor.observer.ServiceObserverFactory`
    `with monitor.observer.alpha.AlphaServiceObserverFactory;` [`⑤`](part0025.html#filepos1222732)
    `}  module monitor.observer.beta { requires monitor.observer; provides monitor.observer.ServiceObserverFactory
    with monitor.observer.beta.BetaServiceObserverFactory; }`'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor {` `requires monitor.observer;` [`①`](part0025.html#filepos1220950)
    `// [... truncated other requires directives ...]` `uses monitor.observer.ServiceObserverFactory;`
    [`②`](part0025.html#filepos1221412) `}` `module monitor.observer {` [`③`](part0025.html#filepos1221799)
    `exports monitor.observer; }  module monitor.observer.alpha {` `requires monitor.observer;`
    [`④`](part0025.html#filepos1222300) `provides monitor.observer.ServiceObserverFactory`
    `with monitor.observer.alpha.AlphaServiceObserverFactory;` [`⑤`](part0025.html#filepos1222732)
    `}  module monitor.observer.beta { requires monitor.observer; provides monitor.observer.ServiceObserverFactory
    with monitor.observer.beta.BetaServiceObserverFactory; }`'
- en: ①
  id: totrans-74
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: The consuming module monitor requires monitor.observer because it contains ServiceObserverFactory.
    Thanks to services, it requires neither alpha nor beta.
  id: totrans-75
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 消耗模块监控器需要monitor.observer，因为它包含ServiceObserverFactory。多亏了服务，它不需要alpha或beta。
- en: ②
  id: totrans-76
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: The consuming module monitor uses the service interface ServiceObserverFactory.
  id: totrans-77
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 消耗模块监控器使用服务接口ServiceObserverFactory。
- en: ③
  id: totrans-78
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: 'Nothing changed for monitor.observer: it’s unaware that it’s used as a service.
    All that’s needed is the usual export of the package containing ServiceObserver
    and ServiceObserverFactory.'
  id: totrans-79
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: monitor.observer没有变化：它不知道它被用作服务。所需的一切只是包含ServiceObserver和ServiceObserverFactory的包的常规导出。
- en: ④
  id: totrans-80
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ④
- en: Both provider modules require monitor.observer because they implement the interfaces
    it contains—services changed nothing.
  id: totrans-81
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 两个提供模块都需要monitor.observer，因为它们实现了它包含的接口——服务没有改变什么。
- en: ⑤
  id: totrans-82
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⑤
- en: Each provider module provides the service ServiceObserverFactory with its concrete
    class.
  id: totrans-83
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个提供模块都向服务ServiceObserverFactory提供其具体类。
- en: 'The final step is to get the observer factories in monitor. To that end, call
    `ServiceLoader.load(ServiceObserverFactory.class)`, stream over the returned providers,
    and get the service implementations:'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后一步是在监控器中获取观察器工厂。为此，调用`ServiceLoader.load(ServiceObserverFactory.class)`，对返回的提供者进行流处理，并获取服务实现：
- en: '`List<ServiceObserverFactory> observerFactories = ServiceLoader .load(ServiceObserverFactory.class).stream()`
    `.map(Provider::get)` [`①`](part0025.html#filepos1224103) `.collect(toList());`'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`List<ServiceObserverFactory> observerFactories = ServiceLoader .load(ServiceObserverFactory.class).stream()`
    `.map(Provider::get)` [`①`](part0025.html#filepos1224103) `.collect(toList());`'
- en: ①
  id: totrans-86
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Provider::get instantiates a provider (see section 10.4.2).
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Provider::get`实例化一个提供者（参见第10.4.2节）。'
- en: 'And there you go: you have a bunch of service providers, and neither the consuming
    nor the providing modules know each other. Their only connection is that all have
    a dependency on the API module.'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在你有了服务提供者，消费模块和提供模块都不知道对方。它们之间唯一的联系是它们都依赖于API模块。
- en: 'The platform modules also declare and use a lot of services. A particularly
    interesting one is `java.sql.Driver`, declared and used by java.sql:'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 平台模块也声明并使用了大量服务。其中一个特别有趣的是`java.sql.Driver`，由java.sql声明和使用：
- en: '`$ java --describe-module java.sql  > java.sql # truncated exports # truncated
    requires > uses java.sql.Driver`'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --describe-module java.sql  > java.sql # truncated exports # truncated
    requires > uses java.sql.Driver`'
- en: This way, java.sql can access all `Driver` implementations provided by other
    modules.
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这样，java.sql就可以访问其他模块提供的所有`Driver`实现。
- en: Another exemplary use of services in the platform is `java.lang.System.LoggerFinder`.
    This is part of a new API added in Java 9 and allows users to pipe the JDK’s log
    messages (not the JVM’s!) into the logging framework of their choice (say, Log4J
    or Logback). Instead of writing to standard out, the JDK uses `LoggerFinder` to
    create `Logger` instances and then logs all messages with them.
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 平台中服务的另一个典型用途是`java.lang.System.LoggerFinder`。这是Java 9中添加的新API的一部分，允许用户将JDK的日志消息（不是JVM的！）导入他们选择的日志框架（例如，Log4J或Logback）。而不是写入标准输出，JDK使用`LoggerFinder`来创建`Logger`实例，然后使用它们记录所有消息。
- en: 'For Java 9 and later, logging frameworks can implement factories for loggers
    that use the framework’s infrastructure:'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于Java 9及以后的版本，日志框架可以实现使用框架基础设施的日志记录器工厂：
- en: '`public class ForesterFinder extends LoggerFinder {` [`①`](part0025.html#filepos1227398)
    `@Override public Logger getLogger(String name, Module module) { return new Forester(name,
    module); }  }`'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public class ForesterFinder extends LoggerFinder {` [`①`](part0025.html#filepos1227398)
    `@Override public Logger getLogger(String name, Module module) { return new Forester(name,
    module); }  }`'
- en: ①
  id: totrans-95
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Belongs to the fictitious Forester logging framework
  id: totrans-96
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 属于虚构的Forester日志框架
- en: 'But how can logging frameworks inform java.base of their `LoggerFinder` implementation?
    Easy: they provide the `LoggerFinder` service with their own implementation:'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但日志框架如何通知java.base它们的`LoggerFinder`实现呢？很简单：它们提供自己的实现来提供`LoggerFinder`服务：
- en: '`module org.forester { provides java.lang.System.LoggerFinder with org.forester.ForesterFinder;
    }`'
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module org.forester { provides java.lang.System.LoggerFinder with org.forester.ForesterFinder;
    }`'
- en: This works because the base module uses `LoggerFinder` and then calls the `ServiceLoader`
    to locate `LoggerFinder` implementations. It gets a framework-specific finder,
    asks it to create `Logger` implementations, and then uses them to log messages.
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为基础模块使用了`LoggerFinder`，然后调用`ServiceLoader`来定位`LoggerFinder`的实现。它获取一个框架特定的查找器，要求它创建`Logger`实现，然后使用它们来记录消息。
- en: This should give you a good idea of how to create and use services. On to the
    details!
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这应该能给你一个如何创建和使用服务的良好概念。接下来是细节！
- en: 10.2.2 MODULE RESOLUTION FOR SERVICES
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.2.2 服务模块解析
- en: If you’ve ever started a simple modular application and observed what the module
    system is doing (for example, with `--show-module-resolution`, as explained in
    section 5.3.6), you may have been surprised by the number of platform modules
    that are resolved. With a simple application like ServiceMonitor, the only platform
    modules should be java.base and maybe one or two more, so why are there so many
    others? Services are the answer.
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你曾经启动了一个简单的模块化应用程序并观察模块系统正在做什么（例如，使用`--show-module-resolution`，如第5.3.6节所述），你可能会对解析的平台模块数量感到惊讶。对于像ServiceMonitor这样的简单应用程序，唯一的平台模块应该是java.base以及可能的一个或两个更多，那么为什么有这么多其他模块呢？服务就是答案。
- en: ESSENTIAL INFO Remember from section 3.4.3 that only modules that make it into
    the graph during module resolution are available at run time. To make sure that’s
    the case for all observable providers of a service, the resolution process takes
    into account `uses` and `provides` directives. Beyond the resolution behavior
    described in section 3.4.1, once it resolves a module consuming a service, it
    adds all observable modules to the graph that provides that service. This is called
    binding.
  id: totrans-103
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**基本信息** 记住从3.4.3节中提到的，只有那些在模块解析过程中进入图的模块在运行时才是可用的。为了确保所有可观察的服务提供者都符合这一条件，解析过程会考虑`uses`和`provides`指令。除了3.4.1节中描述的解析行为之外，一旦解析了一个消耗服务的模块（例如monitor或java.base），它就会将提供该服务的所有可观察模块添加到图中。这被称为绑定。'
- en: 'Launching ServiceMonitor with `--show-module-resolution` shows a lot of service
    bindings:'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用`--show-module-resolution`选项启动ServiceMonitor会显示许多服务绑定：
- en: '`$ java --show-module-resolution --module-path mods:libs --module monitor  >
    root monitor > monitor requires monitor.observer # truncated many resolutions
    > monitor binds monitor.observer.beta > monitor binds monitor.observer.alpha >
    java.base binds jdk.charsets jrt:/jdk.charsets > java.base binds jdk.localedata
    jrt:/jdk.localedata # truncated lots of more bindings for java.base # truncated
    rest of resolution`'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --show-module-resolution --module-path mods:libs --module monitor  >
    root monitor > monitor requires monitor.observer # truncated many resolutions
    > monitor binds monitor.observer.beta > monitor binds monitor.observer.alpha >
    java.base binds jdk.charsets jrt:/jdk.charsets > java.base binds jdk.localedata
    jrt:/jdk.localedata # truncated lots of more bindings for java.base # truncated
    rest of resolution`'
- en: The module monitor binds the modules monitor.observer.alpha and monitor.observer.beta
    even though it doesn’t depend on either of them. The same happens to jdk.charsets,
    jdk.localedata, and many more due to java.base and other platform modules. [Figure
    10.6](part0025.html#filepos1233675) shows the module graph.
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块monitor绑定了monitor.observer.alpha和monitor.observer.beta模块，即使它不依赖于它们中的任何一个。类似的情况也发生在jdk.charsets、jdk.localedata和其他许多模块上，这是由于java.base和其他平台模块导致的。[图10.6](part0025.html#filepos1233675)显示了模块图。
- en: '![](../images/00085.jpeg)'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00085.jpeg)'
- en: '[Figure 10.6](part0025.html#filepos1233340) Service binding is part of module
    resolution: Once a module is resolved (like monitor or java.base), its `uses`
    directives are analyzed, and all modules that provide matching services (alpha
    and beta as well as charsets and localedata) are added to the module graph.'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图10.6](part0025.html#filepos1233340) 服务绑定是模块解析的一部分：一旦一个模块被解析（如monitor或java.base），就会分析其`uses`指令，并将提供匹配服务的所有模块（包括alpha和beta以及charsets和localedata）添加到模块图中。'
- en: EXCLUDING SERVICES WITH --LIMIT-MODULES
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**使用--LIMIT-MODULES排除服务**'
- en: Services and the `--limit-modules` option have an interesting interaction. As
    section 5.3.5 describes, `--limit-modules` limits the universe of observable modules
    to the specified ones and their transitive dependencies. This doesn’t include
    services! Unless modules providing services are transitively required by the modules
    listed after `--limit-modules`, they aren’t observable and won’t make it into
    the module graph. In that case, calls to `ServiceLoader::load` will often return
    empty-handed.
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 服务和`--limit-modules`选项有有趣的交互。如5.3.5节所述，`--limit-modules`将可观察模块的宇宙限制为指定的模块及其传递依赖。这不包括服务！除非提供服务的模块是`--limit-modules`之后列出的模块的传递依赖，否则它们不可观察，也不会进入模块图。在这种情况下，对`ServiceLoader::load`的调用通常会返回空。
- en: 'If you launch ServiceMonitor as when examining module resolution but limit
    the observable universe to modules depending on monitor, the output is much simpler:'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你以检查模块解析的方式启动ServiceMonitor，但将可观察的宇宙限制为依赖于monitor的模块，输出将更加简单：
- en: '`$ java --show-module-resolution --module-path mods:libs --limit-modules monitor
    --module monitor root monitor # truncated monitor''s transitive dependencies`'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --show-module-resolution --module-path mods:libs --limit-modules monitor
    --module monitor root monitor # truncated monitor''s transitive dependencies`'
- en: 'That’s it: no services—neither observer factories nor the many services platform
    modules usually bind. [Figure 10.7](part0025.html#filepos1237817) shows this simplified
    module graph.'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 就这些：没有服务——既没有观察者工厂，也没有许多平台模块通常绑定的服务。[图10.7](part0025.html#filepos1237817)显示了这个简化的模块图。
- en: '![](../images/00105.jpeg)'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00105.jpeg)'
- en: '[Figure 10.7](part0025.html#filepos1237470) With `--limit-modules monitor`,
    the universe of observable modules is limited to monitor''s transitive dependencies,
    which excludes the service providers resolved in [figure 10.6](part0025.html#filepos1233675).'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图10.7](part0025.html#filepos1237470) 使用`--limit-modules monitor`，可观察模块的宇宙被限制为monitor的传递依赖，这排除了在[图10.6](part0025.html#filepos1233675)中解析的服务提供者。'
- en: 'Particularly powerful is the combination of `--limit-modules` and `--add-modules`:
    the former can be used to exclude all services and the latter to add back the
    desired ones. This allows you to try out different service configurations at launch
    without having to manipulate the module path.'
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 特别强大的是`--limit-modules`和`--add-modules`的组合：前者可以用来排除所有服务，而后者可以用来添加所需的服务。这允许你在启动时尝试不同的服务配置，而无需操作模块路径。
- en: Why are uses directives necessary?
  id: totrans-117
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么需要使用指令？
- en: 'In a small aside, I want to answer a question some developers have about the
    `uses` directive: Why is it necessary? Couldn’t the module system look for providers
    once `ServiceLoader::load` is called?'
  id: totrans-118
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在一个小插曲中，我想回答一些开发者关于`uses`指令的问题：为什么它是必要的？模块系统在调用`ServiceLoader::load`之后不能查找提供者吗？
- en: If modules are properly decoupled via services, there’s a good chance the providing
    modules aren’t transitive dependencies of any root module. Without further efforts,
    service-provider modules routinely wouldn’t make it into the module graph and
    thus wouldn’t be available at run time when a module tries to use a service.
  id: totrans-119
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果模块通过服务正确解耦，那么提供服务的模块很可能不是任何根模块的传递依赖。在不做进一步努力的情况下，服务提供者模块通常会无法进入模块图，因此在模块尝试使用服务时，它们在运行时将不可用。
- en: For services to properly work, provider modules must make it into the module
    graph even if they aren’t transitively required from any root module. But how
    can the module system identify which modules provide services? Does that mean
    all modules that have a `provides` directive? That would be too many. No, only
    providers of needed services should be resolved.
  id: totrans-120
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了服务能够正确工作，提供者模块必须进入模块图，即使它们不是从任何根模块的传递性需求。但模块系统如何识别哪些模块提供服务呢？这意味着所有具有`provides`指令的模块吗？那会太多。不，只有所需服务的提供者应该被解析。
- en: 'This makes it necessary to identify service uses. Analyzing the bytecode that
    calls `ServiceLoader::load` is both slow and unreliable, so a more explicit mechanism
    is required to guarantee efficiency and correctness: `uses` directives. By requiring
    you to declare which services a module uses, the module system can reliably and
    efficiently make all service provider modules available.'
  id: totrans-121
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这使得识别服务使用变得必要。分析调用`ServiceLoader::load`的字节码既慢又不可靠，因此需要一个更明确的机制来保证效率和正确性：`uses`指令。通过要求你声明模块使用哪些服务，模块系统可以可靠且高效地使所有服务提供者模块可用。
- en: 10.3 Designing services well
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.3 设计良好的服务
- en: 'As you saw in section 10.2, services are a play with four actors:'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如你在第10.2节中看到的，服务是四个演员的表演：
- en: Service—In the JPMS, a class or an interface.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务——在JPMS中，一个类或一个接口。
- en: Consumer—Any piece of code that wants to use services.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者——任何想要使用服务的代码片段。
- en: Provider—A concrete implementation of the service.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者——服务的具体实现。
- en: Locator—The puppet master that, triggered by the consumer’s request, locates
    providers and returns them. In Java, this is the `ServiceLoader`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定位器——由消费者的请求触发的总管，定位提供者并返回它们。在Java中，这是`ServiceLoader`。
- en: The `ServiceLoader` is provided by the JDK (we take a closer look at it in section
    10.4), but when you’re creating services, the other three classes are your responsibility.
    Which types do you choose for services (see section 10.3.1), and how do you best
    design them (section 10.3.2)? Isn’t it weird that consumers depend on ugly global
    state (section 10.3.3)? How should the modules containing services, consumers,
    and providers be related to one another (section 10.3.4)? To design well-crafted
    services, you need to be able to answer these questions.
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ServiceLoader`由JDK提供（我们将在第10.4节中更详细地探讨它），但在创建服务时，其他三个类是你的责任。你为服务选择哪些类型（见第10.3.1节），以及如何最佳地设计它们（第10.3.2节）？消费者依赖于丑陋的全局状态（第10.3.3节）不是很奇怪吗？包含服务、消费者和提供者的模块之间应该如何相互关联（第10.3.4节）？为了设计精心制作的服务，你需要能够回答这些问题。'
- en: We’ll also look into using services to break cyclic dependencies between modules
    (section 10.3.5). Last but not least—and this is particularly interesting for
    those who plan to use services on different Java versions—we discuss how services
    work across plain and modular JARs (section 10.3.6).
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们还将探讨使用服务来打破模块之间的循环依赖（第10.3.5节）。最后但同样重要的是——这对计划在不同Java版本上使用服务的开发者来说尤其有趣——我们讨论了服务如何在平面和模块化JAR文件之间工作（第10.3.6节）。
- en: 10.3.1 TYPES THAT CAN BE SERVICES
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.3.1 可作为服务的类型
- en: A service can be a concrete class (even a final one), an abstract class, or
    an interface. Although only enums are excluded, using a concrete class (particularly
    a final one) as a service is unconventional—the entire point is that the module
    is supposed to depend on something abstract. Unless a specific use case requires
    it, a service should always be an abstract class or an interface.
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个服务可以是具体的类（甚至是一个最终类），抽象类，或者接口。尽管排除了枚举，但将具体类（尤其是最终类）用作服务是不寻常的——整个模块的目的是依赖于某种抽象的东西。除非有特定的用例要求，否则服务始终应该是抽象类或接口。
- en: On abstract classes
  id: totrans-132
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于抽象类
- en: 'Personally, I’m not a fan of deep class hierarchies and thus have a natural
    aversion to abstract classes. With Java 8’s ability to implement methods in interfaces,
    a big use case for abstract classes fell away: providing basic implementations
    of interface methods for which a good default behavior exists.'
  id: totrans-133
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 个人来说，我不喜欢深层类层次结构，因此对抽象类有自然的反感。随着Java 8在接口中实现方法的能力，抽象类的一个大用途消失了：为具有良好默认行为的接口方法提供基本实现。
- en: Now I mainly use them as local support (usually package-scoped or inner classes)
    for implementing complex interfaces, but I make a point to not let them seep into
    a public API unless absolutely necessary. In that vein, I’ve never created a service—which
    is necessarily part of a module’s public API—that wasn’t an interface.
  id: totrans-134
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，我主要将它们用作本地支持（通常是包作用域或内部类）以实现复杂接口，但我总是确保除非绝对必要，否则不要让它们渗入公共API。在这方面，我从未创建过服务——这必然是模块公共API的一部分——它不是一个接口。
- en: 10.3.2 USING FACTORIES AS SERVICES
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.3.2 使用工厂作为服务
- en: 'Let’s go back to the first try at refactoring the service observer architecture
    to use JPMS services in section 10.2.1\. That didn’t go well. Using the `ServiceObserver`
    interface as the service and its implementations `AlphaServiceObserver` and `BetaServiceObserver`
    as providers had a number of problems:'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们回到第10.2.1节中尝试重构服务观察者架构以使用JPMS服务的第一次尝试。那并不顺利。将`ServiceObserver`接口作为服务和其实现`AlphaServiceObserver`和`BetaServiceObserver`作为提供者存在一些问题：
- en: Providers need parameterless provider methods or constructors, but the classes
    we wanted to use needed to be initialized with a concrete state that wasn’t meant
    to be mutated.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者需要无参数的提供者方法或构造函数，但我们想要使用的类需要用具体的初始状态初始化，而这个状态并不打算被修改。
- en: It would have been awkward for observer instances, which can handle either the
    alpha or beta API, to decide whether they’re suitable for a specific network service.
    I prefer creating instances in their correct state.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于可以处理alpha或beta API的观察者实例来说，决定它们是否适合特定的网络服务可能会很尴尬。我更喜欢创建处于正确状态的实例。
- en: 'The service loader caches providers (more on that in section 10.4), so depending
    on how you use the API, there may be only one instance per provider: in this case,
    one `AlphaServiceObserver` and one `BetaServiceObserver`.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务加载器缓存提供者（更多内容请参阅第10.4节），因此根据您如何使用API，每个提供者可能只有一个实例：在这种情况下，一个`AlphaServiceObserver`和一个`BetaServiceObserver`。
- en: This made it impractical to directly create the instance we needed, so we used
    a factory instead. As it turns out, that wasn’t a special case.
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这使得直接创建我们需要的实例变得不切实际，所以我们使用了工厂。结果证明，那并不是一个特殊情况。
- en: Whether it’s the URL to connect to or the name of the logger, it’s common for
    a consumer to want to configure the services it uses. The consumer might also
    like to create more than one instance of any specific service provider. Taken
    together with the service loader’s requirement for parameterless construction
    and its freedom to cache instances, this makes it impractical to make the used
    type, `ServiceObserver` or `Logger`, the service.
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不论是连接的URL还是记录器的名称，消费者通常都希望配置他们使用的服务。消费者还可能希望创建任何特定服务提供者的多个实例。结合服务加载器对无参数构造的要求以及其缓存实例的自由，这使得将使用的类型`ServiceObserver`或`Logger`作为服务变得不切实际。
- en: Instead, it’s common to create a factory for the desired type, like `ServiceObserverFactory`
    or `LoggerFinder`, and make it the service. According to the factory pattern,
    factories have the sole responsibility to create instances in the correct state.
    As such, it’s often straightforward to design them so they have no state of their
    own and you don’t particularly care how many of them there are. This makes factories
    a great fit for the peculiarities of the `ServiceLoader`.
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 相反，通常为所需类型创建一个工厂，如`ServiceObserverFactory`或`LoggerFinder`，并将其作为服务。根据工厂模式，工厂的唯一责任是创建处于正确状态的实例。因此，通常可以设计它们使其没有自己的状态，并且你并不特别关心它们的数量。这使得工厂非常适合`ServiceLoader`的特殊性。
- en: 'And they have at least two further bonuses:'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 他们至少有两个额外的优势：
- en: If instantiating the desired type is expensive, having a factory for it as the
    service makes it easiest for consumers to control when instances are created.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果实例化所需类型代价高昂，将其作为服务的一部分拥有一个工厂，使得消费者控制实例创建的时间变得最容易。
- en: If it’s necessary to check whether a provider can handle a certain input or
    configuration, the factory can have a method indicating that. Alternatively, its
    methods can return a type indicating that creating an object wasn’t possible (for
    example, an `Optional`).
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要检查一个提供者是否能够处理某个特定的输入或配置，工厂可以有一个方法来指示这一点。或者，它的方法可以返回一个类型，表示创建对象是不可能的（例如，一个`Optional`）。
- en: I want to show you two examples for selecting services depending on their applicability
    to a certain situation. The first comes from ServiceMonitor, where `ServiceObserverFactory`
    doesn’t have a method `create(String)` returning a `ServiceObserver`, but does
    have a `createIfMatchingService(String)` method returning an `Optional<ServiceObserver>`.
    This way, you can throw any URL at any factory and the return value informs you
    whether it could handle it.
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我想给你展示两个根据其适用性选择服务的例子。第一个来自ServiceMonitor，其中`ServiceObserverFactory`没有返回`ServiceObserver`的`create(String)`方法，但有一个返回`Optional<ServiceObserver>`的`createIfMatchingService(String)`方法。这样，你可以将任何URL投向任何工厂，返回值会告诉你它是否可以处理。
- en: The other example doesn’t use the `ServiceLoader`, but rather uses a similar
    API deep in the JDK, the `ServiceRegistry`. It was created exclusively for Java’s
    ImageIO API, which uses it to locate an `ImageReader` for a given image depending
    on its codec, for example, JPEG or PNG.
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个例子没有使用`ServiceLoader`，而是使用JDK中深层的类似API，即`ServiceRegistry`。它是专门为Java的ImageIO
    API创建的，它使用它来根据图像的编解码器（例如，JPEG或PNG）定位给定的图像的`ImageReader`。
- en: Image IO locates readers by requesting implementations of the abstract class
    `ImageReaderSpi` from the registry, which returns instances of classes like `JPEGImageReaderSpi`
    and `PNGImageReaderSpi`. It then calls `canDecodeInput(Object)` on each `ImageReaderSpi`
    implementation, which returns `true` if the image uses the right codec as indicated
    by the file header. Only when an implementation returns `true` will Image IO call
    `createReaderInstance(Object)` to create an actual reader for the image. [Figure
    10.8](part0025.html#filepos1255922) shows using a factory.
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 图像输入输出（Image IO）通过从注册表中请求抽象类`ImageReaderSpi`的实现来定位读取器，该注册表返回类似`JPEGImageReaderSpi`和`PNGImageReaderSpi`的类实例。然后它对每个`ImageReaderSpi`实现调用`canDecodeInput(Object)`，如果图像使用文件头指示的正确编解码器，则返回`true`。只有当某个实现返回`true`时，Image
    IO才会调用`createReaderInstance(Object)`来创建实际的图像读取器。[图10.8](part0025.html#filepos1255922)展示了使用工厂的方法。
- en: '`ImageReaderSpi` acts as a factory service, where `canDecodeInput` is used
    to select the correct provider and `createReaderInstance` is used to create the
    needed type: an `ImageReader`. As section 10.4.2 shows, there’s an alternative
    approach to selecting a suitable provider.'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ImageReaderSpi`充当一个工厂服务，其中`canDecodeInput`用于选择正确的提供者，`createReaderInstance`用于创建所需的类型：一个`ImageReader`。如第10.4.2节所示，选择合适提供者的另一种方法是。'
- en: In summary, you should routinely consider not picking the type you want to use
    as a service, but instead choosing another type, a factory, that returns instances
    of what you want to use. That factory should require no state of its own to function
    correctly. (This also makes it much easier to implement it in a thread-safe manner
    if that’s relevant for your use case.) See factories as a way to separate the
    original requirements for the type you want to use from the service infrastructure’s
    specific requirements instead of mixing them in one type.
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总结来说，你应该常规性地考虑不要选择你想要使用的类型作为服务，而是选择另一种类型，即工厂，该工厂返回你想要使用的实例。这个工厂在正确配置下运行时不应有自己的状态。（这也使得在需要的情况下以线程安全的方式实现它变得容易得多。）将工厂视为一种方法，将你想要使用的类型的原始需求与服务基础设施的特定需求分开，而不是将它们混合在一个类型中。
- en: '![](../images/00070.jpeg)'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00070.jpeg)'
- en: '[Figure 10.8](part0025.html#filepos1254177) Making the desired type the service
    often doesn’t go well with the JDK’s peculiarities. Instead, consider designing
    a factory that creates instances in the correct configuration, and make it the
    service.'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图10.8](part0025.html#filepos1254177) 将所需类型作为服务通常与JDK的特有性不太相容。相反，考虑设计一个工厂，以正确的配置创建实例，并将其作为服务。'
- en: 10.3.3 ISOLATING CONSUMERS FROM GLOBAL STATE
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.3.3 将消费者与全局状态隔离
- en: 'Code calling `ServiceLoader::load` is inherently hard to test because it depends
    on the global application state: the modules with which the program was launched.
    That can easily become a problem when the module using a service doesn’t depend
    on the module providing it (as should be the case), because then the build tool
    won’t include the providing module in the test’s module path.'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 调用`ServiceLoader::load`的代码本质上是难以测试的，因为它依赖于全局应用程序状态：启动程序时使用的模块。当使用服务的模块不依赖于提供它的模块（应该是这种情况）时，这很容易成为一个问题，因为构建工具不会将提供模块包含在测试模块路径中。
- en: Manually preparing the `ServiceLoader` for a unit test so that it returns a
    specific list of service providers requires some heavy lifting. That’s anathema
    to unit tests, which are supposed to run in isolation and on small units of code.
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了使`ServiceLoader`在单元测试中返回特定的服务提供者列表，需要做一些繁重的工作。这对于单元测试来说是禁忌的，因为单元测试应该在隔离和小的代码单元上运行。
- en: Beyond that, the call to `ServiceLoader::load` doesn’t usually solve any problem
    the application’s user cares about. It’s just a necessary and technical step toward
    such a solution. This puts it on a different level of abstraction than the code
    that uses the received service providers. Friends of the single responsibility
    principle would say such code has two responsibilities (requesting providers and
    implementing a business requirement), which seems to be one too many.
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了这些，对`ServiceLoader::load`的调用通常不会解决应用程序用户关心的任何问题。它只是通向这种解决方案的必要且技术性的步骤。这使得它与使用接收到的服务提供者的代码处于不同的抽象级别。遵循单一责任原则的朋友会说这样的代码有两个责任（请求提供者和实现业务需求），这似乎是太多了。
- en: 'These properties suggest that code handling service loading shouldn’t be mixed
    with code implementing the application’s business requirements. Fortunately, keeping
    them separate isn’t too complicated. Somewhere the instance that ends up using
    the providers is created, and that’s usually a good place to call `ServiceLoader`
    and then pass the providers. ServiceMonitor follows the same structure: it creates
    all instances required to run the app in the `Main` class (including loading`ServiceObserver`
    implementations) and then hands off to `Monitor`, which does the actual work of
    monitoring services.'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些属性表明，处理服务加载的代码不应与实现应用程序业务需求的代码混合。幸运的是，将它们分开并不太复杂。在某个地方创建最终使用提供者的实例，通常这是一个调用`ServiceLoader`并传递提供者的好地方。ServiceMonitor遵循相同的结构：在`Main`类中创建运行应用程序所需的所有实例（包括加载`ServiceObserver`实现），然后将其传递给`Monitor`，它执行实际的服务监控工作。
- en: Listings 10.4 and 10.5 show a comparison. In [listing 10.4](part0025.html#filepos1261741),
    `IntegerStore` does the heavy service lifting itself, which mixes responsibilities.
    This also makes code using `IntegerStore` hard to test, because tests have to
    be aware of the `ServiceLoader` call and then make sure it returns the desired
    integer makers.
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表10.4和10.5显示了比较。在[列表10.4](part0025.html#filepos1261741)中，`IntegerStore`自己执行了繁重的服务操作，这混淆了职责。这也使得使用`IntegerStore`的代码难以测试，因为测试必须知道`ServiceLoader`的调用，并确保它返回所需的整数生成器。
- en: In [listing 10.5](part0025.html#filepos1264669), `IntegerStore` is refactored
    and now expects the code constructing it to deliver a `List<IntegerMaker>`. This
    makes its code focus on the business problem at hand (making integers) and removes
    any dependency on the `ServiceLoader` and thus the global application state. Testing
    it is a breeze. Somebody still has to deal with loading services, but a `create...`
    method that’s called during application setup is a much better place for that.
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在[列表10.5](part0025.html#filepos1264669)中，`IntegerStore`被重构，现在期望构建它的代码传递一个`List<IntegerMaker>`。这使得其代码专注于当前的业务问题（生成整数）并移除了对`ServiceLoader`和全球应用程序状态的任何依赖。测试它变得轻而易举。仍然有人需要处理服务的加载，但一个在应用程序设置期间调用的`create...`方法是一个更好的地方。
- en: Listing 10.4 Hard to test due to too many responsibilities
  id: totrans-160
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表10.4 由于责任过多而难以测试
- en: '`public class Integers {  public static void main(String[] args) { IntegerStore
    store = new IntegerStore(); List<Integer> ints = store.makeIntegers(args[0]);
    System.out.println(ints); }  }  public class IntegerStore {` `public List<Integer>
    makeIntegers(String config) {` [`①`](part0025.html#filepos1263407) `return ServiceLoader`
    `.load(IntegerMaker.class).stream()` [`②`](part0025.html#filepos1263817) `.map(Provider::get)`
    `.map(maker -> maker.make(config))` [`③`](part0025.html#filepos1264180) `.distinct()
    .sorted() .collect(toList()); }  }  public interface IntegerMaker {  int make(String
    config);  }`'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public class Integers {  public static void main(String[] args) { IntegerStore
    store = new IntegerStore(); List<Integer> ints = store.makeIntegers(args[0]);
    System.out.println(ints); }  }  public class IntegerStore {` `public List<Integer>
    makeIntegers(String config) {` [`①`](part0025.html#filepos1263407) `return ServiceLoader`
    `.load(IntegerMaker.class).stream()` [`②`](part0025.html#filepos1263817) `.map(Provider::get)`
    `.map(maker -> maker.make(config))` [`③`](part0025.html#filepos1264180) `.distinct()
    .sorted() .collect(toList()); }  }  public interface IntegerMaker {  int make(String
    config);  }`'
- en: ①
  id: totrans-162
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: The results of this call directly depend on the module path content, which makes
    it hard to unit test.
  id: totrans-163
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此调用的结果直接依赖于模块路径内容，这使得单元测试变得困难。
- en: ②
  id: totrans-164
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Solves the technical requirement to load integer makers
  id: totrans-165
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解决了加载整数制造者的技术要求
- en: ③
  id: totrans-166
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: 'Solves the business problem: making unique integers and sorting them'
  id: totrans-167
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解决了业务问题：生成唯一的整数并对它们进行排序
- en: Listing 10.5 Rewritten to improve its design and testability
  id: totrans-168
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表10.5 重新编写以提高其设计和可测试性
- en: '`public class Integers {  public static void main(String[] args) { IntegerStore
    store = createIntegerStore(); List<Integer> ints = store.makeIntegers(args[0]);
    System.out.println(ints); }  private static IntegerStore createIntegerStore()
    { List<IntegerMaker> makers = ServiceLoader` `.load(IntegerMaker.class).stream()`
    [`①`](part0025.html#filepos1266821) `.map(Provider::get) .collect(toList()); return
    new IntegerStore(makers); }  }  public class IntegerStore {  private final List<IntegerMaker>
    makers;  public IntegerStore(List<IntegerMaker> makers) {` `this.makers = makers;`
    [`②`](part0025.html#filepos1267197) `}` `public List<Integer> makeIntegers(String
    config) {` [`③`](part0025.html#filepos1267589) `return makers.stream() .map(maker
    -> maker.make(config)) .distinct() .sorted() .collect(toList()); }  }  public
    interface IntegerMaker {  int make(String config);  }`'
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public class Integers {  public static void main(String[] args) { IntegerStore
    store = createIntegerStore(); List<Integer> ints = store.makeIntegers(args[0]);
    System.out.println(ints); }  private static IntegerStore createIntegerStore()
    { List<IntegerMaker> makers = ServiceLoader` `.load(IntegerMaker.class).stream()`
    [`①`](part0025.html#filepos1266821) `.map(Provider::get) .collect(toList()); return
    new IntegerStore(makers); }  }  public class IntegerStore {  private final List<IntegerMaker>
    makers;  public IntegerStore(List<IntegerMaker> makers) {` `this.makers = makers;`
    [`②`](part0025.html#filepos1267197) `}` `public List<Integer> makeIntegers(String
    config) {` [`③`](part0025.html#filepos1267589) `return makers.stream() .map(maker
    -> maker.make(config)) .distinct() .sorted() .collect(toList()); }  }  public
    interface IntegerMaker {  int make(String config);  }`'
- en: ①
  id: totrans-170
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Solves the technical requirement to load integer makers during setup
  id: totrans-171
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解决了在设置过程中加载整数制造者的技术要求
- en: ②
  id: totrans-172
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: IntegerStore gets makers during construction and has no dependency on ServiceLoader.
  id: totrans-173
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`IntegerStore`在构造时获取制造者，并且没有依赖`ServiceLoader`。'
- en: ③
  id: totrans-174
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: The makeIntegers method can focus on its business requirement.
  id: totrans-175
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`makeIntegers`方法可以专注于其业务需求。'
- en: Depending on the particular project and requirements, you may have to pass providers
    more than one method or constructor call, wrap it into another object that defers
    loading until the last moment, or configure your dependency-injection framework,
    but it should be doable. And it’s worth the effort—your unit tests and colleagues
    will thank you.
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 根据特定的项目和需求，你可能需要向提供者传递多个方法或构造函数调用，将其包装在另一个延迟加载直到最后一刻的对象中，或者配置你的依赖注入框架，但这应该是可行的。而且这值得努力——你的单元测试和同事们会感谢你。
- en: 10.3.4 ORGANIZING SERVICES, CONSUMERS, AND PROVIDERS INTO MODULES
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.3.4 将服务、消费者和提供者组织成模块
- en: 'With the service’s type, design, and consumption settled, the question emerges:
    how can you organize the service and the other two actors, consumers and providers,
    into modules? Services obviously need to be implemented, and to provide value,
    code in modules other than the one containing the service should be able implement
    the service. That means the service type must be public and in an exported package.'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当服务的类型、设计和消费确定后，问题随之而来：您如何将服务以及其他两个参与者，消费者和提供者，组织到模块中？显然，服务需要实现，并且为了提供价值，包含服务的模块之外的模块中的代码应该能够实现服务。这意味着服务类型必须是公开的，并且位于导出包中。
- en: The consumer doesn’t have to be public or exported and hence may be internal
    to its module. It must access the service’s type, though, so it needs to require
    the module containing the service (the service, not the classes implementing it).
    It isn’t uncommon for the consumer and service to end up in the same module, as
    is the case with java.sql and `Driver` as well as java.base and `LoggerFinder`.
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 消费者不必是公开的或导出的，因此可能位于其模块内部。然而，它必须访问服务类型，因此需要要求包含服务的模块（服务，而不是实现它的类）。消费者和服务最终位于同一模块中并不罕见，例如java.sql和`Driver`以及java.base和`LoggerFinder`。
- en: Finally, we come to providers. Because they implement the service, they have
    to read the module defining it—that much is obvious. The interesting question
    is whether the providing type should become part of the module’s public API beyond
    being named in a `provides` directive.
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，我们来到提供者。因为他们实现了服务，所以他们必须阅读定义它的模块——这一点很明显。有趣的问题是，提供类型是否应该成为模块公共API的一部分，而不仅仅是命名在`provides`指令中。
- en: A service provider must be public, but there’s no technical requirement for
    exporting its package—the service loader is fine with instantiating inaccessible
    classes. Thus, exporting the package containing a provider needlessly enlarges
    a module’s API surface. It also invites consumers to do things they’re not supposed
    to, like casting a service to its real type to access additional features (analogous
    to what happened with `URLClassLoader`; see section 6.2.1). I hence advise you
    to not make service providers accessible.
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 服务提供者必须是公开的，但对其包的导出没有技术要求——服务加载器可以实例化不可访问的类。因此，导出包含提供者的包无谓地扩大了模块的API表面积。它还可能诱使消费者做一些他们不应该做的事情，比如将服务强制转换为其实际类型以访问附加功能（类似于`URLClassLoader`发生的情况；参见第6.2.1节）。因此，我建议您不要使服务提供者可访问。
- en: In summary (see also [figure 10.9](part0025.html#filepos1272303))
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总结（参见[图10.9](part0025.html#filepos1272303)）
- en: Services need to be public and in an exported package.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务必须是公开的，并且位于导出包中。
- en: Consumers can be internal. They need to read the module defining the service
    or may even be part of it.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者可以是内部的。他们需要阅读定义服务的模块，甚至可能是其一部分。
- en: Providers must be public but shouldn’t be in an exported package, to minimize
    misuse and API surface. They need to read the module defining the service.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者必须是公开的，但不应该位于导出包中，以最大限度地减少误用和API表面积。他们需要阅读定义服务的模块。
- en: '![](../images/00106.jpeg)'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00106.jpeg)'
- en: '[Figure 10.9](part0025.html#filepos1271409) Visibility and accessibility requirements
    for consumers, services, and providers'
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图10.9](part0025.html#filepos1271409) 消费者、服务和提供者的可见性和可访问性要求'
- en: NOTE In case you’re wondering, a module can only provide a service with a type
    it owns. The service implementation named in the `provides` directive must be
    in the same module as the declaration.
  id: totrans-188
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：如果您在疑惑，一个模块只能提供它拥有的类型的服务。在`provides`指令中命名的服务实现必须在声明它的同一个模块中。
- en: 10.3.5 USING SERVICES TO BREAK CYCLIC DEPENDENCIES
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.3.5 使用服务来打破循环依赖
- en: When working with a code base that’s split into subprojects, there always comes
    a point where one of them becomes too large and we want to split it into smaller
    projects. Doing so requires some work, but given enough time to disentangle classes,
    we can usually accomplish the goal. Sometimes, though, the code clings together
    so tightly that we can’t find a way to cut it apart.
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当与分割为子项目的代码库一起工作时，总会有一个点，其中一个项目变得太大，我们希望将其分割成更小的项目。这样做需要一些工作，但如果我们有足够的时间解开类，我们通常可以实现目标。有时，尽管如此，代码粘合得如此紧密，以至于我们找不到将其分开的方法。
- en: A common reason is cyclic dependencies between classes. There could be two classes
    importing each other, or a longer cycle involving a number of classes where each
    imports the next. However you ended up with such a cycle, if you’d prefer to have
    some of its constituting classes in one project and some in another, it’s a problem.
    This is true even without the module system, because build tools usually don’t
    like cyclic dependencies either; but the JPMS voices its own strong disagreement.
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个常见的原因是类之间的循环依赖。可能有两个类互相导入，或者是一个涉及多个类的更长的循环，其中每个类都导入下一个类。无论你如何结束这样的循环，如果你希望其中一些构成类在一个项目中，而另一些在另一个项目中，那么这是一个问题。即使没有模块系统，这也是正确的，因为构建工具通常也不喜欢循环依赖；但JPMS表达了自己的强烈反对。
- en: NOTE Due to the accessibility rules, dependencies between classes that live
    in separate modules require dependencies between those modules (see section 3.3).
    If the class dependencies are circular, so are the module dependencies, and the
    readability rules don’t allow that (see section 3.2).
  id: totrans-192
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：由于可访问性规则，存在于不同模块中的类之间的依赖需要这些模块之间的依赖（参见第3.3节）。如果类依赖是循环的，那么模块依赖也是循环的，可读性规则不允许这样做（参见第3.2节）。
- en: 'What can you do? Because you’re reading the chapter about services, it may
    not surprise you to learn that services can help. The idea is to invert one of
    the dependencies in the cycle by creating a service that lives in the depending
    module. Here’s how to do it, step by step (see also [figure 10.10](part0025.html#filepos1278340)):'
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你能做什么？因为你正在阅读关于服务的章节，你可能不会对了解到服务可以帮助你感到惊讶。想法是通过创建一个存在于依赖模块中的服务来反转循环中的依赖之一。以下是逐步操作的方法（也请参阅[图10.10](part0025.html#filepos1278340)）：
- en: Look at the cycle of module dependencies, and identify which dependency you’d
    like to invert. I’ll call the two involved modules depending (the one that will
    have the `requires` directive) and depended. Ideally, depending uses a single
    type from depended. I’ll focus on that special case—if there are more types, repeat
    the following steps for each of them.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下模块依赖的循环，并确定你想要反转的依赖。我将涉及的两个模块称为依赖（具有`requires`指令的那个）和依赖项。理想情况下，依赖项使用依赖项的单个类型。我将专注于这个特殊情况——如果有更多类型，请为每个类型重复以下步骤。
- en: In depending, create a service type, and extend the module declaration with
    a `uses` directive for that type.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在依赖中，创建一个服务类型，并使用`uses`指令扩展模块声明。
- en: 'In depending, remove the dependency on depended. Take note of the resulting
    compile errors, because depended''s type is no longer accessible. Replace all
    references to it with the service type:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在依赖中，删除对依赖项的依赖。注意由此产生的编译错误，因为依赖项的类型不再可访问。用服务类型替换所有对其的引用：
- en: Update imports and class names.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新导入和类名。
- en: Method calls should require no changes.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法调用不需要任何更改。
- en: 'Constructor calls won’t work out of the box because you need the instances
    from depended. This is where the `ServiceLoader` comes in: use it to replace constructions
    of depended''s type by loading the service type you just created.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数调用不会立即生效，因为你需要依赖项的实例。这就是`ServiceLoader`发挥作用的地方：使用它通过加载你刚刚创建的服务类型来替换依赖项类型的构造。
- en: In depended, add a dependency to depending so the service type becomes accessible.
    Provide that service with the type that originally caused the trouble.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在独立的情况下，向依赖项中添加一个依赖，以便服务类型变得可访问。提供原始导致问题的类型的服务。
- en: '![](../images/00064.jpeg)'
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00064.jpeg)'
- en: '[Figure 10.10](part0025.html#filepos1275266) Using services to break dependency
    cycles in four steps: ❶ Pick a dependency, ❷ introduce a service on the depending
    end, ❸ use that service on the depending end, and ❹ provide the service on the
    depended end.'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图10.10](part0025.html#filepos1275266) 使用服务在四步中打破依赖循环：❶ 选择一个依赖，❷ 在依赖端引入服务，❸
    在依赖端使用该服务，❹ 在依赖项端提供该服务。'
- en: 'Success! You just inverted the dependency between depending and depended (now
    the latter depends on the former) and thus broke the cycle. Here are a few further
    details to keep in mind:'
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 成功！你刚刚反转了依赖项和依赖项之间的依赖（现在后者依赖于前者），从而打破了循环。以下是一些需要记住的进一步细节：
- en: The type in depended that depending used may not be a good candidate for a service.
    If that’s so, consider creating a factory for it, as explained in section 10.3.2,
    or look for another dependency you can replace.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项中依赖项使用的类型可能不是作为服务的好候选。如果是这样，考虑创建一个工厂来处理它，如第10.3.2节所述，或者寻找可以替换的另一个依赖项。
- en: Section 10.3.3 explores the problem with sprinkling `ServiceLoader` calls all
    over a module; that issue applies here. Maybe you need to refactor depending's
    code to minimize the number of loads.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第10.3.3节探讨了在模块中到处撒`ServiceLoader`调用的问题；这个问题也适用于此处。你可能需要重构依赖于模块的代码以最小化加载次数。
- en: The service type doesn’t have to be in depending. As section 10.3.4 explains,
    it can live in any module. Or, rather, in almost any module—you don’t want to
    put it in one that recreates the cycle, for example in depended.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务类型不必依赖于其他模块。正如第10.3.4节解释的那样，它可以存在于任何模块中。或者更确切地说，几乎可以存在于任何模块中——你不想将其放在一个会重新创建循环的模块中，例如在依赖于模块中。
- en: Most important, try to create a service that stands on its own and is more than
    just a cycle breaker. There may be more providers and consumers than just the
    two modules involved so far.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，尝试创建一个独立且不仅仅是作为循环断路器的服务。可能涉及的提供者和消费者不止两个模块。
- en: 10.3.6 DECLARING SERVICES ACROSS DIFFERENT JAVA VERSIONS
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.3.6 在不同JAVA版本间声明服务
- en: Services aren’t new. They were introduced in Java 6, and the mechanisms designed
    back then still work today. It makes sense to look at how they operate without
    modules and particularly how they work across plain and modular JARs.
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 服务并不新鲜。它们是在Java 6中引入的，当时设计的机制至今仍然有效。因此，研究它们在没有模块的情况下如何操作，尤其是它们如何在普通和模块化JAR之间工作，是有意义的。
- en: DECLARING SERVICES IN META-INF/SERVICES
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在`META-INF/SERVICES`中声明服务
- en: Before the module system entered the picture, services worked much the same
    as they do now. The only difference is that there were no module declarations
    to declare that a JAR uses or provides a service. On the using side, that’s fine—all
    code could use every service it wanted. On the providing side, though, JARs had
    to declare their intentions, and they did so in a dedicated directory in the JAR.
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在模块系统出现之前，服务的工作方式与现在几乎相同。唯一的区别是没有模块声明来声明JAR使用或提供服务。在使用方面，这没问题——所有代码都可以使用它想要的任何服务。然而，在提供方面，JAR必须声明其意图，并且它们在JAR中的专用目录中这样做。
- en: 'To have a plain JAR declare a service, follow these simple steps:'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要让一个普通的JAR声明一个服务，请遵循以下简单步骤：
- en: Place a file with the service’s fully qualified name as the filename in `META-INF/services`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包含服务完全限定名称的文件作为文件名放在`META-INF/services`中。
- en: In the file, list all fully qualified names of classes that implement the service.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中列出实现该服务的所有类的完全限定名称。
- en: As an example, let’s create a third `ServiceObserverFactory` provider in the
    newly envisioned plain JAR monitor.observer.zero. To do so, you first need a concrete
    class `ZeroServiceObserverFactory` that implements `ServiceObserverFactory` and
    has a parameterless constructor. That’s analogous to the alpha and beta variants,
    so I don’t need to discuss it in detail.
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，让我们在新的普通JAR monitor.observer.zero中创建第三个`ServiceObserverFactory`提供者。为此，你首先需要一个具体的类`ZeroServiceObserverFactory`，它实现了`ServiceObserverFactory`并具有无参构造函数。这与alpha和beta变体类似，因此我不需要详细讨论。
- en: 'A plain JAR has no module descriptor to declare the services it provides, but
    you can use the `META-INF/services` directory for that: put a simple text file
    `monitor.observer.ServiceObserverFactory` (the fully qualified name of the service
    type) in the directory, with the single line `monitor.observer.zero.ZeroServiceObserverFactory`
    (the fully qualified name of the provider type). [Figure 10.11](part0025.html#filepos1285878)
    shows what that looks like.'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 普通JAR没有模块描述符来声明它提供的服务，但你可以使用`META-INF/services`目录来做到这一点：在该目录中放置一个简单的文本文件`monitor.observer.ServiceObserverFactory`（服务类型的完全限定名称），其中包含单行`monitor.observer.zero.ZeroServiceObserverFactory`（提供者类型的完全限定名称）。[图10.11](part0025.html#filepos1285878)显示了它的样子。
- en: '![](../images/00019.jpeg)'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00019.jpeg)'
- en: '[Figure 10.11](part0025.html#filepos1285538) To declare service providers without
    module declarations, the folder `META-INF/services` needs to contain a plain text
    file with the name of the service and a single line per provider.'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![图10.11](part0025.html#filepos1285538) 要在不进行模块声明的情况下声明服务提供者，文件夹`META-INF/services`需要包含一个包含服务名称和每个提供者单行的纯文本文件。'
- en: I promise you this works, and the `ZeroServiceObserverFactory` is properly resolved
    when `Main` streams all observer factories. But you’ll have to take my word for
    it until we’ve discussed how plain and modular JARs' services interact. That’s
    next.
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我保证这可行，当`Main`流式传输所有观察者工厂时，`ZeroServiceObserverFactory`将得到正确解析。但直到我们讨论了普通和模块化JAR的服务如何交互之前，你只能相信我的话。接下来就是这一点。
- en: NOTE There’s a small difference between declaring services in `META-INF/services`
    and declaring them in module declarations. Only the latter can use provider methods—the
    former need to stick to public, parameterless constructors.
  id: totrans-220
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意** 在`META-INF/services`中声明服务和在模块声明中声明服务之间有一个小的区别。只有后者可以使用提供者方法——前者需要坚持使用公共、无参数的构造函数。'
- en: COMPATIBILITY ACROSS JARS AND PATHS
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**JAR和路径之间的兼容性**'
- en: Because the service loader API was around before the module system arrived in
    Java 9, there are compatibility concerns. Can consumers in plain and modular JARs
    use services the same way? And what happens with providers across different kinds
    of JARs and paths?
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于服务加载器API在Java 9模块系统到来之前就已经存在，因此存在兼容性问题。普通和模块化JAR中的消费者能否以相同的方式使用服务？不同类型的JAR和路径中的提供者会发生什么？
- en: 'For service consumers, the picture is simple: explicit modules can use the
    services they declare with `uses` directives; automatic modules (see section 8.3)
    and the unnamed module (section 8.2) can use all existing services. In summary,
    on the consumer side, it just works.'
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于服务消费者来说，情况很简单：显式模块可以使用它们通过`uses`指令声明的服务；自动模块（见第8.3节）和未命名的模块（第8.2节）可以使用所有现有服务。总之，在消费者端，这很简单。
- en: 'For service providers, it’s a little more complicated. There are two axes with
    two expressions each, leading to four combinations:'
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于服务提供者来说，情况稍微复杂一些。有两个轴，每个轴有两个表达式，导致四种组合：
- en: 'Kind of JAR: plain (service declaration in `META-INF/services`) or modular
    (service declaration in module descriptor)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JAR类型**：普通（在`META-INF/services`中声明服务）或模块化（在模块描述符中声明服务）'
- en: 'Kind of path: class or module'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径类型**：类路径或模块路径'
- en: No matter which path a plain JAR ends up on, the service loader will identify
    and bind services in `META-INF/services`. If the JAR is on the class path, its
    content is already part of the unnamed module. If it’s on the module path, service
    binding results in the creation of an automatic module. This triggers the resolution
    of all other automatic modules, as described in section 8.3.2.
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无论普通JAR最终位于哪个路径上，服务加载器都会在`META-INF/services`中识别和绑定服务。如果JAR位于类路径上，其内容已经是未命名的模块的一部分。如果它位于模块路径上，服务绑定会导致自动模块的创建。这会触发所有其他自动模块的解析，如第8.3.2节所述。
- en: Now you know why you could try out monitor.observer.zero, a plain JAR providing
    its service in `META-INF/services`, with the modularized ServiceMonitor application.
    And it doesn’t matter which path I choose; it works from both without further
    ado.
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在你知道为什么你可以尝试使用monitor.observer.zero，这是一个提供其服务在`META-INF/services`中的普通JAR，与模块化的ServiceMonitor应用程序一起使用。而且，无论我选择哪个路径；它都可以从两个路径上工作，无需进一步操作。
- en: ESSENTIAL INFO Modular JARs on the module path are the sweet spot for services
    in the module system, so they work without limitations. On the class path, modular
    JARs can cause problems, though. They’re treated like plain JARs, so they need
    entries in the `META-INF/services` folder. As a developer whose project relies
    on services and whose modular artifacts are supposed to work on both paths, you
    need to declare services in the module descriptor and`META-INF/services`.
  id: totrans-229
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**必要信息** 模块路径上的模块化JAR是模块系统中服务的最佳选择，因此它们可以无限制地工作。在类路径上，模块化JAR可能会引起问题。它们被当作普通JAR处理，因此需要在`META-INF/services`文件夹中包含条目。作为一个依赖于服务并且其模块化工件应在两个路径上工作的开发者，你需要在模块描述符和`META-INF/services`中声明服务。'
- en: Launching ServiceMonitor from the class path leads to no useful output, because
    no observer factory can be found—unless you add monitor.observer.zero to the mix.
    With its provider definition in `META-INF/services`, it’s well suited to work
    from the unnamed module, and indeed it does—unlike the alpha and beta providers.
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从类路径启动ServiceMonitor会导致没有有用的输出，因为没有找到观察者工厂——除非你将monitor.observer.zero添加到其中。由于它在`META-INF/services`中有提供者定义，它非常适合从未命名的模块中工作，并且确实如此——与alpha和beta提供者不同。
- en: 10.4 Accessing services with the ServiceLoader API
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.4 使用ServiceLoader API访问服务
- en: Despite the fact that the `ServiceLoader` has been around since Java 6, it hasn’t
    seen wide adoption, but I expect that with its prominent integration into the
    module system, its use will increase considerably. To make sure you know your
    way around its API, we explore it in this section.
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管ServiceLoader自Java 6以来就已经存在，但它并没有得到广泛的应用，但我预计随着它显著集成到模块系统中，其使用将会大幅增加。为了确保你熟悉其API，我们将在本节中对其进行探讨。
- en: As usual, the first step is to get to know the basics, which in this case won’t
    take long. The service loader does have some idiosyncrasies, though, and to make
    sure they won’t trip you up, we’ll discuss them too.
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如同往常，第一步是了解基础知识，在这种情况下不会花费太多时间。然而，服务加载器确实有一些特性，为了确保它们不会让你感到困惑，我们也会讨论它们。
- en: 10.4.1 LOADING AND ACCESSING SERVICES
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.4.1 加载和访问服务
- en: 'Using the `ServiceLoader` is always a two-step process:'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用`ServiceLoader`始终是一个两步过程：
- en: Create a `ServiceLoader` instance for the correct service.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为正确的服务创建一个`ServiceLoader`实例。
- en: Use that instance to access service providers.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该实例来访问服务提供商。
- en: Let’s have a quick look at each step so you know the options. Also check [table
    10.1](part0025.html#filepos1294658) for an overview of all the `ServiceLoader`
    methods.
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们快速看一下每个步骤，以便你知道选项。同时查看[表10.1](part0025.html#filepos1294658)以了解所有`ServiceLoader`方法的概述。
- en: Table 10.1 `ServiceLoader` API at a glance
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表10.1 快速查看`ServiceLoader` API
- en: '| Return type   | Method name   | Description   |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 返回类型   | 方法名称   | 描述   |'
- en: '| Methods to create a new service loader for the given type   |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 为给定类型创建新的服务加载器的方法   |'
- en: '| `ServiceLoader<S>`   | `load(Class<S>)`   | Loads providers starting from
    the current thread’s context class loader   |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `ServiceLoader<S>`   | `load(Class<S>)`   | 从当前线程的上下文类加载器开始加载提供商   |'
- en: '| `ServiceLoader<S>`   | `load(Class<S>, ClassLoader)`   | Loads providers
    starting from the specified class loader   |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `ServiceLoader<S>`   | `load(Class<S>, ClassLoader)`   | 从指定的类加载器开始加载提供商   |'
- en: '| `ServiceLoader<S>`   | `load(ModuleLayer, Class<S>)`   | Loads providers
    starting from modules in the given module layer   |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `ServiceLoader<S>`   | `load(ModuleLayer, Class<S>)`   | 从给定的模块层中的模块开始加载提供商   |'
- en: '| `ServiceLoader<S>`   | `loadInstalled(Class<S>)`   | Loads providers from
    the platform class loader   |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `ServiceLoader<S>`   | `loadInstalled(Class<S>)`   | 从平台类加载器加载提供商   |'
- en: '| Methods to access service providers   |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 访问服务提供商的方法   |'
- en: '| `Optional<S>`   | `findFirst()`   | Loads the first available provider   |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `Optional<S>`   | `findFirst()`   | 加载第一个可用的提供商   |'
- en: '| `Iterator<S>`   | `iterator()`   | Returns an iterator to lazily load and
    instantiate available providers   |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `Iterator<S>`   | `iterator()`   | 返回一个用于延迟加载和实例化可用提供商的迭代器   |'
- en: '| `Stream<Provider<S>>`   | `stream()`   | Returns a stream to lazily load
    available providers   |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `Stream<Provider<S>>`   | `stream()`   | 返回一个用于延迟加载可用提供商的流   |'
- en: '| `void`   | `reload()`   | Clears this loader’s provider cache so all providers
    will be reloaded   |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `void`   | `reload()`   | 清除此加载器的提供商缓存，以便所有提供商都将被重新加载   |'
- en: WAYS TO CREATE A SERVICELOADER
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建SERVICELOADER的方法
- en: 'The first step, creating a `ServiceLoader` instance, is covered by its several
    static `load` methods. The simplest one just needs an instance of `Class<S>` for
    the service you want to load (this is called a type token, in this case for type
    `S`):'
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第一步，创建`ServiceLoader`实例，由其几个静态`load`方法处理。最简单的一个只需要你想要加载的服务的`Class<S>`实例（这被称为类型标记，在这种情况下是类型`S`）：
- en: '`ServiceLoader<TheService> loader = ServiceLoader.load(TheService.class);`'
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ServiceLoader<TheService> loader = ServiceLoader.load(TheService.class);`'
- en: You only need the other `load` methods if you’re juggling several class loaders
    or module layers (see section 12.4); that’s not a common case, so I won’t go into
    it. The API docs for the corresponding overloads have you covered.
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只有在你同时处理多个类加载器或模块层时，你才需要其他`load`方法（参见第12.4节）；这不是一个常见的情况，所以我就不深入讨论了。相应重载的API文档已经涵盖了这些内容。
- en: 'One other method gets a service loader: `loadInstalled`. It’s interesting here
    because it has a specific behavior: it ignores the module path and class path
    and only loads services from platform modules, meaning only providers found in
    JDK modules will be returned.'
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个获取服务加载器的方法是`loadInstalled`。在这里它很有趣，因为它有一个特定的行为：它忽略了模块路径和类路径，并且只从平台模块加载服务，这意味着只有JDK模块中找到的提供商将被返回。
- en: ACCESSING SERVICE PROVIDERS
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 访问服务提供商
- en: 'With a `ServiceLoader` instance for the desired service in hand, it’s time
    to start using those providers. There are two and a half methods for doing that:'
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 拥有所需服务的`ServiceLoader`实例后，是时候开始使用这些提供商了。为此有两种半方法：
- en: '`Iterator<S> iterator()` lets you iterate over the instantiated service providers.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterator<S> iterator()` 允许你遍历实例化的服务提供商。'
- en: '`Optional<S> findFirst()` uses `iterator` to return the first provider if any
    were found (this is a convenience method, so I only count it as a half).'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional<S> findFirst()` 使用`iterator`来返回找到的第一个提供商（这是一个便利方法，所以我只将其计为半个方法）。'
- en: '`Stream<Provider<S>> stream()` lets you stream over service providers, which
    are wrapped into a `Provider` instance. (What’s up with that? Section 10.4.2 explains.)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<Provider<S>> stream()`允许你流式处理服务提供者，这些提供者被包装在一个`Provider`实例中。（这是怎么回事？10.4.2节将解释。）'
- en: 'If you have specific laziness/caching needs (see section 10.4.2 for more),
    you may want to keep the `ServiceLoader` instance around. But in most cases that
    isn’t necessary and you can immediately start iterating over or streaming the
    providers:'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你具有特定的惰性/缓存需求（有关更多信息，请参阅10.4.2节），你可能希望保留`ServiceLoader`实例。但在大多数情况下，这并不是必要的，你可以立即开始迭代或流式处理提供者：
- en: '`ServiceLoader .load(TheService.class) .iterator() .forEachRemaining(TheService::doTheServiceThing);`'
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ServiceLoader .load(TheService.class) .iterator() .forEachRemaining(TheService::doTheServiceThing);`'
- en: 'In case you’re wondering about the inconsistency between `iterator` listing
    `S` and `stream` listing `Provider<S>`, it has historic reasons: although `iterator`
    has been around since Java 6, `stream` and `Provider` were only added in Java
    9.'
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想知道`iterator`列出`S`和`stream`列出`Provider<S>`之间不一致的原因，这有历史原因：尽管`iterator`自Java
    6以来就存在，但`stream`和`Provider`是在Java 9中添加的。
- en: One detail that’s obvious when you think about it but still easily overlooked
    is that there may not be a provider for a given service. `Iterator` and `stream`
    may be empty, and `findFirst` may return an empty `Optional`. If you filter by
    capabilities, as described in sections 10.3.2 and 10.4.2, ending with zero suitable
    providers is even more likely.
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个当你思考时很明显但仍然容易忽视的细节是，可能没有给定服务的提供者。`Iterator`和`stream`可能为空，`findFirst`可能返回一个空的`Optional`。如果你按能力过滤，如10.3.2节和10.4.2节所述，最终没有合适的提供者的情况就更加可能了。
- en: Make sure your code either handles that case gracefully and can operate without
    the absent service or fails fast. It’s annoying if an application ignores an easily
    detectable error and keeps running in an undesired and unexpected state.
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 确保你的代码要么优雅地处理这种情况并且可以在没有服务的情况下运行，要么快速失败。如果应用程序忽略了一个容易检测到的错误并继续以不期望和不期望的状态运行，那就很烦人。
- en: 10.4.2 IDIOSYNCRASIES OF LOADING SERVICES
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 10.4.2 加载服务的特性
- en: The `ServiceLoader` API is pretty simple, but don’t be fooled. A few important
    things are going on behind the curtains, and you need to be aware of them when
    using the API for anything beyond a basic "Hello, services!" example. This concerns
    the service loader’s laziness, its concurrency capabilities (or lack thereof),
    and proper error handling. Let’s go through these one by one.
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ServiceLoader` API非常简单，但不要被其表面所迷惑。在幕后发生了一些重要的事情，当使用API进行超出基本“Hello, services!”示例的操作时，你需要了解它们。这涉及到服务加载器的惰性、其并发能力（或缺乏）以及适当的错误处理。让我们逐一探讨这些问题。'
- en: LAZINESS AND PICKING THE RIGHT PROVIDER
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 惰性和选择正确的提供者
- en: The service loader is as lazy as possible. Called on a `ServiceLoader<S>` (where
    `S` is the service type with which `ServiceLoader::load` was called), its `iterator`
    method returns an `Iterator<S>` that finds and instantiates the next provider
    only when `hasNext` or `next` is called.
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 服务加载器尽可能地惰性。当调用`ServiceLoader<S>`（其中`S`是调用`ServiceLoader::load`时的服务类型）时，其`iterator`方法返回一个`Iterator<S>`，只有在调用`hasNext`或`next`时才会查找和实例化下一个提供者。
- en: The `stream` method is even lazier. It returns a `Stream<Provider<S>>` that
    not only lazily finds providers (like `iterator`) but also returns `Provider`
    instances, which further defer service instantiation until their `get` method
    is called. Their `type` method gives access to a `Class<? extends S>` instance
    for their specific provider (meaning the type implementing the service, not the
    type that is the service).
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`stream`方法甚至更加惰性。它返回一个`Stream<Provider<S>>`，不仅像`iterator`一样惰性查找提供者，还返回`Provider`实例，进一步延迟服务实例化直到其`get`方法被调用。它们的`type`方法提供了访问特定提供者的`Class<?
    extends S>`实例的途径（意味着实现服务的类型，而不是服务本身）。'
- en: Accessing the provider’s type is useful to scan annotations without having an
    actual instance of the class. Similar to what we discussed toward the end of section
    10.3.2, this gives you a tool to pick the right service provider for a given configuration
    but without the possible performance impact of instantiating it first. That’s
    if the class is annotated to give you some indication of the provider’s suitability.
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 访问提供者的类型对于在没有实际类实例的情况下扫描注解很有用。类似于我们在10.3.2节末尾讨论的内容，这为你提供了一个工具，可以根据给定的配置选择正确的服务提供者，而无需首先实例化它。如果类被注解以提供对提供者适用性的指示，那就更好了。
- en: 'Continuing the ServiceMonitor example of `ServiceObserver` factories being
    applicable to specific REST service generations, the factories can be annotated
    with `@Alpha` or `@Beta` to indicate the generation they were created for:'
  id: totrans-272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 继续以 `ServiceObserver` 工厂适用于特定REST服务生成为例的 `ServiceMonitor` 示例，这些工厂可以用 `@Alpha`
    或 `@Beta` 注解来表示它们创建的生成：
- en: '`Optional<ServiceObserverFactory> alphaFactory = ServiceLoader .load(ServiceObserverFactory.class).stream()
    .filter(provider -> provider.type().isAnnotationPresent(Alpha.class)) .map(Provider::get)
    .findFirst();`'
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Optional<ServiceObserverFactory> alphaFactory = ServiceLoader .load(ServiceObserverFactory.class).stream()
    .filter(provider -> provider.type().isAnnotationPresent(Alpha.class)) .map(Provider::get)
    .findFirst();`'
- en: Here, `Provider::type` is used to access `Class<? extends ServiceObserver>`,
    which you then ask with `isAnnotationPresent` whether it was annotated with `@Alpha`.
    Only when `Provider::get` is called is a factory instantiated.
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这里，使用 `Provider::type` 来访问 `Class<? extends ServiceObserver>`，然后使用 `isAnnotationPresent`
    检查它是否被 `@Alpha` 注解。只有在调用 `Provider::get` 时才会实例化工厂。
- en: To top off the laziness, a `ServiceLoader` instance caches the providers loaded
    so far and always returns the same ones. It does have a `reload` method, though,
    which empties the cache and will trigger new instantiations on the next call to
    `iterate`, `stream`, or `findFirst`.
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了进一步体现懒加载，`ServiceLoader` 实例会缓存已加载的提供者，并始终返回相同的实例。尽管如此，它确实有一个 `reload` 方法，该方法会清空缓存，并在下一次调用
    `iterate`、`stream` 或 `findFirst` 时触发新的实例化。
- en: USING CONCURRENT SERVICELOADERS
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用并发 `ServiceLoader`
- en: '`ServiceLoader` instances aren’t thread-safe. If several threads need to operate
    concurrently on a set of service providers, either each of them needs to make
    the same `ServiceLoader::load` call, thus getting its own `ServiceLoader` instance,
    or you must make one call for all of them and store the results in a thread-safe
    collection.'
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ServiceLoader` 实例不是线程安全的。如果多个线程需要同时操作一组服务提供者，则每个线程都需要进行相同的 `ServiceLoader::load`
    调用，从而获得自己的 `ServiceLoader` 实例，或者您必须为它们中的每一个都进行一次调用，并将结果存储在线程安全的集合中。'
- en: HANDLING ERRORS WHEN LOADING SERVICES
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 加载服务时处理错误
- en: 'All kinds of things can go wrong when the `ServiceLoader` tries to locate or
    instantiate service providers:'
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当 `ServiceLoader` 尝试定位或实例化服务提供者时，可能会出现各种问题：
- en: A provider may not fulfill all requirements. Maybe it doesn’t implement the
    service type or doesn’t have a suitable provider method or constructor.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者可能无法满足所有要求。也许它没有实现服务类型，或者没有合适的提供者方法或构造函数。
- en: A provider constructor or method can throw an exception or (in case of a method)
    return `null`.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者的构造函数或方法可以抛出异常，或者（在方法的情况下）返回 `null`。
- en: A file in `META-INF/services` may violate the required format or not be processed
    for other reasons.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`META-INF/services` 目录中的文件可能违反所需格式，或者由于其他原因无法处理。'
- en: And those are just the obvious problems.
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些只是显而易见的问题。
- en: Because loading is done lazily, `load` can’t throw any exception. Instead, the
    iterator’s `hasNext` and `next` methods, as well as the stream processing and
    the `Provider` methods, can throw errors. These will all be of type `ServiceConfigurationError`,
    so catching that error lets you handle all problems that can occur.
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于加载是懒加载的，`load` 方法不能抛出任何异常。相反，迭代器的 `hasNext` 和 `next` 方法，以及流处理和 `Provider`
    方法都可以抛出错误。这些错误都将属于 `ServiceConfigurationError` 类型，因此捕获该错误可以让您处理可能发生的所有问题。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: 'The service architecture is made up of four parts:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务架构由四个部分组成：
- en: The service is a class or an interface.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务是一个类或一个接口。
- en: The provider is a concrete implementation of the service.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供者是对服务的具体实现。
- en: The consumer is any piece of code that wants to use a service.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者是指任何想要使用服务的代码片段。
- en: The `ServiceLoader` creates and returns an instance of each provider of a given
    service to consumers.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServiceLoader` 为消费者创建并返回给定服务的每个提供者的实例。'
- en: 'Requirements and recommendations for the service type are as follows:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务类型的要求数据和建议如下：
- en: Any class or interface can be a service, but because the goal is to provide
    maximum flexibility to consumers and providers, it’s recommended to use interfaces
    (or, at the least, abstract classes).
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何类或接口都可以是服务，但由于目标是向消费者和提供者提供最大灵活性，建议使用接口（或者至少是抽象类）。
- en: Service types need to be public and in an exported package. This makes them
    part of their module’s public API, and they should be designed and maintained
    appropriately.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务类型需要是公开的，并且位于导出包中。这使得它们成为其模块的公共API的一部分，并且应该适当地设计和维护。
- en: The declaration of the module defining a service contains no entry to mark a
    type as a service. A type becomes a service by consumers and providers using it
    as one.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义服务的模块的声明中不包含标记类型为服务的入口。一个类型通过消费者和提供者将其用作服务而成为服务。
- en: Services rarely emerge randomly, but are specifically designed for their purpose.
    Always consider making the used type not the service but a factory for it. This
    makes it easier to search for a suitable implementation as well as to control
    when instances are created and in which state.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务很少是随机出现的，而是专门为特定目的而设计的。始终考虑将使用的类型不是服务本身，而是它的工厂。这使搜索合适的实现更加容易，同时也更容易控制实例的创建时间和状态。
- en: 'Requirements and recommendations for providers are as follows:'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对提供者的要求和推荐如下：
- en: Modules providing services need to access the service type, so they must require
    the module containing it.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供服务的模块需要访问服务类型，因此它们必须要求包含它的模块。
- en: 'There are two ways to create a service provider: a concrete class that implements
    the service type and has a provider constructor (a public, parameterless constructor),
    or a type with a provider method (a public, static, parameterless method called
    `provide`) that returns an instance implementing the service type. Either way,
    the type must be public, but there’s no need to export the package containing
    it. On the contrary, it’s advisable not to make the providing type part of a module’s
    public API.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建服务提供者有两种方式：一个实现了服务类型并具有提供者构造函数（一个公共的无参数构造函数）的具体类，或者一个具有提供者方法（一个公共的静态无参数方法，称为`provide`）的类型，该方法返回实现服务类型的实例。无论哪种方式，类型必须是公共的，但不需要导出包含它的包。相反，建议不要将提供者类型作为模块的公共API的一部分。
- en: Modules providing services declare that by adding a `provides ${service} with
    ${provider}` directive to their descriptor.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供服务的模块会在其描述符中声明通过添加`provides ${service} with ${provider}`指令。
- en: If a modular JAR is supposed to provide services even if placed on the class
    path, it also needs entries in the `META-INF/services` directory. For each `provides
    ${service} with ${provider}` directive, create a plain file called ${service}
    that contains one line per `${provider}` (all names must be fully qualified).
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个模块化的JAR文件即使在放置在类路径上也要提供服务，它也需要在`META-INF/services`目录中添加条目。对于每个`provides
    ${service} with ${provider}`指令，创建一个名为${service}的普通文件，其中每行包含一个`${provider}`（所有名称都必须是完全限定的）。
- en: 'Requirements and recommendations for consumers are as follows:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对消费者的要求和推荐如下：
- en: 'Modules consuming services need to access the service type, so they must require
    the module containing it. They shouldn’t require the modules providing that service,
    though—on the contrary, that would be against the main reason to use services
    in the first place: to decouple consumers and providers.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费服务的模块需要访问服务类型，因此它们必须要求包含它的模块。不过，它们不应该要求提供该服务的模块——相反，这会违背最初使用服务的主要原因：解耦消费者和提供者。
- en: There’s nothing wrong with service types and the service’s consumers living
    in the same module.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务类型和服务的消费者位于同一模块中并没有什么问题。
- en: Any code can consume services regardless of its own accessibility, but the module
    containing it needs to declare which services it uses with a `uses` directive.
    This allows the module system to perform service binding efficiently and makes
    module declarations more explicit and readable.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何代码都可以消费服务，无论其自身的可访问性如何，但包含它的模块需要通过`uses`指令声明它使用的服务。这允许模块系统有效地执行服务绑定，并使模块声明更加明确和可读。
- en: Modules are consumed by calling `ServiceLoader::load` and then iterating or
    streaming over the returned instances by calling either `iterate` or `stream`.
    It’s possible that will be providers are found, and consumers must handle that
    case gracefully.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`ServiceLoader::load`并随后通过调用`iterate`或`stream`来迭代或流式传输返回的实例，可以消费模块。可能会找到提供者，消费者必须优雅地处理这种情况。
- en: 'The behavior of code that consumes services depends on global state: which
    provider modules are present in the module graph. This gives such code undesirable
    properties like making it hard to test. Try to push service loading into setup
    code that creates objects in their correct configuration (for example, your dependency
    injection framework), and always allow regular provider code to pass service providers
    to consuming classes (for example, during construction).'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费服务的代码的行为取决于全局状态：哪些提供者模块存在于模块图中。这给这样的代码带来了不希望的性质，例如使其难以测试。尝试将服务加载推入创建对象并配置正确的设置代码（例如，你的依赖注入框架），并且始终允许常规提供者代码将服务提供者传递给消费类（例如，在构造期间）。
- en: The service loader instantiates providers as late as possible. Its `stream`
    method even returns a `Stream<Provider<S>>`, where `Provider::type` can be used
    to access the `Class` instance for the provider. This allows searching for a suitable
    provider by checking class-level annotations without instantiating the provider
    yet.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务加载器尽可能晚地实例化提供者。它的`stream`方法甚至返回一个`Stream<Provider<S>>`，其中`Provider::type`可以用来访问提供者的`Class`实例。这允许在尚未实例化提供者的情况下通过检查类级别的注解来搜索合适的提供者。
- en: Service-loader instances aren’t thread-safe. If you use them concurrently, you
    have to provide synchronization.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务加载器实例不是线程安全的。如果你并发使用它们，你必须提供同步。
- en: All problems during loading and instantiating providers are thrown as `ServiceConfigurationError`.
    Due to the loader’s laziness, this doesn’t happen during `load`, but later in
    `iterate` or `stream` when problematic providers are encountered. Always be sure
    to put the entire interaction with `ServiceLoader` into a `try` block if you want
    to handle errors.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有在加载和实例化提供者期间的问题都会抛出`ServiceConfigurationError`。由于加载器的惰性，这不会在`load`期间发生，而是在`iterate`或`stream`期间，当遇到有问题的提供者时。如果你想要处理错误，请确保将整个与`ServiceLoader`的交互放入`try`块中。
- en: 'Here are some points about module resolution and more:'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有一些关于模块解析和更多的要点：
- en: When module resolution processes a module that declares the use of a service,
    all modules providing that service are resolved and thus included in the application’s
    module graph. This is called service binding, and together with the use of services
    in the JDK, it explains why by default even small apps use a lot of platform modules.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当模块解析过程处理声明使用服务的模块时，所有提供该服务的模块都会被解析，从而包含在应用程序的模块图中。这被称为服务绑定，并且与JDK中服务的使用一起，解释了为什么默认情况下即使是小型应用程序也会使用大量的平台模块。
- en: The command-line option `--limit-modules`, on the other hand, does no service
    binding. As a consequence, providers that aren’t transitive dependencies of the
    modules given to this option don’t make it into the module graph and aren’t available
    at run time. The option can be used to exclude services, optionally together with
    `--add-modules` to add some of them back.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，命令行选项`--limit-modules`不进行服务绑定。因此，不是给定此选项的模块的传递依赖关系的提供者不会进入模块图，并且在运行时不可用。此选项可用于排除服务，可选地与`--add-modules`一起使用，以添加其中的一些。
- en: '11'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '11'
- en: Refining dependencies and APIs
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 精炼依赖和API
- en: This chapter covers
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Handling dependencies that are part of a module’s API
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理模块API中的一部分依赖
- en: Aggregating and refactoring modules without breaking clients
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不破坏客户端的情况下聚合和重构模块
- en: Defining optional dependencies
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义可选依赖
- en: Writing code in the face of absent dependencies
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在缺少依赖的情况下编写代码
- en: Exporting packages to selected modules only
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅将包导出到选定的模块
- en: 'Chapter 3 explains how `requires` and `exports` directives are the basis for
    readability and accessibility. But these mechanisms are strict: every module has
    to be explicitly required, all required modules have to be present for the application
    to compile and launch, and exported packages are accessible to all other modules.
    This suffices for the majority of use cases, but there’s still a significant portion
    in which these solutions are too broad.'
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第3章解释了`requires`和`exports`指令是可读性和可访问性的基础。但这些机制是严格的：每个模块都必须被显式地要求，所有必需的模块都必须存在，应用程序才能编译和启动，并且导出的包对所有其他模块都是可访问的。这对于大多数用例来说足够了，但仍然有一大部分用例中这些解决方案过于宽泛。
- en: The most obvious use case is optional dependencies, which a module wants to
    compile against but which aren’t necessarily present at run time. Spring, for
    example, does this with the Jackson databind library. If you run a Spring application
    and want to use JSON as a data-transfer format, you can get support for that by
    dropping in the Jackson artifact. If, on the other hand, that artifact is absent,
    Spring is still happy—it doesn’t support JSON then. Spring uses Jackson but doesn’t
    require it.
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最明显的用例是可选依赖，模块希望针对它进行编译，但在运行时它不一定存在。例如，Spring使用Jackson databind库就是这样做的。如果你运行一个Spring应用程序并想使用JSON作为数据传输格式，你可以通过添加Jackson工件来获得对该格式的支持。另一方面，如果该工件不存在，Spring仍然很乐意——它不支持JSON。Spring使用Jackson，但不需要它。
- en: Regular `requires` directives don’t cover this use case, though, because the
    modules would have to be present for the application to launch. Services can be
    the solution in some such cases, but using them for all optional dependencies
    would lead to many awkward and complex implementations. Hence, plainly expressing
    that a dependency isn’t required at run time is an important feature; section
    11.2 shows how the JPMS implements it.
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，常规的`requires`指令并不涵盖这个用例，因为模块必须存在才能启动应用程序。在某些情况下，服务可以是解决方案，但将它们用于所有可选依赖会导致许多尴尬和复杂的实现。因此，明确表达在运行时不需要依赖是一个重要的功能；11.2节展示了JPMS如何实现它。
- en: Another use case where the module system’s strictness can become a hindrance
    is refactoring modules over time. In any decently sized project, the architecture
    evolves as time goes by, and developers will want to merge or split modules. But
    then what happens to code that depends on the old modules? Wouldn’t it be missing
    functionality (if it was split off into a new module) or even entire modules (if
    they were merged)? Fortunately the module system offers a feature, called implied
    readability, that can be of use here.
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块系统严格性可能成为障碍的另一个用例是随着时间的推移重构模块。在任何规模适中的项目中，架构都会随着时间的推移而演变，开发者会希望合并或拆分模块。但那么依赖于旧模块的代码会怎样呢？如果它被拆分到一个新的模块中，会不会丢失功能（如果它被拆分到一个新的模块中）或者甚至整个模块（如果它们被合并了）？幸运的是，模块系统提供了一个名为隐式可读性的功能，这在这里可能很有用。
- en: Although the `requires` and `exports` mechanisms we know so far make for a comparatively
    simple mental model, they offer no elegant solutions for use cases that don’t
    fit into their one-size-fits-all approaches. In this chapter, we look into such
    specific use cases and explore the solutions the module system offers.
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然我们迄今为止所知的`requires`和`exports`机制提供了一个相对简单的心理模型，但它们为不适合其一刀切方法的用例提供了没有优雅的解决方案。在本章中，我们将探讨这样的特定用例，并探索模块系统提供的解决方案。
- en: By the time you’ve worked through it, you’ll be able to use more refined mechanisms
    to access dependencies and export functionality. This will allow you to, among
    other things, express optional dependencies (section 11.2), refactor modules (section
    11.1), and share code between a defined set of modules while keeping it private
    from other code (section 11.3).
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在你完成它之后，你将能够使用更精细的机制来访问依赖关系并导出功能。这将允许你做许多事情，例如，表达可选依赖（11.2节），重构模块（11.1节），并在定义的模块集之间共享代码，同时将其对其他代码保持私有（11.3节）。
- en: '11.1 Implied readability: Passing on dependencies'
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 11.1 隐式可读性：传递依赖
- en: In section 3.2, we explored in depth how `requires` directives establish dependencies
    between modules and how the module system uses them to create reads edges (eventually
    resulting in the module graph, as sections 3.4.1 and 3.4.2 show). In section 3.3,
    you saw that accessibility is based on these edges, and to access a type, the
    accessing module must read the module containing the type (the type must also
    be public and the package exported, but that isn’t relevant here).
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在3.2节中，我们深入探讨了`requires`指令如何建立模块之间的依赖关系，以及模块系统如何使用它们来创建读取边（最终形成模块图，如3.4.1和3.4.2节所示）。在3.3节中，你看到可访问性基于这些边，要访问一个类型，访问模块必须读取包含该类型的模块（类型也必须是公共的，并且包必须导出，但这在这里并不相关）。
- en: In this section, we’ll look at another way to give modules access to other modules.
    We’ll start by discussing a motivating use case before I introduce the new mechanism
    and develop some guidelines for how best to use it. Toward the end, you’ll see
    how powerful it is and how it can help with much more than the initial examples.
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨另一种使模块能够访问其他模块的方法。在介绍新机制并制定最佳使用该机制的指南之前，我们将首先讨论一个激励用例。在结尾处，你将看到它有多么强大，以及它如何能帮助解决比初始示例更多的问题。
- en: Check out ServiceMonitor’s `feature-implied-readability` branch for the code
    accompanying this section.
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看ServiceMonitor的`feature-implied-readability`分支以获取本节所伴随的代码。
- en: 11.1.1 EXPOSING A MODULE’S DEPENDENCIES
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 11.1.1 展示模块的依赖
- en: 'When it comes to the interplay between `requires` directives and accessibility,
    there’s a fine detail to observe: The `requires` directives create reads edges
    but the edges are a prerequisite for accessibility. Doesn’t that beg the question
    of which other mechanisms can establish readability and thus unlock access to
    types? This is more than theoretical pondering—approaching the situation from
    a practical angle, we end up in the same place.'
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当涉及到`requires`指令和可访问性之间的交互时，有一个需要注意的细节：`requires`指令创建读取边，但这些边是可访问性的先决条件。这难道不引发了一个问题：还有哪些其他机制可以建立可读性，从而解锁对类型的访问？这不仅仅是理论上的思考——从实际的角度来看待这个问题，我们最终会到达同一个地方。
- en: Let’s turn back to the ServiceMonitor application, particularly the modules
    monitor.observer and monitor.observer.alpha. Assume that a new module, let’s call
    it monitor.peek, wants to use monitor.observer.alpha directly. It has no need
    for monitor.observer or the service architecture you created in the previous chapter.
    Can monitor.peek just `require` monitor.observer.alpha and start using it?
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们回到ServiceMonitor应用程序，特别是monitor.observer和monitor.observer.alpha模块。假设有一个新的模块，让我们称它为monitor.peek，它想直接使用monitor.observer.alpha。它不需要monitor.observer或你在上一章中创建的服务架构。monitor.peek是否只需`require`monitor.observer.alpha并开始使用它？
- en: '`ServiceObserver observer = new AlphaServiceObserver("some://service/url");
    DiagnosticDataPoint data = observer.gatherDataFromService();`'
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ServiceObserver observer = new AlphaServiceObserver("some://service/url");
    DiagnosticDataPoint data = observer.gatherDataFromService();`'
- en: It looks like it needs the types `ServiceObserver` and `DiagnosticDataPoint`.
    Both are in monitor.observer, so what happens if monitor.peek doesn’t `require`
    monitor.observer? It can’t access its types, resulting in compile errors. As you
    saw when we discussed the encapsulation of transitive dependencies in section
    3.3.2, this is a feature of the module system.
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它看起来需要`ServiceObserver`和`DiagnosticDataPoint`类型。这两个类型都在`monitor.observer`中，那么如果`monitor.peek`不`require``monitor.observer`会发生什么？它将无法访问其类型，导致编译错误。正如我们在3.3.2节讨论传递依赖的封装时所见，这是模块系统的一个特性。
- en: Here it’s an impediment, though. Without the types from monitor.observer, monitor.observer.alpha
    is effectively useless; and every module that wants to use it has to read monitor.observer
    as well. (This is shown in [figure 11.1](part0026.html#filepos1345189).) Does
    every module using monitor.observer.alpha have to `require` monitor.observer,
    too?
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，这里存在一个障碍。如果没有来自`monitor.observer`的类型，`monitor.observer.alpha`实际上是无用的；并且每个想要使用它的模块都必须读取`monitor.observer`。（这可以在[图11.1](part0026.html#filepos1345189)中看到。）使用`monitor.observer.alpha`的每个模块都必须`require``monitor.observer`吗？
- en: That’s not a comfortable solution. If only there was another mechanism to establish
    readability and thus unlock access to types.
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这不是一个令人舒适的解决方案。如果只有另一种机制可以建立可读性，从而解锁对类型的访问。
- en: '![](../images/00043.jpeg)'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00043.jpeg)'
- en: '[Figure 11.1](part0026.html#filepos1344320) The module peek uses observer.alpha,
    which uses types from observer in its public API. If peek doesn’t require observer
    (left), it can’t read its types, making observer.alpha useless. With regular `requires`
    directives, the only way around that is to have peek also require observer (right),
    which becomes cumbersome when more modules are involved.'
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图11.1](part0026.html#filepos1344320) 模块peek使用了observer.alpha，它在其公共API中使用了observer的类型。如果peek不`require`observer（左侧），它将无法读取其类型，使得observer.alpha变得无用。使用常规的`requires`指令，绕过这种情况的唯一方法是将peek也`require`observer（右侧），当涉及更多模块时，这会变得繁琐。'
- en: '![](../images/00114.jpeg)'
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00114.jpeg)'
- en: '[Figure 11.2](part0026.html#filepos1349745) Three modules are involved in the
    problem of exposed dependencies: the innocent one that provides some types (exposed;
    right), the guilty one using those types in its public API (exposing; middle),
    and the impacted one having to accesses the innocent’s types (depending; left).'
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图11.2](part0026.html#filepos1349745) 有三个模块涉及到暴露依赖的问题：一个是提供一些类型（暴露；右侧）的无辜者，一个是使用这些类型在其公共API中（暴露；中间）的有罪者，以及一个必须访问无辜者类型的受影响者（依赖；左侧）。'
- en: What happens in the previous example is common. A module exposing depends on
    some module exposed, but uses types from exposed in its own public API (as defined
    in section 3.3). In such cases, exposing is said to expose its dependency on exposed
    to its clients because they also need to depend on exposed in order to use exposing.
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在前面的示例中发生的情况是常见的。一个暴露模块依赖于某些暴露的模块，但使用暴露中的类型在其自己的公共 API（如第 3.3 节中定义的）中使用。在这种情况下，暴露被认为向其客户端暴露了对暴露的依赖，因为它们也需要依赖暴露才能使用暴露。
- en: 'To make talking about this situation a little less confusing, make sure you
    understand these definitions in [figure 11.2](part0026.html#filepos1347342). I’ll
    stick to these terms when describing the involved modules:'
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了使讨论这种情况不那么令人困惑，请确保你理解了 [图 11.2](part0026.html#filepos1347342) 中的这些定义。在描述涉及的模块时，我会坚持使用这些术语：
- en: The module exposing its dependency is called the exposing module.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露其依赖的模块称为暴露模块。
- en: The module that is exposed as a dependency is the exposed module.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为依赖关系被暴露的模块是暴露模块。
- en: The module depending on that mess is called the depending module.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖该混乱模块的模块称为依赖模块。
- en: Many examples can be found in the JDK. The java.sql module, for example, contains
    a type `java.sql.SQLXML` (used by `java.sql.Connection`, among others), which
    uses types from the java.xml module in its public methods. The type `java.sql.SQLXML`
    is public and in an exported package, so it’s part of the API of java.sql. That
    means in order for any depending module to properly use the exposing java.sql,
    it must read the exposed java.xml as well.
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 JDK 中可以找到许多示例。例如，java.sql 模块包含一个类型 `java.sql.SQLXML`（由 `java.sql.Connection`
    等使用），它在公共方法中使用来自 java.xml 模块的类型。类型 `java.sql.SQLXML` 是公共的，并且在一个导出包中，因此它是 java.sql
    API 的一部分。这意味着为了任何依赖模块能够正确使用暴露的 java.sql，它还必须读取暴露的 java.xml。
- en: '11.1.2 THE TRANSITIVE MODIFIER: IMPLYING READABILITY ON A DEPENDENCY'
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 11.1.2 传递修饰语：在依赖关系上暗示可读性
- en: Looking at the situation, it’s clear that the developers of the exposing module
    are the ones who need to solve this problem. After all, they decide to use the
    exposed module’s types in their own API, forcing the modules depending on them
    to read the exposed modules.
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从情况来看，很明显，暴露模块的开发者需要解决这个问题。毕竟，他们决定在自己的 API 中使用暴露模块的类型，迫使依赖它们的模块读取暴露模块。
- en: 'The solution for these situations is to use a `requires transitive`directive
    in the exposing module’s declaration. If exposing declares `requires transitive
    exposed`, then any module reading exposing will implicitly also read exposed.
    The effect is called implied readability: reading exposing implies reading exposed.
    [Figure 11.3](part0026.html#filepos1354407) shows this directive.'
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些情况的解决方案是在暴露模块的声明中使用 `requires transitive` 指令。如果暴露声明 `requires transitive exposed`，则任何读取暴露的模块将隐式地读取暴露。这种效果称为隐含的可读性：读取暴露意味着读取暴露。[图
    11.3](part0026.html#filepos1354407) 展示了这个指令。
- en: '![](../images/00042.jpeg)'
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00042.jpeg)'
- en: '[Figure 11.3](part0026.html#filepos1354074) When exposing uses a `requires
    transitive` directive to depend on exposed, reading exposing implies readability
    of exposed. As a consequence, modules like depending (left) can read exposed even
    if they only require exposing.'
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 11.3](part0026.html#filepos1354074) 当使用 `requires transitive` 指令依赖暴露时，读取暴露意味着暴露的可读性。因此，即使依赖项仅要求暴露，依赖模块（左侧）也可以读取暴露。'
- en: The use of implied readability is obvious when looking at a module declaration
    or descriptor. With the skills you learned in section 5.3.1, you can look into
    java.sql. The following listing shows that the dependency on java.xml is marked
    with `transitive`.
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当查看模块声明或描述符时，隐含的可读性使用是显而易见的。通过你在第 5.3.1 节中学到的技能，你可以查看 java.sql。以下列表显示对 java.xml
    的依赖关系被标记为 `transitive`。
- en: 'Listing 11.1 java.sql module descriptor: implies readability of java.xml and
    java.logging'
  id: totrans-354
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 11.1 java.sql 模块描述符：暗示 java.xml 和 java.logging 的可读性
- en: '`$ java --describe-module java.sql  > java.sql@9.0.4 > exports java.sql > exports
    javax.sql > exports javax.transaction.xa > requires java.base mandate` `> requires
    java.logging transitive` [`①`](part0026.html#filepos1358134)`> requires java.xml
    transitive` [`①`](part0026.html#filepos1358134) `> uses java.sql.Driver`'
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --describe-module java.sql  > java.sql@9.0.4 > exports java.sql > exports
    javax.sql > exports javax.transaction.xa > requires java.base mandate` `> requires
    java.logging transitive` [`①`](part0026.html#filepos1358134)`> requires java.xml
    transitive` [`①`](part0026.html#filepos1358134) `> uses java.sql.Driver`'
- en: ①
  id: totrans-356
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: These directives indicate that modules reading java.sql can also read java.xml
    and java.logging.
  id: totrans-357
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些指令表明，读取 java.sql 的模块也可以读取 java.xml 和 java.logging。
- en: Likewise, the dependency on java.logging is marked `transitive`. The reason
    is the public interface `java.sql.Driver` and its method `Logger getParentLogger()`.
    It exposes the type `java.util.logging.Logger` from java.logging in the public
    API of java.sql, so java.sql implies readability of java.logging. Note that although
    `java --describe-module` puts `transitive` last, the module declaration expects
    the modifier to come between `requires` and the module name (`requires transitive
    ${module}`).
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 同样，对 `java.logging` 的依赖被标记为 `transitive`。原因是公共接口 `java.sql.Driver` 和其方法 `getParentLogger()`。它从
    `java.logging` 暴露了 `java.util.logging.Logger` 类型到 `java.sql` 的公共 API 中，因此 `java.sql`
    隐式传递了 `java.logging` 的可读性。请注意，尽管 `java --describe-module` 将 `transitive` 放在最后，但模块声明期望修饰符位于
    `requires` 和模块名称之间（`requires transitive ${module}`）。
- en: 'Going back to the motivating example of how to make monitor.observer.alpha
    usable without depending modules also having to require monitor.observer, the
    solution is now obvious—use `requires transitive` to declare the dependency of
    monitor.observer.alpha on monitor.observer:'
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 回到如何使 `monitor.observer.alpha` 可用而不需要依赖模块也必须要求 `monitor.observer` 的激励示例，现在的解决方案很明显——使用
    `requires transitive` 来声明 `monitor.observer.alpha` 对 `monitor.observer` 的依赖：
- en: '`module monitor.observer.alpha { requires transitive monitor.observer; exports
    monitor.observer.alpha; }`'
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.observer.alpha { requires transitive monitor.observer; exports
    monitor.observer.alpha; }`'
- en: When exploring reliable configuration and missing dependencies in section 3.2.2,
    you discovered that although the run time requires all dependencies (direct and
    indirect) to be observable, the compiler only mandates that for direct ones. This
    means you can compile your module against exposing without its dependencies being
    present. Now, how does implied readability fit into this?
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在探索第 3.2.2 节中的可靠配置和缺失依赖时，你发现尽管运行时要求所有依赖（直接和间接）都必须是可观察的，但编译器只强制要求直接依赖。这意味着你可以编译你的模块，即使其依赖项不存在也可以。那么隐式可读性如何适应这种情况？
- en: ESSENTIAL INFO Modules whose readability is implied to the module under compilation
    go into the “must be observable” bucket. That means every dependency that exposing
    requires transitively, like exposed in the earlier examples, must be observable
    when you compile your module against exposing.
  id: totrans-362
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 必要信息：那些对正在编译的模块具有隐式可读性的模块将进入“必须可观察”的类别。这意味着当你编译你的模块针对暴露时，所有暴露通过传递性要求的依赖，就像在早期示例中展示的那样，都必须是可观察的。
- en: That’s regardless of whether you use types from exposed, which might at first
    seem overly strict. But remember from section 3.4.1 that modules are resolved
    and the module graph is built before the code is compiled. The module graph is
    the basis for compilation, not the other way around, and mutating it based on
    the encountered types would go against the goal of reliable configuration. The
    module graph must hence always contain transitive dependencies.
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这与你是否使用暴露的类型无关，这乍一看可能过于严格。但记住从第 3.4.1 节中，模块在代码编译之前被解析，模块图被构建。模块图是编译的基础，而不是相反，根据遇到类型对其进行修改将违反可靠配置的目标。因此，模块图必须始终包含传递性依赖。
- en: Chains of dependencies
  id: totrans-364
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 依赖链
- en: You may wonder what happens in a chain of dependencies, where each `requires`
    directive uses `transitive`. Will readability be implied along longer paths? The
    answer is yes. It doesn’t matter whether an exposing module is read because of
    an explicit dependency or implied readability—it will imply readability of its
    dependencies just the same. The following figure illustrates the transitivity
    of `transitive`.
  id: totrans-365
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能会想知道在一个依赖链中会发生什么，其中每个 `requires` 指令都使用 `transitive`。可读性会沿着更长的路径隐式传递吗？答案是肯定的。无论是由于显式依赖还是隐式可读性而读取暴露的模块，它都会同样地隐式传递其依赖的可读性。以下图示说明了
    `transitive` 的传递性。
- en: '![](../images/00046.jpeg)'
  id: totrans-366
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00046.jpeg)'
- en: The depending module requires exposing, which implies readability of exposed,
    which in turn implies readability of exposed.alpha and exposed.beta. Implied readability
    is transitive, so depending can read all other four modules even though it only
    depends on one of them.
  id: totrans-367
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 依赖模块需要暴露，这隐式传递了暴露的可读性，进而隐式传递了暴露.alpha 和暴露.beta 的可读性。隐式可读性是传递的，因此依赖可以读取所有其他四个模块，尽管它只依赖于其中一个。
- en: 11.1.3 WHEN TO USE IMPLIED READABILITY
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 11.1.3 何时使用隐式可读性
- en: 'As you’ve seen, implied readability reduces the need for explicit `requires`
    directives in depending modules. This can be a good thing, but I want to return
    to something I only mentioned in passing before. Implied readability goes against
    a feature of the module system: the encapsulation of transitive dependencies discussed
    in section 3.2.2\. With two opposing requirements (strictness versus convenience)
    and two features to fulfill them (`requires` versus `requires transitive`), it’s
    important to carefully consider the trade-offs.'
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如你所见，隐含的可读性减少了依赖模块中显式`requires`指令的需求。这可能是个好事，但我想要回到之前只是简单提到的事情。隐含的可读性与模块系统的特性相矛盾：即第3.2.2节中讨论的传递依赖的封装。由于有两个对立的要求（严格性与便利性）和两个特性来满足它们（`requires`与`requires
    transitive`），因此仔细考虑权衡是很重要的。
- en: The situation is similar to visibility modifiers. For convenience’s sake, it
    would be easy to make every class, every field, and every method public. We don’t
    do that, though, because we know that exposing less reduces the contact surface
    between different parts of the code and makes modification, replacement, and reuse
    easier. And like making a type or member public, exposing a dependency becomes
    part of that module’s public API, and clients may rely on the fact that readability
    is implied. This can make evolving the module and its dependencies more difficult,
    so it shouldn’t be undertaken lightly.
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种情况与可见性修饰符类似。为了方便起见，很容易让每个类、每个字段和每个方法都是公开的。我们并没有这样做，因为我们知道减少暴露可以减少代码不同部分之间的接触面，使修改、替换和重用更容易。并且，就像使类型或成员公开一样，暴露依赖成为该模块公共API的一部分，客户端可能会依赖隐含的可读性。这可能会使模块及其依赖的演变更加困难，因此不应轻率地进行。
- en: 'ESSENTIAL INFO Following this line of thought, using `transitive` should be
    the exception and only be done under very specific circumstances. The most prominent
    is what I’ve described so far: if a module uses types from a second module in
    its own public API (as defined in section 3.3), it should imply readability of
    that second module by using a `requires transitive` directive.'
  id: totrans-371
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 11.2节：重要信息 沿着这个思路，使用`transitive`应该是例外，并且只有在非常具体的情况下才使用。最突出的是我之前描述的情况：如果一个模块在其自己的公共API（如第3.3节定义）中使用来自第二个模块的类型，它应该通过使用`requires
    transitive`指令来隐含第二个模块的可读性。
- en: Other use cases are aggregation, decomposition, and merging of modules, all
    of which we’ll discuss in section 11.1.5\. Before that, I want to explore a similar
    use case that may warrant another solution.
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 其他用例包括模块的聚合、分解和合并，我们将在11.1.5节中讨论这些内容。在此之前，我想探讨一个可能需要另一种解决方案的类似用例。
- en: So far, the assumption has been that the exposing module can’t operate without
    exposed. Interestingly enough, that isn’t always the case. The exposing module
    could implement utility functions based on the exposed module that only code that’s
    already using the exposed module would call.
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到目前为止，一直假设暴露模块没有暴露就无法运行。有趣的是，这并不总是情况。暴露模块可以基于暴露模块实现一些实用函数，只有已经使用暴露模块的代码才会调用这些函数。
- en: Say a library uber.lib offers utility functions based on com.google.common.
    Then only users of Guava had a use for uber.lib. In such cases, optional dependencies
    may be the way to go; see section 11.2.
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设有一个名为uber.lib的库提供了基于com.google.common的实用函数。在这种情况下，只有Guava的用户才会使用uber.lib。在这种情况下，可选依赖可能是可行的；请参阅11.2节。
- en: 11.1.4 WHEN TO RELY ON IMPLIED READABILITY
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 11.1.4 何时依赖隐含可读性
- en: You’ve seen how implied readability allows a module to “pass on” readability
    of exposed dependencies. We discussed considerations that go into deciding when
    to use that feature. That was from the perspective of the developer writing the
    exposing module.
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你已经看到了隐含的可读性如何允许一个模块“传递”暴露依赖的可读性。我们讨论了决定何时使用该功能的考虑因素。这是从编写暴露模块的开发者的角度来讨论的。
- en: 'Now, let’s switch perspective and look at this from the point of view of the
    depending module: the one to which readability of the exposed module is passed
    on. To what extent should it rely on implied readability? At what point should
    it instead require the exposed module?'
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，让我们转换视角，从依赖模块的角度来看这个问题：即暴露模块的可读性传递给哪个模块。它应该在多大程度上依赖隐含的可读性？在什么情况下它应该要求暴露模块？
- en: As you saw when we first explored implied readability, java.sql exposes its
    dependency on java.logging. That begs the question, should modules using java.sql
    also require java.logging? Technically, such a declaration isn’t needed and may
    seem redundant.
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我们最初探索隐含可读性时，你看到java.sql暴露了对java.logging的依赖。这引发了一个问题，使用java.sql的模块是否也应该要求java.logging？技术上，这样的声明是不必要的，可能看起来是多余的。
- en: 'That’s also true for the motivating example of monitor.peek, monitor.observer,
    and monitor.observer.alpha: in the final solution, monitor.peek uses types from
    both other modules but only requires monitor.observer.alpha, which implies readability
    of monitor.observer. Should it also explicitly require monitor.observer? And if
    not, just not in that specific example, or never?'
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这也适用于motivating example of monitor.peek、monitor.observer和monitor.observer.alpha的激励示例：在最终解决方案中，monitor.peek使用来自其他模块的类型，但只要求monitor.observer.alpha，这暗示了monitor.observer的可读性。它是否也应该显式要求monitor.observer？如果不是，只是在那个特定示例中，或者永远不是？
- en: 'To decide when to rely on a dependency implying readability on a module or
    when to require that module directly, it makes sense to turn back to one of the
    core promises of the module system: reliable configuration (see section 3.2.1).
    Using `requires` directives makes code more reliable by making dependencies explicit,
    and you can apply that principle here to make a decision by asking a different
    question.'
  id: totrans-380
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要决定何时依赖一个模块的隐含可读性依赖，何时直接要求该模块，回到模块系统的核心承诺之一：可靠的配置（见第3.2.1节）是有意义的。使用`requires`指令通过使依赖关系明确，使代码更可靠，你可以应用这个原则，通过提出不同的问题来做出决定。
- en: ESSENTIAL INFO Does the depending module depend on the exposed module regardless
    of the exposing one? Or, in other words, if the depending module is modified to
    no longer use the exposing module, might it still need the exposed one?
  id: totrans-381
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息**：依赖模块是否无论暴露模块如何都依赖于暴露模块？换句话说，如果依赖模块被修改为不再使用暴露模块，它是否仍然需要暴露模块？'
- en: If the answer is negative, removing the code that uses the exposing module also
    removes the dependency on the exposed module. We could say that the exposed module
    was only used on the boundary between the depending and the exposing modules.
    In that case, there’s no need to explicitly requiring it, and relying on implied
    readability is fine.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果答案是负面的，移除使用暴露模块的代码也会移除对暴露模块的依赖。我们可以这样说，暴露模块仅在依赖和暴露模块之间的边界处使用。在这种情况下，没有必要显式地要求它，依赖隐含可读性是可行的。
- en: If, on the other hand, the answer is positive, then the exposed module is used
    on more than just the boundary to the exposing module. Accordingly, it should
    be explicitly depended on with a `requires` directive.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，如果答案是肯定的，那么暴露模块不仅用于暴露模块的边界。相应地，它应该通过`requires`指令显式依赖。
- en: '[Figure 11.4](part0026.html#filepos1377262) illustrates visualizes these two
    options.'
  id: totrans-384
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图11.4](part0026.html#filepos1377262) 展示了这两个选项的可视化。'
- en: '![](../images/00089.jpeg)'
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00089.jpeg)'
- en: '[Figure 11.4](part0026.html#filepos1376879) Two cases of implied readability,
    involving depending, exposing, and exposed modules. Where the two boxes touch,
    the depending module uses exposing, on which it explicitly depends. Both use the
    exposed module (striped area). But the degree of use can differ: The depending
    module may only use it on the boundary to exposed (top), or it may use the types
    internally to implements its own features (bottom).'
  id: totrans-386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图11.4](part0026.html#filepos1376879) 两个涉及依赖、暴露和暴露模块的隐含可读性案例。当两个方框接触时，依赖模块使用暴露模块，它明确依赖于该模块。两者都使用暴露模块（条纹区域）。但使用的程度可能不同：依赖模块可能仅在暴露的边界处使用它（顶部），或者它可能使用内部类型来实现自己的功能（底部）。'
- en: 'Looking back on the example of java.sql, you can answer the question based
    on how the depending module, let’s say it’s monitor.persistence, uses java.logging:'
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 回顾java.sql的例子，你可以根据依赖模块如何使用java.logging来回答这个问题，比如说它是monitor.persistence：
- en: It may only need to read java.logging, so it’s able to call `java.sql.Driver.getParentLogger()`,
    change the logger’s log level, and be done with it. In this case, its interaction
    with java.logging is limited to the boundary between monitor.persistence and java.sql,
    and you’re in the sweet spot for implied readability.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能只需要读取java.logging，因此能够调用`java.sql.Driver.getParentLogger()`，更改记录器的日志级别，然后完成。在这种情况下，它与java.logging的交互仅限于monitor.persistence和java.sql之间的边界，你处于隐含可读性的甜蜜点。
- en: Alternatively, monitor.persistence may use logging throughout its own code.
    Then, types from java.logging appear in many places, independently of `Driver`,
    and can no longer be considered limited to the boundary. In that case, monitor.persistence
    should explicitly require java.logging.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，monitor.persistence可能在它的代码中到处使用日志记录。然后，来自java.logging的类型出现在许多地方，独立于`Driver`，并且不能再被认为是局限于边界的。在这种情况下，monitor.persistence应明确要求java.logging。
- en: A similar juxtaposition can be made for the example from the ServiceMonitor
    application. Does monitor.peek, which requires monitor.observer.alpha, only use
    types from monitor.observer to create a `ServiceObserver`? Or does it have a use
    for the types from the monitor.observer module independently of its interaction
    with monitor.observer.alpha?
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可以对ServiceMonitor应用程序的例子进行类似的对比。monitor.peek，它需要monitor.observer.alpha，是否只使用monitor.observer中的类型来创建`ServiceObserver`？或者它是否独立于与monitor.observer.alpha的交互而使用monitor.observer模块中的类型？
- en: 11.1.5 REFACTORING MODULES WITH IMPLIED READABILITY
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 11.1.5 使用隐式可读性重构模块
- en: At first glance, implied readability looks like a small feature that solves
    a specific use case. Interestingly, though, it isn’t limited to that case! On
    the contrary, it unlocks some useful techniques that help with refactoring modules.
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 初看之下，隐式可读性似乎是一个解决特定用例的小功能。然而，有趣的是，它并不仅限于那个用例！相反，它解锁了一些有用的技术，有助于模块重构。
- en: The motivation for using these techniques is often to prevent changes in modules
    that depend on the one(s) that are being refactored. If you have total control
    over all clients of a module and compile and deploy them all at once, then you
    can change their module declarations instead of doing something more complicated.
    But often you can’t—for example, when developing a library—so you need a way to
    refactor modules without breaking backward compatibility.
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用这些技术的动机通常是防止重构模块时模块依赖项发生变化。如果你完全控制模块的所有客户端，并且一次性编译和部署它们，那么你可以更改它们的模块声明，而不是做更复杂的事情。但通常你无法做到——例如，当开发库时——因此你需要一种在不破坏向后兼容性的情况下重构模块的方法。
- en: REPRESENTING MODULE FAMILIES WITH AGGREGATOR MODULES
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用聚合模块表示模块家族
- en: Let’s say your application has a couple of core modules that almost any other
    module must depend on. You could, of course, copy-paste the necessary `requires`
    directives into every module declaration, but that’s rather tedious. Instead,
    you can use implied readability to create a so-called aggregator module.
  id: totrans-395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你的应用程序有几个核心模块，几乎任何其他模块都必须依赖它们。你当然可以将必要的`requires`指令复制粘贴到每个模块声明中，但这相当繁琐。相反，你可以使用隐式可读性来创建所谓的聚合模块。
- en: An aggregator module contains no code and implies readability with `requires
    transitive` on all of its dependencies. It’s used to create a coherent set of
    modules that other modules can easily depend on by just requiring the aggregator
    module.
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 聚合模块不包含代码，并通过在其所有依赖项上使用`requires transitive`来体现可读性。它用于创建一组连贯的模块，其他模块可以通过仅要求聚合模块来轻松依赖。
- en: 'The ServiceMonitor application is a little small to justify creating an aggregator
    module; but for the sake of an example, let’s decide that monitor.observer and
    monitor.statistics are its core API. In that case, you can create monitor.core
    as follows:'
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ServiceMonitor应用程序的规模有点小，不足以证明创建聚合模块的必要性；但为了举例，让我们决定monitor.observer和monitor.statistics是其核心API。在这种情况下，你可以按以下方式创建monitor.core：
- en: '`module monitor.core { requires transitive monitor.observer; requires transitive
    monitor.statistics; }`'
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.core { requires transitive monitor.observer; requires transitive
    monitor.statistics; }`'
- en: Now, all other modules can depend on monitor.core and get readability of monitor.observer
    and monitor.statistics for free. [Figure 11.5](part0026.html#filepos1386592) visualizes
    this example.
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，所有其他模块都可以依赖monitor.core，并免费获得monitor.observer和monitor.statistics的可读性。[图11.5](part0026.html#filepos1386592)展示了这个例子。
- en: '![](../images/00116.jpeg)'
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00116.jpeg)'
- en: '[Figure 11.5](part0026.html#filepos1386256) The aggregator module core (left)
    contains no code and uses `requires transitive` directives to refer to the aggregated
    modules observer and statistics (right), which contain the functionality. Thanks
    to implied readability, clients of the aggregator module can use the APIs of the
    aggregated modules.'
  id: totrans-401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图11.5](part0026.html#filepos1386256) 聚合模块core（左）不包含代码，并使用`requires transitive`指令引用聚合的模块observer和statistics（右），其中包含功能。多亏了隐式可读性，聚合模块的客户端可以使用聚合模块的API。'
- en: There is, of course, no reason to limit aggregation to core functionality. Every
    family of modules that cooperate to implement a feature is a candidate to get
    an aggregator module that represents it.
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当然，没有理由将聚合限制在核心功能上。每个合作实现功能的模块家族都是获得代表它的聚合模块的候选者。
- en: 'But wait: don’t aggregator modules bring clients into a situation where they
    internally use APIs of modules they don’t explicitly depend on? This can be seen
    as conflicting with what I said when discussing when to rely on implied readability:
    that it should be used on the boundary to other modules. But I think the situation
    is subtly different here.'
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但是等等：聚合模块不会让客户端陷入一个内部使用它们明确不依赖的模块的API的情况吗？这似乎与我在讨论何时依赖隐含可读性时所说的相矛盾：它应该在模块边界处使用。但我认为这里的情况微妙地不同。
- en: 'Aggregator modules have a specific responsibility: to bundle the functionality
    of related modules into a single unit. Modifying the bundle’s content is a pivotal
    conceptual change. “Regular” implied readability, on the other hand, often manifests
    between modules that aren’t immediately related (as with java.sql and java.logging),
    where the implied module is used more incidentally (although it’s still API-breaking
    to change it; see section 15.2.4).'
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 聚合模块有一个特定的责任：将相关模块的功能捆绑成一个单一单元。修改捆绑内容是一个关键的概念性变化。“常规”隐含的可读性，另一方面，通常表现在不直接相关的模块之间（如java.sql和java.logging），其中隐含的模块更偶然地被使用（尽管改变它仍然是破坏API的；参见第15.2.4节）。
- en: 'If you’re into object-oriented programming terminology, you can compare this
    to association, aggregation, and composition (the comparison is far from perfect,
    and the terms don’t neatly align, but if you know the terminology, it should give
    you some intuition):'
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你熟悉面向对象的编程术语，你可以将其与关联、聚合和组合（比较远非完美，术语也不整齐对齐，但如果你了解术语，它应该给你一些直观的感受）：
- en: Regular `requires` directives create an uncomplicated association between the
    two involved modules.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义的 `requires` 指令在两个相关模块之间创建了一个简单的关联。
- en: Using `requires transitive` turns this into an aggregation where one module
    makes the other part of its API.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `requires transitive` 将其转变为一种聚合，其中一个模块使其它模块成为其API的一部分。
- en: Aggregator modules are then similar to composition in the sense that the involved
    modules’ lifecycles are coupled—the aggregator module has no raison d’être of
    its own. This doesn’t quite hit the nail on the head, though, because in a true
    aggregation, the referenced modules have no purpose of their own—with aggregator
    modules, on the other hand, they typically do.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合模块在某种程度上类似于组合，因为涉及到的模块的生命周期是耦合的——聚合模块本身没有存在的理由。然而，这并不完全准确，因为在真正的聚合中，被引用的模块本身没有目的——而另一方面，聚合模块通常是有目的的。
- en: Given these categories, I’d say that requiring an aggregation’s exposed dependencies
    is governed by the guideline introduced in section 11.1.4, whereas depending on
    a composition’s exposed dependencies is always okay. To not make matters more
    complicated than they need to be, I won’t use the terms aggregation and composition
    in the rest of the book; I’ll stick to implied readability and aggregator modules.
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑到这些类别，我认为要求聚合公开的依赖关系受第11.1.4节中引入的指南的约束，而依赖于组合公开的依赖关系始终是可行的。为了不让事情比必要的更复杂，我将在本书的其余部分不使用聚合和组合这两个术语；我将坚持使用隐含的可读性和聚合模块。
- en: 'ESSENTIAL INFO Finally, a word of warning: aggregator modules are a leaky abstraction!
    In this case, they leak services and qualified exports and opens. The latter are
    introduced in sections 11.3 and 12.2.2, so I won’t go into full detail. Suffice
    it to say that they work by naming specific modules, so only they can access a
    package. Although an aggregator module invites developers to use it instead of
    its composing modules, exporting or opening a package to an aggregator module
    is pointless because it contains no code of its own, and the composing modules
    will still see a strongly encapsulated package.'
  id: totrans-410
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 最后，一个警告：聚合模块是一个有缺陷的抽象！在这种情况下，它们泄露了服务和有资格的导出和公开。后者在第11.3节和12.2.2节中介绍，所以我不将详细说明。只需说，它们通过命名特定的模块来工作，因此只有它们可以访问一个包。尽管聚合模块鼓励开发者使用它而不是其组成模块，但向聚合模块导出或公开一个包是没有意义的，因为它不包含自己的代码，组成模块仍然会看到一个强封装的包。'
- en: Service binding, as explained in section 10.1.2, also tarnishes the illusion
    of aggregator modules being perfect placeholders. Here, the problem is that if
    a composing module provides a service, binding will pull it into the module graph
    but, of course, not the aggregator module (because it doesn’t declare to provide
    that service), and hence not the other composing modules. Think these cases through
    before creating aggregator modules.
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如第 10.1.2 节所述的服务绑定，也破坏了聚合器模块是完美占位符的幻想。在这里，问题是如果组成模块提供了一个服务，绑定将把它拉入模块图中，但当然不是聚合器模块（因为它没有声明提供该服务），因此也不是其他组成模块。在创建聚合器模块之前，仔细考虑这些情况。
- en: REFACTORING MODULES BY SPLITTING THEM UP
  id: totrans-412
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过拆分模块进行重构
- en: I’m sure you’ve been in a situation where you realized that what you once thought
    of as a simple feature has grown into a more complex subsystem. You’ve improved
    and extended it again and again, and it’s a little tangled; so, to clean up the
    code base, you refactor it into smaller parts that interact in a better-defined
    way while keeping its public API stable.
  id: totrans-413
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我确信你曾经遇到过这样的情况，你意识到你曾经认为的一个简单功能已经发展成为一个更复杂的子系统。你一次又一次地改进和扩展它，它变得有些混乱；因此，为了清理代码库，你将其重构为更小的部分，这些部分以更好的定义方式交互，同时保持其公共
    API 稳定。
- en: ESSENTIAL INFO Taking the ServiceMonitor application as an example, its statistics
    operations may have collected so much code that it makes sense to split it into
    a few smaller subprojects, such as Averages, Medians, and Percentiles. So far,
    so good; now, let’s consider how this interacts with modules.
  id: totrans-414
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 以 ServiceMonitor 应用程序为例，其统计操作可能收集了如此多的代码，以至于将其拆分为几个较小的子项目是有意义的，例如平均值、中位数和百分位数。到目前为止，一切顺利；现在，让我们考虑这如何与模块交互。'
- en: Suppose the simple feature had its own module to begin with, and the new solution
    would use several modules. What happens with code that depends on the original
    module? If that disappears, the module system will complain about missing dependencies.
  id: totrans-415
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设简单功能最初就有自己的模块，而新的解决方案将使用几个模块。如果原始模块消失了，模块系统将抱怨缺少依赖项。
- en: With what we just discussed, why not keep the original module and turn it into
    an aggregator? This is possible as long as all of the original module’s exported
    packages are now exported by the new modules. (Otherwise, depending on the new
    aggregator module doesn’t grant accessibility to all types of its former API.)
  id: totrans-416
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 根据我们刚才讨论的内容，为什么不保留原始模块并将其转换为聚合器呢？只要原始模块的所有导出包现在都由新的模块导出，这是可能的。（否则，依赖于新的聚合器模块并不授予对其以前
    API 所有类型的访问权限。）
- en: 'ESSENTIAL INFO To keep dependencies on monitor.statisticsintact, it can be
    turned into an aggregator module. Move all code into the new modules, and edit
    the module declaration of monitor.statistics to require the new ones with the
    `transitive` keyword:'
  id: totrans-417
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 为了保持对 monitor.statistics 的依赖关系不变，它可以被转换为一个聚合器模块。将所有代码移动到新的模块中，并编辑
    monitor.statistics 模块的声明，使用 `transitive` 关键字要求新的模块：'
- en: '`module monitor.statistics { requires transitive monitor.statistics.averages;
    requires transitive monitor.statistics.medians; requires transitive monitor.statistics.percentiles;
    }`'
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.statistics { requires transitive monitor.statistics.averages;
    requires transitive monitor.statistics.medians; requires transitive monitor.statistics.percentiles;
    }`'
- en: 'See [figure 11.6](part0026.html#filepos1397878) to picture this decomposition.
    This is a good opportunity to reiterate the transitive nature of implied readability:
    all modules depending on the hypothetical monitor.core module created in the previous
    example will read the new statistics modules as well, because monitor.core `requires
    transitive`monitor.statistics, and monitor.statistics`requires transitive` the
    new modules.'
  id: totrans-419
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看 [图 11.6](part0026.html#filepos1397878) 来了解这种分解。这是一个重申隐含可读性传递性质的好机会：所有依赖于上一个示例中创建的假设
    monitor.core 模块的模块都将读取新的统计模块，因为 monitor.core `requires transitive` monitor.statistics，而
    monitor.statistics `requires transitive` 新的模块。
- en: '![](../images/00120.jpeg)'
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00120.jpeg)'
- en: '[Figure 11.6](part0026.html#filepos1397693) Before refactoring, the statistics
    module contains a lot of functionality (left). It’s then decomposed into three
    smaller modules that contain all the code (right). To not mandate changes in modules
    depending on statistics, it isn’t removed, but is instead turned into an aggregator
    module that implies readability of the modules it was split into.'
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 11.6](part0026.html#filepos1397693) 在重构之前，统计模块包含了很多功能（左）。然后它被分解成三个更小的模块，包含所有代码（右）。为了不强制更改依赖于统计模块的模块，它没有被移除，而是转换成了一个聚合器模块，它暗示了被拆分的模块的可读性。'
- en: 'If you want clients to replace their dependency on the old module with more
    specific `requires` directives on the new ones, consider deprecating the aggregator:'
  id: totrans-422
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你希望客户端用更具体的 `requires` 指令替换对旧模块的依赖，考虑弃用聚合器：
- en: '`@Deprecated module my.shiny.aggregator { // ... }`'
  id: totrans-423
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`@Deprecated module my.shiny.aggregator { // ... }`'
- en: ESSENTIAL INFO The earlier warning about aggregator modules being a leaky abstraction
    fully applies. If users use a qualified export or open on the aggregator module,
    the new modules won’t benefit from it.
  id: totrans-424
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 关于聚合器模块是泄漏抽象的早期警告完全适用。如果用户在聚合器模块上使用有资格的导出或公开，新模块将不会从中受益。'
- en: 11.1.6 REFACTORING MODULES BY MERGING THEM
  id: totrans-425
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 11.1.6 通过合并模块重构模块
- en: 'Although probably less often than splitting up a module that has outgrown its
    roots, you may occasionally want to merge several modules into one. As before,
    removing the now-technically useless modules may break clients; and as before,
    you can use implied readability to fix that problem: keep the empty old modules
    around, and make sure the old module declaration has as its only line a `requires
    transitive` on the new module.'
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然可能不如拆分已经超出其根基的模块常见，但你偶尔可能想要将几个模块合并成一个。和之前一样，移除现在技术上无用的模块可能会破坏客户端；和之前一样，你可以使用隐含的可读性来解决这个问题：保留空的旧模块，并确保旧模块声明中只有一行是
    `requires transitive` 指令针对新模块。
- en: 'ESSENTIAL INFO Working on the ServiceMonitor application, you may realize that
    having a module per observer implementation is overkill, and you’d like to merge
    all the modules into monitor.observer. Moving the code from monitor.observer.alpha
    and monitor.observer.beta into monitor.observer is simple. To keep the parts of
    the application that directly require the implementation modules working without
    changes, you make them imply readability on the larger module:'
  id: totrans-427
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 在 ServiceMonitor 应用程序上工作，你可能会意识到每个观察器实现都有一个模块是过度的，你希望将所有模块合并到 monitor.observer
    中。将代码从 monitor.observer.alpha 和 monitor.observer.beta 移动到 monitor.observer 是简单的。为了保持直接需要实现模块的应用程序部分在无需更改的情况下工作，你使它们对更大的模块具有隐含的可读性：'
- en: '`@Deprecated module monitor.observer.alpha { requires transitive monitor.observer;
    }  @Deprecated module monitor.observer.beta { requires transitive monitor.observer;
    }`'
  id: totrans-428
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`@Deprecated module monitor.observer.alpha { requires transitive monitor.observer;
    }  @Deprecated module monitor.observer.beta { requires transitive monitor.observer;
    }`'
- en: You can see these modules in [figure 11.7](part0026.html#filepos1402597). You
    also deprecate them to push users toward updating their dependencies.
  id: totrans-429
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以在[图11.7](part0026.html#filepos1402597)中看到这些模块。你还可以弃用它们，以推动用户更新他们的依赖项。
- en: '![](../images/00024.jpeg)'
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00024.jpeg)'
- en: '[Figure 11.7](part0026.html#filepos1402412) Before refactoring, the observation
    code is shared between the three modules alpha, beta, and observer (left). Afterward,
    all functionality is in observer, and the hollowed modules alpha and beta imply
    readability on it in order to not require their clients to change (right).'
  id: totrans-431
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图11.7](part0026.html#filepos1402412) 在重构之前，观察代码在三个模块 alpha、beta 和 observer（左侧）之间共享。之后，所有功能都集中在
    observer 模块中，而空心的模块 alpha 和 beta 则暗示了对其的可读性，以避免要求其客户端进行更改（右侧）。'
- en: ESSENTIAL INFO Carefully consider this approach, though. It makes the smaller
    modules’ clients suddenly depend on something much larger than they originally
    bargained for. On top of that, keep the earlier warning in mind that aggregator
    modules are a leaky abstraction.
  id: totrans-432
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 虽然如此，仔细考虑这种方法。它使较小模块的客户端突然依赖于比他们最初期望的更大的东西。此外，记住之前关于聚合器模块是泄漏抽象的警告。'
- en: 11.2 Optional dependencies
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 11.2 可选依赖
- en: In section 3.2, you saw that the module system uses `requires` directives to
    implement reliable configuration by making sure dependencies are present at compile
    and run time. But as we discussed at the end of section 2.3, after looking at
    the ServiceMonitor application for the first time, this approach can be too inflexible.
  id: totrans-434
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 3.2 节中，你看到模块系统使用 `requires` 指令通过确保依赖项在编译和运行时存在来实现可靠的配置。但正如我们在 2.3 节末讨论的那样，在第一次查看
    ServiceMonitor 应用程序后，这种方法可能过于僵化。
- en: There are cases where code ends up using types that don’t have to be present
    at run time—they may be, but they don’t have to be. As it stands, the module system
    either requires them to be present at launch time (when you use a `requires` directive)
    or doesn’t allow access at all (when you don’t use it).
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时候代码最终会使用那些在运行时不必存在的类型——它们可能存在，但不必存在。目前，模块系统要么要求它们在启动时存在（当你使用 `requires` 指令时），要么完全不允许访问（当你不使用它时）。
- en: 'In this section, I’ll show you a couple of examples in which this strictness
    leads to problems. Then I’ll introduce the module system’s solution: optional
    dependencies. Coding against them isn’t trivial, though, so we’ll take a close
    look at that as well. By the end of this section, you’ll be able to code against
    modules that aren’t required to be present at run time. The branch `feature-optional-dependencies`
    in ServiceMonitor’s repository demonstrates how to use optional dependencies.'
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示几个例子，说明这种严格性会导致问题。然后我将介绍模块系统的解决方案：可选依赖项。尽管针对它们进行编码并不简单，但我们将仔细研究这一点。在本节结束时，您将能够针对不需要在运行时存在的模块进行编码。ServiceMonitor
    仓库中的 `feature-optional-dependencies` 分支展示了如何使用可选依赖项。
- en: 11.2.1 THE CONUNDRUM OF RELIABLE CONFIGURATION
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 11.2.1 可靠配置的难题
- en: Assume that there’s an advanced statistics library containing a stats.fancy
    module that can’t be present on the module path for each deployment of the ServiceMonitor
    application. (The reason is irrelevant, but let’s say it’s a licensing issue.)
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设有一个包含 stats.fancy 模块的先进统计库，这个模块不能在 ServiceMonitor 应用程序的每个部署中都存在于模块路径上。（原因无关紧要，但让我们假设它是一个许可问题。）
- en: You want to write code in monitor.statistics that uses types from the fancy
    module, but for that to work, you need to depend on it with a `requires` directive.
    But if you do that, the module system wouldn’t let the application launch if stats.fancy
    isn’t present. [Figure 11.8](part0026.html#filepos1408818) shows this deadlock.
    (If this case seems familiar, it’s because we looked at it before from another
    angle. I’ll tell you where when we come full circle in a few minutes.)
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您想在 monitor.statistics 中编写使用 fancy 模块类型的代码，但要使其工作，您需要使用 `requires` 指令来依赖它。但如果你这样做，如果
    stats.fancy 不存在，模块系统就不会让应用程序启动。[图 11.8](part0026.html#filepos1408818) 展示了这个死锁。（如果这个情况看起来很熟悉，那是因为我们之前从另一个角度看过它。几分钟后，我会告诉你具体位置。）
- en: '![](../images/00058.jpeg)'
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00058.jpeg)'
- en: '[Figure 11.8](part0026.html#filepos1408332) The conundrum of reliable configuration:
    either the module system doesn’t grant statistics access to stats.fancy because
    statistics doesn’t require the access (left), or statistics does require access,
    which means stats.fancy must always be present for the application to launch (right).'
  id: totrans-441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 11.8](part0026.html#filepos1408332) 可靠配置的难题：要么模块系统没有授予 stats.fancy 统计访问权限，因为统计不需要访问权限（左），要么统计需要访问权限，这意味着
    stats.fancy 必须始终存在才能启动应用程序（右）。'
- en: Another example would be a utility library—let’s call it `uber.lib`—that integrates
    with a handful of other libraries. Its API offers functionality that builds on
    them and thus exposes their types. So far, that may make it look like an open-and-shut
    case for implied readability, as discussed in section 11.1, but things can be
    seen in another light.
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个例子是一个实用库——让我们称它为 `uber.lib`——它集成了几个其他库。它的 API 提供了基于它们的功能，因此暴露了它们的类型。到目前为止，这可能会让人认为这是一个显而易见的隐含可读性案例，如第
    11.1 节所述，但事情可以从另一个角度来看。
- en: Let’s play this through with the example of `com.google.common`, which `uber.lib`
    integrates with. The maintainers of `uber.lib` may assume that nobody who isn’t
    already using Guava is ever going to call the Guava portion of their library.
    This makes sense in certain cases. Why would you call a method in `uber.lib` that
    creates a nice report for a `com.google.common.graph.Graph` instance if you don’t
    have such a graph?
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们以 `uber.lib` 集成的 `com.google.common` 为例来演示这个过程。`uber.lib` 的维护者可能认为，任何没有使用
    Guava 的人永远不会调用他们库中的 Guava 部分。在某些情况下，这是有道理的。如果你没有这样的图，你为什么要调用 `uber.lib` 中创建一个漂亮的报告的
    `com.google.common.graph.Graph` 实例的方法呢？
- en: For `uber.lib`, that means it can function perfectly without `com.google.common`.
    If Guava makes it into the module graph, clients may call into that portion of
    the `uber.lib` API. If it doesn’t, they won’t, and the library will be fine as
    well. You can say that `uber.lib` never needs the dependency for its own sake.
  id: totrans-444
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于 `uber.lib`，这意味着它可以在不使用 `com.google.common` 的情况下完美运行。如果 Guava 进入模块图，客户端可能会调用
    `uber.lib` API 的那一部分。如果没有，它们就不会调用，库也会正常运行。你可以这样说，`uber.lib` 从不需要依赖它自己。
- en: With the features we’ve explored so far, such an optional relationship can’t
    be implemented. According to the readability and accessibility rules from chapter
    3, `uber.lib` has to require `com.google.common` to compile against its types
    and thus force all clients to always have Guava on the module path when launching
    their application.
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 运用我们迄今为止探索的功能，这样的可选关系无法实现。根据第3章的可读性和可访问性规则，`uber.lib` 必须要求 `com.google.common`
    来编译其类型，从而强制所有客户端在启动应用程序时始终在模块路径上拥有 Guava。
- en: If `uber.lib` integrates with a handful of libraries, it would make clients
    depend on all of them even though they may never use more than one. That’s not
    a nice move from `uber.lib`, so its maintainers will be looking for a way to mark
    their dependencies as being optional at run time. As the next section shows, the
    module system has them covered.
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 `uber.lib` 集成了一小部分库，它将使客户端依赖所有这些库，即使他们可能永远不会使用超过一个。这不是 `uber.lib` 的好做法，因此其维护者将寻找一种方法来标记他们的依赖项在运行时为可选。正如下一节所示，模块系统已经为他们提供了解决方案。
- en: NOTE Build tools also know such optional dependencies. In Maven, you set a dependency’s
    `<optional>` tag to `true`; in Gradle, you list them under `compileOnly`.
  id: totrans-447
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：构建工具也了解这样的可选依赖。在 Maven 中，你将依赖项的 `<optional>` 标签设置为 `true`；在 Gradle 中，你将它们列在
    `compileOnly` 下。
- en: '11.2.2 THE STATIC MODIFIER: MARKING DEPENDENCIES AS OPTIONAL'
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 11.2.2 静态修饰符：将依赖项标记为可选
- en: 'When a module needs to be compiled against types from another module but doesn’t
    want to depend on it at run time, you can use a `requires static`directive to
    establish this optional dependency. For two modules depending and optional, where
    depending’s declaration contains the line `requires static optional`, the module
    system behaves differently at compile and launch time:'
  id: totrans-449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当一个模块需要针对另一个模块的类型进行编译，但又不希望在运行时依赖它时，可以使用 `requires static` 指令来建立这种可选依赖。对于两个依赖和可选的模块，其中依赖的声明包含
    `requires static optional` 这一行，模块系统在编译和启动时表现不同：
- en: At compile time, optional must be present or there will be an error. During
    compilation, optional is readable by depending.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译时，可选必须存在，否则将出现错误。在编译期间，可选对依赖项是可读的。
- en: At launch time, optional may be absent, and that will cause neither an error
    nor a warning. If it’s present, it’s readable by depending.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动时，可选可能不存在，这既不会导致错误也不会导致警告。如果存在，它对依赖项是可读的。
- en: '[Table 11.1](part0026.html#filepos1417329) compares this behavior with a regular
    `requires` directive. Note that although the module system doesn’t issue an error,
    the runtime still may. Optional dependencies make runtime errors like `NoClassDefFoundError`
    much more likely because classes that a module was compiled against can be missing.
    In section 11.2.4, you’ll see code that prepares for that eventuality.'
  id: totrans-452
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[表11.1](part0026.html#filepos1417329) 比较了这种行为与常规 `requires` 指令。请注意，尽管模块系统不会发出错误，但运行时仍然可能会。可选依赖使得运行时错误，如
    `NoClassDefFoundError`，更加可能，因为模块编译时可能缺少类。在第11.2.4节中，您将看到为这种情况做准备的代码。'
- en: Table 11.1 A comparison of how `requires` and `requires static` behave at compile
    and launch time for present and missing dependencies. The only difference lies
    in how they treat missing dependencies at launch time (far-right column).
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表11.1 比较 `requires` 和 `requires static` 在编译和启动时对现有和缺失依赖项的行为。唯一的区别在于它们在启动时如何处理缺失依赖项（最右侧列）。
- en: '|    | Dependency present   | Dependency missing   |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '|    | 依赖项存在   | 依赖项缺失   |'
- en: '|    | Compile time   | Launch time   | Compile time   | Launch time   |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '|    | 编译时   | 启动时   | 编译时   | 启动时   |'
- en: '| `requires`   | Reads   | Reads   | Error   | Error   |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| `requires`   | 读取   | 读取   | 错误   | 错误   |'
- en: '| `requires static`   | Reads   | Reads   | Error   | Ignores   |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| `requires static`   | 读取   | 读取   | 错误   | 忽略   |'
- en: 'As an example, let’s create an optional dependency from monitor.statistics
    to stats.fancy. For that, you use a `requires static` directive:'
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以一个例子，让我们创建一个从 `monitor.statistics` 到 `stats.fancy` 的可选依赖。为此，你使用 `requires static`
    指令：
- en: '`module monitor.statistics { requires monitor.observer; requires static stats.fancy;
    exports monitor.statistics; }`'
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.statistics { requires monitor.observer; requires static stats.fancy;
    exports monitor.statistics; }`'
- en: 'If stats.fancy is missing during compilation, you get an error when the module
    declaration is compiled:'
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果在编译时缺少 `stats.fancy`，则在模块声明编译时会出现错误：
- en: '`> monitor.statistics/src/main/java/module-info.java:3: > error: module not
    found: stats.fancy > requires static stats.fancy; > ^ > 1 error`'
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> monitor.statistics/src/main/java/module-info.java:3: > error: module not
    found: stats.fancy > requires static stats.fancy; > ^ > 1 error`'
- en: At launch time, on the other hand, the module system doesn’t care whether stats.fancy
    is present.
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一方面，在启动时，模块系统并不关心stats.fancy是否存在。
- en: 'The module descriptor for uber.lib declares all dependencies as optional:'
  id: totrans-463
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: uber.lib的模块描述符将所有依赖项声明为可选：
- en: '`module uber.lib { requires static com.google.common; requires static org.apache.commons.lang;
    requires static org.apache.commons.io; requires static io.vavr; requires static
    com.aol.cyclops; }`'
  id: totrans-464
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module uber.lib { requires static com.google.common; requires static org.apache.commons.lang;
    requires static org.apache.commons.io; requires static io.vavr; requires static
    com.aol.cyclops; }`'
- en: 'Now that you know how to declare optional dependencies, two questions remain
    to be answered:'
  id: totrans-465
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何声明可选依赖，但还有两个问题需要回答：
- en: Under what circumstances will the dependency be present?
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在什么情况下依赖项会存在？
- en: How can you code against an optional dependency?
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何针对可选依赖进行编码？
- en: We’ll answer both questions next, and when we’re finished, you’re all set to
    use this handy feature.
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将在下文中回答这两个问题，完成之后，你们都将准备好使用这个方便的功能。
- en: 11.2.3 MODULE RESOLUTION OF OPTIONAL DEPENDENCIES
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 11.2.3 可选依赖项的模块解析
- en: 'As discussed in section 3.4.1, module resolution is the process that, given
    an initial module and a universe of observable modules, builds a module graph
    by resolving `requires` directives. When a module is being resolved, all modules
    it requires must be observable. If they are, they’re added to the module graph;
    otherwise, an error occurs. A little later I wrote this about the graph:'
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如第3.4.1节所述，模块解析是一个过程，给定一个初始模块和一组可观察的模块，通过解析`requires`指令来构建模块图。当一个模块正在解析时，它所需要的所有模块都必须是可观察的。如果它们是，它们将被添加到模块图中；否则，将发生错误。稍后我这样描述了这个图：
- en: It’s important to note that modules that did not make it into the module graph
    during resolution aren’t available later during compilation or execution, either.
  id: totrans-471
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的是要注意，在解析期间没有进入模块图的模块在编译或执行期间也不可用。
- en: ESSENTIAL INFO At compile time, module resolution handles optional dependencies
    like regular dependencies. At launch time, on the other hand, `requires static`
    directives are mostly ignored. When the module system encounters one, it doesn’t
    try to fulfill it, meaning it doesn’t even check whether the named module is observable.
  id: totrans-472
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ESSENTIAL INFO 在编译时，模块解析像常规依赖项一样处理可选依赖。另一方面，在启动时，`requires static`指令大多被忽略。当模块系统遇到一个时，它不会尝试满足它，这意味着它甚至不会检查是否有名为该模块的可观察模块。
- en: As a consequence, even if a module is present on the module path (or in the
    JDK, for that matter), it won’t be added to the module graph because of an optional
    dependency. It will only make it into the graph if it’s also a regular dependency
    of some other module that’s being resolved or because it was added explicitly
    with the command-line option `--add-modules`, as described in section 3.4.3\.
    [Figure 11.9](part0026.html#filepos1430459) illustrates both behaviors, using
    the option to ensure the presence of the optional dependency.
  id: totrans-473
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，即使一个模块存在于模块路径上（或者对于JDK来说也是如此），由于可选依赖的存在，它也不会被添加到模块图中。只有当它也是正在解析的其他模块的常规依赖项，或者因为它被明确地通过命令行选项`--add-modules`添加，正如第3.4.3节所述时，它才会进入图。图11.9[Figure
    11.9](part0026.html#filepos1430459)展示了这两种行为，使用该选项确保可选依赖的存在。
- en: 'This is where we come full circle. The first time I mentioned a fancy statistics
    library was in the section when I explained why it may sometimes be necessary
    to explicitly add a module to the module graph. I didn’t talk about optional dependencies
    in particular (and this isn’t the only use case for that option), but the general
    idea was the same as now: the fancy statistics module isn’t strictly required
    and hence isn’t automatically added to the module graph. If you want to have it
    in there, you must use the `--add-modules` option—either naming the specific module
    or using `ALL-MODULE-PATH`.'
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这就是我们的循环。我第一次提到这个花哨的统计库是在解释为什么有时有必要明确地将模块添加到模块图中时。我没有特别提到可选依赖（这并不是该选项的唯一用例），但总体想法与现在相同：花哨的统计模块不是严格必需的，因此不会自动添加到模块图中。如果你想让它在那里，你必须使用`--add-modules`选项——要么命名特定的模块，要么使用`ALL-MODULE-PATH`。
- en: '![](../images/00001.jpeg)'
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00001.jpeg)'
- en: '[Figure 11.9](part0026.html#filepos1429156) Both sides show similar situations.
    Both cases involve three modules A, B, and C, where A strictly depends on B and
    optionally depends on C. At left, A is the initial module, leading to a module
    graph without C because optional dependencies aren’t resolved. At right, C was
    forced into the graph with the use of the command-line option `--add-modules`,
    making it the second root module. It’s hence resolved and readable by A.'
  id: totrans-476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图11.9](part0026.html#filepos1429156) 两边显示了类似的情况。这两种情况都涉及三个模块A、B和C，其中A严格依赖于B，并且可选地依赖于C。在左边，A是初始模块，由于可选依赖没有被解析，所以没有C的模块图。在右边，使用命令行选项`--add-modules`将C强制加入到图中，使其成为第二个根模块。因此，它被解析并且可以被A读取。'
- en: Maybe you tripped over the phrase that during module resolution, optional dependencies
    “are mostly ignored.” Why mostly? Well, if an optional dependency makes it into
    a graph, the module systems adds a reads edge. So if the fancy statistics module
    is in the graph (maybe due to a regular `requires`, maybe due to an `--add-modules`),
    any module optionally depending on it can read it. This ensures that its types
    can be accessed straight away.
  id: totrans-477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可能你注意到了这样一个短语：在模块解析过程中，可选依赖“通常被忽略”。为什么是“通常”？好吧，如果一个可选依赖被加入到图中，模块系统会添加一个读取边。所以如果花哨的统计模块在图中（可能是因为常规的`requires`，也可能是因为使用了`--add-modules`），任何可选依赖它的模块都可以读取它。这确保了它的类型可以立即访问。
- en: 11.2.4 CODING AGAINST OPTIONAL DEPENDENCIES
  id: totrans-478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 11.2.4 针对可选依赖的编码
- en: 'Optional dependencies require a little more thought when you’re writing code
    against them, because this is what happens when monitor.statistics uses types
    in stats.fancy but the module isn’t present at run time:'
  id: totrans-479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你编写针对这些可选依赖的代码时，需要稍微多想一点，因为这是当`monitor.statistics`使用`stats.fancy`中的类型但模块在运行时不存在时发生的情况：
- en: '`Exception in thread "main" java.lang.NoClassDefFoundError: stats/fancy/FancyStats
    at monitor.statistics/monitor.statistics.Statistician .<init>(Statistician.java:15)
    at monitor/monitor.Main.createMonitor(Main.java:42) at monitor/monitor.Main.main(Main.java:22)
    Caused by: java.lang.ClassNotFoundException: stats.fancy.FancyStats ... many more`'
  id: totrans-480
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Exception in thread "main" java.lang.NoClassDefFoundError: stats/fancy/FancyStats
    at monitor.statistics/monitor.statistics.Statistician.<init>(Statistician.java:15)
    at monitor/monitor.Main.createMonitor(Main.java:42) at monitor/monitor.Main.main(Main.java:22)
    Caused by: java.lang.ClassNotFoundException: stats.fancy.FancyStats ... 更多`'
- en: Oops. You usually don’t want your code to do that.
  id: totrans-481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哎呀。你通常不希望你的代码这样做。
- en: Generally speaking, when the code that’s currently being executed references
    a type, the JVM checks whether it’s already loaded. If not, it tells the class
    loader to do that; and if that fails, the result is a `NoClassDefFoundError`,
    which usually crashes the application or at least fails out of the chunk of logic
    that was being executed.
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一般而言，当当前正在执行的代码引用一个类型时，JVM会检查它是否已经被加载。如果没有，它会告诉类加载器去加载；如果失败了，结果就是`NoClassDefFoundError`，这通常会导致应用程序崩溃或者至少导致正在执行的逻辑块失败。
- en: This is something JAR hell was famous for (see section 1.3.1). The module system
    wants to overcome that problem by checking declared dependencies when launching
    an application. But with `requires static`, you opt out of that check, which means
    you can end up with a `NoClassDefFoundError` after all. What can you do against
    that?
  id: totrans-483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这正是JAR地狱臭名昭著的原因（参见1.3.1节）。模块系统希望通过在启动应用程序时检查声明的依赖来克服这个问题。但是，使用`requires static`，你选择退出这个检查，这意味着最终你可能会遇到`NoClassDefFoundError`。对此你能做什么呢？
- en: Before looking into solutions, you need to see whether you really have a problem.
    In the case of `uber.lib`, you expect to use types from an optional dependency
    only if the code calling into the library already uses them, meaning class loading
    already succeeded. In other words, when `uber.lib` is called, all required dependencies
    must be present or the call wouldn’t have been possible. So you don’t have a problem
    after all, and you don’t need to do anything. [Figure 11.10](part0026.html#filepos1437537)
    illustrates this case.
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在探讨解决方案之前，你需要确认你是否真的遇到了问题。在`uber.lib`的情况下，你只期望在调用库的代码已经使用这些类型的情况下使用可选依赖的类型，这意味着类加载已经成功。换句话说，当调用`uber.lib`时，所有必需的依赖都必须存在，否则调用不可能发生。所以你实际上没有问题，不需要做任何事情。[图11.10](part0026.html#filepos1437537)说明了这种情况。
- en: '![](../images/00118.jpeg)'
  id: totrans-485
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00118.jpeg)'
- en: '[Figure 11.10](part0026.html#filepos1437202) By assumption, calling `uber.lib`
    only makes sense when clients already use types from the optional dependency.
    As a consequence, all execution paths (squiggly lines) that rely on the optional
    dependency being available for `uber.lib` (top two) have already passed through
    client code that also relied on that dependency (striped areas). If that didn’t
    fail, `uber.lib` won’t fail, either.'
  id: totrans-486
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![图11.10](part0026.html#filepos1437202) 假设，只有在客户端已经使用可选依赖项中的类型时调用`uber.lib`才有意义。因此，所有依赖于可选依赖项对`uber.lib`可用的执行路径（顶部两个）都已经通过了依赖于该依赖项的客户端代码（条纹区域）。如果那没有失败，`uber.lib`也不会失败。'
- en: The general case is different, though, as shown in [figure 11.11](part0026.html#filepos1439393).
    It may well be the module with the optional dependency that first tries to load
    classes from a dependency that might not be present so the risk of a `NoClassDefFoundError`
    is very real.
  id: totrans-487
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，一般情况是不同的，如图11.11所示。可能正是具有可选依赖项的模块首先尝试从可能不存在的依赖项中加载类，因此`NoClassDefFoundError`的风险是非常真实的。
- en: '![](../images/00079.jpeg)'
  id: totrans-488
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00079.jpeg)'
- en: '[Figure 11.11](part0026.html#filepos1438791) In the general case, it isn’t
    guaranteed that the client code calling a module like statistics has already established
    the optional dependency. In that case, execution paths (squiggly lines) may first
    encounter the dependency in the statistics module (striped area) and will fail
    if the optional dependency is absent.'
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![图11.11](part0026.html#filepos1438791) 在一般情况下，不能保证调用像统计这样的模块的客户端代码已经建立了可选依赖项。在这种情况下，执行路径（波浪线）可能首先在统计模块（条纹区域）中遇到依赖项，如果可选依赖项不存在，则将失败。'
- en: ESSENTIAL INFO One solution for this is to make sure all possible calls into
    the module with the optional dependency have to go through a checkpoint before
    accessing the dependency. As shown in [figure 11.12](part0026.html#filepos1441106),
    that checkpoint has to evaluate whether the dependency is present and send all
    code that arrives at it down a different execution path if it isn’t.
  id: totrans-490
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 一个解决方案是确保所有可能调用具有可选依赖项的模块的调用都必须在访问依赖项之前通过检查点。如图11.12所示，该检查点必须评估依赖项是否存在，如果不存在，则将到达它的所有代码发送到不同的执行路径。'
- en: '![](../images/00057.jpeg)'
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00057.jpeg)'
- en: '[Figure 11.12](part0026.html#filepos1440921) To ensure that a module like statistics,
    which has an optional dependency, is stable regardless of that dependency’s presence,
    checkpoints are required. Based on whether the dependency is present, the code
    branches execution paths (squiggly lines) either into code that uses that dependency
    (striped area) or into other code that doesn’t.'
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![图11.12](part0026.html#filepos1440921) 为了确保像统计这样的模块，它有一个可选的依赖项，无论该依赖项是否存在都能保持稳定，需要检查点。根据依赖项是否存在，代码会根据执行路径（波浪线）分支到使用该依赖项的代码（条纹区域）或到其他不使用该依赖项的代码。'
- en: 'The module system offers an API to check whether a module is present. I won’t
    go into details of how it works yet, because you lack some of the prerequisites
    that you need to understand the code. So you’ll have to wait for (or skip ahead
    to) section 12.4.2 to see for yourself that a utility method like the following
    can be implemented:'
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块系统提供了一个API来检查模块是否存在。我目前不会深入讲解它是如何工作的，因为您缺少理解代码所需的一些先决条件。所以您需要等待（或跳到）第12.4.2节，亲自查看以下类似实用方法是如何实现的：
- en: '`public static boolean isModulePresent(String moduleName) { // ... }`'
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public static boolean isModulePresent(String moduleName) { // ... }`'
- en: Calling this method with an argument like `"stats.fancy"` will return whether
    that module is present. If called with the name of a regular dependency (simple
    `requires` directive), the result will always be `true` because otherwise the
    module system wouldn’t have let the application launch.
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用类似`"stats.fancy"`这样的参数调用此方法将返回该模块是否存在。如果使用常规依赖项的名称（简单的`requires`指令）调用，结果始终为`true`，因为否则模块系统不会允许应用程序启动。
- en: If called with the name of an optional dependency (`requires static` directive),
    the result will be either `true` or `false`. If an optional dependency is present,
    the module system established readability, so it’s safe to go down an execution
    path that uses types from the module. If an optional dependency is absent, choosing
    such a path will lead to a `NoClassDefFoundError`, so a different one has to be
    found.
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果使用可选依赖项的名称（`requires static`指令），结果将是`true`或`false`。如果存在可选依赖项，模块系统建立了可读性，因此可以安全地走一个使用模块中类型的执行路径。如果不存在可选依赖项，选择这样的路径将导致`NoClassDefFoundError`，因此必须找到另一个路径。
- en: '11.3 Qualified exports: Limiting accessibility to specific modules'
  id: totrans-497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 11.3 合格导出：限制对特定模块的访问
- en: Whereas the previous two sections show how to refine dependencies, this one
    introduces a mechanism that allows a finer API design. As discussed in section
    3.3, a module’s public API is defined by exporting packages with `exports` directives,
    in which case every module reading the exporting one can access all public types
    in those packages at compile and at run time. This lies at the heart of strong
    encapsulation, which section 3.3.1 explains in depth.
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 而前两个部分展示了如何细化依赖项，这一部分介绍了一种允许更精细API设计的机制。如第3.3节所述，模块的公共API是通过使用`exports`指令导出包来定义的，在这种情况下，每个读取导出模块的模块都可以在编译和运行时访问这些包中的所有公共类型。这是强封装的核心，第3.3.1节对此进行了深入解释。
- en: 'With what we’ve discussed so far, you have to choose between strongly encapsulating
    a package or making it accessible to everybody all the time. To handle use cases
    that don’t easily fit into that dichotomy, the module system offers two less-candid
    ways to export a package: qualified exports, which we’ll look at now; and open
    packages, which section 12.2 introduces, because they’re related to reflection.
    As before, I’ll start with examples before introducing the mechanism. By the end
    of this section, you’ll be able to more precisely expose APIs than is possible
    with regular `exports` directives. Look at the branch `feature-qualified-exports`
    in ServiceMonitor’s repository to see how qualified exports pan out.'
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的内容要求你在强封装一个包或始终使其对所有人都可访问之间做出选择。为了处理那些不容易适应这种二分法的用例，模块系统提供了两种不那么坦率的导出包的方式：合格导出，我们现在将探讨；以及开放包，第12.2节将介绍，因为它们与反射有关。和以前一样，我将先通过例子介绍机制。在本节结束时，你将能够比使用常规`exports`指令更精确地暴露API。查看ServiceMonitor存储库中的`feature-qualified-exports`分支，以了解合格导出的实际应用。
- en: 11.3.1 EXPOSING INTERNAL APIS
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 11.3.1 展示内部API
- en: The best examples showing that `exports` directives can be too general come
    from the JDK. As you saw in section 7.1, only one platform module exports a `sun.*`
    package and few export `com.sun.*` packages. But does that mean all other packages
    are only used within the module they’re declared in?
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最好的例子表明`exports`指令可能过于通用，来自JDK。如你在第7.1节所见，只有一个平台模块导出`sun.*`包，而很少有模块导出`com.sun.*`包。但这是否意味着所有其他包都只在其声明的模块中使用？
- en: 'Far from it! Many packages are shared among modules. Here are some examples:'
  id: totrans-502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 远非如此！许多包在模块间共享。以下是一些例子：
- en: Internals of the base module java.base are used all over the place. For example,
    java.sql (providing the Java Database ConnectivityAPI [JDBC]) uses `jdk.internal.misc`,
    `jdk.internal.reflect`, and `sun.reflect.misc`. Security-relevant packages like
    `sun.security.provider` and `sun.security.action` are used by java.rmi (Remote
    Method Invocation API [RMI]) or java.desktop (AWT and Swing user interface toolkits,
    plus accessibility, multimedia, and JavaBeans APIs).
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础模块java.base的内部结构被广泛使用。例如，java.sql（提供Java数据库连接API [JDBC]）使用了`jdk.internal.misc`、`jdk.internal.reflect`和`sun.reflect.misc`。与安全相关的包，如`sun.security.provider`和`sun.security.action`，被java.rmi（远程方法调用API
    [RMI]）或java.desktop（AWT和Swing用户界面工具包，以及可访问性、多媒体和JavaBeans API）使用。
- en: The java.xml module defines the Java API for XML Processing (JAXP), which includes
    the Streaming API for XML (StAX), the Simple API for XML (SAX), and the W3C Document
    Object Model (DOM) API. Six of its internal packages (mostly prefixed with `com.sun.org.apache.xml`
    and `com.sun.org.apache.xpath`) are used by java.xml.crypto (API for XML cryptography).
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.xml模块定义了Java XML处理API（JAXP），它包括XML流式API（StAX）、简单XML API（SAX）和W3C文档对象模型（DOM）API。其六个内部包（大多数以`com.sun.org.apache.xml`和`com.sun.org.apache.xpath`为前缀）被java.xml.crypto（XML加密API）使用。
- en: Many JavaFX modules access internal packages of javafx.graphics (mostly `com.sun.javafx.*`),
    which in turn uses `com.sun.javafx.embed.swing` from javafx.swing (integrating
    JavaFX and Swing), which in turn uses seven internal packages from java.desktop
    (like `sun.awt` and `sun.swing`), which …
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多JavaFX模块访问javafx.graphics的内部包（主要是`com.sun.javafx.*`），而javafx.graphics反过来又使用javafx.swing中的`com.sun.javafx.embed.swing`（集成JavaFX和Swing），而javafx.swing反过来又使用java.desktop的七个内部包（如`sun.awt`和`sun.swing`），以此类推...
- en: 'I could go on, but I’m sure you get my point. This poses a question, though:
    how does the JDK share these packages among its modules without exporting them
    to everybody else?'
  id: totrans-506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我可以继续说，但我相信你已经明白了我的意思。然而，这提出了一个问题：JDK是如何在没有将其导出到其他所有人的情况下，在其模块之间共享这些包的？
- en: Although the JDK surely has the strongest use case for a more targeted export
    mechanism, it isn’t the only one. This situation occurs every time a set of modules
    wants to share functionality between them without exposing it. This can be the
    case for a library, a framework, or even a subset of modules from a larger application.
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然JDK确实有更针对性的导出机制的最强用例，但它并不是唯一的。每当一组模块想要在不暴露的情况下相互共享功能时，这种情况就会发生。这可能是一个库、一个框架，甚至是一个大型应用程序模块集的子集。
- en: This is symmetrical to the problem of hiding utility classes before the module
    system was introduced. As soon as a utility class has to be available across packages,
    it has to be public; but before Java 9, that meant all code running in the same
    JVM could access it. Now you’re up against the case that you want to hide a utility
    package, but as soon as it has to be available across modules, it must be exported
    and can thus be accessed by all modules running in the same JVM—at least with
    the mechanisms you’ve used so far. [Figure 11.13](part0026.html#filepos1451588)
    illustrates this symmetry.
  id: totrans-508
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这与在模块系统引入之前隐藏实用类的问题是对称的。一旦实用类需要在包之间可用，它就必须是公开的；但在Java 9之前，这意味着所有在同一个JVM中运行的代码都可以访问它。现在你面临的情况是你想隐藏一个实用包，但一旦它需要在模块之间可用，它就必须被导出，因此可以被同一JVM中运行的所有模块访问——至少到目前为止你所使用的机制是这样的。[图11.13](part0026.html#filepos1451588)说明了这种对称性。
- en: '![](../images/00111.jpeg)'
  id: totrans-509
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00111.jpeg)'
- en: '[Figure 11.13](part0026.html#filepos1451242) (Left) The situation before Java
    9, where as soon as a type is public (like `FancyUtil` in package `util`), it
    can be accessed by all other code. (Right) A similar situation with modules, but
    on a higher level, where as soon as a package is exported (like `util` in `utils.fancy`),
    it’s accessible to all other modules.'
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图11.13](part0026.html#filepos1451242)（左）Java 9之前的状况，一旦类型是公开的（如`util`包中的`FancyUtil`），它就可以被所有其他代码访问。（右）模块的类似情况，但处于更高的层面，一旦包被导出（如`utils.fancy`中的`util`），它就可以被所有其他模块访问。'
- en: 11.3.2 EXPORTING PACKAGES TO MODULES
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 11.3.2 将包导出到模块
- en: The `exports`directive can be qualified by following it up with `to ${modules}`,
    where `${modules}` is a comma-separated list of module names (no placeholders
    are allowed). To the modules named in an `exports to` directive, the package will
    be exactly as accessible as with a regular `exports` directive. To all other modules,
    the package will be as strongly encapsulated as if there were no `exports` at
    all. This situation is shown in [figure 11.14](part0026.html#filepos1454385).
  id: totrans-512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`exports`指令可以通过跟在它后面加上`to ${modules}`来限定，其中`${modules}`是一个以逗号分隔的模块名称列表（不允许使用占位符）。对于在`exports
    to`指令中命名的模块，包的访问权限将与常规的`exports`指令完全相同。对于所有其他模块，包的封装性将像没有`exports`一样强。这种情况在[图11.14](part0026.html#filepos1454385)中显示。'
- en: '![](../images/00049.jpeg)'
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00049.jpeg)'
- en: '[Figure 11.14](part0026.html#filepos1454072) The module owner uses a qualified
    export to make the package `pack` accessible only to the privileged module. To
    privileged, it’s just as accessible as if a regular export were used; but other
    modules, like regular, can’t access it.'
  id: totrans-514
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图11.14](part0026.html#filepos1454072) 模块所有者使用限定导出来使包`pack`仅对特权模块可用。对于特权模块，它的访问权限与使用常规导出时一样；但其他模块，如常规模块，无法访问它。'
- en: As a hypothetical example, let’s say all observer implementations in the ServiceMonitor
    application need to share some utility code. The first question is where to put
    those types. All observers already depend on monitor.observer because it contains
    the ServiceObserver interface they implement, so why not put it there? Okay, they
    end up in the package `monitor.observer.utils`.
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为一个假设的例子，假设ServiceMonitor应用程序中的所有观察者实现都需要共享一些实用代码。第一个问题是把这些类型放在哪里。所有观察者已经依赖于monitor.observer，因为它包含了它们实现的ServiceObserver接口，所以为什么不把它放在那里呢？好吧，它们最终放在了包`monitor.observer.utils`中。
- en: 'Now comes the interesting part. Here’s the module declaration of monitor.observer
    that exports the new package only to the implementation modules:'
  id: totrans-516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接下来是有趣的部分。这是仅将新包导出到实现模块的monitor.observer模块声明：
- en: '`module monitor.observer { exports monitor.observer; exports monitor.observer.utils
    to monitor.observer.alpha, monitor.observer.beta; }`'
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.observer { exports monitor.observer; exports monitor.observer.utils
    to monitor.observer.alpha, monitor.observer.beta; }`'
- en: Whereas `monitor.observer` is exported to everybody, `monitor.observer.utils`
    will be accessible only by the modules monitor.observer.alpha and monitor.observer.beta.
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然`monitor.observer`对所有模块都进行了导出，但`monitor.observer.utils`将只能由monitor.observer.alpha和monitor.observer.beta模块访问。
- en: 'This example demonstrates two interesting details:'
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个例子展示了两个有趣的细节：
- en: 'The modules to which a package is exported can depend on the exporting module,
    creating a cycle. Thinking about it, unless implied readability is used, this
    must be the case: how else would the module to which a package is exported read
    the exporting one?'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被导出的包可以依赖于导出模块，从而形成一个循环。思考这个问题，除非使用了隐含的可读性，否则这必须是这种情况：否则，被导出包的模块如何读取导出模块？
- en: Whenever a new implementation wants to use the utilities, the API module needs
    to be changed, so it gives access to this new module. Although letting the exporting
    module control what can access the packages is kind of the whole point of qualified
    exports, it can still be cumbersome.
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当一个新的实现想要使用这些工具时，API模块需要被更改，以便它能够访问这个新模块。尽管让导出模块控制哪些模块可以访问包是合格导出的主要目的，但这仍然可能有些繁琐。
- en: 'As a real-world example, I’d like to show you the qualified exports that java.base
    declares—but there are 65 of them, so that would be a little overwhelming. Instead,
    let’s look at the module descriptor of java.xml with `java --describe-module java.xml`
    (as described in section 5.3.1):'
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为现实世界的例子，我想向您展示java.base声明的合格导出，但一共有65个，这可能会有些令人眼花缭乱。相反，让我们通过`java --describe-module
    java.xml`（如第5.3.1节所述）来查看java.xml的模块描述符：
- en: '`> module java.xml@9.0.4 # everything but qualified exports are truncated >
    qualified exports com.sun.org.apache.xml.internal.utils > to java.xml.crypto >
    qualified exports com.sun.org.apache.xpath.internal.compiler > to java.xml.crypto
    > qualified exports com.sun.xml.internal.stream.writers > to java.xml.ws > qualified
    exports com.sun.org.apache.xpath.internal > to java.xml.crypto > qualified exports
    com.sun.org.apache.xpath.internal.res > to java.xml.crypto > qualified exports
    com.sun.org.apache.xml.internal.dtm > to java.xml.crypto > qualified exports com.sun.org.apache.xpath.internal.functions
    > to java.xml.crypto > qualified exports com.sun.org.apache.xpath.internal.objects
    > to java.xml.crypto`'
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 模块java.xml@9.0.4 # 除了合格导出之外的所有内容都被截断 > 合格导出com.sun.org.apache.xml.internal.utils到java.xml.crypto
    > 合格导出com.sun.org.apache.xpath.internal.compiler到java.xml.crypto > 合格导出com.sun.xml.internal.stream.writers到java.xml.ws
    > 合格导出com.sun.org.apache.xpath.internal到java.xml.crypto > 合格导出com.sun.org.apache.xpath.internal.res到java.xml.crypto
    > 合格导出com.sun.org.apache.xml.internal.dtm到java.xml.crypto > 合格导出com.sun.org.apache.xpath.internal.functions到java.xml.crypto
    > 合格导出com.sun.org.apache.xpath.internal.objects到java.xml.crypto`'
- en: This shows that java.xml lets java.xml.cryptoand java.xml.ws use some of its
    internal APIs.
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这表明java.xml允许java.xml.crypto和java.xml.ws使用其一些内部API。
- en: 'Now that you know about qualified exports, I can clear up a small mystery that
    we left behind in section 5.3.6 when we analyzed the module system’s logs. There
    you saw messages like these:'
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在您已经了解了合格导出，我可以澄清我们在分析模块系统日志时留下的一个小谜团。在那里，您看到了如下信息：
- en: '`> Adding read from module java.xml to module java.base > package com/sun/org/apache/xpath/internal/functions
    in module java.xml > is exported to module java.xml.crypto > package javax/xml/datatype
    in module java.xml > is exported to all unnamed modules`'
  id: totrans-526
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 将从模块java.xml读取到模块java.base > 模块java.xml中的包com/sun/org/apache/xpath/internal/functions导出到模块java.xml.crypto
    > 模块java.xml中的包javax/xml/datatype导出到所有未命名的模块`'
- en: I didn’t explain why the log talks about exporting to a module, but with what
    we just discussed, that should be clear now. As you saw in the recent example,
    java.xml exports `com.sun.org.apache.xpath.internal.functions` to java.xml.crypto,
    which is exactly what the second message says. The third message exports `javax.xml.datatype`
    to “all unnamed modules,” which looks a little weird but is the module system’s
    way of saying that the package is exported without further qualification and hence
    is accessible to every module reading java.xml, including the unnamed module.
  id: totrans-527
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我没有解释为什么日志谈论的是导出到模块，但根据我们刚才讨论的，现在应该很清楚。正如你在最近的例子中看到的，java.xml导出`com.sun.org.apache.xpath.internal.functions`到java.xml.crypto，这正是第二条消息所说的。第三条消息将`javax.xml.datatype`导出到“所有未命名的模块”，这看起来有点奇怪，但这是模块系统表示该包未进一步限定导出，因此对读取java.xml的每个模块都可用，包括未命名的模块。
- en: 'ESSENTIAL INFO Finally, two small notes on compilation:'
  id: totrans-528
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**基本信息** 最后，关于编译的两个小贴士：'
- en: If a module that declares a qualified export is compiled and the target module
    isn’t present in the universe of observable modules, the compiler will issue a
    warning. It’s not an error because the target module is mentioned but not required.
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个声明了合格导出的模块被编译，而目标模块不在可观察模块的宇宙中，编译器将发出警告。这不是一个错误，因为目标模块被提及了，但不是必需的。
- en: It isn’t allowed to use a package in an `exports`and in an `exports to` directive.
    If both directives were present, the latter would be effectively useless, so this
    situation is interpreted as an implementation error and thus results in a compile
    error.
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`exports`和`exports to`指令中不允许使用一个包。如果两个指令都存在，后者将实际上是无用的，因此这种情况被解释为实现错误，因此导致编译错误。
- en: 11.3.3 WHEN TO USE QUALIFIED EXPORTS
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 11.3.3 **何时使用合格导出**
- en: A qualified export allows modules to share a package between them without making
    it available to all other modules in the same JVM. This makes qualified exports
    useful for libraries and frameworks that consist of several modules and want to
    share code without clients being able to use it. They will also come in handy
    for large applications that want to restrict dependencies on specific APIs.
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 合格导出允许模块之间共享一个包，而不会使其对所有同一JVM中的其他模块可用。这使得合格导出对于由多个模块组成且希望在不让客户端使用的情况下共享代码的库和框架非常有用。它们对于希望限制对特定API依赖的大型应用程序也非常有用。
- en: Qualified exports can be seen as lifting strong encapsulation from guarding
    types in artifacts to guarding packages in sets of modules. This is illustrated
    by [figure 11.15](part0026.html#filepos1465220).
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 合格导出可以看作是从保护工件中的类型到保护模块集合中的包的强封装的提升。这由[图11.15](part0026.html#filepos1465220)所示。
- en: '![](../images/00083.jpeg)'
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00083.jpeg)'
- en: '[Figure 11.15](part0026.html#filepos1464907) (Left) How a public type in a
    non-exported package can be accessed by other types in the same module but not
    by types from other modules. (Right) A similar situation, but on a higher level,
    where qualified exports are used to make a package in one module available to
    a defined set of modules while keeping it inaccessible to unprivileged ones.'
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![图11.15](part0026.html#filepos1464907)（左）一个非导出包中的公共类型如何被同一模块中的其他类型访问，但不能被其他模块的类型访问。（右）一个类似的情况，但处于更高的层面，其中合格导出被用来使一个模块中的包对一组定义的模块可用，同时使其对无权限的模块不可访问。'
- en: 'Say you’re designing a module. When should you favor qualified over unqualified
    exports? To answer that, we have to focus on the core benefit of qualifying exports:
    controlling who uses an API. Generally speaking, this becomes more important the
    further the package in question is from its clients.'
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你正在设计一个模块。你何时应该优先选择合格导出而不是无合格导出？为了回答这个问题，我们必须关注合格导出的核心好处：控制谁使用API。一般来说，当问题包与其客户端的距离越远时，这变得越重要。
- en: Suppose you have a small to medium-sized application made out of a handful of
    modules (not counting dependencies) that’s maintained by a small team and compiled
    and deployed all at once. In that case, it’s comparatively easy to control which
    module uses which API; and if something goes wrong, it’s easy to fix it because
    everything is under your control. In this scenario, the benefits of qualified
    exports have little impact.
  id: totrans-537
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你有一个由少量模块（不计依赖项）组成的小到中等规模的应用程序，由一个小团队维护，并且一次性编译和部署。在这种情况下，控制哪个模块使用哪个API相对容易；如果出现问题，由于一切都在你的控制之下，所以很容易修复。在这种情况下，合格导出的好处影响很小。
- en: At the other end of the spectrum is the JDK, which is used by literally every
    Java project in the world and has an extreme focus on backward compatibility.
    Having code “out there” depend on an internal API can be problematic and is hard
    to fix, so the need to control who accesses what is great.
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在光谱的另一端是JDK，它被世界上几乎每个Java项目使用，并且极端关注向后兼容性。代码“在外部”依赖于内部API可能会出现问题，并且难以修复，因此控制谁可以访问什么的需求很大。
- en: The most obvious line separating these two extremes is whether you can freely
    change the package’s clients. If you can, because you’re developing the module
    and all its client modules, regular exports are a good way to go. If you can’t,
    because you maintain a library or framework, only the API that you want clients
    to use and that you’re willing to maintain should be exported without qualification.
    Everything short of that, particularly internal utilities, should only be exported
    to your modules.
  id: totrans-539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 区分这两种极端的最明显的界限是您是否可以自由更改包的客户端。如果您可以，因为您正在开发该模块及其所有客户端模块，常规导出是一个不错的选择。如果您不能，因为您维护一个库或框架，那么只有您希望客户端使用并且愿意维护的API应该无条件地导出。所有其他内容，尤其是内部实用程序，应该仅导出到您的模块中。
- en: The line gets blurred in larger projects. If a big code base is maintained over
    years by a large team, you may technically be able to change all clients when
    doing so becomes necessary due to an API change, but it can be painful. In such
    cases, using qualified exports not only prevents accidental dependencies on internal
    packages, but also documents which clients an API was designed for.
  id: totrans-540
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在大型项目中，这条线变得模糊。如果一个大型代码库由一个大型团队在多年内维护，那么在API更改变得必要时，您可能技术上能够更改所有客户端，但这可能很痛苦。在这种情况下，使用有条件的导出不仅防止了意外依赖于内部包，而且还记录了API是为哪些客户端设计的。
- en: 11.3.4 EXPORTING PACKAGES ON THE COMMAND LINE
  id: totrans-541
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 11.3.4 命令行上的导出包
- en: What if the use of internal APIs wasn’t foreseen (or, more likely, wasn’t intended)
    at the time of writing? What if code absolutely has to access types the containing
    module doesn’t export, qualified or not? If the module system were adamant about
    these rules, many applications wouldn’t compile or launch on Java 9+; but if it
    were an easy way to circumvent strong encapsulation, it would hardly be “strong,”
    thus losing its benefits. Middle ground was found by defining command-line options
    that can be used as an escape hatch but are too cumbersome to become a ubiquitous
    fix.
  id: totrans-542
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果在编写时没有预见（或者更可能的是，没有打算）使用内部API，那会怎样？如果代码绝对必须访问包含模块未导出的类型，无论是合格的还是不合格的，那会怎样？如果模块系统坚决执行这些规则，许多应用程序在Java
    9+上可能无法编译或启动；但如果它是一个绕过强封装的简单方法，那么它几乎不会是“强”的，从而失去了其优势。通过定义可以作为逃生口但又不至于成为普遍解决方案的命令行选项，找到了中间地带。
- en: 'In addition to the `exports to` directive, there’s a command-line option with
    the exact same effect that can be applied to the compiler and runtime commands:
    with `--add-exports ${module}/${package}=${accessing-modules}`, the module system
    exports `${package}` of $module to all modules named in the comma-separated list
    `${accessing-modules}`>. If `ALL-UNNAMED` is among them, code from the unnamed
    module can also read that package.'
  id: totrans-543
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了`exports to`指令外，还有一个具有相同效果的命令行选项可以应用于编译器和运行时命令：使用`--add-exports ${module}/${package}=${accessing-modules}`，模块系统将$module的`${package}`导出到以逗号分隔的列表`${accessing-modules}`中命名的所有模块。如果其中包含`ALL-UNNAMED`，未命名的模块中的代码也可以读取该包。
- en: 'Normal accessibility rules as presented in section 3.3 apply—for a module to
    access a type this due to an `--add-exports` option, the following conditions
    must be fulfilled:'
  id: totrans-544
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正常的可访问性规则，如第3.3节所述，适用——对于由于`--add-exports`选项而需要访问类型的模块，必须满足以下条件：
- en: The type has to be public.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型必须是公开的。
- en: The type has to be in `${package}`.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型必须在`${package}`中。
- en: The module addressed in `${accessing-modules}` must read ${module}.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`${accessing-modules}`中指定的模块必须读取${module}。
- en: For `--add-exports` examples, flip back to sections 7.1.3 and 7.1.4, where you
    used it to gain access to internal APIs of platform modules at compile and run
    time. Like other command-line options, requiring `--add-exports` to be present
    for more than experiments is a maintainability problem; see section 9.1 for details.
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于`--add-exports`的示例，请翻回到7.1.3和7.1.4节，在那里您使用它来在编译和运行时访问平台模块的内部API。与其他命令行选项一样，要求`--add-exports`在实验之外存在是一个可维护性问题；请参阅9.1节以获取详细信息。
- en: Summary
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Implied readability:'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐含的可读性：
- en: With a `requires transitive` directive, a module makes its client read the thus-required
    module even though the module doesn’t explicitly depend on it. This allows the
    module to use types from dependencies in its API without putting the burden to
    manually require those dependencies on the client modules. As a consequence, the
    module becomes instantly usable.
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`requires transitive`指令，一个模块使其客户端读取因此所需的模块，即使该模块没有明确依赖它。这允许模块在其API中使用依赖项的类型，而无需将手动要求这些依赖项的负担放在客户端模块上。因此，该模块可以立即使用。
- en: A module should only rely on a transitive dependency being implicitly readable
    if it only uses it on the boundary to the respective direct dependency. As soon
    as the module starts using the transitive dependency to implement its own functionality,
    it should make it a direct dependency. This ensures that the module declaration
    reflects the true set of dependencies and makes the module more robust for refactorings
    that may remove the transitive dependency.
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个模块仅在边界上使用传递依赖项，那么它应该仅依赖于传递依赖项的隐含可读性。一旦模块开始使用传递依赖项来实现其自己的功能，它应该将其作为直接依赖项。这确保了模块声明反映了真实的依赖项集合，并使模块在可能删除传递依赖项的重构中更加健壮。
- en: Implied readability can be used when moving code between modules by having the
    modules that used to contain the code imply readability on the ones that do now.
    This lets clients access the code they depend on without requiring them to change
    their module descriptors, because they still end up reading the module that contains
    the code. Keeping compatibility like this is particularly interesting for libraries
    and frameworks.
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在模块之间移动代码时，可以通过使曾经包含代码的模块对现在包含代码的模块暗示可读性来使用隐含的可读性。这允许客户端访问他们依赖的代码，而无需要求他们更改他们的模块描述符，因为他们最终仍然会读取包含代码的模块。保持这种兼容性对库和框架尤其有趣。
- en: 'Optional dependencies:'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选依赖项：
- en: With a `requires static` directive, a module marks a dependency that the module
    system will ensure is present at compile time but can be absent at run time. This
    allows coding against modules without forcing clients to always have those modules
    in their application.
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`requires static`指令，一个模块标记了一个模块系统将确保在编译时存在但在运行时可以不存在的依赖项。这允许在不强制客户端始终在其应用程序中包含这些模块的情况下针对模块进行编码。
- en: At launch time, modules required only by `requires static` directives aren’t
    added to the module graph even if they’re observable. Instead, you have to add
    them manually with `--add-modules`.
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动时，仅由`requires static`指令要求的模块即使可观察也不会添加到模块图中。相反，您必须使用`--add-modules`手动添加它们。
- en: Coding against optional dependencies should involve making sure no execution
    path can fail due to the dependency missing, because this would severely undermine
    the module’s usability.
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对可选依赖项的编码应确保没有执行路径会因为依赖项缺失而失败，因为这会严重损害模块的可用性。
- en: 'Qualified exports:'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有资格的导出：
- en: With an `exports to` directive, a module makes a package accessible only to
    the named modules. This is a third and more targeted option between encapsulating
    a package and making it accessible for everybody.
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`exports to`指令，一个模块使一个包仅对命名的模块可访问。这是在封装包和使其对每个人可访问之间的一种第三种更具体的选择。
- en: Exporting to specific modules allows sharing code within a set of privileged
    modules without making it a public API. This reduces the API surface of a library
    or framework, thus improving maintainability.
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码导出到特定模块允许在一系列特权模块内共享代码，而不将其公开为公共API。这减少了库或框架的API表面积，从而提高了可维护性。
- en: With the `--add-exports` command-line option, you can export packages at compile
    and run time that the module’s developers intended as internal APIs. On the one
    hand, this keeps code running that depends on those internals; on the other hand,
    it introduces its own maintainability problems.
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--add-exports`命令行选项，您可以在编译和运行时导出模块的开发者打算作为内部API的包。一方面，这保留了依赖于这些内部代码的代码运行；另一方面，它引入了自己的可维护性问题。
- en: '12'
  id: totrans-562
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '12'
- en: Reflection in a modular world
  id: totrans-563
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块世界的反射
- en: This chapter covers
  id: totrans-564
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Opening packages and modules to reflection
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向反射开放包和模块
- en: Combining modules and reflection
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块和反射的组合
- en: Alternatives to the reflection API
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射API的替代方案
- en: Analyzing and modifying module properties
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析和修改模块属性
- en: If you’re working on a Java application, chances are good that you rely on Spring,
    Hibernate, JAXP, GSON, or the like. What are “the like”? Frameworks that use Java’s
    reflection API to inspect your code, search for annotations, instantiate objects,
    or call methods. Thanks to reflection, they can do all that without having to
    compile against your code.
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你正在开发一个 Java 应用程序，那么你很可能依赖于 Spring、Hibernate、JAXP、GSON 等框架。什么是“类似的东西”？这些是使用
    Java 的反射 API 来检查你的代码、搜索注解、实例化对象或调用方法的框架。多亏了反射，它们可以在不针对你的代码进行编译的情况下完成所有这些操作。
- en: Moreover, the reflection API allows frameworks to access nonpublic classes and
    nonpublic members. It has superpowers beyond what’s possible with compiled code,
    which bounces off of package boundaries if classes or members aren’t public. The
    thing is that with modules, reflection no longer works out of the box.
  id: totrans-570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，反射 API 允许框架访问非公共类和非公共成员。它具有超出编译代码可能性的超级能力，如果类或成员不是公共的，它会在包边界上反弹。问题是，随着模块的出现，反射不再自动工作。
- en: 'Quite the opposite: reflection lost its superpowers and is bound to the exact
    same accessibility rules as compiled code. It can only access public members of
    public classes in exported packages. These frameworks, on the other hand, use
    reflection over fields and methods that often aren’t public and on classes that
    you may not want to export because they aren’t part of a module’s API. What do
    you do then? That’s what this chapter is all about!'
  id: totrans-571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 恰恰相反：反射失去了它的超级能力，并且被绑定到与编译代码相同的精确可访问性规则。它只能访问导出包中公共类的公共成员。另一方面，这些框架使用反射来访问通常不是公共的属性和方法，以及你可能不希望导出的类，因为这些类不是模块
    API 的一部分。那么你该怎么办？这正是本章的主题！
- en: To get the most out of this chapter, you should
  id: totrans-572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了充分利用本章内容，你应该
- en: Have a basic understanding of how reflection works (otherwise, appendix B will
    bring you up to speed).
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对反射的工作原理有一个基本的理解（否则，附录 B 将帮助你跟上进度）。
- en: Know that every time you put an annotation somewhere, you’re marking that class
    for a framework to reflect over it (see [listing 12.1](part0027.html#filepos1480068)
    for a few examples).
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道每次你在某个地方放置一个注解，你实际上是在标记这个类供框架进行反射（参见 [列表 12.1](part0027.html#filepos1480068)
    以获取一些示例）。
- en: Understand the accessibility rules (as presented in section 3.3).
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解可访问性规则（如第 3.3 节所述）。
- en: Listing 12.1 Code snippets for reflection-based standards and frameworks
  id: totrans-576
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 12.1 基于反射的标准和框架的代码片段
- en: '`// JPA @Entity @Table(name = "user") public class Book {  @Id @GeneratedValue(strategy
    = GenerationType.SEQUENCE) @Column(name = "id", updatable = false, nullable =
    false) private Long id;  @Column(name = "title", nullable = false) private String
    title;  // [...]  }  // JAXB @XmlRootElement(name = "book") @XmlAccessorType(XmlAccessType.FIELD)
    public class Book {  @XmlElement private String title;  @XmlElement private String
    author;  // [...]  }  // SPRING @RestController public class BookController {  @RequestMapping(value
    = "*book*{id}", method = RequestMethod.GET) @ResponseBody public Book getBook(@PathVariable("id")
    long id) { // [...] }  // [...]  }`'
  id: totrans-577
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`// JPA @Entity @Table(name = "user") public class Book {  @Id @GeneratedValue(strategy
    = GenerationType.SEQUENCE) @Column(name = "id", updatable = false, nullable =
    false) private Long id;  @Column(name = "title", nullable = false) private String
    title;  // [...]  }  // JAXB @XmlRootElement(name = "book") @XmlAccessorType(XmlAccessType.FIELD)
    public class Book {  @XmlElement private String title;  @XmlElement private String
    author;  // [...]  }  // SPRING @RestController public class BookController {  @RequestMapping(value
    = "*book*{id}", method = RequestMethod.GET) @ResponseBody public Book getBook(@PathVariable("id")
    long id) { // [...] }  // [...]  }`'
- en: With that under your belt, you’ll learn why `exports` directives won’t take
    you far if you want to allow reflective access to your modules (section 12.1)
    and what you can do instead (section 12.2). (Note that this only applies to explicit
    modules—if your code runs from the class path, it isn’t encapsulated, so you don’t
    have to worry about any of this.)
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在掌握这些知识的基础上，你会了解到，如果你想要允许对模块进行反射访问（第 12.1 节），仅使用 `exports` 指令是远远不够的，以及你可以采取的其他措施（第
    12.2 节）。（请注意，这仅适用于显式模块——如果你的代码从类路径运行，它不是封装的，因此你不必担心这些问题。）
- en: 'But this chapter is about more than “just” preparing modules for reflection:
    it also covers the other side and discusses how to update reflecting code as well
    as alternatives and additions to the reflection API (section 12.3). It closes
    with how you can use layers to dynamically load modules at run time (section 12.4).
    (These two sections are written for developers who already had those use cases
    before Java 9, so they require more familiarity with reflection and class loaders
    than the rest of this chapter.)'
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但本章不仅仅关于“仅仅”为反射准备模块：它还涵盖了另一面，讨论了如何更新反射代码以及反射API的替代方案和补充（第12.3节）。它以如何使用层在运行时动态加载模块结束（第12.4节）。（这两个部分是为那些在Java
    9之前就已经有这些用例的开发者编写的，因此它们比本章的其余部分需要更多对反射和类加载器的熟悉。）
- en: By the time you’re done, you’ll know all about preparing your project for reflection
    in a modular world, no matter whether it’s the one being reflected or over or
    doing the reflection. You’ll also be able to use reflection to dynamically load
    code at run time, for example to implement a plugin-based application.
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 完成之后，你将了解如何在模块世界中为反射准备你的项目，无论它是被反射的、反射之上的还是执行反射。你还将能够使用反射在运行时动态加载代码，例如实现基于插件的程序。
- en: 12.1 Why exports directives aren’t a good fit for reflection
  id: totrans-581
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.1 为什么exports指令不适合反射
- en: 'Before we get into how to best prepare your code for reflection, it makes sense
    to discuss why the mechanism discussed so far for exposing classes, the `exports`
    directive (see section 3.3), isn’t a good fit. There are three reasons:'
  id: totrans-582
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在我们讨论如何最佳准备你的代码以进行反射之前，讨论到目前为止所讨论的用于公开类、`exports`指令（见第3.3节）的机制为何不适合是有意义的。有三个原因：
- en: It’s highly questionable whether classes designed to be used with such frameworks
    should be part of a module’s public API.
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否应该将设计用于与这样的框架一起使用的类包含在模块的公共API中，这是一个高度可疑的问题。
- en: Exporting those classes to a selected module can couple the module to an implementation
    instead of a standard.
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些类导出到选定的模块中可以将模块耦合到实现而不是标准。
- en: Exports don’t support deep reflection over nonprivate fields and methods.
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出不支持对非私有字段和方法的深度反射。
- en: We’ll look at each of these in turn after we discuss how things worked before
    the module system.
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在我们讨论模块系统之前的工作方式之后，我们将依次查看这些内容。
- en: 12.1.1 BREAKING INTO NON-MODULAR CODE
  id: totrans-587
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.1.1 打破非模块代码
- en: Let’s say you’ve successfully migrated your application to Java 9+, as described
    in chapters 6 and 7\. You didn’t modularize it yet, though, so you’re still running
    it from the class path. In that case, reflection over your code continues to work
    as in Java 8.
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你已经按照第6章和第7章的描述成功地将你的应用程序迁移到Java 9+，尽管如此，你还没有对其进行模块化，所以你仍然是从类路径上运行它。在这种情况下，对你的代码的反射仍然像在Java
    8中一样继续工作。
- en: Reflection-based frameworks will routinely create and modify instances of classes
    by accessing nonpublic types and members. Although it isn’t possible to compile
    code against package-visible or private elements, reflection allows you to use
    them after making them accessible. The following listing shows a hypothetical
    persistence framework that uses reflection to create an entity and assign an ID
    to a private field.
  id: totrans-589
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 基于反射的框架将常规地通过访问非公共类型和成员来创建和修改类的实例。尽管无法针对包可见或私有元素进行编译，但反射允许你在使其可访问后使用它们。以下列表显示了一个假设的持久化框架，该框架使用反射来创建一个实体并为私有字段分配一个ID。
- en: Listing 12.2 Using reflection
  id: totrans-590
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表12.2 使用反射
- en: '`Class<?> type = ...` [`①`](part0027.html#filepos1486635) `Constructor<?> constructor
    = entityType.getConstructor();` `constructor.setAccessible(true);` [`②`](part0027.html#filepos1486995)
    `Object entity = constructor.newInstance(); Field id = entity.getDeclaredField("id");`
    `id.setAccessible(true);` [`②`](part0027.html#filepos1486995) `id.set(entity,
    42);`'
  id: totrans-591
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Class<?> type = ...` [`①`](part0027.html#filepos1486635) `Constructor<?> constructor
    = entityType.getConstructor();` `constructor.setAccessible(true);` [`②`](part0027.html#filepos1486995)
    `Object entity = constructor.newInstance(); Field id = entity.getDeclaredField("id");`
    `id.setAccessible(true);` [`②`](part0027.html#filepos1486995) `id.set(entity,
    42);`'
- en: ①
  id: totrans-592
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Whatever the framework needs to do to get that class
  id: totrans-593
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无论框架需要做什么来获取那个类
- en: ②
  id: totrans-594
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Makes the possibly private constructor and field accessible for the following
    calls
  id: totrans-595
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使可能私有的构造函数和字段对以下调用可访问
- en: Now imagine the application gets modularized, and suddenly there’s a module
    boundary between your code and those frameworks. What options does the module
    system, and particularly the `exports` directives, leave you with for making your
    internal types accessible?
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在想象一下，如果应用程序被模块化，突然在您的代码和那些框架之间出现了一个模块边界。模块系统，特别是`exports`指令，为您提供了哪些选项来使内部类型可访问？
- en: 12.1.2 FORCING THE PUBLICATION OF INTERNAL TYPES
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.1.2 强制发布内部类型
- en: 'ESSENTIAL INFO According to the accessibility rules discussed in section 3.3,
    types need to be public and in an exported package to be accessible. That also
    holds for reflection; so, without using an `exports` directive, you’ll get an
    exception like the following:'
  id: totrans-598
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关键信息：根据第3.3节中讨论的可访问性规则，类型必须是公共的，并且位于导出包中才能被访问。这也适用于反射；因此，如果不使用`exports`指令，您将得到以下异常：
- en: '`> Exception in thread "main" java.lang.IllegalAccessException: > class p.X
    (in module A) cannot access class q.Y (in module B) > because module B does not
    export q to module A > at java.base/....Reflection.newIllegalAccessException >
    at java.base/....AccessibleObject.checkAccess > at java.base/....Constructor.newInstance`'
  id: totrans-599
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 异常发生在主线程中 java.lang.IllegalAccessException: > 类p.X（在模块A中）无法访问类q.Y（在模块B中）
    > 因为模块B没有将q导出到模块A > at java.base/....Reflection.newIllegalAccessException > at
    java.base/....AccessibleObject.checkAccess > at java.base/....Constructor.newInstance`'
- en: That seems to indicate that you have to make the classes that Spring, Hibernate,
    and so on need to access public, and export the packages containing them. That
    adds them to a module’s public API, though, and because we’re so far considering
    these types to be internal, that’s a serious decision to make.
  id: totrans-600
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这似乎表明，你必须将Spring、Hibernate等类库需要访问的类设置为public，并导出包含它们的包。然而，这样做会将它们添加到模块的公共API中，鉴于我们之前将这些类型视为内部类型，这是一个重大的决定。
- en: If you’re writing a small service with a few thousand lines of code split into
    a handful of modules, that may not look like a problem. After all, there isn’t
    much chance for large-scale confusion about your modules’ APIs and relationships.
    But it’s also not the scenario where you need modules to shine.
  id: totrans-601
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您正在编写一个包含几千行代码的小型服务，这些代码被分成几个模块，这可能看起来不是问题。毕竟，关于您模块的API和关系的重大混淆的可能性很小。但这也不是您需要模块发光的场景。
- en: On the other hand, if you’re working on a larger code base with numbers of lines
    of code in the six or seven digits, split into dozens or hundreds of modules that
    are being worked on by a dozen or more developers, things look very different.
    In that scenario, exporting a package gives other developers a strong signal that
    it’s okay to use those classes outside of the module, and that they were specifically
    designed to be used across module boundaries—after all, that’s what exports are
    for.
  id: totrans-602
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一方面，如果您正在处理一个包含六位数或七位数代码行的大型代码库，分成由十几个或更多开发者共同工作的几十个或几百个模块，情况就完全不同了。在这种情况下，导出一个包会给其他开发者一个强烈的信号，表明可以在模块外部使用这些类，并且它们被特别设计为可以跨越模块边界使用——毕竟，这就是exports的作用。
- en: But because the starting point for this exploration was that you preferred,
    for whatever reason, to not make these classes public, you apparently valued their
    encapsulation. It would be pretty ironic if the module system then forced you
    to mark something as supported that you didn’t even want to be accessible, thus
    weakening encapsulation.
  id: totrans-603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但由于这次探索的起点是您出于某种原因更喜欢不将这些类设置为public，您显然重视它们的封装性。如果模块系统迫使您标记某些您甚至不希望其可访问的内容为受支持，从而削弱了封装性，那就非常讽刺了。
- en: 12.1.3 QUALIFIED EXPORTS CREATE COUPLING TO SPECIFIC MODULES
  id: totrans-604
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.1.3 限定导出创建对特定模块的耦合
- en: At this point, think back to section 11.3 and consider using a qualified export
    to make sure only the one module can access these internals. First, kudos for
    thinking on your feet—this can indeed fix the problem I just described.
  id: totrans-605
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这一点上，回顾第11.3节，并考虑使用限定导出以确保只有单个模块可以访问这些内部类型。首先，对于您即兴思考的能力表示赞赏——这确实可以解决我刚才描述的问题。
- en: It can introduce a new one, though. Think about JPA and its various implementations,
    like Hibernate and EclipseLink. Depending on your style, you may have worked hard
    to prevent direct dependencies on your chosen implementation, so you won’t look
    forward to hard-coding one into a module declaration with an `exports … to concrete.jpa.implementation`.
    If you rely on qualified exports, there’s no way around that, though.
  id: totrans-606
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然它可以引入一个新的。想想JPA及其各种实现，比如Hibernate和EclipseLink。根据你的风格，你可能已经努力防止直接依赖于你选择的实现，所以你不会期待在模块声明中硬编码一个`exports
    … to concrete.jpa.implementation`。如果你依赖于限定导出，那就没有其他办法了。
- en: 12.1.4 NO SUPPORT FOR DEEP REFLECTION
  id: totrans-607
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.1.4 不支持深度反射
- en: Having to make types that you’d rather treat as implementation details accessible
    to other code is bad. But it gets worse.
  id: totrans-608
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将你本想作为实现细节处理的类型暴露给其他代码是件坏事。但这还只是开始。
- en: Say you did settle on an `exports` directive (qualified or not) to let your
    framework of choice access your classes. Although it’s often possible to use reflection-based
    frameworks with public members only, this is neither always the case nor always
    the best approach. On the contrary, it’s common to rely on deep reflection over
    private fields or nonpublic methods to not expose framework-related details to
    the rest of the code base. ([Listing 12.1](part0027.html#filepos1480068) shows
    a number of examples and [listing 12.2](part0027.html#filepos1485668) shows how
    `setAccessible` is used to achieve access to internals.)
  id: totrans-609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你决定使用一个`exports`指令（无论是否限定）来允许你选择的框架访问你的类。尽管通常可以使用仅包含公共成员的基于反射的框架，但这并不总是情况，也不是最佳方法。相反，通常依赖于对私有字段或非公共方法的深度反射，以防止将框架相关的细节暴露给代码库的其他部分。（[列表12.1](part0027.html#filepos1480068)
    展示了一些示例，[列表12.2](part0027.html#filepos1485668) 展示了如何使用`setAccessible`来实现对内部结构的访问。）
- en: 'ESSENTIAL INFO Fortunately in general—but unfortunately in this scenario—making
    the type public and exporting its package doesn’t grant access to nonpublic members.
    If the framework tries to use them by calling `setAccessible`, you’ll get an error
    like this one:'
  id: totrans-610
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的是——一般来说是幸运的——但不幸的是在这种情况下——将类型公开并导出其包并不授予对非公共成员的访问权限。如果框架尝试通过调用`setAccessible`来使用它们，你会得到这样的错误：
- en: '`> Exception in thread "main" java.lang.reflect.InaccessibleObjectException:
    > Unable to make field q.Y.field accessible: > module B does not "opens q" to
    module A > at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible
    > at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible > at java.base/java.lang.reflect.Field.checkCanSetAccessible
    > at java.base/java.lang.reflect.Field.setAccessible`'
  id: totrans-611
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 线程 "main" 中发生异常 java.lang.reflect.InaccessibleObjectException: > 无法使字段 q.Y.field
    可访问：> 模块 B 没有向模块 A "打开" q > at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible
    > at java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible > at java.base/java.lang.reflect.Field.checkCanSetAccessible
    > at java.base/java.lang.reflect.Field.setAccessible`'
- en: If you really wanted to go this route, you’d have to make all reflectively accessed
    members public, which makes the earlier “this weakens encapsulation” conclusion
    much worse.
  id: totrans-612
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你真的想走这条路，你必须将所有通过反射访问的成员公开，这使得之前“这削弱了封装性”的结论变得更糟。
- en: 'To summarize, these are the drawbacks of using `exports` directives for code
    that’s primarily supposed to be used reflectively:'
  id: totrans-613
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总结来说，这些是使用`exports`指令对主要用于反射的代码的缺点：
- en: Only allows access to public members, which often requires making implementation
    details public.
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只允许访问公共成员，这通常需要将实现细节公开。
- en: Allows other modules to compile code against those exposed classes and members.
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许其他模块编译代码时针对那些公开的类和成员。
- en: Qualified exports may couple you to an implementation instead of a specification.
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限定导出可能会使你绑定到一个实现而不是一个规范。
- en: Marks the package as being part of a module’s public API.
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记包为模块公共API的一部分。
- en: It’s up to you which of these four things you find the worst. For me, it’s the
    last.
  id: totrans-618
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 取决于你哪一点觉得最糟糕。对我来说，是最后一点。
- en: '12.2 Open packages and modules: Designed for the reflection use case'
  id: totrans-619
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.2 开放包和模块：为反射用例设计
- en: Now that we’ve established how thoroughly unsuitable `exports` are for making
    code accessible for reflection-based libraries, what alternative does the module
    system offer?
  id: totrans-620
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 既然我们已经确定了`exports`对于使代码对基于反射的库可访问是多么不合适，模块系统提供了什么替代方案？
- en: 'The answer is the `opens` directive, and it’s the first thing we’re going to
    look at (section 12.2.1) before introducing its qualified variant (akin to `exports
    … to`; section 12.2.2). To make sure you pick the right tool for the job, we’ll
    also thoroughly compare the effects of exporting and opening a module (section
    12.2.3). Last but not least comes the sledgehammer of giving reflective access:
    open modules (12.2.4).'
  id: totrans-621
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案是 `opens` 指令，在我们介绍其合格变体（类似于 `exports … to`；第 12.2.2 节）之前，这是我们首先要关注的内容（第 12.2.1
    节）。为了确保你选择正确的工具来完成这项工作，我们还将彻底比较导出和打开模块的效果（第 12.2.3 节）。最后但同样重要的是，提供反射访问权限的锤子：打开模块（第
    12.2.4 节）。
- en: 12.2.1 OPENING PACKAGES TO RUN-TIME ACCESS
  id: totrans-622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.2.1 打开包以进行运行时访问
- en: 'Definition: The opens directive'
  id: totrans-623
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：`opens` 指令
- en: 'A package can be opened by adding a directive`opens ${package}` to the module
    declaration. At compile time, opened packages are strongly encapsulated: there’s
    no difference between them being opened or not opened. At run time, opened packages
    are fully accessible, including nonpublic classes, methods, and fields.'
  id: totrans-624
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可以通过在模块声明中添加指令 `opens ${package}` 来打开一个包。在编译时，打开的包被强封装：它们是否被打开没有区别。在运行时，打开的包是完全可访问的，包括非公共类、方法和字段。
- en: 'The module monitor.persistence uses Hibernate, so it opens a package with entities
    to allow reflection over them:'
  id: totrans-625
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块 monitor.persistence 使用 Hibernate，因此它打开一个包含实体的包以允许对其反射：
- en: '`module monitor.persistence { requires hibernate.jpa; requires monitor.statistics;  exports
    monitor.persistence; opens monitor.persistence.entity; }`'
  id: totrans-626
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.persistence { requires hibernate.jpa; requires monitor.statistics;  exports
    monitor.persistence; opens monitor.persistence.entity; }`'
- en: This allows Hibernate to work with classes like `StatisticsEntity` (see [listing
    12.3](part0027.html#filepos1500581)). Because the package isn’t exported, other
    ServiceMonitor modules can’t accidentally compile code against types it contains.
  id: totrans-627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这使得 Hibernate 能够与 `StatisticsEntity` 类（见[清单 12.3](part0027.html#filepos1500581)）等类一起工作。由于该包没有被导出，其他
    ServiceMonitor 模块不会意外地编译包含其类型的代码。
- en: Listing 12.3 Excerpts from `StatisticsEntity`, which Hibernate reflects over
  id: totrans-628
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 清单 12.3 从 `StatisticsEntity` 中摘录的内容，Hibernate 将对其进行反射
- en: '`@Entity @Table(name = "stats") public class StatisticsEntity {  @Id @GeneratedValue(strategy
    = GenerationType.AUTO)` `private int id;` [`①`](part0027.html#filepos1501757)
    `@ManyToOne @JoinColumn(name = "quota_id", updatable = false)` `private LivenessQuotaEntity
    totalLivenessQuota;` [`①`](part0027.html#filepos1501757)`private StatisticsEntity()
    { }` [`②`](part0027.html#filepos1502120) `// [...]  }`'
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`@Entity @Table(name = "stats") public class StatisticsEntity {  @Id @GeneratedValue(strategy
    = GenerationType.AUTO)` `private int id;` [①](part0027.html#filepos1501757) `@ManyToOne
    @JoinColumn(name = "quota_id", updatable = false)` `private LivenessQuotaEntity
    totalLivenessQuota;` [①](part0027.html#filepos1501757)`private StatisticsEntity()
    { }` [②](part0027.html#filepos1502120) `// [...]  }`'
- en: ①
  id: totrans-630
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Hibernate will inject values into these private fields.
  id: totrans-631
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Hibernate 将将这些私有字段注入值。
- en: ②
  id: totrans-632
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Hibernate can also access the private constructor.
  id: totrans-633
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Hibernate 也可以访问私有构造函数。
- en: 'As you can tell, `opens` was designed specifically for the use case of reflection
    and behaves very differently from `exports`:'
  id: totrans-634
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如你所看到的，`opens` 是专门为反射用例设计的，并且与 `exports` 的行为非常不同：
- en: It allows access to all members, thus not impacting your decisions regarding
    visibility.
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许访问所有成员，因此不会影响你的可见性决策。
- en: It prevents compilation against code in opened packages and only allows access
    at run time.
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它防止了对打开包中代码的编译，并且只允许在运行时访问。
- en: It marks the package as being designed for use by a reflection-based framework.
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将包标记为设计用于由基于反射的框架使用。
- en: 'Beyond the clear technical advantages over `exports` for this specific use
    case, I again find the final point the most important one: with an `opens` directive,
    you communicate clearly and in code that this package isn’t meant for general
    use, but only for access by a specific tool. If you want, you can even include
    that tool by opening the package just for its module. Read on to find out how
    to do that. As section 5.2.3 explains, if you want to give access to resources
    like configurations or media files that are located in your packages, you also
    need to open them.'
  id: totrans-638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了在特定用例中对 `exports` 的明显技术优势之外，我认为最后一个要点是最重要的：使用 `opens` 指令，你可以在代码中清楚地传达这个包不是用于通用用途，而只是供特定工具访问。如果你愿意，甚至可以通过只为该模块打开包来包含该工具。继续阅读以了解如何做到这一点。正如第
    5.2.3 节所解释的，如果你想访问位于你的包中的资源，如配置或媒体文件，你也需要打开它们。
- en: 12.2.2 OPENING PACKAGES FOR SPECIFIC MODULES
  id: totrans-639
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.2.2 为特定模块打开包
- en: The `opens` directive we’ve discussed so far allows all modules to reflect over
    an opened package. That parallels how `exports` allows all modules to access the
    exported package. And just as `exports` can be limited to specific modules (see
    section 11.3), so can `opens`.
  id: totrans-640
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们之前讨论的 `opens` 指令允许所有模块反射打开的包。这与 `exports` 指令允许所有模块访问导出的包的方式相似。正如 `exports`
    可以限制为特定的模块（见第11.3节）一样，`opens` 也可以。
- en: 'Definition: Qualifying opens'
  id: totrans-641
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：限定打开
- en: The `opens` directive can be qualified by following it up with `to ${modules}`,
    where `${modules}` is a comma-separated list of module names (no placeholders
    are allowed). To the modules named in an `opens to` directive, the package will
    be exactly as accessible as with a regular `opens` directive. To all other modules,
    the package will be as strongly encapsulated as if there were no `opens` at all.
  id: totrans-642
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`opens` 指令可以通过跟在后面 `to ${modules}` 来限定，其中 `${modules}` 是模块名称的逗号分隔列表（不允许使用占位符）。对于
    `opens to` 指令中命名的模块，包的访问权限将与常规 `opens` 指令完全相同。对于所有其他模块，包的封装性将像没有 `opens` 一样强。'
- en: 'To make encapsulation even stronger, monitor.persistence may only open its
    entity package to Hibernate:'
  id: totrans-643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了使封装性更强，monitor.persistence可能只能将其实体包打开给Hibernate：
- en: '`module monitor.persistence { requires hibernate.jpa; requires monitor.statistics;  exports
    monitor.persistence; // assuming Hibernate were an explicit module opens monitor.persistence.entity
    to hibernate.core; }`'
  id: totrans-644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.persistence { requires hibernate.jpa; requires monitor.statistics;  exports
    monitor.persistence; // assuming Hibernate were an explicit module opens monitor.persistence.entity
    to hibernate.core; }`'
- en: In cases where specifications and implementations are separated (for example,
    JPA and Hibernate), you may find it a little fishy to mention the implementation
    in your module declaration. Section 12.3.5 addresses that thought—the summary
    is that this will be necessary until the standards are updated to take the module
    system into account.
  id: totrans-645
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在规范和实现分离的情况下（例如，JPA和Hibernate），您可能会觉得在模块声明中提及实现有些奇怪。第12.3.5节解决了这个问题——总结来说，在标准更新以考虑模块系统之前，这是必要的。
- en: We’ll discuss in section 12.2.3 when you may want to use qualified opens, but
    before we do that, let’s formally introduce a command-line option that we used
    in section 7.1.
  id: totrans-646
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将在第12.2.3节中讨论何时可能需要使用限定 `opens`，但在我们这样做之前，让我们正式介绍在第7.1节中使用的命令行选项。
- en: 'Definition: --add-opens'
  id: totrans-647
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：--add-opens
- en: The option `--add-opens ${module}/${package}=${reflecting-module}` opens `${package}`
    of ${module} to ${reflecting-module}. Code in ${reflecting-module} can hence access
    all types and members, public and nonpublic ones, in `${package}`, but other modules
    can’t.
  id: totrans-648
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 `--add-opens ${module}/${package}=${reflecting-module}` 将 ${module} 中的 ${package}
    打开给 ${reflecting-module}。因此，${reflecting-module} 中的代码可以访问 `${package}` 中的所有类型和成员，包括公开和非公开的，但其他模块则不能。
- en: When you set ${reading-module} to `ALL-UNNAMED`, all code from the class path,
    or more precisely from the unnamed module (see section 8.2), can access that package.
    When migrating to Java 9+, you’ll always use that placeholder—only once your own
    code runs in modules can you limit open packages to specific modules.
  id: totrans-649
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您将 ${reading-module} 设置为 `ALL-UNNAMED` 时，类路径上的所有代码，或者更确切地说，是从未命名的模块（见第8.2节）中，都可以访问该包。当迁移到Java
    9+时，您将始终使用该占位符——只有当您自己的代码在模块中运行时，您才能将打开的包限制为特定的模块。
- en: If you’re interested in an example, check the one toward the end of section
    7.1.4.
  id: totrans-650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您对示例感兴趣，请查看第7.1.4节末尾的示例。
- en: 'Because `--add-opens` is bound to reflection, a pure run-time concept, it only
    makes sense for the `java` command. Interestingly enough, it’s available on `javac`,
    though, where it leads to a warning:'
  id: totrans-651
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于 `--add-opens` 与反射绑定，而反射是一个纯运行时概念，因此它只适用于 `java` 命令。有趣的是，尽管如此，它也存在于 `javac`
    中，但会导致警告：
- en: '`> warning: [options] --add-opens has no effect at compile time`'
  id: totrans-652
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 警告：[options] --add-opens 在编译时没有效果`'
- en: My best guess for why `javac` doesn’t roundly reject `--add-opens` is that this
    makes it possible to share the same argument file with module system–related command-line
    flags between compilation and launch.
  id: totrans-653
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我认为 `javac` 并不全面拒绝 `--add-opens` 的原因可能是，这使得在编译和启动之间共享相同的参数文件成为可能，该参数文件与模块系统相关的命令行标志相关。
- en: 'NOTE What are argument files? You can put compiler and JVM arguments into a
    file and add them to a command with `javac @file-name` and `java @file-name`.
    See the Java documentation for details: [http://mng.bz/K1ZK](http://mng.bz/K1ZK).)'
  id: totrans-654
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 备注：什么是参数文件？您可以将编译器和JVM参数放入文件中，并通过 `javac @file-name` 和 `java @file-name` 将它们添加到命令中。有关详细信息，请参阅Java文档：[http://mng.bz/K1ZK](http://mng.bz/K1ZK)。
- en: 12.2.3 EXPORTING VS. OPENING PACKAGES
  id: totrans-655
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.2.3 导出与打开包的比较
- en: 'The `exports` and `open` directives have a few things in common:'
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`exports`和`open`指令有一些共同点：'
- en: They make package content available beyond module boundaries.
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们使包内容在模块边界之外可用。
- en: They have a qualified variant `to ${modules}` that only gives access to the
    listed modules.
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有一个合格变体`to ${modules}`，只允许访问列出的模块。
- en: They have command-line options for `javac` and `java` that can be used to bypass
    strong encapsulation if need be.
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们为`javac`和`java`提供了命令行选项，可以在需要时绕过强封装。
- en: 'They’re different in when and to what they give access:'
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它们在何时以及提供何种访问权限方面有所不同：
- en: Exported packages give access to public types and members at compile time, making
    them perfect to define public APIs that other modules can use.
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出包在编译时提供对公共类型和成员的访问权限，因此它们非常适合定义其他模块可以使用的公共API。
- en: Opened packages give access to all types and members (including nonpublic ones),
    but only at run time, making them well-suited to give reflection-based frameworks
    access to code that’s otherwise considered to be module-internal.
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开的包提供对所有类型和成员（包括非公共成员）的访问权限，但仅限于运行时，这使得它们非常适合为基于反射的框架提供对其他情况下被认为是模块内部代码的访问权限。
- en: '[Table 12.1](part0027.html#filepos1514738) summarizes this. You may also want
    to flip back to [table 7.1](part0021.html#filepos884309) to see how it relates
    to gaining access to internal APIs with `--add-exports` and `--add-opens`.'
  id: totrans-663
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[表12.1](part0027.html#filepos1514738)总结了这一点。你可能还想翻回到[表7.1](part0021.html#filepos884309)以查看它如何与使用`--add-exports`和`--add-opens`获取内部API的访问权限相关。'
- en: Table 12.1 A comparison of when and to what encapsulated, exported, and opened
    packages give access
  id: totrans-664
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表12.1 对封装、导出和打开的包何时以及提供何种访问权限的比较
- en: '| Access   | Compile-time   | Runtime   |'
  id: totrans-665
  prefs: []
  type: TYPE_TB
  zh: '| 访问   | 编译时   | 运行时   |'
- en: '| Class or member   | Public   | Nonpublic   | Public   | Nonpublic   |'
  id: totrans-666
  prefs: []
  type: TYPE_TB
  zh: '| 类或成员   | 公共   | 非公共   | 公共   | 非公共   |'
- en: '| Encapsulated package   | ✘   | ✘   | ✘   | ✘   |'
  id: totrans-667
  prefs: []
  type: TYPE_TB
  zh: '| 封装包   | ✘   | ✘   | ✘   | ✘   |'
- en: '| Exported package   | ✔   | ✘   | ✔   | ✘   |'
  id: totrans-668
  prefs: []
  type: TYPE_TB
  zh: '| 导出包   | ✔   | ✘   | ✔   | ✘   |'
- en: '| Opened package   | ✘   | ✘   | ✔   | ✔   |'
  id: totrans-669
  prefs: []
  type: TYPE_TB
  zh: '| 打开的包   | ✘   | ✘   | ✔   | ✔   |'
- en: 'You may wonder whether and how you can combine `exports` and `opens` directives,
    and qualified and unqualified variants. The answer is simple—any way you like:'
  id: totrans-670
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能会想知道是否以及如何组合`exports`和`opens`指令，以及合格和不合格变体。答案是简单的——你喜欢的方式：
- en: Your Hibernate entities are public API? Use `exports` and `opens`.
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的Hibernate实体是公共API吗？使用`exports`和`opens`。
- en: Want to give only a select few of your application modules compile-time access
    to your Spring contexts? Use `exports … to` and `opens`.
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想要只给应用程序的少数模块提供编译时访问你的Spring上下文？使用`exports … to`和`opens`。
- en: There may not be an obvious use case for each of the four possible combinations
    (and I’d even argue that you should design your code so you don’t need any of
    them), but rest assured that if you encounter one, you can arrange these directives
    accordingly.
  id: totrans-673
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于四种可能的组合中的每一种可能都没有明显的用例（我甚至可以争论你应该设计代码，以便不需要任何一种），但请放心，如果你遇到一个，你可以相应地安排这些指令。
- en: When it comes to whether `opens` should be limited to specific modules, my opinion
    is that it often won’t be worth the additional effort. Although qualified exports
    are an important tool to prevent colleagues and users from introducing accidental
    dependencies on internal APIs (see section 11.3.3 for more on that), the target
    audience for qualified opens are frameworks that are completely independent of
    your code. Whether or not you open a package just to Hibernate, Spring won’t start
    depending on it. If your project uses a lot of reflection over its own code, then
    things might look different; but otherwise my default is to open—without qualification.
  id: totrans-674
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当涉及到是否应该将`opens`限制为特定的模块时，我的观点是，这通常不值得额外的努力。尽管合格导出是防止同事和用户意外依赖内部API的重要工具（有关更多信息，请参阅第11.3.3节），但合格`opens`的目标受众是完全独立于你代码的框架。无论你是否只为Hibernate打开一个包，Spring都不会依赖于它启动。如果你的项目在其代码上使用了大量的反射，那么情况可能会有所不同；但否则，我的默认做法是不加限定地打开。
- en: '12.2.4 OPENING MODULES: REFLECTION CLOSEOUT'
  id: totrans-675
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.2.4 打开模块：反射关闭
- en: Finally, if you have a large module with many packages that are exposed to reflection,
    you may find it tiresome to open each of them individually. Although there’s no
    wildcard like `opens com.company.*`, something close to it exists.
  id: totrans-676
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，如果你有一个包含许多暴露于反射的包的大模块，你可能发现逐个打开它们会很麻烦。尽管没有类似于`opens com.company.*`的通配符，但存在类似的东西。
- en: 'Definition: Open module'
  id: totrans-677
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：打开模块
- en: 'By putting the keyword`open` before `module` in the module declaration, an
    open module is created:'
  id: totrans-678
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过在模块声明中将关键字`open`放在`module`之前，创建了一个公开的模块：
- en: '`open module ${module-name} { requires ${module-name}; exports ${package-name};
    // no opens allowed }`'
  id: totrans-679
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`open module ${module-name} { requires ${module-name}; exports ${package-name};
    // no opens allowed }`'
- en: An open module opens all packages it contains as if each of them were used in
    an `opens` directive. Consequently, it doesn’t make sense to manually open further
    packages, which is why the compiler doesn’t accept `opens` directives in an open
    module.
  id: totrans-680
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个公开的模块将其包含的所有包都公开，就像每个包都在使用一个`opens`指令一样。因此，手动进一步打开包是没有意义的，这也是为什么编译器不接受公开模块中的`opens`指令的原因。
- en: 'As an alternative to using `opens monitor.persistence.entity`, the monitor.persistence
    module could instead be open:'
  id: totrans-681
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为使用`opens monitor.persistence.entity`的替代方案，monitor.persistence模块可以改为公开：
- en: '`open module monitor.persistence { requires hibernate.jpa; requires monitor.statistics;  exports
    monitor.persistence; }`'
  id: totrans-682
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`open module monitor.persistence { requires hibernate.jpa; requires monitor.statistics;  exports
    monitor.persistence; }`'
- en: As you can see, open modules are really just a convenience to keep you from
    having to open dozens of packages manually. Ideally, you’d never be in that position,
    though, because your modules aren’t that large. A scenario with so many opened
    packages is more likely during a modularization, when you turn a large JAR into
    a large module before splitting it up. That’s also why `jdeps` can generate declarations
    for open modules—see section 9.3.2.
  id: totrans-683
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如您所见，公开模块实际上只是为了方便您不必手动打开数十个包。理想情况下，您永远不会处于这种情况，因为您的模块并不大。在模块化过程中，当您在拆分之前将一个大JAR转换成一个大模块时，出现如此多打开包的情况更为常见。这也是为什么`jdeps`可以为公开模块生成声明的原因——参见第9.3.2节。
- en: 12.3 Reflecting over modules
  id: totrans-684
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.3 模块上的反射
- en: Sections 12.1 and 12.2 explored how you can expose code to reflection, so that
    frameworks like Hibernate and Spring can access it. Because most Java applications
    use such frameworks, you’ll encounter that scenario regularly.
  id: totrans-685
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.1和12.2节探讨了如何将代码暴露给反射，以便像Hibernate和Spring这样的框架可以访问它。由于大多数Java应用程序都使用这样的框架，您将经常遇到这种情况。
- en: Now we’re going to switch sides and reflect over modular code. It’s good to
    know how that works, so you can update your understanding of the reflection API;
    but because writing reflection code is rare for most developers, chances are you
    won’t be doing this regularly. Consequently, this section is more of a discussion
    of noteworthy aspects of reflecting over modules and their code than a thorough
    introduction to all involved topics and APIs.
  id: totrans-686
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在我们将转换到另一边，对模块化代码进行反射。了解这一点是好的，这样您就可以更新对反射API的理解；但由于编写反射代码对于大多数开发者来说很少见，所以您不太可能经常这样做。因此，本节更多地是关于对模块及其代码进行反射的值得注意方面的讨论，而不是对所有相关主题和API的全面介绍。
- en: We’ll first look at why you won’t need to change your reflection code to work
    with modular code (12.3.1), and why you may switch to a more modern API (12.3.2).
    Then we’ll get to the modules themselves, which have a prominent representation
    in the reflection API that can be used to query (12.3.3) and even modify (12.3.4)
    them. We’ll finish by looking more closely at how a module can be modified to
    allow other modules reflective access to it (12.3.5).
  id: totrans-687
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们首先将探讨为什么您不需要更改反射代码以与模块化代码（12.3.1）一起工作，以及为什么您可能需要切换到更现代的API（12.3.2）。然后我们将深入到模块本身，它们在反射API中有显著的表示，可以用来查询（12.3.3）甚至修改（12.3.4）它们。最后，我们将更详细地研究如何修改模块以允许其他模块通过反射访问它（12.3.5）。
- en: 12.3.1 UPDATING REFLECTING CODE FOR MODULES (OR NOT)
  id: totrans-688
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.3.1 更新模块的反射代码（或不）
- en: Before venturing into new territories, I want to update your reflection knowledge
    with changes caused by the module system. Although it’s good to understand how
    reflection deals with readability and accessibility, you’ll find that there isn’t
    much you need to change in your code. More important is that you inform your users
    what they have to do when creating modules.
  id: totrans-689
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在探索新领域之前，我想通过模块系统引起的变化来更新您的反射知识。虽然了解反射如何处理可读性和可访问性是好的，但您会发现您在代码中需要更改的内容并不多。更重要的是，您需要通知用户在创建模块时他们需要做什么。
- en: NOTHING NEEDS TO BE DONE FOR READABILITY
  id: totrans-690
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 读取性方面无需进行任何操作
- en: One thing I’ve stated repeatedly is that reflection is bound by the same accessibility
    rules as static access (see section 3.3). First and foremost, that means for code
    in one module to be able to access code in another module, the first must read
    the second. Generally speaking, the module graph won’t be set up that way, though—Hibernate
    won’t usually read application modules.
  id: totrans-691
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我反复强调的一点是，反射受到与静态访问相同的可访问性规则的约束（参见第 3.3 节）。首先，这意味着一个模块中的代码要能够访问另一个模块中的代码，第一个必须读取第二个。一般来说，模块图不会以这种方式设置——Hibernate
    通常不会读取应用程序模块。
- en: ESSENTIAL INFO That sounds like the reflecting module needs to add a reads edge
    from it to the reflected module, and indeed, there is an API for that (see section
    12.3.4). But because reflection always requires that edge, always adding it would
    just lead to unavoidable boilerplate, so the reflection API does it internally.
    In summary, you don’t need to worry about readability.
  id: totrans-692
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的信息 这听起来像是反射模块需要向反射模块添加一个读取边，确实，有一个 API 可以做到这一点（参见第 12.3.4 节）。但由于反射始终需要这个边，总是添加它只会导致不可避免的样板代码，因此反射
    API 会内部处理。总之，你不需要担心可读性。
- en: NOTHING CAN BE DONE FOR ACCESSIBILITY
  id: totrans-693
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无法实现可访问性
- en: The next hurdle in the way to accessing code is that it needs to be either exported
    or opened. As thoroughly discussed in section 12.2, that’s indeed an issue, albeit
    one that you, as the author of a reflection library, can do little about. Either
    the module’s owner prepared the package by opening or exporting it, or they didn’t.
  id: totrans-694
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 访问代码的下一个障碍是它需要被导出或打开。在第 12.2 节中已经彻底讨论过，这确实是一个问题，尽管作为反射库的作者，你能做的很少。要么模块的所有者通过打开或导出包来准备它，要么他们没有这样做。
- en: 'ESSENTIAL INFO The module system doesn’t limit visibility: calls like `Class::forName`
    or reflection to get references to constructors, methods, and fields succeed.
    Accessibility is limited: if access isn’t given by the reflected module, then
    invoking a constructor or method, accessing a field, and calls to `AccessibleObject::setAccessible`
    will fail with an `InaccessibleObjectException`.'
  id: totrans-695
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的信息 模块系统不会限制可见性：像 `Class::forName` 或通过反射获取构造函数、方法和字段的引用这样的调用是成功的。但可访问性是有限的：如果反射模块没有提供访问权限，那么调用构造函数或方法、访问字段以及调用
    `AccessibleObject::setAccessible` 将会失败并抛出 `InaccessibleObjectException`。
- en: '`InaccessibleObjectException` extends `RuntimeException`, making it an unchecked
    exception, so the compiler won’t force you to catch it. But make sure you do,
    and on that operation, too—this way, you can provide users with a maximally helpful
    error message. See [listing 12.4](part0027.html#filepos1535662) for an example.'
  id: totrans-696
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`InaccessibleObjectException` 扩展了 `RuntimeException`，使其成为一个非受检异常，因此编译器不会强制你捕获它。但请确保你确实捕获了它，并在该操作上也是如此——这样，你可以为用户提供一个尽可能有帮助的错误信息。参见[列表
    12.4](part0027.html#filepos1535662) 中的示例。'
- en: 'Definition: AccessibleObject::trySetAccessible'
  id: totrans-697
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：AccessibleObject::trySetAccessible
- en: 'If you prefer checking accessibility without causing an exception to be thrown,
    the `AccessibleObject::trySetAccessible` method, added in Java 9, is there for
    you. At its core, it does the same thing as `setAccessible(true)`: it tries to
    make the underlying member accessible, but uses its return value to indicate whether
    it worked. If accessibility was granted, it returns `true`; otherwise it returns
    `false`. [Listing 12.4](part0027.html#filepos1535662) shows it in action.'
  id: totrans-698
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你更喜欢在不抛出异常的情况下检查可访问性，Java 9 中新增的 `AccessibleObject::trySetAccessible` 方法正是为你准备的。本质上，它做的是与
    `setAccessible(true)` 相同的事情：它尝试使底层成员可访问，但使用其返回值来指示是否成功。如果授予了可访问性，它返回 `true`；否则返回
    `false`。[列表 12.4](part0027.html#filepos1535662) 展示了它的实际应用。
- en: Listing 12.4 Three ways to handle inaccessible code
  id: totrans-699
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 12.4 三种处理不可访问代码的方法
- en: '`private Object constructWithoutExceptioHandling(Class<?> type) throws ReflectiveOperationException
    { Constructor<?> constructor = type.getConstructor();` `constructor.setAccessible(true);`
    [`①`](part0027.html#filepos1538070) `return constructor.newInstance(); }  private
    Object constructWithExceptionHandling(Class<?> type) throws ReflectiveOperationException,
    FrameworkException { Constructor<?> constructor = type.getConstructor(); try {`
    `constructor.setAccessible(true);` [`②`](part0027.html#filepos1538506) `} catch
    (InaccessibleObjectException ex) { throw new FrameworkException(createErrorMessage(type),
    ex); } return constructor.newInstance(); }  private Object constructWithoutException(Class<?>
    type) throws ReflectiveOperationException, FrameworkException { Constructor<?>
    constructor = type.getConstructor();` `boolean isAccessible = constructor.trySetAccessible();`
    [`③`](part0027.html#filepos1538953) `if (!isAccessible) throw new FrameworkException(createErrorMessage(type));
    return constructor.newInstance(); }  private String createErrorMessage(Class<?>
    type) { return "When doing THE FRAMEWORK THING, accessing " + type + "''s parameterless
    constructor failed " + "because the module does not open the containing package.
    " + "For details see https://framework.org/java-modules"; }`'
  id: totrans-700
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`private Object constructWithoutExceptionHandling(Class<?> type) throws ReflectiveOperationException
    { Constructor<?> constructor = type.getConstructor();` `constructor.setAccessible(true);`
    [`①`](part0027.html#filepos1538070) `return constructor.newInstance(); }  private
    Object constructWithExceptionHandling(Class<?> type) throws ReflectiveOperationException,
    FrameworkException { Constructor<?> constructor = type.getConstructor(); try {`
    `constructor.setAccessible(true);` [`②`](part0027.html#filepos1538506) `} catch
    (InaccessibleObjectException ex) { throw new FrameworkException(createErrorMessage(type),
    ex); } return constructor.newInstance(); }  private Object constructWithoutException(Class<?>
    type) throws ReflectiveOperationException, FrameworkException { Constructor<?>
    constructor = type.getConstructor();` `boolean isAccessible = constructor.trySetAccessible();`
    [`③`](part0027.html#filepos1538953) `if (!isAccessible) throw new FrameworkException(createErrorMessage(type));
    return constructor.newInstance(); }  private String createErrorMessage(Class<?>
    type) { return "当进行框架操作时，访问 " + type + " 的无参构造函数失败，因为模块没有打开包含它的包。 " + "有关详细信息，请参阅
    https://framework.org/java-modules"; }`'
- en: ①
  id: totrans-701
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: This call can throw an InaccessibleObjectException, which isn’t explicitly handled—the
    user is left to sort out the problem.
  id: totrans-702
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此调用可能会抛出InaccessibleObjectException，该异常没有明确处理——用户需要自行解决问题。
- en: ②
  id: totrans-703
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Here the exception is converted into a framework-specific one with an additional
    error message explaining the context in which it occurred.
  id: totrans-704
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这里，异常被转换为一个具有附加错误消息的框架特定异常，该消息解释了异常发生的环境。
- en: ③
  id: totrans-705
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: By using trySetAccessible, the initial exception is prevented, but in this case
    a framework-specific one is thrown nonetheless.
  id: totrans-706
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过使用trySetAccessible，可以防止初始异常，但在此情况下，仍然会抛出一个框架特定的异常。
- en: 'Beyond making sure you properly handle the case in which access couldn’t be
    granted, there isn’t anything you can do. This makes updating your project for
    the module system more of a communication challenge than a technical one: users
    need to be aware which packages your project may need access to and what to do
    about it. Your documentation is the obvious place to educate them.'
  id: totrans-707
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了确保正确处理无法授予访问权限的情况外，您别无他法。这使得更新项目以适应模块系统更像是一个沟通挑战，而不是技术挑战：用户需要了解项目可能需要访问哪些包以及如何处理。您的文档是教育他们的明显位置。
- en: Dedicated JPMS page
  id: totrans-708
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 专门的JPMS页面
- en: Going slightly off-topic, I recommend creating a dedicated page in your documentation
    for the issue of how to prepare a module for use by your project. The more focused
    it is, the more likely that searching users will find it, so don’t bury it in
    an already-gigantic document. Then spread that resource wide and far, including
    in your Javadoc and the exception message for failed access.
  id: totrans-709
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 稍微偏离主题，我建议在您的文档中为如何为项目准备模块使用的问题创建一个专门的页面。越专注，搜索的用户就越有可能找到它，所以不要把它埋在一个已经非常大的文档中。然后广泛传播这个资源，包括在Javadoc和失败访问的异常消息中。
- en: 12.3.2 USING VARIABLE HANDLES INSTEAD OF REFLECTION
  id: totrans-710
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.3.2 使用变量处理程序而不是反射
- en: 'Java 9 introduced a new API called variable handles (extending Java 7’s method
    handles, which few developers have a use case for). It centers around the class
    `java.lang.invoke.VarHandle`, whose instances are strongly typed references to
    variables: for example, fields (although it’s not limited to that). It addresses
    use cases from areas like reflection, concurrency, and off-heap data storage.
    Compared to the reflection API, it offers more type safety and better performance.'
  id: totrans-711
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java 9 引入了一个名为变量句柄的新 API（扩展了 Java 7 的方法句柄，而很少有开发者有使用场景）。它围绕 `java.lang.invoke.VarHandle`
    类展开，其实例是变量的强类型引用：例如，字段（尽管它不仅限于这一点）。它解决了来自反射、并发和堆外数据存储等领域的用例。与反射 API 相比，它提供了更多的类型安全和更好的性能。
- en: 'Method and variable handles are versatile, complex features that have little
    to do with the module system, so I won’t formally introduce them here. If you
    even occasionally write code that uses reflection, you should definitely look
    into them—for a simple example, see the next listing. There’s one particularly
    interesting aspect, though, that I want to discuss in more depth: how variable
    handles can be used to give access to module internals.'
  id: totrans-712
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 方法句柄和变量句柄是多功能、复杂的特性，与模块系统关系不大，所以在这里我不会正式介绍它们。如果你偶尔编写使用反射的代码，你绝对应该研究它们——一个简单的例子，请参见下一个列表。不过，有一个特别有趣的问题，我想更深入地讨论：变量句柄如何用于访问模块内部。
- en: Listing 12.5 Using `VarHandle` to access a field value
  id: totrans-713
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表12.5 使用 `VarHandle` 访问字段值
- en: '`Object object = // ...` [`①`](part0027.html#filepos1543642)`String fieldName
    = // ...` [`①`](part0027.html#filepos1543642)`Class<?> type = object.getClass();`
    [`②`](part0027.html#filepos1543993)`Field field = type.getDeclaredField(fieldName);`
    [`②`](part0027.html#filepos1543993)`Lookup lookup = MethodHandles.lookup();` [`③`](part0027.html#filepos1544367)
    `VarHandle handle = lookup.unreflectVarHandle(field); handle.get(object);`'
  id: totrans-714
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Object object = // ...` [`①`](part0027.html#filepos1543642)`String fieldName
    = // ...` [`①`](part0027.html#filepos1543642)`Class<?> type = object.getClass();`
    [`②`](part0027.html#filepos1543993)`Field field = type.getDeclaredField(fieldName);`
    [`②`](part0027.html#filepos1543993)`Lookup lookup = MethodHandles.lookup();` [`③`](part0027.html#filepos1544367)`VarHandle
    handle = lookup.unreflectVarHandle(field); handle.get(object);`'
- en: ①
  id: totrans-715
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Given an object and the name of a field …
  id: totrans-716
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定一个对象和一个字段的名称 …
- en: ②
  id: totrans-717
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: … this is the typical reflection code to get the type and field.
  id: totrans-718
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: …这是获取类型和字段的典型反射代码。
- en: ③
  id: totrans-719
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: Lookup and VarHandle are part of the method/variable handle API, which is based
    on lookups.
  id: totrans-720
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查找和变量句柄是方法/变量句柄 API 的一部分，该 API 基于查找。
- en: You’ve seen that the reflection API requires the user to open some packages,
    but there’s no way for the reflecting framework to express that in code. The user
    either knows that based on their understanding of the module system or has to
    learn it from reading your documentation—neither of which are exactly the most
    robust way to express a requirement. What if the framework code could make that
    clearer?
  id: totrans-721
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你已经看到，反射 API 要求用户打开一些包，但反射框架没有方法在代码中表达这一点。用户要么基于对模块系统的理解知道这一点，要么必须通过阅读你的文档来学习它——这两种方式都不是表达要求的最稳健方式。如果框架代码能够使这一点更清晰会怎样？
- en: Method and variable handles give you the tool for that. Take another look at
    [listing 12.5](part0027.html#filepos1542348)—see the call to `MethodHandles.lookup()`?
    This creates a `Lookup` instance that, among other privileges and information,
    captures the access rights of the caller.
  id: totrans-722
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 方法句柄和变量句柄为你提供了这样的工具。再看一下[列表12.5](part0027.html#filepos1542348)——看到了对 `MethodHandles.lookup()`
    的调用吗？这创建了一个 `Lookup` 实例，它除了其他特权和信息外，还捕获了调用者的访问权限。
- en: That means all code, regardless of the module it belongs to, that gets hold
    of that specific `lookup` instance can do deep reflection on the same classes
    as the code that created the lookup (see [figure 12.1](part0027.html#filepos1546666)).
    This way, a module can capture its access rights to its own internals and pass
    them on to other modules.
  id: totrans-723
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这意味着所有代码，无论它属于哪个模块，只要获取了那个特定的 `lookup` 实例，就可以对与创建查找的代码相同的类进行深度反射（参见[图12.1](part0027.html#filepos1546666)）。这样，一个模块可以捕获它对自己内部结构的访问权限，并将它们传递给其他模块。
- en: '![](../images/00034.jpeg)'
  id: totrans-724
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00034.jpeg)'
- en: '[Figure 12.1](part0027.html#filepos1546248) The reflected module creates a
    lookup and passes it to reflecting, which can then use it to access the same classes
    and members that reflected can access—these include reflected’s internals.'
  id: totrans-725
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图12.1](part0027.html#filepos1546248) 反射模块创建一个查找并将其传递给反射，然后反射可以使用它来访问反射可以访问的相同类和成员——这些包括反射的内部成员。'
- en: Your reflecting code can make use of that by requiring the user to pass lookup
    objects to it; for example, when bootstrapping your framework. When users have
    to call a method that takes one or more `Lookup` instances, they’re bound to read
    the docs to learn what they’re supposed to do. Then they create an instance in
    each module that needs to be accessed and pass them to you, and you use them to
    access their module’s internals. [Listing 12.6](part0027.html#filepos1548869)
    shows how that works.
  id: totrans-726
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你的反射代码可以通过要求用户将其传递给查找对象来利用这一点；例如，在引导你的框架时。当用户必须调用一个接受一个或多个 `Lookup` 实例的方法时，他们必然会阅读文档来了解他们应该做什么。然后，他们为需要访问的每个模块创建一个实例并将它们传递给你，而你则使用它们来访问它们的模块内部。
    [列表 12.6](part0027.html#filepos1548869) 展示了这是如何工作的。
- en: Listing 12.6 Using `VarHandle` to access a field value with a private lookup
  id: totrans-727
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 12.6 使用 `VarHandle` 通过私有查找访问字段值
- en: '`Lookup lookup = // ...` [`①`](part0027.html#filepos1549779) `Object object
    = // ... String fieldName = // ...  Class<?> type = object.getClass(); Field field
    = type.getDeclaredField(fieldName);  Lookup privateLookup = MethodHandles` `.privateLookupIn(type,lookup);`
    [`②`](part0027.html#filepos1550139) `VarHandle handle = privateLookup.unreflectVarHandle(field);
    handle.get(object);`'
  id: totrans-728
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Lookup lookup = // ...` [`①`](part0027.html#filepos1549779) `Object object
    = // ... String fieldName = // ...  Class<?> type = object.getClass(); Field field
    = type.getDeclaredField(fieldName);  Lookup privateLookup = MethodHandles`.privateLookupIn(type,lookup);`
    [`②`](part0027.html#filepos1550139) `VarHandle handle = privateLookup.unreflectVarHandle(field);
    handle.get(object);`'
- en: ①
  id: totrans-729
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: This lookup was created in the module owning object.
  id: totrans-730
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这个查找是在拥有对象的模块中创建的。
- en: ②
  id: totrans-731
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: By creating a private lookup from the user-provided one, you can access the
    object’s internals from a different module.
  id: totrans-732
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过从用户提供的查找中创建一个私有查找，你可以从不同的模块访问对象的内部。
- en: 'The interesting thing about lookups is that they can be passed around between
    modules. In the case of a standard versus implementation split as with JPA and
    its providers, the user could pass lookups to JPA’s bootstrapping methods, which
    could then pass them on to Hibernate, EclipseLink, and the like. I think that’s
    a pretty neat way to implement lookups:'
  id: totrans-733
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于查找的有趣之处在于，它们可以在模块之间传递。在标准与实现分离的情况下，例如 JPA 及其提供者，用户可以将查找传递给 JPA 的引导方法，然后这些方法可以将它们传递给
    Hibernate、EclipseLink 等类似系统。我认为这是一种相当巧妙实现查找的方法：
- en: Users are aware that they have to do something, because bootstrapping methods
    require `Lookup` instances (as opposed to the requirement to open packages, which
    can’t be expressed in code).
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户知道他们必须做些什么，因为引导方法需要 `Lookup` 实例（这与打开包的要求不同，后者不能在代码中表达）。
- en: There’s no need to change module declarations (unlike with `opens` directives).
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有必要更改模块声明（与 `opens` 指令不同）。
- en: Standards can pass lookups to implementations, thus not forcing users to reference
    the implementation in code or module declarations (this is also possible for open
    packages, as section 12.3.5 explains).
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准可以将查找传递给实现，因此不必强制用户在代码或模块声明中引用实现（正如第 12.3.5 节所解释的，对于开放包也是如此）。
- en: That concludes the discussions of using reflection or variable handles to access
    types that are encapsulated in modules. We’ll now turn to the modules themselves
    and see what information you can get about them.
  id: totrans-737
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这就结束了使用反射或变量处理程序访问模块中封装的类型的相关讨论。现在，我们将转向模块本身，看看你能从中获取哪些信息。
- en: 12.3.3 ANALYZING MODULE PROPERTIES WITH REFLECTION
  id: totrans-738
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.3.3 使用反射分析模块属性
- en: 'If you ever tried to analyze a JAR at run time, you found out that doing so
    isn’t convenient. That goes back to the fundamental interpretation of what JARs
    are: mere containers (see section 1.2). Java doesn’t recognize them as first-class
    citizens like packages and types, so it has no representation at run time that
    sees them as anything more than just Zip files.'
  id: totrans-739
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你曾经尝试在运行时分析一个 JAR 文件，你会发现这样做并不方便。这回到了 JAR 文件的基本解释：仅仅是容器（参见第 1.2 节）。Java 并不把它们视为像包和类型那样的第一类公民，因此在运行时没有将它们视为除了
    Zip 文件之外任何东西的表示。
- en: The module system’s pivotal change is to align Java’s interpretation of JARs
    with ours as units of code that have names, dependencies, and explicit APIs. Beyond
    everything we’ve discussed so far in this book, this should carry all the way
    to the reflection API, where modules, unlike JARs but like packages and types,
    should be represented. And indeed they are.
  id: totrans-740
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块系统的关键变化是将 Java 对 JAR 文件的解释与我们的一致，即具有名称、依赖关系和显式 API 的代码单元。超出本书中我们迄今为止讨论的所有内容，这一点应该一直延伸到反射
    API，在那里，模块（与 JAR 文件不同，但与包和类型相同）应该被表示。确实如此。
- en: 'Definition: Module and ModuleDescriptor types'
  id: totrans-741
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：`Module` 和 `ModuleDescriptor` 类型
- en: 'Java 9 introduced the new type `java.lang.Module`, which represents a module
    at run time. A `Module` instance lets you do the following:'
  id: totrans-742
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java 9 引入了新的类型 `java.lang.Module`，它在运行时表示一个模块。`Module` 实例允许你执行以下操作：
- en: Analyze the module’s name, annotations, exports/opens directives, and service
    uses
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析模块的名称、注解、导出/公开指令和服务使用
- en: Access resources the module contains (see section 5.2)
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问模块包含的资源（参见第 5.2 节）
- en: Modify the module by exporting and opening packages or adding reads edges and
    services uses (if the modifying code is in the same module)
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过导出和公开包或添加读取边和服务使用来修改模块（如果修改代码在同一模块中）
- en: Some of these pieces of information are only available on the equally new type
    `java.lang.module.ModuleDescriptor`, returned by `Module::getDescriptor`.
  id: totrans-746
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 其中一些信息仅在同样新引入的类型 `java.lang.module.ModuleDescriptor` 上可用，该类型由 `Module::getDescriptor`
    返回。
- en: One way to get instances of `Module` is to call `getModule` on any `Class` instance,
    which, no big surprise, returns the module to which that class belongs. The following
    listing shows how to analyze a module by querying `Module` and `ModuleDescriptor`;
    the output for some example modules is shown in [listing 12.8](part0027.html#filepos1558184).
  id: totrans-747
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 获取 `Module` 实例的一种方法是在任何 `Class` 实例上调用 `getModule`，这毫不奇怪，返回该类所属的模块。以下列表展示了如何通过查询
    `Module` 和 `ModuleDescriptor` 来分析模块；一些示例模块的输出显示在 [列表 12.8](part0027.html#filepos1558184)
    中。
- en: Listing 12.7 Analyzing a module by querying `Module` and `ModuleDescriptor`
  id: totrans-748
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 12.7 通过查询 `Module` 和 `ModuleDescriptor` 分析模块
- en: '`public static String describe(Module module) { String annotations = Arrays
    .stream(module.getDeclaredAnnotations()) .map(Annotation::annotationType) .map(Object::toString)
    .collect(joining(", ")); ModuleDescriptor md = module.getDescriptor(); if (md
    == null) return "UNNAMED module { }";  return "" + "@[" + annotations + "]\n"
    + md.modifiers() + " module " + md.name() + " @ " + toString(md.rawVersion())
    + " {\n" + "\trequires " + md.requires() + "\n" + "\texports " + md.exports()
    + "\n" + "\topens " + md.opens() + "\n" + "\tcontains " + md.packages() + "\n"
    + "\tmain " + toString(md.mainClass()) + "\n" + "}"; }  private static String
    toString(Optional<?> optional) { return optional.isPresent() ? optional.get().toString()
    : "[]"; }`'
  id: totrans-749
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public static String describe(Module module) { String annotations = Arrays
    .stream(module.getDeclaredAnnotations()) .map(Annotation::annotationType) .map(Object::toString)
    .collect(joining(", ")); ModuleDescriptor md = module.getDescriptor(); if (md
    == null) return "UNNAMED module { }";  return "" + "@[" + annotations + "]\n"
    + md.modifiers() + " module " + md.name() + " @ " + toString(md.rawVersion())
    + " {\n" + "\trequires " + md.requires() + "\n" + "\texports " + md.exports()
    + "\n" + "\topens " + md.opens() + "\n" + "\tcontains " + md.packages() + "\n"
    + "\tmain " + toString(md.mainClass()) + "\n" + "}"; }  private static String
    toString(Optional<?> optional) { return optional.isPresent() ? optional.get().toString()
    : "[]"; }`'
- en: Listing 12.8 Output of calling `describe(Module)` from [listing 12.7](part0027.html#filepos1556405)
  id: totrans-750
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 12.8 从 [列表 12.7](part0027.html#filepos1556405) 调用 `describe(Module)` 的输出
- en: '`> @[] > [] module monitor @ [] { > requires [ > monitor.observer, > monitor.rest
    > monitor.persistence, > monitor.observer.alpha, > mandated java.base (@9.0.4),
    > monitor.observer.beta, > monitor.statistics] > exports [] > opens [] > contains
    [monitor] > main monitor.Main > } > > @[] > [] module monitor.persistence @ []
    { > requires [ > hibernate.jpa, > mandated java.base (@9.0.4), > monitor.statistics]
    > exports [monitor.persistence] > opens [monitor.persistence.entity] > contains
    [ > monitor.persistence, > monitor.persistence.entity] > main [] > } > > @[] >
    [] module java.logging @ 9.0.4 { > requires [mandated java.base] > exports [java.util.logging]
    > opens [] > contains [ > java.util.logging, > sun.util.logging.internal, > sun.net.www.protocol.http.logging,
    > sun.util.logging.resources] > main [] > } > > @[] > [] module java.base @ 9.0.4
    { > requires [] > exports [... lots ...] > opens [] > contains [... lots ...]
    > main [] > }`'
  id: totrans-751
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> @[] > [] 模块监控器 @ [] { > requires [ > monitor.observer, > monitor.rest >
    monitor.persistence, > monitor.observer.alpha, > mandated java.base (@9.0.4),
    > monitor.observer.beta, > monitor.statistics] > exports [] > opens [] > contains
    [monitor] > main monitor.Main > } > > @[] > [] 模块 monitor.persistence @ [] { >
    requires [ > hibernate.jpa, > mandated java.base (@9.0.4), > monitor.statistics]
    > exports [monitor.persistence] > opens [monitor.persistence.entity] > contains
    [ > monitor.persistence, > monitor.persistence.entity] > main [] > } > > @[] >
    [] 模块 java.logging @ 9.0.4 { > requires [mandated java.base] > exports [java.util.logging]
    > opens [] > contains [ > java.util.logging, > sun.util.logging.internal, > sun.net.www.protocol.http.logging,
    > sun.util.logging.resources] > main [] > } > > @[] > [] 模块 java.base @ 9.0.4
    { > requires [] > exports [... lots ...] > opens [] > contains [... lots ...]
    > main [] > }`'
- en: 'Some `ModuleDescriptor` methods return information related to other modules:
    for example, which modules are required, or to which modules packages are exported
    and opened. These are just module names as strings, not actual `Module` instances.
    At the same time, many methods of `Module` require such instances as input. So
    you get strings out, but you need to put modules in—how do you bridge that gap?
    As section 12.4.1 shows, the answer is layers.'
  id: totrans-752
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些`ModuleDescriptor`方法返回与其它模块相关的信息：例如，哪些模块是必需的，或者哪些模块的包被导出和公开。这些只是作为字符串的模块名称，而不是实际的`Module`实例。同时，许多`Module`方法需要这样的实例作为输入。因此，您得到的是字符串，但需要将模块放入——如何弥合这个差距？正如第12.4.1节所示，答案是层。
- en: 12.3.4 MODIFYING MODULE PROPERTIES WITH REFLECTION
  id: totrans-753
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.3.4 使用反射修改模块属性
- en: 'In addition to analyzing a module’s properties, you can also use `Module` to
    modify them by calling these methods:'
  id: totrans-754
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了分析模块属性外，您还可以使用`Module`通过调用这些方法来修改它们：
- en: '`addExports` exports a package to a module.'
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addExports`将包导出到模块。'
- en: '`addOpens` opens a package to a module.'
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addOpens`向模块公开一个包。'
- en: '`addReads` lets the module read another one.'
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addReads`允许模块读取另一个模块。'
- en: '`addUses` makes the module use a service.'
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addUses`使模块使用一个服务。'
- en: When looking these over, you may wonder why it’s possible to export or open
    packages of a module. Doesn’t that go against strong encapsulation? Didn’t we
    spend all of section 12.2 discussing what the module owner has to do to prepare
    for reflection because the reflecting code can’t break in?
  id: totrans-759
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在查看这些内容时，您可能会 wonder为什么可以导出或公开模块的包。这难道不是与强封装相矛盾吗？我们不是在第12.2节中讨论了模块所有者必须做什么来为反射做准备，因为反射代码不能破坏吗？
- en: 'ESSENTIAL INFO Here’s the thing: these methods are caller sensitive, meaning
    they behave differently based on the code that calls them. For the call to succeed,
    it either has to come from within the module that’s being modified or from the
    unnamed module. Otherwise it will fail with an `IllegalCallerException`.'
  id: totrans-760
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的信息：这些方法是调用者敏感的，这意味着它们根据调用它们的代码表现不同。为了成功调用，它必须来自正在修改的模块内部或来自未命名的模块。否则，它将失败并抛出`IllegalCallerException`。
- en: 'Take the following code as an example:'
  id: totrans-761
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码作为示例：
- en: '`public boolean openJavaLangTo(Module module) { Module base = Object.class.getModule();
    base.addOpens("java.lang", module); return base.isOpen("java.lang", module); }`'
  id: totrans-762
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public boolean openJavaLangTo(Module module) { Module base = Object.class.getModule();
    base.addOpens("java.lang", module); return base.isOpen("java.lang", module); }`'
- en: 'If copied into a `main` method that’s executed from the class path (so it runs
    in the unnamed module), this works fine, and the method returns `true`. If, on
    the other hand, it runs from within any named module (open.up in the following
    example), it fails:'
  id: totrans-763
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果将其复制到从类路径执行的`main`方法中（因此它在未命名的模块中运行），这将正常工作，并且方法返回`true`。另一方面，如果它从任何命名模块（以下示例中的open.up）内部运行，它将失败：
- en: '`> Exception in thread "main" java.lang.IllegalCallerException: > java.lang
    is not open to module open.up > at java.base/java.lang.Module.addOpens(Module.java:751)
    > at open.up/open.up.Main.openJavaLangTo(Main.java:18) > at open.up/open.up.Main.main(Main.java:14)`'
  id: totrans-764
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> Exception in thread "main" java.lang.IllegalCallerException: > java.lang
    is not open to module open.up > at java.base/java.lang.Module.addOpens(Module.java:751)
    > at open.up/open.up.Main.openJavaLangTo(Main.java:18) > at open.up/open.up.Main.main(Main.java:14)`'
- en: 'You can make it work (again) by injecting the code into the module it modifies,
    namely java.base, with `--patch-module` (see section 7.2.4):'
  id: totrans-765
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以通过将代码注入它修改的模块（即java.base）并使用`--patch-module`（参见第7.2.4节）来使其（再次）工作：
- en: '`$ java --patch-module java.base=open.up.jar --module java.base/open.up.Main
    > WARNING: module-info.class ignored in patch: open.up.jar > true`'
  id: totrans-766
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ java --patch-module java.base=open.up.jar --module java.base/open.up.Main
    > WARNING: module-info.class ignored in patch: open.up.jar > true`'
- en: 'There you go: the final `true` is the return value from `openJavaLangTo` called
    with an arbitrary platform module.'
  id: totrans-767
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这样就完成了：最后的`true`是从带有任意平台模块的`openJavaLangTo`调用返回的值。
- en: 'Dynamically modifying your own modules’ properties isn’t something you’ll do
    on a regular basis, even if you’re developing a reflection-based framework. So
    why am I telling you all this? Because as you’ll see in the following section,
    one interesting detail is hidden in here: you can open other modules’ packages
    under certain circumstances.'
  id: totrans-768
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 动态修改您自己的模块属性不是您会经常做的事情，即使您正在开发基于反射的框架。那么，为什么我要告诉您所有这些？因为正如您将在下一节中看到的那样，这里隐藏了一个有趣的细节：在特定情况下，您可以打开其他模块的包。
- en: 12.3.5 FORWARDING OPEN PACKAGES
  id: totrans-769
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.3.5 前向公开包
- en: I said that only a module could open one of its packages with `Module:addOpens`,
    but that’s not entirely true. If a module’s package is already opened to a set
    of other modules, then all those modules can also open that package. In other
    words, modules with reflective access to a package can open that package to other
    modules. What does that mean?
  id: totrans-770
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我说过只有模块可以通过`Module:addOpens`打开其包中的一个，但这并不完全正确。如果一个模块的包已经对一组其他模块打开，那么所有这些模块也可以打开该包。换句话说，具有对包进行反射访问的模块可以将该包打开给其他模块。这意味着什么呢？
- en: 'Once again, think about JPA. You may have flinched in section 12.2.2 when it
    looked as if you needed to open a package either unconditionally or to the module
    doing the actual reflection, because in the case of JPA, that would mean something
    like this:'
  id: totrans-771
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 再次思考JPA。你可能在第12.2.2节中退缩了，因为看起来你需要无条件地打开一个包或者打开实际进行反射的模块，因为在JPA的情况下，这意味着如下所示：
- en: '`module monitor.persistence { requires hibernate.jpa; requires monitor.statistics;  exports
    monitor.persistence; // assuming Hibernate were an explicit module opens monitor.persistence.entity
    to hibernate.core; }`'
  id: totrans-772
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.persistence { requires hibernate.jpa; requires monitor.statistics;  exports
    monitor.persistence; // 假设Hibernate是一个显式模块，打开monitor.persistence.entity到hibernate.core;
    }`'
- en: Wouldn’t it be better to open to JPA instead of the specific implementation?
    That’s exactly what’s made possible by enabling modules with reflective access
    to open packages to other modules! This way, JPA’s bootstrapping code can open
    all packages to Hibernate, even those packages that just have reflective access.
  id: totrans-773
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不打开到JPA而不是特定的实现不是更好吗？这正是通过启用具有对包进行反射访问的模块打开包给其他模块的功能所实现的！这样，JPA的引导代码就可以打开所有包给Hibernate，即使那些只有反射访问的包。
- en: So although only the module can add package exports, reads edges, and service
    uses, the rule for opening packages is relaxed, and all modules to which a package
    was opened can open it to other modules. For reflection-based frameworks to make
    use of that, they of course have to be aware of the module system and update their
    code. In the case of JEE technologies, that could still take a while, though,
    unless Eclipse adopts a faster release cycle for Jakarte EE (it took more than
    three years from Java SE 8 to Java EE 8).
  id: totrans-774
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管只有模块可以添加包导出、读取边和服务使用，但打开包的规则已经放宽，所有被打开包的模块都可以将其打开给其他模块。对于基于反射的框架要利用这一点，它们当然必须了解模块系统并更新它们的代码。在JEE技术的情况下，这仍然可能需要一段时间，除非Eclipse为Jakarte
    EE采用更快的发布周期（从Java SE 8到Java EE 8花费了超过三年时间）。
- en: Now that we’ve settled how to reflect over, analyze, and modify an individual
    module, we can take it to the next level, or rather layer as you’ll see in the
    following section, and work with the entire module graph.
  id: totrans-775
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在我们已经解决了如何对单个模块进行反射、分析和修改的问题，我们可以将其提升到下一个层次，或者说在接下来的章节中，我们将看到的工作层，并处理整个模块图。
- en: 12.4 Dynamically creating module graphs with layers
  id: totrans-776
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.4 使用层动态创建模块图
- en: 'In section 12.3, we focused on individual modules: how to reflect over modular
    code and how to analyze and modify a single module’s properties. In this section,
    we’re broadening our scope and looking at entire module graphs.'
  id: totrans-777
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在第12.3节中，我们关注了单个模块：如何对模块代码进行反射以及如何分析和修改单个模块的属性。在本节中，我们扩大了我们的范围，并查看整个模块图。
- en: So far, we’ve left the creation of module graphs to the compiler or JVM, which
    generates them before starting its work. From that moment on, the graph is an
    almost immutable entity that offers no way to add or remove modules.
  id: totrans-778
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到目前为止，我们将模块图的创建留给了编译器或JVM，它们在开始工作之前生成它们。从那时起，图几乎是一个不可变的实体，没有提供添加或删除模块的方法。
- en: Although that’s fine for many run-of-the-mill applications, there are those
    which need more flexibility. Think about application servers or plug-in based
    applications. They need a dynamic mechanism that allows them to load and unload
    classes at run time.
  id: totrans-779
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然这对许多常规应用程序来说很好，但还有一些需要更多灵活性的应用程序。想想应用服务器或基于插件的程序。它们需要一个动态机制，允许它们在运行时加载和卸载类。
- en: As an example, let’s assume the ServiceMonitor application offers an endpoint
    or a graphical interface with which a user can specify that an additional service
    has to be observed. That can be done by instantiating the appropriate `ServiceObserver`
    implementation, but what if that implementation comes from a module that was unknown
    at launch time? Then it (and its dependencies) would have to be loaded dynamically
    at run time.
  id: totrans-780
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，假设ServiceMonitor应用程序提供了一个端点或图形界面，用户可以通过它指定需要观察的附加服务。这可以通过实例化适当的`ServiceObserver`实现来完成，但如果该实现来自启动时未知的模块呢？那么（及其依赖项）就必须在运行时动态加载。
- en: Before the module system, such container applications used bare class loaders
    for dynamic loading and unloading, but wouldn’t it be nice if they, just like
    compiler and JVM, could also take it to a higher level of abstraction and operate
    on modules instead? Fortunately, the module system allows just that by introducing
    the concept of layers. The first thing you need to do is to get to know layers,
    including one that has been around all the time without you knowing (section 12.4.1).
    The next step is to analyze layers (section 12.4.2) before you dynamically create
    your own at run time (section 12.4.3).
  id: totrans-781
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在模块系统之前，此类容器应用程序使用裸类加载器进行动态加载和卸载，但它们是否也能像编译器和JVM一样，将其提升到更高的抽象层次，并操作模块呢？幸运的是，模块系统通过引入层的概念实现了这一点。首先，你需要了解层，包括那些你一直不知道的层（第12.4.1节）。下一步是在运行时动态创建自己的层之前分析层（第12.4.2节）。
- en: 'Note that writing code that deals with layers is even less common than using
    the reflection API. Here’s a simple litmus test: if you’ve never instantiated
    a class loader, you’re unlikely to use layers any time soon. Accordingly, this
    section gives you the lay of the land, so you know your way around, but doesn’t
    go into full detail. Still, you may see something you didn’t know was possible
    and end up with some new ideas.'
  id: totrans-782
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，处理层的代码甚至比使用反射API更不常见。这里有一个简单的试金石：如果你从未实例化过类加载器，你不太可能很快使用层。因此，本节为你提供了地形图，让你知道自己的位置，但不会深入细节。尽管如此，你可能会看到一些你不知道可以实现的事情，并最终得到一些新想法。
- en: 12.4.1 WHAT ARE LAYERS?
  id: totrans-783
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.4.1 层是什么？
- en: 'Definition: Module layer'
  id: totrans-784
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：模块层
- en: A module layer comprises a fully resolved graph of named modules as well as
    the class loader(s) used to load the modules’ classes. Each class loader has an
    unnamed module associated with it (accessible with `ClassLoader::getUnnamedModule`).
    A layer also references one or more parent layers—modules in a layer can read
    modules in the ancestor layers, but not the other way around.
  id: totrans-785
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块层包含一个名为模块的完全解析的图以及用于加载模块类的类加载器（们）。每个类加载器都与一个未命名的模块相关联（可以通过`ClassLoader::getUnnamedModule`访问）。层还引用一个或多个父层——层中的模块可以读取祖先层中的模块，但反之则不行。
- en: Everything we’ve discussed so far about the resolution and relationships between
    modules happens within one module graph. With layers, it’s possible to stack as
    many graphs as you want, so, conceptually, layers add a third dimension to the
    two-dimensional concept of module graphs. Parent layers are defined when a layer
    is created and can’t be changed afterward, so there’s no way to create cyclic
    layers. [Figure 12.2](part0027.html#filepos1575315) shows a module graph with
    layers.
  id: totrans-786
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们到目前为止讨论的所有关于模块的解析和关系都发生在单个模块图中。使用层，可以堆叠尽可能多的图，因此，从概念上讲，层为二维模块图的概念添加了第三个维度。父层在创建层时定义，之后不能更改，因此无法创建循环层。[图12.2](part0027.html#filepos1575315)显示了带有层的模块图。
- en: '![](../images/00121.jpeg)'
  id: totrans-787
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图](../images/00121.jpeg)'
- en: '[Figure 12.2](part0027.html#filepos1574970) With layers, module graphs can
    be stacked, adding a third dimension to your mental model of the application.
    Because they don’t share class loaders, layers are well-isolated from one another.
    (Like every good computer science graph, this one may look upside down. Parent
    layers are below their children because that keeps the layer containing the platform
    modules at the bottom.)'
  id: totrans-788
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![图12.2](part0027.html#filepos1574970) 使用层，模块图可以堆叠，为你的应用程序的心理模型添加第三个维度。因为它们不共享类加载器，所以层之间很好地隔离。（像每个好的计算机科学图一样，这个图可能看起来是颠倒的。父层位于其子层下方，因为这样可以保持包含平台模块的层在底部。）'
- en: For ServiceMonitor, that means in order to dynamically load the new observer
    implementation, it needs to create a new layer. Before we come to that in section
    12.4.3, let’s take a closer look at existing layers and how to analyze them.
  id: totrans-789
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于 ServiceMonitor 来说，这意味着为了动态加载新的观察者实现，它需要创建一个新的层。在我们第12.4.3节中讨论这一点之前，让我们更仔细地看看现有的层以及如何分析它们。
- en: Are all modules contained in a layer? Almost. As you’ve seen, technically speaking,
    the unnamed modules aren’t. And then there are so-called dynamic modules, which
    don’t have to belong to a layer, but I’m not covering them in this book. These
    exceptions aside, all modules are part of a layer.
  id: totrans-790
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有的模块都包含在一个层中吗？几乎是这样。正如你所看到的，从技术上来说，未命名的模块不是。然后还有所谓的动态模块，它们不必属于一个层，但我在这本书中不会涉及它们。除了这些例外，所有模块都是层的组成部分。
- en: THE BOOT LAYER
  id: totrans-791
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**引导层**'
- en: What about all the application and platform modules that were put into a graph
    throughout this book? They should also belong to a layer, right?
  id: totrans-792
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 那么，在这本书中通过图形放入的所有应用程序和平台模块呢？它们也应该属于一个层，对吧？
- en: 'Definition: Boot layer'
  id: totrans-793
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：引导层
- en: Indeed they do. When launching, the JVM creates an initial layer, the boot layer,
    which contains the application and platform modules that were resolved based on
    the command-line options.
  id: totrans-794
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 的确如此。在启动时，JVM创建一个初始层，即引导层，它包含根据命令行选项解析的应用程序和平台模块。
- en: 'The boot layer has no parent and contains three class loaders:'
  id: totrans-795
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 引导层没有父层，包含三个类加载器：
- en: The boot class loader grants all classes it loads all security permissions,
    so an effort is made by the JDK team to minimize the modules it’s responsible
    for; these are a few core platform modules, chief among them java.base.
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导类加载器为它加载的所有类授予所有安全权限，因此JDK团队努力最小化它负责的模块；这些是一些核心平台模块，其中最重要的是 java.base。
- en: The platform class loader loads classes from all other platform modules; it
    can be accessed with the static method `ClassLoader::getPlatformClassLoader`.
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台类加载器从所有其他平台模块中加载类；可以通过静态方法 `ClassLoader::getPlatformClassLoader` 访问它。
- en: The system or application class loader loads all classes from the module and
    class path, which means it’s responsible for all application modules; it can be
    accessed with the static method `ClassLoader::getSystemClassLoader`.
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统或应用程序类加载器从模块和类路径中加载所有类，这意味着它负责所有应用程序模块；可以通过静态方法 `ClassLoader::getSystemClassLoader`
    访问它。
- en: Only the system class loader has access to the class path, so of these three
    loaders, only its unnamed module will ever be non-empty. Hence, when section 8.2
    talks about the unnamed module, it always references the system class loader’s.
  id: totrans-799
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只有系统类加载器可以访问类路径，因此在这三个加载器中，只有它的未命名模块可能不为空。因此，当第8.2节提到未命名模块时，它总是引用系统类加载器的。
- en: 'As you can see in [figure 12.3](part0027.html#filepos1580663), class loaders
    aren’t islands: each class loader has a parent, and most implementations, including
    the three just mentioned, first ask the parent to load a class before trying to
    look it up themselves. For the three boot-layer class loaders, boot is the parent-less
    ancestor, platform delegates to boot, and system delegates to platform. As a consequence,
    the system class loader has access to all application and JDK classes from the
    boot and platform loaders.'
  id: totrans-800
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如你在[图12.3](part0027.html#filepos1580663)中可以看到的，类加载器不是孤岛：每个类加载器都有一个父类加载器，包括刚刚提到的三个在内的大多数实现，首先会请求父类加载器加载一个类，然后再尝试自己查找。对于三个引导层类加载器，引导层是没有任何父类的祖先，平台委托给引导层，系统委托给平台。因此，系统类加载器可以访问来自引导层和平台加载器的所有应用程序和JDK类。
- en: '![](../images/00028.jpeg)'
  id: totrans-801
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00028.jpeg)'
- en: '[Figure 12.3](part0027.html#filepos1579881) Delegation between the three class
    loaders in the boot layer'
  id: totrans-802
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '![图12.3](part0027.html#filepos1579881) 引导层中三个类加载器之间的委托'
- en: 12.4.2 ANALYZING LAYERS
  id: totrans-803
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.4.2 分析层
- en: 'Definition: ModuleLayer'
  id: totrans-804
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：ModuleLayer
- en: 'At run time, layers are represented by`java.lang.ModuleLayer` instances. They
    can be queried for the three things a layer is made up of:'
  id: totrans-805
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在运行时，层由 `java.lang.ModuleLayer` 实例表示。它们可以查询层由以下三个部分组成：
- en: 'The modules:'
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块：
- en: The method `modules()` returns the modules the layer contains as a `Set<Module>`.
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法 `modules()` 返回层包含的模块，作为一个 `Set<Module>`。
- en: The method `findModule(String)`searches the layer itself and all its ancestor
    layers for a module with the specified name. It returns an `Optional<Module>`
    because it may not find it.
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法 `findModule(String)` 在自身层以及所有祖先层中搜索具有指定名称的模块。因为它可能找不到，所以它返回一个 `Optional<Module>`。
- en: The layer’s parents are returned as `List<ModuleLayer>` by the `parents()` method.
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`parents()`方法，层的父级以`List<ModuleLayer>`的形式返回。
- en: Each module’s class loader can be determined by calling `findLoader(String)`
    with a module’s name.
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`findLoader(String)`并传递模块的名称，可以确定每个模块的类加载器。
- en: Then there’s the `configuration` method, which returns a `Configuration` instance—see
    section 12.4.3 for more on that.
  id: totrans-811
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后是`configuration`方法，它返回一个`Configuration`实例——有关更多内容，请参阅第12.4.3节。
- en: 'To get hold of a `ModuleLayer` instance, you can ask any module for the layer
    it belongs to:'
  id: totrans-812
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要获取`ModuleLayer`实例，您可以要求任何模块提供它所属的层：
- en: '`Class<?> type = // ... any class ModuleLayer layer = type .getModule() .getLayer();`'
  id: totrans-813
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Class<?> type = // ... 任何类 ModuleLayer layer = type .getModule() .getLayer();`'
- en: The last line returns `null` if the type comes from an unnamed module or a dynamic
    module that doesn’t belong to a layer. If you want to access the boot layer, you
    can call the static `ModuleLayer::boot` method.
  id: totrans-814
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果类型来自未命名的模块或不属于层的动态模块，则最后一行返回`null`。如果您想访问引导层，可以调用静态的`ModuleLayer::boot`方法。
- en: So what can you learn from `ModuleLayer` instances? Undoubtedly the most interesting
    methods are `modules()` and `findModule(String)`, because together with the methods
    on `Module` (see section 12.3.3), they allow the traversal and analysis of the
    module graph.
  id: totrans-815
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 那么，从`ModuleLayer`实例中你可以学到什么？毫无疑问，最有趣的方法是`modules()`和`findModule(String)`，因为与`Module`上的方法（参见第12.3.3节）一起，它们允许遍历和分析模块图。
- en: DESCRIBING A MODULE LAYER
  id: totrans-816
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**描述模块层**'
- en: 'Given the `describe(Module)` method in [listing 12.7](part0027.html#filepos1556405),
    this is how an entire layer could be described:'
  id: totrans-817
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定[列表12.7](part0027.html#filepos1556405)中的`describe(Module)`方法，这就是如何描述整个层的方法：
- en: '`private static String describe(ModuleLayer layer) { return layer .modules().stream()
    .map(ThisClass::describe) .collect(joining("\n\n")); }`'
  id: totrans-818
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`private static String describe(ModuleLayer layer) { return layer .modules().stream()
    .map(ThisClass::describe) .collect(joining("\n\n")); }`'
- en: FINDING MODULES IN AND ACROSS LAYERS
  id: totrans-819
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**在层内和层间查找模块**'
- en: It’s also possible to determine the presence or absence of specific modules,
    which can come in handy if the dependency on them is optional (with `requires
    static`; see section 11.2). In section 11.2.4, I claimed that it would be straightforward
    to implement a method `isModulePresent(String)` to do that. That makes you put
    into practice what you learned about layers so far, so let’s do it step by step.
  id: totrans-820
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还可以确定特定模块的存在或不存在，如果对这些模块的依赖是可选的（使用`requires static`；参见第11.2节）。在第11.2.4节中，我声称实现一个名为`isModulePresent(String)`的方法来做这件事是直接的。这使你将迄今为止学到的关于层的内容付诸实践，所以让我们一步一步来做。
- en: 'At first it seems to be pretty trivial:'
  id: totrans-821
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 起初这似乎很简单：
- en: '`public boolean isModulePresent(String moduleName) { return ModuleLayer .boot()
    .findModule(moduleName) .isPresent(); }`'
  id: totrans-822
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public boolean isModulePresent(String moduleName) { return ModuleLayer .boot()
    .findModule(moduleName) .isPresent(); }`'
- en: 'But that only shows whether the module is present in the boot layer. What if
    additional layers were created, and the module is in another layer? You can replace
    the boot layer with the layer that contains `isModulePresent`:'
  id: totrans-823
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但这仅显示模块是否存在于引导层。如果创建了额外的层，并且模块位于另一个层中怎么办？您可以替换引导层为包含`isModulePresent`的层：
- en: '`public boolean isModulePresent(String moduleName) { return searchRootModuleLayer()
    .findModule(moduleName) .isPresent(); }  private ModuleLayer searchRootModuleLayer()
    { return this .getClass() .getModule() .getLayer(); }`'
  id: totrans-824
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public boolean isModulePresent(String moduleName) { return searchRootModuleLayer()
    .findModule(moduleName) .isPresent(); }  private ModuleLayer searchRootModuleLayer()
    { return this .getClass() .getModule() .getLayer(); }`'
- en: This way, `isModulePresent` searches the layer containing itself—let’s call
    it `search`—as well as all parent layers. But even that isn’t good enough. The
    module calling that method could be in a different layer, named `call`, which
    has `search` as an ancestor. (Confused? See [figure 12.4](part0027.html#filepos1590377).)
    Then `search` can’t look into `call` and hence can’t search through all possible
    modules. No, you need the module of the caller to use its layer as the root for
    your search.
  id: totrans-825
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这样，`isModulePresent`会搜索包含自身的层——让我们称它为`search`——以及所有父层。但即使这样也不够好。调用该方法的模块可能位于不同的层，称为`call`，该层将`search`作为祖先。（困惑吗？参见[图12.4](part0027.html#filepos1590377)。）然后`search`无法查看`call`，因此无法搜索所有可能的模块。不，您需要调用者的模块来使用其层作为搜索的根。
- en: '![](../images/00035.jpeg)'
  id: totrans-826
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00035.jpeg)'
- en: '[Figure 12.4](part0027.html#filepos1589598) A layer asked to find a module
    only scans itself and its parents (in this graph, that’s downward). So if `search`
    queries its own layer, it may ignore layers that call, the module initiating the
    search, can see, thus running the risk of returning a wrong result. That’s why
    it’s important to query call’s layer.'
  id: totrans-827
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图12.4](part0027.html#filepos1589598) 请求查找模块的层只扫描它自己和它的父级（在这个图中，是向下）。所以如果`search`查询它自己的层，它可能会忽略调用层，即启动搜索的模块可以看到的层，从而冒着返回错误结果的风险。这就是为什么查询调用层很重要。'
- en: The following listing implements `getCallerClass`, which determines the caller’s
    class with the stack-walking API that Java 9 introduced.
  id: totrans-828
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下列表实现了`getCallerClass`，它使用Java 9引入的堆栈遍历API确定调用者的类。
- en: Listing 12.9 New API to walk the call stack
  id: totrans-829
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表12.9 新的API用于遍历调用栈
- en: '`private Class<?> getCallerClass() { return StackWalker` `.getInstance(RETAIN_CLASS_REFERENCE)`
    [`①`](part0027.html#filepos1593722)`.walk(stack -> stack` [`②`](part0027.html#filepos1594137)`.filter(frame
    ->` [`③`](part0027.html#filepos1594675) `frame.getDeclaringClass() != this.getClass())`
    `.findFirst()` [`③`](part0027.html#filepos1594675)`.map(StackFrame::getDeclaringClass)`
    [`④`](part0027.html#filepos1595139)`.orElseThrow(IllegalStateException::new)`
    [`⑤`](part0027.html#filepos1595462) `); }`'
  id: totrans-830
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`private Class<?> getCallerClass() { return StackWalker.getInstance(RETAIN_CLASS_REFERENCE).walk(stack
    -> stack.filter(frame -> frame.getDeclaringClass() != this.getClass()).findFirst().map(StackFrame::getDeclaringClass).orElseThrow(IllegalStateException::new));
    }`'
- en: ①
  id: totrans-831
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Static factory method to get a StackWalker instance where each frame has a reference
    to the declaring Class
  id: totrans-832
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 静态工厂方法用于获取一个StackWalker实例，其中每个帧都引用了声明类
- en: ②
  id: totrans-833
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: StackWalker::walk expects a function from a Stream<StackFrame> to an arbitrary
    object. It creates a lazy view of the stack and immediately calls the function
    with it. The object the function returns is then returned by walk.
  id: totrans-834
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: StackWalker::walk期望一个从Stream<StackFrame>到任意对象的函数。它创建了一个对堆栈的懒视图，并立即用它调用函数。函数返回的对象随后由walk返回。
- en: ③
  id: totrans-835
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: You’re interested in the first frame that comes from a class that isn’t this
    one (that must be the caller!); you now have an Optional<StackFrame>.
  id: totrans-836
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你对来自不是这个类的第一个帧感兴趣（这必须是调用者！）；你现在有一个Optional<StackFrame>。
- en: ④
  id: totrans-837
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ④
- en: Gets that class
  id: totrans-838
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 获取那个类
- en: ⑤
  id: totrans-839
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⑤
- en: It would be weird if no such frame existed …
  id: totrans-840
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果没有这样的帧存在，那就奇怪了……
- en: 'With that in your toolbox, the caller’s module is at your fingertips:'
  id: totrans-841
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在你的工具箱中有这个，调用者的模块就在你的指尖：
- en: '`public boolean isModulePresent(String moduleName) { return searchRootModuleLayer()
    .findModule(moduleName) .isPresent(); }  private ModuleLayer searchRootModuleLayer()
    { return getCallerClass() .getModule() .getLayer(); }`'
  id: totrans-842
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public boolean isModulePresent(String moduleName) { return searchRootModuleLayer().findModule(moduleName).isPresent();
    } private ModuleLayer searchRootModuleLayer() { return getCallerClass().getModule().getLayer();
    }`'
- en: 'That’s it for analyzing layers. Now we can finally get to the most exciting
    part: loading new code into a running application by create new layers.'
  id: totrans-843
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 分析层到此结束。现在我们终于可以进入最激动人心的部分：通过创建新层将新代码加载到运行中的应用程序中。
- en: 12.4.3 CREATING MODULE LAYERS
  id: totrans-844
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 12.4.3 创建模块层
- en: Only a fraction of the applications written with Java need to dynamically load
    code at run time. At the same time, these tend to be the more important ones.
    Maybe the best-known is Eclipse, with its strong focus on plugins, but application
    servers like WildFly and GlassFish also have to load code from one or several
    applications at the same time. As discussed in section 1.7.3, OSGi is also able
    to dynamically load and unload bundles (its name for modules).
  id: totrans-845
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只有少数用Java编写的应用程序需要在运行时动态加载代码。同时，这些往往是更重要的。最著名的可能是Eclipse，它对插件有很强的关注，但像WildFly和GlassFish这样的应用服务器也必须同时从一个或多个应用程序中加载代码。如1.7.3节所述，OSGi也能够动态加载和卸载包（它对模块的称呼）。
- en: 'They all have the same fundamental requirements for the mechanism they use
    to load plugins, applications, bundles, and other new fragments of the running
    JVM:'
  id: totrans-846
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它们对它们使用的加载插件、应用程序、包和其他运行JVM的新片段的机制有相同的基本要求：
- en: It must be possible to spin up a fragment from set of JARs at run time.
  id: totrans-847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须能够在运行时从一组JAR文件中启动一个片段。
- en: It must allow interaction with the loaded fragments.
  id: totrans-848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须允许与加载的片段交互。
- en: It must allow isolation between different fragments.
  id: totrans-849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须允许不同片段之间的隔离。
- en: Before the module system, this was done with class loaders. Briefly summarized,
    a new class loader was created for the new JARs. It delegated to another class
    loader, such as the system class loader, which gave it access to other classes
    in the running JVM. Although each class, identified by its fully qualified name,
    can exist only once per class loader, it can easily be loaded by several loaders.
    This isolates fragments and gives each the possibility of coming up with its own
    dependencies without conflicting with other fragments.
  id: totrans-850
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在模块系统之前，这是通过类加载器完成的。简要来说，为新的 JAR 文件创建了一个新的类加载器。它委托给另一个类加载器，例如系统类加载器，这使它能够访问运行中的
    JVM 中的其他类。尽管每个类（通过其完全限定名标识）在每个类加载器中只能存在一次，但它可以很容易地被多个加载器加载。这隔离了片段，并给每个片段提供了在没有与其他片段冲突的情况下提出其自身依赖的可能性。
- en: The module system didn’t change this in any way. Leaving existing class-loader
    hierarchies intact was one of the driving reasons for implementing the module
    system below the class loaders (see section 1.7.3). What the module system adds
    is the notion of layers around class loaders, which enable integration with the
    modules loaded at launch time. Let’s see how you can create one. (You can find
    the variant of ServiceMonitor that creates layers in the branch `feature-layers`.)
  id: totrans-851
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块系统在这方面没有改变。保持现有的类加载器层次结构完整是实施模块系统在类加载器之下（见第 1.7.3 节）的主要驱动因素之一。模块系统添加的是围绕类加载器的层概念，这使得与启动时加载的模块集成成为可能。让我们看看如何创建一个。你可以找到创建层的
    ServiceMonitor 变体的分支 `feature-layers`）。
- en: CREATING A CONFIGURATION
  id: totrans-852
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建一个配置
- en: An important ingredient of a `ModuleLayer` is a `Configuration`. Creating one
    triggers the module-resolution process (see section 3.4.1), and the created instance
    represents a successfully resolved module graph. The most bare-bones form to create
    a configuration is with the static factory methods `resolve` and `resolveAndBind`.
    The only difference between the two is that the second binds services (see section
    10.1.2), whereas the first doesn’t.
  id: totrans-853
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ModuleLayer` 的一个重要组成部分是 `Configuration`。创建一个会触发模块解析过程（见第 3.4.1 节），创建的实例代表一个成功解析的模块图。创建配置的最基本形式是使用静态工厂方法
    `resolve` 和 `resolveAndBind`。两者之间的唯一区别是第二个会绑定服务（见第 10.1.2 节），而第一个不会。'
- en: 'Both `resolve` and `resolveAndBind` take the same four arguments:'
  id: totrans-854
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`resolve` 和 `resolveAndBind` 都接受相同的四个参数：'
- en: '`ModuleFinder before` is asked to locate modules before looking into the parent
    configurations.'
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在检查父配置之前，`ModuleFinder before` 被要求定位模块。
- en: '`List<Configuration> parents` are the configurations of the parent layers.'
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<Configuration> parents` 是父层的配置。'
- en: '`ModuleFinder after` is asked to locate modules after looking into the parent
    configurations.'
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ModuleFinder after`在检查父配置后会被要求定位模块。'
- en: '`Collection<String> roots` are the root modules for the resolution process.'
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<String> roots` 是解析过程中的根模块。'
- en: Creating a `ModuleFinder` for a module path is as simple as calling `ModuleFinder.of(Path...)`.
    It’s common to try to reference as many modules as possible from the parent layer,
    so the `before` finder is often created without an argument and thus can’t find
    any modules.
  id: totrans-859
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为模块路径创建一个 `ModuleFinder` 与调用 `ModuleFinder.of(Path...)` 一样简单。通常，会尝试尽可能多地从父层引用模块，因此
    `before` 查找器通常在没有参数的情况下创建，因此无法找到任何模块。
- en: For the common case of wanting to create a configuration that has a single parent,
    it’s easier to call the instance methods `resolve` and `resolveAndBind`. They
    have no `List<Configuration> parents` argument and use the current configuration
    as parent.
  id: totrans-860
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于想要创建具有单个父级的配置的常见情况，调用实例方法 `resolve` 和 `resolveAndBind` 更容易。它们没有 `List<Configuration>
    parents` 参数，并使用当前配置作为父级。
- en: 'Let’s say you want to create a configuration with the boot layer as parent
    that emulates the launch command `java --module-path mods --module root` but without
    service binding. For that, you can call `resolve` (so services aren’t bound) on
    the boot layer’s configuration (making it the parent) and pass a module finder
    that looks into the `mods` directory. The following listing shows that: it creates
    a configuration that emulates `java --module-path mods --module initial` minus
    the service binding.'
  id: totrans-861
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你想要创建一个以引导层作为父级的配置，该配置模拟启动命令 `java --module-path mods --module root` 但不进行服务绑定。为此，你可以在引导层的配置（使其成为父级）上调用
    `resolve`（这样就不会绑定服务），并传递一个查看 `mods` 目录的模块查找器。以下列表显示了这一点：它创建了一个模拟 `java --module-path
    mods --module initial` 的配置，但不包括服务绑定。
- en: Listing 12.10 Emulating `java --module-path mods --module`
  id: totrans-862
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 12.10 模拟 `java --module-path mods --module`
- en: '`ModuleFinder emptyBefore = ModuleFinder.of();` [`①`](part0027.html#filepos1605567)`ModuleFinder
    modulePath = ModuleFinder.of(Paths.get("mods"));` [`②`](part0027.html#filepos1605935)
    `Configuration bootGraph = ModuleLayer.boot().configuration();` `Configuration
    graph = bootGraph` [`③`](part0027.html#filepos1606335) `.resolve(emptyBefore,
    modulePath, List.of("initial"));`'
  id: totrans-863
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ModuleFinder emptyBefore = ModuleFinder.of();` [`①`](part0027.html#filepos1605567)`ModuleFinder
    modulePath = ModuleFinder.of(Paths.get("mods"));` [`②`](part0027.html#filepos1605935)
    `Configuration bootGraph = ModuleLayer.boot().configuration();` `Configuration
    graph = bootGraph` [`③`](part0027.html#filepos1606335) `.resolve(emptyBefore,
    modulePath, List.of("initial"));`'
- en: ①
  id: totrans-864
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: No need to find modules before looking into the parent graph
  id: totrans-865
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在查看父图之前不需要查找模块
- en: ②
  id: totrans-866
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: The finder for modules that don’t exist in the parent graph looks into the mods
    directory.
  id: totrans-867
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查找父图中不存在的模块的查找器查看mods目录。
- en: ③
  id: totrans-868
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: Defines the boot layer’s configuration as parent by calling resolve on it (resolveAndBind
    would bind services)
  id: totrans-869
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过调用resolve来定义引导层的配置作为父层（resolveAndBind会绑定服务）
- en: As a second example, let’s turn back to the scenario where you want ServiceMonitor
    to start observing new services at run time, for which new `ServiceObserver` implementations
    need to be loaded. The first step is to create a configuration with the current
    layer as parent that looks up modules on a specified path.
  id: totrans-870
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为第二个例子，让我们回到这样一个场景：你希望在运行时让ServiceMonitor开始观察新的服务，为此需要加载新的`ServiceObserver`实现。第一步是创建一个配置，以当前层为父层，在指定的路径上查找模块。
- en: Because you’re using the module system’s service infrastructure for your services,
    you call `resolveAndBind`. You can solely depend on that mechanism to find all
    the modules you need (and their dependencies), so you don’t even need to specify
    root modules. Here’s the implementation.
  id: totrans-871
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因为你在你的服务中使用模块系统的服务基础设施，所以调用`resolveAndBind`。你可以完全依赖该机制来查找所有需要的模块（及其依赖项），因此你甚至不需要指定根模块。以下是实现方式。
- en: Listing 12.11 Configuration that binds all modules from specified paths
  id: totrans-872
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表12.11 绑定指定路径上所有模块的配置
- en: '`private static Configuration createConfiguration(Path[] modulePaths) {` `return
    getThisLayer()` [`①`](part0027.html#filepos1609103) `.configuration()` `.resolveAndBind(`
    [`②`](part0027.html#filepos1609486) `ModuleFinder.of(), ModuleFinder.of(modulePaths),`
    `Collections.emptyList()` [`③`](part0027.html#filepos1609830) `); }`'
  id: totrans-873
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`private static Configuration createConfiguration(Path[] modulePaths) {` `return
    getThisLayer()` [`①`](part0027.html#filepos1609103) `.configuration()` `.resolveAndBind(`
    [`②`](part0027.html#filepos1609486) `ModuleFinder.of(), ModuleFinder.of(modulePaths),`
    `Collections.emptyList()` [`③`](part0027.html#filepos1609830) `); }`'
- en: ①
  id: totrans-874
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Returns the layer to which the class containing createConfiguration belongs
  id: totrans-875
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回包含createConfiguration的类的层
- en: ②
  id: totrans-876
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Called so that services are resolved
  id: totrans-877
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 被称为服务解析调用
- en: ③
  id: totrans-878
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: You rely on service binding to do the work for you and pull in the desired modules,
    so you define no root modules.
  id: totrans-879
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你依赖服务绑定为你完成工作并拉入所需的模块，因此你不需要定义根模块。
- en: CREATING A MODULELAYER
  id: totrans-880
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建MODULELAYER
- en: 'As described in section 12.4.1, a layer consists of a module graph, class loaders,
    and references to parent layers. The bare-bones form to create a module is with
    the static method `defineModules(Configuration, List<ModuleLayer>, Function<String,
    ClassLoader>)`:'
  id: totrans-881
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如第12.4.1节所述，一个层由模块图、类加载器和父层引用组成。创建模块的裸骨形式是使用静态方法`defineModules(Configuration,
    List<ModuleLayer>, Function<String, ClassLoader>)`：
- en: You already know how to get `Configuration` instances.
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经知道如何获取`Configuration`实例。
- en: The `List<ModuleLayer>` are the parents.
  id: totrans-883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List<ModuleLayer>`是父层。'
- en: The `Function<String, ClassLoader>` maps each module name to the class loader
    you want to be in charge of that module.
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Function<String, ClassLoader>`将每个模块名称映射到你想要负责该模块的类加载器。'
- en: The method returns a `Controller`, which can be used to further edit the module
    graph by adding reads edges or exporting/opening packages before calling `layer()`
    on it, which returns the `ModuleLayer`.
  id: totrans-885
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 该方法返回一个`Controller`，可以用来在调用`layer()`之前进一步编辑模块图，通过添加读取边或导出/打开包，`layer()`返回`ModuleLayer`。
- en: 'There are several alternative methods you can call that build on `defineModules`:'
  id: totrans-886
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有几种替代方法可以调用，这些方法基于`defineModules`：
- en: '`defineModulesWithOneLoader` uses a single class loader for all modules. The
    class loader given as argument to the method becomes its parent.'
  id: totrans-887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defineModulesWithOneLoader`为所有模块使用单个类加载器。方法参数中给出的类加载器成为其父类加载器。'
- en: '`defineModulesWithManyLoaders` uses a separate class loader for each module.
    The class loader given as argument to the method becomes the parent of each of
    them.'
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defineModulesWithManyLoaders`使用为每个模块单独的类加载器。方法参数中给出的类加载器成为每个模块的父类加载器。'
- en: There is a variant of each method that can be called on a `ModuleLayer` instance
    and uses that instance as the parent layer; they return the created layer instead
    of the intermediate `Controller`.
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个方法都有一个变体可以在 `ModuleLayer` 实例上调用，并使用该实例作为父层；它们返回创建的层而不是中间的 `Controller`。
- en: Continuing your quest to dynamically load `ServiceObserver` implementations,
    the next step is to create the actual layer from the configuration. That’s fairly
    simple, as the following listing shows.
  id: totrans-890
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 继续你的动态加载 `ServiceObserver` 实现的探索之旅，下一步是从配置创建实际层。这相当简单，如下面的列表所示。
- en: Listing 12.12 Creating a layer from a configuration
  id: totrans-891
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 12.12 从配置创建层
- en: '`private static ModuleLayer createLayer(Path[] modulePaths) {` `Configuration
    configuration = createConfiguration(modulePaths);` [`①`](part0027.html#filepos1615355)`ClassLoader
    thisLoader = getThisLoader();` [`②`](part0027.html#filepos1615792)`return getThisLayer()`
    [`③`](part0027.html#filepos1616184)`.defineModulesWithOneLoader(configuration,
    thisLoader);` [`④`](part0027.html#filepos1616617) `}`'
  id: totrans-892
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`private static ModuleLayer createLayer(Path[] modulePaths) {` `Configuration
    configuration = createConfiguration(modulePaths);` [`①`](part0027.html#filepos1615355)`ClassLoader
    thisLoader = getThisLoader();` [`②`](part0027.html#filepos1615792)`return getThisLayer();`
    [`③`](part0027.html#filepos1616184)`defineModulesWithOneLoader(configuration,
    thisLoader);` [`④`](part0027.html#filepos1616617)`}` '
- en: ①
  id: totrans-893
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Creates the configuration as in [listing 12.11](part0027.html#filepos1608008)
  id: totrans-894
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建配置，如[列表 12.11](part0027.html#filepos1608008)
- en: ②
  id: totrans-895
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: getThisLoader returns the class loader that loaded the class containing createLayer.
  id: totrans-896
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: getThisLoader 返回加载包含 createLayer 的类的类加载器
- en: ③
  id: totrans-897
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: The same as getThisLayer in [listing 12.11](part0027.html#filepos1608008)
  id: totrans-898
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与[列表 12.11](part0027.html#filepos1608008)中的 getThisLayer 相同
- en: ④
  id: totrans-899
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ④
- en: You only want a single loader for all modules with this layer as the parent,
    so you call defineModulesWithOneLoader on it.
  id: totrans-900
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你只想为具有此层作为父级的所有模块使用单个加载器，因此你在其上调用 defineModulesWithOneLoader。
- en: 'The final step is to check whether the freshly created layer contains a `ServiceObserver`
    that can handle the service you need to observe. To that end, you can use an overload
    of `ServiceLoader::load` that expects a `ModuleLayer` in addition to the service
    type it looks up. The semantics should be clear: look into that layer (and its
    ancestors) when locating providers.'
  id: totrans-901
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后一步是检查新创建的层是否包含一个可以处理你需要观察的服务 `ServiceObserver`。为此，你可以使用一个 `ServiceLoader::load`
    的重载版本，它除了查找的服务类型外，还期望一个 `ModuleLayer`。语义应该是清晰的：在定位提供者时，查看该层（及其祖先）。
- en: Listing 12.13 Discovering service providers in a new layer (and its ancestors)
  id: totrans-902
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 12.13 在新层（及其祖先）中查找服务提供者
- en: '`private static void registerNewService( String serviceName, Path... modulePaths)
    {` `ModuleLayer layer = createLayer(modulePaths);` [`①`](part0027.html#filepos1619395)
    `Stream<ServiceObserverFactory> observerFactories = ServiceLoader` `.load(layer,
    ServiceObserverFactory.class).stream()` [`②`](part0027.html#filepos1619914) `.map(Provider::get);`
    `Optional<ServiceObserver> observer = observerFactories` [`③`](part0027.html#filepos1620285)
    `.map(factory -> factory .createIfMatchingService(serviceName)) .flatMap(Optional::stream)
    .findFirst(); observer.ifPresent(monitor::addServiceObserver); }`'
  id: totrans-903
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`private static void registerNewService(String serviceName, Path... modulePaths)
    {` `ModuleLayer layer = createLayer(modulePaths);` [`①`](part0027.html#filepos1619395)`Stream<ServiceObserverFactory>
    observerFactories = ServiceLoader.load(layer, ServiceObserverFactory.class).stream();`
    [`②`](part0027.html#filepos1619914)`map(Provider::get);` `Optional<ServiceObserver>
    observer = observerFactories.map(factory -> factory.createIfMatchingService(serviceName)).flatMap(Optional::stream).findFirst();
    observer.ifPresent(monitor::addServiceObserver); }`'
- en: ①
  id: totrans-904
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Creates the layer as in [listing 12.1](part0027.html#filepos1480068).2
  id: totrans-905
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建层，如[列表 12.1](part0027.html#filepos1480068).2
- en: ②
  id: totrans-906
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Uses the ServiceLoader::load variant that accepts the new layer
  id: totrans-907
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用接受新层的 ServiceLoader::load 变体
- en: ③
  id: totrans-908
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: The rest is service-business-as-usual to find an observer for serviceName.
  id: totrans-909
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 其余部分是常规服务业务，以找到 serviceName 的观察者。
- en: 'If that wasn’t enough for you, there are a few more things we’ve barely touched
    on that you can do with module layers:'
  id: totrans-910
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果这些还不够，还有一些我们几乎没提到的事情，你可以用模块层来做：
- en: Create configurations and layers with several parents or several class loaders
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个父级或多个类加载器创建配置和层
- en: Use layers to load multiple versions of the same module
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用层来加载同一模块的多个版本
- en: Modify the module graph with the `Controller`—for example, to export or open
    modules—before turning it into a `ModuleLayer`
  id: totrans-913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将其转换为 `ModuleLayer` 之前，使用 `Controller` 修改模块图——例如，导出或打开模块
- en: Directly load-specific classes from the created layers as entry points into
    the fragment, as opposed to using JPMS services
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接从创建的层中加载特定的类作为片段的入口点，而不是使用 JPMS 服务
- en: You can learn more about these from the excellent Javadoc on the involved methods,
    particularly in `ModuleLayer` and `Configuration`. Or flip to section 13.3, which
    makes good use of a few of these possibilities.
  id: totrans-915
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以从涉及方法的优秀 Javadoc 中了解更多信息，特别是在 `ModuleLayer` 和 `Configuration` 中。或者翻到第 13.3
    节，它很好地利用了这些可能性中的几个。
- en: Summary
  id: totrans-916
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Modules that code reflects over:'
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被代码反射的模块：
- en: In most cases, `exports` directives aren’t a good fit for making classes available
    for reflection, because classes you designed to be used with reflection-based
    frameworks are rarely suited to be part of a module’s public API; with qualified
    exports, you may be forced to couple your module to an implementation instead
    of a standard; and exports don’t support deep reflection over nonprivate fields
    and methods.
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数情况下，`exports` 指令并不适合用于使类可用于反射，因为为与基于反射的框架一起使用而设计的类很少适合成为模块公共 API 的一部分；使用限定导出，你可能会被迫将你的模块耦合到实现而不是标准；并且导出不支持对非私有字段和方法的深度反射。
- en: By default, you shouldn’t use `exports`, but rather `opens` directives, to open
    packages for reflection.
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，你不应该使用 `exports`，而应该使用 `opens` 指令来打开包以进行反射。
- en: 'The `opens` directive has the same syntax as `exports`, but works differently:
    an opened package isn’t accessible at compile time; and all types and members,
    including nonpublic ones, in an opened package are accessible at run time. These
    properties are closely aligned with the requirements of reflection-based frameworks,
    which makes `opens` directives the default choice when preparing modules for reflection.'
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opens` 指令与 `exports` 具有相同的语法，但工作方式不同：打开的包在编译时不可访问；并且打开包中的所有类型和成员，包括非公共的，在运行时都是可访问的。这些属性与基于反射的框架的要求紧密一致，这使得
    `opens` 指令在为反射准备模块时的默认选择。'
- en: The qualified variant `opens ... to` opens a package just to the named modules.
    Because it’s usually exceedingly obvious which frameworks reflect over which packages,
    it’s questionable whether qualifying `open` directives adds much value.
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限定变体 `opens ... to` 仅将包打开给命名的模块。由于通常非常明显哪些框架会反射哪些包，因此质疑限定 `open` 指令是否增加了多少价值是有疑问的。
- en: If the reflecting framework is split into a standard and its implementations
    (as with JPA and Hibernate, EclipseLink, and so forth), it’s technically possible
    to only open a package to the standard, which can then use the reflection API
    to open it to a specific implementation. This isn’t yet widely implemented, though,
    so for the time being, qualified opens need to name the specific implementation
    modules.
  id: totrans-922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果反射框架分为标准及其实现（如 JPA 和 Hibernate、EclipseLink 等等），从技术上讲，只打开包给标准是可能的，然后它可以使用反射
    API 将其打开到特定的实现。尽管如此，这还没有得到广泛实现，因此目前，限定打开需要指定特定的实现模块。
- en: The command-line option `--add-opens` has the same syntax as `--add-exports`
    and works like a qualified opens. Opening platform modules from the command line
    to access their internals is common during a migration to Java 9+, but you can
    also use it to break into other application modules if you absolutely have to.
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行选项 `--add-opens` 与 `--add-exports` 具有相同的语法，并且像限定 `opens` 一样工作。在迁移到 Java 9+
    期间，从命令行打开平台模块以访问其内部结构是常见的，但如果你绝对需要，你也可以用它来突破其他应用程序模块。
- en: By starting a module declaration with `open module` (instead of just `module`),
    all packages in that module are opened. This is a good solution if a module contains
    a lot of packages that need to be opened, but it should be carefully evaluated
    whether that’s really necessary or could be remedied. Ideally, open modules are
    mostly used during modularization before refactoring a module to a cleaner state
    that exposes less internals.
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过以 `open module`（而不是仅 `module`）开始模块声明，该模块中的所有包都被打开。如果模块包含大量需要打开的包，这是一个很好的解决方案，但应该仔细评估这是否真的必要或是否可以纠正。理想情况下，打开模块主要在模块化之前使用，在将模块重构为更干净的状态并暴露较少内部结构之前。
- en: 'Code that reflects over modules:'
  id: totrans-925
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射模块的代码：
- en: Reflection is bound by the same accessibility rules as regular code. Regarding
    having to read the module that you access, the reflection API makes things easier
    by implicitly adding a reads edge. Regarding exported or opened packages, there’s
    nothing the author of the reflecting code can do about it if a module owner didn’t
    prepare their module for it. (The only solution would be the `--add-opens` command-line
    option.)
  id: totrans-926
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射受限于与常规代码相同的可访问性规则。关于必须读取你访问的模块，反射API通过隐式添加读取边来简化了操作。至于导出或打开的包，如果模块所有者没有为反射准备他们的模块，那么反射代码的作者对此无能为力。（唯一的解决方案可能是使用`--add-opens`命令行选项。）
- en: This makes it all the more necessary to educate users about strong encapsulation
    and which packages your module needs access to. Document that well, and make the
    source easily available.
  id: totrans-927
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得教育用户关于强封装以及你的模块需要访问哪些包变得尤为重要。做好文档记录，并确保源代码易于获取。
- en: Make sure to properly handle exceptions that are thrown due to strong encapsulation,
    so you can provide users with an informative error message, possibly linking to
    your documentation.
  id: totrans-928
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保妥善处理由于强封装而抛出的异常，以便你可以为用户提供一个信息丰富的错误消息，可能还会链接到你的文档。
- en: Consider using variable handles instead of the reflection API. They provide
    more type safety, are more performant, and give you the means to express your
    need for access in your bootstrap API by requiring `Lookup` instances.
  id: totrans-929
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑使用变量句柄而不是反射API。它们提供了更多的类型安全性，性能更优，并且通过要求`Lookup`实例来表达你在引导API中对访问的需求。
- en: A `Lookup` instance offers everybody using it the same accessibility as the
    module that created it. So when your users create a `Lookup` instance in their
    module and pass it to your framework, you can access their module internals.
  id: totrans-930
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lookup`实例为所有使用它的人提供了与创建它的模块相同的可访问性。因此，当你的用户在他们的模块中创建一个`Lookup`实例并将其传递给你的框架时，你可以访问他们的模块内部。'
- en: The new classes `Module` and `ModuleDescriptor` are part of the reflection API
    and give access to all information regarding a module, such as its name, dependencies,
    and exported or opened packages. You can use it to analyze the actual module graph
    at run time.
  id: totrans-931
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的类`Module`和`ModuleDescriptor`是反射API的一部分，提供了关于模块的所有信息，例如它的名称、依赖项以及导出或打开的包。你可以用它来分析运行时的实际模块图。
- en: Using that API, modules can also modify their own properties and export or open
    packages or add reads edges to other modules. It’s generally not possible to modify
    other modules, with the exception that every module to which another module’s
    package was opened can open that package to a third module.
  id: totrans-932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用该API，模块还可以修改自己的属性，导出或打开包，或向其他模块添加读取边。通常无法修改其他模块，但有一个例外，即任何打开另一个模块包的模块都可以将该包打开给第三个模块。
- en: 'Code that dynamically loads modules:'
  id: totrans-933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态加载模块的代码：
- en: Class loaders are the way to dynamically load code into a running program. This
    doesn’t change with the module system, but it does provide a modular wrapper around
    class loaders with layers. A layer encapsulates a class loader and a module graph,
    and creating the latter exposes the loaded modules to all the consistency checks
    and accessibility rules that the module system offers. Layers can hence be used
    to provide reliable configuration and strong encapsulation for the loaded modules.
  id: totrans-934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载器是将代码动态加载到运行程序中的方式。模块系统不会改变这一点，但它确实提供了带有层的模块包装器。层封装了一个类加载器和模块图，创建后者会将加载的模块暴露给模块系统提供的所有一致性检查和可访问性规则。因此，层可以用来为加载的模块提供可靠的配置和强封装。
- en: When launching, the JVM creates the boot layer, which consists of three class
    loaders and all platform and application modules that were initially resolved.
    It can be accessed with the static method `ModuleLayer::boot`, and the returned
    `ModuleLayer` instance can be used to analyze the entire module graph.
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动时，JVM创建引导层，它由三个类加载器和所有最初解析的平台和应用模块组成。它可以通过静态方法`ModuleLayer::boot`访问，返回的`ModuleLayer`实例可以用来分析整个模块图。
- en: '13'
  id: totrans-936
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '13'
- en: 'Module versions: What’s possible and what’s not'
  id: totrans-937
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块版本：可能性和不可能性
- en: This chapter covers
  id: totrans-938
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Why the module system doesn’t act on version information
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么模块系统不对版本信息采取行动
- en: Recording version information
  id: totrans-940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录版本信息
- en: Analyzing version information at run time
  id: totrans-941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时分析版本信息
- en: Loading multiple module versions
  id: totrans-942
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载多个模块版本
- en: As briefly mentioned in section 1.5.6, the JPMS doesn’t support module versions.
    But then what is `jar --module-version` good for? And didn’t section 12.3.3 show
    that `ModuleDescriptor` can at least report a module’s version? This chapter clears
    things up and looks at module versions from a few different angles.
  id: totrans-943
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如第1.5.6节简要提到的，JPMS不支持模块版本。那么`jar --module-version`有什么好处呢？而且第12.3.3节不是显示`ModuleDescriptor`至少可以报告模块的版本吗？本章将澄清这些问题，并从几个不同的角度探讨模块版本。
- en: 'We’ll first discuss in what ways the module system could support versions and
    why it doesn’t do that (section 13.1). It at least allows you to record and evaluate
    version information, though, and we’ll explore that next (section 13.2). Last
    on the list is the Holy Grail: running different versions of the same module (section
    13.3). Although there’s no native support for that, there are ways to make it
    happen with some effort.'
  id: totrans-944
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们首先将讨论模块系统如何支持版本以及为什么它不这样做（第13.1节）。尽管如此，它至少允许你记录和评估版本信息，我们将在下一节中探讨这一点（第13.2节）。列表上的最后一项是圣杯：运行同一模块的不同版本（第13.3节）。尽管没有原生支持，但有一些方法可以通过一些努力实现这一点。
- en: By the end of this chapter, you’ll have a clear understanding of the module
    system’s limited support for versions. This will help you analyze your application
    and can even be used to proactively report possible problems. Maybe more important,
    you’ll also know the reasons for the limitations and whether you can expect them
    to change. You’ll also learn how to run multiple versions of the same module—but
    as you’ll see, it will rarely be worth the effort.
  id: totrans-945
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到本章结束时，你将对模块系统对版本的有限支持有一个清晰的理解。这将帮助你分析你的应用程序，甚至可以用来主动报告可能的问题。也许更重要的是，你还将了解限制的原因，以及你是否可以期待它们发生变化。你还将学习如何运行同一模块的多个版本——但正如你将看到的，这很少值得付出努力。
- en: 13.1 The lack of version support in the JPMS
  id: totrans-946
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 13.1 JPMS中版本支持的缺乏
- en: Java 8 and earlier have no concept of versions. As described in section 1.3.3,
    that can result in unexpected run-time behavior where the only solution may be
    to pick different versions of your dependencies than you’d like. That’s unfortunate,
    and when the module system was first conceived, one of its goals was to remedy
    this situation.
  id: totrans-947
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java 8及之前版本没有版本的概念。如第1.3.3节所述，这可能导致意外的运行时行为，唯一的解决方案可能是选择你不想选择的依赖项的不同版本。这是不幸的，当模块系统最初被构想时，其目标之一就是解决这个问题。
- en: That didn’t happen, though. The module system that’s now operating in Java is
    still comparatively blind to versions. It’s limited to recording a module’s or
    dependency’s version (see section 13.2).
  id: totrans-948
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然如此，但这种情况并未发生。目前Java中运行的模块系统在版本方面仍然相对盲目。它仅限于记录模块或依赖项的版本（参见第13.2节）。
- en: But why is that? Couldn’t the module system support having several versions
    of the same module (section 13.1.1)? If not, couldn’t it at least take a bunch
    of modules and version requirements as input and select a single version for each
    module (section 13.1.2)? The answer to both questions is “no,” and I want to explain
    why.
  id: totrans-949
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但为什么是这样呢？模块系统不能支持同一模块的多个版本吗（第13.1.1节）？如果不能，它至少不能接受一系列模块和版本要求作为输入，并为每个模块选择一个版本吗（第13.1.2节）？这两个问题的答案都是“不”，我想解释一下原因。
- en: 13.1.1 NO SUPPORT FOR MULTIPLE VERSIONS
  id: totrans-950
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 13.1.1 不支持多个版本
- en: A seemingly simple solution to version conflicts would be to allow running two
    versions of the same JAR. Straightforward. So why can’t the module system just
    do that? To answer that question, you have to know how Java loads classes.
  id: totrans-951
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解决版本冲突的一个看似简单的解决方案是允许运行同一JAR的两个版本。简单直接。那么，为什么模块系统不能这样做呢？要回答这个问题，你必须了解Java如何加载类。
- en: HOW CLASS LOADING PREVENTS MULTIPLE VERSIONS
  id: totrans-952
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**如何防止加载多个版本**'
- en: As discussed when we looked at shadowing in section 1.3.2, the JVM—or, more
    precisely, its class loaders—identify classes by their fully qualified name, such
    as `java.util.List` or `monitor.observer.ServiceObserver`. To load a class from
    the class path, the application class loader scans all JARs until it encounters
    a class with the specific name it’s looking for, which it then loads.
  id: totrans-953
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如同我们在第1.3.2节讨论阴影时提到的，JVM——更准确地说，是其类加载器——通过完全限定名识别类，例如`java.util.List`或`monitor.observer.ServiceObserver`。为了从类路径中加载一个类，应用程序类加载器扫描所有JAR文件，直到它遇到一个具有特定名称的类，然后加载它。
- en: ESSENTIAL INFO The critical observation is that it doesn’t matter whether another
    JAR on the class path contains a class with the exact same name—it will never
    be loaded. In other words, the class loader operates under the assumption that
    each class, identified by its fully qualified name, exists exactly once.
  id: totrans-954
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**关键信息** 重要的观察结果是，无论类路径上的另一个JAR文件是否包含具有完全相同名称的类——它永远不会被加载。换句话说，类加载器在假设每个类（通过其完全限定名识别）恰好存在一次的情况下运行。'
- en: 'Turning back to our desire to run multiple versions of the same module, the
    roadblock is apparent: such modules are bound to contain classes with the same
    fully qualified name, and without any changes, the JVM would only ever see one
    of them. What could those changes look like?'
  id: totrans-955
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 回到我们希望运行同一模块的多个版本的需求，障碍显而易见：这样的模块必然包含具有相同完全限定名的类，并且如果没有任何更改，JVM将始终只看到其中之一。这些更改可能看起来是什么样子？
- en: CHANGES TO CLASS LOADING THAT WOULD ALLOW MULTIPLE VERSIONS
  id: totrans-956
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**允许多个版本的类加载器更改**'
- en: 'The first option for allowing several classes with the same name would be to
    rewrite the entire class-loading mechanism so that an individual class loader
    could handle that case. That would be a huge engineering task because the assumption
    that each class loader has at most one class of any given name permeates the entire
    JVM. In addition to the massive effort, it would also carry a lot of risk: it
    would be an invasive change and hence would be almost guaranteed to be backward
    incompatible.'
  id: totrans-957
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 允许多个具有相同名称的类的第一个选项是重写整个类加载机制，以便单个类加载器可以处理这种情况。这将是一个巨大的工程任务，因为每个类加载器最多只有一个给定名称的类的假设贯穿整个JVM。除了巨大的努力之外，它还会带来很多风险：这将是一个侵入性的更改，因此几乎可以保证与向后不兼容。
- en: 'The second option would be to allow multiple classes with the same name to
    do what, for example, OSGi does: use a separate class loader for each module (see
    [figure 13.1](part0028.html#filepos1638350)). That would be comparatively straightforward
    but would also probably cause compatibility issues.'
  id: totrans-958
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第二个选项是允许具有相同名称的多个类执行类似OSGi的操作：为每个模块使用一个单独的类加载器（参见[图13.1](part0028.html#filepos1638350)）。这将相对简单，但也可能引起兼容性问题。
- en: '![](../images/00008.jpeg)'
  id: totrans-959
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00008.jpeg)'
- en: '[Figure 13.1](part0028.html#filepos1637941) The JPMS uses the same class loader
    for all application modules (left), but it’s conceivable that it could use a separate
    loader for each module instead (right). In many cases, that would change the application’s
    behavior, though.'
  id: totrans-960
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图13.1](part0028.html#filepos1637941) JPMS为所有应用程序模块使用相同的类加载器（左侧），但可以设想它可以为每个模块使用一个单独的加载器（右侧）。在许多情况下，这会改变应用程序的行为。'
- en: One potential source of problems is that some tools, frameworks, and even applications
    make specific assumptions about the exact class-loader hierarchy. (By default,
    there are three class loaders that reference one another—this didn’t change in
    Java 9\. The details are explained in the description of the boot layer in section
    12.4.1.) Putting each module in its own class loader would considerably change
    that hierarchy and would probably break most of these projects.
  id: totrans-961
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个潜在的问题来源是，一些工具、框架甚至应用程序对确切的类加载器层次结构做出了特定的假设。（默认情况下，有三个类加载器相互引用——在Java 9中这一点没有改变。详情请参阅第12.4.1节中关于引导层的描述。）将每个模块放入其自己的类加载器中将会显著改变这个层次结构，并且可能会破坏这些项目中的大多数。
- en: There’s another devious detail hidden in changing the hierarchy. Even if you
    were willing to require projects to adapt to that change to run from the module
    path, what would happen if they ran from the class path? Would JARs from the class
    path also each get a separate class loader?
  id: totrans-962
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在改变层次结构中隐藏的另一个狡猾的细节是，即使你愿意要求项目适应这种变化以从模块路径运行，如果它们从类路径运行会发生什么？类路径上的JAR文件也会每个都得到一个单独的类加载器吗？
- en: If so, projects that had trouble with the changed class-loader hierarchy not
    only wouldn’t run as modules, they also wouldn’t even run on Java 9+.
  id: totrans-963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是这样，那些在更改后的类加载器层次结构上遇到麻烦的项目不仅不能作为模块运行，甚至不能在Java 9+上运行。
- en: If not, they would need to be aware of two different class-loading hierarchies
    and correctly interact with each of them, depending on which path they landed
    on.
  id: totrans-964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不是这样，它们需要意识到两个不同的类加载器层次结构，并且根据它们落在哪个路径上，正确地与每个层次结构进行交互。
- en: None of these impacts on compatibility or migration paths are acceptable if
    applied to the entire ecosystem.
  id: totrans-965
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果将这些影响兼容性或迁移路径的更改应用于整个生态系统，则这些更改都是不可接受的。
- en: NOTE The weight of these concerns is different for OSGi. It offers features
    that most applications that use it can’t live without, so their developers can
    be expected to put in more work. Java 9+, on the other hand, also needs to work
    for projects that don’t care about the module system. OSGi is opt-in, so if push
    comes to shove and it doesn’t work out for any specific project, it can be ignored.
    The same is obviously not the case with Java 9+.
  id: totrans-966
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 备注：对于OSGi来说，这些担忧的权重是不同的。它提供了大多数使用它的应用程序无法没有的功能，因此可以预期它们的开发者会投入更多的工作。另一方面，Java
    9+还需要为不关心模块系统的项目工作。OSGi是可选的，所以如果事情变得棘手，并且它对任何特定项目不起作用，可以忽略它。显然，Java 9+的情况并非如此。
- en: ESSENTIAL INFO Another reason a specific class loader per JAR can be problematic
    has to do with class equality. Let’s assume the same class was loaded by two different
    class loaders. Their `Class<?>` instances aren’t equal, because the class loader
    is always included in that check. So? Who cares, right?
  id: totrans-967
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 必要信息：一个JAR文件对应一个特定的类加载器可能存在问题的另一个原因是与类等价性有关。假设同一个类被两个不同的类加载器加载。它们的`Class<?>`实例不相等，因为类加载器总是包含在检查中。那么呢？谁会在意，对吧？
- en: Well, if you have an instance of each class and compare the two, what’s one
    of the first things that happen in the `equals` comparison? It’s `this.getClass()
    == other.getClass()` or an `instanceof` check. In this case, that will always
    be false because the two classes aren’t equal.
  id: totrans-968
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 好吧，如果你有每个类的实例并且比较这两个，`equals`比较中首先发生的事情之一是什么？是`this.getClass() == other.getClass()`或者一个`instanceof`检查。在这种情况下，这总是错误的，因为两个类不相等。
- en: 'That means with two versions of Guava, for example, `mutimap1.equals(multimap2)`
    would always be false, no matter what elements the two `Multimap` instances contained.
    You also couldn’t cast an instance of the class from one class loader to the same
    class loaded from the other, so `(Multimap) multimap2` could fail:'
  id: totrans-969
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这意味着，例如，使用两个版本的Guava，`mutimap1.equals(multimap2)`将始终为false，无论两个`Multimap`实例包含什么元素。你也不能将来自一个类加载器的类的实例转换为来自另一个类加载器的相同类加载的实例，因此`(Multimap)
    multimap2`可能会失败：
- en: '`static boolean equalsImpl(` `Multimap<?, ?> multimap,` [`①`](part0028.html#filepos1644371)`@NullableDecl
    Object object) {` [`②`](part0028.html#filepos1644783) `if (object == multimap)
    { return true; }` `if (object instanceof Multimap) {` [`③`](part0028.html#filepos1645196)
    `Multimap<?, ?> that = (Multimap<?, ?>) object; return multimap.asMap().equals(that.asMap());
    } return false; }`'
  id: totrans-970
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`static boolean equalsImpl(` `Multimap<?, ?> multimap,` [`①`](part0028.html#filepos1644371)`@NullableDecl
    Object object) {` [`②`](part0028.html#filepos1644783) `if (object == multimap)
    { return true; }` `if (object instanceof Multimap) {` [`③`](part0028.html#filepos1645196)
    `Multimap<?, ?> that = (Multimap<?, ?>) object; return multimap.asMap().equals(that.asMap());
    } return false; }`'
- en: ①
  id: totrans-971
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Multimap instance on which equals was called. The method is executed in the
    context of its class loader.
  id: totrans-972
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 被调用equals方法的Multimap实例。该方法在其类加载器的上下文中执行。
- en: ②
  id: totrans-973
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Object passed to the equals call. It’s assumed to be a Multimap instance from
    a different class loader.
  id: totrans-974
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 传递给equals调用的对象。它假定是一个来自不同类加载器的Multimap实例。
- en: ③
  id: totrans-975
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: object is of type Multimap, but it’s from a different class loader, so this
    instanceof check always fails.
  id: totrans-976
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对象是Multimap类型，但它来自不同的类加载器，因此这个instanceof检查总是失败。
- en: It would be nice to know how many projects would be tripped up just by that
    detail. There’s no way to know, but my guess is a lot. Compared to that, chapters
    6 and 7 are outright benign.
  id: totrans-977
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 很想知道有多少项目仅仅因为这个细节而受到影响。没有办法知道，但我的猜测是很多。相比之下，第6章和第7章是直接无害的。
- en: NOTE By the way, everything we’ve just discussed also applies to split packages
    (see section 7.2). Wouldn’t it be nice if the module system didn’t care whether
    two modules contain the same package and could keep them separate? It would, but
    that would run into the same problems we just explored.
  id: totrans-978
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 备注：顺便说一下，我们刚才讨论的每一件事也适用于分割包（见第7.2节）。如果模块系统不关心两个模块是否包含相同的包并且可以保持它们分开，那不是很好吗？它会，但会遇到我们刚才探讨的相同问题。
- en: What we determined so far only means that the module system doesn’t allow multiple
    versions of the same module out of the box. There’s no native support, but that
    doesn’t mean it’s categorically impossible. Take a look at section 13.3 for ways
    to make it work.
  id: totrans-979
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们到目前为止所确定的是，模块系统默认不允许同一模块的多个版本。没有原生支持，但这并不意味着它绝对不可能。请参阅第13.3节了解使其工作的方法。
- en: 13.1.2 NO SUPPORT FOR VERSION SELECTION
  id: totrans-980
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 13.1.2 不支持版本选择
- en: If the module system can’t load several versions of the same module, why can’t
    it at least select the correct versions for us? That, too, is, of course, theoretically
    possible, but unfortunately isn’t feasible—let me explain why.
  id: totrans-981
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果模块系统不能加载相同模块的多个版本，为什么它至少不能为我们选择正确的版本呢？这当然在理论上也是可能的，但不幸的是并不可行——让我解释一下原因。
- en: HOW BUILD TOOLS HANDLE VERSIONS
  id: totrans-982
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**如何处理版本**'
- en: Build tools like Maven and Gradle work with versioned JARs all the time. They
    know for each JAR which version it has and which versions its dependencies have.
    Considering the shoulders of giants on which so many projects stand, it’s only
    natural that they have deep dependency trees that contain the same JARs several
    times, possibly with different versions.
  id: totrans-983
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Maven和Gradle这样的构建工具一直与版本化的JAR文件打交道。它们知道每个JAR文件的版本以及其依赖项的版本。考虑到许多项目都站在巨人的肩膀上，它们自然会有深度依赖树，包含多次相同的JAR文件，可能具有不同的版本。
- en: Although it’s nice to know how many different versions require a JAR, that doesn’t
    change the fact that they better not all end up on the class path. If they do,
    you’ll run into problems like shadowing (see section 1.3.2) and outright version
    conflicts (see section 1.3.3), which will threaten your project’s stability.
  id: totrans-984
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然知道有多少不同版本的JAR文件是件好事，但这并不能改变它们最好不要都出现在类路径上的事实。如果它们真的都出现了，你可能会遇到像阴影（见第1.3.2节）和直接版本冲突（见第1.3.3节）等问题，这会威胁到项目的稳定性。
- en: ESSENTIAL INFO When it comes time to compile, test, or launch a project, build
    tools have to flatten that tree into a list that contains each JAR only once (see
    [figure 13.2](part0028.html#filepos1649460)). Effectively, they have to select
    a version for each artifact. That’s a nontrivial process, particularly if artifacts
    can define a range of acceptable versions for each dependency. Because the process
    is nontrivial, it also isn’t particularly transparent. It can be hard to predict
    which versions Maven or Gradle will select, and it isn’t surprising that they
    don’t necessarily select the same ones under the same circumstances.
  id: totrans-985
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 当编译、测试或启动项目时，构建工具必须将这个树扁平化为一个只包含每个JAR文件一次的列表（见图13.2）。实际上，它们必须为每个工件选择一个版本。这是一个非平凡的过程，尤其是如果工件可以定义每个依赖项可接受的版本范围。由于这个过程非平凡，它也不太透明。很难预测Maven或Gradle将选择哪个版本，它们在相同情况下不一定选择相同的版本并不令人惊讶。'
- en: '![](../images/00059.jpeg)'
  id: totrans-986
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00059.jpeg)'
- en: '[Figure 13.2](part0028.html#filepos1649274) An application’s dependency tree
    (left) may contain the same JAR more than once, like `johnson` and `mango`, possibly
    in different versions. To work on the class path, this tree has to be reduced
    to a set that contains each JAR only once (right).'
  id: totrans-987
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图13.2](part0028.html#filepos1649274) 一个应用程序的依赖树（左侧）可能包含相同的JAR文件多次，例如`johnson`和`mango`，可能在不同版本中。为了在类路径上工作，这个树必须缩减为一个只包含每个JAR文件一次的集合（右侧）。'
- en: WHY THE MODULE SYSTEM DOESN’T SELECT VERSIONS
  id: totrans-988
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**为什么模块系统不选择版本**'
- en: Now let’s leave build tools behind and talk about the module system. As you’ll
    see in section 13.2, modules can record their own version and those of their dependencies.
    Assuming the module system can’t run several instances of the same module, couldn’t
    it select a single version of each?
  id: totrans-989
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在让我们放下构建工具，谈谈模块系统。正如你在第13.2节中将会看到的，模块可以记录它们自己的版本以及它们依赖的版本。假设模块系统不能运行相同模块的多个实例，它难道不能选择每个模块的单个版本吗？
- en: Let’s play this through. In this hypothetical scenario, the JPMS would accept
    several versions of the same module on the module path. When building the module
    graph, it would decide for each module which version to pick.
  id: totrans-990
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们通过一个假设场景来探讨这个问题。在这个场景中，JPMS会在模块路径上接受相同模块的多个版本。当构建模块图时，它会为每个模块决定选择哪个版本。
- en: ESSENTIAL INFO This means the JPMS would now replicate what build tools already
    do. And because they don’t do it exactly the same way, the module system would
    behave subtly different than most (probably all) of them. Even worse, because
    Java is based on a standard, the precise behavior would likely have to be standardized,
    making it difficult to evolve over time.
  id: totrans-991
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 这意味着JPMS现在会复制构建工具已经做的事情。由于它们并不完全以相同的方式做这件事，模块系统的行为可能会与大多数（可能所有）其他系统有细微的差别。更糟糕的是，因为Java基于一个标准，精确的行为可能需要标准化，这使得随着时间的推移进行演变变得困难。'
- en: 'On top of that would come the effort to implement and maintain the version-selection
    algorithm. The final nail in the coffin is performance: if the compiler and JVM
    had to run that algorithm before they could start their actual work, which would
    measurably increase compile and launch times. As you can see, version selection
    isn’t a cheap feature, and it makes sense that Java isn’t adopting it.'
  id: totrans-992
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在此之上，还需要努力实现和维护版本选择算法。棺材的最后一根钉子是性能：如果编译器和 JVM 必须在开始实际工作之前运行该算法，这将显著增加编译和启动时间。如您所见，版本选择不是一个便宜的特性，Java
    不采用它是合理的。
- en: 13.1.3 WHAT THE FUTURE MAY BRING
  id: totrans-993
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 13.1.3 未来可能带来的变化
- en: In summary, the module system is version agnostic, meaning version information
    doesn’t impact its behavior. That’s today. Many developers hope Java will support
    either of these features in the future. If you’re one of them, I don’t want to
    rain on your parade, and however the future looks today doesn’t mean it won’t
    happen. I don’t see it, though.
  id: totrans-994
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总结来说，模块系统对版本信息不敏感，这意味着版本信息不会影响其行为。这是今天的现状。许多开发者希望 Java 在未来支持这些特性之一。如果您是其中之一，我不想浇你冷水，无论今天的未来看起来如何，并不意味着它不会发生。不过，我看不出来。
- en: ESSENTIAL INFO Mark Reinhold, chief architect of the Java Platform Group at
    Oracle and specification lead for the module system, has repeatedly and publicly
    stated that he doesn’t see version support in Java’s future. Given the considerable
    investment such a feature would require, and its dubious payoff, I can understand
    how he arrived at that decision.
  id: totrans-995
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息**：Oracle Java 平台组的首席架构师马克·雷诺尔德（Mark Reinhold）以及模块系统的规范负责人，反复公开表示，他看不到
    Java 未来会有版本支持。鉴于这样一个特性所需的巨大投资以及其可疑的回报，我可以理解他做出这一决定的原因。'
- en: This means we still have to battle versioning problems. Maybe it’s my Stockholm
    syndrome talking, but it’s not like those fights are for naught. Working, sometimes
    hard, to unify version ranges across a project and make sure there’s a set of
    unique JARs that can support the application actually provides benefits.
  id: totrans-996
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这意味着我们仍然需要与版本问题作斗争。也许是我的斯德哥尔摩综合症在作祟，但那些斗争并非毫无意义。努力统一项目中的版本范围，并确保有一组独特的 JAR 文件可以支持应用程序，这实际上是有益的。
- en: Imagine you had no incentive to do that. How many more JARs would your project
    drag onto the class or module path? How much larger would it get, and how much
    more complicated would debugging be? No, I think allowing conflicting versions
    to work out of the box would be a horrible idea.
  id: totrans-997
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 想象一下，如果您没有任何动力去做这件事。您的项目会拖多少 JAR 文件到类或模块路径上？它会变得多大，调试会变得多么复杂？不，我认为允许冲突版本默认工作是一个糟糕的想法。
- en: That said, the fact remains that there are cases where a version conflict stops
    important work dead in its tracks or makes critical updates impossible without
    having to update tons of other dependencies at the same time. To that end, it
    would be nice to have a command-line switch like `java --one-class-loader-per-module`
    that you could try on a rainy day. Alas, it doesn’t exist (yet?).
  id: totrans-998
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 话虽如此，事实仍然是，在某些情况下，版本冲突会立即停止重要的工作，或者在没有更新大量其他依赖项的情况下，使关键更新变得不可能。为此，有一个像 `java
    --one-class-loader-per-module` 这样的命令行开关，您可以在下雨天尝试使用，那将是件好事。然而，它（目前）还不存在。
- en: 13.2 Recording version information
  id: totrans-999
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 13.2 记录版本信息
- en: As we’ve just covered in detail, the module system doesn’t process version information.
    Interestingly enough, it does allow us to record and access that information.
    That may seem a little weird at first, but it turns out to be helpful when debugging
    an application.
  id: totrans-1000
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如我们刚刚详细讨论的那样，模块系统不处理版本信息。有趣的是，它确实允许我们记录和访问这些信息。一开始这可能看起来有点奇怪，但事实证明，在调试应用程序时这很有帮助。
- en: Let’s first look at how to record version information during compilation and
    packaging (section 13.2.1) before discussing where you see that information and
    what benefits it provides (section 13.2.2). Recording and evaluating version information
    is demonstrated in ServiceMonitor’s `feature-versions` branch.
  id: totrans-1001
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在讨论您在哪里看到这些信息以及它提供了哪些好处（第 13.2.2 节）之前，让我们首先看看如何在编译和打包过程中记录版本信息（第 13.2.1 节）。在
    ServiceMonitor 的 `feature-versions` 分支中演示了如何记录和评估版本信息。
- en: 13.2.1 RECORDING VERSIONS WHILE BUILDING MODULES
  id: totrans-1002
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 13.2.1 在构建模块时记录版本
- en: 'Definition: --module-version'
  id: totrans-1003
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：--module-version
- en: The `javac` and `jar` commands accept the command line option `--module-version
    ${version}`. They embed the given version, which can be an arbitrary string, in
    the module descriptor.
  id: totrans-1004
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`javac` 和 `jar` 命令接受命令行选项 `--module-version ${version}`。它们将给定的版本（可以是任意字符串）嵌入到模块描述符中。'
- en: Regardless of whether the option is used, if a module is compiled against a
    dependency that recorded its version, the compiler will add that information to
    the module descriptor, too. That means a module descriptor can contain the version
    of the module itself as well as of all dependencies against which the module was
    compiled.
  id: totrans-1005
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 无论是否使用该选项，如果模块针对记录了其版本的依赖项进行编译，编译器也会将此信息添加到模块描述符中。这意味着模块描述符可以包含模块本身的版本以及模块编译时针对的所有依赖项的版本。
- en: The `jar` command overrides the module’s version if it was present before. So,
    if `--module-version` is used on both `jar` and `javac`, only the value given
    to `jar` matters.
  id: totrans-1006
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果之前存在模块版本，`jar`命令将覆盖模块版本。因此，如果`jar`和`javac`都使用了`--module-version`，则只有`jar`提供的值有效。
- en: '[Listing 2.5](part0015.html#filepos271227) showed how to compile and package
    the monitor module, but you don’t need to flip back. Updating the `jar` command
    to record the version is trivial:'
  id: totrans-1007
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[列表2.5](part0015.html#filepos271227)展示了如何编译和打包monitor模块，但您不需要翻回。将`jar`命令更新为记录版本是微不足道的：'
- en: '`$ jar --create --file mods/monitor.jar --module-version 1.0 --main-class monitor.Monitor
    -C monitor/target/classes .`'
  id: totrans-1008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jar --create --file mods/monitor.jar --module-version 1.0 --main-class monitor.Monitor
    -C monitor/target/classes .`'
- en: As you can see, it’s as simple as slipping in `--module-version 1.0`. Because
    the script compiles and immediately packages the module, there’s no need to also
    add it to `javac`.
  id: totrans-1009
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如您所见，只需简单地将`--module-version 1.0`添加进去即可。因为脚本编译并立即打包模块，所以没有必要将其也添加到`javac`中。
- en: 'To see whether you succeeded, all you need to do is ask `jar --describe-module`
    (see section 4.5.2):'
  id: totrans-1010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要查看您是否成功，您只需执行`jar --describe-module`（参见第4.5.2节）：
- en: '`$ jar --describe-module --file mods/monitor.jar  > monitor@1.0 jar:.../monitor.jar/!module-info.class
    > requires java.base mandated > requires monitor.observer # truncated requires
    > contains monitor > main-class monitor.Main`'
  id: totrans-1011
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jar --describe-module --file mods/monitor.jar  > monitor@1.0 jar:.../monitor.jar/!module-info.class
    > requires java.base mandated > requires monitor.observer # truncated requires
    > contains monitor > main-class monitor.Main`'
- en: 'The version is right there in the first line: `monitor@1.0`. Why don’t the
    dependencies’ versions show up, though? In this specific case, I didn’t record
    them, but java.base definitely has one, and it doesn’t appear, either. Indeed,
    `--describe-module` doesn’t print this information—neither the `jar` nor the `java`
    variant.'
  id: totrans-1012
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 版本信息就在第一行：`monitor@1.0`。为什么依赖项的版本没有显示出来呢？在这个特定的情况下，我没有记录它们，但java.base肯定有一个版本，也没有显示出来。实际上，`--describe-module`并没有打印出这些信息——无论是`jar`还是`java`变体。
- en: To access the versions of a module’s dependencies, you need a different approach.
    Let’s look at where the version information appears and how you can access it.
  id: totrans-1013
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要访问模块依赖项的版本，您需要采取不同的方法。让我们看看版本信息出现在哪里以及如何访问它。
- en: 13.2.2 ACCESSING MODULE VERSIONS
  id: totrans-1014
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 13.2.2 访问模块版本
- en: The versions recorded during compilation and packaging show up in various places.
    As you’ve just seen, `jar --describe-module` and `java --describe-module` both
    print the module’s version.
  id: totrans-1015
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编译和打包过程中记录的版本信息出现在各种地方。正如您所看到的，`jar --describe-module`和`java --describe-module`都打印了模块的版本。
- en: VERSION INFORMATION IN STACK TRACES
  id: totrans-1016
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 栈跟踪中的版本信息
- en: 'Stack traces are also important locations. If code runs in a module, the module’s
    name is printed for each stack frame together with the package, class, and method
    names. The good news is that the version is included, too:'
  id: totrans-1017
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 栈跟踪也是重要的位置。如果代码在模块中运行，模块的名称将与包、类和方法名称一起打印在每个栈帧中。好消息是版本信息也包括在内：
- en: '`> Exception in thread "main" java.lang.IllegalArgumentException > at monitor@1.0/monitor.Main.outputVersions(Main.java:46)
    > at monitor@1.0/monitor.Main.main(Main.java:24)`'
  id: totrans-1018
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> 异常发生在主线程 "main" java.lang.IllegalArgumentException > 在 monitor@1.0/monitor.Main.outputVersions(Main.java:46)
    > 在 monitor@1.0/monitor.Main.main(Main.java:24)`'
- en: Not revolutionary, but definitely a nice addition. If your code misbehaves for
    seemingly mysterious reasons, problems with versions are a possible cause, and
    seeing them in such a prominent position makes it easier to notice them if they’re
    suspicious.
  id: totrans-1019
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然不是革命性的，但确实是一个很好的补充。如果您的代码因为看似神秘的原因表现不佳，版本问题可能是原因之一，而且将它们放在如此显眼的位置使得更容易注意到它们是否可疑。
- en: ESSENTIAL INFO I’m convinced that version information can be a great help. I
    strongly recommend that you configure your build tool to record it.
  id: totrans-1020
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ESSENTIAL INFO 我坚信版本信息可以大有裨益。我强烈建议您配置您的构建工具以记录它。
- en: MODULE VERSION INFORMATION IN THE REFLECTION API
  id: totrans-1021
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 反射API中的模块版本信息
- en: Arguably the most interesting place to handle version information is the reflection
    API. (Going forward, you need to know about `java.lang.ModuleDescriptor`. Check
    out section 12.3.3 if you haven’t already.)
  id: totrans-1022
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 争议性地，处理版本信息最有趣的地方是反射 API。（从现在开始，你需要了解 `java.lang.ModuleDescriptor`。如果你还没有，请查看第
    12.3.3 节。）
- en: ESSENTIAL INFO As you can see in [listing 12.7](part0027.html#filepos1556405)
    and again in [listing 13.1](part0028.html#filepos1666737), the class `ModuleDescriptor`
    has a method `rawVersion()`. It returns an `Optional<String>` that contains the
    version string exactly as it was passed to `--module-version`, or it’s empty if
    the option wasn’t used.
  id: totrans-1023
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 如你在 [列表 12.7](part0027.html#filepos1556405) 和再次在 [列表 13.1](part0028.html#filepos1666737)
    中所见，类 `ModuleDescriptor` 有一个 `rawVersion()` 方法。它返回一个包含版本字符串的 `Optional<String>`，该字符串与传递给
    `--module-version` 的完全相同，如果没有使用该选项，则为空。'
- en: On top of that, there’s `version()`, which returns an `Optional<Version>`, where
    `Version` is an inner class of `ModuleDescriptor` that parses the raw version
    into a comparable representation. If there’s no raw version, or if parsing it
    failed, `Optional` is empty.
  id: totrans-1024
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，还有一个 `version()` 方法，它返回一个 `Optional<Version>`，其中 `Version` 是 `ModuleDescriptor`
    的内部类，它将原始版本解析为可比较的表示形式。如果没有原始版本，或者解析失败，则 `Optional` 为空。
- en: Listing 13.1 Accessing a module’s raw and parsed version
  id: totrans-1025
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 13.1 访问模块的原始和解析版本
- en: '`ModuleDescriptor descriptor = getClass() .getModule() .getDescriptor(); String
    raw = descriptor` `.rawVersion()` [`①`](part0028.html#filepos1667650) `.orElse("unknown
    version"); String parsed = descriptor` `.version()` [`②`](part0028.html#filepos1668040)
    `.map(Version::toString) .orElse("unknown or unparsable version");`'
  id: totrans-1026
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ModuleDescriptor descriptor = getClass() .getModule() .getDescriptor(); String
    raw = descriptor` `.rawVersion()` [`①`](part0028.html#filepos1667650) `.orElse("unknown
    version"); String parsed = descriptor` `.version()` [`②`](part0028.html#filepos1668040)
    `.map(Version::toString) .orElse("unknown or unparsable version");`'
- en: ①
  id: totrans-1027
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Returns an Optional<String> that’s empty if --module-version wasn’t used
  id: totrans-1028
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果没有使用 `--module-version`，则返回一个空的 `Optional<String>`
- en: ②
  id: totrans-1029
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Returns an Optional<Version> that’s empty if rawVersion() is or if the raw version
    couldn’t be parsed
  id: totrans-1030
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 `rawVersion()` 为空或原始版本无法解析，则返回一个空的 `Optional<Version>`
- en: DEPENDENCY VERSION INFORMATION IN THE REFLECTION API
  id: totrans-1031
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**反射 API 中的依赖项版本信息**'
- en: 'That settles the module’s own version. You still didn’t see how to access the
    versions that were recorded for the dependencies, though. Or did you? [Listing
    12.8](part0027.html#filepos1558184), which shows the output of printing pretty
    much everything a `ModuleDescriptor` has to offer, contains this snippet:'
  id: totrans-1032
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这样就解决了模块自身的版本问题。尽管如此，你还没有看到如何访问记录的依赖项版本。或者你已经看到了？[列表 12.8](part0027.html#filepos1558184)，它显示了打印
    `ModuleDescriptor` 提供的几乎所有内容的输出，包含以下片段：
- en: '`[] module monitor.persistence @ [] { requires [ hibernate.jpa, mandated java.base
    (@9.0.4), monitor.statistics] [...] }`'
  id: totrans-1033
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`[] module monitor.persistence @ [] { requires [ hibernate.jpa, mandated java.base
    (@9.0.4), monitor.statistics] [...] }`'
- en: See `@9.0.4` in there? That’s part of the output of `Requires::toString`. `Requires`
    is another inner class of `ModuleDescriptor` and represents a `requires` directive
    in a module descriptor.
  id: totrans-1034
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你看到那里的 `@9.0.4` 吗？这是 `Requires::toString` 输出的一部分。`Requires` 是 `ModuleDescriptor`
    的另一个内部类，它表示模块描述符中的 `requires` 指令。
- en: ESSENTIAL INFO For a given module, you can get a `Set<Requires>` by calling
    `module.getDescriptor().requires()`. A `Requires` instance contains a few pieces
    of information, most notably the required module’s name (method `name()`) and
    the raw and parsed versions that were compiled against (methods `rawCompiledVersion()`
    and `compiledVersion()`, respectively). The following listing shows code that
    gets a module’s descriptor and then streams over the recorded `requires` directives.
  id: totrans-1035
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 对于给定的模块，你可以通过调用 `module.getDescriptor().requires()` 获取一个 `Set<Requires>`。`Requires`
    实例包含一些信息，最值得注意的是所需模块的名称（`name()` 方法）以及针对编译的原始和解析版本（分别使用 `rawCompiledVersion()`
    和 `compiledVersion()` 方法）。以下列表显示了获取模块描述符并随后流式传输记录的 `requires` 指令的代码。'
- en: Listing 13.2 Printing dependency version information
  id: totrans-1036
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 13.2 打印依赖项版本信息
- en: '`module .getDescriptor() .requires().stream() .map(requires -> String.format("\t->
    %s @ %s", requires.name(), requires.rawCompiledVersion().orElse("unknown"))) .forEach(System.out::println);`'
  id: totrans-1037
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module .getDescriptor() .requires().stream() .map(requires -> String.format("\t->
    %s @ %s", requires.name(), requires.rawCompiledVersion().orElse("unknown"))) .forEach(System.out::println);`'
- en: 'This code produces output like the following:'
  id: totrans-1038
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此代码生成如下输出：
- en: '`> monitor @ 1.0 > -> monitor.persistence @ 1.0 > -> monitor.statistics @ 1.0
    > -> java.base @ 9.0.4 # more dependencies truncated`'
  id: totrans-1039
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`> monitor @ 1.0 > -> monitor.persistence @ 1.0 > -> monitor.statistics @ 1.0
    > -> java.base @ 9.0.4 # 更多依赖被截断`'
- en: 'And here they are: the versions of the dependencies against which monitor was
    compiled. Neat.'
  id: totrans-1040
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 下面就是它们：监控编译时依赖项的依赖项版本。很整洁。
- en: It’s fairly straightforward to write a class that uses this information to compare
    the version against which a module was compiled with the dependency’s actual version
    at run time. It could warn about potential problems, for example, if the actual
    version is lower, or log all this information for later analysis in case of problems.
  id: totrans-1041
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个使用此信息来比较模块编译时版本与运行时依赖项实际版本的类相当直接。例如，如果实际版本较低，它可以发出警告，或者在出现问题时记录所有这些信息以供后续分析。
- en: 13.3 Running multiple versions of a module in separate layers
  id: totrans-1042
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 13.3 在单独的层中运行模块的多个版本
- en: 'Section 13.1.1 states that the module system has no native support for running
    multiple versions of the same module. But as I already hinted, that doesn’t mean
    it’s impossible. Here’s how people did it before the JPMS arrived on the scene:'
  id: totrans-1043
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '13.1.1 节指出，模块系统没有对运行相同模块的多个版本提供原生支持。但正如我已经暗示的，这并不意味着不可能。以下是 JPMS 出现之前人们是如何做到这一点的： '
- en: Build tools can shade dependencies into a JAR, which means all the class files
    from the dependency are copied into the target JAR, but under a new package name.
    References to those classes are also updated to use the new class names. This
    way, the standalone Guava JAR with package `com.google.collect` is no longer needed,
    because its code was moved to `org.library.com.google.collection`. If each project
    does that, different versions of Guava can never conflict.
  id: totrans-1044
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建工具可以将依赖项阴影到 JAR 文件中，这意味着所有来自依赖项的类文件都被复制到目标 JAR 文件中，但使用新的包名。对这些类的引用也被更新为使用新的类名。这样，带有
    `com.google.collect` 包的独立 Guava JAR 文件就不再需要了，因为其代码已被移动到 `org.library.com.google.collection`。如果每个项目都这样做，Guava
    的不同版本就不会发生冲突。
- en: Some projects use OSGi or another module system that supports multiple versions
    out of the box.
  id: totrans-1045
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些项目使用 OSGi 或其他支持开箱即用多版本的模块系统。
- en: Other projects create their own class-loader hierarchy to keep the different
    instances from conflicting. (This is also what OSGi does.)
  id: totrans-1046
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他项目创建自己的类加载器层次结构，以防止不同实例之间发生冲突。（这也是 OSGi 所做的。）
- en: Each of these approaches has its own disadvantages, which I’m not going to go
    into here. If you absolutely have to run multiple versions of the same JAR, you
    need to find a solution that makes the effort worth it for your project.
  id: totrans-1047
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些方法各自都有其缺点，这里不再赘述。如果你绝对需要运行相同 JAR 的多个版本，你需要找到一个解决方案，使你的项目值得付出努力。
- en: ESSENTIAL INFO That said, the module system repackages an existing solution,
    and that’s what I focus on in this section. But although you can run multiple
    versions side by side like this, you’ll see that it’s somewhat complex, so you
    may not want to. This is less of a recipe and more of a demonstration case.
  id: totrans-1048
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 话虽如此，模块系统重新打包了一个现有解决方案，这就是本节的重点。但尽管你可以像这样并行运行多个版本，你也会发现这相当复杂，所以你可能不希望这样做。这与其说是一个食谱，不如说是一个演示案例。'
- en: 13.3.1 WHY YOU NEED A STARTER TO SPIN UP ADDITIONAL LAYERS
  id: totrans-1049
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 13.3.1 为什么你需要一个启动器来启动额外的层
- en: 'As discussed in section 12.4, the module system introduces the concept of layers,
    which essentially pair a module graph with class loaders. There’s always at least
    one layer in play: the boot layer, which the module system creates at launch time
    based on the module path content.'
  id: totrans-1050
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如 12.4 节所述，模块系统引入了层的概念，这本质上是将模块图与类加载器配对。始终至少有一个层在起作用：启动层，模块系统在启动时根据模块路径内容创建它。
- en: 'Beyond that, layers can be created at run time and need a set of modules as
    input: for example, from a directory in the filesystem, which they then evaluate
    according to the readability rules to guarantee a reliable configuration. Because
    a layer can’t be created if it contains multiple versions of the same module,
    the only way to make that work is to arrange them in different layers.'
  id: totrans-1051
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，可以在运行时创建层，并需要一个模块集作为输入：例如，从一个文件系统目录中，然后根据可读性规则对其进行评估，以确保可靠的配置。由于包含相同模块多个版本的层无法创建，因此唯一使其工作的方式是将它们安排在不同的层中。
- en: 'ESSENTIAL INFO That means instead of launching your application, you need to
    launch a starter that expects the following input:'
  id: totrans-1052
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 这意味着你不需要启动应用程序，而是需要启动一个启动器，该启动器期望以下输入：'
- en: Paths to all application modules
  id: totrans-1053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有应用程序模块的路径
- en: The module’s relations, which must consider their different version
  id: totrans-1054
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的关联关系，必须考虑它们的不同版本
- en: It then needs to create a graph of layers-to-be, which are arranged so that
    each layer contains each module only once, although different layers can contain
    the same module in multiple versions. The final step is to fill in the actual
    layers and then call the `main` method.
  id: totrans-1055
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后需要创建一个待创建层的图，这些层被安排得使得每个层只包含每个模块一次，尽管不同的层可以包含相同模块的多个版本。最后一步是填写实际的层，然后调用 `main`
    方法。
- en: Developing such a starter as a general solution is a considerable engineering
    task and effectively means reimplementing existing third-party module systems.
    Creating a starter that solves only your specific problem is easier, though, so
    we’ll focus on that. By the end of the section, you’ll know how to create a simple
    layer structure that allows you to run two versions of the same module.
  id: totrans-1056
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将这样的启动器作为通用解决方案开发是一个相当大的工程任务，实际上意味着重新实现现有的第三方模块系统。虽然创建一个仅解决你特定问题的启动器更容易，但我们将专注于这一点。到本节结束时，你将知道如何创建一个简单的层结构，允许你运行相同模块的两个版本。
- en: 13.3.2 SPINNING UP LAYERS FOR YOUR APPLICATION, APACHE TWILL, AND CASSANDRA
    JAVA DRIVER
  id: totrans-1057
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 13.3.2 为您的应用程序、Apache Twill 和 Cassandra Java Driver 启动层
- en: 'Say you depend on two projects, Apache Twill and Cassandra Java Driver. They
    have conflicting version requirements for Guava: Apache Twill breaks on any version
    after 13, and Cassandra Java Driver breaks on any version before 16\. You’ve tried
    everything you can think of to work around the problem, but nothing has worked,
    and now you want to solve the problem by using layers.'
  id: totrans-1058
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你依赖于两个项目，Apache Twill 和 Cassandra Java Driver。它们对 Guava 的版本要求存在冲突：Apache Twill
    在 13 版本之后的任何版本都会崩溃，而 Cassandra Java Driver 在 16 版本之前的任何版本都会崩溃。你已经尝试了所有能想到的方法来解决这个问题，但都没有成功，现在你希望通过使用层来解决这个问题。
- en: That means the base layer contains only your application starter. The starter
    needs to create one layer with Guava 13 and another with Guava 16—they need to
    reference the base layer to have access to platform modules. Then comes a fourth
    layer with the rest of the application and dependencies—it references both of
    the other layers the starter creates, so it can look up dependencies in them.
  id: totrans-1059
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这意味着基本层只包含你的应用程序启动器。启动器需要创建一个包含 Guava 13 的层，另一个包含 Guava 16 的层——它们需要引用基本层以访问平台模块。然后是一个包含应用程序其余部分及其依赖关系的第四层——它引用了启动器创建的两个其他层，因此可以在其中查找依赖项。
- en: 'It won’t work exactly like that, though. As soon as Apache Twill’s dependencies
    are resolved, the module system will see Guava twice: once in each of the layers
    the top layer references. But a module isn’t allowed to read another module more
    than once because it would be unclear which version classes should be loaded from.'
  id: totrans-1060
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，它不会完全像那样工作。一旦 Apache Twill 的依赖项被解决，模块系统将看到 Guava 两次：一次在顶层引用的每个层中。但是，模块不允许读取另一个模块超过一次，因为这会导致不清楚应该从哪个版本加载类。
- en: So you pull these two modules and all of their dependencies into their respective
    Guava layer, and you’re good to go. Almost. Both modules expose their dependency
    on Guava, so your code needs to see Guava, too; and if that code is in the top
    layer, you end up in the same situation as before, with the module system complaining
    about code seeing two versions of Guava.
  id: totrans-1061
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，你将这些两个模块及其所有依赖项拉入各自的 Guava 层，然后就可以出发了。几乎是这样。这两个模块都公开了它们对 Guava 的依赖，所以你的代码也需要看到
    Guava；如果这段代码在顶层，你最终会陷入与之前相同的情况，模块系统会抱怨代码看到了两个版本的 Guava。
- en: 'If you pull your Twill-and Cassandra-specific code into the respective layers,
    too, you get the layer graph shown in [figure 13.3](part0028.html#filepos1682990).
    Now let’s create those layers. To do so, assume that you’ve organized the application
    modules into three directories:'
  id: totrans-1062
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你将 Twill 和 Cassandra 特定的代码也拉入相应的层，你将得到 [图 13.3](part0028.html#filepos1682990)
    中所示的层图。现在让我们创建这些层。为此，假设你已经将应用程序模块组织到了三个目录中：
- en: '`mods/twill` contains Apache Twill with all its dependencies and your modules
    that directly interact with it (in this example, app.twill).'
  id: totrans-1063
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mods/twill` 包含 Apache Twill 及其所有依赖项以及直接与之交互的你的模块（在这个例子中，是 app.twill）。'
- en: '`mods/cassandra` contains Cassandra Java Driver with all its dependencies and
    your modules that directly interact with it (in this example, app.cassandra).'
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mods/cassandra` 包含 Cassandra Java Driver 及其所有依赖项以及直接与之交互的你的模块（在这个例子中，是 app.cassandra）。'
- en: '`mods/app` contains the rest of your application and its dependencies (in this
    example, the main module is app).'
  id: totrans-1065
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mods/app` 包含应用程序的其余部分及其依赖项（在这个例子中，主模块是 app）。'
- en: '![](../images/00086.jpeg)'
  id: totrans-1066
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00086.jpeg)'
- en: '[Figure 13.3](part0028.html#filepos1681576) Apache Twill and Cassandra Java
    Driver have conflicting dependencies on Guava. To launch an application using
    both libraries, each library, including its respective dependencies, has to go
    in its own layer. Above them is the layer containing the rest of the application,
    and below the base layer.'
  id: totrans-1067
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图13.3](part0028.html#filepos1681576) Apache Twill和Cassandra Java Driver在Guava上存在冲突的依赖关系。要使用这两个库启动应用程序，每个库及其各自的依赖项都必须放在自己的层中。在其上方是包含应用程序其余部分的层，在其下方是基本层。'
- en: 'Your starter can then proceed as shown in [listing 13.3](part0028.html#filepos1685342):'
  id: totrans-1068
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您的启动器可以按照[列表13.3](part0028.html#filepos1685342)所示进行操作：
- en: Create a layer with the modules in `mods/cassandra`. Be careful to pick the
    right module as root for the resolution process. Pick the boot layer as the parent
    layer.
  id: totrans-1069
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mods/cassandra`目录下创建一个包含模块的层。请小心选择正确的模块作为根模块以进行解析过程。选择引导层作为父层。
- en: Do the same for modules in `mods/twill`.
  id: totrans-1070
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`mods/twill`中的模块执行相同的操作。
- en: Create a layer with the modules in `mods/app`, and pick your main module as
    root. Use the other two layers as parents; this way, your application’s dependency
    on the modules in `mods/cassandra` and `mods/twill` can be resolved.
  id: totrans-1071
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mods/app`目录下创建一个包含模块的层，并将您的主模块作为根模块。使用其他两个层作为父层；这样，您的应用程序对`mods/cassandra`和`mods/twill`中模块的依赖关系就可以得到解决。
- en: When that’s all finished, get the class loader for the upper layer’s main module,
    and call its `main` method.
  id: totrans-1072
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当所有这些都完成时，获取上层主要模块的类加载器，并调用其`main`方法。
- en: Listing 13.3 Starter that creates layers for Cassandra, Apache Twill, and the
    app
  id: totrans-1073
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表13.3 创建Cassandra、Apache Twill和应用程序层的启动器
- en: '`public static void main(String[] args) throws ReflectiveOperationException
    { createApplicationLayers() .findLoader("app") .loadClass("app.Main") .getMethod("main",
    String[].class)` `.invoke(null, (Object) new String[0]);` [`①`](part0028.html#filepos1688238)
    `}  private static ModuleLayer createApplicationLayers() { Path mods = Paths.get("mods");  ModuleLayer
    cassandra = createLayer( List.of(ModuleLayer.boot()), mods.resolve("cassandra"),`
    `"app.cassandra");` [`②`](part0028.html#filepos1688644) `ModuleLayer twill = createLayer(
    List.of(ModuleLayer.boot()), mods.resolve("twill"),` `"app.twill");` [`②`](part0028.html#filepos1688644)
    `return createLayer( List.of(cassandra, twill), mods.resolve("app"),` `"app");`
    [`③`](part0028.html#filepos1689081) `}` `private static ModuleLayer createLayer(`
    [`④`](part0028.html#filepos1689503) `List<ModuleLayer> parentLayers, Path modulePath,
    String rootModule) { Configuration configuration = createConfiguration( parentLayers,
    modulePath, rootModule); return ModuleLayer .defineModulesWithOneLoader( configuration,
    parentLayers, ClassLoader.getSystemClassLoader()) .layer(); }` `private static
    Configuration createConfiguration(` [`④`](part0028.html#filepos1689503)'
  id: totrans-1074
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public static void main(String[] args) throws ReflectiveOperationException
    { createApplicationLayers() .findLoader("app") .loadClass("app.Main") .getMethod("main",
    String[].class)` `.invoke(null, (Object) new String[0]);` [`①`](part0028.html#filepos1688238)
    `}  private static ModuleLayer createApplicationLayers() { Path mods = Paths.get("mods");  ModuleLayer
    cassandra = createLayer( List.of(ModuleLayer.boot()), mods.resolve("cassandra"),`
    `"app.cassandra");` [`②`](part0028.html#filepos1688644) `ModuleLayer twill = createLayer(
    List.of(ModuleLayer.boot()), mods.resolve("twill"),` `"app.twill");` [`②`](part0028.html#filepos1688644)
    `return createLayer( List.of(cassandra, twill), mods.resolve("app"),` `"app");`
    [`③`](part0028.html#filepos1689081) `}` `private static ModuleLayer createLayer(`
    [`④`](part0028.html#filepos1689503) `List<ModuleLayer> parentLayers, Path modulePath,
    String rootModule) { Configuration configuration = createConfiguration( parentLayers,
    modulePath, rootModule); return ModuleLayer .defineModulesWithOneLoader( configuration,
    parentLayers, ClassLoader.getSystemClassLoader()) .layer(); }` `private static
    Configuration createConfiguration(` [`④`](part0028.html#filepos1689503)'
- en: ①
  id: totrans-1075
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: After the application layers are created, loads the app’s Main class and invokes
    the main method
  id: totrans-1076
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在创建应用程序层之后，加载应用程序的Main类并调用main方法
- en: ②
  id: totrans-1077
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Creates one layer for Twill and another for Cassandra, each containing the entire
    project plus your modules that interact with it
  id: totrans-1078
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为Twill和Cassandra创建一个层，每个层都包含整个项目以及与它交互的模块
- en: ③
  id: totrans-1079
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: The main application layer starts resolving in your main module and has the
    twill and cassandra layers as parents.
  id: totrans-1080
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 主要应用程序层从主模块开始解析，并将twill和cassandra层作为父层。
- en: ④
  id: totrans-1081
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ④
- en: The createLayer and createConfiguration methods are similar to those in section
    12.4.3\. The main difference is that they specify the root modules for the resolution
    (not necessary before, because you relied on service binding—here you don’t).
  id: totrans-1082
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`createLayer`和`createConfiguration`方法与第12.4.3节中的方法类似。主要区别在于它们指定了解析的根模块（之前不是必需的，因为您依赖于服务绑定——这里则不需要）。'
- en: '`List<ModuleLayer> parentLayers, Path modulePath, String rootModule) { List<Configuration>
    configurations = parentLayers.stream() .map(ModuleLayer::configuration) .collect(toList());
    return Configuration.resolveAndBind( ModuleFinder.of(), configurations, ModuleFinder.of(modulePath),
    List.of(rootModule) ); }`'
  id: totrans-1083
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`List<ModuleLayer> parentLayers, Path modulePath, String rootModule) { List<Configuration>
    configurations = parentLayers.stream() .map(ModuleLayer::configuration) .collect(toList());
    return Configuration.resolveAndBind( ModuleFinder.of(), configurations, ModuleFinder.of(modulePath),
    List.of(rootModule) ); }`'
- en: And that’s it! I admit it takes some time, and you’ll likely have to fiddle
    a while to make it work (I had to), but if it’s the only solution you’re left
    with, it’s worth giving it a try.
  id: totrans-1084
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 就这样！我承认这需要一些时间，你可能需要调整一段时间才能让它工作（我就是这样做的），但如果这是你唯一剩下的解决方案，那么尝试一下是值得的。
- en: Summary
  id: totrans-1085
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: The `javac` and `jar` commands let you record a module’s versions with the `--module-version
    ${version}` option. It embeds the given version in the module declaration, where
    it can be read with command-like tools (for example, `jar --describe-module`)
    and the reflection API (`ModuleDescriptor::rawVersion`). Stack traces also show
    module versions.
  id: totrans-1086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`javac`和`jar`命令允许您使用`--module-version ${version}`选项记录模块的版本。它将给定的版本嵌入到模块声明中，其中可以使用类似命令的工具（例如，`jar
    --describe-module`）和反射API（`ModuleDescriptor::rawVersion`）读取。堆栈跟踪也会显示模块版本。'
- en: If a module knows its own version and another module is compiled against it,
    the compiler will record the version in the second module’s descriptor. This information
    is only available on the `Requires` instances returned by `ModuleDescriptor::requires`.
  id: totrans-1087
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个模块知道自己的版本，并且另一个模块针对它进行编译，编译器将在第二个模块的描述符中记录该版本。此信息仅在`ModuleDescriptor::requires`返回的`Requires`实例上可用。
- en: The module system doesn’t act on version information in any way. Instead of
    trying to select a specific version for a module if the module path contains several,
    it quits with an error message. This keeps the expensive version-selection algorithm
    out of the JVM and the Java standard.
  id: totrans-1088
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块系统不会以任何方式对版本信息进行操作。如果模块路径包含多个版本，而不是尝试为模块选择一个特定版本，它会以错误信息退出。这避免了昂贵的版本选择算法出现在JVM和Java标准中。
- en: The module system has no out-of-the-box support for running multiple versions
    of the same module. The underlying reason is the class-loading mechanism, which
    assumes that each class loader knows at most one class for any given name. If
    you need to run multiple versions, you need more than one class loader.
  id: totrans-1089
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块系统没有内置支持来运行同一模块的多个版本。其根本原因在于类加载机制，该机制假设每个类加载器最多只知道一个给定名称的类。如果你需要运行多个版本，你需要不止一个类加载器。
- en: OSGi does exactly that by creating a single class loader for every JAR. Creating
    a similarly general solution is a challenging task, but a simpler variant, customized
    to your exact problem, is feasible. To run multiple versions of the same module,
    create layers and associated class loaders so that conflicting modules are separated.
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OSGi通过为每个JAR创建一个单独的类加载器来实现这一点。创建一个类似通用的解决方案是一个具有挑战性的任务，但一个更简单的变体，针对你确切的问题进行定制，是可行的。要运行同一模块的多个版本，创建层和相关的类加载器，以便冲突的模块被分离。
- en: '14'
  id: totrans-1091
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '14'
- en: Customizing runtime images with jlink
  id: totrans-1092
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用jlink自定义运行时镜像
- en: This chapter covers
  id: totrans-1093
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating images with selected content
  id: totrans-1094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用选定内容创建镜像
- en: Generating native application launchers
  id: totrans-1095
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成原生应用程序启动器
- en: Judging the security, performance, and stability of images
  id: totrans-1096
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 判断镜像的安全性、性能和稳定性
- en: Generating and optimizing images
  id: totrans-1097
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成和优化镜像
- en: One of the key motivations for discussing modularity in Java has always been
    what is now called the Internet of Things (IoT). This is true for OSGi, Java’s
    most widely used third-party module system, which set out in 1999 to improve the
    development of embedded Java applications, and also for Project Jigsaw, which
    developed the JPMS and aimed to make the platform more scalable by allowing the
    creation of very small runtimes with just the code an (embedded) application needs.
  id: totrans-1098
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 讨论Java模块化的关键动机之一一直是现在所说的物联网（IoT）。这对于OSGi来说是真的，它是Java最广泛使用的第三方模块系统，它在1999年启动，旨在改善嵌入式Java应用程序的开发，也适用于Project
    Jigsaw，它开发了JPMS，旨在通过允许创建仅包含（嵌入式）应用程序需要的代码的非常小的运行时来提高平台的可伸缩性。
- en: This is where `jlink` comes in. It’s a Java command-line tool (in your JDK’s
    `bin` folder) that you can use to select a number of platform modules and link
    them into a runtime image. Such a runtime image acts exactly like a JRE but contains
    only the modules you picked and the dependencies they need to function (as indicated
    by `requires` directives). During that linking phase, `jlink` can be used to further
    optimize image size and improve VM performance, particularly startup time.
  id: totrans-1099
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这就是`jlink`发挥作用的地方。它是一个Java命令行工具（位于你的JDK的`bin`文件夹中），你可以使用它来选择多个平台模块并将它们链接到一个运行时镜像中。这样的运行时镜像的行为与JRE完全相同，但它只包含你选择的模块以及它们运行所需的依赖项（如`requires`指令所示）。在链接阶段，`jlink`可以用来进一步优化镜像大小并提高虚拟机性能，尤其是启动时间。
- en: In the years since Jigsaw’s inception, a lot has changed, though. For one thing,
    disk space in embedded devices no longer comes at such a premium. At the same
    time, we’ve seen the rise of virtualization, most prominently with Docker, where
    container size is once again a concern (although not a major one). The rise of
    containerization also brought pressure to ease and automate deployment, which
    today is done a few orders of magnitude more frequently.
  id: totrans-1100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自从Jigsaw启动以来，已经发生了许多变化。一方面，嵌入式设备中的磁盘空间不再像以前那样珍贵。同时，我们也看到了虚拟化的兴起，尤其是Docker，其中容器大小再次成为关注点（尽管不是主要问题）。容器化的兴起也带来了简化并自动化部署的压力，而今天，部署的频率已经提高了几个数量级。
- en: And `jlink` helps here, as well. It doesn’t stop at linking platform modules—it
    can also create application images, which include app code as well as library
    and framework modules. This allows your build process to produce an entirely self-contained
    deployment unit that consists of your entire app with exactly the platform modules
    it needs, optimized for image size and performance as you see fit, and launchable
    with a simple call to a native script.
  id: totrans-1101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，`jlink`在这里也有帮助。它不仅限于链接平台模块——它还可以创建应用程序镜像，这些镜像包括应用程序代码以及库和框架模块。这使得你的构建过程能够生成一个完全自包含的部署单元，该单元包含你的整个应用程序以及它需要的精确平台模块，根据你的需求优化镜像大小和性能，并且可以通过对本地脚本的简单调用启动。
- en: If you’re more of a desktop application developer and your eyes glazed over
    when I mentioned IoT and Docker, that last bit should have made you sit up. With
    `jlink`, it’s exceedingly easy to ship a single Zip file that users can launch
    without any further setup. And if you’ve been using `javapackager`, you’ll be
    delighted to hear that it now calls `jlink` internally, giving you access to all
    its features (although I won’t go into the integration—the `javapackager` documentation
    has you covered).
  id: totrans-1102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你更倾向于桌面应用程序开发，当我提到IoT和Docker时，你的眼睛可能已经失去了光泽。但使用`jlink`，你可以非常容易地发送一个单一的Zip文件，用户可以无需任何进一步设置即可启动它。如果你一直在使用`javapackager`，你将很高兴地听到它现在内部调用`jlink`，这让你可以访问所有其功能（尽管我不会深入集成——`javapackager`文档已经涵盖了这一点）。
- en: So let’s start linking! We’ll begin with creating runtime images from platform
    modules (section 14.1) and use that opportunity to explore the linking process
    in more detail, look into the generated image, and discuss how to pick the right
    modules. Next up is including application modules and creating custom launchers
    (section 14.2) before we discuss generating images across operating systems (section
    14.3). We close with looking at size and performance optimizations (section 14.4).
  id: totrans-1103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，让我们开始链接！我们将从创建由平台模块组成的运行时镜像（第14.1节）开始，并利用这个机会更详细地探讨链接过程，查看生成的镜像，并讨论如何选择正确的模块。接下来是包含应用程序模块和创建自定义启动器（第14.2节），然后我们讨论跨操作系统的镜像生成（第14.3节）。最后，我们将探讨大小和性能优化（第14.4节）。
- en: To code along, take a look at the `feature-jlink` branch in the ServiceMonitor
    repo. By the end of this chapter you’ll know how to create optimized runtime images,
    possibly including an entire application, for various OSs. That allows you to
    build a single deployment unit that works out of the box on your servers or your
    customers’ machines.
  id: totrans-1104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了跟随代码编写，请查看ServiceMonitor仓库中的`feature-jlink`分支。到本章结束时，你将知道如何为各种操作系统创建优化的运行时镜像，可能包括整个应用程序。这允许你构建一个单一的部署单元，该单元可以在你的服务器或客户的机器上直接使用。
- en: 14.1 Creating custom runtime images
  id: totrans-1105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 14.1 创建自定义运行时镜像
- en: One big use case for `jlink` is the creation of Java runtime images that contain
    only the modules you need for your application. The result is a tailored JRE that
    contains exactly the modules your code needs, but nothing else. You can then use
    the `java` binary in that image to launch your application just like any other
    JRE.
  id: totrans-1106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`jlink`的一个大用途是创建只包含你应用程序所需的模块的Java运行时镜像。结果是定制的JRE，它正好包含你的代码需要的模块，没有其他模块。然后你可以使用该镜像中的`java`二进制文件来启动你的应用程序，就像使用任何其他JRE一样。'
- en: 'Customizing the runtime has a few advantages: you can save some disk space
    (smaller image) and maybe network bandwidth (if you deploy remotely), you’re safer
    (fewer classes mean a smaller attack surface), and you even get a JVM that starts
    a little more quickly (more on that in section 14.4.3).'
  id: totrans-1107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自定义运行时有一些优点：你可以节省一些磁盘空间（更小的镜像）和可能的网络带宽（如果你远程部署），你更安全（类越少意味着攻击面越小），而且你甚至能得到一个启动速度略快的JVM（更多内容请参考第14.4.3节）。
- en: NOTE With that said, `jlink` “just” links bytecode—it doesn’t compile it to
    machine code. You might have heard that beginning with version 9, Java experiments
    with ahead-of-time (AOT) compilation, but `jlink` has nothing to do with that.
    To learn about AOT in Java, have a look at Java Enhancement Proposal 295 ([http://openjdk.java.net/jeps/295](http://openjdk.java.net/jeps/295)).
  id: totrans-1108
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：尽管如此，`jlink`“仅仅”链接字节码——它不会将其编译成机器码。你可能听说过从版本9开始，Java尝试了即时（AOT）编译，但`jlink`与此无关。要了解Java中的AOT，请查看Java增强提案295
    ([http://openjdk.java.net/jeps/295](http://openjdk.java.net/jeps/295))。
- en: ESSENTIAL INFO You can create runtime images tailored to your application as
    soon as it runs on Java 9+. You don’t need to modularize it first.
  id: totrans-1109
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的是：你可以在Java 9+上运行你的应用程序后立即创建针对你的应用程序定制的运行时镜像。你不需要先对其进行模块化。
- en: 'To understand how to create runtime images with `jlink`, we’ll start with the
    simplest image (section 14.1.1) and then examine the result (section 14.1.2).
    Next, we’ll discuss the special treatment of services (section 14.1.3) before
    topping off the section with a real-life use case: how to create an image dedicated
    to running a given application (section 14.1.4).'
  id: totrans-1110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要了解如何使用`jlink`创建运行时镜像，我们将从最简单的镜像（第14.1.1节）开始，然后检查结果（第14.1.2节）。接下来，我们将讨论服务的特殊处理（第14.1.3节），最后在本节中添加一个实际用例：如何创建用于运行特定应用程序的镜像（第14.1.4节）。
- en: 14.1.1 GETTING STARTED WITH JLINK
  id: totrans-1111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 14.1.1 使用JLINK入门
- en: 'Definition: Required info for jlink'
  id: totrans-1112
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：jlink所需的必要信息
- en: 'To create an image, `jlink` needs three pieces of information, each specified
    with a command-line option:'
  id: totrans-1113
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要创建镜像，`jlink`需要三个信息点，每个信息点通过命令行选项指定：
- en: Where to find the available modules (specified with `--module-path`)
  id: totrans-1114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用模块的位置（使用`--module-path`指定）
- en: Which modules to use (specified with `--add-modules`)
  id: totrans-1115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用的模块（使用`--add-modules`指定）
- en: Folder in which to create the image (specified with `--output`)
  id: totrans-1116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建镜像的文件夹（使用`--output`指定）
- en: The simplest possible runtime image contains only the base module. The following
    listing shows how to create it with `jlink`.
  id: totrans-1117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最简单的运行时镜像只包含基本模块。以下列表展示了如何使用`jlink`创建它。
- en: Listing 14.1 Creating a runtime image containing only the base module
  id: totrans-1118
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表14.1 创建只包含基本模块的运行时镜像
- en: '`$ jlink` `--module-path ${jdk-9}/jmods` [`①`](part0029.html#filepos1705698)`--add-modules
    java.base` [`②`](part0029.html#filepos1706083)`--output jdk-base` [`③`](part0029.html#filepos1706512)`$
    jdk-base/bin/java --list-modules` [`④`](part0029.html#filepos1706850) `> java.base`'
  id: totrans-1119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jlink` `--module-path ${jdk-9}/jmods` [`①`](part0029.html#filepos1705698)`--add-modules
    java.base` [`②`](part0029.html#filepos1706083)`--output jdk-base` [`③`](part0029.html#filepos1706512)`$
    jdk-base/bin/java --list-modules` [`④`](part0029.html#filepos1706850) `> java.base`'
- en: ①
  id: totrans-1120
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Location of modules, in this case platform modules from the local JDK install
  id: totrans-1121
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块的位置，在本例中为本地JDK安装的平台模块
- en: ②
  id: totrans-1122
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Modules to add to the image, in this case only java.base
  id: totrans-1123
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 需要添加到镜像中的模块，在本例中仅为java.base
- en: ③
  id: totrans-1124
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: Output directory for the image
  id: totrans-1125
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 镜像的输出目录
- en: ④
  id: totrans-1126
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ④
- en: Executes java --list-modules from the new image to verify that it only contains
    the base module
  id: totrans-1127
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从新镜像执行`java --list-modules`以验证它只包含基本模块
- en: It may seem a little odd that you need to tell `jlink` where to find platform
    modules. This isn’t necessary for `javac` and `java`, so why wouldn’t `jlink`
    know where to find them? The answer is cross-platform linking, which section 14.3
    discusses.
  id: totrans-1128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 需要告诉`jlink`在哪里查找平台模块可能看起来有些奇怪。对于`javac`和`java`来说，这不是必需的，那么为什么`jlink`不知道它们在哪里呢？答案是跨平台链接，这是第14.3节讨论的内容。
- en: NOTE From Java 10 on, it’s no longer necessary to place platform modules on
    the module path. If it doesn’t contain any, `jlink` implicitly loads them from
    the directory `$JAVA_HOME/jmods`.
  id: totrans-1129
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意** 从Java 10开始，不再需要在模块路径上放置平台模块。如果没有，`jlink`会隐式地从目录`$JAVA_HOME/jmods`加载它们。'
- en: ESSENTIAL INFO Regardless of whether platform modules are referenced explicitly
    or implicitly, it’s recommended that you only load them from the exact same JVM
    version as the `jlink` binary. For example, if `jlink` has version 9.0.4, make
    sure it loads platform modules from JDK 9.0.4.
  id: totrans-1130
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 无论平台模块是显式还是隐式引用，建议您只从与`jlink`二进制文件相同的精确JVM版本加载它们。例如，如果`jlink`的版本是9.0.4，请确保它从JDK
    9.0.4加载平台模块。'
- en: 'Given the three command-line options, `jlink` resolves modules as described
    in section 3.4.1: the module path content becomes the universe of observable modules,
    and the modules given to `--add-modules` become the root for the resolution process.
    But `jlink` has a few peculiarities:'
  id: totrans-1131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定三个命令行选项，`jlink`按照第3.4.1节中描述的方式解析模块：模块路径内容成为可观察模块的宇宙，而`--add-modules`提供的模块成为解析过程的根。但是`jlink`有几个特性：
- en: ESSENTIAL INFO By default, services (see chapter 10) aren’t bound. Section 14.1.3
    explains why and explores what to do about it.
  id: totrans-1132
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 默认情况下，服务（见第10章）没有被绑定。14.1.3节解释了原因，并探讨了如何解决这个问题。'
- en: Optional dependencies with `requires static` (see section 11.2) aren’t resolved.
    They need to be added manually.
  id: totrans-1133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`requires static`（见第11.2节）的可选依赖项不会被解析。它们需要手动添加。
- en: Automatic modules aren’t allowed. This becomes important in section 14.2 and
    is explained there in more detail.
  id: totrans-1134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许自动模块。这一点在14.2节中非常重要，并在那里有更详细的解释。
- en: Unless any problems like missing or duplicate modules are encountered, the resolved
    modules (root modules plus transitive dependencies) end up in the new runtime
    image. Let’s take a look at it.
  id: totrans-1135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除非遇到任何问题，如缺少或重复的模块，否则解析的模块（根模块加上传递依赖）最终会出现在新的运行时镜像中。让我们来看看它。
- en: 14.1.2 IMAGE CONTENT AND STRUCTURE
  id: totrans-1136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 14.1.2 镜像内容和结构
- en: 'First things first: this image takes up only about 45 MB (on Linux; I hear
    it’s even less on Windows) compared to the 263 MB of a full JRE—and that’s without
    the space optimizations discussed in section 14.4.2\. So what does the image look
    like? Section 6.3 introduces the new JDK/JRE directory structure; and as [figure
    14.1](part0029.html#filepos1712158) shows, runtime images created with `jlink`
    are similar. This isn’t a coincidence: the JDKs and JREs you can download are
    composed with `jlink`.'
  id: totrans-1137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先：这个镜像仅占用大约45 MB（在Linux上；我听说在Windows上更少），而完整的JRE占用263 MB——这还不包括第14.4.2节中讨论的空间优化。那么这个镜像看起来是什么样子呢？第6.3节介绍了新的JDK/JRE目录结构；如图14.1（part0029.html#filepos1712158）所示，用`jlink`创建的运行时镜像相似。这不是巧合：您可以下载的JDK和JRE是用`jlink`组合的。
- en: '![](../images/00122.jpeg)'
  id: totrans-1138
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00122.jpeg)'
- en: '[Figure 14.1](part0029.html#filepos1711509) Comparison between the directory
    structure of the JDK (left) and a custom runtime image created with `jlink` (right).
    The similarity isn’t accidental—the JDK is created with `jlink`.'
  id: totrans-1139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图14.1](part0029.html#filepos1711509) JDK（左）和用`jlink`创建的自定义运行时镜像（右）的目录结构比较。这种相似性并非偶然——JDK是用`jlink`创建的。'
- en: 'Note that `jlink` fuses the included modules into `lib/modules` and then omits
    the `jmods` folder from the final image. This is in line with how the JRE was
    generated, which also doesn’t contain `jmods`. The raw JMOD files are only included
    in the JDK so that `jlink` can process them: optimizing modules into `lib/modules`
    is a one-way operation, and `jlink` can’t generate further images from the optimized
    image.'
  id: totrans-1140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，`jlink`将包含的模块融合到`lib/modules`中，然后从最终镜像中省略`jmods`文件夹。这与生成JRE的方式一致，它也不包含`jmods`。原始的JMOD文件仅包含在JDK中，以便`jlink`可以处理它们：将模块优化到`lib/modules`是一个单向操作，`jlink`不能从优化后的镜像生成进一步的镜像。
- en: Looking into `bin`, you may wonder which executables you can expect to find
    there. Turns out that `jlink` is clever and will only generate executables for
    which the required modules were included in the image. The compiler executable
    `javac`, for example, comes with the jdk.compiler module and won’t be available
    if that module isn’t included.
  id: totrans-1141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看目录`bin`时，你可能想知道你可以在那里找到哪些可执行文件。实际上，`jlink`非常智能，它只为那些在镜像中包含了所需模块的可执行文件生成可执行文件。例如，编译器可执行文件`javac`包含`jdk.compiler`模块，如果该模块没有被包含，则不可用。
- en: 14.1.3 INCLUDING SERVICES IN RUNTIME IMAGES
  id: totrans-1142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 14.1.3 在运行时镜像中包含服务
- en: If you take a careful look at [listing 14.1](part0029.html#filepos1704639),
    it should seem a little odd that the image only contains java.base. In section
    10.1.2, you learned that the base module uses a lot of services provided by other
    platform modules and that when services are bound during module resolution, all
    those providers are pulled into the module graph. So why don’t they end up in
    the image, too?
  id: totrans-1143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你仔细观察[列表14.1](part0029.html#filepos1704639)，你会发现图像中只包含java.base这一点有些奇怪。在第10.1.2节中，你了解到基本模块使用了其他平台模块提供的大量服务，并且在模块解析期间绑定服务时，所有这些提供者都会被拉入模块图中。那么为什么它们最终没有出现在图像中呢？
- en: 'Definition: --bind-services'
  id: totrans-1144
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：--bind-services
- en: To enable the creation of small, deliberately assembled runtime images, `jlink`,
    by default, performs no service binding when creating an image. Instead, service-provider
    modules have to be included manually by listing them in `--add-modules`. Alternatively,
    the option`--bind-services`can be used toinclude all modules that provide a service
    that’s used by another resolved module.
  id: totrans-1145
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了能够创建小而精心组装的运行时图像，`jlink`默认在创建图像时不执行服务绑定。相反，服务提供者模块必须通过在`--add-modules`中列出它们来手动包含。或者，可以使用选项`--bind-services`来包含所有提供其他解析模块使用的服务的模块。
- en: 'Let’s pick charsets like ISO-8859-1, UTF-8, or UTF-16 as an example. The base
    module knows the ones you need on a daily basis, but there’s a specific platform
    module that contains a few other ones: jdk.charsets. The base module and jdk.charsets
    are decoupled via services. Here are the relevant parts of their module declarations:'
  id: totrans-1146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们以ISO-8859-1、UTF-8或UTF-16这样的字符集为例。基本模块知道你日常需要的一些字符集，但有一个特定的平台模块包含了一些其他的字符集：jdk.charsets。基本模块和jdk.charsets通过服务解耦。以下是它们模块声明的相关部分：
- en: '`module java.base { uses java.nio.charset.spi.CharsetProvider; }  module jdk.charsets
    { provides java.nio.charset.spi.CharsetProvider with sun.nio.cs.ext.ExtendedCharsets
    }`'
  id: totrans-1147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module java.base { uses java.nio.charset.spi.CharsetProvider; }  module jdk.charsets
    { provides java.nio.charset.spi.CharsetProvider with sun.nio.cs.ext.ExtendedCharsets
    }`'
- en: When the JPMS resolves modules during a regular launch, service binding will
    pull in jdk.charsets, so its charsets haven’t always been available in a standard
    JRE. But when you’re creating a runtime image with `jlink`, that doesn’t happen,
    so by default images won’t contain the charsets module. If your project depends
    on it, you may find out the hard way.
  id: totrans-1148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当JPMS在常规启动期间解析模块时，服务绑定会拉入jdk.charsets，因此其字符集并不总是存在于标准的JRE中。但是，当你使用`jlink`创建运行时图像时，这种情况不会发生，因此默认情况下图像不会包含字符集模块。如果你的项目依赖于它，你可能需要通过困难的方式才能发现这一点。
- en: 'Once you’ve determined that you depend on a module that’s decoupled from the
    rest via services, you can include it in the image with `--add-modules`:'
  id: totrans-1149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦你确定你依赖于一个通过服务与其他模块解耦的模块，你就可以使用`--add-modules`将其包含在图像中：
- en: '`$ jlink --module-path ${jdk-9}/jmods --add-modules java.base,jdk.charsets
    --output jdk-charsets $ jdk-charsets/bin/java --list-modules  > java.base > jdk.charsets`'
  id: totrans-1150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jlink --module-path ${jdk-9}/jmods --add-modules java.base,jdk.charsets
    --output jdk-charsets $ jdk-charsets/bin/java --list-modules  > java.base > jdk.charsets`'
- en: 'Definition: --suggest-providers'
  id: totrans-1151
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：--suggest-providers
- en: Manually identifying service-provider modules can be cumbersome. Fortunately,
    `jlink` can help you out. The option`--suggest-providers ${service}`lists all
    observable modules that provide an implementation of `${service}`, which must
    be specified with its fully qualified name.
  id: totrans-1152
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 手动识别服务提供者模块可能会很麻烦。幸运的是，`jlink`可以帮助你。选项`--suggest-providers ${service}`列出所有提供`${service}`实现的可观察模块，其中`${service}`必须使用其完全限定名指定。
- en: 'Say you’ve created a minimal runtime image containing only java.base, and,
    when executing your application, you run into problems due to missing charsets.
    You track the problem to java.base using `java.nio.charset.spi.CharsetProvider`
    and now wonder which modules provide that service. Here comes `--suggest-providers`
    to save the day:'
  id: totrans-1153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你已经创建了一个只包含java.base的最小运行时图像，并且在执行你的应用程序时，由于缺少字符集而遇到问题。你使用`java.nio.charset.spi.CharsetProvider`追踪到java.base的问题，现在想知道哪些模块提供了该服务。这时，`--suggest-providers`选项就派上用场了：
- en: '`$ jlink --module-path ${jdk-9}/jmods --suggest-providers java.nio.charset.spi.CharsetProvider  >
    Suggested providers: > jdk.charsets > provides java.nio.charset.spi.CharsetProvider
    > used by java.base`'
  id: totrans-1154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jlink --module-path ${jdk-9}/jmods --suggest-providers java.nio.charset.spi.CharsetProvider  >
    建议提供者: > jdk.charsets > provides java.nio.charset.spi.CharsetProvider > used by
    java.base`'
- en: 'Another good example for silently missing modules is locales. All except the
    English locales are contained in jdk.localedata, which makes them available to
    the base module via a service. Consider the following code:'
  id: totrans-1155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个无声缺失模块的好例子是区域。除了英语区域外，所有区域都包含在jdk.localedata中，这使得它们可以通过服务提供给基础模块。考虑以下代码：
- en: '`String half = NumberFormat .getInstance(new Locale("fi", "FI")) .format(0.5);
    System.out.println(half);`'
  id: totrans-1156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`String half = NumberFormat .getInstance(new Locale("fi", "FI")) .format(0.5);
    System.out.println(half);`'
- en: What does it print? `Locale("fi", "FI")` creates the locale for Finland, and
    the Finnish format uses floating-point numbers with a comma, so the result will
    be `0,5`—at least, when the Finnish locale is available. If you execute this code
    on a runtime image that doesn’t contain jdk.localedata, like the one you created
    earlier, you’ll get `0.5`, because Java silently falls back to the default locale.
    Yes, this isn’t an error, but silent misbehavior.
  id: totrans-1157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 它会打印什么？`Locale("fi", "FI")`为芬兰创建区域，芬兰格式使用带有逗号的浮点数，所以结果将是`0,5`——至少，当芬兰区域可用时。如果你在不含jdk.localedata的运行时图像上执行此代码，比如你之前创建的那个，你会得到`0.5`，因为Java会静默地回退到默认区域。是的，这不是错误，但这是静默的错误行为。
- en: As before, the solution is to explicitly include the decoupled module, in this
    case jdk.localedata. But it adds a whopping 16 MB to the image size because it
    contains a lot of locale data. Fortunately, as you’ll see in section 14.4.2, `jlink`
    can help reduce that additional load.
  id: totrans-1158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 和之前一样，解决方案是显式包含解耦的模块，在这个例子中是jdk.localedata。但它会增加16 MB到图像大小，因为它包含大量的区域数据。幸运的是，正如你将在14.4.2节中看到的，`jlink`可以帮助减少这种额外的负载。
- en: NOTE When your application’s behavior differs between running on generic downloaded
    Java and on a customized runtime image, you should think about services. Could
    the misbehavior stem from some feature of the JVM not being available? Maybe its
    module was decoupled via services and is now missing in your runtime image.
  id: totrans-1159
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：当你的应用程序在通用下载的Java和定制运行时图像上运行时的行为不同时，你应该考虑服务。错误行为可能是由于JVM中某些功能不可用吗？也许它的模块通过服务解耦，现在在你的运行时图像中缺失。
- en: 'These are some of the services the base module uses and other platform modules
    provide that you may implicitly depend on:'
  id: totrans-1160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些是基础模块使用以及其他平台模块提供的你可能隐式依赖的一些服务：
- en: Charsets from jdk.charsets
  id: totrans-1161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自jdk.charsets的字符集
- en: Locales from jdk.localedata
  id: totrans-1162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自jdk.localedata的区域
- en: Zip file system from jdk.zipfs
  id: totrans-1163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自jdk.zipfs的ZIP文件系统
- en: Security providers from java.naming, java.security.jgss, java.security.sasl,
    java.smartcardio, java.xml.crypto, jdk.crypto.cryptoki, jdk.crypto.ec, jdk.deploy,
    and jdk.security.jgss
  id: totrans-1164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自java.naming、java.security.jgss、java.security.sasl、java.smartcardio、java.xml.crypto、jdk.crypto.cryptoki、jdk.crypto.ec、jdk.deploy和jdk.security.jgss的安全提供者
- en: 'As an alternative to manually identifying and adding individual modules, you
    can use the blanket `--bind-services`:'
  id: totrans-1165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为手动识别和添加单个模块的替代方案，你可以使用通用的`--bind-services`：
- en: '`$ jlink --module-path ${jdk-9}/jmods --add-modules java.base --bind-services
    --output jdk-base-services $ jdk-base-services/bin/java --list-modules  > java.base
    > java.compiler > java.datatransfer > java.desktop # truncated about three dozen
    more modules`'
  id: totrans-1166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jlink --module-path ${jdk-9}/jmods --add-modules java.base --bind-services
    --output jdk-base-services $ jdk-base-services/bin/java --list-modules  > java.base
    > java.compiler > java.datatransfer > java.desktop # 省略了大约三十多个模块`'
- en: This binds all modules that provide a service to the base module, though, and
    thus creates a fairly large image—this one is about 150 MB without optimizations.
    You should carefully consider whether that’s the way to go.
  id: totrans-1167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，这会将所有提供服务的模块绑定到基础模块，从而创建了一个相当大的图像——这个图像在优化之前大约有150 MB。你应该仔细考虑这是否是正确的做法。
- en: 14.1.4 RIGHT-SIZING IMAGES WITH JLINK AND JDEPS
  id: totrans-1168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 14.1.4 使用JLINK和JDeps调整图像大小
- en: So far, you’ve only created small images consisting of java.base and a few other
    modules. But what about a real-life use case; how would you determine which platform
    modules you need to sustain a large application? Can’t use trial and error, right?
  id: totrans-1169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到目前为止，你只创建了包含java.base和一些其他模块的小型图像。但对于实际应用场景，你将如何确定需要哪些平台模块来维持一个大型应用？不能使用试错法，对吧？
- en: 'The answer is JDeps. For a thorough introduction, see appendix D—here it suffices
    to know that the following incantation will list all platform modules your application
    depends on:'
  id: totrans-1170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案是JDeps。对于详细介绍，请参阅附录D——这里只需知道以下咒语将列出你的应用程序依赖的所有平台模块：
- en: '`jdeps -summary -recursive --class-path ''jars/*'' jars/app.jar`'
  id: totrans-1171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`jdeps -summary -recursive --class-path ''jars/*'' jars/app.jar`'
- en: 'For this to work, the `jars` folder must contain all JARs required to run your
    application (your code as well as dependencies; your build tool will help with
    that), and `jars/app.jar` must contain the `main` method you use to launch. The
    result will show lots of dependencies between artifacts, but you’ll also see lines
    that show dependencies on platform modules. The following example lists platform
    modules used by Hibernate Core 5.2.12 and its dependencies:'
  id: totrans-1172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了使其工作，`jars`文件夹必须包含运行应用程序所需的所有JAR文件（包括你的代码以及依赖项；你的构建工具将帮助你完成这项工作），并且`jars/app.jar`必须包含你用来启动的`main`方法。结果将显示许多工件之间的依赖关系，但你也会看到显示对平台模块依赖的行。以下示例列出了Hibernate
    Core 5.2.12及其依赖项使用的平台模块：
- en: '`antlr-2.7.7.jar -> java.base classmate-1.3.0.jar -> java.base dom4j-1.6.1.jar
    -> java.base dom4j-1.6.1.jar -> java.xml hibernate-commons-annotations-5.0.1.Final.jar
    -> java.base hibernate-commons-annotations-5.0.1.Final.jar -> java.desktop hibernate-core-5.2.12.Final.jar
    -> java.base hibernate-core-5.2.12.Final.jar -> java.desktop hibernate-core-5.2.12.Final.jar
    -> java.instrument hibernate-core-5.2.12.Final.jar -> java.management hibernate-core-5.2.12.Final.jar
    -> java.naming hibernate-core-5.2.12.Final.jar -> java.sql hibernate-core-5.2.12.Final.jar
    -> java.xml hibernate-core-5.2.12.Final.jar -> java.xml.bind hibernate-jpa-2.1-api-1.0.0.Final.jar
    -> java.base hibernate-jpa-2.1-api-1.0.0.Final.jar -> java.instrument hibernate-jpa-2.1-api-1.0.0.Final.jar
    -> java.sql jandex-2.0.3.Final.jar -> java.base javassist-3.22.0-GA.jar -> java.base
    javassist-3.22.0-GA.jar -> jdk.unsupported jboss-logging-3.3.0.Final.jar -> java.base
    jboss-logging-3.3.0.Final.jar -> java.logging slf4j-api-1.7.13.jar -> java.base`'
  id: totrans-1173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`antlr-2.7.7.jar -> java.base classmate-1.3.0.jar -> java.base dom4j-1.6.1.jar
    -> java.base dom4j-1.6.1.jar -> java.xml hibernate-commons-annotations-5.0.1.Final.jar
    -> java.base hibernate-commons-annotations-5.0.1.Final.jar -> java.desktop hibernate-core-5.2.12.Final.jar
    -> java.base hibernate-core-5.2.12.Final.jar -> java.desktop hibernate-core-5.2.12.Final.jar
    -> java.instrument hibernate-core-5.2.12.Final.jar -> java.management hibernate-core-5.2.12.Final.jar
    -> java.naming hibernate-core-5.2.12.Final.jar -> java.sql hibernate-core-5.2.12.Final.jar
    -> java.xml hibernate-core-5.2.12.Final.jar -> java.xml.bind hibernate-jpa-2.1-api-1.0.0.Final.jar
    -> java.base hibernate-jpa-2.1-api-1.0.0.Final.jar -> java.instrument hibernate-jpa-2.1-api-1.0.0.Final.jar
    -> java.sql jandex-2.0.3.Final.jar -> java.base javassist-3.22.0-GA.jar -> java.base
    javassist-3.22.0-GA.jar -> jdk.unsupported jboss-logging-3.3.0.Final.jar -> java.base
    jboss-logging-3.3.0.Final.jar -> java.logging slf4j-api-1.7.13.jar -> java.base`'
- en: 'All you need to do now is extract those lines, remove the `… ->` part, and
    throw away duplicates. For Linux users:'
  id: totrans-1174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在你需要做的就是提取这些行，删除`… ->`部分，并丢弃重复项。对于Linux用户：
- en: '`jdeps -summary -recursive --class-path ''jars/*'' jars/app.jar | grep ''\->
    java.\|\-> jdk.'' | sed ''s/^.*-> //'' | sort -u`'
  id: totrans-1175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`jdeps -summary -recursive --class-path ''jars/*'' jars/app.jar | grep ''\->
    java.\|\-> jdk.'' | sed ''s/^.*-> //'' | sort -u`'
- en: You end up with a neat list of platform modules that your application depends
    on. Feed those into `jlink --add-modules`, and you’ll get the smallest possible
    runtime image that supports your app (see [figure 14.2](part0029.html#filepos1731834)).
  id: totrans-1176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你最终会得到一个整洁的平台模块列表，你的应用程序依赖于这些模块。将这些模块输入到`jlink --add-modules`中，你将得到支持你的应用程序的最小可能的运行时镜像（参见[图14.2](part0029.html#filepos1731834)）。
- en: '![](../images/00092.jpeg)'
  id: totrans-1177
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00092.jpeg)'
- en: '[Figure 14.2](part0029.html#filepos1731521) Given the application JARs (top)
    and their dependencies on platform modules (bottom), `jlink` can create a runtime
    image with just the required platform modules.'
  id: totrans-1178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图14.2](part0029.html#filepos1731521) 给定应用程序JAR文件（顶部）及其对平台模块的依赖关系（底部），`jlink`可以创建仅包含所需平台模块的运行时镜像。'
- en: 'ESSENTIAL INFO There are a few caveats, though:'
  id: totrans-1179
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**基本信息** 有几点需要注意：'
- en: JDeps occasionally reports `… -> not found`, which means some transitive dependency
    wasn’t on the class path. Make sure the class path for JDeps contains the exact
    artifacts you use when running your app.
  id: totrans-1180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDeps偶尔会报告`… -> not found`，这意味着某些传递依赖没有在类路径上。确保JDeps的类路径包含运行应用程序时使用的确切工件。
- en: JDeps can’t analyze reflection, so if your code or your dependencies’ code interacts
    with JDK classes by reflection only, JDeps won’t pick up on that. That could lead
    to a required module not making it into the image.
  id: totrans-1181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDeps无法分析反射，因此如果你的代码或依赖项的代码仅通过反射与JDK类交互，JDeps将无法检测到这一点。这可能导致所需的模块没有包含在镜像中。
- en: As discussed in section 14.1.3, `jlink` doesn’t bind services by default, but
    your application may implicitly rely on some JDK-internal providers being present.
  id: totrans-1182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如第14.1.3节所述，`jlink`默认不绑定服务，但你的应用程序可能隐式依赖于一些JDK内部提供者存在。
- en: Consider adding the java.instrument module, which is needed to support Java
    agents. It’s a must if your production environment uses agents to observe running
    applications; but even if it doesn’t, you may find yourself in a bind where a
    Java agent is the best way to analyze your problem. Also, it’s only about 150
    KB, so it’s hardly a big deal.
  id: totrans-1183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑添加java.instrument模块，这是支持Java代理所需的。如果你的生产环境使用代理来观察运行中的应用程序，那么这是必须的；即使不使用，你也可能发现自己处于一种困境，即Java代理是分析问题的最佳方式。此外，它只有大约150
    KB，所以这几乎不是什么大问题。
- en: NOTE Once you’ve created a runtime image for your application, I recommend you
    run unit tests and integration tests on it. This will give you confidence that
    you really included all required modules.
  id: totrans-1184
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意** 一旦为你的应用程序创建了运行时镜像，我建议你在其上运行单元测试和集成测试。这将让你有信心确实包含了所有必需的模块。'
- en: Next up is including application modules in your image—but to do that, your
    app and its dependencies need to be fully modularized. If that isn’t the case,
    and you’re looking for more immediately applicable knowledge, skip to section
    14.3 for generating runtime images across OSs or section 14.4 for optimizing your
    image.
  id: totrans-1185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接下来是将在你的镜像中包含应用程序模块——但要做到这一点，你的应用程序及其依赖项需要完全模块化。如果这不是情况，并且你在寻找更直接适用的知识，请跳转到第14.3节以生成跨操作系统的运行时镜像，或第14.4节以优化你的镜像。
- en: 14.2 Creating self-contained application images
  id: totrans-1186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 14.2 创建自包含的应用程序镜像
- en: So far, you’ve created runtime images supporting an application, but there’s
    no reason to stop there. `jlink` makes it easy to create images containing the
    entire application. That means you’ll end up with an image containing application
    modules (the app itself plus its dependencies) and the platform modules needed
    to support it. You can even create a nice launcher, so you can run your application
    with `bin/my-app`! Distributing your application just became a lot easier.
  id: totrans-1187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到目前为止，你已经创建了支持应用程序的运行时镜像，但没有任何理由就此停止。`jlink`使得创建包含整个应用程序的镜像变得容易。这意味着你最终会得到一个包含应用程序模块（应用程序本身及其依赖项）和支撑它的平台模块的镜像。你甚至可以创建一个漂亮的启动器，这样你就可以使用`bin/my-app`来运行你的应用程序了！分发你的应用程序现在变得容易多了。
- en: 'Definition: Application images'
  id: totrans-1188
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：应用程序镜像
- en: Even though it’s not an official term, I call images including application modules
    application images (as opposed to runtime images) to clearly delineate what I’m
    talking about. After all, the outcome is more akin to an application than to a
    general runtime.
  id: totrans-1189
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然这不是一个官方术语，但我将包含应用程序模块的镜像称为应用程序镜像（与运行时镜像相对），以清楚地界定我在谈论的内容。毕竟，结果更接近于应用程序而不是通用的运行时。
- en: ESSENTIAL INFO Note that `jlink` only operates on explicit modules, so an application
    depending on automatic modules (see section 8.3) can’t be linked into an image.
    If you absolutely have to create an image with your app, have a look at section
    9.3.3 on how to make third-party JARs modular, or use a tool like ModiTect ([https://github.com/moditect/moditect](https://github.com/moditect/moditect))
    that does it for you.
  id: totrans-1190
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 注意，`jlink`只操作显式模块，所以依赖于自动模块（见第8.3节）的应用程序不能链接到镜像中。如果你绝对需要创建包含你的应用程序的镜像，请查看第9.3.3节了解如何使第三方JARs模块化，或者使用ModiTect（[https://github.com/moditect/moditect](https://github.com/moditect/moditect)）这样的工具来为你完成这项工作。'
- en: This limitation to explicit modules has no technical grounds—it was a design
    decision. An application image is supposed to be self-contained, but if it depends
    on automatic modules, which don’t express dependencies, the JPMS can’t verify
    that and a `NoClassDefFoundError` may ensue. Not exactly the reliability the module
    system strives for.
  id: totrans-1191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种对显式模块的限制没有技术依据——这是一个设计决策。应用程序镜像应该是自包含的，但如果它依赖于不表达依赖的自动模块，JPMS就无法验证，可能会导致`NoClassDefFoundError`。这并不符合模块系统追求的可靠性。
- en: With the prerequisites settled, let’s get going. You’ll first create an image
    that includes application modules (section 14.2.1) before making your life easier
    by creating launchers (section 14.2.2). Finally, we’ll ponder the security, performance,
    and stability of application images (section 14.2.3).
  id: totrans-1192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在满足先决条件后，让我们开始吧。你首先会创建一个包含应用程序模块的镜像（第14.2.1节），然后通过创建启动器（第14.2.2节）来简化你的生活。最后，我们将探讨应用程序镜像的安全性、性能和稳定性（第14.2.3节）。
- en: 14.2.1 INCLUDING APPLICATION MODULES IN IMAGES
  id: totrans-1193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 14.2.1 在镜像中包含应用程序模块
- en: All you need to do to create an application image is add application modules
    to the `jlink` module path and pick one or more of them as root. The resulting
    image will contain all required modules (but no others; see [figure 14.3](part0029.html#filepos1739734))
    and can be launched with `bin/java --module ${initial-module}`.
  id: totrans-1194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建应用程序镜像所需的所有操作就是将应用程序模块添加到 `jlink` 模块路径，并从中选择一个或多个作为根模块。生成的镜像将包含所有必需的模块（但不含其他模块；参见[图
    14.3](part0029.html#filepos1739734)）并且可以使用 `bin/java --module ${initial-module}`
    启动。
- en: '![](../images/00015.jpeg)'
  id: totrans-1195
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00015.jpeg)'
- en: '[Figure 14.3](part0029.html#filepos1739262) Given the application modules (top)
    and their dependencies on platform modules (bottom), `jlink` can create a runtime
    image with just the required modules, including both application and platform
    code.'
  id: totrans-1196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 14.3](part0029.html#filepos1739262) 给定应用程序模块（上方）及其对平台模块的依赖关系（下方），`jlink`
    可以创建仅包含所需模块的运行时镜像，包括应用程序和平台代码。'
- en: 'As an example, let’s once again turn to the ServiceMonitor application. Because
    it depends on the automatic modules spark.core and hibernate.jpa and `jlink` doesn’t
    support those, I had to cut out that functionality. This leaves us with seven
    modules, all of which depend only on java.base:'
  id: totrans-1197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，让我们再次转向 ServiceMonitor 应用程序。因为它依赖于自动模块 spark.core 和 hibernate.jpa，而 `jlink`
    不支持这些模块，所以我不得不移除该功能。这使我们只剩下七个模块，它们都只依赖于 java.base：
- en: monitor
  id: totrans-1198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: monitor
- en: monitor.observer
  id: totrans-1199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: monitor.observer
- en: monitor.observer.alpha
  id: totrans-1200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: monitor.observer.alpha
- en: monitor.observer.beta
  id: totrans-1201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: monitor.observer.beta
- en: monitor.persistence
  id: totrans-1202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: monitor.persistence
- en: monitor.rest
  id: totrans-1203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: monitor.rest
- en: monitor.statistics
  id: totrans-1204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: monitor.statistics
- en: I put these into a folder named `mods` and created an image, as shown in [listing
    14.2](part0029.html#filepos1743693). Unfortunately, I forgot that the observer
    implementations monitor.observer.alpha and monitor.observer.beta are decoupled
    from the rest of the application via services and that they aren’t bound by default
    (see chapter 10 on services and section 14.1.3 on how `jlink` handles them). Hence
    I had to try again in [listing 14.3](part0029.html#filepos1746093) by adding them
    explicitly. Alternatively, I could have used `--bind-services`, but I didn’t like
    how large the image became when all JDK-internal service providers were included.
  id: totrans-1205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我将这些放入名为 `mods` 的文件夹中，并创建了一个镜像，如[列表 14.2](part0029.html#filepos1743693)所示。不幸的是，我忘记了观察者实现
    monitor.observer.alpha 和 monitor.observer.beta 通过服务与应用程序的其他部分解耦，并且它们默认情况下没有绑定（参见第
    10 章“服务”和第 14.1.3 节“`jlink` 如何处理它们”）。因此，我不得不在[列表 14.3](part0029.html#filepos1746093)中再次尝试，通过显式添加它们。或者，我本可以使用
    `--bind-services`，但我不喜欢包含所有 JDK 内部服务提供者时镜像变得很大。
- en: Listing 14.2 Creating an application image containing ServiceMonitor
  id: totrans-1206
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 14.2 创建包含 ServiceMonitor 的应用程序镜像
- en: '`$ jlink` `--module-path ${jdk-9}/jmods:mods` [`①`](part0029.html#filepos1744748)`--add-modules
    monitor` [`②`](part0029.html#filepos1745161) `--output jdk-monitor $ jdk-monitor/bin/java
    --list-modules  > java.base > monitor` `> monitor.observer` [`③`](part0029.html#filepos1745571)
    `> monitor.persistence > monitor.rest > monitor.statistics`'
  id: totrans-1207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jlink` `--module-path ${jdk-9}/jmods:mods` [①](part0029.html#filepos1744748)`--add-modules
    monitor` [②](part0029.html#filepos1745161) `--output jdk-monitor $ jdk-monitor/bin/java
    --list-modules  > java.base > monitor` `> monitor.observer` [③](part0029.html#filepos1745571)
    `> monitor.persistence > monitor.rest > monitor.statistics`'
- en: ①
  id: totrans-1208
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: In addition to platform modules, I specified application modules in mods. On
    Windows, use ; instead of :.
  id: totrans-1209
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了平台模块外，我在 mods 中还指定了应用程序模块。在 Windows 上，使用 ; 而不是 :。
- en: ②
  id: totrans-1210
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Starts module resolution with monitor
  id: totrans-1211
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以 monitor 为起点开始模块解析
- en: ③
  id: totrans-1212
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: The service implementations monitor.observer.alpha and monitor.observer.beta
    are missing.
  id: totrans-1213
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 服务实现 monitor.observer.alpha 和 monitor.observer.beta 缺失。
- en: Listing 14.3 Creating an application image, this time including services
  id: totrans-1214
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 14.3 创建应用程序镜像，这次包括服务
- en: '`$ jlink --module-path ${jdk-9}/jmods:mods --add-modules monitor,` `monitor.observer.alpha,monitor.observer.beta`
    [`①`](part0029.html#filepos1746978) `--output jdk-monitor $ jdk-monitor/bin/java
    --list-modules  > java.base > monitor > monitor.observer > monitor.observer.alpha
    > monitor.observer.beta > monitor.persistence > monitor.rest > monitor.statistics`'
  id: totrans-1215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jlink --module-path ${jdk-9}/jmods:mods --add-modules monitor,` `monitor.observer.alpha,monitor.observer.beta`
    [①](part0029.html#filepos1746978) `--output jdk-monitor $ jdk-monitor/bin/java
    --list-modules  > java.base > monitor > monitor.observer > monitor.observer.alpha
    > monitor.observer.beta > monitor.persistence > monitor.rest > monitor.statistics`'
- en: ①
  id: totrans-1216
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Starts module resolution with the initial module (monitor) and all desired services
    (other two)
  id: totrans-1217
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以初始模块（monitor）和所有所需服务（其他两个）为起点开始模块解析
- en: 'Definition: System modules'
  id: totrans-1218
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：系统模块
- en: Taken together, the platform and application modules that the image contains
    are known as system modules. As you’ll see in a minute, it’s still possible to
    add other modules when launching the application.
  id: totrans-1219
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总而言之，镜像中包含的平台模块和应用程序模块被称为系统模块。您将在下一分钟看到，在启动应用程序时仍然可以添加其他模块。
- en: BEWARE OF RESOLUTION PECULIARITIES!
  id: totrans-1220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意分辨率特性！
- en: 'Remember from section 14.1 that `jlink` creates a minimal image:'
  id: totrans-1221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从第14.1节中记住，`jlink`创建了一个最小镜像：
- en: It doesn’t bind services.
  id: totrans-1222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不绑定服务。
- en: It doesn’t include optional dependencies.
  id: totrans-1223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不包括可选依赖项。
- en: ESSENTIAL INFO Although you’ll likely remember to check the presence of your
    own services, you may forget about your dependencies (that SQL driver implementation,
    for example) or platform modules (locale data or unusual charsets). The same goes
    for optional dependencies, which you may want to include but forget that they
    aren’t resolved merely because they’re present on the module path (see section
    11.2.3). Make sure you really end up with all the modules you need!
  id: totrans-1224
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的信息：尽管您可能会记得检查您自己的服务是否存在，但您可能会忘记您的依赖项（例如，SQL驱动程序的实现）或平台模块（地区数据或非标准的字符集）。同样适用于可选依赖项，您可能希望包含它们，但忘记它们仅仅因为它们存在于模块路径上而没有解决（参见第11.2.3节）。确保您最终获得了所需的全部模块！
- en: The ServiceMonitor application uses the Finnish locale to format its output,
    so it needs to add jdk.localedata to the image (see the following listing). This
    drives up the image size by 16 MB (to 61 MB), but section 14.4.2 shows how to
    reduce that.
  id: totrans-1225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ServiceMonitor应用程序使用芬兰地区设置来格式化其输出，因此它需要在镜像中添加 jdk.localedata（参见以下列表）。这会使镜像大小增加16
    MB（至61 MB），但第14.4.2节展示了如何减少这个大小。
- en: Listing 14.4 Creating the ServiceMonitor application image with locale data
  id: totrans-1226
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表14.4 使用区域数据创建ServiceMonitor应用程序镜像
- en: '`$ jlink --module-path ${jdk-9}/jmods:mods --add-modules monitor, monitor.observer.alpha,monitor.observer.beta,`
    `jdk.localedata` [`①`](part0029.html#filepos1750804) `--output jdk-monitor`'
  id: totrans-1227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jlink --module-path ${jdk-9}/jmods:mods --add-modules monitor, monitor.observer.alpha,monitor.observer.beta,`
    `jdk.localedata` [①](part0029.html#filepos1750804) `--output jdk-monitor`'
- en: ①
  id: totrans-1228
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: The platform module for locales is also added to the image.
  id: totrans-1229
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 平台模块的区域设置也添加到了镜像中。
- en: USING COMMAND-LINE OPTIONS WHEN LAUNCHING THE APPLICATION
  id: totrans-1230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在启动应用程序时使用命令行选项
- en: Once you’ve created the image, you can launch your application as usual with
    `java --module ${initial-module}`, using the `java` executable in the image’s
    `bin` folder. But because you included your application modules in the image,
    you don’t need to specify a module path—the JPMS will find them inside the image.
  id: totrans-1231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦创建了镜像，您就可以像往常一样使用`java --module ${initial-module}`启动应用程序，使用镜像`bin`文件夹中的`java`可执行文件。但由于您已在镜像中包含了应用程序模块，因此不需要指定模块路径——JPMS将在镜像内部找到它们。
- en: 'After creating the ServiceMonitor image in `jdk-monitor`, the application can
    be launched with a short command:'
  id: totrans-1232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在`jdk-monitor`中创建ServiceMonitor镜像后，可以使用简短的命令启动应用程序：
- en: '`$ jdk-monitor/bin/java --module monitor`'
  id: totrans-1233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jdk-monitor/bin/java --module monitor`'
- en: If you want to, you can use the module path, though. In that case, keep in mind
    that system modules (the ones in the image) will always shadow modules of the
    same name on the module path—it will be as if those on the module path don’t exist.
    What you can do with the module path is to add new modules to the application.
    These will likely be additional service providers, which allows you to ship an
    image with your application while still allowing users to easily extend it locally.
  id: totrans-1234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以使用模块路径。在这种情况下，请记住，系统模块（镜像中的模块）将始终覆盖模块路径上相同名称的模块——就好像模块路径上的模块不存在一样。您可以使用模块路径做的事情是向应用程序添加新模块。这些可能是额外的服务提供者，这允许您在仍然允许用户轻松本地扩展的情况下，与您的应用程序一起分发镜像。
- en: Let’s say ServiceMonitor discovers a new kind of microservice it needs to observe,
    and the module monitor.observer.zero does that. Moreover, the module implements
    all the right interfaces, and its descriptor declares that it provides `ServiceObserver`.
    Then, as shown next, you can use the same image from before and add monitor.observer.zero
    via the module path.
  id: totrans-1235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设ServiceMonitor发现了一种它需要观察的新类型的微服务，模块monitor.observer.zero就是这样做的。此外，该模块实现了所有正确的接口，并且其描述符声明它提供`ServiceObserver`。然后，如以下所示，您可以使用之前的相同镜像并通过模块路径添加monitor.observer.zero。
- en: Listing 14.5 Launching an application image with an additional service provider
  id: totrans-1236
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表14.5 使用附加服务提供者启动应用程序镜像
- en: '`$ jdk-monitor/bin/java` `--module-path mods/monitor.observer.zero.jar` [`①`](part0029.html#filepos1756265)`--show-module-resolution`
    [`②`](part0029.html#filepos1756619)`--dry-run` [`②`](part0029.html#filepos1756619)
    `--module monitor` `> root monitor jrt:/monitor` [`③`](part0029.html#filepos1757088)
    `# truncated monitor''s dependencies` `> monitor binds monitor.observer.alpha
    jrt:/monitor.observer.alpha` [`③`](part0029.html#filepos1757088)`> monitor binds
    monitor.observer.beta jrt:/monitor.observer.beta` [`③`](part0029.html#filepos1757088)`>
    monitor binds monitor.observer.zero file://...` [`④`](part0029.html#filepos1757470)'
  id: totrans-1237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jdk-monitor/bin/java` `--module-path mods/monitor.observer.zero.jar` [`①`](part0029.html#filepos1756265)`--show-module-resolution`
    [`②`](part0029.html#filepos1756619)`--dry-run` [`②`](part0029.html#filepos1756619)
    `--module monitor` `> root monitor jrt:/monitor` [`③`](part0029.html#filepos1757088)
    `# truncated monitor''s dependencies` `> monitor binds monitor.observer.alpha
    jrt:/monitor.observer.alpha` [`③`](part0029.html#filepos1757088)`> monitor binds
    monitor.observer.beta jrt:/monitor.observer.beta` [`③`](part0029.html#filepos1757088)`>
    monitor binds monitor.observer.zero file://...` [`④`](part0029.html#filepos1757470)'
- en: ①
  id: totrans-1238
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Places the service provider on the module path
  id: totrans-1239
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将服务提供者放置在模块路径上
- en: ②
  id: totrans-1240
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: Instead of really launching the app, looks at the module resolution to see the
    provider getting picked up (also, to see these options work as with a regular
    JRE)
  id: totrans-1241
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 而不是真正启动应用程序，查看模块解析以查看提供者是否被选中（此外，也可以看到这些选项如何与常规JRE一起工作）
- en: ③
  id: totrans-1242
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: 'The jrt: string shows that these modules are loaded from inside the image.'
  id: totrans-1243
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: jrt:字符串表明这些模块是从镜像内部加载的。
- en: ④
  id: totrans-1244
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ④
- en: The additional module is loaded from the module path as indicated by file:.
  id: totrans-1245
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 额外的模块从文件:指示的模块路径加载。
- en: ESSENTIAL INFO If you want to replace system modules, you have to place them
    on the upgrade module path as described in section 6.1.3\. In addition to the
    special case of the module path, all the other `java` options presented throughout
    this book work exactly the same in custom application images.
  id: totrans-1246
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 如果你想替换系统模块，你必须按照第6.1.3节中描述的方式将它们放置在升级模块路径上。除了模块路径的特殊情况外，本书中展示的所有其他`java`选项在自定义应用程序镜像中工作方式完全相同。'
- en: 14.2.2 GENERATING A NATIVE LAUNCHER FOR YOUR APPLICATION
  id: totrans-1247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 14.2.2 为你的应用程序生成本地启动器
- en: If creating an image containing your application and everything it needs, but
    nothing else, is the cake, adding a custom launcher is the icing. A custom launcher
    is an executable script (shell on Unix-based OSs, batch on Windows) in the image’s
    `bin` folder that’s preconfigured to start the JVM with a concrete module and
    main class.
  id: totrans-1248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果创建一个包含你的应用程序及其所需一切，但除此之外没有其他内容的镜像是一个蛋糕，那么添加自定义启动器就是糖霜。自定义启动器是图像`bin`文件夹中的一个可执行脚本（Unix基于操作系统上的shell，Windows上的批处理），预先配置为使用具体的模块和主类启动JVM。
- en: 'Definition: --launcher'
  id: totrans-1249
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**定义**：--launcher'
- en: 'To create a launcher, use the `--launcher ${name}=${module}/${main-class}`option:'
  id: totrans-1250
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要创建启动器，请使用`--launcher ${name}=${module}/${main-class}`选项：
- en: '`${name}` is the filename you pick for the executable.'
  id: totrans-1251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${name}`是你为可执行文件选择的文件名。'
- en: '`${module}` is the name of the module to launch with.'
  id: totrans-1252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${module}`是要启动的模块的名称。'
- en: '`${main-class}` is the name of the module’s main class.'
  id: totrans-1253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${main-class}`是模块的主类名称。'
- en: The latter two are what you’d normally put after `java --module`. And as in
    that case, if the module defines a main class, you can leave out `/${main-class}`.
  id: totrans-1254
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 后两个是你通常在`java --module`之后放置的内容。并且在这种情况下，如果模块定义了一个主类，你可以省略`/${main-class}`。
- en: As [listing 14.6](part0029.html#filepos1762452) shows, with `--launcher run-monitor=monitor`,
    you can tell `jlink` to create a script `run-monitor` in `bin` that launches the
    application with the equivalent of `java --module monitor`. Because monitor declares
    a main class (`monitor.Main`), there’s no reason to specify that with `--launcher`.
    If you wanted to, it would be `--launcher run-monitor=monitor/monitor.Main`.
  id: totrans-1255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如[列表14.6](part0029.html#filepos1762452)所示，使用`--launcher run-monitor=monitor`，你可以告诉`jlink`在`bin`目录中创建一个名为`run-monitor`的脚本，该脚本以`java
    --module monitor`的方式启动应用程序。因为monitor声明了一个主类（`monitor.Main`），所以没有必要在`--launcher`中指定它。如果你想要的话，它将是`--launcher
    run-monitor=monitor/monitor.Main`。
- en: Listing 14.6 Creating an application image with a launcher (and taking a peek)
  id: totrans-1256
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表14.6 使用启动器创建应用程序镜像（并一瞥）
- en: '`$ jlink` [`①`](part0029.html#filepos1764088) `--module-path ${jdk-9}/jmods:mods
    --add-modules monitor, monitor.observer.alpha,monitor.observer.beta --output jdk-monitor`
    `--launcher run-monitor=monitor` [`②`](part0029.html#filepos1764611)`$ cat jdk-monitor/bin/run-monitor`
    [`③`](part0029.html#filepos1765034)`> #!/bin/sh` [`④`](part0029.html#filepos1765407)
    `` > JLINK_VM_OPTIONS= > DIR=`dirname $0` `` `> $DIR/java $JLINK_VM_OPTIONS -m
    monitor/monitor.Main $@` [`⑤`](part0029.html#filepos1765752)`$ jdk-monitor/bin/run-monitor`
    [`⑥`](part0029.html#filepos1766109)'
  id: totrans-1257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jlink` [`①`](part0029.html#filepos1764088) `--module-path ${jdk-9}/jmods:mods
    --add-modules monitor, monitor.observer.alpha,monitor.observer.beta --output jdk-monitor`
    `--launcher run-monitor=monitor` [`②`](part0029.html#filepos1764611)`$ cat jdk-monitor/bin/run-monitor`
    [`③`](part0029.html#filepos1765034)`> #!/bin/sh` [`④`](part0029.html#filepos1765407)
    `` > JLINK_VM_OPTIONS= > DIR=`dirname $0` `` `> $DIR/java $JLINK_VM_OPTIONS -m
    monitor/monitor.Main $@` [`⑤`](part0029.html#filepos1765752)`$ jdk-monitor/bin/run-monitor`
    [`⑥`](part0029.html#filepos1766109)'
- en: ①
  id: totrans-1258
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: Generates the image as in [listing 14.3](part0029.html#filepos1746093) …
  id: totrans-1259
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 生成与[列表14.3](part0029.html#filepos1746093)中所示相同的图像…
- en: ②
  id: totrans-1260
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: … except for adding a launcher called run-monitor that launches the module monitor
    (which defines the main class)
  id: totrans-1261
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: …除了添加一个名为run-monitor的启动器，该启动器启动模块monitor（定义了主类）
- en: ③
  id: totrans-1262
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: Just for fun, looks into the script (cat prints the file content)
  id: totrans-1263
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只为好玩，看看脚本（cat打印文件内容）
- en: ④
  id: totrans-1264
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ④
- en: Indicates that this is a shell script
  id: totrans-1265
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表示这是一个shell脚本
- en: ⑤
  id: totrans-1266
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⑤
- en: Command that’s executed when calling the script
  id: totrans-1267
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 调用脚本时执行的命令
- en: ⑥
  id: totrans-1268
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⑥
- en: How you use the launcher
  id: totrans-1269
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如何使用启动器
- en: NOTE Did you spot the `JLINK_VM_OPTIONS` in [listing 14.6](part0029.html#filepos1762452)?
    If there are any command-line options you’d like to specify for your application—for
    example, tuning the garbage collector—you can put them here.
  id: totrans-1270
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意** 您在[列表14.6](part0029.html#filepos1762452)中发现了`JLINK_VM_OPTIONS`吗？如果您想为应用程序指定任何命令行选项——例如，调整垃圾收集器——您可以在这里放置它们。'
- en: 'Using a launcher does have a downside, though: all options you try to apply
    to the launching JVM will be interpreted as if you’d put them after the `--module`
    option, making them program arguments instead. That means that when using a launcher,
    you can’t ad hoc configure the module system—for example, to add additional services
    as discussed earlier.'
  id: totrans-1271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然使用启动器确实有缺点：您尝试应用于启动JVM的所有选项都将被解释为放在`--module`选项之后，因此它们将成为程序参数。这意味着在使用启动器时，您不能即兴配置模块系统——例如，添加之前讨论的额外服务。
- en: 'But I have good news: you aren’t forced to use the launcher, and the `java`
    command is still available. [Listing 14.5](part0029.html#filepos1754455) works
    exactly the same if a launcher was created—as long as you don’t use it.'
  id: totrans-1272
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但我有好消息：您不必使用启动器，`java`命令仍然可用。[列表14.5](part0029.html#filepos1754455)在创建启动器的情况下工作方式完全相同——只要您不使用它。
- en: 14.2.3 SECURITY, PERFORMANCE, AND STABILITY
  id: totrans-1273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 14.2.3 安全性、性能和稳定性
- en: Creating an application image can increase your application’s security by minimizing
    the amount of code available in the JVM and thus reducing the attack surface.
    As section 14.4.3 discusses, you can also expect small improvements in startup
    time.
  id: totrans-1274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建应用程序镜像可以通过最小化JVM中可用的代码量来提高应用程序的安全性，从而减少攻击面。正如第14.4.3节讨论的，您还可以期待启动时间的小幅提升。
- en: Although that sounds pretty neat, it only fully applies to situations where
    you have complete control over the application’s operation and redeploy regularly.
    If you ship your image to customers or otherwise have no control over when and
    how often the image is replaced with a newer one, the tables turn.
  id: totrans-1275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然听起来很酷，但这仅适用于完全控制应用程序操作并定期重新部署的情况。如果您将镜像发送给客户或无法控制何时以及如何用新镜像替换旧镜像，情况就会逆转。
- en: ESSENTIAL INFO An image generated with `jlink` isn’t built for modifications.
    It has no auto-update function, and patching it manually isn’t a realistic scenario.
    If users update their system Java, your application image won’t be impacted by
    that. Taken together, it’s forever bound to the exact Java version from which
    you took the platform modules during linking.
  id: totrans-1276
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 使用`jlink`生成的镜像不是为修改而构建的。它没有自动更新功能，手动修补也不是一个现实场景。如果用户更新系统Java，您的应用程序镜像将不会受到影响。综合来看，它将永远绑定到链接平台模块时的确切Java版本。'
- en: The upside is that Java patch updates can’t break your application, but the
    much more serious downside is that your app won’t benefit from any security patches
    or performance improvements the new Java version brings. Let that sink in. If
    a critical vulnerability is patched in a new Java version, your users will still
    be exposed until they deploy the new application image that you shipped.
  id: totrans-1277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 优点是Java补丁更新不会破坏你的应用程序，但更大的缺点是，你的应用程序将无法从新Java版本带来的任何安全补丁或性能改进中受益。请记住这一点。如果一个新Java版本中修复了关键漏洞，你的用户仍然会暴露，直到他们部署你发送的新应用程序镜像。
- en: NOTE If you decide to deliver application images, I recommend making this an
    additional delivery mechanism instead of the only one. Let users decide whether
    they want to deploy an entire image or prefer to run the JARs on their own runtime,
    over which they have full control and which they can update independently.
  id: totrans-1278
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意** 如果你决定交付应用程序镜像，我建议将其作为额外的交付机制，而不是唯一的机制。让用户决定他们是否想要部署整个镜像，或者更愿意在自己的运行时上运行JAR文件，他们可以完全控制该运行时，并且可以独立更新它。'
- en: 14.3 Generating images across operating systems
  id: totrans-1279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 14.3 在不同操作系统间生成镜像
- en: Although the bytecode your application and library JARs contain is independent
    of any OS, it needs an OS-specific Java Virtual Machine (JVM) to execute them.
    That’s why you download JDKs and runtimes specifically for Linux, macOS, or Windows
    (for example). It’s important to realize that `jlink` operates on the OS-specific
    plane! [Figure 14.4](part0029.html#filepos1771802) shows OS-specific pieces.
  id: totrans-1280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管你的应用程序和库JAR文件中的字节码与任何操作系统无关，但它们需要特定于操作系统的Java虚拟机（JVM）来执行。这就是为什么你需要下载针对Linux、macOS或Windows（例如）的特定JDK和运行时。重要的是要认识到`jlink`是在特定于操作系统的层面上操作的！[图14.4](part0029.html#filepos1771802)展示了特定于操作系统的组件。
- en: '![](../images/00017.jpeg)'
  id: totrans-1281
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00017.jpeg)'
- en: '[Figure 14.4](part0029.html#filepos1771465) Unlike application, library, and
    framework JARs (top), application images (right) are OS-specific, like JVMs (bottom).'
  id: totrans-1282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图14.4](part0029.html#filepos1771465) 与应用程序、库和框架JAR文件（顶部）不同，应用程序镜像（右侧）是特定于操作系统的，就像JVM（底部）一样。'
- en: 'It’s obvious when you think about it: the platform modules `jlink` uses to
    create an image come from an OS-specific JDK/JRE, so the resulting image is also
    OS-specific. Thus runtime or application images are always bound to one concrete
    OS.'
  id: totrans-1283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你思考这个问题时，这是显而易见的：`jlink`用来创建镜像的平台模块来自特定于操作系统的JDK/JRE，因此生成的镜像也是特定于操作系统的。因此，运行时或应用程序镜像总是绑定到一个具体的操作系统。
- en: 'Does that mean you have to execute `jlink` on a bunch of different machines
    to create all the various runtime or application images you need? Fortunately
    not. As you saw in section 14.1.1, when creating an image, you point `jlink` to
    the platform modules you want it to include. Here’s the thing: those don’t have
    to be for the OS on which you’re executing `jlink`!'
  id: totrans-1284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是否意味着你必须在一堆不同的机器上执行`jlink`来创建你需要的所有各种运行时或应用程序镜像？幸运的是，不必如此。正如你在14.1.1节中看到的，在创建镜像时，你需要将`jlink`指向它想要包含的平台模块。这里的关键是：这些模块不需要是你执行`jlink`的操作系统上的！
- en: ESSENTIAL INFO If you download and unpack a JDK for a different OS, you can
    place its `jmods` folder on the module path when running the `jlink` version from
    your system JDK. The linker will then determine that the image is to be created
    for that OS and will hence create one that works on it (but, of course, not on
    another). So given JDKs for all OSs your application supports, you can generate
    runtime or application images for each of them on the same machine.
  id: totrans-1285
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 如果你下载并解压了不同操作系统的JDK，你可以在运行系统JDK的`jlink`版本时将它的`jmods`文件夹放置在模块路径上。链接器将确定要为该操作系统创建镜像，因此将创建一个在该操作系统上运行的镜像（但当然，不能在其他操作系统上运行）。所以，如果你有支持所有操作系统的JDK，你可以在同一台机器上为每个操作系统生成运行时或应用程序镜像。'
- en: I’m running Linux, but say I want to generate an application image for the ServiceMonitor
    application that runs on macOS. Conveniently, `jlink` supports such scenarios
    very well—all you need is a JDK for the target OS.
  id: totrans-1286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我正在运行Linux，但假设我想为在macOS上运行的ServiceMonitor应用程序生成一个应用程序镜像。方便的是，`jlink`非常支持这种场景——你所需要的只是一个目标操作系统的JDK。
- en: Turns out the hardest part is to unpack a JDK on an OS it wasn’t packaged for.
    In this case, I have to get into the `*.dmg` file that Oracle distributes for
    macOS—I won’t go into details here, but you can find advice on each of the nontrivial
    combinations of `{Linux, macOS, Windows} versus {rpm/tar.gz, dmg, exe}` with the
    search engine of your choice. In the end, I have the macOS JDK in some folder,
    which I will represent as `${jdk-9-mac-os}`.
  id: totrans-1287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 结果证明，最难的部分是在未为其打包的操作系统上解包 JDK。在这种情况下，我必须进入 Oracle 为 macOS 分发的 `*.dmg` 文件——这里不会详细介绍，但您可以使用您选择的搜索引擎找到关于
    `{Linux, macOS, Windows} 与 {rpm/tar.gz, dmg, exe}` 的每个非平凡组合的建议。最后，我在某个文件夹中有 macOS
    JDK，我将用 `${jdk-9-mac-os}` 来表示它。
- en: 'Then all I have to do is the same thing as in section 14.2.1, except for replacing
    my machine’s JDK 9 folder (`${jdk-9}`) with the one containing the macOS JDK (`${jdk-9-mac-os}`).
    This means I’m using the `jlink` executable from my Linux JDK with the `jmods`
    directory in the macOS JDK:'
  id: totrans-1288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然后我必须做的与14.2.1节中的相同，只是用包含 macOS JDK 的文件夹（`${jdk-9-mac-os}`）替换我的机器上的 JDK 9 文件夹（`${jdk-9}`）。这意味着我正在使用
    Linux JDK 的 `jlink` 可执行文件，以及 macOS JDK 中的 `jmods` 目录：
- en: '`$ jlink --module-path ${jdk-9-mac-os}/jmods:mods --add-modules monitor, monitor.observer.alpha,monitor.observer.beta
    --output jdk-monitor --launcher run-monitor=monitor`'
  id: totrans-1289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jlink --module-path ${jdk-9-mac-os}/jmods:mods --add-modules monitor, monitor.observer.alpha,monitor.observer.beta
    --output jdk-monitor --launcher run-monitor=monitor`'
- en: Taking this to my boss should work. (But if it doesn’t, I can’t even claim that
    it works on my machine!)
  id: totrans-1290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 带着这个去见我的老板应该没问题。（但如果不行，我甚至不能声称它在我的机器上能工作！）
- en: 14.4 Using jlink plugins to optimize images
  id: totrans-1291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 14.4 使用 jlink 插件优化镜像
- en: '“Make it work, make it right, make it fast,” said Kent Beck, creator of extreme
    programming and author of Test-Driven Development: By Example (O’Reilly, 2000).
    And so, with the nuts and bolts of creating runtime and application images (even
    across OSs) covered, we’ll turn to optimizations. These can considerably reduce
    image size and slightly increase runtime performance, particularly startup time.'
  id: totrans-1292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “先让它工作，再让它正确，最后让它快速，”Kent Beck，极限编程的创造者和《测试驱动开发：实例》（O’Reilly，2000）一书的作者说道。因此，在创建了运行时和应用镜像的螺母和螺栓（甚至跨操作系统）之后，我们将转向优化。这些优化可以显著减小镜像大小并略微提高运行时性能，尤其是启动时间。
- en: In `jlink`, optimizations are handled by plugins. Hence, it makes sense to first
    talk about that plugin architecture (section 14.4.1) before making images smaller
    (section 14.4.2) and faster (section 14.4.3).
  id: totrans-1293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 `jlink` 中，优化由插件处理。因此，在使镜像更小（14.4.2节）和更快（14.4.3节）之前，首先讨论该插件架构（14.4.1节）是有意义的。
- en: 14.4.1 PLUGINS FOR JLINK
  id: totrans-1294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 14.4.1 JLINK 插件
- en: A central aspect of `jlink` is its modular design. Beyond the essential steps
    of determining the correct modules and generating an image for them, `jlink` leaves
    further processing of the image’s content to its plugins. You can see the available
    plugins with `jlink --list-plugins`, see [https://docs.oracle.com/javase/9/tools/jlink.htm](https://docs.oracle.com/javase/9/tools/jlink.htm)
    for the officially supported ones, or check [table 14.1](part0029.html#filepos1779498)
    for a selection (we’ll look at each of them in sections 14.4.2 and 14.4.3).
  id: totrans-1295
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`jlink` 的一个核心方面是其模块化设计。除了确定正确的模块并为它们生成镜像的基本步骤之外，`jlink` 将镜像内容的进一步处理留给其插件。您可以使用
    `jlink --list-plugins` 查看可用的插件，查看[https://docs.oracle.com/javase/9/tools/jlink.htm](https://docs.oracle.com/javase/9/tools/jlink.htm)以获取官方支持的插件，或查看[表14.1](part0029.html#filepos1779498)以获取选择（我们将在14.4.2和14.4.3节中查看每个插件）。'
- en: Table 14.1 An alphabetized table of some `jlink` plugins, indicating whether
    they primarily reduce image size or improve runtime performance
  id: totrans-1296
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表14.1 一些 `jlink` 插件的字母顺序表，指示它们主要减少镜像大小还是提高运行时性能
- en: '| Name   | Description   | Size   | Perf.   |'
  id: totrans-1297
  prefs: []
  type: TYPE_TB
  zh: '| 名称   | 描述   | 大小   | 性能   |'
- en: '| class-for-name   | Replaces `Class::forName` with static access   |    |
    ✔   |'
  id: totrans-1298
  prefs: []
  type: TYPE_TB
  zh: '| class-for-name   | 将 `Class::forName` 替换为静态访问   |    | ✔   |'
- en: '| compress   | Shares string literals, and compresses `lib/modules`   | ✔   |    |'
  id: totrans-1299
  prefs: []
  type: TYPE_TB
  zh: '| compress   | 共享字符串字面量，并压缩 `lib/modules`   | ✔   |    |'
- en: '| exclude-files   | Excludes files, for example native binaries   | ✔   |    |'
  id: totrans-1300
  prefs: []
  type: TYPE_TB
  zh: '| exclude-files   | 排除文件，例如本地二进制文件   | ✔   |    |'
- en: '| exclude-resources   | Excludes resources, for example from `META-INF` folders   |
    ✔   |    |'
  id: totrans-1301
  prefs: []
  type: TYPE_TB
  zh: '| exclude-resources   | 排除资源，例如来自 `META-INF` 文件夹   | ✔   |    |'
- en: '| generate-jli-classes   | Pregenerates method handles   |    | ✔   |'
  id: totrans-1302
  prefs: []
  type: TYPE_TB
  zh: '| generate-jli-classes   | 预生成方法句柄   |    | ✔   |'
- en: '| include-locales   | Strips all but the specified locales from `jdk.localedata`   |
    ✔   |    |'
  id: totrans-1303
  prefs: []
  type: TYPE_TB
  zh: '| include-locales   | 从 `jdk.localedata` 中移除除指定区域设置之外的所有区域设置   | ✔   |    |'
- en: '| order-resources   | Orders resources in `lib/modules`   |    | ✔   |'
  id: totrans-1304
  prefs: []
  type: TYPE_TB
  zh: '| order-resources   | 在`lib/modules`中排序资源   |    | ✔   |'
- en: '| strip-debug   | Removes debug symbols from image bytecode   | ✔   |    |'
  id: totrans-1305
  prefs: []
  type: TYPE_TB
  zh: '| strip-debug   | 从图像字节码中删除调试符号   | ✔   |    |'
- en: '| system-modules   | Prepares the system module graph for quick access   |    |
    ✔   |'
  id: totrans-1306
  prefs: []
  type: TYPE_TB
  zh: '| system-modules   | 准备系统模块图以快速访问   |    | ✔   |'
- en: NOTE The documentation as well as `jlink` itself also lists the vm plugin, which
    lets you pick one of several HotSpot virtual machines (client, server, or minimal)
    that you want to include in the image. This a theoretical possibility, though,
    because 64-bit JDKs only ship with the server VM. For most situations, that leaves
    you with a choice of one.
  id: totrans-1307
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：文档以及`jlink`本身还列出了vm插件，它允许你选择你想要包含在镜像中的几个HotSpot虚拟机（客户端、服务器或最小）之一。这是一个理论上的可能性，因为64位JDK只附带服务器VM。对于大多数情况，这让你只剩下一个选择。
- en: DEVELOPING PLUGINS FOR JLINK
  id: totrans-1308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 开发JLINK插件
- en: At the time of book printing, only the supported plugins are available, but
    that may change in the future when more experimental features are added. The efforts
    of optimizing images during their creation are still pretty young, and a lot of
    work is being done here. As a consequence, the plugin API may change in the future
    and isn’t standardized or exported in Java 9+.
  id: totrans-1309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本书印刷时，只有支持的插件可用，但将来可能会发生变化，因为将添加更多实验性功能。在创建图像时优化图像的努力仍然相当年轻，这里正在进行大量工作。因此，插件API在未来可能会发生变化，并且没有在Java
    9+中标准化或导出。
- en: That makes developing plugins for `jlink` quite intricate^([1](part0029.html#filepos1794406))
    and means you’ll have to wait some time before the community really starts contributing
    plugins. What could those do? First of all, writing `jlink` plugins is a little
    like writing agents or build-tool plugins—not something that’s done during typical
    application development. It’s a specialized task to support specialized libraries,
    frameworks, and tools.
  id: totrans-1310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这使得为`jlink`开发插件相当复杂^([1](part0029.html#filepos1794406))，意味着你将不得不等待一段时间，社区才开始真正贡献插件。这些插件能做什么呢？首先，编写`jlink`插件有点像编写代理或构建工具插件——这不是在典型应用程序开发期间完成的事情。这是一个专门的任务，用于支持专门的库、框架和工具。
- en: ^([1](part0029.html#filepos1793775)) See Gunnar Morling’s blog post “Exploring
    the jlink Plug-in API in Java 9” ([http://mng.bz/xJ6B](http://mng.bz/xJ6B)) if
    you’re interested in a walk-through.
  id: totrans-1311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([1](part0029.html#filepos1793775)) 如果你对Java 9中探索jlink插件API的教程感兴趣，请参阅Gunnar
    Morling的博客文章“Exploring the jlink Plug-in API in Java 9” ([http://mng.bz/xJ6B](http://mng.bz/xJ6B))。
- en: But let’s get back to the question of what community-provided plugins could
    do. One use case comes from profilers, which currently use agents to inject performance-tracking
    code into running applications. With a `jlink` plugin, you could do this at link
    time instead of paying the instrumentation cost while executing your app. If a
    quick launch matters, that might be a sensible move.
  id: totrans-1312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但让我们回到社区提供的插件能做什么的问题。一个用例来自性能分析器，它们目前使用代理将性能跟踪代码注入正在运行的应用程序。使用`jlink`插件，你可以在链接时而不是在执行应用程序时支付仪器成本来完成这项工作。如果快速启动很重要，这可能是一个明智的选择。
- en: Another use case is enhancing the bytecode of Java Persistence API (JPA) entities.
    Hibernate, for example, already does that with an agent to track which entities
    were mutated (so-called dirty checking) without having to check every field. Doing
    it at link time instead of at launch time makes sense, which is why Hibernate
    already offers plugins for build tools and IDEs that do that during their build
    process.
  id: totrans-1313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个用例是增强Java持久化API（JPA）实体的字节码。例如，Hibernate已经通过代理来跟踪哪些实体被修改（所谓的脏检查），而不必检查每个字段。在链接时而不是在启动时进行这项工作是有意义的，这就是为什么Hibernate已经为构建工具和IDE提供了插件，这些插件在它们的构建过程中执行这项工作。
- en: As a final example, a really nice, potential `jlink` plugin would be one that
    indexes annotations at link time and makes that index available at run time. That
    could considerably reduce startup time for apps scanning the module path for annotated
    beans and entities. In fact, the plugin tutorial I gave in a footnote does exactly
    that.
  id: totrans-1314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为最后的例子，一个非常好的、潜在的`jlink`插件将是一个在链接时索引注解并在运行时提供该索引的插件。这可以显著减少扫描注解的bean和实体的模块路径的应用程序的启动时间。实际上，我在脚注中给出的插件教程正是这样做的。
- en: USING JLINK PLUGINS
  id: totrans-1315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用JLINK插件
- en: 'Definition: Plugin --${name} command-line option'
  id: totrans-1316
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：插件 --${name} 命令行选项
- en: 'With the theory out of the way, let’s use some of these plugins. But how? It’s
    pretty simple: `jlink`automatically creates a command-line option`--${name}` based
    on each plugin’s name. How further parameters are passed depends on the plugin
    and is described in `jlink --list-plugins`.'
  id: totrans-1317
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 理论部分已经讲完，让我们使用一些这些插件。但如何使用呢？其实很简单：`jlink`会根据每个插件的名字自动创建一个命令行选项`--${name}`。如何传递进一步参数取决于插件，并在`jlink
    --list-plugins`中描述。
- en: 'Stripping debug symbols is a good way to reduce image size. To do so, create
    the image with `--strip-debug`:'
  id: totrans-1318
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 移除调试符号是减小镜像大小的有效方法。要这样做，使用`--strip-debug`创建镜像：
- en: '`$ jlink --module-path ${jdk-9}/jmods --add-modules java.base --strip-debug
    --output jdk-base-stripped`'
  id: totrans-1319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jlink --module-path ${jdk-9}/jmods --add-modules java.base --strip-debug
    --output jdk-base-stripped`'
- en: 'There you go: `lib/modules` just went from 23 MB for just the base module to
    18 MB (on Linux).'
  id: totrans-1320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 看这里：`lib/modules`的大小从仅基础模块的23 MB减少到了18 MB（在Linux上）。
- en: 'Ordering the contents of `lib/modules` by putting more important files first
    can reduce launch time (although I doubt the effect will be noticeable):'
  id: totrans-1321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过将更重要的文件放在前面来排序`lib/modules`的内容可以减少启动时间（尽管我怀疑效果是否明显）：
- en: '`$ jlink --module-path ${jdk-9}/jmods --add-modules java.base --order-resources=**/module-info.class,/java.base/java/lang/**
    --output jdk-base-ordered`'
  id: totrans-1322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jlink --module-path ${jdk-9}/jmods --add-modules java.base --order-resources=**/module-info.class,/java.base/java/lang/**
    --output jdk-base-ordered`'
- en: This way, module descriptors come first, followed by classes from the `java.lang`
    package.
  id: totrans-1323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这样，模块描述符首先出现，然后是`java.lang`包中的类。
- en: Now that you know how to use plugins, it’s time to test-drive a few. We’ll do
    that in two sections, the first one focusing on size reductions (section 14.4.2)
    and the second on performance improvements (section 14.4.3). Because this is an
    evolving feature and also a rather specialized one, I won’t go into full detail—the
    official `jlink` documentation and `jlink --list-plugins`, although sparse with
    words, show much more precisely how to use them.
  id: totrans-1324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何使用插件，是时候测试几个插件了。我们将分为两个部分进行，第一部分关注大小缩减（第14.4.2节）和第二部分关注性能提升（第14.4.3节）。因为这个特性是不断发展的，并且相对较为专业，所以我不将详细说明——官方的`jlink`文档和`jlink
    --list-plugins`，尽管文字不多，但能更精确地展示如何使用它们。
- en: 14.4.2 REDUCING IMAGE SIZE
  id: totrans-1325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 14.4.2 减小镜像大小
- en: 'Let’s go through the size-reducing plugins one by one and measure how far they
    get us. I would have liked to test them on an application image, but ServiceMonitor
    only has about a dozen classes, so that’s pointless; and I couldn’t find a real
    application that’s freely available and fully modularized, including its dependencies
    (no automatic modules in images, remember?). Instead, I’ll measure the effects
    on three different runtime images (unmodified size in parentheses):'
  id: totrans-1326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们逐一查看这些大小缩减插件，并测量它们能带我们走多远。我本想在一个应用程序镜像上测试它们，但ServiceMonitor只有大约十几个类，所以这样做没有意义；而且我找不到一个真正免费且完全模块化的应用程序，包括其依赖项（记住，镜像中没有自动模块）。相反，我将测量对三个不同运行时镜像的影响（括号内为未修改的大小）：
- en: base —Just java.base (45 MB)
  id: totrans-1327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: base —仅java.base（45 MB）
- en: services —java.base plus all service providers (150 MB)
  id: totrans-1328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: services —java.base加上所有服务提供者（150 MB）
- en: java —All java.* and javafx.* modules, but without service providers (221 MB)
  id: totrans-1329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java —所有java.*和javafx.*模块，但不包括服务提供者（221 MB）
- en: It’s interesting that the larger size of java compared to services doesn’t come
    from the amount of bytecode (`lib/modules` is a little smaller in java than in
    services), but from the native libraries, particularly from the WebKit code bundled
    for JavaFX’s `WebView`. This will help you understand the plugins’ behavior when
    working to reduce image size. (By the way, I’m doing this on Linux, but proportions
    should be similar on other OSs.)
  id: totrans-1330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有趣的是，与服务相比，Java的大小更大，并不是由于字节码的数量（在Java中，`lib/modules`比服务小一点），而是由于原生库，尤其是为JavaFX的`WebView`捆绑的WebKit代码。这将帮助你理解插件在减小镜像大小时的行为。（顺便说一句，我在Linux上做这个，但比例在其他操作系统上应该相似。）
- en: COMPRESSING THE IMAGE
  id: totrans-1331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 压缩镜像
- en: 'Definition: compress plugin'
  id: totrans-1332
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：压缩插件
- en: 'The compress plugin aims to reduce the size of `lib/modules`. It’s controlled
    by the `--compress=${value}` option, which has three possible values:'
  id: totrans-1333
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 压缩插件旨在减小`lib/modules`的大小。它由`--compress=${value}`选项控制，该选项有三个可能的值：
- en: 0—No compression (default)
  id: totrans-1334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0—无压缩（默认）
- en: 1—Deduplicate and share string literals (meaning the `"text"` in `String s =
    "text";`)
  id: totrans-1335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1—去重并共享字符串字面量（意味着`String s = "text";`中的`"text"`）
- en: 2—Zip-compress `lib/modules`
  id: totrans-1336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2—压缩`lib/modules`为Zip格式
- en: An optional pattern list can be included with `--compress=${value}:filter=${pattern-list}`,
    in which case only files that match the patterns are compressed.
  id: totrans-1337
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可以通过`--compress=${value}:filter=${pattern-list}`包括一个可选的模式列表，在这种情况下，只有匹配模式的文件才会被压缩。
- en: 'This command creates a compressed runtime image with just the base module:'
  id: totrans-1338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此命令创建了一个仅包含基础模块的压缩运行时镜像：
- en: '`$ jlink --module-path ${jdk-9}/jmods --add-modules java.base --output jdk-base
    --compress=2`'
  id: totrans-1339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jlink --module-path ${jdk-9}/jmods --add-modules java.base --output jdk-base
    --compress=2`'
- en: 'You obviously don’t need to try `0`. For `1` and `2`, I got the following results:'
  id: totrans-1340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 显然，你不需要尝试`0`。对于`1`和`2`，我得到了以下结果：
- en: base —45 MB ⇝ 39 MB (`1`) ⇝ 33 MB (`2`)
  id: totrans-1341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: base —45 MB ⇝ 39 MB (`1`) ⇝ 33 MB (`2`)
- en: services —150 MB ⇝ 119 MB (`1`) ⇝ 91 MB (`2`)
  id: totrans-1342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: services —150 MB ⇝ 119 MB (`1`) ⇝ 91 MB (`2`)
- en: java —221 MB ⇝ 189 MB (`1`) ⇝ 164 MB (`2`)
  id: totrans-1343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java —221 MB ⇝ 189 MB (`1`) ⇝ 164 MB (`2`)
- en: 'You can see that the compression rate isn’t the same across all images. The
    services image size could be brought down by almost 40%, but the larger java image
    only by 25%. That’s because the compress plugin only works on `lib/modules`, but
    as we discussed, those have almost the same size in both images. Accordingly,
    the absolute size reduction is similar: about 60 MB for both images, which is
    more than 50% of the initial size of `lib/modules`.'
  id: totrans-1344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以看到压缩率并不是在所有镜像中都是相同的。服务镜像的大小可以降低近40%，但较大的java镜像只能降低25%。这是因为压缩插件只作用于`lib/modules`，但正如我们讨论的那样，这两个镜像中的大小几乎相同。因此，绝对大小减少也相似：两个镜像都是大约60
    MB，这超过了`lib/modules`初始大小的50%。
- en: NOTE Zip-compressing with `--compress=2` will increase startup time—generally
    speaking, more, the larger the image is. Make sure to measure it if that’s important
    to you.
  id: totrans-1345
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：使用`--compress=2`进行Zip压缩会增加启动时间——一般来说，镜像越大，增加的越多。如果你认为这很重要，请确保对其进行测量。
- en: EXCLUDING FILES AND RESOURCES
  id: totrans-1346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 排除文件和资源
- en: 'Definition: exclude-files and exclude-resources plugins'
  id: totrans-1347
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：exclude-files和exclude-resources插件
- en: The plugins exclude-files and exclude-resources allow the exclusion of files
    from the final image. The corresponding options `--exclude-files=${pattern-list}`
    and `--exclude-resources=${pattern-list}` accept a list of patterns against which
    files that are to be excluded are matched.
  id: totrans-1348
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 插件`exclude-files`和`exclude-resources`允许从最终镜像中排除文件。相应的选项`--exclude-files=${pattern-list}`和`--exclude-resources=${pattern-list}`接受一个模式列表，用于匹配要排除的文件。
- en: 'As I pointed out when comparing the initial sizes of the services and base
    images, it’s mainly the native binary for the JavaFX `WebView` that makes java
    larger. On my machine, that’s the 73 MB file `lib/libjfxwebkit.so`. Here’s how
    to exclude it with `--exclude-files`:'
  id: totrans-1349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我比较服务和基础镜像的初始大小时，指出的是，主要是JavaFX `WebView`的本地二进制文件使得java镜像变大。在我的机器上，这是73 MB的文件`lib/libjfxwebkit.so`。以下是使用`--exclude-files`排除它的方法：
- en: '`$ jlink --module-path ${jdk-9}/jmods --add-modules java.base --output jdk-base
    --exclude-files=**/libjfxwebkit.so`'
  id: totrans-1350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jlink --module-path ${jdk-9}/jmods --add-modules java.base --output jdk-base
    --exclude-files=**/libjfxwebkit.so`'
- en: 'The resulting image is 73 MB smaller. Two caveats:'
  id: totrans-1351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 结果镜像小了73 MB。有两个注意事项：
- en: This has the same effect as manually deleting the file from the image.
  id: totrans-1352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这与手动从镜像中删除文件的效果相同。
- en: This makes the javafx.scene.web module, which basically contains only the `WebView`,
    borderline useless, so it’s probably better to just not include that module.
  id: totrans-1353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得基本上只包含`WebView`的javafx.scene.web模块变得几乎无用，所以可能最好根本不包含该模块。
- en: Beyond experimenting and learning, it’s bad practice to exclude content that
    comes with platform modules. Be sure to thoroughly research any decision to do
    so, because that may impact the JVM’s stability.
  id: totrans-1354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了实验和学习之外，排除平台模块附带的内容是不良的做法。确保彻底研究任何此类决定的后果，因为这可能会影响JVM的稳定性。
- en: 'A much better use of these plugins is to exclude files that your application
    or dependency JARs contain that you don’t need in your application image. These
    could be documentation, undesired source files, native binaries for OSs you don’t
    care about, configurations, or any of the other myriad things ingenious developers
    put into their archives. It’s also pointless to compare size reductions: you’ll
    save the space the excluded files take up.'
  id: totrans-1355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些插件的一个更好的用途是排除你的应用程序或依赖JAR中包含而你不需要在应用程序镜像中的文件。这些可能包括文档、不想要的源文件、对你不关心的操作系统的本地二进制文件、配置文件，或者任何其他无数聪明的开发者放入他们存档中的东西。比较大小减少也是没有意义的：你将节省被排除文件所占用的空间。
- en: EXCLUDING UNNEEDED LOCALES
  id: totrans-1356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 排除不必要的区域
- en: Locales are something from the platform modules that it does make sense to remove.
    As you discovered in section 14.1.3, the base module can only work with the English
    locales, whereas the jdk.localedata module contains information for all the other
    locales that Java supports. Unfortunately, these others, taken together, are about
    16 MB. That’s a little excessive if you need only one or even just a few non-English
    locales.
  id: totrans-1357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 区域设置是从平台模块中来的，确实有移除的必要。正如你在第14.1.3节中发现的那样，基础模块只能与英语区域设置一起工作，而jdk.localedata模块包含Java支持的所有其他区域设置的信息。不幸的是，这些其他区域设置加在一起大约有16
    MB。如果你只需要一个或甚至只有几个非英语区域设置，这有点过于奢侈。
- en: 'Definition: include-locales plugin'
  id: totrans-1358
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定义：include-locales插件
- en: Here’s where the include-locales plugin comes into play. Used as `--include-locales=${langs}`,
    where `${langs}` is a comma-separated list of BCP 47 language tags (which look
    like `en-US`, `zh-Hans`, and `fi-FI`), the resulting image will only contain those
    languages.
  id: totrans-1359
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正是include-locales插件在这里发挥作用。它用作`--include-locales=${langs}`，其中`${langs}`是一个由逗号分隔的BCP
    47语言标签列表（例如`en-US`、`zh-Hans`和`fi-FI`），生成的镜像将只包含这些语言。
- en: This only works if the jdk.localedata module makes it into the image, so it
    doesn’t so much include additional locales beyond those the base module contains
    as it excludes all other locales from jdk.localedata.
  id: totrans-1360
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这只会在jdk.localedata模块被包含在镜像中时才有效，所以它不仅仅包括除了基础模块包含的额外区域设置，更多的是排除了jdk.localedata中的所有其他区域设置。
- en: '[Listing 14.4](part0029.html#filepos1750171) created an application image for
    ServiceMonitor that includes all of jdk.localedata because the app uses the Finnish
    format for its output. That drove up the image size by 16 MB, which you now know
    how to push back down. [Listing 14.7](part0029.html#filepos1816928) uses `--include-locales=fi-FI`
    to achieve that. The resulting image is marginally larger than the one without
    jdk.localedata (168 KB, to be precise). Success!'
  id: totrans-1361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[列表14.4](part0029.html#filepos1750171)为ServiceMonitor创建了一个包含所有jdk.localedata的应用程序镜像，因为该应用程序使用芬兰格式进行输出。这导致镜像大小增加了16
    MB，你现在知道如何将其推回。 [列表14.7](part0029.html#filepos1816928)使用`--include-locales=fi-FI`来实现这一点。生成的镜像略大于没有jdk.localedata的镜像（精确到168
    KB）。成功！'
- en: Listing 14.7 Creating the ServiceMonitor application image with Finnish locale
    data
  id: totrans-1362
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表14.7 创建包含芬兰区域数据的ServiceMonitor应用程序镜像
- en: '`$ jlink --module-path ${jdk-9}/jmods:mods --add-modules monitor, monitor.observer.alpha,monitor.observer.beta,`
    `jdk.localedata` [`①`](part0029.html#filepos1817755) `--output jdk-monitor` `--include-locales=fi-FI`
    [`②`](part0029.html#filepos1818220)'
  id: totrans-1363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jlink --module-path ${jdk-9}/jmods:mods --add-modules monitor, monitor.observer.alpha,monitor.observer.beta,`
    `jdk.localedata` [`①`](part0029.html#filepos1817755) `--output jdk-monitor` `--include-locales=fi-FI`
    [`②`](part0029.html#filepos1818220)'
- en: ①
  id: totrans-1364
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: The platform module for locales needs to be added to the image—either explicitly
    (as it is here) or implicitly (by being required or with --bind-services).
  id: totrans-1365
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 区域设置的平台模块需要添加到镜像中——要么明确地（如这里所示），要么隐式地（通过需要或使用--bind-services）。
- en: ②
  id: totrans-1366
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: All locales except fi-FI (Finnish) are stripped out of jdk.localedata.
  id: totrans-1367
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了fi-FI（芬兰语）之外的所有区域设置都被从jdk.localedata中移除。
- en: How much you can reduce image size by excluding locales depends on how many
    locales you need. If you deliver an internationalized application to a global
    audience, you won’t be able to save much, but my guess is this isn’t the common
    case. If your app supports only a handful or even a dozen languages, excluding
    the others will save you almost all of those 16 MB. Whether that’s worth the effort
    is up to you.
  id: totrans-1368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通过排除区域设置可以减少多少镜像大小取决于你需要多少区域设置。如果你向全球受众提供国际化应用程序，你将无法节省太多，但我的猜测这并不是常见情况。如果你的应用程序只支持少数几种甚至十几种语言，排除其他语言将为你节省几乎所有那16
    MB。是否值得付出努力取决于你。
- en: STRIPPING DEBUG INFORMATION
  id: totrans-1369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 移除调试信息
- en: When you’re debugging Java code in your IDE, you’ll usually see nicely formatted,
    named, and even commented source code. That’s because the IDE retrieves the actual
    sources that belong to that code, ties them to the currently executed bytecode,
    and conveniently displays them. That’s the best-case scenario.
  id: totrans-1370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你在IDE中调试Java代码时，你通常会看到格式良好、命名清晰，甚至带有注释的源代码。这是因为IDE检索了属于该代码的实际源代码，将其与当前执行的字节码关联起来，并方便地显示它们。这就是最佳情况。
- en: If there are no sources, you may still end up with readable code if, in addition
    to field and method parameter names (which are always present in bytecode), you
    see the proper names of variables (which aren’t necessarily present). That happens
    when the decompiled code contains debug symbols. This information makes debugging
    much easier but of course takes up space. And `jlink` allows you to strip out
    the symbols.
  id: totrans-1371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果没有源代码，你仍然可能看到可读的代码，如果除了字段和方法参数名称（这些名称始终存在于字节码中）之外，你还看到了变量的正确名称（这些名称不一定存在）。这发生在反编译代码包含调试符号时。这些信息使调试变得容易得多，但当然会占用空间。而`jlink`允许你移除这些符号。
- en: 'Definition: strip-debug plugin'
  id: totrans-1372
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**定义** strip-debug插件'
- en: If the `jlink` plugin strip-debug is activated with `--strip-debug`, it will
    remove all debug symbols from the image’s bytecode, thus reducing the size of
    the `lib/modules` file. This option has no further parameters.
  id: totrans-1373
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果`jlink`插件strip-debug通过`--strip-debug`激活，它将从图像的字节码中移除所有调试符号，从而减小`lib/modules`文件的大小。此选项没有其他参数。
- en: 'I used `--strip-debug` in section 14.4.1, so I’ll spare you the repetition.
    Let’s see how it reduces image sizes:'
  id: totrans-1374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我在第14.4.1节中使用了`--strip-debug`，所以我就不再重复了。让我们看看它是如何减少图像大小的：
- en: base —45 MB ⇝ 40 MB
  id: totrans-1375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础 —45 MB ⇝ 40 MB
- en: services —150 MB ⇝ 130 MB
  id: totrans-1376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务 —150 MB ⇝ 130 MB
- en: java —221 MB ⇝ 200 MB
  id: totrans-1377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java —221 MB ⇝ 200 MB
- en: That’s about 10% of the total image size, but remember that this only touches
    on `lib/modules`, which is reduced by about 20%.
  id: totrans-1378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这大约是总图像大小的10%，但请记住，这仅影响到`lib/modules`，它减少了大约20%。
- en: 'ESSENTIAL INFO A word of warning: debugging code without sources and without
    debug symbols is a hellish task. If you occasionally use remote debugging to connect
    to a running application and analyze what’s going wrong, you won’t be happy if
    you gave away those debug symbols and the few megabytes you saved aren’t really
    important to you. Consider `--strip-debug` carefully!'
  id: totrans-1379
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 一个警告：在没有源代码和调试符号的情况下调试代码是一项痛苦的任务。如果你偶尔使用远程调试连接到正在运行的应用程序并分析问题所在，如果你已经放弃了那些调试符号，而你节省的那几兆字节对你来说并不重要，你不会感到高兴。请仔细考虑`--strip-debug`选项！'
- en: PUTTING IT ALL TOGETHER
  id: totrans-1380
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: 'Although excluding files and resources is better left for application modules,
    the other options work well on pure runtime images. Let’s put them all together
    and try to create the smallest possible images for the three selections of modules.
    Here’s the command for just java.base:'
  id: totrans-1381
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然排除文件和资源最好留给应用程序模块，但其他选项在纯运行时图像上效果良好。让我们将它们全部整合起来，并尝试为模块的三种选择创建尽可能小的图像。以下是仅针对java.base的命令：
- en: '`$ jlink --module-path ${jdk-9}/jmods --add-modules java.base --output jdk-base
    --compress=2 --strip-debug`'
  id: totrans-1382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`$ jlink --module-path ${jdk-9}/jmods --add-modules java.base --output jdk-base
    --compress=2 --strip-debug`'
- en: 'And here are the results:'
  id: totrans-1383
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 下面是结果：
- en: base —45 MB ⇝ 31 MB
  id: totrans-1384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础 —45 MB ⇝ 31 MB
- en: services —150 MB ⇝ 75 MB (I also removed all locales except `fi-FI`)
  id: totrans-1385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务 —150 MB ⇝ 75 MB（我还移除了除`fi-FI`之外的所有区域设置）
- en: java —221 MB ⇝ 155 MB (or 82 MB if you cripple the JavaFX `WebKit`)
  id: totrans-1386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: java —221 MB ⇝ 155 MB（或者如果你削弱了JavaFX `WebKit`，则是82 MB）
- en: Not too bad, eh?
  id: totrans-1387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还不错，不是吗？
- en: 14.4.3 IMPROVING RUNTIME PERFORMANCE
  id: totrans-1388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 14.4.3 提高运行时性能
- en: As you’ve seen, there are quite a few ways to reduce an application’s or runtime
    image’s size. My guess is, though, that most developers are eagerly awaiting performance
    improvements, particularly after Spectre and Meltdown have robbed them of some
    of their CPU cycles.
  id: totrans-1389
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如你所见，有相当多的方法可以减小应用程序或运行时图像的大小。不过，我的猜测是，大多数开发者都在热切期待性能改进，尤其是在Spectre和Meltdown事件夺走了他们一些CPU周期之后。
- en: 'ESSENTIAL INFO Unfortunately, I don’t have much good news in this regard: performance
    optimizations with `jlink` are still in their early stages, and most of the existing
    or envisioned ones focus on improving startup time, not long-term runtime performance.'
  id: totrans-1390
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 很遗憾，关于这一点我没有太多好消息：使用`jlink`的性能优化还处于早期阶段，大多数现有的或预期的优化都集中在提高启动时间，而不是长期运行性能。'
- en: One existing plugin, which is turned on by default, is system-modules, which
    precomputes the system module graph and stores it for quick access. This way,
    the JVM doesn’t have to parse and process module declarations, verifying reliable
    configuration, on every launch.
  id: totrans-1391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个默认启用的现有插件是system-modules，它预先计算系统模块图并将其存储以供快速访问。这样，JVM就不需要在每次启动时解析和处理模块声明，验证可靠配置。
- en: Another plugin, class-for-name, replaces bytecode like `Class.forName("some.Type")`
    with `some.Type.class`, so the comparatively expensive, reflection-based search
    for a class by its name can be avoided. We briefly looked at order-resources,
    and there isn’t much to add.
  id: totrans-1392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个插件，`class-for-name`，将字节码如`Class.forName("some.Type")`替换为`some.Type.class`，因此可以避免通过名称比较昂贵的基于反射的类搜索。我们简要地看了`order-resources`，但没有太多可以补充的。
- en: The only other performance-related plugin that’s currently supported is generate-jli-classes.
    If properly configured, it can move the initialization costs of lambda expressions
    from run time to link time, but learning how to do that requires a good understanding
    of method handles, so I won’t touch on it here.
  id: totrans-1393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 目前唯一支持的其他与性能相关的插件是`generate-jli-classes`。如果配置得当，它可以将lambda表达式的初始化成本从运行时移动到链接时，但学习如何做到这一点需要很好地理解方法句柄，所以这里不会涉及。
- en: And that’s all there is regarding performance improvements. I get it if you’re
    disappointed about the lack of big gains in this area, but let me point out that
    the JVM is already quite optimized. All the low-hanging fruits (and many higher
    up the tree) have already been picked, and it will take some ingenuity, time,
    and clever engineering to reach the others. The `jlink` tool is still young, and
    I’m confident that the JDK development team and the community will make good use
    of it in due time.
  id: totrans-1394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于性能改进的内容就这些了。我理解如果你对这个领域的大幅提升感到失望，但让我指出，JVM已经相当优化了。所有低垂的果实（以及树上的许多其他果实）都已经摘取，要达到其他果实需要一些独创性、时间和巧妙的设计。`jlink`工具还比较年轻，我坚信JDK开发团队和社区会在适当的时候充分利用它。
- en: Application class-data sharing in Java 10
  id: totrans-1395
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java 10中的应用类数据共享
- en: 'Not directly connected to `jlink` is an optimization introduced by Java 10:
    application class-data sharing.^([2](part0029.html#filepos1829749)) Experiments
    indicate that it can lead to application launches that are between 10% and 50%
    quicker. What’s interesting is that you can apply this technique within an application
    image, creating an even more-optimized deployment unit.'
  id: totrans-1396
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与`jlink`没有直接关联的是Java 10引入的一种优化：应用类数据共享。[2](part0029.html#filepos1829749) 实验表明，它可以导致应用启动速度提高10%到50%。有趣的是，你可以在应用程序镜像内应用这项技术，创建一个更加优化的部署单元。
- en: ^([2](part0029.html#filepos1829209)) To learn more, see my blog post “Improve
    Launch Times on Java 10 with Application Class-Data Sharing,” [https://blog.codefx.org/java/application-class-data-sharing](https://blog.codefx.org/java/application-class-data-sharing).
  id: totrans-1397
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[2](part0029.html#filepos1829209) 要了解更多信息，请参阅我的博客文章“使用应用类数据共享提高Java 10的启动时间”，[https://blog.codefx.org/java/application-class-data-sharing](https://blog.codefx.org/java/application-class-data-sharing)。'
- en: 14.5 Options for jlink
  id: totrans-1398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 14.5 jlink的选项
- en: For your convenience, [table 14.2](part0029.html#filepos1831426) lists all the
    command-line options for `jlink` that this book discusses. More are available
    in the official documentation at [https://docs.oracle.com/javase/9/tools/jlink.htm](https://docs.oracle.com/javase/9/tools/jlink.htm)
    or with `jlink --help` and `jlink --list-plugins`.
  id: totrans-1399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了方便起见，[表14.2](part0029.html#filepos1831426) 列出了本书讨论的所有`jlink`命令行选项。更多选项可以在官方文档[https://docs.oracle.com/javase/9/tools/jlink.htm](https://docs.oracle.com/javase/9/tools/jlink.htm)中找到，或者使用`jlink
    --help`和`jlink --list-plugins`。
- en: Table 14.2 An alphabetized table of selected `jlink` options, including plugins.
    The descriptions are based on the documentation, and the references point to the
    sections in this book that explain in detail how to use the options.
  id: totrans-1400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表14.2 一个按字母顺序排列的`jlink`选项表，包括插件。描述基于文档，参考文献指向本书中解释如何使用这些选项的章节。
- en: '| Option   | Description   | Ref.   |'
  id: totrans-1401
  prefs: []
  type: TYPE_TB
  zh: '| 选项   | 描述   | 参考文献号   |'
- en: '| `--add-modules`   | Defines root modules for inclusion in the image   | 14.1.1   |'
  id: totrans-1402
  prefs: []
  type: TYPE_TB
  zh: '| `--add-modules`   | 定义要包含在镜像中的根模块   | 14.1.1   |'
- en: '| `--bind-services`   | Includes all providers of services that resolved modules
    use   | 14.1.3   |'
  id: totrans-1403
  prefs: []
  type: TYPE_TB
  zh: '| `--bind-services`   | 包括所有已解析模块使用的服务提供者   | 14.1.3   |'
- en: '| `--class-for-name`   | Replaces `Class::forName` with static access (plugin)   |
    14.4.3   |'
  id: totrans-1404
  prefs: []
  type: TYPE_TB
  zh: '| `--class-for-name`   | 将`Class::forName`替换为静态访问（插件）   | 14.4.3   |'
- en: '| `--compress, -c`   | Shares string literals, and compresses `lib/modules`
    (plugin)   | 14.4.2   |'
  id: totrans-1405
  prefs: []
  type: TYPE_TB
  zh: '| `--compress, -c`   | 共享字符串字面量，并压缩`lib/modules`（插件）   | 14.4.2   |'
- en: '| `--exclude-files, --exclude-resources`   | Excludes the specified files and
    resources (plugin)   | 14.4.2   |'
  id: totrans-1406
  prefs: []
  type: TYPE_TB
  zh: '| `--exclude-files, --exclude-resources`   | 排除指定的文件和资源（插件）   | 14.4.2   |'
- en: '| `--generate-jli-classes`   | Pregenerates method handles (plugin)   | 14.4.3   |'
  id: totrans-1407
  prefs: []
  type: TYPE_TB
  zh: '| `--generate-jli-classes`   | 预生成方法句柄（插件）   | 14.4.3   |'
- en: '| `--include-locales`   | Strips all but the specified locales from jdk.localedata
    (plugin)   | 14.4.2   |'
  id: totrans-1408
  prefs: []
  type: TYPE_TB
  zh: '| `--include-locales`   | 从 jdk.localedata（插件）中删除除指定区域设置之外的所有区域设置   | 14.4.2   |'
- en: '| `--launcher`   | Generates a native launcher script for the application in
    `bin`   | 14.2.2   |'
  id: totrans-1409
  prefs: []
  type: TYPE_TB
  zh: '| `--launcher`   | 在 `bin` 中为应用程序生成原生启动器脚本   | 14.2.2   |'
- en: '| `--list-plugins`   | Lists available plugins   | 14.4.1   |'
  id: totrans-1410
  prefs: []
  type: TYPE_TB
  zh: '| `--list-plugins`   | 列出可用的插件   | 14.4.1   |'
- en: '| `--module-path, -p`   | Specifies where to find platform and application
    modules   | 14.1.1   |'
  id: totrans-1411
  prefs: []
  type: TYPE_TB
  zh: '| `--module-path, -p`   | 指定查找平台和应用模块的位置   | 14.1.1   |'
- en: '| `--order-resources`   | Orders resources in `lib/modules` (plugin)   | 14.4.1   |'
  id: totrans-1412
  prefs: []
  type: TYPE_TB
  zh: '| `--order-resources`   | 在 `lib/modules`（插件）中排序资源   | 14.4.1   |'
- en: '| `--output`   | Generates the image in the specified location   | 14.1.1   |'
  id: totrans-1413
  prefs: []
  type: TYPE_TB
  zh: '| `--output`   | 在指定位置生成镜像   | 14.1.1   |'
- en: '| `--strip-debug`   | Removes debug symbols from image bytecode (plugin)   |
    14.4.2   |'
  id: totrans-1414
  prefs: []
  type: TYPE_TB
  zh: '| `--strip-debug`   | 从镜像的字节码中删除调试符号（插件）   | 14.4.2   |'
- en: '| `--suggest-providers`   | Lists observable providers for the specified services   |
    14.1.3   |'
  id: totrans-1415
  prefs: []
  type: TYPE_TB
  zh: '| `--suggest-providers`   | 列出指定服务的可观察提供者   | 14.1.3   |'
- en: Summary
  id: totrans-1416
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: The command-line tool `jlink` creates runtime images from selected platform
    modules (use `jdeps` to determine which ones an application needs). To benefit
    from that, the application needs to run on Java 9+, but it doesn’t have to be
    modularized.
  id: totrans-1417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行工具 `jlink` 从选定的平台模块创建运行时镜像（使用 `jdeps` 确定应用程序需要哪些模块）。为了从中受益，应用程序需要运行在 Java
    9+ 上，但不需要模块化。
- en: Once the application and its dependencies have been fully modularized (without
    the use of automatic modules), `jlink` can create application images with it,
    including the app’s modules.
  id: totrans-1418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦应用程序及其依赖项已完全模块化（不使用自动模块），`jlink` 就可以使用它创建应用程序镜像，包括应用程序的模块。
- en: 'All calls to `jlink` need to specify the following:'
  id: totrans-1419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有对 `jlink` 的调用都需要指定以下内容：
- en: Where to find modules (including platform modules), with `--module-path`
  id: totrans-1420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找模块的位置（包括平台模块），使用 `--module-path`
- en: The root modules for resolution, with `--add-modules`
  id: totrans-1421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析的根模块，使用 `--add-modules`
- en: The output directory for the resulting image, with `--output`
  id: totrans-1422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果镜像的输出目录，使用 `--output`
- en: 'Be aware of how `jlink` resolves modules:'
  id: totrans-1423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意 `jlink` 如何解析模块：
- en: Services aren’t bound by default.
  id: totrans-1424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，服务不受限制。
- en: Optional dependencies with `requires static` aren’t resolved.
  id: totrans-1425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 `requires static` 的可选依赖项不会解析。
- en: Automatic modules aren’t allowed.
  id: totrans-1426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许自动模块。
- en: Make sure to add required service providers or optional dependencies individually
    with `--add-modules` or bind all providers with `--bind-services`.
  id: totrans-1427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保使用 `--add-modules` 或 `--bind-services` 单独添加所需的服务提供者或可选依赖项，或者绑定所有提供者。
- en: Watch out for platform services that you may implicitly depend on without realizing
    it. Some candidates are charsets (jdk.charsets), locales (jdk.localedata), the
    Zip file system (jdk.zipfs), and security providers (various modules).
  id: totrans-1428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意可能没有意识到就隐式依赖的平台服务。一些候选者包括字符集（jdk.charsets）、区域设置（jdk.localedata）、Zip 文件系统（jdk.zipfs）和安全提供者（各种模块）。
- en: The runtime image generated by `jlink`
  id: totrans-1429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 `jlink` 生成的运行时镜像
- en: Is bound to the OS for which the platform modules chosen with `--module-path`
    were built
  id: totrans-1430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与使用 `--module-path` 选择平台模块构建的操作系统绑定
- en: Has the same directory structure as the JDK and JRE
  id: totrans-1431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 JDK 和 JRE 具有相同的目录结构
- en: Fuses platform and application modules (collectively known as system modules)
    into `lib/modules`
  id: totrans-1432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将平台模块和应用程序模块（统称为系统模块）融合到 `lib/modules`
- en: Contains only the binaries (in `bin`) for which the required modules were included
  id: totrans-1433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅包含包含所需模块的二进制文件（在 `bin` 中）
- en: To launch an application image, use either `bin/java --module ${initial-module}`
    (no module path required, because system modules are automatically resolved) or
    the launcher created with `--launcher ${name}=${module}/${main-class}`.
  id: totrans-1434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要启动应用程序镜像，可以使用 `bin/java --module ${initial-module}`（不需要模块路径，因为系统模块会自动解析）或使用
    `--launcher ${name}=${module}/${main-class}` 创建的启动器。
- en: With application images, the module path can be used to add additional modules
    (particularly those providing services). Modules on the module path with the same
    name as system modules are ignored.
  id: totrans-1435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用应用程序镜像，可以使用模块路径添加额外的模块（尤其是提供服务的模块）。具有与系统模块相同名称的模块路径上的模块将被忽略。
- en: Carefully evaluate the security, performance, and stability implications of
    delivering application images when you aren’t able to readily replace them with
    newer versions.
  id: totrans-1436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您无法轻松用新版本替换它们时，仔细评估交付应用程序镜像的安全、性能和稳定性影响。
- en: Various `jlink` options, which activate plugins, offer ways to reduce image
    size (for example, `--compress`, `--exclude-files`, `--exclude-resource`, `--include-locales`,
    and `--strip-debug`) or improve performance (mostly startup time; `--class-for-name`,
    `--generate-jli-classes`, and `--order-resources`). More can be expected in the
    future; this area is still in its early phases.
  id: totrans-1437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种 `jlink` 选项，这些选项激活插件，提供减少图像大小（例如，`--compress`，`--exclude-files`，`--exclude-resource`，`--include-locales`
    和 `--strip-debug`）或提高性能（主要是启动时间；`--class-for-name`，`--generate-jli-classes` 和
    `--order-resources`）的方法。未来可能会有更多；这个领域仍处于早期阶段。
- en: The `jlink` plugin API isn’t yet standardized to ease its evolution in that
    early phase, which makes it more difficult to develop and use third-party plugins.
  id: totrans-1438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jlink` 插件 API 尚未标准化，以简化其在早期阶段的演变，这使得开发和使用第三方插件变得更加困难。'
- en: '15'
  id: totrans-1439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '15'
- en: Putting the pieces together
  id: totrans-1440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将各个部分组合在一起
- en: This chapter covers
  id: totrans-1441
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: A bells-and-whistles version of ServiceMonitor
  id: totrans-1442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ServiceMonitor 的铃声和哨声版本
- en: Whether to use modules
  id: totrans-1443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否使用模块
- en: What an ideal module might look like
  id: totrans-1444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个理想的模块可能的样子
- en: Keeping module declarations clean
  id: totrans-1445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持模块声明干净
- en: Comparing the module system to build tools, OSGi, and microservices
  id: totrans-1446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模块系统与构建工具、OSGi 和微服务进行比较
- en: Now that we’ve covered pretty much everything there is to know about the module
    system, it’s time to wrap things up. In this final chapter, I want to connect
    the dots and give a few pieces of advice for creating awesome modular applications.
  id: totrans-1447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了有关模块系统几乎所有的知识，是时候总结一下了。在本章的最后，我想将所有这些联系起来，并给出一些关于创建出色的模块化应用程序的建议。
- en: The first step is to show you an example of how the various features discussed
    throughout the book can come together by applying most of them to the ServiceMonitor
    application (section 15.1). Then I’ll take a deep dive into a number of more general
    concerns that will help you decide whether to even create modules, what to aim
    for when doing so, and how to carefully evolve your module declarations so they
    stay squeaky clean (section 15.2). I’ll close with a review of the technology
    landscape surrounding the module system (section 15.3) and my vision for Java’s
    modular ecosystem (section 15.4).
  id: totrans-1448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第一步是向您展示如何通过将本书中讨论的各个功能的大部分应用于 ServiceMonitor 应用程序（第 15.1 节）来展示这些功能如何结合在一起。然后，我将深入探讨一些更一般的问题，这些问题将帮助您决定是否创建模块，在创建模块时应追求什么，以及如何仔细地演进模块声明，使它们保持干净（第
    15.2 节）。我将通过回顾围绕模块系统的技术格局（第 15.3 节）以及我对 Java 模块生态系统的愿景（第 15.4 节）来结束。
- en: 15.1 Adding bells and whistles to ServiceMonitor
  id: totrans-1449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 15.1 向 ServiceMonitor 添加铃声和哨声
- en: Chapter 2 showed the anatomy of the ServiceMonitor application. In section 2.2,
    you created simple modules that only used plain `requires` and `exports` directives.
    Since then, we’ve not only discussed those in detail but also explored the module
    system’s more-advanced features. We’ve looked at each of them individually, but
    now I want to put them all together.
  id: totrans-1450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第 2 章展示了 ServiceMonitor 应用程序的结构。在第 2.2 节中，您创建了只使用简单的 `requires` 和 `exports`
    指令的模块。从那时起，我们不仅详细讨论了这些内容，还探索了模块系统的更高级功能。我们逐一研究了它们，但现在我想将它们全部结合起来。
- en: To enjoy the ServiceMonitor application in all its glory, check out the repository’s
    `features-combined` branch. The following listing contains the declarations for
    all the modules in ServiceMonitor.
  id: totrans-1451
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要欣赏 ServiceMonitor 应用程序的全部辉煌，请查看存储库的 `features-combined` 分支。以下列表包含 ServiceMonitor
    中所有模块的声明。
- en: Listing 15.1 ServiceMonitor, using advanced features presented throughout the
    book
  id: totrans-1452
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表 15.1 使用本书中介绍的先进功能的 ServiceMonitor
- en: '`module monitor.observer { exports monitor.observer;` `exports monitor.observer.utils`
    [`①`](part0030.html#filepos1861247) `to monitor.observer.alpha, monitor.observer.beta;
    }  module monitor.observer.alpha { requires monitor.observer;` `provides monitor.observer.ServiceObserverFactory`
    [`②`](part0030.html#filepos1861684) `with monitor.observer.alpha.AlphaServiceObserverFactory;
    }` `// [...]` [`③`](part0030.html#filepos1862141) `module monitor.statistics {`
    `requires transitive monitor.observer;` [`④`](part0030.html#filepos1862562)`requires
    static stats.fancy;` [`⑤`](part0030.html#filepos1863018) `exports monitor.statistics;
    }  module stats.fancy { exports stats.fancy; }  module monitor.persistence {`
    `requires transitive monitor.statistics;` [`④`](part0030.html#filepos1862562)`requires
    hibernate.jpa;` [`⑥`](part0030.html#filepos1863485) `exports monitor.persistence;`
    `opens monitor.persistence.entity;` [`⑦`](part0030.html#filepos1863953) `}  module
    monitor.rest {` `requires transitive monitor.statistics;` [`④`](part0030.html#filepos1862562)`requires
    spark.core;` [`⑥`](part0030.html#filepos1863485) `exports monitor.rest; }  module
    monitor { requires monitor.observer; requires monitor.statistics; requires monitor.persistence;
    requires monitor.rest;` `uses monitor.observer.ServiceObserverFactory;` [`②`](part0030.html#filepos1861684)
    `}`'
  id: totrans-1453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`module monitor.observer { exports monitor.observer;` `exports monitor.observer.utils`
    [`①`](part0030.html#filepos1861247) `to monitor.observer.alpha, monitor.observer.beta;
    }  module monitor.observer.alpha { requires monitor.observer;` `provides monitor.observer.ServiceObserverFactory`
    [`②`](part0030.html#filepos1861684) `with monitor.observer.alpha.AlphaServiceObserverFactory;
    }` `// [...]` [`③`](part0030.html#filepos1862141) `module monitor.statistics {`
    `requires transitive monitor.observer;` [`④`](part0030.html#filepos1862562)`requires
    static stats.fancy;` [`⑤`](part0030.html#filepos1863018) `exports monitor.statistics;
    }  module stats.fancy { exports stats.fancy; }  module monitor.persistence {`
    `requires transitive monitor.statistics;` [`④`](part0030.html#filepos1862562)`requires
    hibernate.jpa;` [`⑥`](part0030.html#filepos1863485) `exports monitor.persistence;`
    `opens monitor.persistence.entity;` [`⑦`](part0030.html#filepos1863953) `}  module
    monitor.rest {` `requires transitive monitor.statistics;` [`④`](part0030.html#filepos1862562)`requires
    spark.core;` [`⑥`](part0030.html#filepos1863485) `exports monitor.rest; }  module
    monitor { requires monitor.observer; requires monitor.statistics; requires monitor.persistence;
    requires monitor.rest;` `uses monitor.observer.ServiceObserverFactory;` [`②`](part0030.html#filepos1861684)
    `}`'
- en: ①
  id: totrans-1454
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ①
- en: monitor.observer.utils is geared toward observer implementations, so it’s only
    exported to (some of) them (see section 15.1.2).
  id: totrans-1455
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: monitor.observer.utils主要针对观察者实现，因此它仅导出给（一些）它们（参见第15.1.2节）。
- en: ②
  id: totrans-1456
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ②
- en: The consumer (monitor) and implementations (for example, monitor.observer.alpha)
    of the observer API are decoupled via services (see section 15.1.3).
  id: totrans-1457
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 观察者API的消费者（monitor）和实现（例如，monitor.observer.alpha）通过服务解耦（参见第15.1.3节）。
- en: ③
  id: totrans-1458
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ③
- en: monitor.observer.beta and monitor.observer.gamma aren’t shown here; they look
    just like monitor.observer.alpha.
  id: totrans-1459
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: monitor.observer.beta和monitor.observer.gamma在此处未显示；它们看起来就像monitor.observer.alpha。
- en: ④
  id: totrans-1460
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ④
- en: Some modules expose types from another module in their API and are unusable
    without that module, so they imply its readability (see section 15.1.1).
  id: totrans-1461
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一些模块在其API中公开了另一个模块的类型，并且没有该模块就无法使用，因此它们暗示了其可读性（参见第15.1.1节）。
- en: ⑤
  id: totrans-1462
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⑤
- en: stats.fancy isn’t present in each deployment, and monitor.statistics reflects
    that by marking its dependency on that module as optional (see section 15.1.1).
  id: totrans-1463
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: stats.fancy并非在每个部署中都存在，monitor.statistics通过将其对该模块的依赖标记为可选来反映这一点（参见第15.1.1节）。
- en: ⑥
  id: totrans-1464
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⑥
- en: Neither the Hibernate nor the Spark version that ServiceMonitor uses is modularized,
    so hibernate.jpa and spark.core are automatic modules (see section 15.1.5).
  id: totrans-1465
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ServiceMonitor使用的Hibernate和Spark版本都没有模块化，因此hibernate.jpa和spark.core是自动模块（参见第15.1.5节）。
- en: ⑦
  id: totrans-1466
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⑦
- en: monitor.persistence opens the package containing its persistence entities for
    reflection (see section 15.1.2).
  id: totrans-1467
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: monitor.persistence将其持久化实体包含的包打开以供反射（参见第15.1.2节）。
- en: If you compare this listing to [listing 2.2](part0015.html#filepos266357) or
    look at [figure 15.1](part0030.html#filepos1865219), you can see that the fundamental
    structure of ServiceMonitor has stayed pretty much the same. But looking closer,
    you can see a number of improvements. Let’s go over them one by one.
  id: totrans-1468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您将此列表与[列表2.2](part0015.html#filepos266357)进行比较或查看[图15.1](part0030.html#filepos1865219)，您会发现ServiceMonitor的基本结构基本保持不变。但仔细观察，您会发现许多改进。让我们逐一过目。
- en: '![](../images/00016.jpeg) ![](../images/00073.jpeg)'
  id: totrans-1469
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片1](../images/00016.jpeg) ![图片2](../images/00073.jpeg)'
- en: '[Figure 15.1](part0030.html#filepos1864526)a Comparison of module graphs for
    the ServiceMonitor application depending on feature use. The first variant only
    uses plain `exports` and `requires` directives (a), whereas the second makes full
    use of refined dependencies and exports as well as services (b). (The basic variant
    has been extended to include the same modules and packages as the advanced one.)'
  id: totrans-1470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图15.1](part0030.html#filepos1864526)根据功能使用情况比较ServiceMonitor应用的模块图。第一个变体仅使用普通的`exports`和`requires`指令（a），而第二个变体充分利用了精炼的依赖关系、导出以及服务（b）。（基本变体已扩展，包括与高级变体相同的模块和包。）'
- en: 15.1.1 DIVERSIFIED DEPENDENCIES
  id: totrans-1471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 15.1.1 多样化的依赖关系
- en: One change that’s easy to spot are the `requires transitive` and `requires optional`
    directives. Although plain `requires` directives are the right choice in most
    cases, a significant portion of dependencies are a little more complicated.
  id: totrans-1472
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 容易发现的一个变化是`requires transitive`和`requires optional`指令。尽管在大多数情况下，普通的`requires`指令是正确的选择，但相当一部分依赖关系要复杂一些。
- en: The most obvious case is optional dependencies, where a module uses types from
    another module and hence needs to be compiled against it, but the dependency may
    still be absent at run time. This is exactly the case for monitor.statistics and
    stats.fancy, so the dependency is established with a `requires static` directive.
  id: totrans-1473
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最明显的情况是可选依赖，其中某个模块使用来自另一个模块的类型，因此需要针对它进行编译，但依赖关系在运行时可能仍然不存在。这正是monitor.statistics和stats.fancy的情况，因此使用`requires
    static`指令建立了依赖关系。
- en: The module system will then enforce the presence of stats.fancy when compiling
    monitor.statistics (which makes sense, because otherwise compilation would fail)
    and will add a reads edge from monitor.statistics to stats.fancy if the latter
    made it into the module graph (which also makes sense, because otherwise monitor.statistics
    couldn’t access types from stats.fancy). But stats.fancy may not make it into
    the module graph, in which case monitor.statistics has to handle its absence.
  id: totrans-1474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块系统将在编译monitor.statistics时强制stats.fancy的存在（这是有意义的，因为否则编译会失败），如果后者进入了模块图（这也是有意义的，因为否则monitor.statistics无法访问stats.fancy的类型），则将从monitor.statistics添加一个读取边到stats.fancy。但stats.fancy可能不会进入模块图，在这种情况下，monitor.statistics必须处理其不存在的情况。
- en: Listing 15.2 `Checking` whether the optional dependency stats.fancy is present
  id: totrans-1475
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表15.2 `检查`可选依赖stats.fancy是否存在
- en: '`private static boolean checkFancyStats() { boolean isFancyAvailable = isModulePresent("stats.fancy");
    String message = "Module ''stats.fancy'' is" + (isFancyAvailable ? " " : " not
    ") + "available."; System.out.println(message); return isFancyAvailable; }  private
    static boolean isModulePresent(String moduleName) { return Statistician.class
    .getModule() .getLayer() .findModule(moduleName) .isPresent(); }`'
  id: totrans-1476
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`private static boolean checkFancyStats() { boolean isFancyAvailable = isModulePresent("stats.fancy");
    String message = "Module ''stats.fancy'' is" + (isFancyAvailable ? " " : " not
    ") + "available."; System.out.println(message); return isFancyAvailable; }  private
    static boolean isModulePresent(String moduleName) { return Statistician.class
    .getModule() .getLayer() .findModule(moduleName) .isPresent(); }`'
- en: Optional dependencies are discussed in detail in section 11.2.
  id: totrans-1477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可选依赖关系在11.2节中进行了详细讨论。
- en: 'The other case is a little less obvious than optional dependencies, but no
    less common—maybe even more so. The module monitor.rest, for example, has this
    method in its public API:'
  id: totrans-1478
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一种情况比可选依赖稍微不明显，但并不少见——甚至可能更常见。例如，monitor.rest模块在其公共API中就有这个方法：
- en: '`public static MonitorServer create(Supplier<Statistics> statistics) { return
    new MonitorServer(statistics); }`'
  id: totrans-1479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`public static MonitorServer create(Supplier<Statistics> statistics) { return
    new MonitorServer(statistics); }`'
- en: 'But `Statistics` comes from monitor.statistics, so any module using rest needs
    to read statistics or it can’t access `Statistics` and thus can’t create a `MonitorServer`.
    In other words, rest is useless to modules that don’t also read statistics. In
    the ServiceMonitor application, this happens surprisingly often: every module
    that requires at least one other module and exports a package ends up being in
    that situation.'
  id: totrans-1480
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但`Statistics`来自monitor.statistics，因此任何使用rest的模块都需要读取statistics，否则它无法访问`Statistics`，因此无法创建`MonitorServer`。换句话说，rest对于不也读取statistics的模块来说是无用的。在ServiceMonitor应用中，这种情况出人意料地经常发生：每个至少需要另一个模块并导出包的模块最终都会处于这种情况。
- en: That’s considerably more frequent than out in the wild and only happens that
    often because the modules are so small that almost all of their code is public
    API—it would be surprising if they didn’t constantly expose their dependencies’
    types in their own APIs. So although this occurs more rarely in practice, you
    can still expect to see it on a daily basis—in the JDK, roughly 20% of the dependencies
    are exposed.
  id: totrans-1481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这在野外发生的频率要高得多，而且只有那么频繁，是因为这些模块非常小，几乎所有的代码都是公开的API——如果它们不在自己的API中不断暴露其依赖项的类型，那将令人惊讶。所以尽管在实践中这种情况发生的频率较低，但你仍然可以期望每天都会看到这种情况——在JDK中，大约20%的依赖项被暴露。
- en: To not keep users guessing about which other modules they need to require explicitly,
    which is cumbersome and bloats module declarations, the module system offers `requires
    transitive`. Because rest `requires transitive` statistics, any module reading
    rest also reads statistics, and thus users of rest are spared the guesswork. Implied
    readability is discussed in detail in section 11.1.
  id: totrans-1482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了不让用户猜测他们需要显式要求的其他模块，这既麻烦又使模块声明膨胀，模块系统提供了`requires transitive`。因为rest `requires
    transitive`统计信息，任何读取rest的模块也会读取统计信息，因此rest的用户免去了猜测的麻烦。隐含的可读性在第11.1节中进行了详细讨论。
- en: 15.1.2 REDUCED VISIBILITY
  id: totrans-1483
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 15.1.2 降低可见性
- en: 'Another change from the application’s original versions in section 2.2 is that
    its modules work harder to reduce their API surface. The updated modules use considerably
    fewer plain `exports` directives:'
  id: totrans-1484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与2.2节中应用程序原始版本相比的另一个变化是，它的模块更加努力地减少它们的API表面积。更新的模块使用了相当少的普通`exports`指令：
- en: Thanks to services, the observers no longer have to export their implementations.
  id: totrans-1485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多亏了服务，观察者不再需要导出它们的实现。
- en: By using qualified exports, the package `monitor.observer.utils` in monitor.observer
    is only accessible to a selected set of modules.
  id: totrans-1486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用限定导出，`monitor.observer.utils`包在`monitor.observer`中只能被选定的模块访问。
- en: monitor.persistence opens its entity package instead of exporting it, thus only
    making it available at run time.
  id: totrans-1487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`monitor.persistence`打开其实体包而不是导出它，因此仅在运行时使其可用。'
- en: These changes reduce the amount of code that’s readily accessible for any random
    module, which means developers can change more code inside a module without having
    to worry about the effects on downstream consumers. Reducing the API surface this
    way is a boon for the maintainability of frameworks and libraries, but large applications
    with many modules can also benefit. Section 11.3 introduces qualified exports,
    and section 12.2 explores open packages.
  id: totrans-1488
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些变化减少了任何随机模块可以轻松访问的代码量，这意味着开发者可以在模块内部更改更多代码，而无需担心对下游消费者的影响。以这种方式减少API表面积对于框架和库的维护性来说是一个福音，但具有许多模块的大型应用程序也可以从中受益。第11.3节介绍了限定导出，第12.2节探讨了公开包。
- en: 15.1.3 DECOUPLED WITH SERVICES
  id: totrans-1489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 15.1.3 通过服务解耦
- en: The only structural change of the module graph (compared to section 2.2) is
    that monitor no longer directly depends on the observer implementations. Instead,
    it only depends on the module providing the API, monitor.observer, and it uses
    `ServiceObserverFactory` as a service. All three implementing modules provide
    that service with their specific implementations, and the module system connects
    the two sides.
  id: totrans-1490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与2.2节相比，模块图的结构性变化仅在于`monitor`不再直接依赖于观察者实现。相反，它只依赖于提供API的模块`monitor.observer`，并使用`ServiceObserverFactory`作为服务。所有三个实现模块都提供该服务及其特定实现，模块系统连接了这两者。
- en: This is much more than just an aesthetic improvement. Thanks to services, it’s
    possible to configure aspects of the application’s behavior—which kinds of services
    it can observe—at launch time. New implementations can be added and obsolete ones
    can be removed by adding or removing modules that provide that service—no changes
    of monitor are required, and hence the same artifacts can be used without having
    to rebuild them. To learn all about services, check out chapter 10.
  id: totrans-1491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这不仅仅是一个美学上的改进。多亏了服务，可以在启动时配置应用程序行为的某些方面——它可以观察哪些类型的服务。可以通过添加或删除提供该服务的模块来添加新实现和删除过时的实现——无需对`monitor`进行任何更改，因此可以使用相同的工件而无需重新构建它们。要了解有关服务的所有信息，请参阅第10章。
- en: 15.1.4 LOADS CODE AT RUN TIME WITH LAYERS
  id: totrans-1492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 15.1.4 在运行时以层叠方式加载代码
- en: Although services allow us to define the application’s behavior at launch time,
    we even went one step further. It isn’t visible in the module declarations, but
    by enabling the monitor module to create new layers, we made it possible for the
    application to start observing services at run time for which it didn’t even have
    the `ServiceObserver` implementation when it launched. On demand, monitor will
    create a new module graph and, together with a new class loader, load additional
    classes and update its list of observers.
  id: totrans-1493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管服务允许我们在启动时定义应用程序的行为，但我们甚至更进一步。这并没有在模块声明中体现出来，但通过启用监控模块创建新层，我们使得应用程序能够在运行时观察那些在启动时甚至没有`ServiceObserver`实现的服务的功能。按需，监控器将创建一个新的模块图，并使用新的类加载器加载额外的类，并更新其观察者列表。
- en: Listing 15.3 Creating a new layer with the graph created for modules on those
    paths
  id: totrans-1494
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表15.3 使用为这些路径上的模块创建的图创建新层
- en: '`private static ModuleLayer createLayer(Path[] modulePaths) { Configuration
    configuration = createConfiguration(modulePaths); ClassLoader thisLoader = getThisLoader();
    return getThisLayer() .defineModulesWithOneLoader(configuration, thisLoader);
    }  private static Configuration createConfiguration(Path[] modulePaths) { return
    getThisLayer() .configuration() .resolveAndBind( ModuleFinder.of(), ModuleFinder.of(modulePaths),
    Collections.emptyList() ); }`'
  id: totrans-1495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`private static ModuleLayer createLayer(Path[] modulePaths) { Configuration
    configuration = createConfiguration(modulePaths); ClassLoader thisLoader = getThisLoader();
    return getThisLayer() .defineModulesWithOneLoader(configuration, thisLoader);
    }  private static Configuration createConfiguration(Path[] modulePaths) { return
    getThisLayer() .configuration() .resolveAndBind( ModuleFinder.of(), ModuleFinder.of(modulePaths),
    Collections.emptyList() ); }`'
- en: Such behavior is particularly interesting for applications that aren’t frequently
    redeployed and where restarts are inconvenient. Complex desktop applications come
    to mind, but a web backend that runs on the customer’s premises and needs to be
    comprehensibly configurable could also qualify. For a discussion of what layers
    are and how to create them, see section 12.4.
  id: totrans-1496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种行为对于不经常重新部署且重启不便的应用程序尤其有趣。复杂的桌面应用程序可以想到，但运行在客户场所并需要可理解配置的Web后端也可能符合条件。关于层是什么以及如何创建它们的讨论，请参阅12.4节。
- en: 15.1.5 HANDLES DEPENDENCIES ON PLAIN JARS
  id: totrans-1497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 15.1.5 处理普通JAR的依赖
- en: Another detail that isn’t obvious from the module declarations is the modularization
    status of ServiceMonitor’s third-party dependency. Neither the Hibernate version
    nor the Spark version it uses is modularized yet, and they still ship as plain
    JARs. Because explicit modules require them, they need to be on the module path,
    though, where the module system turns plain JARs into automatic modules.
  id: totrans-1498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从模块声明中不明显的一个细节是ServiceMonitor的第三方依赖的模块化状态。它所使用的Hibernate版本和Spark版本尚未模块化，它们仍然以普通JAR文件的形式发布。由于显式模块需要它们，因此它们需要位于模块路径上，尽管模块系统会将普通JAR文件转换为自动模块。
- en: So although ServiceMonitor is fully modularized, it can nonetheless depend on
    non-modularized JARs. Looking at this from the ecosystem-wide perspective, where
    the JDK modules sit at the bottom and application modules are at the top, this
    is effectively a top-down modularization effort.
  id: totrans-1499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管ServiceMonitor完全模块化，但它仍然可以依赖于非模块化的JAR文件。从整个生态系统角度来看，其中JDK模块位于底层，而应用模块位于顶层，这实际上是一个自上而下的模块化努力。
- en: Automatic modules in particular are covered in section 8.3, but all of chapter
    8 applies here. If you want to catch up on modularization strategies, check out
    section 9.2.
  id: totrans-1500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 自动模块在8.3节中有详细说明，但第8章的所有内容都适用。如果您想了解模块化策略，请查看9.2节。
- en: 15.2 Tips for a modular application
  id: totrans-1501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 15.2 模块化应用程序的技巧
- en: Throughout the book, we’ve spent a lot of time looking at how to use the module
    system’s various tools to solve individual problems. That’s obviously the most
    important task of a book about the JPMS, but I won’t let you go without taking
    at least a quick inventory of the toolbox as a whole.
  id: totrans-1502
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在整本书中，我们花费了大量时间研究如何使用模块系统中的各种工具来解决个别问题。显然，这是关于JPMS的书籍最重要的任务，但我不打算让您在没有至少快速盘点整个工具箱的情况下离开。
- en: The first question is, do you even want to use these tools? Without the metaphor,
    do you want to create modules (section 15.2.1)? Once that’s settled, we’ll take
    a shot at defining what an ideal module might look like (section 15.2.2). We’ll
    then focus on how to keep module declarations in tip-top shape (section 15.2.3)
    and which changes might break your users’ code (section 15.2.4).
  id: totrans-1503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第一个问题是你是否真的想使用这些工具？不使用比喻，你是否想创建模块（第 15.2.1 节）？一旦这个问题解决，我们将尝试定义一个理想的模块可能的样子（第
    15.2.2 节）。然后我们将关注如何保持模块声明处于最佳状态（第 15.2.3 节）以及哪些更改可能会破坏用户的代码（第 15.2.4 节）。
- en: 15.2.1 MODULAR OR NOT?
  id: totrans-1504
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 15.2.1 模块化与否？
- en: After all you’ve learned about the module system—its features, its drawbacks,
    its promises, and its restrictions—maybe you’re still asking yourself whether
    you should modularize your JARs. In the end, only you and your team can answer
    that for your project, but I can give you my thoughts on the topic.
  id: totrans-1505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总的来说，你已经了解了模块系统的各个方面——它的特性、缺点、承诺和限制——也许你还在问自己是否应该模块化你的 JAR 文件。最终，只有你和你的团队能够为你的项目回答这个问题，但我可以给你一些关于这个话题的想法。
- en: As I’ve expressed throughout the book, I’m convinced that the module system
    offers lots of benefits that are important to libraries, frameworks, and most
    nontrivial applications. Particularly strong encapsulation, decoupling via services
    (although that can also be done without modules, albeit less comfortably), and
    application images stand out to me.
  id: totrans-1506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如我在整本书中表达的那样，我坚信模块系统为库、框架和大多数非平凡应用程序提供了许多重要的好处。尤其是强大的封装、通过服务解耦（尽管没有模块也可以这样做，但不太方便），以及应用程序镜像，这些对我来说特别突出。
- en: 'What I like best, though, are the module declarations themselves: they’re at
    all times a true representation of your project’s architecture and will provide
    considerable benefits to every developer and architect who works on those aspects
    of their system, thus improving its overall maintainability. (I go deeper into
    this topic in section 15.2.3.)'
  id: totrans-1507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，我最喜欢的是模块声明本身：它们始终是项目架构的真实反映，并将为每个致力于系统这些方面的开发者和架构师提供相当大的好处，从而提高其整体的可维护性。（我在第
    15.2.3 节中对此进行了更深入的探讨。）
- en: ESSENTIAL INFO For those reasons, my default is to start every new project that’s
    developed against Java 9+ with modules. (Theoretically, project-specific reasons
    could convince me otherwise, but I can’t come up with any that might.) If dependencies
    start making too much trouble when put onto the module path (for example, they
    could be splitting packages—see section 7.2), it’s fairly easy to back out of
    the module system by using the class path instead of the module path. If you work
    with modules from the get-go, creating and evolving them will take almost no time,
    relatively speaking, whereas the improved maintainability will considerably reduce
    the amount of untangling that needs to be done as the project grows and ages.
  id: totrans-1508
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息**由于这些原因，我的默认做法是使用模块系统来启动每个针对 Java 9+ 开发的全新项目。（理论上，特定项目的原因可能会让我改变主意，但我实在想不出任何可能的情况。）如果依赖项在模块路径上造成太多麻烦（例如，它们可能会分割包——参见第
    7.2 节），那么通过使用类路径而不是模块路径，退出模块系统相对容易。如果你从一开始就使用模块，那么创建和演进模块几乎不需要时间，相对而言，而改进的可维护性将大大减少随着项目增长和老化需要解开的问题数量。'
- en: If you’re not convinced, give it a try first. Build a demo project with modules
    or, even better, a small application with real users and requirements. Noncritical,
    company-internal tools make great guinea pigs.
  id: totrans-1509
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你还不信服，先试试看。用模块构建一个演示项目，或者更好的是，一个具有真实用户和需求的小型应用程序。非关键性的公司内部工具是绝佳的实验对象。
- en: 'When it comes to modularizing existing projects, the answer is much more “it
    depends.” The amount of work that needs to be done is much more apparent, but
    the benefits are just as tangible. In fact, the more work that has to be done,
    the higher the payoff will usually be. Think about it: which applications are
    the hardest to modularize? Those that consist of more artifacts, are more entangled,
    and are less maintainable. But these are also exactly the ones that stand to gain
    the most from having their structure investigated and worked on. So be careful
    when somebody assumes the modularization of an existing project has low costs
    and high benefits (or the other way around).'
  id: totrans-1510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当涉及到模块化现有项目时，答案要复杂得多。“这取决于”的情况更多。需要完成的工作量更加明显，但好处同样明显。事实上，需要完成的工作越多，通常回报就越高。想想看：哪些应用程序最难模块化？那些由更多工件组成、更加纠缠、维护性更差的。但这些都是从调查和改进其结构中获益最多的。所以当有人假设现有项目的模块化成本低、收益高（或相反）时要小心。
- en: ESSENTIAL INFO In the end, a project’s expected remaining lifetime can be a
    tie breaker. The longer the project needs to be maintained, the lower the relative
    costs and the higher the benefits of modularization. In other words, the longer
    the remaining lifetime, the more sense modularization makes.
  id: totrans-1511
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关键信息最终，一个项目预期的剩余寿命可能是一个决定性因素。项目需要维护的时间越长，模块化的相对成本就越低，收益就越高。换句话说，剩余寿命越长，模块化就越有意义。
- en: If you’re working on a project that has users outside your team, such as a library
    or a framework, you should also take their needs into account. Even if modularization
    doesn’t seem worth it to you, they stand to benefit considerably from it.
  id: totrans-1512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你正在开发一个有团队外用户的项目，比如库或框架，你也应该考虑他们的需求。即使模块化对你来说似乎不值得，他们也能从中获得相当大的好处。
- en: 15.2.2 THE IDEAL MODULE
  id: totrans-1513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 15.2.2 理想模块
- en: 'Suppose you’ve made your decision and have gone with modules. What’s the ideal
    module? What are you shooting for when cutting modules and writing declarations?
    Once again, there’s no one-size-fits-all answer, but there are a number of signals
    you can keep on your radar:'
  id: totrans-1514
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设你已经做出了决定，并选择了模块。理想的模块是什么？你在切割模块和编写声明时追求的是什么？再次强调，没有一种适合所有情况的答案，但有一些信号你可以保持关注：
- en: Module size
  id: totrans-1515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块大小
- en: API surface
  id: totrans-1516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 表面
- en: Coupling between modules
  id: totrans-1517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块之间的耦合
- en: Before discussing each of these in turn, I want to add that even if you have
    a notion of what an ideal module is, it’s unlikely that you’ll churn out one after
    another. Particularly if you start by modularizing an existing project, chances
    are you’ll create some ugly modules on the way.
  id: totrans-1518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在依次讨论这些内容之前，我想补充一点，即使你有一个理想模块的概念，你也不太可能一个接一个地创造出这样的模块。尤其是如果你从模块化现有项目开始，你可能会在过程中创建一些丑陋的模块。
- en: If you’re working on an application, you don’t have to worry about that—you
    can easily refactor modules as you go. For library and framework developers, life
    is tougher. As you’ll see in section 15.2.4, many refactoring steps can break
    your users’ code, so you have much less freedom to evolve.
  id: totrans-1519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你正在开发一个应用程序，你不必担心这一点——你可以轻松地在开发过程中重构模块。对于库和框架的开发者来说，生活更艰难。正如你将在15.2.4节中看到的，许多重构步骤可能会破坏用户的代码，因此你进化时拥有的自由度更小。
- en: 'Now, let’s turn to the three signals you can observe to judge a module’s quality:
    size, surface, and coupling.'
  id: totrans-1520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，让我们转向你可以观察到的三个信号来判断模块的质量：大小、表面和耦合。
- en: KEEP YOUR MODULES SMALL(ISH)
  id: totrans-1521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 保持你的模块（相对）小
- en: Module declarations give you a great tool to analyze and sculpt the boundaries
    between modules, but they’re relatively blind to what goes on within a module.
    Packages have circular dependencies? All classes and members are public? It’s
    a big ball of mud? That may hurt during development, but your module declarations
    won’t reflect it.
  id: totrans-1522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块声明为你提供了一个强大的工具来分析和塑造模块之间的边界，但它们对模块内部发生的事情相对盲目。包有循环依赖？所有类和成员都是公开的？它可能对开发造成伤害，但你的模块声明不会反映这一点。
- en: That means the more module declarations you have, the more insight into and
    control over your code’s structure you have (see [figure 15.2](part0030.html#filepos1891298)).
    On the other hand, there’s a one-to-one relationship between modules, JARs, and
    (typically) build-tool projects, so a higher number of module declarations also
    means increased maintenance efforts and longer build times. It’s clearly a trade-off.
  id: totrans-1523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这意味着你拥有的模块声明越多，你对代码结构的洞察和控制就越多（参见[图15.2](part0030.html#filepos1891298)）。另一方面，模块、JAR文件和（通常是）构建工具项目之间存在一对一的关系，因此模块声明的数量越多，也意味着维护工作量的增加和构建时间的延长。这显然是一个权衡。
- en: '![](../images/00061.jpeg)'
  id: totrans-1524
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00061.jpeg)'
- en: '[Figure 15.2](part0030.html#filepos1890735) These package relationships are
    arguably somewhat chaotic. With just two modules (top), that doesn’t become apparent,
    though. It’s only when trying to create more modules (bottom) that the problems
    become obvious. The additional module boundaries provided that insight.'
  id: totrans-1525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图15.2](part0030.html#filepos1890735) 这些包之间的关系可以说是有些混乱。只有两个模块（顶部）时，这一点并不明显。只有在尝试创建更多模块（底部）时，问题才会变得明显。额外的模块边界提供了这个洞见。'
- en: Still, as a general rule of thumb, prefer smaller modules over larger ones.
    Once a module’s lines of code get into five digits, you may want to think about
    cutting it apart; when the module crosses into six digits, I recommend seriously
    considering it. If it’s seven digits, you’re likely to have some serious refactoring
    work ahead of you. (If you have trouble breaking cyclic dependencies between classes,
    check out section 10.2.5, where you use services to do just that.)
  id: totrans-1526
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管如此，作为一个一般性的规则，还是倾向于选择较小的模块而不是较大的模块。一旦一个模块的代码行数达到五位数字，你可能想要考虑将其拆分；当模块的代码行数达到六位数字时，我建议你认真考虑这一点。如果达到七位数字，你很可能会面临一些重大的重构工作。（如果你在解决类之间的循环依赖关系方面遇到困难，可以查看第10.2.5节，那里介绍了使用服务来解决这个问题。）
- en: ESSENTIAL INFO With all that said, don’t trust anybody who tells you there’s
    a correct size for your modules without looking at your project. The only valid
    answer to “How small or large should modules be?” is, “It depends.” Each module
    should be a cohesive solution to a specific problem. If that problem happens to
    have a large solution, that’s ok—don’t start cutting things apart that belong
    together.
  id: totrans-1527
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 就这样说了，不要相信那些没有查看你的项目就告诉你模块正确大小的人。对于“模块应该有多小或多大？”这个问题，唯一的有效答案是，“这取决于。”每个模块都应该是针对特定问题的完整解决方案。如果这个问题恰好有一个大的解决方案，那也没关系——不要开始拆分本应属于一起的东西。'
- en: What belongs together? When cutting a cohesive module in two, you’re bound to
    end up with a pretty large API surface between the pieces—which brings us to the
    next aspect we need to discuss.
  id: totrans-1528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 什么属于一起？当你将一个完整的模块拆分成两部分时，你很可能会在两部分之间得到一个非常大的API表面——这把我们带到了下一个需要讨论的方面。
- en: KEEP THE API SURFACE SMALL
  id: totrans-1529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**保持API表面小**'
- en: ESSENTIAL INFO The strength of modules is that they can keep their internals
    to themselves. This allows easier refactoring within the module and a more careful
    evolution of its public API. Given those benefits, a smaller number of plain `exports`
    directives is generally preferable. The same is true for qualified exports—the
    fewer, the better.
  id: totrans-1530
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 模块的优势在于它们可以将其内部内容保留给自己。这允许在模块内部进行更轻松的重构，并更谨慎地演进其公共API。考虑到这些好处，通常更倾向于使用较少的普通`exports`指令。对于有资格的导出也是同样的道理——越少越好。'
- en: How do plain and qualified exports compare? Within a project, there isn’t much
    of a difference. When it comes to entangling two modules, it doesn’t really matter
    whether the export was qualified. That said, a qualification at least indicates
    that an API may not have been designed for general use, which is useful information,
    particularly in larger projects.
  id: totrans-1531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 普通导出和有资格导出如何比较？在一个项目中，两者之间并没有太大的区别。当涉及到将两个模块纠缠在一起时，导出是否有资格实际上并不重要。话虽如此，一个资格至少表明一个API可能不是为通用用途设计的，这是一个有用的信息，尤其是在较大的项目中。
- en: 'Libraries and frameworks, unlike applications, always have to think about how
    their exports impact projects depending on them. In this scenario, a qualified
    export to other modules within the same project is the same as if the package
    wasn’t exported at all, which is definitely a win. In summary, qualified exports
    still contribute to the API surface: almost as much as regular exports within
    a project, but considerably less so across project boundaries.'
  id: totrans-1532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与应用程序不同，库和框架总是需要考虑它们的导出如何影响依赖于它们的工程。在这种情况下，同一项目内其他模块的合格导出与没有导出是一样的，这绝对是一个胜利。总的来说，合格导出仍然对API表面有贡献：几乎与项目内部的常规导出一样多，但在项目边界之外则少得多。
- en: KEEP COUPLING TO A MINIMUM
  id: totrans-1533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**尽量减少耦合**'
- en: 'Pick two random pieces of code—it doesn’t matter whether they’re methods, classes,
    or modules. Everything else being equal, the one with fewer dependencies is more
    maintainable. The reason is simple: the more dependencies it has, the more changes
    are in a position to break it.'
  id: totrans-1534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 随机选择两段代码——无论是方法、类还是模块都无关紧要。在其他条件相同的情况下，依赖项更少的代码更容易维护。原因很简单：依赖项越多，越有可能出现破坏它的变化。
- en: 'It goes beyond plain dependencies, though: it’s more generally a matter of
    coupling. If a module not only depends on another, but actively uses all of the
    dozen packages it exports, the two modules are more tightly coupled. This is even
    truer if qualified exports are part of the mix, because they essentially say,
    “This isn’t a properly supported API, but I’ll let you use it anyway.”'
  id: totrans-1535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然这超出了普通依赖的范围：它更普遍地是一个耦合问题。如果一个模块不仅依赖于另一个，而且积极地使用它导出的所有十二个包，那么这两个模块的耦合就更加紧密。如果合格导出是混合的一部分，这更是如此，因为它们本质上是在说，“这不是一个支持良好的API，但我仍然会让你使用它。”
- en: ESSENTIAL INFO This goes beyond individual modules. To understand a system,
    you not only need to understand the parts (here, modules), but also their connections
    (here, dependencies and coupling). And if you aren’t careful, the system can have
    many more connections than parts (on the order of the number of modules squared;
    see [figure 15.3](part0030.html#filepos1897373)). Loosely coupled parts are hence
    a critical ingredient to keeping a system as simple as possible.
  id: totrans-1536
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 这不仅限于单个模块。要理解一个系统，你不仅需要理解其部分（在这里是模块），还需要理解它们之间的连接（在这里是依赖和耦合）。如果不小心，系统可能比部分有更多的连接（大约是模块数量的平方；参见[图15.3](part0030.html#filepos1897373)）。因此，松散耦合的部分是保持系统尽可能简单的一个关键因素。'
- en: '![](../images/00082.jpeg)'
  id: totrans-1537
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00082.jpeg)'
- en: '[Figure 15.3](part0030.html#filepos1897188) Even though both graphs have the
    same number of nodes, they vary considerably in complexity. The one on the left
    has about as many edges as nodes, whereas the one on the right has about one edge
    per pair of nodes. If a new node was added, the left graph would get one or maybe
    two new edges, whereas the right graph would get about six.'
  id: totrans-1538
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图15.3](part0030.html#filepos1897188) 即使两个图具有相同数量的节点，它们的复杂度差异很大。左边的图大约有与节点数量相等的边，而右边的图大约每对节点有一条边。如果添加一个新节点，左边的图将增加一个或可能两个新边，而右边的图将增加大约六个。'
- en: One good way to decouple modules are services, as explained in chapter 10\.
    Not only do they break the direct dependency between modules, but they also require
    you to have a single type through which you can access the entire API. If you
    don’t turn that type into a kraken that connects to dozens of other types, this
    will greatly reduce the coupling between the modules.
  id: totrans-1539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一种解耦模块的好方法是使用服务，如第10章所述。它们不仅打破了模块之间的直接依赖，而且要求你有一个单一的类型，通过它可以访问整个API。如果你不把这个类型变成连接到数十个其他类型的kraken，这将大大减少模块之间的耦合。
- en: 'ESSENTIAL INFO A word of warning: services are neat, but they’re harder to
    predict than plain dependencies. You can’t easily see how two pieces of code are
    connected, and you won’t get errors when providers are missing. So don’t go overboard
    and put services everywhere.'
  id: totrans-1540
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 一个警告：服务很整洁，但它们比普通依赖更难以预测。你无法轻易地看到两段代码是如何连接的，当提供者缺失时，你也不会收到错误。所以不要过度使用服务。'
- en: 'This should be the litmus test: Can you create a service type with a reasonably
    small API? Does it look like it might be used or provided by more than just one
    module on each side?'
  id: totrans-1541
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这应该是一个试金石：你能创建一个具有合理小API的服务类型吗？它看起来可能被每个模块的多个模块使用或提供吗？
- en: If you’re unsure, have a look around the JDK. The official documentation lists
    the services a module uses or provides, and you can use your IDE to look at the
    user’s and implementation’s code.
  id: totrans-1542
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你不确定，可以查看一下JDK。官方文档列出了模块使用或提供的服务，你可以使用你的IDE查看用户和实现代码。
- en: LISTEN TO YOUR MODULE DECLARATION
  id: totrans-1543
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**倾听你的模块声明**'
- en: 'ESSENTIAL INFO We’ve just discussed that modules should be small, should have
    an even smaller API surface, and should be loosely coupled to their surroundings.
    In the end, these pieces of advice can be boiled down into a deceptively simple
    formula: keep cohesion high and coupling low. Looking out for module size, number
    of `exports`, and number of `requires` as well as the strength of each dependency
    can help you with that.'
  id: totrans-1544
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**基本信息** 我们刚刚讨论过，模块应该是小的，应该有更小的API表面，并且应该与周围环境松散耦合。最终，这些建议可以归结为一个看似简单的公式：保持内聚度高，耦合度低。关注模块大小、`exports`数量、`requires`数量以及每个依赖项的强度可以帮助你做到这一点。'
- en: NOTE Like any set of target numbers, these can be gamed without achieving anything.
    More important than some numbers is a thought-out overall architecture. Although
    this book gives you a lot of tools and even some tips for achieving that, it doesn’t
    teach it from the ground up.
  id: totrans-1545
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意** 就像任何一组目标数字一样，这些数字可以随意操作而不取得任何成果。比一些数字更重要的是一个经过深思熟虑的整体架构。尽管这本书为你提供了很多工具，甚至提供了一些实现该架构的技巧，但它并没有从基础开始教你。'
- en: 'Also note that the three signals (size, surface, and cohesion) will often work
    against one another. As an extreme example, take an application that consists
    of just one module. It very likely has no API; and with just one artifact, there’s
    not much coupling going on. At the other extreme, a code base where each package
    is in its own module is full of small modules with small API surfaces. These extremes
    are, of course, ridiculous, but they illustrate the problem: this is a balancing
    act.'
  id: totrans-1546
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还要注意，这三个信号（大小、表面和内聚）通常会相互对立。作为一个极端的例子，考虑一个只包含一个模块的应用程序。它很可能没有API；并且只有一个工件，耦合度不高。在另一个极端，每个包都在自己的模块中的代码库充满了小型模块，这些模块具有小的API表面。当然，这些极端是荒谬的，但它们说明了问题：这是一个平衡行为。
- en: ESSENTIAL INFO In summary, these signals are just, well, signals—you and your
    team will always have to apply your own good judgment based on the information
    they provide. But your module declarations can help with that. If they’re turning
    complex and constantly need a lot of changes, they’re trying to tell you something.
    Listen to them.
  id: totrans-1547
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**基本信息** 总结来说，这些信号只是，嗯，信号——你和你团队将始终需要根据它们提供的信息应用自己的良好判断。但你的模块声明可以帮助你做到这一点。如果它们变得复杂并且需要不断进行大量更改，它们正在试图告诉你一些事情。倾听它们。'
- en: 15.2.3 TAKE CARE OF YOUR MODULE DECLARATIONS
  id: totrans-1548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 15.2.3 **注意模块声明**
- en: If you’re building a modular project, module declarations are easily the most
    important `.java` files in your code base. Each of them represents an entire JAR,
    which will likely consist of dozens, hundreds, or maybe even thousands of source
    files. Even more than merely representing them, the modular declarations govern
    how the module interacts with other modules.
  id: totrans-1549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你正在构建一个模块化项目，模块声明可能是你代码库中最重要的一些`.java`文件。每个都代表一个完整的JAR文件，它可能包含数十、数百甚至可能成千上万的源文件。除了仅仅代表它们之外，模块声明还规定了模块如何与其他模块交互。
- en: 'So, you should take good care of your module declarations! Here are a few things
    to look out for:'
  id: totrans-1550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，你应该好好照顾你的模块声明！以下是一些需要注意的事项：
- en: Keep declarations clean.
  id: totrans-1551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持声明整洁。
- en: Comment declarations.
  id: totrans-1552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释声明。
- en: Review declarations.
  id: totrans-1553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查声明。
- en: Let’s take these one by one.
  id: totrans-1554
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让我们逐一来看。
- en: CLEAN MODULE DECLARATIONS
  id: totrans-1555
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**整洁的模块声明**'
- en: Module declarations are code and should be treated as such, so make sure your
    code style is applied. Consistent indentation, line length, bracket positions,
    and so forth—these rules make as much sense for declarations as they do for any
    other source file.
  id: totrans-1556
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块声明是代码，应该像对待代码一样处理，所以请确保你的代码风格得到应用。一致的缩进、行长度、括号位置等等——这些规则对于声明来说和任何其他源文件一样有意义。
- en: 'In addition, I strongly recommend that you structure your module declarations
    instead of putting directives in random order. All declarations in the JDK as
    well as in this book have the following order:'
  id: totrans-1557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，我强烈建议你结构化你的模块声明，而不是将指令随机排序。JDK以及本书中的所有声明都有以下顺序：
- en: '`requires`, including `static` and `transitive`'
  id: totrans-1558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`requires`，包括`static`和`transitive`'
- en: '`exports`'
  id: totrans-1559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`exports`'
- en: '`exports to`'
  id: totrans-1560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`exports to`'
- en: '`opens`'
  id: totrans-1561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`opens`'
- en: '`opens to`'
  id: totrans-1562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`opens to`'
- en: '`uses`'
  id: totrans-1563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`uses`'
- en: '`provides`'
  id: totrans-1564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`provides`'
- en: The JDK always puts an empty line between blocks to keep them apart—I only do
    that when there are more than a few directives.
  id: totrans-1565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JDK 总是在块之间留一个空行以保持它们分开——我只在有几个指令以上时才这样做。
- en: Going further, you could define how to order directives within the same block.
    Lexicographically is an obvious choice, although for `requires` I first list internal
    dependencies and then external ones.
  id: totrans-1566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 进一步来说，你可以定义如何在同一块中排序指令。字典序是一个明显的选择，尽管对于 `requires`，我首先列出内部依赖，然后是外部依赖。
- en: NOTE However you decide, if you have a document defining your code style, record
    the decision there. If you have your IDE, build tool, or code analyzer check such
    things for you, even better. Try to bring it up to speed so it can automatically
    check or apply your chosen style.
  id: totrans-1567
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意** 无论你如何决定，如果你有一个定义你的代码风格的文档，记录在那里。如果你有你的 IDE、构建工具或代码分析器为你检查这些事情，那就更好了。尽量让它跟上进度，以便它可以自动检查或应用你选择的风格。'
- en: COMMENTING MODULE DECLARATIONS
  id: totrans-1568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注释模块声明**'
- en: Opinions on code documentation, like Javadoc or inline comments, vary wildly,
    and this isn’t the place to make my argument for why it’s important. But whatever
    your team’s position on comments is, extend it to module declarations.
  id: totrans-1569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于代码文档的意见，如 Javadoc 或内联注释，差异很大，这不是我提出为什么它很重要的地方。但无论你团队对注释的看法如何，都要将其扩展到模块声明中。
- en: 'If you like the idea that each abstraction has a sentence or a small paragraph
    explaining its meaning and importance, consider adding a Javadoc comment to each
    module:'
  id: totrans-1570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你喜欢每个抽象都有一个句子或一小段解释其意义和重要性的想法，考虑为每个模块添加 Javadoc 注释：
- en: '`/** * Aggregates service availability data points into statistics. */ module
    monitor.statistics { // ... }`'
  id: totrans-1571
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`/** * 将服务可用性数据点聚合到统计信息中。 */ module monitor.statistics { // ... }`'
- en: The JDK has such a comment or a longer one on each module.
  id: totrans-1572
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JDK 在每个模块上都有一个这样的注释或更长的注释。
- en: Even if you don’t like writing down what a module does, most people agree that
    documenting why a specific decision was made has value. In a module declaration,
    that could mean adding an inline comment
  id: totrans-1573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 即使你不喜欢记录模块的功能，大多数人都会同意记录为什么做出特定决策是有价值的。在模块声明中，这可能意味着添加一个内联注释
- en: To an optional dependency, to explain why the module might be absent
  id: totrans-1574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于可选依赖，解释为什么模块可能不存在
- en: To a qualified export, to explain why it isn’t a public API, but was still made
    accessible to specific modules
  id: totrans-1575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于合格的导出，为了解释为什么它不是公共 API，但仍然使特定模块可以访问
- en: To an open package, explaining which frameworks are planned to access it
  id: totrans-1576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于公开包，解释哪些框架计划访问它
- en: 'In the JDK, you’ll occasionally find comments like this one in jdk.naming.rmi:'
  id: totrans-1577
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 JDK 中，你偶尔会在 jdk.naming.rmi 中找到这样的注释：
- en: '`// temporary export until NamingManager.getURLContext uses services exports
    com.sun.jndi.url.rmi to java.naming;`'
  id: totrans-1578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`// 在 NamingManager.getURLContext 使用 services exports com.sun.jndi.url.rmi
    到 java.naming 之前临时导出；`'
- en: 'Generally speaking, my recommendation is this: every time you make a decision
    that isn’t immediately obvious, add a comment. Every time a reviewer asked why
    some change was made, add a comment. Doing that can help your fellow developers—or
    yourself two months down the road.'
  id: totrans-1579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一般而言，我的建议是：每次你做出一个不是立即明显的决策时，添加一个注释。每次审阅者询问为什么做出某些更改时，添加一个注释。这样做可以帮助你的同事——或者两个月后的你自己。
- en: ESSENTIAL INFO Module declarations present a new opportunity. Never before has
    it been so easy to properly document the relationships of your project’s artifacts
    in code.
  id: totrans-1580
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**必要信息** 模块声明提供了一个新的机会。以前从未如此容易地在代码中正确地记录项目工件之间的关系。'
- en: REVIEWING MODULE DECLARATIONS
  id: totrans-1581
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**审查模块声明**'
- en: 'Module declarations are the central representation of your modular structure,
    and examining them should be an integral part of any kind of code review you do.
    Whether it’s looking over your changes before a commit or before opening a pull
    request, wrapping up after a pair-programing session, or during a formal code
    review—any time you inspect a body of code, pay special attention to `module-info.java`:'
  id: totrans-1582
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块声明是您模块结构的中心表示，检查它们应该是任何类型代码审查的组成部分。无论是提交前的更改审查、打开拉取请求前的审查、结对编程会话后的总结，还是在正式代码审查期间——任何检查代码的时候，都要特别注意
    `module-info.java`：
- en: Are added dependencies really necessary? Are they in line with the project’s
    underlying architecture? Should they be exposed with `requires transitive` because
    their types are used in the module’s API?
  id: totrans-1583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真的有必要添加额外的依赖吗？它们是否与项目的底层架构相一致？是否应该使用 `requires transitive` 来暴露它们，因为它们的类型被用在模块的
    API 中？
- en: If a dependency is optional, is the code prepared to handle its absence at run
    time? Are there knock-on effects, like missing transitive dependencies that the
    optional dependency implied readability on?
  id: totrans-1584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个依赖项是可选的，代码是否准备好在运行时处理其缺失？是否存在连锁反应，比如缺失的传递依赖项，而可选依赖项暗示了可读性？
- en: Could a new dependency be replaced with a service?
  id: totrans-1585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新的依赖项能否被一个服务取代？
- en: Are added exports really necessary? Are all public classes in the newly exported
    packages ready for public use, or do they need to be shuffled around to reduce
    the API surface?
  id: totrans-1586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加的导出是否真的有必要？新导出的包中的所有公共类都准备好公开使用了吗，或者它们需要重新排列以减少API表面积？
- en: If an export is qualified, does that make sense, or is it just a cop-out to
    get access to an API that was never meant to be public?
  id: totrans-1587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果导出是合格的，这有意义吗，或者这只是为了获取一个从未打算公开的API而找的借口？
- en: Is the type used as a service designed to be an integral part of the application’s
    infrastructure?
  id: totrans-1588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的类型是否设计为应用程序基础设施的组成部分？
- en: Were any changes made that can negatively affect downstream consumers that aren’t
    part of the build process? (See section 15.2.4 for more on that.)
  id: totrans-1589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有任何更改可能对构建过程之外的下游消费者产生负面影响？（有关更多信息，请参阅15.2.4节。）
- en: Is the module declaration styled and commented according to the team’s requirements?
  id: totrans-1590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块声明是否按照团队的要求进行了样式化和注释？
- en: A diligent review is particularly important because IDEs offer quick fixes that
    let developers edit declarations at a distance by exporting packages or adding
    dependencies with a simple command. I appreciate those features, but they make
    careless editing more likely; thus it’s all the more important to ensure that
    nothing sneaks by unnoticed.
  id: totrans-1591
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 仔细审查尤其重要，因为IDE提供快速修复功能，允许开发者通过导出包或通过简单命令添加依赖项来远程编辑声明。我欣赏这些功能，但它们使粗心编辑的可能性更大；因此，确保没有东西被忽视就变得尤为重要。
- en: NOTE If you have a code-review guide, a commit check list, or any other document
    that helps to keep code quality high, you may want to add an item about module
    declarations.
  id: totrans-1592
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意** 如果您有一个代码审查指南、提交检查清单或任何其他有助于保持代码质量的文档，您可能希望添加关于模块声明的一项。'
- en: Investing time into reviewing module descriptors may sound like a lot of additional
    work. First, I would argue whether it’s a lot, particularly compared to the effort
    that goes into developing and reviewing the rest of the code base. More important,
    though, I don’t see it as an additional task—instead I see it as an opportunity.
  id: totrans-1593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在审查模块描述符上投入时间可能听起来像是一项额外的繁重工作。首先，我会争论这算不算多，尤其是与投入开发和其他代码库审查的努力相比。更重要的是，我不认为这是一项额外的工作——相反，我认为这是一个机会。
- en: ESSENTIAL INFO Never before has it been so easy to analyze and review your project’s
    structure. And not the white-board sketch that was photographed and uploaded to
    your team’s wiki a few years ago; no, I’m talking about the real deal, the actual
    relationships between your artifacts. The module declarations show you the naked
    reality instead of outdated good intentions.
  id: totrans-1594
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 从前从未如此容易分析和审查您项目的结构。而且不是几年前拍照上传到团队维基的白板草图；不，我指的是真正的交易，您工件之间的实际关系。模块声明向您展示了赤裸的现实，而不是过时的良好意图。'
- en: 15.2.4 BREAKING CODE BY EDITING MODULE DECLARATIONS
  id: totrans-1595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 15.2.4 通过编辑模块声明破坏代码
- en: As with any other source file, changing a module declaration can have unintended
    and possibly breaking effects on other code. More than that, though, the declaration
    is the distillation of your module’s public API and so has a much higher impact
    than any random class.
  id: totrans-1596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与任何其他源文件一样，更改模块声明可能会对其他代码产生意外和可能破坏性的影响。然而，更重要的是，声明是您模块公共API的提炼，因此其影响远大于任何随机类。
- en: If you develop an application and all consumers of your module are part of the
    same build process, then breaking changes can’t slip by unnoticed. Even for frameworks
    and libraries, such changes can be detected with thorough integration tests.
  id: totrans-1597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您开发的应用程序以及您模块的所有消费者都是同一构建过程的一部分，那么破坏性更改就不会被忽视。即使是框架和库，这样的更改也可以通过彻底的集成测试来检测。
- en: 'ESSENTIAL INFO Still, it helps to be aware of which changes are more likely
    to cause problems and which are usually benign. Here’s a ranked list of the more
    troublesome ones:'
  id: totrans-1598
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息** 仍然，了解哪些更改更有可能引起问题，哪些通常是良性的，是有帮助的。以下是一个按问题严重程度排序的列表：'
- en: New module name
  id: totrans-1599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新模块名称
- en: Fewer exported packages
  id: totrans-1600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出包更少
- en: Different provided services
  id: totrans-1601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供的服务不同
- en: Editing dependencies
  id: totrans-1602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑依赖项
- en: As you’ll see, all of these changes can cause compile errors or unexpected runtime
    behavior in downstream projects. As such, they should always be considered breaking
    changes, so if you use semantic versioning, a major version bump is in order.
    This doesn’t mean making other changes in your module declarations can’t also
    cause problems, but they’re much less likely; so, let’s focus on these four.
  id: totrans-1603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如你所看到的，所有这些更改都可能导致下游项目中出现编译错误或意外的运行时行为。因此，它们应该始终被视为破坏性更改，所以如果你使用语义版本控制，就需要进行主要版本号的提升。这并不意味着在模块声明中做出其他更改不会引起问题，但它们发生的可能性要小得多；所以，让我们专注于这四个。
- en: IMPACT OF A NEW MODULE NAME
  id: totrans-1604
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 新模块名称的影响
- en: Changing a module’s name will immediately break all modules that depend on it—they
    will need to be updated and rebuilt. That’s the least of the problems it can cause,
    though.
  id: totrans-1605
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 改变模块的名称将立即破坏所有依赖于它的模块——它们需要更新和重建。但这只是它可能引起的问题中最小的一个。
- en: 'Much more dangerous is the modular diamond of death (see section 3.2.2) it
    may create when some project transitively depends on your module twice: once with
    the old name and once with the new name. That project will have a hard time including
    your new version in its build and may well have to resort to eschewing the update
    just because of the changed name.'
  id: totrans-1606
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更危险的是，当某些项目在旧名称和新名称下两次 transitively 依赖于你的模块时，它可能创建的模块钻石死亡（见第3.2.2节）。该项目将很难将其新版本包含在其构建中，并且可能不得不因为名称更改而放弃更新。
- en: Be aware of this, and try to minimize renames. You may still have to do it occasionally,
    in which case you can try to mitigate the effects by creating an aggregator module
    with the old name (explained in section 11.1.5).
  id: totrans-1607
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意这一点，并尽量减少重命名。你仍然可能偶尔需要这样做，在这种情况下，你可以尝试通过创建一个具有旧名称的聚合模块来减轻影响（第11.1.5节中解释）。
- en: IMPACT OF EXPORTING FEWER PACKAGES
  id: totrans-1608
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 导出更少包的影响
- en: 'It should be obvious why “unexporting” packages causes problems: any module
    that uses types in these packages will fail to access them at compile time and
    run time. If you want to go this route, you should first deprecate those packages
    and types to give your users time to move away from them before they’re removed.'
  id: totrans-1609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 应该很明显，“取消导出”包会导致问题的原因：任何使用这些包中的类型的模块在编译时和运行时都无法访问它们。如果你想走这条路，你应该首先废弃那些包和类型，给用户时间从它们迁移开，在它们被移除之前。
- en: 'This only fully applies to plain `exports` directives:'
  id: totrans-1610
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这只完全适用于普通的 `exports` 指令：
- en: Qualified exports usually only export to other modules you control, which are
    likely part of your build and thus updated at the same time.
  id: totrans-1611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合格的导出通常只导出到你控制的模块，这些模块很可能是你的构建的一部分，因此会同时更新。
- en: Open packages are usually geared toward a specific framework or piece of code
    that’s intended to reflect over them. That code is rarely part of your users’
    modules, so they won’t be impacted by closing the package.
  id: totrans-1612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放式包通常针对特定的框架或代码片段，旨在反映它们。这段代码很少是用户模块的一部分，所以关闭包不会影响他们。
- en: Generally speaking, I wouldn’t consider removing qualified exports or opened
    packages a breaking change. Specific scenarios may go against that rule of thumb,
    though, so watch out for them and think things through when making such a change.
  id: totrans-1613
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通常来说，我不会认为删除合格的导出或打开的包是破坏性更改。尽管如此，具体场景可能违反这一经验法则，所以要注意它们，并在做出此类更改时仔细思考。
- en: IMPACT OF ADDING AND REMOVING SERVICES
  id: totrans-1614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 添加和删除服务的影响
- en: With services, the situation is a little less clear-cut. As described in section
    10.3.1, service consumers should always be prepared to handle the absence of service
    providers; similarly, they shouldn’t break when an additional provider is suddenly
    returned. But that only really covers that applications shouldn’t crash because
    the service loader returned the wrong number of providers.
  id: totrans-1615
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于服务来说，情况要复杂一些。如第10.3.1节所述，服务消费者应该始终准备好处理服务提供者不存在的情况；同样，当突然返回额外的提供者时，它们也不应该崩溃。但这只真正涵盖了应用程序不应该因为服务加载器返回了错误数量的提供者而崩溃。
- en: It’s still conceivable, maybe even likely, that an application misbehaves because
    a service was there in one version and isn’t in another. And because service binding
    happens across all modules, this may even impact code that doesn’t directly depend
    on you.
  id: totrans-1616
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 仍然有可能，甚至可能很可能会出现应用程序行为不当，因为服务在一个版本中存在，而在另一个版本中不存在。而且因为服务绑定发生在所有模块之间，这甚至可能影响到不直接依赖于你的代码。
- en: IMPACT OF EDITING DEPENDENCIES
  id: totrans-1617
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编辑依赖项的影响
- en: The last point on the list, dependencies in all their forms, is also a gray
    area. Let’s start with `requires transitive`. Section 11.1.4 explains that users
    should only rely on a dependency you let them read if they use it in the direct
    vicinity of your module. Assuming you stopped exposing the dependency’s types
    and your users updated their code, removing `transitive` from the `exports` directive
    shouldn’t impact them.
  id: totrans-1618
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表中的最后一点，所有形式的依赖项，也是一个灰色地带。让我们从`requires transitive`开始。第11.1.4节解释说，如果用户在您的模块的直接附近使用依赖项，他们应该只依赖您让他们阅读的依赖项。假设您停止公开依赖项的类型，并且您的用户更新了他们的代码，从`exports`指令中移除`transitive`不应该对他们产生影响。
- en: On the other hand, they may not know about or heed that recommendation, so keeping
    them from reading that dependency still requires them to update and rebuild their
    code. Hence I’d still consider it a breaking change.
  id: totrans-1619
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一方面，他们可能不知道或忽视这个建议，因此防止他们阅读那个依赖项仍然需要他们更新和重新构建他们的代码。因此，我仍然认为这是一个破坏性的变更。
- en: 'It’s also possible to come up with scenarios where removing or even adding
    other dependencies can cause problems, even though that shouldn’t be observable
    from outside your module:'
  id: totrans-1620
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还有可能出现这样的场景，即使移除或添加其他依赖项也可能导致问题，尽管从您的模块外部观察不到这些问题：
- en: Adding or removing plain `requires` directives changes optional dependency resolution
    and service binding.
  id: totrans-1621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加或移除普通的`requires`指令会改变可选依赖项解析和服务绑定。
- en: Making a dependency optional (or going the other way) can also change which
    modules make it into the module graph.
  id: totrans-1622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将依赖项设置为可选（或相反）也可能改变哪些模块进入模块图。
- en: So although `requires` and `requires static` can change the module graph and
    thus impact modules that are totally unrelated to you, this isn’t a common case.
    By default, I wouldn’t consider such changes to be breaking.
  id: totrans-1623
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，尽管`requires`和`requires static`可以改变模块图并因此影响与您完全不相关的模块，但这不是一个常见的情况。默认情况下，我不会认为这样的更改是破坏性的。
- en: NOTE Although all that may sound awful and complex, it isn’t any more so than
    when you’re editing classes that are part of a public API. You just don’t have
    an intuition yet for how changes to the module declaration impact other projects.
    It will come over time.
  id: totrans-1624
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：尽管所有这些都可能听起来很糟糕且复杂，但它并不比您编辑属于公共API的类更复杂。您只是还没有对模块声明更改如何影响其他项目的直觉。这将在一段时间后到来。
- en: 15.3 The technology landscape
  id: totrans-1625
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 15.3 技术景观
- en: 'After I first introduced the module system in section 1.4, I thought you might
    have a few questions about how it relates to the rest of the ecosystem. As you
    may recall, they went like this:'
  id: totrans-1626
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在我在第1.4节首次介绍模块系统后，我认为您可能对它如何与生态系统中的其他部分相关有一些疑问。如您所回忆的，它们是这样的：
- en: Don’t Maven, Gradle, and others already manage dependencies?
  id: totrans-1627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven、Gradle和其他工具不是已经管理依赖项了吗？
- en: What about OSGi? Why not just use that?
  id: totrans-1628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么，关于OSGi呢？为什么不直接使用它呢？
- en: Isn’t a module system overkill in times where everybody writes microservices?
  id: totrans-1629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个人都编写微服务的时候，模块系统不是过度了吗？
- en: I’ll answer these in a minute, but first I want to introduce you to what Java
    9+ has to offer beyond the module system. These benefits come as a package, after
    all, and if you’re skeptical about one, maybe the benefits of the other can sway
    you.
  id: totrans-1630
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我将在一分钟内回答这些问题，但首先我想向您介绍Java 9+提供的模块系统之外的优点。毕竟，这些好处是一个套餐，如果您对其中一个持怀疑态度，也许其他的好处可以影响您。
- en: 15.3.1 MAVEN, GRADLE, AND OTHER BUILD TOOLS
  id: totrans-1631
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 15.3.1 MAVEN、GRADLE和其他构建工具
- en: The Java ecosystem is in the lucky position to have a few powerful, battle-tested
    build tools like Maven and Gradle. They’re not perfect, of course, but they’ve
    been building Java projects for more than 10 years, so they clearly have something
    going for them.
  id: totrans-1632
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java生态系统幸运地拥有几个强大、经过实战考验的构建工具，如Maven和Gradle。当然，它们并不完美，但它们已经构建Java项目超过10年了，所以它们显然有一些优势。
- en: As the name implies, a build tool’s main job is to build a project, which includes
    compiling, testing, packaging, and distributing it. Although the module system
    touches on a lot of these steps and requires some changes in the tools, it doesn’t
    add any capabilities to the platform that make it compete with them in this area.
    So when it comes to building a project, the relation between the Java platform
    and its build tools remains much the same.
  id: totrans-1633
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如其名所示，构建工具的主要任务是构建项目，这包括编译、测试、打包和分发。尽管模块系统涉及许多这些步骤并要求对工具进行一些更改，但它并没有为平台添加任何使其在这个领域与它们竞争的功能。因此，当涉及到构建项目时，Java平台与其构建工具之间的关系仍然保持不变。
- en: Build tools on Java 9+
  id: totrans-1634
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java 9+上的构建工具
- en: I can’t speak for all build tools, but Maven and Gradle have already been updated
    to work properly with Java 9+ and the module system. The changes are largely internal,
    and creating modular JARs instead of plain JARs requires nothing more than adding
    a `module-info.java` to your source folder. They take it from there and mostly
    just do the right thing.
  id: totrans-1635
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我不能代表所有构建工具，但 Maven 和 Gradle 已经更新以正确地与 Java 9+ 和模块系统协同工作。这些更改主要是内部的，创建模块 JAR
    而不是普通 JAR 只需要在您的源文件夹中添加一个 `module-info.java` 文件。它们从那里开始，大部分只是做正确的事情。
- en: For details on how your build tool of choice interacts with the module system
    or other new Java features (like multi-release JARs—see appendix E), look at its
    documentation. One thing I want to mention explicitly is that you’ll likely have
    to add some command-line options when migrating to Java 9+, so you may want to
    brush up on how to do that.
  id: totrans-1636
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于您选择的构建工具如何与模块系统或其他新 Java 功能（如多版本 JAR——见附录 E）交互的详细信息，请查看其文档。我想明确提到的是，在迁移到 Java
    9+ 时，你可能需要添加一些命令行选项，所以你可能想复习一下如何做。
- en: If you want to learn more about Gradle, check out Manning’s very hands-on Gradle
    in Action (Benjamin Muschko, 2014, [www.manning.com/books/gradle-in-action](http://www.manning.com/books/gradle-in-action)).
    Unfortunately, I can’t recommend any book on Maven that I’ve had the chance to
    at least flip through.
  id: totrans-1637
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 Gradle 的信息，可以查看 Manning 的非常实用的《Gradle in Action》（Benjamin Muschko，2014，[www.manning.com/books/gradle-in-action](http://www.manning.com/books/gradle-in-action)）。不幸的是，我没有推荐任何一本我至少翻阅过的
    Maven 书籍。
- en: DEPENDENCY MANAGEMENT
  id: totrans-1638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 依赖项管理
- en: 'Build systems usually perform another task, and now Java 9+ performs it, too:
    dependency management. As section 3.2 discusses, reliable configuration aims at
    making sure dependencies are present and unambiguous, so that the application
    becomes more stable—Maven or Gradle will do the same for you. Does that mean the
    module system replaces build tools? Or is it too late to the game, and these features
    are useless? On the surface, it seems as though the module system duplicates the
    build tools’ functionality; but when you look closer, you can see that the overlap
    is small.'
  id: totrans-1639
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构建系统通常执行另一个任务，现在 Java 9+ 也执行这个任务：依赖项管理。正如第 3.2 节所讨论的，可靠的配置旨在确保依赖项存在且无歧义，从而使应用程序更加稳定——Maven
    或 Gradle 会为您做同样的事情。这意味着模块系统取代了构建工具吗？或者，这些功能来得太晚了，变得无用？表面上，模块系统似乎重复了构建工具的功能；但当你仔细观察时，你会发现重叠很小。
- en: First, the module system has no way to uniquely identify or locate artifacts.
    Most notable is that it has no concept of versions, which means given a few different
    versions of the same artifact, it can’t pick the right one. This situation will
    result in an error precisely because it’s ambiguous.
  id: totrans-1640
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 首先，模块系统没有方法来唯一标识或定位工件。最值得注意的是，它没有版本的概念，这意味着给定几个相同工件的几个不同版本，它无法选择正确的版本。这种情况将导致错误，正是因为它是模糊的。
- en: And although many projects will choose a module name that has the chance to
    be unique (like reversing a domain name the project is associated with), there
    is no instance like Maven Central to ensure that, which makes the module name
    insufficient for uniquely identifying a dependency. Speaking of remote repositories
    like Maven Central, the module system has no capabilities to connect to them.
    So although both the module system and build tools manage dependencies, the former
    performs on a level that’s too abstract to replace the latter.
  id: totrans-1641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管许多项目会选择一个可能独特的模块名称（比如反转与项目关联的域名），但没有像 Maven Central 这样的实例来确保这一点，这使得模块名称不足以唯一地标识一个依赖项。说到像
    Maven Central 这样的远程仓库，模块系统没有连接到它们的任何能力。因此，尽管模块系统和构建工具都管理依赖项，但前者在过于抽象的层面上执行，无法取代后者。
- en: 'Build systems do have a considerable shortcoming, though: they ensure that
    dependencies are present during compilation and can even deliver them to your
    doorstep, but they don’t manage the application’s launch. If the tool is unaware
    of an indirectly required dependency (due to use of Maven’s `provided` or Gradle’s
    `compileOnly`), or a library gets lost on the way from build to launch, you’ll
    only find out at run time, most likely by a crashing application. The module system,
    on the other hand, manages direct and transitive dependencies not only at compile
    time but also at run time, ensuring reliable configuration across all phases.
    It’s also better equipped to detect ambiguities like duplicate artifacts or artifacts
    containing the same types. So even when you zoom in on dependency management,
    both technologies are different; the only overlap is that both list dependencies
    in some form.'
  id: totrans-1642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 构建系统确实存在一个相当大的缺点：它们确保在编译期间存在依赖项，甚至可以将它们送到你的门口，但它们并不管理应用程序的启动。如果工具不知道间接需要的依赖项（由于使用了
    Maven 的 `provided` 或 Gradle 的 `compileOnly`），或者库在构建到启动的过程中丢失，你只能在运行时发现，很可能是通过应用程序崩溃。另一方面，模块系统不仅管理编译时的直接和传递依赖项，还管理运行时的依赖项，确保所有阶段的可靠配置。它还更有能力检测诸如重复的工件或包含相同类型的工件之类的歧义。因此，即使你聚焦于依赖项管理，这两种技术也是不同的；唯一的交集是它们都以某种形式列出依赖项。
- en: ENCAPSULATION, SERVICES, AND LINKING
  id: totrans-1643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 封装、服务和链接
- en: Moving away from dependency management, we quickly find features of the module
    system that build tools can’t compete with. Most notable is strong encapsulation
    (see section 3.3), which enables libraries to hide implementation details from
    other code at compile time and run time—something Maven or Gradle can’t even dream
    of promising. This strictness will take a while to get used to, but in the long
    run, the JDK, frameworks, libraries, and even large applications will benefit
    from clearly distinguishing supported and internal APIs and making sure the latter
    aren’t accidentally relied on. In my opinion, strong encapsulation alone is worth
    the move to the module system.
  id: totrans-1644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 离开依赖项管理，我们很快就会找到构建工具无法竞争的模块系统功能。最值得注意的是强大的封装（见第 3.3 节），它使库能够在编译时和运行时隐藏实现细节，这是
    Maven 或 Gradle 甚至无法梦想承诺的。这种严格性需要一段时间才能习惯，但从长远来看，JDK、框架、库甚至大型应用程序都将从明确区分受支持和内部
    API 以及确保后者不会意外依赖中受益。在我看来，强大的封装本身就值得迁移到模块系统。
- en: Looking over the more-advanced features, two particularly interesting ones stand
    out as being beyond the build tools’ reach. First, the module system can operate
    as a service registry in the service locator pattern, allowing you to decouple
    artifacts and to implement applications that make it easy to use plugins (see
    chapter 10). Second is the ability to link desired modules into a self-contained
    runtime image, giving you the opportunity to make deployments slimmer and easier
    (see chapter 14).
  id: totrans-1645
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在查看更高级的功能时，有两个特别有趣的功能脱颖而出，它们超出了构建工具的范围。首先，模块系统可以作为服务定位模式中的服务注册表运行，允许你解耦工件，并实现易于使用插件的程序（见第
    10 章）。其次是能够将所需的模块链接到一个自包含的运行时映像中，这为你提供了使部署更精简和更容易的机会（见第 14 章）。
- en: In summary, except for a small overlap in dependency management, build tools
    and the module system don’t compete but should instead be seen as complementary.
    [Figure 15.4](part0030.html#filepos1933772) shows this relationship.
  id: totrans-1646
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 总结来说，除了在依赖项管理方面有微小重叠外，构建工具和模块系统并不竞争，而应该被视为互补。[图 15.4](part0030.html#filepos1933772)
    展示了这种关系。
- en: '![](../images/00023.jpeg)'
  id: totrans-1647
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00023.jpeg)'
- en: '[Figure 15.4](part0030.html#filepos1933429) Build tools (left) and the module
    system (right) have very different feature sets. The only similarities are that
    both record dependencies (build tools by globally unique identifiers plus versions;
    the JPMS just by module names) and can verify them for compilation. Their handling
    of dependencies is very different, and beyond that they have virtually nothing
    in common.'
  id: totrans-1648
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 15.4](part0030.html#filepos1933429) 建筑工具（左）和模块系统（右）具有非常不同的功能集。唯一的相似之处是它们都记录依赖项（构建工具通过全局唯一标识符加上版本；JPMS
    只通过模块名称）并且可以验证它们以进行编译。它们对依赖项的处理非常不同，除此之外，它们几乎没有任何共同之处。'
- en: 15.3.2 OSGI
  id: totrans-1649
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 15.3.2 OSGI
- en: The Open Service Gateway initiative (OSGi) is shorthand for both an organization
    (the OSGi Alliance) and the specification it creates. It’s also somewhat imprecisely
    applied to the different implementations of that specification, which is how I
    use it in this section.
  id: totrans-1650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 开放服务网关倡议（OSGi）是既指一个组织（OSGi 联盟）又指它创建的规范。它也被不精确地应用于该规范的各个实现，这就是我在本节中使用的用法。
- en: OSGi is a module system and service platform on top of the Java Virtual Machine
    that shares parts of its feature set with the JPMS. If you know a few things about
    OSGi or have been using it, you may wonder how it compares to Java’s new module
    system, and maybe whether it’s replaced by it. But you may also wonder why the
    latter was even developed—couldn’t Java just use OSGi?
  id: totrans-1651
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: OSGi 是建立在 Java 虚拟机之上的模块系统和平台，它与 JPMS 共享部分功能集。如果你对 OSGi 知之甚少或者一直在使用它，你可能想知道它与
    Java 的新模块系统如何比较，也许还会想知道它是否被取代了。但你可能也会想知道为什么后者甚至被开发出来——Java 为什么不能直接使用 OSGi？
- en: NOTE This section may be a little tough if you only know OSGi by hearsay—that’s
    not a problem, because this isn’t required reading. If you still want to follow
    along, start by imagining that OSGi is similar to the module system. The rest
    of this section will then shine light on some of the important differences.
  id: totrans-1652
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：如果你只是听说 OSGi 而不是真正了解它，本节可能有点难懂——这不是问题，因为这不是必读内容。如果你仍然想跟上来，首先想象一下 OSGi 类似于模块系统。本节的其余部分将阐明一些重要差异。
- en: I’m not an OSGi expert, but during my research I paged through Manning’s OSGi
    in Depth and liked it (Alexandre de Castro Alves, 2011, [www.manning.com/books/osgi-in-depth](http://www.manning.com/books/osgi-in-depth)).
    Consider turning to it if you need more than the Java Platform Module System can
    offer you.
  id: totrans-1653
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我不是 OSGi 专家，但在我的研究过程中，我翻阅了《OSGi 深入解析》（Alexandre de Castro Alves，2011，[www.manning.com/books/osgi-in-depth](http://www.manning.com/books/osgi-in-depth)），并且很喜欢它。如果你需要比
    Java 平台模块系统提供的内容更多，可以考虑转向它。
- en: WHY DOESN’T THE JDK USE OSGI?
  id: totrans-1654
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么 JDK 不使用 OSGi？
- en: Why doesn’t the JDK use OSGi? The technical answer to this question comes down
    to the way OSGi implements its feature set. It heavily leans on class loaders,
    which we briefly discussed in sections 1.2 and 1.3.4, and of which OSGi creates
    its own implementations. It uses one class loader per bundle (modules are called
    bundles in OSGi) and in this way controls, for example, which classes a bundle
    can see (to implement encapsulation) or what happens when a bundle is unloaded
    (which OSGi allows—more on that later).
  id: totrans-1655
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为什么 JDK 不使用 OSGi？对这个问题的技术答案归结于 OSGi 实现其功能集的方式。它严重依赖于类加载器，这在 1.2 和 1.3.4 节中进行了简要讨论，而
    OSGi 为其创建了自身的实现。它为每个包（在 OSGi 中模块被称为包）使用一个类加载器，并且以这种方式控制，例如，一个包可以看到哪些类（以实现封装）或者当包被卸载时会发生什么（OSGi
    允许的——稍后会有更多介绍）。
- en: What may seem like a technical detail has far-reaching consequences. Before
    the JPMS, Java placed no limitations on the use of class loaders, and using the
    reflection API to access classes by name was common practice.
  id: totrans-1656
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可能看似技术细节的事情有着深远的影响。在 JPMS 之前，Java 对类加载器的使用没有限制，并且通过反射 API 按名称访问类是常见的做法。
- en: If the JPMS required a specific class-loader architecture, Java 9+ would drastically
    break the JDK, many existing libraries and frameworks, and critical application
    code. Java 9+ still poses migration challenges, but incompatibly changing the
    class-loader API would be even more disruptive and not replace these challenges
    but come on top of them. As a consequence, the JPMS operates below class loaders,
    as shown in [figure 15.5](part0030.html#filepos1938791).
  id: totrans-1657
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 JPMS 需要特定的类加载器架构，Java 9+ 将会极大地破坏 JDK、许多现有的库和框架以及关键的应用代码。Java 9+ 仍然存在迁移挑战，但如果不兼容地更改类加载器
    API 将会更具破坏性，并且不仅会取代这些挑战，还会在它们之上。因此，JPMS 在类加载器之下运行，如图 15.5 所示 [figure 15.5](part0030.html#filepos1938791)。
- en: '![](../images/00052.jpeg)'
  id: totrans-1658
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![图片](../images/00052.jpeg)'
- en: '[Figure 15.5](part0030.html#filepos1938479) OSGi (left) is built on top of
    the JVM, which forced it to use existing functionality, mainly the class-loading
    infrastructure, to implement its feature set. The module system (right), on the
    other hand, was implemented within the JVM and operates below class loading, keeping
    systems built on top of it working as before.'
  id: totrans-1659
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图 15.5](part0030.html#filepos1938479) OSGi（左侧）建立在 JVM 之上，这迫使其使用现有功能，主要是类加载基础设施，以实现其功能集。另一方面，模块系统（右侧）是在
    JVM 内部实现的，并且运行在类加载之下，保持其上构建的系统按原样工作。'
- en: Another consequence of using class loaders for module isolation is that although
    OSGi uses them to reduce the visibility of classes, they can’t reduce accessibility.
    What do I mean by that? Say a bundle lib contains a type `Feature` from a package
    that isn’t exported. Then OSGi makes sure code in another bundle app can’t “see”
    `Feature`, meaning, for example, that `Class.forName("org.lib.Feature")` will
    throw a `ClassNotFoundException`. (`Feature` isn’t visible.)
  id: totrans-1660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用类加载器进行模块隔离的另一个后果是，尽管OSGi使用它们来减少类的可见性，但它们不能减少可访问性。我这是什么意思呢？比如说，一个包含来自未导出包的`Feature`类型的库包。那么OSGi确保另一个包中的代码不能“看到”`Feature`，也就是说，例如，`Class.forName("org.lib.Feature")`将抛出`ClassNotFoundException`。(`Feature`是不可见的。)
- en: But now assume lib has an API that returns a `Feature` as an `Object`, in which
    case app can get an instance of the class. Then app can call `featureObject.getClass().newInstance()`
    and create a new `Feature` instance. (`Feature` is accessible.)
  id: totrans-1661
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但现在假设lib有一个返回`Feature`类型的`Object`的API，在这种情况下，app可以获取该类的实例。然后app可以调用`featureObject.getClass().newInstance()`并创建一个新的`Feature`实例。(`Feature`是可访问的。)
- en: As discussed in section 3.3, the JPMS wants to ensure strong encapsulation,
    and what OSGi has to offer isn’t strong enough. If you create a situation like
    earlier, with two JPMS modules app and lib and a type `Feature` that lib contains
    but doesn’t export, app can successfully get a class instance with `Class.forName("org.lib.Feature")`
    (it’s visible) but can’t call `newInstance()` on it (it isn’t accessible). [Table
    15.1](part0030.html#filepos1943350) juxtaposes the differences of OSGi and JPMS.
  id: totrans-1662
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如第3.3节所述，JPMS想要确保强封装，而OSGi提供的并不足够强大。如果你创建了一个类似早先的情况，有两个JPMS模块app和lib以及lib包含但未导出的类型`Feature`，app可以成功通过`Class.forName("org.lib.Feature")`获取类实例（它是可见的），但不能调用其上的`newInstance()`（它不可访问）。[表15.1](part0030.html#filepos1943350)并列了OSGi和JPMS的差异。
- en: Table 15.1 OSGI’s visibility and JPMS’s accessibility limitations
  id: totrans-1663
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表15.1 OSGI的可见性和JPMS的可访问性限制
- en: '|    | OSGi   | JPMS   |'
  id: totrans-1664
  prefs: []
  type: TYPE_TB
  zh: '|    | OSGi   | JPMS   |'
- en: '| Limits visibility (`Class::forName` fails)   | ✔   | ✘   |'
  id: totrans-1665
  prefs: []
  type: TYPE_TB
  zh: '| 限制可见性（`Class::forName`失败）   | ✔   | ✘   |'
- en: '| Limits accessibility (`Class::newInstance` fails)   | ✘   | ✔   |'
  id: totrans-1666
  prefs: []
  type: TYPE_TB
  zh: '| 限制可访问性（`Class::newInstance`失败）   | ✘   | ✔   |'
- en: CAN THE JPMS REPLACE OSGI?
  id: totrans-1667
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JPMS能否取代OSGi？
- en: Can the JPMS replace OSGi? No.
  id: totrans-1668
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JPMS能否取代OSGi？不能。
- en: The JPMS was primarily developed to modularize the JDK. It covers all the modularity
    basics—some of them, like encapsulation, arguably better than OSGi—but OSGi has
    a lot of features the JPMS doesn’t need and thus doesn’t have.
  id: totrans-1669
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JPMS主要是为了模块化JDK而开发的。它涵盖了所有模块化的基本要素——其中一些，比如封装，可能比OSGi做得更好——但OSGi有很多JPMS不需要且没有的特性。
- en: To name a few, with OSGi, due to its class-loader strategy, you can have the
    same fully qualified type in several bundles. This also makes it possible to run
    different versions of the same bundle at the same time. In that vein, with OSGi,
    exports and imports can be versioned, letting bundles express what version they
    are and which versions their dependencies should be. If the same bundle is required
    in two different versions, OSGi can make that work.
  id: totrans-1670
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以几个为例，在OSGi中，由于其类加载器策略，你可以在几个包中拥有相同的完全限定类型。这也使得同时运行同一包的不同版本成为可能。在这方面，OSGi的导出和导入可以是版本化的，允许包表达它们的版本以及它们的依赖应该是什么版本。如果需要同一包的两个不同版本，OSGi可以使这成为可能。
- en: Another interesting difference is that in OSGi, a bundle usually expresses dependencies
    on packages instead of bundles. Although both are possible, the former is the
    default. This makes dependencies more robust with regard to replacing or refactoring
    bundles, because it doesn’t matter where a package comes from. (In the JPMS, on
    the other hand, a package must be in one of the required modules, so moving a
    package into another module or exchanging one module for another with the same
    API will cause problems.)
  id: totrans-1671
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个有趣的不同之处在于，在OSGi中，一个包通常表达对包的依赖，而不是对包的依赖。尽管两者都是可能的，但前者是默认的。这使得依赖性在替换或重构包时更加稳健，因为包的来源并不重要。（另一方面，在JPMS中，一个包必须位于所需的模块之一，所以将包移动到另一个模块或用具有相同API的另一个模块交换将导致问题。）
- en: A big feature set of OSGi revolves around dynamic behavior, where its roots
    as an Internet of Things service gateway clearly show and where the implementation
    via class loaders enables powerful capabilities. OSGi allows bundles to appear,
    disappear, and even be updated at run time, exposing an API that lets dependencies
    react accordingly. This is great for applications running across multiple devices
    but can also come in handy for single-server systems that want to reduce downtime
    to a minimum.
  id: totrans-1672
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: OSGi的一大特性集围绕着动态行为，其作为物联网服务网关的根源明显，通过类加载器实现的功能也非常强大。OSGi允许包在运行时出现、消失，甚至更新，提供了一个API，让依赖项相应地做出反应。这对于跨多台设备运行的应用程序来说非常好，也可以为希望将停机时间减少到最低限度的单服务器系统提供便利。
- en: The bottom line is that if your project is already using OSGi, chances are high
    that you’re relying on features the JPMS doesn’t have. In that case, there’s no
    reason to switch to Java’s native module system.
  id: totrans-1673
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 核心问题是，如果你的项目已经使用OSGi，那么你很可能依赖于JPMS没有的特性。在这种情况下，没有必要切换到Java的本地模块系统。
- en: DOES OSGI OBVIATE THE JPMS?
  id: totrans-1674
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: OSGi取代了JPMS吗？
- en: Does OSGi obviate the JPMS? No.
  id: totrans-1675
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: OSGi取代了JPMS吗？不。
- en: Although what I just presented sounds a lot like OSGi is better than the JPMS
    for every use case, OSGi has never seen wide adoption. It has carved out a niche
    and is successful in it, but it has never become a default technology (unlike
    IDEs, build tools, and logging, to name a few examples).
  id: totrans-1676
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管我刚才提出的听起来OSGi在所有用例上都优于JPMS，但OSGi从未得到广泛采用。它已经占据了一个细分市场，并在其中取得了成功，但它从未成为默认技术（与IDE、构建工具和日志记录等相比，仅举几个例子）。
- en: The main reason for that lack of wide adoption is complexity. Whether it’s perceived
    or real, whether it’s inherent to modularity or accidental to OSGi, is secondary
    to the fact that the majority of developers see OSGi’s complexity as a reason
    not to use it by default.
  id: totrans-1677
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 那种缺乏广泛采用的主要原因在于复杂性。无论是感知到的还是真实的，无论是模块化固有的还是OSGi偶然的，这都次要于大多数开发者将OSGi的复杂性视为不默认使用它的理由这一事实。
- en: The JPMS is in a different position. First, its reduced feature set (particularly,
    no version support, and dependencies on modules, not packages) makes it less complex.
    In addition, it benefits from being built into the JDK. All Java developers are
    exposed to the JPMS to some degree, and more senior developers in particular will
    explore how it can help them with their projects. This more intense use will also
    spur good tool integration.
  id: totrans-1678
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JPMS处于不同的位置。首先，其减少的特性集（尤其是没有版本支持，以及依赖于模块而不是包）使其更简单。此外，它得益于内置在JDK中。所有Java开发者都程度不同地接触到了JPMS，尤其是更资深的一些开发者会探索它如何帮助他们的项目。这种更频繁的使用也将促进良好的工具集成。
- en: So if a team already has the skills and tools and is already running on top
    of the JPMS, why not go all the way and modularize the entire application? This
    step builds on existing knowledge, incurs less additional complexity, and requires
    no new tools, while giving a lot of benefits.
  id: totrans-1679
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，如果一个团队已经拥有技能和工具，并且已经在JPMS上运行，为什么不彻底模块化整个应用程序呢？这一步骤建立在现有知识的基础上，增加了更少的复杂性，不需要新的工具，同时带来很多好处。
- en: In the end, even OSGi stands to profit from the JPMS, because Java 9+ will put
    modularity on the map much as Java 8 did with functional programming. Both releases
    are exposing mainstream Java developers to new ideas and are teaching them an
    entirely new skill set. At some point, when a project stands to benefit from functional
    programming or more powerful modularity, its developers climb enough of the learning
    curve to evaluate and maybe use “the real thing.”
  id: totrans-1680
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，即使是OSGi也能从JPMS中获益，因为Java 9+将模块化提升到与Java 8将函数式编程提升到相同的地位。这两个版本都在向主流Java开发者展示新思想，并教会他们一套全新的技能。在某个时刻，当项目有望从函数式编程或更强大的模块化中获益时，其开发者将足够爬上学习曲线，以评估并可能使用“真正的”技术。
- en: ARE JPMS AND OSGI COMPATIBLE?
  id: totrans-1681
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JPMS和OSGi兼容吗？
- en: Are JPMS and OSGi compatible? In a sense, yes. Applications developed with OSGi
    can run on top of Java 9+ just as they did on earlier versions. (To be more precise,
    they will run in the unnamed module, which section 8.2 explains in detail.) OSGi
    incurs no migration efforts, but the application code faces the same challenges
    as other code bases.
  id: totrans-1682
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JPMS和OSGi兼容吗？在某种程度上，是的。使用OSGi开发的应用程序可以在Java 9+上运行，就像在早期版本上一样。（更准确地说，它们将在未命名的模块中运行，第8.2节详细解释了这一点。）OSGi不需要进行迁移工作，但应用程序代码面临与其他代码库相同的挑战。
- en: In another sense, the verdict isn’t in yet. Whether OSGi will allow us to map
    bundles to JPMS modules is still an open question. For now, OSGi uses no capabilities
    of the JPMS and continues to implement its features itself. It’s also not clear
    whether adapting OSGi to the JPMS would be worth the considerable engineering
    cost.
  id: totrans-1683
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在另一个意义上，结论尚未明朗。OSGi是否会允许我们将包映射到JPMS模块，这仍然是一个悬而未决的问题。目前，OSGi不使用JPMS的任何功能，继续自行实现其功能。是否将OSGi适应JPMS值得相当大的工程成本，这也不清楚。
- en: 15.3.3 MICROSERVICES
  id: totrans-1684
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 15.3.3 微服务
- en: 'The relationship between the module system and microservices architecture has
    two very different aspects:'
  id: totrans-1685
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 模块化系统与微服务架构之间的关系有两个非常不同的方面：
- en: Are microservices and the module system in competition? How do they compare?
  id: totrans-1686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务与模块化系统是否竞争？它们是如何比较的？
- en: Does the module system concern you if you go with microservices?
  id: totrans-1687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你选择微服务，模块化系统会令你担忧吗？
- en: We’ll look at both in this section.
  id: totrans-1688
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将在本节中探讨这两个方面。
- en: If you’re not familiar with the microservices architecture, you can safely skip
    this section. If you want to learn more, there are tons of great microservice
    books out there. To back up my claims, I skimmed Manning’s Microservices in Action
    and can recommend it (Morgan Bruce and Paulo A. Pereira, 2018, [www.manning.com/books/microservices-in-action](http://www.manning.com/books/microservices-in-action)).
  id: totrans-1689
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你不太熟悉微服务架构，你可以安全地跳过这一节。如果你想了解更多，市面上有很多优秀的微服务书籍。为了支持我的观点，我浏览了Manning的《Microservices
    in Action》一书，并推荐它（Morgan Bruce和Paulo A. Pereira，2018年，[www.manning.com/books/microservices-in-action](http://www.manning.com/books/microservices-in-action)）。
- en: MICROSERVICES VS. THE JPMS
  id: totrans-1690
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 微服务与JPMS的比较
- en: In general, it’s fair to say that the module system’s benefits have a larger
    effect, the bigger the project is. So when everybody is talking about microservices,
    isn’t a module system for large applications the proverbial lipstick on a pig?
    The answer depends on how many projects will end up being structured as microservices,
    and that is, of course, a huge discussion in itself.
  id: totrans-1691
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通常来说，可以说模块化系统的优势在更大的项目中影响更大。所以当大家都在谈论微服务时，大型应用程序的模块化系统不就像是猪身上的口红吗？答案取决于最终有多少项目会被构建成微服务结构，这当然是一个巨大的讨论话题。
- en: Some believe microservices are the future and sooner or later all projects will
    start out that way—it’s all microservices! If you’re in that camp, you may still
    implement your services in Java 9+, and the module system will affect you, but,
    of course, much less than it affects monolithic projects. We’ll discuss that in
    the next section.
  id: totrans-1692
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有些人认为微服务是未来，迟早所有项目都会以这种方式开始——全是微服务！如果你属于这个阵营，你仍然可以在Java 9+中实现你的服务，模块化系统会对你产生影响，但当然，比它对单体项目的影响小得多。我们将在下一节中讨论这一点。
- en: Others have a more cautious opinion. Like all architecture styles, microservices
    have both advantages and disadvantages, and a trade-off must be made between them
    with the project’s requirements in mind. Microservices shine particularly brightly
    in rather complex projects that have to sustain high loads, where their ability
    to scale is almost unrivaled.
  id: totrans-1693
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一些人持更加谨慎的观点。像所有架构风格一样，微服务既有优点也有缺点，必须根据项目需求在这两者之间做出权衡。微服务在需要承受高负载的相对复杂的项目中特别闪耀，其扩展能力几乎无与伦比。
- en: This scalability is paid for with operational complexity, though, because running
    a multitude of services requires much more knowledge and infrastructure than putting
    a handful of instances of the same service behind a load balancer. Another drawback
    is that getting service boundaries wrong, which is more likely the less the team
    knows about the domain, is more expensive to fix in microservices than in a monolith.
  id: totrans-1694
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然这种可扩展性是以操作复杂性为代价的，因为运行众多服务需要比在负载均衡器后面放置相同服务的一小批实例更多的知识和基础设施。另一个缺点是，如果团队对领域的了解越少，服务边界错误的可能性就越大，在微服务中修复这种错误比在单体中更昂贵。
- en: The critical observation is that the price for the complexity (Martin Fowler
    calls it the microservices premium) must always be paid, but the benefits are
    only reaped once a project is large enough. This factor has convinced many developers
    and architects that most projects should start as a monolith and move toward splitting
    off services, maybe eventually ending in microservices, once circumstances require
    it.
  id: totrans-1695
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关键的观察结果是，对于复杂性（马丁·福勒称之为微服务溢价）的代价必须始终付出，但只有在项目足够大时才能获得收益。这个因素已经说服了许多开发人员和架构师，大多数项目应该从单体开始，并逐渐转向拆分服务，也许最终在需要时结束在微服务中。
- en: 'Martin Fowler, for examples, relates the following opinions of his colleagues
    (in [https://martinfowler.com/bliki/MonolithFirst.html](https://martinfowler.com/bliki/MonolithFirst.html);
    emphasis mine):'
  id: totrans-1696
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 例如，马丁·福勒（Martin Fowler）引用了他同事的以下观点（在[https://martinfowler.com/bliki/MonolithFirst.html](https://martinfowler.com/bliki/MonolithFirst.html)；强调是我的）：
- en: You shouldn’t start a new project with microservices, even if you’re sure your
    application will be big enough to make it worthwhile. […] The logical way is to
    design a monolith carefully, paying attention to modularity within the software,
    both at the API boundaries and how the data is stored. Do this well, and it’s
    a relatively simple matter to make the shift to microservices.
  id: totrans-1697
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你不应该一开始就使用微服务来启动一个新项目，即使你确信你的应用程序足够大，足以使其变得值得。 [...] 合理的做法是仔细设计单体架构，注意软件内部的模块化，包括API边界和数据存储方式。做好这一点，转向微服务就相对简单了。
- en: 'By now, the emphasized phrases should be familiar: careful design, modularity,
    boundaries—these are all properties that the module system promotes (see section
    1.5). In a microservice architecture, service dependencies should be clear (cue
    reliable configuration) and ideally decoupled (service loader API); furthermore,
    all requests must go through public APIs (strong encapsulation). Carefully using
    the module system can lay the groundwork for a successful migration to microservices
    if and when the time for that comes. [Figure 15.6](part0030.html#filepos1960667)
    shows the importance of this careful design.'
  id: totrans-1698
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 到现在为止，强调的短语应该已经熟悉了：仔细设计、模块化、边界——这些都是模块系统所促进的特性（参见第1.5节）。在微服务架构中，服务依赖关系应该是清晰的（提示可靠配置）并且理想情况下是解耦的（服务加载器API）；此外，所有请求都必须通过公共API（强封装）。如果需要，仔细使用模块系统可以为成功迁移到微服务奠定基础。[图15.6](part0030.html#filepos1960667)显示了这种仔细设计的重要性。
- en: '![](../images/00117.jpeg)'
  id: totrans-1699
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/00117.jpeg)'
- en: '[Figure 15.6](part0030.html#filepos1960311) Given two hypothetical migrations
    of a monolithic application to microservices, would you rather start with a sizable
    square of mud (left) or a properly modularized code base (right)?'
  id: totrans-1700
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[图15.6](part0030.html#filepos1960311) 假设有两个将单体应用程序迁移到微服务的假设情况，你更愿意从一个大块的泥地（左侧）开始，还是从一个正确模块化的代码库（右侧）开始？'
- en: Notwithstanding the module system’s focus on larger projects, even small services
    can benefit from embracing modules.
  id: totrans-1701
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管模块系统侧重于大型项目，但即使是小型服务也能从采用模块中受益。
- en: MICROSERVICES WITH THE JPMS
  id: totrans-1702
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用JPMS的微服务
- en: If your project went with microservices and you’re implementing some of them
    on top of Java 9+ because you want to benefit from improved security and performance,
    you’ll necessarily interact with the module system because it’s operating within
    the JVM that’s running your code. One consequence is that the potentially breaking
    changes discussed in chapters 6 and 7 still apply to the services in question
    and need to be mended. It’s also likely that most of your dependencies will be
    turned into modules over time, but as section 8.1.3 describes, that doesn’t force
    you to package your artifacts as modules.
  id: totrans-1703
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你的项目采用了微服务，并且你正在使用Java 9+实现其中的一些服务，因为你希望从改进的安全性和性能中受益，你必然会与模块系统交互，因为它是运行你的代码的JVM的一部分。一个后果是，第6章和第7章中讨论的潜在破坏性更改仍然适用于相关服务，需要修复。此外，随着时间的推移，你的大部分依赖项很可能会转换为模块，但正如第8.1.3节所描述的，这并不强迫你将你的工件打包为模块。
- en: If you decide to keep all JARs on the class path, strong encapsulation isn’t
    enforced between them. So within that set of JARs, access to internal APIs as
    well as reflection, for example from frameworks into your code, will continue
    to work. In this scenario, your exposure to the module system is limited to the
    changes it had on the JDK.
  id: totrans-1704
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你决定将所有JAR文件放在类路径上，它们之间不会强制执行强封装。因此，在这个JAR文件集中，对内部API的访问以及反射（例如从框架到你的代码），例如，将继续工作。在这种情况下，你对模块系统的接触仅限于它对JDK的影响。
- en: The other route you could take would be to use your services and dependencies
    as modules, at which point you’d be fully integrated into the module system. Of
    its various benefits, the most relevant may end up being the scalable platform
    briefly described in section 1.5.5 and thoroughly explored in chapter 14, which
    allows you to use `jlink`.
  id: totrans-1705
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以采取的另一条路线是使用你的服务和依赖项作为模块，这时你将完全集成到模块系统中。其各种好处中，最相关的一个可能是第1.5.5节中简要描述并在第14章中彻底探讨的可扩展平台，它允许你使用`jlink`。
- en: 'With `jlink`, you can create a small runtime image with just the right set
    of platform modules to support your application, including your modules, which
    can cut image size by up to 80%. Furthermore, when linking the required modules
    together, `jlink` can analyze the bytecode with the knowledge that it sees the
    entire application and can thus apply more aggressive optimizations, leading to
    even smaller image sizes and slightly improved performance. You also get other
    benefits: for example, being sure you only use your dependencies’ public APIs.'
  id: totrans-1706
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用`jlink`，你可以创建一个包含恰好支持你的应用程序（包括你的模块）的平台模块的小型运行时映像，这可以减少映像大小高达80%。此外，当链接所需的模块时，`jlink`可以利用它看到整个应用程序的知识来分析字节码，从而应用更激进的优化，导致映像尺寸更小，性能略有提升。你还可以获得其他好处：例如，确保你只使用依赖项的公共API。
- en: 15.4 Thoughts on a modular ecosystem
  id: totrans-1707
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 15.4 关于模块化生态系统的思考
- en: Java 9+ is a massive release. Although lacking in new language features, it
    packs a lot of powerful improvements and additions. But all of those improvements
    are eclipsed by the Java Platform Module System. It’s easily both the most anticipated
    and the most contentious feature of Java 9+, not least because of the migration
    challenges it causes.
  id: totrans-1708
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Java 9+是一个巨大的版本。尽管缺乏新的语言特性，但它包含了大量强大的改进和新增功能。但所有这些改进都被Java平台模块系统所掩盖。它既是Java
    9+最受期待的功能，也是最具争议的功能，这不仅仅是因为它带来的迁移挑战。
- en: Despite the sometimes-rocky start on the way to the modular future, well-known
    libraries and frameworks were quick to support Java 9+, and since then there’s
    been no sign of that trend slowing down. What about older, less-well-supported
    projects? Although some may find new maintainers, even if just to get them to
    work on a current Java release, the long tail of Java projects may thin out.
  id: totrans-1709
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管在迈向模块化未来的道路上有时会遇到一些波折，但知名库和框架迅速支持了Java 9+，并且自那时起，这一趋势并没有放缓的迹象。那么，对于较老、支持度较低的项目呢？尽管有些人可能会找到新的维护者，即使只是为了让他们在当前的Java版本上工作，但Java项目的长尾可能会逐渐减少。
- en: That will surely disgruntle some developers whose code bases depend on such
    projects. That’s understandable—nobody likes having to change working code without
    apparent benefit. At the same time, the exodus of some incumbents will give other
    projects the chance to sweep up their users. And who knows? Maybe they’ll see
    a benefit from switching after all.
  id: totrans-1710
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这肯定会令一些依赖此类项目的开发者感到不满。这是可以理解的——没有人喜欢在没有明显好处的情况下修改正在工作的代码。同时，一些既得利益者的流失将给其他项目带来机会，让他们吸引他们的用户。而且谁知道呢？他们最终可能会从转换中获得好处。
- en: Once the big wave of upgrading to Java 9+ is behind us and projects start raising
    their baseline to Java 9+, you’ll begin to see more and more modular JARs being
    publicly available. Thanks to the module system’s support for incremental and
    decentralized modularization, this process requires comparatively little coordination
    between projects. It also gives you the opportunity to start modularizing your
    project right now.
  id: totrans-1711
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦Java 9+的升级大潮过去，项目开始将基准提升到Java 9+，你将开始看到越来越多的模块化JAR文件公开可用。多亏了模块化系统对增量化和去中心化模块化的支持，这个过程在项目之间需要相对较少的协调。这也给你提供了一个机会，让你现在就可以开始模块化你的项目。
- en: To what end? Unlike more flashy features like lambda expressions and streams
    in Java 8 or local variable type inference in Java 10, the module system’s effect
    on your code base will be subtle. You won’t be able to look at a few lines of
    code and be content with its beauty. You won’t notice suddenly that you’re having
    more fun when coding.
  id: totrans-1712
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 目的是什么？与Java 8中的lambda表达式和流或Java 10中的局部变量类型推断等更吸引眼球的特性相比，模块化系统对你的代码库的影响将是微妙的。你不会仅仅通过查看几行代码就对其美感感到满意。你也不会突然发现自己在编码时更有乐趣。
- en: No, the module system’s benefits are on the other end of the spectrum. You’ll
    catch more errors early due to reliable configuration. You’ll avoid missteps due
    to having better insight into your project architecture. You won’t so readily
    entangle your code, and you won’t accidentally depend on your dependencies’ internals.
  id: totrans-1713
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不，模块化系统的优势在光谱的另一端。由于可靠的配置，你将能够更早地捕捉到错误。由于对项目架构有更深入的了解，你将避免误操作。你不会那么容易地使代码变得复杂，也不会意外地依赖于依赖项的内部实现。
- en: 'It’s the moody parts of software development that the JPMS will improve. The
    module system is no panacea: you still have to put in the hard work to properly
    design and arrange your artifacts; but with the module system on hand, this effort
    will have fewer pitfalls and more shortcuts along the way.'
  id: totrans-1714
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JPMS 将会改善软件开发中那些情绪化的部分。模块化系统并非万能良药：你仍然需要付出辛勤的努力来正确设计和安排你的工件；但有了模块化系统在手，这个过程将会有更少的陷阱和更多的捷径。
- en: As more and more of the ecosystem’s artifacts become modular, this effect will
    only get stronger, until one day we’ll ask ourselves how we ever coded without
    the module system. What was it like, back in the day when the JVM turned our carefully
    designed dependency graph into a ball of mud?
  id: totrans-1715
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 随着生态系统中的工件越来越多地采用模块化，这种效果将会越来越明显，直到有一天我们会问自己，没有模块化系统我们是如何编码的？在 JVM 将我们精心设计的依赖图变成一团糟的那个时代，那会是什么样子？
- en: It will feel strange, thinking back. As strange as writing a Java class without
    `private`. Can you imagine what that would be like?
  id: totrans-1716
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 回想起来会感觉有些奇怪。就像写一个没有 `private` 的 Java 类一样奇怪。你能想象那会是什么样子吗？
- en: Summary
  id: totrans-1717
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 摘要
- en: Design your module system carefully.
  id: totrans-1718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细设计你的模块化系统。
- en: Microservices and the JPMS complement each other.
  id: totrans-1719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务与 JPMS 相互补充。
- en: OSGi and the JPMS also complement each other.
  id: totrans-1720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OSGi 和 JPMS 也相互补充。
- en: And now—thank you very much for reading this book. It was a pleasure to write
    for you. I’m sure we’ll see each other again!
  id: totrans-1721
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在——非常感谢您阅读这本书。为您写作是一种乐趣。我相信我们还会再见面的！
