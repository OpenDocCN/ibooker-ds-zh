- en: 17 Traversable and stacked monads
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17 可穿越和堆叠的单子
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: 'Traversables: handling lists of elevated types'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可穿越的：处理升序类型列表
- en: Combining the effects of different monads
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合不同单子的效果
- en: 'So far in the book you’ve seen a number of different containers that add some
    effect to the underlying value(s)—`Option` for optionality, `IEnumerable` for
    aggregation, `Task` for asynchrony, and so on. As our list of containers keeps
    growing, we’ll inevitably hit the problem of combining different containers:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，你已经看到了许多不同的容器，它们为底层值添加了一些效果——`Option` 用于可选性，`IEnumerable` 用于聚合，`Task`
    用于异步，等等。随着我们的容器列表不断增长，我们不可避免地会遇到组合不同容器的问题：
- en: If you have a list of `Task`s that you want to execute, how can you combine
    them into a single `Task` that will complete when all the operations have completed?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有一个想要执行的 `Task` 列表，你如何将它们组合成一个在所有操作完成后完成的单个 `Task`？
- en: If you have a value of type `Task<Validation<T>>`, how do you compose it with
    a function of type `T` `→` `Task<R>` with the least amount of noise?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有一个 `Task<Validation<T>>` 类型的值，你如何用类型为 `T` `→` `Task<R>` 的函数以最少的噪音来组合它？
- en: This chapter will give you the tools to combine the effects of different containers
    and show how to avoid an excess of nested containers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为你提供组合不同容器效果的工具，并展示如何避免过多的嵌套容器。
- en: '17.1 Traversables: Working with lists of elevated values'
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.1 可穿越的：处理升序值列表
- en: '`Traverse` is one of the slightly more esoteric core functions in FP, and it
    allows you to work with lists of elevated values. It’s probably easiest to approach
    through an example.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`Traverse` 是 FP 中稍微有些神秘的核函数之一，它允许你处理升序值列表。通过一个例子来接近它可能最容易。'
- en: 'Imagine a simple command-line application that reads a comma-separated list
    of numbers entered by the user and returns the sum of all the given numbers. We
    could start along these lines:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个简单的命令行应用程序，它读取用户输入的以逗号分隔的数字列表，并返回所有给定数字的总和。我们可以从这里开始：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Exposes an `Option`-returning function for parsing a `double`
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 提供了一个返回 `Option` 的函数来解析 `double`
- en: ❷ Exposes a static `Trim` function
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 提供了一个静态的 `Trim` 函数
- en: We split the input string to get an array of strings and remove any whitespace
    with `Trim`. We can then map onto this list the parsing function `Double.Parse`,
    which has the signature `string` `→` `Option<double>`. As a result, we get an
    `IEnumerable<Option<double>>`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将输入字符串分割成字符串数组，并使用 `Trim` 移除任何空白。然后我们可以将解析函数 `Double.Parse` 映射到这个列表上，该函数的签名是
    `string` `→` `Option<double>`。结果，我们得到一个 `IEnumerable<Option<double>>`。
- en: Instead, what we really want is an `Option<IEnumerable<double>>`, which should
    be `None` if *any* of the numbers failed to parse. In this case, we can warn the
    user to correct their input.[¹](#pgfId-1157845) We saw that `Map` yields a type
    where the effects are stacked up in the opposite order than the one we need.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 而实际上，我们真正想要的是一个 `Option<IEnumerable<double>>`，如果 *任何* 数字解析失败，它应该是 `None`。在这种情况下，我们可以警告用户更正他们的输入。[¹](#pgfId-1157845)
    我们看到 `Map` 产生了一个类型，其效果是按照与我们需要的相反的顺序堆叠的。
- en: This is a common enough scenario that there’s a specific function called `Traverse`
    to address it, and a type for which `Traverse` is defined is called a *traversable*.
    Figure 17.1 shows the relationship between `Map` and `Traverse`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当常见的场景，因此有一个名为 `Traverse` 的特定函数来处理它，而 `Traverse` 定义的类型被称为 *可穿越的*。图 17.1
    展示了 `Map` 和 `Traverse` 之间的关系。
- en: '![](Images/CH17_F01_Buonanno2.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH17_F01_Buonanno2.png)'
- en: Figure 17.1 Comparing `Map` and `Traverse`
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.1 比较 `Map` 和 `Traverse`
- en: 'Let’s generalize the idea of a traversable:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们推广可穿越的概念：
- en: We have a traversable structure of `T`’s, so let’s indicate this with `Tr<T>`.
    In this example, it’s `IEnumerable<string>`.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个 `T` 的可穿越结构，所以让我们用 `Tr<T>` 来表示这一点。在这个例子中，它是 `IEnumerable<string>`。
- en: We have a world-crossing function, `f` `:` `T` `→` `A<R>`, where `A` must be
    at least an applicative. In this example, it’s `Double.Parse`, which has type
    `string` `→` `Option<double>`.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个跨越世界的函数，`f` `:` `T` `→` `A<R>`，其中 `A` 至少是一个应用。在这个例子中，它是 `Double.Parse`，它具有类型
    `string` `→` `Option<double>`。
- en: We want to obtain an `A<Tr<R>>`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望得到一个 `A<Tr<R>>`。
- en: The general signature for `Traverse` is in this form
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Traverse` 的一般签名是这个形式'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Particularized for this example, it’s
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，它是
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 17.1.1 Validating a list of values with monadic Traverse
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.1 使用单子 Traverse 验证值列表
- en: Let’s see how we can go about implementing `Traverse` with the preceding signature.
    If you look at the top-level types in the signature, you’ll see that we start
    with a list and end up with a single value. Remember, we reduce lists to a single
    value using `Aggregate`, which was covered in section 9.6.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何根据前面的签名实现`Traverse`。如果你查看签名中的顶级类型，你会发现我们从一个列表开始，最终得到一个单一值。记住，我们使用`Aggregate`将列表缩减为一个单一值，这在第9.6节中已经介绍过。
- en: '`Aggregate` takes an accumulator and a reducer function, which combines each
    element in the list with the accumulator. The accumulator is returned as the result
    if the list is empty. This is easy; we just create an empty `IEnumerable` and
    lift it into an `Option` using `Some`, as the following listing shows.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Aggregate`接受一个累加器和减法函数，该函数将列表中的每个元素与累加器组合。如果列表为空，则返回累加器作为结果。这很简单；我们只需创建一个空的`IEnumerable`，并使用`Some`将其提升到`Option`，如下列所示。'
- en: Listing 17.1 Monadic `Traverse` with an `Option`-returning function
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17.1 返回`Option`的`Traverse`的单调函数
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ If the traversable is empty, lifts an empty instance
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果可遍历的为空，则提升一个空实例
- en: ❷ Extracts the accumulated list of `R`'s from the `Option`
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从`Option`中提取累积的`R`列表
- en: ❸ Applies the function to the current element, and extracts the value from the
    resulting `Option`
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将函数应用于当前元素，并从结果`Option`中提取值
- en: ❹ Appends the value to the list, and lifts the resulting list into an `Option`
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将值追加到列表中，并将结果列表提升到`Option`
- en: Now, let’s look at the reducer function—that’s the interesting bit. Its type
    is
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看减法函数——这是有趣的部分。它的类型是
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we apply the function `f` to the value `t`, we get an `Option<R>`. After
    that, we must satisfy the signature:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将函数`f`应用于值`t`时，我们得到一个`Option<R>`。之后，我们必须满足以下签名：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s simplify this for a moment by removing the `Option` from each element:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时简化一下，从每个元素中移除`Option`：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now it becomes clear that the problem is that of appending a single `R` to an
    `IEnumerable<R>`, yielding an `IEnumerable<R>` with all the elements traversed
    so far. The appending should happen within the elevated world of `Option` because
    all the values are wrapped in an `Option`. As you learned in chapter 10, we can
    apply functions in the elevated world in the applicative or the monadic way. Here
    we use the monadic flow.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很明显，问题是将单个`R`追加到`IEnumerable<R>`中，得到一个包含所有已遍历元素的`IEnumerable<R>`。追加应该在提升的`Option`世界中发生，因为所有值都被包裹在`Option`中。正如你在第10章中学到的，我们可以在提升的世界中以适用性或单调的方式应用函数。这里我们使用单调流程。
- en: Now that you’ve seen the definition of `Traverse`, let’s go back to the scenario
    of parsing a comma-separated list of numbers typed by the user. The following
    listing shows how we can achieve this with `Traverse`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了`Traverse`的定义，让我们回到用户输入的逗号分隔数字列表解析的场景。以下列表显示了我们可以如何使用`Traverse`实现这一点。
- en: Listing 17.2 Safely parses and sums a comma-separated list of numbers
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17.2 安全解析并求和逗号分隔的数字列表
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding listing, the top-level statements perform I/O, while all the
    logic is in the `Process` function. Let’s test it to see the behavior:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，顶级语句执行I/O，而所有逻辑都在`Process`函数中。让我们测试它以查看行为：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 17.1.2 Harvesting validation errors with applicative Traverse
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.2 使用适用性遍历收集验证错误
- en: Let’s improve error handling so we can tell the user which values are wrong.
    For that, we need `Validation`, which can contain a list of errors. This means
    we’ll need an implementation of `Traverse` that takes a list of values and a `Validation`-returning
    function. This is shown in the following listing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进错误处理，以便我们可以告诉用户哪些值是错误的。为此，我们需要`Validation`，它可以包含一个错误列表。这意味着我们需要一个`Traverse`的实现，它接受一个值列表和一个返回`Validation`的函数。这如下列所示。
- en: Listing 17.3 Monadic `Traverse` with a `Validation`-returning function
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17.3 返回`Validation`的`Traverse`的单调函数
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This implementation is similar to the implementation that takes an `Option`-returning
    function (listing 17.1) except for the signature and the fact that the `Return`
    function being used is `Valid` instead of `Some`. This duplication is due to the
    lack of an abstraction common to both `Option` and `Validation`.[²](#pgfId-1157949)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现与返回`Option`的函数实现（列表17.1）类似，除了签名和使用的`Return`函数是`Valid`而不是`Some`。这种重复是由于缺少同时适用于`Option`和`Validation`的通用抽象。[²](#pgfId-1157949)
- en: Notice that I’ve called the function `TraverseM` (for monadic) because the implementation
    is monadic. If one item fails validation, the validation function won’t be called
    for any of the subsequent items.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我之所以将函数命名为`TraverseM`（对于monadic），是因为实现是monadic的。如果一个项目验证失败，验证函数将不会对后续的任何项目进行调用。
- en: If, instead, we want errors to accumulate, we should use the applicative flow
    (if you need a refresher on why this is the case, refer back to section 10.5).
    We can, therefore, define `TraverseA` (for applicative) with the same signature
    but using the applicative flow, as the following listing shows.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要累积错误，我们应该使用applicative flow（如果你需要回顾为什么是这样，请参阅第10.5节）。因此，我们可以定义`TraverseA`（对于applicative），使用相同的签名但使用applicative
    flow，如下列所示。
- en: Listing 17.4 Applicative `Traverse` with a `Validation`-returning function
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17.4 使用返回`Validation`的函数的`Applicative `Traverse`
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ If the traversable is empty, lifts an empty instance
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果可遍历的是空的，则提升一个空实例
- en: ❷ Lifts the `Append` function, particularized for `R`
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 提升特定于`R`的`Append`函数
- en: ❸ Applies it to the accumulator
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 应用到累加器
- en: ❹ Applies `f` to the current element; the `R` wrapped in the resulting `Validation`
    is the second argument to `Append`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将`f`应用于当前元素；结果`Validation`中包裹的`R`是`Append`的第二个参数。
- en: ❺ For `Validation`, `Traverse` should default to the applicative implementation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 对于`Validation`，`Traverse`应默认为applicative实现。
- en: The implementation of `TraverseA` is similar to `TraverseM`, except that in
    the reducer function, the appending is done with the applicative rather than the
    monadic flow. As a result, the validation function `f` is called for *each* `T`
    in `ts`, and all validation errors will accumulate in the resulting `Validation`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`TraverseA`的实现类似于`TraverseM`，不同之处在于在reducer函数中，追加是通过applicative而不是monadic flow完成的。因此，验证函数`f`对`ts`中的每个`T`都会被调用，所有验证错误都会累积在结果`Validation`中。'
- en: Because this is the behavior we usually want with `Validation`, I’ve defined
    `Traverse` to point to the applicative implementation `TraverseA`, but there’s
    still scope for having `TraverseM` if you want a short-circuiting behavior.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是我们通常希望`Validation`具有的行为，所以我将`Traverse`定义为指向applicative实现`TraverseA`，但如果你想要短路行为，仍然有`TraverseM`的空间。
- en: The following listing shows the program, refactored to use `Validation`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了重构后使用`Validation`的程序。
- en: Listing 17.5 Safely parsing and summing a comma-separated list of numbers
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17.5 安全解析和求和逗号分隔的数字列表
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The listing only shows the updated implementation of `Process` (the top-level
    statements are the same as previously). If we test this enhanced implementation,
    we now get this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表仅显示了`Process`（顶级语句与之前相同）的更新实现。如果我们测试这个增强的实现，我们现在会得到以下结果：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, in the second example, the validation errors have accumulated
    as we have traversed the list of inputs. If we used the monadic implementation,
    `TraverseM`, we’d only get the first error.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在第二个示例中，随着我们遍历输入列表，验证错误已经累积。如果我们使用monadic实现`TraverseM`，我们只会得到第一个错误。
- en: 17.1.3 Applying multiple validators to a single value
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.3 将多个验证器应用于单个值
- en: The preceding example demonstrates how to apply a single validation function
    to a list of values you want to validate. What about the case in which you have
    a single value to validate and many validation functions?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例演示了如何将单个验证函数应用于要验证的值列表。那么，当你有一个要验证的单个值和多个验证函数时怎么办？
- en: 'We tackled such a scenario in section 9.6.3, where we had a request object
    to validate and a list of validators, each checking that certain conditions for
    validity are met. As a reminder, we defined a `Validator` delegate to capture
    a function performing validation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第9.6.3节中处理了这样的场景，其中有一个请求对象要验证，以及一个验证器列表，每个验证器都检查某些有效性条件是否得到满足。作为提醒，我们定义了一个`Validator`委托来捕获执行验证的函数：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The challenge was to write a single `Validator` function combining the validation
    of a list of `Validator`’s, harvesting all errors. We had to jump through a few
    hoops to define a `HarvestErrors` function with this behavior (listing 9.22).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于编写一个单一的`Validator`函数，结合多个`Validator`的验证，收集所有错误。我们不得不跳过几个障碍来定义一个具有此行为的`HarvestErrors`函数（列表9.22）。
- en: Now that you know about using `Traverse` with a `Validation`-returning function,
    we can rewrite `HarvestErrors` much more concisely, as the following listing shows.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何使用返回`Validation`的函数与`Traverse`一起使用，我们可以将`HarvestErrors`重写得更简洁，如下列所示。
- en: Listing 17.6 Aggregating errors from multiple validators
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表17.6 从多个验证器中聚合错误
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, `Traverse` returns a `Validation<IEnumerable<T>>`, collecting all the
    errors. If there are no errors, the inner value of type `IEnumerable<T>` will
    contain as many instances of the input value `t` as there are validators. The
    subsequent call to `Map` disregards this `IEnumerable` and replaces it with the
    original object being validated. Here’s an example of using `HarvestErrors` in
    practice:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Traverse` 返回一个 `Validation<IEnumerable<T>>`，收集所有错误。如果没有错误，类型为 `IEnumerable<T>`
    的内部值将包含与验证器数量相同数量的输入值 `t`。随后的 `Map` 调用将忽略这个 `IEnumerable` 并用正在验证的原始对象替换它。以下是在实践中使用
    `HarvestErrors` 的一个示例：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 17.1.4 Using Traverse with Task to await multiple results
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.4 使用 Traverse 与 Task 等待多个结果
- en: '`Traverse` works with `Task` much as it does with `Validation`. We can define
    `TraverseA`, which uses the applicative flow and runs all tasks in parallel, `TraverseM`,
    which uses the monadic flow and runs the tasks sequentially, and `Traverse`, which
    defaults to `TraverseA` because running independent asynchronous operations in
    parallel is usually preferable. Given a list of long-running operations, we can
    use `Traverse` to obtain a single `Task` that we can use to await all the results.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Traverse` 与 `Task` 的工作方式与与 `Validation` 的工作方式相似。我们可以定义 `TraverseA`，它使用应用流并并行运行所有任务，`TraverseM`，它使用单调流并顺序运行任务，以及默认为
    `TraverseA` 的 `Traverse`，因为并行运行独立异步操作通常是首选的。给定一个长时间运行的操作列表，我们可以使用 `Traverse` 获取一个单一的
    `Task`，我们可以使用它来等待所有结果。'
- en: 'In section 16.1.7, we looked at comparing flight fares from two airlines. With
    `Traverse`, we’re equipped to deal with a list of airlines. Imagine that each
    airline’s flights can be queried with a method that returns a `Task<IEnumerable<Flight>>`,
    and we want to get all flights available on a given date and route, sorted by
    price:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 16.1.7 节中，我们讨论了比较两家航空公司的航班价格。使用 `Traverse`，我们能够处理航空公司列表。想象一下，每个航空公司的航班可以通过返回
    `Task<IEnumerable<Flight>>` 的方法进行查询，而我们想要获取给定日期和路线上的所有航班，并按价格排序：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'How do we get all flights from all the airlines? Notice what happens if we
    use `Map`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何获取所有航空公司的所有航班？注意如果我们使用 `Map` 会发生什么：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We end up with an `IEnumerable<Task<IEnumerable<Flight>>>`. This isn’t at all
    what we want!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终得到一个 `IEnumerable<Task<IEnumerable<Flight>>>`。这根本不是我们想要的！
- en: 'With `Traverse`, instead, we’ll end up with a `Task<IEnumerable<IEnumerable
    <Flight>>>`, a single task that completes when *all* airlines have been queried
    (and fails if any query fails). The task’s inner value is a list of lists (one
    list for each airline), which can then be flattened and sorted to get our list
    of results sorted by price:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Traverse`，相反，我们将得到一个 `Task<IEnumerable<IEnumerable<Flight>>>`，一个当所有航空公司都被查询（如果任何查询失败则失败）时完成的单一任务。任务的内部值是一个列表的列表（每个航空公司一个列表），然后可以将其展平和排序，以获取按价格排序的结果列表：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`Flatten` is simply a convenience function that calls `Bind` with the identity
    function, hence flattening the nested `IEnumerable` into a single list including
    flights from all airlines. This list is then sorted by price.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flatten` 只是一个方便函数，它使用恒等函数调用 `Bind`，因此将嵌套的 `IEnumerable` 转换为包含所有航空公司航班的单个列表。然后，这个列表按价格排序。'
- en: Most of the time, you’ll want the parallel behavior, so I’ve defined `Traverse`
    to be the same as `TraverseA`. On the other hand, if you have 100 tasks and the
    second task fails, then monadic traverse will save you from running 98 tasks that
    would still be kicked off when using applicative traverse. So the implementation
    you choose depends on the use case, and this is the reason for including both.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，你希望有并行行为，所以我定义了 `Traverse` 与 `TraverseA` 相同。另一方面，如果你有 100 个任务，第二个任务失败，那么单调遍历将帮助你避免在应用遍历中使用时启动的
    98 个任务。因此，你选择的实现取决于用例，这也是为什么包括两者的原因。
- en: Let’s look at one final variation on this example. In real life, you probably
    don’t want your search to fail if one of perhaps dozens of queries to a third-party
    API fails. Imagine you want to display the best results available, like on many
    price comparison websites. If a provider’s API is down, results from that provider
    won’t be available, but we still want to see results from all the others.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个示例的最后一个变体。在现实生活中，你可能不希望搜索失败，如果第三方 API 的数十个查询中的一个失败。想象一下，你想要显示可用的最佳结果，就像许多价格比较网站一样。如果提供商的
    API 不可用，该提供商的结果将不可用，但我们仍然希望看到其他所有提供商的结果。
- en: 'The change is easy! We can use the `Recover` function shown in section 16.1.4
    so that *each* query returns an empty list of flights if the remote query fails:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 变更很简单！我们可以使用第 16.1.4 节中展示的 `Recover` 函数，这样每个查询在远程查询失败时都会返回一个空的航班列表：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here we have a function that queries several APIs in parallel, disregards any
    failures, and aggregates all the successful results into a single list sorted
    by price. I find this a great example of how composing core functions like `Traverse`,
    `Bind`, and others allows you to specify rich behavior with little code and effort.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个函数，它并行查询多个API，忽略任何失败，并将所有成功的结果汇总到一个按价格排序的单个列表中。我认为这是一个很好的例子，说明了如何通过组合核心函数如`Traverse`、`Bind`等，以少量代码和努力来指定丰富的行为。
- en: 17.1.5 Defining Traverse for single-value structures
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.1.5 为单值结构定义 Traverse
- en: 'So far you’ve seen how to use `Traverse` with an `IEnumerable` and a function
    that returns an `Option`, `Validation`, `Task`, or any other applicative. It turns
    out that `Traverse` is even more general. `IEnumerable` isn’t the only traversable
    structure out there; you can define `Traverse` for many of the constructs you’ve
    seen in the book. If we take a nuts and bolts approach, we can see `Traverse`
    as a utility that stacks effects up the opposite way as when performing `Map`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何使用`Traverse`与`IEnumerable`以及返回`Option`、`Validation`、`Task`或任何其他应用函数。实际上，`Traverse`更加通用。`IEnumerable`并不是唯一的可遍历结构；你可以为书中看到的大多数结构定义`Traverse`。如果我们采取一种从细节到整体的方法，我们可以将`Traverse`视为一种工具，它以与执行`Map`相反的方式堆叠效果：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If we have a function that returns an applicative `A`, `Map` returns a type
    with the `A` on the inside, whereas `Traverse` returns a type with the `A` on
    the outside.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个返回应用`A`的函数，`Map`返回一个内部有`A`的类型，而`Traverse`返回一个外部有`A`的类型。
- en: 'For example, in chapter 8, we had a scenario in which we used `Map` to combine
    a `Validation`-returning function with an `Exceptional`-returning function. The
    code went along these lines:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在第8章中，我们有一个场景，我们使用`Map`将返回`Validation`的函数与返回`Exceptional`的函数组合起来。代码是这样的：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What if, for some reason, we wanted to return an `Exceptional<Validation<Unit>>`
    instead? Well, now you know the trick: just replace `Map` with `Traverse` !'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因，我们想要返回一个`Exceptional<Validation<Unit>>`，那会怎样呢？好吧，现在你知道了这个技巧：只需将`Map`替换为`Traverse`！
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'But can we make `Validation` traversable? The answer is yes. Remember that
    we can view `Option` as a list with at most one element. The same goes for `Either`,
    `Validation`, and `Exceptional`: the success case can be treated as a traversable
    with a single element; the failure case as empty.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们能否使`Validation`可遍历呢？答案是肯定的。记住，我们可以将`Option`视为一个最多只有一个元素的列表。对于`Either`、`Validation`和`Exceptional`也是同样的道理：成功情况可以被视为一个包含单个元素的遍历结构；失败情况则为空。
- en: In this scenario, we need a definition of `Traverse` taking a `Validation` and
    an `Exceptional`-returning function. The following listing shows the implementation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要一个定义`Traverse`的函数，它接受一个`Validation`和一个返回`Exceptional`的函数。下面的列表显示了实现。
- en: Listing 17.7 Making `Validation` traversable
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17.7 使 `Validation` 可遍历
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The base case is if the `Validation` is `Invalid`; that’s analogous to the empty
    list case. Here we create a value of the required output type, *preserving* the
    validation errors. If the `Validation` is `Valid`, that means we should “traverse”
    the single element it contains, named `t`. We apply the `Exception`-returning
    function `f` to it to get an `Exceptional<R>` and then we `Map` the `Valid` function
    on it, which lifts the inner value `r` into a `Validation<R>`, giving us the required
    output type, `Exceptional<Validation<R>>`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 基本情况是如果`Validation`是`Invalid`；这与空列表的情况类似。在这里，我们创建一个所需输出类型的价值，*保留*验证错误。如果`Validation`是`Valid`，这意味着我们应该“遍历”它包含的单个元素，命名为`t`。我们将返回`Exception`的函数`f`应用于它，以获得`Exceptional<R>`，然后我们`Map``Valid`函数于其上，将内部值`r`提升到`Validation<R>`，从而得到所需的输出类型，`Exceptional<Validation<R>>`。
- en: You can follow this pattern to define `Traverse` for the other one-or-no-value
    structures. Notice that once you’ve defined `Traverse`, then when you have, say,
    a `Validation<Exceptional<T>>` and want to reverse the order of the effects, you
    could just use `Traverse` with the identity function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以遵循这个模式来为其他单值或无值结构定义`Traverse`。注意，一旦你定义了`Traverse`，那么当你有，比如说，一个`Validation<Exceptional<T>>`并且想要反转效果顺序时，你只需使用带有恒等函数的`Traverse`即可。
- en: In summary, `Traverse` is useful not just to handle lists of elevated values
    but, more generally, whenever you have stacked effects. As you encode your application’s
    requirements through `Option`, `Validation`, and others, `Traverse` is one of
    the tools you can use to ensure that the types don’t get the better of you.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`Traverse` 不仅对处理提升值列表很有用，而且在更一般的情况下，无论何时你有堆叠效应，`Traverse` 都是你可以使用的工具之一，以确保类型不会占上风。
- en: 17.2 Combining asynchrony and validation (or any other two monadic effects)
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.2 结合异步性和验证（或任何其他两个单子效应）
- en: Most enterprise applications are distributed and depend on a number of external
    systems, so much if not most of your code runs asynchronously. If you want to
    use constructs like `Option` or `Validation`, soon enough you’ll deal with `Task<Option<T>>`,
    `Task<Validation<T>>`, `Validation<Task<T>>`, and so on.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数企业应用程序都是分布式的，依赖于多个外部系统，因此大部分代码都是异步运行的。如果你想使用 `Option` 或 `Validation` 这样的结构，很快你就会处理
    `Task<Option<T>>`、`Task<Validation<T>>`、`Validation<Task<T>>` 等等。
- en: 17.2.1 The problem of stacked monads
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.1 堆叠单子的难题
- en: These nested types can be difficult to work with. When you work within one monad,
    such as `Option`, everything is fine because you can use `Bind` to compose several
    `Option`-returning computations. But what if you have a function that returns
    an `Option<Task<T>>` and another function of type `T` `→` `Option<R>`? How can
    you combine them? And how would you use an `Option<Task<T>>` with a function of
    type `T` `→` `Task<Option<R>>`?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些嵌套类型可能难以处理。当你在一个单子内部工作时，例如 `Option`，一切都很正常，因为你可以使用 `Bind` 来组合多个返回 `Option`
    的计算。但是，如果你有一个返回 `Option<Task<T>>` 的函数，另一个函数的类型是 `T` `→` `Option<R>`，你该如何组合它们？你将如何使用一个
    `Option<Task<T>>` 与一个类型为 `T` `→` `Task<Option<R>>` 的函数？
- en: We can refer to this more generally as the problem of *stacked monads*. In order
    to illustrate this problem and how it can be addressed, let’s revisit one of the
    examples from chapter 13\. The following listing shows a skeletal version of the
    endpoint that handles API requests to make a transfer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更普遍地将其称为堆叠单子的难题。为了说明这个问题以及如何解决它，让我们回顾第 13 章中的一个例子。以下列表显示了处理 API 请求进行转账的端点的骨架版本。
- en: Listing 17.8 Skeleton of the `MakeTransfer` command handler
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17.8 `MakeTransfer` 命令处理程序的骨架
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Handles receiving a command
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 处理接收到的命令
- en: ❷ Retrieves the account
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检索账户
- en: ❸ Performs the state transition; returns a tuple with the event and the new
    state
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 执行状态转换；返回一个包含事件和新状态的元组
- en: ❹ Persists the event and publishes it to interested parties
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 持久化事件并将其发布给感兴趣的各方
- en: ❺ Returns information to the client about the new state
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 向客户端返回有关新状态的信息
- en: The preceding code serves as an outline. Next, you’ll see how to add asynchrony,
    error handling, and validation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码作为大纲。接下来，你将看到如何添加异步性、错误处理和验证。
- en: 'First, we’ll inject a new dependency to perform validation on the `MakeTransfer`
    command. Its type will be `Validator<MakeTransfer>`, which is a delegate with
    this signature:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将注入一个新的依赖项来对 `MakeTransfer` 命令进行验证。其类型将是 `Validator<MakeTransfer>`，这是一个具有以下签名的委托：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, we need to revise the signatures of the existing dependencies. When we
    call `getAccount` to retrieve the current state of an account, that operation
    will hit the database. We want to make it asynchronous, so the result type should
    be wrapped in a `Task`. Furthermore, errors can occur when connecting to the DB.
    Fortunately, `Task` already captures this. Finally, there’s the possibility that
    the account doesn’t exist (no events were ever recorded for the given ID), so
    the result should also be wrapped in an `Option`. The full signature will be
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改现有依赖项的签名。当我们调用 `getAccount` 来检索账户的当前状态时，该操作将击中数据库。我们希望使其异步，因此结果类型应该被包装在
    `Task` 中。此外，连接到数据库时可能会发生错误。幸运的是，`Task` 已经捕获了这一点。最后，还有账户可能不存在（对于给定的 ID 没有记录任何事件）的可能性，因此结果也应该被包装在
    `Option` 中。完整的签名将是
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Saving and publishing an event should also be asynchronous so that the signature
    should be
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 保存和发布事件也应异步进行，因此签名应该是
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, remember that `Account.Debit` also returns its result wrapped in a
    `Validation`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住 `Account.Debit` 也返回其结果被包装在 `Validation` 中：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let’s write a skeleton of the command handler with all these effects in
    place:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个带有所有这些效应的命令处理程序的骨架：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'So far, we’ve listed the dependencies with the new signatures, established
    that the main workflow will return a `Task<Validation<AccountState>>` (because
    there will be some asynchronous operations, and there will be some validation),
    and mapped its possible states to appropriately populated HTTP responses. Now
    comes the real work: How do we put together the functions we need to consume?'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经列出了带有新签名的依赖项，确定了主工作流程将返回一个 `Task<Validation<AccountState>>`（因为将有一些异步操作，并且将有一些验证），并将其可能的状态映射到适当填充的
    HTTP 响应。现在才是真正的任务：我们如何组合所需的函数？
- en: 17.2.2 Reducing the number of effects
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.2 减少效果的数量
- en: First, we’ll need a couple of adapters. Notice that `getAccount` returns an
    `Option` (wrapped in a `Task`), meaning we should cater for the case in which
    no account is found. What does it mean if there’s no account? It means the command
    is incorrectly populated, so we can map `None` to a `Validation` with an appropriate
    error.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要几个适配器。注意，`getAccount` 返回一个 `Option`（包裹在一个 `Task` 中），这意味着我们应该考虑没有找到账户的情况。如果没有账户意味着什么？这意味着命令被错误地填充，因此我们可以将
    `None` 映射到一个带有适当错误的 `Validation`。
- en: '`LaYumba.Functional` defines `ToValidation`, a natural transformation that
    “promotes” an `Option` to a `Validation`. It maps `Some` to `Valid`, using the
    `Option`''s inner value, and `None` to `Invalid`, using the provided `Error`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`LaYumba.Functional` 定义了 `ToValidation`，这是一个自然转换，它“提升”一个 `Option` 到一个 `Validation`。它使用
    `Option` 的内部值将 `Some` 映射到 `Valid`，并使用提供的 `Error` 将 `None` 映射到 `Invalid`：'
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the case of `getAccount`, the returned `Option` is wrapped in a `Task` so
    that we don’t apply `ToValidation` directly, but use `Map` instead:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `getAccount` 的情况下，返回的 `Option` 被包裹在一个 `Task` 中，这样我们就不直接应用 `ToValidation`，而是使用
    `Map`：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At least now we’re only dealing with two monads: `Task` and `Validation`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 至少现在我们只处理两个单子：`Task` 和 `Validation`。
- en: 'Second, `saveAndPublish` returns a `Task`, which doesn’t have an inner value,
    so it won’t compose well. Let’s write an adapter that returns a `Task<Unit>` instead:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，`saveAndPublish` 返回一个 `Task`，它没有内部值，所以它不会很好地组合。让我们编写一个适配器，它返回 `Task<Unit>`
    代替：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s look again at the functions we must compose in order to compute the workflow’s
    outcome:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看我们必须组合的函数，以计算工作流程的结果：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If we used `Map` the whole way through, we’d get a result type of `Validation<Task
    <Validation<Validation<Task<Unit>>>>>`. We could try using a sophisticated combination
    of calls to `Traverse` to change the order of monads and `Bind` to flatten them.
    Honestly, I tried. It took me about half an hour to figure it out, and the result
    was cryptic and not something you’d be keen to ever refactor!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们一路使用 `Map`，我们将得到一个结果类型为 `Validation<Task<Validation<Validation<Task<Unit>>>>>`。我们可以尝试使用复杂的
    `Traverse` 调用组合来改变单子的顺序，以及 `Bind` 来扁平化它们。说实话，我试了。这花了大约半小时的时间来弄清楚，结果是晦涩的，不是你愿意经常重构的东西！
- en: 'We have to look for a better way. Ideally, we’d like to write something like
    this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须寻找更好的方法。理想情况下，我们希望编写如下内容：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We’d then have some underlying implementations of `Select` and `SelectMany`
    that figure out how to combine the types together. Unfortunately, this can’t be
    achieved in a general enough way: add too many overloads of `SelectMany` and this
    will cause overload resolution to fail. The good news is that we can have a close
    approximation. You’ll see this next.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将有一些底层的 `Select` 和 `SelectMany` 实现来确定如何组合类型。不幸的是，这不能以足够通用的方式实现：添加过多的 `SelectMany`
    重载将导致重载解析失败。好消息是我们可以有一个接近的近似。你将在下面看到这一点。
- en: 17.2.3 LINQ expressions with a monad stack
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.2.3 带有单子堆栈的 LINQ 表达式
- en: 'We can implement `Bind` and the LINQ query pattern for a specific monad stack;
    in this case, `Task<Validation<T>>`.[³](#pgfId-1158273) This allows us to compose
    several functions that return a `Task<Validation<>>` within a LINQ expression.
    With this in mind, we can adapt our existing functions to this type by following
    these rules:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现 `Bind` 和 LINQ 查询模式，针对特定的单子堆栈；在这种情况下，`Task<Validation<T>>`。[³](#pgfId-1158273)
    这允许我们在 LINQ 表达式中组合返回 `Task<Validation<>>` 的几个函数。考虑到这一点，我们可以通过以下规则将现有函数适配到这种类型：
- en: If we have a `Task<Validation<T>>` (or a function that returns such a type),
    then there’s nothing to do. That’s the monad we’re working in.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有一个 `Task<Validation<T>>`（或返回这种类型的函数），那么就没有什么要做的。这就是我们正在工作的单子。
- en: If we have a `Validation<T>`, we can use the `Async` function to lift it into
    a `Task`, obtaining a `Task<Validation<T>>`.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有一个 `Validation<T>`，我们可以使用 `Async` 函数将其提升到 `Task`，从而获得一个 `Task<Validation<T>>`。
- en: If we have a `Task<T>`, we can map the `Valid` function onto it to again obtain
    `Task<Validation<T>>`.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有一个 `Task<T>`，我们可以将 `Valid` 函数映射到它上面，再次获得 `Task<Validation<T>>`。
- en: If we have a `Validation<Task<T>>`, we can call `Traverse` with the identity
    function to swap the containers around.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有一个 `Validation<Task<T>>`，我们可以使用恒等函数调用 `Traverse` 来交换容器。
- en: 'So our previous query needs to be modified as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们之前的查询需要按以下方式修改：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Uses `Async` to lift the `Validation` into a `Task<Validation<>>`
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 `Async` 将 `Validation` 提升到 `Task<Validation<>>`
- en: ❷ `GetAccount` returns a `Task<Validation<>>`, which is the monad stack we’re
    working with.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `GetAccount` 返回一个 `Task<Validation<>>`，这是我们正在使用的单子栈。
- en: ❸ Uses `Map(Valid)` to turn a `Task` into a `Task<Validation<>>`
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用 `Map(Valid)` 将 `Task` 转换为 `Task<Validation<>>`
- en: This will work as long as the appropriate implementations of `Select` and `SelectMany`
    for `Task<Validation<T>>` are defined. As you can see, the resulting code is still
    reasonably clean and easy to understand and refactor. We just had to add a few
    calls to `Async` and `Map(Valid)` to make the types line up. The following listing
    shows the complete implementation of the command handler, refactored to include
    asynchrony and validation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 只要为 `Task<Validation<T>>` 定义了适当的 `Select` 和 `SelectMany` 实现，这就会起作用。正如你所看到的，生成的代码仍然相当干净且易于理解和重构。我们只需添加几个对
    `Async` 和 `Map(Valid)` 的调用，以使类型对齐。下面的列表显示了命令处理器的完整实现，重构后包括异步和验证。
- en: Listing 17.9 The command handler, including asynchrony and validation
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 17.9 命令处理器，包括异步和验证
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let’s look at the code. First, the operations that need to be completed as part
    of the workflow are injected as dependencies. Next, we have a couple of adapter
    functions to go from `Option` to `Validation` and from `Task` to `Task<Unit>`.
    We then configure the endpoint that handles transfer requests. Here, we use a
    LINQ comprehension to combine the different operations in the workflow. Finally,
    we translate the resulting outcome into an object representing the HTTP response
    we’d like to return.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码。首先，作为工作流程一部分需要完成的操作被注入为依赖项。接下来，我们有一些适配函数，用于将 `Option` 转换为 `Validation`
    和将 `Task` 转换为 `Task<Unit>`。然后，我们配置处理传输请求的端点。在这里，我们使用 LINQ 表达式来组合工作流程中的不同操作。最后，我们将结果结果转换为表示我们希望返回的
    HTTP 响应的对象。
- en: As you saw in this chapter, although monads are nice and pleasant to work with
    in the context of a single monadic type, things get more complicated when you
    need to combine several monadic effects. Note that this isn’t just the case in
    C# but even in functional languages. Even in Haskell, where monads are used everywhere,
    stacked monads are usually dealt with via the rather clunky *monad transformers*.
    A more promising approach is called *composable effects*, and it has first-class
    support in a rather niche-functional language called Idris. It’s possible that
    the programming languages of the future will not only have syntax optimized for
    monads, such as LINQ, but also syntax optimized for monad stacks.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本章中看到的，虽然单子在这个单一单子类型的环境中很棒，易于使用，但当需要组合多个单子效应时，事情会变得更加复杂。请注意，这不仅仅是在 C# 中如此，甚至在函数式语言中也是如此。即使在
    Haskell 中，单子无处不在，堆叠的单子通常是通过相当笨拙的 *单子转换器* 来处理的。一个更有前景的方法被称为 *可组合效应*，它在一种相当小众的函数式语言
    Idris 中具有一等支持。可能未来的编程语言不仅会有针对单子的优化语法，如 LINQ，还会有针对单子栈的优化语法。
- en: As a practical guideline, remember that combining several monads adds complexity,
    and limit the nesting of different monads to what you really need. For instance,
    once we simplified things in the previous example by transforming `Option` to
    `Validation`, we only had to deal with two stacked monads rather than three. Similarly,
    if you have a `Task<Try<T>>`, you can probably reduce it to a `Task<T>` because
    `Task` can capture any exceptions raised when running the `Try`. Finally, if you
    find yourself always using a stack of two monads, you can write a new type that
    encapsulates both effects into that single type. For example, `Task` encapsulates
    both asynchrony and error handling.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项实际指南，请记住，组合多个单子会增加复杂性，并限制不同单子的嵌套层数，使其符合你的实际需求。例如，一旦我们在前面的示例中将 `Option` 转换为
    `Validation` 来简化事情，我们只需处理两个堆叠的单子而不是三个。同样，如果你有一个 `Task<Try<T>>`，你可能可以将其缩减为 `Task<T>`，因为
    `Task` 可以捕获在运行 `Try` 时抛出的任何异常。最后，如果你发现自己总是使用两个单子的堆栈，你可以编写一个新的类型，将这两个效应封装到该单个类型中。例如，`Task`
    封装了异步和错误处理。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: If you have two monads, `A` and `B`, you might like to stack them up in values
    like `A<B<T>>` to combine the effects of both monads.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有两个单子，`A` 和 `B`，你可能希望将它们堆叠成 `A<B<T>>` 这样的值来组合这两个单子的效果。
- en: You can use `Traverse` to invert the order of monads in the stack.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `Traverse` 来反转堆栈中单子的顺序。
- en: Implementing the LINQ query pattern for such a stack allows you to combine `A`’s,
    `B`’s, and `A<B<>>`’s with relative ease.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为这样的堆栈实现LINQ查询模式可以让你相对容易地组合 `A`、`B` 和 `A<B<>>`。
- en: Still, stacked monads tend to be cumbersome, so use them sparingly.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仍然，堆叠的单子往往比较繁琐，所以请尽量少用。
- en: '* * *'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '¹ You may remember from chapter 6 that we could use `Bind` instead of `Map`
    to filter out all the `None` values and only add up the numbers that were successfully
    parsed. That’s not desirable for this scenario: we’d be silently removing values
    that the user probably mistyped in error, effectively giving an incorrect result.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 你可能还记得在第6章中，我们可以使用 `Bind` 而不是 `Map` 来过滤掉所有的 `None` 值，并且只累加成功解析的数字。这在当前场景中并不理想：我们可能会默默地移除用户可能错误输入的值，从而得到一个错误的结果。
- en: ² The reasons for this were discussed in chapter 6, in the “Why is functor not
    an interface?” sidebar.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ² 关于这一点的原因在第6章中进行了讨论，在“为什么函子不是一个接口？”的侧边栏中。
- en: ³ I won’t show the implementation, which is included in the code samples. This
    really is library code, not code that a library user should worry about. You may
    also ask whether an implementation is required for every stack of monads, and
    indeed, this is the case, given the pattern-based approach we’ve been following
    in the book.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 我不会展示实现代码，它包含在代码示例中。这确实是库代码，不是库用户应该关心的代码。你也许还会问是否每个单子堆栈都需要实现，确实如此，考虑到我们在书中一直遵循的模式化方法。
