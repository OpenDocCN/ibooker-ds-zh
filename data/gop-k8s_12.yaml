- en: 9 Argo CD
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 Argo CD
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: What is Argo CD?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Argo CD？
- en: Deploying an application using Argo CD
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Argo CD 部署应用程序
- en: Using Argo CD enterprise features
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Argo CD 企业功能
- en: In this chapter, you will learn how to use the Argo CD GitOps operator to deploy
    a reference example application to Kubernetes. You will also learn how Argo CD
    addresses enterprise considerations such as single sign-on (SSO) and access control.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用 Argo CD GitOps 运营商将参考示例应用程序部署到 Kubernetes。您还将了解 Argo CD 如何解决企业考虑因素，例如单点登录
    (SSO) 和访问控制。
- en: We recommend you read chapters 1, 2, 3, and 5 before reading this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您在阅读本章之前阅读第 1、2、3 和 5 章。
- en: 9.1 What is Argo CD?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 什么是 Argo CD？
- en: 'Argo CD is an open source GitOps operator for Kubernetes.^([1](#pgfId-1083174))
    The project is a part of the Argo family, a set of cloud-native tools for running
    and managing jobs and applications on Kubernetes. Along with Argo Workflows, Rollouts,
    and Events, Argo CD focuses on application delivery use cases and makes it easier
    to combine three modes of computing: services, workflows, and event-based processing.
    In 2020, Argo CD was accepted by the Cloud Native Computing Foundation (CNCF)
    as an incubation-level hosted project.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD 是一个开源的 GitOps 运营商，用于 Kubernetes.^([1](#pgfId-1083174)) 该项目是 Argo 家族的一部分，是一套用于在
    Kubernetes 上运行和管理作业和应用程序的云原生工具集。与 Argo Workflows、Rollouts 和 Events 一起，Argo CD
    专注于应用程序交付用例，并简化了三种计算模式的结合：服务、工作流和基于事件的处理。在 2020 年，Argo CD 被云原生计算基金会 (CNCF) 批准为孵化级托管项目。
- en: CNCF The Cloud Native Computing Foundation is a Linux Foundation project that
    hosts critical components of the global technology infrastructure.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: CNCF 云原生计算基金会是一个 Linux 基金会项目，它托管着全球技术基础设施的关键组件。
- en: The company behind Argo CD is Intuit, the creator of TurboTax and QuickBooks.
    In early 2018, Intuit decided to adopt Kubernetes to speed up cloud migration.
    At the time, the market already had several successful continuous deployment tools
    for Kubernetes, but none of them fully satisfied Intuit’s needs. So instead of
    adopting an existing solution, the company decided to invest in a new project
    and started working on Argo CD. What is so special about Intuit’s requirements?
    The answer to that question explains how Argo CD is different from other Kubernetes
    CD tools and explains its main project use cases.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD 背后的公司是 Intuit，它是 TurboTax 和 QuickBooks 的创造者。在 2018 年初，Intuit 决定采用 Kubernetes
    来加速云迁移。当时，市场上已经存在几个针对 Kubernetes 的成功的持续部署工具，但它们都没有完全满足 Intuit 的需求。因此，而不是采用现有的解决方案，公司决定投资一个新的项目，并开始开发
    Argo CD。Intuit 的需求有什么特别之处？这个问题的答案解释了 Argo CD 与其他 Kubernetes CD 工具的不同之处，以及其主要项目用例。
- en: 9.1.1 Main use cases
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 主要用例
- en: The importance of a GitOps methodology and benefits of representing infrastructure
    as code is not questionable. However, the enterprise scale demands additional
    requirements. Intuit is a cloud-based software-as-a-service company. With around
    5,000 developers, the company successfully runs hundreds of microservices on-premises
    and in the cloud. Given that scale, it was unreasonable to expect that every team
    would run its own Kubernetes cluster. Instead, it was decided that a centralized
    platform team would run and maintain a set of multitenant clusters for the whole
    company. At the same time, end users should have the freedom and necessary tools
    to manage workloads in those clusters. These considerations have defined the following
    additional requirements on top of the decision to use GitOps.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps 方法论的重要性以及将基础设施表示为代码的好处是不容置疑的。然而，企业规模的需求需要额外的要求。Intuit 是一家基于云的软件即服务公司。拥有大约
    5,000 名开发者，该公司成功地在本地和云端运行了数百个微服务。鉴于这种规模，期望每个团队都运行自己的 Kubernetes 集群是不合理的。相反，决定由一个集中式平台团队运行和维护整个公司的多租户集群。同时，最终用户应该有自由和必要的工具来管理这些集群中的工作负载。这些考虑因素在决定使用
    GitOps 的基础上定义了以下额外的要求。
- en: Available as a service
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 作为服务提供
- en: A simple onboarding process is extremely important if you are trying to move
    hundreds of microservices to Kubernetes. Instead of asking every team to install,
    configure, and maintain the deployment operator, it should be provided by the
    centralized team. With several thousands of new users, SSO integration is crucial.
    The service must integrate with various SSO providers instead of introducing its
    own user management.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您试图将数百个微服务迁移到 Kubernetes，一个简单的入门流程至关重要。与其要求每个团队安装、配置和维护部署操作员，不如由集中团队提供。随着数千名新用户的加入，SSO
    集成至关重要。该服务必须与各种 SSO 提供商集成，而不是引入自己的用户管理。
- en: Enable multitenancy and multicluster management
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 启用多租户和多集群管理
- en: In multitenant environments, users need an effective and flexible access control
    system. Kubernetes has a great built-in role-based access control system, but
    that is not enough when you have to deal with hundreds of clusters. The continuous
    deployment tool should provide access control on top of multiple clusters and
    seamlessly integrate with existing SSO providers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在多租户环境中，用户需要一个有效且灵活的访问控制系统。Kubernetes 有一个出色的内置基于角色的访问控制系统，但当您必须处理数百个集群时，这还不够。持续部署工具应在多个集群上提供访问控制，并无缝集成到现有的
    SSO 提供商中。
- en: Enable observability
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 启用可观察性
- en: 'Last, but not least, the continuous deployment tool should provide developers
    insights about the state of managed applications. That assumes a user-friendly
    interface that quickly answers the following questions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，但同样重要的是，持续部署工具应向开发者提供有关管理应用程序状态的了解。这假设有一个用户友好的界面，可以快速回答以下问题：
- en: Is the application configuration in sync with the configuration defined in Git?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序配置是否与 Git 中定义的配置同步？
- en: What exactly is not matching?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 究竟是什么不匹配？
- en: Is the application up and running?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序是否已启动并运行？
- en: What exactly is broken?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 究竟是什么出了问题？
- en: The company needed the GitOps operator ready for enterprise scale. The team
    evaluated several GitOps operators, but none of them satisfied all the requirements,
    so it was decided to implement Argo CD.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该公司需要为企业规模准备好的 GitOps 操作员。团队评估了几个 GitOps 操作员，但没有一个满足所有要求，因此决定实施 Argo CD。
- en: Exercise 9.1
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.1
- en: Reflect on your organization’s needs and compare them to use cases that Argo
    CD is focused on. Try to decide if Argo CD solves the pain points your team has.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 反思您组织的需要，并将它们与 Argo CD 专注于的使用案例进行比较。尝试决定 Argo CD 是否解决了您团队面临的痛点。
- en: 9.1.2 Core concepts
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 核心概念
- en: 'In order to effectively use Argo CD, we should understand two basic concepts:
    the Application and the Project. Let’s have a closer look at the Application first.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地使用 Argo CD，我们应该了解两个基本概念：应用程序和项目。让我们首先更详细地看看应用程序。
- en: Application
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序
- en: The Application provides a logical grouping of Kubernetes resources and defines
    a resources manifest’s source and destination.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序提供 Kubernetes 资源的逻辑分组，并定义资源清单的源和目标。
- en: '![](Images/CH09_F01_Yuen.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F01_Yuen.png)'
- en: Figure 9.1 The main properties of the Argo CD Application are the source and
    destination. The source specifies a resource manifest’s location in the Git repository.
    The destination specifies where resources should be created in the Kubernetes
    cluster.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 Argo CD 应用程序的主要属性是源和目标。源指定资源清单在 Git 仓库中的位置。目标指定资源应在 Kubernetes 集群中的何处创建。
- en: 'The Application source includes the repository URL and the directory inside
    of the repository. Typically repositories include multiple directories, one per
    application environment such as QA and Prod. The sample directory structure of
    such a repository is represented here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序源包括仓库 URL 和仓库内的目录。通常，仓库包含多个目录，每个应用程序环境一个，例如 QA 和 Prod。此类仓库的示例目录结构如下所示：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each directory does not necessarily contain plain YAML files. Argo CD does not
    enforce any configuration management tool and instead provides first-class support
    for various config management tools. So the directory might as well contain a
    Helm chart definition as YAML along with Kustomize overlays.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每个目录不一定包含纯 YAML 文件。Argo CD 不强制使用任何配置管理工具，而是提供对各种配置管理工具的一级支持。因此，目录可能也包含与 Helm
    图表定义一起的 YAML 文件以及 Kustomize 遮罩。
- en: The Application destination defines where resources must be deployed and includes
    the API server URL of the target Kubernetes cluster, along with the cluster Namespace
    name. The API server URL identifies the cluster where all application manifests
    must be deployed. It is impossible to deploy application manifests across several
    clusters, but different applications might be deployed into different clusters.
    The Namespace name is used to identify the target Namespace of all Namespace-level
    application resources.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序目标定义了资源必须部署的位置，包括目标 Kubernetes 集群的 API 服务器 URL 以及集群命名空间名称。API 服务器 URL 识别所有应用程序清单必须部署的集群。无法在多个集群之间部署应用程序清单，但不同的应用程序可能被部署到不同的集群中。命名空间名称用于识别所有命名空间级别应用程序资源的目标命名空间。
- en: So the Argo CD Application represents an environment deployed in the Kubernetes
    cluster and connects it to the desired state stored in the Git repository.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Argo CD 应用程序代表在 Kubernetes 集群中部署的环境，并将其连接到 Git 仓库中存储的期望状态。
- en: Exercise 9.2
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.2
- en: Consider the real service deployed in your organization and come up with a list
    of Argo CD applications. Define the source repository URL, directory, and target
    cluster with the Namespace for one of the applications from your list.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑您组织中实际部署的服务，并为您列表中的应用程序制定一个 Argo CD 应用程序列表。定义一个应用程序的源仓库 URL、目录和目标集群以及命名空间。
- en: 9.1.3 Sync and health statuses
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 同步和健康状态
- en: 'In addition to the source and destination, the Argo CD application has two
    more important properties: sync and health statuses.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了源和目标之外，Argo CD 应用程序还有两个更重要的属性：同步和健康状态。
- en: Sync status answers whether the observed application resources state deviates
    from the resources state stored in the Git repository. The logic behind deviation
    calculation is equivalent to the logic of the `kubectl` `diff` command. The possible
    values of a sync status are in-sync and out-of-sync. The in-sync status means
    that each application resource is found and fully matching to the expected resource
    state. The out-of-sync status means that at least one resource status is not matching
    to the expected state or not found in the target cluster.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 同步状态回答观察到的应用程序资源状态是否与存储在 Git 仓库中的资源状态不同。偏差计算背后的逻辑等同于 `kubectl` `diff` 命令的逻辑。同步状态的值可能是同步或不同步。同步状态表示每个应用程序资源都被找到，并且完全匹配预期的资源状态。不同步状态表示至少有一个资源状态与预期状态不匹配，或者在目标集群中未找到。
- en: 'The health status aggregates information about the observed health status of
    each resource that makes up the application. The health assessment logic is different
    for each Kubernetes resource type and results in one of the following values:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的健康状态汇总了构成应用程序的每个资源的观察到的健康状态。对于每个 Kubernetes 资源类型，健康评估逻辑不同，并导致以下值之一：
- en: '*Healthy*—For example, the Kubernetes deployment is considered healthy if the
    required number of Pods is running and each Pod successfully passes both readiness
    and liveness probes.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*健康*——例如，如果所需的 Pod 数量正在运行，并且每个 Pod 成功通过了就绪和存活探针，则认为 Kubernetes 部署是健康的。'
- en: '*Progressing*—Represents a resource that is not healthy yet but is still expected
    to reach a healthy state. The Deployment is considered progressing if it is not
    healthy yet but still without a time limit specified by the `progressingDeadlineSeconds`[2](#pgfId-1083255)
    field.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*进行中*——表示尚未健康但预计将达到健康状态的资源。如果 Deployment 尚未健康但尚未指定由 `progressingDeadlineSeconds`[2](#pgfId-1083255)
    字段指定的超时时间，则认为它是进行中的。'
- en: '*Degraded*—The antipode of a healthy status. The example is a Deployment that
    could not reach a healthy status within an expected timeout.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*退化*——健康状态的相反。例如，一个 Deployment 在预期超时内无法达到健康状态。'
- en: '*Missing*—Represents the resource that is stored in Git but not deployed to
    the target cluster.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缺失*——表示存储在 Git 中但未部署到目标集群的资源。'
- en: The aggregated application status is the worst status of every application resource.
    The healthy status is the best, descending to progressing, degraded, and missing
    (the worst). So if all application resources are healthy and only one is degraded,
    the aggregated status is also degraded.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 汇总的应用程序状态是每个应用程序资源的最差状态。健康状态是最好的，依次下降到进行中、退化、缺失（最差）。因此，如果所有应用程序资源都是健康的，而只有一个资源是退化的，则汇总状态也是退化的。
- en: Exercise 9.3
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.3
- en: 'Consider an application consisting of two Deployments. The following information
    is known about the resources:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个由两个 Deployment 组成的应用程序。关于资源的以下信息是已知的：
- en: Deployment 1 has an image that does not match the image stored in the Git repository.
    All Deployment Pods have failed to start for several hours while Deployment `progressingDeadlineSeconds`
    is set to 10 minutes.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署1有一个与Git仓库中存储的镜像不匹配的镜像。由于部署`progressingDeadlineSeconds`设置为10分钟，所有部署Pod已经失败启动数小时。
- en: Deployment 2 is not fully matching the expected state and has all Pods running.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署2没有完全匹配预期的状态，并且所有Pod都在运行。
- en: What are the application sync and health statuses?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的同步和健康状态是什么？
- en: 'The health and sync statuses answer the two most important questions about
    an application:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 健康和同步状态回答了关于应用程序最重要的两个问题：
- en: Is my application working?
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的应用程序是否在运行？
- en: Am I running what is expected?
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是否运行了预期的内容？
- en: Project
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 项目
- en: 'Argo CD applications provide a very flexible way to manage different applications
    independently of each other. This functionality provides very useful insights
    to the team about each piece of infrastructure and greatly improves productivity.
    However, this is not enough to support multiple teams with different access levels:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD应用程序提供了一种非常灵活的方式来独立管理不同的应用程序。这种功能为团队提供了关于每项基础设施的非常有用的见解，并大大提高了生产力。然而，这还不足以支持具有不同访问级别的多个团队：
- en: The mixed list of applications creates confusion that creates a human error
    possibility.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的混合列表造成了混淆，这可能导致人为错误的可能性。
- en: Different teams have different access levels. As has been described in chapter
    6, an individual might use the GitOps operator to escalate their own permissions
    to get full cluster access.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的团队有不同的访问级别。正如第6章所述，个人可能会使用GitOps操作员来提升自己的权限以获得完整的集群访问权限。
- en: The workaround for these issues is a separate Argo CD instance for each team.
    This is not a perfect solution since a separate instance means management overhead.
    In order to avoid management overhead, Argo CD introduces the Project abstraction.
    Figure 9.2 illustrates the relationship between Applications and Projects.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的解决方案是为每个团队创建一个单独的Argo CD实例。这不是一个完美的解决方案，因为单独的实例意味着管理开销。为了避免管理开销，Argo CD引入了项目抽象。图9.2说明了应用程序和项目之间的关系。
- en: A Project provides a logical grouping of Applications, isolates teams from each
    other, and allows for fine-tuning access control in each Project.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 项目为应用程序提供了一个逻辑分组，隔离了团队之间的联系，并允许在每个项目中进行细粒度的访问控制调整。
- en: '![](Images/CH09_F02_Yuen.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F02_Yuen.png)'
- en: Figure 9.2 Demonstrates the relationship between Applications and Projects.
    A Project provides a logical grouping of Applications, isolating teams from each
    other and enabling using Argo CD in multitenant environments.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2展示了应用程序和项目之间的关系。项目为应用程序提供了一个逻辑分组，隔离了团队之间的联系，并允许在多租户环境中使用Argo CD。
- en: 'In addition to separating sets of applications, a Project provides the following
    set of features:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除了分离应用程序集之外，项目还提供以下功能集：
- en: Restricts which Kubernetes clusters and Git repositories might be used by Project
    Applications
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制项目应用程序可能使用的Kubernetes集群和Git存储库
- en: Restricts which Kubernetes resources can be deployed by each Application within
    a Project
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制项目内每个应用程序可以部署的Kubernetes资源
- en: Exercise 9.4
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 练习9.4
- en: Try to come up with a list of projects in your organization. Using Projects,
    you can restrict what kind of resource users can deploy, source repositories,
    and destination clusters available within the Project. Which restrictions would
    you configure for your projects?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试列出你组织中的项目列表。使用项目，你可以限制用户可以部署的资源类型、源存储库以及项目内可用的目标集群。你会为你的项目配置哪些限制？
- en: 9.1.4 Architecture
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.4 架构
- en: 'At first glance, the implementation of the GitOps operator does not look too
    complex. In theory, all you need is to clone the Git repository with manifests
    and use `kubectl` `diff` and `kubectl` `apply` to detect and handle config drifts.
    This is true until you are trying to automate this process for multiple teams
    and manage the configuration of dozens of clusters simultaneously. Logically this
    process is split into three phases, and each phase has its own challenges:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，GitOps操作员的实现并不太复杂。从理论上讲，你所需要做的就是克隆包含清单的Git仓库，并使用`kubectl` `diff`和`kubectl`
    `apply`来检测和处理配置漂移。这在你尝试为多个团队自动化此过程并同时管理数十个集群的配置时是正确的。逻辑上，这个过程分为三个阶段，每个阶段都有其自身的挑战：
- en: Retrieve resource manifests.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取资源清单。
- en: Detect and fix the deviations.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测并修复偏差。
- en: Present the results to end users.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果呈现给最终用户。
- en: Each phase consumes different resources, and the implementation of each phase
    has to scale differently. A separate Argo CD component is responsible for each
    phase.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段消耗不同的资源，每个阶段的实现必须以不同的方式扩展。每个阶段都有一个单独的 Argo CD 组件负责。
- en: '![](Images/CH09_F03_Yuen.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3](Images/CH09_F03_Yuen.png)'
- en: Figure 9.3 Argo CD consists of three main components that implement GitOps reconciliation
    cycle phases. The `argocd-repo-server` retrieves manifests from Git. The `argocd-application-controller`
    compares manifests from Git with resources in the Kubernetes cluster. The `argocd-api-server`
    presents reconciliation results to the user.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 Argo CD 由三个主要组件组成，实现了 GitOps 协调周期阶段。`argocd-repo-server` 从 Git 中检索清单。`argocd-application-controller`
    将 Git 中的清单与 Kubernetes 集群中的资源进行比较。`argocd-api-server` 向用户展示协调结果。
- en: Let’s go through each phase and the corresponding Argo CD component implementation
    details.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一了解每个阶段及其对应的 Argo CD 组件实现细节。
- en: Retrieve resource manifests
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 检索资源清单
- en: The manifest generation in Argo CD is implemented by the `argocd-repo-server`
    component. This phase presents a whole set of challenges.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD 中的清单生成由 `argocd-repo-server` 组件实现。这个阶段带来了一系列挑战。
- en: Manifest generation requires you to download Git repository content and produce
    ready-to-use manifest YAML. First of all, it is too time consuming to download
    the whole repository content every time you need to retrieve expected resource
    manifests. Argo CD solves this by caching the repository content on local disk
    and using the `git` `fetch` command to download only recent changes from the remote
    Git repository. The next challenge is related to memory usage. In real life, resource
    manifests are rarely stored as plain YAML files. In most cases, developers prefer
    to use a config management tool such as Helm or Kustomize. Every tool invocation
    causes a spike in memory usage. To handle the memory usage issues, Argo CD allows
    the user to limit the number of parallel manifest generations and scale up the
    number of `argocd-repo-server` instances to improve performance.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 生成清单需要您下载 Git 仓库内容并生成可用的清单 YAML 文件。首先，每次需要检索预期的资源清单时都下载整个仓库内容是非常耗时的。Argo CD
    通过在本地磁盘上缓存仓库内容并使用 `git` `fetch` 命令仅从远程 Git 仓库下载最近更改来解决此问题。下一个挑战与内存使用有关。在现实生活中，资源清单很少以纯
    YAML 文件的形式存储。在大多数情况下，开发者更喜欢使用像 Helm 或 Kustomize 这样的配置管理工具。每次工具调用都会导致内存使用量的峰值。为了处理内存使用问题，Argo
    CD 允许用户限制并行生成清单的数量，并增加 `argocd-repo-server` 实例的数量以提高性能。
- en: '![](Images/CH09_F04_Yuen.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4](Images/CH09_F04_Yuen.png)'
- en: Figure 9.4 `argocd-repo-server` caches the cloned repository on local storage
    and encapsulates interaction with the config management tool that is required
    to produce final resource manifests.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 `argocd-repo-server` 在本地存储中缓存克隆的仓库，并封装与生成最终资源清单所需的配置管理工具的交互。
- en: Detect and fix the deviations
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 检测并修复偏差
- en: The reconciliation phase is implemented by the `argocd-application-controller`
    component. The controller loads the live Kubernetes cluster state, compares it
    with the expected manifests provided by the `argocd-repo-server`, and patches
    deviated resources. This phase is probably the most challenging one. In order
    to correctly detect deviations, the GitOps operator needs to know about each resource
    in the cluster, and compare and update thousands of resources.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 协调阶段由 `argocd-application-controller` 组件实现。控制器加载实时 Kubernetes 集群状态，将其与 `argocd-repo-server`
    提供的预期清单进行比较，并修补偏离的资源。这个阶段可能是最具挑战性的。为了正确检测偏差，GitOps 运营商需要了解集群中的每个资源，并比较和更新数千个资源。
- en: '![](Images/CH09_F05_Yuen.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5](Images/CH09_F05_Yuen.png)'
- en: Figure 9.5 `argocd-application-controller` performs resource reconciliation.
    The controller leverages the `argocd-repo-server` component to retrieve expected
    manifests and compare manifests with the lightweight in-memory Kubernetes cluster
    state cache.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 `argocd-application-controller` 执行资源协调。控制器利用 `argocd-repo-server` 组件检索预期的清单，并将清单与轻量级的内存中
    Kubernetes 集群状态缓存进行比较。
- en: The controller maintains a lightweight cache of each managed cluster and updates
    it in the background using the Kubernetes watch API. This allows the controller
    to perform reconciliation on an application within a fraction of a second and
    empowers it to scale and manage dozens of clusters simultaneously. After each
    reconciliation, the controller has exhaustive information about each application
    resource, including the sync and health status. The controller saves that information
    into the Redis cluster so it can be presented to the end user later.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器维护每个管理集群的轻量级缓存，并在后台使用 Kubernetes 监视 API 更新它。这使得控制器能够在几秒钟内对应用程序进行协调，并赋予其扩展和管理数十个集群的能力。每次协调后，控制器都会收集每个应用程序资源的详尽信息，包括同步和健康状态。控制器将这些信息保存到
    Redis 集群中，以便稍后向最终用户展示。
- en: Present the results to end users
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 向最终用户展示结果
- en: Finally, the reconciliation results must be presented to end users. This task
    is performed by the `argocd-server` component. While the heavy lifting was already
    done by the `argocd-repo-server` and `argocd-application-controller`, this last
    phase has the highest resiliency requirements. The `argocd-server` is a stateless
    web application that loads the information about reconciliation results and powers
    the web user interface.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，必须将协调结果展示给最终用户。这项任务由 `argocd-server` 组件执行。虽然繁重的工作已经由 `argocd-repo-server`
    和 `argocd-application-controller` 完成，但这个最后阶段具有最高的弹性要求。`argocd-server` 是一个无状态的
    Web 应用程序，它加载关于协调结果的信息并驱动 Web 用户界面。
- en: The architecture design allows Argo CD to serve GitOps operations for large
    enterprises with minimal maintenance overhead.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 架构设计使得 Argo CD 能够以最小的维护开销为大型企业提供 GitOps 操作。
- en: Exercise 9.5
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.5
- en: Which components serve user requests and require multiple replicas for resiliency?
    Which components might require a lot of memory to scale?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些组件服务于用户请求并需要多个副本以提高弹性？哪些组件可能需要大量内存以进行扩展？
- en: 9.2 Deploy your first application
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 部署您的第一个应用程序
- en: While Argo CD is an enterprise-ready, complex distributed system, it is still
    lightweight and can easily run on minikube. The installation is trivial and includes
    a few simple steps. Please refer to appendix B for more information on how to
    install Argo CD, or follow the official Argo CD instructions.^([3](#pgfId-1083365))
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Argo CD 是一个企业级、复杂的分布式系统，但它仍然轻量级，可以轻松运行在 minikube 上。安装过程简单，包括几个简单的步骤。请参阅附录
    B 了解有关如何安装 Argo CD 的更多信息，或遵循官方 Argo CD 指令.^([3](#pgfId-1083365))
- en: 9.2.1 Deploying the first application
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 部署第一个应用程序
- en: As soon as Argo CD is running, we are ready to deploy our first application.
    As it’s been mentioned before, to deploy an Argo CD application, we need to specify
    the Git repository that contains deployment manifests and target the Kubernetes
    cluster and Namespace. To create the Git repository for this exercise, open the
    following GitHub repository and create a repository fork:^([4](#pgfId-1083372))
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Argo CD 启动，我们就准备好部署我们的第一个应用程序。正如之前提到的，要部署 Argo CD 应用程序，我们需要指定包含部署清单的 Git
    仓库，并针对 Kubernetes 集群和命名空间。为了进行此练习创建 Git 仓库，请打开以下 GitHub 仓库并创建一个仓库 fork:^([4](#pgfId-1083372))
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Argo CD can deploy into the external cluster as well as into the same cluster
    where it is installed. Let’s use the second option and deploy our application
    into the default Namespace of our minikube cluster.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD 可以部署到外部集群，也可以部署到它安装的同一集群。让我们使用第二种选项，将我们的应用程序部署到 minikube 集群的默认命名空间。
- en: Reset your fork Have you already forked the deployment repository while working
    on previous chapters? Please make sure to revert changes for the best experience.
    The simplest way is to delete the previously forked repository and fork it again.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重置您的分支 在您之前章节的工作中已经 fork 了部署仓库吗？请确保重置更改以获得最佳体验。最简单的方法是删除之前 fork 的仓库并再次 fork。
- en: 'The application might be created using the web user interface, using the CLI,
    or even programmatically using the REST or gRPC APIs. Since we already have Argo
    CD CLI installed and configured, let’s use it to deploy an application. Go ahead
    and execute the following command to create an application:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可能通过 Web 用户界面、CLI 或甚至通过 REST 或 gRPC API 以编程方式创建。由于我们已安装并配置了 Argo CD CLI，让我们使用它来部署应用程序。请执行以下命令以创建应用程序：
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Unique applicationname
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 唯一的应用程序名称
- en: ❷ Git repository URL
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Git 仓库 URL
- en: ❸ Directory path within the Git repository
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Git 仓库内的目录路径
- en: ❹ The Kubernetes API server URL. The https://kubernetes.default.svc/ is the
    API server URL that is available inside of every Kubernetes cluster.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ Kubernetes API服务器URL。https://kubernetes.default.svc/是每个Kubernetes集群中可用的API服务器URL。
- en: ❺ The Kubernetes Namespace name
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ Kubernetes命名空间名称
- en: 'As soon as the application is created, we can use the Argo CD CLI to get the
    information about the application state. Use the following command to get the
    information about the `sample-app` application state:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用创建，我们就可以使用Argo CD CLI获取应用状态信息。使用以下命令获取`sample-app`应用状态信息：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ CLI command that returns the information about an application state
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 返回应用状态信息的CLI命令
- en: ❷ Application sync status that answers whether the application state matches
    the expected state or not
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 应用同步状态，回答应用状态是否与预期状态匹配
- en: ❸ Application aggregated health status
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 应用聚合健康状态
- en: 'As we can see from the command output, the application is out of sync and not
    healthy. By default, Argo CD does not push resources defined in the Git repository
    into the cluster if it detects a deviation. In addition to the high-level summary,
    we can see the details of every application resource. Argo CD detected that the
    application is supposed to have a Deployment and a Service, but both resources
    are missing. To deploy the resources, we need to either configure automated application
    syncing using the sync policy^([5](#pgfId-1083414)) or trigger syncing manually.
    To trigger the sync and deploy the resources, use the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从命令输出中可以看到，应用已出现同步错误且不健康。默认情况下，如果Argo CD检测到偏差，它不会将Git仓库中定义的资源推送到集群中。除了高级摘要外，我们还可以看到每个应用资源的详细信息。Argo
    CD检测到应用应该有一个Deployment和一个Service，但这两个资源都缺失。要部署资源，我们需要配置使用同步策略的自动应用同步^([5](#pgfId-1083414))或手动触发同步。要触发同步并部署资源，请使用以下命令：
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ CLI command that triggers application sync
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 触发应用同步的CLI命令
- en: ❷ Initial application state before the sync operation
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 同步操作前的初始应用状态
- en: ❸ Final application state after the sync is completed
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 同步完成后最终的 应用状态
- en: As soon as the sync is triggered, Argo CD pushes the manifests stored in Git
    into the Kubernetes cluster and then reevaluates the application state. The final
    application state is printed to the console when the synchronization completes.
    The `sample-app` application was successfully synced, and each result matches
    the expected state.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦触发同步，Argo CD将Git中存储的清单推送到Kubernetes集群，然后重新评估应用状态。当同步完成时，最终的应用状态将打印到控制台。`sample-app`应用成功同步，每个结果都与预期状态相匹配。
- en: 9.2.2 Inspect the application using the user interface
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.2 使用用户界面检查应用
- en: In addition to the CLI and API, Argo CD provides a user-friendly web interface.
    Using the web interface, you might get the high-level view of all your applications
    deployed across multiple clusters as well as very detailed information about every
    application resource. Open the https://<host>:<port> URL to see the applications
    list in the Argo CD user interface.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了CLI和API之外，Argo CD还提供了一个用户友好的Web界面。使用Web界面，您可能会看到跨多个集群部署的所有应用的高级视图以及每个应用资源的非常详细的信息。打开https://<host>:<port>
    URL以在Argo CD用户界面中查看应用列表。
- en: '![](Images/CH09_F06_Yuen.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F06_Yuen.png)'
- en: Figure 9.6 Application list page showing available Argo CD applications. The
    page provides high-level information about each application, such as sync and
    health status.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 显示可用Argo CD应用的列表页面。页面提供了关于每个应用的高级信息，例如同步和健康状态。
- en: The application list page provides high-level information about all deployed
    applications, including health and synchronization status. Using this page, you
    can quickly find if any of your applications have degraded or have configuration
    drift. The user interface is designed for large enterprises and able to handle
    hundreds of applications. You can use search and various filters to quickly find
    the desired applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 应用列表页面提供了所有已部署应用的高级信息，包括健康和同步状态。使用此页面，您可以快速查找是否有任何应用出现降级或配置漂移。用户界面是为大型企业设计的，能够处理数百个应用。您可以使用搜索和各种过滤器快速找到所需的应用。
- en: Exercise 9.6
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 练习9.6
- en: Experiment with the filters and page view settings to learn which other features
    are available in the applications list page.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整过滤器和平页面视图设置，以了解应用列表页面中其他哪些功能可用。
- en: Application details page
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 应用详情页面
- en: The additional information about the application is available on the application
    details page. Navigate to the application details page by clicking on the “sample
    app” application tile.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 关于应用程序的附加信息可在应用程序详情页面找到。通过点击“sample app”应用程序磁贴导航到应用程序详情页面。
- en: The application details page visualizes the application resources hierarchy
    and provides additional details about synchronization and health status. Let’s
    take a closer look at the application resource tree and learn which features it
    provides.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序详情页面可视化应用程序资源层次结构，并提供有关同步和健康状态的额外详细信息。让我们更仔细地查看应用程序资源树并了解它提供了哪些功能。
- en: The root element of the resource tree is the application itself. The next level
    consists of managed resources. The managed resources are resources that the manifest
    defined in Git and are controlled by Argo CD explicitly. As we’ve learned in chapter
    2, Kubernetes controllers often leverage delegation and create child resources
    to delegate the work. The third and deeper levels represent such resources. That
    provides complete information about every application element and makes the application
    details page an extremely powerful Kubernetes dashboard.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 资源树的根元素是应用程序本身。下一级包括管理资源。管理资源是 Git 中定义并由 Argo CD 明确控制的资源。正如我们在第 2 章中学到的，Kubernetes
    控制器通常利用委派并创建子资源来委派工作。第三级及更深层级代表这样的资源。这提供了关于每个应用程序元素的完整信息，使得应用程序详情页面成为一个极其强大的 Kubernetes
    仪表板。
- en: '![](Images/CH09_F07_Yuen.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F07_Yuen.png)'
- en: Figure 9.7 The application details page provides information about the application
    resource hierarchy as well as detailed information about each resource.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 应用程序详情页面提供了关于应用程序资源层次结构以及每个资源的详细信息。
- en: In addition to this information, the user interface allows executing various
    actions against each resource. It is possible to delete any resource, re-create
    it by running sync actions, update the resource definition using a built-in YAML
    editor, and even run resource-specific actions such as Deployment restart.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些信息外，用户界面允许对每个资源执行各种操作。可以删除任何资源，通过运行同步操作重新创建它，使用内置的 YAML 编辑器更新资源定义，甚至运行特定于资源的操作，如
    Deployment 重启。
- en: Exercise 9.7
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.7
- en: Go ahead, use the application details page to inspect your application. Try
    to find how to view the resource manifests, locate Pods, and see the live logs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用应用程序详情页面来检查你的应用程序。尝试找到查看资源清单、定位 Pod 和查看实时日志的方法。
- en: 9.3 Deep dive into Argo CD features
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 深入了解 Argo CD 功能
- en: So far, we’ve learned how to deploy new applications using Argo CD and get detailed
    application information using the CLI and the user interface. Next, let’s learn
    how to deploy a new application version using GitOps and Argo CD.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何使用 Argo CD 部署新应用程序以及如何使用 CLI 和用户界面获取详细的应用程序信息。接下来，让我们学习如何使用 GitOps
    和 Argo CD 部署新应用程序版本。
- en: 9.3.1 GitOps-driven deployment
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 GitOps 驱动的部署
- en: 'In order to perform GitOps deployment, we need to update resource manifests
    and let the GitOps operator push changes into the Kubernetes cluster. As a first
    step, clone the Deployment repository using the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行 GitOps 部署，我们需要更新资源清单并让 GitOps 操作员将更改推送到 Kubernetes 集群。作为第一步，使用以下命令克隆 Deployment
    仓库：
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, use the following command to change the image version of the Deployment
    resource:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令更改 Deployment 资源的形象版本：
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Use the `git diff` command to make sure that your Git repository has the expected
    changes:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `git diff` 命令确保你的 Git 仓库有预期的更改：
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, use `git` `commit` and `git` `push` to push changes to the remote
    Git repository:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `git commit` 和 `git push` 将更改推送到远程 Git 仓库：
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s use the Argo CD CLI to make sure that Argo CD correctly detected manifest
    changes in Git and then triggered a synchronization process to push the changes
    into the Kubernetes cluster:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Argo CD CLI 来确保 Argo CD 正确检测到 Git 中的清单更改并触发了同步过程以将更改推送到 Kubernetes 集群：
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Exercise 9.8
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.8
- en: Open the Argo CD UI and use the application details page to check the application
    sync status and inspect the managed resources status.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Argo CD UI 并使用应用程序详情页面来检查应用程序同步状态并检查管理资源状态。
- en: 'Use the `argocd sync` command to trigger the synchronization process:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `argocd sync` 命令触发同步过程：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Great, you just performed GitOps deployment using Argo CD!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，你刚刚使用 Argo CD 执行了 GitOps 部署！
- en: 9.3.2 Resource hooks
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 资源钩子
- en: Resource manifest syncing is just the basic use case. In real life, we often
    need to execute additional steps before and after actual deployment. For example,
    set the maintenance page, execute database migration before the new version deployment,
    and finally remove the maintenance page.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 资源清单同步只是基本用例。在现实生活中，我们通常需要在实际部署前后执行额外的步骤。例如，设置维护页面，在新版本部署前执行数据库迁移，最后移除维护页面。
- en: Traditionally these deployment steps are scripted in the CI pipeline. However,
    this again requires production access from the CI server, which involves a security
    threat. To solve that problem, Argo CD provides a feature called *resource hooks*.
    These hooks allow running custom scripts, typically packaged into a Pod or a Job,
    inside of the Kubernetes cluster during the synchronization process.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，这些部署步骤是在CI管道中编写的。然而，这又需要从CI服务器访问生产环境，这涉及到安全风险。为了解决这个问题，Argo CD提供了一种名为*资源钩子*的功能。这些钩子允许在同步过程中在Kubernetes集群内部运行自定义脚本，通常打包成一个Pod或一个Job。
- en: 'The hook is a Kubernetes resource manifest stored in the Git repository and
    annotated with the `argocd.argoproj.io/hook` annotation. The annotation value
    contains a comma-separated list of phases when the hook is supposed to be executed.
    The following phases are supported:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子是一个存储在Git仓库中并带有`argocd.argoproj.io/hook`注解的Kubernetes资源清单。注解值包含一个逗号分隔的列表，表示钩子应该执行的阶段。以下阶段被支持：
- en: '*Pre-sync*—Executes prior to the applying of the manifests'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*预同步*—在应用清单之前执行'
- en: '*Sync*—Executes after all pre-sync hooks completed and were successful, at
    the same time as the apply of the manifests'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同步*—在所有预同步钩子完成且成功执行后执行，同时执行清单的应用'
- en: '*Skip*—Indicates to Argo CD to skip the apply of the manifest'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*跳过*—指示Argo CD跳过清单的应用'
- en: '*Post-sync*—Executes after all sync hooks completed and were successful, a
    successful apply, and all resources in a healthy state'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同步后*—在所有同步钩子完成且成功执行、成功应用以及所有资源处于健康状态后执行'
- en: '*Sync-fai*—Executes when the sync operation fails'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*同步失败*—在同步操作失败时执行'
- en: The hooks are executed inside of the cluster, so there is no need to access
    the cluster from the CI pipeline. The ability to specify the sync phase provides
    the necessary flexibility and allows a mechanism to solve the majority of real-life
    deployment use cases.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子在集群内部执行，因此无需从CI管道访问集群。指定同步阶段的能力提供了必要的灵活性，并允许解决大多数现实生活中的部署用例的机制。
- en: '![](Images/CH09_F08_Yuen.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F08_Yuen.png)'
- en: Figure 9.8 The synchronization process includes three main phases. The pre-sync
    phase is used to execute preparation tasks such as database migration. The sync
    phase includes the synchronization of application resources. Finally, the post-sync
    phase runs postprocessing tasks, such as email notifications.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 同步过程包括三个主要阶段。预同步阶段用于执行准备任务，如数据库迁移。同步阶段包括应用资源同步。最后，同步后阶段运行后处理任务，如发送电子邮件通知。
- en: 'It is time to see the hooks feature in action! Add the hook definition into
    the sample app deployment repository and push changes to the remote repository:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看钩子功能在实际中的应用了！将钩子定义添加到示例应用部署仓库中，并将更改推送到远程仓库：
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Listing 9.1 http://mng.bz/go7l
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1 http://mng.bz/go7l
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The Argo CD user interface provides much better visualization of a dynamic
    process than the CLI. Let’s use it to better understand how hooks work. Open the
    Argo CD UI using the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD用户界面比CLI提供了更好的动态过程可视化。让我们使用它来更好地理解钩子是如何工作的。使用以下命令打开Argo CD UI：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Navigate to the `sample-app` details page and trigger the synchronization process
    using the Sync button. The syncing process is represented in figure 9.9.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`sample-app`详情页面，并使用同步按钮触发同步过程。同步过程在图9.9中展示。
- en: '![](Images/CH09_F09_Yuen.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH09_F09_Yuen.png)'
- en: Figure 9.9 The application detail page allows the user to trigger the synchronization
    as well as view detailed information about the synchronization progress, including
    synchronization hooks.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 应用详情页面允许用户触发同步，以及查看同步进度的详细信息，包括同步钩子。
- en: As soon as the sync is started, the application details page shows live process
    status in the top-right corner. The status includes information about operation
    start time and duration. You can view the syncing status panel with detailed information,
    including sync hook results, by clicking the Sync Status icon.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始同步，应用程序详情页面在右上角显示实时进程状态。状态包括操作开始时间和持续时间。您可以通过点击同步状态图标查看包含同步钩子结果的详细信息的同步状态面板。
- en: The hooks are stored as the regular resource manifests in the Git repository
    and also visualized as regular resources in the Application resource tree. You
    can see the real-time status of the “before” job and use the Argo CD user interface
    to inspect child Pods.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子以常规资源清单的形式存储在 Git 仓库中，并在应用程序资源树中以常规资源的形式可视化。您可以看到“删除前”作业的实时状态，并使用 Argo CD
    用户界面检查子 Pod。
- en: In addition to phases, you might customize the hook deletion policy. The deletion
    policy allows automating hook resources deletion that will save you a lot of manual
    work.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了阶段之外，您还可以自定义钩子删除策略。删除策略允许自动化钩子资源的删除，这将为您节省大量的手动工作。
- en: Exercise 9.9
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 9.9
- en: Read more details in the Argo CD documentation^([6](#pgfId-1083590)) and change
    the “before” job deletion policy. Use the Argo CD user interface to observe how
    various deletion policies affect hook behavior. Synchronize the application and
    observe how hook resources got created and deleted by Argo CD.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Argo CD 文档中阅读更多详细信息^([6](#pgfId-1083590)) 并更改“删除前”作业的策略。使用 Argo CD 用户界面来观察不同的删除策略如何影响钩子行为。同步应用程序并观察
    Argo CD 如何创建和删除钩子资源。
- en: 9.3.3 Postdeployment verification
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.3 部署后验证
- en: Resource hooks allow encapsulating the application synchronization logic, so
    we don’t have to use scripts and continuous integration tools. However, some of
    such use cases naturally belong to continuous integration processes, and it is
    still preferable to use tools like Jenkins.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 资源钩子允许封装应用程序同步逻辑，因此我们不必使用脚本和持续集成工具。然而，某些此类用例自然属于持续集成流程，并且仍然更倾向于使用像 Jenkins 这样的工具。
- en: One such use case is postdeployment verification. The challenge here is that
    GitOps deployment is asynchronous by nature. After the commit is pushed to the
    Git repository, we still need to make sure that changes are propagated to the
    Kubernetes cluster. Even after changes are propagated, it is not safe to start
    running tests. In most cases, the update of a Kubernetes resource is not instant,
    either. For example, the Deployment resource update triggers the rolling-update
    process. The rolling update might take several minutes or even fail if the new
    application version has an issue. So if you start tests too early, you might end
    up testing the previously deployed application version.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个用例是部署后验证。这里的挑战在于 GitOps 部署本质上是异步的。在将提交推送到 Git 仓库之后，我们仍然需要确保更改已传播到 Kubernetes
    集群。即使在更改已传播之后，启动测试也不是安全的。在大多数情况下，Kubernetes 资源更新也不是瞬时的。例如，Deployment 资源更新会触发滚动更新过程。滚动更新可能需要几分钟，如果新应用程序版本存在问题，甚至可能失败。因此，如果您开始测试过早，可能会测试之前部署的应用程序版本。
- en: 'Argo CD makes this issue trivial by providing tools that help to monitor application
    status. The `argocd app wait` command monitors the application and exits after
    the application reaches a synced and healthy state. As soon as the command exits,
    you can assume that all changes are successfully rolled out, and it is safe to
    start postdeployment verification. The `argocd` `app` `wait` command is often
    used in conjunction with `argocd` `app` `sync`. Use the following command to synchronize
    your application and wait until the change is fully rolled out, and the application
    is ready for testing:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD 通过提供帮助监控应用程序状态的工具，使这个问题变得微不足道。`argocd app wait` 命令监控应用程序，在应用程序达到同步和健康状态后退出。一旦命令退出，您就可以假设所有更改都已成功部署，并且可以安全地开始部署后验证。`argocd
    app wait` 命令通常与 `argocd app sync` 一起使用。使用以下命令同步您的应用程序，并等待更改完全部署，应用程序准备就绪进行测试：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 9.4 Enterprise features
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 企业功能
- en: Argo CD is pretty lightweight, and it is really easy to start using it. At the
    same time, it scales well for a large enterprise and is able to accommodate the
    needs of multiple teams. The enterprise features can be configured as you go.
    If you are rolling out an Argo CD for your organization, then the first question
    is how to configure the end user and effectively manage access control.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD非常轻量级，并且使用起来非常简单。同时，它对于大型企业具有良好的可扩展性，能够满足多个团队的需求。企业功能可以根据需要进行配置。如果您正在为您的组织部署Argo
    CD，那么第一个问题就是如何配置最终用户并有效地管理访问控制。
- en: 9.4.1 Single sign-on
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.1 单点登录
- en: Instead of introducing its own user management system, Argo CD provides integration
    with multiple SSO services. The list includes Okta, Google OAuth, Azure AD, and
    many more.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD没有引入自己的用户管理系统，而是提供了与多个SSO服务的集成。该列表包括Okta、Google OAuth、Azure AD以及更多。
- en: SSO SSO is a session and user authentication service that allows a user to use
    one set of login credentials to access multiple applications.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: SSO SSO是一种会话和用户身份验证服务，允许用户使用一组登录凭证访问多个应用程序。
- en: The SSO integration is great because it saves you a lot of management overhead,
    and end users don’t have to remember another set of login credentials. There are
    several open standards for exchanging authentication and authorization data. The
    most popular ones are SAML, OAuth, and OpenID Connect (OIDC). Of the three, SAML
    and OIDC satisfy the best requirements of a typical enterprise and can be used
    to implement SSO. Argo CD decided to go ahead with OIDC because of its power and
    simplicity.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: SSO集成非常出色，因为它可以为您节省大量的管理开销，并且最终用户无需记住另一组登录凭证。存在几种用于交换身份验证和授权数据的开放标准。其中最受欢迎的是SAML、OAuth和OpenID
    Connect (OIDC)。在这三者中，SAML和OIDC最符合典型企业的需求，可以用来实现SSO。Argo CD决定采用OIDC，因为它具有强大的功能和简单的特性。
- en: 'The number of steps required to configure an OIDC integration depends on your
    OIDC provider. The Argo CD community already contributed a number of instructions
    for popular OIDC providers such as Okta and Azure AD. After performing the configuration
    on the OIDC provider side, you need to add the corresponding configuration to
    the `argocd-cm` ConfigMap. The following snippet represents the sample Okta configuration:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 配置OIDC集成所需的步骤数量取决于您的OIDC提供者。Argo CD社区已经为Okta和Azure AD等流行的OIDC提供者贡献了许多说明。在OIDC提供者端完成配置后，您需要将相应的配置添加到`argocd-cm`
    ConfigMap中。以下是一个示例Okta配置片段：
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ The externally facing base URL Argo CD URL
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 面向外部的基URL Argo CD URL
- en: ❷ OIDC configuration that includes Okta application client id and secret
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 包含Okta应用程序客户端ID和密钥的OIDC配置
- en: What if your organization does not have an OIDC-compatible SSO service? In this
    case, you can use a federated OIDC provider, Dex,^([7](#pgfId-1083642)) which
    is bundled into the Argo CD by default. Dex acts as a proxy to other identity
    providers and allows establishing integration with SAML, LDAP providers, or even
    services like GitHub and Active Directory.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的组织没有OIDC兼容的SSO服务怎么办？在这种情况下，您可以使用一个联邦OIDC提供者，Dex，^([7](#pgfId-1083642))，它默认包含在Argo
    CD中。Dex充当其他身份提供者的代理，并允许与SAML、LDAP提供者或GitHub和Active Directory等服务建立集成。
- en: GitHub often is a very attractive option, especially if it is already used by
    developers in your organization. Additionally, organizations and teams configured
    in GitHub naturally fit the access control model required to organize cluster
    access. As you are going to learn soon, it is very easy to model Argo CD access
    using the GitHub team membership. Let’s use GitHub to enhance our Argo CD installation
    and enable SSO integration.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub通常是一个非常吸引人的选择，尤其是如果它已经被您的组织中的开发者使用。此外，在GitHub中配置的组织和团队自然符合组织集群访问所需的访问控制模型。正如您很快就会学到的那样，使用GitHub团队成员资格来建模Argo
    CD访问非常简单。让我们使用GitHub来增强我们的Argo CD安装并启用SSO集成。
- en: First of all, we need to create a GitHub OAuth application. Navigate to [https://github.com/settings/applications/new](https://github.com/settings/applications/new)
    and configure the application settings as represented in figure 9.10.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个GitHub OAuth应用程序。导航到[https://github.com/settings/applications/new](https://github.com/settings/applications/new)并配置应用程序设置，如图9.10所示。
- en: '![](Images/CH09_F10_Yuen.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10](Images/CH09_F10_Yuen.png)'
- en: Figure 9.10 New GitHub OAuth application settings include the application name
    and description, home page URL, and, most importantly, the authorization callback
    URL.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 新的GitHub OAuth应用程序设置包括应用程序名称和描述、主页URL，最重要的是，授权回调URL。
- en: Specify the application name of your choice and the home page URL that matches
    the Argo CD web user interface URL. The most important application setting is
    the callback URL. The callback URL value is the Argo CD web user interface URL
    plus the /api/dex/callback path. The sample URL with minikube might be http://192.168.64.2:32638/api/dex/callback.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 指定您选择的应用程序名称和与 Argo CD 网页用户界面 URL 匹配的首页 URL。最重要的应用程序设置是回调 URL。回调 URL 的值是 Argo
    CD 网页用户界面 URL 加上 /api/dex/callback 路径。使用 minikube 的示例 URL 可能是 http://192.168.64.2:32638/api/dex/callback。
- en: After creating the application, you will be redirected to the OAuth application
    settings page. Copy the application Client ID and Client Secret. These values
    will be used to configure the Argo CD settings.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用程序后，您将被重定向到 OAuth 应用程序设置页面。复制应用程序客户端 ID 和客户端密钥。这些值将用于配置 Argo CD 设置。
- en: '![](Images/CH09_F11_Yuen.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH09_F11_Yuen.png)'
- en: Figure 9.11 The GitHub OAuth application settings page displays the Client ID
    and Client Secret values, which are required to configure the SSO integration.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 GitHub OAuth 应用程序设置页面显示客户端 ID 和客户端密钥值，这些值是配置 SSO 集成所必需的。
- en: Substitute the placeholder values in the argocd-cm.yaml file with your environment
    values.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 argocd-cm.yaml 文件中将占位符值替换为您的环境值。
- en: Listing 9.2 http://mng.bz/pV1G
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 http://mng.bz/pV1G
- en: '[PRE16]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ The externally facing base URL Argo CD URL
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 面向外部的基 URL Argo CD URL
- en: ❷ GitHub OAuth application client ID
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ GitHub OAuth 应用程序客户端 ID
- en: ❸ GitHub OAuth application client secret
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ GitHub OAuth 应用程序客户端密钥
- en: 'Update the Argo CD ConfigMap using the `kubectl apply` command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl apply` 命令更新 Argo CD ConfigMap：
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You are ready to go! Open the Argo CD user interface in the browser and use
    the Login Via GitHub button.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经准备就绪！在浏览器中打开 Argo CD 用户界面并使用“通过 GitHub 登录”按钮。
- en: 9.4.2 Access control
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.2 访问控制
- en: You might notice that after a successful login using GitHub SSO integration,
    the application list page is empty. If you try creating a new application, you
    will see a “permission denied” error. This behavior is expected because we have
    not given any permission to the new SSO user yet. In order to provide the user
    with appropriate access, we need to update the Argo CD access control settings.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，使用 GitHub SSO 集成成功登录后，应用程序列表页面为空。如果您尝试创建新的应用程序，您将看到“权限拒绝”错误。这种行为是预期的，因为我们尚未为新
    SSO 用户授予任何权限。为了向用户提供适当的访问权限，我们需要更新 Argo CD 访问控制设置。
- en: Argo CD provides a flexible role-based access control (RBAC) system whose implementation
    is based on Casbin,^([8](#pgfId-1083704)) a powerful open source access control
    library. Casbin provides a very solid foundation and allows configuring various
    access control rules.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD 提供了一个灵活的基于角色的访问控制（RBAC）系统，其实施基于 Casbin，^([8](#pgfId-1083704)) 一个强大的开源访问控制库。Casbin
    提供了一个非常坚实的基础，并允许配置各种访问控制规则。
- en: The RBAC Argo CD settings are configured using `argocd-rbac-cm` `ConfigMap`.
    To quickly dive into the configuration details, let’s update the ConfigMap fields
    and then go together through each change.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC Argo CD 设置是通过 `argocd-rbac-cm` `ConfigMap` 配置的。为了快速深入了解配置细节，让我们更新 ConfigMap
    字段，然后一起查看每个更改。
- en: Substitute the `<username>` placeholder with your GitHub account username in
    the argocd-rbac-cm.yaml file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在 argocd-rbac-cm.yaml 文件中将 `<username>` 占位符替换为您的 GitHub 账户用户名。
- en: Listing 9.3 http://mng.bz/OEPn
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 http://mng.bz/OEPn
- en: '[PRE18]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ The policy.csv contains role-based access rules.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ policy.csv 包含基于角色的访问规则。
- en: ❷ The scopes setting specifieswhich JWT claim is used to infer user groups.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 范围设置指定了用于推断用户组的 JWT 声明。
- en: 'Apply the RBAC changes using the `kubectl apply` command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl apply` 命令应用 RBAC 更改：
- en: '[PRE19]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `policy.csv` field in this configuration defines a role named `role:developer`
    with full permissions on Argo CD applications and read-only permissions over Argo
    CD system settings. The role is granted to any user that belongs to a group whose
    name matches your GitHub account username. As soon as changes are applied, refresh
    the applications list page and try syncing the `sample-app` application.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置中的 `policy.csv` 字段定义了一个名为 `role:developer` 的角色，该角色对 Argo CD 应用程序拥有完全权限，并且对
    Argo CD 系统设置拥有只读权限。该角色授予任何属于名称与您的 GitHub 账户用户名匹配的组的用户。一旦应用更改，刷新应用程序列表页面并尝试同步 `sample-app`
    应用程序。
- en: We’ve introduced quite a few new terms. Let’s step back and discuss what roles,
    groups, and claims are and how they work together.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了一些新的术语。让我们回顾一下角色、组和声明是什么，以及它们是如何协同工作的。
- en: Role
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 角色
- en: The role allows or denies a set of actions on an Argo CD object to a particular
    subject. The role is defined in the form
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 角色允许或拒绝对Argo CD对象上的特定主题执行一组动作。角色以以下形式定义
- en: '[PRE20]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: where
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '`p` indicates the RBAC policy line.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p`表示RBAC策略行。'
- en: '`subject` is a group.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subject`是一个组。'
- en: '`resource` is one of the Argo CD resource types. Argo CD supports the following
    resources: `"clusters"`, `"projects"`, `"applications"`, `"repositories"`, `"certificates"`,
    `"accounts"`.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource`是Argo CD资源类型之一。Argo CD支持以下资源：`"clusters"`、`"projects"`、`"applications"`、`"repositories"`、`"certificates"`、`"accounts"`。'
- en: '`action` is an action name that might be executed against a resource. All Argo
    CD resources support the following actions: `"get"`, `"create"`, `"update"`, `"delete"`.
    The `"*"` value matches any action.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action`是对资源可能执行的动作名称。所有Argo CD资源都支持以下动作：`"get"`、`"create"`、`"update"`、`"delete"`。`"*"`值匹配任何动作。'
- en: '`object` is a pattern that identifies a particular resource instance. The `"*"`
    value matches any instance.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`object`是一个标识特定资源实例的模式。`"*"`值匹配任何实例。'
- en: '`effect` defines whether the role grants or denies the action.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`effect`定义了角色是授予还是拒绝动作。'
- en: 'The `role:developer` role from this example allows any action against any Argo
    CD application:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的`role:developer`角色允许对任何Argo CD应用程序执行任何动作：
- en: '[PRE21]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Group
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 组
- en: A group provides the ability to identify a set of users and works in conjunction
    with OIDC integration. After performing the successful OIDC authentication, the
    end user receives a JWT token that verifies the user identity as well as provides
    additional metadata stored in the token claims.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 组提供识别一组用户的能力，并与OIDC集成协同工作。在成功执行OIDC身份验证后，最终用户会收到一个JWT令牌，该令牌验证用户身份并提供存储在令牌断言中的额外元数据。
- en: JWT token A JWT token is an internet standard for creating JSON-based access
    tokens that assert some number of claims.^([9](#pgfId-1083765))
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: JWT令牌JWT令牌是一个互联网标准，用于创建基于JSON的访问令牌，该令牌断言一些断言。^([9](#pgfId-1083765))
- en: The token is supplied with every Argo CD request. The Argo CD extracts the list
    of groups that a user belongs to from a configured list of token claims and uses
    it to verify user permissions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌随每个Argo CD请求提供。Argo CD从配置的令牌断言列表中提取用户所属的组列表，并使用它来验证用户权限。
- en: 'Following is a token claims example generated by Dex:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由Dex生成的令牌断言示例：
- en: '[PRE22]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The token contains two claims that might be useful for authorization:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌包含两个可能对授权有用的断言：
- en: '`groups` includes a list of GitHub organizations and teams the user belongs
    to.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groups`包括用户所属的GitHub组织和团队列表。'
- en: '`preferred_username` is the GitHub account username.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preferred_username`是GitHub账户用户名。'
- en: By default, Argo CD uses `groups` to retrieve user groups from the JWT token.
    We’ve added the `preferred_username` claim using the `scopes` setting to allow
    identifying GitHub users by name.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Argo CD使用`groups`从JWT令牌中检索用户组。我们已通过`scopes`设置添加了`preferred_username`断言，以便可以通过名称识别GitHub用户。
- en: Exercise 9.10
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 练习9.10
- en: Update the `argocd-rbac-cm` ConfigMap to provide admin access to the GitHub
    user based on their email.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`argocd-rbac-cm` ConfigMap，以便根据用户的电子邮件提供对GitHub用户的管理员访问权限。
- en: Note This chapter covers important foundations of Argo CD and gets you ready
    for further learning. Explore the Argo CD documentation to learn about diffing
    logic customization, fine-tuning config management tools, advanced security features
    such as auth tokens, and much more. The project keeps evolving and getting new
    features in every release. Check out the Argo CD blog to stay up to date with
    the changes, and don’t hesitate to ask questions in the Argoproj slack channel.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章涵盖了Argo CD的重要基础，并为您进一步学习做好准备。探索Argo CD文档，了解差异逻辑定制、微调配置管理工具、高级安全功能（如身份验证令牌）等。项目不断进化，并在每个版本中添加新功能。查看Argo
    CD博客以了解最新变化，并在Argoproj的Slack频道中不要犹豫提问。
- en: 9.4.3 Declarative management
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.3 声明式管理
- en: As you might’ve noticed, Argo CD provides a lot of configuration settings. The
    RBAC policies, SSO settings, Applications, and Projects—all of those are settings
    that have to be managed by someone. The good news is that you can leverage GitOps
    and use Argo CD to manage itself!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，Argo CD提供了大量的配置设置。RBAC策略、SSO设置、应用程序和项目——所有这些都需要有人来管理。好消息是你可以利用GitOps并使用Argo
    CD来自动管理自己！
- en: All Argo CD settings are persisted in Kubernetes resources. The SSO and RBAC
    settings stored in ConfigMap and Applications and Projects are stored in custom
    resources, so you can store these resource manifests in a Git repository and configure
    Argo CD to use it as a source of truth. This technique is very powerful and allows
    us to manage configuration settings as well as seamlessly upgrade the Argo CD
    version.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Argo CD设置都持久化在Kubernetes资源中。SSO和RBAC设置存储在ConfigMap中，而应用程序和项目存储在自定义资源中，因此您可以将这些资源清单存储在Git仓库中，并配置Argo
    CD使用它作为真相来源。这项技术非常强大，允许我们管理配置设置，以及无缝升级Argo CD版本。
- en: As a first step, let’s demonstrate how to convert the SSO and RBAC changes we’ve
    just made imperatively into a declarative configuration. To do so we would need
    to create a Git repository that stores manifest definitions of every Argo CD component.
    Instead of starting from scratch, you can just use the code listings in the repository
    at [https://github.com/gitopsbook/resources](https://github.com/gitopsbook/resources)
    as a starting point. Navigate to the repository GitHub URL and create your personal
    fork so you can store settings specific to your environment.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，让我们演示如何将我们刚刚强制执行的SSO和RBAC更改转换为声明性配置。为此，我们需要创建一个Git仓库，用于存储每个Argo CD组件的清单定义。您可以直接从[https://github.com/gitopsbook/resources](https://github.com/gitopsbook/resources)仓库中的代码列表作为起点。导航到仓库的GitHub
    URL，创建您个人的分叉，以便您可以存储特定于您环境的设置。
- en: The required manifest files are located in the chapter-09 directory, and the
    first file we should look at is represented in the following listing.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的清单文件位于第09章目录中，我们应该首先查看的文件如下所示。
- en: Listing 9.4 http://mng.bz/YqRN
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 http://mng.bz/YqRN
- en: '[PRE23]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ The remote file URL containing default Argo CD manifests
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含默认Argo CD清单的远程文件URL
- en: ❷ The file path that contains argocd-cm ConfigMap modifications
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 包含argocd-cm ConfigMap修改的文件路径
- en: ❸ The file path that contains argocd-rbac-cm ConfigMap modifications
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 包含argocd-rbac-cm ConfigMap修改的文件路径
- en: ❹ The file path that contains argocd-server Service modifications
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 包含argocd-server服务修改的文件路径
- en: The kustomization.yaml file contains references to the default Argo CD manifests
    and files with the environment-specific changes.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: kustomization.yaml文件包含对默认Argo CD清单和具有特定环境更改的文件的引用。
- en: 'The next step is to move your environment-specific changes into Git and push
    them into the remote Git repository. Clone the forked Git repository:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将特定环境的更改移动到Git中，并将它们推送到远程Git仓库。克隆分叉的Git仓库：
- en: '[PRE24]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Repeat the changes to the argocd-cm.yaml and argocd-rbac-cm.yaml files described
    in sections 9.4.1 and 9.4.2\. Add SSO configuration to the ConfigMap manifest
    in argocd-cm.yaml. Update the RBAC policy in the argocd-rbac-cm.yaml file. Once
    the files are updated, commit and push the changes back to the remote repository:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 重复第9.4.1节和第9.4.2节中描述的argocd-cm.yaml和argocd-rbac-cm.yaml文件的更改。在argocd-cm.yaml中的ConfigMap清单中添加SSO配置。更新argocd-rbac-cm.yaml文件中的RBAC策略。一旦文件更新，提交并将更改推回远程仓库：
- en: '[PRE25]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The hardest part is done! Argo CD config changes are not version controlled
    and can be managed using GitOps methodology. The last step is to create an Argo
    CD application that deploys Kustomize-based manifests from your Git repository
    into the `argocd` Namespace:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最困难的部分已经完成！Argo CD配置更改不受版本控制，可以使用GitOps方法进行管理。最后一步是创建一个Argo CD应用程序，将基于Kustomize的清单从您的Git仓库部署到`argocd`命名空间：
- en: '[PRE26]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As soon as the application is created, Argo CD should detect already deployed
    resources and visualize the detected deviations.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建应用程序，Argo CD应该检测已部署的资源并可视化检测到的偏差。
- en: So how about managing applications and projects? Both are represented by the
    Kubernetes custom resource and might be managed using GitOps as well. The manifest
    in the next listing represents the declarative definition of the `sample-app`
    Argo CD application that we created manually earlier in the chapter. In order
    to start managing `sample-app` declaratively, add the sample-app.yaml into the
    resources section of kustomization.yaml and push the change back to your repository
    fork.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何管理应用程序和项目呢？两者都由Kubernetes自定义资源表示，也可能使用GitOps进行管理。下一条清单中的清单代表了我们之前在章节中手动创建的`sample-app`
    Argo CD应用程序的声明性定义。为了开始以声明性方式管理`sample-app`，将sample-app.yaml添加到kustomization.yaml的资源部分，并将更改推回您的仓库分叉。
- en: Listing 9.5 http://mng.bz/Gx9q
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.5 http://mng.bz/Gx9q
- en: '[PRE27]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, you don’t have to choose between declarative and imperative
    management styles. Argo CD supports using both simultaneously so that some settings
    are managed using GitOps and some are managed using imperative commands.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您不必在声明式和管理式管理风格之间做出选择。Argo CD 支持同时使用这两种风格，以便某些设置使用 GitOps 管理，而某些设置使用命令式命令管理。
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Argo CD is designed with enterprises in mind and can be offered as a centralized
    service to support multitenancy and multiclustering for large enterprises.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argo CD 考虑到企业需求而设计，可以作为集中式服务提供给大型企业，以支持多租户和多集群。
- en: As a continuous deployment tool, Argo CD also provides detail diff among Git,
    target Kubernetes clusters, and running states for observability.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为持续部署工具，Argo CD 还提供了 Git、目标 Kubernetes 集群和运行状态之间的详细差异，以实现可观察性。
- en: 'Argo CD automates three phases in deployment:'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argo CD 自动化部署的三个阶段：
- en: Retrieve resource manifests.
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取资源清单。
- en: Detect and fix the deviations.
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测并修复偏差。
- en: Present the results to end users.
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果呈现给最终用户。
- en: Argo CD provides CLI for configuring Application deployment and can be incorporated
    into CI solutions through scripting.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argo CD 提供了用于配置应用程序部署的 CLI，并且可以通过脚本集成到 CI 解决方案中。
- en: Argo CD’s CLI and web interface can be used to inspect applications’ sync and
    health statuses.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argo CD 的 CLI 和 Web 界面可用于检查应用程序的同步和健康状态。
- en: Argo CD provides resource hooks to enable additional customization of the deployment
    life cycle.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argo CD 提供资源钩子，以启用对部署生命周期的额外自定义。
- en: Argo CD also provides support to ensure deployment completion and application
    readiness.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argo CD 还提供支持以确保部署完成和应用程序就绪。
- en: Argo CD supports both SSO and RBAC integration for enterprise-level SSO and
    access control.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argo CD 支持企业级 SSO 和 RBAC 集成，以实现单点登录和访问控制。
- en: '* * *'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1. [https://argoproj.github.io/projects/argo-cd](https://argoproj.github.io/projects/argo-cd).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 1. [https://argoproj.github.io/projects/argo-cd](https://argoproj.github.io/projects/argo-cd).
- en: 2.[http://mng.bz/aomz](https://shortener.manning.com/aomz).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 2.[http://mng.bz/aomz](https://shortener.manning.com/aomz).
- en: 3.[https://argoproj.github.io/argo-cd/getting_started/](https://argoproj.github.io/argo-cd/getting_started/).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 3.[https://argoproj.github.io/argo-cd/getting_started/](https://argoproj.github.io/argo-cd/getting_started/).
- en: 4.[https://help.github.com/en/github/getting-started-with-github/fork-a-repo](https://help.github.com/en/github/getting-started-with-github/fork-a-repo).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 4.[https://help.github.com/en/github/getting-started-with-github/fork-a-repo](https://help.github.com/en/github/getting-started-with-github/fork-a-repo).
- en: 5.[https://argoproj.github.io/argo-cd/user-guide/auto_sync/](https://argoproj.github.io/argo-cd/user-guide/auto_sync/).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 5.[https://argoproj.github.io/argo-cd/user-guide/auto_sync/](https://argoproj.github.io/argo-cd/user-guide/auto_sync/).
- en: 6.[http://mng.bz/e5Ez](http://mng.bz/e5Ez).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 6.[http://mng.bz/e5Ez](http://mng.bz/e5Ez).
- en: 7.[https://github.com/dexidp/dex](https://github.com/dexidp/dex).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 7.[https://github.com/dexidp/dex](https://github.com/dexidp/dex).
- en: 8.[https://github.com/casbin/casbin](https://github.com/casbin/casbin).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 8.[https://github.com/casbin/casbin](https://github.com/casbin/casbin).
- en: 9.[https://en.wikipedia.org/wiki/JSON_Web_Token](https://en.wikipedia.org/wiki/JSON_Web_Token).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 9.[https://en.wikipedia.org/wiki/JSON_Web_Token](https://en.wikipedia.org/wiki/JSON_Web_Token).
