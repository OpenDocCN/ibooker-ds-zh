- en: 2 A first unit test
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 第一次单元测试
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Writing your first test with Jest
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jest 编写你的第一个测试
- en: Test structure and naming conventions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试结构和命名约定
- en: Working with the assertion library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用断言库进行工作
- en: Refactoring tests and reducing repetitive code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构测试和减少重复代码
- en: When I first started writing unit tests with a real unit testing framework,
    there was little documentation, and the frameworks I worked with didn’t have proper
    examples. (I was mostly coding in VB 5 and 6 at the time.) It was a challenge
    learning to work with them, and I started out writing rather poor tests. Fortunately,
    times have changed. In JavaScript, and in practically any language out there,
    there’s a wide range of choices and plenty of documentation and support from the
    community for trying out these bundles of helpfulness.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次开始使用真正的单元测试框架编写单元测试时，几乎没有文档，我工作的框架也没有合适的示例。（当时我主要在用VB 5和6进行编码。）学习如何与他们一起工作是一个挑战，我开始编写相当糟糕的测试。幸运的是，时代已经改变。在JavaScript中，实际上在所有语言中，都有广泛的选择，社区提供了大量的文档和支持来尝试这些有用的捆绑包。
- en: In the previous chapter, we wrote a very simple home-grown test framework. In
    this chapter, we’ll take a look at Jest, which will be our framework of choice
    for this book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们编写了一个非常简单的自编测试框架。在这一章中，我们将探讨 Jest，它将成为本书的框架选择。
- en: 2.1 Introducing Jest
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 介绍 Jest
- en: Jest is an open source test framework created by Facebook. It’s easy to use,
    easy to remember, and has lots of great features. Jest was originally created
    for testing frontend React components in JavaScript. These days it’s widely used
    in many parts of the industry for both backend and frontend project testing. It
    supports two major flavors of test syntax (one that uses the word `test` and another
    that’s based on the Jasmin syntax, a framework that has inspired many of Jest’s
    features). We’ll try both of them to see which one we like better.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Jest是由Facebook创建的开源测试框架。它易于使用，易于记忆，并且有很多优秀的功能。Jest最初是为在JavaScript中测试前端React组件而创建的。如今，它在行业的许多部分都广泛用于后端和前端项目的测试。它支持两种主要的测试语法（一种使用单词`test`，另一种基于Jasmin语法，这是一个启发了Jest许多功能的框架）。我们将尝试两者，看看我们更喜欢哪一个。
- en: Aside from Jest, there are many other testing frameworks in JavaScript, pretty
    much all open source as well. There are some differences between them in style
    and APIs, but for the purposes of this book, that shouldn’t matter too much.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Jest，JavaScript中还有许多其他的测试框架，几乎都是开源的。它们在风格和API上有些不同，但就本书的目的而言，这并不重要太多。
- en: 2.1.1 Preparing our environment
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 准备我们的环境
- en: Make sure you have Node.js installed locally. You can follow the instructions
    at [https://nodejs.org/en/download/](https://nodejs.org/en/download/) to get it
    up and running on your machine. The site will provide you with the option of either
    a long-term support (LTS) release or a current release. The LTS release is geared
    toward enterprises, whereas the current release has more frequent updates. Either
    will work for the purposes of this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经在本地安装了Node.js。你可以按照[https://nodejs.org/en/download/](https://nodejs.org/en/download/)上的说明来在你的机器上安装它。该网站将提供长期支持（LTS）版本或当前版本的选项。LTS版本面向企业，而当前版本有更频繁的更新。对于本书的目的来说，两者都适用。
- en: Make sure that the node package manager (npm) is installed on your machine.
    It is included with Node.js, so run the command `npm` `-v` on the command line,
    and if you see a version of 6.10.2 or higher, you should be good to go. If not,
    make sure Node.js is installed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的机器上安装了node包管理器（npm）。它包含在Node.js中，所以请在命令行上运行`npm -v`命令，如果你看到一个6.10.2或更高版本的版本，你应该可以开始了。如果不是，请确保已经安装了Node.js。
- en: 2.1.2 Preparing our working folder
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 准备我们的工作文件夹
- en: To get started with Jest, let’s create a new empty folder named “ch2” and initialize
    it with a package manager of your choice. I’ll use npm, since I have to choose
    one. Yarn is an alternative package manager. It shouldn’t matter, for the purposes
    of this book, which one you use.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Jest，让我们创建一个名为“ch2”的新空文件夹，并用你选择的包管理器初始化它。我会使用npm，因为我必须选择一个。Yarn是另一种包管理器。对于本书的目的来说，你使用哪一个并不重要。
- en: 'Jest expects either a jest.config.js or a package.json file. We’re going with
    the latter, and `npm` `init` will generate one for us:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Jest期望有一个jest.config.js文件或一个package.json文件。我们将选择后者，`npm init`将为生成一个：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I’m also initializing Git in this folder. This would be recommended anyway,
    to track changes, but for Jest this file is used under the covers to track changes
    to files and run specific tests. It makes Jest’s life easier.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我也在这个文件夹中初始化 Git。这无论如何都是推荐的，以跟踪更改，但对于 Jest 来说，这个文件在幕后用于跟踪文件更改并运行特定的测试。这使得 Jest
    的生活更加轻松。
- en: By default, Jest will look for its configuration either in the package.json
    file that is created by this command or in a special jest.config.js file. For
    now, we won’t need anything but the default package.json file. If you’d like to
    learn more about the Jest configuration options, refer to [https://jestjs.io/docs/en/configuration](https://jestjs.io/docs/en/configuration).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Jest 将在其配置文件中查找配置，该文件是由此命令创建的 package.json 文件，或者在一个特殊的 jest.config.js
    文件中。目前，我们不需要除了默认的 package.json 文件以外的任何东西。如果您想了解更多关于 Jest 配置选项的信息，请参阅 [https://jestjs.io/docs/en/configuration](https://jestjs.io/docs/en/configuration)。
- en: 2.1.3 Installing Jest
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 安装 Jest
- en: 'Next, we’ll install Jest. To install Jest as a dev dependency (which means
    it does not get distributed to production) we can use this command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将安装 Jest。为了将 Jest 作为开发依赖项安装（这意味着它不会被分发到生产环境中），我们可以使用以下命令：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will create a new jest.js file under our [root folder]/node_modules/bin.
    We can then execute Jest using the `npx` `jest` command.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的 [根文件夹]/node_modules/bin 下创建一个新的 jest.js 文件。然后我们可以使用 `npx` `jest` 命令来执行
    Jest。
- en: 'We can also install Jest *globally* on the local machine (I recommend doing
    this on top of the `save-dev` installation) by executing this command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在本地机器上全局安装 Jest（我建议在 `save-dev` 安装之上执行此操作）通过执行以下命令：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will give us the freedom to execute the `jest` command directly from the
    command line in any folder that has tests, without going through npm to execute
    it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够在任何有测试的文件夹中直接从命令行执行 `jest` 命令，而无需通过 npm 来执行它。
- en: In real projects, it is common to use `npm` commands to run tests instead of
    using the global `jest`. I’ll show how this is done in the next few pages.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际项目中，通常使用 `npm` 命令来运行测试，而不是使用全局的 `jest`。我将在接下来的几页中展示如何这样做。
- en: 2.1.4 Creating a test file
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.4 创建测试文件
- en: 'Jest has a couple of default ways to find test files:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 有几种默认方式来查找测试文件：
- en: If there’s a __tests__ folder, it loads all the files in it as test files, regardless
    of their naming conventions.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有 __tests__ 文件夹，它将加载其中的所有文件作为测试文件，无论它们的命名约定如何。
- en: It tries to find any file that ends with *.spec.js or *.test.js, in any folder
    under the root folder of your project, recursively.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会尝试查找任何以 *.spec.js 或 *.test.js 结尾的文件，在项目根目录下的任何文件夹中，递归地查找。
- en: We’ll use the first variation, but we’ll also name our files with either *test.js
    or *.spec.js to make things a bit more consistent in case we want to move them
    around later (and stop using the __tests_ folder altogether).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用第一种变体，但也会用 *test.js 或 *.spec.js 命名我们的文件，以便在以后移动它们时保持一致性（并完全停止使用 __tests_
    文件夹）。
- en: You can also configure Jest to your heart’s content, specifying how to find
    which files where, with a jest.config.js file or through package.json. You can
    look up the Jest docs at [https://jestjs.io/docs/en/configuration](https://jestjs.io/docs/en/configuration)
    to find all the gory details.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以根据个人喜好配置 Jest，指定如何查找哪些文件在哪里，通过 jest.config.js 文件或通过 package.json 实现。您可以在
    [https://jestjs.io/docs/en/configuration](https://jestjs.io/docs/en/configuration)
    查找 Jest 文档，以获取所有详细信息。
- en: The next step is to create a special folder under our ch2 folder called __tests__.
    Under this folder, create a file that ends with either test.js or spec.js—my-component.test.js,
    for example. Which suffix you choose is up to you—it’s about your own style. I’ll
    use them interchangeably in this book because I think of “test” as the simplest
    version of “spec,” so I use it when showing very simple things.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在我们的 ch2 文件夹下创建一个特殊的文件夹，名为 __tests__。在这个文件夹下，创建一个以 test.js 或 spec.js 结尾的文件——例如
    my-component.test.js。您选择哪个后缀取决于您自己的风格。在这本书中，我会交替使用它们，因为我认为“test”是“spec”最简单的版本，所以我在展示非常简单的事情时使用它。
- en: Test file locations
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 测试文件位置
- en: 'There are two main patterns I see for placing test files: Some people prefer
    to place the test files directly next to the files or modules being tested. Others
    prefer to place all the files under a test directory. Which approach you choose
    doesn’t really matter; just be consistent in your choice throughout a project,
    so it’s easy to know where to find the tests for a specific item.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我看到两种主要的放置测试文件的模式：有些人喜欢将测试文件直接放置在要测试的文件或模块旁边。其他人则喜欢将所有文件放在一个测试目录下。你选择哪种方法并不重要；只需在整个项目中保持一致，这样就可以轻松地找到特定项目的测试。
- en: I find that placing tests in a test folder allows me to also put helper files
    under the test folder close to the tests. As for easily navigating between tests
    and the code under test, there are plugins for most IDEs today that allow you
    to navigate between code and its tests with a keyboard shortcut.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现将测试放在测试文件夹中，我还能够将辅助文件放在测试文件夹中，靠近测试。至于在测试和被测试的代码之间轻松导航，大多数 IDE 现在都有插件，允许你通过键盘快捷键在代码及其测试之间导航。
- en: We don’t need `require()` at the top of the file to start using Jest. It automatically
    imports global functions for us to use. The main functions you should be interested
    in include `test`, `describe`, `it`, and `expect`. Listing 2.1 shows what a simple
    test might look like.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要在文件顶部使用 `require()` 来开始使用 Jest。它自动为我们导入全局函数。你应该感兴趣的函数主要包括 `test`、`describe`、`it`
    和 `expect`。列表 2.1 显示了一个简单的测试可能的样子。
- en: Listing 2.1 Hello Jest
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.1 Hello Jest
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We haven’t used `describe` and `it` yet, but we’ll get to them soon.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有使用 `describe` 和 `it`，但很快就会用到。
- en: 2.1.5 Executing Jest
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.5 执行 Jest
- en: 'To run this test, we need to be able to execute Jest. For Jest to be recognized
    from the command line, we need to do either of the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个测试，我们需要能够执行 Jest。为了让 Jest 在命令行中被识别，我们需要执行以下操作之一：
- en: Install Jest globally on the machine by running `npm` `install` `jest` `-g`.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过运行 `npm install jest -g` 在机器上全局安装 Jest。
- en: Use `npx` to execute Jest from the node_modules directory by typing `jest` in
    the root of the ch2 folder.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `npx` 在 ch2 文件夹的根目录下输入 `jest` 来从 node_modules 目录执行 Jest。
- en: If all the stars lined up correctly, you should see the results of the Jest
    test run and a failure. Your first failure. Yay! Figure 2.1 shows the output on
    my terminal when I run the command. It’s pretty cool to see such lovely, colorful
    (if you’re reading the e-book), useful output from a test tool. It looks even
    cooler if your terminal is in dark mode.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有星星都正确对齐，你应该会看到 Jest 测试运行的结果和失败。你的第一次失败。太棒了！图 2.1 显示了我运行命令时的终端输出。看到来自测试工具的如此可爱、多彩（如果你在阅读电子书的话）、有用的输出真是太酷了。如果你的终端处于暗模式，看起来会更酷。
- en: '![02-01](../Images/02-01.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![02-01](../Images/02-01.png)'
- en: Figure 2.1 Terminal output from Jest
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 Jest 的终端输出
- en: 'Let’s take a closer look at the details. Figure 2.2 shows the same output,
    but with numbers to follow along. Let’s see how many pieces of information are
    presented here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看细节。图 2.2 显示了相同的输出，但带有数字以便跟随。让我们看看这里展示了多少信息：
- en: ❶ A quick list of all the failing tests (with names) with nice red Xs next to
    them
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一份快速列表，列出了所有失败的测试（带名称），旁边有漂亮的红色 X
- en: ❷ A detailed report on the expectation that failed (aka our assertion)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对失败的期望的详细报告（即我们的断言）
- en: ❸ The exact difference between the actual value and expected value
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 实际值和预期值之间的确切差异
- en: ❹ The type of comparison that was executed
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 执行的比较类型
- en: ❺ The code for the test
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 测试的代码
- en: ❻ The exact line (visually) where the test failed
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 测试失败的确切行（视觉上）
- en: ❼ A report of how many tests ran, failed, and passed
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 运行的测试数量、失败的测试数量和通过的测试数量的报告
- en: ❽ The time it took
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 执行时间
- en: ❾ The number of snapshots (not relevant to our discussion)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 快照的数量（与我们讨论无关）
- en: '![02-02](../Images/02-02.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![02-02](../Images/02-02.png)'
- en: Figure 2.2 Annotated terminal output from Jest
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 Jest 的注释终端输出
- en: Imagine trying to write all this reporting functionality yourself. It’s possible,
    but who’s got the time and the inclination? Plus, you’d have to take care of any
    bugs in the reporting mechanism.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下自己尝试编写所有这些报告功能。这是可能的，但谁有时间和意愿呢？此外，你还得负责任何报告机制中的错误。
- en: If we change `goodbye` to `hello` in the test, we can see what happens when
    the test passes (figure 2.3). Nice and green, as all things should be (again,
    in the digital version—otherwise it’s nice and grey).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将测试中的 `goodbye` 改为 `hello`，我们可以看到测试通过时会发生什么（图 2.3）。一切都很正常，就像所有事物应该的那样（再次，在数字版本中——否则它看起来很漂亮，是灰色的）。
- en: '![02-03](../Images/02-03.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![02-03](../Images/02-03.png)'
- en: Figure 2.3 Jest terminal output for a passing test
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 Jest 通过终端输出的通过测试
- en: You might note that it takes 1.5 seconds to run this single Hello World test.
    If we used the command `jest` `--watch` instead, we could have Jest monitor filesystem
    activity in our folder and automatically run tests for files that have changed
    without re-initializing itself every time. This can save a considerable amount
    of time, and it really helps with the whole notion of *continuous testing*. Set
    a terminal in the other window of your workstation with `jest` `--watch` on it,
    and you can keep coding and getting fast feedback on issues you might be creating.
    That’s a good way to get into the flow of things.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，运行这个单个 Hello World 测试需要 1.5 秒。如果我们使用 `jest --watch` 命令，Jest 可以监视文件夹中的文件系统活动，并在文件更改时自动运行测试，而无需每次都重新初始化自己。这可以节省相当多的时间，并且对于整个
    *持续测试* 概念非常有帮助。在您的工作站的其他窗口中设置一个带有 `jest --watch` 的终端，您可以在编码的同时快速获得您可能创建的问题的反馈。这是进入工作流程的好方法。
- en: 'Jest also supports async-style testing and callbacks. I’ll touch on these when
    we get to those topics later in the book, but if you’d like to learn more about
    this style now, head over to the Jest documentation on the subject: [https://jestjs.io/docs/en/asynchronous](https://jestjs.io/docs/en/asynchronous).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 还支持异步风格的测试和回调。当我们在书中稍后讨论这些主题时，我会涉及到这些内容，但如果你现在想了解更多关于这种风格的信息，请访问 Jest 关于此主题的文档：[https://jestjs.io/docs/en/asynchronous](https://jestjs.io/docs/en/asynchronous)。
- en: 2.2 The library, the assert, the runner, and the reporter
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 库、断言、执行器和报告器
- en: 'Jest has acted in several capacities for us:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 为我们提供了几个角色：
- en: It acted as a *test library* to use when writing the test.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它充当了编写测试时使用的测试库。
- en: It acted as an *assertion library* for asserting inside the test (`expect`).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它充当了测试内部的断言库（`expect`）。
- en: It acted as the *test* *runner*.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它充当了测试执行器。
- en: It acted as the *test* *reporter* for the test run.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它充当了测试运行的测试报告器。
- en: Jest also provides *isolation* facilities to create mocks, stubs, and spies,
    though we haven’t seen that yet. We’ll touch on these ideas in later chapters.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 还提供了创建模拟、存根和间谍的隔离功能，尽管我们还没有看到这一点。我们将在后面的章节中涉及到这些想法。
- en: Other than isolation facilities, it’s very common in other languages for a test
    framework to fill all the roles I just mentioned—library, assertions, test runner,
    and test reporter—but the JavaScript world seems a bit more fragmented. Many other
    test frameworks provide only some of these facilities. Perhaps this is because
    the mantra of “do one thing, and do it well” has been taken to heart, or perhaps
    it’s for other reasons. In any case, Jest stands out as one of a handful of all-in-one
    frameworks. It is a testament to the strength of the open source culture in JavaScript
    that for each one of these categories, there are multiple tools that you can mix
    and match to create your own super toolset.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了隔离功能外，在其他语言中，测试框架通常需要填补我刚才提到的所有角色——库、断言、测试执行器和测试报告器——但 JavaScript 世界似乎更加碎片化。许多其他测试框架只提供其中的一些功能。这可能是因为“做一件事，做好它”的箴言被认真对待，或者可能还有其他原因。无论如何，Jest
    都是一小部分全能框架之一。这是对 JavaScript 开源文化力量的证明，对于这些类别中的每一个，都有多个工具可以混合搭配，创建自己的超级工具集。
- en: One of the reasons I chose Jest for this book is so we don’t have to bother
    too much with the tooling or deal with missing features—we can just focus on the
    patterns. That way we won’t have to use multiple frameworks in a book that is
    mostly concerned with patterns and antipatterns.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择 Jest 作为这本书的原因之一是，我们不必过多地烦恼于工具或处理缺失的功能——我们只需专注于模式。这样，我们就不必在主要关注模式和反模式的书中使用多个框架。
- en: 2.3 What unit testing frameworks offer
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 单元测试框架提供的内容
- en: Let’s zoom out for a second and see where we are. What do frameworks like Jest
    offer us over creating our own framework, like we started to do in the previous
    chapter, or over manually testing things?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时放大视角，看看我们现在身处何地。与我们在上一章中开始尝试的创建自己的框架，或者手动测试相比，像 Jest 这样的框架为我们提供了什么？
- en: '*Structure*—Instead of reinventing the wheel every time you want to test a
    feature, when you use a test framework you always start out the same way—by writing
    a test with a well-defined structure that everyone can easily recognize, read,
    and understand.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结构*——当你想要测试一个功能时，不必每次都重新发明轮子，使用测试框架时，你总是以相同的方式开始——通过编写一个具有良好定义的结构，每个人都能轻松识别、阅读和理解。'
- en: '*Repeatability*—When using a test framework, it’s easy to repeat the act of
    writing a new test. It’s also easy to repeat the execution of the test, using
    a test runner, and it’s easy to do this quickly and many times a day. It’s also
    easy to understand failures and their causes. Someone has already done all the
    hard work for us, instead of us having to code all that stuff into our hand-rolled
    framework.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可重复性*—当使用测试框架时，重复编写新测试的行为很容易。使用测试运行器重复执行测试也很容易，而且可以快速多次执行。理解失败及其原因也很容易。有人已经为我们做了所有艰苦的工作，而不是我们不得不将所有这些代码都放入我们自制的框架中。'
- en: '*Confidence and time savings*—When we roll our own test framework, the framework
    is more likely to have bugs in it, since it is less battle-tested than an existing
    mature and widely used framework. On the other hand, manually testing things is
    usually very time consuming. When we’re short on time, we’ll likely focus on testing
    the things that feel the most critical and skip over things that might feel less
    important. We could be skipping small but significant bugs. By making it easy
    to write new tests, it’s more likely that we’ll also write tests for the stuff
    that feels less significant because we won’t be spending too much time writing
    tests for the big stuff.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*信心和时间节省*—当我们自己构建测试框架时，框架中可能存在更多错误，因为它不如现有成熟且广泛使用的框架经过实战考验。另一方面，手动测试通常非常耗时。当我们时间紧迫时，我们可能会专注于测试感觉最关键的事情，而跳过可能感觉不那么重要的事情。我们可能会跳过一些小但重要的错误。通过使编写新测试变得容易，我们更有可能为那些感觉不那么重要的事情编写测试，因为我们不会在编写大型测试上花费太多时间。'
- en: '*Shared understanding*—The framework’s reporting can be helpful for managing
    tasks at the team level (when a test is passing, it means the task is done). Some
    people find this useful.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*共享理解*—框架的报告对于团队层面的任务管理很有帮助（当一个测试通过时，意味着任务已完成）。有些人发现这很有用。'
- en: In short, frameworks for writing, running, and reviewing unit tests and their
    results can make a huge difference in the daily lives of developers who are willing
    to invest the time in learning how to use them properly. Figure 2.4 shows the
    areas in software development in which a unit testing framework and its helper
    tools have influence, and table 2.1 lists the types of actions we usually execute
    with a test framework.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，编写、运行和审查单元测试及其结果的框架可以极大地改变愿意投入时间学习如何正确使用它们的开发者的日常生活。图2.4显示了单元测试框架及其辅助工具在软件开发中产生影响的领域，表2.1列出了我们通常使用测试框架执行的动作类型。
- en: '![02-04](../Images/02-04.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![02-04](../Images/02-04.png)'
- en: Figure 2.4 Unit tests are written as code, using libraries from the unit testing
    framework. The tests are run from a test runner inside the IDE or through the
    command line, and the results are reviewed through a test reporter (either as
    output text or in the IDE) by the developer or an automated build process.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 单元测试作为代码编写，使用单元测试框架的库。测试从IDE内的测试运行器或通过命令行运行，结果由开发者或自动化构建过程通过测试报告器（无论是输出文本还是IDE中的内容）进行审查。
- en: Table 2.1 How testing frameworks help developers write and execute tests and
    review results
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 测试框架如何帮助开发者编写和执行测试以及审查结果
- en: '| Unit testing practice | How the framework helps |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 单元测试实践 | 框架如何帮助 |'
- en: '| Write tests easily and in a structured manner. | A framework supplies the
    developer with helper functions, assertion functions, and structure-related functions.
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 轻松并以结构化的方式编写测试。 | 框架为开发者提供辅助函数、断言函数和与结构相关的函数。 |'
- en: '| Execute one or all of the unit tests. | A framework provides a test runner,
    usually at the command line, that'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '| 执行一个或所有单元测试。 | 框架提供测试运行器，通常在命令行中，它'
- en: Identifies tests in your code
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别代码中的测试
- en: Runs tests automatically
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动运行测试
- en: Indicates test status while running
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行时指示测试状态
- en: '|'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Review the results of the test runs. | A test runner will usually provide
    information such as'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '| 审查测试运行的结果。 | 测试运行器通常会提供有关信息，例如'
- en: How many tests ran
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行的测试数量
- en: How many tests didn’t run
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 未运行的测试数量
- en: How many tests failed
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 失败的测试数量
- en: Which tests failed
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些测试失败了
- en: The reason tests failed
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试失败的原因
- en: The code location that failed
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 失败的代码位置
- en: Possibly provide a full stack trace for any exceptions that caused the test
    to fail, and let you go to the various method calls inside the call stack
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能提供任何导致测试失败的异常的完整堆栈跟踪，并允许你进入调用堆栈中的各种方法调用
- en: '|'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'At the time of writing, there are around 900 unit testing frameworks out there,
    with more than a couple for most programming languages in public use (and a few
    dead ones). You can find a good list on Wikipedia: [https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks](https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，大约有 900 个单元测试框架存在，对于大多数在公共使用的编程语言来说，都有超过几个（以及一些已经废弃的）。你可以在维基百科上找到一个很好的列表：[https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks](https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks)。
- en: Note Using a unit testing framework doesn’t ensure that the tests you write
    are *readable*, *maintainable*, or *trustworthy*, or that they cover all the logic
    you’d like to test. We’ll look at how to ensure your unit tests have these properties
    in chapters 7 through 9 and in various other places throughout this book.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：使用单元测试框架并不能保证你编写的测试是 *可读的*、*可维护的* 或 *可靠的*，或者它们覆盖了你想要测试的所有逻辑。我们将在第 7 章至第 9
    章以及本书的其他地方探讨如何确保你的单元测试具备这些特性。
- en: 2.3.1 The xUnit frameworks
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 xUnit 框架
- en: When I started writing tests (in the Visual Basic days), the standard by which
    most unit test frameworks were measured was collectively called xUnit. The grandfather
    of the xUnit frameworks idea was SUnit, the unit testing framework for Smalltalk.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始编写测试（在 Visual Basic 时代）时，大多数单元测试框架的标准被统称为 xUnit。xUnit 框架思想的始祖是 SUnit，它是
    Smalltalk 的单元测试框架。
- en: These unit testing frameworks’ names usually start with the first letters of
    the language for which they were built; you might have CppUnit for C++, JUnit
    for Java, NUnit and xUnit for .NET, and HUnit for the Haskell programming language.
    Not all of them follow these naming guidelines, but most do.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些单元测试框架的名称通常以它们所构建的语言的首字母开头；例如，你可能会有 CppUnit 用于 C++，JUnit 用于 Java，NUnit 和 xUnit
    用于 .NET，以及 HUnit 用于 Haskell 编程语言。虽然并非所有框架都遵循这些命名指南，但大多数都是。
- en: 2.3.2 xUnit, TAP, and Jest structures
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 xUnit、TAP 和 Jest 结构
- en: It’s not just the names that were reasonably consistent. If you were using an
    xUnit framework, you could also expect a specific structure in which the tests
    were built. When these frameworks would run, they would output their results in
    the same structure, which was usually an XML file with a specific schema.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅名称相当一致。如果你使用的是 xUnit 框架，你还可以期待一个特定的结构，其中测试被构建。当这些框架运行时，它们会以相同的结构输出结果，这通常是一个具有特定模式的
    XML 文件。
- en: This type of xUnit XML report is still prevalent today, and it’s widely used
    in most build tools, such as Jenkins, which support this format with native plugins
    and use it to report the results of test runs. Most unit test frameworks in static
    languages still use the xUnit model for structure, which means that once you’ve
    learned to use one of them, you should be able to easily use any of them (assuming
    you know the particular programming language).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的 xUnit XML 报告至今仍然很普遍，并且在大多数构建工具中广泛使用，如 Jenkins，它通过本机插件支持此格式，并使用它来报告测试运行的结果。静态语言中的大多数单元测试框架仍然使用
    xUnit 模型进行结构设计，这意味着一旦你学会了使用其中之一，你应该能够轻松地使用任何其他框架（假设你了解特定的编程语言）。
- en: The other interesting standard for the reporting structure of test results and
    more is called *TAP*, the Test Anything Protocol. TAP started life as part of
    the test harness for Perl, but now it has implementations in C, C++, Python, PHP,
    Perl, Java, JavaScript, and other languages. TAP is much more than just a reporting
    specification. In the JavaScript world, the TAP framework is the best-known test
    framework that natively supports the TAP protocol.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的测试结果报告结构标准，以及更多内容，被称为 *TAP*，即测试任何协议。TAP 最初是 Perl 测试工具的一部分，但现在它在 C、C++、Python、PHP、Perl、Java、JavaScript
    以及其他语言中都有实现。TAP 不仅仅是一个报告规范。在 JavaScript 世界中，TAP 框架是支持 TAP 协议的知名测试框架。
- en: Jest is not strictly an xUnit or TAP framework. Its output is not xUnit- or
    TAP-compliant by default. However, because xUnit-style reporting still rules the
    build sphere, we’ll usually want to adapt to that protocol for our reporting on
    a build server. To get Jest test results that are easily recognized by most build
    tools, you can install npm modules such as `jest-xunit` (if you want TAP-specific
    output, use `jest-tap-reporter`) and then use a special jest.config.js file in
    your project to configure Jest to alter its reporting format.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 不是一个严格的 xUnit 或 TAP 框架。它的输出默认不是 xUnit 或 TAP 兼容的。然而，由于 xUnit 风格的报告仍然统治着构建领域，我们通常希望适应该协议以在构建服务器上的报告。为了获得大多数构建工具容易识别的
    Jest 测试结果，你可以安装 npm 模块，如 `jest-xunit`（如果你需要特定的 TAP 输出，请使用 `jest-tap-reporter`），然后在你的项目中使用特殊的
    jest.config.js 文件来配置 Jest，以改变其报告格式。
- en: Now let’s move on and write something that feels a bit more like a real test
    with Jest, shall we?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续，用 Jest 编写一些感觉更像真实测试的内容，好吗？
- en: 2.4 Introducing the Password Verifier project
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 介绍密码验证器项目
- en: The project that we’ll mostly use for testing examples in this book will start
    out simple, containing only one function. As the book moves along, we’ll extend
    that project with new features, modules, and classes to demonstrate different
    aspects of unit testing. We’ll call it the Password Verifier project.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中主要用于测试示例的项目最初将很简单，只包含一个函数。随着本书的进行，我们将通过添加新功能、模块和类来扩展该项目，以展示单元测试的不同方面。我们将称之为密码验证器项目。
- en: 'The first scenario is pretty simple. We’ll be building a password verification
    library, and it will just be a function at first. The function, `verifyPassword(rules)`,
    allows us to put in custom verification functions dubbed `rules`, and it outputs
    the list of errors, according to the rules that have been input. Each rule function
    will output two fields:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个场景相当简单。我们将构建一个密码验证库，最初它只是一个函数。这个函数 `verifyPassword(rules)` 允许我们输入自定义验证函数，称为
    `rules`，并根据输入的规则输出错误列表。每个规则函数将输出两个字段：
- en: '[PRE4]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this book, I’ll teach you to write tests that check `verifyPassword`’s functionality
    in multiple ways as we add more features to it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我将教你如何编写测试，以多种方式检查随着我们添加更多功能到其中，`verifyPassword` 的功能。
- en: The following listing shows version 0 of this function, with a very naive implementation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了该函数的版本 0，它有一个非常天真的实现。
- en: Listing 2.2 Password Verifier version 0
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.2 密码验证器版本 0
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Granted, this is not the most functional-style code, and we might refactor it
    a bit later, but I wanted to keep things very simple here so we can focus on the
    tests.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不是最功能性的代码，我们可能稍后会对其进行重构，但我想保持这里的代码非常简单，以便我们可以专注于测试。
- en: The function doesn’t really do much. It iterates over all the rules given and
    runs each one with the supplied input. If the rule’s result is not *passed*, then
    an error is added to the final errors array that is returned as the final result.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数实际上并没有做什么。它遍历所有给定的规则，并使用提供的输入运行每个规则。如果规则的输出结果没有*通过*，那么一个错误会被添加到最终返回的错误数组中。
- en: 2.5 The first Jest test for verifyPassword
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 对 verifyPassword 的第一个 Jest 测试
- en: Assuming you have Jest installed, you can go ahead and create a new file named
    password-verifier0.spec.js under the __tests__ folder.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经安装了 Jest，你可以在 __tests__ 文件夹下创建一个名为 password-verifier0.spec.js 的新文件。
- en: Using the __tests__ folder is only one convention for organizing your tests,
    and it’s part of Jest’s default configuration. There are many who prefer to place
    the test files alongside the code being tested. There are pros and cons to each
    approach, and we’ll get into that in later parts of the book. For now, we’ll go
    with the defaults.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 __tests__ 文件夹是组织测试的一种约定，它是 Jest 默认配置的一部分。许多人更喜欢将测试文件放置在与被测试的代码相同的目录下。每种方法都有其优缺点，我们将在本书的后续部分中探讨这一点。现在，我们将采用默认设置。
- en: Here’s a first version of a test against our new function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们对新函数的第一个测试版本。
- en: Listing 2.3 The first test against `verifyPassword()`
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.3 对 `verifyPassword()` 的第一个测试
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Setting up inputs for the test
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置测试的输入
- en: ❷ Invoking the entry point with the inputs
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用输入调用入口点
- en: ❸ Checking the exit point
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查退出点
- en: 2.5.1 The Arrange-Act-Assert pattern
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 安排-行动-断言模式
- en: The structure of the test in listing 2.3 is colloquially called the *Arrange-Act-Assert*
    (AAA) pattern. It’s quite nice! I find it very easy to reason about the parts
    of a test by saying things like “that ‘arrange’ part is too complicated” or “where
    is the ‘act’ part?”
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.3中的测试结构通常被称为*安排-行动-断言*（AAA）模式。它相当不错！我发现通过说“那个‘安排’部分太复杂了”或“‘行动’部分在哪里？”之类的话来推理测试的各个部分非常容易。
- en: In the arrange part, we’re creating a fake rule that always returns false, so
    that we can prove it’s actually used by asserting *on its reason* at the end of
    the test. We then send it to `verifyPassword` along with a simple input. We check
    in the assert section that the first error we get matches the fake reason we gave
    in the arrange part. `.toMatch(/string/)` uses a regular expression to find a
    part of the string. It’s the same as using `.toContain('fake` `reason')`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在安排部分，我们创建了一个总是返回false的假规则，这样我们就可以通过在测试结束时断言其理由来证明它实际上被使用了。然后我们将其与一个简单的输入一起发送到`verifyPassword`。在断言部分，我们检查得到的第一个错误是否与我们在安排部分给出的假理由匹配。`.toMatch(/string/)`使用正则表达式来查找字符串的一部分。它与使用`.toContain('fake
    reason')`相同。
- en: 'It’s tedious to run Jest manually after we write a test or fix something, so
    let’s configure npm to run Jest automatically. Go to package.json in the root
    folder of ch2 and add the following items under the `scripts` item:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们写完测试或修复某些东西之后手动运行Jest很麻烦，所以让我们配置npm来自动运行Jest。转到ch2根目录下的package.json，在`scripts`项下添加以下内容：
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you don’t have Git initialized in this folder, you can use the command `--watchAll`
    instead of `--watch`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个文件夹中没有初始化Git，你可以使用命令`--watchAll`而不是`--watch`。
- en: If everything went well, you can now type `npm` `test` in the command line from
    the ch2 folder, and Jest will run the tests once. If you type `npm` `run` `testw`,
    Jest will run and wait for changes in an endless loop, until you kill the process
    with Ctrl-C. (You need to use the word `run` because `testw` is not one of the
    special keywords that npm recognizes automatically.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你现在可以从ch2文件夹中在命令行中键入`npm test`，Jest将运行一次测试。如果你键入`npm run testw`，Jest将运行并无限循环等待更改，直到你使用Ctrl-C终止进程。（你需要使用单词`run`，因为`testw`不是npm自动识别的特殊关键字之一。）
- en: If you run the test, you can see that it passes, since the function works as
    expected.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行测试，你可以看到它通过了，因为函数按预期工作。
- en: 2.5.2 Testing the test
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 测试测试
- en: Let’s put a bug in the production code and see if the test fails when it should.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在生产代码中放一个错误，看看测试是否应该在失败时失败。
- en: Listing 2.4 Adding a bug
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.4 添加一个错误
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ We've accidentally commented out this line.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们不小心注释掉了这一行。
- en: You should now see your test failing with a nice message. Let’s uncomment the
    line and see the test pass again. This is a great way to gain some confidence
    in your tests, if you’re not doing test-driven development and are writing the
    tests after the code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能看到测试失败并显示一个友好的消息。让我们取消注释这一行，看看测试是否再次通过。如果你不是在做测试驱动开发，而是在写完代码后再写测试，这是一种建立测试信心的好方法。
- en: 2.5.3 USE naming
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.3 USE命名
- en: Our test has a really bad name. It doesn’t explain anything about what we’re
    trying to accomplish here. I like to put three pieces of information in test names,
    so that the reader of the test will be able to answer most of their mental questions
    just by looking at the test name. These three parts include
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试名称真的很糟糕。它没有解释我们在这里试图完成什么。我喜欢在测试名称中放入三个信息点，这样测试的读者只需看一眼测试名称就能回答他们大部分的心理问题。这三个部分包括
- en: The unit of work under test (the `verifyPassword` function, in this case)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被测试的工作单元（在这个例子中是`verifyPassword`函数）
- en: The scenario or inputs to the unit (the failed rule)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试的场景或输入（失败的规则）
- en: The expected behavior or exit point (returns an error with a reason)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期的行为或退出点（返回带有原因的错误）
- en: 'During the review process, Tyler Lemke, a reviewer of the book, came up with
    a nice acronym for this, USE: unit under test, scenario, expectation. I like it,
    and it’s easy to remember. Thanks Tyler!'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查过程中，这本书的审稿人Tyler Lemke提出了一个很好的缩写USE：被测试单元、场景、预期。我喜欢它，而且很容易记住。谢谢Tyler！
- en: The following listing shows our next revision of the test with a USE name.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了带有USE名称的测试的下一个版本。
- en: Listing 2.5 Naming a test with USE
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.5 使用USE命名测试
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is a bit better. When a test fails, especially during a build process,
    you don’t see comments or the full test code. You usually only see the name of
    the test. The name should be so clear that you might not even have to look at
    the test code to understand where the production code problem might be.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点更好。当测试失败时，尤其是在构建过程中，你通常看不到注释或完整的测试代码。你通常只能看到测试的名称。名称应该足够清晰，以至于你可能甚至不需要查看测试代码就能理解生产代码中可能出现的问题。
- en: 2.5.4 String comparisons and maintainability
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.4 字符串比较和可维护性
- en: 'We also made another small change in the following line:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在下一行做了另一个小的更改：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Instead of checking that one string is equal to another, as is very common in
    tests, we are checking that a string is contained in the output. This makes our
    test less brittle for future changes to the output. We can use `.toContain` or
    `.toMatch(/fake` `reason/)`, which uses a regular expression to match a part of
    the string, to achieve this.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与在测试中非常常见的检查一个字符串是否等于另一个字符串不同，我们正在检查一个字符串是否包含在输出中。这使得我们的测试对输出的未来更改更不脆弱。我们可以使用
    `.toContain` 或 `.toMatch(/fake reason/)` 来实现这一点，它使用正则表达式匹配字符串的一部分。
- en: 'Strings are a form of user interface. They are visible to humans, and they
    might change—especially the edges of strings. We might add whitespace, tabs, asterisks,
    or other embellishments to a string. We care that the *core* of the information
    contained in the string exists. We don’t want to change our test every time someone
    adds a new line to the end of a string. This is part of the thinking we want to
    encourage in our tests: test maintainability over time, and resistance to test
    brittleness, are of high priority.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是一种用户界面。它们对人类可见，并且可能会改变——尤其是字符串的边缘。我们可能会向字符串添加空白、制表符、星号或其他装饰。我们关心字符串中包含的信息的核心。我们不希望每次有人向字符串末尾添加新行时都更改我们的测试。这是我们希望在测试中鼓励的思考方式：随着时间的推移，测试的可维护性和对测试脆弱性的抵抗力是高度优先的。
- en: We’d ideally like the test to fail only when something is actually wrong in
    the production code. We’d like to reduce the number of false positives to a minimum.
    Using `toContain()` or `toMatch()` is a great way to move toward that goal.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理想的情况是，测试只在生产代码中实际出错时失败。我们希望将误报的数量减少到最低。使用 `toContain()` 或 `toMatch()` 是朝着这个目标迈进的好方法。
- en: I’ll talk about more ways to improve test maintainability throughout the book,
    and especially in part 2 of the book.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在整本书中讨论更多提高测试可维护性的方法，尤其是在书的第二部分。
- en: 2.5.5 Using describe()
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.5 使用 describe()
- en: We can use Jest’s `describe()` function to create a bit more structure around
    our test and to start separating the three USE pieces of information from each
    other. This step and the ones after it are completely up you—you can decide how
    you want to style your test and its readability structure. I’m showing you these
    steps because many people either don’t use `describe()` in an effective way, or
    they ignore it altogether. It can be quite useful.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Jest 的 `describe()` 函数在我们的测试周围创建更多的结构，并开始将三个 USE 信息部分彼此分离。这一步以及之后的步骤完全取决于你——你可以决定你想要如何格式化你的测试及其可读性结构。我向你展示这些步骤是因为许多人要么没有有效地使用
    `describe()`，要么完全忽略了它。它可以非常有用。
- en: 'The `describe()` functions wrap our tests with context: both logical context
    for the reader, and functional context for the test itself. The next listing shows
    how we can start using them.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe()` 函数用上下文包裹我们的测试：既为读者提供逻辑上下文，也为测试本身提供功能上下文。下面的列表显示了我们可以如何开始使用它们。'
- en: Listing 2.6 Adding a `describe()` block
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.6 添加 `describe()` 块
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'I’ve made four changes here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里做了四个更改：
- en: I’ve added a `describe()` block that describes the unit of work under test.
    To me this looks clearer. It also feels like I can now add more nested tests under
    that block. This `describe()` block also helps the command-line reporter create
    nicer reports.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我添加了一个描述正在测试的工作单元的 `describe()` 块。对我来说，这看起来更清晰。它也让我觉得现在可以在该块下添加更多嵌套测试。这个 `describe()`
    块还有助于命令行报告生成更漂亮的报告。
- en: I’ve nested the `test` under the new block and removed the name of the unit
    of work from the test.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我在新的块下嵌套了 `test` 并从测试中移除了工作单元的名称。
- en: I’ve added the `input` into the fake rule’s `reason` string.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我已经将 `input` 添加到了模拟规则的 `reason` 字符串中。
- en: I’ve added an empty line between the arrange, act, and assert parts to make
    the test more readable, especially to someone new to the team.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我在 arrange、act 和 assert 部分之间添加了一个空行，使测试更易于阅读，尤其是对团队新成员来说。
- en: 2.5.6 Structure implying context
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.6 结构暗示上下文
- en: The nice thing about `describe()` is that it can be nested under itself. So
    we can use it to create another level that explains the scenario, and under that
    we’ll nest our test.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe()`的好处在于它可以嵌套在自身之下。因此，我们可以用它来创建另一个层级，解释场景，然后在这个层级下嵌套我们的测试。'
- en: Listing 2.7 Nested `describe`s for extra context
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.7：用于额外上下文的嵌套`describe`
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Some people will hate it, but I think there’s a certain elegance to it. This
    nesting allows us to separate the three pieces of critical information to their
    own level. In fact, we can also extract the false rule outside of the test right
    under the relevant `describe()`, if we wish to.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会讨厌它，但我觉得它有一定的优雅之处。这种嵌套使我们能够将三块关键信息分别分离到它们自己的层级。实际上，如果我们愿意，我们还可以在`describe()`下方提取出测试之外的错误规则。
- en: Listing 2.8 Nested `describe`s with an extracted input
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.8：带有提取输入的嵌套`describe`
- en: '[PRE13]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For the next example, I’ll move this rule back into the test (I like it when
    things are close together—more on that later).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我将这个规则重新放回测试中（我喜欢事物紧密相连——关于这一点稍后还会提到）。
- en: This nesting structure also implies very nicely that under a specific scenario
    you could have more than one expected behavior. You could check multiple exit
    points under a scenario, with each one as a separate test, and it will still make
    sense from the reader’s point of view.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这种嵌套结构也非常巧妙地暗示了，在特定场景下，你可能有多种预期的行为。你可以在一个场景下检查多个退出点，每个退出点作为一个单独的测试，并且从读者的角度来看仍然是有意义的。
- en: 2.5.7 The it() function
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.7 `it()`函数
- en: There’s one missing piece to the puzzle I’ve been building so far. Jest also
    exposes an `it()` function. This function is, for all intents and purposes, an
    *alias* to the `test()` function, but it fits in more nicely in terms of syntax
    with the describe-driven approach outlined so far.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我至今构建的谜题中还有一块缺失。Jest也暴露了一个`it()`函数。这个函数在所有意图和目的上都是`test()`函数的一个别名，但它与迄今为止概述的描述驱动方法在语法上更契合。
- en: The following listing shows what the test looks like when I replace `test()`
    with `it()`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了当我将`test()`替换为`it()`时测试看起来像什么。
- en: Listing 2.9 Replacing `test()` with `it()`
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.9：将`test()`替换为`it()`
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this test, it’s very easy to understand what `it` refers to. This is a natural
    extension of the previous `describe()` blocks. Again, it’s up to you whether you
    want to use this style. I’m showing one variation of how I like to think about
    it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，很容易理解`it`指的是什么。这是对之前`describe()`块的自然扩展。再次强调，是否使用这种风格取决于你。我在这里展示了我喜欢的一种变体。
- en: 2.5.8 Two Jest flavors
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.8 两种Jest风味
- en: 'As you’ve seen, Jest supports two main ways to write tests: a terse `test`
    syntax, and a more `describe`-driven (i.e., hierarchical) syntax.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Jest支持两种主要的测试编写方式：简洁的`test`语法和更`describe`驱动的（即分层）语法。
- en: The `describe`-driven Jest syntax can be largely attributed to Jasmine, one
    of the oldest JavaScript test frameworks. The style itself can be traced back
    to Ruby-land and the well-known RSpec Ruby test framework. This nested style is
    usually called *BDD style*, referring to *behavior-driven development*.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe`驱动的Jest语法在很大程度上归功于Jasmine，这是最古老的JavaScript测试框架之一。这种风格本身可以追溯到Ruby世界和著名的RSpec
    Ruby测试框架。这种嵌套风格通常被称为*行为驱动开发（BDD）风格*。'
- en: You can mix and match these styles as you like (I do). You can use the `test`
    syntax when it’s easy to understand your test target and all of its context, without
    going to too much trouble. The `describe` syntax can help when you’re expecting
    multiple results from the same entry point under the same scenario. I’m showing
    them both here because I sometimes use the terse `test` flavor and sometimes use
    the `describe`-driven flavor, depending on the complexity and expressiveness requirements.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据自己的喜好混合和匹配这些风格（我就是这样做的）。当测试目标及其所有上下文容易理解，而不需要过多麻烦时，你可以使用`test`语法。当你在同一场景下的同一入口点期望多个结果时，`describe`语法可以帮助你。我在这里展示了它们两个，因为我有时使用简洁的`test`风格，有时使用`describe`驱动的风格，这取决于复杂性和表达性要求。
- en: BDD’s dark present
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: BDD的黑暗现状
- en: BDD has quite an interesting background that might be worth talking about. BDD
    isn’t related to TDD. Dan North, the person most associated with inventing the
    term, refers to BDD as using stories and examples to describe how an application
    should behave. Mainly this is targeted at working with non-technical stakeholders—product
    owners, customers, etc. RSpec (inspired by RBehave) brought the story-driven approach
    to the masses, and in the process, many other frameworks came along, including
    the famous Cucumber.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: BDD有一个相当有趣的历史背景，可能值得讨论。BDD与TDD无关。与发明这个术语最相关的人丹·诺斯（Dan North）将BDD描述为使用故事和示例来描述应用程序应该如何表现。主要目标是与非技术利益相关者（如产品所有者、客户等）合作。RSpec（受RBehave的启发）将故事驱动的方法普及开来，在这个过程中，许多其他框架也随之而来，包括著名的Cucumber。
- en: 'There is also a dark side to this story: many frameworks have been developed
    and used solely by developers without working with non-technical stakeholders,
    in complete opposition to the main ideas of BDD.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事也有阴暗面：许多框架都是由开发者独立开发和使用，而没有与非技术利益相关者合作，这与BDD的主要思想完全相反。
- en: Today, to me, the term *BDD frameworks* mainly means “test frameworks with some
    syntactic sugar,” since they are almost never used to create real conversations
    between stakeholders and are almost always used as just another shiny or prescribed
    tool for performing developer-based automated tests. I’ve even seen the mighty
    Cucumber fall into this pattern.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 今天对我来说，“BDD框架”这个术语主要指的是“带有一些语法糖的测试框架”，因为它们几乎从未被用来创建利益相关者之间的真实对话，而几乎总是作为执行基于开发者的自动化测试的另一个闪亮的或规定的工具。我甚至看到强大的Cucumber也陷入了这种模式。
- en: 2.5.9 Refactoring the production code
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.9 重构生产代码
- en: Since there are many ways to build the same thing in JavaScript, I thought I’d
    show a couple of variations on our design and what happens if we change it. Suppose
    we’d like to make the password verifier an object with state.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在JavaScript中有许多构建相同东西的方法，我想展示我们设计的一些变体以及如果我们改变它会发生什么。假设我们希望将密码验证器变成一个具有状态的对象。
- en: One reason to change the design into a stateful one might be that I intend for
    different parts of the application to use this object. One part will configure
    and add rules to it, and a different part will use it to do the verification.
    Another reason is that we need to know how to handle a stateful design and look
    at which directions it pulls our tests in, and what we can do about that.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将设计改为状态性的一个原因可能是我打算让应用程序的不同部分使用这个对象。一部分将对其进行配置并添加规则，而另一部分将使用它来进行验证。另一个原因是我们需要知道如何处理状态性设计，并查看它将测试推向哪些方向，我们能做些什么。
- en: Let’s look at the production code first.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看生产代码。
- en: Listing 2.10 Refactoring a function to a stateful class
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.10 将函数重构为状态性类
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I’ve highlighted the main changes from listing 2.9\. There’s nothing really
    special going on here, though this may feel more comfortable if you’re coming
    from an object-oriented background. It’s important to note that this is just one
    way to design this functionality. I’m using the class-based approach so that I
    can show how this design affects the test.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经高亮了2.9列表中的主要变化。这里并没有什么特别的事情发生，尽管如果你有面向对象背景的话可能会觉得更舒服。需要注意的是，这只是设计这种功能的一种方式。我使用基于类的方法，以便展示这种设计如何影响测试。
- en: 'In this new design, where are the entry and exit points for the current scenario?
    Think about it for a second. The scope of the unit of work has increased. To test
    a scenario with a failing rule, we would have to invoke two functions that affect
    the state of the unit under test: `addRule` and `verify`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的设计中，当前场景的入口和出口在哪里？思考一下。工作单元的范围已经增加。为了测试一个有失败规则的场景，我们必须调用影响测试中工作单元状态的两个函数：`addRule`和`verify`。
- en: Now let’s see what the test might look like (changes are highlighted as usual).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看测试可能的样子（变化通常以高亮显示）。
- en: Listing 2.11 Testing the stateful unit of work
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.11 测试状态性工作单元
- en: '[PRE16]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So far, so good; nothing fancy is happening here. Note that the surface of the
    unit of work has increased. It now spans two related functions that must work
    together (`addRule` and `verify`). There is a *coupling* that occurs due to the
    stateful nature of the design. We need to use two functions to test productively
    without exposing any internal state from the object.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利；这里没有发生任何特别的事情。请注意，工作单元的表面已经增加。现在它跨越了两个必须一起工作的相关功能（`addRule`和`verify`）。由于设计的状态性，发生了耦合。我们需要使用两个函数来有效地进行测试，而不暴露任何对象的内部状态。
- en: 'The test itself looks innocent enough. But what happens when we want to write
    several tests for the same scenario? That would happen if we have multiple exit
    points, or if we want to test multiple results from the same exit point. For example,
    let’s say we want to verify that we have only a single error. We could simply
    add a line to the test like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 测试本身看起来足够无辜。但当我们想要为同一场景编写多个测试时会发生什么？这可能会发生在我们有多个出口点，或者我们想要从同一出口点测试多个结果时。例如，假设我们想要验证我们只有一个错误。我们可以在测试中简单地添加一行，如下所示：
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ A new assertion
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 新的断言
- en: What happens if the new assertion fails? The second assertion would never execute,
    because the test runner would receive an error and move on to the next test case.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新的断言失败会发生什么？第二个断言永远不会执行，因为测试运行器会收到一个错误并继续下一个测试用例。
- en: We’d still want to know if the second assertion would have passed, right? So
    maybe we’d start commenting out the first one and rerunning the test. That’s not
    a healthy way to run your tests. In Gerard Meszaros’ book *xUnit Test Patterns*,
    this human behavior of commenting things out to test other things is called *assertion
    roulette*. It can create lots of confusion and false positives in your test runs
    (thinking that something is failing or passing when it isn’t).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然想知道第二个断言是否会通过，对吧？所以也许我们会开始注释掉第一个，然后重新运行测试。这不是运行测试的健康方式。在 Gerard Meszaros
    的书 *xUnit Test Patterns* 中，这种注释掉某些内容以测试其他内容的人类行为被称为 *断言轮盘游戏*。它可以在你的测试运行中造成很多混淆和假阳性（认为某些事情失败或通过，而实际上并没有）。
- en: I’d rather separate this extra check into its own test case with a good name,
    as follows.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我宁愿将这个额外的检查单独分成一个带有良好名称的测试用例，如下所示。
- en: Listing 2.12 Checking an extra end result from the same exit point
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.12 从同一出口点检查额外的最终结果
- en: '[PRE18]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is starting to look *bad*. Yes, we have solved the assertion roulette
    issue. Each `it()` can fail separately and not interfere with the results from
    the other test case. But what did it cost? Everything. Look at all the duplication
    we have now. At this point, those of you with some unit testing background will
    start shouting at the book: “Use a `setup`/`beforeEach` method!”'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始看起来很糟糕。是的，我们解决了断言轮盘问题。每个 `it()` 可以单独失败，不会干扰其他测试用例的结果。但我们付出了什么代价？一切。看看我们现在有多少重复。在这个时候，那些有单元测试背景的人会开始对着这本书大喊：“使用
    `setup`/`beforeEach` 方法！”
- en: Fine!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！
- en: 2.6 Trying the beforeEach() route
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 尝试使用 beforeEach() 路由
- en: I haven’t introduced `beforeEach()` yet. This function and its sibling, `afterEach()`,
    are used to set up and tear down a specific state required by the test cases.
    There’s also `beforeAll()` and `afterAll()`, which I try to avoid using at all
    costs for unit testing scenarios. We’ll talk more about the siblings later in
    the book.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我还没有介绍 `beforeEach()`。这个函数及其兄弟函数 `afterEach()` 用于设置和撤销测试用例所需的特定状态。还有 `beforeAll()`
    和 `afterAll()`，我尽量避免在单元测试场景中使用它们。我们将在本书的后面部分更多地讨论这些兄弟函数。
- en: '`beforeEach()` can help us remove duplication in our tests because it runs
    once before each test in the `describe` block in which we nest it. We can also
    nest it multiple times, as the following listing demonstrates.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`beforeEach()` 可以帮助我们移除测试中的重复，因为它在我们嵌套的 `describe` 块中的每个测试之前运行一次。我们也可以多次嵌套它，如下面的列表所示。'
- en: Listing 2.13 Using `beforeEach()` on two levels
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.13 在两个级别上使用 `beforeEach()`
- en: '[PRE19]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Setting up a new verifier that will be used in each test
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置一个将在每个测试中使用的新的验证器
- en: ❷ Setting up a fake rule that will be used within this describe() method
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在 describe() 方法内设置一个将在此处使用的假规则
- en: Look at all that extracted code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 看看所有提取的代码。
- en: In the first `beforeEach()`, we’re setting up a new `PasswordVerifier1` that
    will be created for each test case. In the `beforeEach()` after that, we’re setting
    up a fake rule and adding it to the new verifier for every test case under that
    specific scenario. If we had other scenarios, the second `beforeEach()` in line
    6 wouldn’t run for them, but the first one would.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个 `beforeEach()` 中，我们正在设置一个新的 `PasswordVerifier1`，它将为每个测试用例创建。在之后的 `beforeEach()`
    中，我们正在为该特定场景下的每个测试用例设置一个假规则并将其添加到新的验证器中。如果我们有其他场景，第 6 行的第二个 `beforeEach()` 不会为它们运行，但第一个会。
- en: The tests seem shorter now, which ideally is what you want in a test, to make
    it more readable and maintainable. We removed the creation line from each test
    and reused the same higher-level variable `verifier`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 测试看起来现在更短了，这在测试中理想情况下是你想要的，可以使它更易于阅读和维护。我们移除了每个测试中的创建行，并重用了相同的更高层次的变量 `verifier`。
- en: 'There are a couple of caveats:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点需要注意：
- en: We forgot to reset the `errors` array in `beforeEach()` on line 6\. That could
    bite us later on.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在第6行的`beforeEach()`中忘记重置`errors`数组。这可能会在以后给我们带来麻烦。
- en: Jest runs unit tests in parallel by default. This means that moving the verifier
    to line 2 may cause an issue with parallel tests, where the verifier could be
    overwritten by a different test on a parallel run, which would screw up the state
    of our running test. Jest is quite different from unit test frameworks in most
    other languages I know, which make a point of running tests in a single thread,
    not in parallel (at least by default), to avoid such issues. With Jest, we have
    to remember that parallel tests are a reality, so stateful tests with a shared
    upper state, like we have at line 2, can potentially be problematic and cause
    flaky tests that fail for unknown reasons.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jest默认并行运行单元测试。这意味着将验证器移到第2行可能会引起并行测试的问题，因为在并行运行中，验证器可能会被另一个测试覆盖，这将破坏我们正在运行的测试的状态。与我所知道的许多其他语言的单元测试框架相比，Jest相当不同，这些框架强调在单个线程中运行测试，而不是并行（至少默认情况下），以避免此类问题。在使用Jest时，我们必须记住并行测试是现实，因此具有共享上层状态的带状态测试，就像我们在第2行所做的那样，可能存在潜在问题，并可能导致原因不明的不可靠测试。
- en: We’ll correct both of these issues soon.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快纠正这两个问题。
- en: 2.6.1 beforeEach() and scroll fatigue
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6.1 `beforeEach()`和滚动疲劳
- en: 'We lost a couple of things in the process of refactoring to `beforeEach()`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在将代码重构为`beforeEach()`的过程中，我们失去了一些东西：
- en: If I’m trying to read only the `it()` parts, I can’t tell where the `verifier`
    is created and declared. I’d have to scroll up to understand.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我只想阅读`it()`部分，我无法知道验证器是在哪里创建和声明的。我必须向上滚动才能理解。
- en: The same goes for understanding what rule was added. I’d have to look one level
    above the `it()` to see what rule was added, or look up the `describe()` block
    description.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解添加了什么规则也是如此。我必须向上查看`it()`一级以查看添加了什么规则，或者查看`describe()`块描述。
- en: Right now, this doesn’t seem so bad. But we’ll see later that this structure
    starts to get a bit hairy as the scenario list increases in size. Larger files
    can bring about what I like to call *scroll fatigue*, requiring the test reader
    to scroll up and down the test file to understand the context and state of the
    tests. This makes maintaining and reading the tests a chore instead of a simple
    act of reading.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这似乎并不糟糕。但稍后我们会看到，随着场景列表的大小增加，这种结构开始变得有些复杂。较大的文件可能会带来我称之为*滚动疲劳*的情况，需要测试读者在测试文件中上下滚动以理解测试的上下文和状态。这使得维护和阅读测试变成了一项任务，而不是简单的阅读行为。
- en: This nesting is great for reporting, but it sucks for humans who have to keep
    looking up where something came from. If you’ve ever tried to debug CSS styles
    in the browser’s inspector window, you’ll know the feeling. You’ll see that a
    specific cell is bold for some reason. Then you scroll up to see which style made
    that `<div>` inside nested cells in a special `table` under the third node bold.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这种嵌套对于报告来说很棒，但对于必须不断查找事物来源的人来说很糟糕。如果你曾经尝试在浏览器的检查器窗口中调试CSS样式，你就会知道这种感觉。你会看到某个单元格由于某种原因而加粗。然后你向上滚动以查看哪个样式使第三个节点下的特殊`table`中的嵌套单元格内的`<div>`加粗。
- en: Let’s see what happens when we take it one step further in the following listing.
    Since we’re in the process of removing duplication, we can also call `verify`
    in `beforeEach()` and remove an extra line from each `it()`. This is basically
    putting the arrange and act parts from the AAA pattern into the `beforeEach()`
    function.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在以下列表中进一步推进会发生什么。由于我们正在删除重复，我们还可以在`beforeEach()`中调用`verify`并从每个`it()`中删除一行。这基本上是将AAA模式中的安排和执行部分放入`beforeEach()`函数中。
- en: Listing 2.14 Pushing the arrange and act parts into `beforeEach()`
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.14 将安排和执行部分推入`beforeEach()`
- en: '[PRE20]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code duplication has been reduced to a minimum, but now we also need to
    look up where and how we got the `errors` array if we want to understand each
    `it()`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重复已经减少到最小，但现在我们也需要查找`errors`数组在哪里以及如何获取它，如果我们想理解每个`it()`。
- en: Let’s double down and add a few more basic scenarios, and see if this approach
    is scalable as the problem space increases.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加大赌注，添加一些更多的基础场景，看看随着问题空间的增加，这种方法是否可扩展。
- en: Listing 2.15 Adding extra scenarios
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.15 添加额外场景
- en: '[PRE21]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Do we like this? I don’t. Now we’re seeing a couple of extra problems:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢这样吗？我不喜欢。现在我们看到了一些额外的问题：
- en: I can already start to see lots of repetition in the `beforeEach()` parts.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我已经可以看到`beforeEach()`部分中有很多重复。
- en: The potential for scroll fatigue has increased dramatically, with more options
    of which `beforeEach()` affects which `it()` state.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动疲劳的潜在风险显著增加，因为现在有更多选项来确定`beforeEach()`会影响哪个`it()`状态。
- en: 'In real projects, `beforeEach()` functions tend to be the garbage bin of the
    test file. People throw all kinds of test-initialized stuff in there: things that
    only some tests need, things that affect all the other tests, and things that
    nobody uses anymore. It’s human nature to put things in the easiest place possible,
    especially if everyone else before you has done so as well.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际项目中，`beforeEach()`函数往往成为测试文件的垃圾箱。人们会把各种测试初始化的东西扔进去：只有某些测试需要的东西，影响所有其他测试的东西，以及不再有人使用的东西。把东西放在最容易的地方是人的本性，尤其是如果你之前的人也都这样做的话。
- en: I’m not crazy about the `beforeEach()` approach. Let’s see if we can mitigate
    some of these issues while still keeping duplication to a minimum.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我对`beforeEach()`方法并不狂热。让我们看看我们是否可以在最小化重复的同时缓解一些这些问题。
- en: 2.7 Trying the factory method route
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7 尝试工厂方法路线
- en: '*Factory methods* are simple helper functions that help us build objects or
    special states and reuse the same logic in multiple places. Perhaps we can reduce
    some of the duplication and clunky-feeling code by using a couple of factory methods
    for the failing and passing rules in listing 2.16.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*工厂方法*是简单的辅助函数，帮助我们构建对象或特殊状态，并在多个地方重用相同的逻辑。也许我们可以通过使用列表2.16中失败和通过规则的几个工厂方法来减少一些重复和笨拙的代码。'
- en: Listing 2.16 Adding a couple of factory methods to the mix
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.16 向其中添加几个工厂方法
- en: '[PRE22]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `makeFailingRule()` and `makePassingRule()` factory methods have made our
    `beforeEach()` functions a little more clear.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeFailingRule()`和`makePassingRule()`工厂方法使我们的`beforeEach()`函数变得更加清晰。'
- en: 2.7.1 Replacing beforeEach() completely with factory methods
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.7.1 完全用工厂方法替换beforeEach()
- en: What if we don’t use `beforeEach()` to initialize various things at all? What
    if we switched to using small factory methods instead? Let’s see what that looks
    like.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们根本不使用`beforeEach()`来初始化各种东西怎么办？如果我们改为使用小的工厂方法呢？让我们看看那会是什么样子。
- en: Listing 2.17 Replacing `beforeEach()` with factory methods
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.17 替换`beforeEach()`为工厂方法
- en: '[PRE23]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The length here is about the same as in listing 2.16, but I find the code to
    be more readable and thus more easily maintained. We’ve eliminated the `beforeEach()`
    functions, but we didn’t lose maintainability. The amount of repetition we’ve
    eliminated is negligible, but the readability has improved greatly due to the
    removal of the nested `beforeEach()` blocks.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的长度与列表2.16大致相同，但我发现代码的可读性更高，因此更容易维护。我们消除了`beforeEach()`函数，但并没有失去可维护性。我们消除的重复量微乎其微，但由于消除了嵌套的`beforeEach()`块，可读性得到了极大的提高。
- en: Furthermore, we’ve reduced the risk of scroll fatigue. As a reader of the test,
    I don’t have to scroll up and down the file to find out when an object is created
    or declared. I can glean all the information from the `it()`. We don’t need to
    know *how* something is created, but we know *when* it is created and what important
    parameters it is initialized with. Everything is explicitly explained.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还降低了滚动疲劳的风险。作为测试的读者，我不必在文件上下滚动来找出对象何时被创建或声明。我可以从`it()`中获取所有信息。我们不需要知道*如何*创建某物，但我们知道*何时*创建以及它用哪些重要参数初始化。一切都得到了明确的解释。
- en: If the need arises, I can drill into specific factory methods, and I like that
    each `it()` is encapsulating its own state. The nested `describe()` structure
    is a good way to know where we are, but the state is all triggered from inside
    the `it()` blocks, not outside of them.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我可以深入到特定的工厂方法中，我喜欢每个`it()`都封装了自己的状态。嵌套的`describe()`结构是了解我们位置的好方法，但状态都是从`it()`块内部触发的，而不是外部。
- en: 2.8 Going full circle to test()
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.8 完整地使用test()进行测试
- en: The tests in listing 2.17 are self-encapsulated enough that the `describe()`
    blocks act only as added sugar for understanding. They are no longer needed if
    we don’t want them. If we wanted to, we could write the tests as in the following
    listing.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.17中的测试足够自包含，以至于`describe()`块仅仅作为理解时的额外糖。如果我们不想使用它们，它们就不再需要。如果我们想的话，我们可以像以下列表那样编写测试。
- en: Listing 2.18 Removing nested describes
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2.18 移除嵌套的describes
- en: '[PRE24]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The factory methods provide us with all the functionality we need, without losing
    clarity for each specific test.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法为我们提供了所有需要的功能，而不会在每个特定测试中失去清晰度。
- en: I kind of like the terseness of listing 2.18\. It’s easy to understand. We might
    lose a bit of structure clarity here, so there are instances where I go with the
    `describe`-less approach, and there are places where nested `describe`s make things
    more readable. The sweet spot of maintainability and readability for your project
    is probably somewhere between these two points.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我相当喜欢列表 2.18 的简洁性。它很容易理解。我们可能会失去一些结构清晰度，所以有些情况下我会选择没有`describe`的方法，而有些地方嵌套的`describe`会使内容更易于阅读。对于你的项目来说，可维护性和可读性的最佳平衡点可能就在这两个点之间。
- en: 2.9 Refactoring to parameterized tests
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.9 重构为参数化测试
- en: Let’s move away from the `verifier` class to work on creating and testing a
    new custom rule for the verifier. Listing 2.19 shows a simple rule for an uppercase
    letter (I realize passwords with these requirements are no longer considered a
    great idea, but for demonstration purposes I’m okay with it).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时离开`verifier`类，来创建和测试一个新的自定义规则。列表 2.19 显示了一个大写字母的简单规则（我意识到具有这些要求的密码不再被认为是一个好主意，但为了演示目的，我对此可以接受）。
- en: Listing 2.19 Password rules
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.19 密码规则
- en: '[PRE25]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We could write a couple of tests as in the following listing.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像以下列表中那样编写几个测试。
- en: Listing 2.20 Testing a rule with variations
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.20 使用变体测试规则
- en: '[PRE26]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In listing 2.20 I highlighted some duplication we might have if we’re trying
    out the same scenario with small variations in the input to the unit of work.
    In this case, we want to test that it should not matter where the uppercase letter
    is, as long as it’s there. But this duplication will hurt us down the road if
    we ever want to change the uppercase logic, or if we need to correct the assertions
    in some way for that use case.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 2.20 中，我突出显示了一些重复，如果我们尝试用单元工作输入的小幅变化来测试相同的场景。在这种情况下，我们想要测试的是，只要大写字母存在，位置无关紧要。但如果将来我们需要更改大写逻辑，或者需要以某种方式纠正该用例的断言，这种重复将会对我们造成伤害。
- en: 'There are a few ways to create parameterized tests in JavaScript, and Jest
    already includes one that’s built in: `test.each` (also aliased to `it.each`).
    The next listing shows how we could use this feature to remove duplication in
    our tests.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中创建参数化测试有几种方法，Jest 已经内置了一个：`test.each`（也称为别名`it.each`）。下一个列表展示了我们如何使用这个功能来减少测试中的重复。
- en: Listing 2.21 Using `test.each`
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.21 使用 `test.each`
- en: '[PRE27]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Passing in an array of values that are mapped to the input parameter
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将一个映射到输入参数的值数组传递
- en: ❷ Using each input parameter passed in the array
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用数组中传递的每个输入参数
- en: In this example, the test will repeat once for each value in the array. It’s
    a bit of a mouthful at first, but once you’ve tried this approach, it becomes
    easy to use. It’s also pretty readable.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，测试将针对数组中的每个值重复一次。一开始可能有点难以理解，但一旦你尝试了这种方法，它就会变得容易使用。它也相当易于阅读。
- en: If we want to pass in multiple parameters, we can enclose them in an array,
    as in the following listing.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想传递多个参数，我们可以将它们放在一个数组中，如下面的列表所示。
- en: Listing 2.22 Refactoring `test.each`
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.22 重构 `test.each`
- en: '[PRE28]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Providing three arrays, each with two parameters
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 提供三个包含两个参数的数组
- en: ❷ A new false expectation for a missing uppercase character
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对于缺失的大写字符的新预期
- en: ❸ Jest maps the array values to arguments automatically.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Jest 自动将数组值映射到参数。
- en: We don’t have to use Jest, though. JavaScript is versatile enough to allow us
    to roll out our own parameterized test quite easily if we want to.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不必使用 Jest，但 JavaScript 足够灵活，允许我们轻松地推出自己的参数化测试，如果我们想要的话。
- en: Listing 2.23 Using a vanilla JavaScript `for`
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.23 使用纯 JavaScript `for`
- en: '[PRE29]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It’s up to you which one you want to use (I like to keep it simple and use `test.each`).
    The point is, Jest is just a tool. The pattern of parameterized tests can be implemented
    in multiple ways. This pattern gives us a lot of power, but also a lot of responsibility.
    It’s really easy to abuse this technique and create tests that are harder to understand.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 取决于你想要使用哪一个（我喜欢保持简单，使用`test.each`）。重点是，Jest 只是一个工具。参数化测试的模式可以用多种方式实现。这个模式给我们带来了很多力量，但也带来了很多责任。滥用这个技术并创建难以理解的测试是非常容易的。
- en: 'I usually try to make sure that the same scenario (type of input) holds for
    the entire table. If I were reviewing this test in a code review, I would have
    told the person who wrote it that this test is actually testing two different
    scenarios: one with *no uppercase*, and a couple with *one uppercase*. I would
    split those out into two different tests.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常试图确保整个表格中相同的场景（输入类型）保持一致。如果我在代码审查中审查这个测试，我会告诉编写这个测试的人，这个测试实际上测试了两个不同的场景：一个没有大写字母，几个有一个大写字母。我会将它们分成两个不同的测试。
- en: In this example, I wanted to show that it’s very easy to get rid of many tests
    and put them all in a big `test.each`—even when it hurts readability—so be careful
    when running with these specific scissors.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我想展示的是，非常容易去掉许多测试并将它们全部放入一个大的 `test.each` 中——即使这会损害可读性——所以运行这些特定的剪刀时要小心。
- en: 2.10 Checking for expected thrown errors
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.10 检查预期的抛出错误
- en: Sometimes we need to design a piece of code that throws an error at the right
    time with the right data. What happens if we add code to the `verify` function
    that throws an error if there are no rules configured, as in the next listing?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要设计一段代码，在正确的时间和正确的数据下抛出错误。如果我们向 `verify` 函数中添加代码，当没有配置规则时抛出错误，会发生什么？就像下一个列表中那样？
- en: Listing 2.24 Throwing an error
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.24 抛出错误
- en: '[PRE30]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We could test it the old-fashioned way by using `try`/`catch`, and failing the
    test if we *don’t* get an error.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照老式的方法通过使用 `try`/`catch` 来测试，如果没有错误发生，测试就会失败。
- en: Listing 2.25 Testing exceptions with `try/catch`
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.25 使用 `try/catch` 测试异常
- en: '[PRE31]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Using fail()
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 fail()
- en: Technically, `fail()` is a leftover API from the original fork of Jasmine, which
    Jest is based on. It’s a way to trigger a test failure, but it’s not in the official
    Jest API docs, and they would recommend that you use `expect.assertions(1)` instead.
    This would fail the test if you never reached the `catch()` expectation. I find
    that as long as `fail()` still works, it does the job quite nicely for my purposes,
    which are to demonstrate why you shouldn’t use the `try`/`catch` construct in
    a unit test if you can help it.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，`fail()` 是 Jasmine 原始分支的遗留 API，Jest 是基于 Jasmine 开发的。它是一种触发测试失败的方式，但它不在官方
    Jest API 文档中，他们建议你使用 `expect.assertions(1)` 代替。这样，如果你从未达到 `catch()` 预期，测试就会失败。我发现只要
    `fail()` 仍然有效，它就能很好地完成我的任务，我的任务是证明如果你能避免在单元测试中使用 `try`/`catch` 构造，你应该避免使用它。
- en: This `try`/`catch` pattern is an effective method but very verbose and annoying
    to type. Jest, like most other frameworks, contains a shortcut to accomplish exactly
    this type of scenario, using `expect().toThrowError()`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这种 `try`/`catch` 模式是一种有效的方法，但非常冗长且难以输入。Jest，像大多数其他框架一样，包含一个快捷方式来完成这种类型的场景，使用
    `expect().toThrowError()`。
- en: Listing 2.26 Using `expect().toThrowError()`
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.26 使用 `expect().toThrowError()`
- en: '[PRE32]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Using a regular expression instead of looking for the exact string
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用正则表达式而不是查找确切的字符串
- en: Notice that I’m using a regular expression match to check that the error string
    *contains* a specific string, and is not equal to it, so as to make the test a
    bit more future-proof if the string changes on its sides. `toThrowError` has a
    few variations, and you can go to [https://jestjs.io/](https://jestjs.io/) find
    out all about them.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我正在使用正则表达式匹配来检查错误字符串是否包含特定的字符串，而不是等于它，这样可以使测试在字符串发生变化时更具未来性。`toThrowError`
    有几种变体，你可以访问 [https://jestjs.io/](https://jestjs.io/) 了解所有相关信息。
- en: Jest snapshots
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 快照
- en: Jest has a unique feature called Snapshots. It allows you to render a component
    (when working in a framework like React) and then match the current rendering
    to a saved snapshot of that component, including all of its properties and HTML.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 有一个独特的功能叫做快照。它允许你在使用像 React 这样的框架时渲染一个组件，然后将当前的渲染与该组件保存的快照进行匹配，包括所有属性和
    HTML。
- en: 'I won’t be touching on this too much, but from what I’ve seen, this feature
    tends to be abused quite heavily. You can use it to create hard-to-read tests
    that look something like this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会过多地涉及这个话题，但从我所见到的来看，这个功能往往被过度使用。你可以用它来创建难以阅读的测试，看起来像这样：
- en: '[PRE33]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is obtuse (hard to reason about what is being tested) and it’s testing
    many things that might not be related to one another. It will also break for many
    reasons that you might not care about, so the maintainability cost of that test
    will be higher over time. It’s also a great excuse not to write readable and maintainable
    tests, because you’re on a deadline but still have to show you write tests. Yes,
    it does serve a purpose, but it’s easy to use in places where other types of tests
    are more relevant.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这很晦涩（难以推理正在测试的内容），并且测试了许多可能彼此无关的事情。它还可能因为许多你不太关心的原因而失败，因此该测试的维护成本会随着时间的推移而增加。它也是一个很好的借口，不写可读性和可维护的测试，因为你在截止日期内，但仍然需要展示你写了测试。是的，它确实有作用，但在其他类型测试更相关的地方很容易使用。
- en: If you need a variation of this, try using `toMatchInlineSnapshot()` instead.
    You can find more info at [https://jestjs.io/docs/en/snapshot-testing](https://jestjs.io/docs/en/snapshot-testing).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要这种变化的变体，请尝试使用 `toMatchInlineSnapshot()`。你可以在 [https://jestjs.io/docs/en/snapshot-testing](https://jestjs.io/docs/en/snapshot-testing)
    找到更多信息。
- en: 2.11 Setting test categories
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.11 设置测试类别
- en: If you’d like to run only a specific category of tests, such as only unit tests,
    or only integration tests, or only tests that touch a specific part of the application,
    Jest currently doesn’t have the ability to define test case categories.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想运行特定类别的测试，例如只想运行单元测试、集成测试，或者只想运行触及应用程序特定部分的测试，Jest 目前还没有定义测试案例类别的功能。
- en: All is not lost, though. Jest has a special `--testPathPattern` command-line
    flag, which allows us to define how Jest will find our tests. We can trigger this
    command with a different path for a specific type of test we’d like to run (such
    as “all tests under the ‘integration’ folder”). You can get the full details at
    [https://jestjs.io/docs/en/cli](https://jestjs.io/docs/en/cli).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，并非一切都已失去。Jest 有一个特殊的 `--testPathPattern` 命令行标志，它允许我们定义 Jest 将如何找到我们的测试。我们可以通过为想要运行的特定类型的测试（例如，“集成”文件夹下的所有测试”）使用不同的路径来触发此命令。你可以在
    [https://jestjs.io/docs/en/cli](https://jestjs.io/docs/en/cli) 获取完整详情。
- en: Another alternative is to create a separate jest.config.js file for each test
    category, each with its own `testRegex` configuration and other properties.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个替代方案是为每个测试类别创建一个单独的 jest.config.js 文件，每个文件都有其自己的 `testRegex` 配置和其他属性。
- en: Listing 2.27 Creating separate jest.config.js files
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.27 创建单独的 jest.config.js 文件
- en: '[PRE34]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, for each category, you can create a separate npm script that invokes
    the Jest command line with a custom config file: `jest` `-c` `my.custom.jest.config.js`.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于每个类别，你可以创建一个单独的 npm 脚本来调用具有自定义配置文件的 Jest 命令行：`jest` `-c` `my.custom.jest.config.js`。
- en: Listing 2.28 Using separate npm scripts
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2.28 使用单独的 npm 脚本
- en: '[PRE35]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the next chapter, we’ll look at code that has dependencies and testability
    problems, and we’ll start discussing the idea of fakes, spies, mocks, and stubs,
    and how you can use them to write tests against such code.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将查看具有依赖性和可测试性问题的代码，并开始讨论伪造、间谍、模拟和存根的概念，以及如何使用它们来编写针对此类代码的测试。
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Jest is a popular, open source test framework for JavaScript applications. It
    simultaneously acts as a *test library* to use when writing tests, an *assertion
    library* for asserting inside the tests, a *test runner*, and a *test reporter*.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jest 是一个流行的开源 JavaScript 应用程序测试框架。它同时充当测试时使用的 *测试库*、测试内的 *断言库*、*测试运行器* 和 *测试报告器*。
- en: '*Arrange-Act-Assert* (*AAA*) is a popular pattern for structuring tests. It
    provides a simple, uniform layout for all tests. Once you get used to it, you
    can easily read and understand any test.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安排-行动-断言* (*AAA*) 是一种流行的测试结构模式。它为所有测试提供了一个简单、统一的布局。一旦习惯了它，你就可以轻松地阅读和理解任何测试。'
- en: In the AAA pattern, the *arrange* section is where you bring the system under
    test and its dependencies to a desired state. In the *act* section, you call methods,
    pass the prepared dependencies, and capture the output value (if any). In the
    *assert* section, you verify the outcome.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 AAA 模式下，*安排* 部分是你将待测试的系统及其依赖项带到所需状态的地方。在 *行动* 部分中，你调用方法，传递准备好的依赖项，并捕获输出值（如果有）。在
    *断言* 部分中，你验证结果。
- en: A good pattern for naming tests is to include in the name of the test the unit
    of work under test, the scenario or inputs to the unit, and the expected behavior
    or exit point. A handy mnemonic for this pattern is USE (unit, scenario, expectation).
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试命名的良好模式是在测试名称中包含待测试的工作单元、单元的情景或输入，以及预期的行为或退出点。这个模式的一个方便的记忆法是 USE（单元、情景、期望）。
- en: Jest provides several functions that help create more structure around multiple
    related tests. `describe()` is a scoping function that allows for grouping multiple
    tests (or groups of tests) together. A good metaphor for `describe()` is a folder
    containing tests or other folders. `test()` is a function denoting an individual
    test. `it()` is an alias for `test()`, but it provides better readability when
    used in combination with `describe()`.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jest 提供了几个函数，有助于围绕多个相关测试创建更多结构。`describe()` 是一个作用域函数，允许将多个测试（或测试组）组合在一起。`describe()`
    的一个好比喻是包含测试或其他文件夹的文件夹。`test()` 是表示单个测试的函数。`it()` 是 `test()` 的别名，但与 `describe()`
    结合使用时，可读性更好。
- en: '`beforeEach()` helps avoid duplication by extracting code that is common for
    the nested `describe` and `it` functions.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeEach()` 通过提取嵌套 `describe` 和 `it` 函数中通用的代码来帮助避免重复。'
- en: The use of `beforeEach()` often leads to scroll fatigue, when you have to look
    at various places to understand what a test does.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你必须查看多个地方来理解测试做了什么时，使用 `beforeEach()` 往往会导致滚动疲劳。
- en: '*Factory methods* with plain tests (without any `beforeEach()`) improve readability
    and help avoid scroll fatigue.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用普通测试（没有任何 `beforeEach()`）的*工厂方法*可以提高可读性，并有助于避免滚动疲劳。
- en: '*Parameterized tests* help reduce the amount of code needed for similar tests.
    The drawback is that the tests become less readable as you make them more generic.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*参数化测试*有助于减少相似测试所需的代码量。缺点是，随着测试变得更加通用，可读性会降低。'
- en: To maintain a balance between test readability and code reuse, only parameterize
    input values. Create separate tests for different output values.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了在测试可读性和代码重用之间保持平衡，仅参数化输入值。为不同的输出值创建单独的测试。
- en: Jest doesn’t support test categories, but you can run groups of tests using
    the `--testPathPattern` flag. You can also set up `testRegex` in the configuration
    file.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jest 不支持测试类别，但你可以使用 `--testPathPattern` 标志来运行测试组。你还可以在配置文件中设置 `testRegex`。
