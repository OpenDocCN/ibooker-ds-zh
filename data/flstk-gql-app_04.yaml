- en: 3 Graphs in the database
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 数据库中的图
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: An introduction to graph databases with a focus on Neo4j
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专注于Neo4j的图数据库简介
- en: The property graph data model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性图数据模型
- en: Using the Cypher query language to create and query data in Neo4j
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cypher查询语言在Neo4j中创建和查询数据
- en: Using client drivers for Neo4j, specifically the JavaScript Node.js driver
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Neo4j客户端驱动程序，特别是JavaScript Node.js驱动程序
- en: Fundamentally, a graph database is a software tool that allows the user to model,
    store, and query data as a graph. Working with a graph at the database level is
    often more intuitive for modeling complex connected data and can be more performant
    when working with complex queries that require traversing many connected entities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，图数据库是一个允许用户以图的形式建模、存储和查询数据的软件工具。在数据库级别使用图通常对建模复杂连接数据更为直观，并且在处理需要遍历许多连接实体的复杂查询时可能性能更佳。
- en: In this chapter, we begin the process of creating a property graph data model
    using the business requirements from the previous chapter and compare it to the
    GraphQL schema created in the previous chapter. We then explore the Cypher query
    language, focusing on how to write Cypher queries to address the requirements
    of our application. Along the way, we show how to install Neo4j, use Neo4j Desktop
    to create new Neo4j projects locally, and use Neo4j Browser to query Neo4j and
    visualize the results. Finally, we show how to use the Neo4j JavaScript client
    driver to create a simple Node.js application that queries Neo4j.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始使用上一章的业务需求创建属性图数据模型的过程，并将其与上一章中创建的GraphQL模式进行比较。然后，我们探讨Cypher查询语言，重点关注如何编写Cypher查询以满足我们应用程序的需求。在这个过程中，我们展示了如何安装Neo4j，使用Neo4j
    Desktop在本地创建新的Neo4j项目，以及如何使用Neo4j Browser查询Neo4j并可视化结果。最后，我们展示了如何使用Neo4j JavaScript客户端驱动程序创建一个简单的Node.js应用程序，该应用程序查询Neo4j。
- en: 3.1 Neo4j overview
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 Neo4j概述
- en: Neo4j is a native graph database that uses the property graph model for modeling
    data and the Cypher query language for interacting with the database. Neo4j is
    a transactional database with full ACID guarantees necessary for operational workloads
    and can also be used for graph analytics. Graph databases like Neo4j are optimized
    for working with highly connected data and queries that traverse the graph (think
    of the equivalent of multiple JOINs in a relational database) and, therefore,
    are the perfect backend for GraphQL APIs, which describe connected data and often
    result in complex, nested queries. Neo4j is open source and can be downloaded
    from [neo4j.com/download](https://neo4j.com/download/).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j是一个使用属性图模型建模数据和使用Cypher查询语言与数据库交互的原生图数据库。Neo4j是一个具有完整ACID保证的事务型数据库，这对于操作工作负载是必要的，也可以用于图分析。像Neo4j这样的图数据库针对处理高度连接的数据和遍历图（在关系型数据库中相当于多个JOIN操作）的查询进行了优化，因此是GraphQL
    API的完美后端，这些API描述了连接数据，并且通常会导致复杂、嵌套的查询。Neo4j是开源的，可以从[neo4j.com/download](https://neo4j.com/download/)下载。
- en: We will make use of Neo4j Desktop and Neo4j Browser in this chapter as we learn
    how to create and query data in Neo4j, but first, let’s dig into the property
    graph model used by Neo4j and see how it relates to the model used to describe
    GraphQL APIs that we reviewed in the previous chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何在Neo4j中创建和查询数据时使用Neo4j Desktop和Neo4j Browser，但首先，让我们深入了解Neo4j使用的属性图模型，并看看它与我们之前章节中审查的GraphQL
    API模型之间的关系。
- en: 3.2 Graph data modeling with Neo4j
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 使用Neo4j进行图数据建模
- en: Unlike other databases that use tables or documents to model data, graph databases
    like Neo4j model, store, and allow the user to query data as a graph. In a graph,
    nodes are the entities, and relationships connect them. In a relational database,
    we represent relationships with foreign keys and join tables. In a document database,
    we reference other entities using IDs or even denormalizing and embedding other
    entities in a single document (see figure 3.1).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用表或文档来建模数据的其他数据库不同，像Neo4j这样的图数据库将数据建模、存储并允许用户以图的形式查询数据。在图中，节点是实体，关系将它们连接起来。在关系型数据库中，我们使用外键和连接表来表示关系。在文档数据库中，我们使用ID引用其他实体，甚至可以在单个文档中非规范化并嵌入其他实体（参见图3.1）。
- en: '![CH03_F01_Lyon](../../OEBPS/Images/CH03_F01_Lyon.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F01_Lyon](../../OEBPS/Images/CH03_F01_Lyon.png)'
- en: Figure 3.1 Comparing relational, document, and graph data models
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 比较关系型、文档型和图数据模型
- en: The first step when working with a database is to determine the data model that
    will be used. In our case, our data model will be driven from the business requirements
    we defined in the previous chapter—working with businesses, users, and reviews.
    Review the requirements listed in the first section of the previous chapter for
    a refresher. Let’s take those requirements and our knowledge of the domain to
    create a whiteboard model.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库一起工作时，第一步是确定将要使用的数据模型。在我们的案例中，我们的数据模型将由我们在上一章中定义的业务需求驱动——与商业、用户和评论一起工作。回顾上一章第一部分中列出的需求以进行复习。让我们根据那些需求和我们对该领域的了解来创建一个白板模型。
- en: Whiteboard model
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 白板模型
- en: We will use the term *whiteboard model* to refer to the diagram typically created
    when first reasoning about a domain, which is often a graph of entities and how
    they relate, drawn on a whiteboard (see the following figure).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用术语*白板模型*来指代在首次对一个领域进行推理时通常创建的图，这通常是在白板上绘制的实体及其关系的图（参见以下图）。
- en: '![CH03_F01_UN01_Lyon](../../OEBPS/Images/CH03_F01_UN01_Lyon.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F01_UN01_Lyon](../../OEBPS/Images/CH03_F01_UN01_Lyon.png)'
- en: 'Building the property graph model: whiteboard model'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 构建属性图模型：白板模型
- en: How do we translate this mental model from the whiteboard model to the physical
    data model used by the database? In other systems, this might involve creating
    an entity-relationship (ER) diagram or defining the schema of the database. Neo4j
    is said to be *schema optional*. While we can create database constraints to enforce
    constraints, such as property uniqueness, we can also use Neo4j without these
    constraints or a schema. But the first step is to define a model using the property
    graph data model, which is the model used by Neo4j and other graph databases.
    Let’s convert our simple whiteboard model, shown previously, into a property graph
    model we can use in the database.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将这个思维模型从白板模型转换为数据库使用的物理数据模型？在其他系统中，这可能涉及创建实体-关系（ER）图或定义数据库的模式。据说Neo4j是*可选模式的*。虽然我们可以创建数据库约束来强制约束，例如属性唯一性，但我们也可以在没有这些约束或模式的情况下使用Neo4j。但第一步是使用属性图数据模型定义一个模型，这是Neo4j和其他图数据库使用的模型。让我们将之前展示的简单白板模型转换为可以在数据库中使用的属性图模型。
- en: 3.2.1 The property graph model
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 属性图模型
- en: We gave a brief overview of the property graph data model in chapter 1\. Next,
    we will go through the process of taking our whiteboard model and converting it
    to a property graph model used by the database.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们简要概述了属性图数据模型。接下来，我们将介绍将我们的白板模型转换为数据库使用的属性图模型的过程。
- en: The property graph data model
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 属性图数据模型
- en: The property graph model is composed of
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 属性图模型由以下部分组成
- en: Node labels—Nodes are the entities or objects in our data model. Nodes can have
    one or more labels that describe how nodes are grouped (think type of entity).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点标签——节点是我们数据模型中的实体或对象。节点可以有一个或多个标签，这些标签描述了节点是如何分组的（想想实体类型）。
- en: Relationships—Relationships connect two nodes and have a single type and direction.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系——关系连接两个节点，具有单一类型和方向。
- en: Properties—These are arbitrary key-value pair attributes that are stored on
    either nodes or relationships.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性——这些是存储在节点或关系上的任意键值对属性。
- en: Node labels
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 节点标签
- en: Nodes represent the objects in our whiteboard model. Each node can have one
    or more labels, which is a way of grouping nodes. Adding node labels to a whiteboard
    model is usually a simple process, since some grouping will already have been
    defined during the whiteboard process. Here we formalize the descriptors used
    to refer to our nodes into node labels (later, we will add node aliases and multiple
    labels, so we use a colon as a separator to indicate the label; see figure 3.2).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 节点代表白板模型中的对象。每个节点可以有一个或多个标签，这是一种分组节点的方式。向白板模型添加节点标签通常是一个简单的过程，因为在白板过程中已经定义了一些分组。在这里，我们将用于引用我们的节点的描述符正式化为节点标签（稍后，我们将添加节点别名和多个标签，因此我们使用冒号作为分隔符来表示标签；参见图3.2）。
- en: '![CH03_F02_Lyon](../../OEBPS/Images/CH03_F02_Lyon.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F02_Lyon](../../OEBPS/Images/CH03_F02_Lyon.png)'
- en: 'Figure 3.2 Building the property graph model: node labels'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 构建属性图模型：节点标签
- en: Graph data model diagramming tools
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据模型绘图工具
- en: There are many tools available for diagramming graph data models. Throughout
    this book, we use the Arrows tool, a simple web-based application that allows
    for creating graph data models. Arrows is available online at [https://arrows.app](https://arrows.app).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可用于图形化图数据模型。在这本书的整个过程中，我们使用Arrows工具，这是一个简单的基于Web的应用程序，允许创建图数据模型。Arrows可在网上找到：[https://arrows.app](https://arrows.app)。
- en: 'The Arrows user interface is minimal and is designed around creating property
    graph data models:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Arrows用户界面是最简化的，它围绕创建属性图数据模型而设计：
- en: Create new nodes with the (+ Node) button or by dragging out from an existing
    node.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用（+ 节点）按钮或从现有节点拖出创建新节点。
- en: Drag relationships out of the halo of a node, either to an empty space for a
    new node or centered over an existing one to connect them.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将关系从节点的光环中拖出，要么拖到空白空间以创建新节点，要么拖到现有节点上方以连接它们。
- en: 'Double-click nodes and relationships to edit them, set names, and set properties
    (in a key: value syntax).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双击节点和关系以编辑它们，设置名称，并设置属性（使用键：值语法）。
- en: You can export to PNG, SVG, and other formats (including GraphQL type definitions).
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以导出为PNG、SVG和其他格式（包括GraphQL类型定义）。
- en: The convention used for casing node labels is PascalCase. See the Cypher style
    guide for more examples of naming conventions at [neo4j.com/developer/cypher/style-guide/](https://neo4j.com/developer/cypher/style-guide/).
    Nodes can have multiple labels and allow us to represent type hierarchies, roles
    in different contexts, or even multitenancy.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 用于节点标签的大小写约定是PascalCase。有关命名约定的更多示例，请参阅Cypher风格指南：[neo4j.com/developer/cypher/style-guide/](https://neo4j.com/developer/cypher/style-guide/)。节点可以有多个标签，并允许我们表示类型层次结构、不同上下文中的角色，甚至多租户。
- en: Relationships
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关系
- en: Once we’ve identified our nodes labels, the next step is to identify the relationships
    in our data model. Relationships have a single type and direction but can be queried
    in either direction (see the figure in the following sidebar).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了节点标签，下一步就是确定数据模型中的关系。关系有一个单一的类型和方向，但可以以任一方向查询（见下侧栏中的图）。
- en: Dealing with undirected relationships
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 处理无向关系
- en: While every relationship has a single direction, we can treat the relationship
    as undirected at query time by not specifying a direction in the Cypher query.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个关系只有一个方向，但我们在查询时可以通过在Cypher查询中不指定方向来将关系视为无向的。
- en: '![CH03_F02_UN02_Lyon](../../OEBPS/Images/CH03_F02_UN02_Lyon.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F02_UN02_Lyon](../../OEBPS/Images/CH03_F02_UN02_Lyon.png)'
- en: 'Building the property graph model: relationship types'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 构建属性图模型：关系类型
- en: 'A good guideline for naming relationships is that the traversal from a node
    along a relationship to another node should read as a somewhat comprehensible
    sentence (e.g., “User wrote review” or “Review reviews business”). You can read
    more about best practices for naming and conventions in the *Cypher Style Guide*:
    [neo4j.com/developer/cypher-style-guide](https://neo4j.com/developer/cypher/style-guide/).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 命名关系的良好指南是，从节点沿关系到另一个节点的遍历应读作一个多少有些可理解的句子（例如，“用户撰写评论”或“评论评论业务”）。您可以在*Cypher风格指南*中了解更多关于命名和约定的最佳实践：[neo4j.com/developer/cypher-style-guide](https://neo4j.com/developer/cypher/style-guide/)。
- en: Properties
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 属性
- en: Properties are arbitrary key-value pairs stored on nodes and relationships.
    These are the attributes or fields of entities in our data model. Here we store
    userId and name as string properties on the *User* node, as well as other relevant
    properties on the *Review* and *Business* nodes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是存储在节点和关系上的任意键值对。这些是我们数据模型中实体的属性或字段。在这里，我们在*用户*节点上存储userId和name作为字符串属性，以及在*评论*和*业务*节点上的其他相关属性。
- en: Property types
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 属性类型
- en: 'The following property types are supported by Neo4j (see the following figure):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j支持以下属性类型（见下图）：
- en: '|'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: String
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: '|'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Date, DateTime, and other temporal types
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期、日期时间和其他时间类型
- en: '|'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Float
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数
- en: '|'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Point
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点
- en: '|'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Long
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长度
- en: '|'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Lists of the previous types
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之前类型的列表
- en: '|'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '![CH03_F02_UN03_Lyon](../../OEBPS/Images/CH03_F02_UN03_Lyon.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F02_UN03_Lyon](../../OEBPS/Images/CH03_F02_UN03_Lyon.png)'
- en: 'Building the property graph model: properties'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 构建属性图模型：属性
- en: 3.2.2 Database constraints and indexes
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 数据库约束和索引
- en: Now that we’ve defined our data model, how do we make use of it in the database?
    As mentioned earlier, unlike other databases that require us to define a complete
    schema before inserting data, Neo4j is said to be schema optional and does not
    require the use of a pre-defined schema. Instead, we can define database constraints
    that ensure the data adheres to the rules of the domain. We can create uniqueness
    constraints that ensure property values are unique across a node label (e.g.,
    guaranteeing that no two users have a duplicate ID property value), property existence
    constraints (e.g., ensuring that a set of properties exist when a node or relationship
    is created or modified), and node key constraints, which are similar to a composite
    key and create a constraint using multiple properties.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的数据模型，我们如何在数据库中利用它呢？如前所述，与其他数据库不同，这些数据库在插入数据之前要求我们定义完整的模式，Neo4j据说具有可选模式，并且不需要使用预定义的模式。相反，我们可以定义数据库约束，以确保数据遵循领域规则。我们可以创建唯一性约束，确保属性值在节点标签之间是唯一的（例如，保证没有两个用户有重复的ID属性值），属性存在约束（例如，确保在创建或修改节点或关系时存在一组属性），以及节点键约束，这与复合键类似，并使用多个属性创建约束。
- en: Database constraints are backed by indexes, which can be created separately
    as well. In a graph database, indexes are used to find the starting point for
    a traversal, not to traverse the graph. We will cover database constraints and
    indexes in more detail in the following section, which introduces Cypher.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库约束由索引支持，这些索引也可以单独创建。在图数据库中，索引用于找到遍历的起点，而不是用于遍历图。我们将在下一节中更详细地介绍数据库约束和索引，该节介绍了Cypher。
- en: 3.3 Data modeling considerations
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 数据建模考虑因素
- en: 'Graph data modeling can be an iterative process. In general, this is the process
    followed:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图数据建模可能是一个迭代过程。一般来说，这是遵循的过程：
- en: What are the entities? How are they grouped? These become nodes and node labels.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实体是什么？它们是如何分组的？这些成为节点和节点标签。
- en: How are these entities connected? These become relationships.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些实体是如何连接的？这些成为关系。
- en: What are the attributes of the nodes and relationships? These become properties.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节点和关系的属性是什么？这些成为属性。
- en: Can you identify the graph traversal that answers your questions? These become
    Cypher queries. If not, iterate on the graph model.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能识别出回答你问题的图遍历吗？这些将成为Cypher查询。如果不能，请迭代图模型。
- en: However, there are often some nuances not covered by this general approach.
    We address some common graph data modeling questions in the following section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常有一些细微差别没有被这种通用方法涵盖。我们将在下一节中解决一些常见的图数据建模问题。
- en: 3.3.1 Node vs. property
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 节点与属性
- en: Sometimes, it can be difficult to determine whether a value should be modeled
    as a node or a property on the node. A good guideline to follow here is to ask
    yourself the question, “Could I discover something useful by traversing through
    this value if it was a node?” If the answer is yes, then it should be modeled
    as a node; if not, then treat it as a property. For example, consider if we were
    to add the category of business to our model. Finding businesses with overlapping
    categories is potentially useful and easier to discover if the category is modeled
    as a node. On the other hand, consider a business address. If we modeled the address
    as a node instead of a property, would it be useful to traverse through the address
    node? Most likely, that is not useful, and we should model the address as a property.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，确定一个值应该建模为节点还是节点上的属性可能会有困难。这里的一个好指南是问自己这样的问题，“如果这个值是一个节点，我能否通过遍历这个值发现一些有用的信息？”如果答案是肯定的，那么它应该被建模为节点；如果不是，那么将其视为属性。例如，考虑如果我们向我们的模型添加业务类别。找到具有重叠类别的业务可能是有用的，并且如果类别被建模为节点，那么发现它可能更容易。另一方面，考虑一个商业地址。如果我们将地址建模为节点而不是属性，那么遍历地址节点会有用吗？很可能是没有用，我们应该将地址建模为属性。
- en: 3.3.2 Node vs. relationship
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 节点与关系
- en: In the case where we have a piece of data that seemingly connects two nodes
    (e.g., a review of a business, written by a user), should we model this data as
    a node or as a relationship? At first glance, it seems like we might want to just
    create a REVIEWS relationship connecting the user and business, storing the review
    information, such as stars and text, as relationship properties. However, we might
    want to extract data from the review, such as keywords mentioned, through some
    natural language processing technique, and connect that extracted data to the
    review. Or perhaps we want to use the review nodes as the starting point for a
    traversal query. These are two examples of why we may want to choose to model
    this data as an intermediate node instead of as a relationship.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有一份数据似乎连接了两个节点的情况下（例如，一个由用户撰写的商业评论），我们应该将此数据建模为一个节点还是一个关系？乍一看，我们可能只想创建一个连接用户和商业的REVIEWS关系，将评论信息（如星级和文本）作为关系属性存储。然而，我们可能希望通过某些自然语言处理技术从评论中提取数据，例如提到的关键词，并将提取的数据连接到评论。或者，我们可能希望将评论节点作为遍历查询的起点。这些都是我们可能选择将此数据建模为中间节点而不是关系的原因的两个例子。
- en: 3.3.3 Indexes
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 索引
- en: Indexes are used in graph databases to find the starting point of a traversal,
    not during the actual traversal. This is an important performance characteristic
    of graph databases like Neo4j, known as *index-free adjacency*. Only create indexes
    for properties that will be used to find the starting point of a traversal, such
    as a user name or business ID.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 索引在图数据库中用于查找遍历的起点，而不是在遍历过程中。这是像Neo4j这样的图数据库的一个重要性能特征，称为*无索引邻接*。只为将用于查找遍历起点的属性创建索引，例如用户名或业务ID。
- en: 3.3.4 Specificity of relationship types
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.4 关系类型的特定性
- en: Relationship types are a way of grouping relationships and should convey just
    enough information to make it clear how two nodes are connected without being
    overly specific. For example, REVIEWS is a good relationship type connecting Review
    and Business nodes. REVIEW_WRITTEN_BY_BOB_FOR_PIZZA is an overly specific relationship
    type; the name of the user and restaurant are stored elsewhere and do not need
    to be duplicated in the relationship type.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关系类型是分组关系的一种方式，应该传达足够的信息，以便清楚地表明两个节点是如何连接的，而不需要过于具体。例如，REVIEWS是一个很好的关系类型，它连接了Review和Business节点。REVIEW_WRITTEN_BY_BOB_FOR_PIZZA是一个过于具体的关系类型；用户和餐厅的名称存储在其他地方，不需要在关系类型中重复。
- en: 3.3.5 Choosing a relationship direction
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.5 选择关系方向
- en: All relationships in the property graph model have a single direction but can
    be queried in either direction or queried without consideration of direction.
    There is no need to create duplicate relationships to model bidirectionality.
    In general, you should choose relationship directions that allow for a consistent
    reading of the data model.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 属性图模型中的所有关系都有一个单一的方向，但可以双向查询或不考虑方向进行查询。不需要创建重复的关系来模拟双向性。通常，你应该选择允许一致读取数据模型的关系方向。
- en: '3.4 Tooling: Neo4j desktop'
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 工具：Neo4j桌面
- en: Now that we understand the property graph data model and have defined a simple
    version of the model we will use for our business reviews application, let’s create
    a Neo4j database and start executing some Cypher queries. To do this, we will
    make use of Neo4j Desktop, which is the mission control center for Neo4j (see
    figure 3.3). In Neo4j Desktop, we can create projects and instances of Neo4j.
    We can start, stop, and configure Neo4j database instances in Neo4j Desktop, as
    well as install optional database plugins, such as Graph Data Science and APOC
    (a standard library of database procedures for Neo4j). Neo4j Desktop also includes
    functionality for installing *graph apps*, which are applications that run in
    Neo4j Desktop and connect to the active Neo4j instance. Neo4j Browser, installed
    by default, is an example of one of these graph apps. See [install.graphapp.io](https://install.graphapp.io/)
    for examples of other graph apps.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了属性图数据模型，并且定义了我们用于业务审查应用的模型的一个简单版本，让我们创建一个Neo4j数据库并开始执行一些Cypher查询。为此，我们将利用Neo4j
    Desktop，它是Neo4j的任务控制中心（见图3.3）。在Neo4j Desktop中，我们可以创建项目和Neo4j的实例。我们可以在Neo4j Desktop中启动、停止和配置Neo4j数据库实例，以及安装可选的数据库插件，例如图数据科学和APOC（Neo4j的数据库过程标准库）。Neo4j
    Desktop还包括安装*图应用*的功能，这些应用在Neo4j Desktop中运行并连接到活动的Neo4j实例。默认安装的Neo4j浏览器就是这些图应用中的一个例子。有关其他图应用的示例，请参阅[install.graphapp.io](https://install.graphapp.io/)。
- en: '![CH03_F03_Lyon](../../OEBPS/Images/CH03_F03_Lyon.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F03_Lyon](../../OEBPS/Images/CH03_F03_Lyon.png)'
- en: 'Figure 3.3 Neo4j Desktop: Mission control for Neo4j'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 Neo4j Desktop：Neo4j 的任务控制台
- en: If you haven’t yet downloaded Neo4j Desktop, do so now at [neo4j.com/download](https://neo4j.com/download/).
    Neo4j Desktop is available to download for Mac, Windows, and Linux systems.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未下载 Neo4j Desktop，请现在前往 [neo4j.com/download](https://neo4j.com/download/)
    进行下载。Neo4j Desktop 可供 Mac、Windows 和 Linux 系统下载。
- en: Once you have downloaded and installed Neo4j, create a new local Neo4j instance
    by selecting *Add Graph*. You’ll be prompted to enter a database name and password.
    The password can be anything you want; just be sure to remember it for later.
    Once you’ve created the graph, click the *Start* button to activate it; then we’ll
    use Neo4j Browser to start querying the database we just created.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下载并安装 Neo4j 后，通过选择 *添加图* 创建一个新的本地 Neo4j 实例。您将被提示输入数据库名和密码。密码可以是您想要的任何内容；只需确保您能记住它以备后用。创建图后，点击
    *启动* 按钮激活它；然后我们将使用 Neo4j 浏览器来查询我们刚刚创建的数据库。
- en: '3.5 Tooling: Neo4j Browser'
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 工具：Neo4j 浏览器
- en: Neo4j Browser is a query workbench for Neo4j that allows developers to interact
    with the database by writing Cypher queries and visualizing the results (see figure
    3.4). Start Neo4j Browser by selecting its application icon in the *Application*
    section of Neo4j Desktop.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j 浏览器是一个 Neo4j 的查询工作台，允许开发者通过编写 Cypher 查询并与结果可视化来与数据库交互（见图 3.4）。通过在 Neo4j
    Desktop 的 *应用程序* 部分选择其应用程序图标来启动 Neo4j 浏览器。
- en: '![CH03_F04_Lyon](../../OEBPS/Images/CH03_F04_Lyon.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F04_Lyon](../../OEBPS/Images/CH03_F04_Lyon.png)'
- en: 'Figure 3.4 Neo4j Browser: a query workbench for Cypher and Neo4j'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 Neo4j 浏览器：Cypher 和 Neo4j 的查询工作台
- en: Neo4j Browser allows us to run Cypher queries against Neo4j and work with the
    results. Before digging into Neo4j Browser, let’s review the Cypher query language.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j 浏览器允许我们针对 Neo4j 运行 Cypher 查询并处理结果。在深入研究 Neo4j 浏览器之前，让我们回顾一下 Cypher 查询语言。
- en: 3.6 Cypher
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 Cypher
- en: Cypher is a declarative graph query language with some features that may be
    familiar from SQL. In fact, a good way to think of Cypher is as *SQL for graphs*.
    Cypher makes use of pattern matching, using an ASCII-art-like notation for describing
    graph patterns. In this section, we will take a look at some basic Cypher functionality
    for creating and querying data, including making use of predicates and aggregations.
    We will only cover a small part of the Cypher language; see the Cypher refcard
    [r.neo4j.com/refcard](https://neo4j.com/docs/cypher-refcard/current/) for a through
    reference, or consult the documentation at [neo4j.com/docs/cypher-manual/current/](https://neo4j.com/docs/cypher-manual/current/).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Cypher 是一种声明式图查询语言，具有一些可能来自 SQL 的特性。实际上，将 Cypher 视为 *图上的 SQL* 是一个很好的思考方式。Cypher
    利用模式匹配，使用类似 ASCII 艺术的符号来描述图模式。在本节中，我们将查看一些基本的 Cypher 功能，用于创建和查询数据，包括使用谓词和聚合。我们只涵盖
    Cypher 语言的一小部分；有关全面参考，请参阅 Cypher refcard [r.neo4j.com/refcard](https://neo4j.com/docs/cypher-refcard/current/)，或查阅
    [neo4j.com/docs/cypher-manual/current/](https://neo4j.com/docs/cypher-manual/current/)
    的文档。
- en: 3.6.1 Pattern matching
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.1 模式匹配
- en: As a declarative graph query language, pattern matching is a fundamental tool
    used in Cypher, both for creating and querying data. Instead of telling the database
    the exact operations we want it to take (an imperative approach), with Cypher,
    we describe the pattern we are looking for or want to create, and the database
    is responsible for determining the series of operations that satisfies the statement
    in the most efficient way possible. Describing graph patterns using an ASCII-art-like
    notation (also called motifs) is at the heart of this declarative functionality.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种声明式图查询语言，模式匹配是 Cypher 中用于创建和查询数据的基本工具。与告诉数据库我们希望它执行的确切操作（命令式方法）不同，使用 Cypher，我们描述我们正在寻找或想要创建的模式，数据库负责以最有效的方式确定满足该语句的操作序列。使用类似
    ASCII 艺术的符号（也称为模式）描述图模式是这种声明式功能的核心。
- en: Nodes
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 节点
- en: Nodes are defined within parentheses (). Optionally, we can specify node label(s),
    using a colon as a separator—for example, (:User).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 节点定义在括号 () 内。可选地，我们可以指定节点标签（使用冒号作为分隔符），例如，(:User)。
- en: Relationships
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 关系
- en: 'Relationships are defined within square brackets []. Optionally, we can specify
    type and direction: (:Review)-[:REVIEWS]->(:Business).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 关系定义在方括号 [] 内。可选地，我们可以指定类型和方向：(:Review)-[:REVIEWS]->(:Business)。
- en: 3.6.2 Properties
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.2 属性
- en: 'Properties are specified as comma-separated name: value pairs within braces
    ‘{}’, like the name of a business or user.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 属性被指定为花括号‘{}’内的逗号分隔的名称：值对，例如企业或用户的名称。
- en: Aliases
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 别名
- en: Graph elements can be bound to aliases or variables that can be referred to
    later on in the query. For example, given this pattern (r:Review)-[a:REVIEWS]->(b:Business),
    the alias r becomes a variable bound to the review node matched in the graph,
    a is bound to the REVIEWS relationship, and b is bound to the business node. These
    variables are only in scope for the Cypher query in which they are used. Follow
    along by running the following Cypher queries in the Neo4j browser as we introduce
    Cypher commands for creating and querying data that matches the data model we’ve
    built throughout this chapter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图元素可以绑定到别名或变量，这些别名或变量可以在查询的后续部分中引用。例如，给定此模式（r:Review）-[a:REVIEWS]->(b:Business)，别名
    r 被绑定到图中匹配的评论节点，a 被绑定到 REVIEWS 关系，b 被绑定到业务节点。这些变量仅在它们被使用的 Cypher 查询的范围内有效。随着我们介绍
    Cypher 命令来创建和查询数据，这些数据与我们在本章中构建的数据模型相匹配，请跟随以下 Cypher 查询在 Neo4j 浏览器中运行。
- en: 3.6.3 CREATE
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.3 CREATE
- en: 'The first thing we need to do is create some data in our database using the
    CREATE command. First, to create a single Business node in the graph, we start
    with the CREATE command followed by a graph pattern that describes the data to
    be created:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是使用 CREATE 命令在我们的数据库中创建一些数据。首先，为了在图中创建一个单独的业务节点，我们以 CREATE 命令开始，后跟一个描述要创建的数据的图模式：
- en: '[PRE0]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ The CREATE command is used to create data in the database.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ CREATE 命令用于在数据库中创建数据。
- en: ❷ b becomes an alias that can be used to refer to this node later in the query.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ b 成为一个别名，可以在查询的后续部分中引用此节点。
- en: ❸ Here we specify the label of the node we want to create.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们指定要创建的节点的标签。
- en: ❹ name is a property of the business node that specifies its value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 名称是业务节点的属性，用于指定其值。
- en: ❺ This is our graph pattern—in this case, it is a node identified by the parentheses.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 这是我们图模式——在这种情况下，它是一个由括号标识的节点。
- en: 'The result of running in Neo4j Browser shows the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Neo4j 浏览器中运行的结果显示以下内容：
- en: '[PRE1]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This means we’ve created one node with a new label in the database and set
    one node property value—in this case, the name property on a node with the label
    Business. Alternatively, we can use the SET command. The following is equivalent:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们在数据库中创建了一个带有新标签的节点，并设置了一个节点属性值——在这种情况下，是带有 Business 标签的节点的名称属性。或者，我们也可以使用
    SET 命令。以下内容是等效的：
- en: '[PRE2]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To visualize the data being created, we can add a RETURN clause to the Cypher
    statement, which will be rendered in Neo4j Browser as a graph visualization. Running
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化正在创建的数据，我们可以在 Cypher 语句中添加一个 RETURN 子句，它将在 Neo4j 浏览器中以图形可视化的形式呈现。运行
- en: '[PRE3]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: gives the visualization in Neo4j Browser shown in figure 3.5.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Neo4j 浏览器中显示的图形如图 3.5 所示。
- en: '![CH03_F05_Lyon](../../OEBPS/Images/CH03_F05_Lyon.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F05_Lyon](../../OEBPS/Images/CH03_F05_Lyon.png)'
- en: Figure 3.5 Creating a node with Cypher and Neo4j Browser
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 使用 Cypher 和 Neo4j 浏览器创建节点
- en: 'We can specify more complex patterns in the CREATE statement, such as relationships.
    Note the ASCII-art notation of defining a relationship using square brackets <-[]-,
    including the direction of the relationship (see figure 3.6):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 CREATE 语句中指定更复杂的模式，例如关系。注意使用方括号 <-[]- 定义关系的 ASCII 艺术表示法，包括关系的方向（见图 3.6）：
- en: '[PRE4]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![CH03_F06_Lyon](../../OEBPS/Images/CH03_F06_Lyon.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F06_Lyon](../../OEBPS/Images/CH03_F06_Lyon.png)'
- en: Figure 3.6 Creating two nodes and a relationship
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 创建两个节点和一个关系
- en: 'We can create arbitrarily complex graph patterns with Cypher. Here we also
    specify the user connected to the review in the CREATE statement (see figure 3.7):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Cypher 创建任意复杂的图模式。在这里，我们还在 CREATE 语句中指定了与评论相连的用户（见图 3.7）：
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![CH03_F07_Lyon](../../OEBPS/Images/CH03_F07_Lyon.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F07_Lyon](../../OEBPS/Images/CH03_F07_Lyon.png)'
- en: Figure 3.7 Creating a subgraph
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 创建子图
- en: Note that in this Cypher query we bind the entire graph pattern to a variable
    p and return that variable. In this case, p takes on the value of the entire path
    (a combination of nodes and relationships) being created.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个 Cypher 查询中，我们将整个图模式绑定到一个变量 p 并返回该变量。在这种情况下，p 获得了正在创建的整个路径（节点和关系的组合）的值。
- en: 'So far, we’ve only returned the data we’ve created in each Cypher statement.
    How do we query and visualize the rest of the data in the database? To do this,
    we use the MATCH keyword. Let’s match on all nodes in the database and return
    them:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只返回了每个Cypher语句中创建的数据。我们如何查询和可视化数据库中的其余数据？为了做到这一点，我们使用MATCH关键字。让我们匹配数据库中的所有节点并将它们返回：
- en: '[PRE6]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We should see a graph that looks something like figure 3.8.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到一个看起来像图3.8的图。
- en: '![CH03_F08_Lyon](../../OEBPS/Images/CH03_F08_Lyon.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F08_Lyon](../../OEBPS/Images/CH03_F08_Lyon.png)'
- en: Figure 3.8 Duplicate nodes were created
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8创建了重复节点
- en: 'Right away we can see that something is wrong; we’ve created lots of duplicate
    nodes in our graph! Let’s delete all data in the database:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻我们可以看到有问题；我们在图中创建了大量的重复节点！让我们删除数据库中的所有数据：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will match on all nodes and delete both the nodes and any relationships.
    We should see output that tells us what we’ve deleted:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配所有节点并删除节点及其任何关系。我们应该看到输出告诉我们我们删除了什么：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, let’s start over and see how to create data in the database without creating
    duplicates.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新开始，看看如何在不创建重复数据的情况下在数据库中创建数据。
- en: 3.6.4 MERGE
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.4 MERGE
- en: 'To avoid creating duplicates, we can use the MERGE command. MERGE acts as an
    upsert, only creating data specified in the pattern if it does not already exist
    in the database. When using MERGE, it is best to create a uniqueness constraint
    on the property that identifies uniqueness—often an ID field. By creating a uniqueness
    constraint, this will also create an index in the database. See the next section
    for an example of creating uniqueness constraints. For simple examples, it is
    fine to use MERGE without these constraints, so let’s revisit our Cypher statement
    that created a business, review, and user, but this time we will use MERGE:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免创建重复数据，我们可以使用MERGE命令。MERGE充当upsert，仅在数据已存在于数据库中时才创建模式中指定的数据。当使用MERGE时，最好在标识唯一性的属性上创建唯一性约束——通常是一个ID字段。通过创建唯一性约束，这也会在数据库中创建索引。请参阅下一节中创建唯一性约束的示例。对于简单的示例，在没有这些约束的情况下使用MERGE是可以的，所以让我们回顾一下创建业务、评论和用户的Cypher语句，但这次我们将使用MERGE：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Figure 3.9 shows the resulting graph visualization with the data we’ve created.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9显示了使用我们创建的数据生成的结果图可视化。
- en: '![CH03_F09_Lyon](../../OEBPS/Images/CH03_F09_Lyon.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![CH03_F09_Lyon](../../OEBPS/Images/CH03_F09_Lyon.png)'
- en: Figure 3.9 Using MERGE to create data
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![CH03_F09_Lyon](../../OEBPS/Images/CH03_F09_Lyon.png)'
- en: 'The results of this Cypher statement look identical to the previous version
    using CREATE; however, there is an important difference: this query is now *idempotent*.
    No matter how many times we run the query, we will not create duplicate nodes
    because we are using MERGE instead of CREATE. We will revisit MERGE again in the
    next chapter when we show how to create data in the database via our GraphQL API.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Cypher语句的结果看起来与使用CREATE的上一版本相同；然而，有一个重要的区别：这个查询现在是**幂等的**。无论我们运行查询多少次，我们都不会创建重复的节点，因为我们使用MERGE而不是CREATE。我们将在下一章再次回顾MERGE，届时我们将展示如何通过我们的GraphQL
    API在数据库中创建数据。
- en: Indexes in Neo4j
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j中的索引
- en: It’s important to understand how indexes are used in a graph database like Neo4j.
    We said earlier that Neo4j has a property called index-free adjacency, which means
    that traversing from a node to any other connected node does not require an index
    lookup. So how are indexes used in Neo4j? Indexes are used to find the starting
    point for a traversal only, unlike relational databases, which use an index to
    compute set (table) overlap, graph databases are simply computing offsets in the
    filestore, essentially chasing pointers, which we know computers are very good
    at doing quickly.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 理解在像Neo4j这样的图数据库中索引的使用方式很重要。我们之前提到Neo4j有一个名为index-free adjacency的属性，这意味着从一个节点遍历到任何其他连接的节点不需要索引查找。那么在Neo4j中索引是如何使用的呢？索引仅用于查找遍历的起点，与关系数据库不同，关系数据库使用索引来计算集合（表）重叠，图数据库只是在文件存储中计算偏移量，本质上是在追逐指针，我们知道计算机在快速执行这项任务时非常出色。
- en: 3.6.5 Defining database constraints with cypher
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.5 使用Cypher定义数据库约束
- en: We mentioned database constraints and how they relate to (optionally) defining
    a schema in Neo4j earlier in the chapter as we built up our data model. Next,
    we’ll look at the Cypher syntax for creating database constraints relevant to
    our data model.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构建数据模型时，在章节中提到了数据库约束以及它们如何与（可选地）定义Neo4j中的模式相关联。接下来，我们将查看创建与我们的数据模型相关的数据库约束的Cypher语法。
- en: Uniqueness constraint
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一性约束
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Property existence constraint
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 属性存在约束
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Node key constraint
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 节点键约束
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that if you still have duplicate data in the database that conflicts with
    any of these constraints, then you will receive an error message saying the constraint
    cannot be created. In that case, you may want to delete all data in the database,
    and then try creating the constraint again.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您数据库中仍然有与这些约束冲突的重复数据，那么您将收到一个错误消息，表明无法创建约束。在这种情况下，您可能想要删除数据库中的所有数据，然后再次尝试创建约束。
- en: 3.6.6 MATCH
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.6 MATCH
- en: 'Now that we’ve created our data in the graph, we can start to write queries
    to address some of the business requirements of our application. The MATCH clause
    is similar to CREATE in that it takes a graph pattern; however, we can also use
    a WHERE clause for specifying predicates to be applied in the pattern. A MATCH
    statement is used to find data in the database that matches a specified graph
    pattern. For example, here we search for all user nodes in the database:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在图中创建了我们的数据，我们可以开始编写查询来处理我们应用程序的一些业务需求。MATCH子句与CREATE类似，因为它接受一个图模式；然而，我们还可以使用WHERE子句来指定要在模式中应用的谓词。MATCH语句用于在数据库中查找与指定图模式匹配的数据。例如，这里我们搜索数据库中所有的用户节点：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can, of course, use more complex graph patterns in a MATCH clause:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以在MATCH子句中使用更复杂的图模式：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This query matches on all users who have written a review of any business. What
    if, instead, we only want to query for reviews of a certain business? In that
    case, we need to introduce predicates into our query, using a WHERE clause.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询匹配所有撰写过任何企业评论的用户。如果我们只想查询特定企业的评论呢？在这种情况下，我们需要在我们的查询中引入谓词，使用WHERE子句。
- en: WHERE
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: WHERE
- en: 'The WHERE clause can be used to add predicates to a MATCH statement. To search
    for a business named Bob’s Pizza, we could write the following Cypher statement:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: WHERE子句可以用于向MATCH语句添加谓词。为了搜索名为Bob’s Pizza的企业，我们可以编写以下Cypher语句：
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For equality comparisons, an equivalent shorthand notation is available:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于等价比较，有一个等效的简写符号可用：
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 3.6.7 Aggregations
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.7 聚合
- en: 'Often, we want to compute an aggregation across a set of results. For example,
    we may want to calculate the average rating of all the reviews of Bob’s Pizza.
    To do this, we make use of the avg aggregation function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常想要对一组结果进行聚合计算。例如，我们可能想要计算Bob’s Pizza所有评论的平均评分。为此，我们使用avg聚合函数：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, in Neo4j Browser, we are presented with a table showing the results of
    our query instead of a graph visualization because we are not returning graph
    data, but rather tabular data:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Neo4j浏览器中，我们看到的不是图可视化，而是一个表格，显示了我们的查询结果，因为我们不是返回图数据，而是表格数据：
- en: '![Lyon_ch03_table_01](../../OEBPS/Images/Lyon_ch03_table_01.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![Lyon_ch03_table_01](../../OEBPS/Images/Lyon_ch03_table_01.png)'
- en: 'What if we wanted to calculate the average rating of *each* business? In SQL,
    we might use a GROUP BY operator to group the reviews by business name and calculate
    the aggregation across each group, but there is no GROUP BY operator in Cypher.
    Instead, with Cypher there is an *implicit group by* operation applied when returning
    the results of an aggregation function along with non-aggregated results. For
    example, we do the following to compute the average rating of each business using
    Cypher:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要计算每个企业的平均评分呢？在SQL中，我们可能会使用GROUP BY运算符按企业名称对评论进行分组，并在每个组中计算聚合，但在Cypher中没有GROUP
    BY运算符。相反，在Cypher中，当返回聚合函数的结果以及非聚合结果时，会自动应用隐式分组操作。例如，我们执行以下操作来使用Cypher计算每个企业的平均评分：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The results table is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表如下：
- en: '![Lyon_ch03_table_02](../../OEBPS/Images/Lyon_ch03_table_02.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![Lyon_ch03_table_02](../../OEBPS/Images/Lyon_ch03_table_02.png)'
- en: Of course, this isn’t very exciting because we only have one business and one
    review. In the exercise section of this chapter, we will work with a larger dataset.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不令人兴奋，因为我们只有一个企业和一条评论。在本章的练习部分，我们将处理更大的数据集。
- en: 3.7 Using the Neo4j client drivers
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 使用Neo4j客户端驱动程序
- en: 'So far, we have been using Neo4j Browser to execute our Cypher queries, which
    is useful for ad-hoc analysis or prototyping; however, typically, we want to create
    an application that interacts with the database programmatically. To do this,
    we make use of the Neo4j client drivers. These client drivers are available in
    many languages, such as JavaScript, Java, Python, .NET, and Go, and they allow
    the developer to execute Cypher queries against a Neo4j instance with a consistent
    API that is idiomatic to the programming language being used. In chapter 1, we
    saw an example of using the Neo4j JavaScript driver to execute a Cypher query
    and work with the results. Refer to the driver and language guides for more information
    on Neo4j client drivers: [neo4j.com/developer/language-guides/](https://neo4j.com/developer/language-guides/).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用Neo4j浏览器来执行我们的Cypher查询，这对于即席分析或原型设计很有用；然而，通常我们希望创建一个以编程方式与数据库交互的应用程序。为此，我们使用Neo4j客户端驱动程序。这些客户端驱动程序在许多语言中可用，例如JavaScript、Java、Python、.NET和Go，并且允许开发者使用与编程语言一致的API对Neo4j实例执行Cypher查询。在第1章中，我们看到了使用Neo4j
    JavaScript驱动程序执行Cypher查询和处理结果的示例。有关Neo4j客户端驱动程序的更多信息，请参阅驱动程序和语言指南：[neo4j.com/developer/language-guides/](https://neo4j.com/developer/language-guides/)。
- en: In the next chapter, we will combine the concepts and tools we have discussed
    so far (GraphQL and Neo4j) by building a GraphQL API that uses Neo4j as the data
    layer. To do this, we will use the Neo4j GraphQL Library, which simplifies and
    accelerates the process of building GraphQL APIs backed by Neo4j.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过构建一个使用Neo4j作为数据层的GraphQL API来结合我们迄今为止讨论的概念和工具（GraphQL和Neo4j）。为此，我们将使用Neo4j
    GraphQL库，该库简化并加速了构建由Neo4j支持的GraphQL API的过程。
- en: 3.8 Exercises
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.8 练习
- en: 'To complete the following exercises, first run the following command in Neo4j
    Browser to load a browser guide with embedded Cypher queries: :play grandstack.
    This browser guide will walk you through the process of loading a larger, more
    complete sample dataset of businesses and reviews. After running the query to
    load the data in Neo4j, proceed to the following exercises:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成以下练习，首先在Neo4j浏览器中运行以下命令以加载一个包含嵌入式Cypher查询的浏览器指南：:play grandstack。这个浏览器指南将指导您加载更大、更完整的商家和评论样本数据集。在Neo4j中运行查询加载数据后，继续以下练习：
- en: Run the command CALL db.schema.visualization() to inspect the data model. What
    are the node labels used? What are the relationship types?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行命令CALL db.schema.visualization()来检查数据模型。使用了哪些节点标签？有哪些关系类型？
- en: Write a Cypher query to find all the users in the database. How many users are
    there? What are their names?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个Cypher查询以找到数据库中的所有用户。有多少用户？他们的名字是什么？
- en: Find all the reviews written by the user named Will. What is the average rating
    given by this user?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出用户名为Will所写的所有评论。这位用户给出的平均评分是多少？
- en: Find all the businesses reviewed by the user named Will. What is the most common
    category?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出用户名为Will的所有评论过的商家。最常见的类别是什么？
- en: Write a query to recommend businesses to the user named Will that he has not
    previously reviewed.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个查询，为用户名为Will的未评论过的商家推荐业务。
- en: 'You can find solutions to the exercises as well as code samples in the GitHub
    repository for this book: [github.com/johnymontana/fullstack-graphql-book](https://github.com/johnymontana/fullstack-graphql-book).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub仓库中找到练习的解决方案以及代码示例：[github.com/johnymontana/fullstack-graphql-book](https://github.com/johnymontana/fullstack-graphql-book)。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A graph database allows the user to model, store, and query data as a graph.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据库允许用户将数据建模、存储和查询为图。
- en: The property graph data model is used by graph databases and consists of node
    labels, relationships, and properties.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据库使用属性图数据模型，该模型由节点标签、关系和属性组成。
- en: The Cypher query language is a declarative graph query language focused around
    pattern matching and is used for querying graph databases, including Neo4j.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypher查询语言是一种以模式匹配为中心的声明式图查询语言，用于查询图数据库，包括Neo4j。
- en: Client drivers are used for building applications that interact with Neo4j.
    These drivers enable applications to send Cypher queries to the database and work
    with the results.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端驱动程序用于构建与Neo4j交互的应用程序。这些驱动程序使应用程序能够向数据库发送Cypher查询并处理结果。
