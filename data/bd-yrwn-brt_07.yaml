- en: 7 Joystick-controlled robots
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 摇杆控制机器人
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Reading joystick data using Pygame
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Pygame读取摇杆数据
- en: Reading and parsing raw joystick event data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和解析原始摇杆事件数据
- en: Measuring the rate of joystick events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量摇杆事件速率
- en: Creating a remote joystick robot controller
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建远程摇杆机器人控制器
- en: Joysticks are one of the most powerful input devices. When it comes to controlling
    robot motors, they offer much more superior control compared to keyboards and
    mice. The scenarios covered in this chapter will help you create a fully functional
    joystick-controlled robot. This chapter will teach you multiple ways of reading
    events from joystick hardware. We can then create our own event handlers that
    will perform different robot movements based on specific joystick movements. Along
    the way, we will also learn how to measure the number of joystick events triggered
    per second and optimize our code so that it prevents the robot motors from getting
    flooded with movement requests. Finally, we end the chapter by creating an application
    that moves the robot using a joystick over the network.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 摇杆是最强大的输入设备之一。当涉及到控制机器人电机时，它们相比键盘和鼠标提供了更优越的控制。本章涵盖的场景将帮助您创建一个功能齐全的摇杆控制机器人。本章将教授您多种从摇杆硬件读取事件的方法。然后我们可以创建自己的事件处理器，根据特定的摇杆动作执行不同的机器人运动。在这个过程中，我们还将学习如何测量每秒触发的摇杆事件数量，并优化我们的代码，以防止机器人电机被运动请求淹没。最后，我们通过创建一个通过网络使用摇杆移动机器人的应用程序来结束本章。
- en: Joystick-controlled robots have a wide array of applications, ranging from remotely
    operating heavy vehicles on factory floors to performing delicate medical procedures
    using robotic arms. In the case of robot-assisted surgery, by controlling very
    small robotic arms, the doctor can perform surgical procedures that would not
    be possible otherwise.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 摇杆控制的机器人具有广泛的应用，从在工厂车间远程操作重型车辆到使用机械臂进行精细的医学程序。在机器人辅助手术的情况下，通过控制非常小的机器人臂，医生可以执行其他情况下不可能进行的手术程序。
- en: 7.1 Hardware stack
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 硬件堆栈
- en: Figure 7.1 shows the hardware stack, with the specific components used in this
    chapter highlighted. The joystick hardware can be connected to the Raspberry Pi
    using either a wired USB or a wireless Bluetooth connection. The joystick can
    also be connected to a remote computer, and the robot movement requests will be
    transmitted over the network using either Wi-Fi or Ethernet.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1展示了硬件堆栈，其中本章使用的特定组件被突出显示。摇杆硬件可以通过有线USB或无线蓝牙连接连接到Raspberry Pi。摇杆还可以连接到远程计算机，并且机器人运动请求将通过网络使用Wi-Fi或以太网进行传输。
- en: '![](../Images/CH07_F01_Alsabbagh.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F01_Alsabbagh.png)'
- en: 'Figure 7.1 Hardware stack: the Joystick will be used to control the robot movements.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 硬件堆栈：摇杆将被用来控制机器人运动。
- en: The Joystick hardware to be used for this chapter is either the Sony PlayStation
    4/5 controller or an Xbox controller. Figure 7.2 shows a photo of a PlayStation
    4 controller, and figure 7.3 shows a photo of an Xbox controller. Make sure to
    check the hardware purchasing guide in appendix A before buying the hardware needed
    in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所使用的摇杆硬件可以是索尼PlayStation 4/5控制器或Xbox控制器。图7.2展示了一款PlayStation 4控制器的照片，图7.3展示了一款Xbox控制器的照片。在购买本章所需的硬件之前，请务必查阅附录A中的硬件购买指南。
- en: '![](../Images/CH07_F02_Alsabbagh.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F02_Alsabbagh.png)'
- en: 'Figure 7.2 PlayStation 4 controller: this controller is widely available and
    has good Linux support.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 PlayStation 4控制器：这款控制器广泛可用，并且对Linux有良好的支持。
- en: '![](../Images/CH07_F03_Alsabbagh.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F03_Alsabbagh.png)'
- en: 'Figure 7.3 Xbox controller: this controller is like the PlayStation controller,
    but it has two analog sticks.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 Xbox控制器：这款控制器与PlayStation控制器类似，但它有两个模拟摇杆。
- en: When connecting the controller to the Raspberry Pi over USB, all you need to
    do is connect the USB cable between the controller and the Raspberry Pi. No additional
    software or configuration is required. The Sony PlayStation controller supports
    a Bluetooth connection. To make use of it, you must first follow the instructions
    for your controller to put it into a pairing mode. Then you can search and pair
    the controller like any other Bluetooth device using the graphical Bluetooth application
    that comes with the Raspberry Pi OS. The final application in the chapter also
    supports connecting the controller to a remote Linux computer on the same network.
    On that computer, the same USB and Bluetooth options can be used.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过USB将控制器连接到树莓派时，您只需将USB线连接到控制器和树莓派之间。不需要额外的软件或配置。索尼PlayStation控制器支持蓝牙连接。要使用它，您必须首先按照控制器的说明将其置于配对模式。然后，您可以使用随树莓派操作系统一起提供的图形蓝牙应用程序搜索并配对控制器，就像配对任何其他蓝牙设备一样。本章的最后一个应用程序也支持将控制器连接到同一网络上的远程Linux计算机。在该计算机上，可以使用相同的USB和蓝牙选项。
- en: 7.2 Software stack
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 软件栈
- en: Details of the specific software used in this chapter are provided in figure
    7.4\. The first few applications will use the Pygame library, as it is a great
    starting point to work with joystick devices. Then, we will use the `struct` Python
    module to directly read and parse joystick events from the Linux input subsystem.
    The `sys` and `time` modules will be used when we create the `joystick_levels`
    application that measures the rate at which joystick events are generated. The
    Bluetooth hardware and associated Bluetooth Linux drivers will be used to create
    a wireless connection for the controller. The chapter ends with the `joystick_remote`
    application that controls the robot motors using the joystick hardware.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的特定软件的详细信息提供在图7.4中。前几个应用程序将使用Pygame库，因为它是与游戏杆设备一起工作的绝佳起点。然后，我们将使用`struct`
    Python模块直接从Linux输入子系统读取和解析游戏杆事件。当创建`joystick_levels`应用程序来测量游戏杆事件生成的速率时，将使用`sys`和`time`模块。蓝牙硬件及其相关的蓝牙Linux驱动程序将被用于为控制器创建无线连接。本章以`joystick_remote`应用程序结束，该应用程序使用游戏杆硬件控制机器人电机。
- en: '![](../Images/CH07_F04_Alsabbagh.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4](../Images/CH07_F04_Alsabbagh.png)'
- en: 'Figure 7.4 Software stack: the Linux input subsystem will be used to read joystick
    events.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 软件栈：将使用Linux输入子系统来读取游戏杆事件。
- en: 7.3 Joystick events
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 游戏杆事件
- en: Figure 7.5 shows the specific joystick events we are most interested in. There
    are many buttons and sticks on the controller, and each can send events to the
    connected computer when they are pressed or moved. For the applications in this
    chapter, we are most interested in the events related to the two analog sticks
    on the controller. There is one stick for the left and another for the right hand.
    We will control the robot’s movements by having the throttle on each motor set
    based on the position of the stick. If the right stick is pushed fully forward,
    the right motor will be given full throttle power in the forward direction. If
    the right stick is pulled all the way back, the right motor will be given full
    throttle power in the backward direction. The same will be done for the left stick
    and left motor. We will also set the throttle speed or level based on how far
    each stick is pushed forward or backward. In this way, you can use the joystick
    to control forward, backward, turn, and spin movements. You can also perform these
    movements at a slower or faster speed, depending on how far you push the sticks.
    When the sticks are moved, the stick axis and position are provided as an event.
    Each stick has the *y*- and *x*-axes. Changes in the vertical position of a stick
    relate to a *y*-axis event, and changes in the horizontal position of the stick
    relate to an *x*-axis event.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 展示了我们最感兴趣的特定摇杆事件。控制器上有很多按钮和摇杆，每个按钮和摇杆在被按下或移动时都可以向连接的计算机发送事件。对于本章中的应用程序，我们最感兴趣的是与控制器上两个模拟摇杆相关的事件。有一个摇杆用于左手，另一个用于右手。我们将通过根据摇杆的位置设置每个电机的节流来控制机器人的移动。如果右摇杆完全向前推，右电机将在前进方向上获得全功率。如果右摇杆完全向后拉，右电机将在后退方向上获得全功率。对于左摇杆和左电机，也将执行同样的操作。我们还将根据每个摇杆向前或向后推的程度来设置节流速度或级别。这样，你可以使用摇杆来控制前进、后退、转向和旋转动作。你还可以根据摇杆推的程度以较慢或较快的速度执行这些动作。当摇杆移动时，摇杆轴和位置将作为事件提供。每个摇杆都有
    *y* 和 *x* 轴。摇杆垂直位置的变化与 *y* 轴事件相关，摇杆水平位置的变化与 *x* 轴事件相关。
- en: '![](../Images/CH07_F05_Alsabbagh.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH07_F05_Alsabbagh.png)'
- en: 'Figure 7.5 Joystick events: the sticks generate y-axis events when moved up
    and down.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 摇杆事件：摇杆在上下移动时产生 y 轴事件。
- en: 7.4 Reading joystick events using Pygame
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 使用 Pygame 读取摇杆事件
- en: 'Pygame is a very popular Python module used for writing video games. It has
    built-in support for reading joystick events and is an excellent starting point
    for working with joysticks in Python. We need to create an application to meet
    the following requirements:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame 是一个非常流行的 Python 模块，用于编写视频游戏。它内置了对读取摇杆事件的支持，是使用 Python 处理摇杆的绝佳起点。我们需要创建一个满足以下要求的应用程序：
- en: It is necessary to create a Python application that uses the Pygame library
    to read joystick events.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有必要创建一个使用 Pygame 库读取摇杆事件的 Python 应用程序。
- en: We should create an event-handler function in the application that will get
    called every time there is a stick movement or button-press event.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该在应用程序中创建一个事件处理函数，每次有摇杆移动或按钮按下事件时都会调用该函数。
- en: 7.4.1 Detecting events in Pygame
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 在 Pygame 中检测事件
- en: 'This first program will have an event loop that reads all the events detected
    and prints them out. Once we have it in place, we can move on to the next section
    that will focus on joystick events. Run the following line to install the Pygame
    Python package in our virtual environment:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将有一个事件循环，读取所有检测到的事件并将它们打印出来。一旦我们设置好，我们就可以继续下一节，该节将专注于摇杆事件。运行以下行以在我们的虚拟环境中安装
    Pygame Python 包：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first part of our application will import the `pygame` module:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的第一部分将导入 `pygame` 模块：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we run the main event loop, we will need to set how frequently the loop
    will check for events. This rate is called the frame rate, and we set it in a
    variable called `FRAME_RATE`. It is set at 60 frames per second, which is a common
    value for creating a responsive application. If this value is too small, the application
    will not be very responsive, and if too high, it would put an unnecessary load
    on the computer without providing an improved user experience. Human beings cannot
    perceive frame rates beyond 60 frames per second. We save the window height and
    width in the variable called `WINDOW_SIZE`. The size of the window isn’t too important
    in our application because we won’t be drawing anything in the window:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行主事件循环时，我们需要设置循环检查事件的频率。这个频率被称为帧率，我们将其设置在一个名为 `FRAME_RATE` 的变量中。它被设置为每秒
    60 帧，这是创建响应性应用程序的常见值。如果这个值太小，应用程序将不会非常响应，如果太高，则会在不提供改进用户体验的情况下给计算机带来不必要的负担。人类无法感知每秒超过
    60 帧的帧率。我们将窗口的高度和宽度保存在名为 `WINDOW_SIZE` 的变量中。在我们的应用程序中，窗口的大小并不重要，因为我们不会在窗口中绘制任何内容：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We now define the function `main` that is at the heart of our program. We call
    the `pygame.init` function to initialize the Pygame module. Then, we create a
    window called `screen`. We then create a `Clock` object that will be used in our
    event loop to process events at the desired frame rate. The next block is the
    main event loop, which is run constantly until the application is exited. The
    subsequent available event is fetched by calling `pygame.event.get`. The details
    of this event are then printed. The type of event is checked to see whether it
    is a `pygame.QUIT` type of event. If so, the application is exited by calling
    `pygame.quit`, and then we return from the main function. Finally, the last line
    of the loop calls `clock.tick` with the configured frame rate:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在定义位于程序核心的 `main` 函数。我们调用 `pygame.init` 函数来初始化 Pygame 模块。然后，我们创建一个名为 `screen`
    的窗口。接着，我们创建一个 `Clock` 对象，该对象将在事件循环中使用，以在期望的帧率处理事件。下一个块是主事件循环，它将持续运行，直到应用程序退出。通过调用
    `pygame.event.get` 获取后续可用的事件。然后打印出该事件的详细信息。检查事件类型以确定它是否是 `pygame.QUIT` 类型的事件。如果是，通过调用
    `pygame.quit` 退出应用程序，然后从主函数返回。最后，循环的最后一行使用配置的帧率调用 `clock.tick`：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The last line of the application calls the `main` function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的最后一行调用 `main` 函数：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The full script can be saved as `pygame_events.py` on the Pi and then executed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 完整脚本可以保存为 `pygame_events.py` 在 Pi 上，然后执行。
- en: 'Listing 7.1 `pygame_events.py`: Using the Pygame library to print joystick
    events'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7.1 `pygame_events.py`: 使用 Pygame 库打印摇杆事件'
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The application requires a graphical environment to run as it creates windows.
    You can run it on the desktop environment on the Pi directly or remotely over
    a VNC session. The output is taken from a session of running the command. In the
    session that follows, the application was started, and the letter A was pressed
    down and released on the keyboard. The mouse was moved around the application,
    and then the window was closed. The keyboard, mouse, and window close events can
    be seen in the output as being detected:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序需要一个图形环境来运行，因为它会创建窗口。您可以直接在 Pi 的桌面环境中运行它，或者通过 VNC 会话远程运行。输出是从运行命令的会话中获取的。在下面的会话中，启动了应用程序，并在键盘上按下并释放了字母
    A。鼠标在应用程序周围移动，然后关闭了窗口。键盘、鼠标和窗口关闭事件可以在输出中看到，它们被检测到：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Going deeper: Frame rate'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解：帧率
- en: Frame rate is often measured in frames per second. It is a very important aspect
    of human interaction with computers. In this chapter, we focus on creating applications
    that read joystick events and react to them fast enough to create real-time applications.
    If our frame rate drops to a very low level, it will be visible to our robot operator.
    There will be a noticeable lag in our application reacting to our actions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 帧率通常以每秒帧数来衡量。它是人类与计算机交互的一个重要方面。在本章中，我们专注于创建读取摇杆事件并能快速响应以创建实时应用的应用程序。如果我们的帧率下降到一个非常低的水平，我们的机器人操作者会注意到。我们的应用程序在响应我们的动作时会有明显的延迟。
- en: Even though we have set the frame rate in the initial application to 60 frames
    per second, a lower frame rate of 30 frames per second is still popular and comfortable
    for many applications. In the coming chapters, the default frame capture rate
    of the Pi camera is 30 frames per second. Images displayed at this rate will appear
    as a smooth video feed. As we perform demanding tasks like face detection and
    frame rates drop to much lower levels, it will become very noticeable and disruptive.
    Thus, we will solve these problems as we encounter them through software optimization.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在初始应用程序中将帧率设置为每秒 60 帧，但每秒 30 帧的较低帧率对于许多应用程序来说仍然很受欢迎且舒适。在接下来的章节中，Pi 相机的默认帧捕获率为每秒
    30 帧。以这个速率显示的图像将看起来像流畅的视频流。当我们执行像人脸检测这样的要求较高的任务，帧率降低到非常低的水平时，这将会非常明显且具有破坏性。因此，我们将通过软件优化在遇到问题时解决这些问题。
- en: Whether we deal with video playback, joystick events, or any other highly interactive
    user application, it will often boil down to measuring the frame rates and making
    sure the software design maintains the target frame rate so that the user experience
    is not affected.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们处理视频播放、摇杆事件，还是任何其他高度交互式的用户应用程序，通常都会归结为测量帧率并确保软件设计保持目标帧率，以免用户体验受到影响。
- en: 7.4.2 Detecting joystick events
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 检测摇杆事件
- en: 'We can now add the capability to detect and handle joystick events to our application.
    The following two lines are added to the `main` function. The first line calls
    `Joystick` to set up the controller device object and saves it in the `joystick`
    variable. We then output the name of the joystick controller device:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将检测和处理摇杆事件的能力添加到我们的应用程序中。以下两行代码被添加到 `main` 函数中。第一行调用 `Joystick` 来设置控制器设备对象，并将其保存在
    `joystick` 变量中。然后我们输出摇杆控制器设备的名称：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'One line is added to our previous event loop to call the `handle_event` function
    each time we detect a new event:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的事件循环中添加了一行代码，以便每次检测到新事件时调用 `handle_event` 函数：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The event-handler function can now be defined. It will focus only on joystick
    events and print a different message when a button is pressed or when one of the
    sticks on the controller is moved around:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以定义事件处理函数。它将仅关注摇杆事件，并在按钮被按下或控制器上的某个摇杆被移动时打印不同的消息：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The full script can be saved as `pygame_joystick.py` on the Pi and then executed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为 Pi 上的 `pygame_joystick.py` 并执行。
- en: 'Listing 7.2 `pygame_joystick.py`: Detecting specific joystick events with Pygame'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2 `pygame_joystick.py`：使用 Pygame 检测特定的摇杆事件
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the session that follows, the application was started, four different buttons
    were pressed, and the stick was moved around to different positions. We can see
    that each button has a unique identifier, and the stick movements have details
    to identify the axis of movement and the position the stick was moved to:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的会话中，应用程序被启动，按下了四个不同的按钮，摇杆被移动到不同的位置。我们可以看到每个按钮都有一个唯一的标识符，摇杆的移动有详细信息来识别移动的轴和摇杆移动到的位置：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the following sections, we will learn how to read the event data in more
    detail.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将学习如何更详细地读取事件数据。
- en: 7.5 Reading Linux joystick events
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 读取 Linux 摇杆事件
- en: 'Using Pygame gave us a good introduction into interacting with joystick events
    in Python and creating a graphical application, which we will be doing more in
    the coming chapters. However, it is a library focused more on creating video games,
    so it is not perfectly suitable for our needs. Luckily, on Linux, there is very
    good support for joystick devices, and their event data can be directly read by
    Python applications. The benefit of doing this is that we can avoid the overhead
    and complexity of running a whole video game engine and can instead focus purely
    on the task at hand of reading joystick events. We will parse the joystick event
    data and focus on handling joystick events on the *y*-axis, which are the stick
    movements we are most interested in for our robot application. We need to create
    an application to meet the following requirements:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Pygame 让我们了解了如何在 Python 中与摇杆事件交互以及创建图形应用程序，我们将在接下来的章节中做更多这方面的内容。然而，这个库更专注于创建视频游戏，所以它并不完全适合我们的需求。幸运的是，在
    Linux 上，对摇杆设备有非常好的支持，Python 应用程序可以直接读取它们的事件数据。这样做的好处是我们可以避免运行整个视频游戏引擎的开销和复杂性，而可以专注于当前的任务，即读取摇杆事件。我们将解析摇杆事件数据，并专注于处理
    *y*-轴上的摇杆事件，这是我们机器人应用程序中最感兴趣的事件。我们需要创建一个满足以下要求的应用程序：
- en: The Python application should directly read Linux joystick events.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 应用程序应直接读取 Linux 摇杆事件。
- en: It should differentiate whether the event was a button-press or a stick movement
    event.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该区分事件是按钮按下还是摇杆移动事件。
- en: It should filter axis events to handle only *y-*axis events on both sticks.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该过滤轴事件，只处理两个摇杆上的 *y-* 轴事件。
- en: It should be able to calculate the direction and percentage of movement on the
    *y*-axis.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该能够计算 *y*-轴上的移动方向和百分比。
- en: 7.5.1 Exploring the Linux input subsystem
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.1 探索 Linux 输入子系统
- en: 'To read the joystick event data, we first need to explore the Linux input subsystem.
    The documentation ([https://www.kernel.org/doc/html/latest/input/](https://www.kernel.org/doc/html/latest/input/))
    is very comprehensive and will be the basis for our exploration and implementation.
    Everything we are interested in is covered in the “Linux joystick support” chapter.
    From the documentation, we can see that each connected joystick is exposed as
    a device file on the filesystem. This is a common approach on Unix systems. The
    joystick devices are automatically created when joysticks are connected, and a
    common naming convention is followed. This makes it easy to list them. The following
    terminal session shows how we can list the joystick devices on a system:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取摇杆事件数据，我们首先需要探索 Linux 输入子系统。文档([https://www.kernel.org/doc/html/latest/input/](https://www.kernel.org/doc/html/latest/input/))非常全面，并将成为我们探索和实施的基础。我们感兴趣的所有内容都在“Linux
    摇杆支持”章节中。从文档中，我们可以看到每个连接的摇杆在文件系统中都暴露为一个设备文件。这是 Unix 系统中的一种常见方法。当摇杆连接时，摇杆设备会自动创建，并遵循一个常见的命名约定。这使得列出它们变得容易。以下终端会话显示了如何列出系统上的摇杆设备：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'From the output, we can see that one joystick is connected. If additional joysticks
    were connected, they would be called `/dev/input/js1` and `/dev/input/js2`. The
    documentation also covers the `jstest` command that can be used to connect to
    the joystick in the terminal and see details of the generated joystick events.
    Run the following line to install the command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到连接了一个摇杆。如果有额外的摇杆连接，它们将被命名为 `/dev/input/js1` 和 `/dev/input/js2`。文档还涵盖了
    `jstest` 命令，该命令可用于在终端连接到摇杆并查看生成的摇杆事件详情。运行以下行来安装该命令：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now run `jstest` to obtain a live view of the joystick events in our
    terminal:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行 `jstest` 来在我们的终端中获得摇杆事件的实时视图：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'From the output, we can see the different buttons and axes that have been detected.
    We can see that all the buttons are off because none of them are pressed. Each
    button has a specific number used to identify it. The value of each button is
    either on or off. If we press and hold down the cross button on a PlayStation
    controller, we get the following output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到检测到的不同按钮和轴。我们可以看到所有按钮都是关闭的，因为它们都没有被按下。每个按钮都有一个特定的编号用于识别它。每个按钮的值要么是开启要么是关闭。如果我们按住
    PlayStation 控制器的十字按钮，我们将得到以下输出：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can see that the button number `0` is on, which means the cross button is
    mapped to this button. If we now press the circle button, we will get the following
    output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到按钮编号 `0` 是开启的，这意味着十字按钮被映射到这个按钮。如果我们现在按下圆形按钮，我们将得到以下输出：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The output indicates the circle button is mapped to button number `1`. If we
    continue this process, it will show that the triangle button is mapped to button
    number `2`, and the square button is mapped to button number `3`. We can make
    note of these mappings and use them in our application to map the button numbers
    to button labels. If you are using an Xbox controller, you can follow the same
    procedure for the A, B, X, and Y buttons.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出指示圆形按钮被映射到按钮编号 `1`。如果我们继续这个过程，它将显示三角形按钮被映射到按钮编号 `2`，正方形按钮被映射到按钮编号 `3`。我们可以记录这些映射并在我们的应用程序中使用它们将按钮编号映射到按钮标签。如果你使用的是
    Xbox 控制器，你可以遵循相同的程序来处理 A、B、X 和 Y 按钮。
- en: 'Next, let’s explore the axes values. When nothing is pressed, we get the following
    values:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索轴值。当没有任何按键被按下时，我们得到以下值：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'From the documentation, we can see that when the stick is in the center position,
    the value of the axis is `0`. When the stick is pushed to the furthest direction
    along a specific axis, the value is `32767`, and when put in the opposite direction,
    it becomes `-32767`. Other positions of the stick will be represented between
    these values, depending on how far the stick is from the center. We can see from
    the output that two axes have a value of `-32767`, even though we are not moving
    the stick. The reason for this is that these two axes are mapped to the trigger
    buttons on the controller, which have hardware that can detect to what extent
    the button has been pressed, unlike the other buttons on the joystick. We don’t
    need to use the triggers for our robot application, so we can ignore them. If
    we push the right stick to the most forward position, we get the following output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从文档中，我们可以看到当摇杆处于中心位置时，轴的值为 `0`。当摇杆沿特定轴推到最远方向时，值为 `32767`，而当它放在相反方向时，它变为 `-32767`。摇杆的其他位置将表示在这些值之间，具体取决于摇杆离中心有多远。我们可以从输出中看到，有两个轴的值为
    `-32767`，即使我们没有移动摇杆。原因是这两个轴被映射到控制器上的触发按钮，这些按钮具有可以检测按钮被按下程度的硬件，而摇杆上的其他按钮则没有。对于我们的机器人应用程序，我们不需要使用触发器，因此我们可以忽略它们。如果我们把右侧摇杆推到最前面的位置，我们会得到以下输出：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can see that the *y*-axis for the right stick is mapped to axis number `4,`
    which has the value `-32767`. This means the forward position in the *y*-axis
    is mapped to the value `-32767`. Let us now move the right stick to the furthest
    position backward and see the results:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到右侧摇杆的 `y` 轴映射到轴号 `4`，其值为 `-32767`。这意味着 `y` 轴的前进位置映射到 `-32767` 的值。现在，让我们将右侧摇杆移动到最远位置向后，并查看结果：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The same axis now has the value `32767`. The backward position is mapped to
    the value `32767`. By doing the same process for the *x*-axis on the right stick,
    we see it is mapped to axis number `3`. Similarly, we can discover that the left
    stick *x*-axis is mapped to axis number `0`, and the *y*-axis is mapped to axis
    number `1`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在相同的轴具有 `32767` 的值。向后位置映射到 `32767` 的值。通过为右侧摇杆的 `x` 轴执行相同的处理过程，我们看到它映射到轴号 `3`。同样，我们可以发现左侧摇杆的
    `x` 轴映射到轴号 `0`，而 `y` 轴映射到轴号 `1`。
- en: 'The documentation has an excellent section called “Programming interface” that
    will give us everything we need to write our application. The general approach
    will be to open the joystick device file in the binary mode and read a fixed length
    of bytes from the device file. Each chunk of data we read is a single joystick
    event. The structure of the binary data we are reading is in the following format:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 文档有一个名为“编程接口”的优秀部分，它将为我们提供编写应用程序所需的一切。一般方法将是以二进制模式打开摇杆设备文件，并从设备文件中读取固定长度的字节。我们读取的每个数据块都是一个单独的摇杆事件。我们正在读取的二元数据的结构如下：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Python has a built-in module to read binary data in the C language `struct`
    format and convert it to its related Python value. At this stage, we just need
    to make note of the data types and their meanings. The first value is a time stamp
    that we won’t need. Then, `value` will have the same button and axis values we
    saw using the `jstest` command. By inspecting `type`, we can tell whether the
    event is a button or an axis event. The documentation states that for the `type`
    variable, button events will have a value of `1` and axis events will have a value
    of `2`. Finally, `number` indicates which button or axis the event is for in the
    same way we saw for the `jstest` output. Now, we have all the required information
    to put together our implementation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Python 内置了一个模块，用于以 C 语言 `struct` 格式读取二进制数据并将其转换为相关的 Python 值。在这个阶段，我们只需要注意数据类型及其含义。第一个值是一个时间戳，我们不需要它。然后，`value`
    将具有与使用 `jstest` 命令看到的相同的按钮和轴值。通过检查 `type`，我们可以判断事件是按钮事件还是轴事件。文档中说明，对于 `type` 变量，按钮事件将具有
    `1` 的值，而轴事件将具有 `2` 的值。最后，`number` 表示事件针对的是哪个按钮或轴，这与我们在 `jstest` 输出中看到的方式相同。现在，我们已经拥有了所有必需的信息来组合我们的实现。
- en: 7.5.2 Unpacking joystick events
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.2 解包摇杆事件
- en: 'This script will have the core logic of reading joystick events from the Linux
    input subsystem and converting the event data to Python. We will import the `struct`
    module that is part of the Python standard library. This module provides the functionality
    to convert C structs data to Python values:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将包含从 Linux 输入子系统读取摇杆事件并将事件数据转换为 Python 的核心逻辑。我们将导入 Python 标准库中的 `struct`
    模块。此模块提供了将 C 结构数据转换为 Python 值的功能：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We then save the path to the joystick device file in a variable called `DEVICE`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将摇杆设备文件的路径保存在一个名为`DEVICE`的变量中：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We now define the function `main`, which first creates a `Struct` object and
    saves it in the `event_struct` variable. The Python documentation for the `struct`
    module shows how to map different C data types. The first value is a `u32`, which
    is an unsigned integer of the 32-bit length, and so it maps to `I`. The next value
    is a `__s16`, which is a 16-bit integer and thus maps to `h`. Finally, the last
    two values are both `u8`, which is an 8-bit integer and thus maps to `B`. This
    makes the `Struct` object created with the format `''I h B B.''` We now open the
    device file with the mode `''rb''` so that the file can be opened for reading
    in the binary mode. We then enter into a `while` loop that continuously reads
    event data from the device file. Next, we read the `event_struct.size` number
    of bytes from the file and save it into the `bytes` variable. This value is the
    exact size of the C `structs` data in bytes. By reading this exact size, we are
    reading a single joystick event in each loop. Next, we use the `unpack` method
    to convert the data in bytes to a set of Python values that are saved in `data`.
    Then, we save each part of the event data into individual variables. Finally,
    we print out `value` and `number` when a button press event is detected, which
    correlates to `type` being `1`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义函数`main`，它首先创建一个`Struct`对象，并将其保存在`event_struct`变量中。Python文档中的`struct`模块展示了如何映射不同的C数据类型。第一个值是`u32`，它是一个32位长度的无符号整数，因此映射到`I`。下一个值是`__s16`，它是一个16位整数，因此映射到`h`。最后，最后两个值都是`u8`，它是一个8位整数，因此映射到`B`。这使得创建的`Struct`对象格式为`'I
    h B B.'`。我们现在以模式`'rb'`打开设备文件，以便以二进制模式打开文件进行读取。然后我们进入一个`while`循环，该循环持续从设备文件中读取事件数据。接下来，我们从文件中读取`event_struct.size`个字节，并将其保存到`bytes`变量中。此值是C
    `structs`数据的确切字节数。通过读取这个确切的大小，我们在每个循环中读取一个摇杆事件。接下来，我们使用`unpack`方法将字节数据转换为Python值集合，并将其保存到`data`中。然后，我们将事件数据的每个部分保存到单独的变量中。最后，当检测到按钮按下事件时，我们打印出`value`和`number`，这对应于`type`为`1`：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The last line of the application calls the `main` function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的最后一行调用`main`函数：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The full script can be saved as `joystick_unpack.py` on the Pi and then executed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为`joystick_unpack.py`在Pi上，然后执行。
- en: 'Listing 7.3 `joystick_unpack.py`: Unpacking raw joystick events on Linux'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3 `joystick_unpack.py`：在Linux上解包原始摇杆事件
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output shows a session where the script was run and then the cross and
    circle button were pressed. The first two lines of output relate to the cross
    button that has `number:0` as its button number. We can see that the `value` for
    the button changes from `1` to `0` as it is pressed and then released. The last
    two lines show the same, except with `number:1`, which indicates the circle button
    being pressed and released:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了脚本运行会话，然后按下了十字和圆形按钮。输出的前两行与十字按钮相关，其按钮编号为`number:0`。我们可以看到，按钮的`value`值在按下和释放时从`1`变为`0`。最后两行显示相同的情况，但按钮编号为`number:1`，这表明圆形按钮被按下和释放：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 7.5.3 Mapping joystick events
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.3 映射摇杆事件
- en: The next step is mapping the values in the events to more readable names for
    the buttons and axes, as well as the event types. This will make our code more
    readable and provide us with the ability to produce more readable output in the
    terminal. We will also create a dedicated function that will be called to handle
    joystick events as we receive them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将事件中的值映射到更易读的按钮和轴的名称以及事件类型。这将使我们的代码更易读，并为我们提供在终端中生成更易读输出的能力。我们还将创建一个专用函数，该函数将在接收摇杆事件时被调用。
- en: 'We will import the `namedtuple` object from the `collections` module, which
    is part of the Python standard library. This object provides a great way to convert
    a Python `tuple` object to a more readable `namedtuple`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入`collections`模块中的`namedtuple`对象，它是Python标准库的一部分。此对象提供了一种将Python `tuple`对象转换为更易读的`namedtuple`的绝佳方式：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We save the values for button and axis type events in `TYPE_BUTTON` and `TYPE_AXIS`.
    We use a dictionary to map the name of each button in the `BUTTON` variable. The
    first version of `BUTTON` has the mapping for the PlayStation controller, while
    the second commented-out version has the mapping for the Xbox controller. You
    can use either one as needed. Then, we create a dictionary called `AXIS` to obtain
    the name of an axis for axis events:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `TYPE_BUTTON` 和 `TYPE_AXIS` 中保存按钮和轴类型事件的值。我们使用字典将 `BUTTON` 变量中每个按钮的名称进行映射。`BUTTON`
    的第一个版本是对 PlayStation 控制器的映射，而第二个注释掉的版本是对 Xbox 控制器的映射。根据需要，您可以使用任何一个。然后，我们创建一个名为
    `AXIS` 的字典，以获取轴事件的轴名称：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A `namedtuple` called `Event` is created, and it will be used to save event
    data in a more readable data structure:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个名为 `Event` 的 `namedtuple`，它将被用来以更可读的数据结构保存事件数据：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `main` function is largely the same as the previous script. The main difference
    is that an `Event` object is created for each new event, and then the `handle_event`
    function is called with this object:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数基本上与上一个脚本相同。主要区别是，为每个新事件创建一个 `Event` 对象，然后使用此对象调用 `handle_event` 函数：'
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When the `handle_event` function encounters a button event, it will look up
    the name of the button using the `BUTTON` dictionary. We use the `get` method
    so that if a button we haven’t defined is pressed, it doesn’t cause an error;
    instead, the `None` value is returned. In this way, we can define the names of
    buttons we care most about. We then output to the terminal that a button event
    was encountered and provide the button name and dump of the `event` variable.
    When an axis event is detected, the name of the axis is retrieved, and similar
    details of the axis name and `event` variable are outputted:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `handle_event` 函数遇到按钮事件时，它将使用 `BUTTON` 字典查找按钮的名称。我们使用 `get` 方法，这样如果按下了我们未定义的按钮，就不会导致错误；相反，返回
    `None` 值。这样，我们可以定义我们最关心的按钮名称。然后，我们将输出到终端，表示遇到了按钮事件，并提供按钮名称和 `event` 变量的转储。当检测到轴事件时，会检索轴的名称，并输出轴名称和
    `event` 变量的类似详细信息：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The full script can be saved as `joystick_map.py` on the Pi and then executed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 完整脚本可以保存为 `joystick_map.py` 在 Pi 上，然后执行。
- en: 'Listing 7.4 `joystick_map.py`: Map joystick events to button and axis names'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 `joystick_map.py`：将摇杆事件映射到按钮和轴名称
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following session shows the output when the cross and circle buttons are
    pressed. Then, the right stick is moved along the *y*- and the *x*-axes. Finally,
    the left stick is moved again on both the axes:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下会话显示了按下十字和圆形按钮时的输出。然后，右摇杆沿 *y* 轴和 *x* 轴移动。最后，左摇杆在两个轴上再次移动：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 7.5.4 Working with axis events
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.4 与轴事件一起工作
- en: 'We can now delve more deeply into the axis events and calculate the direction
    and how far the stick was moved. For controlling the robot, we only care about
    the stick moving on the *y*-axis, so we will only focus on the events on that
    axis. The `MAX_VAL` variable can be used so that we can compare the stick position
    to the maximum possible value to calculate the percentage of movement:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更深入地研究轴事件，并计算方向以及摇杆移动的距离。对于控制机器人，我们只关心摇杆在 *y* 轴上的移动，因此我们只会关注该轴上的事件。可以使用
    `MAX_VAL` 变量，这样我们就可以将摇杆位置与最大可能值进行比较，以计算移动的百分比：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `handle_event` function has been changed to only focus on axis events.
    Once the name of the axis is obtained, it is checked to make sure that it is either
    `left_y` or `right_y`. In this way, only *y*-axis events are processed. The `direction`
    variable will keep track of whether the stick is being pushed forward or backward.
    This value is calculated based on whether `event.value` is negative or positive.
    The absolute value of `event.value` is taken and divided by `MAX_VAL` to calculate
    the fractional position of the stick away from center. This value is multiplied
    by a hundred and rounded to two decimal points to express it as a percentage.
    These three variables are then outputted to the terminal:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle_event` 函数已被修改，仅关注轴事件。一旦获得轴的名称，就会检查它是否为 `left_y` 或 `right_y`。这样，只处理
    *y* 轴事件。`direction` 变量将跟踪摇杆是向前推还是向后推。此值基于 `event.value` 是正数还是负数来计算。取 `event.value`
    的绝对值，并将其除以 `MAX_VAL` 来计算摇杆远离中心的分数位置。此值乘以一百并四舍五入到两位小数，以百分比的形式表示。然后，这三个变量被输出到终端：'
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The full script can be saved as `joystick_axis.py` on the Pi and then executed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 完整脚本可以保存为 `joystick_axis.py` 在 Pi 上，然后执行。
- en: 'Listing 7.5 `joystick_axis.py`: Controlling direction and movement percentage'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5 `joystick_axis.py`：控制方向和移动百分比
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following session shows the output generated during script execution when
    the right stick is moved forward to the fullest position and then back to center.
    The right stick is then moved backward a bit and back to center. Finally, the
    left stick is also moved forward and backward:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下会话显示了当右摇杆向前移动到最满位置然后回到中心，然后再向后移动一点并回到中心时，在脚本执行过程中生成的输出。最后，左摇杆也被向前和向后移动：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 7.6 Measuring the rate of joystick events
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 测量摇杆事件率
- en: The sensors on the analog sticks are extremely sensitive and can detect hundreds
    of different positions. Such sensitivity generates a very high rate of joystick
    events per second. We want to be mindful of this, as it could flood our robot
    with requests to change the throttle on the motors even for very small changes
    in stick positions. In the `motor` module, we have included three levels of speed.
    We can apply a similar approach to solve our joystick problem by calculating three
    levels of joystick position for each direction and only requesting a robot movement
    when one of these levels has changed. Each of the levels will be directly correlated
    with a speed level.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟摇杆上的传感器极其灵敏，可以检测到数百种不同的位置。这种灵敏度会产生每秒非常高的摇杆事件率。我们需要注意这一点，因为它可能会让我们的机器人接收到大量请求来改变电机节流，即使摇杆位置只有微小的变化。在`motor`模块中，我们包含了三个速度等级。我们可以采用类似的方法来解决我们的摇杆问题，通过计算每个方向的三个摇杆位置等级，并且只有在这些等级中的一个发生变化时才请求机器人移动。每个等级将直接与一个速度等级相关联。
- en: Another common solution used with joysticks is creating a configurable joystick
    dead zone. This dead zone is how far the stick needs to be moved from the neutral
    position before the application will treat it as a movement.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与摇杆一起使用的另一种常见解决方案是创建一个可配置的摇杆死区。这个死区是指摇杆需要从中性位置移动多远，应用程序才会将其视为运动。
- en: 'We will write a script to measure and report how many axis events are generated
    per second so that we can quantify the problem. Then, we will enhance the script
    to calculate changes on three defined levels and the rate at which the levels
    change. With these measurements, we will have data to conclude whether this solution
    solves the problem. The script will focus only on the *y*-axis on a single stick
    to make implementation and measurement simpler. The application will need to meet
    the following requirements:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个脚本来测量和报告每秒生成的轴事件数量，以便我们可以量化这个问题。然后，我们将增强脚本以计算三个定义好的等级的变化以及等级变化的速率。有了这些测量数据，我们将有数据来得出这个解决方案是否解决问题的结论。脚本将仅关注单个摇杆的*y*轴，以简化实现和测量。应用程序需要满足以下要求：
- en: A Python application should read 100 axis events and record the time taken.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python应用程序应读取100个轴事件并记录所花费的时间。
- en: The event rate should be calculated as new events per second.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件率应计算为新事件每秒的数量。
- en: The level rate should be calculated as new levels per second.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等级率应计算为新等级每秒的数量。
- en: Only axis movements on the right-stick *y*-axis should be recorded.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应仅记录右摇杆*y*轴上的轴运动。
- en: 7.6.1 Calculating the event rate
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.1 计算事件率
- en: 'The initial task at hand will be to calculate the number of new axis events
    per second. The script will build on the work from the script in the previous
    section. We will import the `sys` module so that we can exit the script when all
    measurements have been taken. The `time` module is imported to measure the time.
    The `SimpleNamespace` object is imported from the `types` module and will be used
    to keep track of our statistical data:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当前手头的首要任务将是计算每秒新轴事件的数量。脚本将基于上一节中的脚本进行构建。我们将导入`sys`模块，以便在所有测量完成后退出脚本。导入`time`模块以测量时间。从`types`模块导入`SimpleNamespace`对象，并将用于跟踪我们的统计数据：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `main` function is very similar to what we have seen in the previous script,
    with some small additions. The `data` variable will keep track of the number of
    events encountered so far and the start time of the first event:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数与我们之前看到的脚本非常相似，有一些小的添加。`data`变量将跟踪迄今为止遇到的事件数量以及第一个事件的开始时间：'
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `handle_event` will check for any *y*-axis events on the right stick. Each
    time it detects one, it will call the `update_counter` function so that it can
    update the counter statistics:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle_event`将检查右摇杆上的任何*y*轴事件。每次检测到事件时，它将调用`update_counter`函数，以便更新计数器统计信息：'
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `update_counter` function increments the `data.events` counter variable
    to record the new event. The number of counted events is then outputted. If this
    is the first event encountered, then the starting time of the sample is saved
    in the `data.start` variable. If a hundred samples have been collected, then the
    `stop_ counter` function is called to end measurement and report the results:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_counter` 函数将 `data.events` 计数器变量增加以记录新事件。然后输出计数事件的数目。如果这是遇到的第一事件，则将样本的起始时间保存在
    `data.start` 变量中。如果收集了一百个样本，则调用 `stop_counter` 函数结束测量并报告结果：'
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `stop_counter` function first calculates how much time has elapsed while
    counting the new events and saving the results in `duration`. Then, the number
    of new events per second is calculated and saved in `event_rate`. Finally, the
    time taken, total number of events, and event rate are printed, and the script
    is exited:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop_counter` 函数首先计算在计数新事件并保存结果到 `duration` 中的时间。然后，计算每秒新事件的数量并保存在 `event_rate`
    中。最后，打印所用时间、总事件数和事件速率，并退出脚本：'
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The full script can be saved as `joystick_stats.py` on the Pi and then executed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为 `joystick_stats.py` 在 Pi 上，然后执行。
- en: 'Listing 7.6 `joystick_stats.py`: Collecting and reporting joystick statistics'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7.6 `joystick_stats.py`: 收集和报告摇杆统计数据'
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When you execute the script, take the right stick and continually push it forward
    and backward until 100 events have been detected. Then, the script will exit and
    print the measurement results. The session shows the results of axis measurements
    that were taken. As expected, the number of events per second is quite high for
    our purposes and could pose a challenge for our robot motor server to keep up
    with if we send a throttle request for every stick movement:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行脚本时，用右摇杆不断向前和向后推，直到检测到 100 个事件。然后，脚本将退出并打印测量结果。会话显示了所进行的轴测量结果。正如预期的那样，每秒事件数对我们来说相当高，如果我们为每次摇杆运动发送一个油门请求，可能会对我们的机器人电机服务器构成挑战：
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 7.6.2 Calculating the level rate
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.2 计算层级速率
- en: We can now enhance our script to calculate the three different levels of the
    stick position for each direction of movement along the *y*-axis. Then, we can
    calculate the number of new levels per second.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以增强我们的脚本，以计算沿 *y* 轴每个运动方向的摇杆位置的不同层级。然后，我们可以计算每秒新层级的数量。
- en: 'The `data` variable has some additional attributes to keep track of the number
    of new levels and the last level that was encountered. The rest of the function
    is unchanged:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` 变量有一些额外的属性来跟踪新层级的数量和遇到的最后一个层级。函数的其余部分保持不变：'
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `handle_event` function will calculate the level by taking the distance
    the stick has moved from the center and dividing it by three. This value is then
    saved in the `level` variable and given to the `update_counter` function when
    called:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle_event` 函数将通过将摇杆从中心移动的距离除以三来计算层级。然后将此值保存在 `level` 变量中，并在调用时将其传递给 `update_counter`
    函数：'
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `update_counter` function will now also increment `data.levels` every time
    a new level is encountered. On each call, the event and level counts are printed.
    The rest of the logic in the function remains the same:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`update_counter` 函数现在每次遇到新层级时也会增加 `data.levels`。在每次调用中，打印事件和层级计数。函数中的其余逻辑保持不变：'
- en: '[PRE47]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `stop_counter` function will now also calculate the level rate and output
    the rate and total number of new levels encountered:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop_counter` 函数现在也会计算层级速率并输出速率和遇到的新层级总数：'
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The full script can be saved as `joystick_levels.py` on the Pi and then executed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为 `joystick_levels.py` 在 Pi 上，然后执行。
- en: 'Listing 7.7 `joystick_levels.py`: Applying levels to joystick movements'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7.7 `joystick_levels.py`: 将层级应用于摇杆运动'
- en: '[PRE49]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can now execute the new script and move the right stick again until 100
    events have been detected. The session shows the results of event measurements
    that were taken again with level measurements being calculated this time. We can
    see from the results that the level rate of 10.3 is 14 times lower than the event
    rate of 146.6\. By only sending robot movement requests when levels have changed
    instead of on every event, we can make very significant improvements on the request
    load on our robot motor server. With this performance enhancement, we still support
    all the three motor speed levels and will be able to provide a responsive experience
    for using the joystick across the network to move the robot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以执行新的脚本，再次移动右侧操纵杆，直到检测到100个事件。会话显示了再次进行事件测量和这次计算水平测量的结果。我们可以从结果中看到，10.3的水平速率是146.6事件速率的14倍低。通过仅在水平发生变化时而不是在每次事件上发送机器人移动请求，我们可以在机器人电机服务器上的请求负载上做出非常显著的改进。通过这种性能提升，我们仍然支持所有三个电机速度级别，并将能够通过网络提供对操纵杆的响应式体验来移动机器人：
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 7.7 Moving robots with joysticks
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7 使用操纵杆移动机器人
- en: 'We now have what we need to connect our joystick to our robot. The task at
    hand is to create an application that will meet the following requirements:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了将操纵杆连接到机器人的所需工具。当前的任务是创建一个满足以下要求的应用程序：
- en: We should create a Python application that moves the right motor forward and
    backward when the right stick moves forward and backward.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该创建一个Python应用程序，当右侧操纵杆向前和向后移动时，使右侧电机向前和向后移动。
- en: The left motor should be moved based on left-stick movements in the same fashion.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧电机应根据左侧操纵杆的移动进行相应的移动。
- en: The joystick application should send the movement requests over HTTP to the
    robot server running the `robows` server.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操纵杆应用程序应通过HTTP将移动请求发送到运行`robows`服务器的机器人服务器。
- en: 7.7.1 Creating the joystick client
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.1 创建操纵杆客户端
- en: 'All the logic to send movement requests to the `robows` server is taken from
    `client_persist.py` in listing 5.6\. The `json` and `http.client` modules are
    imported to make the needed HTTP requests. The `Struct` and `namedtuple` objects
    are imported to help in reading the joystick event data:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将发送移动请求到`robows`服务器的所有逻辑都是从列表5.6中的`client_persist.py`中获取的。导入`json`和`http.client`模块以进行所需的HTTP请求。导入`Struct`和`namedtuple`对象以帮助读取操纵杆事件数据：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `MOTOR_AXIS` dictionary is used to map the joystick axis to its associated
    motor on the robot. The left stick *y*-axis maps to the left motor, and the right
    stick *y*-axis maps to the right motor:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`MOTOR_AXIS`字典将操纵杆轴映射到机器人上相关的电机。左侧操纵杆*y*轴映射到左侧电机，右侧操纵杆*y*轴映射到右侧电机：
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `main` function is very similar to the ones we saw previously in this chapter.
    An HTTP connection to the robot server is made and saved in `HTTPConnection`.
    Then, a dictionary called `data` is created to keep track of the position levels
    on the left and right sticks *y*-axis. The rest of the function is unchanged:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数与本章中之前看到的函数非常相似。建立到机器人服务器的HTTP连接并将其保存在`HTTPConnection`中。然后创建一个名为`data`的字典来跟踪左右操纵杆*y*轴上的位置水平。函数的其余部分保持不变：'
- en: '[PRE53]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `handle_event` function will be called each time a new event is detected.
    It will check whether the event is an axis event on the *y*-axis of either the
    stick or right stick. If so, it will then calculate the level of the stick from
    the center position. The previous level is compared, and if the level has changed,
    it will then prepare to make a change to the throttle on the robot motor. The
    new level is saved in `data`. The name of the motor to move is looked up using
    `MOTOR_AXIS`. The value of `factor` is calculated based on whether the level is
    positive or negative. This will dictate whether the motor is turned in the forward
    or backward direction. The speed of the motor movement will be based on the absolute
    value of the `level`. These arguments are saved in a dictionary called `args`.
    The `call_robot` function is then called so that a request to call `set_throttle`
    on the robot server is made:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 每当检测到新事件时，都会调用`handle_event`函数。它将检查事件是否是操纵杆或右侧操纵杆的*y*轴上的轴事件。如果是，它将计算操纵杆从中心位置的水平。将前一个水平进行比较，如果水平发生变化，它将准备对机器人电机的油门进行更改。新的水平将保存在`data`中。使用`MOTOR_AXIS`查找要移动的电机名称。根据水平是正还是负计算`factor`的值。这将决定电机是向前还是向后转动。电机移动的速度将基于`level`的绝对值。这些参数将保存在名为`args`的字典中。然后调用`call_robot`函数，以便向机器人服务器发出调用`set_throttle`的请求：
- en: '[PRE54]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `call_api` and `call_robot` functions are as presented in chapter 5\. They
    will send an HTTP request to the robot server to request changes in the motor
    throttle:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`call_api`和`call_robot`函数在第5章中已有介绍。它们将向机器人服务器发送HTTP请求，请求改变电机油门：'
- en: '[PRE55]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The full script can be saved as `joystick_remote.py` on the Pi and then executed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为`joystick_remote.py`在Pi上，然后执行。
- en: 'Listing 7.8 `joystick_remote.py`: Remotely controlling the robot motors'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.8 `joystick_remote.py`：远程控制机器人电机
- en: '[PRE56]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As was done in chapter 5, make sure to keep the `robows` server running in
    one terminal and then run this script in another. In the following session, we
    can see the output from the script. The right stick was pushed all the way forward
    and then brought back to center to make the right motor move forward. Then, the
    right stick was pulled backward and returned to center to make the right motor
    turn backward. Finally, both the right and left sticks were pushed forward together
    to make both motors drive forward, and then both were returned to center to make
    the robot come to a full stop:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如第5章所述，请确保在一个终端中保持`robows`服务器运行，然后在另一个终端中运行此脚本。在以下会话中，我们可以看到脚本的输出。右侧操纵杆被推到最前面，然后回到中心，使右侧电机向前移动。然后，右侧操纵杆被拉回并回到中心，使右侧电机向后转动。最后，左右两侧操纵杆一起向前推，使两个电机都向前驱动，然后都回到中心，使机器人完全停止：
- en: '[PRE57]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Robots in the real world: Remote forklift operators'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中的机器人：远程叉车操作员
- en: A number of robotics startup companies have begun providing services for vehicles
    such as forklifts to be operated remotely. The remote driver can see the area
    around the vehicle using multiple cameras and drive the forklift using a joystick
    controller. This opens the potential to match drivers from many remote locations
    to different sites, which has become an important technology for addressing shortages
    in heavy vehicle drivers. The BBC article ([https://www.bbc.com/news/business-54431056](https://www.bbc.com/news/business-54431056))
    on the subject mentions many of the opportunities this approach offers, as well
    as the risks.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 许多机器人初创公司已经开始为叉车等车辆提供远程操作服务。远程驾驶员可以使用多个摄像头查看车辆周围区域，并使用操纵杆控制器驾驶叉车。这为将来自许多远程位置的驾驶员与不同地点相匹配提供了可能性，这对于解决重型车辆驾驶员短缺问题已成为一项重要技术。关于这一主题的BBC文章([https://www.bbc.com/news/business-54431056](https://www.bbc.com/news/business-54431056))提到了这种方法提供的机会以及风险。
- en: Safety features, such as having microphones on the vehicles so that remote drivers
    can hear if anyone around the vehicle is calling for them to stop the vehicle,
    are essential. Security measures are also put in place at the software and network
    levels to prevent unauthorized access to the vehicles by malicious parties.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 安全功能，如车辆上安装麦克风，以便远程驾驶员可以听到周围是否有人呼叫他们停车，是必不可少的。在软件和网络层面上也采取了安全措施，以防止恶意方未经授权访问车辆。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Joysticks offer superior control over keyboards and mice when used to control
    the motors of a robot.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用于控制机器人电机时，操纵杆比键盘和鼠标提供了更优越的控制。
- en: The joystick hardware can be connected to the Raspberry Pi using either a wired
    USB or a wireless Bluetooth connection.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操纵杆硬件可以通过有线USB或无线蓝牙连接连接到Raspberry Pi。
- en: The `struct` Python module can be used to directly read and parse joystick events
    from the Linux input subsystem.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用Python的`struct`模块直接从Linux输入子系统中读取和解析操纵杆事件。
- en: Pygame is a very popular Python module used for writing video games.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pygame是一个非常流行的Python模块，用于编写视频游戏。
- en: Linux provides very good support for joystick devices, and their event data
    can be read directly by Python applications.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux为操纵杆设备提供了非常好的支持，Python应用程序可以直接读取其事件数据。
- en: The sensors on the analog sticks of the controller are extremely sensitive and
    can detect hundreds of different positions.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器的模拟杆上的传感器非常敏感，可以检测到数百种不同的位置。
- en: To remotely control the robot motors, the joystick application must send movement
    requests over HTTP to the robot server running the `robows` server.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要远程控制机器人电机，操纵杆应用程序必须通过HTTP向运行`robows`服务器的机器人服务器发送移动请求。
