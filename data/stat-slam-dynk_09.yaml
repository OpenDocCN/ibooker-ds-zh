- en: 9 Chi-square testing and more effect size testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卡方检验和更多效应量检验
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Running and interpreting statistical tests of significance on categorical data
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分类数据上运行和解释显著性检验
- en: Running and interpreting effect size tests on categorical data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分类数据上运行和解释效应量检验
- en: Computing permutations and differentiating permutations from combinations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算排列以及区分排列和组合
- en: Creating facet plots, balloon plots, and mosaic plots
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建分面图、气球图和mosaic图
- en: Rest was once thought to be the antithesis of work and activity. Today, it’s
    considered a critical enabler for achieving the highest levels of productivity
    and performance. Our purpose here is to explore—first by visualizing and then
    by statistical testing—the effect that rest, defined herein as the number of days
    off prior to a regular season game, has on wins and losses in the NBA.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 休息曾经被认为是工作和活动的对立面。今天，它被认为是实现最高生产力和表现的关键推动因素。我们的目的是通过可视化和统计检验来探索——首先通过可视化和然后通过统计检验——休息（在本文中定义为常规赛比赛前的休息日数）对NBA胜负的影响。
- en: Back in chapter 7, we ran t-tests because we were working with numeric dependent
    variables. In this chapter, we’ll instead be working with a categorical dependent
    variable, so we’ll run a chi-square test for independence. But like t-tests, our
    going-in, or null, hypothesis is that there is no meaningful relationship between
    variables. Again, like t-tests, we’ll reject our null hypothesis if our chi-square
    test returns a p-value less than 0.05, or we’ll fail to reject our null hypothesis
    if we instead get a p-value greater than 0.05\. Afterward, we’ll demonstrate two
    ways by which you can run a Cramer’s V test, which is an effect size test that
    complements a chi-square test, just as a Cohen’s d effect size test complements
    a t-test. Once more, which tests to run should tie back to your data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章中，我们运行了t检验，因为我们正在处理数值依赖变量。在本章中，我们将处理一个分类依赖变量，因此我们将运行独立性卡方检验。但就像t检验一样，我们的进入假设，或零假设，是变量之间没有有意义的关系。同样，就像t检验一样，如果我们的卡方检验返回的p值小于0.05，我们将拒绝我们的零假设；如果我们得到的p值大于0.05，我们将无法拒绝我们的零假设。之后，我们将展示两种方法，你可以通过这些方法运行Cramer’s
    V效应量检验，这是一种补充卡方检验的效应量检验，就像Cohen’s d效应量检验补充t检验一样。再次强调，应该根据你的数据来决定运行哪些测试。
- en: The NBA regular season schedule is essentially a constrained optimization problem.
    Every team plays 82 games, split evenly between home and away. Each team must
    play 16 games against other teams from their division, 36 games against other
    teams from the same conference, and 30 games against teams from the opposing conference.
    The best teams are showcased on Christmas and other days to maximize TV viewership;
    venues are available on some days but not others; and there are blackout dates.
    All the while, the league aims to minimize air travel and travel-related expenses.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: NBA常规赛赛程本质上是一个约束优化问题。每个球队都要打82场比赛，主场和客场各占一半。每个球队必须与同分区的其他球队打16场比赛，与同一联盟的其他球队打36场比赛，与对立联盟的球队打30场比赛。最好的球队在圣诞节和其他日子里展示，以最大化电视观众；某些日子有场地可用，而其他日子则没有；还有黑名单日期。同时，联盟的目标是尽量减少空中旅行和与旅行相关的费用。
- en: Consequently, teams play dissimilar and irregular schedules—a pair of opposing
    teams might have an equal or an unequal number of days off before their scheduled
    matchup. Our null hypothesis is that rest has no bearing on wins and losses; therefore,
    our alternative hypothesis is that rest does, in fact, affect who wins and loses.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，球队会打不同的和不规则的赛程——一对对手球队在他们的比赛前可能会有相同或不同数量的休息日。我们的零假设是休息对胜负没有影响；因此，我们的备择假设是休息实际上确实影响谁赢谁输。
- en: 'After we’re done loading our packages, importing our data set, and wrangling
    the same, our subsequent steps are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成加载我们的包、导入我们的数据集和整理数据之后，我们的后续步骤如下：
- en: We’ll lead off with a brief examination of combinations and permutations and
    discuss how to differentiate one versus the other; additionally, we’ll demonstrate
    how to compute permutations with R code.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将首先简要检查组合和排列，并讨论如何区分它们；此外，我们还将演示如何使用R代码计算排列。
- en: We’ll baseline our data and visualize the same with a facet plot.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将基线我们的数据，并使用分面图可视化。
- en: We’ll next run our statistical tests, starting with a chi-square test for independence
    and finishing with a pair of Cramer’s V effect size tests.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们接下来将运行我们的统计检验，从独立性卡方检验开始，以一对Cramer’s V效应量检验结束。
- en: A chi-square test is a tad more encompassing than other tests of statistical
    significance, such as a correlation test or a t-test. We have to first create
    a contingency table—a table or matrix, sometimes referred to as a crosstab, that
    displays the frequency distribution involving two or more variables—and then we
    pass the contingency table to our chi-square test. There are many ways to visualize
    a contingency table, but we’ll demonstrate just two of these.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡方检验比其他统计显著性测试，如相关检验或t检验，更全面。我们首先必须创建一个列联表——一个表格或矩阵，有时也称为交叉表，它显示了涉及两个或更多变量的频率分布——然后我们将列联表传递给我们的卡方检验。有许多方法可以可视化列联表，但我们将演示其中的两种。
- en: Let’s get started.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: 9.1 Loading packages
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 加载包
- en: The function to run our statistical test of significance and return the results
    comes out-of-the-box; however, wrangling data, querying data, and creating our
    visualizations require functions that aren’t available in base R. We therefore
    make a series of calls to the `library()` function to load packages that allow
    us to go above and beyond the base install.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的显著性统计测试并返回结果的函数是现成的；然而，处理数据、查询数据和创建我们的可视化需要一些基础R中不可用的函数。因此，我们通过一系列调用`library()`函数来加载允许我们超越基础安装的包。
- en: 'You’re by now intimately familiar with the `tidyverse` and `sqldf` packages.
    We’ll load these two packages plus five others that haven’t previously been loaded
    or used:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你对`tidyverse`和`sqldf`包已经很熟悉了。我们将加载这两个包以及五个之前未加载或使用的其他包：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first of these is `gtools`, which contains several utility functions, including
    some for counting and printing permutations and combinations. Permutations are
    essentially combinations where we care about the order. For instance, the numbers
    24, 16, and 31 are equivalent to 16, 31, and 24 if the order is immaterial; if
    so, these numbers qualify as a combination. But if 24, 16, and 31 is the “combination”
    to open your locker at the gym, it’s really a permutation because 16, 31, 24 won’t
    work. We’ll cover much more on permutations and combinations in a bit. For now,
    understand that computing the maximum number of possible permutations isn’t the
    same as computing the maximum number of combinations; we’ll need to first differentiate
    which is which before plotting and analyzing our data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其中第一个是`gtools`，它包含几个实用函数，包括一些用于计算和打印排列和组合的函数。排列实际上是组合，其中我们关心顺序。例如，数字24、16和31如果顺序无关紧要，则等同于16、31和24；如果是这样，这些数字可以被视为组合。但如果24、16和31是打开健身房储物柜的“组合”，那么它实际上是一个排列，因为16、31、24将不起作用。我们将在稍后详细介绍排列和组合。现在，了解计算可能排列的最大数量与计算可能组合的最大数量并不相同；在绘图和分析数据之前，我们需要首先区分这两者。
- en: The second and third of these packages are `gplots` and `vcd`. While our facet
    plot will be created with `ggplot2` functions, we’ll also use the `balloonplot()`
    function from the `gplots` package to create a balloon chart and the `mosaic()`
    function from the `vcd` package to create a mosaic plot. Balloon plots and mosaic
    plots are just two ways of visualizing a contingency table.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个包中的第二个和第三个是`gplots`和`vcd`。虽然我们的分面图将使用`ggplot2`函数创建，但我们还将使用`gplots`包中的`balloonplot()`函数创建气球图，以及`vcd`包中的`mosaic()`函数创建镶嵌图。气球图和镶嵌图只是可视化列联表的两种方式。
- en: The fourth and fifth packages are `questionr` and `rcompanion`, and we’ll demonstrate
    two ways, one from each of these packages, to run a Cramer’s V effect size test.
    We’ll import our data set next.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个和第五个包是`questionr`和`rcompanion`，我们将演示这两种包中的一种方法，分别运行Cramer的V效应量测试。接下来我们将导入我们的数据集。
- en: 9.2 Importing data
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 导入数据
- en: We now import our data, a .csv file downloaded from Kaggle, by calling the `readr`
    `read_csv()` function (recall that `readr` is part of the `tidyverse`). Our *file*
    was previously saved with the filename 2012_18_officialBoxScore and stored in
    our default working directory; our *data set* is called NBAboxscores, and it contains
    tabulated results of every regular season NBA game between the 2012-13 and 2017-18
    seasons.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在通过调用`readr`的`read_csv()`函数（记住`readr`是`tidyverse`的一部分）导入我们的数据，一个从Kaggle下载的.csv文件。我们的*文件*之前以文件名2012_18_officialBoxScore保存，并存储在我们的默认工作目录中；我们的*数据集*名为NBAboxscores，它包含了2012-13赛季至2017-18赛季之间每场常规赛NBA比赛的表格化结果。
- en: 'We then call the base R `dim()` function to return the dimension of the NBAboxscores
    data set:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用基础R的`dim()`函数来返回NBAboxscores数据集的维度：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our data has a row count equal to 44,284 and a column count equal to 119\. In
    the following section, we’ll run a series of operations to reduce the NBAboxscores
    data set, length-wise and width-wise, into an object we can better work with.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据有 44,284 行和 119 列。在接下来的部分，我们将运行一系列操作来将 NBAboxscores 数据集在长度和宽度上减少，以便我们更好地处理。
- en: 9.3 Wrangling data
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 数据整理
- en: 'For starters, we absolutely don’t need the last name (`offLNm`) and first name
    (`offFNm`) of the officials or referees assigned to each game. So we call the
    `dplyr select()` function to remove those two variables from NBAboxscores. Here,
    we demonstrate another application of the `select()` function; rather than calling
    out the variable names or variable positions to deselect, we instead tell R to
    remove all variables in the NBAboxscores data set that start with `off`. We then
    call the `dim()` function again, only to confirm that our data set has, in fact,
    been reduced from 119 columns to 117 columns:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们绝对不需要每个游戏分配的官员或裁判的姓氏 (`offLNm`) 和名字 (`offFNm`)。因此，我们调用 `dplyr select()`
    函数从 NBAboxscores 中移除这两个变量。在这里，我们展示了 `select()` 函数的另一个应用；而不是指出变量名称或变量位置来取消选择，我们反而告诉R移除NBAboxscores数据集中以
    `off` 开头的所有变量。然后我们再次调用 `dim()` 函数，只是为了确认我们的数据集确实已经从 119 列减少到 117 列：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: However, by simply removing those two variables from our data set, we now have
    duplicate rows. The last and first names of the officials were the only variables
    distinguishing one record from the next because we have a vertical rather than
    horizontal data set in which single game records are divided between multiple
    observations. Therefore, we next call the base R `unique()` function to remove
    every duplicate record in our data set.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅通过从我们的数据集中移除这两个变量，我们现在有了重复的行。官员的姓氏和名字是区分一条记录与下一条记录的唯一变量，因为我们有一个垂直而不是水平的数据集，其中单场比赛的记录分布在多个观测值之间。因此，我们接下来调用基本的R
    `unique()` 函数来从我们的数据集中移除每个重复的记录。
- en: 'We then call the `dim()` function for a third time to check on the reduced
    dimension of the NBAboxscores data set. Don’t be alarmed if this operation takes
    more than a few seconds to complete:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们第三次调用 `dim()` 函数来检查 NBAboxscores 数据集的减少维度。如果这个操作需要超过几秒钟才能完成，请不要惊慌：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because most NBA games are called by three officials, we should expect the row
    count in NBAboxscores to have been cut by approximately two-thirds, resulting
    in our data set being reduced from 44,284 rows to 14,758 rows.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数NBA比赛都是由三位官员判罚，我们应该预计 NBAboxscores 中的行数将减少大约三分之二，从而使我们的数据集从 44,284 行减少到
    14,758 行。
- en: 'Although everything seems to be in good order, we’ll nevertheless pause momentarily
    to run an integrity check against our data set. The `count()` function from the
    `dplyr` package makes it possible to quickly and easily pull counts of unique
    values or conditions. The frequency by which the variable `teamPTS` (representing
    the total points scored in a game by one of the participating teams) is greater
    than the variable `opptPTS` (representing the number of points scored by the opposing
    team) should equal the frequency by which the exact opposite condition is true:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一切似乎都很顺利，但我们仍然会暂时暂停，对我们的数据集进行完整性检查。`dplyr` 包中的 `count()` 函数使得快速轻松地提取唯一值或条件的计数成为可能。变量
    `teamPTS`（代表一支参赛队伍在比赛中得分的总和）大于变量 `opptPTS`（代表对方队伍得分的数量）的频率应该等于相反条件成立的频率：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This checks out, but just to be sure, we’ll run a second integrity check by
    reversing the condition:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来没问题，但为了确保，我们将通过反转条件进行第二次完整性检查：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Because R returned the results we were hoping for and expecting, we can now
    move forward with confidence to further wrangle the NBAboxscores data set. Next,
    we call the `dplyr filter()` function to subset NBAboxscores where the variable
    `teamPTS` is greater than the variable `opptPTS`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于R返回了我们希望和预期的结果，我们现在可以自信地继续进一步整理 NBAboxscores 数据集。接下来，我们调用 `dplyr filter()`
    函数来对 NBAboxscores 进行子集化，其中 `teamPTS` 变量大于 `opptPTS` 变量。
- en: 'Another call to the `dim()` function confirms that we’ve effectively cut the
    NBAboxscores row count by exactly 50%—our data set now contains 7,379 records
    and, at least for now, 117 columns:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 再次调用 `dim()` 函数确认我们已经有效地将 NBAboxscores 的行数减少了正好50%——我们的数据集现在包含 7,379 条记录，至少到目前为止，有
    117 列：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s save NBAboxscores and create a copy called mydata. Yet another call to
    the `dim()` function confirms that mydata has the exact same dimension as NBAboxscores:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保存NBAboxscores并创建一个名为mydata的副本。再次调用`dim()`函数确认mydata与NBAboxscores具有相同的维度：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then make another call to the `select()` function to subset mydata on just
    six variables. The base R `head``()` and `tail()` functions print, respectively,
    the first six and last six observations in the mydata data set:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次调用`select()`函数，对mydata进行子集化，只保留六个变量。基础R的`head()`和`tail()`函数分别打印mydata数据集中的前六个和最后六个观察值：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here’s a breakdown of our “surviving” variables:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们“幸存”变量的分解：
- en: '`teamLoc`—Equals either `Home` or `Away`, but will always equal the opposite
    of the variable `opptLoc`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`teamLoc`—等于`Home`或`Away`，但始终等于变量`opptLoc`的相反值'
- en: '`teamRslt`—Equals `Win` for all observations'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`teamRslt`—等于所有观察值中的`Win`'
- en: '`teamDayOff`—Equals the number of off days for the winning team prior to a
    game, and has a minimum of 0 and a maximum of 11'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`teamDayOff`—等于比赛前赢得球队的休息日天数，最小值为0，最大值为11'
- en: '`opptLoc`—Equals either `Home` or `Away`, but will always equal the opposite
    of `teamLoc`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opptLoc`—等于`Home`或`Away`，但始终等于`teamLoc`的相反值'
- en: '`opptRslt`—Equals `Loss` for all observations'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opptRslt`—等于所有观察值中的`Loss`'
- en: '`opptDayOff`—Equals the number of off days for the losing team prior to a game,
    and has a minimum of 0 and a maximum of 11'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opptDayOff`—等于比赛前输掉球队的休息日天数，最小值为0，最大值为11'
- en: 'The minimum and maximum values for the variables `teamDayOff` and `opptDayOff`
    were pulled by calling the base R `min``()` and `max()` functions:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用基础R的`min()`和`max()`函数，提取了变量`teamDayOff`和`opptDayOff`的最小值和最大值：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To make this a manageable exercise and avoid having an unreasonable number of
    days-off permutations between home and visiting teams, most of which would have
    very few observations anyway, we call the `filter()` function twice to subset
    mydata by retaining only those observations where the variable `teamDayOff` is
    less than or equal to 4 and then again where the variable `opptDayOff` is less
    than or equal to 4.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个练习易于管理并避免在主队和客队之间有太多不合理的休息日排列，其中大多数观察值非常少，我们两次调用`filter()`函数，以保留变量`teamDayOff`小于或等于4的观察值，然后再次保留变量`opptDayOff`小于或等于4的观察值。
- en: 'We then call the `dim()` function yet again and discover that we now have 7,191
    rows and six columns in our working data set. So we merely stripped 188 rows from
    mydata, or less than 3% of the total record count:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次调用`dim()`函数，发现现在我们的工作数据集有7,191行和六列。因此，我们仅仅从mydata中移除了188行，或者说不到总记录数的3%：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we call the `map_df()` function from the `purrr` package, which is part
    of the `tidyverse` universe of packages, to return the class for each of our six
    variables. (We automatically loaded the `purrr` packaged when we loaded the `tidyverse`.)
    They are all character strings or integers, but they all should be factors instead,
    so we convert them accordingly by calling the base R `as.factor()` function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`purrr`包中的`map_df()`函数，它是`tidyverse`包宇宙的一部分，以返回我们六个变量的类别。（我们在加载`tidyverse`时自动加载了`purrr`包。）它们都是字符字符串或整数，但都应该被转换为因子，因此我们通过调用基础R的`as.factor()`函数相应地转换它们：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then pipe the mydata data set to the `dplyr group_by``()` and `tally()`
    functions to compute the number of home and away wins:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将mydata数据集管道传输到`dplyr group_by()`和`tally()`函数，以计算主队和客队的胜利次数：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It turns out that the home team won 4,224 games, and the away team won 2,967
    games. So the home team won 58.7% of the regular season games between the 2012-13
    and 2017-18 seasons—that’s our benchmark.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，主队赢得了4,224场比赛，客队赢得了2,967场比赛。因此，在2012-13赛季至2017-18赛季的常规赛中，主队赢得了58.7%的比赛——这就是我们的基准。
- en: Before we get into our analysis, let’s have that conversation about permutations
    and combinations that we promised in the beginning.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始分析之前，让我们谈谈我们最初承诺的排列和组合问题。
- en: 9.4 Computing permutations
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 计算排列
- en: The first thing to understand about permutations is that they are *not* synonymous
    with combinations. The starting lineup for the Golden State Warriors might consist
    of Otto Porter Jr., Andrew Wiggins, Draymond Green, Klay Thompson, and Stephen
    Curry. That’s a combination, not a permutation, because it doesn’t matter in what
    order these players are announced before tip-off; either way, Golden State’s starting
    lineup remains unchanged.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于排列，首先需要理解的是，它们与组合不是同义的。金州勇士队的首发阵容可能由奥托·波特小、安德鲁·威金斯、德拉蒙德·格林、克莱·汤普森和斯蒂芬·库里组成。这是一个组合而不是排列，因为宣布这些球员的顺序并不重要；无论哪种方式，金州勇士队的首发阵容都不会改变。
- en: On the other hand, if we’re concerned with division standings at the end of
    the 2021-22 season, that’s a permutation, not a combination, because the order
    is everything—the place at which each team finished absolutely matters.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们关心 2021-22 赛季结束时的分区排名，那么这是一个排列而不是组合，因为顺序至关重要——每个队伍最终的位置绝对重要。
- en: So the first thing to understand is that if or when the order doesn’t matter,
    it’s a combination, but if or when the order does matter, it’s a permutation.
    The second thing to understand about permutations is the concept of *with replacement*
    versus *without replacement*. A pair of plays called by a head coach for their
    team’s next two possessions is a permutation *with replacement* because the same
    player could be the primary option for zero, one, or both plays. The NBA lottery
    is a permutation *without replacement* because the same team can’t be selected
    more than once.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先需要理解的是，如果顺序不重要，那么它是组合；但如果顺序重要，那么它是排列。关于排列的第二个理解是带替换与不带替换的概念。主教练为球队接下来的两次进攻叫出的两个战术是带替换的排列，因为同一个球员可能是零次、一次或两次进攻的主要选择。NBA
    抽签是不带替换的排列，因为同一个队伍不能被选中超过一次。
- en: 'What’s the point of all this? In just a moment, we’re going to compute and
    visualize the number of wins between home and away teams based on *permutations*
    of prior days off. In fact, these are permutations *with replacement* due to the
    following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些有什么意义？在下一刻，我们将计算并可视化主队和客队之间基于前一天休息日的排列数量的胜负。事实上，这些是带替换的排列，原因如下：
- en: The order matters. For any given game, the home team might have two prior days
    off and the away team just one prior day off; that’s very different, of course,
    from the home team having just one day off and the away team having two days.
    Therefore, these are permutations and not combinations.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序很重要。对于任何一场比赛，主队可能有两个前一天休息日，而客队只有一个前一天休息日；当然，这与主队只有一个休息日而客队有两个休息日的情况非常不同。因此，这些都是排列而不是组合。
- en: The home and away teams may absolutely have the same number of prior days off;
    in fact, this is quite common. For instance, a pair of opposing home and road
    teams may both have two prior days off. This means we can use the same number
    (2, in this example) twice in our permutations rather than just once. Therefore,
    these are permutations *with replacement.*
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主队和客队的前一天休息日数量可能完全相同；事实上，这种情况很常见。例如，一对主客场球队可能都有两个前一天休息日。这意味着我们可以在排列中使用相同的数字（在这个例子中是
    2）两次，而不仅仅是一次。因此，这些是带替换的排列。
- en: For our purposes here, there are five prior days off to select from (0-4), and
    each permutation will contain two of them. It’s easy to compute the number of
    permutations we need to account for; the formula is *n*^r, where *n* represents
    the number of potential selections (5) and *r* represents the number of selections
    per permutation (2).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们的目的而言，我们有五个前一天休息日可供选择（0-4），并且每个排列将包含其中两个。计算我们需要考虑的排列数量很容易；公式是 *n*^r，其中 *n*
    代表潜在选择数量（5）和 *r* 代表每个排列的选择数量（2）。
- en: 'We can perform this or any other mathematical operation in R. We square 5 and
    set the output to equal an object called permutationsCount. The `paste0()` function
    from base R is a sort of enhanced version of the `print()` function; here, it
    concatenates a character string with permutationsCount and prints the full result
    as a character string. The `^` operator takes the first numeral and raises it
    to the exponent of the second numeral:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 R 中执行此操作或任何其他数学运算。我们将 5 平方并将输出设置为等于一个名为 permutationsCount 的对象。来自基础 R 的
    `paste0()` 函数是 `print()` 函数的一种增强版本；在这里，它将一个字符串与 permutationsCount 连接并打印完整的字符字符串结果。`^`
    运算符将第一个数字提升为第二个数字的指数：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also call on the `permutations()` function from the `gtools` package
    to compute the permutations count where *n* equals the number of prior days off
    to select from, *r* equals the number of days off per permutation, and `repeats.allowed`
    is set to `TRUE` because replacement is allowed. We front the `permutations()`
    function with the base R `nrow()` function to return the permutations count:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以调用 `gtools` 包中的 `permutations()` 函数来计算排列计数，其中 *n* 等于可供选择的先前休息日数，*r* 等于每个排列的休息日数，而
    `repeats.allowed` 设置为 `TRUE` 因为允许重复。我们在 `permutations()` 函数前面使用基本的R `nrow()` 函数来返回排列计数：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We then call the `permutations()` function again, this time without the `nrow()`
    function, to print our 25 permutations. We conveniently subtract our results by
    one so that R returns prior days off between 0 and 4 rather than between 1 and
    5:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次调用 `permutations()` 函数，这次没有使用 `nrow()` 函数，以打印出我们的25种排列。我们方便地减去我们的结果，这样R就返回了0到4之间的先前休息日，而不是1到5之间：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Given that *n* and *r* are both small numbers, we certainly could have performed
    this operation by hand, but that’s *not* how statisticians, data scientists, and
    data analysts are supposed to roll. Besides, we can’t always count on *n* and
    *r* being small numbers; therefore, it’s imperative to understand what distinguishes
    a permutation from a combination and to further understand the differences between
    *with replacement* and *without replacement*—the formulas are very different depending
    on the problem type.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *n* 和 *r* 都是较小的数字，我们当然可以手动执行此操作，但这并不是统计学家、数据科学家和数据分析师应该采取的方式。此外，我们并不总是可以依赖
    *n* 和 *r* 是较小的数字；因此，了解排列与组合的区别以及进一步了解有放回和无放回之间的差异——公式根据问题类型的不同而有很大差异——是至关重要的。
- en: We can now proceed to computing and visualizing our results.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续计算和可视化我们的结果。
- en: 9.5 Visualizing results
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 可视化结果
- en: Our plan is to display counts of home team and road team wins by every possible
    permutation in a single facet plot. We’ll create a data source, plot our results,
    and summarize the key takeaways.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计划是在单张分面图中显示主队和客队胜利的计数，按每个可能的排列进行。我们将创建一个数据源，绘制我们的结果，并总结关键要点。
- en: 9.5.1 Creating a data source
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.1 创建数据源
- en: 'We start by resuming—and completing—our data wrangling operations with another
    call to the `group_by``()` and `tally()` functions; this time, however, our objective
    is to compute the home and away win totals for each of our 25 permutations. Because
    there are home wins and away wins for every permutation, our results are cast
    into a tibble, called finaldf, that is 50 rows long rather than 25\. Because R
    prints only the first 10 rows of our tibble by default, we add the argument `n
    = 50` to the `print()` function so that R instead prints finaldf in its entirety:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过再次调用 `group_by()` 和 `tally()` 函数来恢复并完成我们的数据处理操作；然而，这一次，我们的目标是计算我们25种排列中的主队和客队胜利总数。由于每个排列都有主队胜利和客队胜利，我们的结果被转换成一个名为
    finaldf 的 tibble，长度为50行而不是25行。因为R默认只打印tibble的前10行，所以我们向 `print()` 函数添加了参数 `n =
    50`，这样R就会完整地打印出 finaldf：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The win totals are represented in the far-right column labeled `n`. Take a look,
    for instance, at the first row. When the away and home teams both had no prior
    days off, the away team won 35 times. Now take a look at row 26; again, when the
    away and home teams had no prior days off, the home team won 66 times.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 胜利总数在右侧的列 `n` 中表示。例如，看看第一行。当客队和主队都没有先前休息日时，客队赢了35次。现在看看第26行；同样，当客队和主队都没有先前休息日时，主队赢了66次。
- en: 'We then call the base R `sum()` function against finaldf to return the sum
    of `n`—it equals 7,191, which, of course, is identical to the mydata row count
    once we subset mydata so that the variables `teamDayOff` and `opptDayOff` were
    both equal to or less than 4:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对 finaldf 调用基本的R `sum()` 函数来返回 `n` 的总和——它等于7,191，当然，一旦我们将 mydata 子集化，使得变量
    `teamDayOff` 和 `opptDayOff` 都等于或小于4，这个数字就与 mydata 的行数相同：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We now have a data source for our facet plot.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了分面图的数据源。
- en: 9.5.2 Visualizing the results
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.2 可视化结果
- en: 'Our `ggplot2` facet plot visualizes the number of home team and away team wins
    for every possible days-off permutation in finaldf. (Once more, a facet plot is
    a type of visualization made up of several subplots that have the same axes where
    each subplot represents a mutually exclusive subset of the data.) Because there
    are five days off possibilities (0-4) and two teams (`Home` and `Away`), the number
    of days off permutations equals 5², or 25\. Therefore, our facet plot has 25 panels.
    Affixed atop each panel is the prior days-off permutation, where the top number
    applies to the home team and the bottom number applies to the away team. The specific
    instructions for creating our facet plot are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ggplot2`面图可视化在finaldf中每个可能的休息日排列组合的主队和客队胜负次数。（再次强调，面图是由多个子图组成的可视化类型，每个子图具有相同的坐标轴，每个子图代表数据的一个互斥子集。）由于有五种休息日可能性（0-4）和两支球队（主队和客队），休息日排列组合的数量等于5²，即25。因此，我们的面图有25个面板。每个面板顶部都附有前一天休息日的排列组合，其中顶部数字适用于主队，底部数字适用于客队。创建我们的面图的具体说明如下：
- en: We set `n` as the x-axis variable and `teamLoc` as the y-axis variable; therefore,
    our results will be visualized horizontally rather than vertically.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`n`设置为x轴变量，将`teamLoc`设置为y轴变量；因此，我们的结果将以水平而不是垂直的方式可视化。
- en: The `geom_bar()` function is called to visualize the results with a bar chart
    per panel; the `stat` `=` `identify` argument tells R to draw the length of the
    bars to match the variable `n`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`geom_bar()`函数在每个面板中以条形图的形式可视化结果；`stat` `=` `identify`参数告诉R将条形的长度与变量`n`匹配。
- en: The `facet_wrap()` function instructs R to match `teamDayOff`/`opptDayOff` permutations
    with the 25 panels. R will automatically arrange the 25 panels in a 5 × 5 grid,
    but the layout can be customized by adding the `ncol` argument to the `facet_wrap()`
    function and then specifying the number of columns, which, of course, would then
    increase or decrease the row count to stay fixed on 25 panels. In addition, x-axis
    scales are fixed by default to be harmonized across all the panels. But this,
    too, can be customized by using the `scales` package in tandem with the `facet_wrap()`
    function and setting it to `free`; R will then scale each panel, or x-axis, independently
    based on the per-permutation results. We experimented with both of these options,
    and suffice to say, the defaults are there for a reason.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`facet_wrap()`函数指示R将`teamDayOff`/`opptDayOff`排列组合与25个面板匹配。R将自动将25个面板排列成5×5的网格，但可以通过向`facet_wrap()`函数添加`ncol`参数并指定列数来自定义布局，这样就会相应地增加或减少行数以保持25个面板不变。此外，x轴刻度默认固定，以在整个面板中保持一致。但这也可以通过使用`scales`包与`facet_wrap()`函数一起使用并设置为`free`来自定义；R将根据每个排列的结果独立缩放每个面板或x轴。我们尝试了这两种选项，但可以肯定的是，默认设置有其原因。'
- en: The `xlim()` function is added to extend the length of the x-axes. We do this
    so that our labels affixed to the “top” of our horizontal bars fit inside all
    the panels, especially where the record counts are highest.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了`xlim()`函数来延长x轴的长度。我们这样做是为了确保我们附加在水平条形图“顶部”的标签能够适应所有面板，尤其是在记录计数最高的地方。
- en: These labels are made possible by the addition of the `geom_text()` function;
    the `vjust` and `hjust` arguments adjust the placement of the labels vertically
    and horizontally.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些标签是通过添加`geom_text()`函数实现的；`vjust`和`hjust`参数调整标签的垂直和水平位置。
- en: 'We create our facet plot (see figure 9.1)—any `ggplot2` object, really—by first
    calling the `ggplot()` function; then we incrementally add bells and whistles
    by alternately calling the plus (`+`) operator and other `ggplot2` functions.
    Note that R might not merely bypass `ggplot()` functions that aren’t preceded
    by the `+` operator; instead, R could very well throw an error or return `NULL`.
    It all depends on the function that’s not preceded by the `+` operator. The following
    calls the object:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过首先调用`ggplot()`函数来创建我们的面图（实际上任何`ggplot2`对象）——然后通过交替调用加号（`+`）运算符和其他`ggplot2`函数来逐步添加功能。请注意，R可能不会仅仅跳过没有加号（`+`）运算符的前置的`ggplot()`函数；相反，R可能会抛出一个错误或返回`NULL`。这完全取决于没有加号（`+`）运算符的前置函数。以下是对象的调用：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![CH09_F01_Sutton](../../OEBPS/Images/CH09_F01_Sutton.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F01_Sutton](../../OEBPS/Images/CH09_F01_Sutton.png)'
- en: Figure 9.1 A facet plot divided into 25 panels that visualizes with a series
    of bar charts the breakdown in home and away wins by permutations of prior days
    off
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 将面图分为25个面板，通过一系列条形图展示了通过前一天休息日的排列组合来分解主队和客队胜负情况。
- en: 9.5.3 Conclusions
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5.3 结论
- en: It’s fascinating to see these results because rest appears to have a tremendous
    influence on wins and losses. As just one example, consider where the home team
    had two days off and the away team had just one—the home team won 795 of the 996
    games, or almost 80%. But when the away team had two days off and the home team
    just one day off, the away team won about two-thirds of the games. Recall that
    our reference point is 58.7%—this is the home team winning percentage regardless
    of prior days off between home and away teams.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这些结果非常令人着迷，因为休息似乎对胜负有巨大的影响。仅举一个例子，当主队休息两天而客队只休息一天时，主队赢得了 996 场比赛中的 795 场，或者说接近
    80%。但当客队休息两天而主队只休息一天时，客队赢得了大约三分之二的比赛。记住，我们的参考点是 58.7%——这是无论主队和客队之间前一天休息日多少，主队胜率。
- en: 'In the chunk of `dplyr` code shown next, we compute the number of wins for
    home and away teams when both teams had an equal number of prior days off. That’s
    followed by a pair of `SELECT` statements where we call the `sqldf()` function
    from the `sqldf` package, just for comparison purposes; the `sqldf` code is otherwise
    equivalent to the `dplyr` code immediately above it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面展示的 `dplyr` 代码块中，我们计算了当两支球队都有相同数量的前一天休息日时，主队和客队的胜利次数。随后是一对 `SELECT` 语句，我们在这里调用
    `sqldf()` 函数，仅用于比较目的；`sqldf` 代码在其他方面与上面的 `dplyr` 代码相同：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When home and away teams squared off with an equal number of prior days off,
    the home team won 57.7% of the games, which is very close to their overall winning
    percentage in regular season games between the 2012-13 and 2017-18 seasons.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当主队和客队在前一天休息日数量相等时，主队赢得了 57.7% 的比赛，这非常接近他们在 2012-13 赛季和 2017-18 赛季常规赛中的整体胜率。
- en: 'In the next chunk of `dplyr` code, we compute the counts of home team wins
    and away team wins when the home team had more prior days off than the away team.
    Note that we temporarily converted the variables `teamDayOff` and `opptDayOff`
    to numeric variables from factors because most mathematical operators don’t work
    on factors. Again, we follow up by calling the `sqldf()` function twice and writing
    another pair of `SELECT` statements that provide the same output as our `dplyr`
    code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个 `dplyr` 代码块中，我们计算了当主队比客队有更多前一天休息日时，主队胜利次数和客队胜利次数。注意，我们临时将变量 `teamDayOff`
    和 `opptDayOff` 从因子转换为数值变量，因为大多数数学运算符不适用于因子。同样，我们再次调用 `sqldf()` 函数两次，并编写另一对 `SELECT`
    语句，提供与我们的 `dplyr` 代码相同的输出：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The home team won 74% of games in which it had at least one additional prior
    day off than the away team.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当主队比客队多休息一天或以上时，主队赢得了 74% 的比赛。
- en: 'In the next and final chunk of `dplyr` code, we compute the counts of home
    team wins and away team wins when the away team had more prior days off than the
    home team. Following that, we again call the `sqldf()` function to return the
    same output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个也是最后的 `dplyr` 代码块中，我们计算了当客队比主队有更多前一天休息日时，主队胜利次数和客队胜利次数。随后，我们再次调用 `sqldf()`
    函数以返回相同的输出：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The away team won 58% of the games in which it had at least one more prior day
    off than the home team. These results seem significant, but let’s perform a statistical
    test to confirm (or discover otherwise).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 客队在它比主队多休息一天或以上的比赛中赢得了 58% 的比赛。这些结果似乎很显著，但让我们进行统计检验来确认（或发现其他情况）。
- en: 9.6 Statistical test of significance
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 显著性统计检验
- en: Let’s now conduct what is called a chi-squared test for independence to determine
    whether or not these differences are statistically significant. Whereas a t-test
    computes the statistical significance or lack thereof, when the dependent variable
    is numeric, a chi-square test is used when the dependent variable is categorical.
    Like a t-test, our null hypothesis is that there is no meaningful relationship
    between two variables and that the value of one variable doesn’t help to predict
    the value of the other variable. We’ll therefore need a p-value equal to or less
    than our predefined 0.05 threshold for significance to reject the null hypothesis
    and alternately conclude that rest matters in wins and losses.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将进行所谓的卡方检验，以确定这些差异是否具有统计学意义。当因变量是数值时，t 检验用于计算统计显著性或缺乏显著性，而当因变量是分类变量时，使用卡方检验。与
    t 检验一样，我们的零假设是两个变量之间没有有意义的关系，并且一个变量的值不能帮助预测另一个变量的值。因此，我们需要一个等于或小于我们预定义的 0.05 显著性阈值的
    p 值，以拒绝零假设，并得出结论，休息对胜负有影响。
- en: 'Here are three hypothetical yet real-world examples of a chi-square test:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是三个假设但却是现实世界的卡方检验例子：
- en: We want to determine if there is a relationship between voter sentiment toward
    a bill to increase public school funding and marital status. The null hypothesis,
    or *H*[0], is that sentiment and marital status are independent of one another;
    the alternative hypothesis, or *H*[1], is that sentiment and marital status aren’t
    independent. This sort of data would usually be collected by a survey. Chi-square
    tests for independence are frequently used by researchers studying survey responses.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想确定选民对增加公立学校资金法案的情感与婚姻状况之间是否存在关系。零假设，或*H*[0]，是情感和婚姻状况彼此独立；备择假设，或*H*[1]，是情感和婚姻状况并不独立。这类数据通常通过调查收集。研究人员在研究调查回答时经常使用卡方检验来检验独立性。
- en: We have an interest in testing the potential relationship between gender and
    political beliefs. The null hypothesis is that no relationship exists between
    gender and whether one associates as liberal or conservative; the alternative
    hypothesis is that gender and politics are related.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们对测试性别与政治信仰之间潜在关系感兴趣。零假设是性别与一个人是否将自己视为自由派或保守派之间不存在关系；备择假设是性别与政治相关。
- en: We want to measure customer counts in a restaurant by day of week. The null
    hypothesis is that the restaurant serves the same, or roughly the same, number
    of customers regardless of the day of the week; the alternative hypothesis is
    that customer counts vary, perhaps significantly so, by day of week.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望通过星期几来衡量餐厅的顾客数量。零假设是，无论星期几，餐厅提供的顾客数量相同或大致相同；备择假设是，顾客数量按星期几变化，可能变化很大。
- en: All things considered, we’re comparing the p-value from a chi-square test to
    a predefined 5% threshold for statistical significance—just like we did with our
    t-tests earlier. If the p-value is less than 5%, we’ll reject a null hypothesis
    that any differences are more or less due to chance; if greater than 5%, we’ll
    fail to reject that same null hypothesis—again, just like we did with our t-tests.
    We’re running a chi-square test for independence rather than a t-test because
    we’re now working with categorical data, whereas back in chapter 6, we instead
    worked with numeric data. This is why we’ll run a Cramer’s V effect size test
    afterward rather than a Cohen’s d effect size test.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有因素，我们正在比较卡方检验的p值与预先定义的5%统计显著性阈值——就像我们之前在t检验中所做的那样。如果p值小于5%，我们将拒绝零假设，即任何差异更多或更少是由于偶然性造成的；如果大于5%，我们将无法拒绝那个相同的零假设——再次，就像我们在t检验中所做的那样。我们现在运行的是卡方检验的独立性，而不是t检验，因为我们现在处理的是分类数据，而回想起第6章，我们当时处理的是数值数据。这就是为什么我们将在之后运行Cramer’s
    V效应量测试而不是Cohen’s d效应量测试的原因。
- en: 9.6.1 Creating a contingency table and a balloon plot
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.1 创建列联表和气球图
- en: 'The outputs we computed in the previous section are thrown into a 3 × 2 contingency
    table called chisq_table. A contingency table is a way of summarizing categorical
    data by showing one distribution horizontally (or by rows) and another distribution
    vertically (or by columns); shortly, we’ll pass our contingency table to a chi-square
    test. We initialize the contingency table by calling the base R `matrix()` function;
    therefore, our contingency table, at least for the time being, is really a matrix
    rather than a table. The three rows are labeled More Rest, Same Rest, and Less
    Rest (after all, each team has more, less, or the same rest as the opposing team)
    while the two columns are labeled Home Wins and Home Losses (all games end with
    one of these two outcomes, but clearly there are alternatives in the labeling):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中我们计算出的输出被放入了一个3 × 2的列联表，称为chisq_table。列联表是一种通过水平（或按行）显示一个分布，而垂直（或按列）显示另一个分布的方式来总结分类数据的方法；简而言之，我们将我们的列联表传递给卡方检验。我们通过调用基础R的`matrix()`函数来初始化列联表；因此，至少在目前，我们的列联表实际上是一个矩阵而不是一个表格。三行分别标记为“更多休息”、“相同休息”和“较少休息”（毕竟，每个队伍的休息时间都比对方队伍多、少或相同）而两列分别标记为“主场胜利”和“主场失利”（所有比赛都以这两种结果之一结束，但显然在标签上还有其他选择）：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: One way of visualizing a contingency table is through a balloon chart (see figure
    9.2), and one way of creating a balloon chart in R is to call the `balloonplot()`
    function from the `gplots` package in combination with the `t()` function from
    base R. The `t()` function transposes a matrix or data frame by switching the
    rows and columns. It’s not absolutely required, but the `balloonplot()` function
    by itself automatically transposes our contingency table. The `t()` function therefore
    merely reverts the contingency table to its original dimension.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化列联表的一种方法是通过气球图（见图9.2），在R中创建气球图的一种方法是通过调用`gplots`包中的`balloonplot()`函数，并结合基础R中的`t()`函数。`t()`函数通过交换行和列来转置矩阵或数据框。这不是绝对必要的，但`balloonplot()`函数本身会自动转置我们的列联表。因此，`t()`函数仅仅是将列联表恢复到其原始维度。
- en: '![CH09_F02_Sutton](../../OEBPS/Images/CH09_F02_Sutton.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F02_Sutton](../../OEBPS/Images/CH09_F02_Sutton.png)'
- en: Figure 9.2 A balloon chart is just one way to visualize a contingency table
    in R.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 气球图是可视化R中列联表的一种方法。
- en: 'The `balloonplot()` function requires a table as a data source, so we first
    convert chisq_table from a matrix to a table by passing chisq_table as a matrix
    to the base R `as.table()` function and then create our visualization:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`balloonplot()`函数需要一个表格作为数据源，因此我们首先通过将`chisq_table`作为矩阵传递给基础R的`as.table()`函数，将`chisq_table`从矩阵转换为表格，然后创建我们的可视化：'
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our balloon chart isn’t necessarily the most elegant visualization we’ve created
    so far, but it does the job. It’s basically a graphical contingency table or matrix
    where the dot sizes reflect the record counts. We can readily see that home teams
    are even more successful when they have more rest than their visiting opponents
    and less successful when their opponents instead have more rest.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的气球图可能不是我们迄今为止创建的最优雅的视觉化图表，但它确实完成了任务。它基本上是一个图形化的列联表或矩阵，其中点的大小反映了记录数。我们可以清楚地看到，当主队比客队有更多休息时间时，主队的表现更加成功；而当对手反而有更多休息时间时，主队的表现则不那么成功。
- en: When `label` equals `TRUE`, R adds the record counts inside the dots; when `show.margins`
    equals `TRUE`, R sums every row and column and prints the totals just outside
    the table.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当`label`等于`TRUE`时，R会在点内添加记录数；当`show.margins`等于`TRUE`时，R会汇总每一行和每一列，并将总数打印在表格的外面。
- en: 9.6.2 Running a chi-square test
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.2 运行卡方检验
- en: 'We then run our chi-squared test for independence by calling the base R `chisq.test()`
    function and passing our contingency table—now really a table—as the only parameter.
    This is just as simple and straightforward as running a t-test:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用基础R的`chisq.test()`函数并传递我们的列联表（现在实际上是一个表格）作为唯一参数来运行我们的独立性卡方检验。这和运行t检验一样简单直接：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our results are returned in full digit numerals because we fronted our code
    by disabling scientific notation via the `options()` function from base R and
    passing the `scipen` `=` `999` argument. Because the p-value is less than the
    0.05 threshold for significance (much less, in fact), we can therefore reject
    the null hypothesis and conclude that a statistically significant relationship
    does exist between rest and wins and losses. Our null hypothesis—here and always—is
    that the variables are independent of one another and that the value of one variable
    therefore doesn’t and can’t predict the value of the other variable. We can and
    should reject the null hypothesis and instead accept the alternative hypothesis
    only when the evidence tells us there is almost zero chance our results could
    be random. This is why we generally require a p-value at or below 5% to reject
    any null hypothesis.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果以完整的数字形式返回，因为我们通过禁用基础R中的`options()`函数的指数表示法并通过传递`scipen` `=` `999`参数来提前处理我们的代码。因为p值小于显著性阈值0.05（实际上要小得多），因此我们可以拒绝零假设，并得出结论，休息时间和胜负之间存在显著的统计关系。我们的零假设——在这里以及总是——是变量之间相互独立，因此一个变量的值不能也不应该预测另一个变量的值。只有当证据表明我们的结果几乎完全不可能随机时，我们才能并且应该拒绝零假设，并接受备择假设。这就是为什么我们通常要求p值在5%或以下才能拒绝任何零假设。
- en: 9.6.3 Creating a mosaic plot
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6.3 创建mosaic图
- en: A mosaic plot is another graphical representation of a contingency table (see
    figure 9.3). However, the `mosaic()` function from the `vcd` package goes a step
    further—in addition to drawing a picture that represents the relationship between
    categorical variables, the `mosaic()` function adds the results of our chi-squared
    test for independence by independently computing the p-value and returning the
    result in the lower-right corner.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 空间拼图是列联表的另一种图形表示方法（见图9.3）。然而，`vcd`包中的`mosaic()`函数更进一步——除了绘制表示分类变量之间关系的图片外，`mosaic()`函数还通过独立计算p值并将结果返回到右下角，添加了我们关于独立性的卡方检验结果。
- en: '![CH09_F03_Sutton](../../OEBPS/Images/CH09_F03_Sutton.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![CH09_F03_Sutton](../../OEBPS/Images/CH09_F03_Sutton.png)'
- en: Figure 9.3 A mosaic plot is yet another way to visualize a contingency table
    in R. It’s not at all necessary to create a balloon chart and a mosaic plot—one
    or the other is recommended—and you should pick the plot that works best for you.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 空间拼图是另一种在R中可视化列联表的方法。完全没有必要创建气球图和空间拼图——推荐选择其中一个——你应该选择最适合你的图表。
- en: 'We call the `mosaic()` function and add our contingency table as the first
    argument. When `shade` equals `TRUE`, R adds colors to the plot where the actual
    outcomes are at variance with the expected outcomes; when `legend` also equals
    `TRUE`, R adds a legend, in the form of Pearson residuals, to the right of the
    plot. Pearson residuals represent the standardized distances between actual and
    expected outcomes:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`mosaic()`函数并将我们的列联表作为第一个参数。当`shade`等于`TRUE`时，R会在实际结果与预期结果不一致的地方添加颜色到图中；当`legend`也等于`TRUE`时，R会在图的右侧添加一个图例，以皮尔逊残差的形式。皮尔逊残差表示实际结果与预期结果之间的标准化距离：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The size, or length, of the rectangles represent proportional values. When compared
    to equal amounts of rest, home teams win even more frequently when they have at
    least one additional prior day off than visiting teams, and they win less frequently
    when the opposite is true.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形的尺寸或长度代表比例值。与休息时间相等的情况相比，当主队至少有额外一天的休息时间时，主队获胜的频率更高，而当情况相反时，获胜的频率更低。
- en: 9.7 Effect size testing
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7 效应量测试
- en: A Cramer’s V test is to categorical data what a Cohen’s d test is to continuous
    data; so whereas a Cohen’s d test complements a t-test, a Cramer’s V test complements
    a chi-square test for independence. Our purpose here is to demonstrate two ways
    of computing a Cramer’s V effect size test where we pass our contingency table,
    chisq_table, to a pair of similar functions that return similar results.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Cramer’s V测试对于分类数据就像Cohen’s d测试对于连续数据；因此，Cohen’s d测试补充了t检验，而Cramer’s V测试补充了独立性卡方检验。我们在这里的目的是要展示两种计算Cramer’s
    V效应量测试的方法，我们将我们的列联表chisq_table传递给一对类似的功能，它们返回相似的结果。
- en: From our chi-square test, we learned that a statistically significant relationship
    exists between rest and wins and losses; however, a chi-square test doesn’t provide
    any insight as to *how* significant that relationship might be. A Cramer’s V test,
    regardless of what function is called from which package, will return some number
    between 0 and 1, where 0 indicates absolutely no association between two variables,
    and 1 indicates a strong association between two variables.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的卡方检验中，我们了解到休息时间和胜负之间存在统计显著的关联；然而，卡方检验并没有提供关于这种关联可能“如何”显著的任何见解。无论从哪个包中调用哪个函数，Cramer’s
    V测试都会返回一个介于0到1之间的数字，其中0表示两个变量之间完全没有关联，而1表示两个变量之间有强烈的关联。
- en: 'We first call the `cramer.v()` function from the `questionr` package:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用`questionr`包中的`cramer.v()`函数：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we call the `cramerV()` function from the `rcompanion` package:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用`rcompanion`包中的`cramerV()`函数：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So we get the same results from both operations; based on the results equaling
    0.24, we can conclude that the effect size is small. Back in chapter 6, we emphasized
    that an effect size test like Cohen’s d complements and doesn’t replace a test
    of statistical significance, such as a t-test, and that we shouldn’t correlate
    the results between the two. It’s the same here between our chi-square test for
    independence and our subsequent Cramer’s V effect size tests.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到了两个操作相同的结果；基于结果等于0.24，我们可以得出结论，效应量较小。在第六章中，我们强调了像Cohen’s d这样的效应量测试是补充而不是取代统计显著性测试，如t检验，并且我们不应该将两个结果相关联。在这里，我们的卡方检验和随后的Cramer’s
    V效应量测试也是如此。
- en: In the following chapter, we’ll explore what sort of relationship there might
    be between team payrolls, regular season wins, postseason appearances, and league
    championships.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨球队工资、常规赛胜利、季后赛出场和联赛冠军之间可能存在的关系。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Rest is quite obviously a significant factor in wins and losses. Our chi-square
    test for independence confirmed what we previously computed and visualized—wins
    and losses between home and away teams flip as prior days off flip. In R, you
    can write and run a significance test with just one or two lines of built-in code.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 休息显然是胜负的重要因素。我们的卡方检验独立性证实了我们之前计算和可视化的结果——主客场之间的胜负会随着之前的休息日而翻转。在R中，你可以用一行或两行内置代码编写和运行显著性检验。
- en: The same is true with effect size tests on categorical data; just one line of
    code is all that’s needed to run a Cramer’s V test in R, regardless of what function
    from which package you choose.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于分类数据的效应量测试也是如此；在R中运行Cramer的V测试只需要一行代码，无论你选择哪个包的哪个函数。
- en: It’s critical to understand the differences between permutations and combinations
    and between with replacement and without replacement. There are radically different
    formulas depending on the problem type; it just so happens that permutations with
    replacement are probably the easiest.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解排列组合以及有放回和无放回之间的区别至关重要。根据问题类型，公式可能会有根本性的不同；恰好排列组合有放回的情况可能是最简单的。
- en: While the brainpower must come from you, R can perform the grunt work and the
    heavy lifting. Computing permutations is hardly an everyday task, yet R includes
    more than one package and more than one function for accomplishing this task.
    Moreover, it took just one line of code to compute the permutations count and
    just one additional line of code to print all the permutations.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然脑力必须来自你，但R可以完成繁琐的工作和重活。计算排列几乎不是日常任务，但R包含多个包和多个函数来完成这项任务。此外，计算排列计数只需一行代码，打印所有排列只需额外一行代码。
- en: Transforming a bar chart into a `ggplot2` facet plot requires just one additional
    line of code. Our balloon plot and mosaic plot might not be the most sophisticated
    plots we’ve created thus far, but they are nevertheless just as compelling as
    they were easy to produce.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将条形图转换为`ggplot2`分面图只需额外一行代码。我们的气球图和马赛克图可能不是我们迄今为止创建的最复杂的图表，但它们仍然像以前一样引人入胜，而且制作起来也很容易。
- en: Due to the importance and benefits of rest, the NBA should consider days off,
    if at all possible, when generating the regular season schedule. Additionally,
    the Las Vegas sportsbooks should incorporate prior days off into their algorithms
    if they aren’t already doing so.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于休息的重要性及其带来的益处，NBA在生成常规赛日程时，如果可能的话，应考虑安排休息日。此外，如果拉斯维加斯的体育博彩公司还没有这样做，它们应该将之前的休息日纳入其算法中。
