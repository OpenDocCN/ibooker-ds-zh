- en: Chapter 7\. Linear and logistic regression
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 线性和逻辑回归
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using linear regression to predict quantities
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线性回归预测数量
- en: Using logistic regression to predict probabilities or categories
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用逻辑回归预测概率或类别
- en: Extracting relations and advice from linear models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从线性模型中提取关系和建议
- en: Interpreting the diagnostics from R’s `lm()` call
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释R的`lm()`调用中的诊断信息
- en: Interpreting the diagnostics from R’s `glm()` call
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释R的`glm()`调用中的诊断信息
- en: Using regularization via the `glmnet` package to address issues that can arise
    with linear models.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`glmnet`包通过正则化来解决线性模型可能出现的各种问题。
- en: In the previous chapter, you learned how to evaluate models. Now that we have
    the ability to discuss if a model is good or bad, we’ll move on to the modeling
    step, as shown in the mental model ([figure 7.1](../Text/07.xhtml#ch07fig01)).
    In this chapter, we’ll cover fitting and interpreting *linear models* in R.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何评估模型。现在我们有了讨论模型是好是坏的能力，我们将继续到建模步骤，如图7.1中的心理模型所示。在本章中，我们将介绍如何在R中拟合和解释*线性模型*。
- en: Figure 7.1\. Mental model
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1. 心理模型
- en: '![](Images/07fig01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig01.jpg)'
- en: Linear models are especially useful when you don’t want only to predict an outcome,
    but also to know the relationship between the input variables and the outcome.
    This knowledge can prove useful because this relationship can often be used as
    *advice* on how to get the outcome that you want.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不仅想要预测一个结果，还想了解输入变量与结果之间的关系时，线性模型特别有用。这种知识可能非常有用，因为这种关系通常可以用作如何获得你想要的结果的*建议*。
- en: We’ll first define *linear regression* and then use it to predict customer income.
    Later, we will use *logistic regression* to predict the probability that a newborn
    baby will need extra medical attention. We’ll also walk through the diagnostics
    that R produces when you fit a linear or logistic model.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义*线性回归*，然后用它来预测客户收入。之后，我们将使用*逻辑回归*来预测新生儿需要额外医疗注意力的概率。我们还将介绍R在拟合线性或逻辑模型时产生的诊断信息。
- en: Linear methods can work well in a surprisingly wide range of situations. However,
    there can be issues when the inputs to the model are correlated or *collinear*.
    In the case of logistic regression, there can also be issues (ironically) when
    a subset of the variables predicts a classification output perfectly in a subset
    of the training data. The last section of the chapter will show how to address
    these issues by a technique called *regularization*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 线性方法可以在出人意料广泛的情境中有效工作。然而，当模型的输入变量相关或*共线性*时，可能会出现问题。在逻辑回归的情况下，当变量子集在训练数据的一个子集中完美预测分类输出时，也可能出现问题（具有讽刺意味的是）。本章的最后部分将展示如何通过一种称为*正则化*的技术来解决这些问题。
- en: 7.1\. Using linear regression
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1. 使用线性回归
- en: Linear regression is the bread and butter prediction method for statisticians
    and data scientists. If you’re trying to predict a numerical quantity like profit,
    cost, or sales volume, you should always try linear regression first. If it works
    well, you’re done; if it fails, the detailed diagnostics produced can give you
    a good clue as to what methods you should try next.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归是统计学家和数据科学家常用的预测方法。如果你试图预测像利润、成本或销售量这样的数值量，你应该首先尝试线性回归。如果它工作得很好，你就完成了；如果它失败了，产生的详细诊断信息可以给你一个很好的线索，告诉你下一步应该尝试什么方法。
- en: 7.1.1\. Understanding linear regression
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1. 理解线性回归
- en: '* * *'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Example
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '*Suppose you want to predict how many pounds a person on a diet and exercise
    plan will lose in a month. You will base that prediction on other facts about
    that person, like how much they reduce their average daily caloric intake over
    that month and how many hours a day they exercised. In other words, for every
    person* `i`*, you want to predict* `pounds_lost[i]` *based on* `daily_cals_down[i]`
    *and* `daily_exercise[i]`*.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*假设你想预测一个正在节食和锻炼计划中的人一个月内会减掉多少磅。你将基于该人的其他事实来做出预测，比如他们在这个月平均每天减少多少卡路里摄入量，以及他们每天锻炼多少小时。换句话说，对于每个人*
    `i`*，你想要根据* `daily_cals_down[i]` *和* `daily_exercise[i]`*来预测* `pounds_lost[i]`*。*'
- en: '* * *'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Linear regression assumes that the outcome `pounds_lost` is linearly related
    to each of the inputs `daily_cals_down[i]` and `daily_exercise[i]`. This means
    that the relationship between (for instance) `daily_cals_down[i]` and `pounds_lost`
    looks like a (noisy) straight line, as shown in [figure 7.2](../Text/07.xhtml#ch07fig02).^([[1](../Text/07.xhtml#ch07fn1)])
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归假设结果`pounds_lost`与每个输入`daily_cals_down[i]`和`daily_exercise[i]`线性相关。这意味着（例如）`daily_cals_down[i]`与`pounds_lost`之间的关系看起来像一条（有噪声的）直线，如图[7.2](../Text/07.xhtml#ch07fig02)所示。[1](../Text/07.xhtml#ch07fn1)
- en: ¹
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is tempting to hope that `b0J = bC0 + be0` or that `b.calsJ = b.cals`; however,
    a joint regression does not ensure this.
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 很有希望希望`b0J = bC0 + be0`或者`b.calsJ = b.cals`；然而，联合回归并不能保证这一点。
- en: Figure 7.2\. The linear relationship between `daily_cals_down` and `pounds_lost`
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2。`daily_cals_down`与`pounds_lost`之间的线性关系
- en: '![](Images/07fig02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2](Images/07fig02.jpg)'
- en: The relationship between `daily_exercise` and `pounds_lost` would similarly
    be a straight line. Suppose that the equation of the line shown in [figure 7.2](../Text/07.xhtml#ch07fig02)
    is
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`daily_exercise`与`pounds_lost`之间的关系也会是直线。假设图[7.2](../Text/07.xhtml#ch07fig02)中显示的线的方程是'
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This means that for every unit change in `daily_cals_down` (every calorie reduced),
    the value of `pounds_lost` changes by `b.cals`, no matter what the starting value
    of `daily_cals_down` was. To make it concrete, suppose `pounds_lost = 3 + 2 *
    daily_ cals_down`. Then increasing `daily_cals_down` by one increases `pounds_lost`
    by 2, no matter what value of `daily_cals_down` you start with. This would not
    be true for, say, `pounds_lost = 3 + 2 * (daily_cals_down^2)`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对于`daily_cals_down`（每减少一卡路里）的每单位变化，`pounds_lost`的值会通过`b.cals`变化，无论`daily_cals_down`的起始值是多少。为了具体说明，假设`pounds_lost
    = 3 + 2 * daily_cals_down`。那么增加`daily_cals_down`一个单位，`pounds_lost`也会增加2，无论你从什么值开始。对于像`pounds_lost
    = 3 + 2 * (daily_cals_down^2)`这样的例子，这就不成立了。
- en: 'Linear regression further assumes that the total pounds lost is a *linear combination*
    of our variables `daily_cals_down[i]` and `daily_exercise[i]`, or the sum of the
    pounds lost due to reduced caloric intake, and the pounds lost due to exercise.
    This gives us the following form for the linear regression model of `pounds_lost`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归进一步假设总减重是变量`daily_cals_down[i]`和`daily_exercise[i]`的*线性组合*，或者说是由于减少卡路里摄入量和运动导致的减重之和。这给我们带来了以下线性回归模型形式的`pounds_lost`：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The goal of linear regression is to find the values of `b0`, `b.cals`, and `b.exercise`
    so that the linear combination of `daily_cals_lost[i]` and `daily_exercise[i]`
    (plus some offset `b0`) comes very close to `pounds_lost[i]` for all persons `i`
    in the training data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归的目标是找到`b0`、`b.cals`和`b.exercise`的值，使得`daily_cals_lost[i]`和`daily_exercise[i]`的线性组合（加上一些偏移量`b0`）对于训练数据中的所有人员`i`的`pounds_lost[i]`都非常接近。
- en: Let’s put this in more general terms. Suppose that `y[i]` is the numeric quantity
    you want to predict (called the *dependent* or *response* variable), and `x[i,]`
    is a row of inputs that corresponds to output `y[i]` (the `x[i,]` are the *independent*
    or *explanatory* variables). Linear regression attempts to find a function *f*(*x*)
    such that
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用更普遍的术语来表述。假设`y[i]`是你想要预测的数值量（称为*因变量*或*响应变量*），而`x[i,]`是与输出`y[i]`相对应的一行输入（`x[i,]`是*自变量*或*解释变量*）。线性回归试图找到一个函数*f*(*x*)，使得
- en: equation 7.1\. The expression for a linear regression model
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 公式7.1。线性回归模型的表示
- en: '![](Images/07equ01_alt.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![公式7.1](Images/07equ01_alt.jpg)'
- en: 'You want numbers `b[0],...,b[n]` (called the *coefficients* or *betas*) such
    that `f(x[i,])` is as near as possible to `y[i]` for all `(x[i,],y[i])` pairs
    in the training data. R supplies a one-line command to find these coefficients:
    `lm()`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要找到数字`b[0],...,b[n]`（称为*系数*或*贝塔*），使得对于训练数据中的所有`(x[i,],y[i])`对，`f(x[i,])`尽可能接近`y[i]`。R提供了一个单行命令来找到这些系数：`lm()`。
- en: The last term in equation 7.1, `e[i]`, represents what are called *unsystematic
    errors*, or noise. Unsystematic errors are defined to all have a mean value of
    `0` (so they don’t represent a net upward or net downward bias) and are defined
    as uncorrelated with `x[i,].` In other words, `x[i,]` should not encode information
    about `e[i]` (or vice versa).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 公式7.1中的最后一项`e[i]`代表所谓的*非系统误差*，或噪声。非系统误差被定义为具有均值为`0`（因此它们不代表净向上或净向下的偏差）并且与`x[i,]`不相关。换句话说，`x[i,]`不应该包含关于`e[i]`的信息（反之亦然）。
- en: By assuming that the noise is unsystematic, linear regression tries to fit what
    is called an “unbiased” predictor. This is another way of saying that the predictor
    gets the right answer “on average” over the entire training set, or that it underpredicts
    about as much as it overpredicts. In particular, unbiased estimates tend to get
    totals correct.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过假设噪声是无系统的，线性回归试图拟合所谓的“无偏”预测器。这另一种说法是，预测器在整个训练集上“平均”得到正确答案，或者说它低估的量与高估的量大致相等。特别是，无偏估计往往能得到总数正确。
- en: '* * *'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Example
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '*Suppose you have fit a linear regression model to predict weight loss based
    on reduction of caloric intake and exercise. Now consider the set of subjects
    in the training data,* `LowExercise`*, who exercised between zero and one hour
    a day. Together, these subjects lost a total of 150 pounds over the course of
    the study. How much did the model predict they would lose?*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*假设你已拟合一个线性回归模型来预测基于卡路里摄入量减少和锻炼的体重减轻。现在考虑训练数据集中的`LowExercise`组，该组的人每天锻炼时间在零到一小时之间。这些受试者共同在研究过程中减掉了总共150磅。模型预测他们会减掉多少体重？*'
- en: '* * *'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: With a linear regression model, if you take the predicted weight loss for all
    the subjects in `LowExercise` and sum them up, that total will sum to 150 pounds,
    which means that the model predicts the *average* weight loss of a person in the
    `LowExercise` group correctly, even though some of the individuals will have lost
    more than the model predicted, and some of them will have lost less. In a business
    setting, getting sums like this correct is critical, particularly when summing
    up monetary amounts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线性回归模型时，如果你将`LowExercise`组中所有受试者的预测体重减轻值加起来，这个总和将是150磅，这意味着模型正确预测了`LowExercise`组一个人的平均体重减轻，尽管有些人减掉的重量超过了模型的预测，有些人减掉的重量少于模型预测。在商业环境中，正确计算这样的总和是至关重要的，尤其是在汇总货币金额时。
- en: Under these assumptions (linear relationships and unsystematic noise), linear
    regression is absolutely relentless in finding the best coefficients `b[i]`. If
    there’s some advantageous combination or cancellation of features, it’ll find
    it. One thing that linear regression doesn’t do is reshape variables to be linear.
    Oddly enough, linear regression often does an excellent job, even when the actual
    relation is not in fact linear.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些假设（线性关系和无系统噪声）下，线性回归在寻找最佳系数`b[i]`方面是绝对不懈的。如果有某种有利的特点组合或特征消除，它也会找到。线性回归不做的一件事是将变量重塑为线性。奇怪的是，即使实际关系不是线性的，线性回归通常也能做得很好。
- en: '* * *'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Thinking about linear regression
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 思考线性回归
- en: 'When working with linear regression, you’ll go back and forth between “Adding
    is too simple to work,” and “How is it even possible to estimate the coefficients?”
    This is natural and comes from the fact that the method is both simple and powerful.
    Our friend Philip Apps sums it up: “You have to get up pretty early in the morning
    to beat linear regression.”'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用线性回归时，你会在“加法太简单无法工作”和“如何估计系数？”之间来回摇摆。这是自然的，源于该方法既简单又强大。我们的朋友菲利普·阿普斯总结了这一点：“你必须起得很早才能打败线性回归。”
- en: '* * *'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: When the assumptions of linear regression are violated
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当线性回归的假设被违反时
- en: As a toy example, consider trying to fit the squares of the integers 1–10 using
    only a linear function plus a constant. We’re asking for coefficients `b[0]` and
    `b[1]` such that
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个小例子，考虑只用线性函数加上一个常数来拟合整数1到10的平方。我们要求系数`b[0]`和`b[1]`，使得
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is clearly not a fair thing to ask, since we know that what we are trying
    to predict is not linear. In this case, however, linear regression still does
    a pretty good job. It picks the following fit:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个问题是不公平的，因为我们知道我们试图预测的不是线性的。然而，在这种情况下，线性回归仍然做得相当不错。它选择了以下拟合：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As [figure 7.3](../Text/07.xhtml#ch07fig03) shows, this is a good fit in the
    region of values we trained on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图7.3](../Text/07.xhtml#ch07fig03)所示，这是我们在训练区域的一个良好拟合。
- en: Figure 7.3\. Fit versus actuals for y=x²
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3\. y=x²的拟合与实际值
- en: '![](Images/07fig03_alt.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig03_alt.jpg)'
- en: 'The example in [figure 7.3](../Text/07.xhtml#ch07fig03) is typical of how linear
    regression is “used in the field”—we’re using a linear model to predict something
    that is itself not linear. Be aware that this is a minor sin. In particular, note
    that the errors between the model’s predictions and the true `y` are not random,
    but systematic: the model underpredicts for specific ranges of `x` and overpredicts
    for others. This isn’t ideal, but often the best we can do. Note also that, in
    this example, the predictions veer further away from the true outcome near the
    endpoints of the fit, which indicates that this model is probably not safe to
    use outside the range of `x` that the model observed in the training data.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.3](../Text/07.xhtml#ch07fig03)中的例子是线性回归在“实际应用中”的典型用法——我们使用线性模型来预测本身不是线性的东西。请注意，这是一个小错误。特别是，请注意，模型预测与真实`y`之间的误差不是随机的，而是系统的：模型在特定的`x`范围内低估，在其他范围内高估。这不是理想的，但通常是我们能做的最好的。请注意，在本例中，预测在拟合的端点附近偏离真实结果更远，这表明这个模型可能不适合在模型在训练数据中观察到的`x`范围之外使用。'
- en: '* * *'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Extrapolation is not as safe as interpolation
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 外推法不如内插法安全
- en: 'In general, you should try to use a model only for *interpolation*: predicting
    for new data that falls inside the range of your training data. *Extrapolation*
    (predicting for new data outside the range observed during training) is riskier
    for any model. It’s especially risky for linear models, unless you know that the
    system that you are modeling is truly linear.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您应该只尝试使用模型进行*内插法*：预测训练数据范围内的新的数据。*外推法*（预测训练数据观察范围之外的新的数据）对任何模型来说都更具风险。对于线性模型来说，除非您知道您正在建模的系统确实是线性的，否则这尤其危险。
- en: '* * *'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Next we’ll work through an example of how to apply linear regression on more-interesting
    real data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过一个例子来展示如何将线性回归应用于更有趣的实时数据。
- en: Introducing the PUMS dataset
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍PUMS数据集
- en: '* * *'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Example
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '*Suppose you want to predict personal income of any individual in the general
    public, within some relative percent, given their age, education, and other demographic
    variables. In addition to predicting income, you also have a secondary goal: to
    determine the effect of a bachelor’s degree on income, relative to having no degree
    at all.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*假设您想预测任何公众人物的相对百分比的个人收入，给定他们的年龄、教育和其他人口统计变量。除了预测收入外，您还有一个次要目标：确定学士学位对收入的影响，相对于完全没有学位的情况。*'
- en: '* * *'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'For this task, you will use the 2016 US Census PUMS dataset. For simplicity,
    we have prepared a small sample of PUMS data to use for this example. The data
    preparation steps include these:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，您将使用2016年美国人口普查PUMS数据集。为了简化，我们已经准备了一个小样本的PUMS数据用于本例。数据准备步骤包括以下内容：
- en: Restricting the data to full-time employees between 20 and 50 years of age,
    with an income between $1,000 and $250,000.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据限制为20至50岁之间的全职员工，收入在1,000美元至250,000美元之间。
- en: Dividing the data into a training set, `dtrain`, and a test set, `dtest`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据划分为训练集`dtrain`和测试集`dtest`。
- en: We can continue the example by loading psub.RDS (which you can download from
    [https://github.com/WinVector/PDSwR2/raw/master/PUMS/psub.RDS](https://github.com/WinVector/PDSwR2/raw/master/PUMS/psub.RDS))
    into your working directory, and performing the steps in the following listing.^([[1](../Text/07.xhtml#ch07fn2)])
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 psub.RDS（您可以从[https://github.com/WinVector/PDSwR2/raw/master/PUMS/psub.RDS](https://github.com/WinVector/PDSwR2/raw/master/PUMS/psub.RDS)下载）加载到工作目录中，并执行以下列表中的步骤来继续这个例子.^([[1](../Text/07.xhtml#ch07fn2)])
- en: ¹
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The script for preparing the data sample can be found at [https://github.com/WinVector/PDSwR2/blob/master/PUMS/makeSubSample.Rmd](https://github.com/WinVector/PDSwR2/blob/master/PUMS/makeSubSample.Rmd).
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 准备数据样本的脚本可以在[https://github.com/WinVector/PDSwR2/blob/master/PUMS/makeSubSample.Rmd](https://github.com/WinVector/PDSwR2/blob/master/PUMS/makeSubSample.Rmd)找到。
- en: Listing 7.1\. Loading the PUMS data and fitting a model
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1\. 加载PUMS数据并拟合模型
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Makes a random variable to group and partition the data
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过随机变量对数据进行分组和划分
- en: ❷ Splits 50–50 into training and test sets
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将数据50-50分成训练集和测试集
- en: ❸ Fits a linear model to log(income)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将线性模型拟合到对数收入
- en: ❹ Gets the predicted log(income) on the test and training sets
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在测试集和训练集上获取预测的对数收入
- en: Each row of PUMS data represents a single anonymized person or household. Personal
    data recorded includes occupation, level of education, personal income, and many
    other demographic variables.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: PUMS数据集的每一行代表一个单独的匿名个人或家庭。记录的个人数据包括职业、教育水平、个人收入以及许多其他人口统计变量。
- en: 'For this example we have decided to predict `log10(PINCP)`, or the logarithm
    of income. Fitting logarithm-transformed data typically gives results with smaller
    relative error, emphasizing smaller errors on smaller incomes. But this improved
    relative error comes at a cost of introducing a bias: on average, predicted incomes
    are going to be below actual training incomes. An unbiased alternative to predicting
    `log(income)` would be to use a type of generalized linear model called *Poisson
    regression*. We will discuss generalized linear models (specifically, logistic
    regression) in [section 7.2](../Text/07.xhtml#ch07lev1sec2). The Poisson regression
    is unbiased, but typically at the cost of larger relative errors.^([[1](../Text/07.xhtml#ch07fn3)])'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们决定预测`log10(PINCP)`，即收入的对数。拟合对数转换后的数据通常会得到相对误差更小的结果，强调对较小收入的较小误差。但这种改进的相对误差是以引入偏差为代价的：平均而言，预测的收入将低于实际训练收入。预测`log(income)`的无偏替代方案是使用一种称为*泊松回归*的广义线性模型。我们将在[第7.2节](../Text/07.xhtml#ch07lev1sec2)中讨论广义线性模型（特别是逻辑回归）。泊松回归是无偏的，但通常以更大的相对误差为代价。[1](../Text/07.xhtml#ch07fn3)]
- en: ¹
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For a series of articles discussing these issues, please see [http://www.win-vector.com/blog/2019/07/link-functions-versus-data-transforms/](http://www.win-vector.com/blog/2019/07/link-functions-versus-data-transforms/).
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于讨论这些问题的系列文章，请参阅[http://www.win-vector.com/blog/2019/07/link-functions-versus-data-transforms/](http://www.win-vector.com/blog/2019/07/link-functions-versus-data-transforms/)。
- en: For the analysis in this section, we’ll consider the input variables age (`AGEP`),
    sex (`SEX`), class of worker (`COW`), and level of education (`SCHL`). The output
    variable is personal income (`PINCP`). We’ll also set the *reference level*, or
    “default” sex to `M` (male); the reference level of class of worker to `Employee
    of a private for-profit`; and the reference level of education level to `no high
    school diploma`. We’ll discuss reference levels later in this chapter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节的分析，我们将考虑输入变量年龄（`AGEP`）、性别（`SEX`）、工人类别（`COW`）和教育水平（`SCHL`）。输出变量是个人收入（`PINCP`）。我们还将设置*参考水平*，或“默认”性别为`M`（男性）；工人类别的参考水平为`私营营利性企业的雇员`；教育水平的参考水平为`无高中文凭`。我们将在本章后面讨论参考水平。
- en: '* * *'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Reference levels are baselines, not value judgments**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**参考水平是基线，而非价值判断**'
- en: When we say that the default sex is male and the default educational level is
    `no high school diploma`, we are not implying that you should expect that a typical
    worker is male, or that a typical worker has no high school diploma. The reference
    level of a variable is the baseline that other values of the variable are compared
    to. So we are saying that at some point in this analysis, we may want to compare
    the income of female workers to that of male workers with equivalent characteristics,
    or that we may want to compare the income of workers with a high school degree
    or a bachelor’s degree to that of a worker with no high school diploma (but otherwise
    equivalent characteristics).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说默认性别为男性，默认教育水平为`无高中文凭`时，我们并不是暗示你应该期待典型工人是男性，或者典型工人没有高中文凭。变量的参考水平是其他变量值与之比较的基础水平。因此，我们说的是，在分析的这个阶段，我们可能想要比较具有相同特征的男女工人的收入，或者我们可能想要比较拥有高中文凭或学士学位的工人与没有高中文凭（但其他特征相同）的工人的收入。
- en: By default, R selects the alphabetically first value of a categorical variable
    as the reference level.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，R会选择分类变量按字母顺序排列的第一个值作为参考水平。
- en: '* * *'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Now on to the model building.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始构建模型。
- en: 7.1.2\. Building a linear regression model
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2\. 构建线性回归模型
- en: The first step in either prediction or finding relations (advice) is to build
    the linear regression model. The function to build the linear regression model
    in R is `lm()`, supplied by the `stats` package. The most important argument to
    `lm()` is a formula with `~` used in place of an equals sign. The formula specifies
    what column of the data frame is the quantity to be predicted, and what columns
    are to be used to make the predictions.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 预测或寻找关系（建议）的第一步是构建线性回归模型。在R中构建线性回归模型的函数是`lm()`，由`stats`包提供。`lm()`函数最重要的参数是一个公式，其中用`~`代替等号。公式指定数据框中哪一列是要预测的量，以及要用于预测的列。
- en: 'Statisticians call the quantity to be predicted the *dependent variable* and
    the variables/ columns used to make the prediction the *independent variables*.
    We find it is easier to call the quantity to be predicted the *y* and the variables
    used to make the predictions the *x*s. Our formula is this: `log10(PINCP) ~ AGEP
    + SEX + COW + SCHL`, which is read “Predict the log base 10 of income as a function
    of age, sex, employment class, and education.”^([[1](../Text/07.xhtml#ch07fn4)])
    The overall method is demonstrated in [figure 7.4](../Text/07.xhtml#ch07fig04).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学家将需要预测的量称为*因变量*，将用于进行预测的变量/列称为*自变量*。我们发现将需要预测的量称为*y*，将用于预测的变量称为*x*更容易。我们的公式是：`log10(PINCP)
    ~ AGEP + SEX + COW + SCHL`，这可以读作“预测以年龄、性别、就业类别和教育为函数的收入的对数10为基数。”^([[1](../Text/07.xhtml#ch07fn4)])整体方法在[图7.4](../Text/07.xhtml#ch07fig04)中得到了演示。
- en: ¹
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Recall from the discussion of the lognormal distribution in [section 4.2](../Text/04.xhtml#ch04lev1sec2)
    that it’s often useful to log transform monetary quantities. The log transform
    is also compatible with our original task of predicting incomes with a relative
    error (meaning large errors count more against small incomes). The `glm()` methods
    of [section 7.2](../Text/07.xhtml#ch07lev1sec2) can be used to avoid the log transform
    and predict in such a way as to minimize square errors (so being off by $50,000
    would be considered the same error for both large and small incomes).
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 回想一下[第4.2节](../Text/04.xhtml#ch04lev1sec2)中关于对数正态分布的讨论，通常对货币量进行对数变换是有用的。对数变换也与我们的原始任务兼容，即使用相对误差（意味着大误差对小额收入的影响更大）来预测收入。[第7.2节](../Text/07.xhtml#ch07lev1sec2)中的`glm()`方法可以用来避免对数变换，并以最小化平方误差的方式预测（因此，偏离$50,000将被视为大额和小额收入相同的误差）。
- en: Figure 7.4\. Building a linear model using `lm()`
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4\. 使用`lm()`构建线性模型
- en: '![](Images/07fig04_alt.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4的替代文本](Images/07fig04_alt.jpg)'
- en: The statement in [figure 7.4](../Text/07.xhtml#ch07fig04) builds the linear
    regression model and stores the results in the new object called `model`. This
    model is able to make predictions, and to extract important advice from the data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.4](../Text/07.xhtml#ch07fig04)中的语句构建了线性回归模型，并将结果存储在名为`model`的新对象中。这个模型能够进行预测，并从数据中提取重要信息。'
- en: '* * *'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: R stores training data in the model
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: R将训练数据存储在模型中
- en: R holds a copy of the training data in its model to supply the residual information
    seen in `summary(model)`. Holding a copy of the data this way is not strictly
    necessary, and can needlessly run you out of memory. If you’re running low on
    memory (or swapping), you can dispose of R objects like `model` using the `rm()`
    command. In this case, you’d dispose of the model by running `rm("model")`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: R在其模型中保留了一份训练数据的副本，以提供在`summary(model)`中看到的残差信息。以这种方式保留数据的副本并非绝对必要，并且可能无谓地耗尽你的内存。如果你内存不足（或正在交换），你可以使用`rm()`命令删除R对象，如`model`。在这种情况下，你可以通过运行`rm("model")`来删除模型。
- en: '* * *'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 7.1.3\. Making predictions
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3\. 进行预测
- en: Once you’ve called `lm()` to build the model, your first goal is to predict
    income. This is easy to do in R. To predict, you pass data into the `predict()`
    method. [Figure 7.5](../Text/07.xhtml#ch07fig05) demonstrates this using both
    the test and training data frames `dtest` and `dtrain`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你调用了`lm()`函数来构建模型，你的第一个目标就是预测收入。在R中这样做很简单。要预测，你需要将数据传递给`predict()`方法。[图7.5](../Text/07.xhtml#ch07fig05)展示了如何使用测试数据框`dtest`和训练数据框`dtrain`来演示这一点。
- en: Figure 7.5\. Making predictions with a linear regression model
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5\. 使用线性回归模型进行预测
- en: '![](Images/07fig05_alt.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5的替代文本](Images/07fig05_alt.jpg)'
- en: The data frame columns `dtest$predLogPINCP` and `dtrain$predLogPINCP` now store
    the predictions for the test and training sets, respectively. We have now both
    produced and applied a linear regression model.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框列`dtest$predLogPINCP`和`dtrain$predLogPINCP`现在分别存储测试集和训练集的预测结果。我们现在已经产生了并应用了一个线性回归模型。
- en: Characterizing prediction quality
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 描述预测质量
- en: Before publicly sharing predictions, you want to inspect both the predictions
    and model for quality. We recommend plotting the actual `y` (in this case, predicted
    income) that you’re trying to predict as if it were a function of your prediction.
    In this case, plot `log10(PINCP)` as if it were a function of `predLogPINCP`.
    If the predictions are very good, then the plot will be dots arranged near the
    line `y=x`, which we call *the line of perfect prediction* (the phrase is not
    standard terminology; we use it to make talking about the graph easier). The steps
    to produce this, illustrated in [figure 7.6](../Text/07.xhtml#ch07fig06), are
    shown in the next listing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在公开分享预测之前，你希望检查预测和模型的质量。我们建议将你试图预测的实际 `y`（在这种情况下，预测收入）作为你的预测的函数来绘制。在这种情况下，将
    `log10(PINCP)` 作为 `predLogPINCP` 的函数来绘制。如果预测非常好，那么图上的点将排列在 `y=x` 线附近，我们称之为*完美预测线*（这个短语不是标准术语；我们用它来使讨论图形更容易）。在[图
    7.6](../Text/07.xhtml#ch07fig06)中展示的生成此图的步骤将在下一个列表中显示。
- en: Figure 7.6\. Plot of actual log income as a function of predicted log income
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6\. 实际对数收入作为预测对数收入的函数的图
- en: '![](Images/07fig06_alt.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig06_alt.jpg)'
- en: Listing 7.2\. Plotting log income as a function of predicted log income
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2\. 将对数收入作为预测对数收入的函数进行绘图
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Plots the line x=y
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 绘制 x=y 的线
- en: ❷ Limits the range of the graph for legibility
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 限制图形范围以提高可读性
- en: Statisticians prefer the residual plot shown in [figure 7.7](../Text/07.xhtml#ch07fig07),
    where the residual errors (in this case, `predLogPINCP - log10(PINCP)`) are plotted
    as a function of `predLogPINCP`. In this case, the line of perfect prediction
    is the line `y=0`. Notice that the points are scattered widely from this line
    (a possible sign of low-quality fit). The residual plot in [figure 7.7](../Text/07.xhtml#ch07fig07)
    is prepared with the R steps in the next listing.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学家更喜欢[图 7.7](../Text/07.xhtml#ch07fig07)中所示的残差图，其中残差误差（在这种情况下，`predLogPINCP
    - log10(PINCP)`）作为 `predLogPINCP` 的函数进行绘制。在这种情况下，完美预测线是 `y=0` 的线。注意，点从这个线散布很广（可能是低质量拟合的迹象）。[图
    7.7](../Text/07.xhtml#ch07fig07)中的残差图是用下一个列表中的 R 步骤准备的。
- en: Figure 7.7\. Plot of residual error as a function of prediction
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7\. 预测误差作为预测函数的图
- en: '![](Images/07fig07_alt.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig07_alt.jpg)'
- en: Listing 7.3\. Plotting residuals income as a function of predicted log income
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3\. 将残差收入作为预测对数收入的函数进行绘图
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '* * *'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Why are the predictions, not the true values, on the x-axis?**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么预测而不是真实值在 x 轴上？**'
- en: A graph that plots predictions on the x-axis and either true values (as in [figure
    7.6](../Text/07.xhtml#ch07fig06)) or residuals (as in [figure 7.7](../Text/07.xhtml#ch07fig07))
    on the y-axis answers different questions than a graph that puts true values on
    the x-axis and predictions (or residuals) on the y-axis. Statisticians tend to
    prefer the graph as shown in [figure 7.7](../Text/07.xhtml#ch07fig07). A residual
    graph with *predictions* on the x-axis gives you a sense of when the model may
    be under- or overpredicting, based on the model’s output.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 x 轴上绘制预测，并在 y 轴上绘制真实值（如[图 7.6](../Text/07.xhtml#ch07fig06)所示）或残差（如[图 7.7](../Text/07.xhtml#ch07fig07)所示）的图与在
    x 轴上绘制真实值并在 y 轴上绘制预测（或残差）的图所回答的问题不同。统计学家倾向于更喜欢[图 7.7](../Text/07.xhtml#ch07fig07)中所示的图形。在
    x 轴上有预测的残差图能让你根据模型输出判断模型可能存在低估或高估的情况。
- en: A residual graph with the *true outcome* on the x-axis and residuals on the
    y-axis would almost always appear to have undesirable residual structure, even
    when there is no modeling problem. This illusion is due to an effect called *regression
    to the mean* or *reversion to mediocrity*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 x 轴上有真实结果并在 y 轴上有残差，那么几乎总是会显示出不希望的残差结构，即使没有建模问题。这种错觉是由于一种称为*回归到均值*或*回归到平庸*的效果造成的。
- en: '* * *'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: When you look at the true-versus-fitted or residual graphs, you’re looking for
    some specific things that we’ll discuss next.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看真实值与拟合值或残差图时，你正在寻找一些我们将在下文中讨论的具体内容。
- en: On average, are the predictions correct?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 平均而言，预测是否正确？
- en: 'Does the smoothing curve lie more or less along the line of perfect prediction?
    Ideally, the points will all lie very close to that line, but you may instead
    get a wider cloud of points (as we do in [figures 7.6](../Text/07.xhtml#ch07fig06)
    and [7.7](../Text/07.xhtml#ch07fig07)) if your input variables don’t explain the
    output too closely. But if the smoothing curve lies along the line of perfect
    prediction and “down the middle” of the cloud of points, then the model predicts
    correctly on average: it underpredicts about as much as it overpredicts.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 平滑曲线是否更靠近完美预测的直线？理想情况下，点将非常接近那条线，但如果你输入的变量没有很好地解释输出，你可能会得到一个更宽的点云（如我们在[图7.6](../Text/07.xhtml#ch07fig06)和[7.7](../Text/07.xhtml#ch07fig07)中看到的那样）。但如果平滑曲线沿着完美预测的直线并且“在点云的中间”，那么模型平均预测是正确的：它低估的量大约等于高估的量。
- en: Are there systematic errors?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 是否存在系统性误差？
- en: 'If the smoothing curve veers off the line of perfect prediction too much, as
    in [figure 7.8](../Text/07.xhtml#ch07fig08), this is a sign of systematic under-
    or overprediction in certain ranges: the error is correlated with the prediction.
    Systematic errors indicate that the system is not “linear enough” for a linear
    model to be a good fit, so you should try one of the different modeling approaches
    that we will discuss later in this book.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果平滑曲线过多地偏离了完美预测的直线，如[图7.8](../Text/07.xhtml#ch07fig08)所示，这表明在特定范围内存在系统性的低估或高估：误差与预测相关。系统性误差表明系统“线性程度”不够，线性模型不适合，因此你应该尝试本书后面将要讨论的不同建模方法之一。
- en: Figure 7.8\. An example of systematic errors in model predictions
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8\. 模型预测中的系统性误差示例
- en: '![](Images/07fig08_alt.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig08_alt.jpg)'
- en: R-squared and RMSE
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: R-squared和RMSE
- en: In addition to inspecting graphs, you should produce quantitative summaries
    of the quality of the predictions and the residuals. One standard measure of quality
    of a prediction is called *R-squared*, which we covered in [section 6.2.4](../Text/06.xhtml#ch06lev2sec8).
    R-squared is a measure of how well the model “fits” the data, or its “goodness
    of fit.” You can compute the R-squared between the prediction and the actual `y`
    with the R steps in the following listing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了检查图表外，你还应该对预测质量和残差进行定量总结。衡量预测质量的一个标准指标称为*R-squared*，我们在[第6.2.4节](../Text/06.xhtml#ch06lev2sec8)中讨论过。R-squared是衡量模型“拟合”数据程度或其“拟合优度”的指标。你可以使用以下列表中的R步骤计算预测和实际`y`之间的R-squared。
- en: Listing 7.4\. Computing R-squared
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.4\. 计算R-squared
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ R-squared of the model on the training data
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 训练数据上的模型R-squared
- en: ❷ R-squared of the model on the test data
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 测试数据上的模型R-squared
- en: R-squared can be thought of as what fraction of the `y` variation is explained
    by the model. You want R-squared to be fairly large (1.0 is the largest you can
    achieve) and R-squareds that are similar on test and training. A significantly
    lower R-squared on test data is a symptom of an overfit model that looks good
    in training and won’t work in production. In this case, the R-squareds were about
    0.3 for both the training and test data. We’d like to see R-squareds higher than
    this (say, 0.7–1.0). So the model is of low quality, but not overfit.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: R-squared可以理解为`y`变化的多少部分是由模型解释的。你希望R-squared相当大（1.0是你可以达到的最大值）并且测试和训练数据上的R-squared相似。测试数据上的R-squared显著低于这是过度拟合模型的症状，这种模型在训练中看起来很好，但在生产中却不起作用。在这种情况下，训练和测试数据的R-squared大约都是0.3。我们希望看到高于这个值（比如，0.7–1.0）。所以模型质量低，但不是过度拟合。
- en: For well-fit models, R-squared is also equal to the square of the correlation
    between the predicted values and actual training values.^([[1](../Text/07.xhtml#ch07fn5)])
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于拟合良好的模型，R-squared也等于预测值与实际训练值之间的相关性的平方.^([[1](../Text/07.xhtml#ch07fn5)])
- en: ¹
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See [http://www.win-vector.com/blog/2011/11/correlation-and-r-squared/](http://www.win-vector.com/blog/2011/11/correlation-and-r-squared/).
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 查看[http://www.win-vector.com/blog/2011/11/correlation-and-r-squared/](http://www.win-vector.com/blog/2011/11/correlation-and-r-squared/)。
- en: '* * *'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**R-squared can be overoptimistic**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**R-squared可能过于乐观**'
- en: In general, R-squared on training data will be higher for models with more input
    parameters, independent of whether the additional variables actually improve the
    model or not. That’s why many people prefer the adjusted R-squared (which we’ll
    discuss later in this chapter).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，训练数据上的R-squared对于具有更多输入参数的模型会更高，无论这些额外变量是否真正改善了模型。这就是为什么许多人更喜欢调整后的R-squared（我们将在本章后面讨论）。
- en: Also, R-squared is related to correlation, and the correlation can be artificially
    inflated if the model correctly predicts a few outliers. This is because the increased
    data range makes the overall data cloud appear “tighter” against the line of perfect
    prediction. Here’s a toy example. Let `y <- c(1,2,3,4,5,9,10)` and `pred <- c(0.5,0.5,0.5,
    0.5,0.5,9,10)`. This corresponds to a model that’s completely uncorrelated to
    the true outcome for the first five points, and perfectly predicts the last two
    points, which are somewhat far away from the first five. You can check for yourself
    that this obviously poor model has a correlation `cor(y, pred)` of about 0.926,
    with a corresponding R-squared of 0.858\. So it’s an excellent idea to look at
    the true-versus-fitted graph on test data, in addition to checking R-squared.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，R-squared与相关系数有关，如果模型正确预测了几个异常值，相关系数可能会被人为地夸大。这是因为增加的数据范围使得整体数据云相对于完美预测线看起来“更紧密”。以下是一个玩具示例。设`y
    <- c(1,2,3,4,5,9,10)`和`pred <- c(0.5,0.5,0.5, 0.5,0.5,9,10)`。这对应于一个模型，对于前五个点与真实结果完全不相关，并且完美预测了最后两个点，这两个点与前面的五个点有些距离。你可以自己检查这个明显较差的模型具有约0.926的相关系数`cor(y,
    pred)`，相应的R-squared为0.858。因此，在检查R-squared的同时，查看测试数据的真实值与拟合值图是一个很好的想法。
- en: '* * *'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Another good measure to consider is *root mean square error* (RMSE ).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得考虑的良好度量是*均方根误差*（RMSE）。
- en: Listing 7.5\. Calculating root mean square error
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5\. 计算均方根误差
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ RMSE of the model on the training data
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 模型在训练数据上的均方根误差（RMSE）
- en: ❷ RMSE of the model on the test data
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 模型在测试数据上的均方根误差（RMSE）
- en: You can think of the RMSE as a measure of the width of the data cloud around
    the line of perfect prediction. We’d like RMSE to be small, and one way to achieve
    this is to introduce more useful, explanatory variables.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将RMSE视为围绕完美预测线的数据云宽度的度量。我们希望RMSE尽可能小，实现这一目标的一种方法就是引入更多有用、解释性的变量。
- en: 7.1.4\. Finding relations and extracting advice
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.4\. 寻找关系和提取建议
- en: Recall that your other goal, beyond predicting income, is to find the value
    of having a bachelor’s degree. We’ll show how this value, and other relations
    in the data, can be read directly off a linear regression model.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你的另一个目标，除了预测收入之外，是找到拥有学士学位的价值。我们将展示如何直接从线性回归模型中读取这个价值以及其他数据中的关系。
- en: All the information in a linear regression model is stored in a block of numbers
    called the *coefficients*. The coefficients are available through the `coefficients(model)`
    function. The coefficients of our income model are shown in [figure 7.9](../Text/07.xhtml#ch07fig09).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归模型中的所有信息都存储在一个称为*系数*的数字块中。系数可以通过`coefficients(model)`函数获得。我们的收入模型的系数在[图7.9](../Text/07.xhtml#ch07fig09)中显示。
- en: Figure 7.9\. The model coefficients
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9\. 模型系数
- en: '![](Images/07fig09_alt.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig09_alt.jpg)'
- en: Reported coefficients
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 报告的系数
- en: Our original modeling variables were only `AGEP`, `SEX`, `COW` (class of work),
    and `SCHL` (schooling/education); yet the model reports many more coefficients
    than these four. We’ll explain what all the reported coefficients are.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们原始的建模变量只有`AGEP`、`SEX`、`COW`（工作类别）和`SCHL`（教育/学历）；然而，模型报告的系数比这四个还要多。我们将解释所有报告的系数是什么。
- en: 'In [figure 7.9](../Text/07.xhtml#ch07fig09), there are eight coefficients that
    start with `SCHL`. The original variable `SCHL` took on these eight string values
    plus one more not shown: `no high school diploma`. Each of these possible strings
    is called a *level*, and `SCHL` itself is called a *categorical* or *factor* variable.
    The level that isn’t shown is called the *reference level*; the coefficients of
    the other levels are measured with respect to the reference level.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图7.9](../Text/07.xhtml#ch07fig09)中，有八个以`SCHL`开头的系数。原始变量`SCHL`取了这八个字符串值以及一个未显示的值：`no
    high school diploma`。每个可能的字符串被称为*水平*，而`SCHL`本身被称为*分类*或*因子*变量。未显示的水平被称为*参考水平*；其他水平的系数是以参考水平为基准测量的。
- en: 'For example, in `SCHLBachelor''s degree` we find the coefficient 0.36, which
    is read as “The model gives a 0.36 bonus to log base 10 income for having a bachelor’s
    degree, relative to not having a high school degree.” You can solve for the income
    ratio between someone with a bachelor’s degree and the equivalent person (same
    sex, age, and class of work) without a high school degree as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`SCHLBachelor's degree`中，我们找到了系数0.36，这可以读作“模型为拥有学士学位相对于没有高中文凭的10对数收入提供了0.36的额外奖励。”你可以通过以下方式求解拥有学士学位的人与同等学历（相同性别、年龄和工作类别）但没有高中文凭的人之间的收入比率：
- en: '[PRE9]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This means that someone with a bachelor’s degree will tend to have an income
    about `10^0.36`, or 2.29 times higher than the equivalent person without a high
    school degree.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，拥有学士学位的人的收入将倾向于是 `10^0.36`，或者说比没有高中文凭的同等人员高出2.29倍。
- en: And under `SCHLRegular high school diploma`, we find the coefficient 0.11\.
    This is read as “The model believes that having a bachelor’s degree tends to add
    0.36–0.11 units to the predicted log income, relative to having a high school
    degree.”
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SCHLRegular high school diploma` 下，我们发现系数为0.11。这可以理解为“模型认为，相对于拥有高中文凭，拥有学士学位往往会使预测的对数收入增加0.36-0.11个单位。”
- en: '[PRE10]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Subtracts the second equation from the first
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从第二个方程中减去第一个方程
- en: 'The modeled relation between the bachelor’s degree holder’s expected income
    and the high school graduate’s (all other variables being equal) is `10^(0.36
    - 0.11)`, or about 1.8 times greater. The advice: college is worth it if you can
    find a job (remember that we limited the analysis to the fully employed, so this
    is assuming you can find a job).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本科毕业生预期收入与高中毕业生（其他变量相等）之间的模型关系是 `10^(0.36 - 0.11)`，或者说大约高1.8倍。建议：如果你能找到工作，上大学是值得的（记住，我们只分析了完全就业的情况，所以这是假设你能找到工作）。
- en: '`SEX` and `COW` are also discrete variables, with reference levels `Male` and
    `Employee of a private for profit` [company], respectively. The coefficients that
    correspond to the different levels of `SEX` and `COW` can be interpreted in a
    manner similar to the education level. `AGEP` is a continuous variable with coefficient
    0.0116\. You can interpret this as saying that a one-year increase in age adds
    a 0.0116 bonus to log income; in other words, an increase in age of one year corresponds
    to an increase of income of `10^0.0116`, or a factor of 1.027—about a 2.7% increase
    in income (all other variables being equal).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEX` 和 `COW` 也是离散变量，分别以 `Male` 和 `私人营利性公司员工` [公司] 为参考水平。对应于 `SEX` 和 `COW`
    不同水平的系数可以以与教育水平相似的方式解释。`AGEP` 是一个系数为 0.0116 的连续变量。你可以将其解释为：年龄增加一年，对对数收入的增加贡献了
    0.0116 的额外值；换句话说，年龄增加一年相当于收入增加 `10^0.0116`，即增加了1.027倍——大约是收入的2.7%增加（其他变量相等）。'
- en: The coefficient `(Intercept)` corresponds to a variable that always has a value
    of `1`, which is implicitly added to linear regression models unless you use the
    special `0+` notation in the formula during the call to `lm()`. One way to interpret
    the intercept is to think of it as “the prediction for the reference subject”—that
    is, the subject who takes on the values of all the reference levels for the categorical
    inputs, and zero for the continuous variables. Note that this may not be a physically
    plausible subject.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 系数 `(Intercept)` 对应于一个始终具有值为 `1` 的变量，这个变量在调用 `lm()` 函数时默认添加到线性回归模型中，除非你在公式调用中使用特殊的
    `0+` 符号。解释截距的一种方式是将其视为“参考主体的预测”——也就是说，这个主体承担了所有分类输入的参考水平值，对于连续变量为零。请注意，这可能不是一个在物理上合理的主体。
- en: In our example, the reference subject would be a male employee of a private
    for-profit company, with no high school degree, who is zero years old. If such
    a person could exist, the model would predict their log base 10 income to be about
    4.0, which corresponds to an income of $10,000.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，参考主体将是一个没有高中文凭、年龄为零的男性私人营利性公司员工。如果这样的人存在，模型将预测他们的以10为底的对数收入约为4.0，这对应于1万美元的收入。
- en: '* * *'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Indicator variables**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**指标变量**'
- en: 'Most modeling methods handle a string-valued (categorical) variable with *n*
    possible levels by converting it to *n* (or *n*-1) binary variables, or *indicator
    variables*. R has commands to explicitly control the conversion of string-valued
    variables into well-behaved indicators: `as.factor()` creates categorical variables
    from string variables; `relevel()` allows the user to specify the reference level.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数建模方法通过将其转换为 *n*（或 *n*-1）个二元变量，或指标变量来处理具有 *n* 个可能水平的字符串值（分类）变量。R 有命令可以显式控制将字符串值变量转换为表现良好的指标变量：`as.factor()`
    从字符串变量创建分类变量；`relevel()` 允许用户指定参考水平。
- en: But beware of variables with a very large number of levels, like ZIP codes.
    The runtime of linear (and logistic) regression increases as roughly the cube
    of the number of coefficients. Too many levels (or too many variables in general)
    will bog the algorithm down and require much more data for reliable inference.
    In [chapter 8](../Text/08.xhtml#ch08), we will discuss methods for dealing with
    such high cardinality variables, such as effects coding or impact coding.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但要注意那些具有非常多的水平变量的情况，例如邮政编码。线性（和逻辑）回归的运行时间大致与系数数量的立方成正比。太多的水平（或太多的变量）将使算法变得缓慢，并需要更多的数据来进行可靠的推断。在第8章[第8章](../Text/08.xhtml#ch08)中，我们将讨论处理此类高基数变量的方法，例如效果编码或影响编码。
- en: '* * *'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The preceding interpretations of the coefficients assume that the model has
    provided good estimates of the coefficients. We’ll see how to check that in the
    next section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 之前对系数的解释假设模型已经提供了良好的系数估计。我们将在下一节中看到如何检查这一点。
- en: 7.1.5\. Reading the model summary and characterizing coefficient quality
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.5. 阅读模型摘要和描述系数质量
- en: In [section 7.1.3](../Text/07.xhtml#ch07lev2sec3), we checked whether our income
    predictions were to be trusted. We’ll now show how to check whether model coefficients
    are reliable. This is especially important, as we’ve been discussing showing coefficients’
    relations to others as advice.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7.1.3节](../Text/07.xhtml#ch07lev2sec3)中，我们检查了我们的收入预测是否值得信赖。现在我们将展示如何检查模型系数是否可靠。这尤其重要，因为我们一直在讨论展示系数与其他系数的关系作为建议。
- en: 'Most of what we need to know is already in the model summary, which is produced
    using the `summary()` command: `summary(model)`. This produces the output shown
    in [figure 7.10](../Text/07.xhtml#ch07fig10).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要了解的大部分信息已经在模型摘要中，该摘要是通过`summary()`命令生成的：`summary(model)`。这产生了[图7.10](../Text/07.xhtml#ch07fig10)所示的输出。
- en: Figure 7.10\. Model summary
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10. 模型摘要
- en: '![](Images/07fig10_alt.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig10_alt.jpg)'
- en: This figure looks intimidating, but it contains a lot of useful information
    and diagnostics. You’re likely to be asked about elements of [figure 7.10](../Text/07.xhtml#ch07fig10)
    when presenting results, so we’ll demonstrate how all of these fields are derived
    and what the fields mean.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图看起来可能有些吓人，但它包含了很多有用的信息和诊断信息。当你展示结果时，你可能会被问到[图7.10](../Text/07.xhtml#ch07fig10)中的元素，所以我们将演示所有这些字段是如何得出的以及这些字段的意义。
- en: We’ll first break down the `summary()` into pieces.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将`summary()`分解成几个部分。
- en: The original model call
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 原始模型调用
- en: 'The first part of the `summary()` is how the `lm()` model was constructed:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`summary()`的第一部分是`lm()`模型的构建方式：'
- en: '[PRE11]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is a good place to double-check whether you used the correct data frame,
    performed your intended transformations, and used the right variables. For example,
    you can double-check whether you used the data frame `dtrain` and not the data
    frame `dtest`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个双重检查你是否使用了正确的数据框、执行了预期的转换以及使用了正确变量的好地方。例如，你可以再次检查你是否使用了数据框`dtrain`而不是数据框`dtest`。
- en: The residuals summary
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 残差摘要
- en: 'The next part of the `summary()` is the residuals summary:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`summary()`的下一部分是残差摘要：'
- en: '[PRE12]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Recall that the residuals are the errors in prediction: `log10(dtrain$PINCP)
    - predict (model,newdata=dtrain)`. In linear regression, the residuals are everything.
    Most of what you want to know about the quality of your model fit is in the residuals.
    You can calculate useful summaries of the residuals for both the training and
    test sets, as shown in the following listing.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，残差是预测中的误差：`log10(dtrain$PINCP) - predict (model,newdata=dtrain)`。在线性回归中，残差是所有内容。你想要了解的关于模型拟合质量的大部分信息都在残差中。你可以计算训练集和测试集的残差的有用摘要，如下所示。
- en: Listing 7.6\. Summarizing residuals
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.6. 残差摘要
- en: '[PRE13]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In linear regression, the coefficients are chosen to minimize the sum of squares
    of the residuals. This is why the method is also often called the *least squares
    method*. So for good models, you expect the residuals to be small.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在线性回归中，系数被选择以最小化残差的平方和。这也是为什么这种方法也经常被称为*最小二乘法*。因此，对于好的模型，你期望残差很小。
- en: 'In the residual summary, you’re given the `Min.` and `Max.`, which are the
    smallest and largest residuals seen. You’re also given the quartiles of the residuals:
    `1st. Qu.`, or the value that upper bounds the first 25% of the data; the `Median`,
    or the value that upper bounds the first 50% of the data; and `3rd Qu.`, or the
    value that upper bounds the first 75% of the data (the `Max` is the 4th quartile:
    the value that upper bounds 100% of the data). The quartiles give you a rough
    idea of the data’s distribution.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在残差摘要中，你得到了 `Min.` 和 `Max.`，这是所见到的最小和最大残差。你还得到了残差的四分位数：`1st. Qu.`，或上界于数据前 25%
    的值；`Median`，或上界于数据前 50% 的值；以及 `3rd Qu.`，或上界于数据前 75% 的值（`Max` 是第四四分位数：上界于 100%
    的数据的值）。四分位数给你一个关于数据分布的大致概念。
- en: What you hope to see in the residual summary is that the median is near 0 (as
    it is in our example), and that the `1st. Qu.` and the `3rd Qu.` are roughly equidistant
    from the median (with neither too large). In our example, the `1st. Qu.` and `3rd
    Qu.` of the training residuals (`resids_train`) are both about 0.15 from the median.
    They are slightly less symmetric for the test residuals (0.16 and 0.15 from the
    median), but still within bounds.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望在残差摘要中看到的是中位数接近 0（如我们的示例所示），以及 `1st. Qu.` 和 `3rd Qu.` 大约与中位数等距（两者都不太大）。在我们的例子中，训练残差（`resids_train`）的
    `1st. Qu.` 和 `3rd Qu.` 都大约离中位数 0.15。测试残差（0.16 和 0.15 离中位数）稍微不对称，但仍在范围内。
- en: The `1st. Qu.` and `3rd Qu.` quantiles are interesting because exactly half
    of the training data has a residual in this range. In our example, if you drew
    a random training datum, its residual would be in the range –0.1354 to 0.1710
    exactly half the time. So you really expect to commonly see prediction errors
    of these magnitudes. If these errors are too big for your application, you don’t
    have a usable model.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`1st. Qu.` 和 `3rd Qu.` 的四分位数很有趣，因为正好有一半的训练数据在这个范围内有残差。在我们的例子中，如果你随机抽取一个训练数据，其残差有
    50% 的时间会在 –0.1354 到 0.1710 的范围内。所以你实际上期望经常看到这种规模的预测误差。如果这些误差对于你的应用来说太大，那么你没有一个可用的模型。'
- en: The coefficients table
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 系数表
- en: The next part of the `summary(model)` is the coefficients table, as shown in
    [figure 7.11](../Text/07.xhtml#ch07fig11). A matrix form of this table can be
    retrieved as `summary(model)$coefficients`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`summary(model)` 的下一部分是系数表，如图 7.11 所示。此表的矩阵形式可以通过 `summary(model)$coefficients`
    获取。'
- en: Figure 7.11\. Model summary coefficient columns
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11\. 模型摘要系数列
- en: '![](Images/07fig11_alt.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig11_alt.jpg)'
- en: Each model coefficient forms a row of the summary coefficients table. The columns
    report the estimated coefficient, the uncertainty of the estimate, how large the
    coefficient is relative to the uncertainty, and how likely such a ratio would
    be due to mere chance. [Figure 7.11](../Text/07.xhtml#ch07fig11) gives the names
    and interpretations of the columns.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模型系数形成系数摘要表的行。列报告估计系数、估计的不确定性、系数相对于不确定性的大小以及这种比率仅由于偶然性而可能出现的可能性。[图 7.11](../Text/07.xhtml#ch07fig11)
    给出了列的名称和解释。
- en: You set out to study income and the impact that getting a bachelor’s degree
    has on income. But you must look at all the coefficients to check for interfering
    effects.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始研究收入以及获得学士学位对收入的影响。但你必须查看所有系数以检查是否存在干扰效应。
- en: 'For example, the coefficient of –0.108 for `SEXF` means that your model learned
    a penalty of –0.108 to `log10(PINCP)` for being female. The ratio of female income
    to male income is modeled to be `10^(-0.108)`: women earn 78% of what men earn,
    all other model parameters being equal. Note we said “all other model parameters
    being equal” not “all other things being equal.” That’s because we’re not modeling
    the number of years in the workforce (which age may not be a reliable proxy for)
    or occupation/industry type (which has a big impact on income). This model is
    not, with the features it was given, capable of testing if, on average, a female
    in the same job with the same number of years of experience is paid less.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`SEXF` 的系数为 –0.108 表示你的模型学会了为女性对 `log10(PINCP)` 施加 –0.108 的惩罚。女性收入与男性收入的比率被建模为
    `10^(-0.108)`：女性的收入是男性的 78%，在其他模型参数相等的情况下。注意我们说的是“其他模型参数相等”，而不是“其他所有事物相等。”这是因为我们不是在建模工作年限（年龄可能不是一个可靠的代理）或职业/行业类型（这对收入有重大影响）。这个模型，在它被赋予的特征下，无法测试平均而言，一个与男性在相同职位且具有相同工作经验的女性是否会被支付更少。
- en: '* * *'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Insignificant coefficients**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**不显著的系数**'
- en: Notice in [figure 7.11](../Text/07.xhtml#ch07fig11) the coefficient `COWSelf
    employed incorporated` is “not significant.” This means there is not enough evidence
    with respect to this model design to determine if the coefficient is non-zero.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在[图7.11](../Text/07.xhtml#ch07fig11)中，系数`COWSelf employed incorporated`是“不显著的”。这意味着对于这个模型设计来说，没有足够的证据来确定系数是否为零。
- en: Some recommend stepwise regression to remove such variables, or add a useful
    inductive bias of the form, “If we can’t tell it is non-zero, force it to zero.”
    In this case, this wouldn’t be convenient as the variable is just a level of a
    categorical variable (so it’s a bit harder to treat independently). We do not
    recommend stepwise regression, as stepwise regression introduces *multiple comparison*
    problems that bias the estimates of the remaining coefficients.^([[a](../Text/07.xhtml#ch07fn6a)])
    We recommend either living with the non-significant estimates (as even replacing
    them with zero is still trading one uncertain estimate for another), or prefiltering
    the variables for utility, or regularized methods (such as `glmnet`/lasso). All
    of these ideas are covered throughout this book.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一些推荐逐步回归来移除这样的变量，或者添加一种有用的归纳偏差，形式为：“如果我们不能判断它是非零的，就强制它为零。”在这种情况下，这并不方便，因为变量只是一个分类变量的水平（因此，独立处理它有点困难）。我们不推荐逐步回归，因为逐步回归会引入*多重比较*问题，这会偏颇剩余系数的估计。[^a](../Text/07.xhtml#ch07fn6a)我们建议接受非显著的估计（因为即使将它们替换为零，也是在用一个不确定的估计替换另一个），或者预先过滤变量以供使用，或者使用正则化方法（如`glmnet`/lasso）。本书中涵盖了所有这些想法。
- en: ^a
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See Robert Tibshirani, “Regression shrinkage and selection via the lasso.”
    *Journal of the Royal Statistical Society*, Series B 58: 267–288, 1996.'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参见Robert Tibshirani，“通过lasso进行回归收缩和选择。”*皇家统计学会杂志*，第58卷：267–288，1996年。
- en: 'A point to remember: in terms of prediction (our primary goal), it’s not a
    problem to have a small number of insignificant coefficients with small effects
    sizes. Problems arise when we have insignificant coefficients with large coefficients/effects
    or a great number of insignificant coefficients.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要记住的点：在预测（我们的主要目标）方面，拥有少量影响较小的无关系数并不是问题。问题出现在我们拥有影响较小的系数但系数/效应较大，或者有大量无关系数的情况下。
- en: '* * *'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '* * *'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Statistics as an attempt to correct bad experimental design**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**统计学作为纠正不良实验设计的尝试**'
- en: 'The absolute best experiment to test if there’s a sex-driven difference in
    income distribution would be to compare incomes of individuals who were identical
    in all possible variables (age, education, years in industry, performance reviews,
    race, region, and so on) but differ only in sex. We’re unlikely to have access
    to such data, so we’d settle for a good experimental design: a population where
    there’s no correlation between any other feature and sex. Random selection can
    help in experimental design, but it’s not a complete panacea. Barring a good experimental
    design, the usual pragmatic strategy is this: introduce extra variables to represent
    effects that may have been interfering with the effect we were trying to study.
    Thus a study of the effect of sex on income may include other variables like education
    and age to try to disentangle the competing effects.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是否存在性别驱动的收入分布差异的绝对最佳实验是将所有可能变量（年龄、教育、行业年数、绩效评估、种族、地区等）都相同但性别不同的个人的收入进行比较。我们不太可能获得这样的数据，所以我们只能满足于一个好的实验设计：一个没有其他特征与性别相关的总体。随机选择可以帮助实验设计，但它并不是万能的。如果没有一个好的实验设计，通常的实用策略是这样的：引入额外的变量来表示可能干扰我们试图研究的效应的效应。因此，研究性别对收入的影响可能包括其他变量，如教育水平和年龄，以尝试解开相互竞争的效应。
- en: '* * *'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The p-value and significance
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: p值和显著性
- en: The *p-value* (also called the *significance*) is one of the most important
    diagnostic columns in the coefficient summary. The p-value estimates the probability
    of seeing a coefficient with a magnitude as large as you observed if the true
    coefficient is really zero (if the variable has no effect on the outcome). So
    don’t trust the estimate of any coefficient with a large p-value. Generally, people
    pick a threshold, and call all the coefficients with a p-value below that threshold
    *statistically significant*, meaning that those coefficients are likely not zero.
    A common threshold is *p* < 0.05; however, this is an arbitrary level.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*p值*（也称为*显著性*）是系数摘要中最重要的一列诊断信息。p值估计在真实系数实际上为零的情况下（如果变量对结果没有影响）观察到与观察到的系数大小一样大的概率。因此，不要信任任何具有大p值的系数的估计。通常，人们会选择一个阈值，并将所有p值低于该阈值的系数称为*统计显著*，这意味着这些系数很可能不是零。一个常见的阈值是*p*
    < 0.05；然而，这是一个任意水平。'
- en: Note that lower p-values aren’t always “better” once they’re good enough. There’s
    no reason to prefer a coefficient with a p-value of 1e-23 to one with a p-value
    of 1e-08 as long as both p-values are below your chosen threshold; at this point,
    you know both coefficients are likely good estimates and you should prefer the
    ones that explain the most variance. Also note that high p-values don’t always
    tell you which of the coefficients are bad, as we discuss in the sidebar.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦足够好，较低的p值并不总是“更好”。只要两个p值都低于你选择的阈值，就没有理由偏好一个p值为1e-23的系数而不是一个p值为1e-08的系数；在这个点上，你知道两个系数都可能是良好的估计，你应该偏好那些解释最多变异的系数。此外，注意高p值并不总是告诉我们哪些系数是坏的，正如我们在侧边栏中讨论的那样。
- en: '* * *'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Collinearity also lowers significance**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**共线性也会降低显著性**'
- en: Sometimes, a predictive variable won’t appear significant because it’s collinear
    (or correlated) with another predictive variable. For example, if you did try
    to use both age and number of years in the workforce to predict income, neither
    variable may appear significant. This is because age tends to be correlated with
    number of years in the workforce. If you remove one of the variables and the other
    one gains significance, this is a good indicator of correlation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个预测变量可能不会显得显著，因为它与另一个预测变量共线性（或相关）。例如，如果你尝试使用年龄和在职年数来预测收入，两个变量可能都不会显得显著。这是因为年龄往往与在职年数相关。如果你移除其中一个变量，另一个变量变得显著，这是一个很好的相关性指标。
- en: If you see coefficients that seem unreasonably large (often of opposite signs),
    or unusually large standard errors on the coefficients, that may indicate collinear
    variables.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到看起来不合理大的系数（通常是相反的符号），或者系数的异常大的标准误差，这可能表明存在共线性变量。
- en: 'Another possible indication of collinearity in the inputs is seeing coefficients
    with an unexpected sign: for example, seeing that income is *negatively* correlated
    with years in the workforce.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 输入中存在共线性的另一个可能迹象是看到具有意外符号的系数：例如，看到收入与在职年数呈*负相关*。
- en: The overall model can still predict income quite well, even when the inputs
    are correlated; it just can’t determine which variable deserves the credit for
    the prediction.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 整体模型即使在输入相关的情况下仍然可以很好地预测收入，但它无法确定哪个变量应该得到预测的功劳。
- en: Using regularization can be helpful in collinear situations, as we will discuss
    in [section 7.3](../Text/07.xhtml#ch07lev1sec3). Regularization prefers small
    coefficients, which can be less hazardous when used on new data.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7.3节](../Text/07.xhtml#ch07lev1sec3)中我们将讨论，使用正则化在共线性情况下可能会有所帮助。正则化偏好较小的系数，当用于新数据时可能风险较低。
- en: If you want to use the coefficient values as advice as well as to make good
    predictions, try to avoid collinearity in the inputs as much as possible.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望将系数值用作建议以及做出良好的预测，尽量在输入中避免共线性。
- en: '* * *'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Overall model quality summaries
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 整体模型质量摘要
- en: 'The last part of the `summary(model)` report is the overall model quality statistics.
    It’s a good idea to check the overall model quality before sharing any predictions
    or coefficients. The summaries are as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`summary(model)`报告的最后部分是整体模型质量统计。在分享任何预测或系数之前检查整体模型质量是个好主意。摘要如下：'
- en: '[PRE14]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let’s explain each of the summaries in a little more detail.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释每个摘要。
- en: Degrees of freedom
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 自由度
- en: 'The *degrees of freedom* is the number of data rows minus the number of coefficients
    fit, in our case, this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*自由度*是数据行数减去拟合的系数数，在我们的例子中，是这样的：'
- en: '[PRE15]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The degrees of freedom is the number of training data rows you have after correcting
    for the number of coefficients you tried to solve for. You want the number of
    datums in the training set to be large compared to the number of coefficients
    you are solving for; in other words, you want the degrees of freedom to be high.
    A low degree of freedom indicates that the model you are trying to fit is too
    complex for the amount of data that you have, and your model is likely to be overfit.
    Overfitting is when you find chance relations in your training data that aren’t
    present in the general population. Overfitting is bad: you think you have a good
    model when you don’t.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 自由度是在纠正了你试图解决的系数数量之后，你拥有的训练数据行数。你希望训练集中的数据点数量与你要解决的系数数量相比要大；换句话说，你希望自由度要高。自由度低表明你试图拟合的模型对于你拥有的数据量来说过于复杂，并且你的模型很可能是过拟合的。过拟合是指你在训练数据中发现了在总体中不存在的偶然关系。过拟合是件坏事：当你没有好模型时，你却以为你有。
- en: Residual standard error
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 残差标准误差
- en: 'The *residual standard error* is the sum of the square of the residuals (or
    the sum of squared error) divided by the degrees of freedom. So it’s similar to
    the RMSE (root mean squared error) that we discussed earlier, except with the
    number of data rows adjusted to be the degrees of freedom; in R, this is calculated
    as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*残差标准误差* 是残差平方和（或平方误差之和）除以自由度的结果。因此，它与我们在前面讨论过的RMSE（均方根误差）类似，只是调整了数据行数以匹配自由度；在R中，这可以这样计算：'
- en: '[PRE16]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The residual standard error is a more conservative estimate of model performance
    than the RMSE, because it’s adjusted for the complexity of the model (the degrees
    of freedom is less than the number of rows of training data, so the residual standard
    error is larger than the RMSE). Again, this tries to compensate for the fact that
    more-complex models have a higher tendency to overfit the data.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 残差标准误差比RMSE对模型性能的估计更保守，因为它调整了模型的复杂性（自由度小于训练数据行数，因此残差标准误差大于RMSE）。再次强调，这试图弥补更复杂的模型有更高的过拟合数据的倾向。
- en: '* * *'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Degrees of freedom on test data**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试数据上的自由度**'
- en: On test data (data not used during training), the degrees of freedom equal the
    number of rows of data. This differs from the case of training data, where, as
    we have said, the degrees of freedom equal the number of rows of data minus the
    number of parameters of the model.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试数据（在训练过程中未使用的数据）上，自由度等于数据行数。这与训练数据的情况不同，正如我们所说的，在训练数据的情况下，自由度等于数据行数减去模型的参数数量。
- en: The difference arises from the fact that model training “peeks at” the training
    data, but not the test data.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 差异产生的原因在于模型训练“窥视”的是训练数据，而不是测试数据。
- en: '* * *'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Multiple and adjusted R-squared
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 多元和调整后的R-squared
- en: '*Multiple R-squared* is just the R-squared of the model on the training data
    (discussed in [section 7.1.3](../Text/07.xhtml#ch07lev2sec3)).'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*多元R-squared* 只是模型在训练数据上的R-squared（在[7.1.3节](../Text/07.xhtml#ch07lev2sec3)中讨论）。'
- en: The *adjusted R-squared* is the multiple R-squared penalized for the number
    of input variables. The reason for this penalty is that, in general, increasing
    the number of input variables will improve the R-squared on the training data,
    even if the added variables aren’t actually informative. This is another way of
    saying that more-complex models tend to look better on training data due to overfitting,
    so the adjusted R-squared is a more conservative estimate of the model’s goodness
    of fit.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*调整后的R-squared* 是对输入变量数量进行惩罚的多个R-squared。这种惩罚的原因是，通常情况下，增加输入变量的数量会提高训练数据上的R-squared，即使添加的变量实际上并不具有信息性。这另一种说法是，更复杂的模型由于过拟合，往往在训练数据上看起来更好，因此调整后的R-squared是对模型拟合优度的一个更保守的估计。'
- en: If you do not have test data, it’s a good idea to rely on the adjusted R-squared
    when evaluating your model. But it’s even better to compute the R-squared between
    predictions and actuals on holdout test data. In [section 7.1.3](../Text/07.xhtml#ch07lev2sec3),
    we showed the R-squared on test data was 0.29, which in this case is about the
    same as the reported adjusted R-squared of 0.3\. However, we still advise preparing
    both training and test datasets; the test dataset estimates can be more representative
    of production model performance than statistical formulas.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有测试数据，在评估你的模型时依赖调整后的R平方是一个好主意。但更好的是，在保留的测试数据上计算预测值和实际值之间的R平方。在[7.1.3节](../Text/07.xhtml#ch07lev2sec3)中，我们展示了测试数据上的R平方为0.29，在这种情况下，它与报告的调整后的R平方0.3大致相同。然而，我们仍然建议准备训练集和测试集；测试集的估计可能比统计公式更能代表生产模型的表现。
- en: The F-statistic and its p-value
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: F统计量和它的p值
- en: 'The *F-statistic* is similar to the t-values for coefficients that you saw
    earlier in [figure 7.11](../Text/07.xhtml#ch07fig11). Just as the t-values are
    used to calculate p-values on the coefficients, the F-statistic is used to calculate
    a p-value on the model fit. It gets its name from the F-test, which is the technique
    used to check if two variances—in this case, the variance of the residuals from
    the constant model and the variance of the residuals from the linear model—are
    significantly different. The corresponding p-value is the estimate of the probability
    that we would’ve observed an F-statistic this large or larger if the two variances
    in question were in reality the same. So you want the p-value to be small (a common
    threshold: less that 0.05).'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*F统计量*与你在[图7.11](../Text/07.xhtml#ch07fig11)中看到的系数的t值类似。正如t值用于计算系数的p值一样，F统计量用于计算模型拟合的p值。它得名于F检验，这是一种检查两个方差（在这种情况下，常数模型的残差方差和线性模型的残差方差）是否显著不同的技术。相应的p值是在假设所讨论的两个方差实际上相同的情况下，我们观察到如此大的或更大的F统计量的概率估计。因此，你希望p值很小（一个常见的阈值：小于0.05）。'
- en: 'In our example, the F-statistic p-value is quite small (< 2.2e-16): the model
    explains more variance than the constant model does, and the improvement is incredibly
    unlikely to have arisen only from sampling error.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，F统计量的p值非常小（< 2.2e-16）：该模型解释的方差比常数模型更多，而且这种改进不太可能仅仅来自抽样误差。
- en: '* * *'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Interpreting model significances
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 解释模型的重要性
- en: Most of the tests of linear regression, including the tests for coefficient
    and model significance, are based on the assumption that the error terms or residuals
    are normally distributed. It’s important to examine graphically or use quantile
    analysis to determine if the regression model is appropriate.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数线性回归的测试，包括系数和模型重要性的测试，都是基于误差项或残差呈正态分布的假设。重要的是要通过图形分析或使用分位数分析来确定回归模型是否合适。
- en: '* * *'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 7.1.6\. Linear regression takeaways
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.6. 线性回归要点
- en: 'Linear regression is the go-to statistical modeling method for predicting quantities.
    It is simple and has the advantage that the coefficients of the model can often
    function as advice. Here are a few points you should remember about linear regression:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归是预测数量时首选的统计建模方法。它简单且具有优势，即模型的系数通常可以充当建议。以下是关于线性回归你应该记住的几个要点：
- en: Linear regression assumes that the outcome is a linear combination of the input
    variables. Naturally, it works best when that assumption is nearly true, but it
    can predict surprisingly well even when it isn’t.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性回归假设结果是输入变量的线性组合。自然地，当这个假设几乎成立时，它效果最好，但即使它不成立，它也能出人意料地预测得很好。
- en: If you want to use the coefficients of your model for advice, you should only
    trust the coefficients that appear statistically significant.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要使用你模型的系数作为建议，你应该只信任那些在统计上显著的系数。
- en: Overly large coefficient magnitudes, overly large standard errors on the coefficient
    estimates, and the wrong sign on a coefficient could be indications of correlated
    inputs.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过大的系数幅度、过大的系数估计标准误差以及系数的符号错误可能是相关输入的迹象。
- en: Linear regression can predict well even in the presence of correlated variables,
    but correlated variables lower the quality of the advice.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使在存在相关变量的情况下，线性回归也能很好地预测，但相关变量会降低建议的质量。
- en: Linear regression will have trouble with problems that have a very large number
    of variables, or categorical variables with a very large number of levels.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性回归在处理具有大量变量或具有大量级别的分类变量的问题时可能会遇到困难。
- en: Linear regression packages have some of the best built-in diagnostics available,
    but rechecking your model on test data is still your most effective safety check.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性回归包提供了一些最好的内置诊断工具，但仍然需要在测试数据上重新检查你的模型，这是你最有效的安全检查。
- en: 7.2\. Using logistic regression
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2\. 使用逻辑回归
- en: Logistic regression is the most important (and probably most used) member of
    a class of models called *generalized linear models*. Unlike linear regression,
    logistic regression can directly predict values that are restricted to the (0,
    1) interval, such as probabilities. It’s the go-to method for predicting probabilities
    or rates, and like linear regression, the coefficients of a logistic regression
    model can be treated as *advice*. It’s also a good first choice for binary classification
    problems.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑回归是称为 *广义线性模型* 的一类模型中最重要的（也可能是最常用的）成员。与线性回归不同，逻辑回归可以直接预测限制在 (0, 1) 区间内的值，例如概率。它是预测概率或比率的首选方法，并且像线性回归一样，逻辑回归模型的系数可以被视为
    *建议*。它也是二元分类问题的良好首选。
- en: In this section, we’ll use a medical classification example (predicting whether
    a newborn will need extra medical attention) to work through all the steps of
    producing and using a logistic regression model.^([[1](../Text/07.xhtml#ch07fn6)])
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用一个医疗分类示例（预测新生儿是否需要额外的医疗关注）来详细说明生产和使用逻辑回归模型的各个步骤.^([[1](../Text/07.xhtml#ch07fn6)])
- en: ¹
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Logistic regression is usually used to perform classification, but logistic
    regression and its close cousin *beta regression* are also useful in estimating
    *rates*. In fact, R’s standard g`lm()` call will work with predicting numeric
    values between 0 and 1 in addition to predicting classifications.
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 逻辑回归通常用于分类，但逻辑回归及其近亲 *beta回归* 也用于估计 *比率*。事实上，R 的标准 g`lm()` 调用除了预测分类之外，还可以预测介于
    0 和 1 之间的数值。
- en: As we did with linear regression, we’ll take a quick overview of logistic regression
    before tackling the main example.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在线性回归中所做的那样，在处理主要示例之前，我们将快速概述逻辑回归。
- en: 7.2.1\. Understanding logistic regression
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1\. 理解逻辑回归
- en: '* * *'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Example
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '*Suppose you want to predict whether or not a flight will be delayed, based
    on facts like the flight’s origin and destination, weather, and air carrier. For
    every flight* `i`*, you want to predict* `flight_delayed[i]` *based on* `origin[i]`*,*
    `destination[i]`*,* `weather[i]`*, and* `air_carrier[i]`*.*'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '*假设你想根据航班的事实，如起点和终点、天气和航空公司，预测航班是否会延误。对于每架航班* `i`*，你希望根据* `origin[i]`*、* `destination[i]`*、*
    `weather[i]`* 和* `air_carrier[i]`* 来预测* `flight_delayed[i]`*。*'
- en: '* * *'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: We’d like to use linear regression to predict the probability that a flight
    `i` will be delayed, but probabilities are strictly in the range `0:1`, and linear
    regression doesn’t restrict its prediction to that range.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用线性回归来预测航班 `i` 将会延误的概率，但概率严格限制在 `0:1` 的范围内，而线性回归并不限制其预测值在这个范围内。
- en: 'One idea is to find a function of probability that is in the range `-Infinity:Infinity`,
    fit a linear model to predict that quantity, and then solve for the appropriate
    probabilities from the model predictions. So let’s look at a slightly different
    problem: instead of predicting the probability that a flight is delayed, consider
    the *odds* that the flight is delayed, or the ratio of the probability that the
    flight is delayed over the probability that it is not.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一个想法是找到一个概率函数，其值域在 `-Infinity:Infinity` 之间，将线性模型拟合到预测该数量，然后从模型预测中求解适当的概率。那么让我们看看一个稍微不同的问题：不是预测航班延误的概率，而是考虑航班延误的
    *几率*，或者航班延误的概率与不延误的概率之比。
- en: '[PRE17]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The range of the odds function isn’t `-Infinity:Infinity`; it’s restricted to
    be a non-negative number. But we can take the log of the odds—the *log-odds*—to
    get a function of the probabilities that *is* in the range `-Infinity:Infinity`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 几率函数的值域不是 `-Infinity:Infinity`；它被限制为非负数。但我们可以取几率的对数——*对数几率*——以得到一个概率函数，其值域是
    `-Infinity:Infinity`。
- en: '[PRE18]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that if it’s more likely that a flight will be delayed than on time, the
    odds ratio will be greater than one; if it’s less likely that a flight will be
    delayed than on time, the odds ratio will be less than one. So the log-odds is
    positive if it’s more likely that the flight will be delayed, negative if it’s
    more likely that the flight will be on time, and zero if the chances of delay
    are 50-50\. This is shown in [figure 7.12](../Text/07.xhtml#ch07fig12).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果航班延迟的可能性大于准时，则几率比将大于一；如果航班延迟的可能性小于准时，则几率比将小于一。因此，如果航班延迟的可能性更大，对数几率将是正的；如果航班准时的可能性更大，对数几率将是负的；如果延迟的可能性是50-50，则对数几率为零。这如图7.12所示。
- en: Figure 7.12\. Mapping the odds of a flight delay to log-odds
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12\. 将延迟航班的几率映射到对数几率
- en: '![](Images/07fig12_alt.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig12_alt.jpg)'
- en: The log-odds of a probability *p* is also known as *logit(p)*. The inverse of
    *logit(p)* is the *sigmoid* function, shown in [figure 7.13](../Text/07.xhtml#ch07fig13).
    The sigmoid function maps values in the range from `-Infinity:Infinity` to the
    range `0:1`—in this case, the sigmoid maps unbounded log-odds ratios to a probability
    value that is between 0 and 1.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 概率*p*的对数几率也称为*logit(p)*。*logit(p)*的逆函数是*sigmoid*函数，如图7.13所示。sigmoid函数将范围从`-Infinity:Infinity`的值映射到范围`0:1`——在这种情况下，sigmoid函数将无界的对数几率比映射到介于0和1之间的概率值。
- en: '[PRE19]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Figure 7.13\. Mapping log-odds to the probability of a flight delay via the
    sigmoid function
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13\. 通过Sigmoid函数将延迟航班的对数几率映射到概率
- en: '![](Images/07fig13_alt.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig13_alt.jpg)'
- en: 'Now we can try to fit a linear model to the log-odds of a flight being delayed:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试将线性模型拟合到延迟航班的对数几率：
- en: '[PRE20]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'But what we are really interested in is the *probability* that a flight is
    delayed. To get that, take the sigmoid `s()` of both sides:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们真正感兴趣的是航班延迟的*概率*。为了得到这个概率，取等式两边的sigmoid `s()`：
- en: '[PRE21]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is the *logistic regression model* for the probability that a flight will
    be delayed. The preceding derivation may seem ad hoc, but using the `logit` function
    to transform the probabilities is known to have a number of favorable properties.
    For instance, like linear regression, it gets totals right (as we will see in
    [section 7.2.3](../Text/07.xhtml#ch07lev2sec9)).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这是航班延迟概率的*逻辑回归模型*。前面的推导可能看起来是临时的，但使用`logit`函数转换概率是已知具有许多有利特性的。例如，像线性回归一样，它正确地得到总数（正如我们将在[7.2.3节](../Text/07.xhtml#ch07lev2sec9)中看到）。
- en: 'More generally, suppose `y[i]` is the class of object `i`: `TRUE` or `FALSE`;
    `delayed` or `on_time`. Also, suppose that `x[i,]` is a row of inputs, and call
    one of the classes the “class of interest” or *target class* —that is, the class
    you are trying to predict (you want to predict whether something is `TRUE` or
    whether the flight is in the class `delayed`). Then logistic regression attempts
    to a fit function `f(x)` such that'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，假设`y[i]`是对象`i`的类别：`TRUE`或`FALSE`；`delayed`或`on_time`。同时，假设`x[i,]`是一行输入，并将其中一个类别称为“感兴趣类别”或*目标类别*——即你试图预测的类别（你想要预测某物是否为`TRUE`或者航班是否属于`delayed`类别）。然后逻辑回归试图拟合一个函数`f(x)`，使得
- en: equation 7.2\. The expression for a logistic regression model
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 方程7.2\. 逻辑回归模型的表达式
- en: '![](Images/07equ02_alt.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07equ02_alt.jpg)'
- en: 'If the `y[i]` are the probabilities that the `x[i,]` belong to the class of
    interest, then the task of fitting is to find the `a, b[1], ..., b[n]` such that
    `f(x[i,])` is the best possible estimate of `y[i]`. R supplies a one-line statement
    to find these coefficients: `glm()`.^([[1](../Text/07.xhtml#ch07fn7)]) Note that
    you don’t need to supply `y[i]` that are probability estimates to run `glm()`;
    the training method only requires `y[i]` that say which class a given training
    example belongs to.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`y[i]`是`x[i,]`属于感兴趣类别的概率，那么拟合的任务就是找到`a, b[1], ..., b[n]`，使得`f(x[i,])`是`y[i]`的最佳可能估计。R提供了一个单行语句来找到这些系数：`glm()`。^([[1](../Text/07.xhtml#ch07fn7)])
    注意，运行`glm()`不需要提供概率估计的`y[i]`；训练方法只需要`y[i]`表明给定的训练示例属于哪个类别。
- en: ¹
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Logistic regression can be used for classifying into any number of categories
    (as long as the categories are disjoint and cover all possibilities: every `x`
    has to belong to one of the given categories). But `glm()` only handles the two-category
    case, so our discussion will focus on this case.'
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 逻辑回归可以用于分类到任意数量的类别（只要类别是互斥的并且覆盖所有可能性：每个`x`必须属于给定的类别之一）。但`glm()`只处理两类别的情况，因此我们的讨论将集中在这种情况。
- en: As we’ve shown, you can think of logistic regression as a linear regression
    that finds the log-odds of the probability that you’re interested in. In particular,
    logistic regression assumes that `logit(y)` is linear in the values of `x`. Like
    linear regression, logistic regression will find the best coefficients to predict
    `y`, including finding advantageous combinations and cancellations when the inputs
    are correlated.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所展示的，你可以将逻辑回归视为一种线性回归，它寻找你感兴趣概率的对数几率。特别是，逻辑回归假设 `logit(y)` 在 `x` 的值上是线性的。与线性回归一样，逻辑回归将找到最佳系数来预测
    `y`，包括当输入相关时找到有利组合和抵消。
- en: Now to the main example.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看主要示例。
- en: '* * *'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Example
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '*Imagine that you’re working at a hospital. The overall goal is to design a
    plan that provisions neonatal emergency equipment to delivery rooms. Newborn babies
    are assessed at one and five minutes after birth using what’s called the Apgar
    test, which is designed to determine if a baby needs immediate emergency care
    or extra medical attention. A baby who scores below 7 (on a scale from 0 to 10)
    on the Apgar scale needs extra attention.*'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*想象一下你在一所医院工作。总体目标是设计一个计划，为分娩室配备新生儿紧急设备。新生儿出生后一分钟和五分钟会使用所谓的阿普加测试进行评估，该测试旨在确定婴儿是否需要立即的紧急护理或额外的医疗关注。阿普加评分低于
    7 分（0 到 10 分的评分标准）的婴儿需要额外的关注。*'
- en: '*Such at-risk babies are rare, so the hospital doesn’t want to provision extra
    emergency equipment for every delivery. On the other hand, at-risk babies may
    need attention quickly, so provisioning resources proactively to appropriate deliveries
    can save lives. Your task is to build a model to identify ahead of time situations
    with a higher probability of risk, so that resources can be allocated appropriately.*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*这类有风险的新生儿很少见，所以医院不想为每一次分娩都配备额外的紧急设备。另一方面，有风险的新生儿可能需要快速得到关注，因此主动为合适的分娩提供资源可以挽救生命。你的任务是构建一个模型，提前识别出风险概率较高的情形，以便能够适当地分配资源。*'
- en: '* * *'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: We’ll use a sample dataset from the 2010 CDC natality public-use data file ([http://mng.bz/pnGy](http://mng.bz/pnGy)).
    This dataset records statistics for all US births registered in the 50 states
    and the District of Columbia, including facts about the mother and father, and
    about the delivery. The sample has just over 26,000 births in a data frame called
    `sdata`.^([[2](../Text/07.xhtml#ch07fn8)]) The data is split into training and
    test sets, using a random grouping column that we added, which allows for repeatable
    experiments with the split ratio.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 2010 年 CDC 出生公共使用数据文件中的样本数据集 ([http://mng.bz/pnGy](http://mng.bz/pnGy))。该数据集记录了在美国
    50 个州和哥伦比亚特区的所有出生登记的统计数据，包括关于母亲和父亲以及分娩的事实。样本中有一个名为 `sdata` 的数据框，包含超过 26,000 次出生。^([[2](../Text/07.xhtml#ch07fn8)])
    数据被分为训练集和测试集，使用我们添加的随机分组列，这允许进行可重复的实验，并确定分割比例。
- en: ²
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Our pre-prepared file is at [https://github.com/WinVector/PDSwR2/tree/master/CDC/NatalRiskData.rData](https://github.com/WinVector/PDSwR2/tree/master/CDC/NatalRiskData.rData);
    we also provide a script file ([https://github.com/WinVector/PDSwR2/blob/master/CDC/PrepNatalRiskData.R](https://github.com/WinVector/PDSwR2/blob/master/CDC/PrepNatalRiskData.R)),
    which prepares the data frame from an extract of the full natality dataset. Details
    found at [https://github.com/WinVector/PDSwR2/blob/master/CDC/README.md](https://github.com/WinVector/PDSwR2/blob/master/CDC/README.md).
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们预先准备好的文件在 [https://github.com/WinVector/PDSwR2/tree/master/CDC/NatalRiskData.rData](https://github.com/WinVector/PDSwR2/tree/master/CDC/NatalRiskData.rData)；我们还提供了一个脚本文件
    ([https://github.com/WinVector/PDSwR2/blob/master/CDC/PrepNatalRiskData.R](https://github.com/WinVector/PDSwR2/blob/master/CDC/PrepNatalRiskData.R))，该文件从完整的出生数据集的提取中准备数据框。详细信息请参阅
    [https://github.com/WinVector/PDSwR2/blob/master/CDC/README.md](https://github.com/WinVector/PDSwR2/blob/master/CDC/README.md)。
- en: Listing 7.7\. Loading the CDC data
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7\. 加载 CDC 数据
- en: '[PRE22]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[Table 7.1](../Text/07.xhtml#ch07table01) lists the columns of the dataset
    that you will use. Because the goal is to anticipate at-risk infants ahead of
    time, we’ll restrict variables to those whose values are known before delivery
    or can be determined during labor. For example, facts about the mother’s weight
    and health history are valid inputs, but post-birth facts like infant birth weight
    are not. We can include in-labor complications like breech birth by reasoning
    that the model can be updated in the delivery room (via a protocol or checklist)
    in time for emergency resources to be allocated before delivery.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 7.1](../Text/07.xhtml#ch07table01) 列出了您将使用的数据集的列。因为目标是提前预测有风险的新生儿，所以我们将变量限制在那些在分娩前已知或在分娩期间可以确定的变量。例如，关于母亲体重和健康史的资料是有效的输入，但出生后的资料，如婴儿出生体重则不是。我们可以通过推理将分娩室内的并发症，如臀位分娩包括在内，因为模型可以在分娩前（通过协议或清单）及时更新，以便在分娩前分配紧急资源。'
- en: Table 7.1\. Some variables in the natality dataset
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1\. 出生数据集中的一些变量
- en: '| Variable | Type | Description |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| Variable | 类型 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| atRisk | Logical | TRUE if 5-minute Apgar score < 7; FALSE otherwise |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| atRisk | 逻辑 | 如果 5 分钟 Apgar 评分小于 7 则为 TRUE；否则为 FALSE |'
- en: '| PWGT | Numeric | Mother’s prepregnancy weight |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| PWGT | 数字 | 母亲的孕前体重 |'
- en: '| UPREVIS | Numeric (integer) | Number of prenatal medical visits |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| UPREVIS | 数字（整数） | 预产期医疗访问次数 |'
- en: '| CIG_REC | Logical | TRUE if smoker; FALSE otherwise |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| CIG_REC | 逻辑 | 如果吸烟则为 TRUE；否则为 FALSE |'
- en: '| GESTREC3 | Categorical | Two categories: <37 weeks (premature) and >=37 weeks
    |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| GESTREC3 | 分类 | 两个类别：小于 37 周（早产）和大于等于 37 周 |'
- en: '| DPLURAL | Categorical | Birth plurality, three categories: single/twin/triplet+
    |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| DPLURAL | 分类 | 出生多胎，分为三类：单胎/双胎/三胎及以上 |'
- en: '| ULD_MECO | Logical | TRUE if moderate/heavy fecal staining of amniotic fluid
    |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| ULD_MECO | 逻辑 | 如果羊水有中度/重度粪便污染则为 TRUE |'
- en: '| ULD_PRECIP | Logical | TRUE for unusually short labor (< three hours) |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| ULD_PRECIP | 逻辑 | 如果异常短产（小于三小时）则为 TRUE |'
- en: '| ULD_BREECH | Logical | TRUE for breech (pelvis first) birth position |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| ULD_BREECH | 逻辑 | 臀位（骨盆首先）出生位置为 TRUE |'
- en: '| URF_DIAB | Logical | TRUE if mother is diabetic |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| URF_DIAB | 逻辑 | 如果母亲是糖尿病患者则为 TRUE |'
- en: '| URF_CHYPER | Logical | TRUE if mother has chronic hypertension |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| URF_CHYPER | 逻辑 | 如果母亲有慢性高血压则为 TRUE |'
- en: '| URF_PHYPER | Logical | TRUE if mother has pregnancy-related hypertension
    |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| URF_PHYPER | 逻辑 | 如果母亲有与怀孕相关的妊娠高血压则为 TRUE |'
- en: '| URF_ECLAM | Logical | TRUE if mother experienced eclampsia: pregnancy-related
    seizures |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| URF_ECLAM | 逻辑 | 如果母亲经历了子痫：与怀孕相关的癫痫发作则为 TRUE |'
- en: Now we’re ready to build the model.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好构建模型。
- en: 7.2.2\. Building a logistic regression model
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2\. 构建逻辑回归模型
- en: The function to build a logistic regression model in R is `glm()`, supplied
    by the `stats` package. In our case, the dependent variable `y` is the logical
    (or Boolean) `atRisk`; all the other variables in [table 7.1](../Text/07.xhtml#ch07table01)
    are the independent variables `x`. The formula for building a model to predict
    `atRisk` using these variables is rather long to type in by hand; you can generate
    the formula using the `mk_formula()` function from the `wrapr` package, as shown
    next.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中构建逻辑回归模型的函数是 `glm()`，由 `stats` 包提供。在我们的情况下，因变量 `y` 是逻辑（或布尔）的 `atRisk`；[表
    7.1](../Text/07.xhtml#ch07table01) 中的所有其他变量是自变量 `x`。使用这些变量预测 `atRisk` 的模型公式相当长，手动输入；您可以使用
    `wrapr` 包中的 `mk_formula()` 函数生成公式，如下所示。
- en: Listing 7.8\. Building the model formula
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8\. 构建模型公式
- en: '[PRE23]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now we’ll build the logistic regression model, using the training dataset.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将构建逻辑回归模型，使用训练数据集。
- en: Listing 7.9\. Fitting the logistic regression model
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.9\. 拟合逻辑回归模型
- en: '[PRE24]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is similar to the linear regression call to `lm()`, with one additional
    argument: `family = binomial(link = "logit")`. The `family` function specifies
    the assumed distribution of the dependent variable `y`. In our case, we’re modeling
    `y` as a binomial distribution, or as a coin whose probability of heads depends
    on `x`. The `link` function “links” the output to a linear model—it’s as if you
    pass `y` through the `link` function, and then model the resulting value as a
    linear function of the `x` values. Different combinations of `family` functions
    and `link` functions lead to different kinds of generalized linear models (for
    example, Poisson, or probit). In this book, we’ll only discuss logistic models,
    so we’ll only need to use the binomial family with the `logit` link.^([[1](../Text/07.xhtml#ch07fn9)])'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这与调用`lm()`的线性回归类似，但有一个额外的参数：`family = binomial(link = "logit")`。`family`函数指定了因变量`y`的假设分布。在我们的例子中，我们将`y`建模为二项分布，或者是一个概率依赖于`x`的硬币。链接函数“链接”输出到线性模型——就好像您通过链接函数传递`y`，然后将其作为`x`值的线性函数建模。不同的`family`函数和链接函数的组合会导致不同类型的广义线性模型（例如，泊松或probit）。在这本书中，我们只讨论逻辑模型，所以我们只需要使用带有`logit`链接的二项分布族。^([[1](../Text/07.xhtml#ch07fn9)])
- en: ¹
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `logit` link is the default link for the binomial family, so the call `glm(fmla,
    data = train, family = binomial)` works just fine. We explicitly specified the
    link in our example for the sake of discussion.
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`logit`链接是二项分布族的默认链接，因此调用`glm(fmla, data = train, family = binomial)`是完全可以的。我们明确指定链接是为了讨论的目的。'
- en: '* * *'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Don’t forget the family argument!
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记`family`参数！
- en: Without an explicit `family` argument, `glm()` defaults to standard linear regression
    (like `lm`).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 没有显式的`family`参数，`glm()`默认为标准线性回归（如`lm`）。
- en: The `family` argument can be used to select many different behaviors of the
    `glm()` function. For example, choosing `family = quasipoisson` chooses a “log”
    link, which models the logarithm of the prediction as linear in the inputs.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`family`参数来选择`glm()`函数的许多不同行为。例如，选择`family = quasipoisson`会选择一个“log”链接，将预测的对数视为输入的线性模型。
- en: This would be another approach to try for the income prediction problem of [section
    7.1](../Text/07.xhtml#ch07lev1sec1). However, it is a subtle point to determine
    whether a log transformation and linear model or a log-link and a generalized
    linear model is a better choice for a given problem. The log-link will be better
    at predicting total incomes (scoring an error of $50,000 for small and large incomes
    alike). The log-transform method will be better at predicting relative incomes
    (a scoring error of $50,000 being less dire for large incomes than for small incomes).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是尝试解决[第 7.1 节](../Text/07.xhtml#ch07lev1sec1)中的收入预测问题的另一种方法。然而，确定对数变换和线性模型或对数链接和广义线性模型对于给定问题来说哪个更好是一个微妙的问题。对数链接将更好地预测总收入（对于小收入和大收入都达到$50,000的误差）。对数变换方法将更好地预测相对收入（对于大收入来说，$50,000的评分误差不如小收入严重）。
- en: '* * *'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: As before, we’ve stored the results in the object `model`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将结果存储在对象`model`中。
- en: 7.2.3\. Making predictions
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.3\. 做出预测
- en: Making predictions with a logistic model is similar to making predictions with
    a linear model—use the `predict()` function. The following code stores the predictions
    for the training and test sets as the column `pred` in the respective data frames.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑模型进行预测与使用线性模型进行预测类似——使用`predict()`函数。以下代码将训练集和测试集的预测结果存储为相应数据框中的`pred`列。
- en: Listing 7.10\. Applying the logistic regression model
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.10\. 应用逻辑回归模型
- en: '[PRE25]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note the additional parameter `type = "response"`. This tells the `predict()`
    function to return the predicted probabilities `y`. If you don’t specify `type
    = "response"`, then by default `predict()` will return the output of the `link`
    function, `logit(y)`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 注意额外的参数`type = "response"`。这告诉`predict()`函数返回预测概率`y`。如果您不指定`type = "response"`，则默认情况下`predict()`将返回`link`函数的输出，即`logit(y)`。
- en: One strength of logistic regression is that it preserves the marginal probabilities
    of the training data. That means that if you sum the predicted probability scores
    for the entire training set, that quantity will be equal to the number of positive
    outcomes (`atRisk == TRUE`) in the training set. This is also true for subsets
    of the data determined by variables included in the model. For example, in the
    subset of the training data that has `train$GESTREC == "<37 weeks"` (the baby
    was premature), the sum of the predicted probabilities equals the number of positive
    training examples (see, for example [http://mng.bz/j338](http://mng.bz/j338)).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑回归的一个优点是它保留了训练数据的边缘概率。这意味着如果你对整个训练集的预测概率得分进行求和，这个数量将等于训练集中正结果（`atRisk == TRUE`）的数量。对于由模型中包含的变量确定的数据子集也是如此。例如，在训练数据子集中，`train$GESTREC
    == "<37 weeks"`（婴儿早产）的情况下，预测概率的总和等于正训练示例的数量（例如，参见[http://mng.bz/j338](http://mng.bz/j338)）。
- en: Listing 7.11\. Preserving marginal probabilities with logistic regression
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.11\. 使用逻辑回归保留边缘概率
- en: '[PRE26]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Counts the number of at-risk infants in the training set.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算训练集中处于风险中的婴儿数量。
- en: ❷ Sums all the predicted probabilities over the training set. Notice that it
    adds to the number of at-risk infants.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对训练集中的所有预测概率进行求和。请注意，它增加了处于风险中的婴儿的数量。
- en: ❸ Counts the number of at-risk premature infants in the training set
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算训练集中处于风险中的早产婴儿数量
- en: ❹ Sums all the predicted probabilities for premature infants in the training
    set. Note that it adds to the number of at-risk premature infants.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 对训练集中所有早产婴儿的预测概率进行求和。请注意，它增加了处于风险中的早产婴儿的数量。
- en: 'Because logistic regression preserves marginal probabilities, you know that
    the model is in some sense consistent with the training data. When the model is
    applied to future data with distributions similar to the training data, it should
    then return results consistent with that data: about the correct probability mass
    of expected at-risk infants, distributed correctly with respect to the infants’
    characteristics. However, if the model is applied to future data with very different
    distributions (for example, a much higher rate of at-risk infants), the model
    may not predict as well.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 由于逻辑回归保留了边缘概率，你知道模型在某种程度上与训练数据是一致的。当模型应用于与训练数据分布相似的未来数据时，它应该返回与该数据一致的结果：预期的处于风险中的婴儿的正确概率质量，正确地根据婴儿的特征分布。然而，如果模型应用于具有非常不同分布的未来数据（例如，处于风险中的婴儿的比率大大增加），模型可能无法预测得很好。
- en: Characterizing prediction quality
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 描述预测质量
- en: If your goal is to use the model to classify new instances into one of two categories
    (in this case, at-risk or not-at-risk), then you want the model to give high scores
    to positive instances and low scores otherwise. As we discussed in [section 6.2.5](../Text/06.xhtml#ch06lev2sec9),
    you can check if this is so by plotting the distribution of scores for both the
    positive and negative instances. Let’s do this on the training set (you should
    also plot the test set, to make sure the performance is of similar quality).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的目标是使用模型将新实例分类为两个类别之一（在这种情况下，处于风险或不在风险中），那么你希望模型对正实例给出高分数，否则给出低分数。正如我们在[第6.2.5节](../Text/06.xhtml#ch06lev2sec9)中讨论的那样，你可以通过绘制正负实例得分的分布来检查这一点。让我们在训练集上这样做（你也应该绘制测试集，以确保性能质量相似）。
- en: Listing 7.12\. Plotting distribution of prediction score grouped by known outcome
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.12\. 按已知结果分组绘制预测得分分布
- en: '[PRE27]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The result is shown in [figure 7.14](../Text/07.xhtml#ch07fig14). Ideally, we’d
    like the distribution of scores to be separated, with the scores of the negative
    instances (FALSE) to be concentrated on the left, and the distribution for the
    positive instances to be concentrated on the right. Earlier in [figure 6.15](../Text/06.xhtml#ch06fig15)
    (reproduced here as [figure 7.15](../Text/07.xhtml#ch07fig15)), we showed an example
    of a classifier (the spam filter) that separates the positives and the negatives
    quite well. With the natality risk model, both distributions are concentrated
    on the left, meaning that both positive and negative instances score low. This
    isn’t surprising, since the positive instances (the ones with the baby at risk)
    are rare (about 1.8% of all births in the dataset). The distribution of scores
    for the negative instances dies off sooner than the distribution for positive
    instances. This means that the model did identify subpopulations in the data where
    the rate of at-risk newborns is higher than the average, as is pointed out in
    [figure 7.14](../Text/07.xhtml#ch07fig14).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在[图7.14](../Text/07.xhtml#ch07fig14)中。理想情况下，我们希望得分的分布是分离的，负实例（FALSE）的得分集中在左侧，而正实例的分布集中在右侧。在[图6.15](../Text/06.xhtml#ch06fig15)（此处重现为[图7.15](../Text/07.xhtml#ch07fig15)）中，我们展示了一个分类器（垃圾邮件过滤器）的例子，它很好地将正负实例分开。使用出生风险模型，两个分布都集中在左侧，这意味着正负实例的得分都较低。这并不奇怪，因为正实例（有风险婴儿的实例）是罕见的（在数据集中占所有出生的约1.8%）。负实例的得分分布比正实例的得分分布衰减得更快。这意味着模型确实在数据中识别出了子群体，其中高风险新生儿的比率高于平均水平，如[图7.14](../Text/07.xhtml#ch07fig14)所示。
- en: Figure 7.14\. Distribution of score broken up by positive examples (TRUE) and
    negative examples (FALSE)
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14。按正例（TRUE）和负例（FALSE）分开的得分分布
- en: '![](Images/07fig14_alt.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07fig14_alt.jpg)'
- en: Figure 7.15\. Reproduction of the spam filter score distributions from [chapter
    6](../Text/06.xhtml#ch06)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15。重绘第6章[图6.15](../Text/06.xhtml#ch06)中的垃圾邮件过滤器得分分布
- en: '![](Images/07fig15_alt.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07fig15_alt.jpg)'
- en: In order to use the model as a classifier, you must pick a threshold; scores
    above the threshold will be classified as positive, those below as negative. When
    you pick a threshold, you’re trying to balance the *precision* of the classifier
    (what fraction of the predicted positives are true positives) and its *recall*
    (how many of the true positives the classifier finds).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将模型用作分类器，你必须选择一个阈值；得分高于阈值的将被分类为正，低于阈值的将被分类为负。当你选择一个阈值时，你试图平衡分类器的*精确度*（预测的正例中有多少是真正的正例）和其*召回率*（分类器找到多少真正的正例）。
- en: If the score distributions of the positive and negative instances are well separated,
    as in [figure 7.15](../Text/07.xhtml#ch07fig15), you can pick an appropriate threshold
    in the “valley” between the two peaks. In the current case, the two distributions
    aren’t well separated, which indicates that the model can’t build a classifier
    that simultaneously achieves good recall and good precision.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正负实例的得分分布很好地分离，如[图7.15](../Text/07.xhtml#ch07fig15)所示，你可以在两个峰值之间的“山谷”中选取一个合适的阈值。在当前情况下，两个分布没有很好地分离，这表明模型不能构建一个同时实现良好召回率和良好精确度的分类器。
- en: 'However, you might be able to build a classifier that identifies a subset of
    situations with a higher-than-average rate of at-risk births: for example, you
    may be able to find a threshold that produces a classifier with a precision of
    3.6%. Even though this precision is low, it represents a subset of the data that
    has twice the risk as the overall population (3.6% versus 1.8%), so preprovisioning
    resources to those situations may be advised. We’ll call the ratio of the classifier
    precision to the average rate of positives the *enrichment rate*.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能能够构建一个分类器，以识别具有高于平均风险出生率的子集：例如，你可能能够找到一个阈值，产生一个精确度为3.6%的分类器。尽管这个精确度很低，但它代表了一个数据子集，其风险是整体人口的两倍（3.6%比1.8%），因此为这些情况预先分配资源可能是明智的。我们将分类器精确度与平均正例率之比称为*富集率*。
- en: The higher you set the threshold, the more precise the classifier will be (you’ll
    identify a set of situations with a much higher-than-average rate of at-risk births);
    but you’ll also miss a higher percentage of at-risk situations, as well. When
    picking the threshold, you should use the training set, since picking the threshold
    is part of classifier-building. You can then use the test set to evaluate classifier
    performance.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你设置的阈值越高，分类器的精确度就越高（你将识别出风险出生率远高于平均水平的情境集）；但你也可能会错过更多风险情境。在挑选阈值时，你应该使用训练集，因为挑选阈值是分类器构建的一部分。然后你可以使用测试集来评估分类器性能。
- en: To help pick the threshold, you can use a plot like [figure 7.16](../Text/07.xhtml#ch07fig16),
    which shows both enrichment and recall as functions of the threshold.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助挑选阈值，你可以使用类似于图7.16的图表，该图表显示了富集度和召回率作为阈值的函数。
- en: Figure 7.16\. Enrichment (top) and recall (bottom) plotted as functions of threshold
    for the training set
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16\. 训练集的富集度（顶部）和召回率（底部）作为阈值的函数
- en: '![](Images/07fig16_alt.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig16_alt.jpg)'
- en: Looking at [figure 7.16](../Text/07.xhtml#ch07fig16), you see that higher thresholds
    result in more-precise classifications (precision is proportional to enrichment),
    at the cost of missing more cases; a lower threshold will identify more cases,
    at the cost of many more false positives (lower precision). The best trade-off
    between precision/enrichment and recall is a function of how many resources the
    hospital has available to allocate, and how many they can keep in reserve (or
    redeploy) for situations that the classifier missed. A threshold of 0.02 (marked
    in [figure 7.16](../Text/07.xhtml#ch07fig16) by the dashed line) might be a good
    trade-off. The resulting classifier will identify a subset of the population where
    the rate of risky births is 2.5 times higher than in the overall population, and
    which contains about half of all the true at-risk situations.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 查看图7.16，你会发现更高的阈值会导致更精确的分类（精确度与富集度成正比），但代价是错过更多案例；较低的阈值将识别更多案例，但代价是许多更多的误报（精确度降低）。最佳精度/富集度与召回率之间的权衡取决于医院可以分配的资源数量，以及他们可以保留在储备（或重新部署）以应对分类器未涵盖情况的数量。阈值0.02（在图7.16中由虚线标记）可能是一个不错的权衡。结果分类器将识别出人口中风险出生率是总体人口2.5倍的一个子集，并且包含所有真正风险情况的一半左右。
- en: You can produce [figure 7.16](../Text/07.xhtml#ch07fig16) using the `PRTPlot()`
    function in `WVPlots`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`WVPlots`中的`PRTPlot()`函数生成图7.16。
- en: Listing 7.13\. Exploring modeling trade-offs
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.13\. 探索建模权衡
- en: '[PRE28]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Calls PRTPlot() where pred is the column of predictions, atRisk is the true
    outcome column, and TRUE is the class of interest
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在PRTPlot()中调用pred为预测列，atRisk为真实结果列，TRUE为感兴趣类别
- en: ❷ Adds a line to mark threshold = 0.02.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 添加一条线标记阈值=0.02。
- en: Once you’ve picked an appropriate threshold, you can evaluate the resulting
    classifier by looking at the confusion matrix, as we discussed in [section 6.2.3](../Text/06.xhtml#ch06lev2sec7).
    Let’s use the test set to evaluate the classifier with a threshold of 0.02.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你挑选了一个合适的阈值，你可以通过查看混淆矩阵来评估结果分类器，正如我们在[第6.2.3节](../Text/06.xhtml#ch06lev2sec7)中讨论的那样。让我们使用测试集来评估阈值为0.02的分类器。
- en: Listing 7.14\. Evaluating the chosen model
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.14\. 评估所选模型
- en: '[PRE29]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Builds the confusion matrix. The rows contain predicted negatives and positives;
    columns contain actual negatives and positives.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 构建混淆矩阵。行包含预测的负例和正例；列包含实际的负例和正例。
- en: The resulting classifier is low-precision, but identifies a set of potential
    at-risk cases that contains 55.5% of the true positive cases in the test set,
    at a rate 2.66 times higher than the overall average. This is consistent with
    the results on the training set.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 结果分类器精确度较低，但识别出包含测试集中55.5%真正正例的潜在风险案例集，其比率是总体平均水平的2.66倍。这与训练集上的结果一致。
- en: In addition to making predictions, a logistic regression model also helps you
    extract useful information and advice. We’ll show this in the next section.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 除了做出预测外，逻辑回归模型还能帮助你提取有用的信息和建议。我们将在下一节中展示这一点。
- en: 7.2.4\. Finding relations and extracting advice from logistic models
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.4\. 从逻辑模型中寻找关系和提取建议
- en: The coefficients of a logistic regression model encode the relationships between
    the input variables and the output in a way similar to how the coefficients of
    a linear regression model do. You can get the model’s coefficients with the call
    `coefficients (model)`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑回归模型的系数以类似于线性回归模型系数的方式编码输入变量与输出之间的关系。你可以通过调用 `coefficients (model)` 来获取模型的系数。
- en: Listing 7.15\. The model coefficients
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.15。模型系数
- en: '[PRE30]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Negative coefficients that are statistically significant^([[1](../Text/07.xhtml#ch07fn10)])
    correspond to variables that are negatively correlated to the odds (and hence
    to the probability) of a positive outcome (the baby being at risk). Positive coefficients
    that are statistically significant are positively correlated to the odds of the
    baby being at risk.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 统计上显著的负系数对应于与正结果（婴儿处于风险）的概率负相关的变量。统计上显著的正系数与婴儿处于风险的概率正相关。
- en: ¹
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We’ll show how to check for statistical significance in the next section.
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将在下一节中展示如何检查统计显著性。
- en: As with linear regression, every categorical variable is expanded to a set of
    indicator variables. If the original variable has `n` levels, there will be `n-1`
    indicator variables; the remaining level is the reference level.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 就像线性回归一样，每个分类变量都会扩展成一组指示变量。如果原始变量有 `n` 个级别，将会有 `n-1` 个指示变量；剩余的级别是参考水平。
- en: 'For example, the variable `DPLURAL` has three levels corresponding to single
    births, twins, and triplets or higher. The logistic regression model has two corresponding
    coefficients: `DPLURALtwin` and `DPLURALtriplet or higher`. The reference level
    is single births. Both of the `DPLURAL` coefficients are positive, indicating
    that multiple births have higher odds of being at risk than single births do,
    all other variables being equal.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，变量 `DPLURAL` 有三个级别，分别对应单胎、双胞胎和三胞胎或更高。逻辑回归模型有两个相应的系数：`DPLURALtwin` 和 `DPLURALtriplet
    or higher`。参考水平是单胎。`DPLURAL` 的两个系数都是正的，表明多胎出生的风险概率比单胎出生高，其他变量保持不变。
- en: '* * *'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Logistic regression also dislikes a very large variable count
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑回归也不喜欢变量数量非常多
- en: And as with linear regression, you should avoid categorical variables with too
    many levels.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 就像线性回归一样，你应该避免使用具有太多级别的分类变量。
- en: '* * *'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Interpreting the coefficients
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 解释系数
- en: Interpreting coefficient values is a little more complicated with logistic than
    with linear regression. If the coefficient for the variable `x[,k]` is `b[k]`,
    then the odds of a positive outcome are multiplied by a factor of `exp(b[k])`
    for every unit change in `x[,k]`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 与线性回归相比，解释系数值要复杂一些。如果变量 `x[,k]` 的系数是 `b[k]`，那么对于 `x[,k]` 每单位的变化，正结果的概率会乘以 `exp(b[k])`
    的因子。
- en: '* * *'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Example
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '*Suppose a full-term baby with certain characteristics has a 1% probability
    of being at risk. Then the risk odds for that baby are `p/(1-p)`, or `0.01/0.99
    = 0.0101`. What are the risk odds (and the risk probability) for a baby with the
    same characteristics, but born prematurely?*'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '*假设一个具有某些特征的足月婴儿有 1% 的风险概率。那么这个婴儿的风险概率是 `p/(1-p)`，即 `0.01/0.99 = 0.0101`。那么具有相同特征但早产儿的婴儿的风险概率（以及风险概率）是多少？*'
- en: '* * *'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The coefficient for `GESTREC3< 37 weeks` (for a premature baby) is 1.545183\.
    So for a premature baby, the odds of being at risk are `exp(1.545183)= 4.68883`
    times higher compared to a baby that’s born full-term, with all other input variables
    unchanged. The risk odds for a premature baby with the same characteristics as
    our hypothetical full-term baby are `0.0101 * 4.68883 = 0.047`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `GESTREC3< 37 weeks`（早产儿）的系数是 1.545183。因此，对于一个早产儿，其处于风险的概率是 `exp(1.545183)=
    4.68883` 倍高于足月出生的婴儿，其他输入变量保持不变。具有与假设足月婴儿相同特征的早产儿的危险概率是 `0.0101 * 4.68883 = 0.047`。
- en: 'You can invert the formula `odds = p / (1 - p)` to solve for `p` as a function
    of `odds`:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将公式 `odds = p / (1 - p)` 逆转来求解 `p` 作为 `odds` 的函数：
- en: '[PRE31]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The probability of this premature baby being at risk is `0.047/1.047`, or about
    4.5%—quite a bit higher than the equivalent full-term baby
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这个早产儿处于风险的概率是 `0.047/1.047`，大约是 4.5%——比等效的足月婴儿高得多
- en: Similarly, the coefficient for `UPREVIS` (number of prenatal medical visits)
    is about –0.06\. This means every prenatal visit lowers the odds of an at-risk
    baby by a factor of `exp(-0.06)`, or about 0.94\. Suppose the mother of a premature
    baby had made no prenatal visits; a baby in the same situation whose mother had
    made three prenatal visits would have odds of being at risk of about `0.047 *
    0.94 * 0.94 * 0.94 = 0.039`. This corresponds to a probability of being at risk
    of 3.75%.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`UPREVIS`（产前医疗访问次数）的系数大约是-0.06。这意味着每次产前访问都会将高风险婴儿的概率降低到`exp(-0.06)`倍，即大约0.94。假设一个早产儿的母亲没有进行任何产前访问；在相同情况下，如果母亲进行了三次产前访问，那么婴儿处于风险的概率大约是`0.047
    * 0.94 * 0.94 * 0.94 = 0.039`。这对应于3.75%的风险概率。
- en: The general advice in this case might be to keep a special eye on premature
    births (and multiple births), and encourage expectant mothers to make regular
    prenatal visits.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下的一般建议可能是特别关注早产（和多胞胎），并鼓励孕妇进行定期的产前访问。
- en: 7.2.5\. Reading the model summary and characterizing coefficients
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.5。阅读模型摘要和描述系数
- en: As we mentioned earlier, conclusions about the coefficient values are only to
    be trusted if the coefficient values are statistically significant. We also want
    to make sure that the model is actually explaining something. The diagnostics
    in the model summary will help us determine some facts about model quality. The
    call, as before, is `summary(model)`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，关于系数值的结论只有在系数值具有统计学意义时才应予以信任。我们还想确保模型实际上在解释某些东西。模型摘要中的诊断将帮助我们确定有关模型质量的一些事实。调用，如前所述，是`summary(model)`。
- en: Listing 7.16\. The model summary
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.16。模型摘要
- en: '[PRE32]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Again, you’re likely to be asked about elements of the model summary when presenting
    results, so we’ll discuss what the fields mean, and how to use them to interpret
    your model.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，当你展示结果时，可能会被问到模型摘要中的元素，所以我们将讨论这些字段的意义，以及如何使用它们来解释你的模型。
- en: The original model call
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 原始模型调用
- en: 'The first line of the summary is the call to `glm()`:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要的第一行是`glm()`的调用：
- en: '[PRE33]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here is where we check that we’ve used the correct training set and the correct
    formula (although in our case, the formula itself is in another variable). We
    can also verify that we used the correct family and link function to produce a
    logistic model.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们检查是否使用了正确的训练集和正确的公式（尽管在我们的情况下，公式本身在另一个变量中）。我们还可以验证是否使用了正确的家族和连接函数来生成逻辑模型。
- en: The deviance residuals summary
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 偏差残差摘要
- en: 'The deviance residuals are the analog to the residuals of a linear regression
    model:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 偏差残差是线性回归模型残差的类似物：
- en: '[PRE34]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Linear regression models are found by minimizing the sum of the squared residuals;
    logistic regression models are found by minimizing the sum of the residual deviances,
    which is equivalent to maximizing the log likelihood of the data, given the model
    (we’ll talk about log likelihood later in this chapter).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归模型是通过最小化残差的平方和来找到的；逻辑回归模型是通过最小化残差偏差的总和来找到的，这相当于最大化给定模型的数据的对数似然，我们将在本章后面讨论对数似然。
- en: 'Logistic models can also be used to explicitly compute rates: given several
    groups of identical data points (identical except the outcome), predict the rate
    of positive outcomes in each group. This kind of data is called *grouped data*.
    In the case of grouped data, the deviance residuals can be used as a diagnostic
    for model fit. This is why the deviance residuals are included in the summary.
    We’re using *ungrouped data*—every data point in the training set is potentially
    unique. In the case of ungrouped data, the model fit diagnostics that use the
    deviance residuals are no longer valid, so we won’t discuss them here.^([[1](../Text/07.xhtml#ch07fn11)])'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑模型也可以用来明确地计算比率：给定几个相同数据点（除了结果外都相同）的组，预测每个组中阳性结果的比率。这种数据称为*分组数据*。在分组数据的情况下，偏差残差可以用作模型拟合的诊断。这就是为什么偏差残差包括在摘要中的原因。我们正在使用*未分组数据*——训练集中的每个数据点可能是唯一的。在未分组数据的情况下，使用偏差残差进行模型拟合诊断不再有效，所以我们在这里不讨论它们.^([[1](../Text/07.xhtml#ch07fn11)])
- en: ¹
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Daniel Powers and Yu Xie, *Statistical Methods for Categorical Data Analysis*,
    2nd ed, Emerald Group Publishing Ltd., 2008.
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 见Daniel Powers和Yu Xie所著的《分类数据分析的统计方法》，第2版，Emerald Group Publishing Ltd.，2008年。
- en: The summary coefficients table
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要系数表
- en: 'The summary coefficients table for logistic regression has the same format
    as the coefficients table for linear regression:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑回归的摘要系数表与线性回归的系数表具有相同的格式：
- en: '[PRE35]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The columns of the table represent
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的列表示
- en: A coefficient
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个系数
- en: Its estimated value
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其估计值
- en: The error around that estimate
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该估计值周围的误差
- en: The signed distance of the estimated coefficient value from 0 (using the standard
    error as the unit of distance)
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 估计系数值与0的符号距离（使用标准误差作为距离的单位）
- en: The probability of seeing a coefficient value at least as large as we observed,
    under the null hypothesis that the coefficient value is really zero
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在假设系数值实际上为零的零假设下，观察到至少与我们观察到的系数值一样大的概率
- en: This last value, called the *p-value* or *significance*, tells us whether we
    should trust the estimated coefficient value. The common practice is to assume
    that coefficients with p-values less than 0.05 are reliable, although some researchers
    prefer stricter thresholds.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的值，称为*p值*或*显著性*，告诉我们是否应该相信估计的系数值。常见的做法是假设p值小于0.05的系数是可靠的，尽管一些研究人员更喜欢更严格的阈值。
- en: 'For the birth data, we can see from the coefficient summary that premature
    birth and triplet birth are strong predictors of the newborn needing extra medical
    attention: the coefficient magnitudes are non-negligible and the p-values indicate
    significance. Other variables that affect the outcome are'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 对于出生数据，我们可以从系数摘要中看到，早产和三胞胎出生是新生儿需要额外医疗关注的有力预测因素：系数的绝对值不可忽视，p值表明其显著性。其他影响结果的因素还包括
- en: '*`PWGT`*—The mother’s prepregnancy weight (heavier mothers indicate higher
    risk—slightly surprising)'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`PWGT`*—母亲的孕前体重（体重较重的母亲表示风险更高——有点令人惊讶）'
- en: '*`UPREVIS`*—The number of prenatal medical visits (the more visits, the lower
    the risk)'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`UPREVIS`*—产前医疗访问次数（访问次数越多，风险越低）'
- en: '*`ULD_MECOTRUE`*—Meconium staining in the amniotic fluid'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`ULD_MECOTRUE`*—羊水中的胎粪污染'
- en: '`ULD_BREECHTRUE`—Breech position at birth'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ULD_BREECHTRUE`—出生时的臀位'
- en: There might be a positive correlation between a mother’s smoking and an at-risk
    birth, but the data doesn’t indicate it definitively. None of the other variables
    show a strong relationship to an at-risk birth.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 母亲吸烟与高风险出生之间可能存在正相关，但数据并没有明确表明这一点。其他变量与高风险出生之间没有显示出强烈的关系。
- en: '* * *'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Lack of significance could mean collinear inputs**'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '**不显著可能意味着共线性输入**'
- en: As with linear regression, logistic regression can predict well with collinear
    (or correlated) inputs, but the correlations can mask good advice.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 与线性回归一样，逻辑回归在处理共线性（或相关）输入时也能很好地进行预测，但相关性可能会掩盖有用的建议。
- en: 'To see this for yourself, we left data about the babies’ birth weight in grams
    in the dataset `sdata`. It’s present in both the test and training data as the
    column `DBWT`. Try adding `DBWT` to the logistic regression model in addition
    to all the other variables; you’ll see that the coefficient for baby’s birth weight
    will be significant, non-negligible (has a substantial impact on prediction),
    and negatively correlated with risk. The coefficient for `DPLURALtriplet or higher`
    will appear insignificant, and the coefficient for `GESTREC3< 37 weeks` has a
    much smaller magnitude. This is because low birth weight is correlated to both
    prematurity and multiple birth. Of the three related variables, birth weight is
    the best single predictor of the outcome: knowing that the baby is a triplet adds
    no additional useful information, and knowing the baby is premature adds only
    a little information.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您自己看到这一点，我们在数据集`sdata`中留下了关于婴儿出生体重的克数数据。它在测试数据和训练数据中都作为`DBWT`列存在。尝试将`DBWT`添加到除了所有其他变量之外的逻辑回归模型中；您会发现婴儿出生体重的系数将是显著的、不可忽视的（对预测有实质性影响），并且与风险呈负相关。`DPLURALtriplet
    or higher`的系数将显得不显著，而`GESTREC3< 37 weeks`的系数的绝对值要小得多。这是因为低出生体重与早产和多胞胎都有关联。在这三个相关变量中，出生体重是结果的最佳单一预测因素：知道婴儿是三胞胎不会增加额外的有用信息，而知道婴儿早产只会增加一点信息。
- en: In the context of the modeling goal—to proactively allocate emergency resources
    where they’re more likely to be needed—birth weight isn’t very useful a variable,
    because we don’t know the baby’s weight until it’s born. We do know ahead of time
    if it’s being born prematurely, or if it’s one of multiple babies. So it’s better
    to use `GESTREC3` and `DPLURAL` as input variables, instead of `DBWT`.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在建模目标——主动分配紧急资源到更有可能需要的地点——的背景下，出生体重不是一个非常有用的变量，因为我们不知道婴儿出生时的体重。我们事先知道它是否早产，或者是否是多个婴儿中的一个。因此，最好使用`GESTREC3`和`DPLURAL`作为输入变量，而不是`DBWT`。
- en: Other signs of possibly collinear inputs are coefficients with the wrong sign
    and unusually large coefficient magnitudes with giant standard errors.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可能存在共线性输入的迹象是系数符号错误和异常大的系数幅度，伴随着巨大的标准误差。
- en: '* * *'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Overall model quality summaries
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 模型整体质量摘要
- en: 'The next section of the summary contains the model quality statistics:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要的下一部分包含模型质量统计信息：
- en: '[PRE36]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Null and residual deviances
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 零偏差和残差偏差
- en: Deviance is a measure of how well the model fits the data. It is two times the
    negative *log likelihood* of the dataset, given the model. As we discussed previously
    in [section 6.2.5](../Text/06.xhtml#ch06lev2sec9), the idea behind log likelihood
    is that positive instances `y` should have high probability `py` of occurring
    under the model; negative instances should have low probability of occurring (or
    putting it another way, `(1 - py)` should be large). The log likelihood function
    rewards matches between the outcome `y` and the predicted probability `py`, and
    penalizes mismatches (high `py` for negative instances, and vice versa).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 偏差是衡量模型拟合数据好坏的度量。它是数据集给定模型的负对数似然的两倍。正如我们之前在[第6.2.5节](../Text/06.xhtml#ch06lev2sec9)中讨论的，对数似然背后的思想是，正实例`y`应该在模型下有高概率`py`发生；负实例应该有低概率发生（或者换句话说，`(1
    - py)`应该是大的）。对数似然函数奖励结果`y`与预测概率`py`之间的匹配，并惩罚不匹配（负实例的高`py`，反之亦然）。
- en: If you think of deviance as analogous to variance, then the *null deviance*
    is similar to the variance of the data around the average rate of positive examples.
    The *residual deviance* is similar to the variance of the data around the model.
    As with variance, you want the residual deviance to be small, compared to the
    null deviance. The model summary reports the deviance and null deviance of the
    model on the training data; you can (and should) also calculate them for test
    data. In the following listing we calculate the deviances for both the training
    and test sets.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为偏差类似于方差，那么*零偏差*类似于围绕正例平均率的平均数据方差。*残差偏差*类似于围绕模型的数据方差。与方差一样，你希望残差偏差相对于零偏差较小。模型摘要报告了训练数据上的偏差和零偏差；你（并且应该）也可以为测试数据计算它们。在下面的列表中，我们计算了训练集和测试集的偏差。
- en: Listing 7.17\. Computing deviance
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.17\. 计算偏差
- en: '[PRE37]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Function to calculate the log likelihood of a dataset. Variable y is the outcome
    in numeric form (1 for positive examples, 0 for negative). Variable py is the
    predicted probability that y==1.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 计算数据集对数似然的函数。变量y是数值形式的结果（正例为1，负例为0）。变量py是y等于1的预测概率。
- en: ❷ Calculates the rate of positive examples in the dataset
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算数据集中正例的比率
- en: ❸ Calculates the null deviance
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算零偏差
- en: ❹ For training data, the null deviance is stored in the slot model$null.deviance.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 对于训练数据，零偏差存储在model$null.deviance槽中。
- en: ❺ Predicts probabilities for the training data
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 为训练数据预测概率
- en: ❻ Calculates deviance of the model for training data
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 计算训练数据的模型偏差
- en: ❻ For training data, model deviance is stored in the slot model$deviance.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 对于训练数据，模型偏差存储在model$deviance槽中。
- en: ❽ Calculates the null deviance and residual deviance for the test data
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 计算测试数据的零偏差和残差偏差
- en: The pseudo R-squared
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 伪R平方
- en: 'A useful goodness-of-fit measure based on the deviances is the pseudo R-squared:
    `1 - (dev.model/dev.null)`. The pseudo R-squared is the analog to the R-squared
    measure for linear regression. It’s a measure of how much of the deviance is “explained”
    by the model. Ideally, you want the pseudo R-squared to be close to 1\. Let’s
    calculate the pseudo R-squared for both the test and training data.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 基于偏差的一个有用的拟合优度度量是伪R平方：`1 - (dev.model/dev.null)`。伪R平方是线性回归中R平方的类似物。它是衡量模型“解释”了多少偏差的度量。理想情况下，你希望伪R平方接近1。让我们计算测试数据和训练数据的伪R平方。
- en: Listing 7.18\. Calculating the pseudo R-squared
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.18\. 计算伪R平方
- en: '[PRE38]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The model only explains about 7.7–8.7% of the deviance; it’s not a highly predictive
    model (you should have suspected that already from [figure 7.14](../Text/07.xhtml#ch07fig14)).
    This tells us that we haven’t yet identified all the factors that actually predict
    at-risk births.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型仅解释了约7.7-8.7%的偏差；它不是一个高度预测性的模型（你早已应该从[图7.14](../Text/07.xhtml#ch07fig14)中怀疑这一点）。这告诉我们，我们尚未识别出所有实际预测风险出生的因素。
- en: Model significance
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 模型显著性
- en: 'The other thing you can do with the null and residual deviances is check whether
    the model’s probability predictions are better than just guessing the average
    rate of positives, statistically speaking. In other words, is the reduction in
    deviance from the model meaningful, or just something that was observed by chance?
    This is similar to calculating the F-test statistic and associated p-value that
    are reported for linear regression. In the case of logistic regression, the test
    you’ll run is the *chi-squared test*. To do that, you need to know the degrees
    of freedom for the null model and the actual model (which are reported in the
    summary). The degrees of freedom of the null model is the number of data points
    minus 1:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用空模型和残差偏差来检查模型的概率预测是否比仅仅猜测平均阳性率更好，从统计学的角度来看。换句话说，模型偏差的减少是否具有意义，或者只是偶然观察到的？这与计算线性回归中报告的F检验统计量和相关p值类似。在逻辑回归的情况下，您将运行的测试是*卡方检验*。为此，您需要知道空模型和实际模型的自由度（这些在总结中报告）。空模型的自由度是数据点数量减去1：
- en: '[PRE39]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The degrees of freedom of the model that you fit is the number of data points
    minus the number of coefficients in the model:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 您拟合的模型自由度是数据点数量减去模型中的系数数量：
- en: '[PRE40]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If the number of data points in the training set is large, and `df.null - df.model`
    is small, then the probability of the difference in deviances `null.dev - resid.dev`
    being as large as we observed is approximately distributed as a chi-squared distribution
    with `df.null - df.model` degrees of freedom.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 如果训练集中数据点的数量很大，且`df.null - df.model`很小，那么偏差差异`null.dev - resid.dev`与我们观察到的差异一样大的概率大约服从具有`df.null
    - df.model`个自由度的卡方分布。
- en: Listing 7.19\. Calculating the significance of the observed fit
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.19\. 计算观察到的拟合的显著性
- en: '[PRE41]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ The null model has (number of data points - 1) degrees of freedom.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 空模型具有（数据点数量 - 1）个自由度。
- en: ❷ The fitted model has (number of data points - number of coefficients) degrees
    of freedom.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 拟合模型具有（数据点数量 - 系数数量）个自由度。
- en: ❸ Computes the difference in deviances and difference in degrees of freedom
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算偏差差异和自由度差异
- en: ❹ Estimates the probability of seeing the observed difference in deviances under
    the null model (the p-value) using chi-squared distribution
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用卡方分布估计在空模型下观察到偏差差异的概率（p值）
- en: The p-value is very small; it’s extremely unlikely that we could’ve seen this
    much reduction in deviance by chance. This means it is plausible (but unfortunately
    not definitive) that this model has found informative patterns in the data.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: p值非常小；我们通过偶然看到如此多的偏差减少的可能性极低。这意味着这个模型在数据中找到信息性模式的可能性是合理的（但遗憾的是不是决定性的）。
- en: '* * *'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Goodness of fit vs. significance**'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '**拟合优度与显著性**'
- en: 'It’s worth noting that the model we found is a significant model, just not
    a powerful one. The good p-value tells us that the model is significant: it predicts
    at-risk birth in the training data at a quality that is unlikely to be pure chance.
    The poor pseudo R-squared means that the model isn’t giving us enough information
    to effectively distinguish between low-risk and high-risk births.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们找到的模型是一个显著的模型，但不是一个强大的模型。良好的p值告诉我们，该模型是显著的：它在训练数据中预测有风险出生的质量，这种质量不太可能是纯粹的偶然。较差的伪R平方意味着该模型没有给我们提供足够的信息来有效地区分低风险和高风险出生。
- en: It’s also possible to have good pseudo R-squared (on the training data) with
    a bad p-value. This is an indication of overfit. That’s why it’s a good idea to
    check both, or better yet, check the pseudo R-squared of the model on both training
    and test data.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能存在良好的伪R平方（在训练数据上），但p值较差。这是过拟合的迹象。这就是为什么检查两者都是好主意，或者更好的是，检查模型在训练和测试数据上的伪R平方。
- en: '* * *'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: The AIC
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: AIC
- en: The last metric given in the section of the summary is the AIC, or the *Akaike
    information criterion*. The AIC is the log likelihood adjusted for the number
    of coefficients. Just as the R-squared of a linear regression is generally higher
    when the number of variables is higher, the log likelihood also increases with
    the number of variables.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 概述部分给出的最后一个指标是AIC，或*赤池信息准则*。AIC是调整了系数数量的对数似然。正如线性回归的R平方在变量数量较高时通常较高一样，对数似然也随着变量数量的增加而增加。
- en: Listing 7.20\. Calculating the Akaike information criterion
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.20\. 计算赤池信息准则
- en: '[PRE42]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The AIC is generally used to decide which and how many input variables to use
    in the model. If you train many different models with different sets of variables
    on the same training set, you can consider the model with the lowest AIC to be
    the best fit.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: AIC 通常用于决定在模型中使用哪些输入变量以及使用多少。如果你在同一个训练集上使用不同的变量集训练了许多不同的模型，你可以考虑具有最低 AIC 的模型为最佳拟合。
- en: Fisher scoring iterations
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 费舍尔评分迭代
- en: 'The last line of the model summary is the number of Fisher scoring iterations:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 模型摘要的最后一行是费舍尔评分迭代的次数：
- en: '[PRE43]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The Fisher scoring method is an iterative optimization method, similar to Newton’s
    method, that `glm()` uses to find the best coefficients for the logistic regression
    model. You should expect it to converge in about six to eight iterations. If there
    are many more iterations than that, then the algorithm may not have converged,
    and the model may not be valid.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 费舍尔评分法是一种迭代优化方法，类似于牛顿法，`glm()` 使用它来找到逻辑回归模型的最佳系数。你应该期望它在大约六到八次迭代内收敛。如果迭代次数比这多得多，那么算法可能没有收敛，模型可能无效。
- en: Separation and quasi-separation
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 分离和准分离
- en: 'The probable reason for non-convergence is separation or quasi-separation:
    one of the model variables or some combination of the model variables predicts
    the outcome perfectly for at least a subset of the training data. You’d think
    this would be a good thing; but, ironically, logistic regression fails when the
    variables are too powerful. Ideally, `glm()` will issue a warning when it detects
    separation or quasi-separation:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 非收敛的可能原因是分离或准分离：模型中的一个变量或一些模型变量的组合至少对于训练数据的一个子集完美预测了结果。你可能会认为这是一件好事；但讽刺的是，当变量过于强大时，逻辑回归会失败。理想情况下，`glm()`
    在检测到分离或准分离时会发出警告：
- en: '[PRE44]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Unfortunately, there are situations when it seems that no warning is issued,
    but there are other warning signs:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，有些情况下似乎没有发出警告，但仍有其他警告信号：
- en: An unusually high number of Fisher iterations
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 费舍尔迭代次数异常高
- en: Very large coefficients, usually with extremely large standard errors
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常大的系数，通常伴随着非常大的标准误差
- en: Residual deviances larger than the null deviances
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余偏差大于零偏差
- en: 'If you see any of these signs, the model is suspect. The last section of this
    chapter covers one way to address the problem: regularization.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到这些迹象中的任何一种，那么模型是可疑的。本章的最后一节介绍了一种解决该问题的方法：正则化。
- en: 7.2.6\. Logistic regression takeaways
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.6. 逻辑回归要点
- en: 'Logistic regression is the go-to statistical modeling method for binary classification.
    As with linear regression, the coefficients of a logistic regression model can
    often function as advice. Here are some points to remember about logistic regression:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑回归是二元分类的统计建模方法中的首选。与线性回归一样，逻辑回归模型的系数通常可以充当建议。以下是关于逻辑回归的一些要点：
- en: 'Logistic regression is well calibrated: it reproduces the marginal probabilities
    of the data.'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑回归校准良好：它再现了数据的边缘概率。
- en: Pseudo R-squared is a useful goodness-of-fit heuristic.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪 R 平方是一个有用的拟合优度启发式方法。
- en: Logistic regression will have trouble with problems with a very large number
    of variables, or categorical variables with a very large number of levels.
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑回归在处理具有大量变量或具有大量级别的分类变量的问题时可能会遇到困难。
- en: Logistic regression can predict well even in the presence of correlated variables,
    but correlated variables lower the quality of the advice.
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使存在相关变量，逻辑回归也能很好地预测，但相关变量会降低建议的质量。
- en: Overly large coefficient magnitudes, overly large standard errors on the coefficient
    estimates, and the wrong sign on a coefficient could be indications of correlated
    inputs.
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过大的系数幅度，系数估计的标准误差过大，以及系数的符号错误可能是相关输入的迹象。
- en: Too many Fisher iterations, or overly large coefficients with very large standard
    errors, could be signs that your logistic regression model has not converged,
    and may not be valid.
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过多的费舍尔迭代，或过大的系数与非常大的标准误差可能是你的逻辑回归模型没有收敛，可能无效的迹象。
- en: '`glm()` provides good diagnostics, but rechecking your model on test data is
    still your most effective diagnostic.'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glm()` 提供了良好的诊断，但仍然需要在测试数据上重新检查你的模型，这是你最有效的诊断方法。'
- en: 7.3\. Regularization
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3. 正则化
- en: 'As mentioned earlier, overly large coefficient magnitudes and overly large
    standard errors can indicate some issues in your model: nearly collinear variables
    in either a linear or logistic regression, or separation or quasi-separation in
    a logistic regression system.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，过大的系数绝对值和过大的标准误差可能表明你的模型存在一些问题：线性或逻辑回归中的几乎共线变量，或者在逻辑回归系统中存在分离或准分离。
- en: Nearly collinear variables can cause the regression solver to needlessly introduce
    large coefficients that often nearly cancel each other out, and that have large
    standard errors. Separation/quasi-separation can cause a logistic regression to
    not converge to the intended solution; this is a separate source of large coefficients
    and large standard errors.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎共线的变量可能导致回归求解器不必要地引入大的系数，这些系数通常几乎相互抵消，并且具有大的标准误差。分离/准分离可能导致逻辑回归无法收敛到预期的解；这是大系数和大标准误差的另一个来源。
- en: Overly large coefficient magnitudes are less trustworthy and can be hazardous
    when the model is applied to new data. Each of the coefficient estimates has some
    measurement noise, and with large coefficients this noise in estimates can drive
    large variations (and errors) in prediction. Intuitively speaking, large coefficients
    fit to nearly collinear variables must cancel each other out in the training data
    to express the observed effect of the variables on the outcome. This set of cancellations
    is an overfit of the training data, if the same variables don’t balance out in
    exactly the same way in future data.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 过大的系数绝对值不太可靠，当模型应用于新数据时可能会带来风险。每个系数估计都存在一些测量噪声，而大的系数会导致估计中的噪声驱动预测中的大变化（和错误）。直观地说，拟合几乎共线的变量的大的系数必须在训练数据中相互抵消，以表达变量对结果的影响。如果未来的数据中相同的变量没有以完全相同的方式平衡，这种抵消集合就是对训练数据的过度拟合。
- en: '* * *'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Example
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '*Suppose that* `age` *and* `years_in_workforce` *are strongly correlated, and
    being one year older/one year longer in the workforce increases log income by
    one unit in the training data. If only* `years_in_workforce` *is in the model,
    it would get a coefficient of about 1\. What happens if the model includes* `age`
    *as well?*'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '*假设* `age` *和* `years_in_workforce` *高度相关，并且年龄增长一年/在劳动力市场工作一年更长，在训练数据中会使对数收入增加一个单位。如果模型中只有*
    `years_in_workforce` *，它将得到大约1的系数。如果模型包括* `age` *又会发生什么？*'
- en: '* * *'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: In some circumstances, if both `age` and `years_in_workforce` are in the model,
    linear regression might give `years_in_workforce` and `age` large counterbalancing
    coefficients of opposite sign; for instance a coefficient of 99 for `years_in_workforce`
    and `age` a coefficient of –98\. These large coefficients would “cancel each other
    out” to the appropriate effect.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，如果模型中同时包含`age`和`years_in_workforce`，线性回归可能会给`years_in_workforce`和`age`分配大的、符号相反的平衡系数；例如，`years_in_workforce`的系数为99，而`age`的系数为-98。这些大的系数将“相互抵消”以达到适当的效果。
- en: A similar effect can arise in a logistic model due to quasi-separation, even
    when there are no collinear variables. To demonstrate this, we’ll introduce the
    bigger scenario that we will work with in this section.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 由于准分离，即使没有共线变量，逻辑模型也可能产生类似的效果。为了演示这一点，我们将引入本节中将处理的更大场景。
- en: 7.3.1\. An example of quasi-separation
  id: totrans-538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1\. 准分离的一个例子
- en: '* * *'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Example
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '*Suppose a car review site rates cars on several characteristics, including
    affordability and safety rating. Car ratings can be “very good,” “good,” “acceptable,”
    or “unacceptable.” Your goal is to predict whether a car will fail the review:
    that is, get an unacceptable rating.*'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '*假设一个汽车评论网站根据几个特征对汽车进行评级，包括可负担性和安全评级。汽车评级可以是“非常好”、“好”、“可接受”或“不可接受”。你的目标是预测汽车是否会失败审查：也就是说，得到一个不可接受的评级。*'
- en: '* * *'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 'For this example, you will use again use the car data from the UCI Machine
    Learning Repository that you used in [chapter 2](../Text/02.xhtml#ch02). This
    dataset has information on 1728 makes of auto, with the following variables:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，你将再次使用UCI机器学习仓库中你在[第2章](../Text/02.xhtml#ch02)中使用过的汽车数据。这个数据集包含1728种汽车的信息，以下变量：
- en: '*`car_price`*—(vhigh, high, med, low)'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`car_price`*—(非常高，高，中，低)'
- en: '*`maint_price`*—(vhigh, high, med, low)'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`maint_price`*—(非常高，高，中，低)'
- en: '*`doors`*—(2, 3, 4, 5, more)'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`doors`*—(2，3，4，5，更多)'
- en: '*`persons`*—(2, 4, more)'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`persons`*—(2，4，更多)'
- en: '*`lug_boot`*—(small, med, big)'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`lug_boot`*—(小，中，大)'
- en: '*`safety`*—(low, med, high)'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*`safety`*—(低，中，高)'
- en: The outcome variable is `rating` (vgood, good, acc, unacc).
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 结果变量是`rating`（vgood，good，acc，unacc）。
- en: First, let’s read in the data and split it into training and test. If you have
    not done so already, download car.data.csv from [https://github.com/WinVector/PDSwR2/blob/master/UCICar/car.data.csv](https://github.com/WinVector/PDSwR2/blob/master/UCICar/car.data.csv)
    and make sure the file is in your working directory.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们读取数据并将其分割为训练集和测试集。如果您还没有这样做，请从 [https://github.com/WinVector/PDSwR2/blob/master/UCICar/car.data.csv](https://github.com/WinVector/PDSwR2/blob/master/UCICar/car.data.csv)
    下载 `car.data.csv` 文件，并确保该文件位于您的当前工作目录中。
- en: Listing 7.21\. Preparing the `cars` data
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.21\. 准备 `cars` 数据
- en: '[PRE45]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ❶ Gets the input variables
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取输入变量
- en: ❷ You want to predict whether the car gets an unacceptable rating
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 你想要预测汽车是否会获得不可接受的评级
- en: ❸ Creates the grouping variable for the test/train split (70% for training,
    30% for test)
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为测试/训练分割创建分组变量（70%用于训练，30%用于测试）
- en: ❹ The split() function returns a list of two groups with the group gp < 0.7
    == FALSE first. The zeallot package’s %<-% multiassignment takes this list of
    values and unpacks them into the variables named cars_test and cars_train.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ `split()` 函数返回一个包含两个组的列表，其中 `gp < 0.7 == FALSE` 的组排在前面。zeallot 包的 `%<-%` 多重赋值操作将这个值列表解包到名为
    `cars_test` 和 `cars_train` 的变量中。
- en: The first thing you might do to solve this problem is try a simple logistic
    regression.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的第一个可能方法是尝试简单的逻辑回归。
- en: Listing 7.22\. Fitting a logistic regression model
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.22\. 拟合逻辑回归模型
- en: '[PRE46]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You will see that `glm()` returns a warning:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到 `glm()` 返回一个警告：
- en: '[PRE47]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This warning indicates that the problem is quasi-separable: some set of variables
    perfectly predicts a subset of the data. In fact, this problem is simple enough
    that you can easily determine that a safety rating of low perfectly predicts that
    a car will fail the review (we leave that as an exercise for the reader). However,
    even cars with higher safety ratings can get ratings of unacceptable, so the safety
    variable only predicts a subset of the data.'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 这个警告表明问题是准可分的：一些变量集合可以完美预测数据的一个子集。实际上，这个问题足够简单，您可以很容易地确定低安全评级可以完美预测汽车将无法通过评审（我们将这作为读者的练习）。然而，即使安全评级较高的汽车也可能获得不可接受的评级，因此安全变量只能预测数据的一个子集。
- en: You can also see the problem if you look at the summary of the model.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过查看模型摘要来看到这个问题。
- en: Listing 7.23\. Looking at the model summary
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.23\. 查看模型摘要
- en: '[PRE48]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ❶ The variables persons4 and personsmore have notably large negative magnitudes,
    and a giant standard error.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 变量 `persons4` 和 `personsmore` 具有显著的大负幅度和巨大的标准误差。
- en: ❷ The variable safetylow has a notably large positive magnitude, and a giant
    standard error.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 变量 `safetylow` 具有显著的大正幅度和巨大的标准误差。
- en: ❸ The algorithm ran for an unusually large number of Fisher scoring iterations.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 算法运行了异常大量的 Fisher 评分迭代。
- en: The variables `safetylow`, `persons4`, and `personsmore` all have unusually
    high magnitudes and very high standard errors. As mentioned earlier, `safetylow`
    always corresponds to an unacceptable rating, so `safetylow` is a strong indicator
    of failing the review. However, larger cars (cars that hold more people) are not
    always going to pass the review. It’s possible that the algorithm has observed
    that larger cars tend to be safer (get a safety rating better than `safetylow`),
    and so it is using the `persons4` and `personsmore` variables to cancel out the
    overly high coefficient from `safetylow`.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `safetylow`、`persons4` 和 `personsmore` 都具有异常高的幅度和非常高的标准误差。如前所述，`safetylow`
    总是与不可接受的评级相对应，因此 `safetylow` 是评审失败的一个强烈指标。然而，更大的汽车（能容纳更多人的汽车）并不总是能通过评审。可能算法观察到更大的汽车往往更安全（获得比
    `safetylow` 更好的安全评级），因此它使用 `persons4` 和 `personsmore` 变量来抵消 `safetylow` 过高的系数。
- en: In addition, you can see that the number of Fisher scoring iterations is unusually
    high; the algorithm did not converge.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以看到 Fisher 评分迭代次数异常高；算法没有收敛。
- en: This problem is fairly simple, so the model may predict acceptably well on the
    test set; however, in general, when you see evidence that `glm()` did not converge,
    you should not trust the model.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题相当简单，因此模型可能在测试集上预测得相当好；然而，一般来说，当您看到 `glm()` 没有收敛的证据时，您不应该相信这个模型。
- en: For comparison with the regularized algorithms, let’s plot the coefficients
    of the logistic regression model ([figure 7.17](../Text/07.xhtml#ch07fig17)).
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与正则化算法进行比较，让我们绘制逻辑回归模型的系数（[图 7.17](../Text/07.xhtml#ch07fig17)）。
- en: Figure 7.17\. Coefficients of the logistic regression model
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17\. 逻辑回归模型的系数
- en: '![](Images/07fig17_alt.jpg)'
  id: totrans-575
  prefs: []
  type: TYPE_IMG
  zh: '![图像 7.17](Images/07fig17_alt.jpg)'
- en: Listing 7.24\. Looking at the logistic model’s coefficients
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.24。查看逻辑模型的系数
- en: '[PRE49]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ Gets the coefficients (except the intercept)
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取系数（除了截距）
- en: In the plot, coefficients that point to the right are positively correlated
    with failing the review, and coefficients that point to the left are negatively
    correlated with failure.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，指向右的系数与未通过审查正相关，而指向左的系数与失败负相关。
- en: You can also look at the model’s performance on the test data.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以查看模型在测试数据上的表现。
- en: Listing 7.25\. The logistic model’s test performance
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.25。逻辑模型的测试性能
- en: '[PRE50]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ Gets the model’s predictions on the test set
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取模型在测试集上的预测
- en: ❷ Attaches the sigr package for deviance calculation (sigr includes a number
    of goodness-of-fit summaries and tests)
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 添加 sigr 包以进行偏差计算（sigr 包含多个拟合优度摘要和测试）
- en: ❸ Convenience function to print confusion matrix, accuracy, and deviance
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 打印混淆矩阵、准确率和偏差的便利函数
- en: In this case, the model seems to be good. However, you cannot always trust non-converged
    models, or models with needlessly large coefficients.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，模型看起来是好的。然而，你并不能总是信任非收敛模型，或者那些系数过大的模型。
- en: In situations where you see suspiciously large coefficients with extremely large
    standard errors, whether due to collinearity or quasi-separation, we recommend
    regularization.^([[1](../Text/07.xhtml#ch07fn12)]) Regularization adds a penalty
    to the formulation that biases the model’s coefficients towards zero. This makes
    it harder for the solver to drive the coefficients to unnecessarily large values.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在你看到系数异常大且标准误差极端大的情况下，无论是由于共线性还是准分离，我们建议使用正则化。[^([1](../Text/07.xhtml#ch07fn12))]
    正则化向公式中添加了一个惩罚，使模型的系数偏向于零。这使得求解器难以将系数驱动到不必要的过大值。
- en: ¹
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-589
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Some people suggest using principal components regression (PCR) to deal with
    collinear variables: PCR uses the existing variables to create synthetic variables
    that are mutually orthogonal, eliminating the collinearities. This won’t help
    with quasi-separation. We generally prefer regularization.'
  id: totrans-590
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有些人建议使用主成分回归（PCR）来处理共线性变量：PCR 使用现有变量创建相互正交的合成变量，消除共线性。这不会帮助解决准分离问题。我们通常更喜欢正则化。
- en: '* * *'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Regarding overfitting**'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于过拟合**'
- en: The modeling goal is to predict well on future application data. Improving your
    measured performance on training data does not always do this. This is what we’ve
    been discussing as overfit. Regularization degrades the quality of the training
    data fit, in the hope of improving future model performance.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 建模的目标是在未来的应用数据上做出良好的预测。提高你在训练数据上的测量性能并不总是能达到这一点。这就是我们一直在讨论的过拟合问题。正则化会降低训练数据拟合的质量，以期提高未来模型的表现。
- en: '* * *'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 7.3.2\. The types of regularized regression
  id: totrans-595
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2。正则化回归的类型
- en: There are multiple types of regularized regression, each defined by the penalty
    that is put on the model’s coefficients. Here we cover the different regularization
    approaches.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种类型的正则化回归，每种类型都由对模型系数施加的惩罚定义。在这里，我们涵盖了不同的正则化方法。
- en: Ridge regression
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 岭回归
- en: '*Ridge regression* (or L2-regularized regression) tries to minimize the training
    prediction error, subject to also minimizing the sum of the squared magnitudes
    of the coefficients.^([[2](../Text/07.xhtml#ch07fn13)]) Let’s look at ridge regularized
    linear regression. Remember that linear regression tries to find the coefficients
    `b` such that'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '*岭回归*（或 L2-正则化回归）试图在最小化训练预测误差的同时，也最小化系数的平方幅度之和。[^([2](../Text/07.xhtml#ch07fn13))]
    让我们看看岭回归正则化线性回归。记住，线性回归试图找到系数 `b`，使得'
- en: ²
  id: totrans-599
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-600
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is called “the L2 norm of the vector of coefficients,” hence the name.
  id: totrans-601
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这被称为“系数向量的 L2 范数”，因此得名。
- en: '[PRE51]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: is as close as possible to `y[i]` for all the training data. It does this by
    minimizing `(y - f(x))^2`, the sum of the squared error between `y` and `f(x)`.
    Ridge regression tries to find the `b` that minimizes
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有训练数据，预测值尽可能接近 `y[i]`。它是通过最小化 `(y - f(x))^2`，即 `y` 和 `f(x)` 之间平方误差的和来做到这一点的。岭回归试图找到使
    `b` 最小的值
- en: '[PRE52]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: where `lambda` >= 0\. When `lambda` = 0, this reduces to regular linear regression;
    the larger `lambda` is, the harder the algorithm will penalize large coefficients.
    The expression for regularized logistic regression is similar.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `lambda` >= 0。当 `lambda` = 0 时，这会退化为常规线性回归；`lambda` 越大，算法对大系数的惩罚就越严格。正则化逻辑回归的表达式类似。
- en: '* * *'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**How ridge regression affects coefficients**'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '**岭回归对系数的影响**'
- en: When variables are nearly collinear, ridge regression tends to average the collinear
    variables together. You can think of this as “ridge regression shares the credit.”
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量几乎完全线性相关时，岭回归往往会将线性相关的变量平均在一起。你可以将其视为“岭回归共享信用。”
- en: For instance, let’s go back to the example of fitting a linear regression for
    log income using both age and years in workforce (which are nearly collinear).
    Recall that being one year older/one year longer in the workforce increases log
    income by one unit in the training data.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们回到使用年龄和工作年限（这两个变量几乎完全线性相关）来拟合对数收入的线性回归的例子。回想一下，在训练数据中，年龄增加一年或工作年限增加一年会使对数收入增加一个单位。
- en: In this situation, ridge regression might assign both variables `age` and `years_in_workforce`
    a coefficient of 0.5, which adds up to the appropriate effect.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，岭回归可能会将变量`age`和`years_in_workforce`的系数都分配为0.5，这加起来是适当的效果。
- en: '* * *'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Lasso regression
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: Lasso回归
- en: '*Lasso regression* (or L1-regularized regression) tries to minimize the training
    prediction error, subject to also minimizing the sum of the absolute value of
    the coefficients.^([[1](../Text/07.xhtml#ch07fn14)]) For linear regression, this
    looks like minimizing'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lasso回归*（或L1正则化回归）试图在最小化训练预测误差的同时，也最小化系数绝对值的总和。[^1] 对于线性回归，这看起来就像是最小化'
- en: ¹
  id: totrans-614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-615
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Or the “L1 norm of the vector of coefficients.”
  id: totrans-616
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 或者“系数向量的L1范数。”
- en: '[PRE53]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '* * *'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**How lasso regression affects coefficients**'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '**lasso回归如何影响系数**'
- en: When variables are nearly collinear, lasso regression tends to drive one or
    more of them to zero. So in the income scenario, lasso regression might assign
    `years_in_workforce` a coefficient of 1 and `age` a coefficient of 0.^([[a](../Text/07.xhtml#ch07fn15a)])
    For this reason, lasso regression is often used as a form of variable selection.
    A larger lambda will tend to drive more coefficients to zero.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量几乎完全线性相关时，lasso回归往往会将其中一个或多个变量驱动到零。因此，在收入场景中，lasso回归可能会将`years_in_workforce`的系数分配为1，而将`age`的系数分配为0。[^a]
    因此，lasso回归通常被用作一种变量选择方法。较大的lambda值往往会将更多系数驱动到零。
- en: ^a
  id: totrans-621
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a
- en: ''
  id: totrans-622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As Hastie et al. point out in *The Elements of Statistical Learning*, 2nd ed
    (Springer, 2009), which of the correlated variables get zeroed out is somewhat
    arbitrary.
  id: totrans-623
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如Hastie等人所指出的，在《统计学习的要素》第2版（Springer，2009年），哪些相关变量被置零是有些任意的。
- en: '* * *'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Elastic net
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: Elastic net
- en: 'In some situations, like quasi-separability, the ridge solution may be preferred.
    In other situations, such as when you have a very large number of variables, many
    of which are correlated to each other, the lasso may be preferred. You may not
    be sure which is the best approach, so one compromise is to combine the two. This
    is called *elastic net*. The penalty of using elastic net is a combination of
    the ridge and the lasso penalties:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，如准分离性，岭回归的解可能更受欢迎。在其他情况下，例如当你有大量变量，其中许多变量相互关联时，lasso可能更受欢迎。你可能不确定哪种方法最好，所以一种折衷的方法是将两者结合起来。这被称为*弹性网络*。使用弹性网络的惩罚是岭回归和lasso惩罚的组合：
- en: '[PRE54]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When `alpha` = 0, this reduces to ridge regression; when `alpha` = 1, it reduces
    to lasso. Different values of `alpha` between 0 and 1 give different trade-offs
    between sharing the credit among correlated variables, and only keeping a subset
    of them.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 当`alpha` = 0时，这会降低到岭回归；当`alpha` = 1时，它降低到lasso。在0和1之间的不同`alpha`值给出了在共享相关变量之间的信用和仅保留它们的一个子集之间的不同权衡。
- en: 7.3.3\. Regularized regression with glmnet
  id: totrans-629
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3. 使用glmnet的正则化回归
- en: All the types of regularized regression that we’ve discussed are implemented
    in R by the package `glmnet`. Unfortunately, the `glmnet` package uses a calling
    interface that is not very R-like; in particular, it expects that the input data
    is a numeric matrix rather than a data frame. So we’ll use the `glmnetUtils` package
    to provide a more R-like interface to the functions.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所讨论的所有正则化回归类型都由R中的`glmnet`包实现。不幸的是，`glmnet`包使用了一个不太像R的调用接口；特别是，它期望输入数据是一个数值矩阵而不是数据框。因此，我们将使用`glmnetUtils`包来为函数提供更R式的接口。
- en: '* * *'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '**Calling interfaces**'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '**调用接口**'
- en: It would be best if all modeling procedures had the same calling interface.
    The `lm()` and `glm()` packages nearly do, and `glmnetUtils` helps make `glmnet`
    more compatible with R’s calling interface conventions.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有建模过程都有相同的调用接口，那就最好不过了。`lm()`和`glm()`包几乎做到了，而`glmnetUtils`帮助使`glmnet`更符合R的调用接口约定。
- en: However, to use a given method correctly, you must know some things about its
    particular constraints and consequences. This means that even if all modeling
    methods had the same calling interface, you still must study the documentation
    to understand how to use it properly.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要正确使用某种方法，你必须了解一些关于其特定约束和后果的事情。这意味着即使所有建模方法都有相同的调用接口，你仍然必须研究文档来了解如何正确使用它。
- en: '* * *'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Let’s compare the different regularization approaches on the car-ratings prediction
    problem.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较一下不同的正则化方法在汽车评分预测问题上的应用。
- en: The ridge regression solution
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 岭回归的解决方案
- en: When reducing the number of variables is not an issue, we generally try ridge
    regression first, because it’s a smoother regularization that we feel retains
    the most interpretability for the coefficients (but see the warning later in this
    section). The parameter `alpha` specifies the mixture of ridge and lasso penalties
    (0=ridge, 1=lasso); so for ridge regression, set `alpha = 0`. The parameter `lambda`
    is the regularization penalty.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 当减少变量数量不是问题的时候，我们通常首先尝试岭回归，因为它是一种更平滑的正则化，我们觉得它保留了系数的最大可解释性（但请参阅本节后面的警告）。参数 `alpha`
    指定了岭回归和 Lasso 惩罚的混合（0=岭回归，1=Lasso）；因此对于岭回归，设置 `alpha = 0`。参数 `lambda` 是正则化惩罚。
- en: 'Since you generally don’t know the best `lambda`, the original function `glmnet::
    glmnet()` tries several values of `lambda` (100 by default) and returns the models
    corresponding to each value. The function `glmnet::cv.glmnet()` in addition does
    the cross-validation needed to pick the `lambda` that gives the minimum cross-validation
    error for a fixed `alpha`, and returns it as the field `lambda.min`. It also returns
    a value `lambda.1se`, the largest value of `lambda` such that the error is within
    1 standard error of the minimum. This is shown in [figure 7.18](../Text/07.xhtml#ch07fig18).'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '由于你通常不知道最佳的 `lambda` 值，原始函数 `glmnet:: glmnet()` 会尝试几个 `lambda` 值（默认为 100）并返回对应每个值的模型。`glmnet::cv.glmnet()`
    函数除了执行交叉验证以选择固定 `alpha` 的最小交叉验证误差的 `lambda` 值，并将其作为 `lambda.min` 字段返回外，还返回一个值
    `lambda.1se`，这是使误差在最小值 1 个标准误差范围内的 `lambda` 的最大值。这如图 7.18 所示。'
- en: Figure 7.18\. Schematic of `cv.glmnet()`
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18\. `cv.glmnet()` 的示意图
- en: '![](Images/07fig18_alt.jpg)'
  id: totrans-641
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig18_alt.jpg)'
- en: The function `glmnetUtils::cv.glmnet()` lets you call the cross-validated version
    in an R-friendlier way.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `glmnetUtils::cv.glmnet()` 允许你以更友好的 R 方式调用交叉验证版本。
- en: When using regularized regression, it’s a good idea to standardize, or center
    and scale the data (see [section 4.2.2](../Text/04.xhtml#ch04lev2sec5)). Fortunately,
    `cv.glmnet()` does this by default. If for some reason you want to turn this off
    (perhaps you have already standardized the data), use the parameter `standardize
    = FALSE`.^([[1](../Text/07.xhtml#ch07fn15)])
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用正则化回归时，标准化数据（或中心化和缩放数据）（见 [4.2.2 节](../Text/04.xhtml#ch04lev2sec5)）是一个好主意。幸运的是，`cv.glmnet()`
    默认就会这样做。如果出于某种原因你想关闭这个功能（可能你已经标准化了数据），使用参数 `standardize = FALSE`。^([[1](../Text/07.xhtml#ch07fn15)])
- en: ¹
  id: totrans-644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-645
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For help/documentation on `glmnetUtils::cv.glmnet()`, see `help(cv.glmnet, package
    = "glmnet-Utils")`, `help(cv.glmnet, package = "glmnet")`, and `help(glmnet, package
    = "glmnet")`.
  id: totrans-646
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关于 `glmnetUtils::cv.glmnet()` 的帮助/文档，请参阅 `help(cv.glmnet, package = "glmnet-Utils")`、`help(cv.glmnet,
    package = "glmnet")` 和 `help(glmnet, package = "glmnet")`。
- en: Listing 7.26\. Fitting the ridge regression model
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.26\. 拟合岭回归模型
- en: '[PRE55]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ❶ For logistic regression-style models, use family = “binomial”. For linear
    regression-style models, use family = “gaussian”.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对于逻辑回归风格的模型，使用 family = “binomial”。对于线性回归风格的模型，使用 family = “gaussian”。
- en: Printing out `model_ridge` tells you the lambda that corresponds to the minimum
    cross-validation error (the deviance)—that is, `model_ridge$lambda.min`. It also
    reports the value of `model_ridge$lambda.1se`.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出 `model_ridge` 会告诉你对应于最小交叉验证误差（偏差）的 lambda 值，即 `model_ridge$lambda.min`。它还报告了
    `model_ridge$lambda.1se` 的值。
- en: Remember that `cv.glmnet()` returns 100 (by default) models; of course, you
    really only want one—the “best” one. As shown in [figure 7.18](../Text/07.xhtml#ch07fig18),
    when you call a function like `predict()` or `coef()`, the `cv.glmnet` object
    by default uses the model corresponding to `lambda.1se`, as some people consider
    `lambda.1se` less likely to be overfit than `lambda.min`.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`cv.glmnet()` 默认返回 100 个模型；当然，你实际上只需要一个——“最佳”模型。如图 7.18 所示，当你调用 `predict()`
    或 `coef()` 等函数时，`cv.glmnet` 对象默认使用对应于 `lambda.1se` 的模型，因为有些人认为 `lambda.1se` 比最小值
    `lambda.min` 更不可能过拟合。
- en: The following listing examines the coefficients of the `lambda.1se` model. If
    you want to see the model corresponding to `lambda.min`, replace the first line
    of the listing with `(coefs <- coef(model_ridge, s = model_ridge$lambda.min))`.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表检查`lambda.1se`模型的系数。如果您想看到对应于`lambda.min`的模型，将列表中的第一行替换为`(coefs <- coef(model_ridge,
    s = model_ridge$lambda.min))`。
- en: Listing 7.27\. Looking at the ridge model’s coefficients
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.27\. 查看岭模型的系数
- en: '[PRE56]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ❶ Note that all the levels of the categorical variable persons are present (no
    reference level).
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注意，分类变量persons的所有级别都存在（没有参考级别）。
- en: 'Notice that `cv.glmnet()` does not use reference levels for categorical variables:
    for instance, the `coefs` vector includes the variables `persons2`, `persons4`,
    and `personsmore`, corresponding to the levels 2, 4, and “more” for the `persons`
    variable. The logistic regression model in [section 7.3.1](../Text/07.xhtml#ch07lev2sec13)
    used the variables `persons4` and `personsmore`, and used the level value `2`
    as the reference level. Using all the variable levels when regularizing has the
    advantage that the coefficient magnitudes are regularized toward zero, rather
    than toward a (possibly arbitrary) reference level.'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`cv.glmnet()`不使用分类变量的参考级别：例如，`coefs`向量包括变量`persons2`、`persons4`和`personsmore`，对应于`persons`变量的级别2、4和“more”。[7.3.1节](../Text/07.xhtml#ch07lev2sec13)中的逻辑回归模型使用了变量`persons4`和`personsmore`，并使用级别值`2`作为参考级别。在正则化时使用所有变量级别的好处是，系数的大小会正则化到零，而不是到一个（可能是任意的）参考级别。
- en: You can see in [figure 7.19](../Text/07.xhtml#ch07fig19) that this model no
    longer has the unusually large magnitudes. The directions of the coefficients
    suggest that low safety ratings, small cars, and very high purchase or maintenance
    price all positively predict rating of unacceptable. One might suspect that small
    cars correlate with low safety ratings, so `safetylow` and `persons2` are probably
    sharing the credit.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[图7.19](../Text/07.xhtml#ch07fig19)中看到，该模型不再具有异常大的幅度。系数的方向表明，低安全评级、小型汽车以及非常高的购买或维护价格都正向预测不可接受的评级。有人可能会怀疑小型汽车与低安全评级相关，因此`safetylow`和`persons2`可能共享了这一荣誉。
- en: Figure 7.19\. Coefficients of the ridge regression model
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19\. 岭回归模型的系数
- en: '![](Images/07fig19_alt.jpg)'
  id: totrans-659
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig19_alt.jpg)'
- en: '* * *'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Regularization affects interpretability
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 正则化影响可解释性
- en: Because regularization adds an additional term to the algorithm’s optimization
    function, you can’t quite interpret the coefficients the same way you did in [sections
    7.1.4](../Text/07.xhtml#ch07lev2sec4) and [7.2.4](../Text/07.xhtml#ch07lev2sec10).
    For instance, no coefficient significances are reported. However, you can at least
    use the signs of the coefficients as indications of which variables are positively
    or negatively correlated with the outcome in the joint model.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 因为正则化向算法的优化函数添加了一个额外的项，所以您不能像在[7.1.4节](../Text/07.xhtml#ch07lev2sec4)和[7.2.4节](../Text/07.xhtml#ch07lev2sec10)中那样解释系数。例如，没有报告系数的显著性。然而，您至少可以使用系数的符号作为指示，哪些变量在联合模型中与结果呈正相关或负相关。
- en: '* * *'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: You can also evaluate the performance of `model_ridge` on the test data.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以评估`model_ridge`在测试数据上的性能。
- en: Listing 7.28\. Looking at the ridge model’s test performance
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.28\. 查看岭模型的测试性能
- en: '[PRE57]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ❶ The prediction variable is a 1-d matrix; convert it to a vector before adding
    it to the cars_test data frame.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 预测变量是一个一维矩阵；在将其添加到cars_test数据框之前，需要将其转换为向量。
- en: 'To look at the predictions for the model corresponding to `lambda.min`, replace
    the first command of the preceding listing with this:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看对应于`lambda.min`的模型的预测，将前面列表中的第一个命令替换为以下命令：
- en: '[PRE58]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The lasso regression solution
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: lasso回归解决方案
- en: You can run the same steps as in the previous section with `alpha = 1` (the
    default) to fit a lasso regression model. We leave fitting the model as an exercise
    for the reader; here are the results.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`alpha = 1`（默认值）与上一节相同的步骤来拟合lasso回归模型。我们将拟合模型作为练习留给读者；以下是结果。
- en: Listing 7.29\. The lasso model’s coefficients
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.29\. lasso模型的系数
- en: '[PRE59]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you see in [figure 7.20](../Text/07.xhtml#ch07fig20), `cv.glmnet()` did not
    reduce the magnitudes of the largest coefficients as much, although it did zero
    out a few variables (`doors3`, `personsmore`, `lug_boot_med`, `safety_med`), and
    it selected a similar set of variables as strongly predictive of an unacceptable
    rating.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图7.20](../Text/07.xhtml#ch07fig20)所示，`cv.glmnet()` 并没有减少最大系数的幅度，尽管它将一些变量（`doors3`、`personsmore`、`lug_boot_med`、`safety_med`）置零，并且选择了与强烈预测不可接受评分相似的变量集。
- en: Figure 7.20\. Coefficients of the lasso regression model
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20\. lasso回归模型的系数
- en: '![](Images/07fig20_alt.jpg)'
  id: totrans-676
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig20_alt.jpg)'
- en: The lasso model’s accuracy on the test data is similar to the ridge model’s,
    but the deviance is much lower, indicating better model performance on the test
    data.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试数据上，lasso模型的准确度与ridge模型相似，但偏差要低得多，这表明在测试数据上模型性能更好。
- en: Listing 7.30\. The lasso model’s test performance
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.30\. lasso模型的测试性能
- en: '[PRE60]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The elastic net solution: picking alpha'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性网络解决方案：选择alpha
- en: The `cv.glmnet()` function only optimizes over `lambda`; it assumes that `alpha`,
    the variable that specifies the mix of the ridge and lasso penalties, is fixed.
    The `glmnetUtils` package provides a function called `cva.glmnet()` that will
    simultaneously cross-validate for both `alpha` and `lambda`.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv.glmnet()` 函数仅优化 `lambda`；它假设 `alpha`，指定岭回归和lasso惩罚混合的变量是固定的。`glmnetUtils`
    包提供了一个名为 `cva.glmnet()` 的函数，该函数将对 `alpha` 和 `lambda` 同时进行交叉验证。'
- en: Listing 7.31\. Cross-validating for both `alpha` and `lambda`
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.31\. 对 `alpha` 和 `lambda` 进行交叉验证
- en: '[PRE61]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The process of extracting the best model is a bit involved. Unlike `cv.glmnet`,
    `cva.glmnet` doesn’t return an `alpha.min` or an `alpha.1se`. Instead, the field
    `elastic_ net$alpha` returns all the alphas that the function tried (11 of them,
    by default), and `elastic_net$modlist` returns all the corresponding `glmnet::cv.glmnet`
    model objects (see [figure 7.21](../Text/07.xhtml#ch07fig21)). Each one of these
    model objects is really 100 models, so for a given `alpha`, we’ll choose the `lambda.1se`
    model as “the best model.”
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 提取最佳模型的过程稍微复杂一些。与 `cv.glmnet` 不同，`cva.glmnet` 不返回 `alpha.min` 或 `alpha.1se`。相反，字段
    `elastic_net$alpha` 返回函数尝试的所有alpha值（默认情况下为11个），而 `elastic_net$modlist` 返回所有相应的
    `glmnet::cv.glmnet` 模型对象（参见[图7.21](../Text/07.xhtml#ch07fig21)）。这些模型对象中的每一个实际上都是100个模型，因此对于给定的
    `alpha`，我们将选择 `lambda.1se` 模型作为“最佳模型”。
- en: Figure 7.21\. Schematic of using `cva.glmnet` to pick `alpha`
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21\. 使用 `cva.glmnet` 选择 `alpha` 的示意图
- en: '![](Images/07fig21_alt.jpg)'
  id: totrans-686
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig21_alt.jpg)'
- en: The following listing implements the process sketched in [figure 7.21](../Text/07.xhtml#ch07fig21)
    to get the mean cross-validation error for each “best model,” and plot the errors
    as a function of `alpha` ([figure 7.22](../Text/07.xhtml#ch07fig22)). You can
    create a similar plot using the function `minlossplot(elastic_ net)`, but the
    following listing also returns the value of the best tested `alpha`.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表实现了在[图7.21](../Text/07.xhtml#ch07fig21)中概述的过程，以获取每个“最佳模型”的平均交叉验证误差，并将误差作为alpha的函数绘制出来（[图7.22](../Text/07.xhtml#ch07fig22)）。您可以使用函数
    `minlossplot(elastic_net)` 创建类似的图表，但下面的列表还返回了最佳测试的 `alpha` 值。
- en: Figure 7.22\. Cross-validation error as a function of `alpha`
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22\. 交叉验证误差作为alpha的函数
- en: '![](Images/07fig22_alt.jpg)'
  id: totrans-689
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig22_alt.jpg)'
- en: Listing 7.32\. Finding the minimum error `alpha`
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.32\. 寻找最小误差 `alpha`
- en: '[PRE62]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: ❶ A function to get the mean cross-validation error of a cv.glmnet lambda.1se
    model
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取cv.glmnet lambda.1se模型平均交叉验证误差的函数
- en: ❷ Gets the alphas that the algorithm tried
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取算法尝试的alpha值
- en: ❸ Gets the model objects produced
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取生成的模型对象
- en: ❹ Gets the errors of each best model
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 获取每个最佳模型的误差
- en: ❺ Finds the minimum cross-validation error
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 找到最小交叉验证误差
- en: ❻ Gets the corresponding alpha
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 获取相应的alpha
- en: ❻ Plots the model performances as a function of alpha
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将模型性能作为alpha的函数绘制
- en: Remember that both `cv.glmnet` and `cva.glmnet` are randomized, so the results
    can vary from run to run. The documentation for `glmnetUtils` ([https://cran.r-project.org/web/packages/glmnetUtils/vignettes/intro.html](https://cran.r-project.org/web/packages/glmnetUtils/vignettes/intro.html))
    recommends running `cva.glmnet` multiple times to reduce the noise. If you want
    to cross-validate for `alpha`, we suggest calculating the equivalent of `enet_performance`
    multiple times, and averaging the values of the `cvm` column together—the `alpha`
    values will be identical from run to run, although the corresponding `lambda.1se`
    values may not be. After you’ve determined the `alpha` that corresponds to the
    best average `cvm`, call `cv.glmnet` one more time with the chosen `alpha` to
    get the final model.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`cv.glmnet`和`cva.glmnet`都是随机的，因此结果可能每次运行都会有所不同。`glmnetUtils`的文档([https://cran.r-project.org/web/packages/glmnetUtils/vignettes/intro.html](https://cran.r-project.org/web/packages/glmnetUtils/vignettes/intro.html))建议多次运行`cva.glmnet`以减少噪声。如果您想对`alpha`进行交叉验证，我们建议多次计算`enet_performance`的等效值，并将`cvm`列的值平均在一起——每次运行的`alpha`值将是相同的，尽管相应的`lambda.1se`值可能不是。在确定了与最佳平均`cvm`相对应的`alpha`之后，再使用所选的`alpha`调用一次`cv.glmnet`以获得最终模型。
- en: Listing 7.33\. Fitting and evaluating the elastic net model
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.33\. 拟合和评估弹性网络模型
- en: '[PRE63]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: It’s also worth noting that in this case, the cross-validated loss falls off
    quite quickly after `alpha=0`, so in practice, almost any non-zero `alpha` will
    give models of similar quality.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，在这种情况下，交叉验证损失在`alpha=0`之后下降得相当快，因此在实际应用中，几乎任何非零的`alpha`都会给出相似质量的模型。
- en: Summary
  id: totrans-703
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Both linear and logistic regression assume that the outcome is a function of
    a linear combination of the inputs. This seems restrictive, but in practice linear
    and logistic regression models can perform well even when the theoretical assumptions
    aren’t exactly met. We’ll show how to further work around these limits in [chapter
    10](../Text/10.xhtml#ch10).
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 线性和逻辑回归都假设结果是一个输入线性组合的函数。这似乎很限制，但在实践中，即使理论假设并不完全符合，线性和逻辑回归模型也能表现良好。我们将在第10章（[chapter
    10](../Text/10.xhtml#ch10)）中展示如何进一步克服这些限制。
- en: Linear and logistic regression can also provide *advice* by quantifying the
    relationships between the outcomes and the model’s inputs. Since the models are
    expressed completely by their coefficients, they’re small, portable, and efficient—all
    valuable qualities when putting a model into production. If the model’s errors
    are uncorrelated with *y*, the model might be trusted to extrapolate predictions
    outside the training range. Extrapolation is never completely safe, but it’s sometimes
    necessary.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 线性和逻辑回归还可以通过量化结果与模型输入之间的关系来提供*建议*。由于模型完全由其系数表达，它们体积小、易于携带、效率高——这些都是将模型投入生产时的宝贵品质。如果模型的误差与*y*不相关，则可以信任模型在训练范围之外进行外推预测。外推永远不完全安全，但有时是必要的。
- en: In situations where variables are correlated or the prediction problem is quasi-separable,
    linear methods may not perform as well. In these cases, regularization methods
    can produce models that are safer to apply to new data, although the coefficients
    of these models are not as useful for advice about the relationships between variables
    and the outcome.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量相关或预测问题近似可分的情况下，线性方法可能表现不佳。在这些情况下，正则化方法可以产生更安全应用于新数据的模型，尽管这些模型的系数对于变量与结果之间关系建议并不那么有用。
- en: 'While learning about linear models in this chapter, we have assumed that the
    data is well behaved: the data has no missing values, the number of possible levels
    for categorical variables is low, and all possible levels are present in the training
    data. In real-world data, these assumptions are not always true. In the next chapter,
    you will learn about advanced methods to prepare ill-behaved data for modeling.'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章学习线性模型时，我们假设数据表现良好：数据没有缺失值，分类变量的可能级别数量较少，并且所有可能的级别都包含在训练数据中。在现实世界的数据中，这些假设并不总是成立。在下一章中，你将学习关于如何准备表现不佳的数据以进行建模的高级方法。
- en: In this chapter you have learned
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学到了
- en: How to predict numerical quantities with linear regression models
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用线性回归模型预测数值量
- en: How to predict probabilities or classify using logistic regression models
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用逻辑回归模型预测概率或进行分类
- en: How to interpret the diagnostics from `lm()` and `glm()` models
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何解释`lm()`和`glm()`模型的诊断结果
- en: How to interpret the coefficients of linear models
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何解释线性模型的系数
- en: How to diagnose when a linear model may not be “safe” or not as reliable (collinearity,
    quasi-separation)
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何诊断线性模型可能不“安全”或不够可靠（多重共线性，准分离）
- en: How to use `glmnet` to fit regularized linear and logistic regression models
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `glmnet` 来拟合正则化线性与逻辑回归模型
