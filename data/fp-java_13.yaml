- en: Chapter 14\. Sharing mutable state with actors
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第14章。使用演员共享可变状态
- en: '***This chapter covers***'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '***本章涵盖的内容***'
- en: Understanding the actor model
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解演员模型
- en: Using asynchronous messaging
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异步消息
- en: Building an actor framework
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建演员框架
- en: Putting actors to work
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将演员投入工作
- en: Optimizing actor performance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化演员表现
- en: 'In working through this book, you first learned that functional programming
    often deals with immutable data, which results in programs that are safer, more
    reliable, and easier to design and scale. Then you learned how mutable state can
    be handled in a functional way by passing the state along as an argument to functions.
    You saw several examples of this technique:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理这本书的过程中，你首先了解到函数式编程通常处理不可变数据，这导致程序更安全、更可靠，并且更容易设计和扩展。然后你了解到可以通过将状态作为函数的参数传递来以函数式方式处理可变状态。你看到了几个这种技术的例子：
- en: Passing the generator while generating random numbers allowed for increased
    testability.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生成随机数时传递生成器允许提高测试性。
- en: Passing the console as a parameter allowed you to send functional output to
    the screen and receive input from the keyboard.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将控制台作为参数传递允许你将功能输出发送到屏幕，并从键盘接收输入。
- en: 'This technique can be widely applied to many domains. In imperative programming,
    parsing a file is generally handled by continuously mutating the state of a component
    that represents the result of the parsing. To make this process compatible with
    functional programming, you just have to pass the state as an additional argument
    to all parsing functions. Logging can be done the same way, as well as monitoring
    performance: instead of writing to a log file in each function, you can make the
    function receive the log file as an argument, and return the augmented file as
    part of the result.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可以广泛应用于许多领域。在命令式编程中，解析文件通常通过持续修改表示解析结果的组件的状态来处理。为了使此过程与函数式编程兼容，你只需将状态作为所有解析函数的附加参数传递即可。日志记录也可以以相同的方式进行，以及监控性能：而不是在每个函数中写入日志文件，你可以让函数接收日志文件作为参数，并将增强的文件作为结果的一部分返回。
- en: The benefit of this approach is that it relieves you from caring about synchronization
    and locking when accessing resources. But this security is obtained by preventing
    data sharing. This is good because it forces you to find other, safer ways of
    doing things. Using immutable lists doesn’t automatically add safety to operations
    involving sharing those lists. It just prevents you from sharing mutable state.
    It allows you to fake a list mutation in a way that more or less corresponds to
    making defensive copies, but without the performance penalty. This is useful,
    but sometimes it’s not what you need.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的好处是，它让你在访问资源时不必关心同步和锁定。但这种安全性是通过防止数据共享获得的。这是好事，因为它迫使你找到其他更安全的方法来做事情。使用不可变列表不会自动为涉及共享这些列表的操作增加安全性。它只是阻止你共享可变状态。它允许你以某种方式模拟列表的修改，这大致对应于制作防御性副本，但不会带来性能损失。这很有用，但有时这并不是你需要的。
- en: Imagine you want to count how many times a function is called. In a single-threaded
    application, you might do this by adding the counter to the function arguments
    and returning the incremented counter as part of the result. But most imperative
    programmers would rather increment the counter as a side effect. This would work
    seamlessly, because there’s only a single thread, so no locking is necessary to
    prevent potential concurrent access. This is the same as living on a desert island.
    If you’re the only inhabitant, there’s really no need for locks on your doors.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要计算一个函数被调用的次数。在一个单线程应用程序中，你可能会通过将计数器添加到函数参数中，并将增加的计数器作为结果的一部分返回来做这件事。但大多数命令式程序员更愿意将计数器作为副作用来增加。这将无缝进行，因为只有一个线程，所以不需要锁定来防止潜在的并发访问。这就像生活在一个荒岛上。如果你是唯一的居民，那么在门上上锁实际上真的没有必要。
- en: But in a multithreaded program, how can you increment the counter in a safe
    way, avoiding concurrent access? The answer is generally to use locks or to make
    operations atomic, or both.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但在多线程程序中，你如何以安全的方式增加计数器，避免并发访问？答案通常是使用锁或使操作原子化，或者两者兼而有之。
- en: In functional programming, sharing resources has to be done as an effect, which
    means, more or less, that each time you access a shared resource, you have to
    leave the functional safety and treat this access as you did for input/output
    in [chapter 13](kindle_split_020.xhtml#ch13). Does this mean that you must then
    manage locks and synchronization? Not at all. As you learned in the previous chapters,
    functional programming is also about pushing abstraction to the limit. Sharing
    mutable state can be abstracted in such a way that you can use it without bothering
    about the gory details. One way to achieve this is to use an actor framework.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，共享资源必须作为一个效果来完成，这意味着，或多或少，每次你访问共享资源时，你都必须离开函数式安全，并将这种访问视为你在[第13章](kindle_split_020.xhtml#ch13)中处理输入/输出时所做的。这意味着你必须管理锁和同步吗？绝对不是。正如你在前面的章节中学到的，函数式编程也是关于将抽象推向极限。共享可变状态可以被抽象化，这样你就可以使用它而不用担心那些令人毛骨悚然的细节。实现这一点的一种方法就是使用演员框架。
- en: Unlike in previous chapters, here you’re not going to develop a real, complete
    actor framework. Creating a complete actor framework is such a tremendous job
    that you should probably use an existing one. Here, you’ll develop a minimal actor
    framework that will give you the feeling of what an actor framework brings to
    functional programming.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的章节不同，在这里你不会开发一个真实、完整的演员框架。创建一个完整的演员框架是一项如此巨大的工作，你可能会选择使用现有的一个。在这里，你将开发一个最小的演员框架，这将给你带来演员框架为函数式编程带来的感觉。
- en: 14.1\. The actor model
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1. 演员模型
- en: In the actor model, a multithreaded application is divided into basically single-threaded
    components called *actors*. If each actor is single threaded, it doesn’t need
    to share data using locks or synchronization. Actors communicate with other actors
    by way of effects, as if such communication were input/output. This means that
    actors rely on a mechanism for serializing the messages they receive. (Here, *serialization*
    means handling one message after the other. This isn’t to be confused with Java
    serialization.) Due to this mechanism, they can process messages one at a time
    without having to bother about concurrent access to their resources. As a result,
    an actor system can be seen as a series of functional programs communicating with
    each other through effects. Each actor can be single threaded, so there’s no concurrent
    access to resources inside. Concurrency is abstracted inside the framework.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在演员模型中，一个多线程应用程序被划分为基本单线程的组件，称为*演员*。如果每个演员都是单线程的，那么它不需要使用锁或同步来共享数据。演员通过效果与其他演员进行通信，就像这种通信是输入/输出一样。这意味着演员依赖于一种序列化他们接收到的消息的机制。（在这里，“序列化”意味着依次处理一个消息。这不要与Java序列化混淆。）由于这种机制，它们可以一次处理一个消息，而无需担心它们资源的并发访问。因此，演员系统可以看作是一系列通过效果相互通信的功能程序。每个演员都可以是单线程的，因此内部没有资源的并发访问。并发性在框架内部被抽象化。
- en: 14.1.1\. Asynchronous messaging
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.1. 异步消息传递
- en: As part of message processing, actors can send messages to other actors. Messages
    are sent asynchronously, which means there’s no answer to wait for. As soon as
    a message is sent, the sender can continue its job, which mostly consists of processing,
    one at a time, a queue of messages it receives. Of course, handling the message
    queue means that there are some concurrent accesses to the queue to manage. But
    this management is abstracted in the actor framework, so you, the programmer,
    don’t need to worry about this.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 作为消息处理的一部分，演员可以向其他演员发送消息。消息是以异步方式发送的，这意味着不需要等待答案。一旦消息被发送，发送者就可以继续其工作，这主要是由处理它接收到的消息队列中的消息组成。当然，处理消息队列意味着需要对队列进行一些并发访问的管理。但这种管理在演员框架中被抽象化，所以你，程序员，不需要担心这一点。
- en: Of course, answers to messages might be needed. Suppose an actor is responsible
    for a long computation. The client can take advantage of asynchronicity by continuing
    its own job while the computation is handled for it. But once the computation
    is done, there must be a way for the client to receive the result. This is simply
    done by having the actor responsible for the computation call back its client
    and send it the result, once again in an asynchronous way. Note that the client
    may be the original sender, though that need not always be the case.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可能需要消息的答案。假设一个演员负责一项长期计算。客户端可以利用异步性，在计算被处理的同时继续自己的工作。但是一旦计算完成，客户端必须有一种方式来接收结果。这很简单，就是让负责计算的演员回调其客户端，并以异步方式发送结果。请注意，客户端可能是原始发送者，尽管这并不总是必须的。
- en: 14.1.2\. Handling parallelization
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.2\. 处理并行化
- en: The actor model allows tasks to be parallelized by using a manager actor that’s
    responsible for breaking the task into subtasks and distributing them to a number
    of worker actors. Each time a worker actor returns a result to the manager, it’s
    given a new subtask. This model offers an advantage over other parallelization
    models in that no worker actor will ever be idle until the list of subtasks is
    empty. The downside is that the manager actor won’t participate in the computation.
    But in a real application, this generally makes no noticeable difference.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 演员模型允许通过使用一个负责将任务分解为子任务并将它们分配给多个工作演员的管理演员来并行化任务。每次一个工作演员将结果返回给管理演员时，它都会得到一个新的子任务。这种模型相较于其他并行化模型的优势在于，没有任何工作演员会在子任务列表为空之前处于空闲状态。缺点是管理演员不会参与计算。但在实际应用中，这通常不会造成明显的差异。
- en: For some tasks, the results of the subtasks may need to be reordered when they’re
    received. In such a case, the manager actor will probably send the results to
    a specific actor responsible for this job. You’ll see an example of this in [section
    14.2.3](#ch14lev2sec6). In small programs, the manager itself can handle this
    task. In [figure 14.1](#ch14fig01), this actor is called `Receiver`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些任务，当收到子任务的结果时可能需要重新排序。在这种情况下，管理演员可能会将结果发送给负责这项工作的特定演员。你可以在[第14.2.3节](#ch14lev2sec6)中看到一个例子。在小程序中，管理器本身可以处理这个任务。在[图14.1](#ch14fig01)中，这个演员被称为`Receiver`。
- en: Figure 14.1\. The `Main` actor produces the main task and sends it to the `Manager`
    actor, which splits it into subtasks that are processed in parallel by several
    `Worker` actors. Sub results are sent back to the `Manager`, which passes them
    to the `Receiver`. After collating the sub results, the `Receiver` sends the final
    result to the `Main` actor.
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.1\. `Main` 演员产生主要任务并将其发送给`Manager` 演员，
- en: '![](Images/14fig01_alt.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/14fig01_alt.jpg)'
- en: 14.1.3\. Handling actor state mutation
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.3\. 处理演员状态变更
- en: Actors can be stateless (immutable) or stateful, meaning they’re supposed to
    change their state according to the messages they receive. For example, a synchronizer
    actor may receive the results of computations that have to be reordered before
    being used.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 演员（actors）可以是无状态的（不可变的）或有状态的，这意味着它们应该根据接收到的消息来改变它们的状态。例如，一个同步器演员可能会接收到需要在使用前重新排序的计算结果。
- en: Imagine, for example, that you have a list of data that must go through heavy
    computation in order to provide a list of results. In short, this is a mapping.
    It could be parallelized by breaking the list into several sublists and giving
    these sublists to worker actors for processing. But there’s no guarantee that
    the worker actors will finish their jobs in the same order that those jobs were
    given to them. One solution for resynchronizing the results is to number the tasks.
    When a worker sends back a result, it adds the corresponding task number, so that
    the receiver can put the results in a priority queue. Not only does this allow
    automatic sorting, but it also makes it possible to process the results as an
    asynchronous stream. Each time the receiver receives a result, it compares the
    task number to the expected number. If there’s a match, it passes the result to
    the client and then looks into the priority queue to see if the first available
    result corresponds to the new expected task number. If there’s a match again,
    the dequeuing process continues until there’s no longer a match. If the received
    result doesn’t match the expected result number, it’s simply added to the priority
    queue.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，例如，您有一个必须经过大量计算才能提供结果列表的数据列表。简而言之，这是一个映射。可以通过将列表拆分为几个子列表并将这些子列表分配给工作演员进行处理来并行化。但是，不能保证工作演员将以与分配给他们的任务相同的顺序完成他们的工作。为了重新同步结果的一个解决方案是对任务进行编号。当工作演员发送回结果时，它会添加相应的任务编号，这样接收者就可以将结果放入优先队列。这不仅允许自动排序，而且还使得将结果作为异步流处理成为可能。每次接收者收到一个结果时，它会将任务编号与预期编号进行比较。如果匹配，它将结果传递给客户端，然后查看优先队列以确定第一个可用的结果是否对应于新的预期任务编号。如果再次匹配，则出队过程将继续，直到不再匹配。如果接收到的结果与预期结果编号不匹配，它将简单地添加到优先队列中。
- en: 'In such a design, the receiving actor has to handle two mutable pieces of data:
    the priority queue and the expected result number. Does this mean the actor has
    to use mutable properties? This wouldn’t be a big deal, but because actors are
    single threaded, it’s not even necessary. As you’ll see, the handling of property
    mutations can be included and abstracted into a general state-mutation process,
    allowing the programmer to use only immutable data.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的设计中，接收的演员必须处理两块可变数据：优先队列和预期结果编号。这意味着演员必须使用可变属性吗？这并不是什么大问题，但鉴于演员是单线程的，这甚至不是必要的。正如您将看到的，属性变更的处理可以包含并抽象为一个通用的状态变更过程，允许程序员仅使用不可变数据。
- en: 14.2\. Building the actor framework
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2. 构建演员框架
- en: In this section, you’ll learn how to build a minimal but fully functional actor
    framework. While building this framework, you’ll learn how an actor framework
    allows for safe sharing of mutable state, easy and secure parallelization and
    reserialization, and modular architecture of applications. At the end of this
    chapter, you’ll see some general things you can do with actor frameworks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何构建一个最小但功能齐全的演员框架。在构建此框架的过程中，您将了解演员框架如何允许安全地共享可变状态、易于且安全的并行化和反序列化，以及应用程序的模块化架构。在本章结束时，您将看到一些您可以使用演员框架执行的一般性操作。
- en: 'Your actor framework will be made of four components:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您的演员框架将由四个组件组成：
- en: The `Actor` interface will determine the behavior of an actor.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Actor` 接口将确定演员的行为。'
- en: The `AbstractActor` class will contain all the stuff that’s common to all actors.
    This class will have to be extended by business actors.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractActor` 类将包含所有演员共有的内容。这个类必须由业务演员扩展。'
- en: The `ActorContext` will act as a way to access actors. In your implementation,
    this component will be very minimalist, and will be used primarily to access actor
    behavior. This component isn’t really necessary in such a small implementation,
    but most serious implementations will use such a component. This context allows,
    for example, searching for available actors.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActorContext` 将作为访问演员的一种方式。在您的实现中，这个组件将非常简约，主要用于访问演员行为。在这个小型实现中，这个组件实际上并不是必需的，但大多数严肃的实现都会使用这样的组件。这个上下文允许，例如，搜索可用的演员。'
- en: The `MessageProcessor` interface will be the interface you’ll implement for
    any component that has to handle a received message.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MessageProcessor` 接口将是您为任何必须处理接收到的消息的组件实现的接口。'
- en: 14.2.1\. Limitations of this actor framework
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.1. 此演员框架的限制
- en: As I said, the implementation you’ll create here is minimalist; consider it
    a way to understand and practice using the actor model. You’ll be missing many
    (most?) of the functions of a real actor system, particularly those related to
    the actor context. One other simplification is that each actor will be mapped
    to a single thread. In a real actor system, actors are mapped to pools of threads,
    allowing thousands or even millions of actors to run on a few dozen threads.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说，你在这里创建的实现是极简的；将其视为理解和使用actor模型的一种方式。你将缺少许多（大多数？）真实actor系统的功能，尤其是那些与actor上下文相关的功能。另一个简化是，每个actor将被映射到一个单独的线程。在真实的actor系统中，actor会被映射到线程池中，允许数千甚至数百万个actor在几十个线程上运行。
- en: Another limitation of your implementation is that most actor frameworks allow
    distributed actors to be handled in a transparent way, meaning that you can use
    actors that are running on different machines without having to care about communication.
    This, of course, makes actor frameworks an ideal way to build scalable applications.
    We won’t deal with this aspect.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你实现的另一个限制是，大多数actor框架允许以透明的方式处理分布式actor，这意味着你可以使用运行在不同机器上的actor，而不必关心通信。这当然使actor框架成为构建可扩展应用的理想方式。我们不会处理这个方面。
- en: 14.2.2\. Designing the actor framework interfaces
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.2. 设计actor框架接口
- en: First, you need to define the interfaces that will constitute your actor framework.
    The most important is, of course, the `Actor` interface that will define several
    methods. The main method of this interface is
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要定义将构成你的actor框架的接口。当然，最重要的是定义`Actor`接口，它将定义几个方法。这个接口的主要方法是
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This method is used to send a message to this actor (meaning the actor holding
    the method). Of course, this means that to send a message to an actor, you must
    have a reference to it. (This is different from real actor frameworks, in which
    messages aren’t sent to actors but to actor references, proxies, or some other
    substitute. Without this enhancement, it wouldn’t be possible to send messages
    to remote actors.) This method takes a `Result<Actor>` as the second parameter.
    It’s supposed to represent the sender, but it’s sometimes set to nobody (the empty
    result) or to a different actor.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法用于向这个actor（即持有这个方法的actor）发送消息。当然，这意味着要向actor发送消息，你必须有它的引用。（这与真实的actor框架不同，在真实的actor框架中，消息不是发送给actor，而是发送给actor引用、代理或其他替代品。没有这个增强，就无法向远程actor发送消息。）这个方法将`Result<Actor>`作为第二个参数。它应该表示发送者，但有时会被设置为无人（空结果）或不同的actor。
- en: Other methods are used to manage the actor lifecycle to ease the use of actors,
    as shown in [listing 14.1](#ch14ex01). Note that this code isn’t intended to use
    the results of the exercises from previous chapters, but the `fpinjava-common`
    module that’s available in the code accompanying this book ([https://github.com/fpinjava/fpinjava](https://github.com/fpinjava/fpinjava)).
    This is mostly the same code as the solutions to the exercises, but with some
    additional methods.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法用于管理actor的生命周期，以简化actor的使用，如[列表14.1](#ch14ex01)所示。请注意，这段代码并不是为了使用之前章节的练习结果，而是使用本书附带代码中的`fpinjava-common`模块（[https://github.com/fpinjava/fpinjava](https://github.com/fpinjava/fpinjava)）。这基本上与练习的解决方案相同，但增加了一些方法。
- en: Listing 14.1\. The `Actor` interface
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.1. `Actor`接口
- en: '![](Images/ch14ex01-0.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch14ex01-0.jpg)'
- en: '![](Images/ch14ex01-1.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch14ex01-1.jpg)'
- en: 'The following listing shows the two other necessary interfaces: `ActorContext`
    and `MessageProcessor`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了另外两个必要的接口：`ActorContext`和`MessageProcessor`。
- en: Listing 14.2\. The `ActorContext` and `MessageProcessor` interfaces
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.2. `ActorContext`和`MessageProcessor`接口
- en: '![](Images/375fig02_alt.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/375fig02_alt.jpg)'
- en: The most important element here is the `ActorContext` interface. The `become`
    method allows an actor to change its behavior, meaning the way it processes messages.
    As you can see, the behavior of an actor looks like an effect, taking as its argument
    a pair composed of the message to process and the sender.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的元素是`ActorContext`接口。`become`方法允许actor改变其行为，即处理消息的方式。如你所见，actor的行为看起来像是一个效果，它的参数是一个由要处理的消息和发送者组成的对。
- en: During the life of the application, the behavior of each actor will be allowed
    to change. Generally, this change of behavior will be caused by a modification
    to the state of the actor, replacing the original behavior with a new one. This
    will be clearer once you see the implementation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的生命周期中，每个演员的行为将被允许改变。通常，这种行为的变化将由演员状态的修改引起，用新的行为替换原始行为。一旦您看到实现，这将更加清晰。
- en: 14.2.3\. The AbstractActor implementation
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.2.3. 抽象演员实现
- en: The `AbstractActor` implementation represents the part of an actor implementation
    that’s common to all actors. All the message management operations are common
    and are provided by the actor framework, so that you’ll only have to implement
    the business part. The `AbstractActor` implementation is shown in the following
    listing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`AbstractActor` 实现代表了所有演员实现中共同的部分。所有的消息管理操作都是共同的，并由演员框架提供，这样您就只需要实现业务部分。`AbstractActor`
    实现如下所示。'
- en: Listing 14.3\. The `AbstractActor` implementation
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.3. `AbstractActor` 实现列表
- en: '![](Images/ch14ex03-0.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch14ex03-0.jpg)'
- en: '![](Images/ch14ex03-1.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch14ex03-1.jpg)'
- en: Note that the `Executor` is initialized with a single-thread executor if the
    actor is to be single threaded, which is the most general case, or a cached thread
    pool if it’s to be multithreaded. Thread pools are created with a daemon thread
    factory to allow automatic shutdown when the main thread terminates.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果演员是单线程的，`Executor` 将使用单个线程执行器初始化，这是最一般的情况，或者如果它是多线程的，则使用缓存线程池。线程池使用守护线程工厂创建，以便在主线程终止时自动关闭。
- en: Your actor framework is now complete, though as I mentioned before, this is
    not production code. This is a minimal example to show you how an actor framework
    might work.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您的演员框架现在已经完成，尽管如我之前提到的，这并不是生产代码。这是一个最小示例，用来展示一个演员框架可能的工作方式。
- en: 14.3\. Putting actors to work
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3. 使用演员
- en: Now that you have an actor framework at your disposal, it’s time to apply it
    to some concrete problems. Actors are useful when multiple threads are supposed
    to share some mutable state, as when a thread produces the result of a computation
    and this result must be passed to another thread for further processing. Usually,
    such mutable state sharing is done by storing values in shared mutable properties,
    which implies locking and synchronization. We’ll first look at a minimal actor
    example, which can be considered as the “Hello, World!” of actors. We’ll then
    study a more complete application where an actor is used to distribute tasks to
    other actors working in parallel.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经拥有了一个可用的演员框架，是时候将其应用于一些具体问题上了。当多个线程需要共享一些可变状态时，演员非常有用，例如当一个线程产生计算结果，而这个结果必须传递给另一个线程进行进一步处理时。通常，这种可变状态共享是通过在共享的可变属性中存储值来完成的，这暗示了锁定和同步。我们首先将查看一个最小的演员示例，这可以被认为是演员的“Hello,
    World!”。然后我们将研究一个更完整的应用，其中使用演员将任务分配给其他并行工作的演员。
- en: The first example is a minimal, traditional example that’s used to test actors.
    It consists of two ping-pong players and a referee. The game starts when the ball,
    represented by an integer, is given to one player. Each player then sends the
    ball to the other until this has happened ten times, at which point the ball is
    given back to the referee.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例是一个最小、传统的示例，用于测试演员。它由两个乒乓球运动员和一个裁判员组成。游戏开始时，代表整数的球被交给一个玩家。然后每个玩家将球发送给另一个玩家，直到发生十次，此时球被交还给裁判员。
- en: 14.3.1\. Implementing the ping-pong example
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.1. 实现乒乓球示例
- en: 'First, you’ll implement the referee. All you have to do is create an actor,
    implementing its `onReceive` method. In this method, you’ll display a message:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将实现裁判员。您需要做的只是创建一个演员，实现其 `onReceive` 方法。在这个方法中，您将显示一条消息：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, you have to create the two players. Because there are two instances, you
    won’t create them as an anonymous class. You’ll create a `Player` class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您必须创建两个玩家。因为有两个实例，您不会将它们创建为匿名类。您将创建一个 `Player` 类。
- en: Listing 14.4\. The `Player` actor
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.4. `Player` 演员列表
- en: '![](Images/ch14ex04-0.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch14ex04-0.jpg)'
- en: '![](Images/ch14ex04-1.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch14ex04-1.jpg)'
- en: With the `Player` class created, you can finalize your program. But you need
    a way to keep the application running until the game is over. Without this, the
    main application thread will terminate as soon as the game is started, and the
    players won’t be given the opportunity to play their game. This can be achieved
    through the use of a semaphore, as shown next.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了`Player`类后，您就可以完成您的程序了。但是，您需要一种方法来保持应用程序运行，直到游戏结束。如果没有这个，主应用程序线程将在游戏开始时终止，玩家将没有机会玩游戏。这可以通过使用信号量来实现，如下所示。
- en: Listing 14.5\. The Ping Pong example
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.5\. Ping Pong示例
- en: '![](Images/ch14ex05-0.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch14ex05-0.jpg)'
- en: '![](Images/ch14ex05-1.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch14ex05-1.jpg)'
- en: 'The program displays the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 程序显示以下输出：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '14.3.2\. A more serious example: running a computation in parallel'
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.2\. 一个更严重的例子：并行运行计算
- en: 'It’s now time to look at a more serious example of the actor framework in action:
    running a computation in parallel. To simulate a long-running computation, you’ll
    choose a list of random numbers between 0 and 30, and compute the corresponding
    Fibonacci value using a slow algorithm. The application will be composed of three
    kinds of actors: a `Manager`, in charge of creating a given number of worker actors
    and distributing the tasks to them; several instances of workers; and a client,
    which will be implemented in the main program class as an anonymous actor. The
    following listing shows the simplest of these classes, the `Worker` actor.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看一个更严肃的演员框架实例：并行运行计算了。为了模拟长时间运行的计算，您将选择一个介于0到30之间的随机数字列表，并使用慢速算法计算相应的斐波那契值。应用程序将由三种类型的演员组成：一个`Manager`，负责创建指定数量的工作演员并将任务分配给他们；几个工作实例；以及一个客户端，它将在主程序类中以匿名演员的形式实现。以下列表显示了这些类中最简单的一个，即`Worker`演员。
- en: Listing 14.6\. The `Worker` actor, in charge of running parts of the computation
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.6\. 负责运行计算部分的`Worker`演员
- en: '![](Images/ch14ex06-0.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch14ex06-0.jpg)'
- en: '![](Images/ch14ex06-1.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch14ex06-1.jpg)'
- en: As you can see, this actor is stateless. It computes the result and sends it
    back to the sender for which it has received a reference. Note that this might
    be a different actor than the caller. Because the numbers are chosen randomly
    between 0 and 30, the time needed to compute the result will be highly variable.
    This simulates tasks that take variable amounts of time to execute. Unlike the
    example of automatic parallelization in [chapter 8](kindle_split_015.xhtml#ch08),
    all threads/actors will be kept busy until the whole computation is finished,
    except when there are no more tasks to process.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个演员是无状态的。它计算结果并将其发送回它接收引用的发送者。请注意，这可能不同于调用者。因为数字是在0到30之间随机选择的，所以计算结果所需的时间将高度可变。这模拟了执行时间可变的任务。与第8章中自动并行化的例子不同，除了没有更多任务要处理外，所有线程/演员都将保持忙碌，直到整个计算完成。
- en: The `Manager` class is a bit more complicated. The following listing shows the
    constructor of the class and the properties that are initialized.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Manager`类稍微复杂一些。以下列表显示了类的构造函数和初始化的属性。'
- en: Listing 14.7\. The constructor and properties of the `Manager` class
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.7\. `Manager`类的构造函数和属性
- en: '![](Images/ch14ex07-0.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch14ex07-0.jpg)'
- en: '![](Images/ch14ex07-1.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch14ex07-1.jpg)'
- en: 'As you can see, if the computation is finished, the result is added to the
    result list and sent to the client. Otherwise, the result is added to the current
    result list. In traditional programs, this would be done by mutating the list
    of results that would be held by the `Manager`. This is exactly what happens here,
    except for two differences:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果计算完成，结果将被添加到结果列表中并发送给客户端。否则，结果将被添加到当前结果列表中。在传统程序中，这将通过修改`Manager`将保留的结果列表来完成。这正是这里发生的事情，除了两个区别：
- en: The list of results is stored in the behavior.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果列表存储在行为中。
- en: Neither the behavior nor the list is mutated. Instead, a new behavior is created,
    and the context is mutated to hold this new behavior as a replacement for the
    old one. However, you don’t have to deal with this mutation. As far as you’re
    concerned, everything is immutable because the mutation is abstracted by the actor
    framework.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为和列表都没有被修改。相反，创建了一个新的行为，并将上下文修改为持有这个新行为，以替换旧的行为。然而，您不必处理这种修改。就您而言，一切都是不可变的，因为修改被演员框架抽象化了。
- en: The following listing shows the `Behavior` class, implemented as an inner class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了作为内部类实现的`Behavior`类。
- en: Listing 14.8\. The `Behavior` inner class allows you to abstract the actor mutation
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.8\. `Behavior`内部类允许你抽象演员的突变
- en: '![](Images/383fig01_alt.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/383fig01_alt.jpg)'
- en: That covers the main parts of the `Manager`. The rest is composed of utility
    methods that are mainly used for starting the work.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了`Manager`的主要部分。其余部分由主要用于启动工作的实用方法组成。
- en: Listing 14.9\. The utility methods of the `Manager`, used to start processing
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.9\. `Manager`的实用方法，用于启动处理
- en: '![](Images/ch14ex09-0.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch14ex09-0.jpg)'
- en: '![](Images/ch14ex09-1.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch14ex09-1.jpg)'
- en: It’s important to understand that the `onReceive` method represents what the
    actor will do when it receives its first message. This method won’t be called
    when the workers send their results to the manager.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解`onReceive`方法代表了演员在接收到它的第一条消息时将执行的操作。当工人将结果发送给经理时，此方法不会被调用。
- en: The last part of the program is shown in [listing 14.10](#ch14ex10). The `WorkersExample`
    class represents the client code for the application. But unlike the `Manager`
    and the `Worker`, it’s not an actor. Instead, it *has* an actor. This is an implementation
    choice. There’s no specific reason for choosing one solution or the other. But
    a client actor is necessary in order to receive the result.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的最后部分显示在[列表 14.10](#ch14ex10)中。`WorkersExample`类代表应用程序的客户端代码。但与`Manager`和`Worker`不同，它不是一个演员。相反，它*拥有*一个演员。这是一个实现选择。没有具体的原因选择一个解决方案或另一个。但是，为了接收结果，客户端演员是必要的。
- en: Listing 14.10\. The client application
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.10\. 客户端应用程序
- en: '![](Images/ch14ex10-0.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch14ex10-0.jpg)'
- en: '![](Images/ch14ex10-1.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ch14ex10-1.jpg)'
- en: 'You can run this program with various lengths for the list of tasks, and various
    numbers of worker actors. On my eight-core Linux box, running with a task length
    of 200,000 gives the following results:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用各种长度的任务列表和各种工作演员的数量运行这个程序。在我的八核 Linux 机器上，以 200,000 个任务长度运行的结果如下：
- en: 'One worker actor: 3.5 sec'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工作演员：3.5 秒
- en: 'Two worker actors: 1.5 sec'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个工作演员：1.5 秒
- en: 'Three worker actors: 1.1 sec'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个工作演员：1.1 秒
- en: 'Four worker actors: 0.8 sec'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个工作演员：0.8 秒
- en: 'Six worker actors: 0.8 sec'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六个工作演员：0.8 秒
- en: 'Eight worker actors: 0.8 sec'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八个工作演员：0.8 秒
- en: 'Sixteen worker actors: 0.8 sec'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六个工作演员：0.8 秒
- en: 'These figures are, of course, not very precise, but they show that using a
    number of threads corresponding to the number of available cores is useless. The
    result displayed by the program is as follows (only the first 40 results are displayed):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些数字并不非常精确，但它们表明使用与可用核心数相对应的线程数是无用的。程序显示的结果如下（仅显示前 40 个结果）：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, you have a problem!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你遇到了问题！
- en: 14.3.3\. Reordering the results
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.3\. 重新排序结果
- en: As you may have noticed, the result isn’t correct. This is obvious when looking
    at the third and fifth random values (28 and 29) and at the corresponding results
    (28,657 and 196,418). You can also compare values and results for 4 and 6\. The
    results are both 34 when the argument values are 13 and 5\. Note that if you run
    the program on your computer, you’ll obtain different results.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，结果是不正确的。当查看第三个和第五个随机值（28 和 29）以及相应的结果（28,657 和 196,418）时，这一点很明显。你也可以比较
    4 和 6 的值和结果。当参数值为 13 和 5 时，结果都是 34。请注意，如果你在自己的计算机上运行程序，你会得到不同的结果。
- en: What’s happening here is that not all tasks take the same amount of time to
    execute. I chose the computation to perform this way, so that some tasks (computations
    for low argument values) return quickly, while others (computations for higher
    values) take much longer. As a result, the returned values aren’t in the correct
    order.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是，不是所有任务执行所需的时间都相同。我选择以这种方式执行计算，以便一些任务（低参数值的计算）可以快速返回，而其他任务（高值的计算）则需要更长的时间。因此，返回的值没有按正确的顺序排列。
- en: To fix this problem, you need to sort the results in the same order as their
    corresponding arguments. One solution is to use the `Heap` data type you developed
    in [chapter 11](kindle_split_018.xhtml#ch11). You could number each task and use
    this number as the priority in a priority queue.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你需要按与相应参数相同的顺序对结果进行排序。一种解决方案是使用你在[第 11 章](kindle_split_018.xhtml#ch11)中开发的`Heap`数据类型。你可以对每个任务进行编号，并使用这个编号作为优先队列中的优先级。
- en: 'The first thing you have to change is the type of the worker actors. Instead
    of working on integers, they’ll have to work on tuples of integers: one integer
    representing the argument or the computation, and one representing the number
    of the task. The following listing shows the corresponding changes in the `Worker`
    class.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须改变工作演员的类型。他们不再处理整数，而必须处理整数的元组：一个整数表示参数或计算，另一个表示任务号。下面的列表显示了 `Worker` 类中相应的更改。
- en: Listing 14.11\. The `Worker` actor keeping track of the task number
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.11\. `Worker` 演员跟踪任务号
- en: '![](Images/386fig01_alt.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/386fig01_alt.jpg)'
- en: Note that the task number is the second element of the tuple. This isn’t easy
    to read and remember, given that the task number and the argument of the computation
    are of the same type (`Integer`). In real life, this shouldn’t happen, because
    you should be using a specific type for the task. But if you prefer, you can also
    use a specific type instead of `Tuple` to wrap both the task and the task number,
    such as a `Task` type with a number property.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，任务号是元组的第二个元素。考虑到任务号和计算参数的类型相同（`Integer`），这并不容易阅读和记忆。在现实生活中，这种情况不应该发生，因为你应该为任务使用特定的类型。但如果你愿意，你也可以使用特定的类型来包装任务和任务号，例如具有数字属性的
    `Task` 类型。
- en: 'Changes in the `Manager` class are more numerous. First, you have to change
    the type of the class and the types of the `workList` and result properties:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Manager` 类的更改更多。首先，你必须更改类类型以及 `workList` 和结果属性的 类型：'
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These properties are initialized in the constructor as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性在构造函数中如下初始化：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `workList` now contains tuples (as was the case for the `initial` list in
    the former example), and the result is a priority queue (`Heap`) of tuples. Note
    that this `Heap` is initialized with a `Comparator` based on the comparison of
    the second element of the tuples. Using a `Task` type that wraps both the task
    and the task number would have allowed you to make this type `Comparable`, so
    that a `Comparator` would have been useless. (I leave this optimization as an
    exercise for you.)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`workList` 现在包含元组（正如前一个例子中 `initial` 列表的情况），结果是元组的优先队列（`Heap`）。请注意，这个 `Heap`
    是基于元组的第二个元素的比较来初始化的 `Comparator`。使用一个同时包装任务和任务号的 `Task` 类型可以使这个类型 `Comparable`，这样
    `Comparator` 就没有用了。（我将这个优化留给你作为练习。）'
- en: 'Of course, the `managerFunction` is different too:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`managerFunction` 也有所不同：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It’s initialized in the constructor like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 它在构造函数中这样初始化：
- en: '![](Images/387fig01_alt.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/387fig01_alt.jpg)'
- en: 'The `Behavior` inner class must be changed to reflect the actor type change:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Behavior` 内部类必须更改以反映演员类型的变化：'
- en: '![](Images/387fig02_alt.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/387fig02_alt.jpg)'
- en: 'There are still some minor changes to apply in the rest of the `Manager` class.
    The `start` method must be modified:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Manager` 类的其余部分还有一些小的更改需要应用。`start` 方法必须进行修改：
- en: '![](Images/388fig01_alt.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/388fig01_alt.jpg)'
- en: 'The `Worker` initialization process is slightly different too:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Worker` 的初始化过程也略有不同：'
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Last, the `onReceive` method is modified:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`onReceive` 方法也进行了修改：
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now the results are displayed in the correct order. But you have a new problem:
    the time needed for the computation is now 15 sec with one worker actor, and 13
    sec with four worker actors. What’s happening?'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在结果以正确的顺序显示。但你有一个新的问题：现在一个工作演员需要 15 秒，四个工作演员需要 13 秒来计算所需的时间。这是怎么回事？
- en: 'The answer is simple: the bottleneck is the `Heap`. The `Heap` data structure
    isn’t meant for sorting. It has good performance as long as the number of elements
    is kept low, but here you’re inserting all 200,000 results into the heap, sorting
    the full data set on each insertion. This isn’t efficient.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单：瓶颈是 `Heap`。`Heap` 数据结构并不适合排序。只要元素数量保持低，它就有很好的性能，但在这里你将所有 200,000 个结果插入到堆中，并在每次插入时对整个数据集进行排序。这并不高效。
- en: 14.3.4\. Fixing the performance problem
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.3.4\. 解决性能问题
- en: Obviously, this inefficiency isn’t an implementation problem, but a problem
    about using the right tool for the job. You’d get much better performance by storing
    all results and sorting them once when the computation is over, though you’d need
    to use the right tool for sorting.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种低效并不是实现问题，而是关于使用正确工具的问题。当计算完成后，通过存储所有结果并在一次排序中排序，你会得到更好的性能，尽管你需要使用正确的工具来进行排序。
- en: Another option is to fix your implementation. One of the problems you’re having
    with the current design is that not only does insertion into the `Heap` take a
    long time, but it’s done by the `Manager` thread, so that instead of distributing
    tasks to the worker actors as soon as they’ve finished a computation, the `Manager`
    makes them wait until it has finished the insertion into the heap. One possible
    solution would be to use a separate actor for inserting into the `Heap`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是修复你的实现。你当前设计中遇到的一个问题是，不仅插入到`Heap`需要很长时间，而且是由`Manager`线程完成的，因此，而不是在计算完成后立即将任务分配给工作演员，`Manager`让他们等待直到它完成堆的插入。一个可能的解决方案是使用一个单独的演员来插入到`Heap`中。
- en: But sometimes a better way to go is to use the right job for the tool. The fact
    that you consume the result synchronously might not be a requirement. If it isn’t,
    you’re just adding an implicit requirement that makes the problem harder to solve.
    One possibility would be to pass the results individually to the client. This
    way, the `Heap` would be used only when the results are out of order, preventing
    it from becoming too big. This kind of use is, in fact, how a priority queue is
    intended to be used. To take this into account, you can add a `Receiver` actor
    to your program.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时使用正确的工具来做正确的工作会更好。你同步消费结果可能不是必需的。如果不是，你只是在添加一个隐含的要求，这使得问题更难解决。一个可能性是将结果单独传递给客户端。这样，只有在结果无序时才会使用`Heap`，防止它变得太大。实际上，这种使用方式正是优先队列预期的方式。为了考虑这一点，你可以在程序中添加一个`Receiver`演员。
- en: Listing 14.12\. The `Receiver` actor, in charge of receiving the results asynchronously
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.12。负责异步接收结果的`Receiver`演员
- en: '![](Images/ch14ex12-0.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch14ex12-0.jpg)'
- en: '![](Images/ch14ex12-1.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/ch14ex12-1.jpg)'
- en: 'The main class (`WorkersExample`) isn’t much different from the previous example.
    The only difference is the addition of the `Receiver`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 主要类（`WorkersExample`）与上一个示例没有太大不同。唯一的区别是添加了`Receiver`：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Worker` actor is exactly the same as in the previous example. This leaves
    you with the `Manager` class holding the most important changes. The first change
    is that the `Manager` will have a client of type `Actor<Integer>` and will keep
    track of the length of the list of tasks:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Worker`演员与上一个示例中的完全相同。这导致`Manager`类保留了最重要的更改。第一个更改是`Manager`将拥有一个类型为`Actor<Integer>`的客户端，并跟踪任务列表的长度：'
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Also note that the `client` is now the `Receiver`, so it’s of type `Actor<Integer>`,
    receiving results asynchronously, one by one.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`client`现在是`Receiver`，因此它是`Actor<Integer>`类型，异步接收结果，一个接一个。
- en: 'The `managerFunction`, of course, is different:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`managerFunction`是不同的：
- en: '![](Images/390fig01_alt.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/390fig01_alt.jpg)'
- en: 'As you can see, most of the work is done in the `streamResult` method:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，大部分工作都是在`streamResult`方法中完成的：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This method may seem difficult to decipher, but that’s only because the type
    notation in Java is so verbose. The `streamResult` method takes as its argument
    the `Heap` of results, the next expected task number, and a list of integers that’s
    initially empty:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能看起来难以理解，但这只是因为Java中的类型表示法非常冗长。`streamResult`方法将其参数作为结果`Heap`、下一个预期的任务编号和一个最初为空的整数列表：
- en: If the head of the result heap is different from the expected task result number,
    nothing needs to be done, and the three parameters are returned as a `Tuple3`.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果结果堆的头部与预期的任务结果编号不同，则不需要做任何事情，并将三个参数作为`Tuple3`返回。
- en: If the head of the result heap matches the expected task result number, it’s
    removed from the heap and added to the list. Then the method is called recursively
    until the head no longer matches, thus constructing a list of the results in expected
    order, leaving the others in the heap.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果结果堆的头部与预期的任务结果编号匹配，则将其从堆中移除并添加到列表中。然后递归调用该方法，直到头部不再匹配，从而按预期顺序构建结果列表，其余的留在堆中。
- en: By processing this way, the heap is always kept small. For example, when computing
    200,000 tasks, the maximal size of the heap was found to be 121\. It was over
    100 on 12 occasions, and more than 95% of the time it was less than 2.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式处理，堆始终保持较小。例如，在计算20万个任务时，发现堆的最大大小为121。它在12次超过了100，并且超过95%的时间小于2。
- en: '[Figure 14.2](#ch14fig02) 14.2 shows the overall process of receiving the results
    from the `Manager` point of view.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.2](#ch14fig02) 14.2从`Manager`的角度展示了接收结果的整体过程。'
- en: Figure 14.2\. The `Manager` receives a result and either stores it in the `Heap`
    (if it doesn’t correspond to the expected number) or sends it to the client. In
    the latter case, it then looks at the `Heap` to see if the next expected result
    has already been received.
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.2. `Manager` 接收到一个结果，如果它不对应预期的数字，则将其存储在 `Heap` 中，或者将其发送给客户端。在后一种情况下，它随后查看
    `Heap` 以查看下一个预期的结果是否已经被接收。
- en: '![](Images/14fig02.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/14fig02.jpg)'
- en: 'The `tellClientEmptyResult` method is modified according to the client type:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`tellClientEmptyResult` 方法根据客户端类型进行了修改：'
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `onReceive` method is different because, on starting, you expect result
    number 0:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`onReceive` 方法不同，因为，在启动时，你期望结果是0：'
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The last change is to the `Behavior` class, which now holds the expected task
    number:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的更改是对 `Behavior` 类的，现在它持有预期的任务编号：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With these modifications, the application is much faster. For example, under
    the same conditions as in the previous example, the time needed to process 200,000
    numbers with one worker actor was 7.5 seconds, whereas it dropped to 5.3 seconds
    with four worker actors.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些修改，应用程序的速度大大提高。例如，在先前的例子相同的条件下，一个工作actor处理20万个数字所需的时间是7.5秒，而使用四个工作actor时，时间降至5.3秒。
- en: This process is obviously not as fast as storing all the values unsorted and
    sorting them afterwards, which brought the time down to 3.5 seconds with one actor
    and 1.19 seconds with four. But there’s still plenty of room for optimization.
    For example, instead of putting each result into the `Heap`, you could pass it
    to the `streamResult` method, where it would be put directly into the result list
    if it matches the expected task number.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个过程的速度不如将所有值无序存储，然后再排序，这使一个actor的时间降至3.5秒，四个actor降至1.19秒。但仍有很大的优化空间。例如，你不必将每个结果放入
    `Heap`，而是可以将其传递给 `streamResult` 方法，如果它匹配预期的任务编号，它将直接放入结果列表。
- en: Anyway, this was just an example to show how actors can be used. Solving this
    kind of problem is much better handled by other means, such as automatic parallelization
    of lists (as shown in [chapter 8](kindle_split_015.xhtml#ch08)), or even a simple
    `map`. The main use of actors is not for parallelization, but for the abstraction
    of sharing mutable state. In these examples, you used lists that were shared between
    tasks. Without actors, you’d have had to synchronize access to the `workList`
    and `resultHeap` to handle concurrency. Actors allow you to abstract synchronization
    and mutation in the framework. If you look at the business code you wrote (apart
    from the actor framework itself), you’ll find no mutable data, and thus no need
    to care about synchronization and no risks of thread starvation or deadlocks.
    Although they’re not functional, actors provide a good way to make functional
    parts of your code work together, sharing mutable state in an abstracted manner.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，这只是个例子，用来展示actor是如何被使用的。解决这类问题最好通过其他方式，例如自动并行化列表（如第8章所示），或者甚至一个简单的 `map`。actor的主要用途不是用于并行化，而是用于抽象共享可变状态。在这些例子中，你使用了在任务之间共享的列表。如果没有actor，你将不得不同步访问
    `workList` 和 `resultHeap` 以处理并发。actor允许你在框架中抽象同步和修改。如果你查看你编写的业务代码（除了actor框架本身），你会发现没有可变数据，因此不需要关心同步，也没有线程饥饿或死锁的风险。尽管它们不是函数式的，但actor提供了一种很好的方式来使代码的函数部分协同工作，以抽象的方式共享可变状态。
- en: Your actor framework is really minimal and isn’t intended to be used in any
    serious code. For such uses, you can use one of the available actor frameworks
    for Java, particularly Akka. Although Akka is written in Scala, a more functional-friendly
    language than Java, it can be used in Java programs as well. When using Akka,
    you’ll never see a line of Scala code unless you want to. To learn more about
    actors, and Akka in particular, refer to Raymond Roestenburg, Rob Bakker, and
    Rob Williams’s *Akka in Action* (Manning, 2016).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你的actor框架非常简单，并不打算用于任何严肃的代码。对于此类用途，你可以使用可用的Java actor框架之一，尤其是Akka。尽管Akka是用Scala编写的，这是一种比Java更功能友好的语言，但它也可以用于Java程序。当使用Akka时，除非你想要，否则你永远不会看到一行Scala代码。要了解更多关于actor的信息，特别是关于Akka的信息，请参阅Raymond
    Roestenburg、Rob Bakker和Rob Williams的《Akka in Action》（Manning，2016）。
- en: 14.4\. Summary
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4. 摘要
- en: Actors are components that receive messages in an asynchronous way and process
    them one after the other.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Actor是异步接收消息并依次处理的组件。
- en: Sharing mutable state can be abstracted into actors.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享可变状态可以抽象为actor。
- en: Abstracting mutable state sharing relieves you of synchronization and concurrency
    problems.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象可变状态共享可以减轻你关于同步和并发问题的负担。
- en: The actor model is based on asynchronous messaging and is a nice complement
    to functional programming.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员模型基于异步消息传递，并且是函数式编程的一个很好的补充。
- en: The actor model offers easy and safe parallelization.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员模型提供了简单且安全的并行化。
- en: Actor mutations are abstracted from the programmer by the framework.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架将演员突变（actor mutations）从程序员那里抽象出来。
- en: Several actor frameworks are available to Java programmers.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Java程序员来说，有多个演员框架可供选择。
- en: Akka is one of the most-used actor frameworks for Java programming.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Akka是Java编程中最常用的演员框架之一。
