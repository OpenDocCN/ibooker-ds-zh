- en: Chapter 1\. Welcome to Linux
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1章. 欢迎来到Linux
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: What makes Linux different
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux的不同之处
- en: Basic survival skills
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本生存技能
- en: Getting help
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取帮助
- en: This book turns technology training sideways. Although other books, courses,
    and online resources organize their content around *skills*, I’m going to use
    real-world *projects* as teaching tools. Each of the core skills and the functionality
    of Linux systems will be covered—and covered well—but only when needed for a project.
    When you’re done, you’ll have learned everything you would have from a traditional
    source, but you’ll also know how to perform more than a dozen vital and sophisticated
    administration tasks and be comfortable tackling dozens more.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书将技术培训颠倒过来。尽管其他书籍、课程和在线资源围绕*技能*组织内容，但我将使用现实世界的*项目*作为教学工具。每个核心技能和Linux系统的功能都将被涵盖，并且覆盖得很好，但只有在项目需要时才会涉及。当你完成时，你将学到从传统来源学到的一切，但你还将知道如何执行十几个关键和复杂的行政任务，并且能够轻松应对更多。
- en: The first two or three chapters will quickly guide you through your initial
    introduction to the world of Linux servers. After that, you’ll work through and
    adapt practical hands-on projects, and nothing but practical hands-on projects.
    Through those projects, you’ll learn more than just commands and skills. Get ready
    to dive deeper and to eventually create solutions to your own business problems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 前两到三章将快速引导你了解Linux服务器世界的初步介绍。之后，你将进行实际的手动项目，并且只有实际的手动项目。通过这些项目，你将学到不仅仅是命令和技能。准备好深入探索，并最终为你的商业问题创造解决方案。
- en: No single book can anticipate all the challenges that you’ll face throughout
    your career. But, by demonstrating how to approach real-world problems using real-world
    tools, this book will make it a whole lot easier for you to use the vast resources
    available through both inline documentation and the internet. If your prior Linux
    experience is limited, this chapter introduces some basic command-line survival
    skills and points to places you can go for help when things don’t work.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一本书能够预测你整个职业生涯中可能遇到的所有挑战。但是，通过展示如何使用现实世界的工具解决现实世界的问题，这本书将使你通过内联文档和互联网使用大量资源变得更加容易。如果你的Linux经验有限，本章介绍了基本的命令行生存技能，并指出当事情不工作时你可以去哪里寻求帮助。
- en: '|  |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-9
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: As you’ll see, a *command line* is an interface provided by an operating system
    (OS) that permits you to type text commands to control the OS or to query data
    it manages.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将看到的，*命令行*是操作系统（OS）提供的一个界面，允许你输入文本命令来控制操作系统或查询它管理的数据。
- en: '|  |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: I should note that in this and every chapter, you’re strongly encouraged to
    try everything out for yourself. There’s no better way to really get to the core
    of an IT skill than actually doing it, realizing that it’s not working the way
    you expected, and playing with it until it becomes yours forever. Good luck and
    have fun!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该指出，在本章以及每一章中，我们都强烈鼓励你自己尝试所有内容。没有比实际操作更好的方式来真正掌握IT技能，意识到它没有按你预期的方向发展，然后玩弄它直到它永远属于你。祝你好运，玩得开心！
- en: 1.1\. What makes Linux different from other operating systems
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1. Linux与其他操作系统的不同之处
- en: Linux is free, which means it’s a lot easier than other OSs to install exactly
    where and when needed for any use you can imagine. Not having to worry about purchasing
    site licenses and jumping through Digital Rights Management hoops makes testing
    all kinds of hardware combinations and server configurations much more straightforward.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Linux是免费的，这意味着它比其他操作系统更容易安装到任何需要的位置和时间，用于任何你能想象到的用途。不必担心购买站点许可证和跳过数字版权管理障碍，这使得测试各种硬件组合和服务器配置变得更加直接。
- en: Linux makes it possible to do various really useful and creative things. For
    instance, you can load a Linux *live boot* image on a USB stick, boot a PC whose
    own hard disk has been corrupted, and then troubleshoot and fix the problem. (You’ll
    learn how to do that in [chapter 6](kindle_split_014.xhtml#ch06).) Or, because
    Linux is a true multiuser OS, whole teams can concurrently log in to work locally
    or remotely, confident in the privacy and stability of the system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Linux使得做各种真正有用和有创意的事情成为可能。例如，你可以在U盘上加载Linux *live boot* 镜像，启动一个自身硬盘已损坏的PC，然后进行故障排除和修复问题。（你将在[第6章](kindle_split_014.xhtml#ch06)中学习如何做这件事。）或者，因为Linux是一个真正的多用户操作系统，整个团队可以同时登录本地或远程工作，对系统的隐私和稳定性充满信心。
- en: Linux was built with some of the same technology and comes with most of the
    same tools as the deeply mature UNIX OS. This adds a great deal of stability and
    security. Linux distributions also provide sophisticated software package management
    systems that reliably install and maintain any of the thousands of free software
    applications available through online curated repositories.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 是使用与深度成熟的 UNIX 操作系统相同的技术构建的，并配备了大多数相同的工具。这增加了极大的稳定性和安全性。Linux 发行版还提供了复杂的软件包管理系统，可以可靠地安装和维护通过在线精选仓库提供的成千上万免费软件应用程序。
- en: But beyond free, Linux is *open source*, which means anyone can take the code
    base and reshape it into anything they want. Practically, this has spawned a vast
    ecosystem of specialty Linux distributions. A *distribution* (sometimes shortened
    to *distro*) is a customized stack of software that’s packaged along with the
    Linux kernel and distributed with tools for installing a working version of Linux
    of user computers. [Table 1.1](#ch01table01) provides a very incomplete distro
    list to illustrate the kinds of things that are available.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但除了免费之外，Linux 还是 *开源* 的，这意味着任何人都可以取用代码库并将其重塑成他们想要的任何东西。实际上，这催生了一个庞大的专业 Linux
    发行版生态系统。*发行版*（有时简称为 *distro*）是一组定制的软件栈，它与 Linux 内核一起打包，并附带安装用户计算机上工作版本 Linux 的工具。[表
    1.1](#ch01table01) 提供了一个非常不完整的发行版列表，以说明可用的各种事物。
- en: Table 1.1\. Some of the many available Linux distros
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 1.1\. 许多可用的 Linux 发行版
- en: '| Purpose | Distribution |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 目的 | 发行版 |'
- en: '| --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Security/anti-hacking | Kali Linux |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 安全/反黑客 | Kali Linux |'
- en: '|   | Parrot |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|   | Parrot |'
- en: '| Consumer desktop | Mint |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 消费者桌面 | Mint |'
- en: '|   | Elementary OS |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|   | Elementary OS |'
- en: '| Lightweight (old hardware; diagnostics) | Puppy Linux |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 轻量级（旧硬件；诊断） | Puppy Linux |'
- en: '|   | LXLE |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|   | LXLE |'
- en: '| Internet of Things administration | Snappy Ubuntu Core |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 物联网管理 | Snappy Ubuntu Core |'
- en: '| Enterprise server room | CentOS (community version of Red Hat Enterprise
    Linux) |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 企业服务器室 | CentOS（Red Hat Enterprise Linux的社区版本） |'
- en: '|   | OpenSUSE (community version of SUSE) |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|   | OpenSUSE（SUSE的社区版本） |'
- en: '| Cloud computing | Amazon Linux (AWS AMI) |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 云计算 | Amazon Linux（AWS AMI） |'
- en: '|   | Ubuntu Server (AWS AMI) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|   | Ubuntu Server（AWS AMI） |'
- en: '| All-purpose (except lightweight) | Ubuntu |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 多用途（除轻量级外） | Ubuntu |'
- en: Can’t find what you’re after? Create your own. Need help? There’s a large and
    active community online where, if someone hasn’t already solved your problem,
    they’ll know where to go to get it done. More than anything else, I’d say it’s
    the community-based resources that really make Linux so powerful.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 找不到你想要的东西？自己创建一个。需要帮助？在线上有一个庞大且活跃的社区，如果有人还没有解决你的问题，他们知道去哪里找到解决方案。我认为最重要的是，基于社区的资源让Linux变得如此强大。
- en: 1.2\. Basic survival skills
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2\. 基本生存技能
- en: 'Before beginning with the enterprise-ready projects that make up the rest of
    the book, it’s worthwhile to make sure we’re starting on the same page. This chapter
    covers the Linux basics: the UNIX Filesystem Hierarchy Standard (including pseudo
    file systems), navigation (`ls`, `pwd`, and `cd`), file management tools (`cat`,
    `less`, `touch`, `mkdir`, `rmdir`, `rm`, `cp`, and `mv`), some tricks (like tab
    completion and file globbing), `sudo`, and where to turn for help (`man`, `info`,
    and `journalctl`).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本书中其余部分的企业级项目之前，确保我们站在同一起跑线上是值得的。这一章涵盖了 Linux 基础：UNIX 文件系统层次标准（包括伪文件系统），导航（`ls`，`pwd`
    和 `cd`），文件管理工具（`cat`，`less`，`touch`，`mkdir`，`rmdir`，`rm`，`cp` 和 `mv`），一些技巧（如自动补全和文件通配符），`sudo`，以及寻求帮助的地方（`man`，`info`
    和 `journalctl`）。
- en: It’s possible you have enough experience already that you won’t need any of
    that material. Feel free to skip this chapter altogether. Don’t worry about the
    rest of us. We’ll catch up.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你已经拥有了足够多的经验，以至于你不需要任何那些材料。你可以自由地跳过这一章。不用担心我们其他人。我们会赶上的。
- en: '|  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|   |'
- en: '**Installing Linux**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装 Linux**'
- en: I’m not going to spend time talking about how to install Linux on your PC. It’s
    not because installation is so ridiculously simple; it can sometimes get quite
    complicated. Rather, it’s because the approach you choose depends on your specific
    circumstances. Describing one possibility or even half a dozen would do nothing
    more than annoy the 75% of you for whom those scenarios won’t work.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会花时间讨论如何在你的 PC 上安装 Linux。这并不是因为安装过程如此荒谬地简单；有时它可能会相当复杂。相反，这是因为你选择的方法取决于你的具体情况。描述一种可能性，甚至六种可能性，对于其中
    75% 的人来说这些场景不起作用，只会让他们感到烦恼。
- en: Need some help getting started with installation? Check out *Learn Linux in
    a Month of Lunches* (Manning, 2016). Encountering a particular installation issue?
    Take a minute to write a brief but detailed description, and then use it to search
    the internet for help. Looking for a laptop or a desktop with Linux preinstalled?
    Search the internet for “pc with Linux preinstalled.” Have some unused hardware
    and a USB stick? Search for “install Linux from usb.” Prefer to install Linux
    as a virtual machine? Smart move. Stick around for [chapter 2](kindle_split_010.xhtml#ch02).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一些帮助开始安装吗？请查看*《一个月午餐时间学Linux》*（Manning，2016）。遇到特定的安装问题？花一分钟时间写一个简短但详细的描述，然后使用它在网上搜索帮助。在寻找预装Linux的笔记本电脑或台式机？在网上搜索“预装Linux的电脑”。有一些未使用的硬件和一个USB闪存盘？搜索“从USB安装Linux”。更喜欢将Linux作为虚拟机安装？这是一个明智的选择。请留在[第2章](kindle_split_010.xhtml#ch02)。
- en: '|  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 1.2.1\. The Linux file system
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1\. Linux文件系统
- en: It’s often said that everything in Linux works through plain text files, so
    it probably makes the most sense to start by understanding the Linux file system.
    But before we can get to Linux, what’s a *file system*? You can think of it as
    a data table (or an *index*) that creates apparent connections between individual
    files and groups of files with identifiable locations on a disk. [Figure 1.1](#ch01fig01)
    can help you visualize how data spread across a disk partition can be exposed
    to system users within a directory structure.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常说Linux中的所有东西都是通过纯文本文件工作的，因此，从理解Linux文件系统开始可能最有意义。但在我们能够进入Linux之前，什么是*文件系统*呢？你可以将其视为一个数据表（或*索引*），它创建了个别文件和具有可识别磁盘位置的文件组之间的明显联系。[图1.1](#ch01fig01)可以帮助你可视化数据如何在磁盘分区中分布，并在目录结构中向系统用户展示。
- en: Figure 1.1\. Raw data on storage devices can be visually represented by the
    OS as organized directory hierarchies.
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.1\. 存储设备上的原始数据可以通过操作系统以组织良好的目录层次结构进行可视化表示。
- en: '![](Images/01fig01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig01.jpg)'
- en: Why would you need an index? A digital storage device like a hard drive or USB
    device isn’t divided into physical divisions that can be used as organizing *folders*
    (or *directories,* as they’re known in Linux circles). One particular file can
    reside in a location on the actual media that’s a great distance away from another,
    nearly identical file created minutes or seconds apart, and all the parts of a
    single file might not be contiguous. Not only that, a file’s geographic location
    on the disk won’t necessarily remain static over time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你需要索引呢？像硬盘或USB这样的数字存储设备并没有划分为可以用来组织*文件夹*（或Linux圈中称之为*目录*）的物理分区。一个特定的文件可以位于实际媒体上的一个位置，这个位置与几分钟或几秒钟前创建的几乎相同的文件相距甚远，而单个文件的所有部分可能并不连续。不仅如此，文件在磁盘上的地理位置也不一定随时间保持静态。
- en: If you want your data to be reliably retrievable, you’ll need some kind of index
    that can consistently point you to the resources you’re after. A file system uses
    such an index to provide the appearance of an organized set of directories and
    files within a single disk division known as a *partition*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想可靠地检索你的数据，你需要某种索引，它可以始终如一地指向你想要获取的资源。文件系统使用这种索引来提供一个有序的目录和文件集合的表象，这些目录和文件位于称为*分区*的单个磁盘分区中。
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: In case you need to dig deeper on your own some time, it’ll be useful to know
    that these days, the most commonly used Linux file system is ext4\. But Linux
    can also work with storage drives that were formatted using file systems from
    other platforms like FAT32 and NTFS.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在某个时候需要自己深入研究，了解这些信息将很有用：如今，最常用的Linux文件系统是ext4。但Linux也可以与使用FAT32和NTFS等平台文件系统格式化的存储驱动器一起工作。
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: All the files in a disk partition are kept in directories beneath the root directory,
    which is represented by the */* (forward slash) character. The way these directories
    are arranged is largely governed by the UNIX Filesystem Hierarchy Standard (FHS).
    You’re going to see pretty much the same basic layout whether you’re using a Linux
    distribution, UNIX, or even macOS. [Figure 1.2](#ch01fig02) shows some of the
    most used, top-level directories.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘分区中的所有文件都保存在根目录下的目录中，根目录由*/*（正斜杠）字符表示。这些目录的排列方式在很大程度上受UNIX文件系统层次结构标准（FHS）的约束。无论你使用的是Linux发行版、UNIX还是甚至macOS，你都会看到几乎相同的基本布局。[图1.2](#ch01fig02)显示了一些最常用的顶级目录。
- en: Figure 1.2\. Common top-level directories as defined by the UNIX FHS
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.2\. UNIX FHS定义的常见顶级目录
- en: '![](Images/01fig02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/01fig02.jpg)'
- en: Top-level directories—those directories located directly beneath the root—include
    /etc/, which contains configuration files that define the way individual programs
    and services function, and /var/, which contains *variable* files belonging to
    the system or individual applications whose content changes frequently through
    the course of normal system activities. You’ll also want to know about the /home
    directory where individual users are given directories for their private files.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级目录——位于根目录直接下方的目录——包括 /etc/，其中包含定义个别程序和服务功能的配置文件，以及 /var/，其中包含系统或个别应用程序的 *可变*
    文件，其内容在正常系统活动过程中经常发生变化。你还需要了解 /home 目录，其中为个别用户提供用于其私有文件的目录。
- en: '1.2.2\. Getting around: Linux navigation tools'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2\. 导航：Linux 导航工具
- en: Here’s where you’ll learn the five most basic, must-have Linux navigation commands
    (`ls`, `pwd`, `cd`, `cat`, and `less`). Because the command line is not a particularly
    visual environment no matter what you’re trying to do, you’re going to rely a
    great deal on these five tools to orient yourself.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将学习五个最基本、必备的 Linux 导航命令 (`ls`、`pwd`、`cd`、`cat` 和 `less`）。由于命令行环境并不是一个特别直观的环境，无论你试图做什么，你都将大量依赖这五个工具来定位自己。
- en: '|  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I hope it’s obvious that you should be trying each of these tools out for yourself
    on your own computer. That’s the only way you’ll learn.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望很明显，你应该在自己的计算机上尝试这些工具。这是你学习的唯一方法。
- en: '|  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The rest of the book requires a command-line terminal of one sort or another.
    Unfortunately, there’s no single way to open a terminal window that’ll work in
    all Linux distributions. For example, the terminal’s location in the Ubuntu menu
    system won’t necessarily match that of Fedora or Mint. And Ubuntu itself? Well,
    that depends on which version you’re running.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 本书其余部分需要某种命令行终端。不幸的是，没有一种打开终端窗口的方法可以在所有 Linux 发行版中工作。例如，在 Ubuntu 菜单系统中终端的位置不一定与
    Fedora 或 Mint 相匹配。至于 Ubuntu 本身？那取决于你运行的是哪个版本。
- en: The Ctrl-Alt-t keyboard combination should work in at least most environments,
    as will looking through the application menus searching for an item with *terminal*
    in the name. By default, once your terminal opens, your home directory (/home/yourname/)
    will be active.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Ctrl-Alt-t 键盘组合至少在大多数环境中应该可以工作，同样，通过在应用程序菜单中搜索带有 *终端* 的项目也可以实现。默认情况下，一旦你的终端打开，你的主目录
    (/home/yourname/) 将处于活动状态。
- en: ls (list)
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ls (列出)
- en: 'No point hanging around the terminal if you can’t see what’s there. You can
    list the names of the files and subdirectories in your current directory using
    `ls`. The `ls` command with the `l` flag (*l* stands for *long*) lists not only
    the object names, but their file permissions, owner, group, file size, and time
    stamp. Adding a directory designation like /var/ displays the contents of that
    directory:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看不到终端中的内容，就没有必要在终端中逗留。你可以使用 `ls` 命令列出当前目录中文件和子目录的名称。带有 `l` 标志的 `ls` 命令（*l*
    代表 *长*）不仅列出对象名称，还包括文件权限、所有者、组、文件大小和时间戳。添加目录指定符如 /var/ 将显示该目录的内容：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `h` argument when added to `ls -l` displays file sizes in a human-readable
    format—kilobytes, megabytes, and gigabytes, rather than bytes, which tend to involve
    a great many hard-to-count digits:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 `h` 参数添加到 `ls -l` 时，会以人类可读的格式显示文件大小——千字节、兆字节和吉字节，而不是字节，字节往往涉及大量难以计算的数字：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* The total disk space (in MB) consumed by files in this directory**'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 该目录中文件占用的总磁盘空间（以 MB 计）**'
- en: '|  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'In general, you add arguments to Linux commands in one of two ways: a dash
    followed by a single letter (like the `h` that modifies `ls`), or two dashes introducing
    more verbose versions of the same argument. In the example, `ls --human-readable`
    generates exactly the same output as `ls -h`. Nearly all Linux commands come packaged
    with full documentation, which we’ll explore later in the chapter.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你可以在两种方式中添加参数到 Linux 命令：一个连字符后跟一个单个字母（例如修改 `ls` 的 `h`），或者两个连字符引入相同参数的更详细版本。在示例中，`ls
    --human-readable` 生成的输出与 `ls -h` 完全相同。几乎所有的 Linux 命令都附带完整的文档，我们将在本章后面进行探讨。
- en: '|  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Want to know what’s going on beneath your current directory? Adding uppercase
    `R` as an argument to `ls` displays subdirectories and the files and subdirectories
    they contain, no matter how many nested layers of directories. Just to get an
    idea of how involved that can get, and therefore how useful it can be to properly
    visualize it, run `ls -R` against the /etc/ directory tree:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 想要知道你的当前目录下面有什么吗？将大写 `R` 作为参数添加到 `ls` 命令中会显示子目录以及它们包含的文件和子目录，无论目录嵌套层级有多少。为了了解这可能会变得多么复杂，以及因此如何有助于正确可视化，运行
    `ls -R` 对 /etc/ 目录树进行操作：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: pwd (present work directory)
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: pwd (当前工作目录)
- en: 'In many cases, your current location within the file system will be displayed
    to the left of your command prompt. In this example, I’m in the network directory
    that lives just below /etc/:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你的文件系统中的当前位置会显示在命令提示符的左侧。在这个例子中，我位于 /etc/ 下的网络目录中：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you’ll likely find yourself working on systems where that prompt isn’t available,
    you might sometimes need a quick heads-up on your position. For that, typing `pwd`
    will print your present working directory:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可能会在那些没有该提示符的系统上工作，你有时可能需要快速了解你的位置。为此，输入 `pwd` 将会打印出你的当前工作目录：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: cd (change directory)
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: cd (更改目录)
- en: 'Once you’ve got a decent idea of where you are and what’s immediately available
    to you in your current directory, you’ll need to know how to change locations.
    Typing `cd` tells the command-line interpreter (which will usually be Bash) to
    move you to the directory you specify. When you first open a terminal session
    (often referred to as a *shell*), by default, you’ll find yourself in your own
    account’s home directory. If you run `pwd`, you’ll probably see something like
    this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对你的位置以及当前目录中立即可用的内容有了大致的了解，你需要知道如何更改位置。输入 `cd` 告诉命令行解释器（通常将是 Bash）移动到你指定的目录。当你第一次打开终端会话（通常被称为
    *shell*）时，默认情况下，你会在自己的账户的 home 目录中。如果你运行 `pwd`，你可能会看到类似以下的内容：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**What’s Bash?**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是 Bash？**'
- en: Bash is probably the most popular UNIX shell. Great! But what’s a shell? A *shell*
    is any user interface that interprets a user’s commands, either through a command-line
    interface (CLI) or a graphical user interface (GUI). You can think of a shell
    (visualized in the figure) as a software layer meant to execute all appropriately
    formatted commands using the underlying kernel and hardware system resources.
    In other words, it’s the way you talk to your computer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 可能是使用最广泛的 UNIX Shell。太好了！但什么是 Shell？*Shell* 是任何解释用户命令的用户界面，无论是通过命令行界面 (CLI)
    还是图形用户界面 (GUI)。你可以将 Shell（如图所示）想象为一个软件层，旨在使用底层内核和硬件系统资源执行所有适当格式的命令。换句话说，它是你与计算机交流的方式。
- en: '![](Images/f0007_01.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f0007_01.jpg)'
- en: The shell interprets the execution of user input commands.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 解释用户输入的命令。
- en: '|  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Now, let’s move back to the root directory by typing `cd` and a forward slash:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过输入 `cd` 和一个正斜杠来返回根目录：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run `ls` again to take a look at what’s there. (You’ll see the directories illustrated
    earlier in [figure 1.2](#ch01fig02).) Notice the home directory from which you
    can access your *yourname* directory. To move to any of the subdirectories listed
    there, type `cd` and then the directory you’d like to visit. Because the path
    you’re specifying here is *relative* to your current location, you don’t need
    to preface the directory name with a forward slash character. The command `cd
    ..` will move you up one level in the directory hierarchy, from /home/*yourname*/
    to /home/, for instance.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 `ls` 命令来看看有哪些内容。（你会看到之前在[图 1.2](#ch01fig02)中展示的目录。）注意你可以访问的 *yourname*
    目录的 home 目录。要移动到那里列出的任何子目录，请输入 `cd` 然后你想要访问的目录名。因为这里指定的路径是相对于你当前位置的 *相对路径*，所以你不需要在目录名前加上正斜杠字符。命令
    `cd ..` 会将你向上移动一个目录层级，例如从 /home/*yourname*/ 移动到 /home/。
- en: 'If, however, you’ve got more ambitious travel plans and you’d like to see parts
    of the world lying far beyond your current directory, you’ll need to use an *absolute*
    path. That means you’ll always use a path that begins with the root directory
    (represented by a forward slash). To move back to your home directory from somewhere
    else on the system, you’ll type the forward slash, then `home` (which, you’ll
    remember, exists within the root directory), and then your username. Try it:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你有更雄心勃勃的旅行计划，并且想看到远在你当前目录之外的世界的一部分，你需要使用一个**绝对**路径。这意味着你将始终使用以根目录（用正斜杠表示）开始的路径。要从系统上的其他位置返回到你的主目录，你将输入正斜杠，然后输入`home`（记住，它存在于根目录中），然后是你的用户名。试试看：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That said, typing `cd` without any arguments will take you back to the home
    directory of the current logged-in user.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，不带任何参数输入`cd`将带你回到当前登录用户的家目录。
- en: cat (print file contents to output)
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: cat（将文件内容打印到输出）
- en: 'Accessing the contents of text files within a terminal can sometimes be a bit
    tricky. The `cat` tool will print a file to the screen where it can be read, but
    not edited. This works pretty well for shorter documents like the fstab file in
    /etc/. The next example uses an absolute path so that the file can be found no
    matter where in the file system you happen to be at the moment:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中访问文本文件的内容有时可能有点棘手。`cat`工具会将文件打印到屏幕上，以便阅读，但不能编辑。这对于像`/etc/`中的`fstab`文件这样的较短的文档来说效果很好。下一个示例使用绝对路径，这样无论你在文件系统中的哪个位置，都可以找到该文件：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The name *cat* is actually short for *concatenate*, which reflects the tool’s
    value in joining multiple strings or files into a single text stream.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: “cat”这个名字实际上是“concatenate”的简称，这反映了该工具在将多个字符串或文件合并成一个文本流中的价值。
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Suppose the file you want to read contains more lines than will display in
    a single screen. Try viewing the /etc/group file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要阅读的文件包含的行数超过了单屏可以显示的行数。尝试查看`/etc/group`文件：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The odds are that the first lines scrolled up and off your screen far too fast
    for you to have read them. What’s the good of a plain text file if you can’t read
    it? Of course, as you’ll soon see, Linux has plenty of text editors for actively
    managing content, but it might be nice to be able to read a longer file, one screen
    at a time.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，第一行滚得太快，以至于你无法阅读。如果你无法阅读，纯文本文件有什么用呢？当然，正如你很快就会看到的，Linux有很多文本编辑器可以用来积极管理内容，但能够一次阅读较长的文件，一次一屏，可能也很不错。
- en: less (display file contents)
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: less（显示文件内容）
- en: 'Welcome to `less`—thus named, presumably, because it can quickly read and display
    *less* than the complete file contents (or perhaps to distinguish it from the
    older `more` command). You launch `less` by running it against an existing filename:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎使用`less`——这个名字可能是由于它能够快速读取和显示比完整文件内容更少的文本（或者可能是为了与较老的`more`命令区分开来）。你可以通过运行它来启动`less`，针对一个现有的文件名：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using `less`, you can scroll up and down through the file with the arrow, PgUp,
    PgDn, and spacebar keys. When you’re done, press the q key to exit.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`less`，你可以使用箭头键、PgUp、PgDn和空格键上下滚动文件。当你完成时，按q键退出。
- en: '1.2.3\. Getting things done: Linux file management tools'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.3\. 完成任务：Linux文件管理工具
- en: 'If you’ve got files and directories, you’ll need to know how to create, destroy,
    move, and copy them. Files are often automatically created by some external process
    such as a software installation or an automated log generation or, say, by saving
    your work within an office productivity package like LibreOffice. There isn’t
    much need to discuss all that here. I’ll note, however, that you can quickly create
    an empty file using the `touch` command, followed by the name you’d like to give
    it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有文件和目录，你需要知道如何创建、销毁、移动和复制它们。文件通常由某些外部过程自动创建，例如软件安装或自动日志生成，或者，比如，在LibreOffice这样的办公生产力软件包中保存你的工作。在这里讨论所有这些内容并不是很有必要。然而，我要指出的是，你可以使用`touch`命令快速创建一个空文件，然后输入你想要给它的名字：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can then see the file listed within your current directory through the
    `ls` command. Displaying its contents with `cat` will, of course, display nothing
    at all because you’ve only just created the file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过`ls`命令在你的当前目录中看到该文件的列表。当然，使用`cat`显示其内容将不会显示任何内容，因为你刚刚创建了该文件：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: “Touching” an existing file with `touch` updates its time stamp without making
    any changes. This can be useful if, for some reason, you want to change how various
    commands like `ls` list or display a file. (It can also be helpful if you’d like
    your boss to think that you’ve been hard at work on a data file that, in fact,
    you haven’t opened for weeks.)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`touch`命令“触摸”现有文件会更新其时间戳，而不会进行任何更改。如果出于某种原因，你想改变`ls`等命令如何列出或显示文件，这可能很有用。（如果你想让你的老板认为你一直在努力工作在一个数据文件上，而这个文件实际上你已经几周没有打开过，这也有帮助。）
- en: Of course, you won’t get too far in this fast-paced, dog-eat-dog world by just
    creating directories full of empty files. Eventually, you’ll need to fill them
    with stuff and then edit the stuff that’s already there. For that, you’ll want
    to introduce yourself to a reliable text editor.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅通过创建满是空文件的目录，你在这个快节奏、弱肉强食的世界中不会走得太远。最终，你需要填充它们，并编辑已经存在的文件。为此，你需要熟悉一个可靠的文本编辑器。
- en: Before I throw myself headfirst into a very dangerous place, I should mention
    that lots of folks develop strong feelings for their text editors. Have you ever
    politely hinted to a Vim user that their venerable editor might not be as useful
    and important as it once was? Of course you haven’t. You wouldn’t be physically
    able to read this book if you’d done something like that.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我一头扎进一个非常危险的地方之前，我应该提到，很多人对他们的文本编辑器有着强烈的感情。你有没有礼貌地暗示过Vim用户，他们尊贵的编辑器可能不像以前那样有用和重要？当然没有。如果你做了类似的事情，你就不可能读到这本书。
- en: 'I definitely won’t be telling you which text editor you must use. I will, however,
    tell you that full-featured word processors like LibreOffice and MS Word should
    *never* be used for your Linux administration work. Those applications will add
    all kinds of hidden formatting to your documents that will break system-level
    files. What I can say is that, roughly speaking, there are three categories of
    editors that could work for you:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我绝对不会告诉你必须使用哪个文本编辑器。然而，我会告诉你，功能齐全的文本处理器，如LibreOffice和MS Word，*永远*不应该用于你的Linux管理工作。这些应用程序会在你的文档中添加各种隐藏的格式，这会破坏系统级文件。我可以说的是，粗略地说，有三种编辑器可能适合你：
- en: If you prefer to work on documents from the GUI environment, then a simple *plain-text
    editor* like gedit (Ubuntu calls this *the Text Editor*) is great. Various syntax
    highlighting tools are also available to make coding and scripting more productive,
    and you can be confident that such a tool will save nothing but the text you see.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你更喜欢在GUI环境中处理文档，那么一个简单的*纯文本编辑器*，如gedit（Ubuntu将其称为*文本编辑器*）就非常不错。还有各种语法高亮工具可供使用，使编码和脚本编写更加高效，你可以放心，这样的工具只会保存你看到的文本。
- en: For those times when you need to edit a file from inside a terminal session,
    then a *command-line editor* like nano (or Pico) with its intuitive interface
    can do the job.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要从终端会话中编辑文件时，一个具有直观界面的*命令行编辑器*，如nano（或Pico）可以完成这项工作。
- en: 'And, finally, there’s *Vim* (or its original iteration: vi). Ah, Vim. If you’re
    willing to invest a few months of your life into learning what is largely a nonintuitive
    interface, then you’ll be rewarded with a lifetime of greatly enhanced productivity.
    It’s that simple.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，还有*Vim*（或其原始版本：vi）。啊，Vim。如果你愿意投入几个月的时间来学习这个在很大程度上是非直观的界面，那么你将获得一生大幅提高的生产力。就这么简单。
- en: '|  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: All my books, articles, and course-related documents are written in gedit. Why?
    I like it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我所有的书籍、文章和课程相关文档都是用gedit编写的。为什么？因为我喜欢它。
- en: '|  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Why not take a minute or two right now and make some edits to the myfile document
    you just created using each of the three text editors mentioned? For example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不现在花一两分钟时间，使用前面提到的三个文本编辑器之一编辑你刚刚创建的myfile文档呢？例如：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For Vim, enter Insert Mode by pressing the i key and then typing your text.
    If you don’t want to spend the rest of your life trapped inside Vim, you can save
    your work by pressing Esc, then type `:w`, and then exit by typing `:q`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Vim，通过按i键进入插入模式，然后输入你的文本。如果你不想余生都困在Vim中，你可以通过按Esc键，然后输入`:w`来保存你的工作，然后通过输入`:q`来退出。
- en: Creating and deleting directories
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建和删除目录
- en: 'Every object within a Linux file system is represented by a unique collection
    of metadata called an *inode*. I suppose you could say that the file system index
    discussed earlier is built from the metadata associated with all the many inodes
    on a drive. To display more information about the file you just created using
    `touch`, including inode information, you can use the `stat` command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Linux文件系统中的每个对象都由一个唯一的元数据集合表示，称为inode。我想你可以这样说，之前讨论的文件系统索引是由驱动器上所有许多inode的元数据构建的。要显示使用
    `touch` 创建的文件（包括inode信息）的更多信息，你可以使用 `stat` 命令：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* The file’s inode ID**'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 文件的inode ID**'
- en: '***2* The file’s permissions and ownership status**'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 文件的权限和所有权状态**'
- en: As you can see, the output includes data describing the file’s name, attributes,
    and time stamps. But it also tells you its inode ID number. It’s important to
    be aware that when you move, copy, or delete a file or directory, all you’re really
    doing is editing its inode attributes, not its ID. An *inode*, by the way, is
    an object used by UNIX systems to identify the disk location and attributes of
    files within a file system (as illustrated in [figure 1.2](#ch01fig02)). Usually
    there’ll be exactly one inode for each file or directory.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，输出包括描述文件名称、属性和时间戳的数据。但它还告诉你它的inode ID号。重要的是要意识到，当你移动、复制或删除文件或目录时，你实际上只是在编辑它的inode属性，而不是它的ID。顺便说一句，inode是UNIX系统用来识别文件系统中文件磁盘位置和属性的对象（如图1.2所示）。通常，每个文件或目录将有一个inode。
- en: 'Assuming that you’re in your home directory, why not create a new directory
    that you can use for your experiments? For that, you’ll use `mkdir`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你处于你的主目录中，为什么不创建一个新的目录，你可以用它来进行实验？为此，你将使用 `mkdir`：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now move to your new directory and create a file there:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在移动到你的新目录并在那里创建一个文件：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So you can see how deleting objects works, move back up to the parent directory
    (using `cd ..`) and delete the directory you just made. Oddly enough, the predefined
    command for deleting directories, `rmdir`, won’t work in this case. Try it yourself:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以看到删除对象是如何工作的，向上移动到父目录（使用 `cd ..`）并删除你刚刚创建的目录。奇怪的是，预定义的删除目录命令 `rmdir` 在这种情况下不起作用。试试看：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: “Directory not empty?” So what? This is a built-in check to prevent you from
    accidentally deleting directories filled with important files and subdirectories
    that you might have forgotten about. To get around this, there are a couple of
    things you can do.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: “目录不为空？”那又怎样？这是一个内置的检查，以防止你意外删除包含重要文件和子目录的目录，你可能已经忘记了。为了解决这个问题，你可以做几件事情。
- en: 'One requires that you add the `--ignore-fail-on-non-empty` argument to the
    `rmdir` command, but that involves an awful lot of typing. Another approach would
    be to manually work through each subdirectory and individually delete every object
    you find. But that can sometimes be even worse. For those times when you are 100%
    sure that there’s absolutely nothing you need beneath the directory, the quickest
    route is to add the `-r` flag (meaning *recursive*) to the `rm` command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是在 `rmdir` 命令中添加 `--ignore-fail-on-non-empty` 参数，但这需要大量的输入。另一种方法是手动逐个处理每个子目录，并逐个删除你找到的每个对象。但有时这可能会更糟。当你100%确信目录下绝对没有任何你需要的东西时，最快的方法是向
    `rm` 命令中添加 `-r` 标志（表示递归）：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now is probably a good time to tell you about one very important difference
    between working with a GUI desktop interface and the command line: the command
    line has no trash can. If you delete something using `rm` (or `rmdir`) and then
    regret it, by and large, you’ll have no way of getting it back. But hey; think
    of all the disk space you’ll have freed up.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能是告诉你关于使用图形用户界面桌面界面和命令行之间一个非常重要区别的好时机：命令行没有回收站。如果你使用 `rm`（或 `rmdir`）删除了某个东西，然后又后悔了，总的来说，你将无法恢复它。但嘿；想想看，你将释放出多少磁盘空间。
- en: Copying and moving files
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 复制和移动文件
- en: 'For this next step, create a few more files and a new directory:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一步，创建一些更多的文件和一个新的目录：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can make an identical copy of an object using `cp`. This example creates
    a copy of file1 within the directory newdir:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `cp` 命令创建对象的相同副本。以下示例在目录newdir中创建了文件file1的副本：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By the way, the `cp` command knows what to do with this command line because
    it’s smart enough to recognize *newdir* as a directory rather than a file. If
    there were no directory called newdir in the current location, `cp` would instead
    make a new copy of file1 named newdir. If you’re anything like me, at some point
    you’re probably going to accidentally misspell a command and end up with an odd
    new file rather than the directory you were after. In any case, check everything
    to confirm it all works out the way it was supposed to.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，`cp` 命令知道如何处理这个命令行，因为它足够聪明，能够识别 *newdir* 作为一个目录而不是文件。如果当前位置没有名为 newdir
    的目录，`cp` 将会创建一个名为 newdir 的新文件副本。如果你像我一样，某个时候你可能会不小心拼错命令，最终得到一个奇怪的新文件而不是你想要的目录。无论如何，检查一切以确保一切按预期工作。
- en: 'Unlike `cp`, the `mv` command will permanently move an object from one place
    to another. Therefore, if you were to move a file from your home directory to
    the newdir subdirectory, the original would no longer be available:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `cp` 命令不同，`mv` 命令会将对象永久地从一处移动到另一处。因此，如果你要将文件从你的主目录移动到 newdir 子目录，原始文件将不再可用：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Again, check the results for yourself. You can copy, move, or delete directories
    using the same commands as for files, adding the `-r` flag where necessary. Remember
    that you might be moving more than just the directory you see: any existing layers
    of unseen nested levels will also be dragged along for the ride.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，亲自检查结果。你可以使用与文件相同的命令复制、移动或删除目录，在必要时添加 `-r` 标志。记住，你可能移动的不仅仅是可见的目录：任何现有的未见的嵌套层也将被拖动。
- en: File globbing
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 文件通配符
- en: Had I been there when they came up with the name *globbing*, I’d have definitely
    urged them to reconsider. Perhaps it’s referring to a steaming swamp creature?
    Or an accidental discharge from the chemical plant up the highway? Actually, as
    it turns out, globbing (derived from the word *global*) describes applying wildcard
    characters to the filenames addressed by your commands.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在他们提出 *globbing* 这个名字的时候在场，我肯定会建议他们重新考虑。也许它是指一条蒸腾的沼泽生物？或者是从高速公路上的化工厂意外排放的？实际上，globbing（源自单词
    *global*）描述的是将通配符字符应用于你的命令所处理的文件名。
- en: 'If you need to move or copy multiple files and would like to avoid typing all
    the names individually, you can often apply the operation globally using the asterisk
    (`*`) wildcard. To move all the contents of the current directory to some other
    location, you might do something like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要移动或复制多个文件，并且不想逐个输入文件名，你通常可以通过使用星号 (`*`) 通配符全局应用操作。要将当前目录的所有内容移动到其他位置，你可能做如下操作：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To move only files with names partially matching a particular sequence, try
    this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要移动只与特定序列部分匹配的文件名，尝试这个：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This command moves all files whose names begin with the letters *file*, but
    leaves everything else untouched. If you had files named file1, file2...file15
    and wanted to move only those between file1 and file9, you’d use the question
    mark (`?`) instead of the asterisk:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会将所有以字母 *file* 开头的文件移动，但会保留其他所有文件不变。如果你有名为 file1, file2...file15 的文件，并且只想移动
    file1 和 file9 之间的文件，你应该使用问号 (`?`) 而不是星号 (*)：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The question mark applies an operation to only those files whose names contain
    the letters *file* and *one* other character. It would leave file10 through file15
    in the current directory.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 问号 (`?`) 只对那些文件名包含字母 *file* 和另一个字符的文件应用操作。它会在当前目录中留下 file10 到 file15。
- en: Deleting files
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 删除文件
- en: 'As you learned earlier, objects can be deleted using `rm`. But keep in mind
    that these operations are effectively irreversible. If you wanted to delete file1
    from the directory, you’d type:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如你之前所学，可以使用 `rm` 删除对象。但请记住，这些操作实际上是不可逆的。如果你想从目录中删除 file1，你应该输入：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: File globbing can be applied to `rm` the same way as to `cp` or `mv`, and with
    the same efficiency. So, for instance, this command
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 文件通配符可以像对 `cp` 或 `mv` 一样应用于 `rm`，并且具有相同的效率。例如，这个命令
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'deletes all files in the current directory whose names begin with the letters
    *file*. Adding the `-r` argument to a delete operation will make the action recursive
    and delete the contents of any subdirectories in the specified path:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 删除当前目录中以字母 *file* 开头的所有文件。在删除操作中添加 `-r` 参数会使操作递归，并删除指定路径中任何子目录的内容：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In fact, that is a very dangerous combination, and even more so when you’re
    working with root authority, giving you power over all system files as well. Think
    very carefully indeed before investing too much into an `rm` command.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是一个非常危险的组合，尤其是当你以root权限工作，拥有对所有系统文件的控制权时。在投入太多到`rm`命令之前，请务必非常仔细地思考。
- en: 1.2.4\. Keyboard tricks
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.4\. 键盘技巧
- en: I doubt there’s anyone who types just for the sheer joy of it. And I suspect
    that most people would really appreciate being told that they can get their typing
    done with, say, 40% fewer keystrokes. Well, I’m about to save you some fairly
    significant keyboard time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我怀疑没有多少人只是为了纯粹的乐趣而打字。而且我猜大多数人都会非常感激得知他们可以用，比如说，40%的更少的按键来完成打字。好吧，我即将为你节省一些相当显著的键盘时间。
- en: Cutting and pasting
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 剪切和粘贴
- en: 'First of all, despite anything you might have seen to the contrary, you can
    copy and paste text into and out of a terminal. It’s true that the familiar Ctrl-c
    (copy) and Ctrl-v (paste) key combinations won’t work for a Bash shell session,
    but Shift-Ctrl-c and Shift-Ctrl-v will. You can also cut and paste by right-clicking
    your mouse and selecting the appropriate operation from the menu. Believe me,
    that can make a very big difference. Just imagine you came across a really long
    command sequence from a reliable online source that looks something like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尽管你可能看到了相反的情况，你可以在终端中复制和粘贴文本。确实，熟悉的Ctrl-c（复制）和Ctrl-v（粘贴）键组合在Bash会话中不起作用，但Shift-Ctrl-c和Shift-Ctrl-v会。你还可以通过右键单击鼠标并从菜单中选择适当的操作来剪切和粘贴。相信我，那可以带来很大的不同。只需想象你从一个可靠的在线来源找到了一个非常长的命令序列，看起来像这样：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Do you want to type that whole thing in? Me neither. Here’s where cutting and
    pasting comes to the rescue.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要输入全部内容吗？我也不想。这就是剪切和粘贴大显身手的地方。
- en: Tab completion
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Tab补全
- en: You’ll really want to know about this one. Bash keeps track of your location
    and environment, and watches as you compose a new command. If the characters you’ve
    typed, based on the files and directories in your current environment, contain
    any hints about your ultimate goal, pressing the Tab key tells Bash to display
    its best guess on the command line. If you’re happy with the suggestion, press
    Enter and you’re on your way.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你真的需要了解这一点。Bash会跟踪你的位置和环境，并监视你编写新命令的过程。如果你输入的字符，基于你当前环境中的文件和目录，包含任何关于你最终目标的提示，按Tab键会告诉Bash在命令行上显示其最佳猜测。如果你对建议满意，按Enter键，你就可以继续了。
- en: Here’s an example. Suppose you’ve downloaded a software archive file thoughtfully
    named something like foo-matic-plus_0.9.1-3_amd64.deb. You’d like to copy it to
    a work directory where you can extract it. Normally, you’d have to type
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子。假设你下载了一个软件存档文件，细心地命名为类似于foo-matic-plus_0.9.1-3_amd64.deb的东西。你希望将其复制到一个工作目录中，以便提取它。通常，你不得不输入
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: But if the file is in your current directory then, assuming it’s the only file
    in that directory that begins with *foo*, all you’ll have to type is `cp foo`
    and press the Tab key. Bash fills in the rest of the filename for you. Because
    Bash can’t read your mind, of course, you’ll still have to type at least enough
    of the destination address to give tab completion something to work with.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果文件位于你的当前目录中，假设它是该目录中唯一以*foo*开头的文件，那么你只需要输入`cp foo`并按Tab键。Bash会为你填写剩余的文件名。当然，由于Bash无法读取你的思想，你仍然至少需要输入足够的目的地地址，以便Tab补全有东西可以工作。
- en: 'Try it yourself. Use `touch` to create a file with some ridiculously long name,
    and then try deleting or copying it using tab completion. Here’s what I came up
    with:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看。使用`touch`创建一个具有非常长的文件名，然后尝试使用Tab补全删除或复制它。这是我想到的：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 1.2.5\. Pseudo file systems
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.5\. 伪文件系统
- en: A normal file is a collection of data that can be reliably accessed over and
    over again, even after a system reboot. By contrast, the contents of a Linux pseudo
    (or virtual) file, like those that might exist in the /sys/ and /proc/ directories,
    don’t really exist in the normal sense. A pseudo file’s contents are dynamically
    generated by the OS itself to represent specific values.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一个普通文件是一组数据，可以在系统重启后反复可靠地访问。相比之下，Linux伪文件（或虚拟文件）的内容，例如可能存在于/sys/和/proc/目录中的内容，在正常意义上并不真正存在。伪文件的内容是由操作系统本身动态生成的，以表示特定的值。
- en: 'For instance, you might be curious to know how much total space you’ve got
    on one of your hard drives. Let me assure you that Linux will be only too happy
    to tell you. Let’s use a command-line program called `cat` to read a file containing
    the number of bytes on the disk, designated by the system as sda:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能想知道你的硬盘上总共有多少空间。让我向你保证，Linux会非常乐意告诉你。让我们使用一个名为`cat`的命令行程序来读取一个包含磁盘字节数的文件，该文件由系统指定为sda：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If the first storage device on a system is called /dev/sda, then, as you might
    guess, the second one would be called /dev/sdb and the third, /dev/sdc. Originally,
    *sda* probably stood for SCSI Device A, but I find that thinking of it as Storage
    Device A makes it more meaningful. You might also run into device designations
    like /dev/hda (hard drive), /dev/sr0 (DVD drive), /dev/cdrom (that’s right, a
    CD-ROM drive), or even /dev/fd0 (floppy drive).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统上的第一个存储设备被称为/dev/sda，那么，正如你可能猜到的，第二个将被称为/dev/sdb，第三个将被称为/dev/sdc。最初，*sda*可能代表SCSI
    Device A，但我发现将其视为Storage Device A更有意义。你也可能会遇到像/dev/hda（硬盘）、/dev/sr0（DVD驱动器）、/dev/cdrom（没错，是CD-ROM驱动器）或甚至/dev/fd0（软盘驱动器）这样的设备标识符。
- en: '|  |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To get this kind of information, there are far simpler ways. You could right-click
    a drive’s icon within your GUI file manager, for instance, but the pseudo files
    in /sys/ are the common source on which all system processes rely.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取这类信息，有更简单的方法。例如，你可以在GUI文件管理器中右键单击驱动器的图标，但/sys/中的伪文件是所有系统进程依赖的常见来源。
- en: 'Don’t happen to know your drive designation? No problem. Knowing that Linux
    organizes attached storage as *block devices*, you can move to the /sys/block/
    directory and list its contents. Among the contents will be a directory called
    sda/. (Remember that sda stands for Storage Drive A.) That’s the first drive used
    by your system on boot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你不知道你的驱动器标识符？没问题。知道Linux将附加存储组织为*块设备*，你可以移动到/sys/block/目录并列出其内容。在其内容中，将有一个名为sda/的目录。（记住，sda代表Storage
    Drive A。）这是系统启动时使用的第一个驱动器：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* All the currently available block devices. A *loop device* is a pseudo
    device that allows a file to be used as though it’s an actual physical device.**'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 所有当前可用的块设备。*循环设备*是一种伪设备，它允许文件像实际物理设备一样被使用。**'
- en: 'Change to the sda/ directory and run `ls`. Among its contents, you’ll probably
    see files with names like sda1, sda2, and sda5\. Each of these represents one
    of the partitions created by Linux to better organize the data on your drive:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到sda/目录并运行`ls`。在其内容中，你可能会看到名为sda1、sda2和sda5等的文件。这些中的每一个都代表Linux为更好地组织你的驱动器上的数据而创建的一个分区：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '1.2.6\. Showing ’em who’s boss: sudo'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.6. 显示谁才是老板：sudo
- en: For practical reasons, using an OS account that enjoys full administration powers
    for day-to-day computing activities is unnecessarily risky. On the other hand,
    fully restricting yourself to a non-administration account makes it pretty much
    impossible to get anything done.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实际原因，使用享有完全管理权限的操作系统账户进行日常计算活动是不必要的风险。另一方面，完全限制自己使用非管理账户几乎无法完成任何事情。
- en: 'Many flavors of Linux solve this problem by providing selected accounts with
    admin authority that under most circumstances are purely theoretical, but that
    can be invoked when necessary by prefacing a command with the word `sudo`. Once
    you confirm your identity by providing your password, your command will be treated
    as though it was issued by the root user:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Linux版本通过为选定的账户提供管理权限来解决此问题，在大多数情况下，这些权限纯粹是理论上的，但在必要时可以通过在命令前加上单词`sudo`来调用。一旦你通过提供密码来确认你的身份，你的命令将被视为由root用户发出的：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* The /etc/shadow file can’t be displayed without sudo powers.**'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 没有sudo权限无法显示/etc/shadow文件。**'
- en: '|  |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: By default, the user created during the initial Linux installation will have
    `sudo` powers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在初始Linux安装过程中创建的用户将拥有`sudo`权限。
- en: '|  |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'When illustrating command-line examples throughout this book, I use a command
    prompt of `$` for commands that don’t require administrator privileges and, instead
    of `$ sudo`, I use `#` for those commands that do. Thus a non-admin command will
    look like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中展示命令行示例时，我使用 `$` 作为不需要管理员权限的命令的命令提示符，而对于需要使用 `$ sudo` 的命令，我则使用 `#`。因此，非管理员命令将看起来像这样：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And a `sudo` command will look like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`sudo`命令将看起来像这样：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 1.3\. Getting help
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3. 获取帮助
- en: One way or another, IT projects will always give you trouble. It can be complicated
    troubleshooting something you’re trying for the first time, or maybe a task you
    haven’t faced in so long that you’ve forgotten the exact syntax. You’re going
    to need help. Here are some solid places to look.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 不论如何，IT项目总会给您带来麻烦。这可能是因为您在尝试复杂的问题解决时遇到了困难，或者可能是因为您已经很久没有面对这个任务，以至于忘记了确切的语法。您将需要帮助。以下是一些可靠的查找地点。
- en: 1.3.1\. Man files
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.1\. Man文件
- en: 'By accepted convention, the people who create and maintain the software behind
    a Linux command also write a highly structured documentation manual known as a
    *man file*. When a Linux program is installed, its man file is nearly always installed
    with it and can be viewed from the command line by typing `man` followed by the
    command name. Believe it or not, the man system itself has a man file, so we’ll
    start there:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 根据公认惯例，创建和维护Linux命令背后软件的人们也会编写一份高度结构化的文档手册，称为*man文件*。当Linux程序安装时，其man文件几乎总是与之一起安装，并且可以通过在命令行中输入`man`后跟命令名称来查看。信不信由你，man系统本身也有一个man文件，所以我们将从这里开始：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When you run this on your own computer, you’ll see that NAME, the first section,
    includes a brief introduction, SYNOPSIS offers a detailed syntax overview, and
    DESCRIPTION provides a more in depth explanation of the program, which usually
    includes a list of command-line arguments and flags. If you’re lucky, you’ll also
    find some useful EXAMPLES.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在自己的计算机上运行此操作时，您会看到NAME部分，即第一个部分，包括简短介绍，SYNOPSIS提供详细的语法概述，DESCRIPTION提供对程序的更深入解释，通常包括命令行参数和标志列表。如果您幸运的话，您还会找到一些有用的示例。
- en: Man files can sometimes be quite large, so skimming through the document looking
    for one particular detail is not always practical. For various historical reasons,
    the Ctrl-f combination that launches local search operations within more modern
    applications like web browsers and word processors isn’t available. Instead, press
    the `/` key to get a text entry field at the bottom of the screen where you can
    type your search pattern. If the first highlighted result isn’t what you want,
    press the n key (as many times as necessary) to search forward in the document
    for the same string until you find what you’re looking for.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Man文件有时可能相当大，因此浏览文档寻找特定细节并不总是实用的。由于各种历史原因，在像网络浏览器和文字处理程序这样的现代应用程序中启动本地搜索操作的Ctrl-f组合键不可用。相反，按`/`键以在屏幕底部获得一个文本输入字段，您可以在其中输入您的搜索模式。如果第一个高亮显示的结果不是您想要的，按n键（根据需要多次）在文档中向前搜索相同的字符串，直到找到您要找的内容。
- en: 1.3.2\. Info
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.2\. Info
- en: 'The man system is great if you happen to know the name of the command or program
    you’re after. But suppose the command name is the bit that you’re missing. Type
    `info` at the command prompt, and you’ll be transported to an environment that
    is, by Bash standards, downright interactive:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您恰好知道您要找的命令或程序的名称，man系统就非常棒。但假设命令名称是您缺失的部分。在命令提示符下输入`info`，您将被带到Bash标准下，一个直接交互的环境：
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see from [figure 1.3](#ch01fig03), the content is arranged alphabetically
    by topic with headings like Basics and Compression. You can use the up and down
    arrow keys to scroll between lines; and, when you reach a topic of interest, you
    can press Enter to move to the topic’s page.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从[图1.3](#ch01fig03)中可以看到，内容按主题字母顺序排列，标题如基础和压缩。您可以使用上下箭头键在行之间滚动；并且，当您到达感兴趣的某个主题时，您可以按Enter键跳转到该主题的页面。
- en: Figure 1.3\. The first screen of Info’s main menu. Info links may appear different
    on your system depending on what software you’ve installed.
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.3\. Info主菜单的第一屏。Info链接在您的系统上可能因您安装的软件而异。
- en: '![](Images/01fig03_alt.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片1.3](Images/01fig03_alt.jpg)'
- en: Let’s suppose that you want to learn more about file permissions. Scroll down
    through the Basics section until you get to File Permissions, and press Enter.
    The Menu section of this page indicates that the lines that follow are links to
    more pages another level down. The u key will take you back up one level, and
    pressing q will exit Info altogether.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想了解更多关于文件权限的信息。在基础部分向下滚动，直到到达文件权限，然后按Enter键。此页面的菜单部分表明，以下行是链接到下一级更多页面的链接。按u键将您带回到上一级，按q键将完全退出Info。
- en: I have the sense that Info isn’t as heavily used in the community as it should
    be. In fact, I myself have a dark secret to share about Info—I worked with Linux
    for the better part of a decade before I even noticed it!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一种感觉，Info 在社区中的使用并没有像它应该的那样广泛。事实上，我自己也有一个关于 Info 的秘密要分享——在我甚至注意到它之前，我已经与 Linux
    合作了十年多！
- en: By default, the Info system might not be installed on some Linux server distributions.
    If typing `info` at the command prompt doesn’t give you the satisfaction you’re
    seeking, you can install it (on Ubuntu/Debian systems) using `sudo apt install
    info`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Info 系统可能没有安装在一些 Linux 服务器发行版上。如果你在命令提示符下输入 `info` 没有给你带来你寻求的满足感，你可以在
    Ubuntu/Debian 系统上使用 `sudo apt install info` 来安装它。
- en: 1.3.3\. The internet
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.3\. 互联网
- en: No matter how dumb you may think you are, I can assure you that thousands of
    Linux administrators with all levels of experience have faced the same kinds of
    problems and solved them. Many of the solutions were the result of reaching out
    for help in an online community forum like link:serverfault.com or link:linuxquestions.org/questions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你认为自己有多笨，我都可以向你保证，成千上万的 Linux 管理员，无论经验水平如何，都面临过相同类型的问题并解决了它们。许多解决方案都是通过在线社区论坛（如
    link:serverfault.com 或 link:linuxquestions.org/questions）寻求帮助的结果。
- en: Of course, you can always post your own questions on those sites, but why bother?
    Internet search engines do a great job indexing the questions that have already
    been asked and answered. A well-formed search query can usually get you to what
    you need much more quickly than starting the whole process over again from scratch.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以在那些网站上发布自己的问题，但为什么要麻烦呢？互联网搜索引擎已经很好地索引了已经提出并回答的问题。一个良好的搜索查询通常可以让你更快地找到你需要的东西，而不是从头开始整个过程。
- en: 'The trick is knowing how to search intelligently. Typing `my server crashed`
    in the search field and hoping for the best probably won’t be all that useful.
    You obviously need more detail. OK. What kind of server is it: an Apache web server?
    Did any error messages appear in your browser? Did the crash generate any log
    entries? It’d probably be a good idea to find out.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 小技巧在于知道如何智能地搜索。在搜索框中输入`我的服务器崩溃了`并寄希望于最好的结果可能不会很有用。显然，你需要更多的细节。好吧。这是什么类型的服务器：Apache
    网络服务器？你的浏览器中是否出现了任何错误消息？崩溃是否生成了任何日志条目？弄清楚这些可能是个不错的想法。
- en: Getting error information from system logs
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从系统日志获取错误信息
- en: 'On nearly all modern Linux distributions (with the notable exception of Ubuntu
    14.04), you can access all system logs through `journalctl`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有现代 Linux 发行版（Ubuntu 14.04 是一个值得注意的例外），你都可以通过 `journalctl` 访问所有系统日志：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you’ll quickly see, running `journalctl` without any arguments will drown
    you in a torrent of data. You’ll need to find some way to filter for the information
    you’re after. Allow me to introduce you to `grep`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 很快你就会看到，不使用任何参数运行 `journalctl` 会使你淹没在数据洪流中。你需要找到一种方法来过滤你想要的信息。让我向你介绍 `grep`：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* The | (pipe) character uses the output of one command (journalctl, for
    example) as input for the next (grep).**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 管道（|）字符使用一个命令（例如 journalctl）的输出作为下一个命令（grep）的输入。**'
- en: In this example, I use the vertical line (`|`) that’s achieved on US keyboard
    layouts through the Shift-\ combination. This pipes the output of `journalctl`
    to the `grep` filter, which will print to the screen only those lines that include
    the string `filename.php`. I’m assuming, of course, that your web server is running
    PHP content and that there’s a file named filename.php. Not that I’d ever do that.
    I usually give mine far more descriptive and useful names like stuff.php.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我使用的是通过美国键盘布局中的 Shift-\ 组合实现的垂直线（|）。这会将 `journalctl` 的输出传递到 `grep` 过滤器，只打印包含字符串
    `filename.php` 的那些行。当然，我假设你的网络服务器正在运行 PHP 内容，并且有一个名为 filename.php 的文件。当然，我永远不会这样做。我通常给我的文件起更描述性和有用的名字，比如
    stuff.php。
- en: 'You can use `grep` in sequence to narrow your results further. Suppose there
    were too many journal entries for filename.php, and you realized you only needed
    the ones that also contain the word *error*. You could pipe the results of the
    first operation to a second `grep` command, filtering for *error*:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `grep` 连续使用来进一步缩小结果。假设 filename.php 的日志条目太多，你意识到你只需要包含单词 *error* 的那些。你可以将第一个操作的输出传递到第二个
    `grep` 命令，过滤 *error*：
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In case you’d prefer to see only those lines that don’t contain the word *error*,
    you’d add `-v` (for inverted results):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想看到不包含单词 *error* 的那些行，你可以添加 `-v`（用于反转结果）：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Searching the internet
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在互联网上搜索
- en: 'Now imagine that the output you got from `journalctl` includes this text:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，您从 `journalctl` 获取的输出包括以下文本：
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This might be useful. There’s no point searching the internet for the date stamp
    or for that particular IP address, but I’ll bet someone else has encountered `Client
    sent malformed Host header`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能很有用。在互联网上搜索日期戳或特定IP地址毫无意义，但我敢打赌其他人也遇到过 `Client sent malformed Host header`。
- en: To cut down on false positives, you might want to enclose the words in quotation
    marks so your search engine returns only results matching that exact phrase. Another
    way to minimize false positives is to tell the search engine to ignore pages containing
    a particular string.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少误报，您可能希望将单词用引号括起来，以便您的搜索引擎只返回匹配该确切短语的搜索结果。减少误报的另一种方法是告诉搜索引擎忽略包含特定字符串的页面。
- en: 'In this rather silly example, you’re searching the internet for a good introduction
    to writing Linux scripts. You find that, based on most of the results your search
    engine shows you for writing scripts, someone out there seems to think that you’d
    rather live in Hollywood. You can solve that problem by excluding pages that contain
    the word *movie*:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个相当愚蠢的例子中，您正在互联网上搜索关于编写Linux脚本的优秀介绍。您发现，根据您搜索引擎显示的大多数编写脚本的结果，似乎有人认为您更愿意住在好莱坞。您可以通过排除包含单词
    *movie* 的页面来解决这个问题：
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: 'Just about any Linux command-line operation will make use of some or all of
    five basic tools: `ls`, `pwd`, `cd`, `cat`, and `less`.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎任何Linux命令行操作都会使用五个基本工具中的某些或全部：`ls`、`pwd`、`cd`、`cat` 和 `less`。
- en: Linux uses pseudo file systems to expose data on the hardware environment to
    processes and users.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 使用伪文件系统将硬件环境上的数据暴露给进程和用户。
- en: Authorized users can invoke `sudo` to gain administration permissions for individual
    commands.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权用户可以通过调用 `sudo` 来为单个命令获取管理权限。
- en: There’s a great deal of documentation and other help available through the man
    system, Info, and online.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过man系统、Info和在线，有大量的文档和其他帮助信息可用。
- en: Key terms
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键术语
- en: A *file system* is made up of data files indexed in a way that allows the perception
    of a directory-based organization.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件系统* 由按目录组织方式索引的数据文件组成。'
- en: A *process* is an active instance of a running software program.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*进程* 是运行软件程序的活动实例。'
- en: A *disk partition* is the logical division of a physical storage device that
    can be made to work exactly like a standalone device. Partitions are common organizational
    tools for all modern operating systems.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*磁盘分区* 是物理存储设备的逻辑划分，可以使其像独立设备一样工作。分区是所有现代操作系统的常见组织工具。'
- en: '*Bash* is a command-line user interface for executing system actions.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Bash* 是一个用于执行系统操作的命令行用户界面。'
- en: '*Plain text* that is usable for administration purposes is text made up of
    a limited set of characters and contains no extraneous formatting code.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于管理的 *纯文本* 是由有限字符集组成的文本，不包含任何多余的格式化代码。
- en: '*File globbing* involves using wildcard characters to refer to multiple files
    with a single command.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件通配符* 涉及使用通配符来通过单个命令引用多个文件。'
- en: '*Tab completion* employs the Tab key to suggest possible completions of a partially
    typed command.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Tab补全* 使用Tab键来建议部分输入命令的可能完成。'
- en: '*Pseudo file systems* are directories containing files with dynamic data automatically
    generated at or after system boot.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*伪文件系统* 是包含具有动态数据（在系统启动时或之后自动生成）的目录。'
- en: Security best practices
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全最佳实践
- en: Avoid working on your Linux machine as the root user. Use a regular user account
    instead, and, when you need to perform administration tasks, use `sudo`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 避免以root用户身份在Linux机器上工作。使用普通用户账户，并在需要执行管理任务时使用 `sudo`。
- en: Command-line review
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令行审查
- en: '`ls -lh /var/log` lists the contents and full, human-friendly details of the
    /var/log/ directory.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls -lh /var/log` 列出 /var/log/ 目录的内容和完整、人性化的详细信息。'
- en: '`cd`, by itself, returns you to your home directory.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cd` 单独使用时，会返回到您的家目录。'
- en: '`cp file1 newdir` copies a file called file1 to the directory named newdir.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cp file1 newdir` 将名为 file1 的文件复制到名为 newdir 的目录中。'
- en: '`mv file? /some/other/directory/` moves all files containing the letters *file*
    and one more character to the target location.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mv file? /some/other/directory/` 将包含字母 *file* 和一个额外字符的所有文件移动到目标位置。'
- en: '`rm -r *` deletes all files and directories beneath the current location. Use
    with great care.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm -r *` 删除当前位置下的所有文件和目录。请谨慎使用。'
- en: '`man sudo` opens the man documentation file on using `sudo` with commands.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man sudo` 打开使用 `sudo` 的 man文档文件。'
- en: Test yourself
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试自己
- en: '**[1](#ch01qa2q0a1)**'
  id: totrans-273
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](#ch01qa2q0a1)**'
- en: ''
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following Linux distributions is best suited for security operations?
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个 Linux 发行版最适合安全操作？
- en: ''
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: OpenSUSE
  id: totrans-277
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenSUSE
- en: CentOS
  id: totrans-278
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: CentOS
- en: Kali Linux
  id: totrans-279
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kali Linux
- en: LXLE
  id: totrans-280
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: LXLE
- en: '**[2](#ch01qa2q0a2)**'
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](#ch01qa2q0a2)**'
- en: ''
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following tools allows you to edit text within a terminal session?
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个工具允许你在终端会话中编辑文本？
- en: ''
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: nano
  id: totrans-285
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: nano
- en: gedit
  id: totrans-286
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: gedit
- en: touch
  id: totrans-287
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: touch
- en: LibreOffice
  id: totrans-288
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: LibreOffice
- en: '**[3](#ch01qa2q0a3)**'
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](#ch01qa2q0a3)**'
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does adding the `-l` argument to the `ls` command do?
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 向 `ls` 命令添加 `-l` 参数的作用是什么？
- en: ''
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Lists file details
  id: totrans-293
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出文件详细信息
- en: Lists information in a human readable format
  id: totrans-294
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以人类可读的格式列出信息
- en: Displays only file names
  id: totrans-295
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅显示文件名
- en: Displays subdirectories recursively
  id: totrans-296
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归显示子目录
- en: '**[4](#ch01qa2q0a4)**'
  id: totrans-297
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](#ch01qa2q0a4)**'
- en: ''
  id: totrans-298
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following commands will display your current location within the
    file system?
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个命令会显示你在文件系统中的当前位置？
- en: ''
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`touch`'
  id: totrans-301
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`touch`'
- en: '`pwd`'
  id: totrans-302
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pwd`'
- en: '`ls -c`'
  id: totrans-303
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ls -c`'
- en: '`cd`'
  id: totrans-304
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cd`'
- en: '**[5](#ch01qa2q0a5)**'
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[5](#ch01qa2q0a5)**'
- en: ''
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does the command `cat /etc/group` do?
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 命令 `cat /etc/group` 的作用是什么？
- en: ''
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Displays the contents of the /etc/group file within a navigable interface
  id: totrans-309
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在可导航界面中显示 /etc/group 文件的内容
- en: Copies the /etc/group file to a new, specified location
  id: totrans-310
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 /etc/group 文件复制到新的指定位置
- en: Updates the last accessed value of the /etc/group file
  id: totrans-311
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 /etc/group 文件的最后访问值
- en: Prints the contents of the /etc/group file to output (scrolling the contents
    to the screen)
  id: totrans-312
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 /etc/group 文件的内容打印到输出（在屏幕上滚动内容）
- en: '**[6](#ch01qa2q0a6)**'
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[6](#ch01qa2q0a6)**'
- en: ''
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of these commands will delete directories containing files and subdirectories?
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个命令会删除包含文件和子目录的目录？
- en: ''
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`rmdir myfulldirectory`'
  id: totrans-317
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rmdir myfulldirectory`'
- en: '`sudo rmdir myfulldirectory`'
  id: totrans-318
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sudo rmdir myfulldirectory`'
- en: '`rm -r myfulldirectory`'
  id: totrans-319
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rm -r myfulldirectory`'
- en: '`rm myfulldirectory`'
  id: totrans-320
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rm myfulldirectory`'
- en: '**[7](#ch01qa2q0a7)**'
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[7](#ch01qa2q0a7)**'
- en: ''
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Assuming there’s no directory named mynewfile, what will the `mv myfile mynewfile`
    command do?
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 假设没有名为 mynewfile 的目录，`mv myfile mynewfile` 命令会做什么？
- en: ''
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make a copy of the file myfile named mynewfile
  id: totrans-325
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 mynewfile 的文件名为 myfile 的文件副本
- en: Create an empty directory named mynewfile
  id: totrans-326
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 mynewfile 的空目录
- en: Create an empty directory named mynewfile and move the myfile file into the
    new directory
  id: totrans-327
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 mynewfile 的空目录并将 myfile 文件移动到新目录中
- en: Change the name of myfile to mynewfile
  id: totrans-328
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 myfile 的名称更改为 mynewfile
- en: '**[8](#ch01qa2q0a8)**'
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[8](#ch01qa2q0a8)**'
- en: ''
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following will delete all files with the word *file* plus any number
    of characters in its name?
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个命令会删除所有包含单词 *file* 以及其名称中任意数量的字符的文件？
- en: ''
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`rm file*`'
  id: totrans-333
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rm file*`'
- en: '`rm file?`'
  id: totrans-334
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rm file?`'
- en: '`rm file.`'
  id: totrans-335
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rm file.`'
- en: '`rm file??`'
  id: totrans-336
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rm file??`'
- en: Answer key
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 答案键
- en: '**[1.](#ch01qa1q1)**'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1.](#ch01qa1q1)**'
- en: ''
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c
- en: '**[2.](#ch01qa1q2)**'
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2.](#ch01qa1q2)**'
- en: ''
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a
- en: '**[3.](#ch01qa1q3)**'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3.](#ch01qa1q3)**'
- en: ''
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a
- en: '**[4.](#ch01qa1q4)**'
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4.](#ch01qa1q4)**'
- en: ''
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: b
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: b
- en: '**[5.](#ch01qa1q5)**'
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[5.](#ch01qa1q5)**'
- en: ''
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d
- en: '**[6.](#ch01qa1q6)**'
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[6.](#ch01qa1q6)**'
- en: ''
  id: totrans-354
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: c
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: c
- en: '**[7.](#ch01qa1q7)**'
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[7.](#ch01qa1q7)**'
- en: ''
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d
- en: '**[8.](#ch01qa1q8)**'
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[8.](#ch01qa1q8)**'
- en: ''
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a
