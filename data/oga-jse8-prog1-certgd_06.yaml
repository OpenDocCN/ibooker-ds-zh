- en: Chapter 6\. Working with inheritance
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章。处理继承
- en: '| Exam objectives covered in this chapter | What you need to know |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| 本章涵盖的考试目标 | 你需要了解的内容 |'
- en: '| --- | --- |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [[7.1](kindle_split_021.html#ch07lev1sec1)] Describe inheritance and its
    benefits. | The need for inheriting classes. How to implement inheritance using
    classes. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| [[7.1](kindle_split_021.html#ch07lev1sec1)] 描述继承及其好处。 | 需要继承类的原因。如何使用类实现继承。|'
- en: '| [[7.2](kindle_split_021.html#ch07lev1sec2)] Develop code that demonstrates
    the use of polymorphism; including overriding and object type versus reference
    type. | How to implement polymorphism with classes and interfaces. How to define
    polymorphic or overridden methods. How to determine the valid types of the variables
    that can be used to refer to an object. How to determine the differences in the
    members of an object, which ones are accessible, and when an object is referred
    to using a variable of an inherited base class or an implemented interface. |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| [[7.2](kindle_split_021.html#ch07lev1sec2)] 开发演示多态使用的代码；包括重写和对象类型与引用类型。 |
    如何使用类和接口实现多态。如何定义多态或重写方法。如何确定可以用来引用对象的变量的有效类型。如何确定对象的成员之间的差异，哪些是可访问的，以及当使用继承的基类或实现的接口的变量引用对象时会发生什么。|'
- en: '| [[7.3](kindle_split_021.html#ch07lev1sec3)] Determine when casting is necessary.
    | The need for casting. How to cast an object to another class or an interface.
    |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| [[7.3](kindle_split_021.html#ch07lev1sec3)] 确定何时需要类型转换。 | 类型转换的需要。如何将对象转换到另一个类或接口。|'
- en: '| [[7.4](kindle_split_021.html#ch07lev1sec4)] Use super and this to access
    objects and constructors. | How to access variables, methods, and constructors
    using super and this. What happens if a derived class tries to access variables
    of a base class when the variables aren''t accessible to the derived class. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| [[7.4](kindle_split_021.html#ch07lev1sec4)] 使用super和this来访问对象和构造函数。 | 如何使用super和this访问变量、方法和构造函数。如果派生类尝试访问对派生类不可访问的基类变量会发生什么。|'
- en: '| [[7.5](kindle_split_021.html#ch07lev1sec6)] Use abstract classes and interfaces.
    | The role of abstract classes and interfaces in implementing polymorphism. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| [[7.5](kindle_split_021.html#ch07lev1sec6)] 使用抽象类和接口。 | 抽象类和接口在实现多态中的作用。|'
- en: '| [9.5] Write a simple Lambda expression that consumes a Lambda Predicate expression
    | Syntax and usage of lambda expressions. Usage of Predicate class. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| [9.5] 编写一个简单的Lambda表达式，该表达式消耗一个Lambda谓词表达式 | Lambda表达式的语法和用法。Predicate类的使用。|'
- en: All living beings inherit the characteristics and behaviors of their parents.
    The offspring of a fly looks and behaves like a fly, and that of a lion looks
    and behaves like a lion. But despite being similar to their parents, all offspring
    are also different and unique in their own ways. In addition, a single action
    may have different meanings for different beings. For example, the action “eat”
    has different meanings for a fly than a lion. A fly eats nectar, whereas a lion
    eats an antelope.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有生物都继承了其父母的特征和行为。苍蝇的后代看起来像苍蝇，狮子后代看起来像狮子。但尽管与父母相似，所有后代都以自己的方式不同和独特。此外，单个动作对不同生物可能有不同的含义。例如，“吃”这个动作对苍蝇和狮子有不同的含义。苍蝇吃花蜜，而狮子吃羚羊。
- en: Something similar happens in Java. The concept of inheriting characteristics
    and behaviors from parents can be compared to classes inheriting variables and
    methods from a parent class. Being different and unique in one’s own way is similar
    to how a class can both inherit from a parent and define additional variables
    and methods. Single actions having different meanings can be compared to polymorphism
    in Java.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的情况也发生在Java中。从父类继承特性和行为的概念可以与类从父类继承变量和方法相比较。以独特的方式与众不同类似于一个类可以同时从父类继承并定义额外的变量和方法。单个动作具有不同含义的情况可以与Java中的多态性相比较。
- en: 'In the OCA Java SE 8 Programmer I exam, you’ll be asked questions on how to
    implement inheritance and polymorphism and how to use classes and interfaces.
    Hence, this chapter covers the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在OCA Java SE 8程序员I考试中，你将需要回答有关如何实现继承和多态以及如何使用类和接口的问题。因此，本章涵盖了以下内容：
- en: Understanding and implementing inheritance
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和实现继承
- en: Developing code that demonstrates the use of polymorphism
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发演示多态使用的代码
- en: Differentiating between the type of a reference and an object
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分引用类型和对象类型
- en: Determining when casting is required
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定何时需要类型转换
- en: Using `super` and `this` to access objects and constructors
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`super`和`this`来访问对象和构造函数
- en: Using abstract classes and interfaces
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象类和接口
- en: 6.1\. Inheritance with classes
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 类的继承
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[7.1](kindle_split_021.html#ch07lev1sec1)] Describe inheritance and its benefits'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[[7.1](kindle_split_021.html#ch07lev1sec1)] 描述继承及其好处'
- en: '|  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[7.5](kindle_split_021.html#ch07lev1sec6)] Use abstract classes and interfaces'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[[7.5](kindle_split_021.html#ch07lev1sec6)] 使用抽象类和接口'
- en: '|  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: When we discuss inheritance in the context of an object-oriented programming
    language such as Java, we talk about how a class can inherit the properties and
    behavior of another class. The class that inherits from another class can also
    define additional properties and behaviors. The exam will ask you explicit questions
    about the need to inherit classes and how to implement inheritance using classes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在面向对象编程语言（如Java）的上下文中讨论继承时，我们谈论的是一个类如何继承另一个类的属性和行为。从另一个类继承的类也可以定义额外的属性和行为。考试将明确询问继承类的需要以及如何使用类实现继承。
- en: Let’s get started with the need to inherit classes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从需要继承类的情况开始。
- en: 6.1.1\. The need to inherit classes
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1\. 继承类的需要
- en: Imagine the positions *Programmer* and *Manager* within an organization. Both
    of these positions have a common set of properties, including name, address, and
    phone number. These positions also have different properties. A *Programmer* may
    be concerned with a project’s programming languages, whereas a *Manager* may be
    concerned with project status reports.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个组织中的*程序员*和*经理*职位。这两个职位都有一个共同的属性集合，包括姓名、地址和电话号码。这些职位也有不同的属性。程序员可能关注项目的编程语言，而经理可能关注项目状态报告。
- en: Let’s assume you’re supposed to store details of all Programmers and Managers
    in your office. [Figure 6.1](#ch06fig01) shows the properties and behavior that
    you may have identified for a Programmer and a Manager, together with their representations
    as classes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要在办公室存储所有程序员和管理员的详细信息。[图6.1](#ch06fig01)显示了你可能识别出的程序员和管理员的属性和行为，以及它们作为类的表示。
- en: Figure 6.1\. Properties and behavior of a Programmer and a Manager, together
    with their representations as classes
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1\. 程序员和管理员的属性和行为，以及它们作为类的表示
- en: '![](06fig01_alt.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig01_alt.jpg)'
- en: Did you notice that the classes `Programmer` and `Manager` have common properties,
    namely, `name`, `address`, `phoneNumber`, and `experience`? The next step is to
    pull out these common properties into a new position and name it something like
    *Employee*. This step is shown in [figure 6.2](#ch06fig02).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到程序员和管理员类有共同属性，即`name`、`address`、`phoneNumber`和`experience`吗？下一步是将这些共同属性提取到新的位置，并命名为类似*Employee*的东西。这一步在[图6.2](#ch06fig02)中显示。
- en: Figure 6.2\. Identify common properties and behaviors of a Programmer and a
    Manager, pull them out into a new position, and name it Employee.
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2\. 识别程序员和管理员的共同属性和行为，将它们提取到新的位置，并将其命名为Employee。
- en: '![](06fig02_alt.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig02_alt.jpg)'
- en: This new position, Employee, can be defined as a new class, `Employee`, which
    is inherited by the classes `Programmer` and `Manager`. A class uses the keyword
    `extends` to *inherit* a class, as shown in [figure 6.3](#ch06fig03).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新位置，Employee，可以被定义为一个新的类`Employee`，它被`Programmer`和`Manager`类继承。一个类使用关键字`extends`来*继承*一个类，如[图6.3](#ch06fig03)所示。
- en: Figure 6.3\. The classes `Programmer` and `Manager` extend the class `Employee`.
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3\. `Programmer`和`Manager`类扩展了`Employee`类。
- en: '![](06fig03_alt.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig03_alt.jpg)'
- en: Inheriting a class is also referred to as *subclassing*. In [figure 6.3](#ch06fig03),
    the inherited class `Employee` is also referred to as the *superclass*, *base
    class*, or *parent class*. The classes `Programmer` and `Manager` that inherit
    the class `Employee` are called *subclasses, derived classes*, *extended classes*,
    or *child classes*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 继承一个类也被称为*子类化*。在[图6.3](#ch06fig03)中，继承的类`Employee`也被称为*超类*、*基类*或*父类*。继承`Employee`类的`Programmer`和`Manager`类被称为*子类*、*派生类*、*扩展类*或*子类*。
- en: Why do you think you need to pull out the common properties and behaviors into
    a separate class `Employee` and make the `Programmer` and `Manager` classes inherit
    it? The next section covers the benefits of inheriting classes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为为什么需要将共同属性和行为提取到单独的类`Employee`中，并使`Programmer`和`Manager`类继承它？下一节将介绍继承类的益处。
- en: 6.1.2\. Benefits
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2\. 益处
- en: Do you know that all classes in Java inherit class `java.lang.Object`, either
    implicitly or explicitly? Extending a class offers multiple benefits. Let’s revisit
    the examples used in the previous section to highlight the benefits of inheriting
    classes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道在 Java 中，所有类都隐式或显式地继承自 `java.lang.Object` 类吗？扩展一个类提供了多个好处。让我们回顾上一节中使用的示例，以突出继承类的优势。
- en: Smaller derived class definitions
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 较小的派生类定义
- en: What if you were supposed to write more-specialized classes, such as `Astronaut`
    and `Doctor`, which have the same common characteristics and behaviors as those
    of the class `Employee`? With the class `Employee` in place, you’d only need to
    define the variables and methods that are specific to the classes `Astronaut`
    and `Doctor` and have the classes inherit `Employee`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要编写更专业的类，例如具有与 `Employee` 类相同常见特性和行为的 `Astronaut` 和 `Doctor` 类，会发生什么？有了
    `Employee` 类，你只需定义 `Astronaut` 和 `Doctor` 类特有的变量和方法，并让这些类继承 `Employee`。
- en: '[Figure 6.4](#ch06fig04) is a UML representation of the classes `Astronaut`,
    `Doctor`, `Programmer`, and `Manager`, both with and without inheritance from
    the class `Employee`. As you can see in this figure, the definition of these classes
    is smaller when they inherit the class `Employee`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.4](#ch06fig04) 是 `Astronaut`、`Doctor`、`Programmer` 和 `Manager` 类的 UML 表示，包括从
    `Employee` 类继承和不继承的情况。如图所示，当这些类继承自 `Employee` 类时，它们的定义更小。'
- en: Figure 6.4\. Differences in the size of the classes `Astronaut`, `Doctor`, `Programmer`,
    and `Manager`, both with and without inheriting from the class `Employee`
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.4\. `Astronaut`、`Doctor`、`Programmer` 和 `Manager` 类的大小差异，包括和不包括从 `Employee`
    类继承
- en: '![](06fig04_alt.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig04_alt.jpg)'
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The examples used in this book are simplified and generalized so that you can
    focus on the concept being covered. They don’t take into consideration all real-world
    scenarios. For example, on a particular project, an astronaut or a doctor might
    not be an employee of some organization.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用的示例被简化和泛化，以便你可以专注于正在覆盖的概念。它们没有考虑所有现实世界的场景。例如，在某个特定项目中，宇航员或医生可能不是某个组织的雇员。
- en: '|  |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Ease of modification to common properties and behavior
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 修改公共属性和行为容易
- en: What happens if your boss steps in and tells you that all of these specialized
    classes—`Astronaut`, `Doctor`, `Programmer`, and `Manager`—should now have a property
    `facebookId`? [Figure 6.5](#ch06fig05) shows that with the base class `Employee`
    in place, you just need to add this variable to that base class. If you haven’t
    inherited from the class `Employee`, you’ll need to add the variable `facebookId`
    to *each* of these four classes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的老板介入并告诉你，所有这些专业类——`Astronaut`、`Doctor`、`Programmer` 和 `Manager`——现在都应该有一个属性
    `facebookId`，会发生什么？[图6.5](#ch06fig05) 显示，在基类 `Employee` 存在的情况下，你只需将这个变量添加到基类中。如果你没有从
    `Employee` 类继承，你需要将变量 `facebookId` 添加到这四个类中的每一个。
- en: Figure 6.5\. Adding a new property, `facebookId`, to all classes, with and without
    the base class `Employee`
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.5\. 向所有类添加新的属性 `facebookId`，包括和不包括基类 `Employee`
- en: '![](06fig05_alt.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig05_alt.jpg)'
- en: Note that common code can be modified and deleted from the base class `Employee`
    fairly easily.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可以从基类 `Employee` 中相对容易地修改和删除公共代码。
- en: Extensibility
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Code that works with the base class in a hierarchy tree can work with all classes
    that are added using inheritance later.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与层次树中的基类一起工作的代码可以与后来使用继承添加的所有类一起工作。
- en: 'Assume that an organization needs to send out invitations to all its employees
    and that it uses the following method to do so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个组织需要向所有员工发送邀请，并且它使用以下方法来这样做：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Because the method `sendInvitation` accepts an argument of type `Employee`,
    you can also pass to it a subclass of `Employee`. Essentially, this design means
    that you can use the previous method with a class defined later that has `Employee`
    as its base class. Inheritance makes code extensible.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `sendInvitation` 方法接受类型为 `Employee` 的参数，所以你也可以传递一个 `Employee` 的子类给它。本质上，这种设计意味着你可以使用之前的方法与后来定义的具有
    `Employee` 作为其基类的类一起使用。继承使得代码可扩展。
- en: Use tried-and-tested code from a base class
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用基类中的经过验证的代码
- en: You don’t need to reinvent the wheel. With inheritance in place, subclasses
    can use tried-and-tested code from a base class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要重新发明轮子。有了继承，子类可以使用基类中的经过验证的代码。
- en: Concentrate on the specialized behavior of your classes
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 专注于你类的专业行为
- en: Inheriting a class enables you to concentrate on the variables and methods that
    define the special behavior of your class. Inheritance lets you make use of existing
    code from a base class without having to define it yourself.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 继承一个类使你能够专注于定义你类特殊行为的变量和方法。继承让你能够使用基类中已经定义的现有代码，而无需自己定义它。
- en: Logical structures and grouping
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 逻辑结构和分组
- en: When multiple classes inherit a base class, this creates a logical group. For
    an example, see [figure 6.5](#ch06fig05). The classes `Astronaut`, `Doctor`, `Programmer`,
    and `Manager` are all grouped as types of the class `Employee`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个类继承一个基类时，这会创建一个逻辑组。例如，请参阅图6.5。类`Astronaut`、`Doctor`、`Programmer`和`Manager`都被分组为类`Employee`的类型。
- en: '|  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Inheritance enables you to reuse code that has already been defined by a class.
    Inheritance can be implemented by extending a class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 继承使你能够重用已经由类定义的代码。继承可以通过扩展一个类来实现。
- en: '|  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The next section solves the mystery of how you can access the inherited members
    of a base class directly in a derived class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将解决如何在派生类中直接访问基类继承成员的神秘。
- en: 6.1.3\. A derived class contains within it an object of its base class
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.3\. 派生类在其内部包含其基类的对象
- en: 'The classes `Programmer` and `Manager` inherit the nonprivate variables and
    methods defined in the class `Employee` and use them directly, as if they were
    defined in their own classes. Examine the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Programmer`和`Manager`继承类`Employee`中定义的非私有变量和方法，并直接使用它们，就像它们是在它们自己的类中定义的一样。检查以下代码：
- en: '![](390fig01_alt.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](390fig01_alt.jpg)'
- en: 'How can the class `Programmer` assign a value to a variable that’s defined
    in the class `Employee`? You can think of this arrangement as follows: When a
    class inherits another class, it encloses within it an object of the inherited
    class. Hence, all the nonprivate members (variables and methods) of the inherited
    class are available to the class, as shown in [figure 6.6](#ch06fig06).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如何让类`Programmer`为在类`Employee`中定义的变量赋值？你可以这样考虑这种安排：当一个类继承另一个类时，它在其内部封装了一个继承类的对象。因此，继承类的所有非私有成员（变量和方法）都对类可用，如图6.6所示。
- en: Figure 6.6\. An object of a derived class can access features of its base class
    object.
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.6\. 派生类的对象可以访问其基类对象的功能。
- en: '![](06fig06_alt.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig06_alt.jpg)'
- en: But a derived class can’t inherit all the members of its base class. The next
    two sections discuss which base class members are and aren’t inherited by a derived
    class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但是派生类不能继承其基类的所有成员。接下来的两个部分将讨论哪些基类成员被派生类继承，哪些不被继承。
- en: 6.1.4\. Which base class members are inherited by a derived class?
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.4\. 哪些基类成员被派生类继承？
- en: 'The access modifiers play an important role in determining the inheritance
    of base class members in derived classes. A derived class can inherit only what
    it can see. A derived class inherits all the nonprivate members of its base class.
    A derived class inherits base class members with the following accessibility levels:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符在确定派生类中基类成员的继承中起着重要作用。派生类只能继承它能看到的。派生类继承其基类的所有非私有成员。派生类继承具有以下可访问级别的基类成员：
- en: '*Default—*Members with default access can be accessed in a derived class only
    if the base and derived classes reside in the same package.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*默认—*只有当基类和派生类位于同一包中时，具有默认访问权限的成员才可以在派生类中访问。'
- en: '`protected`—Members with `protected` access are accessible to all the derived
    classes, regardless of the packages in which the base and derived classes are
    defined.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected`—具有`protected`访问权限的成员对所有派生类都是可访问的，无论基类和派生类定义在哪个包中。'
- en: '`public`—Members with `public` access are visible to all other classes.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`—具有`public`访问权限的成员对所有其他类都是可见的。'
- en: '|  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: A derived class can inherit only what it can see.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类只能继承它能看到的。
- en: '|  |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 6.1.5\. Which base class members aren’t inherited by a derived class?
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.5\. 哪些基类成员不被派生类继承？
- en: 'A derived class doesn’t inherit the following members:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类不继承以下成员：
- en: '`private` members of the base class.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类的`private`成员。
- en: Base class members with default access, if the base class and derived classes
    exist in separate packages.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果基类和派生类存在于不同的包中，则具有默认访问权限的基类成员。
- en: Constructors of the base class. A derived class can call a base class’s constructors,
    but it doesn’t inherit them ([section 6.5](kindle_split_020.html#ch06lev1sec5)
    discusses how a derived class can call a base class’s constructors using the implicit
    reference `super`).
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类构造函数。派生类可以调用基类的构造函数，但它并不继承它们（[第6.5节](kindle_split_020.html#ch06lev1sec5) 讨论了派生类如何使用隐式引用
    `super` 调用基类的构造函数）。
- en: Apart from inheriting the properties and behavior of its base class, a derived
    class can also define additional properties and behaviors, as discussed in the
    next section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除了继承其基类的属性和行为外，派生类还可以定义额外的属性和行为，如下一节所述。
- en: 6.1.6\. Derived classes can define additional properties and behaviors
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.6\. 派生类可以定义额外的属性和行为
- en: Although derived classes are similar to their base classes, they generally also
    have differences. Derived classes can define additional properties and behaviors.
    You may see explicit questions on the exam about how a derived class can differ
    from its base class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管派生类与它们的基类相似，但它们通常也有差异。派生类可以定义额外的属性和行为。您可能在考试中看到关于派生类如何与其基类不同的明确问题。
- en: Take a quick look back at [figure 6.5](#ch06fig05). All the derived classes—`Manager`,
    `Programmer`, `Doctor`, and `Astronaut`—define additional variables, methods,
    or both. Derived classes can also define their own constructors and `static` methods
    and variables. A derived class can also *hide* or *override* its base class’s
    members.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾一下 [图6.5](#ch06fig05)。所有派生类——`Manager`、`Programmer`、`Doctor` 和 `Astronaut`——都定义了额外的变量、方法或两者兼而有之。派生类还可以定义自己的构造函数和
    `static` 方法以及变量。派生类还可以 *隐藏* 或 *重写* 它的基类成员。
- en: When a derived class defines an instance or class variable with the same name
    as one defined from its base class, only these new variables and methods are visible
    to code using the derived class. When a derived class defines different code for
    a method inherited from a base class by defining the method again, this method
    is treated as a special method—an *overridden* method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当派生类定义了一个与基类中定义的名称相同的实例或类变量时，只有这些新变量和方法对使用派生类的代码可见。当派生类通过重新定义方法来为从基类继承的方法定义不同的代码时，此方法被视为一个特殊方法——一个
    *重写* 方法。
- en: You can implement inheritance by using either a concrete class or an `abstract`
    class as a base class, but there are some important differences that you should
    be aware of. These are discussed in the next section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用具体类或 `abstract` 类作为基类来实现继承，但您应该注意一些重要的区别。这些将在下一节中讨论。
- en: 6.1.7\. Abstract base class versus concrete base class
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.7\. 抽象基类与具体基类
- en: '[Figures 6.2](#ch06fig02) and [6.3](#ch06fig03) showed how you can pull out
    the common properties and behavior of a `Programmer` and `Manager` and represent
    these as a new class, `Employee`. You can define the class `Employee` as an `abstract`
    class, if you think that it’s only a categorization and no real Employee exists
    in real life—that is, if all Employees are really either *Programmers* or *Managers*.
    That’s the essence of an `abstract` class: it groups the common properties and
    behavior of its derived classes, but it prevents itself from being instantiated.
    Also, an `abstract` class can *force* all its derived classes to define their
    own implementations for a behavior by defining it as an `abstract` method (a method
    without a body).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.2](#ch06fig02) 和 [6.3](#ch06fig03) 展示了如何提取 `Programmer` 和 `Manager` 的公共属性和行为，并将这些表示为一个新的类，`Employee`。如果您认为它只是一个分类，而在现实生活中并没有真正的
    `Employee` 存在——也就是说，如果所有员工实际上都是 *Programmer* 或 *Manager*，那么您可以将 `Employee` 类定义为
    `abstract` 类。这就是 `abstract` 类的本质：它将派生类的公共属性和行为分组，但它阻止自己被实例化。此外，一个 `abstract` 类可以通过将其定义为
    `abstract` 方法（一个没有主体的方法）来 *强制* 所有派生类为其行为定义自己的实现。'
- en: '|  |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '[Section 6.6.1](kindle_split_020.html#ch06lev2sec25) includes an example of
    usage of abstract classes: how it forces its derived classes to implement the
    `abstract` methods.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6.6.1节](kindle_split_020.html#ch06lev2sec25) 包含了抽象类使用示例：它如何强制其派生类实现 `abstract`
    方法。'
- en: '|  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: It isn’t mandatory for an `abstract` class to define an `abstract` method. But
    if an `abstract` base class defines one or more `abstract` methods, the class
    must be marked as `abstract` and the `abstract` methods must be implemented in
    all its concrete derived classes. If a derived class doesn’t implement all the
    `abstract` methods defined by its base class, then it also needs to be an `abstract`
    class.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`abstract`类不一定要定义`abstract`方法。但如果`abstract`基类定义了一个或多个`abstract`方法，该类必须被标记为`abstract`，并且所有具体的派生类都必须实现这些`abstract`方法。如果一个派生类没有实现其基类定义的所有`abstract`方法，那么它也需要是一个`abstract`类。'
- en: 'For the exam, you need to remember the following important points about implementing
    inheritance using an `abstract` base class:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于考试，你需要记住使用`abstract`基类实现继承的重要要点：
- en: You can never create objects of an `abstract` class.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你永远不能创建`abstract`类的对象。
- en: A base class can be defined as an `abstract` class, even if it doesn’t define
    any `abstract` methods.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类可以定义为`abstract`类，即使它没有定义任何`abstract`方法。
- en: A derived class should implement all the `abstract` methods of its base class.
    If it doesn’t, it must be defined as an `abstract` derived class.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生类应该实现其基类中所有的`abstract`方法。如果不实现，它必须被定义为`abstract`派生类。
- en: You can use variables of an `abstract` base class to refer to objects of its
    derived class (discussed in detail in [section 6.3](kindle_split_020.html#ch06lev1sec3)).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`abstract`基类的变量来引用其派生类的对象（详细讨论见[第6.3节](kindle_split_020.html#ch06lev1sec3)）。
- en: The first Twist in the Tale exercise for this chapter queries you on the relationship
    between base and derived classes (answer in the appendix).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一个故事转折练习询问你关于基类和派生类之间的关系（答案见附录）。
- en: Twist in the Tale 6.1
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事转折 6.1
- en: Modify the code used in the previous example as follows. Which of the options
    is correct for this modified code?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 修改之前例子中使用的代码如下。以下哪个选项是修改后代码的正确选项？
- en: '[PRE1]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The class `Office` prints `Harry`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Office`类打印出`Harry`。'
- en: The derived class `Programmer` can’t define a getter method for a variable defined
    in its base class `Employee`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 派生类`Programmer`不能为其基类`Employee`中定义的变量定义一个getter方法。
- en: The derived class `Programmer` can’t access variables of its base class in its
    constructors-.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 派生类`Programmer`在其构造函数中不能访问其基类`Employee`中的变量-。
- en: '`new Programmer ("Harry").getName();` isn’t the right way to create an object
    of class `Programmer`.'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`new Programmer ("Harry").getName();` 并不是创建`Programmer`类对象的正确方式。'
- en: Compilation error.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误。
- en: Terms and definitions to remember
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要记住的术语和定义
- en: Following is a list of terms and their corresponding definitions that you should
    remember; they’re used throughout the chapter, and you’ll come across them while
    answering questions on inheritance in the OCA Java SE 8 Programmer I exam.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一份你应该记住的术语及其对应定义的列表；它们贯穿整个章节，你将在回答OCA Java SE 8程序员I考试中关于继承的问题时遇到它们。
- en: '***Base class—*** A class inherited by another class. The class `Employee`
    is a *base class* for the classes `Programmer` and `Manager` in the previous examples.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***基类***—被另一个类继承的类。在之前的例子中，`Employee`是`Programmer`和`Manager`的*基类*。'
- en: '*Superclass*—A base class is also known as a *superclass*.'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*超类*—一个基类也被称为*超类*。'
- en: '*Parent class*—A base class is also known as a *parent class*.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*父类*—基类也被称为*父类*。'
- en: '***Derived class—*** A class that inherits from another class. The classes
    `Programmer` and `Manager` are *derived classes* in the previous examples.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***派生类***—从另一个类继承的类。在之前的例子中，`Programmer`和`Manager`是*派生类*。'
- en: '*Subclass*—A derived class is also known as a *subclass*.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*子类*—派生类也被称为*子类*。'
- en: '*Extended class*—A derived class is also known as an *extended class*.'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*扩展类*—派生类也被称为*扩展类*。'
- en: '*Child class*—A derived class is also known as a *child class*.'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*子类*—派生类也被称为*子类*。'
- en: '***IS-A relationship—*** A relationship shared by base and derived classes.
    In the previous examples, a `Programmer` IS-A `Employee`. A `Manager` IS-A `Employee`.
    Because a derived class represents a specialized type of a base class, a derived
    class *IS-A* kind of base class.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***“是”关系***—基类和派生类之间共享的关系。在之前的例子中，`Programmer`是`Employee`的“是”。`Manager`是`Employee`的“是”。因为派生类代表基类的一种特殊类型，所以派生类*是*基类的一种。'
- en: '`extends`—The keyword used by a class to inherit another class and by an interface
    to inherit another interface.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extends`—类用来继承另一个类，接口用来继承另一个接口的关键字。'
- en: '`implements`—The keyword used by a class to implement an interface (interfaces
    are covered in the next section).'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`implements`—类用来实现接口的关键字（接口将在下一节中介绍）。'
- en: '|  |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The terms *base class*, *superclass*, and *parent class* are used interchangeably.
    Similarly, the terms *derived class* and *subclass* are also used interchan-geably.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*base class*、*superclass*和*parent class*可以互换使用。同样，术语*derived class*和*subclass*也可以互换使用。
- en: '|  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this section, you learned that an `abstract` class may define `abstract`
    methods. Let’s take it a step further to interfaces. In the next section, we’ll
    discuss why you need interfaces and how to use them.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解到一个`abstract`类可以定义`abstract`方法。让我们更进一步，讨论接口。在下一节中，我们将讨论为什么需要接口以及如何使用它们。
- en: 6.2\. Use interfaces
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 使用接口
- en: '|  |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[[7.1](kindle_split_021.html#ch07lev1sec1)] Describe inheritance and its benefits'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[[7.1](kindle_split_021.html#ch07lev1sec1)] 描述继承及其优点'
- en: '|  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[[7.5](kindle_split_021.html#ch07lev1sec6)] Use abstract classes and interfaces'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[[7.5](kindle_split_021.html#ch07lev1sec6)] 使用抽象类和接口'
- en: '|  |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: We all use interfaces quite often in our lives. For example, when you refer
    to someone as a *runner*, do you care whether that person is also an orator, a
    parent, or an entrepreneur? You care only that the person is able to *run*. The
    term *runner* enables you to refer to unrelated individuals, by opening a small
    window to each person and accessing behavior that’s applicable to *only* that
    person’s capacity as a runner. Someone can be referred to as a runner only if
    that person supports characteristics relevant to running, though the specific
    behavior can depend on the person.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在生活中经常使用接口。例如，当你称呼某人为*runner*时，你是否关心那个人是否也是一位演说家、一个家长或一个企业家？你只关心那个人是否能够*run*。术语*runner*使你能够通过为每个人打开一个小窗口来访问只适用于那个人作为跑步者能力的操作。只有当那个人支持与跑步相关的特征时，那个人才能被称为跑步者，尽管具体的行为可能取决于个人。
- en: In the preceding example, you can compare the term *runner* to a Java interface,
    which defines the required behavior *run.* An interface can define a set of behaviors
    (methods) and constants. Usually it delegates the implementation of the behavior
    to the classes that implement it. Interfaces are used to refer to multiple related
    or unrelated objects that share the same set of behaviors. [Figure 6.7](#ch06fig07)
    compares the interface *runner* with a small *window* to an object, which is concerned
    only about the running capabilities of that object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你可以将术语*runner*与Java接口进行比较，该接口定义了所需的操作*run*。接口可以定义一组行为（方法）和常量。通常，它将行为的实现委托给实现它的类。接口用于引用具有相同行为集的多个相关或不相关的对象。[图6.7](#ch06fig07)将接口*runner*与一个小的*窗口*与一个对象进行比较，该对象只关注该对象的运行能力。
- en: Figure 6.7\. You can compare an interface with a window that can connect multiple
    objects but has limited access to them.
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.7。你可以将一个可以连接多个对象但对其访问有限的用户界面与一个窗口进行比较。
- en: '![](06fig07_alt.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7](06fig07_alt.jpg)'
- en: Similarly, when you design your application by using interfaces, you can use
    similar windows (also referred to as *specifications* or *contracts*) to specify
    the behavior that you need from an object, without caring about the specific types
    of objects.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当你使用接口设计应用程序时，你可以使用类似的窗口（也称为*specifications*或*contracts*）来指定你需要从对象中获取的行为，而不关心对象的特定类型。
- en: '|  |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can compare a *contract* with a set of rules or deliverables that are mutually
    accepted by persons. A contract might include a set of rules to abide by or deliverables
    to be made accessible by a certain date. A contract usually doesn’t include *how*
    the rules stated would be abided by or *how* the deliverables would be made accessible.
    It states *what* and not *how*. Similarly, an interface defines *what* behavior
    would be supported by the classes that implement it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将*contract*与一组由人员相互接受的规定或可交付成果进行比较。合同可能包括一组必须遵守的规定或必须在特定日期前提供的可交付成果。合同通常不包括如何遵守所陈述的规定或如何使可交付成果可访问。它只说明*什么*，而不说明*如何*。同样，接口定义了由实现它的类支持的*什么*行为。
- en: '|  |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Separating the required behavior from its implementation has many benefits.
    As an application designer, you can use interfaces to *establish* the behavior
    that’s required from objects, promoting flexibility in the design (new classes
    that implement an interface can be created and used later). Interfaces make an
    application manageable, extensible, and less prone to propagation of errors due
    to changes to existing types.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将所需行为与其实现分离有许多好处。作为一个应用程序设计者，你可以使用接口来*建立*从对象中所需的行为，从而提高设计的灵活性（可以创建并稍后使用实现接口的新类）。接口使应用程序易于管理、可扩展，并减少由于现有类型更改而传播错误的倾向。
- en: Now imagine you created an interface in an application some time ago. The application
    needs to be upgraded, which requires additional behavior to be added to some of
    its interfaces. This wouldn’t have been possible with Java 7 or its earlier versions.
    But with Java 8, you can add methods to an interface without breaking the existing
    implementations. Prior to Java 8, an interface could only define `abstract` methods.
    With Java 8, an interface can define the default implementation for its methods
    (so it doesn’t stop the existing classes that implement it from compiling). Interfaces
    in Java 8 can also define `static` methods. One of the main reasons for this language
    change (adding default and `static` methods to interfaces) was to improve the
    aging Collections API, especially with Stream-based functionalities (covered by
    the OCP exam).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象你之前在应用程序中创建了一个接口。应用程序需要升级，这需要向其一些接口添加额外的行为。在Java 7或其早期版本中，这是不可能的。但是，随着Java
    8的推出，你可以在不破坏现有实现的情况下向接口添加方法。在Java 8之前，接口只能定义`抽象`方法。随着Java 8的推出，接口可以为其方法定义默认实现（这样就不会阻止实现它的现有类编译）。Java
    8中的接口还可以定义`静态`方法。这种语言变化（向接口添加默认和`静态`方法）的主要原因之一是为了改进过时的Collections API，特别是基于Stream的功能（由OCP考试涵盖）。
- en: In this section, you’ll come to understand the need for and importance of using
    interfaces and different types of methods that can be defined in an interface.
    You’ll work with the implicit and explicit properties of interface members—its
    constants and methods. You’ll also see why inheriting multiples classes isn’t
    allowed but inheriting multiple interfaces is allowed. Let’s get started with
    the need for interfaces.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '在本节中，你将了解使用接口的需求和重要性，以及可以在接口中定义的不同类型的方法。你将处理接口成员的隐式和显式属性——它的常量和方法。你还将看到为什么不允许继承多个类，但允许继承多个接口。让我们从接口的需求开始。 '
- en: 6.2.1\. Need for using interfaces
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1\. 使用接口的需求
- en: You need interfaces to enable multiple classes to support a set of behaviors.
    Let’s work with the example used in [section 6.1](#ch06lev1sec1). In this example,
    `Employee` is the base class and classes `Programmer` and `Manager` subclass `Employee`.
    Imagine that your boss steps in and states that `Programmer` and `Manager` *must*
    support additional behaviors, as listed in [table 6.1](#ch06table01).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要接口来使多个类能够支持一组行为。让我们以[第6.1节](#ch06lev1sec1)中使用的示例为例。在这个例子中，`Employee`是基类，`Programmer`和`Manager`类是`Employee`的子类。想象一下，你的老板介入并声明`Programmer`和`Manager`*必须*支持额外的行为，如[表6.1](#ch06table01)中列出。
- en: Table 6.1\. Additional behaviors that need to be supported by the classes `Programmer`
    and `Manager`
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.1\. 需要由`Programmer`和`Manager`类支持的其他行为
- en: '| Entity | New expected behavior |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 实体 | 新的预期行为 |'
- en: '| --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Programmer | Attend training |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 程序员 | 参加培训 |'
- en: '| Manager | Attend training, conduct interviews |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 经理 | 参加培训，进行面试 |'
- en: 'How will you accomplish this task? One approach you can take is to define all
    the relevant methods in the class `Employee`. Because both `Programmer` and `Manager`
    extend the class `Employee`, they’d be able to access these methods. But wait:
    `Programmer` doesn’t need the behavior of the conducting interview task; only
    `Manager` should support the functionality of conducting interviews.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你将如何完成这项任务？你可以采取的一种方法是在`Employee`类中定义所有相关的方法。因为`Programmer`和`Manager`都扩展了`Employee`类，所以它们将能够访问这些方法。但是等等：`Programmer`不需要进行面试的行为；只有`Manager`应该支持进行面试的功能。
- en: Another obvious approach would be to define the relevant methods in the desired
    classes. You could define methods to conduct interviews in `Manager` and methods
    to attend training in both `Programmer` and `Manager`. Again, this isn’t an ideal
    solution. What will happen if your boss later informs you that all the `Employee`s
    who attend training should accept a *training schedule*; that is, there’s a change
    in the signature of the method that defines the behavior “attend training”? Can
    you define separate classes for this behavior and make the classes `Programmer`
    and `Manager` implement them? No, you can’t. Java doesn’t allow a class to inherit
    multiple classes (covered in a later section in this chapter).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种明显的方法是在所需的类中定义相关的方法。你可以在 `Manager` 类中定义面试方法，在 `Programmer` 和 `Manager` 类中定义参加培训的方法。再次强调，这并不是一个理想解决方案。如果你的老板后来告诉你，所有参加培训的
    `Employee` 都应该接受一个**培训计划**；也就是说，定义“参加培训”行为的方法签名发生了变化？你能为这种行为定义单独的类，并让 `Programmer`
    和 `Manager` 类实现它们吗？不，你不能。Java 不允许一个类继承多个类（本章后面的部分将介绍）。
- en: 'Let’s try interfaces. Create two interfaces to define the specified behavior:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试接口。创建两个接口来定义指定的行为：
- en: '[PRE2]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Although Java doesn’t allow a class to inherit from more than one class, it
    allows a class to implement multiple interfaces. A class uses the keyword `implements`
    to implement an interface. In the following code, the classes `Programmer` and
    `Manager` implement the relevant interfaces (the modified code is in bold):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Java 不允许一个类从多个类中继承，但它允许一个类实现多个接口。一个类使用 `implements` 关键字来实现接口。在下面的代码中，`Programmer`
    和 `Manager` 类实现了相关的接口（修改后的代码用粗体表示）：
- en: '![](397fig01_alt.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](397fig01_alt.jpg)'
- en: '[Figure 6.8](#ch06fig08) displays the relationships between these classes in
    a UML diagram.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6.8](#ch06fig08) 使用 UML 图显示了这些类之间的关系。'
- en: Figure 6.8\. Relationships among the classes `Employee`, `Programmer`, and `Manager`
    and the interfaces `Trainable` and `Interviewer`
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.8\. `Employee`、`Programmer` 和 `Manager` 类以及 `Trainable` 和 `Interviewer`
    接口之间的关系
- en: '![](06fig08.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig08.jpg)'
- en: '|  |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: An interface can be represented in UML diagrams using either a rectangle with
    the text <<interface>> or simply a circle. Both notations are popular; you may
    see them in various websites or books.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UML 图中，可以使用带有文本 <<interface>> 的矩形或简单地使用一个圆来表示接口。这两种表示法都很流行；你可能会在各种网站或书籍中看到它们。
- en: '|  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The preceding relationships can also be represented as depicted in [figure 6.9](#ch06fig09),
    where the interfaces are defined as circles.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的关系也可以表示如图 6.9 所示，其中接口被定义为圆。
- en: Figure 6.9\. Relationships among the classes `Employee`, `Programmer`, and `Manager`
    and the interfaces `Trainable` and `Interviewer`, with interfaces represented
    by circles
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.9\. `Employee`、`Programmer` 和 `Manager` 类以及 `Trainable` 和 `Interviewer`
    接口之间的关系，接口用圆表示
- en: '![](06fig09_alt.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig09_alt.jpg)'
- en: 6.2.2\. Defining interfaces
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2\. 定义接口
- en: You can define methods and constants in an interface. Declaring an interface
    is simple, but don’t let this simplicity take you for a ride. For the exam, it’s
    important to understand the implicit modifiers that are added to the members of
    an interface. All methods of an interface are implicitly `public`. The interface
    variables are implicitly `public`, `static`, and `final`. Let’s define an interface
    `Runner` that defines an `abstract` method `speed` and a variable `distance`.
    [Figure 6.10](#ch06fig10) shows how implicit modifiers are added to the members
    of interface `Runner` during the compilation process.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在接口中定义方法和常量。声明接口很简单，但不要让这种简单性误导你。对于考试来说，了解添加到接口成员中的隐式修饰符非常重要。接口的所有方法都是隐式
    `public` 的。接口变量是隐式 `public`、`static` 和 `final` 的。让我们定义一个名为 `Runner` 的接口，它定义了一个
    `abstract` 方法 `speed` 和一个变量 `distance`。[图 6.10](#ch06fig10) 展示了在编译过程中如何向接口 `Runner`
    的成员添加隐式修饰符。
- en: Figure 6.10\. All the methods of an interface are implicitly public. Its variables
    are implicitly public, static, and final.
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.10\. 接口的所有方法都是隐式公共的。它的变量是隐式公共的、静态的和最终的。
- en: '![](06fig10_alt.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig10_alt.jpg)'
- en: Why do you think these implicit modifiers are added to the interface members?
    Because an interface is used to define a contract, it doesn’t make sense to limit
    access to its members—and so they are implicitly public. An interface can’t be
    instantiated, and so the value of its variables should be defined and accessible
    in a static context, which makes them implicitly static.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为为什么这些隐式修饰符被添加到接口成员中？因为接口用于定义契约，限制对其成员的访问是没有意义的——因此它们隐式为公共。接口不能被实例化，因此其变量的值应在静态上下文中定义和访问，这使得它们隐式为静态。
- en: 'The exam will also test you on the various components of an interface declaration,
    including access and nonaccess modifiers. Here’s the complete list of the components
    of an interface declaration:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 考试还将测试你对接口声明各个组件的了解，包括访问和非访问修饰符。以下是接口声明组件的完整列表：
- en: Access modifiers
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: Nonaccess modifiers
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非访问修饰符
- en: Interface name
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口名称
- en: All extended interfaces, if the interface is extending any interfaces
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果接口扩展了任何接口，则所有扩展的接口
- en: Interface body (variables and methods), included within a pair of curly braces
    `{}`
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口体（变量和方法），包含在一对花括号 `{}` 内
- en: 'To include all the possible components, let’s modify the declaration of the
    interface `Runner`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含所有可能的组件，让我们修改接口 `Runner` 的声明：
- en: '[PRE3]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The components of the interface `Runner` are shown in [figure 6.11](#ch06fig11).
    To declare any interface, you *must* include the keyword `interface`, the name
    of interface, and its body, marked by `{}`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接口 `Runner` 的组件在 [图 6.11](#ch06fig11) 中展示。要声明任何接口，*必须* 包含关键字 `interface`、接口名称以及其体，由
    `{}` 标记。
- en: Figure 6.11\. Components of an interface declaration
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.11\. 接口声明的组件
- en: '![](06fig11_alt.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig11_alt.jpg)'
- en: The optional and compulsory components of an interface can be summarized as
    listed in [table 6.2](#ch06table02).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的可选和必选组件可以总结如下，见 [表 6.2](#ch06table02)。
- en: Table 6.2\. Optional and compulsory components of an interface declaration
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 6.2\. 接口声明的可选和必选组件
- en: '| Compulsory | Optional |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 必选 | 可选 |'
- en: '| --- | --- |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Keyword interface | Access modifier |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 关键字 `interface` | 访问修饰符 |'
- en: '| Name of the interface | Nonaccess modifier |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 接口名称 | 非访问修饰符 |'
- en: '| Interface body, marked by the opening and closing curly braces {} | Keyword
    extends, together with the name of the base interface(s) (Unlike a class, an interface
    can extend multiple interfaces.) |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 接口体，由开闭花括号 `{}` 标记 | 关键字 `extends`，以及基接口的名称（与类不同，接口可以扩展多个接口。） |'
- en: '|  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: The declaration of an interface can’t include a class name. An interface can
    never extend any class.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接口声明不能包含类名。接口永远不会扩展任何类。
- en: '|  |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Can you define a top-level, *protected* interface? No, you can’t. For the exam,
    you must know the answer to questions about the correct values for each component
    that can be used with an interface declaration. Let’s dive into these nuances.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你能定义一个顶级、*受保护的*接口吗？不，你不能。对于考试，你必须知道关于接口声明中每个组件正确值的答案。让我们深入了解这些细微差别。
- en: Valid access modifiers for an interface
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 接口的有效访问修饰符
- en: 'You can declare a *top-level interface* (the one that isn’t declared within
    any other class or interface), with only the following access levels:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以声明一个 *顶级接口*（不在任何其他类或接口中声明的接口），仅以下访问级别：
- en: '`public`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`'
- en: No modifier (default access)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无修饰符（默认访问）
- en: 'If you try to declare your top-level interfaces by using the other access modifiers
    (`protected` or `private`), your interface will fail to compile. The following
    definitions of the interface `MyInterface` won’t compile:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用其他访问修饰符（`protected` 或 `private`）声明顶级接口，你的接口将无法编译。以下 `MyInterface` 接口的定义将无法编译：
- en: '![](400fig01_alt.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](400fig01_alt.jpg)'
- en: '|  |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: 'All the top-level Java types (classes, enums, and interfaces) can be declared
    using only two access levels: `public` and default. Inner or nested types can
    be declared using any access level.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的顶级 Java 类型（类、枚举和接口）只能使用两种访问级别声明：`public` 和默认。内部或嵌套类型可以使用任何访问级别声明。
- en: '|  |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Valid access modifiers for members of an interface
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 接口成员的有效访问修饰符
- en: 'All members of an interface—variables, methods, inner interfaces, and inner
    classes (yes, an interface can define a class within it!)—are inherently public
    because that’s the only modifier they can accept. Using other access modifiers
    results in compilation errors:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的所有成员——变量、方法、内部接口和内部类（是的，一个接口可以在其中定义一个类！）——都是隐式公共的，因为这是它们唯一可以接受的修饰符。使用其他访问修饰符会导致编译错误：
- en: '![](400fig02_alt.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](400fig02_alt.jpg)'
- en: 'The code at ![](num-1.jpg) fails compilation with the following error message:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在 ![](num-1.jpg) 处编译失败，错误信息如下：
- en: '[PRE4]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Valid nonaccess modifiers for an interface
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 接口的有效非访问修饰符
- en: 'You can declare a top-level interface with only the following nonaccess modifiers:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能使用以下非访问修饰符声明顶级接口：
- en: '`abstract`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abstract`'
- en: '`strictfp`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strictfp`'
- en: '|  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `strictfp` keyword guarantees that results of all floating-point calculations
    are identical on all platforms.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`strictfp`关键字确保所有平台上的所有浮点计算结果都是相同的。'
- en: '|  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'If you try to declare your top-level interfaces by using the other nonaccess
    modifiers (`final`, `static`, `transient`, `synchronized`, or `volatile`), the
    interface will fail to compile. All the following interface declarations fail
    to compile because they use invalid nonaccess modifiers:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用其他非访问修饰符（`final`、`static`、`transient`、`synchronized`或`volatile`）来声明顶级接口，该接口将无法编译。以下所有接口声明都无法编译，因为它们使用了无效的非访问修饰符：
- en: '![](401fig01_alt.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](401fig01_alt.jpg)'
- en: 6.2.3\. Types of methods in an interface
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.3\. 接口中的方法类型
- en: 'Oracle has made fundamental changes to interfaces in Java 8\. Apart from `abstract`
    methods, an interface can define methods with default implementations. It can
    also define `static` methods. Here’s a quick list of the types of methods that
    can be defined in an interface (in Java 8):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 对Java 8中的接口进行了根本性的改变。除了`abstract`方法外，接口还可以定义具有默认实现的方法。它还可以定义`static`方法。以下是一个快速列表，列出了可以在接口中定义的方法类型（在Java
    8中）：
- en: '`abstract` methods'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abstract` 方法'
- en: Default methods (new in Java 8)
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认方法（Java 8 新增）
- en: '`static` methods (new in Java 8)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static` 方法（Java 8 新增）'
- en: Let’s examine each of these in detail.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一详细考察这些内容。
- en: '|  |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The default methods are also referred to as *defender* or *virtual extension
    methods*. But the most popular term to refer them is *default methods* because
    the `default` keyword is used to identify them.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 默认方法也被称为**防御者**或**虚拟扩展方法**。但最常用的术语来指代它们是**默认方法**，因为使用了`default`关键字来识别它们。
- en: '|  |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: abstract methods
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 抽象方法
- en: Most jobs require a candidate to be interviewed, and the interviewer can be
    a CEO, a technical leader, or a programmer. Although each of these categories
    supports the behavior of an *interviewer*, it will *`conductInterview`* in its
    own specific manner.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数工作都需要候选人接受面试，面试官可以是CEO、技术领导或程序员。尽管这些类别中的每一个都支持**面试官**的行为，但它们将以自己的特定方式**`conductInterview`**。
- en: An `abstract` method is used to *specify* a behavior (set of methods), which
    must be defined by the class that implements it. It’s another way of stating “a
    class *supports* a behavior, but in its own manner” in the way it likes. In the
    following example, the interface `Interviewer` defines an `abstract` method `conductInterview`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`abstract`方法用于**指定**一种行为（方法集），它必须由实现它的类定义。这是另一种表达“一个类**支持**一种行为，但以它喜欢的方式”的方式。在以下示例中，接口`Interviewer`定义了一个`abstract`方法`conductInterview`。
- en: 'An `abstract` method is defined without a method body:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`abstract`方法没有方法体：
- en: '![](401fig02_alt.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](401fig02_alt.jpg)'
- en: 'You might include the keyword `abstract` to define an `abstract` method in
    an interface. The following definition of the method `conductInterview` is the
    same as its definition in the preceding code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在接口中包含关键字`abstract`来定义一个`abstract`方法。以下对方法`conductInterview`的定义与前面代码中的定义相同：
- en: '![](402fig01_alt.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](402fig01_alt.jpg)'
- en: '|  |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Interface methods are implicitly `abstract`. To define *default* or *static*
    methods, you must explicitly use the keyword `default` or `static` with the method
    declaration in an interface. Default and `static` methods include their implementation
    in an interface.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接口方法隐式地是`abstract`的。要定义**默认**或**静态**方法，你必须显式地在接口中用`default`或`static`关键字声明方法。默认和`static`方法在接口中包含它们的实现。
- en: '|  |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: When a class implements an interface with `abstract` methods, the class must
    implement all the methods, or else the class won’t compile. A developer can’t
    add `abstract` methods to an interface without breaking existing implementations.
    It can only be done with default methods.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类实现包含`abstract`方法的一个接口时，该类必须实现所有方法，否则类无法编译。开发者不能在不破坏现有实现的情况下向接口添加`abstract`方法。这只能通过默认方法来实现。
- en: Default methods
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 默认方法
- en: 'Imagine you need to add a behavior—*submit interview status*—to the interface
    `Interviewer`, *after* its publication. This wouldn’t have been possible with
    Java 7 and its earlier versions without implying the need to provide an implementation
    for each existing concrete class (either directly or through a superclass). *Default
    methods* can rescue you here. Starting with Java 8, interfaces can be augmented
    by adding methods with default implementation. Implementing classes might choose
    to override these methods to define their own specific behavior. If they don’t
    choose to override them, the default implementation from the interface is used.
    The definition of a default method *must* include the keyword `default`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你需要在接口`Interviewer`发布后添加一个行为——*提交面试状态*。在没有Java 7及其早期版本的情况下，这不可能实现，除非需要为每个现有的具体类提供实现（直接或通过超类）。*默认方法*可以在这里救你。从Java
    8开始，接口可以通过添加具有默认实现的方法来扩展。实现类可以选择覆盖这些方法以定义它们自己的特定行为。如果它们选择不覆盖它们，则使用接口中的默认实现。默认方法的定义*必须*包含关键字`default`：
- en: '![](402fig02_alt.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](402fig02_alt.jpg)'
- en: I deliberately oversimplified `submitInterviewStatus()` in the preceding code
    so that the code focuses on the definition of default methods and not on its implementation
    details.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意在前面的代码中简化了`submitInterviewStatus()`，以便代码专注于默认方法的定义，而不是其实现细节。
- en: '|  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: New in Java 8
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Java 8新增功能
- en: Interface methods can define an implementation by using *default* methods.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接口方法可以使用*default*方法定义一个实现。
- en: '|  |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Because the return type of the preceding method, `submitInterviewStatus`, is
    `void`, the following definition of method `submitInterviewStatus` is valid:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 因为前一个方法`submitInterviewStatus`的返回类型是`void`，所以以下对方法`submitInterviewStatus`的定义是有效的：
- en: '![](402fig03_alt.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](402fig03_alt.jpg)'
- en: 'Even though the method in the preceding example doesn’t define any code in
    its body, it isn’t equivalent to an `abstract` method. Declaration of a default
    method must be followed by the method body marked using `{}`. The following code
    won’t compile:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前一个示例中的方法在其主体中未定义任何代码，但它并不等同于一个`abstract`方法。默认方法的声明必须后跟使用`{}`标记的方法体。以下代码无法编译：
- en: '![](403fig01_alt.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](403fig01_alt.jpg)'
- en: 'Just like regular methods, the return type of a default method must match the
    type of the value that it returns. The following won’t compile:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 正如常规方法一样，默认方法的返回类型必须与它返回的值的类型匹配。以下代码无法编译：
- en: '![](403fig02_alt.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](403fig02_alt.jpg)'
- en: static methods
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 静态方法
- en: Revisit the interface `Interviewer` used in the preceding section. Imagine that
    you need a utility (`static`) method that can be used to book a conference hall
    for an interview on a particular date and time. With Java 8, you can add `static`
    methods to an interface. Prior to Java 8, interfaces weren’t allowed to define
    `static` methods. In such a case, you’d need to define the required `static` method
    in a separate class. This is one of the main reasons why `static` methods have
    been allowed in the interfaces—to improve the aging Collections API, which includes
    a few classes just to define `static` methods (like `Collections` and `Paths`).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾前一个章节中使用的`Interviewer`接口。想象一下，你需要一个实用（静态）方法，可以在特定日期和时间预订面试的会议室。在Java 8中，你可以向接口添加`static`方法。在Java
    8之前，接口不允许定义`static`方法。在这种情况下，你需要在一个单独的类中定义所需的`static`方法。这是允许在接口中使用`static`方法的主要原因之一——为了改进过时的Collections
    API，该API包括一些仅用于定义`static`方法的类（如`Collections`和`Paths`）。
- en: '|  |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`static` interface methods enable you to define utility methods in the interfaces
    that they belong to.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`接口方法允许你在它们所属的接口中定义实用方法。'
- en: '|  |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Let’s add a `static` method `bookConferenceRoom` to the interface `Interviewer`
    (in bold):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接口`Interviewer`（加粗）中添加一个`static`方法`bookConferenceRoom`：
- en: '[PRE5]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The method `bookConferenceRoom()` must be called by prefixing its call with
    the interface name. You can’t call it using a reference variable of the type `Interviewer`
    or of the class that implements this interface. Let’s define the class `Manager`
    that implements `Interviewer` and the class `Project` that tries to call the method
    `bookConferenceRoom`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`bookConferenceRoom()`必须通过在调用前加上接口名称来调用。你不能使用类型为`Interviewer`或实现此接口的类的引用变量来调用它。让我们定义实现`Interviewer`接口的类`Manager`和尝试调用`bookConferenceRoom`方法的类`Project`：
- en: '![](404fig01_alt.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![404fig01_alt.jpg](404fig01_alt.jpg)'
- en: It’s interesting to note that for `mgr.bookConferenceRoom()`, the compiler states
    that the method `bookConferenceRoom` is not defined for the type `Manager`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，对于`mgr.bookConferenceRoom()`，编译器指出`bookConferenceRoom`方法在`Manager`类型中未定义。
- en: '|  |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: A `static` method in an interface can’t be called using a reference variable.
    It *must* be called using the interface name.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接口中的`static`方法不能使用引用变量调用。它*必须*使用接口名称来调用。
- en: '|  |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In contrast to the preceding code, you can call a `static` method defined in
    a class either by using reference variables or by the name of the class:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的代码相比，你可以通过使用引用变量或类名来调用在类中定义的`static`方法：
- en: '![](404fig02_alt.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![404fig02_alt.jpg](404fig02_alt.jpg)'
- en: 'In the preceding example, the `static` method `defaultPlan` is defined in the
    class `Employee`, which is subclassed by the class `Programmer`. The class `Project`
    defines reference variables of the type `Employee` and `Programmer` and initializes
    them using `Programmer` instances. To execute `defaultPlan()`, you can use the
    reference variables `emp` and `pgr` of types `Employee` and `Programmer`, respectively.
    You can also call `default-Plan()` by using the class name: `Employee` or `Programmer`.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`static`方法`defaultPlan`是在`Employee`类中定义的，该类是`Programmer`类的子类。`Project`类定义了类型为`Employee`和`Programmer`的引用变量，并使用`Programmer`实例初始化它们。要执行`defaultPlan()`，你可以使用类型为`Employee`和`Programmer`的引用变量`emp`和`pgr`，或者使用类名：`Employee`或`Programmer`。
- en: '|  |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Unlike an interface, if you define a `static` method in a base class, it can
    be accessed using either a reference variable or the class name.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 与接口不同，如果你在基类中定义一个`static`方法，它可以通过引用变量或类名来访问。
- en: '|  |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.2.4\. Implementing a single interface
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.4\. 实现单个接口
- en: When a class implements an interface, it must follow a set of rules.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类实现一个接口时，它必须遵循一系列规则。
- en: Implement abstract methods
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现抽象方法
- en: 'If a concrete class doesn’t implement the `abstract` methods of the interface
    it implements, it won’t compile:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个具体类没有实现它所实现的接口中的`abstract`方法，则无法编译：
- en: '![](405fig01_alt.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![405fig01_alt.jpg](405fig01_alt.jpg)'
- en: Do you think the following code will compile?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为以下代码会编译吗？
- en: '![](405fig02_alt.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![405fig02_alt.jpg](405fig02_alt.jpg)'
- en: '|  |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: You must implement an `abstract` method of an interface using the explicit access
    modifier `public`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须使用显式的访问修饰符`public`来实现接口的`abstract`方法。
- en: '|  |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'When you implement an interface method in a class, it follows method-overriding
    rules:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在类中实现接口方法时，它遵循方法重写规则：
- en: '![](405fig03_alt.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![405fig03_alt.jpg](405fig03_alt.jpg)'
- en: 'But the following won’t compile:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 但以下代码无法编译：
- en: '![](405fig04_alt.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![405fig04_alt.jpg](405fig04_alt.jpg)'
- en: Overriding default methods
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 重写默认方法
- en: 'A class might choose to override the implementation of a default method in
    an interface that it implements. If it doesn’t, the default implementation of
    the interface method will be used. In the following example, the class `Manager`
    implements the interface `Interviewer` but doesn’t override the default method
    `submitInterview-Status()`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可能会选择重写它所实现的接口中的默认方法。如果不这样做，将使用接口方法的默认实现。在以下示例中，`Manager`类实现了`Interviewer`接口，但没有重写默认方法`submitInterview-Status()`：
- en: '![](406fig01_alt.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![406fig01_alt.jpg](406fig01_alt.jpg)'
- en: 'Let’s override the default implementation of the method `submitInterviewStatus()`
    in the class `Manager`. When a class overrides a default method, it doesn’t use
    the keyword `default`. Also, it follows method-overriding rules:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Manager`类中重写`submitInterviewStatus()`方法的默认实现。当一个类重写默认方法时，它不使用`default`关键字。同时，它遵循方法重写规则：
- en: '![](406fig02_alt.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![406fig02_alt.jpg](406fig02_alt.jpg)'
- en: '|  |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: While overriding a default method, you must not use the keyword `default`. Rules
    for overriding default and regular methods are the same.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写默认方法时，你不可以使用`default`关键字。重写默认方法和常规方法的规则相同。
- en: '|  |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: static methods
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 静态方法
- en: 'If an interface defines a `static` method, the class that implements it can
    define a `static` method with the same name, but the method in the interface isn’t
    related to the method defined in the class. In the following example, the method
    `bookConference-Room` in the class `Manager` doesn’t overload or override the
    method `bookConference-Room` defined in the interface `Interviewer`. This is evident
    from the return types of these methods (highlighted in bold):'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个接口定义了一个`static`方法，实现它的类可以定义一个具有相同名称的`static`方法，但接口中的方法与类中定义的方法无关。在以下示例中，`Manager`类中的`bookConference-Room`方法没有重载或覆盖在`Interviewer`接口中定义的`bookConference-Room`方法。这从这些方法的返回类型（加粗显示）中可以看出：
- en: '![](406fig03_alt.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![406fig03_alt.jpg](406fig03_alt.jpg)'
- en: '|  |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: '`static` methods in a class and the interface that it implements are not related
    to each other. A `static` method in a class doesn’t hide or override the `static`
    method in the interface that it implements.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的`static`方法和它实现的接口之间没有关系。类中的`static`方法不会隐藏或覆盖它实现的接口中的`static`方法。
- en: '|  |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Why do you think Java doesn’t allow a class to inherit multiple classes but
    allows a class to implement multiple interfaces? I’ll cover that in detail in
    the next sections.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为为什么Java不允许一个类继承多个类，却允许一个类实现多个接口？我将在下一节详细说明。
- en: 6.2.5\. A class can’t extend multiple classes
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.5\. 一个类不能扩展多个类
- en: 'In Java, a class can’t extend multiple classes. Let’s examine the reason using
    an example, in which the class `Programmer` *is* allowed to inherit two classes:
    `Employee` and `Philanthropist`. [Figure 6.12](#ch06fig12) shows the relationship
    between these classes and the corresponding code.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，一个类不能扩展多个类。让我们通过一个例子来检查原因，其中类`Programmer`*可以*继承两个类：`Employee`和`Philanthropist`。[图6.12](#ch06fig12)显示了这些类之间的关系以及相应的代码。
- en: Figure 6.12\. What happens if a class is allowed to extend multiple classes?
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.12\. 如果允许一个类扩展多个类会发生什么？
- en: '![](06fig12_alt.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![06fig12_alt.jpg](06fig12_alt.jpg)'
- en: 'If the class `Programmer` inherited the method `receiveSalary`, defined in
    both `Employee` and `Philanthropist`, what do you think a `Programmer` would do
    with their salary: pay dues (like an `Employee`) or donate it (like a `Philanthropist`)?
    What do you think would be the output of the following code?'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Programmer`类继承了`Employee`和`Philanthropist`中定义的`receiveSalary`方法，你认为`Programmer`会如何处理他们的薪水：缴纳会费（像`Employee`一样）还是捐赠（像`Philanthropist`一样）？你认为以下代码的输出会是什么？
- en: '![](407fig01_alt.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![407fig01_alt.jpg](407fig01_alt.jpg)'
- en: In this case, the class `Programmer` can access two `receiveSalary` methods
    with identical method signatures but different implementations, so it’s impossible
    to resolve this method call. This is why classes aren’t allowed to inherit multiple
    classes in Java.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Programmer`类可以访问两个具有相同方法签名但不同实现的`receiveSalary`方法，因此无法解析这个方法调用。这就是为什么Java不允许类继承多个类的原因。
- en: '|  |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Because a derived class may inherit different implementations for the same method
    signature from multiple base *classes*, multiple inheritance isn’t allowed in
    Java.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 因为派生类可能从多个基类继承相同方法签名的不同实现，Java不允许多重继承。
- en: '|  |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 6.2.6\. A class can implement multiple interfaces
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.6\. 一个类可以实现多个接口
- en: In the preceding section, we discussed that a class can’t inherit multiple classes.
    But a class can implement multiple interfaces. Why is this allowed, when Java
    doesn’t allow a class to extend multiple classes? Prior to Java 8, an interface
    could define only `abstract` methods. So even if a class inherited methods with
    the same name from different interfaces, it came without an implementation.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了类不能继承多个类。但一个类可以实现多个接口。为什么Java不允许一个类继承多个类，却允许一个类实现多个接口呢？在Java 8之前，接口只能定义`抽象`方法。所以即使一个类从不同的接口继承同名方法，它也没有实现。
- en: But with Java 8, an interface can also define default methods—methods that include
    an implementation. So when a class implements multiple interfaces, it must adhere
    to a set of rules.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 但在Java 8中，接口也可以定义默认方法——包含实现的方法。因此，当一个类实现多个接口时，它必须遵守一组规则。
- en: '|  |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: A class can extend multiple interfaces only if a set of rules is adhered to.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当遵守一组规则时，一个类才能扩展多个接口。
- en: '|  |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Implementing multiple interfaces with the same constant names
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现具有相同常量名称的多个接口
- en: 'A class can implement multiple interfaces with the same constant name, as long
    as a call to these interfaces isn’t ambiguous. In the following example, the class
    `Animal` compiles successfully. It doesn’t use the constant `MIN_DISTANCE` defined
    in the interfaces `Moveable` and `Jumpable` that it implements:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以实现具有相同常量名称的多个接口，只要对这些接口的调用不是模糊的。在以下示例中，类`Animal`可以成功编译。它没有使用它实现的接口`Moveable`和`Jumpable`中定义的常量`MIN_DISTANCE`：
- en: '![](408fig01_alt.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图片](408fig01_alt.jpg)'
- en: 'If you modify the implementation details of the class `Animal` so that it refers
    to the variable `MIN_DISTANCE` without prefixing it with the interface name, then
    it won’t compile:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你修改了类`Animal`的实现细节，使其引用变量`MIN_DISTANCE`而不在前面加上接口名称，那么它将无法编译：
- en: '![](408fig02_alt.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图片](408fig02_alt.jpg)'
- en: 'When prefixed with the interface name, the reference to `MIN_DISTANCE` is no
    longer ambiguous:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当用接口名称作为前缀时，对`MIN_DISTANCE`的引用就不再模糊了：
- en: '![](409fig01_alt.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图片](409fig01_alt.jpg)'
- en: 'If an implicit reference to a constant defined in an interface(s) isn’t ambiguous,
    the class that implements the interface can refer to it without prefixing it with
    the interface name:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对接口（s）中定义的常量的隐式引用不是模糊的，实现接口的类可以引用它，而不需要在前面加上接口名称：
- en: '![](409fig02_alt.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图片](409fig02_alt.jpg)'
- en: '|  |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: A class can implement multiple interfaces with the same constant names, *only
    if* a reference to the constants isn’t ambiguous.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以实现具有相同常量名称的多个接口，*仅当*对常量的引用不是模糊的时候。
- en: '|  |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Implementing multiple interfaces with the same abstract method names
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现具有相同抽象方法名称的多个接口
- en: 'An `abstract` method doesn’t define a body. It’s acceptable for a class to
    extend multiple interfaces that define `abstract` methods with the same signature
    because when a class implements the `abstract` method, it seems to implement the
    `abstract` method from all the interfaces:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`abstract`方法不定义一个主体。一个类可以扩展多个定义具有相同签名的`abstract`方法的接口是可接受的，因为当一个类实现`abstract`方法时，它似乎实现了所有接口的`abstract`方法：
- en: '[PRE6]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But you can’t make a class extend multiple interfaces that define methods with
    the same name that don’t seem to be a correct combination of overloaded methods.
    If you change the return type of the method `currentPosition()` from `String`
    to `void` in the interface `Moveable`, the class `Animal` won’t compile. It would
    need to implement methods `currentPosition`, which differ only in their return
    type, which isn’t acceptable:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你不能使一个类扩展多个定义具有相同名称的方法的接口，这些方法似乎不是正确的重载方法组合。如果你将接口`Moveable`中`currentPosition()`方法的返回类型从`String`更改为`void`，类`Animal`将无法编译。它需要实现返回类型不同的`currentPosition`方法，这是不可接受的：
- en: '![](410fig01_alt.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图片](410fig01_alt.jpg)'
- en: '|  |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: A class can implement multiple interfaces with the same `abstract` method names
    if they have the same signature or form an overloaded set of methods.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果具有相同的签名或形成一组重载方法，一个类可以实现具有相同`abstract`方法名称的多个接口。
- en: '|  |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Implementing multiple interfaces with the same default method names
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现具有相同默认方法名称的多个接口
- en: 'Imagine a class, `Animal`, that extends multiple interfaces, `Moveable` and
    `Jumpable`, which define default methods with the same name, `relax()`. If the
    class `Animal` doesn’t override the default implementation of `relax()`, it won’t
    compile:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个名为`Animal`的类，它扩展了多个接口`Moveable`和`Jumpable`，这些接口定义了具有相同名称`relax()`的默认方法。如果类`Animal`没有覆盖`relax()`的默认实现，它将无法编译：
- en: '![](410fig02_alt.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图片](410fig02_alt.jpg)'
- en: 'Let’s modify the preceding code, so that the class `Animal` overrides the default
    implementation of `relax()`. In this case, it will compile successfully:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改前面的代码，以便类`Animal`覆盖`relax()`的默认实现。在这种情况下，它将成功编译：
- en: '![](410fig03_alt.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图片](410fig03_alt.jpg)'
- en: 'The default methods that a class inherits from the interfaces that it implements
    must form a correct set of overloaded methods, or else the class won’t compile:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类从它实现的接口继承的默认方法必须形成一个正确的重载方法集，否则该类将无法编译：
- en: '![](411fig01_alt.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图片](411fig01_alt.jpg)'
- en: '|  |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: A class can implement multiple interfaces with the same default method name
    and signature, if it overrides its default implementation.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类覆盖了它的默认实现，它可以实现具有相同默认方法名称和签名的多个接口。
- en: '|  |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Implementing multiple interfaces with the same static method names
  id: totrans-373
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实现具有相同静态方法名称的多个接口
- en: 'A class can implement multiple interfaces that define `static` methods with
    the same name, even if they don’t qualify as correctly overloaded or overridden
    methods. This is because they’re not inherited by the class that implements the
    interfaces:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以实现定义了具有相同名称的 `static` 方法的多个接口，即使它们不符合正确重载或覆盖方法的条件。这是因为它们不会被实现接口的类继承：
- en: '![](411fig02_alt.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![](411fig02_alt.jpg)'
- en: '|  |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: A class can implement multiple interfaces with the same `static` method names,
    irrelevant of their return types or signature.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以实现具有相同 `static` 方法名称的多个接口，无论它们的返回类型或签名如何。
- en: '|  |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.2.7\. Extending interfaces
  id: totrans-380
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.7\. 扩展接口
- en: An interface can extend multiple interfaces. When an interface extends another
    interface, it must follow a set of rules.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接口可以扩展多个接口。当一个接口扩展另一个接口时，它必须遵循一组规则。
- en: Extending multiple interfaces with the same abstract method names
  id: totrans-382
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 扩展具有相同抽象方法名称的多个接口
- en: An `abstract` method doesn’t define a body. Consider the following code, whose
    UML representation is shown in [figure 6.13](kindle_split_020.html#ch06fig13).
    Which of the `getName` methods will be inherited by the interface `MyInterface`?
    Will `MyInterface` inherit the `getName` method defined in `BaseInterface1` or
    the one defined in `BaseInterface2`?
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `abstract` 方法没有定义方法体。考虑以下代码，其 UML 表示形式如图 6.13 所示。接口 `MyInterface` 将继承哪个 `getName`
    方法？`MyInterface` 将继承 `BaseInterface1` 中定义的 `getName` 方法还是 `BaseInterface2` 中定义的？
- en: Figure 6.13\. The interface `MyInterface` extends the interfaces `BaseInterface1`
    and `BaseInterface2`.
  id: totrans-384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.13\. 接口 `MyInterface` 扩展了接口 `BaseInterface1` 和 `BaseInterface2`。
- en: '![](06fig13.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig13.jpg)'
- en: '[PRE7]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because neither of the `getName` methods defined in `BaseInterface1` and `Base-Interface2`
    define a method body (as shown in [figure 6.14](#ch06fig14)), the question of
    which of the methods `MyInterface` inherits is irrelevant. The interface `MyInterface`
    has access to a single `getName` method, which must be implemented by all the
    concrete classes that implement `MyInterface`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `BaseInterface1` 和 `Base-Interface2` 中定义的 `getName` 方法都没有定义方法体（如图 6.14 所示），所以
    `MyInterface` 继承哪个方法的问题是不相关的。接口 `MyInterface` 只能访问一个 `getName` 方法，所有实现 `MyInterface`
    的具体类都必须实现此方法。
- en: Figure 6.14\. Methods defined in an interface don’t have a method body.
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.14\. 接口中定义的方法没有方法体。
- en: '![](06fig14_alt.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig14_alt.jpg)'
- en: 'Let’s make the `Employee` class implement the interface `MyInterface`, as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使 `Employee` 类实现接口 `MyInterface`，如下所示：
- en: '![](412fig01_alt.jpg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](412fig01_alt.jpg)'
- en: Extending multiple interfaces with the same name default method names
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 扩展具有相同名称默认方法名称的多个接口
- en: 'When an interface extends multiple interfaces, Java ensures that it shouldn’t
    inherit multiple method implementations for the same method. In the following
    example, interface `MyInterface` won’t compile because it inherits unrelated defaults
    for `getName()` from types `BaseInterface1` and `BaseInterface2`:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个接口扩展多个接口时，Java 确保它不应该为同一个方法继承多个方法实现。在下面的示例中，接口 `MyInterface` 无法编译，因为它从 `BaseInterface1`
    和 `BaseInterface2` 类型中继承了与 `getName()` 无关的默认值：
- en: '![](413fig01_alt.jpg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](413fig01_alt.jpg)'
- en: 'If you override the default implementation of the method `getName()` in `MyInterface`,
    it will compile successfully:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你覆盖了 `MyInterface` 中 `getName()` 方法的默认实现，它将能够成功编译：
- en: '![](413fig02_alt.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![](413fig02_alt.jpg)'
- en: 'In the preceding code, the `getName` method in `MyInterface` can refer to a
    superinterface method by using the `super` keyword:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`MyInterface` 中的 `getName` 方法可以通过使用 `super` 关键字来引用超接口方法：
- en: '`BaseInterface1.super.getName();`'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseInterface1.super.getName();`'
- en: '`BaseInterface2.super.getName();` (This would work as well if `MyInterface`
    were a class implementing both interfaces.) Other methods too can invoke a superinterface
    method this way.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseInterface2.super.getName();`（如果 `MyInterface` 是同时实现这两个接口的类，这也会起作用。）其他方法也可以用这种方式调用超接口方法。'
- en: 'Here are three resolution rules in case of multiple inheritance:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在多重继承的情况下，这里有三个解决规则：
- en: 'Classes always win: a method implemented in a class always has priority over
    an interface default method.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类总是优先：一个在类中实现的方法总是比接口默认方法有优先级。
- en: 'Otherwise, subinterfaces always win: a method implemented in a more specific
    interface has precedence over one defined in a more general interface (for example,
    a superinterface).'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，子接口总是优先：在更具体的接口中实现的方法比在更通用的接口（例如，超接口）中定义的方法有优先级。
- en: 'Otherwise, if there’s an ambiguity that can’t be resolved by the previous rules,
    then you get to the case presented earlier: the targeted superinterface must be
    specified, using the `super` keyword.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果存在无法通过先前规则解决的歧义，那么你将遇到之前提到的案例：必须使用`super`关键字指定目标超接口。
- en: '|  |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-405
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: When an interface extends multiple interfaces, Java ensures that it shouldn’t
    inherit multiple method implementations for the same method.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个接口扩展多个接口时，Java确保它不应该为同一方法继承多个方法实现。
- en: '|  |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Extending multiple interfaces with the same static method names
  id: totrans-408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用相同静态方法名称扩展多个接口
- en: 'An interface can extend multiple interfaces with the same static method name:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以扩展具有相同静态方法名称的多个接口：
- en: '![](414fig01_alt.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![图片](414fig01_alt.jpg)'
- en: 'The following code also compiles successfully, even though the return types
    of the methods `status()` in `BaseInterface1` and `BaseInterface2` are unrelated:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码也可以成功编译，尽管`BaseInterface1`和`BaseInterface2`中`status()`方法的返回类型不相关：
- en: '![](414fig02_alt.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![图片](414fig02_alt.jpg)'
- en: '|  |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: An interface can extend multiple interfaces, which define `static` methods with
    the same name; the signatures of these methods don’t matter. This is because `static`
    methods are never inherited, so no conflicts can occur.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以扩展多个接口，这些接口定义了具有相同名称的`static`方法；这些方法的签名并不重要。这是因为`static`方法永远不会被继承，因此不会发生冲突。
- en: '|  |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 6.2.8\. Modifying existing methods of an interface
  id: totrans-417
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.8\. 修改接口的现有方法
- en: What happens if you modify the declaration of the methods in an interface? Because
    you can define multiple types of methods in an interface—`abstract`, default,
    and `static`—these modifications would have different implications.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你修改接口中方法的声明会发生什么？因为你可以在一个接口中定义多种类型的方法——`abstract`、默认和`static`——这些修改将具有不同的影响。
- en: The modifications to existing methods of an interface can break the code of
    the classes that implement it or the interfaces that extend it. The modifications
    must follow the rules of implementing or extending interfaces, as covered in detail
    in the previous sections.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 修改接口的现有方法可能会破坏实现它的类或扩展它的接口的代码。这些修改必须遵循实现或扩展接口的规则，如前几节详细所述。
- en: In this section, you’ll see what happens when you modify an interface by changing
    the type of its method (`abstract`, default, or `static`). This change can affect
    the classes that implement the interface or the code that calls the modified methods.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将看到当你通过更改接口中方法的类型（`abstract`、默认或`static`）来修改接口时会发生什么。这种更改可能会影响实现接口的类或调用修改后方法的代码。
- en: Changing static method to default or abstract
  id: totrans-421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将静态方法更改为默认或抽象
- en: In an interface, if you change a `static` method to a default method, the implementing
    class will continue to compile, but the code that calls the method won’t compile.
    It you change a `static` method to an `abstract` method, the implementing class
    might not compile. The code, changes, and results are shown in [figure 6.15](#ch06fig15).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口中，如果你将`static`方法更改为默认方法，实现类将继续编译，但调用该方法的代码将无法编译。如果你将`static`方法更改为`abstract`方法，实现类可能无法编译。代码、更改和结果如图[6.15](#ch06fig15)所示。
- en: Figure 6.15\. What happens when you change a `static` method in an interface
    to a default or `abstract` method
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.15\. 当你将接口中的`static`方法更改为默认或`abstract`方法时会发生什么
- en: '![](06fig15_alt.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig15_alt.jpg)'
- en: Changing an abstract method to default or static
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将抽象方法更改为默认或静态
- en: If you modify an interface by changing its `abstract` method to a default method,
    the code that calls the method will continue to compile. But if you change an
    `abstract` method into a `static` method, the code that calls the method won’t
    compile. This is because `static` methods of an interface are called by prefixing
    the method name with the interface name. The code, modifications, and its results
    are shown in [figure 6.16](#ch06fig16).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过将接口的`abstract`方法更改为默认方法来修改接口，调用该方法的代码将继续编译。但如果你将`abstract`方法更改为`static`方法，调用该方法的代码将无法编译。这是因为接口的`static`方法是通过在方法名称前加上接口名称来调用的。代码、修改及其结果如图[6.16](#ch06fig16)所示。
- en: Figure 6.16\. What happens when you change an `abstract` method in an interface
    to a default or `static` method
  id: totrans-427
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.16\. 当你将接口中的`abstract`方法更改为默认或`static`方法时会发生什么
- en: '![](06fig16_alt.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig16_alt.jpg)'
- en: Changing a default method to abstract or static
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将默认方法更改为抽象或静态
- en: If you modify an interface and change its default method to an `abstract` method,
    a class that implements it *might* fail to compile. The implementing class will
    fail to compile, if it doesn’t override the default method of the interface. If
    you modify the default method to a `static` method in an interface, the code that
    calls the method won’t compile. The code, changes, and results are shown in [figure
    6.17](#ch06fig17).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你修改了一个接口并将其默认方法更改为`abstract`方法，实现它的类可能会编译失败。如果实现类没有覆盖接口的默认方法，它将无法编译。如果你将接口的默认方法更改为`static`方法，调用该方法的代码将无法编译。代码、更改和结果在[图
    6.17](#ch06fig17)中显示。
- en: Figure 6.17\. What happens when you change a default method in an interface
    to an `abstract` or `static` method
  id: totrans-431
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.17\. 当你将接口中的默认方法更改为`abstract`或`static`方法时会发生什么
- en: '![](06fig17_alt.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig17_alt.jpg)'
- en: 6.2.9\. Properties of members of an interface
  id: totrans-433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.9\. 接口成员的属性
- en: An interface can define constants and methods, which are implicitly assigned
    a set of properties.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以定义常量和方法，这些方法隐式地分配了一组属性。
- en: Interface constants
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 接口常量
- en: As you’ve already seen, the variables of an interface are implicitly `public`,
    `final`, and `static`. So the following definition of the interface `MyInterface`
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经看到的，接口的变量隐式地是`public`、`final`和`static`。所以以下接口`MyInterface`的定义
- en: '[PRE8]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'is equivalent to the following definition:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于以下定义：
- en: '![](417fig01_alt.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![](417fig01_alt.jpg)'
- en: 'You must initialize all variables in an interface, or your code won’t compile:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在接口中初始化所有变量，否则你的代码将无法编译：
- en: '![](417fig02_alt.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![](417fig02_alt.jpg)'
- en: Interface methods
  id: totrans-442
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 接口方法
- en: 'The methods of an interface are implicitly `public`. When you implement an
    interface, you must implement all its methods by using the access modifier `public`.
    A class that implements an interface can’t make the interface’s methods more restrictive.
    Although the following class and interface definitions look acceptable, they’re
    not:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的方法隐式地是`public`的。当你实现一个接口时，你必须使用`public`访问修饰符来实现所有它的方法。实现接口的类不能使接口的方法更加限制性。尽管以下类和接口的定义看起来是可以接受的，但它们并不正确：
- en: '![](417fig03_alt.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![](417fig03_alt.jpg)'
- en: 'The following code is correct and compiles happily:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是正确的，并且可以顺利编译：
- en: '![](417fig04.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![](417fig04.jpg)'
- en: Interface constructors
  id: totrans-447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 接口构造函数
- en: Unlike a class, an interface can’t define constructors.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 与类不同，接口不能定义构造函数。
- en: You can use a reference variable of a base class to refer to an object of its
    derived class. Similarly, you can use a reference variable of an interface to
    refer to an object of a class that implements it. It’s interesting to note that
    these variables can’t access all the variables and methods defined in the derived
    class or the class that implements the interface.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用基类的引用变量来引用其派生类的对象。同样，你也可以使用实现它的类的引用变量来引用该类的对象。值得注意的是，这些变量不能访问在派生类或实现接口的类中定义的所有变量和方法。
- en: Let’s dig into some more details about this in the next section.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中深入探讨这个问题的更多细节。
- en: 6.3\. Reference variable and object types
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3\. 引用变量和对象类型
- en: '|  |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[7.2](kindle_split_021.html#ch07lev1sec2)] Develop code that demonstrates
    the use of polymorphism; including overriding and object type versus reference
    type'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '[[7.2](kindle_split_021.html#ch07lev1sec2)] 编写代码以演示多态的使用；包括重写和对象类型与引用类型'
- en: '|  |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: For this exam objective, you need to understand that when you refer to an object,
    the type of the *object reference variable* and the type of the *object* being
    referred to may be different. But there are rules on *how different* these can
    be. This concept may take a while to sink in, so don’t worry if you don’t get
    it on your first attempt.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个考试目标，你需要理解当你引用一个对象时，*对象引用变量*的类型和被引用的*对象*的类型可能不同。但有一些规则决定了它们可以有多大的不同。这个概念可能需要一段时间才能理解，所以如果你第一次没有理解，不要担心。
- en: 'In the same way in which you can refer to a person using their first name,
    last name, or both names, objects of derived classes can be referred to using
    a reference variable of any of the following types:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以用名字、姓氏或两者来指代人一样，派生类的对象可以使用以下任何类型的引用变量来引用：
- en: '***Its own type—*** An object of a class `HRExecutive` can be referred to using
    an object reference variable of type `HRExecutive`.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***其自身类型——*** 一个`HRExecutive`类的对象可以使用类型为`HRExecutive`的对象引用变量来引用。'
- en: '***Its superclass—*** If the class `HRExecutive` inherits the class `Employee`,
    an object of the class `HRExecutive` can be referred to using a variable of type
    `Employee`. If the class `Employee` inherits the class `Person`, an object of
    the class `HRExecutive` can also be referred to using a variable of type `Person`.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***其超类——*** 如果类 `HRExecutive` 继承了类 `Employee`，则可以使用类型为 `Employee` 的变量来引用 `HRExecutive`
    类的对象。如果类 `Employee` 继承了类 `Person`，则也可以使用类型为 `Person` 的变量来引用 `HRExecutive` 类的对象。'
- en: '*Implemented interfaces—*If the class `HRExecutive` implements the interface
    `Interviewer`, an object of the class `HRExecutive` can be referred to using a
    variable of type `Interviewer`.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现接口—* 如果类 `HRExecutive` 实现了接口 `Interviewer`，则可以使用类型为 `Interviewer` 的变量来引用
    `HRExecutive` 类的对象。'
- en: There are differences, however, when you try to access an object using a reference
    variable of its own type, its base class, or an implemented interface. Let’s start
    with accessing an object with a variable of its own type.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当您尝试使用其自身类型、基类或实现接口的引用变量来访问对象时，会有所不同。让我们从使用其自身类型的变量来访问对象开始。
- en: 6.3.1\. Using a variable of the derived class to access its own object
  id: totrans-461
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1\. 使用派生类变量访问其自身对象
- en: 'Let’s start with the code of the class `HRExecutive`, which inherits the class
    `Employee` and implements the interface `Interviewer`, as follows:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从继承自类 `Employee` 并实现接口 `Interviewer` 的类 `HRExecutive` 的代码开始，如下所示：
- en: '![](418fig01_alt.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![](418fig01_alt.jpg)'
- en: 'Here’s some code that demonstrates that an object of the class `HRExecutive`
    can be referred to using a variable of type `HRExecutive`:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 下面有一些代码演示了可以使用类型为 `HRExecutive` 的变量来引用 `HRExecutive` 类的对象：
- en: '![](419fig01_alt.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![](419fig01_alt.jpg)'
- en: 'You can access fields and methods defined in the class `Employee`, the class
    `HRExecutive`, and the interface `Interviewer` using the variable `hr` (with the
    type `HRExecutive`), as follows:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类型为 `HRExecutive` 的变量 `hr` 访问在类 `Employee`、类 `HRExecutive` 和接口 `Interviewer`
    中定义的字段和方法，如下所示：
- en: '![](419fig02_alt.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![](419fig02_alt.jpg)'
- en: When you access an object of the class `HRExecutive` using its own type, you
    can access all the variables and methods that are defined in its base class and
    interface—the class `Employee` and the interface `Interviewer`. Can you do the
    same if the type of the reference variable is changed to the class `Employee`,
    as defined in the next section?
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用其自身类型来访问 `HRExecutive` 类的对象时，您可以访问在其基类和接口中定义的所有变量和方法——即类 `Employee` 和接口
    `Interviewer`。如果将引用变量的类型更改为在下一节中定义的类 `Employee`，您能做同样的事情吗？
- en: 6.3.2\. Using a variable of a superclass to access an object of a derived class
  id: totrans-469
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2\. 使用超类变量访问派生类对象
- en: 'Let’s access an object of type `HRExecutive` using a reference variable of
    type `Employee`, as follows:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用类型为 `Employee` 的引用变量来访问类型为 `HRExecutive` 的对象，如下所示：
- en: '![](419fig03_alt.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![](419fig03_alt.jpg)'
- en: Now let’s see whether changing the type of the reference variable makes any
    difference when accessing the members of the class `Employee`, the class `HRExecutive`,
    or the interface `Interviewer`. Will the following code compile successfully?
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在访问类 `Employee`、类 `HRExecutive` 或接口 `Interviewer` 的成员时，更改引用变量的类型是否会有任何不同。下面的代码能否成功编译？
- en: '![](420fig01_alt.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![](420fig01_alt.jpg)'
- en: 'The code at ![](num-1.jpg) fails to compile because the type of the variable
    `emp` is defined as `Employee`. Picture it like this: the variable `emp` can see
    only the `Employee` object. Hence, it can access only the variables and methods
    defined in the class `Employee`, as illustrated in [figure 6.18](#ch06fig18).'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在 ![](num-1.jpg) 处无法编译，因为变量 `emp` 的类型被定义为 `Employee`。想象一下：变量 `emp` 只能看到 `Employee`
    对象。因此，它只能访问在类 `Employee` 中定义的变量和方法，如图 6.18 所示。
- en: Figure 6.18\. A variable of type `Employee` can see only the members defined
    in the class `Employee`.
  id: totrans-475
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.18\. 类型为 `Employee` 的变量只能看到在类 `Employee` 中定义的成员。
- en: '![](06fig18_alt.jpg)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig18_alt.jpg)'
- en: 6.3.3\. Using a variable of an implemented interface to access a derived class
    object
  id: totrans-477
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.3\. 使用实现接口的变量访问派生类对象
- en: 'Here’s another interesting equation: what happens when you change the type
    of the reference variable to the interface `Interviewer`? A variable of type `Interviewer`
    can also be used to refer to an object of the class `HRExecutive` because the
    class `HRExecutive` implements `Interviewer`. See the following code:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个有趣的等式：当您将引用变量的类型更改为接口 `Interviewer` 时会发生什么？由于类 `HRExecutive` 实现了 `Interviewer`，因此类型为
    `Interviewer` 的变量也可以用来引用 `HRExecutive` 类的对象。请看以下代码：
- en: '[PRE9]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now try to access the same set of variables and methods using the variable
    `interviewer`, which refers to an object of the class `HRExecutive`:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用引用变量`interviewer`（它指向`HRExecutive`类的对象）来访问相同的变量和方法集：
- en: '![](421fig01_alt.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![](421fig01_alt.jpg)'
- en: 'The code at ![](num-1.jpg) doesn’t compile because the type of the variable
    `interviewer` is defined as `Interviewer`. Picture it like this: the variable
    `interviewer` can only *access* the methods defined in the interface `Interviewer`,
    as illustrated in [figure 6.19](#ch06fig19).'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在![](num-1.jpg)处无法编译，因为变量`interviewer`的类型被定义为`Interviewer`。想象一下：变量`interviewer`只能*访问*接口`Interviewer`中定义的方法，如图
    6.19 所示。
- en: Figure 6.19\. A variable of type `Interviewer` can see only the members defined
    in the interface `Interviewer`.
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.19\. 类型为`Interviewer`的变量只能看到在`Interviewer`接口中定义的成员。
- en: '![](06fig19_alt.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig19_alt.jpg)'
- en: 6.3.4\. The need for accessing an object using the variables of its base - class
    or implemented interfaces
  id: totrans-485
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.4\. 需要通过基类或实现接口的变量来访问对象
- en: You may be wondering why you need a reference variable of a base class or an
    implemented interface to access an object of a derived class if a variable can’t
    access all the members that are available to an object of a derived class. The
    simple answer is that you might not be interested in *all* the members of a derived
    class.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，为什么你需要基类或实现接口的引用变量来访问派生类的对象，如果变量不能访问派生类对象可用的所有成员。简单的答案是，你可能对派生类的所有成员不感兴趣。
- en: Confused? Compare it with the following situation. When you enroll in flying
    classes, do you care whether the instructor can cook Italian cuisine or knows
    how to swim? No! You don’t care about characteristics and behavior that are unrelated
    to flying. Here’s another example. At an office party, all the Employees are welcome,
    whether they are Programmers, HRExecutives, or Managers, as shown in [figure 6.20](#ch06fig20).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 感到困惑？比较以下情况。当你报名参加飞行课程时，你是否关心教练是否会做意大利菜或会游泳？不！你不会关心与飞行无关的特征和行为。这里还有一个例子。在办公室派对上，所有员工都受欢迎，无论他们是程序员、HRExecutive还是Manager，如图
    6.20 所示。
- en: Figure 6.20\. All types of Employees can attend an office party.
  id: totrans-488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.20\. 所有类型的员工都可以参加办公室派对。
- en: '![](06fig20_alt.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig20_alt.jpg)'
- en: The same logic applies when you access an object of the class `HRExecutive`
    using a reference variable of type `Interviewer`. When you do so, you’re only
    concerned about the behavior of `HRExecutive` that relates to its capability as
    an `Interviewer`.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用类型为`Interviewer`的引用变量访问`HRExecutive`类的对象时，相同的逻辑也适用。当你这样做时，你只关心与`HRExecutive`作为`Interviewer`的能力相关的行为。
- en: 'This arrangement also makes it possible to create an array (or a list) of the
    objects that refers to different types of objects grouped by a common base class
    or an interface. The following code segment defines an array of type `Interviewer`
    and stores in it objects of the classes `HRExecutive` and `Manager`:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安排还使得能够创建一个数组（或列表），该数组引用了按公共基类或接口分组的不同类型的对象。以下代码段定义了一个类型为`Interviewer`的数组，并在其中存储了`HRExecutive`和`Manager`类的对象：
- en: '![](422fig01_alt.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![](422fig01_alt.jpg)'
- en: 'The class `HRExecutive` extends the class `Employee` and implements the interface
    `Interviewer`. Hence, you can assign an object of `HRExecutive` to any of the
    following types of variables:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 类`HRExecutive`扩展了类`Employee`并实现了接口`Interviewer`。因此，你可以将`HRExecutive`对象赋值给以下任何类型的变量：
- en: '`HRExecutive`'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HRExecutive`'
- en: '`Employee`'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Employee`'
- en: '`Interviewer`'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Interviewer`'
- en: '`Object`'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object`'
- en: 'Please note that the reverse of these assignments will fail compilation. To
    start with, you can’t refer to an object of a base class by using a reference
    variable of its derived class. Because *all* members of a derived class can’t
    be accessed using an object of the base class, it isn’t allowed. The following
    statement won’t compile:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些赋值的逆操作将无法通过编译。首先，你不能使用派生类的引用变量来引用基类的对象。因为派生类的所有成员都不能通过基类的对象访问，这是不允许的。以下语句将无法编译：
- en: '![](422fig02_alt.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![](422fig02_alt.jpg)'
- en: 'Because you can’t create an object of an interface, the following line of code
    will also fail to compile:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 因为不能创建接口的对象，所以以下代码行也将无法编译：
- en: '![](423fig01.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![](423fig01.jpg)'
- en: It’s now time for you to try to add objects of the previously defined related
    classes—`Employee`, `Manager`, and `HRExecutive`—to an array in your next Twist
    in the Tale exercise (answers in the appendix).
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候尝试在你的下一个故事转折练习中添加之前定义的相关类的对象——`Employee`、`Manager` 和 `HRExecutive`——到数组中（答案在附录中）。
- en: Twist in the Tale 6.2
  id: totrans-503
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事转折 6.2
- en: 'Given the following definition of the classes `Employee`, `Manager`, and `HRExecutive`
    and the interface `Interviewer`, select the correct options for the class `TwistInTale2`:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下 `Employee`、`Manager` 和 `HRExecutive` 类以及 `Interviewer` 接口的定义，为类 `TwistInTale2`
    选择正确的选项：
- en: '[PRE10]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An object of the class `Manager` can be added to an array of the interface `Interviewer`.
    Code on line 1 will compile successfully.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类 `Manager` 的对象可以被添加到接口 `Interviewer` 的数组中。第 1 行的代码将成功编译。
- en: An object of the class `Employee` can be added to an array of the interface
    `Interviewer`. Code on line 2 will compile successfully.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类 `Employee` 的对象可以被添加到接口 `Interviewer` 的数组中。第 2 行的代码将成功编译。
- en: An object of the class `HRExecutive` can be added to an array of the interface
    `Interviewer`. Code on line 3 will compile successfully.
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类 `HRExecutive` 的对象可以被添加到接口 `Interviewer` 的数组中。第 3 行的代码将成功编译。
- en: An object of the interface `Interviewer` can be added to an array of the interface
    `Interviewer`. Code on line 4 will compile successfully.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口 `Interviewer` 的对象可以被添加到接口 `Interviewer` 的数组中。第 4 行的代码将成功编译。
- en: '|  |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: You may see multiple questions in the exam that try to assign an object of a
    base class to a reference variable of a derived class. Note that a derived class
    can be referred to using a reference variable of a superclass. The reverse is
    not allowed and won’t compile.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在考试中看到多个问题，尝试将基类对象分配给派生类引用变量。请注意，派生类可以使用超类引用变量来引用。反之则不允许，并且无法编译。
- en: '|  |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this section, you learned that the variables of a base class or interface
    are unable to access all the members of the object to which they refer. Don’t
    worry; this can be resolved by *casting* a reference variable of a base class
    or an interface to the exact type of the object they refer to, as discussed in
    the next section.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解到基类或接口的变量无法访问它们所引用的对象的所有成员。不用担心；这可以通过将基类或接口的引用变量转换为它们所引用的对象的确切类型来解决，正如下一节所讨论的。
- en: 6.4\. Casting
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4\. 类型转换
- en: '|  |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[[7.3](kindle_split_021.html#ch07lev1sec3)] Determine when casting is necessary'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '[[7.3](kindle_split_021.html#ch07lev1sec3)] 确定何时需要进行类型转换'
- en: '|  |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '*Casting* is the process of forcefully making a variable behave as a variable
    of another type. If a class shares an IS-A or inheritance relationship with another
    class or interface, their variables can be cast to each other’s type.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型转换* 是强制使变量表现得像另一个类型的变量的过程。如果一个类与另一个类或接口共享 IS-A 或继承关系，它们的变量可以转换为彼此的类型。'
- en: In [section 6.3](#ch06lev1sec3), you learned that you can’t access all the members
    of the class `HRExecutive` (derived class) if you refer to it via a variable of
    type `Interviewer` (implemented interface) or `Employee` (base class). In this
    section, you’ll learn how to cast a variable of type `Interviewer` to access variables
    defined in the class `HRExecutive` and why you’d want to.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6.3 节](#ch06lev1sec3) 中，你了解到如果你通过类型为 `Interviewer`（实现接口）或 `Employee`（基类）的变量来引用类
    `HRExecutive`（派生类），则无法访问该类的所有成员。在本节中，你将学习如何将类型为 `Interviewer` 的变量转换为类 `HRExecutive`
    中定义的变量，以及为什么需要这样做。
- en: 6.4.1\. How to cast a variable to another type
  id: totrans-521
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.1\. 如何将变量转换为另一种类型
- en: 'We’ll start with the definitions of the interface `Interviewer` and the classes
    `HRExecutive` and `Manager`:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从接口 `Interviewer` 和类 `HRExecutive` 以及 `Manager` 的定义开始：
- en: '[PRE11]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a variable of type `Interviewer` and assign to it an object of type
    `HRExecutive` (as depicted in [figure 6.21](#ch06fig21)):'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类型为 `Interviewer` 的变量，并将其分配给类型为 `HRExecutive` 的对象（如图 6.21 所示）：
- en: '[PRE12]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Figure 6.21\. A reference variable of the interface `Interviewer` referring
    to an object of the class `HRExecutive`
  id: totrans-526
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.21\. 接口 `Interviewer` 的引用变量指向类 `HRExecutive` 的对象
- en: '![](06fig21.jpg)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig21.jpg)'
- en: 'Try to access the variable `specialization` defined in the class `HRExecutive`
    using the previous variable:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用之前的变量访问在类 `HRExecutive` 中定义的变量 `specialization`：
- en: '![](425fig01_alt.jpg)'
  id: totrans-529
  prefs: []
  type: TYPE_IMG
  zh: '![](425fig01_alt.jpg)'
- en: The previous line of code won’t compile. The compiler knows that the type of
    the variable `interviewer` is `Interviewer` and that the interface `Interviewer`
    doesn’t define any variable with the name `specialization` (as shown in [figure
    6.22](#ch06fig22)).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码将无法编译。编译器知道变量`interviewer`的类型是`Interviewer`，并且接口`Interviewer`没有定义名为`specialization`的任何变量（如[图6.22](#ch06fig22)所示）。
- en: Figure 6.22\. The Java compiler doesn’t compile code if you try to access the
    variable `specialization`, defined in the class `HRExecutive`, by using a variable
    of the interface `Interviewer`.
  id: totrans-531
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.22。如果你尝试使用`Interviewer`接口的变量来访问在`HRExecutive`类中定义的变量`specialization`，Java编译器将不会编译代码。
- en: '![](06fig22_alt.jpg)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig22_alt.jpg)'
- en: 'On the other hand, the JRE knows that the object referred to by the variable
    `interviewer` is of type `HRExecutive`, so you can use casting to get past the
    Java compiler and access the members of the object being referred to, as follows
    (see also [figure 6.23](#ch06fig23)):'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，JRE知道变量`interviewer`所引用的对象是`HRExecutive`类型，因此你可以使用类型转换来绕过Java编译器，访问所引用对象的成员，如下所示（也请参见[图6.23](#ch06fig23)）：
- en: '[PRE13]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Figure 6.23\. Casting can be used to access the variable `specialization`, defined
    in the class `HRExecutive`, by using a variable of the interface `Interviewer`.
  id: totrans-535
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.23。可以使用类型转换通过`Interviewer`接口的变量来访问在`HRExecutive`类中定义的变量`specialization`。
- en: '![](06fig23_alt.jpg)'
  id: totrans-536
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig23_alt.jpg)'
- en: In the previous example code, `(HRExecutive)` is placed just before the name
    of the variable, `interviewer`, to cast it to `HRExecutive`. A pair of parentheses
    surrounds `HRExecutive`, which lets Java know you’re sure that the object being
    referred to is an object of the class `HRExecutive`. Casting is another method
    of telling Java, “Look, I know that the actual object being referred to is `HRExecutive`,
    even though I’m using a reference variable of type `Interviewer`.”
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例代码中，`(HRExecutive)`放置在变量名`interviewer`之前，以将其转换为`HRExecutive`。一对括号包围了`HRExecutive`，这使Java知道你确信所引用的对象是`HRExecutive`类的对象。类型转换是另一种告诉Java的方法，“看，我知道实际所引用的对象是`HRExecutive`，尽管我正在使用类型为`Interviewer`的引用变量。”
- en: The parentheses that surround the whole `(HRExecutive)interviewer` token are
    required to bypass the Java operator precedence rules, according to which the
    casting “operator” (the parentheses) has lower priority than the dot “operator”
    (used to access an object field or invoke a method).
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过Java运算符优先级规则，需要将整个`(HRExecutive)interviewer`标记包围在括号中，根据这些规则，类型转换“运算符”（括号）的优先级低于点“运算符”（用于访问对象字段或调用方法）。
- en: 6.4.2\. Need for casting
  id: totrans-539
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.2. 类型转换的需要
- en: In [section 6.3.4](#ch06lev2sec20), I discussed the need to use a reference
    variable of an inherited class or an implemented interface to refer to an object
    of a derived class. I also used an example of enrolling in flying classes, where
    you don’t care about whether the instructor can cook Italian cuisine or knows
    how to swim. You don’t care about characteristics and behavior that are unrelated
    to flying.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6.3.4节](#ch06lev2sec20)中，我讨论了使用继承类或实现接口的引用变量来引用派生类对象的需要。我还用一个报名飞行课程的例子来说明，你并不关心教练是否能做意大利菜或是否会游泳。你并不关心与飞行无关的特征和行为。
- en: But think about a situation in which you do care about the swimming skills of
    your instructor. Imagine that when you’re attending flying classes, your friend
    inquires about whether your flying instructor also conducts swimming classes,
    and if so, whether your friend could enroll. In this case, a *need* arises to
    inquire about the swimming skills of your flying instructor.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 但考虑一下这种情况，你确实关心你的教练的游泳技巧。想象一下，当你正在上飞行课程时，你的朋友询问你的飞行教练是否也开设游泳课程，如果是的话，你的朋友是否可以报名。在这种情况下，就有必要了解你的飞行教练的游泳技巧。
- en: Let’s apply this situation to Java. You can’t access all the members of an object
    if you access it using a reference variable of any of its implemented interfaces
    or of a base class. But when a need arises (as mentioned in the preceding paragraph),
    you *might* choose to access some of the members of a derived class, which aren’t
    explicitly available, by using the reference variable of the base type or the
    implemented interface. This is where casting comes in!
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这种情况应用到Java中。如果你使用任何实现接口或基类的引用变量来访问对象，你将无法访问该对象的所有成员。但是，当出现需要（如前一段所述）时，你可能会选择使用基类型或实现接口的引用变量来访问一些派生类的成员，这些成员不是明确可用的。这就是类型转换发挥作用的地方！
- en: 'It’s time to see this in code. Here’s an example that exhibits the need for
    casting. An application maintains a list of interviewers, and depending on the
    type of interviewer (`HRExecutive` or `Manager`), it performs a different set
    of actions. If the interviewer is a `Manager`, the code calls `conductInterview`
    only if the value for the `Manager`’s `teamSize` is greater than `10`. Here’s
    the code that implements this logic:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候在代码中看到这一点了。以下是一个展示需要类型转换的示例。一个应用程序维护一个面试官列表，根据面试官的类型（`HRExecutive` 或 `Manager`），它执行不同的操作集。如果面试官是
    `Manager`，则只有在 `Manager` 的 `teamSize` 值大于 `10` 时，代码才会调用 `conductInterview`。以下是实现此逻辑的代码：
- en: '![](427fig01_alt.jpg)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
  zh: '![](427fig01_alt.jpg)'
- en: The preceding code shows a best practice when it comes to casting a variable,
    that is, `interviewer instanceof Manager`. If you omit this test, you run the
    risk of code throwing a `ClassCastException` (covered in [section 7.5.2](kindle_split_021.html#ch07lev2sec26)
    in detail).
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了类型转换的最佳实践，即 `interviewer instanceof Manager`。如果您省略了这个测试，代码可能会抛出 `ClassCastException`（在[第
    7.5.2 节](kindle_split_021.html#ch07lev2sec26)中详细说明）。
- en: 6.5\. Use this and super to access objects and constructors
  id: totrans-546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5\. 使用 this 和 super 访问对象和构造函数
- en: '|  |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[[7.4](kindle_split_021.html#ch07lev1sec4)] Use super and this to access objects
    and constructors'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '[[7.4](kindle_split_021.html#ch07lev1sec4)] 使用 super 和 this 访问对象和构造函数'
- en: '|  |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this section, you’ll use the `this` and `super` keywords to access objects
    and constructors. `this` and `super` are *implicit* object references. These variables
    are defined and initialized by the JVM for every object in its memory.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将使用 `this` 和 `super` 关键字来访问对象和构造函数。`this` 和 `super` 是**隐式**对象引用。这些变量由
    JVM 为其内存中的每个对象定义和初始化。
- en: Let’s examine the capabilities and use of each of these reference variables.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查每个这些引用变量的能力和用法。
- en: '6.5.1\. Object reference: this'
  id: totrans-552
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.1\. 对象引用：this
- en: 'The `this` reference always points to an object’s *own instance*. Any object
    can use the `this` reference to refer to its own instance. Think of the words
    *me*, *myself*, and *I*: anyone using those words is always referring to oneself,
    as shown in [figure 6.24](#ch06fig24).'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '`this` 引用始终指向对象的**自身实例**。任何对象都可以使用 `this` 引用来引用其自身的实例。想想看单词 *me*、*myself* 和
    *I*：使用这些单词的人总是指自己，如[图 6.24](#ch06fig24)所示。'
- en: Figure 6.24\. The keyword `this` can be compared to the words *me*, *myself*,
    and *I*.
  id: totrans-554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.24\. 关键字 `this` 可以与单词 *me*、*myself* 和 *I* 相比。
- en: '![](06fig24.jpg)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig24.jpg)'
- en: Using this to access variables and methods
  id: totrans-556
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 this 访问变量和方法
- en: 'You can use the keyword `this` to refer to all methods and variables that are
    accessible to a class. For example, here’s a modified definition of the class
    `Employee`:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用关键字 `this` 来引用类可访问的所有方法和变量。例如，以下是 `Employee` 类的修改后定义：
- en: '[PRE14]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The variable `name` can be accessed in the class `Programmer` (which extends
    the class `Employee`) as follows:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `name` 可以在扩展了 `Employee` 类的 `Programmer` 类中访问，如下所示：
- en: '[PRE15]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Because there exist members of the class `Employee` within the class `Programmer`,
    the variable `name` is accessible to an object of `Programmer`. The variable `name`
    can also be accessed in the class `Programmer` as follows:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在 `Programmer` 类中存在 `Employee` 类的成员，所以变量 `name` 可以被 `Programmer` 类的对象访问。变量
    `name` 也可以在 `Programmer` 类中按如下方式访问：
- en: '[PRE16]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `this` reference is required only when code executing within a method block
    needs to differentiate between an instance variable and its local variable or
    method parameters. But some developers use the keyword `this` all over their code,
    even when it’s not required. Some use `this` as a means to differentiate instance
    variables from local variables or method parameters.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当方法块中的代码需要区分实例变量和它的局部变量或方法参数时，才需要 `this` 引用。但一些开发者即使在不需要时也会在他们的代码中使用关键字 `this`。有些人使用
    `this` 作为区分实例变量和局部变量或方法参数的手段。
- en: '[Figure 6.25](#ch06fig25) shows the constructor of the class `Employee`, which
    uses the reference variable `this` to differentiate between the local and instance
    variables `name`, which are declared with the same name.'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6.25](#ch06fig25) 展示了 `Employee` 类的构造函数，它使用引用变量 `this` 来区分具有相同名称的局部变量 `name`
    和实例变量。'
- en: Figure 6.25\. Using the keyword `this` to differentiate between the method parameter
    and the instance variable
  id: totrans-565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.25\. 使用关键字 `this` 区分方法参数和实例变量
- en: '![](06fig25.jpg)'
  id: totrans-566
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig25.jpg)'
- en: In the previous example, the class `Employee` defines an instance variable `name`.
    The `Employee` class constructor also defines a method parameter `name`, which
    is effectively a local variable defined within the scope of the method block.
    Hence, within the scope of the previously defined `Employee` constructor, there’s
    a clash of names, and the local variable will take precedence (covered in [section
    3.1](kindle_split_014.html#ch03lev1sec1)). Using `name` within the scope of the
    `Employee` class constructor block will implicitly refer to that method’s parameter,
    not the instance variable. In order to refer to the instance variable `name` from
    within the scope of the `Employee` class constructor, you are obliged to use a
    `this` reference.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，类`Employee`定义了一个实例变量`name`。`Employee`类构造函数还定义了一个方法参数`name`，这实际上是在方法块作用域内定义的一个局部变量。因此，在先前定义的`Employee`构造函数的作用域内，存在名称冲突，局部变量将具有优先权（在[第3.1节](kindle_split_014.html#ch03lev1sec1)中介绍）。在`Employee`类构造函数块的作用域内使用`name`将隐式地引用该方法的参数，而不是实例变量。为了从`Employee`类构造函数的作用域内引用实例变量`name`，你必须使用`this`引用。
- en: Using this to access constructors
  id: totrans-568
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用此方法访问构造函数
- en: 'You can also reference one constructor from another by using the keyword `this`.
    Here’s an example in which the class `Employee` defines two constructors, with
    the second constructor calling the first one:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用关键字`this`从另一个构造函数引用一个构造函数。以下是一个例子，其中类`Employee`定义了两个构造函数，第二个构造函数调用了第一个：
- en: '![](429fig01_alt.jpg)'
  id: totrans-570
  prefs: []
  type: TYPE_IMG
  zh: '![](429fig01_alt.jpg)'
- en: 'To call the default constructor (one that doesn’t accept any method parameters),
    call `this()`. Here’s an example:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用默认构造函数（不接受任何方法参数的构造函数），调用`this()`。以下是一个例子：
- en: '![](429fig02_alt.jpg)'
  id: totrans-572
  prefs: []
  type: TYPE_IMG
  zh: '![](429fig02_alt.jpg)'
- en: If present, a call to a constructor from another constructor must be done on
    the first line of code of the calling constructor.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在，从一个构造函数调用另一个构造函数必须在调用构造函数的第一行代码上完成。
- en: '|  |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-575
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: '`this` refers to the instance of the class in which it’s used. `this` can be
    used to access the inherited members of a base class in the derived class.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`指的是使用它的类的实例。`this`可以用来访问派生类中基类的继承成员。'
- en: '|  |'
  id: totrans-577
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Using the keyword this in an interface
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在接口中使用关键字this
- en: 'With Java 8, you can use the keyword `this` in an interface’s `default` method
    to access its constants and other default and `abstract` methods. In the following
    example, the interface `Interviewer` defines a default method `submitInterviewStatus`.
    This method uses `this` to access itself and its constants or methods:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，你可以在接口的`default`方法中使用关键字`this`来访问其常量和其他默认和`abstract`方法。在以下示例中，接口`Interviewer`定义了一个默认方法`submitInterviewStatus`。此方法使用`this`来访问自身及其常量或方法：
- en: '[PRE17]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You might see a similar output for the preceding code:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到前面代码的类似输出：
- en: '[PRE18]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|  |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: With Java 8, you can use the keyword `this` in a default method to access the
    methods of an interface and its constants.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，你可以在默认方法中使用关键字`this`来访问接口的方法和常量。
- en: '|  |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You can’t use the `this` keyword to access `static` methods of an interface.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能使用`this`关键字来访问接口的`static`方法。
- en: '6.5.2\. Object reference: super'
  id: totrans-588
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.2. 对象引用：super
- en: 'In the previous section, I discussed how `this` refers to the object instance
    itself. Similarly, `super` is also an object reference, but `super` refers to
    the direct parent or base class of a class. Think of the words *my parent*, *my
    base*: anyone using those terms is always referring to their direct parent or
    the base class, as shown in [figure 6.26](#ch06fig26).'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我讨论了`this`如何指向对象实例本身。同样，`super`也是一个对象引用，但`super`指向类的直接父类或基类。想想看，“我的父母”，“我的基类”：使用这些术语的人总是指他们的直接父母或基类，如图6.26所示。
- en: Figure 6.26\. When a class mentions `super`, it refers to its direct parent
    or the base class.
  id: totrans-590
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.26。当一个类提到`super`时，它指的是它的直接父类或基类。
- en: '![](06fig26.jpg)'
  id: totrans-591
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig26.jpg)'
- en: Using super to access variables and methods of the base class
  id: totrans-592
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用super访问基类的变量和方法
- en: The variable reference `super` can be used to access a variable or method from
    the base class if there’s a clash between these names. This situation normally
    occurs when a derived class defines variables and methods with the same name as
    the base class.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些名称之间发生冲突时，可以使用变量引用`super`来访问基类中的变量或方法。这种情况通常发生在派生类定义了与基类具有相同名称的变量和方法时。
- en: 'Here’s an example:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子：
- en: '![](431fig01_alt.jpg)'
  id: totrans-595
  prefs: []
  type: TYPE_IMG
  zh: '![](431fig01_alt.jpg)'
- en: 'The output of the preceding code is as follows:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE19]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Similarly, you can use the reference variable `super` to access a method defined
    with the same name in the base or the parent class.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以使用引用变量 `super` 来访问在基类或父类中定义的同名方法。
- en: Using super to access constructors of base class
  id: totrans-599
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 super 访问基类构造函数
- en: The reference variable `super` can also be used to refer to the constructors
    of the base class in a derived class.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 引用变量 `super` 也可以在派生类中用来引用基类的构造函数。
- en: Here’s an example in which the base class, `Employee`, defines a constructor
    that assigns default values to its variables. Its derived class calls the base
    class constructor in its own constructor.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，其中基类 `Employee` 定义了一个构造函数，它为其变量分配默认值。其派生类在其自己的构造函数中调用基类构造函数。
- en: '![](432fig01_alt.jpg)'
  id: totrans-602
  prefs: []
  type: TYPE_IMG
  zh: '![](432fig01_alt.jpg)'
- en: The code at ![](num-1.jpg) calls the superclass constructor by passing it the
    reference variables, `name` and `address`, which it accepts itself.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在 ![](num-1.jpg) 处通过传递引用变量 `name` 和 `address` 调用超类构造函数，它自己接受这些变量。
- en: '|  |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-605
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: If present, a call to a superclass’s constructor must be the first statement
    in a derived class’s constructor. Otherwise, a call to `super();` (the no-argument
    constructor) is inserted automatically by the compiler.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在，派生类构造函数中对超类构造函数的调用必须是派生类构造函数中的第一条语句。否则，编译器会自动插入对 `super();`（无参数构造函数）的调用。
- en: '|  |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Using super and this in static methods
  id: totrans-608
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在静态方法中使用 super 和 this
- en: 'The keywords `super` and `this` are implicit object references. Because `static`
    methods belong to a class, not to objects of a class, you can’t use `this` and
    `super` in `static` methods. Code that tries to do so won’t compile:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `super` 和 `this` 是隐式对象引用。因为 `static` 方法属于一个类，而不是属于类的对象，所以你无法在 `static` 方法中使用
    `this` 和 `super`。尝试这样做的代码将无法编译：
- en: '![](432fig02_alt.jpg)'
  id: totrans-610
  prefs: []
  type: TYPE_IMG
  zh: '![](432fig02_alt.jpg)'
- en: It’s time to attempt the next Twist in the Tale exercise, using the `this` and
    `super` keywords (answer in the appendix).
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候尝试下一个故事转折练习了，使用 `this` 和 `super` 关键字（答案见附录）。
- en: Twist in the Tale 6.3
  id: totrans-612
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事转折 6.3
- en: Let’s modify the definition of the `Employee` and `Programmer` classes as follows.
    What is the output of the class `TwistInTale3`?
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 `Employee` 和 `Programmer` 类的定义如下。`TwistInTale3` 类的输出是什么？
- en: '[PRE20]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`Prog:null:Emp:EmpAddress`'
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Prog:null:Emp:EmpAddress`'
- en: '`Prog:EmpAddress:Emp:EmpAddress`'
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Prog:EmpAddress:Emp:EmpAddress`'
- en: '`Prog::Emp:EmpAddress`'
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Prog::Emp:EmpAddress`'
- en: Compilation error
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: 'Similarly, you can’t use the keyword `this` in a `static` method, defined in
    an interface:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你也不能在接口中定义的 `static` 方法中使用关键字 `this`：
- en: '![](433fig01_alt.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
  zh: '![](433fig01_alt.jpg)'
- en: 'Now let’s move to one of the very important programming concepts: polymorphism.
    In the next section, you’ll use abstract classes and interfaces to implement it.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向一个非常重要的编程概念：多态。在下一节中，你将使用抽象类和接口来实现它。
- en: 6.6\. Polymorphism
  id: totrans-622
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6\. 多态
- en: '|  |'
  id: totrans-623
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[[7.5](kindle_split_021.html#ch07lev1sec6)] Use abstract classes and interfaces'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '[[7.5](kindle_split_021.html#ch07lev1sec6)] 使用抽象类和接口'
- en: '|  |'
  id: totrans-625
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[[7.2](kindle_split_021.html#ch07lev1sec2)] Develop code that demonstrates
    the use of polymorphism; including overriding and object type versus reference
    type'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '[[7.2](kindle_split_021.html#ch07lev1sec2)] 开发演示多态使用的代码；包括重写和对象类型与引用类型'
- en: '|  |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The literal meaning of the word *polymorphism* is “many forms.” At the beginning
    of this chapter, I used a practical example to explain the meaning of polymorphism;
    the same action may have different meanings for different living beings. The action
    *eat* has a different meaning for a *fly* and a *lion.* A *fly* may eat *nectar*,
    whereas a *lion* may eat an antelope. Reacting to the same action in one’s own
    unique manner in living beings can be compared to polymorphism in Java.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: “多态”这个词的字面意思是“多种形式”。在本章的开头，我使用了一个实际例子来解释多态的含义；同样的动作对不同生物可能具有不同的意义。动作 *吃* 对 *苍蝇*
    和 *狮子* 来说有不同的意义。一只 *苍蝇* 可能吃 *花蜜*，而一只 *狮子* 可能吃 *羚羊*。生物对同一动作以独特的方式做出反应可以与 Java 中的多态相提并论。
- en: For the exam, you need to know what polymorphism in Java is, why you need it,
    and how to implement it in code.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 对于考试，你需要知道 Java 中的多态是什么，为什么需要它，以及如何在代码中实现它。
- en: 6.6.1\. Polymorphism with classes
  id: totrans-631
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.6.1\. 类的多态
- en: Polymorphism with classes comes into the picture when a class inherits another
    class and both the base and the derived classes define methods with the same method
    signature (the same method name and method parameters). As discussed in the previous
    section, an object can also be referred to using a reference variable of its base
    class. In this case, depending on the type of the object used to execute a method,
    the Java runtime executes the method defined in the base or derived class.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类继承另一个类，并且基类和派生类都定义了具有相同方法签名（相同的方法名和方法参数）的方法时，就会出现类多态的情况。正如前文所述，一个对象也可以使用其基类的引用变量来引用。在这种情况下，根据执行方法的对象类型，Java运行时会执行基类或派生类中定义的方法。
- en: Let’s consider polymorphism using the classes `Employee`, `Programmer`, and
    `Manager`, where the classes `Programmer` and `Manager` inherit the class `Employee`.
    [Figure 6.27](#ch06fig27) shows a UML diagram depicting the relationships among
    these classes.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过`Employee`、`Programmer`和`Manager`这三个类来考虑多态性，其中`Programmer`和`Manager`类继承自`Employee`类。[图6.27](#ch06fig27)展示了这些类之间的关系。
- en: Figure 6.27\. Relationships among the classes `Employee`, `Programmer`, and
    `Manager`
  id: totrans-634
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.27\. `Employee`、`Programmer`和`Manager`类之间的关系
- en: '![](06fig27.jpg)'
  id: totrans-635
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig27.jpg)'
- en: 'We’ll start with the `Employee` class, which is not quite sure about what must
    be done to start work on a project (execute method `startProjectWork`). Hence,
    the method `startProjectWork` is defined as an `abstract` method, and the class
    `Employee` is defined as an `abstract` class, as follows:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从`Employee`类开始，它并不确定为了开始一个项目的工作必须做什么（执行`startProjectWork`方法）。因此，`startProjectWork`方法被定义为`abstract`方法，而`Employee`类被定义为`abstract`类，如下所示：
- en: '![](434fig01_alt.jpg)'
  id: totrans-637
  prefs: []
  type: TYPE_IMG
  zh: '![](434fig01_alt.jpg)'
- en: 'The class `Programmer` extends the class `Employee`, which essentially means
    that it has access to the method `reachOffice` defined in `Employee`. `Programmer`
    must also implement the `abstract` method `startProjectWork`, inherited from `Employee`.
    How do you think a Programmer will typically start work on a programming project?
    Most probably, the Programmer will define classes and unit test them. This behavior
    is contained in the definition of the class `Programmer`, which implements the
    method `start-ProjectWork`, as follows:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '`Programmer`类继承自`Employee`类，这意味着它能够访问在`Employee`中定义的`reachOffice`方法。`Programmer`类还必须实现从`Employee`继承来的`abstract`方法`startProjectWork`。你认为程序员通常会怎样开始一个编程项目的工作？很可能是，程序员会定义类并对它们进行单元测试。这种行为包含在`Programmer`类的定义中，该类实现了`start-ProjectWork`方法，如下所示：'
- en: '[PRE21]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We’re fortunate to have another special type of Employee, a Manager, who knows
    how to start work on a project. How do you think a Manager will typically start
    work on a programming project? Most probably, the Manager will meet with the customers,
    define a project schedule, and assign work to the team members. Here’s the definition
    of the class `Manager` that extends the class `Employee` and implements the method
    `startProjectWork`:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很幸运还有另一种特殊的员工类型，即经理，他知道如何开始一个项目的工作。你认为经理通常会怎样开始一个编程项目的工作？很可能是，经理会与客户会面，定义项目进度，并分配工作给团队成员。以下是扩展`Employee`类并实现`startProjectWork`方法的`Manager`类的定义：
- en: '[PRE22]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s see how this method behaves with different types of Employees. Here’s
    the relevant code:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个方法在不同类型的员工中是如何表现的。以下是相关的代码：
- en: '![](435fig01_alt.jpg)'
  id: totrans-643
  prefs: []
  type: TYPE_IMG
  zh: '![](435fig01_alt.jpg)'
- en: 'Here’s the output of the code (blank lines added for clarity):'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的输出（为了清晰，添加了空白行）：
- en: '[PRE23]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code at ![](num-1.jpg) creates an object of the class `Programmer` and assigns
    it to a variable of type `Employee`. ![](num-2.jpg) creates an object of the class
    `Manager` and assigns it to a variable of type `Employee`. So far, so good!
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 在![](num-1.jpg)中的代码创建了一个`Programmer`类的对象，并将其分配给一个`Employee`类型的变量。![](num-2.jpg)创建了一个`Manager`类的对象，并将其分配给一个`Employee`类型的变量。到目前为止，一切顺利！
- en: 'Now comes the complicated part. ![](num-3.jpg) executes the method `reachOffice`.
    Because this method is defined only in the class `Employee`, there isn’t any confusion
    and the same method executes, printing the following:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是复杂的部分。![](num-3.jpg)执行了`reachOffice`方法。因为这个方法只在`Employee`类中定义，所以没有混淆，执行了相同的方法，并打印了以下内容：
- en: '[PRE24]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The code at ![](num-4.jpg) executes the code `emp1.startProjectWork()` and
    calls the method `startProjectWork` defined in the class `Programmer`, because
    `emp1` refers to an object of the class `Programmer`. Here’s the output of this
    method call:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 在![num-4.jpg](num-4.jpg)处的代码执行`emp1.startProjectWork()`并调用在`Programmer`类中定义的`startProjectWork`方法，因为`emp1`引用的是`Programmer`类的一个对象。以下是这个方法调用的输出：
- en: '[PRE25]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The code at ![](num-5.jpg) executes `emp2.startProjectWork()` and calls the
    method `startProjectWork` defined in the class `Manager`, because `emp2` refers
    to an object of the class `Manager`. Here’s the output of this method call:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 在![num-5.jpg](num-5.jpg)处的代码执行`emp2.startProjectWork()`并调用在`Manager`类中定义的`startProjectWork`方法，因为`emp2`引用的是`Manager`类的一个对象。以下是这个方法调用的输出：
- en: '[PRE26]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Figure 6.28](#ch06fig28) illustrates this code.'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.28](#ch06fig28)展示了这段代码。'
- en: Figure 6.28\. The objects are aware of their own type and execute the overridden
    method defined in their own class, even if a base class variable is used to refer
    to them.
  id: totrans-654
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.28。对象知道自己的类型，并执行它们自己类中定义的覆盖方法，即使使用基类变量来引用它们。
- en: '![](06fig28_alt.jpg)'
  id: totrans-655
  prefs: []
  type: TYPE_IMG
  zh: '![06fig28_alt.jpg](06fig28_alt.jpg)'
- en: As discussed in the beginning of this section, the usefulness of polymorphism
    lies in the ability of an object to behave in its own specific manner when the
    same action is passed to it. In the previous example, reference variables (`emp1`
    and `emp2`) of type `Employee` are used to store objects of the classes `Programmer`
    and `Manager`. When the same action—that is, the method call `startProjectWork`—is
    invoked on these reference variables (`emp1` and `emp2`), each method call results
    in the method defined in the respective classes being executed.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所述，多态的有用之处在于对象能够在接收到相同操作时以自己的特定方式行为。在前面的例子中，使用类型为`Employee`的引用变量（`emp1`和`emp2`）来存储`Programmer`和`Manager`类的对象。当在引用变量（`emp1`和`emp2`）上调用相同的操作——即方法调用`startProjectWork`——时，每个方法调用都会导致执行相应类中定义的方法。
- en: Polymorphic methods are also called overridden methods
  id: totrans-657
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 多态方法也称为覆盖方法
- en: 'Take a quick look at the method `startProjectWork`, as defined in the following
    classes `Employee`, `Programmer`, and `Manager` (only the relevant code is shown):'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看以下类`Employee`、`Programmer`和`Manager`（只显示相关代码）中定义的`startProjectWork`方法：
- en: '![](437fig01_alt.jpg)'
  id: totrans-659
  prefs: []
  type: TYPE_IMG
  zh: '![437fig01_alt.jpg](437fig01_alt.jpg)'
- en: 'Note that the name of the method `startProjectWork` is same in all these classes.
    Also, it accepts the same number of method arguments and defines the same return
    type in all three classes: `Employee`, `Programmer`, and `Manager`. This is a
    contract specified to define overridden methods. Failing to use the same method
    name, same argument list, or same return type won’t mark a method as an overridden
    method.'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有这些类中的`startProjectWork`方法名称相同。它们接受相同数量的方法参数，并在三个类`Employee`、`Programmer`和`Manager`中定义相同的返回类型：这是指定覆盖方法的契约。未能使用相同的方法名称、相同的参数列表或相同的返回类型不会将方法标记为覆盖方法。
- en: Rules to remember to override methods
  id: totrans-661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 记住覆盖方法的规则
- en: 'Here’s the set of rules to note to define overriding methods:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是定义覆盖方法时需要注意的规则集：
- en: Overridden methods are defined by classes and interfaces that share inheritance
    relationships.
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖方法是由具有继承关系的类和接口定义的。
- en: The name of the overridden method in the base class and the overriding method
    in the subclass must be the same.
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类中覆盖方法的名称和子类中覆盖方法的名称必须相同。
- en: The argument list passed to the overridden method in the base class must be
    the same as the argument list passed to the overriding method in the subclass.
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基类中传递给覆盖方法的参数列表必须与在子类中传递给覆盖方法的参数列表相同。
- en: The return type of an overriding method in the subclass can be the same as or
    a subclass of the return type of the overridden method in the base class. When
    the overriding method returns a subclass of the return type of the overridden
    method, it’s known as a *covariant return type*.
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类中覆盖方法的返回类型可以与基类中覆盖方法的返回类型相同或为其子类。当覆盖方法返回覆盖方法的返回类型的子类时，它被称为*协变返回类型*。
- en: An overridden method defined in the base class can be an `abstract` method or
    a non-`abstract` method.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基类中定义的覆盖方法可以是`abstract`方法或非`abstract`方法。
- en: A derived class can override only non-`final` methods.
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生类只能覆盖非`final`方法。
- en: Access modifiers for an overriding method can be the same as or less restrictive
    than the method being overridden, but they can’t be more restrictive.
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖方法的可访问修饰符可以与被覆盖的方法相同或更少限制，但不能更严格。
- en: Do polymorphic methods always have to be abstract?
  id: totrans-670
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 多态方法是否总是必须是抽象的？
- en: 'No, polymorphic methods don’t always have to be `abstract`. You can define
    the class `Employee` as a concrete class and the method `startProjectWork` as
    a non-`abstract` method and still get the same results (changes in bold):'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 不，多态方法不总是必须是 `abstract`。你可以将 `Employee` 类定义为具体类，将 `startProjectWork` 方法定义为非
    `abstract` 方法，仍然可以得到相同的结果（加粗部分）：
- en: '[PRE27]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Because there’s no change in the definition of the rest of the classes—`Programmer`,
    `Manager`, and `PolymorphismWithClasses`—I haven’t listed them here. If you create
    an object of the class `Employee` (not of any of its derived classes), you can
    execute the method `startProjectWork` as follows:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其他类的定义（`Programmer`、`Manager` 和 `PolymorphismWithClasses`）没有变化，我没有在这里列出它们。如果你创建了一个
    `Employee` 类的对象（不是其任何派生类的对象），你可以如下执行 `startProjectWork` 方法：
- en: '![](438fig01_alt.jpg)'
  id: totrans-674
  prefs: []
  type: TYPE_IMG
  zh: '![图片](438fig01_alt.jpg)'
- en: '|  |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-676
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: To implement polymorphism with classes, you can define `abstract` or non-`abstract`
    methods in the base class and override them in the derived classes.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用类实现多态，你可以在基类中定义 `abstract` 或非 `abstract` 方法，并在派生类中重写它们。
- en: '|  |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Can polymorphism work with overloaded methods?
  id: totrans-679
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 多态能否与重载方法一起工作？
- en: No, polymorphism works only with overridden methods. Overridden methods have
    the same number and type of method arguments, whereas overloaded methods define
    a method argument list with either a different number or type of method parameters.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 不，多态只与重写方法一起工作。重写方法具有相同数量和类型的参数，而重载方法定义了一个具有不同数量或类型的参数的方法参数列表。
- en: Overloaded methods share only the same name; the JRE treats them like different
    methods. In the case of overridden methods, the JRE decides at runtime which method
    should be called based on the exact type of the object on which it’s called.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 重载方法只有相同的名称；JRE 将它们视为不同的方法。在重写方法的情况下，JRE 根据被调用对象的精确类型在运行时决定调用哪个方法。
- en: It’s time for the next Twist in the Tale exercise. As usual, you can find the
    answers in the appendix.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进行下一个故事转折练习了。像往常一样，你可以在附录中找到答案。
- en: Twist in the Tale 6.4
  id: totrans-683
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事转折 6.4
- en: Given the following definition of classes `Employee` and `Programmer`, which
    of the options when inserted at `//INSERT CODE HERE//` will define the method
    `run` as a polymorphic method?
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下 `Employee` 和 `Programmer` 类的定义，以下哪个选项在 `//INSERT CODE HERE//` 处插入将定义 `run`
    方法为多态方法？
- en: '[PRE28]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`String run()`'
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`String run()`'
- en: '`void run(int meters)`'
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`void run(int meters)`'
- en: '`void run()`'
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`void run()`'
- en: '`int run(String race)`'
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`int run(String race)`'
- en: 6.6.2\. Binding of variables and methods at compile time and runtime
  id: totrans-690
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.6.2\. 编译时和运行时变量和方法绑定
- en: You can use reference variables of a base class to refer to an object of a derived
    class. But there’s a major difference in how Java accesses the variables and methods
    for these objects. With inheritance, the instance variables bind at compile time
    and the methods bind at runtime.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用基类的引用变量来引用派生类的对象。但是，Java 访问这些对象的变量和方法的方式有一个主要区别。在继承中，实例变量在编译时绑定，方法在运行时绑定。
- en: '|  |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-693
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '*Binding* refers to resolving of variables or methods that would be called
    for a reference variable.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '*绑定* 指的是解析变量或方法，这些变量或方法将用于引用变量。'
- en: '|  |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Examine the following code:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 检查以下代码：
- en: '![](440fig01_alt.jpg)'
  id: totrans-697
  prefs: []
  type: TYPE_IMG
  zh: '![图片](440fig01_alt.jpg)'
- en: 'The output of the preceding code is as follows:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE29]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s see what’s happening in the code, step by step:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步查看代码中发生了什么：
- en: '![](num-1.jpg) creates an object of the class `Employee`, referenced by a variable
    of its own type—`Employee`.'
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](num-1.jpg) 创建了一个 `Employee` 类的对象，该对象通过其自身类型的变量引用——`Employee`。'
- en: '![](num-2.jpg) creates an object of the class `Programmer`, referenced by a
    variable of its base type—`Employee`.'
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](num-2.jpg) 创建了一个 `Programmer` 类的对象，该对象通过其基类型的变量引用——`Employee`。'
- en: '![](num-3.jpg) accesses the variable `name` defined in the class `Employee`
    and prints `Employee`.'
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](num-3.jpg) 访问了在类 `Employee` 中定义的变量 `name` 并打印了 `Employee`。'
- en: '![](num-4.jpg) also prints `Employee`. The type of the variable `programmer`
    is `Employee`. Because the variables are bound at compile time, the type of the
    object that’s referenced by the variable `emp` doesn’t make a difference. `programmer.name`
    will access the variable `name` defined in the class `Employee`.'
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](num-4.jpg) 也打印了 `Employee`。变量 `programmer` 的类型是 `Employee`。因为变量在编译时绑定，所以变量
    `emp` 所引用的对象的类型并不重要。`programmer.name` 将访问在类 `Employee` 中定义的变量 `name`。'
- en: '![](num-5.jpg) prints `Employee`. Because the type of the reference variable
    `emp` and the type of object referenced by it are the same (`Employee`), there’s
    no confusion with the method call.'
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](num-5.jpg) 打印 `Employee`。因为引用变量 `emp` 的类型和它引用的对象的类型相同（`Employee`），所以在方法调用上没有混淆。'
- en: '![](num-6.jpg) prints `Programmer`. Even though the method `printName` is called
    using a reference of type `Employee`, the JRE is aware that the method is invoked
    on a `Programmer` object and hence executes the overridden `printName` method
    in the class `Programmer`.'
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![](num-6.jpg) 打印 `Programmer`。尽管使用 `Employee` 类型的引用调用了 `printName` 方法，但 JRE
    知道该方法是在 `Programmer` 对象上调用的，因此执行了 `Programmer` 类中重写的 `printName` 方法。'
- en: '|  |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-708
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Watch out for code in the exam that uses variables of the base class to refer
    to objects of the derived class and then accesses variables and methods of the
    referenced object. Remember that variables bind at compile time, whereas methods
    bind at runtime.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 在考试中要注意使用基类变量来引用派生类对象，然后访问引用对象变量和方法的情况。记住，变量在编译时绑定，而方法在运行时绑定。
- en: '|  |'
  id: totrans-710
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 6.6.3\. Polymorphism with interfaces
  id: totrans-711
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.6.3\. 接口的多态
- en: Polymorphism can also be implemented using interfaces. Whereas polymorphism
    with classes has a class as the base class, polymorphism with interfaces requires
    a class to implement an interface. Polymorphism with interfaces involves `abstract`
    or default methods from the implemented interface. An interface can also define
    static methods, but static methods never participate in polymorphism.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 多态也可以通过接口实现。与类多态不同，接口多态需要一个类实现一个接口。接口多态涉及实现接口的 `abstract` 或默认方法。接口还可以定义静态方法，但静态方法永远不会参与多态。
- en: Polymorphism with abstract methods
  id: totrans-713
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 抽象方法的多态
- en: 'Let’s start with an example. Here’s an interface, `MobileAppExpert`, that defines
    an `abstract` method, `deliverMobileApp`:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从例子开始。这里有一个名为 `MobileAppExpert` 的接口，它定义了一个 `abstract` 方法 `deliverMobileApp`：
- en: '[PRE30]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here’s a simplified version of the classes `Programmer` and `Manager` that
    implement this interface and the method `deliverMobileApp`:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是实现了该接口和 `deliverMobileApp` 方法的 `Programmer` 和 `Manager` 类的简化版本：
- en: '[PRE31]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The relationships among the two classes and the interface are shown in [figure
    6.29](#ch06fig29).
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 两个类和接口之间的关系在 [图 6.29](#ch06fig29) 中显示。
- en: Figure 6.29\. Relationships among classes `Employee`, `Programmer`, and `Manager`
    and the interface `MobileAppExpert`
  id: totrans-719
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.29\. `Employee`、`Programmer` 和 `Manager` 类以及 `MobileAppExpert` 接口之间的关系
- en: '![](06fig29_alt.jpg)'
  id: totrans-720
  prefs: []
  type: TYPE_IMG
  zh: '![](06fig29_alt.jpg)'
- en: In the real world, the delivery of a mobile application would have different
    meanings for a programmer and a manager. For a *programmer*, the delivery of a
    mobile application may require the completion of testing on the real mobile device.
    But for a *manager*, the delivery of a mobile application may mean completing
    the QA process and handing over code to the client along with any release notes.
    The bottom line is that the same message, `deliverMobileApp`, results in the execution
    of different sets of steps for a programmer and a manager.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，移动应用程序的交付对程序员和管理员有不同的含义。对于*程序员*来说，移动应用程序的交付可能需要完成在真实移动设备上的测试。但对于*管理员*来说，移动应用程序的交付可能意味着完成质量保证过程，并将代码连同任何发布说明一起移交给客户。总之，同一个消息
    `deliverMobileApp` 对程序员和管理员来说会导致执行不同的步骤集。
- en: 'Here’s a class, `PolymorphismWithInterfaces`, that creates objects of the classes
    `Programmer` and `Manager` and calls the method `deliverMobileApp`:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个名为 `PolymorphismWithInterfaces` 的类，它创建了 `Programmer` 和 `Manager` 类的对象，并调用了
    `deliverMobileApp` 方法：
- en: '![](442fig01_alt.jpg)'
  id: totrans-723
  prefs: []
  type: TYPE_IMG
  zh: '![](442fig01_alt.jpg)'
- en: 'The output of the preceding code is as follows:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE32]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: At ![](num-1.jpg), the type of the variable is `MobileAppExpert`. Because the
    classes `Manager` and `Programmer` implement the interface `MobileAppExpert`,
    a reference variable of type `MobileAppExpert` can also be used to store objects
    of the classes `Programmer` and `Manager`.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](num-1.jpg)，变量的类型是 `MobileAppExpert`。因为 `Manager` 和 `Programmer` 类实现了 `MobileAppExpert`
    接口，所以也可以使用 `MobileAppExpert` 类型的引用变量来存储 `Programmer` 和 `Manager` 类的对象。
- en: 'Because both these classes also extend the class `Employee`, you can use a
    variable of type `Employee` to store objects of the classes `Programmer` and `Manager`.
    But in this case you won’t be able to call the method `deliverMobileApp` because
    it isn’t visible to the class `Employee`. Examine the following code:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这两个类也扩展了 `Employee` 类，所以你可以使用 `Employee` 类型的变量来存储 `Programmer` 和 `Manager`
    类的对象。但在这个情况下，你将无法调用 `deliverMobileApp` 方法，因为它对 `Employee` 类不可见。检查以下代码：
- en: '![](442fig02_alt.jpg)'
  id: totrans-728
  prefs: []
  type: TYPE_IMG
  zh: '![图片](442fig02_alt.jpg)'
- en: 'Let’s see what happens if you modify the class `Employee` to implement the
    interface `MobileAppExpert`, as follows:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果将 `Employee` 类修改为实现 `MobileAppExpert` 接口会发生什么，如下所示：
- en: '[PRE33]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now the classes `Programmer` and `Manager` can just extend the class `Employee`.
    They no longer need to implement the interface `MobileAppExpert` because their
    base class, `Employee`, implements it:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，类 `Programmer` 和 `Manager` 只需扩展 `Employee` 类。它们不再需要实现 `MobileAppExpert` 接口，因为它们的基类
    `Employee` 实现了它：
- en: '[PRE34]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With the modified code, the new relationships among the classes `Employee`,
    `Manager`, and `Programmer` and the interface `MobileAppExpert` are shown in [figure
    6.30](#ch06fig30).
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改后的代码，展示了类 `Employee`、`Manager` 和 `Programmer` 以及接口 `MobileAppExpert` 之间新的关系，如图
    [6.30](#ch06fig30) 所示。
- en: Figure 6.30\. Modified relationships among the classes `Employee`, `Manager`,
    and `Programmer`, and the interface `MobileAppExpert`
  id: totrans-734
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.30\. `Employee`、`Manager` 和 `Programmer` 类以及接口 `MobileAppExpert` 之间的修改后的关系
- en: '![](06fig30_alt.jpg)'
  id: totrans-735
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig30_alt.jpg)'
- en: 'Let’s try to access the method `deliverMobileApp` using a reference variable
    of type `Employee` class, as follows:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用 `Employee` 类型的引用变量来访问 `deliverMobileApp` 方法，如下所示：
- en: '![](444fig01_alt.jpg)'
  id: totrans-737
  prefs: []
  type: TYPE_IMG
  zh: '![图片](444fig01_alt.jpg)'
- en: '[Figure 6.31](#ch06fig31) shows what’s accessible to the variable `expert1`.'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.31](#ch06fig31) 展示了变量 `expert1` 可以访问的内容。'
- en: Figure 6.31\. What’s accessible to the variable `expert1`
  id: totrans-739
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.31\. 变量 `expert1` 可以访问的内容
- en: '![](06fig31_alt.jpg)'
  id: totrans-740
  prefs: []
  type: TYPE_IMG
  zh: '![图片](06fig31_alt.jpg)'
- en: '|  |'
  id: totrans-741
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-742
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Watch out for overloaded methods that seem to participate in polymorphism—overloaded
    methods don’t participate in polymorphism. Only overridden methods—methods with
    the same method signatures—participate in polymorphism.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 当心那些看似参与多态的过度载方法——过度载方法并不参与多态。只有重写的方法——具有相同方法签名的那些方法——才参与多态。
- en: '|  |'
  id: totrans-744
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Polymorphism with default methods
  id: totrans-745
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 默认方法的多态
- en: 'When a class implements an interface that defines a default method, the class
    might or might not override the default method. In the following example, the
    class `Manager-` overrides the default method `submitInterviewStatus`, defined
    in the interface `Interviewer`:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类实现了一个定义默认方法的接口时，该类可能或可能不会重写默认方法。在以下示例中，类 `Manager` 重写了接口 `Interviewer` 中定义的默认方法
    `submitInterviewStatus`：
- en: '[PRE35]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here’s the output of the preceding code:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上述代码的输出：
- en: '[PRE36]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, even though the class `Project` uses a reference variable
    of the interface `Interviewer` and the class `Manager` to refer to a `Manager`
    instance, the call to `submitInterviewStatus()` is delegated to the overriding
    method defined in the class `Manager`.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，尽管 `Project` 类使用接口 `Interviewer` 和 `Manager` 类的引用变量来引用 `Manager` 实例，但
    `submitInterviewStatus()` 的调用被委派给了在 `Manager` 类中定义的重写方法。
- en: Here’s an interesting situation. Imagine that two interfaces, `BaseInterface1`
    and `BaseInterface2`, define default methods with the same name, `getName()`.
    These interfaces are extended by another interface, `MyInterface`, which overrides
    the method `getName`. Now, imagine that a class, `MyClass`, implements all three
    interfaces. What is the output when you call `getName()` on the `MyClass` instance?
    Will it compile?
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的情况。想象有两个接口，`BaseInterface1` 和 `BaseInterface2`，它们定义了具有相同名称的默认方法，`getName()`。这两个接口被另一个接口
    `MyInterface` 扩展，该接口重写了 `getName` 方法。现在，想象一个类 `MyClass` 实现了这三个接口。当你调用 `MyClass`
    实例上的 `getName()` 时，输出是什么？它能否编译？
- en: '[PRE37]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding code compiles successfully and outputs `Just me`. Using the interface
    names `BaseInterface1`, `BaseInterface2` in the declaration of class `MyClass`
    is redundant (duplicate) because `MyInterface` already extends `BaseInterface1`
    and `Base-Interface2`. So `MyClass` doesn’t inherit three implementations of the
    default method `getName`. It inherits just one of them, `getName()`, which is
    defined in the interface `MyInterface`.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码编译成功并输出 `Just me`。在类 `MyClass` 的声明中使用接口名称 `BaseInterface1` 和 `BaseInterface2`
    是多余的（重复的），因为 `MyInterface` 已经扩展了 `BaseInterface1` 和 `Base-Interface2`。所以 `MyClass`
    只继承了一个默认方法 `getName` 的实现，而不是三个。它继承的是在接口 `MyInterface` 中定义的 `getName()`。
- en: 6.7\. Simple lambda expressions
  id: totrans-754
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7\. 简单的 Lambda 表达式
- en: '|  |'
  id: totrans-755
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[9.5] Write a simple Lambda expression that consumes a Lambda Predicate expression'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.5] 编写一个简单的 Lambda 表达式，它消费一个 Lambda 断言表达式'
- en: '|  |'
  id: totrans-757
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This exam includes working with simple lambda expressions to enable you to get
    started with *functional-style programming* in Java. Functional programming enables
    you to write declarative code. It lets you define *what* to do, rather than focusing
    on *how* to do it. With functional programming, you can pass code to your methods
    as arguments. Let’s get the hang of it by comparing passing of variable or literal
    values to methods with passing code to them.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 本考试包括使用简单的 Lambda 表达式，以便你能够开始使用 Java 中的 *函数式编程风格*。函数式编程使你能够编写声明式代码。它让你定义 *要做什么*，而不是专注于
    *如何做*。使用函数式编程，你可以将代码作为参数传递给你的方法。让我们通过比较向方法传递变量或文字值与向它们传递代码来熟悉它。
- en: 6.7.1\. Comparing passing values with passing code to methods
  id: totrans-759
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.7.1\. 比较向方法传递值与向方法传递代码
- en: 'Imagine that you need to write methods to print values of a range of numbers,
    like 1 to 10, 10 to 20, and so on, *without* passing parameters to methods. Here’s
    how you might write your code:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要编写方法来打印一系列数字的值，比如 1 到 10，10 到 20，等等，*而不*需要将参数传递给方法。下面是你可能编写的代码：
- en: '[PRE38]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Because you know how to define method parameters for a method, you’re sure
    to think it’s insane to define the methods as shown in the preceding code. So
    here’s a method that accepts method arguments:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你知道如何为方法定义方法参数，你肯定会认为定义前面代码中的方法是不理智的。所以这里有一个接受方法参数的方法：
- en: '[PRE39]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here’s how you would call the methods to print integers, defined in the preceding
    code:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何调用前面代码中定义的打印整数的方法的示例：
- en: '[PRE40]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note how you can define just *one* method, `printNumbers`, and call it with
    multiple values. Let’s apply the same logic to defining just one method, passing
    it code so that we don’t need its multiple implementations.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你可以只定义一个方法，`printNumbers`，并用多个值调用它。让我们应用相同的逻辑来定义一个方法，传递代码，这样我们就不需要它的多个实现了。
- en: 'Before using lambdas, let’s work with an example that doesn’t use them, to
    highlight their benefits. The following example defines the class `Emp` (with
    a few instance variables). It also defines an interface, `Validate`, which defines
    just one `abstract` method, `check`. It’s meant to check the state of an `Emp`
    instance and return a `boolean` value:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Lambda 之前，让我们用一个不使用它们的例子来工作，以突出其优点。以下示例定义了一个类 `Emp`（包含一些实例变量）。它还定义了一个接口
    `Validate`，该接口定义了一个 `abstract` 方法 `check`。它的目的是检查 `Emp` 实例的状态并返回一个 `boolean` 值：
- en: '[PRE41]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To use the interface `Validate` (without using lambdas), you can either define
    a class that implements it or define anonymous classes. Because anonymous classes
    aren’t on this exam, I’ll define a class that implements the interface `Validate`.
    In the following code, the class `ValidatePerformanceRating` checks an `Emp` instance,
    returning `true` if the `performanceRating` of an `Emp` instance is greater than
    or equal to 5:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用接口 `Validate`（而不使用 Lambda），你可以定义一个实现它的类或定义匿名类。因为匿名类不在这个考试中，我将定义一个实现接口 `Validate`
    的类。在以下代码中，类 `ValidatePerformanceRating` 检查一个 `Emp` 实例，如果 `Emp` 实例的 `performanceRating`
    大于或等于 5，则返回 `true`：
- en: '[PRE42]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'What happens if you want to check another attribute of an `Emp` instance, say,
    `name`? You’ll need another class:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要检查 `Emp` 实例的另一个属性，比如 `name`，你需要另一个类：
- en: '[PRE43]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Compare the preceding classes—`ValidateName` and `ValidatePerformanceRating`—with
    multiple `print`*`XXX`* methods in the class `NoMethodParameters`. Note how just
    the `boolean` condition is changing in the `check` methods in the classes `ValidateName`
    and `ValidatePerformanceRating`. Here’s how you would use instances of `ValidateName`
    or `ValidatePerformanceRating` in a method, say, `filter`:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的类——`ValidateName` 和 `ValidatePerformanceRating`——与类 `NoMethodParameters`
    中的多个 `print`*`XXX`* 方法进行比较。注意在 `ValidateName` 和 `ValidatePerformanceRating` 类的
    `check` 方法中，只是 `boolean` 条件在变化。下面是如何在方法中使用 `ValidateName` 或 `ValidatePerformanceRating`
    实例的示例，比如 `filter` 方法：
- en: '[PRE44]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding code, the `filter` method accepts an `ArrayList` of `Emp` and
    outputs the ones that return `true` when an `Emp` instance is checked with the
    method `check` of the interface `Validate`.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`filter` 方法接受一个 `Emp` 的 `ArrayList` 并输出那些通过使用接口 `Validate` 的 `check`
    方法检查 `Emp` 实例时返回 `true` 的实例。
- en: 'As mentioned previously, you’ll need to create multiple classes (that implement
    the interface `Validate`) to use different validity rules. Apart from being mostly
    repetitive, it’s verbose too. Lambdas to the rescue! Let’s remove the definition
    of the classes `ValidateName` and `ValidatePerformanceRating`. To define the validation
    condition, we’ll use lambdas (the modified code is in bold):'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你需要创建多个类（实现接口`Validate`）以使用不同的有效性规则。除了大部分是重复的，它还非常冗长。Lambdas来拯救！让我们删除`ValidateName`和`ValidatePerformanceRating`类的定义。为了定义验证条件，我们将使用lambda（修改后的代码用粗体表示）：
- en: '![](448fig01_alt.jpg)'
  id: totrans-777
  prefs: []
  type: TYPE_IMG
  zh: '![448fig01_alt.jpg](448fig01_alt.jpg)'
- en: In the preceding code, there isn’t any change to the method `filter` that accepts
    a method parameter of type `Validate` (an interface). The code at ![](num-1.jpg)
    defines a lambda expression. It defines code to be passed to the method `filter`.
    Map the lambda expression to the method signature of `check` in `Validate`. The
    method `check` accepts only one method parameter and so does the lambda expression,
    that is, `(e)`. The method `check` returns a `boolean` value and so does the expression
    `e.getPerformanceRating() >= 5` in the lambda expression.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，对接受类型为`Validate`（一个接口）的方法参数的`filter`方法（没有变化）。在![num-1.jpg]处的代码定义了一个lambda表达式。它定义了要传递给`filter`方法的代码。将lambda表达式映射到`Validate`中的`check`方法签名。`check`方法接受一个方法参数，lambda表达式也是如此，即`(e)`。`check`方法返回一个`boolean`值，lambda表达式中的表达式`e.getPerformanceRating()
    >= 5`也是如此。
- en: '|  |'
  id: totrans-779
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-780
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Lambdas work only with *functional interfaces*—interfaces that define exactly
    one `abstract` method.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: Lambdas仅与*功能接口*一起工作——定义了恰好一个`抽象`方法的接口。
- en: '|  |'
  id: totrans-782
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Let’s dive into the details of lambda expressions in the next section.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节深入探讨lambda表达式的细节。
- en: 6.7.2\. Syntax of lambda expressions
  id: totrans-784
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.7.2\. Lambda表达式的语法
- en: 'Let’s revisit the lambda expression used in the previous expression:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下之前表达式中使用的lambda表达式：
- en: '[PRE45]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding code includes only the mandatory sections of a lambda, as shown
    in [figure 6.32](#ch06fig32).
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码仅包含lambda表达式的必要部分，如图6.32所示。
- en: Figure 6.32\. A Lambda expression and its mandatory sections
  id: totrans-788
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.32\. 一个Lambda表达式及其必要部分
- en: '![](06fig32.jpg)'
  id: totrans-789
  prefs: []
  type: TYPE_IMG
  zh: '![06fig32.jpg](06fig32.jpg)'
- en: 'Each lambda expression has multiple optional and mandatory sections:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 每个lambda表达式都有多个可选和必要部分：
- en: Parameter type (optional)
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数类型（可选）
- en: Parameter name (mandatory)
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数名称（必要）
- en: Arrow (mandatory)
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头（必要）
- en: Curly braces (optional)
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大括号（可选）
- en: Keyword `return` (optional)
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字`return`（可选）
- en: Lambda body (mandatory)
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda体（必要）
- en: 'The following are valid variations of the preceding lambda expression (modifications
    in bold):'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面lambda表达式的有效变体（修改用粗体表示）：
- en: '[PRE46]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'On the exam, you’ll need to identify invalid lambda expressions. The return
    value of the lambda expression must match or must be compatible with the return
    value of the only `abstract` method in the interface. The method `check` in the
    interface `Validate` declares its return type as `boolean`. So the following would
    be invalid:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 在考试中，你需要识别无效的lambda表达式。lambda表达式的返回值必须与接口中唯一的`抽象`方法的返回值匹配或兼容。接口`Validate`中的`check`方法声明其返回类型为`boolean`。因此以下将是无效的：
- en: '![](450fig01_alt.jpg)'
  id: totrans-800
  prefs: []
  type: TYPE_IMG
  zh: '![450fig01_alt.jpg](450fig01_alt.jpg)'
- en: 'If you try to pass an incorrect count of method parameters to the lambda expression,
    the code won’t compile:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试向lambda表达式传递错误数量的方法参数，代码将无法编译：
- en: '![](450fig02_alt.jpg)'
  id: totrans-802
  prefs: []
  type: TYPE_IMG
  zh: '![450fig02_alt.jpg](450fig02_alt.jpg)'
- en: Java 8 has added multiple functional interfaces for your convenience. This exam
    covers just one of these—interface `Predicate`—discussed in the next section.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8为您的方便添加了多个功能接口。本考试仅涵盖其中之一——接口`Predicate`，将在下一节讨论。
- en: 6.7.3\. Interface Predicate
  id: totrans-804
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.7.3\. 接口谓词
- en: '`Predicate` is a functional interface. Here’s the partial definition of this
    interface:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '`Predicate`是一个功能接口。以下是该接口的部分定义：'
- en: '[PRE47]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding code, the class declaration includes `<T>`, which declares
    that `Predicate-` is a generic interface, which isn’t limited to a particular
    type. It can be used with multiple types. Generics are covered in detail in the
    OCP Java SE 8 Programmer II exam.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，类声明包括`<T>`，这表明`Predicate-`是一个泛型接口，它不受特定类型的限制。它可以与多种类型一起使用。泛型在OCP Java
    SE 8程序员II考试中详细讨论。
- en: 'To use `Predicate` in your code, your method must accept a parameter of type
    `Predicate` and you must use its public method `test` to evaluate an argument.
    Let’s modify the example used in [section 6.7.1](#ch06lev2sec28) to use `Predicate`
    instead of `Validate` (changes in bold):'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中使用 `Predicate`，你的方法必须接受类型为 `Predicate` 的参数，并且必须使用其公共方法 `test` 来评估一个参数。让我们修改
    [6.7.1 节](#ch06lev2sec28) 中使用的示例，用 `Predicate` 代替 `Validate`（加粗部分）：
- en: '[PRE48]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Java 8 has also modified many of its existing API methods, which work with
    functional interfaces like `Predicate`. For example, the class `ArrayList` defines
    the method `removeIf`, which accepts a method parameter of type `Predicate`. The
    following example shows the use of `removeIf`:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 也修改了许多现有的 API 方法，这些方法与函数式接口如 `Predicate` 一起工作。例如，`ArrayList` 类定义了 `removeIf`
    方法，该方法接受类型为 `Predicate` 的方法参数。以下示例展示了 `removeIf` 的用法：
- en: '[PRE49]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here’s the output of the preceding code:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述代码的输出：
- en: '[PRE50]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see, the use of `Predicate` and lambda expressions in the preceding
    code enabled you to write code declaratively.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，前述代码中 `Predicate` 和 lambda 表达式的使用使你能够以声明式的方式编写代码。
- en: 6.8\. Summary
  id: totrans-815
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.8. 概述
- en: 'We started the chapter with a discussion of inheritance and polymorphism, using
    an example from everyday life: all creatures inherit the properties and behavior
    of their parents, and the same action (such as *reproduce*) may have different
    meanings for different species. Inheritance enables the reuse of existing code,
    and it can be implemented using classes and interfaces. A class can’t extend more
    than one class, but it can implement more than one interface. Inheriting a class
    is also called *subclassing*, and the inherited class is referred to as the *base*
    or *parent class*. A class that inherits another class or implements an interface
    is called a *derived class* or *subclass*.'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以日常生活中的一个例子开始本章的讨论：所有生物都继承其父母的特点和行为，同样的行为（如 *繁殖*）对不同物种可能有不同的含义。继承使得现有代码可以被重用，并且可以使用类和接口来实现。一个类不能扩展超过一个类，但它可以实现多个接口。继承一个类也称为
    *子类化*，被继承的类被称为 *基类* 或 *父类*。继承另一个类或实现接口的类被称为 *派生类* 或 *子类*。
- en: Just as it’s common to address someone using a last name or family name, an
    object of a derived class can be referred to with a variable of a base class or
    an interface that it implements. But when you refer to an object using a variable
    of the base class, the variable can access only the members defined in the base
    class. Similarly, a variable of type interface can access only the members defined
    in that interface. Even with this limitation, you may wish to refer to objects
    using variables of their base class to work with multiple objects that have common
    base classes.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 正如使用姓氏或家族名称称呼某人一样，派生类的对象可以用基类或它实现的接口的变量来引用。但是，当你使用基类的变量来引用对象时，该变量只能访问在基类中定义的成员。同样，类型为接口的变量只能访问在该接口中定义的成员。即使有这种限制，你也可能希望使用基类的变量来引用对象，以便与具有共同基类的多个对象一起工作。
- en: Objects of related classes—the ones that share an inheritance relationship—can
    be cast to another object. You may wish to cast an object when you wish to access
    its members that aren’t available by default using the variable that’s used to
    refer to the object.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 相关类的对象——那些具有继承关系的对象——可以被转换为另一个对象。当你希望通过引用对象的变量访问默认情况下不可用的成员时，你可能希望进行类型转换。
- en: The keywords `this` and `super` are object references and are used to access
    an object and its base class, respectively. You can use the keyword `this` to
    access a class’s variables, methods, and constructors. Similarly, the keyword
    `super` is used to access a base class’s variables, methods, and constructors.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `this` 和 `super` 是对象引用，分别用于访问对象及其基类。你可以使用关键字 `this` 来访问类的变量、方法和构造函数。同样，关键字
    `super` 用于访问基类的变量、方法和构造函数。
- en: Polymorphism is the ability of objects to execute methods defined in a superclass
    or base class, depending on their type. Classes that share an inheritance relationship
    exhibit polymorphism. The polymorphic method should be defined in both the base
    class and the inherited class.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是对象执行在超类或基类中定义的方法的能力，这取决于它们的类型。具有继承关系的类表现出多态性。多态方法应在基类和继承类中定义。
- en: You can implement polymorphism by using either classes or interfaces. In the
    case of polymorphism with classes, the base class can be either an abstract class
    or a concrete class. The method in question here also need not be an `abstract`
    method. When you implement polymorphism using interfaces, you must use an `abstract`
    method from the interface.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用类或接口来实现多态。在类的多态情况下，基类可以是抽象类或具体类。这里的方法也不一定是 `abstract` 方法。当你使用接口实现多态时，你必须使用接口中的
    `abstract` 方法。
- en: Java 8 enables you to write code declaratively. We covered lambda expressions,
    their syntax, and the interface `Predicate`.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 允许你以声明性方式编写代码。我们涵盖了 lambda 表达式、它们的语法以及 `Predicate` 接口。
- en: 6.9\. Review notes
  id: totrans-823
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.9. 复习笔记
- en: 'Inheritance with classes:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 类的继承：
- en: A class can inherit the properties and behavior of another class.
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以继承另一个类的属性和行为。
- en: A class can implement multiple interfaces.
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以实现多个接口。
- en: An interface can inherit zero or more interfaces. An interface can’t inherit
    a class.
  id: totrans-827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接口可以继承零个或多个接口。一个接口不能继承一个类。
- en: Inheritance enables you to use existing code.
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承使你能够使用现有代码。
- en: Inheriting a class is also known as subclassing.
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承一个类也称为子类化。
- en: A class that inherits another class is called a derived class or subclass.
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承另一个类的类被称为派生类或子类。
- en: A class that’s inherited is called a parent or base class or superclass.
  id: totrans-831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承的类被称为父类或基类或超类。
- en: Private members of a base class can’t be inherited in the derived class.
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类的私有成员不能在派生类中被继承。
- en: A derived class can only inherit members with the default access modifier if
    both the base class and the derived class are in the same package.
  id: totrans-833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果基类和派生类在同一个包中，派生类只能继承具有默认访问修饰符的成员。
- en: A class uses the keyword `extends` to inherit a class.
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类使用关键字 `extends` 来继承一个类。
- en: A class uses the keyword `implements` to implement an interface.
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类使用关键字 `implements` 来实现一个接口。
- en: A class can implement multiple interfaces but can inherit only one class.
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以实现多个接口，但不能继承多个类。
- en: An `abstract` class can inherit a concrete class, and a concrete class can inherit
    an `abstract` class.
  id: totrans-837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `abstract` 类可以继承一个具体类，一个具体类也可以继承一个 `abstract` 类。
- en: 'Use interfaces:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 使用接口：
- en: An interface uses the keyword `extends` to inherit another interface.
  id: totrans-839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口使用关键字 `extends` 来继承另一个接口。
- en: An interface can extend multiple interfaces.
  id: totrans-840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接口可以继承多个接口。
- en: Although interfaces can define a default implementation for their methods in
    Java 8, it’s not compulsory for them to do so. Interfaces can also define `abstract`
    methods.
  id: totrans-841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然在 Java 8 中接口可以为它们的方法定义默认实现，但这不是强制的。接口也可以定义 `abstract` 方法。
- en: The declaration of an interface can’t include a class name. An interface can
    never extend any class.
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口的声明不能包含类名。一个接口永远不能继承任何类。
- en: 'All the top-level Java types (classes, enums, and interfaces) can be declared
    using only two access levels: public and default. Inner or nested types can be
    declared using any access level.'
  id: totrans-843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的顶级 Java 类型（类、枚举和接口）只能使用两种访问级别进行声明：public 和 default。内部或嵌套类型可以使用任何访问级别进行声明。
- en: The `strictfp` keyword guarantees that results of all floating-point calculations
    are identical on all platforms.
  id: totrans-844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strictfp` 关键字保证了所有平台上的所有浮点计算结果都是相同的。'
- en: Interface methods are implicitly abstract. To define default or `static` methods,
    you must use the keyword `default` or `static`.
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口方法隐式地是抽象的。要定义默认或 `static` 方法，必须使用关键字 `default` 或 `static`。
- en: Interface methods can define an implementation by using default methods.
  id: totrans-846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口方法可以通过使用默认方法来定义一个实现。
- en: A `static` method in an interface can’t be called using a reference variable.
    It must be called using the interface name.
  id: totrans-847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口中的 `static` 方法不能使用引用变量来调用。它必须使用接口名称来调用。
- en: Unlike an interface, if you define a `static` method in a base class, it can
    be accessed using either a reference variable or the class name.
  id: totrans-848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与接口不同，如果你在基类中定义了一个 `static` 方法，它可以通过引用变量或类名来访问。
- en: You must implement an `abstract` method of an interface using the explicit access
    modifier `public`.
  id: totrans-849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须使用显式访问修饰符 `public` 来实现接口中的 `abstract` 方法。
- en: While overriding a default method, you must not use the keyword `default`. The
    rules for overriding default and regular methods are same.
  id: totrans-850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在覆盖默认方法时，你不能使用关键字 `default`。覆盖默认方法和常规方法的规则是相同的。
- en: '`static` methods in a class and the interface that it implements are not related
    to each other. A `static` method in a class doesn’t hide or override the `static`
    method in the interface that it implements.'
  id: totrans-851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类中的`static`方法和它实现的接口之间没有关系。类中的`static`方法不会隐藏或覆盖它实现的接口中的`static`方法。
- en: Because a derived class may inherit different implementations for the same method
    signature from multiple base classes, multiple inheritance is not allowed in Java.
  id: totrans-852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于派生类可能从多个基类继承对同一方法签名的不同实现，Java不允许多重继承。
- en: 'A class can extend multiple interfaces, only if a set of rules is adhered to:'
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遵循一组规则，一个类可以扩展多个接口。
- en: A class can implement multiple interfaces with the same constant names only
    if the reference to the constants is not ambiguous.
  id: totrans-854
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类只有在引用常量不模糊的情况下，才能实现具有相同常量名称的多个接口。
- en: A class can implement multiple interfaces with the same `abstract` method names
    if they have the same signature or form an overloaded set of methods.
  id: totrans-855
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类如果具有相同的签名或形成一组重载的方法集，则可以实现对具有相同`abstract`方法名称的多个接口的实现。
- en: A class can implement multiple interfaces with the same default method name
    if it overrides its default implementation.
  id: totrans-856
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类覆盖了其默认实现，则它可以实现对具有相同默认方法名称的多个接口的实现。
- en: A class can implement multiple interfaces with the same `static` method name
    regardless of their return types or signature.
  id: totrans-857
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以实现对具有相同`static`方法名称的多个接口的实现，无论它们的返回类型或签名如何。
- en: When an interface extends multiple interfaces, Java ensures that it doesn’t
    inherit multiple method implementations for the same method.
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个接口扩展多个接口时，Java确保它不会为同一方法继承多个方法实现。
- en: An interface can extend multiple interfaces that define `static` methods with
    the same name; the signatures of these methods don’t matter.
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口可以扩展多个定义了具有相同名称的`static`方法的接口；这些方法的签名无关紧要。
- en: The variables of an interface are implicitly public, final, and static.
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口中的变量默认是公开的、最终的和静态的。
- en: The methods of an interface are implicitly public.
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口中的方法默认是公开的。
- en: An interface can’t define any constructors.
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口不能定义任何构造函数。
- en: 'Reference variable and object types:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 引用变量和对象类型：
- en: With inheritance, you can also refer to an object of a derived class using a
    variable of a base class or interface.
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过继承，你也可以使用基类或接口的变量来引用派生类的对象。
- en: An object of a base class can’t be referred to using a reference variable of
    its derived class.
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能使用派生类的引用变量来引用基类对象。
- en: When an object is referred to by a reference variable of a base class, the reference
    variable can access only the variables and members that are defined in the base
    class.
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个对象被基类的引用变量引用时，该引用变量只能访问在基类中定义的变量和成员。
- en: When an object is referred to by a reference variable of an interface implemented
    by a class, the reference variable can access only the variables and methods defined
    in the interface.
  id: totrans-867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个对象被实现接口的类的引用变量引用时，该引用变量只能访问接口中定义的变量和方法。
- en: You may need to access an object of a derived class using a reference variable
    of the base class to group and use all the classes with common parent classes
    or interfaces.
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能需要使用基类的引用变量来访问派生类的对象，以便将具有共同父类或接口的所有类分组和使用。
- en: 'The need for casting:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 转型的需求：
- en: Casting is the process of forcefully making a variable behave as a variable
    of another type.
  id: totrans-870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转型是将变量强制表现为另一种类型变量的过程。
- en: If the class `Manager` extends the class `Employee`, and a reference variable
    `emp` of type `Employee` is used to refer to an object of the class `Manager`,
    `((Manager)emp)` will cast the variable `emp` to `Manager`.
  id: totrans-871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类`Manager`扩展了类`Employee`，并且使用类型为`Employee`的引用变量`emp`来引用类`Manager`的对象，`((Manager)emp)`将把变量`emp`转型为`Manager`。
- en: 'Using `super` and `this` to access objects and constructors:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`super`和`this`来访问对象和构造函数：
- en: The keywords `super` and `this` are object references. These variables are defined
    and initialized by the JVM for every object in its memory.
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字`super`和`this`是对象引用。这些变量由JVM为内存中的每个对象定义和初始化。
- en: The `this` reference always points to an object’s *own instance*.
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this`引用始终指向对象的*自身实例*。'
- en: You can use the keyword `this` to refer to all methods and variables that are
    accessible to a class.
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用关键字`this`来引用类可访问的所有方法和变量。
- en: If a method defines a local variable or method parameter with the same name
    as an instance variable, the keyword `this` must be used to access the instance
    variable in the method.
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个方法定义了一个与实例变量具有相同名称的局部变量或方法参数，则必须在方法中使用`this`关键字来访问实例变量。
- en: You can call one constructor from another constructor by using the keyword `this`.
  id: totrans-877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`this`关键字从一个构造函数调用另一个构造函数。
- en: With Java 8, you can use the keyword `this` in a default method to access the
    methods of an interface and its constants.
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java 8，你可以在默认方法中使用`this`关键字来访问接口的方法和常量。
- en: The static methods of an interface can’t be accessed using the keyword `this`.
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口的静态方法不能使用`this`关键字访问。
- en: '`super`, an object reference, refers to the parent class or the base class
    of a class.'
  id: totrans-880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`super`，一个对象引用，指向类的父类或基类。'
- en: The reference variable `super` can be used to access a variable or method from
    the base class if there’s a clash between these names. This situation normally
    occurs when a derived class defines variables and methods with the same names
    as in the base class.
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在名称冲突，引用变量`super`可以用来访问基类中的变量或方法。这种情况通常发生在派生类定义了与基类中相同的变量和方法时。
- en: The reference variable `super` can also be used to refer to the constructors
    of the direct parent class in a derived class.
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用变量`super`也可以用来在派生类中引用直接父类的构造函数。
- en: 'Polymorphism with classes:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 类的多态：
- en: The literal meaning of the word *polymorphism* is “many forms.”
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “多态”一词的字面意思是“多种形式”。
- en: In Java, polymorphism comes into the picture when there’s an inheritance relationship
    between classes, and both the base and derived classes define methods with the
    same name.
  id: totrans-885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中，当类之间存在继承关系，并且基类和派生类都定义了具有相同名称的方法时，就会出现多态。
- en: The polymorphic methods are also called overridden methods.
  id: totrans-886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态方法也称为覆盖方法。
- en: Overridden methods should define methods with the same name, same argument list,
    and same list of method parameters. The return type of the overriding method can
    be the same, or it can be a subclass of the return type of the overridden method
    in the base class, which is also known as the covariant return type.
  id: totrans-887
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖方法应定义具有相同名称、相同参数列表和相同方法参数列表的方法。覆盖方法的返回类型可以是相同的，也可以是基类中覆盖方法的返回类型的子类，这称为协变返回类型。
- en: Access modifiers for an overriding method can be equally or less restrictive
    but can’t be more restrictive than the method being overridden.
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖方法的访问修饰符可以是同等或更少的限制，但不能比被覆盖的方法更严格。
- en: A derived class is said to override a method in the base class if it defines
    a method with the same name, same parameter list, and same return type as in the
    derived class.
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果派生类定义了一个与基类中相同名称、相同参数列表和相同返回类型的方法，则称派生类覆盖了基类中的方法。
- en: If a method defined in a base class is overloaded in the derived classes, then
    these two methods (in the base class and the derived class) are not called polymorphic
    methods.
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在基类中定义的方法在派生类中被重载，那么这两个方法（基类和派生类中的方法）不是多态方法。
- en: When implementing polymorphism with classes, a method defined in the base class
    may or may not be `abstract`.
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用类实现多态时，基类中定义的方法可能是`abstract`的，也可能不是。
- en: When implementing polymorphism with interfaces, a method defined in the base
    interface could be an `abstract` method or a non-`abstract` method with a default
    implementation.
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用接口实现多态时，基接口中定义的方法可以是`abstract`方法，也可以是非`abstract`方法，并具有默认实现。
- en: '`Static` methods in interfaces don’t participate in polymorphism.'
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口中的`Static`方法不参与多态。
- en: 'Simple lambda expressions:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的lambda表达式：
- en: Lambdas work only with functional interfaces—interfaces that define exactly
    one `abstract` method.
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式仅与功能接口一起使用——定义了恰好一个`abstract`方法的接口。
- en: 'Each lambda expression has multiple optional and mandatory sections:'
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个lambda表达式都有多个可选和必填部分：
- en: Parameter type (optional)
  id: totrans-897
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数类型（可选）
- en: Parameter name (mandatory)
  id: totrans-898
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数名称（必填）
- en: Arrow (mandatory)
  id: totrans-899
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头（必填）
- en: Curly braces (optional)
  id: totrans-900
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花括号（可选）
- en: Keyword `return` (optional)
  id: totrans-901
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字`return`（可选）
- en: Lambda body (mandatory)
  id: totrans-902
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda体（必填）
- en: 6.10\. Sample exam questions
  id: totrans-903
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.10. 样例考试问题
- en: '**[Q6-1.](#ch06qa2q0a1)**'
  id: totrans-904
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-1.](#ch06qa2q0a1)**'
- en: ''
  id: totrans-905
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-906
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-907
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-908
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ''
  id: totrans-909
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-910
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ''
  id: totrans-911
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-912
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-913
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ''
  id: totrans-914
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-915
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-916
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ''
  id: totrans-917
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-918
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: None of the above
  id: totrans-919
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆非
- en: '**[Q6-2.](#ch06qa2q0a2)**'
  id: totrans-920
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-2.](#ch06qa2q0a2)**'
- en: ''
  id: totrans-921
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given the following code, select the correct statements:'
  id: totrans-922
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下代码，选择正确的语句：
- en: ''
  id: totrans-923
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-924
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ''
  id: totrans-925
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The output of the code is
  id: totrans-926
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的输出是
- en: ''
  id: totrans-927
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-928
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ''
  id: totrans-929
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-930
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The output of the code is
  id: totrans-931
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的输出是
- en: ''
  id: totrans-932
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-933
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ''
  id: totrans-934
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-935
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The output of the code is
  id: totrans-936
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的输出是
- en: ''
  id: totrans-937
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-938
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ''
  id: totrans-939
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-940
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The code fails to compile.
  id: totrans-941
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码无法编译。
- en: '**[Q6-3.](#ch06qa2q0a3)**'
  id: totrans-942
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-3.](#ch06qa2q0a3)**'
- en: ''
  id: totrans-943
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Examine the following code and select the correct method declaration to be
    inserted at `//INSERT CODE HERE`:'
  id: totrans-944
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查以下代码，并选择正确的`//INSERT CODE HERE`处的代码声明：
- en: ''
  id: totrans-945
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-946
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ''
  id: totrans-947
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`void walk(Movable movable) {`'
  id: totrans-948
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`void walk(Movable movable) {`'
- en: '`void walk(Person movable) {`'
  id: totrans-949
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`void walk(Person movable) {`'
- en: '`void walk(Vehicle movable) {`'
  id: totrans-950
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`void walk(Vehicle movable) {`'
- en: '`void walk() {`'
  id: totrans-951
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`void walk() {`'
- en: '**[Q6-4.](#ch06qa2q0a4)**'
  id: totrans-952
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-4.](#ch06qa2q0a4)**'
- en: ''
  id: totrans-953
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Select the correct statements:'
  id: totrans-954
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选择正确的陈述：
- en: ''
  id: totrans-955
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Only an `abstract` class can be used as a base class to implement polymorphism
    with classes.
  id: totrans-956
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有`abstract`类可以作为基类，通过类实现多态。
- en: Polymorphic methods are also called overridden methods.
  id: totrans-957
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多态方法也被称为重写方法。
- en: In polymorphism, depending on the exact type of object, the JVM executes the
    appropriate method at compile time.
  id: totrans-958
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在多态中，根据对象的精确类型，JVM在编译时执行适当的方法。
- en: None of the above.
  id: totrans-959
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆非。
- en: '**[Q6-5.](#ch06qa2q0a5)**'
  id: totrans-960
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-5.](#ch06qa2q0a5)**'
- en: ''
  id: totrans-961
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given the following code, select the correct statements:'
  id: totrans-962
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下代码，选择正确的陈述：
- en: ''
  id: totrans-963
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-964
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ''
  id: totrans-965
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The code exhibits polymorphism with classes.
  id: totrans-966
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码通过类展示了多态性。
- en: The code exhibits polymorphism with interfaces.
  id: totrans-967
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码通过接口展示了多态性。
- en: The code exhibits polymorphism with classes and interfaces.
  id: totrans-968
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码通过类和接口展示了多态性。
- en: None of the above.
  id: totrans-969
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆非。
- en: '**[Q6-6.](#ch06qa2q0a6)**'
  id: totrans-970
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-6.](#ch06qa2q0a6)**'
- en: ''
  id: totrans-971
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following statements are true?
  id: totrans-972
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪些陈述是正确的？
- en: ''
  id: totrans-973
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Inheritance enables you to reuse existing code.
  id: totrans-974
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继承使您能够重用现有代码。
- en: Inheritance saves you from having to modify common code in multiple classes.
  id: totrans-975
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继承使您免于在多个类中修改通用代码。
- en: Polymorphism passes special instructions to the compiler so that the code can
    run on multiple platforms.
  id: totrans-976
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多态向编译器传递特殊指令，以便代码可以在多个平台上运行。
- en: Polymorphic methods can’t throw exceptions.
  id: totrans-977
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多态方法不能抛出异常。
- en: '**[Q6-7.](#ch06qa2q0a7)**'
  id: totrans-978
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-7.](#ch06qa2q0a7)**'
- en: ''
  id: totrans-979
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the following code, which of the options are true?
  id: totrans-980
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下代码，以下哪些选项是正确的？
- en: ''
  id: totrans-981
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-982
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE61]'
- en: ''
  id: totrans-983
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The method `orbit` defined in the classes `Satellite`, `Moon`, and `ArtificialSatellite`
    is polymorphic.
  id: totrans-984
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Satellite`、`Moon`和`ArtificialSatellite`类中定义的`orbit`方法是多态的。
- en: Only the method `orbit` defined in the classes `Satellite` and `Artificial-Satellite`
    is polymorphic.
  id: totrans-985
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有在`Satellite`和`Artificial-Satellite`类中定义的`orbit`方法是多态的。
- en: Only the method `orbit` defined in the class `ArtificialSatellite` is polymorphic.
  id: totrans-986
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有在`ArtificialSatellite`类中定义的`orbit`方法是多态的。
- en: None of the above.
  id: totrans-987
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆非。
- en: '**[Q6-8.](#ch06qa2q0a8)**'
  id: totrans-988
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-8.](#ch06qa2q0a8)**'
- en: ''
  id: totrans-989
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Examine the following code:'
  id: totrans-990
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查以下代码：
- en: ''
  id: totrans-991
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-992
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE62]'
- en: ''
  id: totrans-993
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following lines of code can be individually inserted at `//INSERT
    CODE HERE` so that the output of the code is as follows?
  id: totrans-994
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪行代码可以单独插入到`//INSERT CODE HERE`，以使代码的输出如下？
- en: ''
  id: totrans-995
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-996
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE63]'
- en: ''
  id: totrans-997
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Programmer b = new Programmer();`'
  id: totrans-998
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Programmer b = new Programmer();`'
- en: '`Programmer b = new Author();`'
  id: totrans-999
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Programmer b = new Author();`'
- en: '`Author b = new Author();`'
  id: totrans-1000
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Author b = new Author();`'
- en: '`Author b = new Programmer();`'
  id: totrans-1001
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Author b = new Programmer();`'
- en: '`Programmer b = ((Author)new Programmer());`'
  id: totrans-1002
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Programmer b = ((Author)new Programmer());`'
- en: '`Author b = ((Author)new Programmer());`'
  id: totrans-1003
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Author b = ((Author)new Programmer());`'
- en: '**[Q6-9.](#ch06qa2q0a9)**'
  id: totrans-1004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-9.](#ch06qa2q0a9)**'
- en: ''
  id: totrans-1005
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the following code, which of the options, when applied individually, will
    make it compile successfully?
  id: totrans-1006
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下代码，以下哪个选项单独应用时可以使代码成功编译？
- en: ''
  id: totrans-1007
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-1008
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE64]'
- en: ''
  id: totrans-1009
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify the code on line 2 to `interface Printable{`
  id: totrans-1010
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第2行将代码修改为`interface Printable{`
- en: Modify the code on line 3 to `publicStringprint();`
  id: totrans-1011
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第3行将`publicStringprint();`修改为`public void print();`
- en: Define the accessibility of the `print` methods to `public` on lines 6 and 9.
  id: totrans-1012
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第6行和第9行将`print`方法的可访问性定义为`public`。
- en: Modify the code on line 8 so that it implements only the interface `Printable`.
  id: totrans-1013
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第8行修改代码，使其仅实现`Printable`接口。
- en: '**[Q6-10.](#ch06qa2q0a10)**'
  id: totrans-1014
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-10.](#ch06qa2q0a10)**'
- en: ''
  id: totrans-1015
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1016
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1017
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-1018
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE65]'
- en: ''
  id: totrans-1019
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-1020
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE66]'
- en: ''
  id: totrans-1021
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1022
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-1023
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE67]'
- en: ''
  id: totrans-1024
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1025
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-1026
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE68]'
- en: ''
  id: totrans-1027
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1028
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-1029
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 6.11\. Answers to sample exam questions
  id: totrans-1030
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.11. 样本考试问题的答案
- en: '**[Q6-1.](#ch06qa1q1)**'
  id: totrans-1031
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-1.](#ch06qa1q1)**'
- en: ''
  id: totrans-1032
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1033
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1034
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-1035
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE70]'
- en: ''
  id: totrans-1036
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-1037
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE71]'
- en: ''
  id: totrans-1038
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1039
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-1040
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE72]'
- en: ''
  id: totrans-1041
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1042
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-1043
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE73]'
- en: ''
  id: totrans-1044
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1045
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: None of the above
  id: totrans-1046
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆非
- en: ''
  id: totrans-1047
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: a'
  id: totrans-1048
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：a
- en: ''
  id: totrans-1049
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Although the classes `Cat` and `Rabbit` seem to override the method
    `jump`, the class `Cat` doesn’t override the method `jump()` defined in the class
    `Animal`. The class `Cat` defines a method parameter with the method `jump`, which
    makes it an overloaded method, not an overridden method. Because the class `Cat`
    extends the class `Animal`, it has access to the following two overloaded `jump`
    methods:'
  id: totrans-1050
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：尽管 `Cat` 和 `Rabbit` 类看起来重写了 `jump` 方法，但 `Cat` 类没有重写 `Animal` 类中定义的 `jump()`
    方法。`Cat` 类定义了一个带有 `jump` 方法的参数，这使得它成为一个重载方法，而不是重写方法。因为 `Cat` 类扩展了 `Animal` 类，它有权访问以下两个重载的
    `jump` 方法：
- en: ''
  id: totrans-1051
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-1052
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE74]'
- en: ''
  id: totrans-1053
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following lines of code create an object of class `Cat` and assign it to
    a variable of type `Animal`:'
  id: totrans-1054
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码行创建了一个 `Cat` 类的实例并将其赋值给一个 `Animal` 类型的变量：
- en: ''
  id: totrans-1055
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-1056
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE75]'
- en: ''
  id: totrans-1057
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When you call the method `jump` on the previous object, it executes the method
    `jump`, which doesn’t accept any method parameters, printing the following value:'
  id: totrans-1058
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你调用先前对象的 `jump` 方法时，它执行了没有接受任何方法参数的 `jump` 方法，并打印以下值：
- en: ''
  id: totrans-1059
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-1060
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE76]'
- en: ''
  id: totrans-1061
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The following code will also print `Animal` and not `Cat`:'
  id: totrans-1062
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码将打印 `Animal` 而不是 `Cat`：
- en: ''
  id: totrans-1063
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-1064
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '**[Q6-2.](#ch06qa1q2)**'
  id: totrans-1065
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-2.](#ch06qa1q2)**'
- en: ''
  id: totrans-1066
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given the following code, select the correct statements:'
  id: totrans-1067
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下代码，选择正确的语句：
- en: ''
  id: totrans-1068
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-1069
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE78]'
- en: ''
  id: totrans-1070
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The output of the code is
  id: totrans-1071
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的输出是
- en: ''
  id: totrans-1072
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-1073
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: ''
  id: totrans-1074
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1075
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The output of the code is
  id: totrans-1076
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的输出是
- en: ''
  id: totrans-1077
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-1078
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: ''
  id: totrans-1079
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1080
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The output of the code is
  id: totrans-1081
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的输出是
- en: ''
  id: totrans-1082
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-1083
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: ''
  id: totrans-1084
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1085
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The code fails to compile.**'
  id: totrans-1086
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码无法编译。**'
- en: ''
  id: totrans-1087
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: d'
  id: totrans-1088
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：d
- en: ''
  id: totrans-1089
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Although the code seems to implement polymorphism using classes,
    note that neither of the classes `Rose` or `Lily` *extends* the class `Flower`.
    Hence, a variable of type `Flower` can’t be used to store objects of the classes
    `Rose` or `Lily`. The following lines of code will fail to compile:'
  id: totrans-1090
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：尽管代码似乎使用类实现了多态，但请注意，`Rose` 或 `Lily` 类都没有扩展 `Flower` 类。因此，类型为 `Flower` 的变量不能用来存储
    `Rose` 或 `Lily` 类的实例。以下代码行将无法编译：
- en: ''
  id: totrans-1091
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-1092
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '**[Q6-3.](#ch06qa1q3)**'
  id: totrans-1093
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-3.](#ch06qa1q3)**'
- en: ''
  id: totrans-1094
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Examine the following code and select the correct method declaration to be
    inserted at `//INSERT CODE HERE`:'
  id: totrans-1095
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查以下代码，并选择在 `//INSERT CODE HERE` 处插入的正确方法声明：
- en: ''
  id: totrans-1096
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-1097
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE83]'
- en: ''
  id: totrans-1098
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**`void walk(Movable movable) {`**'
  id: totrans-1099
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`void walk(Movable movable) {`**'
- en: '**`void walk(Person movable) {`**'
  id: totrans-1100
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`void walk(Person movable) {`**'
- en: '**`void walk(Vehicle movable) {`**'
  id: totrans-1101
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`void walk(Vehicle movable) {`**'
- en: '`void walk() {`'
  id: totrans-1102
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`void walk() {`'
- en: ''
  id: totrans-1103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: a, b, c'
  id: totrans-1104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：a, b, c
- en: ''
  id: totrans-1105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: You need to insert code in the class `Test` that makes the following
    line of code work:'
  id: totrans-1106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：你需要在 `Test` 类中插入代码，使得以下代码行能够工作：
- en: ''
  id: totrans-1107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-1108
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE84]'
- en: ''
  id: totrans-1109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hence, option (d) is incorrect. Because class `Test` doesn’t define any instance
    methods, the only way that the question’s line of code can execute is when a method
    parameter `movable` is passed to the method `walk`.
  id: totrans-1110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因此，选项 (d) 是不正确的。因为 `Test` 类没有定义任何实例方法，所以问题中的代码行能够执行的唯一方式是将方法参数 `movable` 传递给
    `walk` 方法。
- en: ''
  id: totrans-1111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (a) is correct. Because the interface `Movable` defines the method `move`,
    you can pass a variable of its type to the method `move`.
  id: totrans-1112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (a) 是正确的。因为接口 `Movable` 定义了方法 `move`，所以你可以将它的类型变量传递给 `move` 方法。
- en: ''
  id: totrans-1113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (b) is correct. Because the class `Person` implements the interface `Movable`
    and defines the method `move`, you can pass a variable of its type to the method
    `walk`. With this version of the method `walk`, you can pass it an object of the
    class `Person` or any of its subclasses.
  id: totrans-1114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (b) 是正确的。因为类 `Person` 实现了接口 `Movable` 并定义了方法 `move`，所以你可以将它的类型变量传递给 `walk`
    方法。使用这个版本的 `walk` 方法，你可以传递一个 `Person` 类的实例或其任何子类的实例。
- en: ''
  id: totrans-1115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (c) is correct. Because the class `Vehicle` implements the interface
    `Movable` and defines the method `move`, you can pass a variable of its type to
    the method `walk`. With this version of method `walk`, you can pass it an object
    of the class `Vehicle` or any of its subclasses.
  id: totrans-1116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (c) 是正确的。因为类 `Vehicle` 实现了接口 `Movable` 并定义了方法 `move`，所以你可以将它的类型变量传递给 `walk`
    方法。使用这个版本的 `walk` 方法，你可以传递一个 `Vehicle` 类的实例或其任何子类的实例。
- en: '**[Q6-4.](#ch06qa1q4)**'
  id: totrans-1117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-4.](#ch06qa1q4)**'
- en: ''
  id: totrans-1118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Select the correct statements:'
  id: totrans-1119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选择正确的语句：
- en: ''
  id: totrans-1120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Only an `abstract` class can be used as a base class to implement polymorphism
    with classes.
  id: totrans-1121
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有 `abstract` 类可以作为基类来实现类之间的多态。
- en: '**Polymorphic methods are also called overridden methods.**'
  id: totrans-1122
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多态方法也称为重写方法。**'
- en: In polymorphism, depending on the exact type of object, the JVM executes the
    appropriate method at compile time.
  id: totrans-1123
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在多态中，根据对象的精确类型，JVM 在编译时执行适当的方法。
- en: None of the above.
  id: totrans-1124
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆非。
- en: ''
  id: totrans-1125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: b'
  id: totrans-1126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：b
- en: ''
  id: totrans-1127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (a) is incorrect. To implement polymorphism with classes, either an `abstract`
    class or a concrete class can be used as a base class.
  id: totrans-1128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项（a）是不正确的。为了使用类实现多态，可以使用`abstract`类或具体类作为基类。
- en: ''
  id: totrans-1129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (c) is incorrect. First of all, no code execution takes place at compile
    time. Code can only execute at runtime. In polymorphism, the determination of
    the exact method to execute is deferred until runtime and is determined by the
    exact type of the object on which a method needs to be called.
  id: totrans-1130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项（c）是不正确的。首先，编译时不会执行任何代码。代码只能在运行时执行。在多态中，确定要执行的确切方法被推迟到运行时，并且由需要调用方法的对象的确切类型决定。
- en: '**[Q6-5.](#ch06qa1q5)**'
  id: totrans-1131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-5.](#ch06qa1q5)**'
- en: ''
  id: totrans-1132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Given the following code, select the correct statements:'
  id: totrans-1133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下代码，选择正确的陈述：
- en: ''
  id: totrans-1134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-1135
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE85]'
- en: ''
  id: totrans-1136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The code exhibits polymorphism with classes.
  id: totrans-1137
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码展示了类多态性。
- en: The code exhibits polymorphism with interfaces.
  id: totrans-1138
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码展示了接口的多态性。
- en: The code exhibits polymorphism with classes and interfaces.
  id: totrans-1139
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码展示了类和接口的多态性。
- en: '**None of the above.**'
  id: totrans-1140
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**以上都不正确。**'
- en: ''
  id: totrans-1141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: d'
  id: totrans-1142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：d
- en: ''
  id: totrans-1143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: The given code doesn’t define any method in the class `Person`
    that is redefined or implemented in the classes `Employee` and `Doctor`. Although
    the classes `Employee` and `Doctor` extend the class `Person`, all three polymorphism
    concepts or design principles are based on a method, which is missing in these
    classes.'
  id: totrans-1144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：给定的代码在`Person`类中没有定义任何在`Employee`和`Doctor`类中被重新定义或实现的方法。尽管`Employee`和`Doctor`类扩展了`Person`类，但所有三个多态概念或设计原则都是基于方法的，而这些类中缺少这种方法。
- en: '**[Q6-6.](#ch06qa1q6)**'
  id: totrans-1145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-6.](#ch06qa1q6)**'
- en: ''
  id: totrans-1146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following statements are true?
  id: totrans-1147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个陈述是正确的？
- en: ''
  id: totrans-1148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Inheritance enables you to reuse existing code.**'
  id: totrans-1149
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**继承使你能够重用现有代码。**'
- en: '**Inheritance saves you from having to modify common code in multiple classes.**'
  id: totrans-1150
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**继承可以让你避免在多个类中修改公共代码。**'
- en: Polymorphism passes special instructions to the compiler so that the code can
    run on multiple platforms.
  id: totrans-1151
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多态向编译器传递特殊指令，以便代码可以在多个平台上运行。
- en: Polymorphic methods can’t throw exceptions.
  id: totrans-1152
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多态方法不能抛出异常。
- en: ''
  id: totrans-1153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: a, b'
  id: totrans-1154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：a, b
- en: ''
  id: totrans-1155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Option (a) is correct. Inheritance can allow you to reuse existing
    code by extending a class. In this way, the functionality that’s already defined
    in the base class need not be defined in the derived class. The functionality
    offered by the base class can be accessed in the derived class as if it were defined
    in the derived class.'
  id: totrans-1156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：选项（a）是正确的。继承允许你通过扩展一个类来重用现有代码。这样，在基类中已经定义的功能不需要在派生类中重新定义。基类提供的功能可以在派生类中访问，就像它是在派生类中定义的一样。
- en: ''
  id: totrans-1157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (b) is correct. Common code can be placed in the base class, which can
    be extended by all the derived classes. If any changes need to be made to this
    common code, it can be modified in the base class. The modified code will be accessible
    to all the derived classes.
  id: totrans-1158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项（b）是正确的。公共代码可以放在基类中，所有派生类都可以扩展它。如果需要对这部分公共代码进行修改，可以在基类中进行修改。修改后的代码将对所有派生类可用。
- en: ''
  id: totrans-1159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (c) is incorrect. Polymorphism doesn’t pass any special instructions
    to the compiler to make the Java code execute on multiple platforms. Java code
    can execute on multiple platforms because the Java compiler compiles to virtual
    machine code, which is platform neutral. Different platforms implement this virtual
    machine.
  id: totrans-1160
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项（c）是不正确的。多态不会向编译器传递任何特殊指令以使Java代码在多个平台上执行。Java代码可以在多个平台上执行，因为Java编译器编译成虚拟机代码，这是平台无关的。不同的平台实现了这个虚拟机。
- en: ''
  id: totrans-1161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (d) is incorrect. Polymorphic methods can throw exceptions.
  id: totrans-1162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项（d）是不正确的。多态方法可以抛出异常。
- en: '**[Q6-7.](#ch06qa1q7)**'
  id: totrans-1163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-7.](#ch06qa1q7)**'
- en: ''
  id: totrans-1164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the following code, which of the options are true?
  id: totrans-1165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下代码，哪些选项是正确的？
- en: ''
  id: totrans-1166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-1167
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE86]'
- en: ''
  id: totrans-1168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**The method `orbit` defined in the classes `Satellite`, `Moon`, and `Artificial-Satellite`
    is polymorphic.**'
  id: totrans-1169
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在`Satellite`、`Moon`和`Artificial-Satellite`类中定义的`orbit`方法是多态的。**'
- en: Only the method `orbit` defined in the classes `Satellite` and `Artificial-Satellite`
    is polymorphic.
  id: totrans-1170
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有在`Satellite`和`Artificial-Satellite`类中定义的`orbit`方法是多态的。
- en: Only the method `orbit` defined in the class `ArtificialSatellite` is polymorphic.
  id: totrans-1171
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有在`ArtificialSatellite`类中定义的`orbit`方法是多态的。
- en: None of the above.
  id: totrans-1172
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上都不正确。
- en: ''
  id: totrans-1173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: a'
  id: totrans-1174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：a
- en: ''
  id: totrans-1175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: All these options define classes. When methods with the same method
    signature are defined in classes that share an inheritance relationship, the methods
    are considered polymorphic.'
  id: totrans-1176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：所有这些选项都定义了类。当在具有继承关系的类中定义具有相同方法签名的类时，这些方法被认为是多态的。
- en: '**[Q6-8.](#ch06qa1q8)**'
  id: totrans-1177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-8.](#ch06qa1q8)**'
- en: ''
  id: totrans-1178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Examine the following code:'
  id: totrans-1179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查以下代码：
- en: ''
  id: totrans-1180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-1181
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE87]'
- en: ''
  id: totrans-1182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following lines of code can be individually inserted at `//INSERT
    CODE HERE` so that the output of the code is as follows?
  id: totrans-1183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪行代码可以单独插入到 `//INSERT CODE HERE` 以使代码的输出如下？
- en: ''
  id: totrans-1184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-1185
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE88]'
- en: ''
  id: totrans-1186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Programmer b = new Programmer();`'
  id: totrans-1187
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Programmer b = new Programmer();`'
- en: '**`Programmer b = new Author()`;**'
  id: totrans-1188
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`Programmer b = new Author();`**'
- en: '**`Author b = new Author()`;**'
  id: totrans-1189
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`Author b = new Author();`**'
- en: '`Author b = new Programmer();`'
  id: totrans-1190
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Author b = new Programmer();`'
- en: '`Programmer b = ((Author)new Programmer());`'
  id: totrans-1191
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Programmer b = ((Author)new Programmer());`'
- en: '`Author b = ((Author)new Programmer());`'
  id: totrans-1192
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Author b = ((Author)new Programmer());`'
- en: ''
  id: totrans-1193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: b, c'
  id: totrans-1194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：b, c
- en: ''
  id: totrans-1195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Option (a) is incorrect. This code will compile, but because both
    the reference variable and object are of type `Programmer`, calling `print` on
    this object will print `Programmer - Mala Gupta`, not `Author - Mala Gupta`.'
  id: totrans-1196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：选项 (a) 是错误的。此代码可以编译，但由于引用变量和对象都是 `Programmer` 类型，调用此对象的 `print` 方法将打印 `Programmer
    - Mala Gupta`，而不是 `Author - Mala Gupta`。
- en: ''
  id: totrans-1197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (d) is incorrect. This code will not compile. You can’t assign an object
    of a base class to a reference variable of a derived class.
  id: totrans-1198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (d) 是错误的。不能将基类对象赋值给派生类引用变量。
- en: ''
  id: totrans-1199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (e) is incorrect. This line of code will compile successfully, but it
    will fail at runtime with a `ClassCastException`. An object of a base class can’t
    be cast to an object of its derived class.
  id: totrans-1200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (e) 是错误的。此行代码可以成功编译，但在运行时将因 `ClassCastException` 而失败。基类对象不能被转换为派生类对象。
- en: ''
  id: totrans-1201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (f) is incorrect. The expression `((Author)new Programmer())` is evaluated
    before it can be assigned to a reference variable of type `Author`. This line
    of code also tries to cast an object of the base class, `Programmer`, to an object
    of its derived class, `Author`. This code will also compile successfully but will
    fail at runtime with a `ClassCastException`. Using a reference variable of type
    `Author` won’t make a difference here. What matters here is the type that follows
    the `new` operator.
  id: totrans-1202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (f) 是错误的。表达式 `((Author)new Programmer())` 在被分配给 `Author` 类型的引用变量之前就被评估了。此行代码也尝试将基类对象
    `Programmer` 转换为其派生类对象 `Author`。此代码也可以成功编译，但在运行时将因 `ClassCastException` 而失败。使用
    `Author` 类型的引用变量在这里没有区别。这里重要的是 `new` 操作符后面的类型。
- en: '**[Q6-9.](#ch06qa1q9)**'
  id: totrans-1203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-9.](#ch06qa1q9)**'
- en: ''
  id: totrans-1204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Given the following code, which of the options, when applied individually, will
    make it compile successfully?
  id: totrans-1205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给定以下代码，以下哪个选项单独应用后可以使代码成功编译？
- en: ''
  id: totrans-1206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-1207
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE89]'
- en: ''
  id: totrans-1208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Modify the code on line 2 to `interface Printable {`
  id: totrans-1209
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第2行的代码修改为 `interface Printable {`
- en: Modify the code on line 3 to public String print();
  id: totrans-1210
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第3行的代码修改为 `public String print();`
- en: '**Define the accessibility of the `print` methods to `public` on lines 6 and
    9.**'
  id: totrans-1211
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在第6行和第9行将 `print` 方法的访问权限定义为 `public`。**'
- en: Modify the code on line 8 so that it implements only the interface `Printable`.
  id: totrans-1212
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第8行的代码修改为仅实现接口 `Printable`。
- en: ''
  id: totrans-1213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: c'
  id: totrans-1214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：c
- en: ''
  id: totrans-1215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: The methods in an interface are implicitly `public`. A non-`abstract`
    class that implements an interface must implement all the methods defined in the
    interface. While overriding or implementing the methods, the accessibility of
    the implemented method must be `public`. An overriding method can’t be assigned
    a weaker access privilege than `public`.'
  id: totrans-1216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：接口中的方法默认是 `public` 的。实现接口的非 `abstract` 类必须实现接口中定义的所有方法。在重写或实现方法时，实现的方法的访问权限必须是
    `public`。重写的方法不能被赋予比 `public` 弱的访问权限。
- en: ''
  id: totrans-1217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (a) is incorrect. There are no issues with the interface `Printable`
    extending the interface `Employee` and the class `Author` implementing both of
    these interfaces.
  id: totrans-1218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (a) 是错误的。接口 `Printable` 扩展接口 `Employee` 以及类 `Author` 实现这两个接口时没有问题。
- en: ''
  id: totrans-1219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (b) is incorrect. Adding the access modifier to the method `print` on
    line 3 won’t make any difference to the existing code. The methods defined in
    an interface are implicitly `public`.
  id: totrans-1220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (b) 是错误的。在行3上添加访问修饰符到 `print` 方法对现有代码没有任何影响。接口中定义的方法默认是 `public` 的。
- en: ''
  id: totrans-1221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (d) is incorrect. There are no issues with a class implementing two interfaces
    when one of the interfaces extends the other interface.
  id: totrans-1222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (d) 是错误的。当一个接口扩展另一个接口时，类实现两个接口没有问题。
- en: '**[Q6-10.](#ch06qa1q10)**'
  id: totrans-1223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q6-10.](#ch06qa1q10)**'
- en: ''
  id: totrans-1224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-1227
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE90]'
- en: ''
  id: totrans-1228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-1229
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE91]'
- en: ''
  id: totrans-1230
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1231
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-1232
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE92]'
- en: ''
  id: totrans-1233
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1234
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-1235
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE93]'
- en: ''
  id: totrans-1236
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1237
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-1238
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE94]'
- en: ''
  id: totrans-1239
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1240
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: a'
  id: totrans-1242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：a
- en: ''
  id: totrans-1243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: With inheritance, the instance variables bind at compile time
    and the methods bind at runtime. The following line of code refers to an object
    of the class `Base`, using a reference variable of type `Base`. Hence, both of
    the following lines of code print `EJava`:'
  id: totrans-1244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：在继承中，实例变量在编译时绑定，而方法在运行时绑定。以下代码行使用类型为 `Base` 的引用变量引用了 `Base` 类的对象。因此，以下两行代码都打印
    `EJava`：
- en: ''
  id: totrans-1245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-1246
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE95]'
- en: ''
  id: totrans-1247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'But the following line of code refers to an object of the class `Derived` using
    a reference variable of type `Base`:'
  id: totrans-1248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但以下代码行使用类型为 `Base` 的引用变量引用了 `Derived` 类的对象：
- en: ''
  id: totrans-1249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-1250
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE96]'
- en: ''
  id: totrans-1251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Because the instance variables bind at compile time, the following line of
    code accesses and prints the value of the instance variable defined in the class
    `Base`:'
  id: totrans-1252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因为实例变量在编译时绑定，所以以下代码行访问并打印了在 `Base` 类中定义的实例变量的值：
- en: ''
  id: totrans-1253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-1254
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE97]'
- en: ''
  id: totrans-1255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In `derived.printVar()`, even though the method `printVar` is called using a
    reference of type `Base`, the JVM is aware that the method is invoked on a `Derived`
    object and so executes the overridden `printVar` method in the class `Derived`.
  id: totrans-1256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 `derived.printVar()` 中，尽管使用类型为 `Base` 的引用调用了 `printVar` 方法，但 JVM 知道该方法是在 `Derived`
    对象上调用的，因此执行了 `Derived` 类中重写的 `printVar` 方法。
