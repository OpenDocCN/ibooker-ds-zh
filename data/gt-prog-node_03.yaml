- en: Unit 3\. Connecting to a database
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元3：连接到数据库
- en: '[Unit 2](../Text/kindle_split_020.html#part02) taught you how to set up a Node.js
    application with Express.js. By this point, you should feel comfortable building
    a basic web application with Express.js routing and templating. This unit is about
    taking the application you built in [unit 2](../Text/kindle_split_020.html#part02)
    and connecting it to a database. A *database* is where values can be stored permanently,
    as opposed to the data in earlier lessons, which was reset every time your application
    restarted.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[单元2](../Text/kindle_split_020.html#part02) 教会了你如何使用Express.js设置Node.js应用程序。到这一点，你应该已经能够舒适地使用Express.js的路由和模板构建一个基本的Web应用程序。本单元是关于将你在[单元2](../Text/kindle_split_020.html#part02)中构建的应用程序连接到数据库。数据库是一个可以永久存储值的地方，与之前课程中的数据不同，后者每次应用程序重启时都会重置。'
- en: In this book, you learn to use MongoDB, a popular database for Node.js. First,
    you download and install Mongo on your computer. Then you explore the MongoDB
    shell, a database environment similar to the Node.js REPL shell. Next, you learn
    some database theory behind structuring your database and the data within it.
    You see how models fit into the model-view-controller (MVC) architecture and how
    they interact with your application’s database via a package called Mongoose.
    Last, you explore how a database schema—an outline of your structured data—helps
    you relate data objects to one another.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你将学习如何使用MongoDB，这是Node.js中流行的数据库。首先，你需要在你的计算机上下载并安装Mongo。然后，你将探索MongoDB
    shell，这是一个类似于Node.js REPL shell的数据库环境。接下来，你将学习一些数据库理论，了解如何构建你的数据库及其中的数据。你将看到模型如何适应模型-视图-控制器（MVC）架构，以及它们如何通过名为Mongoose的包与你的应用程序数据库交互。最后，你将探索数据库模式——你结构化数据的轮廓——如何帮助你将数据对象相互关联。
- en: 'With the goal of building a Node.js application that can store user information
    and display that information back on your screen, this unit covers the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以构建一个可以存储用户信息并在屏幕上显示这些信息的Node.js应用程序为目标，本单元涵盖了以下主题：
- en: '[Lesson 13](../Text/kindle_split_027.html#ch13) introduces MongoDB, a NoSQL
    database that stores data in a JSON structure. In this lesson, you learn how MongoDB
    works with Express.js and install the database program on your computer. You also
    create a database and insert some data by using the MongoDB shell.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第13课](../Text/kindle_split_027.html#ch13)介绍了MongoDB，这是一个NoSQL数据库，它以JSON结构存储数据。在本课中，你将学习MongoDB如何与Express.js协同工作，并在你的计算机上安装数据库程序。你还将使用MongoDB
    shell创建数据库并插入一些数据。'
- en: '[Lesson 14](../Text/kindle_split_028.html#ch14) shows how to connect your MongoDB
    database to an Express.js application. After initial setup, you learn how object-oriented
    programming (OOP) can help you build reliable models for an MVC-structured Node.js
    application. For your models, you install and use the Mongoose package, an object-document
    mapper (ODM).'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第14课](../Text/kindle_split_028.html#ch14)展示了如何将你的MongoDB数据库连接到Express.js应用程序。在初始设置之后，你将学习面向对象编程（OOP）如何帮助你为MVC结构的Node.js应用程序构建可靠的模型。对于你的模型，你将安装并使用Mongoose包，这是一个对象文档映射器（ODM）。'
- en: '[Lesson 15](../Text/kindle_split_029.html#ch15) discusses the types of query
    commands you can use with your MongoDB database from within the Node.js application.
    You also implement JavaScript promises to work with Mongoose to build a more streamlined,
    ES6-friendly application.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第15课](../Text/kindle_split_029.html#ch15)讨论了你可以从Node.js应用程序内部使用的查询命令类型。你还实现了JavaScript承诺，以使用Mongoose构建更流畅、更符合ES6的应用程序。'
- en: Finally, [lesson 16](../Text/kindle_split_030.html#ch16) shows how to put your
    skills to the test by implementing a MongoDB database for the Confetti Cuisine
    cooking-school application. In this capstone exercise, you save user data and
    newsletter emails.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，[第16课](../Text/kindle_split_030.html#ch16)展示了如何通过为Confetti Cuisine烹饪学校应用程序实现MongoDB数据库来测试你的技能。在这个综合练习中，你保存用户数据和时事通讯电子邮件。
- en: Get ready to collect and store data in [lesson 13](../Text/kindle_split_027.html#ch13).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 准备在[第13课](../Text/kindle_split_027.html#ch13)中收集和存储数据。
- en: Lesson 13\. Setting up a MongoDB Database
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第13课：设置MongoDB数据库
- en: In [unit 2](../Text/kindle_split_020.html#part02), you built web applications
    with Express.js. Structuring your applications to use the model-view-controller
    (MVC) architecture, you can now handle requests through your controllers and serve
    views. The third essential piece is models, with which you’ll organize data that
    you plan to store permanently. In this lesson, you install MongoDB, the database
    system that you’ll use to store persistent data. You also explore what makes document
    database structure in MongoDB particularly convenient for Node.js applications.
    By the end of the lesson, you’ll have a database set up and connected to your
    application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2 单元](../Text/kindle_split_020.html#part02) 中，你使用 Express.js 构建了 Web 应用程序。通过将应用程序结构化为使用模型-视图-控制器
    (MVC) 架构，你现在可以通过控制器处理请求并提供服务视图。第三件基本工具是模型，你将使用它来组织你计划永久存储的数据。在本课中，你将安装 MongoDB，这是你将用于存储持久数据的数据库系统。你还将探索
    MongoDB 中的文档数据库结构为何特别适合 Node.js 应用程序。在本课结束时，你将设置数据库并将其连接到你的应用程序。
- en: This lesson covers
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Installing MongoDB
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 MongoDB
- en: Reading and entering data with in the MongoDB shell
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 MongoDB 壳中读取和输入数据
- en: Connecting MongoDB to a Node.js application
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 MongoDB 连接到 Node.js 应用程序
- en: '|  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: You want to start saving data from your application into a database, but you’re
    unsure which database to use. With Node.js, you can work with practically any
    common database, such as MySQL, PostgreSQL, Cassandra, Redis, and Neo4j. You can
    get a sense of the most supported and popular database management systems by exploring
    their associated packages on `npm`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你想从你的应用程序开始将数据保存到数据库中，但你不确定使用哪个数据库。使用 Node.js，你可以与几乎所有常见的数据库一起工作，例如 MySQL、PostgreSQL、Cassandra、Redis
    和 Neo4j。你可以通过探索它们在 `npm` 上的相关包来了解最支持和最受欢迎的数据库管理系统。
- en: MongoDB, however, offers a unique style of data storage that resembles JSON—a
    JavaScript-friendly format that may make working with databases easier for you
    as you delve into saving data with Node.js for the first time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，MongoDB 提供了一种独特的数据存储风格，类似于 JSON——一个对 JavaScript 友好的格式，这可能使你在第一次使用 Node.js
    保存数据时更容易与数据库一起工作。
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)13.1\. Setting up MongoDB'
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)13.1\. 设置 MongoDB'
- en: Storing data is arguably the most important part of application development.
    Without long-term storage, you’re limited in the way you can interact with your
    users. The data in every application you’ve built to this point disappeared each
    time you restarted the application. If data from a social network were to disappear
    every time a user closed his browser or every time you restarted that application,
    users would have to create new accounts and start from scratch.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 存储数据可以说是应用程序开发中最重要的一部分。没有长期存储，你在与用户互动的方式上会受到限制。到目前为止，你构建的每个应用程序中的数据，每次重启应用程序时都会消失。如果社交网络中的数据每次用户关闭浏览器或每次重启该应用程序时都会消失，用户将不得不创建新账户并从头开始。
- en: 'A *database* is an organization of your data designed for easy access and efficient
    changes made by your application. A database is like a warehouse: the more items
    you need to store, the happier you’ll be with an organized system that helps you
    find those items. Like a web server, your application connects to a MongoDB database
    and requests data.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *数据库* 是一个为你的数据设计的组织结构，以便你的应用程序能够轻松访问和高效地修改。数据库就像一个仓库：你需要存储的物品越多，你越会喜欢一个帮助你找到这些物品的有序系统。就像一个网络服务器一样，你的应用程序连接到
    MongoDB 数据库并请求数据。
- en: Throughout this unit, I discuss how to save information to a database for long-term
    storage. Your data will persist, even if the application is shut down.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本单元中，我讨论了如何将信息保存到数据库中进行长期存储。即使应用程序关闭，你的数据也会持续存在。
- en: '*MongoDB* is an open-source database program that organizes data by using documents.
    MongoDB *documents* store data in a JSON-like structure, allowing you to use key-value
    pairing to associate data objects with properties.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*MongoDB* 是一个开源的数据库程序，它通过使用文档来组织数据。MongoDB *文档* 以类似 JSON 的结构存储数据，允许你使用键值对来关联数据对象和属性。'
- en: This system of storage follows a familiar JavaScript syntax. Notice in [figure
    13.1](#ch13fig01) that a document’s contents resemble JSON. In fact, MongoDB stores
    documents as BSON (a binary form of JSON). Unlike relational databases used by
    the majority of applications, MongoDB’s nonrelational database system leads the
    Node.js application community.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这种存储系统遵循熟悉的 JavaScript 语法。注意在 [图 13.1](#ch13fig01) 中，文档的内容类似于 JSON。实际上，MongoDB
    将文档存储为 BSON（JSON 的二进制形式）。与大多数应用程序使用的关系型数据库不同，MongoDB 的非关系型数据库系统在 Node.js 应用程序社区中处于领先地位。
- en: Figure 13.1\. Example document
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.1\. 示例文档
- en: '![](../Images/13fig01_alt.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13fig01_alt.jpg)'
- en: '|  |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**A look at relational databases**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**关系型数据库的概述**'
- en: This book focuses on MongoDB and on how its documents complement a JavaScript-based
    application platform like Node.js. It’s worth noting what MongoDB is not, however,
    as well as how the rest of the programming world is working with databases.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本书重点介绍 MongoDB 以及其文档如何补充基于 JavaScript 的应用程序平台（如 Node.js）。然而，值得注意的是 MongoDB 不是什么，以及编程世界的其他部分是如何与数据库一起工作的。
- en: Most databases used by software and web applications use a different model of
    data storage from the document structure used in MongoDB. Most databases are *relational*,
    meaning that they associate data via tables, like a standard spreadsheet. Within
    these tables, columns define the type of data that should be stored, and rows
    store the values that correspond to the columns. In the following figure, data
    representing people, courses, and which people are enrolled in certain courses
    is displayed in separate tables.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数软件和Web应用程序使用的数据库在数据存储模型上与MongoDB中使用的文档结构不同。大多数数据库是 *关系型* 的，这意味着它们通过表格关联数据，就像标准的电子表格一样。在这些表格中，列定义了应存储的数据类型，而行存储与列对应的值。在以下图中，表示人员、课程以及哪些人员注册了特定课程的数据分别显示在不同的表格中。
- en: '![](../Images/f0137-01_alt.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f0137-01_alt.jpg)'
- en: Example relational database structure
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 示例关系型数据库结构
- en: In this example, two tables are associated by their ID values. To connect a
    person with their desired cooking course, the IDs of the items from the `people`
    and courses tables are added to new rows in a join table. The *join table* generally
    holds only IDs of associated items to define a relationship among those items.
    This relationship designed through reference IDs is where the database system
    gets its name. Databases that use this structure are often SQL-based, making MongoDB
    a NoSQL database system.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，两个表通过它们的 ID 值相关联。为了将一个人与他们想要的烹饪课程联系起来，将 `people` 和 `courses` 表中的项目 ID
    添加到新的连接表行中。*连接表* 通常只包含相关项的 ID，以定义这些项之间的关系。这种通过引用 ID 设计的关系是数据库系统名称的由来。使用这种结构的数据库通常是基于
    SQL 的，这使得 MongoDB 成为一个 NoSQL 数据库系统。
- en: You could set up a relational database with Node.js—in fact, many applications
    do—but to best make use of a SQL database, it helps to know how to write in the
    SQL language. The MongoDB query language is simpler to understand for people who
    have a Java-Script background.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Node.js 设置关系型数据库——实际上，许多应用程序都是这样做的——但要最好地利用 SQL 数据库，了解如何编写 SQL 语言很有帮助。对于有
    JavaScript 背景的人来说，MongoDB 的查询语言更容易理解。
- en: For more information on relational databases, I recommend reading the overview
    by Oracle at [https://docs.oracle.com/javase/tutorial/jdbc/overview/database.html](https://docs.oracle.com/javase/tutorial/jdbc/overview/database.html).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关于关系型数据库的更多信息，我建议阅读 Oracle 提供的概述 [https://docs.oracle.com/javase/tutorial/jdbc/overview/database.html](https://docs.oracle.com/javase/tutorial/jdbc/overview/database.html)。
- en: '|  |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this section, you install MongoDB and look at some data. The installation
    process is a bit different for Windows and Macintosh. For the Mac, the recommended
    approach is a terminal command-line tool called Homebrew. You can install Homebrew
    by entering the command shown in the next listing.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将安装 MongoDB 并查看一些数据。Windows 和 Macintosh 的安装过程略有不同。对于 Mac，推荐的方法是使用名为 Homebrew
    的终端命令行工具。你可以通过输入下一列表中的命令来安装 Homebrew。
- en: Listing 13.1\. Command to install Homebrew on a Mac in terminal
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.1\. 在终端中安装 Homebrew 的命令
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1*** **Run the command in terminal to install Homebrew on MacOS machines.**'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在终端中运行命令以在 MacOS 机器上安装 Homebrew。**'
- en: '|  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Homebrew is a tool that helps you install software and other low-level tools
    such as database management systems. For more information, visit [https://brew.sh](https://brew.sh).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Homebrew 是一个帮助你安装软件和其他底层工具（如数据库管理系统）的工具。更多信息，请访问 [https://brew.sh](https://brew.sh)。
- en: '|  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: When Homebrew is installed, you should be able to enter `brew` in any new terminal
    window and see a list of available Homebrew commands, one of which is `brew install`.
    Install MongoDB by running `brew install mongodb`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当Homebrew安装完成后，您应该能够在任何新的终端窗口中输入 `brew` 并看到可用Homebrew命令的列表，其中之一是 `brew install`。通过运行
    `brew install mongodb` 来安装MongoDB。
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: If your computer throws an error or complains about permissions issues at any
    point in the installation, you may need to run the command as a superuser by appending
    `sudo` to the command. Then you’ll be prompted to enter your computer’s login
    password.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的计算机在安装过程中的任何时刻抛出错误或抱怨权限问题，您可能需要以超级用户身份运行命令，即在命令后附加 `sudo`。然后您将被提示输入计算机的登录密码。
- en: '|  |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Next, create a folder called db within another folder called data at your computer’s
    root level (as far back as you can `cd ..` in a terminal window). You can create
    this folder by entering `mkdir -p /data/db` in a terminal window.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在您的计算机根目录下（在终端窗口中尽可能多地 `cd ..`）创建一个名为data的新文件夹，并在其中创建一个名为db的新文件夹。您可以通过在终端窗口中输入
    `mkdir -p /data/db` 来创建此文件夹。
- en: 'You may need to give permissions to your user account to use this folder. To
    do so, run `sudo chown <your_username> /data/db`, and enter your computer’s password.
    For Windows, the steps are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要为您的用户账户提供使用此文件夹的权限。为此，请运行 `sudo chown <your_username> /data/db`，并输入您的计算机密码。对于Windows，步骤如下：
- en: Go to [https://www.mongodb.com/download-center#community](https://www.mongodb.com/download-center#community)
    in your browser.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的浏览器中访问 [https://www.mongodb.com/download-center#community](https://www.mongodb.com/download-center#community)。
- en: Download MongoDB for Windows (.msi).
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载Windows版本的MongoDB (.msi)。
- en: When the download is complete, open the file, and click through the default
    installation steps.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载完成后，打开文件，并按照默认的安装步骤进行操作。
- en: When the installer completes, go to your C:\ drive, and create a new folder
    called data and a folder within it called db.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当安装程序完成后，转到您的C:\驱动器，创建一个名为data的新文件夹，并在其中创建一个名为db的文件夹。
- en: '|  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In Windows, you may need to add the MongoDB folder path to your environment’s
    PATH variable. To add it, right-click Computer, choose Properties => Advanced
    system settings => Environment variables => Edit environment variables => PATH,
    and add your MongoDB executable path to this string. Your MongoDB path might look
    something like `C:\Program Files\MongoDB\Server\3.6.2\bin`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，您可能需要将MongoDB文件夹路径添加到您的环境变量PATH中。要添加它，请右键单击计算机，选择属性 => 高级系统设置 => 环境变量
    => 编辑环境变量 => PATH，并将您的MongoDB可执行路径添加到该字符串中。您的MongoDB路径可能看起来像 `C:\Program Files\MongoDB\Server\3.6.2\bin`。
- en: '|  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: For more installation instructions, including those for Ubuntu Linux machines,
    go to [https://docs.mongodb.com/v3.0/tutorial/install-mongodb-on-ubuntu](https://docs.mongodb.com/v3.0/tutorial/install-mongodb-on-ubuntu).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多安装说明，包括针对Ubuntu Linux机器的说明，请访问 [https://docs.mongodb.com/v3.0/tutorial/install-mongodb-on-ubuntu](https://docs.mongodb.com/v3.0/tutorial/install-mongodb-on-ubuntu)。
- en: So far, you’ve gotten MongoDB installed on your computer. Like a web server,
    Mongo-DB needs to be started to create new databases for your applications. You
    can start MongoDB by running `mongod` in a terminal window. This command assigns
    MongoDB a port and establishes the location of its databases at `data/db`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经在您的计算机上安装了MongoDB。像Web服务器一样，MongoDB需要启动以创建您应用程序的新数据库。您可以通过在终端窗口中运行
    `mongod` 来启动MongoDB。此命令为MongoDB分配一个端口，并确定其数据库的位置在 `data/db`。
- en: '|  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: To start and stop MongoDB with Homebrew on a Mac, run `brew services start mongodb`
    or `brew services stop mongodb`. Homebrew runs the database server in the background,
    so if `mongod` doesn’t work, you may have started MongoDB with Homebrew elsewhere.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Mac上使用Homebrew启动和停止MongoDB，请运行 `brew services start mongodb` 或 `brew services
    stop mongodb`。Homebrew在后台运行数据库服务器，因此如果 `mongod` 不起作用，您可能已经在其他地方使用Homebrew启动了MongoDB。
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You can test whether Mongo was installed successfully by typing `mongo` in a
    new terminal window. This command brings up the MongoDB shell, an environment
    within which you can run MongoDB commands and view data. This shell environment
    is similar to REPL because it isolates your terminal window to allow you to interact
    purely with MongoDB syntax. When you have some data to work with, you can further
    explore this environment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在新的终端窗口中输入 `mongo` 来测试Mongo是否安装成功。此命令会启动MongoDB shell，这是一个环境，您可以在其中运行MongoDB命令并查看数据。此shell环境类似于REPL，因为它将您的终端窗口隔离出来，允许您仅与MongoDB语法进行交互。当您有一些数据要处理时，您可以进一步探索这个环境。
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 13.1**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查13.1**'
- en: '**[Q1:](#ch13qa2q0a1)**'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch13qa2q0a1)**'
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What data structure does MongoDB use to store data?
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MongoDB 使用什么数据结构来存储数据？
- en: '|  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 13.1 answer**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 13.1 答案**'
- en: '**[1:](#ch13qa1q1)**'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch13qa1q1)**'
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: MongoDB uses documents to store data.
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MongoDB 使用文档来存储数据。
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)13.2\. Running commands in the MongoDB shell'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)13.2\. 在 MongoDB shell 中运行命令'
- en: Now that MongoDB is running, it’s ready to receive commands to add, view, delete,
    or otherwise change data. Before you connect MongoDB to your application, you
    can test some commands in the MongoDB shell.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 MongoDB 已启动，它准备好接收添加、查看、删除或更改数据的命令。在你将 MongoDB 连接到应用程序之前，你可以在 MongoDB shell
    中测试一些命令。
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Commands that you run in the MongoDB shell are permanent. If you delete data
    (or an entire database), there’s no going back.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 MongoDB shell 中运行的命令是永久的。如果你删除了数据（或整个数据库），就无法恢复。
- en: '|  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Run `mongo` in a new terminal window. This command should prompt the shell to
    start. You’ll be greeted by your MongoDB version number, potentially a few warnings
    (which you can ignore for now), and the familiar `>` to indicate that the shell
    is active and ready for commands.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的终端窗口中运行 `mongo`。此命令应提示 shell 启动。你会看到你的 MongoDB 版本号，可能还有一些警告（你现在可以忽略），以及熟悉的
    `>` 来指示 shell 已处于活动状态并准备好接收命令。
- en: MongoDB can store multiple databases; it’s a management system for all your
    applications’ databases. To start, the MongoDB shell places you in the test database.
    You can see this test database by entering `db`, to list your current database,
    after the prompt ([figure 13.2](#ch13fig02)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 可以存储多个数据库；它是所有应用程序数据库的管理系统。首先，MongoDB shell 将你置于测试数据库中。你可以通过输入 `db`
    来查看这个测试数据库，以列出你的当前数据库，在提示符后 ([图 13.2](#ch13fig02))。
- en: Figure 13.2\. MongoDB shell viewing current test database
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.2\. MongoDB shell 查看当前测试数据库
- en: '![](../Images/13fig02_alt.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13fig02_alt.jpg)'
- en: To view all available databases, run `show dbs`. With a clean install of MongoDB,
    your shell’s response should look like the next listing. Your test database is
    one of three that comes prepackaged with MongoDB. To the right of the database
    name is the size of the database. Because you haven’t stored any data yet, the
    databases are understandably empty.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有可用的数据库，运行 `show dbs`。对于 MongoDB 的干净安装，你的 shell 的响应应该看起来像下面的列表。你的测试数据库是
    MongoDB 预先打包的三个数据库之一。在数据库名称的右侧是数据库的大小。因为你还没有存储任何数据，所以数据库是空白的。
- en: Listing 13.2\. Show all databases in terminal
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.2\. 在终端中显示所有数据库
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1*** **View local databases.**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **查看本地数据库。**'
- en: You can create a new database and simultaneously switch into it by entering
    `use <new_database_name>`. Try switching to a new database for the recipe application
    by entering `use recipe_db`. Then run `db` again to see that you’re within the
    `recipe_db` database.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入 `use <new_database_name>` 来创建一个新的数据库并同时切换到它。尝试通过输入 `use recipe_db` 切换到新的食谱应用程序数据库。然后再次运行
    `db` 以查看你已处于 `recipe_db` 数据库中。
- en: '|  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You won’t see your new database in the list of databases until data is added.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会在数据库列表中看到你的新数据库，直到添加数据。
- en: '|  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To add data to your database, you need to specify a collection name with which
    that data is associated. A MongoDB *collection* is representative of your data
    model, storing all documents related to that model within the same grouping. If
    you want to create a contact list for the recipe application, for example, create
    a new collection and add a data item with the command shown in the following listing.
    The `insert` method runs on a MongoDB collection to add elements of a JavaScript
    object to a new document.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要向数据库添加数据，你需要指定一个与该数据关联的集合名称。MongoDB 的 *集合* 代表你的数据模型，将所有与该模型相关的文档存储在同一组中。例如，如果你想为食谱应用程序创建一个联系人列表，可以创建一个新的集合，并使用以下列表中的命令添加一个数据项。`insert`
    方法在 MongoDB 集合上运行，以将 JavaScript 对象的元素添加到新文档中。
- en: Listing 13.3\. Add data to a new collection in terminal
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.3\. 在终端中向新集合添加数据
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1*** **Insert new data into the database.**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将新数据插入到数据库中。**'
- en: 'At this point, there’s no strict collection structure; you can add any values
    to new documents without needing to follow previous data patterns. Insert another
    item into the `contacts` collection with these properties: `{first_name:` “`Jon`”`,
    favoriteSeason:` “`spring`”`, countries_visited: 42}`. MongoDB lets you add these
    seemingly conflicting data elements.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个阶段，没有严格的集合结构；你可以在新文档中添加任何值，而无需遵循之前的数据模式。使用以下属性将另一个项目插入到 `contacts` 集合中：`{first_name:
    "Jon", favoriteSeason: "spring", countries_visited: 42}`。MongoDB 允许你添加这些看似冲突的数据元素。'
- en: '|  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Just because MongoDB lets you store inconsistent data doesn’t mean that you
    should. In [lesson 14](../Text/kindle_split_028.html#ch14), I discuss ways of
    organizing data around your application’s models.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管MongoDB允许您存储不一致的数据，但这并不意味着您应该这样做。在[第14课](../Text/kindle_split_028.html#ch14)中，我讨论了围绕您应用程序模型组织数据的方法。
- en: '|  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: To list the collection’s contents, you can enter `db.contacts.find()`. You should
    see a response that looks like the next listing. Both inserted items are present,
    with an extra property added by MongoDB. The `id` property stores a unique value
    that you can use to differentiate and locate specific items in your database.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出集合的内容，您可以输入`db.contacts.find()`。您应该看到类似于以下列表的响应。两个插入的项目都存在，MongoDB添加了一个额外的属性。`id`属性存储一个唯一的值，您可以使用它来区分和定位数据库中的特定项目。
- en: Listing 13.4\. Find all data response in terminal
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.4\. 终端中查找所有数据响应
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1*** **Display results of database documents.**'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **显示数据库文档的结果。**'
- en: '|  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**ObjectId**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**ObjectId**'
- en: To keep your data organized and unique, MongoDB uses an `ObjectId` class to
    record some meaningful information about its database documents. `ObjectId(`"`5941fe7acda203f026856a5e`"`)`,
    for example, constructs a new `ObjectId` representing a document in your database.
    The hexadecimal value passed into the `ObjectId` constructor references the document,
    a timestamp of the record’s creation, and some information about your database
    system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持您的数据有组织和唯一，MongoDB使用`ObjectId`类来记录有关其数据库文档的一些有意义的信息。例如，`ObjectId("5941fe7acda203f026856a5e")`构建了一个表示数据库中文档的新`ObjectId`。传递给`ObjectId`构造函数的十六进制值引用了文档、记录创建的时间戳以及有关您的数据库系统的一些信息。
- en: The resulting `ObjectId` instance provides many useful methods that you can
    use to sort and organize data in your database. As a result, the `_id` property
    becomes a more useful feature in MongoDB than a string representation of the document
    ID.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`ObjectId`实例提供了许多有用的方法，您可以使用它们在数据库中对数据进行排序和组织。因此，`_id`属性在MongoDB中比文档ID的字符串表示形式更有用。
- en: '|  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Try searching for a specific item in the `contacts` collection by entering
    `db.contacts .find({_id: O``b``jectId("5941fce5cda203f026856a5d")})`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '通过输入`db.contacts .find({_id: O``b``jectId("5941fce5cda203f026856a5d")})`在`contacts`集合中搜索特定项目。'
- en: '|  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Replace the `ObjectId` in this example with one from your own database results.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将此示例中的`ObjectId`替换为您自己的数据库结果中的一个。
- en: '|  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**MongoDB Compass**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**MongoDB Compass**'
- en: As you become familiar with MongoDB, you may want a more user-friendly window
    into your MongoDB databases than the MongoDB shell in terminal. The people at
    MongoDB agreed and have produced a MongoDB graphical user interface called MongoDB
    Compass for all major operating systems.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您对MongoDB的熟悉，您可能需要一个比终端中的MongoDB shell更用户友好的窗口来查看您的MongoDB数据库。MongoDB团队同意了这一点，并为所有主要操作系统开发了一个名为MongoDB
    Compass的图形用户界面。
- en: 'MongoDB Compass is straightforward to use. To view the database that you set
    up for your recipe application, follow these steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB Compass使用简单。要查看为您的食谱应用程序设置的数据库，请按照以下步骤操作：
- en: Download the software from [https://www.mongodb.com/download-center#compass](https://www.mongodb.com/download-center#compass).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://www.mongodb.com/download-center#compass](https://www.mongodb.com/download-center#compass)下载软件。
- en: Follow the installation steps to add MongoDB Compass to your applications folder.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照安装步骤将MongoDB Compass添加到您的应用程序文件夹中。
- en: Run MongoDB Compass and accept the default connection settings to your existing
    MongoDB setup.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行MongoDB Compass并接受默认的连接设置到您现有的MongoDB设置。
- en: See your databases (including `recipe_db`) listed with options to view the collections
    and documents within them, as in [figure 13.3](#ch13fig03).
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看您的数据库（包括`recipe_db`），并列出查看其中集合和文档的选项，如图13.3所示。
- en: '|  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 13.3\. Database view in MongoDB Compass
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.3\. MongoDB Compass中的数据库视图
- en: '![](../Images/13fig03_alt.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13fig03_alt.jpg)'
- en: '|  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Database view in MongoDB Compass**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**MongoDB Compass中的数据库视图**'
- en: I recommend using MongoDB Compass as a supplemental tool while you work with
    MongoDB in your application.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在您在应用程序中使用MongoDB时，将MongoDB Compass作为一个辅助工具。
- en: '|  |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You can use many MongoDB commands. [Table 13.1](#ch13table01) lists a few that
    you should know about.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用许多MongoDB命令。[表13.1](#ch13table01)列出了您应该了解的一些命令。
- en: Table 13.1\. MongoDB Shell Commands
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表13.1\. MongoDB Shell命令
- en: '| Command | Description |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| show collections | Displays all the collections in your database. Later,
    these collections should match your models. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| show collections | 显示您数据库中的所有集合。稍后，这些集合应与您的模型匹配。|'
- en: '| db.contacts.findOne | Returns a single item from your database at random
    or a single item matching the criteria passed in as a parameter, which could look
    like findOne({name: ‘Jon’}). |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| db.contacts.findOne | 从您的数据库中随机返回一个项目或返回一个匹配作为参数传入的标准的单个项目，这可能看起来像 findOne({name:
    ‘Jon’})。|'
- en: '| db.contacts.update({name: “Jon”}, {name: “Jon Wexler”}) | Updates any matching
    documents with the second parameter’s property values. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| db.contacts.update({name: “Jon”}, {name: “Jon Wexler”}) | 使用第二个参数的属性值更新任何匹配的文档。|'
- en: '| db.contacts.delete({name: “Jon Wexler”}) | Removes any matching documents
    in the collection. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| db.contacts.delete({name: “Jon Wexler”}) | 删除集合中任何匹配的文档。|'
- en: '| db.contacts.deleteMany({}) | Removes all the documents in that collection.
    These commands can’t be undone. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| db.contacts.deleteMany({}) | 删除该集合中的所有文档。这些命令是不可逆的。|'
- en: For more practice, view the command cheat sheet at [https://docs.mongodb.com/manual/reference/mongo-shell/](https://docs.mongodb.com/manual/reference/mongo-shell/).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更多练习，请查看 [https://docs.mongodb.com/manual/reference/mongo-shell/](https://docs.mongodb.com/manual/reference/mongo-shell/)
    中的命令速查表。
- en: In the next section, you see how to add MongoDB to your Node.js application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将了解如何将 MongoDB 添加到您的 Node.js 应用程序中。
- en: '|  |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 13.2**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 13.2**'
- en: '**[Q1:](#ch13qa6q0a1)**'
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch13qa6q0a1)**'
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What MongoDB command can you use to view existing collections within a database?
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以使用哪个 MongoDB 命令来查看数据库中的现有集合？
- en: '|  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 13.2 answer**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 13.2 答案**'
- en: '**[1:](#ch13qa5q1)**'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch13qa5q1)**'
- en: ''
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`show collections` lists the collections within the active database in your
    MongoDB shell.'
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`show collections` 列出 MongoDB shell 中活动数据库中的集合。'
- en: '|  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)13.3\. Connecting MongoDB to your application'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)13.3\. 将 MongoDB 连接到您的应用程序'
- en: To add MongoDB to your Node.js recipe application, enter your project folder
    (or create a newly initialized project) in terminal, and install the `mongodb`
    package by running `npm i mongodb@3.6.3 -S`. This command saves the `mongodb`
    package to your project’s package.json dependencies.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 MongoDB 添加到您的 Node.js 食谱应用程序中，请在终端中进入您的项目文件夹（或创建一个新的初始化项目），并运行 `npm i mongodb@3.6.3
    -S` 命令来安装 `mongodb` 包。此命令将 `mongodb` 包保存到您的项目 package.json 依赖项中。
- en: '|  |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In the corresponding code repository for this lesson, some views and styling
    rules have been added from the last capstone project.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课程的相应代码存储库中，已从上一个综合项目添加了一些视图和样式规则。
- en: '|  |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: At the top of your main.js file, add the code shown in [listing 13.5](#ch13ex05).
    Require the MongoDB module to use the `MongoClient` class. `MongoClient` sets
    up a connection to your local database at its default port. The callback function
    returns your connection to the MongoDB server. Then get the database called `recipe_db`
    from your connection to the server. If there’s no database by the name provided,
    MongoDB creates one for use in the app.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 main.js 文件顶部，添加 [清单 13.5](#ch13ex05) 中显示的代码。使用 `MongoClient` 类需要引入 MongoDB
    模块。`MongoClient` 在其默认端口上设置与本地数据库的连接。回调函数返回到 MongoDB 服务器的连接。然后从服务器连接中获取名为 `recipe_db`
    的数据库。如果不存在提供的名称的数据库，MongoDB 将为应用程序创建一个。
- en: '|  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to run `mongod` to ensure that your MongoDB server is running before
    you try to connect to it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在尝试连接之前运行 `mongod` 以确保您的 MongoDB 服务器正在运行。
- en: '|  |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Next, ask the database to find all records in the `contacts` collection and
    return them in an array. The resulting data is returned in the callback function.
    Then you can log the results to the console.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，要求数据库查找 `contacts` 集合中的所有记录，并将它们作为数组返回。结果数据在回调函数中返回。然后您可以将结果记录到控制台。
- en: Listing 13.5\. Add MongoDB connection to Express.js in main.js
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.5\. 在 main.js 中添加 MongoDB 连接到 Express.js
- en: '[PRE4]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1*** **Require the MongoDB module.**'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入 MongoDB 模块。**'
- en: '***2*** **Set up a connection to your local database server.**'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **设置到本地数据库服务器的连接。**'
- en: '***3*** **Get the recipe_db database from your connection to the MongoDB server.**'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **从 MongoDB 服务器连接中获取 recipe_db 数据库。**'
- en: '***4*** **Find all records in the contacts collection.**'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **在 contacts 集合中查找所有记录。**'
- en: '***5*** **Print the results to the console.**'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **将结果打印到控制台。**'
- en: '|  |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `find` query method here works differently from a `find` query in a traditional
    functional programming language. If you get no match when you use `find` in MongoDB,
    you get an empty array.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `find` 查询方法与传统函数式编程语言中的 `find` 查询不同。如果你在 MongoDB 中使用 `find` 没有匹配项，你会得到一个空数组。
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You can use the same commands within your Node.js application that you did in
    the MongoDB shell. To add a new item to the database, for example, you can add
    the code in [listing 13.6](#ch13ex06) within your MongoDB connection callback
    function.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的 Node.js 应用程序中使用与在 MongoDB 命令行界面中相同的命令。例如，要向数据库中添加一个新项目，你可以在你的 MongoDB
    连接回调函数中添加 [代码清单 13.6](#ch13ex06) 中的代码。
- en: As when you query all the items in the database, you connect to the `contacts`
    collection and insert an item. If the new data was inserted successfully, you
    log that database message to the console.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查询数据库中的所有项目时，你连接到 `contacts` 集合并插入一个项目。如果新数据插入成功，你将数据库消息记录到控制台。
- en: Listing 13.6\. Insert data from your Node.js application into terminal
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单 13.6\. 从你的 Node.js 应用程序中将数据插入到终端
- en: '[PRE5]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1*** **Insert a new contact into the database.**'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将一个新联系人插入到数据库中。**'
- en: '***2*** **Log the resulting errors or saved item.**'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **记录结果错误或保存的项目。**'
- en: In [lesson 14](../Text/kindle_split_028.html#ch14), you explore a package called
    Mongoose, which works with MongoDB to provide a bit more organization to your
    application’s storage.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 14 课](../Text/kindle_split_028.html#ch14) 中，你探索了一个名为 Mongoose 的包，它与 MongoDB
    一起工作，为你的应用程序存储提供更多组织。
- en: '|  |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 13.3**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 13.3**'
- en: '**[Q1:](#ch13qa8q0a1)**'
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch13qa8q0a1)**'
- en: ''
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'True or false: If you try to connect to a database that doesn’t exist, MongoDB
    throws an error.'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 判断对错：如果你尝试连接到一个不存在的数据库，MongoDB 会抛出一个错误。
- en: '|  |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 13.3 answer**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 13.3 答案**'
- en: '**[1:](#ch13qa7q1)**'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch13qa7q1)**'
- en: ''
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: False. MongoDB creates a new database by the name you provided instead of throwing
    an error.
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误。MongoDB 会根据你提供的名称创建一个新的数据库，而不是抛出一个错误。
- en: '|  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this lesson, you learned how to set up MongoDB and how to use certain commands
    to manage databases on your computer. At the end of the lesson, you inserted collections
    and documents into your own database and connected that database to your Node.js
    application. In [lesson 14](../Text/kindle_split_028.html#ch14), you build models
    to represent the types of data that you want to store in your application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何设置 MongoDB 以及如何使用某些命令来管理计算机上的数据库。在本课结束时，你将集合和文档插入到自己的数据库中，并将该数据库连接到你的
    Node.js 应用程序。在 [第 14 课](../Text/kindle_split_028.html#ch14) 中，你将构建模型来表示你希望在应用程序中存储的数据类型。
- en: '|  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Try this**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这个**'
- en: Imagine that you’re creating an application to track ice-cream-truck statistics.
    Create an appropriately named database with a collection called `ice_cream_flavors`.
    Try inserting some flavors and include fields that would help with your statistics
    analysis.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在创建一个用于跟踪冰淇淋车统计数据的程序。创建一个名为 `ice_cream_flavors` 的适当命名的数据库集合。尝试插入一些口味，并包括有助于你的统计分析的字段。
- en: '|  |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Lesson 14\. Building models with Mongoose
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 14 课\. 使用 Mongoose 构建模型
- en: In [lesson 13](../Text/kindle_split_027.html#ch13), you got up and running with
    MongoDB. With a database connected to your Node.js application, you’re ready to
    save and load data. In this lesson, you apply a more object-oriented approach
    to your data. First, you install the Mongoose package, a tool that provides a
    syntactic layer between your application logic and your database. Mongoose allows
    you to convert your application data to fit a model structure. Later in the lesson,
    you build your first model and schema to represent newsletter subscribers to your
    recipe application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 13 课](../Text/kindle_split_027.html#ch13) 中，你开始使用 MongoDB。连接到你的 Node.js
    应用程序的数据库后，你就可以保存和加载数据了。在本课中，你将采用更面向对象的方法来处理数据。首先，你安装了 Mongoose 包，这是一个在应用程序逻辑和数据库之间提供语法层的工具。Mongoose
    允许你将应用程序数据转换为适合模型结构。在课程的后半部分，你将构建第一个模型和模式来表示食谱应用程序的订阅者。
- en: This lesson covers
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Installing and connecting Mongoose to your Node.js application
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Mongoose 安装并连接到你的 Node.js 应用程序
- en: Creating a schema
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模式
- en: Building and instantiating Mongoose data models
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 Mongoose 数据模型和实例化
- en: Loading and saving data with custom methods
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义方法加载数据和保存数据
- en: '|  |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: You finally have a database connected to your application, but data can change
    over time. One day, you may want to require all recipes to follow the same format.
    How can you determine such a structure and make sure that all saved data follows
    that structure’s rules?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你最终将数据库连接到你的应用程序，但数据会随时间变化。有一天，你可能希望所有食谱都遵循相同的格式。你如何确定这种结构并确保所有保存的数据都遵循该结构的规则？
- en: In this lesson, you explore Mongoose, a library used to create model schema.
    When you use these schemas, your data begins to follow strict rules that only
    you can customize.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，你将探索 Mongoose，这是一个用于创建模型模式的库。当你使用这些模式时，你的数据开始遵循只有你可以定制的严格规则。
- en: '|  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)14.1\. Setting up Mongoose with your Node.js application'
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)14.1\. 使用 Node.js 应用程序设置 Mongoose'
- en: You’ve already experienced Express.js and seen how it helps you handle HTTP
    requests and responses. Similarly, other packages are available to assist with
    the communication between your Node.js application and its database. The tool
    you’re going to use is called Mongoose. *Mongoose* is an object-document mapper
    (ODM) that allows you to run Mongo-DB commands in a way that preserves the object-oriented
    structure of your application. With MongoDB alone, for example, it’s difficult
    to keep one saved document consistent with the next. Mongoose changes that situation
    by offering tools to build models with schemas defining what type of data can
    be saved.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经体验了 Express.js 并看到了它是如何帮助你处理 HTTP 请求和响应的。同样，还有其他包可用于协助你的 Node.js 应用程序与其数据库之间的通信。你将要使用的工具被称为
    Mongoose。*Mongoose* 是一个对象-文档映射器（ODM），它允许你以保持应用程序面向对象结构的方式运行 MongoDB 命令。例如，仅使用
    MongoDB 时，很难保持一个保存的文档与下一个的一致性。Mongoose 通过提供构建具有定义可以保存的数据类型的模式的模型工具来改变这种情况。
- en: I discussed model-view-controller (MVC) architecture in [unit 2](../Text/kindle_split_020.html#part02)
    and described how controllers communicate with both views and models to ensure
    that the correct data flows through the application. A *model* is like a class
    for a JavaScript object that Mongoose uses to organize your database queries.
    In this section, you install Mongoose and see what a model looks like in your
    application ([figure 14.1](#ch14fig01)).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[单元 2](../Text/kindle_split_020.html#part02)中讨论了模型-视图-控制器（MVC）架构，并描述了控制器如何与视图和模型通信以确保正确数据通过应用程序流动。*模型*类似于
    Mongoose 用于组织你的数据库查询的 JavaScript 对象的类。在本节中，你将安装 Mongoose 并查看你的应用程序中的模型看起来像什么（[图
    14.1](#ch14fig01)）。
- en: Figure 14.1\. Models created with Mongoose map to documents in MongoDB.
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.1\. 使用 Mongoose 创建的模型映射到 MongoDB 中的文档。
- en: '![](../Images/14fig01_alt.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/14fig01_alt.jpg)'
- en: To install Mongoose, run `npm i mongoose -S` within your project folder in terminal.
    With Mongoose, you no longer need to require `mongodb` at the top of main.js or
    use any of the MongoDB code from [lesson 13](../Text/kindle_split_027.html#ch13).
    Add the code in [listing 14.1](#ch14ex01) to main.js. Require `mongoose` into
    the application file. Set up the application’s connection to your MongoDB database.
    (The same rules apply here as in a normal MongoDB connection.) Then assign the
    database connection to the `db` variable, which you can use later in the file
    for data changes or database state changes.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Mongoose，请在终端中运行 `npm i mongoose -S`，在项目文件夹内。使用 Mongoose，你不再需要在 main.js
    的顶部引入 `mongodb` 或使用来自[第 13 课](../Text/kindle_split_027.html#ch13)的任何 MongoDB 代码。将
    [清单 14.1](#ch14ex01) 中的代码添加到 main.js 中。将 `mongoose` 引入应用程序文件。设置应用程序与 MongoDB 数据库的连接。（这里适用的规则与正常
    MongoDB 连接相同。）然后将数据库连接分配给 `db` 变量，你可以在文件中稍后使用它进行数据更改或数据库状态更改。
- en: Listing 14.1\. Configuring Mongoose with your Node.js application in main.js
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单 14.1\. 在 main.js 中配置 Mongoose 与你的 Node.js 应用程序
- en: '[PRE6]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1*** **Require mongoose.**'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入 mongoose。**'
- en: '***2*** **Set up the connection to your database.**'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **设置与数据库的连接。**'
- en: '***3*** **Assign the database to the db variable.**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将数据库分配给 db 变量。**'
- en: '|  |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to have the MongoDB server running in the background. To run Mongo-DB,
    enter `mongod` in a terminal window.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，MongoDB 服务器需要在后台运行。要运行 MongoDB，请在终端窗口中输入 `mongod`。
- en: '|  |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: That’s all you need to do to set up Mongoose. You can log a message as soon
    as the database is connected by adding the code in the next listing to main.js.
    The database connection runs the code in the callback function (the log message)
    only once upon receiving an “`open`” event from the database.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的所有事情来设置 Mongoose。你可以在数据库连接后立即记录一条消息，通过将下一列表中的代码添加到 main.js 中。数据库连接在接收到数据库的“`open`”事件后，仅在回调函数（日志消息）中运行一次代码。
- en: Listing 14.2\. Log a message when the database is connected in main.js
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.2\. 在 main.js 中数据库连接时记录消息
- en: '[PRE7]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1*** **Log a message when the application connects to the database.**'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **当应用程序连接到数据库时记录一条消息。**'
- en: In the next section, you explore how to model your data to make best use of
    Mongoose.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将探索如何建模数据以充分利用 Mongoose。
- en: '|  |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 14.1**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 14.1**'
- en: '**[Q1:](#ch14qa2q0a1)**'
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch14qa2q0a1)**'
- en: ''
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is an ODM?
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ODM 是什么？
- en: '|  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 14.1 answer**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 14.1 答案**'
- en: '**[1:](#ch14qa1q1)**'
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch14qa1q1)**'
- en: ''
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ODM is an object-document mapper, which is the role of Mongoose in your application
    development. ODM (like an object-relational mapper) makes it easier to think purely
    in terms of objects in your application and not worry about how your data is structured
    in the database.
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ODM 是对象-文档映射器，这是 Mongoose 在您的应用程序开发中的角色。ODM（类似于对象-关系映射器）使您在应用程序中以纯粹的对象方式思考变得更容易，而不用担心数据在数据库中的结构。
- en: '|  |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)14.2\. Creating a schema'
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)14.2\. 创建模式'
- en: A schema is like a class definition in some languages or, more broadly, a blueprint
    for how you want data to be organized for specific objects in your application.
    To avoid inconsistent data, where some documents have an `email` field and others
    don’t, for example, you can create a schema stating that all `contact` objects
    need to have an email field to get saved to the database.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 模式类似于某些语言中的类定义，或者更广泛地说，是您希望数据在应用程序中特定对象中组织的方式的蓝图。为了避免不一致的数据，例如，一些文档有 `email`
    字段而其他没有，您可以创建一个模式，声明所有 `contact` 对象都需要有电子邮件字段才能保存到数据库中。
- en: Because you want to add a newsletter subscription form to the recipe application,
    create a schema for the subscriber. Add the code from [listing 14.3](#ch14ex03)
    to main.js. `mongoose.Schema` offers a constructor that allows you to build a
    schema object with the given parameters. Then add object properties to state the
    name of the object’s field and its data type. Someone’s name can’t be a number,
    for example.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您想在食谱应用程序中添加一个新闻通讯订阅表单，所以为订阅者创建一个模式。将 [列表 14.3](#ch14ex03) 中的代码添加到 main.js
    中。`mongoose.Schema` 提供了一个构造函数，允许您使用给定的参数构建一个模式对象。然后添加对象属性以声明对象的字段名称和数据类型。例如，某人的姓名不能是数字。
- en: Listing 14.3\. Subscriber schema in main.js
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.3\. main.js 中的订阅者模式
- en: '[PRE8]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1*** **Create a new schema with mongoose.Schema.**'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用 mongoose.Schema 创建一个新的模式。**'
- en: '***2*** **Add schema properties.**'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加模式属性。**'
- en: '|  |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: MongoDB isn’t enforcing your schema; Mongoose is. For more information about
    Mongoose schema data types, visit [http://mongoosejs.com/docs/schematypes.html](http://mongoosejs.com/docs/schematypes.html).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 不强制执行您的模式；Mongoose 是。有关 Mongoose 模式数据类型的更多信息，请访问 [http://mongoosejs.com/docs/schematypes.html](http://mongoosejs.com/docs/schematypes.html)。
- en: '|  |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that the schema is defined, you need to apply it to a model by using `const
    Subscriber = mongoose.model(`“`Subscriber`”`, subscriberSchema)`. The model is
    what you’ll use to instantiate new `Subscriber` objects, and the schema you created
    can be used for that model. The `model` method takes a model name of your choosing
    and a previously defined schema (in this case, the `subscriberSchema`).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模式已定义，您需要通过使用 `const Subscriber = mongoose.model(`“`Subscriber`”`, subscriberSchema)`
    将其应用于模型。模型是您将用于实例化新的 `Subscriber` 对象的，您创建的模式可以用于该模型。`model` 方法接受您选择的模型名称和先前定义的模式（在本例中为
    `subscriberSchema`）。
- en: You can instantiate new objects from this model by referring to `Subscriber`.
    You have two ways to generate new objects, as shown in [listing 14.4](#ch14ex04).
    You can construct a new instance of the `Subscriber` model by using the `new`
    keyword and by passing properties that abide by the `subscriberSchema` earlier
    in the section. To get this newly created `Subscriber` object into the database,
    you can call `save` on it and handle any errors or returned data through a callback
    function.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过引用 `Subscriber` 从此模型中实例化新对象。您有两种生成新对象的方法，如 [列表 14.4](#ch14ex04) 所示。您可以通过使用
    `new` 关键字并传递符合本节中较早提到的 `subscriberSchema` 的属性来构造 `Subscriber` 模型的新实例。要将这个新创建的
    `Subscriber` 对象保存到数据库中，您可以在其上调用 `save` 并通过回调函数处理任何错误或返回的数据。
- en: An error may have to do with data that doesn’t match the schema types you defined
    earlier. The saved item returns data that you can use elsewhere in the application.
    You may want to thank the subscriber by name for signing up, for example. `create`
    does what `new` and `save` do in one step. If you know that you want to create
    and save the object right away, use this Mongoose method.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 错误可能与您之前定义的模式类型不匹配的数据有关。保存的项目返回您可以在应用程序的其他地方使用的数据。例如，您可能想通过姓名感谢订阅者注册。`create`在一步中完成了`new`和`save`的功能。如果您知道您想立即创建并保存对象，请使用此Mongoose方法。
- en: '|  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Instantiating objects from your Mongoose models is similar to instantiating
    Java-Script objects. The `new` keyword can be used with JavaScript Array and other
    data types.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的Mongoose模型中实例化对象类似于从Java-Script对象中实例化。`new`关键字可以与JavaScript数组和其他数据类型一起使用。
- en: '|  |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 14.4\. Statements to create and save models in main.js
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.4\. 在main.js中创建和保存模型的语句
- en: '[PRE9]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1*** **Instantiate a new subscriber.**'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **实例化一个新的订阅者。**'
- en: '***2*** **Save a subscriber to the database.**'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将订阅者保存到数据库中。**'
- en: '***3*** **Pass potential errors to the next middleware function.**'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将潜在的错误传递给下一个中间件函数。**'
- en: '***4*** **Log saved data document.**'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **记录保存的数据文档。**'
- en: '***5*** **Create and save a subscriber in a single step.**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **一步创建并保存订阅者。**'
- en: Add the code from the listings in this section to your main.js file. As soon
    as you start the application with `node main.js`, you should see your MongoDB
    `recipe_db` database populate with a new subscriber.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 将本节中的代码添加到您的main.js文件中。一旦您使用`node main.js`启动应用程序，您应该看到您的MongoDB `recipe_db`数据库中填充了新的订阅者。
- en: '|  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 14.2**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查14.2**'
- en: '**[Q1:](#ch14qa4q0a1)**'
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch14qa4q0a1)**'
- en: ''
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'True or false: Using `new Subscriber({ name:` “`Jon`”`, email:` “`jon@jonwexler.com`”`})`
    saves a new record to your database.'
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正误：使用`new Subscriber({ name:` “`Jon`”`, email:` “`jon@jonwexler.com`”`})`将新记录保存到您的数据库中。
- en: '|  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 14.2 answer**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 14.2 答案**'
- en: '**[1:](#ch14qa3q1)**'
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch14qa3q1)**'
- en: ''
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: False. This code only creates a new virtual object. If you store the value of
    this line to a variable and call `save` on that variable, the new subscriber is
    stored in the database.
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误。此代码仅创建一个新的虚拟对象。如果您将此行的值存储到变量中并在该变量上调用`save`，则新订阅者将被存储在数据库中。
- en: '|  |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)14.3\. Organizing your models'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)14.3\. 组织您的模型'
- en: Now that you have a way of saving data in the form of Mongoose models, you’ll
    want to organize your models so that they don’t clutter your main.js file. As
    you do for your views and controllers, create a models folder at the root level
    of your application. Within that folder, create a new file called subscriber.js.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有了以Mongoose模型形式保存数据的方法，您可能想要组织您的模型，以便它们不会使您的main.js文件杂乱。就像您为视图和控制器做的那样，在应用程序的根级别创建一个名为models的文件夹。在该文件夹内，创建一个名为subscriber.js的新文件。
- en: This file is where you’ll move your model’s code. Move all the schema and model
    definition code to this file and the model to the file’s `exports` object. (See
    the following listing.) Any module that requires subscriber.js will have access
    to the `Subscriber` model. The schema doesn’t need to be made accessible outside
    the file.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件是您将模型代码移动到的位置。将所有模式和模型定义代码移动到该文件，并将模型移动到文件的`exports`对象中。（参见以下列表。）任何需要`subscriber.js`的模块都将能够访问`Subscriber`模型。模式不需要在文件外部公开。
- en: Listing 14.5\. Moving the schema and model to a separate module
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.5\. 将模式和模型移动到单独的模块
- en: '[PRE10]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1*** **Export the Subscriber model as the only module export.**'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将订阅者模型作为唯一的模块导出。**'
- en: '|  |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You need to require `mongoose` in this module because both the schema and model
    use Mongoose methods to work. Node.js loads a module into the project only once,
    so requiring it here shouldn’t slow your application; you’re telling Node.js that
    you want to use an already-loaded module.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在这个模块中引入`mongoose`，因为模式和模型都使用Mongoose方法来工作。Node.js只将一个模块加载到项目中一次，所以在这里引入它不应该减慢您的应用程序；您正在告诉Node.js您想使用一个已加载的模块。
- en: '|  |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Next, require this model in your main.js by adding `const Subscriber = require(`“`./models/subscriber`”`)`
    below your other required modules. Now you should be able to use the model the
    same way as before.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过在您的其他所需模块下方添加`const Subscriber = require(`“`./models/subscriber`”`)`来在main.js中引入此模型。现在您应该能够像以前一样使用该模型。
- en: In main.js, find documents in your database by using Mongoose’s `findOne` and
    `where` query methods. As an example, you can use `Subscriber.findOne({ name:`
    “`Jon Wexler`” `}) .where(`“`email`”`, /wexler/)` to find and return one document
    that matches the criteria name where the email contains the string “`wexler`”.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '在 main.js 中，使用 Mongoose 的 `findOne` 和 `where` 查询方法在你的数据库中查找文档。例如，你可以使用 `Subscriber.findOne({
    name: "Jon Wexler"}) .where("email", /wexler/)` 来查找并返回一个匹配以下条件的文档：电子邮件包含字符串 "wexler"。'
- en: This example custom query shows how flexible your queries can be to get the
    data you need. Mongoose lets you chain parts of a query and even store queries
    in a variable. You could create a variable `var findWexlers` and assign it to
    the code querying for emails with the word `wexler`. Then you could run the query
    later by using `findWexlers.exec()`. (For more on `exec`, see [lesson 15](../Text/kindle_split_029.html#ch15).)
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自定义查询示例展示了你的查询如何灵活，以获取你需要的数据。Mongoose 允许你链式调用查询的一部分，甚至可以将查询存储在变量中。你可以创建一个变量
    `var findWexlers` 并将其分配给查询电子邮件中包含单词 `wexler` 的代码。然后你可以通过使用 `findWexlers.exec()`
    在以后运行查询。（有关 `exec` 的更多信息，请参阅 [第 15 课](../Text/kindle_split_029.html#ch15)。）
- en: If you plan to run a query immediately without the `exec` method, you need a
    callback function with two arguments. The first argument represents any errors
    that occur, and the second argument represents any data returned by the database,
    as shown in the following listing. Try creating your own queries by following
    some of the example queries at [http://mongoosejs.com/docs/queries.html](http://mongoosejs.com/docs/queries.html).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划立即运行查询而不使用 `exec` 方法，你需要一个带有两个参数的回调函数。第一个参数表示发生的任何错误，第二个参数表示数据库返回的任何数据，如下所示。尝试通过遵循
    [http://mongoosejs.com/docs/queries.html](http://mongoosejs.com/docs/queries.html)
    上的某些示例查询来创建你自己的查询。
- en: Listing 14.6\. Example query to run in main.js
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.6\. 在 main.js 中运行的示例查询
- en: '[PRE11]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1*** **Run a query with a callback function to handle errors and data.**'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **运行一个带有回调函数的查询以处理错误和数据。**'
- en: '|  |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: For queries indicating that multiple items will be returned from the database,
    you should expect an array. If no documents are found, you get an empty array.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表示将从数据库返回多个项目的查询，你应该期望一个数组。如果没有找到文档，你将得到一个空数组。
- en: '|  |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now you have the freedom to create more modules and save them by using their
    names instead of the MongoDB collection names.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有自由创建更多模块，并通过使用它们的名称而不是 MongoDB 集合名称来保存它们。
- en: In [unit 4](../Text/kindle_split_031.html#part04), you learn how to make a more-robust
    model whose values can be created, read, updated, and deleted—the four core model
    functions in a CRUD application. I discuss this approach in detail in that unit.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [单元 4](../Text/kindle_split_031.html#part04) 中，你学习了如何创建一个更健壮的模型，其值可以创建、读取、更新和删除——CRUD
    应用程序中的四个核心模型功能。我在那个单元中详细讨论了这种方法。
- en: '|  |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 14.3**'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 14.3**'
- en: '**[Q1:](#ch14qa6q0a1)**'
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch14qa6q0a1)**'
- en: ''
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What two components are required for each field specified in a Mongoose schema?
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在 Mongoose 架构中指定每个字段需要哪些两个组件？
- en: '|  |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 14.3 answer**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 14.3 答案**'
- en: '**[1:](#ch14qa5q1)**'
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch14qa5q1)**'
- en: ''
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The schema requires a property name and data type.
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 架构需要属性名称和数据类型。
- en: '|  |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this lesson, you learned how to set up Mongoose and use your MongoDB connection
    to map data to your database. You also learned about some Mongoose syntax and
    methods. Through the steps in this lesson, you learned how to create a schema
    and model for storing persistent data. Last, you organized your models, clearing
    your main.js for new tools to come. In [lesson 15](../Text/kindle_split_029.html#ch15),
    you clean up some of the functionality that you built in this lesson by implementing
    JavaScript promises in your database queries.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何设置 Mongoose 并使用你的 MongoDB 连接将数据映射到数据库。你还了解了一些 Mongoose 语法和方法。通过本课中的步骤，你学习了如何创建用于存储持久数据的架构和模型。最后，你组织了你的模型，为新的工具腾出空间。在
    [第 15 课](../Text/kindle_split_029.html#ch15) 中，你通过在数据库查询中实现 JavaScript promises
    来清理本课中构建的一些功能。
- en: '|  |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Try this**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这个**'
- en: Eventually, you’ll create more models for your recipe application. Start to
    think about what those models will look like. You may need a model to represent
    the different types of courses offered through the program, for example. Try creating
    a schema and model for a recipe item.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你将为你的食谱应用创建更多模型。开始思考这些模型将是什么样子。例如，你可能需要一个模型来表示通过该计划提供的不同类型的课程。尝试创建一个食谱条目的架构和模型。
- en: '|  |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Lesson 15\. Connecting Controllers and Models
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第15课：连接控制器和模型
- en: So far, you’ve set up your Node.js application to handle data and store that
    data in a MongoDB database. With the help of Mongoose, you’ve structured your
    data with a model and schema. In this lesson, you connect your routes to your
    controllers and to these models so that you can start to save meaningful data
    based on your user’s URL requests. First, you build a new controller for subscriber
    routes. Then you will convert those routes to use JavaScript ES6-enabled promises.
    Adding promises gives more flexibility to your database calls now and as your
    application grows. Finally, you wrap up this lesson with new views and a form
    where subscribers can post their information.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经设置了你的 Node.js 应用程序来处理数据并将数据存储在 MongoDB 数据库中。在 Mongoose 的帮助下，你已经使用模型和模式结构化了你的数据。在本课中，你将你的路由连接到控制器和这些模型，以便你可以开始根据用户的
    URL 请求保存有意义的基于用户的数据。首先，你将为订阅者路由构建一个新的控制器。然后，你将把这些路由转换为使用 JavaScript ES6 允许的 Promise。添加
    Promise 现在给你的数据库调用提供了更多的灵活性，并且随着应用程序的增长。最后，你将本课总结为新的视图和表单，订阅者可以在其中发布他们的信息。
- en: This lesson covers
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 本课涵盖
- en: Connecting controllers to models
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将控制器连接到模型
- en: Saving data through a controller action
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过控制器动作保存数据
- en: Implementing database queries with promises
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Promise 实现数据库查询
- en: Handling posted form data
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理提交的表单数据
- en: '|  |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Consider this**'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑以下内容**'
- en: Your recipe application is taking shape with Mongoose models to represent data
    in your database. JavaScript, however, is asynchronous in your application, so
    database calls require callbacks to run upon completion. Callbacks can be messy,
    though, especially with complicated queries.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你的食谱应用程序正在使用 Mongoose 模型来表示数据库中的数据。然而，JavaScript 在你的应用程序中是异步的，所以数据库调用需要回调在完成时运行。但是，回调可能会很混乱，尤其是在复杂的查询中。
- en: Luckily, you can use multiple other types of syntax to wrap your callbacks and
    handle returned data or errors in a more elegant way. Promises are a way to do
    that, and Mongoose offers support for using the promise syntax within your application.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以使用多种其他类型的语法来包装你的回调，并以更优雅的方式处理返回的数据或错误。Promise 是实现这一点的途径，Mongoose 也提供了在你的应用程序中使用
    Promise 语法的支持。
- en: '|  |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)15.1\. Creating a controller for subscribers'
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![图片](../Images/sectionFig.png)15.1. 创建订阅者控制器'
- en: Recall that controllers are the glue between your models (the data) and your
    views (the web page). Now that you have a model set up, you need a controller
    that handles external requests specifically looking for data related to your model.
    If someone requests the home path `/`, you can return a view following logic in
    the home controller. Now that someone may request to register as a subscriber,
    you need to implement a subscriber controller. Create a new file in your controllers
    folder called subscribersController.js.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，控制器是你模型（数据）和视图（网页）之间的粘合剂。现在你已经设置好了模型，你需要一个控制器来处理针对与你的模型相关的数据的特定外部请求。如果有人请求主页路径`/`，你可以通过主页控制器中的逻辑返回一个视图。现在，如果有人想要注册为订阅者，你需要实现一个订阅者控制器。在你的控制器文件夹中创建一个名为`subscribersController.js`的新文件。
- en: '|  |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Conventionally, controllers are named in the plural version of your model. There’s
    no strict rule, and as you can see, you already have a homeController.js, but
    this controller doesn’t represent a model in the application.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，控制器以你的模型复数形式命名。没有严格的规则，正如你所见，你已经有一个`homeController.js`，但这个控制器在应用程序中并不代表一个模型。
- en: '|  |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This file needs access to `mongoose` and your `Subscriber` model, both of which
    can be required at the top of the file. Next, you can create a controller action
    for when a request is made to view all subscribers in your database. The code
    would look like [listing 15.1](#ch15ex01). You require `mongoose` so that you
    have access to the tools needed to save your model to the database. Next, require
    the `Subscriber` model from your `subscriber` module so that you can integrate
    the model into your code logic; you no longer need any reference to the `Subscriber`
    model in main.js. `getAllSubscribers` will be accessible to any file that requires
    this module. You can use this exported callback function to return data from the
    database.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件需要访问 `mongoose` 和你的 `Subscriber` 模型，这两个都可以在文件顶部引入。接下来，你可以创建一个控制器操作，用于处理对数据库中所有订阅者视图的请求。代码看起来像
    [列表 15.1](#ch15ex01)。引入 `mongoose` 以便访问将模型保存到数据库所需的工具。接下来，从你的 `subscriber` 模块中引入
    `Subscriber` 模型，以便将其集成到你的代码逻辑中；你不再需要在 main.js 中引用 `Subscriber` 模型。`getAllSubscribers`
    将对任何需要此模块的文件可用。你可以使用这个导出的回调函数从数据库返回数据。
- en: In this controller action, you use the Mongoose `find` method on the `Subscriber`
    model to tell MongoDB that you want an array of all the subscribers in your database.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在此控制器操作中，你使用 Mongoose 的 `find` 方法在 `Subscriber` 模型上，告诉 MongoDB 你想要数据库中所有订阅者的数组。
- en: '|  |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Using the `find` query method without any arguments is the same as an empty
    object (`{}`). Here, you’re using the empty object to make it clear that you want
    to get all subscribers with no conditions attached.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不带任何参数的 `find` 查询方法与空对象 (`{}`) 相同。在这里，你使用空对象来明确表示你想要获取所有订阅者，没有任何附加条件。
- en: '|  |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: If an error occurs while reading from the database, send it to the next middleware
    function. Otherwise, set the data that comes back from MongoDB to the request
    object. Then this object can be accessed by the next function in the middleware
    chain.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在从数据库读取时发生错误，将其发送到下一个中间件函数。否则，将来自 MongoDB 的数据设置到请求对象中。然后这个对象可以被中间件链中的下一个函数访问。
- en: Listing 15.1\. Building your subscribers controller in subscribersController.js
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.1\. 在 subscribersController.js 中构建你的订阅者控制器
- en: '[PRE12]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1*** **Require the subscriber module.**'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入订阅者模块。**'
- en: '***2*** **Export getAllSubscribers to pass data from the database to the next
    middleware function.**'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **导出 `getAllSubscribers` 以将数据库数据传递给下一个中间件函数。**'
- en: '***3*** **Query with find on the Subscriber model.**'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在订阅者模型上使用 find 查询。**'
- en: '***4*** **Pass an error to the next middleware function.**'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将错误传递给下一个中间件函数。**'
- en: '***5*** **Set data that comes back from MongoDB on request object.**'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **将来自 MongoDB 的请求数据设置在请求对象中。**'
- en: '***6*** **Continue to the next middleware function.**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **继续到下一个中间件函数。**'
- en: '|  |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Because the model is in a different folder, you need to use `..` to indicate
    stepping out of your current folder before entering the models folder and requiring
    it.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 因为模型在不同的文件夹中，你需要使用 `..` 来表示在进入模型文件夹之前退出当前文件夹，然后引入它。
- en: '|  |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Make sure that you still have Express.js installed and working properly. The
    next step is setting up the route in main.js. First, make sure to require the
    subscribers controller in main.js by using `const subscribersController = require("./controllers/subscribers
    -Controller")`. The route you use looks like the code in [listing 15.2](#ch15ex02).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你仍然安装并正确设置了 Express.js。下一步是在 main.js 中设置路由。首先，确保通过使用 `const subscribersController
    = require("./controllers/subscribers -Controller")` 在 main.js 中引入订阅者控制器。你使用的路由看起来像
    [列表 15.2](#ch15ex02) 中的代码。
- en: In this code, you’re looking for `GET` requests made to the `/subscribers` path.
    Upon getting a request, pass the request to your `getAllSubscribers` function
    in subscribersController.js. Because you aren’t doing anything with the data in
    that function, attach the results of your query to the request object, and pass
    it to the next middleware function. In this case, that function is a custom callback
    created to render the data in the browser.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，你正在寻找对 `/subscribers` 路径发出的 `GET` 请求。在接收到请求后，将请求传递给 subscribersController.js
    中的 `getAllSubscribers` 函数。因为在该函数中你没有对数据进行任何操作，所以将查询结果附加到请求对象上，并将其传递给下一个中间件函数。在这种情况下，该函数是一个自定义回调，用于在浏览器中渲染数据。
- en: Listing 15.2\. Using the subscribers controller in main.js
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.2\. 在 main.js 中使用订阅者控制器
- en: '[PRE13]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1*** **Pass the request to the getAllSubscribers function.**'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将请求传递给 `getAllSubscribers` 函数。**'
- en: '***2*** **Log data from the request object.**'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **记录请求对象中的数据。**'
- en: '***3*** **Render the data on the browser window.**'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在浏览器窗口上渲染数据。**'
- en: Test this code by running `npm start` to relaunch your application. If everything
    worked as planned, you can visit http://localhost:3000/subscribers and see a list
    of all the subscribers in your database by name and email ([figure 15.1](#ch15fig01)).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `npm start` 重新启动您的应用程序来测试此代码。如果一切按计划进行，您可以通过访问 http://localhost:3000/subscribers
    来查看按姓名和电子邮件列出的数据库中所有订阅者（[图 15.1](#ch15fig01)）。
- en: Figure 15.1\. Example browser response with subscriber data
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 15.1\. 包含订阅者数据的示例浏览器响应
- en: '![](../Images/15fig01_alt.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15fig01_alt.jpg)'
- en: 'You could immediately improve this action by responding with the data in a
    view instead of returning the data. Modify the action’s return statements and
    replace them with `res.render` from Express.js. The line to render a view called
    `subscribers.ejs` could look like `res.render(`“`subscribers`”;`, {subscribers:
    req.data})`. The response makes a call to render a view called `subscribers.ejs`
    and passes the subscribers from the database to that view in a variable called
    `subscribers`. Now you need to build the view to display these subscribers.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以通过在视图中响应数据而不是返回数据来立即改进此操作。修改操作的返回语句，并用 Express.js 中的 `res.render` 替换它们。渲染名为
    `subscribers.ejs` 的视图的行可能看起来像 `res.render(`“`subscribers`”;`, {subscribers: req.data})`。响应调用渲染一个名为
    `subscribers.ejs` 的视图，并通过一个名为 `subscribers` 的变量将数据库中的订阅者传递给该视图。现在您需要构建视图来显示这些订阅者。'
- en: '|  |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Ultimately, this page will be used by administrators of the application to see
    who has signed up for the recipe application. But right now, this page is public
    to anyone who visits its associated route.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这个页面将由应用程序的管理员使用，以查看谁注册了食谱应用程序。但到目前为止，这个页面对其关联的路由的访问是公开的。
- en: '|  |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Create a file in your views folder called subscribers.ejs, and add the code
    in [listing 15.3](#ch15ex03). Using the EJS template syntax, loop through the
    `subscribers` array passed in from the action you just created. For each subscriber,
    `s`, you can print some information. You print the name and email address of the
    subscriber in a paragraph tag.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的视图文件夹中创建一个名为 subscribers.ejs 的文件，并添加 [列表 15.3](#ch15ex03) 中的代码。使用 EJS 模板语法，遍历从您刚刚创建的操作中传递的
    `subscribers` 数组。对于每个订阅者 `s`，您可以打印一些信息。您在段落标签中打印订阅者的姓名和电子邮件地址。
- en: Listing 15.3\. Looping and printing subscribers in a subscribers.ejs
  id: totrans-384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.3\. 在 subscribers.ejs 中循环并打印订阅者
- en: '[PRE14]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1*** **Loop through subscribers.**'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **遍历订阅者。**'
- en: '***2*** **Insert subscriber data into the view.**'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将订阅者数据插入到视图中。**'
- en: Your view at http://localhost:3000/subscribers should list your subscribers,
    as shown in [figure 15.2](#ch15fig02).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 您的视图 http://localhost:3000/subscribers 应该列出您的订阅者，如图 [图 15.2](#ch15fig02) 所示。
- en: Figure 15.2\. Example browser view with listed subscriber data
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 15.2\. 列出订阅者数据的示例浏览器视图
- en: '![](../Images/15fig02_alt.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15fig02_alt.jpg)'
- en: In the next section, you add two more routes to handle information posted with
    a form.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将添加两个额外的路由来处理通过表单发布的信息。
- en: '|  |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 15.1**'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 15.1**'
- en: '**[Q1:](#ch15qa2q0a1)**'
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch15qa2q0a1)**'
- en: ''
  id: totrans-395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From what module do you pass data to the view?
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您从哪个模块将数据传递到视图中？
- en: '|  |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 15.1 answer**'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 15.1 答案**'
- en: '**[1:](#ch15qa1q1)**'
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch15qa1q1)**'
- en: ''
  id: totrans-401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You can pass data to the view from your controller. Within subscribersController.js,
    you pass an array of subscribers within the rendered `subscribers.ejs`.
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 您可以从控制器将数据传递到视图中。在 subscribersController.js 中，您在渲染的 `subscribers.ejs` 中传递一个订阅者数组。
- en: '|  |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)15.2\. Saving posted data to a model'
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)15.2\. 将发布的数据保存到模型中'
- en: So far, you should have data flowing in one direction when a request is made
    to your application’s web server. The next step is saving user-submitted data
    in the form of a subscriber object. [Figure 15.3](#ch15fig03) shows the flow of
    information from a form to your database.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当向您的应用程序的 web 服务器发出请求时，应该只有一个方向的数据流动。下一步是将用户提交的数据以订阅者对象的形式保存。[图 15.3](#ch15fig03)
    展示了从表单到您数据库的信息流。
- en: Figure 15.3\. Flow from a web page form to your database
  id: totrans-406
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 15.3\. 从网页表单到您的数据库的流程
- en: '![](../Images/15fig03_alt.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15fig03_alt.jpg)'
- en: Recall that according to its schema, a subscriber object must contain name,
    email, and zipCode fields, so you should have a view with a form that contains
    these input fields. Change the form in contact.ejs to use the form shown in the
    next listing. The form will submit data to the `/subscribe` path via an HTTP `POST`
    request. The inputs of the form match the fields of the subscriber model.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，根据其模式，订阅者对象必须包含名称、电子邮件和邮政编码字段，所以你应该有一个包含这些输入字段的表单视图。将 contact.ejs 中的表单更改为使用下一个列表中显示的表单。表单将通过
    HTTP `POST` 请求将数据提交到 `/subscribe` 路径。表单的输入与订阅者模型的字段相匹配。
- en: Listing 15.4\. Form to post subscriber data in contact.ejs
  id: totrans-409
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.4\. 在 contact.ejs 中将表单数据发布到订阅者数据
- en: '[PRE15]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1*** **Add a subscription form.**'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加订阅表单。**'
- en: Because this form will display when `contact.ejs` is rendered, create a route
    to render this view when requests are made to the `/contact` path from the subscribers
    controller. You need to build a `GET` route for the `/subscribe` path and modify
    the existing `POST` route for the `/contact` path. These routes look like the
    code in [listing 15.5](#ch15ex05).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个表单将在 `contact.ejs` 渲染时显示，所以创建一个路由，当从订阅者控制器请求 `/contact` 路径时渲染这个视图。你需要为 `/subscribe`
    路径构建一个 `GET` 路由，并修改现有 `/contact` 路径的 `POST` 路由。这些路由看起来像 [列表 15.5](#ch15ex05) 中的代码。
- en: The first route listens for requests made to `/subscribe` and uses the `getSubscriptionPage`
    callback in the `subscribersController`. The second route uses the `saveSubscriber`
    callback function only for requests made with the `POST` method.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条路由监听对 `/subscribe` 的请求，并在 `subscribersController` 中使用 `getSubscriptionPage`
    回调。第二条路由仅对使用 `POST` 方法的请求使用 `saveSubscriber` 回调函数。
- en: '|  |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: After these changes, you no longer need the contact form route handlers in homeController.js
    or their routes in main.js.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改之后，你不再需要在 homeController.js 中使用联系表单路由处理程序或 main.js 中的它们的路由。
- en: '|  |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing 15.5\. Routes for the subscriptions in main.js
  id: totrans-418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.5\. 主.js 中的订阅路由
- en: '[PRE16]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1*** **Add a GET route for the subscription page.**'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加一个用于订阅页面的 GET 路由。**'
- en: '***2*** **Add a POST route to handle subscription data.**'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加一个 POST 路由来处理订阅数据。**'
- en: To complete your work here, create the `getSubscriptionPage` and `saveSubscriber`
    functions. Within subscribersController.js, add the code in [listing 15.6](#ch15ex06).
    The first action renders an EJS page from the views folder. `saveSubscriber` collects
    data from the request and allows the `body-parser` package (installed in [unit
    2](../Text/kindle_split_020.html#part02)) to read the request body’s contents.
    A new model instance is created, mapping the subscriber’s fields to the request
    body parameters. As a final step, try to save the subscriber. If it fails, respond
    with the error that occurred. If it succeeds, respond with `thanks.ejs`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这里的工作，创建 `getSubscriptionPage` 和 `saveSubscriber` 函数。在 subscribersController.js
    中，添加 [列表 15.6](#ch15ex06) 中的代码。第一个操作从视图文件夹渲染一个 EJS 页面。`saveSubscriber` 从请求中收集数据，并允许
    `body-parser` 包（在 [单元 2](../Text/kindle_split_020.html#part02) 中安装）读取请求体的内容。创建一个新的模型实例，将订阅者的字段映射到请求体参数。作为最后一步，尝试保存订阅者。如果失败，则响应错误。如果成功，则响应
    `thanks.ejs`。
- en: Listing 15.6\. Controller actions for subscription routes in subscribersController.js
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.6\. 订阅路由的控制器操作在 subscribersController.js
- en: '[PRE17]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1*** **Add an action to render the contact page.**'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加一个渲染联系页面的操作。**'
- en: '***2*** **Add an action to save subscribers.**'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加一个保存订阅者的操作。**'
- en: '***3*** **Create a new subscriber.**'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **创建一个新的订阅者。**'
- en: '***4*** **Save a new subscriber.**'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **保存一个新的订阅者。**'
- en: '|  |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: MongoDB returns the `_id` of the newly created subscriber. The `result` variable
    in the example contains this information.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 返回新创建的订阅者的 `_id`。示例中的 `result` 变量包含此信息。
- en: '|  |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: You can try this code by filling out your own form at http://localhost/contact.
    Then visit http://localhost:3000/subscribers to see the list of subscribers, including
    your new post. In the next section, you add one more touch to your database queries
    by using JavaScript promises.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 http://localhost/contact 填写自己的表单来尝试这段代码。然后访问 http://localhost:3000/subscribers
    来查看订阅者列表，包括你的新帖子。在下一节中，你将通过使用 JavaScript promises 来添加数据库查询的一个额外功能。
- en: '|  |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 15.2**'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 15.2**'
- en: '**[Q1:](#ch15qa4q0a1)**'
  id: totrans-436
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch15qa4q0a1)**'
- en: ''
  id: totrans-437
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What middleware is needed in addition to Express.js to process data from a form?
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除了 Express.js 之外，还需要哪些中间件来处理表单数据？
- en: '|  |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**QC 15.2 answer**'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 15.2 答案**'
- en: '**[1:](#ch15qa3q1)**'
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch15qa3q1)**'
- en: ''
  id: totrans-443
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To easily parse the body of a request, you need the help of the `express.json`
    and `express.urlencoded` middleware function. These modules act as middleware
    between your request being received and processed fully with Express.js.
  id: totrans-444
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 为了轻松解析请求体，你需要`express.json`和`express.urlencoded`中间件函数的帮助。这些模块在Express.js接收并完全处理请求之间充当中间件。
- en: '|  |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '![](../Images/sectionFig.png)15.3\. Using promises with Mongoose'
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)15.3\. 使用Mongoose的承诺'
- en: ES6 made popular the idea of using promises to facilitate a chain of functions,
    usually callback functions, in asynchronous queries. A *promise* is a JavaScript
    object that contains information about the state of a function call and what the
    next call in the chain needs to see. Similar to middleware, promises can allow
    a function to start and patiently wait for it to complete before passing it off
    to the next callback function. Ultimately, promises offer a cleaner way of representing
    nested callbacks, and with database queries now introduced to your applications,
    your callback functions can get long.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: ES6使使用承诺来促进异步查询中函数链（通常是回调函数）的想法变得流行。*承诺*是一个包含有关函数调用状态和链中下一个调用需要看到的信息的JavaScript对象。类似于中间件，承诺可以允许一个函数开始并耐心等待它完成，然后再将其传递给下一个回调函数。最终，承诺提供了一种更干净的方式来表示嵌套回调，并且随着数据库查询现在被引入到你的应用程序中，你的回调函数可以变得很长。
- en: Luckily, Mongoose is built to work with promises. All you need to do to get
    set up is let Mongoose know that you want to use native ES6 promises by adding
    `mongoose.Promise = global.Promise` near the top of main.js. Now with each query
    made, you can choose to return the normal database response or a promise containing
    that response. In [listing 15.7](#ch15ex07), for example, a query to get all subscribers
    from the database returns a new promise with the database’s response.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Mongoose被构建为与承诺一起工作。你需要做的只是让Mongoose知道你想要使用原生的ES6承诺，通过在main.js的顶部附近添加`mongoose.Promise
    = global.Promise`。现在，对于每个查询，你可以选择返回正常的数据库响应或包含该响应的承诺。例如，在[列表15.7](#ch15ex07)中，从数据库获取所有订阅者的查询返回了一个包含数据库响应的新承诺。
- en: Rewriting this action with a promise still allows querying of all subscribers
    in the database. Within the query, instead of rendering a view immediately, return
    a promise that contains data on whether to resolve by rendering a view or reject
    by logging an error. By using the `exec` call following `find`, you’re invoking
    your query to return a promise.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 使用承诺重写此操作仍然允许查询数据库中的所有订阅者。在查询中，而不是立即渲染视图，返回一个包含有关通过渲染视图解决或通过记录错误拒绝的数据的承诺。通过使用`find`之后的`exec`调用，你正在调用查询以返回一个承诺。
- en: '|  |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Without using `exec`, you’re still able to use `then` and `catch` to handle
    follow-up commands. Without `exec`, however, you won’t have an authentic promise—only
    Mongoose’s version of a promise query. Some Mongoose methods, however, such as
    `save`, return a promise and won’t work with `exec`. You can read more about the
    distinctions at [http://mongoosejs.com/docs/promises.html](http://mongoosejs.com/docs/promises.html).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不使用`exec`，你仍然可以使用`then`和`catch`来处理后续命令。然而，没有`exec`，你将不会有一个真实的承诺——只有Mongoose的承诺查询版本。但是，一些Mongoose方法，例如`save`，返回一个承诺并且不能与`exec`一起使用。你可以在[http://mongoosejs.com/docs/promises.html](http://mongoosejs.com/docs/promises.html)了解更多关于区别的信息。
- en: '|  |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: If an error occurs in the process, the error propagates down the promise chain
    to the `catch` block. Otherwise, data returned from the query passes on to the
    next `then` block. This promise-chain procedure follows the promise convention
    of rejecting or resolving code in a promise block to determine what code should
    be run next ([figure 15.4](#ch15fig04)).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在处理过程中发生错误，错误会沿着承诺链传播到`catch`块。否则，查询返回的数据会传递到下一个`then`块。这种承诺链过程遵循在承诺块中拒绝或解决代码的承诺约定，以确定应该运行哪个代码([图15.4](#ch15fig04))。
- en: Figure 15.4\. Promise chain in Mongoose.js
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.4\. Mongoose.js中的承诺链
- en: '![](../Images/15fig04_alt.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/15fig04_alt.jpg)'
- en: When the promise is complete, it calls `next` to use any following middleware
    in Express.js. You chain on a `then` method to tell the promise to perform this
    task immediately after the database responds. This `then` block is where you render
    your view. Next, the `catch` method is chained to handle any errors rejected in
    the promise.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 当承诺完成时，它会调用`next`来使用Express.js中的任何后续中间件。你通过链式调用一个`then`方法来告诉承诺在数据库响应后立即执行此任务。这个`then`块是你渲染视图的地方。接下来，链式调用`catch`方法来处理承诺中拒绝的任何错误。
- en: '|  |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-459
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: '`then` is used only in the context of promises. `next` is used in a middleware
    function. If both are used, as in [listing 15.7](#ch15ex07), you’re waiting for
    a promise to resolve with `then` and later calling `next` to go to another middleware
    function.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`then` 仅在 promise 的上下文中使用。`next` 在中间件函数中使用。如果两者都使用，如 [列表 15.7](#ch15ex07) 中所示，您将等待
    promise 通过 `then` 解决，然后调用 `next` 以转到另一个中间件函数。'
- en: '|  |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You can add as many `then` chains as you like, ultimately telling your promise
    to run the code within that block when everything else is complete. The final
    `then` block logs a message to your console to let you know that the promise completed.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加任意多的 `then` 链，最终告诉您的 promise 在其他所有操作完成后运行该块内的代码。最后的 `then` 块会在您的控制台记录一条消息，以告知您
    promise 已完成。
- en: Listing 15.7\. Using promises to get all subscribers in subscribersController.js
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.7\. 在 subscribersController.js 中使用 promises 获取所有订阅者
- en: '[PRE18]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1*** **Rewrite the getAllSubscribers action.**'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **重写 getAllSubscribers 动作。**'
- en: '***2*** **Return a promise from the find query.**'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **从 find 查询返回 promise。**'
- en: '***3*** **Send saved data to the next then code block.**'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将保存的数据发送到下一个代码块。**'
- en: '***4*** **Serve results from the database.**'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **从数据库中提供结果。**'
- en: '***5*** **Catch errors that are rejected in the promise.**'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **捕获 promise 中拒绝的错误。**'
- en: '***6*** **End the promise chain with a log message.**'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **使用日志消息结束 promise 链。**'
- en: You may also modify your `save` command in `saveSubscriber` to use promises
    as shown in the following listing. In this example, `exec` isn’t needed.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以修改 `saveSubscriber` 中的 `save` 命令，以使用以下列表中所示的方式使用 promises。在此示例中，不需要 `exec`。
- en: Listing 15.8\. Modifying saveSubscriber to use promises in subscribers-Controller.js
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.8\. 修改 saveSubscriber 以在 subscribers-Controller.js 中使用 promises
- en: '[PRE19]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1*** **Save a new subscriber with a promise return.**'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用 promise 返回值保存新的订阅者。**'
- en: Last, if you want to add data in bulk to your application in development instead
    of tediously entering new subscribers through the contact form, you can create
    a module for that purpose. Create seed.js in your project directory, and add the
    code in [listing 15.9](#ch15ex09). This file makes a connection to your local
    database and loops through an array of subscribers to create. First, clear the
    existing subscriber database with `remove`. Then the promise library’s `Promise.all`
    waits for all new subscriber documents to be created before printing log messages.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您想在开发中批量向应用程序添加数据，而不是通过联系表单逐个输入新订阅者，您可以为此创建一个模块。在您的项目目录中创建 seed.js，并在 [列表
    15.9](#ch15ex09) 中添加代码。此文件与您的本地数据库建立连接，并遍历订阅者数组以创建订阅者。首先，使用 `remove` 清除现有的订阅者数据库。然后，promise
    库的 `Promise.all` 等待所有新的订阅者文档创建完成后才打印日志消息。
- en: Listing 15.9\. Creating new data in seed.js
  id: totrans-476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.9\. 在 seed.js 中创建新数据
- en: '[PRE20]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1*** **Set up the connection to the database.**'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **设置与数据库的连接。**'
- en: '***2*** **Remove all existing data.**'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **删除所有现有数据。**'
- en: '***3*** **Loop through subscriber objects to create promises.**'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **遍历订阅者对象以创建 promises。**'
- en: '***4*** **Log confirmation after promises resolve.**'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **在 promises 解决后记录确认信息。**'
- en: You can run this file by entering `node seed.js` in terminal in each subsequent
    lesson to avoid having an empty or inconsistent database. I talk more about how
    to use seed data in [unit 8](../Text/kindle_split_052.html#part08).
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在终端中输入 `node seed.js` 来运行此文件，以避免在后续课程中有一个空或不一致的数据库。我在 [单元 8](../Text/kindle_split_052.html#part08)
    中更多地讨论了如何使用种子数据。
- en: '|  |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 15.3**'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 15.3**'
- en: '**[Q1:](#ch15qa6q0a1)**'
  id: totrans-485
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q1:](#ch15qa6q0a1)**'
- en: ''
  id: totrans-486
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'True or false: using exec on a Mongoose query is the same as running a query
    that returns a new promise.'
  id: totrans-487
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 exec 在 Mongoose 查询上与运行返回新 promise 的查询相同，对吗？
- en: '|  |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**QC 15.3 answer**'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '**QC 15.3 答案**'
- en: '**[1:](#ch15qa5q1)**'
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1:](#ch15qa5q1)**'
- en: ''
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: True. `exec` is designed to run a query and return a promise if promises are
    configured with your Mongoose setup.
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 是的。`exec` 设计为运行查询，如果您的 Mongoose 设置配置了 promises，则返回 promise。
- en: '|  |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this lesson, you learned how to connect your models with controller actions.
    You also made a complete connection between models, views, and controllers by
    loading a list of subscribers from your database. At the end of the lesson, you
    were introduced to promises used with Mongoose and Node.js. In [lesson 16](../Text/kindle_split_030.html#ch16),
    you take everything you learned in this unit and build a database for an application
    in the capstone exercise. In [unit 4](../Text/kindle_split_031.html#part04), you’ll
    take these steps further by building more-robust models and actions for doing
    more than saving and viewing data.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，你学习了如何将你的模型与控制器动作连接起来。你还通过从数据库中加载订阅者列表，在模型、视图和控制器之间建立了完整的连接。在本课结束时，你被介绍到与Mongoose和Node.js一起使用的承诺。在[第16课](../Text/kindle_split_030.html#ch16)中，你将在这个单元中学到的所有内容应用到架构练习中构建一个应用程序的数据库。在[第4单元](../Text/kindle_split_031.html#part04)中，你将通过构建更健壮的模型和动作来进一步执行这些步骤，以实现除了保存和查看数据之外的功能。
- en: '|  |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Try this**'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '**尝试这个**'
- en: Try converting your other controller actions to use promises. You can also chain
    other Mongoose query methods, such as `where` and `order`. Each method passes
    a promise to the next command.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将你的其他控制器动作转换为使用承诺。你还可以链式调用其他Mongoose查询方法，如`where`和`order`。每个方法都将一个承诺传递给下一个命令。
- en: '|  |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Lesson 16\. Capstone: Saving user subscriptions'
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第16课. 架构：保存用户订阅
- en: I presented the Express.js application to Confetti Cuisine, and they love it.
    They tell me that they’re ready to start promoting their cooking courses and want
    people who visit the site to subscribe to the school’s newsletter. The subscribers
    to this newsletter are potential customers, so Confetti Cuisine wants me to save
    each subscriber’s name, email address, and ZIP code.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我向Confetti Cuisine展示了Express.js应用程序，他们非常喜欢。他们告诉我，他们准备开始推广他们的烹饪课程，并希望访问网站的人订阅学校的通讯。这个通讯的订阅者是潜在客户，所以Confetti
    Cuisine希望我保存每个订阅者的姓名、电子邮件地址和邮政编码。
- en: When I have a database in place, Confetti Cuisine is comfortable with moving
    to the next stages of building user accounts. To accomplish this task, I need
    to build an application with
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 当我有一个数据库可以使用时，Confetti Cuisine对进入构建用户账户的下一阶段感到满意。为了完成这个任务，我需要构建一个具有以下功能的应用程序：
- en: A MongoDB database
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个MongoDB数据库
- en: The Mongoose package
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mongoose包
- en: A data schema with three fields
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有三个字段的数据库模式
- en: A form for subscribing on the site
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站上的订阅表单
- en: A route to handle `POST` requests and save the subscriber data model
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个处理`POST`请求并保存订阅者数据模型的路由
- en: '![](../Images/sectionFig.png)16.1\. Setting up the database'
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![数据库设置](../Images/sectionFig.png)16.1. 设置数据库'
- en: Now that Confetti Cuisine is ready to save user data, I need to install MongoDB
    and Mongoose for this project. First, I install MongoDB with Homebrew on my Mac
    by running `brew install mongodb`. Then I start the MongoDB server locally by
    running `mongod`.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Confetti Cuisine准备保存用户数据，我需要为这个项目安装MongoDB和Mongoose。首先，我在Mac上通过运行`brew install
    mongodb`使用Homebrew安装MongoDB。然后我通过运行`mongod`在本地启动MongoDB服务器。
- en: In a new terminal window, in my project directory, I install the `mongoose`
    package by entering `npm i mongoose -S` in a new terminal window within my project
    folder.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的终端窗口中，在我的项目目录中，我通过在项目文件夹中的新终端窗口中输入`npm i mongoose -S`来安装`mongoose`包。
- en: Next, I open the project’s main.js file and require `mongoose` along with my
    database configuration by using the code in [listing 16.1](#ch16ex01). I require
    `mongoose` in this project to use the module’s methods for building a connection
    to my MongoDB database. Then I set up a connection to the `confetti_cuisine` database
    on my local computer. If this database doesn’t exist yet, it’s created when I
    first run this application.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我打开项目的主.js文件，并使用[列表16.1](#ch16ex01)中的代码，引入`mongoose`以及我的数据库配置。我在这个项目中引入`mongoose`是为了使用模块的方法来建立与我的MongoDB数据库的连接。然后我设置了一个连接到本地计算机上的`confetti_cuisine`数据库。如果这个数据库还不存在，那么在我第一次运行这个应用程序时就会创建它。
- en: Listing 16.1\. Setting up Mongoose in the Node.js application in main.js
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.1. 在main.js中设置Mongoose的Node.js应用程序
- en: '[PRE21]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1*** **Require mongoose.**'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入mongoose。**'
- en: '***2*** **Set up the database connection.**'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **设置数据库连接。**'
- en: Next, I need to build out how my data should look before it goes into the database.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我需要构建我的数据在进入数据库之前应该是什么样子。
- en: '![](../Images/sectionFig.png)16.2\. Modeling data'
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![数据建模](../Images/sectionFig.png)16.2. 建模数据'
- en: Because Confetti Cuisine wants me to store three fields for new subscribers,
    I’ll create a Mongoose schema defining those fields. First, I create a new models
    folder and a new subscriber.js file with the schema from [listing 16.2](#ch16ex02).
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Confetti Cuisine要求我为新订阅者存储三个字段，我将创建一个Mongoose模式来定义这些字段。首先，我创建一个新的`models`文件夹和一个新的`subscriber.js`文件，其中包含[列表16.2](#ch16ex02)中的模式。
- en: I need to require `mongoose` into this file so that I have access to that module’s
    tools and methods. This Mongoose schema defines what a subscriber model should
    contain. In this case, every subscriber object should have name and email fields
    that are both `String`s and a zipCode field that’s a `Number`.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要将`mongoose`引入到这个文件中，以便我可以访问该模块的工具和方法。这个Mongoose模式定义了订阅者模型应该包含的内容。在这种情况下，每个订阅者对象都应该有名称和电子邮件字段，它们都是`String`类型，以及一个`zipCode`字段，它是`Number`类型。
- en: Listing 16.2\. Defining a subscriber schema in subscriber.js
  id: totrans-521
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.2\. 在`subscriber.js`中定义订阅者模式
- en: '[PRE22]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1*** **Require mongoose.**'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **引入mongoose。**'
- en: '***2*** **Define schema properties.**'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **定义模式属性。**'
- en: Now that the schema is defined, I need to define a model to use this schema.
    In other words, I’ve defined a set of rules, and now I need to create a model
    to use those rules.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模式已经定义，我需要定义一个模型来使用这个模式。换句话说，我已经定义了一套规则，现在我需要创建一个模型来使用这些规则。
- en: The subscriber model also lives in the subscriber.js file, but unlike the schema,
    the model should be accessible by other modules in the application. For that reason,
    I add the model to the module’s `exports` object, as shown in [listing 16.3](#ch16ex03).
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者模型也位于`subscriber.js`文件中，但与模式不同，模型应该可以被应用程序中的其他模块访问。因此，我将模型添加到模块的`exports`对象中，如[列表16.3](#ch16ex03)所示。
- en: I assign my subscriber model to the `module.exports` object. Other modules will
    need to require this file to access the `Subscriber` model.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我将我的订阅者模型分配给`module.exports`对象。其他模块将需要引入此文件以访问`Subscriber`模型。
- en: Listing 16.3\. Creating an exported subscriber model in subscriber.js
  id: totrans-528
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.3\. 在`subscriber.js`中创建导出的订阅者模型
- en: '[PRE23]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1*** **Export the model.**'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **导出模型。**'
- en: Because I know that I’ll need to save subscribers who submit a form on the site,
    I’ll prepare a route and some logic to create and save new subscribers to the
    database. All my code is related to subscribers, so I’ll create a new subscribersController.js
    file within the controllers folder where my actions will exist to respond to a
    `POST` route. The code in that controller appears in [listing 16.4](#ch16ex04).
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我知道我需要保存提交网站表单的订阅者，所以我将准备一个路由和一些逻辑来创建和保存新的订阅者到数据库。所有我的代码都与订阅者相关，因此我将在包含我的操作的`controllers`文件夹内创建一个新的`subscribersController.js`文件，以响应一个`POST`路由。该控制器中的代码在[列表16.4](#ch16ex04)中显示。
- en: First, I require the `subscriber.js` module. Because the module lives within
    another local folder, the require line looks for the `models folder relative to
    the controllers folder.` Node.js looks for the subscriber.js file within the models
    folder and assigns that module’s `exports` content to a local constant called
    `Subscriber`. Right now, this module is the only one in which I need to use the
    `Subscriber` model. Now I can create instances of the `Subscriber` module or make
    calls on that model within the main application file.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我引入了`subscriber.js`模块。因为这个模块位于另一个本地文件夹中，所以引入行看起来是相对于`controllers`文件夹的`models`文件夹。Node.js在`models`文件夹中查找`subscriber.js`文件，并将该模块的`exports`内容分配给一个本地常量，称为`Subscriber`。目前，这个模块是唯一需要使用`Subscriber`模型的地方。现在我可以创建`Subscriber`模块的实例或在该主应用程序文件中对该模型进行调用。
- en: The first action uses `find` to run a query finding all subscribers in the database
    and returning a promise. I use `then` to continue the query chain and render a
    view upon successfully receiving data or catching an error with `catch`. The second
    action doesn’t require a promise; it renders a view. The third action creates
    an instance of `Subscriber` and saves to the database. This behavior automatically
    returns a promise through Mongoose and allows me to chain more functionality or
    catch errors. I add `mongoose.Promise = global.Promise` to main.js so that Mongoose
    will support my promise chains.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个操作使用`find`来运行一个查询，查找数据库中的所有订阅者并返回一个承诺。我使用`then`来继续查询链，并在成功接收到数据或捕获错误时使用`catch`渲染视图。第二个操作不需要承诺；它渲染一个视图。第三个操作创建一个`Subscriber`实例并将其保存到数据库。这种行为自动通过Mongoose返回一个承诺，并允许我链式调用更多功能或捕获错误。我在`main.js`中添加`mongoose.Promise
    = global.Promise`，以便Mongoose将支持我的承诺链。
- en: Listing 16.4\. Controller actions for subscribers in subscribersController.js
  id: totrans-534
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.4\. `subscribersController.js`中的订阅者控制器操作
- en: '[PRE24]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1*** **Require the subscriber model.**'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **需要引入订阅者模型。**'
- en: '***2*** **Retrieve all subscribers.**'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检索所有订阅者。**'
- en: '***3*** **Render the contact page.**'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **渲染联系页面。**'
- en: '***4*** **Save subscribers.**'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **保存订阅者。**'
- en: At this point, my application can launch normally with `npm start`, but I haven’t
    created the routes to connect to my new controller actions. First, I create a
    form to correspond with my `getSubscriptionPage` function.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我的应用程序可以正常启动 `npm start`，但我还没有创建连接到我的新控制器操作的路线。首先，我创建了一个与我的 `getSubscriptionPage`
    函数相对应的表单。
- en: '![](../Images/sectionFig.png)16.3\. Adding subscriber views and routes'
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)16.3\. 添加订阅者视图和路由'
- en: The last piece of the puzzle is adding my views and a form that visitors can
    use to submit their information. The `subscribers.ejs` view contains a loop within
    the HTML tags to display all the subscribers in the database, as shown in [listing
    16.5](#ch16ex05). EJS allows basic JavaScript to run side by side with HTML content.
    Here, I’m looping through the `subscribers` I got from the `getAllSubscribers`
    action in the subscribers controller.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个拼图是添加我的视图和访客可以使用来提交他们信息的表单。`subscribers.ejs` 视图在 HTML 标签内包含一个循环，以显示数据库中的所有订阅者，如[列表
    16.5](#ch16ex05)所示。EJS 允许基本的 JavaScript 与 HTML 内容并行运行。在这里，我正在遍历从订阅者控制器中的 `getAllSubscribers`
    操作中获得的 `subscribers`。
- en: Listing 16.5\. Looping through subscribers in subscribers.ejs
  id: totrans-543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.5\. 在 subscribers.ejs 中遍历订阅者
- en: '[PRE25]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1*** **Loop through the subscribers array.**'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **遍历订阅者数组。**'
- en: The other view I need is for the subscription form, which replaces my form in
    `contact .ejs`. The form posts to the `/subscribe` route and looks like [listing
    16.6](#ch16ex06). This form contains input fields with names that match the fields
    in the `Subscriber` schema. When the form is submitted, data can easily be extracted
    by the model’s field names and saved within a new `Subscriber` instance.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 我还需要另一个视图，用于订阅表单，它替换了 `contact .ejs` 中的表单。该表单提交到 `/subscribe` 路由，看起来像[列表 16.6](#ch16ex06)。此表单包含与
    `Subscriber` 模式中的字段名称匹配的输入字段。当表单提交时，可以通过模型字段名称轻松提取数据，并在新的 `Subscriber` 实例中保存。
- en: '|  |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: I’m deprecating my `postedContactForm` in the home controller. The old route
    and action can be removed.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在弃用主控制器中的 `postedContactForm`。可以移除旧路由和操作。
- en: '|  |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 16.6\. For new subscribers in contact.ejs
  id: totrans-551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.6\. 在 contact.ejs 中为新订阅者
- en: '[PRE26]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1*** **Add a subscription form.**'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **添加订阅表单。**'
- en: To get these views to display, I need to add and modify some routes in main.js,
    as shown in [listing 16.7](#ch16ex07). First, I require `subscribersController.js`
    to the top of the file. Then I add a new route to view all subscribers; this route
    uses the `getAllSubscribers` function in `subscribersController.js` ([figure 16.1](#ch16fig01)).
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这些视图显示，我需要在 main.js 中添加和修改一些路由，如[列表 16.7](#ch16ex07)所示。首先，我将 `subscribersController.js`
    引入到文件顶部。然后我添加了一个新的路由来查看所有订阅者；此路由使用 `subscribersController.js` 中的 `getAllSubscribers`
    函数（[图 16.1](#ch16fig01)）。
- en: Figure 16.1\. Listing subscriber data on the subscribers page
  id: totrans-555
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 16.1\. 在订阅者页面上列出订阅者数据
- en: '![](../Images/16fig01_alt.jpg)'
  id: totrans-556
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16fig01_alt.jpg)'
- en: Instead of creating a new route for the subscription view, I modify the `/contact`
    route to use my `getSubscriptionPage` function. When users click the contact button
    in the site’s navigation, they see my subscription form. Last, I add a `POST`
    route to let my `save-Subscriber` function handle submissions from the subscription
    form.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有为订阅视图创建新的路由，而是修改了 `/contact` 路由以使用我的 `getSubscriptionPage` 函数。当用户点击网站导航中的联系按钮时，他们会看到我的订阅表单。最后，我添加了一个
    `POST` 路由，让我的 `save-Subscriber` 函数处理订阅表单的提交。
- en: Listing 16.7\. Adding subscriber routes in main.js
  id: totrans-558
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.7\. 在 main.js 中添加订阅者路由
- en: '[PRE27]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1*** **Require the subscribers controller.**'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **需要引入订阅者控制器。**'
- en: '***2*** **Add a route to view all subscribers.**'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **添加一个路由来查看所有订阅者。**'
- en: '***3*** **Add a route to view the contact page.**'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **添加一个路由来查看联系页面。**'
- en: '***4*** **Add a route to handle posted form data.**'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **添加一个路由来处理提交的表单数据。**'
- en: The result is a form accessible from the contact page where new visitors can
    send me their information ([figure 16.2](#ch16fig02)).
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，从联系页面可以访问的表单，新访客可以发送他们的信息（[图 16.2](#ch16fig02)）。
- en: Figure 16.2\. Listing subscription form on the contact page
  id: totrans-565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 16.2\. 在联系页面上列出订阅表单
- en: '![](../Images/16fig02_alt.jpg)'
  id: totrans-566
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/16fig02_alt.jpg)'
- en: The pieces are in place, and the application is ready to launch. I’m going to
    show this application to Confetti Cuisine. I relaunch my application with `npm
    start` and demonstrate the subscription process to see whether the company is
    interested. This addition could be a good way to gauge interest among subscribers
    to the newsletter.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 所需组件都已就位，应用程序准备就绪，可以发布。我将向Confetti Cuisine展示这个应用程序。我通过`npm start`重新启动我的应用程序，并演示订阅过程，以查看公司是否感兴趣。这个新增功能可能是衡量新闻通讯订阅者兴趣的好方法。
- en: '![](../Images/sectionFig.png)Summary'
  id: totrans-568
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![](../Images/sectionFig.png)摘要'
- en: In this project, I took a largely static Express.js application and modified
    it to start saving and displaying dynamic data. With these changes and the help
    of a templating engine and middleware in Express.js, this application is taking
    shape.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我将一个主要静态的Express.js应用程序修改为开始保存和显示动态数据。通过这些更改以及Express.js中的模板引擎和中间件的帮助，这个应用程序正在成形。
- en: I started by connecting the application with Mongoose and using the schema and
    modeling tools that come with Mongoose to structure application data. Next, I
    connected those models with new controllers and routes that handle specific requests
    to view and save subscriber data. Last, I incorporated a form where users can
    finally interact with and pass along their information to be processed and reviewed
    by the Confetti Cuisine team. With the help of promises, the code is clean and
    ready for errors that may occur.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先通过将应用程序与Mongoose连接起来，并使用Mongoose提供的模式和建模工具来结构化应用程序数据。接下来，我将这些模型与新的控制器和路由连接起来，这些控制器和路由处理查看和保存订阅者数据的特定请求。最后，我加入了一个表单，用户可以通过它最终与应用程序互动，并将他们的信息传递给Confetti
    Cuisine团队进行处理和审查。借助承诺（promises），代码整洁且准备好处理可能出现的错误。
- en: In [unit 4](../Text/kindle_split_031.html#part04), you learn how to use Mongoose
    on another level by building a user model. Through this model, you learn about
    validation and security steps taken when creating, reading, updating, and deleting
    (CRUD) data.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4单元](../Text/kindle_split_031.html#part04)中，你将学习如何通过构建用户模型来在更高层次上使用Mongoose。通过这个模型，你将了解在创建、读取、更新和删除（CRUD）数据时采取的验证和安全步骤。
