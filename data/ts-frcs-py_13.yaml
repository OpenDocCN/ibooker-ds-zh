- en: '11 Capstone: Forecasting the number of antidiabetic drug prescriptions in Australia'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 综合项目：预测澳大利亚抗糖尿病药物处方的数量
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Developing a forecasting model to predict the number of antidiabetic drug prescriptions
    in Australia
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个预测模型来预测澳大利亚抗糖尿病药物处方的数量
- en: Applying the modeling procedure with a SARIMA model
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SARIMA模型应用建模程序
- en: Evaluating our model against a baseline
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的模型与基线进行比较
- en: Determining the champion model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定冠军模型
- en: We have covered a lot of statistical models for time series forecasting. Back
    in chapters 4 and 5, you learned how to model moving average processes and autoregressive
    processes. We then combined these models to form the ARMA model and added a parameter
    to forecast non-stationary time series, leading us to the ARIMA model. We then
    added a seasonal component with the SARIMA model. Adding the effect of exogenous
    variables culminated in the SARIMAX model. Finally, we covered multivariate time
    series forecasting using the VAR model. Thus, you now have access to many statistical
    models that allow you to forecast a wide variety of time series, from simple to
    more complex. This is a good time to consolidate your learning and put your knowledge
    into practice with a capstone project.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了大量的时间序列预测的统计模型。在第四章和第五章中，你学习了如何建模移动平均过程和自回归过程。然后我们将这些模型结合起来形成ARMA模型，并添加一个参数来预测非平稳时间序列，从而得到ARIMA模型。然后我们通过SARIMA模型添加季节性成分。添加外生变量的影响最终导致了SARIMAX模型。最后，我们介绍了使用VAR模型进行多元时间序列预测。因此，你现在可以访问许多统计模型，这些模型允许你预测各种时间序列，从简单到更复杂。现在是巩固你的学习并将你的知识应用于一个综合项目的好时机。
- en: The objective of the project in this chapter is forecasting the number of antidiabetic
    drug prescriptions in Australia, from 1991 to 2008\. In a professional setting,
    solving this problem would allow us to gauge the production of antidiabetic drugs,
    such as to produce enough to meet the demand and but also avoid overproduction.
    The data we’ll use was recorded by the Australian Health Insurance Commission.
    We can visualize the time series in figure 11.1.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章项目的目标是预测1991年至2008年澳大利亚抗糖尿病药物处方的数量。在专业环境中，解决这个问题将使我们能够衡量抗糖尿病药物的生产，例如，生产足够的药物以满足需求，同时避免过度生产。我们将使用的数据是由澳大利亚健康保险委员会记录的。我们可以在图11.1中可视化时间序列。
- en: '![](../../OEBPS/Images/11-01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/11-01.png)'
- en: Figure 11.1 Monthly number of antidiabetic drug prescriptions in Australia between
    1991 and 2008.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 1991年至2008年澳大利亚每月抗糖尿病药物处方的数量。
- en: In figure 11.1 you’ll see a clear trend in the time series, as the number of
    prescriptions increases over time. Furthermore, you’ll observe strong seasonality,
    as each year seems to start at a low value and end at a high value. By now, you
    should intuitively know which model is potentially the most suitable for solving
    this problem.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在图11.1中，你会看到时间序列中有一个明显的趋势，因为处方的数量随着时间的推移而增加。此外，你还会观察到强烈的季节性，因为每年的开始似乎都是低值，而结束则是高值。到现在为止，你应该直觉地知道哪个模型可能是解决这个问题的最佳选择。
- en: 'To solve this problem, refer to the following steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，请参考以下步骤：
- en: The objective is to forecast 12 months of antidiabetic drug prescriptions. Use
    the last 36 months of the dataset as a test set to allow for rolling forecasts.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标是预测12个月的抗糖尿病药物处方。使用数据集的最后36个月作为测试集，以便进行滚动预测。
- en: Visualize the time series.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化时间序列。
- en: Use time series decomposition to extract the trend and seasonal components.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用时间序列分解来提取趋势和季节性成分。
- en: Based on your exploration, determine the most suitable model.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据你的探索，确定最合适的模型。
- en: 'Model the series with the usual steps:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用常规步骤对序列进行建模：
- en: Apply transformations to make it stationary
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用转换使其平稳
- en: Set the values of *d* and *D*. Set the value of *m*.
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置*d*和*D*的值。设置*m*的值。
- en: Find the optimal (*p*,*d*,*q*)(*P*,*D*,*Q*)[m] parameters.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到最优的(*p*,*d*,*q*)(*P*,*D*,*Q*)[m]参数。
- en: Perform residual analysis to validate your model.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行残差分析以验证你的模型。
- en: Perform rolling forecasts of 12 months on the test set.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试集上执行12个月的滚动预测。
- en: Visualize your forecasts.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可视化你的预测。
- en: Compare the model’s performance to a baseline. Select an appropriate baseline
    and error metric.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模型的性能与基线进行比较。选择一个合适的基线和误差指标。
- en: Conclude whether the model should be used or not.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断模型是否应该被使用。
- en: To get the most out of this capstone project, you are highly encouraged to complete
    it on your own by referring to the preceding steps. This will help you assess
    your autonomy in the modeling process and your understanding.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用这个综合项目，强烈建议您根据自己的步骤独立完成它。这将帮助您评估自己在建模过程中的自主性和理解程度。
- en: 'If you ever feel stuck or want to validate your reasoning, the rest of this
    chapter walks through the completion of this project. Also, the full solution
    is available on GitHub if you wish to refer to the code directly: [https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH11](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH11).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到困难或想要验证您的推理，本章的其余部分将指导您完成这个项目。此外，如果您想直接查看代码，完整的解决方案可在 GitHub 上找到：[https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH11](https://github.com/marcopeix/TimeSeriesForecastingInPython/tree/master/CH11)。
- en: I wish you luck on this project!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 祝您在这个项目中好运！
- en: 11.1 Importing the required libraries and loading the data
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 导入所需的库和加载数据
- en: The natural first step is to import the libraries that will be needed to complete
    the project. We can then load the data and store it in a `DataFrame` to be used
    throughout the project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步自然的步骤是导入完成项目所需的所有库。然后我们可以加载数据并将其存储在 `DataFrame` 中，以便在整个项目中使用。
- en: 'Thus, we’ll import the following libraries and specify the magic function `%matplotlib
    inline` to display the plots in the notebook:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将导入以下库并指定魔法函数 `%matplotlib inline` 以在笔记本中显示图表：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once the libraries are imported, we can read the data and store it in a `DataFrame`.
    We can also display the shape of the `DataFrame` to determine the number of data
    points.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 库导入完成后，我们可以读取数据并将其存储在 `DataFrame` 中。我们还可以显示 `DataFrame` 的形状以确定数据点的数量。
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Displays the shape of a DataFrame. The first value is the number of rows,
    and the second value is the number of columns.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 显示 DataFrame 的形状。第一个值是行数，第二个值是列数。
- en: The data is now ready to be used throughout the project.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 数据现在可以用于整个项目。
- en: 11.2 Visualizing the series and its components
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 可视化序列及其组成部分
- en: With the data loaded, we can now easily visualize the series. This essentially
    recreates figure 11.1.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 数据加载完成后，我们现在可以轻松地可视化这些序列。这本质上是在重现图 11.1。
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next we can perform decomposition to visualize the different components of the
    time series. Remember that time series decomposition allows us to visualize the
    trend component, seasonal component, and the residuals.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以进行分解以可视化时间序列的不同组成部分。记住，时间序列分解使我们能够可视化趋势成分、季节成分和残差。
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Column y holds the number of monthly antidiabetic prescriptions. Also, the
    period is set to 12, since we have monthly data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 列 y 存放每月抗糖尿病处方的数量。此外，周期设置为 12，因为我们有月度数据。
- en: The result is shown in figure 11.2\. Everything seems to suggest that a SARIMA(*p*,*d*,*q*)
    (*P*,*D*,*Q*)*[m]* model would be the optimal solution for forecasting this time
    series. We have a trend as well as clear seasonality. Plus, we do not have any
    exogenous variables to work with, so the SARIMAX model cannot be applied. Finally,
    we wish to predict only one target, meaning that a VAR model is also not relevant
    in this case.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如图 11.2 所示。一切似乎都表明，SARIMA(*p*,*d*,*q*) (*P*,*D*,*Q*)*[m]* 模型将是预测这个时间序列的最佳解决方案。我们有一个趋势以及明显的季节性。此外，我们没有外生变量可以操作，因此不能应用
    SARIMAX 模型。最后，我们只想预测一个目标，这意味着在这个情况下，VAR 模型也不相关。
- en: '![](../../OEBPS/Images/11-02.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/11-02.png)'
- en: Figure 11.2 Time series decomposition on the antidiabetic drug prescriptions
    dataset. The first plot shows the observed data. The second plot shows the trend
    component, which tells us that the number of antidiabetic drug prescriptions is
    increasing over time. The third plot shows the seasonal component, where we can
    see a repeating pattern over time, indicating the presence of seasonality. The
    last plot shows the residuals, which are variations that are not explained by
    the trend of the seasonal component.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 抗糖尿病药物处方数据集的时间序列分解。第一个图显示了观测数据。第二个图显示了趋势成分，它告诉我们抗糖尿病药物处方的数量随时间增加。第三个图显示了季节成分，我们可以看到随时间重复的模式，表明存在季节性。最后一个图显示了残差，这些残差是趋势和季节成分无法解释的变异。
- en: 11.3 Modeling the data
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3 建模数据
- en: We’ve decided that a SARIMA(*p*,*d*,*q*) (*P*,*D*,*Q*)*[m]* model is the most
    suitable for modeling and forecasting this time series. Therefore, we’ll follow
    the general modeling procedure for a SARIMAX model, as a SARIMA model is a special
    case of the SARIMAX model. The modeling procedure is shown in figure 11.3.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经决定 SARIMA(*p*,*d*,*q*) (*P*,*D*,*Q*)*[m]* 模型是最适合建模和预测这个时间序列的。因此，我们将遵循 SARIMAX
    模型的通用建模过程，因为 SARIMA 模型是 SARIMAX 模型的特例。建模过程如图 11.3 所示。
- en: '![](../../OEBPS/Images/11-03.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/11-03.png)'
- en: Figure 11.3 The SARIMA modeling procedure. This procedure is the most general
    modeling procedure, and it can be used for a SARIMA, ARIMA, or ARMA model, as
    they are simply special cases of the SARIMAX model.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 SARIMA 模型过程。这个过程是最通用的建模过程，它可以用于 SARIMA、ARIMA 或 ARMA 模型，因为它们只是 SARIMAX
    模型的特例。
- en: Following the modeling procedure outlined in figure 11.3, we’ll first determine
    whether the series is stationary using the augmented Dickey-Fuller (ADF) test.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 按照图 11.3 中概述的建模过程，我们首先将使用增强型迪基-富勒（ADF）测试确定序列是否平稳。
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This returns a p-value of 1.0, meaning that we cannot reject the null hypothesis,
    and we conclude that the series is not stationary. Thus, we must apply transformations
    to make it stationary.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了一个 p 值为 1.0，意味着我们不能拒绝零假设，我们得出结论，该序列是非平稳的。因此，我们必须应用变换使其平稳。
- en: We’ll first apply a first-order differencing on the data and test for stationarity
    again.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先对数据进行一阶差分，并再次进行平稳性测试。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This returns a p-value of 0.12\. Again, the p-value is greater than 0.05, meaning
    that the series is not stationary. Let’s try applying a seasonal difference, since
    we noticed a strong seasonal pattern in the data. Recall that we have monthly
    data, meaning that *m* = 12. Thus, a seasonal difference subtracts values that
    are 12 timesteps apart.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了一个 p 值为 0.12。同样，p 值大于 0.05，意味着序列是非平稳的。由于我们注意到数据中存在强烈的季节性模式，让我们尝试应用季节差分。回想一下，我们有月度数据，这意味着
    *m* = 12。因此，季节差分会减去相隔 12 个时间步长的值。
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ We have monthly data, so n = 12.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们有月度数据，所以 n = 12。
- en: The returned p-value is 0.0\. Thus, we can reject the null hypothesis and conclude
    that our time series is stationary.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的 p 值为 0.0。因此，我们可以拒绝零假设，并得出结论，我们的时间序列是平稳的。
- en: Since we differenced the series once and took one seasonal difference, *d* =
    1 and *D* = 1. Also, since we have monthly data, we know that *m* = 12. Therefore,
    we know that our final model will be a SARIMA(*p*,1,*q*)(*P*,1,*Q*)[12] model.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对序列进行了一次差分并取了一个季节差分，*d* = 1 和 *D* = 1。另外，由于我们有月度数据，我们知道 *m* = 12。因此，我们知道我们的最终模型将是一个
    SARIMA(*p*,1,*q*)(*P*,1,*Q*)[12] 模型。
- en: 11.3.1 Performing model selection
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.1 执行模型选择
- en: We have established that our model will be a SARIMA(*p*,1,*q*)(*P*,1,*Q*)[12]
    model. Now we need to find the optimal values of *p*, *q*, *P*, and *Q*. This
    is the model selection step where we choose the parameters that minimize the Akaike
    information criterion (AIC).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定我们的模型将是一个 SARIMA(*p*,1,*q*)(*P*,1,*Q*)[12] 模型。现在我们需要找到 *p*、*q*、*P* 和 *Q*
    的最佳值。这是模型选择步骤，我们选择最小化赤池信息准则（AIC）的参数。
- en: To do so, we’ll first split the data into train and test sets. As specified
    in the steps in the chapter introduction, the test set will consist of the last
    36 months of data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们首先将数据分为训练集和测试集。如章节引言中所述的步骤，测试集将包括最后 36 个月的数据。
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Print out the length of the test set to make sure that it contains the last
    36 months.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 打印测试集的长度以确保它包含最后 36 个月。
- en: With our split done, we can now use the `optimize_SARIMAX` function to find
    the values of *p*, *q*, *P*, and *Q* that minimize the AIC. Note that we can use
    `optimize_SARIMAX` here because SARIMA is a special case of the more general SARIMAX
    model. The function is shown in the following listing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成分割后，我们现在可以使用 `optimize_SARIMAX` 函数找到使 AIC 最小的 *p*、*q*、*P* 和 *Q* 的值。请注意，我们可以在这里使用
    `optimize_SARIMAX`，因为 SARIMA 是更通用 SARIMAX 模型的特例。该函数在以下列表中显示。
- en: Listing 11.1 Function to find the values of *p*, *q*, *P*, and *Q* that minimize
    the AIC
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.1 寻找使 AIC 最小的 *p*、*q*、*P* 和 *Q* 值的函数
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With the function defined, we can now decide on the range of values to try for
    *p*, *q*, *P*, and *Q*. Then we’ll generate a list of unique combinations of parameters.
    Feel free to test a different range of values than I’ve used here. Simply note
    that the larger the range, the longer it will take to run the `optimize_SARIMAX`
    function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义后，我们现在可以决定尝试*p*，*q*，*P*和*Q*的值范围。然后我们将生成参数的唯一组合列表。您可以自由地测试与我这里使用的不同范围的值。请注意，范围越大，运行`optimize_SARIMAX`函数所需的时间就越长。
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can now run the `optimize_SARIMAX` function. In this example, 625 unique
    combinations are tested, since we have 5 possible values for 4 parameters.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行`optimize_SARIMAX`函数。在这个例子中，测试了625个独特的组合，因为我们有4个参数的5个可能的值。
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once the function is finished, the result shows that the minimum AIC is achieved
    with *p* = 2, *q* = 3, *P* = 1, and *Q* = 3. Therefore, the optimal model is a
    SARIMA(2,1,3)(1,1,3)[12] model.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数完成，结果显示，最小AIC值是在*p* = 2，*q* = 3，*P* = 1和*Q* = 3时达到的。因此，最优模型是一个SARIMA(2,1,3)(1,1,3)[12]模型。
- en: 11.3.2 Conducting residual analysis
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3.2 进行残差分析
- en: Now that we have the optimal model, we must analyze its residuals to determine
    whether the model can be used or not. This will depend on the residuals, which
    should behave like white noise. If that is the case, the model can be used for
    forecasting.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经得到了最优模型，我们必须分析其残差以确定该模型是否可以使用。这将取决于残差，它们应该表现为白噪声。如果是这样，该模型可用于预测。
- en: We can fit the model and use the `plot_diagnostics` method to qualitatively
    analyze its residuals.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以拟合模型并使用`plot_diagnostics`方法对其残差进行定性分析。
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The result is shown in figure 11.4, and we can conclude from this qualitative
    analysis that the residuals closely resemble white noise.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如图11.4所示，我们可以从这种定性分析中得出结论，残差非常接近白噪声。
- en: '![](../../OEBPS/Images/11-04.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/11-04.png)'
- en: Figure 11.4 Visual diagnostics of the residuals. In the top-left plot, the residuals
    have no trend over time, and the variance seems constant. At the top right, the
    distribution of the residuals is very close to a normal distribution. This is
    further supported by the Q-Q plot at the bottom left, which displays a fairly
    straight line that sits on *y* = *x*. Finally, the correlogram at the bottom right
    shows no significant coefficients after lag 0, just like white noise.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4残差的视觉诊断。在左上角的图中，残差在时间上没有趋势，方差似乎保持恒定。在右上角，残差的分布非常接近正态分布。这一点进一步得到了左下角Q-Q图的支撑，该图显示了一条相当直的线，位于*y*
    = *x*上。最后，右下角的自相关图在滞后0之后没有显示出显著的系数，就像白噪声一样。
- en: The next step is to perform the Ljung-Box test, which determines whether the
    residuals are independent and uncorrelated. The null hypothesis of the Ljung-Box
    test states that the residuals are uncorrelated, just like white noise. Thus,
    we want the test to return p-values larger than 0.05\. In that case, we cannot
    reject the null hypothesis and conclude that our residuals are independent, and
    therefore behave like white noise.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是执行Ljung-Box测试，该测试确定残差是否独立且不相关。Ljung-Box测试的零假设是残差是不相关的，就像白噪声一样。因此，我们希望测试返回的p值大于0.05。在这种情况下，我们不能拒绝零假设，并得出结论，我们的残差是独立的，因此表现为白噪声。
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, all the p-values are above 0.05, so we do not reject the null
    hypothesis, and we conclude that the residuals are independent and uncorrelated.
    We can conclude that the model can used for forecasting.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，所有p值都高于0.05，因此我们无法拒绝零假设，我们得出结论，残差是独立且不相关的。我们可以得出结论，该模型可用于预测。
- en: 11.4 Forecasting and evaluating the model’s performance
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4 预测和评估模型性能
- en: We have a model that can be used for forecasting, so we’ll now perform rolling
    forecasts of 12 months over the test set of 36 months. That way we’ll have a better
    evaluation of our model’s performance, as testing on fewer data points might lead
    to skewed results. We’ll use the naive seasonal forecast as a baseline; it will
    simply take the last 12 months of data and use them as forecasts for the next
    12 months.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个可用于预测的模型，因此我们现在将在36个月测试集上进行12个月的滚动预测。这样，我们将更好地评估模型的表现，因为在对较少的数据点进行测试时可能会得到偏颇的结果。我们将使用简单的季节性预测作为基线；它将简单地取最后12个月的数据，并将它们用作未来12个月的预测。
- en: We’ll first define the `rolling_forecast` function to generate the predictions
    over the entire test set with a window of 12 months. The function is shown in
    the following listing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义`rolling_forecast`函数，以12个月为一个窗口，在整个测试集上生成预测。该函数如下所示。
- en: Listing 11.2 Function to perform a rolling forecast over a horizon
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.2 执行滚动预测的函数
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, we’ll create a `DataFrame` to hold the predictions as well as the actual
    values. This is simply a copy of the test set.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`DataFrame`来存储预测值以及实际值。这仅仅是测试集的一个副本。
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now we can define the parameters to be used for the `rolling_forecast` function.
    The dataset contains 204 rows, and the test set contains 36 data points, which
    means the length of the training set is 204 – 36 = 168. The horizon is 36, since
    our test set contains 36 months of data. Finally, the window is 12 months, as
    we are forecasting 12 months at a time.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义用于`rolling_forecast`函数的参数。数据集包含204行，测试集包含36个数据点，这意味着训练集的长度是204 - 36
    = 168。预测范围是36，因为我们的测试集包含36个月的数据。最后，窗口是12个月，因为我们一次预测12个月。
- en: With those values set, we can record the predictions coming from our baseline,
    which is a naive seasonal forecast. It simply takes the last 12 months of observed
    data and uses them as forecasts for the next 12 months.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 设置这些值后，我们可以记录来自基线的预测，基线是一个简单的季节性预测。它只是简单地取最后12个月的观测数据，并将它们用作未来12个月的预测。
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, we’ll compute the forecasts from the SARIMA model.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将计算SARIMA模型的预测。
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At this point, `pred_df` contains the actual values, the forecasts from the
    naive seasonal method, and the forecasts from the SARIMA model. We can use this
    to visualize our forecasts against the actual values. For clarity, we’ll limit
    the *x*-axis to zoom in on the test period. The resulting plot is shown in figure
    11.5.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`pred_df`包含实际值、来自简单季节性方法的预测以及来自SARIMA模型的预测。我们可以使用这些数据来可视化我们的预测与实际值。为了清晰起见，我们将*x*轴限制在测试期间以进行放大。结果图如图11.5所示。
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](../../OEBPS/Images/11-05.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/11-05.png)'
- en: Figure 11.5 Forecasts of the number of antidiabetic drug prescriptions in Australia.
    The predictions from the baseline are shown as a dotted line, while the predictions
    from the SARIMA model are shown as a dashed line.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 澳大利亚抗糖尿病药物处方的数量预测。基线模型的预测以虚线表示，而SARIMA模型的预测以虚线表示。
- en: In figure 11.5 you can see that the predictions from the SARIMA model (the dashed
    line) follow the actual values more closely than the naive seasonal forecasts
    (the dotted line). We can therefore intuitively expect the SARIMA model to have
    performed better than the baseline method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在图11.5中，你可以看到SARIMA模型的预测（虚线）比简单的季节性预测（虚线）更接近实际值。因此，我们可以直观地预期SARIMA模型的表现优于基线方法。
- en: To evaluate the performance quantitatively, we’ll use the mean absolute percentage
    error (MAPE). The MAPE is easy to interpret, as it returns a percentage error.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定量评估性能，我们将使用平均绝对百分比误差（MAPE）。MAPE易于解释，因为它返回一个百分比误差。
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This prints out a MAPE of 12.69% for the baseline and 7.90% for the SARIMA model.
    We can optionally plot the MAPE of each model in a bar chart for a nice visualization,
    as shown in figure 11.6.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这输出了基线模型的MAPE为12.69%，SARIMA模型的MAPE为7.90%。我们可以选择性地将每个模型的MAPE以条形图的形式绘制出来，以便于可视化，如图11.6所示。
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](../../OEBPS/Images/11-06.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/11-06.png)'
- en: Figure 11.6 The MAPE for the naive seasonal forecast and the SARIMA model. Since
    the MAPE of the SARIMA model is lower than the MAPE of the baseline, we can conclude
    that the SARIMA model should be used to forecast the number of antidiabetic drug
    prescriptions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 简单季节性预测和SARIMA模型的MAPE。由于SARIMA模型的MAPE低于基线的MAPE，我们可以得出结论，应该使用SARIMA模型来预测抗糖尿病药物处方的数量。
- en: Since the SARIMA model achieves the lowest MAPE, we can conclude that the SARIMA(2,1,3)(1,1,3)[12]
    model should be used to forecast the monthly number of antidiabetic drug prescriptions
    in Australia.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SARIMA模型实现了最低的MAPE，我们可以得出结论，应该使用SARIMA(2,1,3)(1,1,3)[12]模型来预测澳大利亚每月抗糖尿病药物处方的数量。
- en: Next steps
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一步
- en: Congratulations on completing this capstone project. I hope that you were able
    to complete it on your own and that you now feel confident in your skills and
    knowledge of time series forecasting using statistical models.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了这个顶点项目。我希望你能够独立完成它，并且你现在对自己的技能和时间序列预测的统计模型知识感到自信。
- en: Of course, practice makes perfect, so I highly encourage you to find other time
    series datasets and practice modeling and forecasting them. This will help you
    build your intuition and hone your skills.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，熟能生巧，所以我强烈建议你寻找其他时间序列数据集并练习对它们进行建模和预测。这将帮助你建立你的直觉并磨练你的技能。
- en: In the next chapter, we’ll start a new section where we’ll use deep learning
    models to model and forecast complex time series with high dimensionality.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始一个新的部分，在那里我们将使用深度学习模型来模拟和预测具有高维度的复杂时间序列。
