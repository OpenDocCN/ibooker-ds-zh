- en: 2 Exploring data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 探索数据
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Loading packages
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载包
- en: Importing data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入数据
- en: Wrangling data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据整理
- en: Exploring and analyzing data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索和分析数据
- en: Writing data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入数据
- en: This chapter and the next are a package deal—we’ll explore a real data set in
    this chapter and then get practical implications from the same in chapter 3\.
    An exploratory data analysis (EDA) is a process—or, really, a series of processes—by
    which a data set is interrogated by computing basic statistics and creating graphical
    representations of the same. We won’t paint any broad strokes along the way; instead,
    we’ll focus our analysis on a single variable, a performance metric called win
    shares, and discover how win shares is associated with the other variables in
    our data. Our going-in hypothesis in the next chapter will directly tie back to
    the findings from this chapter. Along the way, we’ll demonstrate how to best use
    the power of R to thoroughly explore a data set—any data set.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和下一章是一套组合——我们将在本章探索一个真实的数据集，然后在第三章中从中获得实际应用。探索性数据分析（EDA）是一个过程——实际上是一系列过程——通过计算基本统计量和创建相同数据的图形表示来对数据集进行质询。我们不会在过程中画任何大笔触；相反，我们将分析的重点放在一个单一变量上，这是一个称为赢分的性能指标，并发现赢分如何与我们数据中的其他变量相关联。我们在下一章中的初始假设将直接与本章的发现相联系。在这个过程中，我们将展示如何最好地利用
    R 的力量彻底探索一个数据集——任何数据集。
- en: But first, we must take care of the mandatory tasks of loading packages, importing
    our data set, and then tidying and wrangling it. If you’re not spending *most*
    of your time dedicated to “intangible” tasks that can sometimes feel like grunt
    work—understanding that time allocations aren’t necessarily correlated with lines
    of code—then you’re most likely doing something wrong. Unfortunately, data isn’t
    always collected and stored in anticipation of subsequent analytical needs; tidying
    and wrangling data help us avoid bad or misleading results. Nevertheless, we’ll
    introduce several operations that will serve us well going forward, and in the
    process, you’ll learn a great deal about win shares and other NBA data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们必须完成加载包、导入我们的数据集以及整理和整理数据的强制任务。如果你没有将 *大部分* 时间投入到“无形”的任务中，这些任务有时会感觉像苦力活——理解时间分配并不一定与代码行数相关——那么你很可能在做一些错误的事情。不幸的是，数据并不总是为了后续的分析需求而收集和存储的；整理和整理数据有助于我们避免不良或误导性的结果。尽管如此，我们将介绍一些将对我们未来大有裨益的操作，在这个过程中，你将学到很多关于赢分和其他
    NBA 数据的知识。
- en: 2.1 Loading packages
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 加载包
- en: We begin by calling the `library()` function to load packages that allow us
    to then call functions not available in the base product. You’re not using the
    best of R by relegating yourself to built-in functions. It may go without saying,
    but packages must be installed before loading them into a script and then calling
    their functions. This is just one reason why we reserve the very top of our scripts
    for loading packages we’ve previously installed. Just to be clear, when you install
    R, you’re installing the base product only; any need thereafter to go above and
    beyond the features and functions of base R requires ongoing installs of packages,
    usually from the Comprehensive R Archive Network (CRAN), but every now and then
    from GitHub.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用 `library()` 函数来加载允许我们调用基础产品中不可用的函数的包。你通过仅使用内置函数，并没有充分利用 R 的优势。这可能无需多言，但包必须在将它们加载到脚本中并调用它们的函数之前安装。这就是为什么我们保留脚本的最顶部来加载我们之前安装的包。为了明确起见，当你安装
    R 时，你只安装了基础产品；任何需要超越基础 R 特性和功能的后续需求都需要持续安装包，通常是从 Comprehensive R Archive Network
    (CRAN) 安装，但偶尔也会从 GitHub 安装。
- en: 'Packages are installed by calling the base R `install.packages()` function
    and passing the package name as an argument between a pair of single or double
    quotation marks, as shown:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用基础 R 的 `install.packages()` 函数，并在一对单引号或双引号之间传递包名作为参数来安装包，如下所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To avoid the risk of confusing R, we use double quotation marks on the outside
    when quoting an entire line of code and use single quotation marks, if and when
    necessary, on the inside when quoting a portion of code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免混淆 R，我们在引用整行代码时使用双引号，并在必要时在内部使用单引号引用代码的一部分。
- en: 'While packages need to be installed just once, they must be loaded whenever
    and wherever you plan to use them. Packages extend the features and functions
    of R without modifying or otherwise affecting the original code base (which no
    one wants to touch today). Here’s a rundown of the packages we plan to use in
    this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然包只需要安装一次，但每次你计划使用它们时都必须加载它们。包扩展了 R 的功能和函数，而不会修改或以其他方式影响原始代码库（今天没有人想修改它）。以下是本章中我们计划使用的包的概述：
- en: The `dplyr` and `tidyr` packages contain *many* functions for manipulating and
    wrangling data. Both of these packages are part of the `tidyverse` universe of
    packages. This means you can call the `library()` function once and pass the `tidyverse`
    package, and R will automatically load `dplyr`, `tidyr`, and every other package
    that is part of the `tidyverse`.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dplyr` 和 `tidyr` 包包含了用于操作和整理数据的许多函数。这两个包都是 `tidyverse` 包宇宙的一部分。这意味着你可以一次调用
    `library()` 函数，并传递 `tidyverse` 包，R 将自动加载 `dplyr`、`tidyr` 以及 `tidyverse` 的其他所有包。'
- en: The `ggplot2` package includes the `ggplot()` function for creating elegant
    visual content that puts to shame most out-of-the-box plots. In addition, `ggplot2`
    contains several other functions for trimming your visualizations that, by and
    large, don’t have base R equivalents. The `ggplot2` package is also part of the
    `tidyverse`.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ggplot2` 包包含了 `ggplot()` 函数，用于创建优雅的视觉内容，其效果远胜于大多数现成的图表。此外，`ggplot2` 包还包含了一些其他函数，用于修剪你的可视化效果，总体来说，这些函数在基础
    R 中没有等效功能。`ggplot2` 包也是 `tidyverse` 的一部分。'
- en: The `readr` package is used to quickly and easily read or import rectangular
    data from delimited files; `readr` is part of the `tidyverse`. Rectangular data
    is synonymous with structured data or tabular data; it simply means that the data
    is organized in rows and columns. A *delimited file* is a type of flat file by
    which the values are separated, or delimited, by a special character or sequence
    of characters; they are usually saved with an extension that indicates how the
    data is delimited. We’ll be working exclusively with files previously saved with
    a .csv extension. A .csv, or *comma-separated values*, file is a Microsoft Excel
    file by which a comma is used as the delimiter.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readr` 包用于快速轻松地读取或导入由分隔符分隔的矩形数据；`readr` 是 `tidyverse` 的一部分。矩形数据等同于结构化数据或表格数据；它仅仅意味着数据是有行和列组织的。一个
    *分隔符文件* 是一种平面文件，其中的值由一个特殊字符或字符序列分隔；它们通常保存为具有扩展名，该扩展名指示数据是如何分隔的。我们将仅使用之前保存为 .csv
    扩展名的文件。一个 .csv，或 *逗号分隔值* 文件，是一个使用逗号作为分隔符的 Microsoft Excel 文件。'
- en: The `reshape2` package includes functions that make it easy—it’s just one line
    of code—to transform data between wide and long formats. Data is usually transformed
    to suit specific analysis methods and/or visualization techniques.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reshape2` 包包含了使数据在宽格式和长格式之间转换变得容易的函数——这同样只需要一行代码。数据通常会被转换以适应特定的分析方法或可视化技术。'
- en: The `sqldf` package is used to write `SELECT` statements and other Structured
    Query Language (SQL) queries. SQL is a programming language of its own that provides
    a mostly standardized way of interacting with stored data. Those migrating from
    another programming language might find some comfort in the fact that R supports
    SQL; however, we’ll gradually wean you away from `sqldf` and toward `dplyr`.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqldf` 包用于编写 `SELECT` 语句和其他结构化查询语言（SQL）查询。SQL 是一种编程语言，它提供了一种主要标准化的方式与存储数据交互。那些从其他编程语言迁移过来的人可能会发现，R
    支持 SQL 是一种安慰；然而，我们将逐渐引导你从 `sqldf` 转向 `dplyr`。'
- en: The `patchwork` package makes it very easy—again, it’s just a single line of
    code—to bundle two or more visualizations into a single graphical object.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patchwork` 包使得将两个或更多可视化组合成一个单一图形对象变得非常简单——这同样只需要一行代码。'
- en: 'In the following chunk, the `library()` function is called four times to load
    four packages we’ve already installed. Note that it’s *not* necessary to include
    the package name inside a pair of quotation marks when calling the `library()`
    function:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的部分中，`library()` 函数被调用了四次，用于加载我们已安装的四个包。请注意，在调用 `library()` 函数时，不需要在包名周围使用一对引号：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To run one or more lines of code—which, by the way, should be entered in the
    Script Editor panel—highlight the code with your cursor and then click Run at
    the top of the Script Editor. If you’re working on a Mac, you can instead hold
    down the Control key and press Return.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行一行或多行代码——顺便说一句，这些代码应该在脚本编辑器面板中输入——使用鼠标指针突出显示代码，然后在脚本编辑器的顶部点击运行。如果你在 Mac 上工作，可以按住
    Control 键并按 Return 键。
- en: 2.2 Importing data
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 导入数据
- en: 'The `read_csv()` function from the `readr` package is used to import a data
    set in the form of a flat file previously saved with a .csv extension. R reads
    .csv files very well, as long as the data is confined to a single worksheet (think
    of a Microsoft Excel file as a workbook that can contain one or more worksheets).
    R will throw an error otherwise. The `read_csv()` function requires just a single
    argument to be passed: the name of the file, preceded by its storage location,
    bounded by a pair of single or double quotation marks.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `readr` 包的 `read_csv()` 函数用于导入以 .csv 扩展名保存的平面文件形式的数据集。只要数据局限于单个工作表（可以将 Microsoft
    Excel 文件想象成一个可以包含一个或多个工作表的工作簿），R 就能很好地读取 .csv 文件。否则，R 会抛出错误。`read_csv()` 函数只需要传递一个参数：文件名，前面是它的存储位置，由一对单引号或双引号包围。
- en: However, if you previously set a working directory and subsequently deployed
    your files in that location, you merely need to pass the name of the file, including
    the extension. You can set the working directory by calling the `setwd()` function
    and get the working directory you previously set by calling the `getwd()` function;
    both `setwd()` and `getwd()` are base R functions. When you then call the `read_csv()`
    function, R will automatically navigate through your folder structure, search
    your working directory, and import your file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你之前设置了工作目录并在该位置部署了文件，你只需传递包括扩展名的文件名即可。你可以通过调用 `setwd()` 函数来设置工作目录，通过调用
    `getwd()` 函数来获取之前设置的工作目录；`setwd()` 和 `getwd()` 都是基础 R 函数。当你调用 `read_csv()` 函数时，R
    会自动导航你的文件夹结构，搜索你的工作目录，并导入你的文件。
- en: 'The following line of code imports a .csv file called draft since it’s saved
    in our working directory and, through the assignment operator `(<-)`, sets it
    equal to an object by the same name. The data set, downloaded from the [http://data.world](http://data.world)
    website, contains information on every NBA first-round draft pick between the
    2000 and 2009 amateur drafts:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行导入了一个名为 draft 的 .csv 文件，因为它存储在我们的工作目录中，并通过赋值运算符 `(<-)` 将其设置为与对象相同的名称。这个数据集是从
    [http://data.world](http://data.world) 网站下载的，包含了2000年至2009年业余选秀中每个NBA第一轮选秀的信息：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What is the NBA draft?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: NBA选秀是什么？
- en: For those of you who might not be familiar with the NBA, the draft is an annual
    event, held during the offseason, where teams take turns selecting eligible players
    from the United States and abroad. Today, the draft is just two rounds. Barring
    trades between teams, each team is allowed one selection per round in an order
    determined by the prior year’s finish, where the worst teams are allowed to select
    first.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能不熟悉 NBA 的你来说，选秀是一个年度活动，在赛季间隙举行，各队轮流从美国和海外选择合格的球员。如今，选秀只有两轮。除非球队之间进行交易，否则每个队在每轮中只能选择一次，顺序由前一年的成绩决定，最差的球队可以首先选择。
- en: 'A quick and easy way to confirm the success of a data import and, at the same
    time, return the dimension of your data set is to call the base R `dim()` function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 确认数据导入成功并同时返回数据集维度的快速简单方法是通过调用基础 R 的 `dim()` 函数：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our draft data set contains 293 rows and 26 columns. Anything and everything
    preceded by a pair of pound signs is a copy and paste of what R subsequently returns
    for us. Now that we have our data set, we’ll wrangle it before exploring it, analyzing
    it, and drawing some meaningful conclusions from it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据集包含293行和26列。任何以一对井号（#）开头的内容都是 R 随后为我们返回的复制粘贴内容。现在我们有了数据集，我们将在探索、分析和从中得出一些有意义的结论之前对其进行处理。
- en: 2.3 Wrangling data
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 处理数据
- en: 'In the real world, most of the data sets you import will be less than perfect;
    it’s therefore absolutely necessary to perform a series of operations to transform
    the data into a clean and tidy object that can then be properly and accurately
    analyzed. Many of the most common data wrangling operations include the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，你导入的大多数数据集可能都不完美；因此，绝对有必要执行一系列操作，将数据转换成干净整洁的对象，然后才能进行适当的准确分析。最常见的数据处理操作包括以下内容：
- en: Reshaping, or transposing, the layout of your data by gathering columns into
    rows or spreading rows into columns
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将列聚集到行或将行扩展到列来重塑或转置数据布局
- en: Subsetting your data by rows that meet some logical criteria
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过行满足某些逻辑标准对数据进行子集化
- en: Subsetting your data by columns to remove superfluous data
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过列对数据进行子集化以删除多余数据
- en: Summarizing your data, usually through mathematical operations, and often grouped
    by some other variable in your data set
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过数学运算总结您的数据，通常按数据集中的其他变量分组
- en: Creating new variables, usually derived from one or more original variables
    in your data
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新变量，通常是从数据中的一个或多个原始变量派生出来的
- en: Converting variables from one class to another, for instance, from numeric to
    date or from character string to categorical
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将变量从一种类型转换为另一种类型，例如，从数值转换为日期或从字符字符串转换为分类
- en: Changing variable names
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改变量名
- en: Replacing attributes
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换属性
- en: Combining or joining your data with one or more other data sets
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的数据与一个或多个其他数据集合并或连接
- en: We’ll start by removing unnecessary columns or variables.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从删除不必要的列或变量开始。
- en: 2.3.1 Removing variables
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.1 删除变量
- en: Our first data wrangling operation is to remove superfluous variables from the
    draft data set. For the most part, we’re dropping career statistics that won’t
    factor into our analysis. This is a purely discretionary operation, but it’s always
    a best practice to retain only what you need and to discard everything else. When
    working with large data sets, dropping irrelevant or redundant data can absolutely
    improve computational efficiency.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步数据整理操作是从草稿数据集中删除多余的变量。大部分情况下，我们正在删除不会影响我们分析的职业统计数据。这是一个纯粹的选择性操作，但始终是最佳实践只保留您需要的，丢弃其他所有内容。当处理大型数据集时，删除无关或冗余数据绝对可以提高计算效率。
- en: 'In the following line of code, we make a call to the `select()` function from
    the `dplyr` package as well as the `c()` function from base R:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码行中，我们调用了来自 `dplyr` 包的 `select()` 函数以及来自基础 R 的 `c()` 函数：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `select()` function is used to select or deselect variables by their name
    or index; the `c()` function is used to combine multiple arguments to form a vector.
    We’re calling the `select()` function to subset the draft data set by removing
    the variables, denoted by their left-to-right position in our data set, passed
    to the `c()` function (notice the preceding minus [-] operator). There is usually
    more than one way to skin a cat in R, and this is one of those instances:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`select()` 函数用于通过变量名或索引选择或取消选择变量；`c()` 函数用于将多个参数组合成一个向量。我们调用 `select()` 函数通过移除变量来对草稿数据集进行子集化，这些变量通过在数据集中从左到右的位置表示，传递给
    `c()` 函数（注意前面的减号 [-] 操作符）。在 R 中，通常有多种方法可以“剥猫皮”，这是一个例子：'
- en: The variable names could be substituted for the position numbers. This is actually
    a best practice and should be the preferred method, unless the number of variables
    to remove is prohibitive or there are extenuating circumstances. In fact, some
    of these variables include characters that would otherwise cause R to error out,
    so we elected to call out the position numbers this time rather than the variable
    names.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名可以替换为位置编号。这实际上是一种最佳实践，应该是首选方法，除非要删除的变量数量过多或存在特殊情况。事实上，其中一些变量包含会导致 R 错误的字符，因此我们这次选择调用位置编号而不是变量名。
- en: The minus operator could be removed, and the variable names or positions to
    *include* could then be passed as arguments to the `c()` function.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减号操作符可以移除，然后可以将要包含的变量名或位置作为参数传递给 `c()` 函数。
- en: Base R functions could be used in lieu of `dplyr` code.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用基础 R 函数代替 `dplyr` 代码。
- en: We’ll apply all of these alternatives going forward, depending on the circumstances.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据情况应用所有这些替代方案。
- en: 2.3.2 Removing observations
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.2 删除观测值
- en: 'The next line of code removes observations (i.e., rows or records) 90 and 131
    from draft for the very simple reason that these observations contain incomplete
    data that would otherwise interrupt ongoing operations. The records are mostly
    blank, thereby eliminating data imputation or other corrective action as options:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码删除了草稿中的观测值（即行或记录）90 和 131，原因很简单，这些观测值包含不完整的数据，否则会中断正在进行的操作。记录大部分为空白，因此消除了数据插补或其他纠正措施作为选项：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we’ve cut the dimension of draft by first dropping unnecessary variables
    and then removing mostly incomplete observations, we’ll next view our data and
    perform more meaningful data wrangling operations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过首先删除不必要的变量然后删除大部分不完整的观测值来减少了草稿的维度，接下来我们将查看我们的数据并执行更有意义的数据整理操作。
- en: 2.3.3 Viewing data
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.3 查看数据
- en: The `dplyr` `glimpse()` function, where the name of our data set is passed as
    the lone argument, returns a transposed view of the data. In this view, the columns
    appear as rows, and the rows appear as columns, making it possible to see every
    column in the RStudio Console; this is especially useful when working with wide
    data sets.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`dplyr` 的 `glimpse()` 函数，其中我们的数据集名称作为唯一的参数传递，返回数据的转置视图。在这个视图中，列显示为行，行显示为列，这使得在
    RStudio 控制台中查看每一列成为可能；这在处理宽数据集时特别有用。'
- en: 'The `glimpse()` function also returns the type, or class, for each variable
    and, at the very top, the dimension of the object:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`glimpse()` 函数还返回每个变量的类型或类，以及在顶部，对象的维度：'
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The draft data set is now 291 rows long and 15 columns wide (versus its original
    293 × 26 dimension), with a combination of numeric variables (`int` and `dbl`)
    and character strings (`chr`).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 草稿数据集现在有 291 行长和 15 列宽（与原始的 293 × 26 维度相比），包含数值变量（`int` 和 `dbl`）和字符字符串（`chr`）的组合。
- en: 'Alternatively (or additionally), R returns the first and last *n* rows of a
    data set when the base R `head``()` and `tail()` functions, respectively, are
    called. This is especially useful if the transposed output from `glimpse``()`is
    less than intuitive. By default, R displays the first six or last six observations
    in a data set for either or both of these functions. The following two lines of
    code return the first three and last three observations in the draft data set:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 或者（或附加地），当调用基础 R 的 `head()` 和 `tail()` 函数时，R 返回数据集的前 *n* 行和后 *n* 行。这在 `glimpse()`
    函数的转置输出不够直观时特别有用。默认情况下，R 为这两个函数显示数据集的前六行或后六行。以下两行代码返回了草稿数据集的前三行和后三行：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Some of our variables that are now character strings or numeric should be converted
    to factor variables. We’ll take care of that next.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的一些字符字符串或数值变量应该转换为因子变量。我们将在下一步处理这个问题。
- en: 2.3.4 Converting variable types
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.4 转换变量类型
- en: Some character strings and numeric variables are, in fact, categorical variables,
    or factors, even if they’re not classed as such; that’s because they can only
    take on a known or fixed set of values. Take the variable `Year`, just to provide
    one example. We’ve already established that our data set includes information
    on NBA first-round draft picks between 2000 and 2009; thus, `Year` can only equal
    some value between 2000 and 2009\. Or, take the variable `Tm`, which is short
    for *Team*. There are only so many teams in the NBA; therefore, `Tm` has a fixed
    set of possibilities. If you plan to model or visualize data, converting variables
    to factors that are truly categorical is almost mandatory.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字符字符串和数值变量实际上是分类变量或因子，即使它们没有被归类为这样的类型；这是因为它们只能取已知或固定的值集。以变量 `Year` 为例，我们可以提供一个例子。我们已经确定我们的数据集包括关于
    2000 年至 2009 年 NBA 第一轮选秀的信息；因此，`Year` 只能等于 2000 年至 2009 年之间的某个值。或者，以变量 `Tm` 为例，它是
    *Team* 的缩写。NBA 中只有这么多支球队；因此，`Tm` 有一个固定的可能性集合。如果您计划建模或可视化数据，将变量转换为真正的分类因子几乎是强制性的。
- en: 'Now take a look at the next few lines of code. The `$` operator in R is used
    to extract, or subset, a variable from a chosen data set. For example, in the
    first line of code here, we’re extracting, or subsetting, the variable `Year`
    from the draft data set and converting it, and only it, to a factor variable:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看接下来的几行代码。在 R 中，`$` 运算符用于从选定的数据集中提取或子集变量。例如，在这段代码的第一行中，我们正在从草稿数据集中提取或子集变量
    `Year`，并将其转换为因子变量：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To directly confirm just one of these operations, and therefore the others
    indirectly, we next make a call to the base R `class()` function and pass the
    draft variable `Year`. We can see that `Year` is now, in fact, a factor variable.
    The `glimpse()` function can again be called as an alternative:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了直接确认这些操作中的任何一个，从而间接确认其他操作，我们接下来调用基础 R 的 `class()` 函数，并传递草稿变量 `Year`。我们可以看到，`Year`
    现在实际上是一个因子变量。`glimpse()` 函数可以作为替代再次调用：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Soon enough, we’ll be visualizing and analyzing our data around the levels,
    or groups, in some of these variables that are now factors.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们将围绕这些变量的一些水平或组来可视化和分析我们的数据，这些变量现在是因子。
- en: 2.3.5 Creating derived variables
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3.5 创建派生变量
- en: We’ve removed variables and converted other variables. Next, we’ll create variables—three,
    in fact—and sequentially append them to the end of the draft data set. With respect
    to the first two variables, we’ll call the `dplyr mutate()` function in tandem
    with the base R `ifelse()` function. This powerful combination makes it possible
    to perform logical tests against one or more original variables and add attributes
    to the new variables, depending on the test results. For the third variable, we’ll
    duplicate an original variable and then replace the new variable’s attributes
    by calling the `dplyr` `recode()` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经删除了变量并将其他变量转换为因子变量。接下来，我们将创建变量——实际上三个变量——并将它们依次追加到草稿数据集的末尾。对于前两个变量，我们将同时使用
    `dplyr mutate()` 函数和基础 R 的 `ifelse()` 函数。这个强大的组合使得我们可以对一个或多个原始变量执行逻辑测试，并根据测试结果向新变量添加属性。对于第三个变量，我们将复制一个原始变量，然后通过调用
    `dplyr` 的 `recode()` 函数来替换新变量的属性。
- en: Let’s start with the variable `Born`; this is a two-byte variable that equals
    a player’s country of birth where, for instance, `us` equals United States.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从变量 `Born` 开始；这是一个两字节变量，表示球员的出生国家，例如，`us` 等于美国。
- en: 'The first line of code in the following chunk creates a new, or derived, variable
    called `Born2`. If the value in the original variable `Born` equals `us`, then
    the same record in draft should equal `USA`; if the value in `Born` equals anything
    other than `us`, `Born2` should instead equal `World`. The second line of code
    converts the variable `Born2` to a factor variable because each record can take
    just one of two possible values and because some of our forthcoming analysis will,
    in fact, be grouped by these same levels:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块的第一行中，创建了一个新的或派生变量，称为 `Born2`。如果原始变量 `Born` 中的值等于 `us`，则草稿中相同的记录应等于 `USA`；如果
    `Born` 中的值等于除 `us` 之外的其他任何值，则 `Born2` 应该等于 `World`。第二行代码将变量 `Born2` 转换为因子变量，因为每个记录只能取两个可能值之一，并且我们即将进行的分析实际上将按这些相同的级别进行分组：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note By the way, the `=` and `==` operators aren’t the same; the first is an
    assignment or mathematical operator, whereas the second is a logical operator.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意顺便说一下，`=` 和 `==` 运算符并不相同；第一个是赋值或数学运算符，而第二个是逻辑运算符。
- en: Now, let’s work with the variable `College`, which equals the last college or
    university every NBA first-round pick in the draft data set attended, regardless
    of how long they might have been enrolled and regardless of whether or not they
    graduated. However, not every player attended a college or university; for those
    who didn’t, `College` equals `NA`. An `NA`, or not available, in R is the equivalent
    of a missing value and therefore can’t be ignored. In the next line of code, we
    call the base R `is.na()` function to replace every `NA` with `0`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们处理变量 `College`，它等于在草稿数据集中每个 NBA 第一轮选秀球员最后就读的大学或学院，无论他们可能注册了多长时间，无论他们是否毕业。然而，并非每个球员都就读过大学或学院；对于那些没有就读的球员，`College`
    等于 `NA`。在 R 中，`NA` 或不可用相当于缺失值，因此不能忽略。在下一行代码中，我们调用基础 R 的 `is.na()` 函数将每个 `NA` 替换为
    `0`。
- en: 'In the second line of code, we again call the `mutate``()` and `ifelse()` functions
    to create a new variable, `College2`, and to add values derived from the original
    variable `College`. If that variable equals `0`, it should also equal `0` in `College2`;
    on the other hand, if `College` equals anything else, `College2` should instead
    equal `1`. The third line of code converts `College2` to a factor variable:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行代码中，我们再次调用 `mutate()` 和 `ifelse()` 函数来创建一个新变量 `College2`，并添加从原始变量 `College`
    导出的值。如果该变量等于 `0`，则 `College2` 中也应等于 `0`；另一方面，如果 `College` 等于其他任何值，则 `College2`
    应该改为等于 `1`。第三行代码将 `College2` 转换为因子变量：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, a quick check on the variable `Pos`, short for a player’s position,
    reveals yet another tidying opportunity—provided we didn’t previously glean the
    same when calling the `glimpse()`function. A call to the base R `levels()` function
    returns every unique attribute from `Pos`. Note that `levels()` only works with
    factor variables, so we therefore couple `levels()` with the `as.factor()` function
    to temporarily convert `Pos` from one class to another:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对变量 `Pos`（代表球员的位置）进行快速检查，揭示了另一个整理的机会——前提是我们之前在调用 `glimpse()` 函数时没有获得相同的信息。对基础
    R 的 `levels()` 函数的调用返回 `Pos` 中的每个唯一属性。请注意，`levels()` 只与因子变量一起工作，因此我们将 `levels()`
    与 `as.factor()` 函数结合使用，临时将 `Pos` 从一个类转换为另一个类：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We readily see that, for instance, some players play center and forward (`C-F`),
    whereas others play forward and center (`F-C`). It’s not clear if a player tagged
    as a C-F is predominantly a center and another player tagged as an F-C is predominantly
    a forward—or if this was simply the result of careless data entry. Regardless,
    these players play the same two positions because of their build and skill set.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很容易看出，例如，一些球员打中锋和前锋（`C-F`），而其他球员打前锋和中锋（`F-C`）。不清楚被标记为C-F的球员是否主要是中锋，而被标记为F-C的球员是否主要是前锋——或者这只是粗心大意的数据录入的结果。无论如何，这些球员由于体型和技能集而打相同的两个位置。
- en: 'In the first line of code that follows, we create a new variable called `Pos2`
    as an exact duplicate of `Pos`. In the next couple lines of code, we make a call
    to the `recode()` function to replace the `Pos2` attributes with new ones, as
    such (note that we apply quotation marks around the variable names because, at
    least for the time being, `Pos2` is still a character string):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码的第一行中，我们创建了一个名为`Pos2`的新变量，它是`Pos`的精确副本。在接下来的几行代码中，我们调用`recode()`函数将`Pos2`属性替换为新的属性，如下所示（注意，我们在变量名周围应用引号，因为至少目前，`Pos2`仍然是一个字符串）：
- en: '`C` is replaced by `Center`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C`被替换为`Center`。'
- en: '`C-F` and `F-C` are replaced by `Big`.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C-F`和`F-C`被替换为`Big`。'
- en: '`F` is replaced by `Forward`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F`被替换为`Forward`。'
- en: '`G` is replaced by `Guard`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G`被替换为`Guard`。'
- en: '`F-G` and `G-F` are replaced by `Swingman`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F-G`和`G-F`被替换为`Swingman`。'
- en: 'Then, we convert the variables `Pos` and `Pos2` to factors. Finally, we pass
    `Pos2` to the `levels()` function to confirm that our recoding worked as planned:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将变量`Pos`和`Pos2`转换为因子。最后，我们将`Pos2`传递给`levels()`函数以确认我们的重编码按计划进行：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With all this wrangling and tidying out of the way—at least for the time being—it
    makes sense to baseline our working data set, which we’ll do next.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些纠缠和整理工作——至少暂时如此——之后，对我们的工作数据集进行基准设置是有意义的，我们将在下一步进行。
- en: 2.4 Variable breakdown
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 变量分解
- en: 'After removing a subset of the original variables, converting other variables
    to factors, and then creating three new variables, the draft data set now contains
    the following 18 variables:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除了一部分原始变量、将其他变量转换为因子以及创建了三个新变量之后，选秀数据集现在包含以下18个变量：
- en: '`Rk`—A record counter only, with a maximum of 293\. The draft data set, when
    imported, *had* 293 records, where `Rk` starts at 1 and then increments by one
    with each subsequent record. Two records were subsequently removed due to incomplete
    data, thereby reducing the length of draft to 291 records, but the values in `Rk`
    remained as is despite the deletions.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rk`—仅记录计数器，最大值为293。当导入选秀数据集时，*有* 293条记录，其中`Rk`从1开始，然后随着每条后续记录的增加而递增。由于数据不完整，随后删除了两条记录，从而将选秀的长度减少到291条记录，但`Rk`中的值在删除后保持不变。'
- en: '`Year`—Represents the year a player was selected in the NBA draft, with a minimum
    of 2000 and a maximum of 2009\. For what it’s worth, the [http://data.world](http://data.world)
    data set actually covers the 1989 to 2016 NBA drafts; however, 10 years of data
    is sufficient for our purposes here. Because our intent (see chapter 3) is to
    eventually track career trajectories, 2009 is a reasonable and even necessary
    stopping point. We’ll sometimes summarize our data grouped by the variable `Year`.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Year`—表示球员在NBA选秀中被选中的年份，最小为2000年，最大为2009年。就其本身而言，[http://data.world](http://data.world)数据集实际上涵盖了1989年至2016年的NBA选秀；然而，10年的数据对于我们的目的来说已经足够了。因为我们的意图（见第3章）是最终追踪职业轨迹，2009年是一个合理甚至必要的截止点。我们有时会根据变量`Year`对数据进行分组总结。'
- en: '`Pk`—The draft data set containing first-round selections only. This is, therefore,
    the selection, or pick, number in the first round where, for instance, the number
    7 indicates the seventh overall pick. We’re particularly interested in win shares
    by the variable `Pk`; we expect to see differences between players picked high
    in the draft versus other players picked later in the first round.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pk`—仅包含第一轮选区的草稿数据集。因此，这是第一轮的选区号或抽签号，例如，数字7表示第七个整体抽签。我们特别关注变量`Pk`的赢分；我们预计在首轮高选球员与其他首轮较晚选中的球员之间会看到差异。'
- en: '`Tm`—The abbreviated team name—for instance, `NYK` for New York Knicks or `GSW`
    for Golden State Warriors—that made the draft pick.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tm`—做出选秀选择的简写队名——例如，`NYK`代表纽约尼克斯或`GSW`代表金州勇士。'
- en: '`Player`—The name of the player selected, in firstname lastname format (e.g.,
    Stephen Curry).'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player`—被选球员的姓名，采用名-姓格式（例如，斯蒂芬·库里）。'
- en: '`Age`—The age of each player at the time he was selected; for instance, Stephen
    Curry was 21.108 years old when the Warriors selected him seventh overall in 2009.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Age`—球员被选中时的年龄；例如，斯蒂芬·库里在2009年被勇士队以第七顺位选中时，年龄为21.108岁。'
- en: '`Pos`—The position, or positions, for each player, in abbreviated format.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pos`—每位球员的位置或位置，以缩写格式表示。'
- en: '`Born`—The country where each player was born, in abbreviated format.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Born`—每位球员出生的国家，以缩写格式表示。'
- en: '`College`—The college or university that each player last attended before turning
    professional. Of course, many players, especially those born overseas, didn’t
    attend college; where that is the case, the record now equals 0.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`College`—每位球员在成为职业球员之前最后就读的大学或学院。当然，许多球员，尤其是那些在国外出生的球员，没有上大学；在这种情况下，记录现在等于0。'
- en: '`From`—The first professional season for each player where, for instance, 2010
    equals the 2009-10 season. A typical NBA regular season starts in mid-October
    and concludes in mid-April of the following calendar year. Because the draft data
    set starts with the 2000 draft, the minimum value equals `2001`.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`From`—每位球员的第一个职业赛季，例如，2010年等于2009-10赛季。典型的NBA常规赛从十月中旬开始，到下一年历年的四月中旬结束。因为选秀数据集从2000年的选秀开始，所以最小值等于`2001`。'
- en: '`To`—The last season for which the draft data set includes player statistics.
    The maximum value here is `2020`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`To`—包含球员统计数据的最后一个赛季。这里的最大值是`2020`。'
- en: '`G`—The total number of regular season games played by each player between
    the 2000-01 and 2019-20 seasons.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G`—每位球员在2000-01赛季至2019-20赛季之间参加的常规赛总场数。'
- en: '`MP`—The average minutes played per regular season game by each player.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MP`—每位球员在常规赛每场比赛的平均出场时间。'
- en: '`WS`—The number of win shares accrued by each player between the 2000-01 and
    2019-20 seasons. Win shares is an advanced statistic used to quantify a player’s
    contributions to his team’s success. It combines each player’s raw statistics
    with team and league-wide statistics to produce a number that represents each
    player’s contributions to his team’s win count. The sum of individual win shares
    on any team should approximately equal that team’s regular season win total. Stephen
    Curry accrued 103.2 win shares between 2009 and 2020\. In other words, approximately
    103 of Golden State’s regular season wins over that 10-year stretch tie back to
    Curry’s offensive and defensive production. Most of the forthcoming EDA focuses
    on win shares, including its associations with other variables.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WS`—每位球员在2000-01赛季至2019-20赛季之间累积的胜利份额。胜利份额是一种高级统计数据，用于量化球员对其球队成功的贡献。它将每位球员的原始统计数据与球队和联盟统计数据相结合，产生一个代表每位球员对其球队胜利贡献的数字。任何球队的个人胜利份额总和应大致等于该球队的常规赛胜利总数。斯蒂芬·库里在2009年至2020年之间累积了103.2个胜利份额。换句话说，大约有103场金州勇士队在10年间的常规赛胜利与库里在进攻和防守上的表现有关。接下来的EDA大部分将关注胜利份额，包括其与其他变量的关联。'
- en: '`WS48`—The number of win shares accrued by each player for every 48 minutes
    played. NBA games are 48 minutes in duration, as long as they end in regulation
    and don’t require overtime.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WS48`—每位球员每48分钟累积的胜利份额。NBA比赛时长为48分钟，只要它们在常规时间内结束且不需要加时。'
- en: '`Born2`—Not in the original data set. This is a derived variable that equals
    `USA` if a player was born in the United States or `World` if the player was born
    outside the United States.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Born2`—不在原始数据集中。这是一个派生变量，如果一名球员出生在美国，则等于`USA`；如果球员出生在美国以外，则等于`World`。'
- en: '`College2`—Not in the original data set. This is a derived variable that equals
    `0` if a player didn’t attend a college or university or `1` if he did.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`College2`—不在原始数据集中。这是一个派生变量，如果球员没有上大学或学院，则等于`0`；如果上了大学，则等于`1`。'
- en: '`Pos2`—Not in the original data set. This is a derived variable that equals
    the full position name for each player so that, for instance, `F-G` and `G-F`
    both equal `Swingman`.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pos2`—不在原始数据集中。这是一个派生变量，等于每位球员的完整位置名称，以便例如`F-G`和`G-F`都等于`Swingman`。'
- en: 'An NBA team might have as many as 15 players on its active roster, but only
    5 players can play at a time. Teams usually play two guards, two forwards, and
    a center; what’s more, there are point guards and shooting guards, and there are
    small forwards and power forwards, as described here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一支NBA球队可能有多达15名球员在其活跃名单上，但一次只能有5名球员上场。球队通常有两名后卫、两名前锋和一名中锋；更重要的是，还有控球后卫和得分后卫，以及小前锋和强力前锋，如以下所述：
- en: '*Point guard*—Basketball’s equivalent to a quarterback; he runs the offense
    and is usually the best passer and dribbler.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控球后卫*——篮球中的四分卫；他负责组织进攻，通常是最好的传球手和运球手。'
- en: '*Shooting guard*—Often a team’s best shooter and scorer.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*得分后卫*——通常是球队最好的射手和得分手。'
- en: '*Small forward*—Usually, a very versatile player; he can score from inside
    or outside and defend short or tall players.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*小前锋*——通常是一个非常多才多艺的球员；他可以在内线或外线得分，并防守矮个或高个球员。'
- en: '*Power forward*—Normally, a good defender and rebounder, but not necessarily
    much of a shooter or scorer.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*大前锋*——通常是一个好的防守者和篮板球手，但不一定是很好的射手或得分手。'
- en: '*Center*—A team’s tallest player; he’s usually counted on to defend the basket,
    block shots, and rebound.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*中锋*——球队最高的球员；他通常被指望防守篮筐、封盖投篮和篮板球。'
- en: The draft data set doesn’t distinguish point guards from shooting guards or
    small forwards from power forwards; but it does single out those players who play
    multiple positions. A *swingman* is a player capable of playing shooting guard
    or small forward, and a *big* is a player who can play either power forward or
    center.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 草案数据集不区分控球后卫和得分后卫，也不区分小前锋和大前锋；但它确实突出了那些打多个位置的比赛者。*摇摆人*是一个能够打得分后卫或小前锋的球员，而*大前锋*是一个能够打大前锋或中锋的球员。
- en: 'A call to the `head()` function returns the first six observations in the new
    and improved draft data set:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`head()`函数返回新改进的草案数据集中的前六个观测值：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now it’s time to explore and analyze `win shares` and other variables from our
    data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候探索和分析我们数据中的`win shares`和其他变量了。
- en: 2.5 Exploratory data analysis
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 探索性数据分析
- en: To reiterate, EDA is most often a mix of computing basic statistics and creating
    visual content. For our purposes, especially as a lead-in to chapter 3, the EDA
    effort that follows concentrates on a single variable—`win shares`—but nonetheless
    provides insights into how `win shares` is associated, or not associated, for
    that matter, with many of the remaining draft data set variables. As such, our
    investigation of the draft data set will be a combination univariate (one variable)
    and bivariate (multiple variable) exercise.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，探索性数据分析（EDA）通常是计算基本统计量和创建视觉内容的混合。就我们的目的而言，特别是作为第3章的引言，接下来的EDA工作将集中在单个变量`win
    shares`上，但仍然提供了关于`win shares`与许多剩余的草案数据集变量相关联或未相关联的见解。因此，我们对草案数据集的调查将是一个单变量（一个变量）和多变量（多个变量）练习的组合。
- en: 2.5.1 Computing basic statistics
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 计算基本统计量
- en: The base R `summary()` function is called to kick-start the exploration and
    analysis of the draft data set, a process that will *mostly* focus on the variable
    `win shares`; that’s because we’re ultimately interested in understanding how
    much productivity teams can expect from their draft picks when `win shares` is
    pegged to other variables in our data set. The `summary()` function returns basic
    statistics for each variable in draft. For continuous, or numeric, variables such
    as `win shares`, the `summary()` function returns the minimum and maximum values,
    the first and third quartiles, and the median and mean; for categorical variables
    such as `Born2`, on the other hand, the `summary()` function returns the counts
    for each level. To elaborate, as far as continuous variables are concerned
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 基础R的`summary()`函数被调用以启动对草案数据集的探索和分析，这个过程将主要关注变量`win shares`；这是因为我们最终感兴趣的是了解当`win
    shares`与其他数据集中的变量挂钩时，球队可以从他们的选秀中期待多少生产力。`summary()`函数为草案中的每个变量返回基本统计信息。对于连续的或数值变量，如`win
    shares`，`summary()`函数返回最小值和最大值、第一四分位数和第三四分位数以及中位数和均值；对于如`Born2`这样的分类变量，另一方面，`summary()`函数返回每个级别的计数。为了详细说明，就连续变量而言
- en: The *minimum* represents the lowest value.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最小值*代表最低值。'
- en: The *maximum* represents the highest value.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最大值*代表最高值。'
- en: The *mean* is the average.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*均值*是平均值。'
- en: The *median* is the middle value when the data is sorted in ascending or descending
    order. When the data contains an even number of records, the median is the average
    between the two middle numbers.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*中位数*是当数据按升序或降序排列时的中间值。当数据包含偶数个记录时，中位数是两个中间数的平均值。'
- en: The *1st quartile* is the lower quartile; when data is arranged in ascending
    order, the lower quartile represents the 25% cutoff point.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第一四分位数*是下四分位数；当数据按升序排列时，下四分位数代表25%的分界点。'
- en: The *3rd quartile* is also known as the upper quartile; again, when the data
    is arranged in ascending order, the upper quartile represents the 75% cutoff point.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第三四分位数*也称为上四分位数；再次强调，当数据按升序排列时，上四分位数代表75%的分位数。'
- en: 'That all being said, we finally make our call to the `summary()` function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们最终调用`summary()`函数：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The most interesting and meaningful takeaways include the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣和有意义的收获包括以下内容：
- en: There is a tremendous amount of variance in career win shares. At least one
    first-round pick between the 2000 and 2009 NBA drafts actually accrued a *negative*
    number of win shares over the course of their career. One player accrued more
    than 236 win shares.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 职业胜利份额的差异极大。在2000年至2009年的NBA选秀中，至少有一位首轮新秀在其整个职业生涯中积累了负数的胜利份额。有球员积累了超过236个胜利份额。
- en: There are also significant variances in the other career statistics, namely
    regular season games played and average minutes played per regular season game.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他职业统计数据也存在显著差异，尤其是常规赛比赛数和每场常规赛的平均分钟数。
- en: Going back to win shares, the mean, which is especially sensitive to outliers
    (or data points far removed from the population center), is significantly greater
    than the median, suggesting that the mean is skewed by a small number of superstars
    in the data set.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回到胜利份额，平均值（对异常值或远离总体中心的观测值特别敏感）显著大于中位数，这表明平均值被数据集中的少数超级巨星所扭曲。
- en: First-round NBA draft picks between 2000 and 2009 were anywhere between 17.25
    and 25.02 years old at the time they were selected.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2000年至2009年的首轮NBA选秀球员在选秀时的年龄在17.25至25.02岁之间。
- en: More than three-quarters of the players in draft, 224 of 291, to be exact, were
    born in the United States.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在选秀中，超过四分之三的球员，确切地说，291位球员中的224位，出生在美国。
- en: Nearly the same number of players—218 to be specific—attended a college or university.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎相同数量的球员——确切地说，218位球员——曾就读于大学或学院。
- en: 'There are other basic statistics, however, that `summary``()` doesn’t return.
    The `sd()` function from base R, for instance, computes the standard deviation
    for continuous variables such as regular season games played (`G`), minutes played
    per regular season game (`MP`), and career win shares (`WS`). Once more, the `$`
    operator tells R to compute and return results for just the one variable that’s
    called out:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一些基本统计数据，`summary()`函数并没有返回。例如，基础R中的`sd()`函数计算连续变量（如常规赛比赛数`G`、每场常规赛的分钟数`MP`和职业生涯胜利份额`WS`）的标准差。再次强调，`$`运算符告诉R只计算并返回指定变量的结果：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The standard deviation is a measure of how dispersed the data is relative to
    the mean. Low standard deviations imply the data is clustered close to the mean;
    alternatively, high standard deviations suggest the data is more dispersed. *If*
    this data was Gaussian or normally distributed (think of a bell curve), approximately
    68% of the players in the draft data set would be within ± one standard deviation
    of the mean, 95% would be within ± two standard deviations of the mean, and all
    but perhaps a couple of players would be within ± three standard deviations of
    the mean. Take minutes played per regular season game—approximately 68% of the
    players are likely to have averaged somewhere between 13.71 and 29.35 minutes,
    which is equal to the population mean ± the standard deviation. We can get to
    the variance for any continuous variable by squaring its standard deviation or
    by passing the variable name to the base R `var()` function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 标准差是衡量数据相对于平均值的分散程度的指标。标准差低意味着数据集中在平均值附近；相反，标准差高意味着数据更分散。*如果*这些数据呈高斯分布或正态分布（想想钟形曲线），那么在大约68%的选秀数据集中的球员将位于平均值的±一个标准差范围内，95%的球员将位于平均值的±两个标准差范围内，除了一两名球员外，所有球员都将位于平均值的±三个标准差范围内。以每场常规赛的分钟数为例——大约68%的球员的平均分钟数可能在13.71至29.35分钟之间，这等于总体均值±标准差。我们可以通过平方标准差或通过将变量名传递给基础R的`var()`函数来得到任何连续变量的方差。
- en: 2.5.2 Returning data
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 返回数据
- en: 'In the following chunk of code, we run a series of independent `SELECT` statements
    by calling the `sqldf()` function from the `sqldf` package. Our purpose here is
    to dig deeper into the data and fetch some specifics that `summary()` and other
    functions don’t return:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块中，我们通过调用`sqldf`包中的`sqldf()`函数运行一系列独立的`SELECT`语句。我们的目的是深入数据并获取`summary()`和其他函数不返回的一些具体信息：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `SELECT` and `FROM` clauses identify which variables to pull from which
    data source. As just one example, the first `SELECT` statement fetches from draft
    the record where the variable `win shares` equals the data set minimum, returning
    the number of win shares, the player’s full name, the team that selected him,
    the pick number, and the year in which he was selected. `SELECT` statements—easy
    to write and usually quick to run—work best when you need just a data point or
    maybe a short list of records. If you need to instead create a data object that
    can subsequently be used as a source for further analysis, `dplyr` is a *way*
    better option. Going forward, we’ll direct our attention squarely to win shares,
    starting with some frequency distribution analysis.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT`和`FROM`子句标识了要从哪个数据源中提取哪些变量。例如，第一个`SELECT`语句从草案中检索变量`win shares`等于数据集最小值的记录，返回赢分、球员的全名、选他的球队、选秀号码以及他被选中的年份。`SELECT`语句——易于编写且通常运行迅速——当你只需要一个数据点或可能是一短列表的记录时效果最佳。如果你需要创建一个可以随后用作进一步分析源的数据对象，`dplyr`是一个更好的选择。从现在起，我们将将注意力集中在赢分上，从一些频率分布分析开始。'
- en: 2.5.3 Computing and visualizing frequency distributions
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.3 计算和可视化频率分布
- en: Pulling data is constructive. But visualizing data is like pressing down on
    the gas pedal—pictures show relationships between variables, display outliers,
    and demonstrate trends that numbers alone don’t reveal for us. In particular,
    frequency distributions are visual displays of continuous data counts. They are
    usually displayed as absolute frequencies, or representations of the raw data,
    but sometimes that same data is converted so that percentages or proportions are
    displayed instead. We’ll visualize the raw data with histograms and boxplots and
    then demonstrate how to write `sqldf` and `dplyr` code to get additional insights.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取数据是有建设性的。但可视化数据就像踩下油门——图片显示了变量之间的关系，显示了异常值，并展示了仅凭数字无法向我们揭示的趋势。特别是，频率分布是连续数据计数的视觉显示。它们通常以绝对频率或原始数据的表示形式显示，但有时相同的数据会被转换，以便显示百分比或比例。我们将使用直方图和箱线图来可视化原始数据，然后展示如何编写`sqldf`和`dplyr`代码以获得额外的见解。
- en: Histograms
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图
- en: No doubt the most common method of visualizing the frequency distribution of
    a continuous variable, like `win shares`, is with a histogram; so drawing a histogram
    is a logical starting point. A *histogram* is a graphical representation of the
    distribution of one continuous variable; it divides the data into what we call
    bins and then displays the frequency or count of observations within each bin.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，最常用的方法来可视化连续变量（如`win shares`）的频率分布是使用直方图；因此，绘制直方图是一个逻辑上的起点。**直方图**是表示一个连续变量分布的图形表示；它将数据划分为我们所说的“箱”，然后显示每个箱中观察值的频率或计数。
- en: 'Every visualization in this chapter was created with the `ggplot2` package;
    `ggplot2`, elegant yet powerful at the same time, is a big reason why R is a leader
    in the data visualization space. Building a `ggplot2` visualization is very much
    like creating a wedding cake—the `ggplot()` function establishes the foundation,
    and then other functions provide the frosting and decorations. Take note of the
    plus or addition operator (`+`) between successive calls to various `ggplot2`
    functions that add, change, or enhance a baseline build with the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的每个可视化都是使用`ggplot2`包创建的；`ggplot2`，既优雅又强大，是R在数据可视化领域领先的一个重要原因。构建`ggplot2`可视化非常类似于制作婚礼蛋糕——`ggplot()`函数建立基础，然后其他函数提供糖霜和装饰。请注意，在连续调用各种`ggplot2`函数以添加、更改或增强基本构建时，存在加号或加法运算符（`+`）：
- en: The `ggplot()` function initializes a `ggplot2` object. The first argument passed
    to `ggplot()`is a pointer to the data source, which, of course, is the draft data
    set. The second argument is a call to the `aes()` function, which defines the
    variables that should be plotted as well as which plot parameters, or axes, they
    should be mapped to.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ggplot()`函数初始化一个`ggplot2`对象。传递给`ggplot()`的第一个参数是数据源的指针，当然，是草案数据集。第二个参数是对`aes()`函数的调用，它定义了应该绘制哪些变量以及它们应该映射到哪些绘图参数或轴。'
- en: The `geom_histogram()` function—geom is short for geometric object—tells R to
    visualize the distribution of a single continuous variable by dividing the x-axis
    into a specified number of bins and counting the observations within each bin.
    The bins should be colored and filled with the same shade of royal blue.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geom_histogram()` 函数——geom 是几何对象的简称——告诉 R 通过将 x 轴划分为指定数量的箱并计算每个箱内的观测值来可视化单个连续变量的分布。箱应着色并填充相同的皇家蓝色。'
- en: The `labs()` function adds a title, subtitle, and labels for the x- and y-axes.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labs()` 函数为 x 轴和 y 轴添加标题、副标题和标签。'
- en: The `theme()` function applies a bold font to the title in place of the default
    plain font.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`theme()` 函数将粗体字体应用于标题，以替代默认的普通字体。'
- en: The base R `print()` function prints the histogram, called `p1`; also, `p1`
    by itself will do the same.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础 R 的 `print()` 函数打印出直方图，称为 `p1`；同时，仅 `p1` 本身也会执行相同的操作。
- en: 'Our histogram (see figure 2.1) provides a snapshot of the win shares data that
    makes it possible, in just a few seconds, to get a read on the distribution by
    simply eyeballing rows of data that would otherwise take much longer and potentially
    lead to false conclusions:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的直方图（见图 2.1）提供了对赢分数据的快照，只需几秒钟，就可以通过简单地观察数据行来了解分布，否则这将花费更长的时间，并可能导致错误的结论：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![CH02_F01_Sutton](../../OEBPS/Images/CH02_F01_Sutton.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F01_Sutton](../../OEBPS/Images/CH02_F01_Sutton.png)'
- en: Figure 2.1 Career win shares has a right-skewed, or positive-skewed, distribution.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 职业生涯赢分具有右偏斜，或正偏斜，的分布。
- en: The variable `win shares` has a right-skewed, or positive-skewed, distribution—right-skewed
    because the distribution has a long right tail and positive-skewed because the
    long tail is in the positive direction of the x-axis. In lay terms, it simply
    means that many NBA first-round picks between the 2000 and 2009 drafts accrued
    very few career win shares while just a few players accrued lots of win shares.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `win shares` 具有右偏斜，或正偏斜，的分布——右偏斜是因为分布有一个长的右尾，正偏斜是因为长尾位于 x 轴的正方向。用通俗的话说，这意味着在
    2000 年至 2009 年的 NBA 选秀中，许多首轮新秀在整个职业生涯中赢分很少，而只有少数球员赢分很多。
- en: Fills and colors
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 填充和颜色
- en: 'If you’re reading this book as a physical copy, you’ve surely noticed by now
    that every plot is printed in grayscale. Nevertheless, we demonstrate how to enhance
    your visualizations—`ggplot2` and otherwise—by adding custom fills and colors
    in almost every plot and referencing the same within the text. The following website
    is a `ggplot2` reference guide for fills and colors that is quite handy: [http://sape.inf.usi.ch/quick-reference/ggplot2/colour](http://sape.inf.usi.ch/quick-reference/ggplot2/colour).
    In addition, anyone who purchased a new copy of this book has access to the e-book
    version (with full color); please do refer to that if you’re interested in seeing
    visualizations in full color as coded.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你以实体书的形式阅读这本书，你现在肯定已经注意到每个图表都是以灰度打印的。尽管如此，我们展示了如何通过在几乎每个图表中添加自定义填充和颜色来增强你的可视化——无论是
    `ggplot2` 还是其他——并在文本中引用相同的颜色。以下是一个 `ggplot2` 填充和颜色参考指南的网站，它非常实用：[http://sape.inf.usi.ch/quick-reference/ggplot2/colour](http://sape.inf.usi.ch/quick-reference/ggplot2/colour)。此外，任何购买过这本书新副本的人都可以访问电子书版本（全彩）；如果你对查看全彩可视化感兴趣，请参阅该版本。 '
- en: 'The following pair of `SELECT` statements return the record counts in the draft
    data set where the number of career win shares is either greater than or equal
    to 75 or less than 75\. We’re therefore getting actual counts versus the approximate
    counts we got from our histogram. Including asterisks with the `COUNT()` function
    ensures that we get any observations with `null` values as part of the result
    set. More significantly, the `WHERE` clause identifies the conditions that must
    evaluate to `true` for any observation to be included in the results:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个 `SELECT` 语句返回在选秀数据集中，职业生涯赢分数量大于或等于 75 或小于 75 的记录数。因此，我们得到了实际计数，而不是从我们的直方图中得到的近似计数。在
    `COUNT()` 函数中包含星号确保我们得到任何包含 `null` 值的观测值作为结果集的一部分。更重要的是，`WHERE` 子句确定了任何观测值必须评估为
    `true` 的条件，才能包含在结果中：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Less than 10% of the first-round picks in the 2000 to 2009 NBA drafts then
    accrued at least 75 win shares in their respective careers. In fact, more than
    50% of the players, 169 of 291, accrued fewer than 25 win shares:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2000 年至 2009 年的 NBA 选秀中，不到 10% 的首轮新秀在其各自的职业生涯中至少赢得了 75 分。事实上，超过 50% 的球员，即
    291 名中的 169 名，赢分少于 25 分：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Boxplots
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 箱线图
- en: Another way of visualizing the frequency distribution of a continuous variable
    is with boxplots. Our next visualization contains two pairs of boxplots inside
    a facet plot, where the distribution of win shares is first segmented by the derived
    variable `Born2` and again by the derived variable `College2`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可视化连续变量频率分布的方法是使用箱线图。我们的下一个可视化包含一个分面图内的两对箱线图，其中胜利份额的分布首先根据派生变量`Born2`进行分段，然后根据派生变量`College2`再次进行分段。
- en: 'No two `ggpplot2` visualizations are exactly alike, especially across geoms,
    or geometric objects; however, they all follow the same general syntax and structure.
    Following are a few notes regarding our facet plot, where the data is broken out
    and visualized in subplots that share the same x- and y-axes:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 没有两个`ggplot2`可视化是完全相同的，尤其是在几何对象或几何形状之间；然而，它们都遵循相同的一般语法和结构。以下是一些关于我们的分面图的注意事项，其中数据被分解并在共享相同x轴和y轴的子图中可视化：
- en: The `stat_summary()` function adds a solid white dot to each boxplot to indicate
    the population means. The population medians are represented by horizontal lines,
    which `ggplot2` adds automatically.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stat_summary()`函数在每个箱线图上添加一个实心白点，以表示总体均值。总体中位数由水平线表示，这是`ggplot2`自动添加的。'
- en: The `facet_wrap()` function creates a panel—and therefore separate pairs of
    boxplots—for each level in the variable `Born2`; because `Born2` has two levels,
    our facet plot therefore has two panels.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`facet_wrap()`函数为变量`Born2`中的每个级别创建一个面板——因此为每个级别生成一对箱线图；因为`Born2`有两个级别，所以我们的分面图因此有两个面板。'
- en: The `scale_x_discrete()` function hardcodes the labels along the x-axis by converting
    `0` and `1`, which are the levels in `College2`, to `No College` and `College`,
    respectively. Accurate or intuitive labeling goes a long way toward improving
    the readability and interpretability of your visual content.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale_x_discrete()`函数通过将`College2`中的级别`0`和`1`分别转换为`No College`和`College`来硬编码x轴上的标签。准确或直观的标签对于提高你的视觉内容的可读性和可解释性有很大帮助。'
- en: 'Our second visualization (see figure 2.2) shows that win shares distributions
    vary depending on place of birth and whether or not players first attended a college
    or university:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个可视化（见图2.2）显示，胜利份额的分布因出生地以及玩家是否首先就读于大学或学院而有所不同：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![CH02_F02_Sutton](../../OEBPS/Images/CH02_F02_Sutton.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F02_Sutton](../../OEBPS/Images/CH02_F02_Sutton.png)'
- en: Figure 2.2 Distribution of win shares varies by place of birth and by whether
    a player first attended a college or university before turning professional.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 胜利份额的分布因出生地以及球员在成为职业球员之前是否首先就读于大学或学院而有所不同。
- en: 'Boxplots display the distribution of a continuous variable by isolating the
    following measures that align, but sometimes not exactly, with `summary()` function
    outputs:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 箱线图通过隔离以下与`summary()`函数输出相一致（但有时并不完全一致）的指标来显示连续变量的分布：
- en: '*Median*—The middle value, represented by a horizontal line.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*中位数*——中间值，由水平线表示。'
- en: '*First quartile*—The middle value between the smallest number (not necessarily
    the “minimum”) and the median, otherwise known as the 25th percentile.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第一四分位数*——最小数（不一定是“最小值”）和中位数之间的中间值，也称为25百分位数。'
- en: '*Third quartile*—The middle value between the median and the highest number
    (not necessarily the “maximum”), otherwise known as the 75th percentile.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第三四分位数*——中位数和最高值（不一定是“最大值”）之间的中间值，也称为75百分位数。'
- en: '*Interquartile Range (IQR**)*—The 25th to 75th percentiles; basically, the
    box. This can otherwise be derived by computing the difference between the first
    and third quartiles.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*四分位距（IQR）*——25百分位数到75百分位数；基本上，就是箱子。这也可以通过计算第一四分位数和第三四分位数的差来得到。'
- en: '*“Minimum”*—Equal to Q1 - (1.5 * IQR). This isn’t necessarily the lowest value;
    there may, in fact, be one or more data points—outliers—beyond the so-called minimum.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*“最小值”*——等于Q1 - (1.5 * IQR)。这不一定是最小值；实际上，可能存在一个或多个数据点——异常值——超出所谓的最小值。'
- en: '*“Maximum”*—Equal to Q3 + (1.5 * IQR). Likewise, this may not actually represent
    the highest value.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*“最大值”*——等于Q3 + (1.5 * IQR)。同样，这实际上可能并不代表最高值。'
- en: The mean isn’t a usual measure for boxplots, which is presumably why `ggplot2`
    doesn’t add it automatically. The whiskers are the lines extending below and above
    the IQR (boxplots are therefore often called box-and-whiskers plots). Dots, or
    circles, beyond the “minimum” and “maximum” are outliers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值不是箱线图的常规指标，这可能是为什么`ggplot2`不会自动添加它。胡须是延伸到IQR（箱线图因此通常被称为箱线图和胡须图）下方和上方的线。超出“最小值”和“最大值”的点或圆圈是异常值。
- en: 'This is otherwise a fascinating graphical representation of the data, rendering
    several truths:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种对数据的迷人图形表示，揭示了几个真理：
- en: Players born in the United States *generally* accrued more career win shares
    than did players born outside the United States.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出生在美国的球员通常比出生在美国以外的球员积累了更多的职业生涯胜利份额。
- en: Players born in the United States who bypassed college *generally* accrued more
    career win shares than did US-born players who did attend a college or university.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出生在美国并绕过大学的球员通常比那些出生在美国并上了大学或学院的球员积累了更多的职业生涯胜利份额。
- en: Alternatively, players born in any country other than the United States who
    did *not* attend a college or university *generally* accrued fewer win shares
    over their respective careers than did other players born outside the United States
    who *did* attend college.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，出生在除美国以外任何国家的球员，如果没有上大学或学院，通常在其职业生涯中积累的胜利份额比那些出生在美国并上了大学或学院的球员要少。
- en: The means are consistently higher than the medians, suggesting, of course, that
    average win shares, regardless of how the data is sliced and diced, are influenced
    by superstar production.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 均值始终高于中位数，这当然表明，无论数据如何切割和重组，平均胜利份额都受到超级巨星产出的影响。
- en: 'More boxplots display the distribution of win shares by year or draft class
    (see figure 2.3):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的箱线图显示了按年份或草稿类别划分的胜利份额分布（见图2.3）：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![CH02_F03_Sutton](../../OEBPS/Images/CH02_F03_Sutton.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F03_Sutton](../../OEBPS/Images/CH02_F03_Sutton.png)'
- en: Figure 2.3 Not every draft class between 2000 and 2009 was alike.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 并非2000年至2009年间的每个草稿类别都相同。
- en: Tables
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 表格
- en: Let’s again take some deeper dives into our data. Rather than just writing a
    series of `SELECT` statements again, we’ll demonstrate how to expand your use
    of the `dplyr` package, which contains several functions for pulling and manipulating
    data. Once more, `sqldf` is just fine if you merely need a few data points, but
    if you need a result set that can subsequently be passed to `ggplot2` or be used
    for other analysis, you’ll want—and need—to become comfortable with `dplyr`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次深入挖掘我们的数据。与其再次编写一系列 `SELECT` 语句，我们将展示如何扩展你对 `dplyr` 包的使用，该包包含几个用于提取和操作数据的函数。再次强调，如果你只需要几个数据点，`sqldf`
    就足够好了，但如果你需要一个可以随后传递给 `ggplot2` 或用于其他分析的结果集，你将需要——并且必须——熟悉 `dplyr`。
- en: 'The first key to understanding the following few lines of code is knowing how
    the pipe operator `(%>%)` works. In short, the pipe operator assigns each functional
    output as an argument to the next function. Think of the pipe as the means by
    which the output from one function, or operation, is then transported to another
    function or operation. You can also think of the word “then” as the pseudocode
    substitute for the pipe: “take the draft data set THEN compute a series of summary
    statistics.”'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 理解以下几行代码的第一个关键是要知道管道操作符 `(%>%)` 的工作原理。简而言之，管道操作符将每个函数的输出作为下一个函数的参数。可以把管道看作是将一个函数或操作的输出传输到另一个函数或操作的手段。你还可以把“然后”这个词看作是管道的伪代码替代：
    “获取草稿数据集然后计算一系列汇总统计量。”
- en: The second key is knowing how the `dplyr summarize()` function works; `summarize``()`
    is somewhat similar to the base R `summary()` function, except that `summarize()`
    is much more flexible and extendable, especially when it’s paired with the `dplyr`
    `group_by()` function. Here, we’re instructing `summarize()` to compute standard
    boxplot-type measures.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个关键是要了解 `dplyr summarize()` 函数的工作原理；`summarize()` 函数与基础R的 `summary()` 函数有些相似，但
    `summarize()` 函数要灵活得多，可扩展性也更强，尤其是在与 `dplyr` 的 `group_by()` 函数搭配使用时。在这里，我们指导 `summarize()`
    函数计算标准箱线图类型的度量。
- en: 'Results are then pushed (take note of the assignment operator) to a tibble
    called `first_tibble`. By far, the most important thing to know about tibbles,
    which are specific to R, is that they share many of the same properties as data
    frames, meaning they can be wrangled and used as data sources for visual content
    and other analysis. However, when printed, only the first 10 rows and whatever
    number of columns that fit onscreen are returned; you’ll see and experience this
    repeatedly. In addition, some base R functions and other legacy code won’t work
    with tibbles (or tibbles won’t work with older code). When that’s the case—and
    we’ll see this much later on—simply convert the tibble to a data frame by passing
    it to the base R `as.data.frame()` function:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 结果随后被推送到一个名为`first_tibble`的tibble中（请注意赋值运算符）。关于R特有的tibble，最重要的是要知道它们与数据框共享许多相同的属性，这意味着它们可以被整理并用作视觉内容和其它分析的源数据。然而，当打印时，只返回前10行以及适合屏幕的列数；你将反复看到和体验到这一点。此外，一些基本的R函数和其他遗留代码与tibble（或tibble与旧代码）不兼容。当这种情况发生时——我们将在稍后看到——只需通过传递给基本的R
    `as.data.frame()`函数将tibble转换为数据框即可：
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following code chunk passes `draft` as an argument to the `group_by()`
    function, and then the `group_by()` function is subsequently passed as an argument
    to the `summarize()` function. Perhaps a better, more effective way of understanding
    these few lines of code is to think of the `summarize()` function as computing
    the mean of win shares by year rather than doing so holistically. The results
    are then thrown into a new object, or tibble, called `second_tibble`. These results
    align with our previous set of boxplots:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块将`draft`作为参数传递给`group_by()`函数，然后`group_by()`函数随后作为参数传递给`summarize()`函数。或许理解这几行代码的更好、更有效的方法是将`summarize()`函数视为按年份计算胜分均值的操作，而不是整体操作。结果随后被放入一个新的对象，或tibble，称为`second_tibble`。这些结果与我们的之前的箱线图相一致：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, the `dplyr tally()` function counts, or tallies, the number of players
    in the draft data set who accrued 75 or more win shares in their respective careers,
    and it breaks the results down by every factor, or level, in the variable `Year`.
    Clearly, means are influenced by the number of draft picks who then accrued a
    relatively high number of career win shares:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`dplyr tally()`函数统计了在选秀数据集中积累了75个或更多胜分的球员数量，并且按变量`Year`中的每个因素或水平分解结果。显然，均值受到积累了相对较高职业胜分选秀球员数量的影响：
- en: '[PRE25]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, alternating between `dplyr` code and `sqldf` code, the following `SELECT`
    statement returns the variables `Player` and `Pk` from `draft` where `WS` is greater
    than or equal to `75` *and* the variable `Year` equals `2001` (just to show who
    are/were the seven players from the 2001 draft who then accrued 75 or more win
    shares as professionals):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`dplyr`代码和`sqldf`代码之间交替，下面的`SELECT`语句返回`draft`中的`Player`和`Pk`变量，其中`WS`大于或等于`75`，并且变量`Year`等于`2001`（只是为了展示2001年选秀中积累了75个或更多胜分的七名球员）：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next `SELECT` statement returns those same variables where `WS` again is
    greater than or equal to `75` and where the variable `Year` this time equals `2003`
    (just to show who are/were the five players from the 2001 draft who then accrued
    75 or more win shares). The results are returned sorted in descending order by
    win shares:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`SELECT`语句返回相同的变量，其中`WS`再次大于或等于`75`，并且变量`Year`这次等于`2003`（只是为了展示2001年选秀中积累了75个或更多胜分的五名球员）。结果按胜分降序排列：
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this next chunk of `dplyr` code, the draft data set is subset, or filtered,
    to include only those records where the variable `WS` is greater than or equal
    to `75`; between the `group_by``()` and `summarize()` functions, the mean of `Pk`
    is then computed across each year in draft. The results are pushed to a 9 × 2
    tibble called `fourth_tibble`. You might recall that no players selected in the
    2000 draft then earned more than 75 career win shares; R doesn’t return any results
    for that year’s draft because it’s impossible, of course, to compute anything
    from zero records. Otherwise, note how low the averages are when you consider
    there were either 29 or 30 first-round selections in each draft between 2000 and
    2009:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个 `dplyr` 代码块中，草稿数据集被子集化或过滤，仅包含变量 `WS` 大于或等于 `75` 的记录；在 `group_by()` 和 `summarize()`
    函数之间，然后计算每个年份的 `Pk` 的平均值。结果被推送到一个 9 × 2 的 tibble，称为 `fourth_tibble`。您可能还记得，在 2000
    年的选秀中，没有球员获得了超过 75 个职业生涯胜利份额；R 为那一年的选秀没有返回任何结果，因为当然，从零记录中无法计算任何东西。否则，请注意，当考虑到每个选秀中都有
    29 或 30 个第一轮选择时，平均值有多低：
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can run relatively simple and straightforward computations with the `sqldf()`
    function. In the following, the mean for the variable `Pk` is computed where the
    variable `WS` is greater than or equal to `75`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `sqldf()` 函数运行相对简单直接的计算。以下计算了变量 `Pk` 的平均值，其中变量 `WS` 大于或等于 `75`：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, the draft data set is again subset to include only those records where
    a player’s career win share total equaled or exceeded 75 by calling the `dplyr
    filter()` function. Between the `dplyr` `group_by``()` and `summarize()` functions,
    the median of `Pk` is computed by the variable `Year` and then thrown into a new
    object called `fifth_tibble`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，草稿数据集再次子集化，仅包含那些球员的职业生涯胜利份额总和等于或超过 75 的记录，这是通过调用 `dplyr filter()` 函数实现的。在
    `dplyr` `group_by()` 和 `summarize()` 函数之间，通过变量 `Year` 计算了 `Pk` 的中位数，然后将其放入一个新的对象
    `fifth_tibble` 中：
- en: '[PRE30]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following `SELECT` statement computes and returns the median of the variable
    `Pk` across the entire draft data set where, again, the variable `WS` is greater
    than or equal to `75`. Notice how much lower the median, which is insensitive
    to outliers, is than the mean:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `SELECT` 语句计算并返回整个草稿数据集中变量 `Pk` 的中位数，其中变量 `WS` 再次大于或等于 `75`。请注意，中位数（对异常值不敏感）比平均值低得多：
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you might imagine by now, the mean and median for the variable `Pk` are
    even lower when the draft data set is subset to include only records where the
    variable `WS` is equal to or greater than `100`, rather than `75`. The following
    `dplyr` code returns the annual mean for `Pk` and casts the results into an object
    called `sixth_tibble`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在可能想象的那样，当草稿数据集仅包含变量 `WS` 等于或大于 `100` 的记录时，变量 `Pk` 的平均值和中位数甚至更低。以下 `dplyr`
    代码返回 `Pk` 的年度平均值，并将结果转换为一个名为 `sixth_tibble` 的对象：
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The next `SELECT` statement computes and returns the mean for the variable
    `Pk` across all of `draft` where the variable `WS` equals or exceeds `100`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个 `SELECT` 语句计算并返回 `draft` 中变量 `WS` 等于或超过 `100` 的 `Pk` 的平均值：
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let’s look at the same set of operations, except the median is substituted
    for the mean. The next chunk of `dplyr` code computes the median of `Pk` for each
    year in draft when the data set is previously subset where the variable `WS` is
    equal to or greater than `100`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看相同的操作集，只是用中位数代替了平均值。以下 `dplyr` 代码块计算了在草稿数据集之前已按变量 `WS` 等于或大于 `100` 进行子集化时，每个年份的
    `Pk` 的中位数：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following `SELECT` statement then computes and returns the median of `Pk`
    where `WS` equals or exceeds `100`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `SELECT` 语句随后计算并返回 `WS` 等于或超过 `100` 的 `Pk` 的中位数：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s pivot and pull some figures where `WS` is equal to or less than `25`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们旋转并提取 `WS` 等于或小于 `25` 的某些数字：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'On average, players who accrued fewer win shares were selected later in the
    first round than other players who earned significantly more win shares. The next
    `SELECT` statement computes and returns the mean and median of the variable `Pk`
    where `WS` is equal to or less than `25`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 平均而言，获得较少胜利份额的球员在第一轮被选中的时间晚于获得更多胜利份额的其他球员。下一个 `SELECT` 语句计算并返回变量 `Pk` 在 `WS`
    等于或小于 `25` 时的平均值和中位数：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let’s go a step further and see what these same figures look like when draft
    is subset to just include players who earned fewer than five win shares in their
    respective careers. Once more, we use `dplyr` to get the annual results and `sqldf`
    to return the overall results:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，看看当选秀名单仅包括在其职业生涯中赢得少于五个胜利份额的球员时，这些相同的数字看起来如何。再次使用`dplyr`获取年度结果，使用`sqldf`返回总体结果：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Many of the first-round selections in the 2000-2009 NBA drafts never amounted
    to much. For every LeBron James or Stephen Curry, there are dozens of other first-round
    picks who are mostly unknown today to most professional basketball fans. Almost
    30% of the first-round picks between 2000 and 2009 earned fewer than five win
    shares in their respective professional careers. The next `SELECT` statement pulls
    a count of players in the draft data set where the variable `WS` is less than
    `5`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 2000-2009年NBA选秀中的许多首轮选中的球员从未成为什么大人物。对于每个勒布朗·詹姆斯或斯蒂芬·库里，都有数十个其他首轮选中的球员，对于大多数职业篮球迷来说，他们今天几乎无人知晓。2000年至2009年之间，近30%的首轮选中的球员在其职业生涯中赢得了少于五个胜利份额。下一个`SELECT`语句提取了在选秀数据集中变量`WS`小于`5`的球员数量：
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Our final `SELECT` statement pulls the number of players in draft who finished
    their NBA careers with a negative number of win shares:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的`SELECT`语句提取了在选秀中结束NBA职业生涯时胜利份额为负数的球员数量：
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Clearly, not every draft class was created equal. Here are the most significant
    takeaways from the latest set of boxplots as well as the returns from our chunks
    of `dplyr` and `sqldf` code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，并非每个选秀批次都是平等的。以下是最新一批箱线图以及我们`dplyr`和`sqldf`代码块返回的最显著发现：
- en: 'The 2001 class stands out: first-round selections from the 2001 NBA draft averaged
    more win shares over the course of their careers, 39, than any other class of
    first-round selections between 2000 and 2009\. Only in 2001 does the top end of
    the IQR exceed 50 win shares.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2001届脱颖而出：2001年NBA选秀的第一轮选中的球员在其职业生涯中平均赢得了39个胜利份额，这是2000年至2009年之间任何一批次首轮选中球员中最多的。只有2001届，IQR的上限才超过50个胜利份额。
- en: Furthermore, seven players from this same class accrued 75 or more win shares
    during their careers, the most of any class within the draft data set. Three of
    these players—Tyson Chandler, Pau Gasol, and Shane Battier—were among the top
    six picks that year; three other players—Joe Johnson, Richard Jefferson, and Zach
    Randolph—were selected between picks 10 and 19; and then there’s Tony Parker,
    who was selected at 28 and then accrued 111.3 win shares, all while playing for
    the San Antonio Spurs.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，同一批次的七名球员在其职业生涯中积累了75个或更多的胜利份额，这是选秀数据集中任何一批次中最多的。其中三名球员——泰森·钱德勒、保罗·加索尔和肖恩·巴蒂尔——当年排名前六；另外三名球员——乔·约翰逊、理查德·杰弗森和扎克·兰多夫——被选在10到19号签之间；然后还有托尼·帕克，他在第28顺位被选中，并在为圣安东尼奥马刺队效力期间积累了111.3个胜利份额。
- en: First-round selections from the 2003 NBA draft averaged almost as many win shares,
    38, as did the first-round picks from the 2001 class. LeBron James, Dwyane Wade,
    Chris Bosh, Carmelo Anthony, and David West all accrued more than 75 win shares
    in their respective careers, and that’s just through the 2019-20 season.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2003年NBA选秀的第一轮选中的球员平均赢得了38个胜利份额，与2001届第一轮选中的球员相当。勒布朗·詹姆斯、德维恩·韦德、克里斯·波什、卡梅隆·安东尼和戴维斯·韦斯特都在他们的职业生涯中赢得了超过75个胜利份额，这仅仅是到2019-20赛季为止。
- en: Four of the five players just referenced—all but David West—were among the first
    five players selected in 2001.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考的这五名球员中的四名——除了大卫·韦斯特——都是2001年首轮前五名被选中的球员。
- en: On the flip side, the 2000 class was probably the most disappointing; first-round
    selections from 2000 averaged barely 18 win shares in their respective careers,
    easily the lowest average of any class in the draft data set. Not surprisingly,
    no players drafted in 2000 earned up to 75 win shares in their respective careers.
    Only in 2000 does the top end of the IQR fall short of 25 win shares.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相反，2000届可能是最令人失望的；2000届首轮选中的球员在其职业生涯中平均只赢得了18个胜利份额，这是选秀数据集中任何一批次中最低的平均值。不出所料，2000届没有球员在其职业生涯中赢得了75个胜利份额。只有2000届，IQR的上限才低于25个胜利份额。
- en: Players who, so far, have accrued at least 75 win shares were selected eighth,
    on average; in fact, in the nine classes from draft that include at least one
    player who then accrued 75 or more win shares, in five of these classes, the average
    was 6 win shares or less. The median equals 4.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，积累了至少75个胜利份额的球员平均被选中为第八位；事实上，在九个至少有一名球员后来积累了75个或更多胜利份额的选秀批次中，有五个批次的平均胜利份额为6个或更少。中位数等于4。
- en: When draft is subset on those players who have accrued a minimum of 100 win
    shares in their respective careers, the average pick, or selection number, equals
    4, and the median is 3.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对那些在其职业生涯中累积了至少 100 个胜利份额的球员进行子集时，平均选择数或选择编号等于 4，中位数是 3。
- en: Of the 291 first-round selections in the draft data set, 81 of them accrued
    fewer than 5 career win shares, and 20 of these players accrued a *negative* number
    of career win shares.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在选秀数据集中的 291 个首轮选择中，其中 81 个累积的职业生涯胜利份额少于 5，这 81 名球员中有 20 名球员累积的职业生涯胜利份额为负数。
- en: There appears to be a relationship between win shares and where in the first
    round players were selected. Players who accrued a relatively high number of win
    shares were generally drafted before other players who earned a lesser number
    of win shares.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看起来胜利份额与球员在首轮被选中的位置之间存在某种关系。累积相对较高胜利份额的球员通常在其他获得较少胜利份额的球员之前被选中。
- en: Let’s now explore how `win shares` is correlated, or maybe not correlated, with
    the other continuous variables in our data set.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探讨 `胜利份额` 与数据集中其他连续变量之间的关联性，或者可能没有关联性。
- en: 2.5.4 Computing and visualizing correlations
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.4 计算和可视化关联性
- en: Correlation is a statistical measure that quantifies the linear relationship
    between a pair of continuous, or numeric, variables. That relationship can either
    be positive or negative. When positive, the variables increase together at constant
    rates; when negative, the variables change at constant rates, but one increases
    while the other decreases. The relationship might actually be neutral as well.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 关联性是一种统计度量，它量化了一对连续变量或数值变量之间的线性关系。这种关系可以是正的，也可以是负的。当为正时，变量以恒定的速率同时增加；当为负时，变量以恒定的速率变化，但一个增加而另一个减少。这种关系实际上也可能是中性的。
- en: The relationship between two continuous variables is determined by computing
    the correlation coefficient between them. The result will always equal some number
    between -1 and +1\. When the correlation coefficient equals or approximates -1,
    then the relationship is negative; when the correlation coefficient instead equals
    or approximates +1, the relationship is positive. As a rule of thumb, correlation
    coefficients less than -0.8 and greater than 0.8 are indications of a strong linear
    relationship; correlation coefficients between -0.6 and -0.8 and also between
    0.6 and 0.8 are indications of a fairly strong linear relationship; and correlation
    coefficients at or near 0 are indications of no relationship at all. Just because
    a pair of continuous variables might be strongly correlated doesn’t necessarily
    mean that one variable influences the other—correlation isn’t the same as causation.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 两个连续变量之间的关系是通过计算它们之间的关联系数来确定的。结果将始终等于 -1 和 +1 之间的某个数字。当关联系数等于或近似于 -1 时，则关系为负；当关联系数等于或近似于
    +1 时，关系为正。作为一个经验法则，关联系数小于 -0.8 且大于 0.8 是强线性关系的迹象；关联系数在 -0.6 和 -0.8 之间以及 0.6 和
    0.8 之间也是相当强线性关系的迹象；关联系数在或接近 0 时表示没有关系。仅仅因为一对连续变量可能高度相关，并不意味着一个变量影响另一个变量——关联性不等于因果关系。
- en: It’s very easy in R to compute the correlation coefficient between two variables
    or between multiple pairs of variables at one time. There are also *many* options
    in R for visualizing the same. We’ll demonstrate how to do the latter by creating
    a `ggplot2` heat map. A *heat map* is a diagram that associates different data
    values with different colors or shades.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 R 中计算两个变量或一次计算多个变量对的关联系数非常容易。R 中也有许多选项用于可视化。我们将通过创建一个 `ggplot2` 热图来演示如何进行后者。热图是一种将不同的数据值与不同的颜色或阴影关联的图表。
- en: 'With that in mind, our first step is to create a new object, `cor_draft`, by
    passing `draft` via the pipe operator (`%>%`) to the `dplyr select()` function
    to subset our original data set on its five continuous variables: `Age`, `G`,
    `MP`, `WS`, and `WS48`. After all, we only compute correlation coefficients between
    continuous variables; if we were to try otherwise, R would throw an error. Here’s
    the first step:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们的第一步是通过管道操作符 (`%>%`) 将 `draft` 传递给 `dplyr select()` 函数，创建一个新的对象 `cor_draft`，以对其原始数据集的五个连续变量：`Age`（年龄）、`G`（比赛次数）、`MP`（分钟数）、`WS`（胜利份额）和
    `WS48`（48分钟胜利份额）进行子集。毕竟，我们只计算连续变量之间的关联系数；如果我们尝试其他方式，R 会抛出错误。以下是第一步：
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The second step is to more or less convert `cor_draft` into a tabular format
    by passing it to the base R `cor()` function, which computes the correlation coefficient
    between every pair of variables. Our results are cast to a new object called `cor_matrix`.
    A subsequent call to the `print()` function is optional—as this isn’t a required
    step to create a heat map—but it does, of course, return the results and shows
    us what a correlation matrix should look like. Here’s the second step:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是将 `cor_draft` 大概转换为表格格式，通过传递给基本 R `cor()` 函数，该函数计算每对变量之间的相关系数。我们的结果被转换到一个名为
    `cor_matrix` 的新对象中。随后的 `print()` 函数调用是可选的——这不是创建热图所必需的步骤——但它当然会返回结果并显示相关矩阵应该是什么样子。以下是第二步：
- en: '[PRE42]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For instance, the correlation coefficient between the variables `MP` and `WS48`
    equals 0.66 (rounded). We actually see this twice because every pair of variables
    in a matrix intersects at two points, which isn’t what we want in our heat map.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，变量 `MP` 和 `WS48` 之间的相关系数等于 0.66（四舍五入）。我们实际上看到了两次，因为矩阵中的每一对变量在两个点上相交，这不是我们热图所希望的。
- en: 'The third step requires a call to the `melt()` function from the `reshape2`
    package. The `melt()` function racks and stacks every two-variable combination
    from `cor_matrix` between a pair of columns labeled `Var1` and `Var2` and also
    creates a third column called `value` where the cells are populated with the corresponding
    correlation coefficient. In consideration of space, rather than printing the entire
    result set, the `head``()` and `tail()` functions are called to just return the
    first three and last three observations in our new object, `cor_table`. Here’s
    the third step:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步需要调用 `reshape2` 包中的 `melt()` 函数。`melt()` 函数将 `cor_matrix` 中的每一对变量组合（标记为 `Var1`
    和 `Var2`）进行排列和堆叠，并创建一个名为 `value` 的第三列，其中单元格填充了相应的相关系数。考虑到空间，而不是打印整个结果集，我们调用 `head()`
    和 `tail()` 函数来仅返回我们新对象 `cor_table` 中的前三个和最后三个观测值。以下是第三步：
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The next chunk of code produces our heat map now that we have a perfectly formatted
    data source:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了格式完美的数据源，接下来的代码块生成了我们的热图：
- en: As with any `ggplot2` visualization, the object is initialized by calling the
    `ggplot()` function, where `cor_table` is passed as the data source for our heat
    map; the `cor_table` variables `Var1` and `Var2` are, respectively, our x- and
    y-axis variables; and the fill is based on the computed correlation coefficient.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与任何 `ggplot2` 可视化一样，对象是通过调用 `ggplot()` 函数初始化的，其中 `cor_table` 被传递为热图的数据源；`cor_table`
    变量 `Var1` 和 `Var2` 分别是 x 轴和 y 轴变量；填充基于计算出的相关系数。
- en: The `geom_tile()` function is the `ggplot()` function that draws the heat map.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`geom_tile()` 函数是 `ggplot()` 函数，用于绘制热图。'
- en: The `scale_fill_gradient2()` function establishes a two-color gradient scheme
    across correlation coefficients.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale_fill_gradient2()` 函数在相关系数之间建立了一个双色调渐变方案。'
- en: Text geoms are called when labels or annotations are in order. By calling the
    `geom_text()` function, we’re annotating our correlation matrix with the actual
    correlation coefficients between each pair of continuous variables in our data
    source. The base R `round()` function reduces our coefficients to only two digits
    right of the decimal point.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当标签或注释有序时，会调用文本几何。通过调用 `geom_text()` 函数，我们用数据源中每对连续变量之间的实际相关系数来注释我们的相关矩阵。基本的
    R `round()` 函数将我们的系数减少到小数点后两位。
- en: 'The purpose of a heat map, or correlation matrix, is to equate colors and their
    shades with different correlation coefficients (see figure 2.4). Positive correlations
    are represented by one color gradient, and negative correlations are represented
    by a different color gradient. Deeper shades represent stronger associations between
    variables, and vice versa. Following is our code, and right after that is our
    heat map created from the same:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 热图或相关矩阵的目的是将颜色及其阴影与不同的相关系数相对应（见图2.4）。正相关用一种颜色渐变表示，负相关用另一种颜色渐变表示。较深的阴影表示变量之间的更强关联，反之亦然。以下是我们的代码，紧接着是我们的热图，它是由相同的代码生成的：
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![CH02_F04_Sutton](../../OEBPS/Images/CH02_F04_Sutton.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F04_Sutton](../../OEBPS/Images/CH02_F04_Sutton.png)'
- en: Figure 2.4 Matrix of correlation coefficients between all continuous variables
    in the draft data set
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 拟数据集中所有连续变量之间的相关系数矩阵
- en: 'There are at least two conclusions that pop out:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有两个结论跃然纸上：
- en: There are positive and strong, or at least fairly strong, correlations between
    win shares and regular season games played, minutes played per regular season
    game, and win shares for every 48 minutes of playing time. Mind you, correlation
    coefficients don’t tell us which variable might be influencing another variable,
    if there is any causation at all.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赢分与常规赛比赛次数、每场常规赛的分钟数以及每48分钟比赛时间的赢分之间存在正相关和强相关，或者至少相当强。请注意，相关系数并不能告诉我们哪个变量可能正在影响另一个变量，如果存在任何因果关系的话。
- en: There is also a negative correlation between the variables `Win Shares` and
    `Age`, which is to say that players entering the NBA draft between 2000 and 2009
    at younger ages then accrued, *generally*, more career win shares than players
    who turned professional at “older” ages. The correlation between these variables
    isn’t strong, however. No doubt this is partially true because younger players
    likely have more years to play as professionals and therefore more opportunity
    to accrue more win shares. But it’s also true—or at least likely—that better players
    turn professional at younger ages than lesser-skilled players.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量“赢分”和“年龄”之间也存在负相关关系，也就是说，2000年至2009年间参加NBA选秀的年轻球员，*通常*比在“较老”年龄成为职业球员的球员积累了更多的职业赢分。然而，这些变量之间的相关性并不强。毫无疑问，这部分的真相可能是，年轻球员可能有更多的年份作为职业球员进行比赛，因此有更多机会积累更多的赢分。但这也可能是真的——至少很可能是这样——更好的球员比技能较低的球员更早成为职业球员。
- en: Next, we’ll visualize population means and medians with a series of bar charts
    so that we can determine how win shares compare across different levels in our
    factor variables.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过一系列条形图来可视化人口均值和中位数，以便我们可以确定在不同水平上我们的因素变量中的赢分如何比较。
- en: 2.5.5 Computing and visualizing means and medians
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.5 计算和可视化均值和中位数
- en: 'Finally, we’re going to slice and dice our data set by computing and then visualizing
    the mean and median win shares broken down by the derived variables we created
    earlier. The following chunk of `dplyr` code again takes the `group_by``()` and
    `summarize()` functions to summarize a subset of the data in the draft data set,
    thereby computing the mean and median win shares by the derived variable `Born2`.
    The results are pushed to a 2 × 3 tibble called `tenth_tibble`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过计算并可视化按我们之前创建的派生变量划分的均值和赢分中位数来切割和分解我们的数据集。以下`dplyr`代码块再次使用`group_by()`和`summarize()`函数来总结选秀数据集中的数据子集，从而计算按派生变量`Born2`划分的均值和赢分中位数。结果被推送到一个2×3的tibble，称为`tenth_tibble`：
- en: '[PRE45]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: These results are then visualized in a pair of `ggplopt2` bar charts, where
    the averages in career win shares are represented on the left, and the median
    win shares are represented on the right (see figure 2.5). In a typical bar chart,
    each level in a factor variable is represented by a separate bar, and the length
    of each bar (not necessarily the height because bar charts can also be oriented
    horizontally) corresponds to the value or frequency of the data it represents.
    In fact, bar charts are especially effective at visualizing categorical data,
    such as sales figures by region or net profits by fiscal year—or means and medians
    when `Born2` equals `USA` or `World`. There are many variations of bar charts
    and even substitutes for bar charts, and we’ll demonstrate many of these in subsequent
    chapters.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果随后在两个`ggplopt2`条形图中进行可视化，其中职业赢分的平均值表示在左侧，而中位数赢分表示在右侧（见图2.5）。在典型的条形图中，因素变量中的每个水平都由一个单独的条形表示，每个条形的长度（不一定是高度，因为条形图也可以水平排列）对应于它所代表的数据值或频率。实际上，条形图在可视化分类数据方面特别有效，例如按地区划分的销售数据或按财政年度划分的净利润——当`Born2`等于`USA`或`World`时，也适用于均值和中位数。条形图有许多变体，甚至还有条形图的替代品，我们将在后续章节中展示许多这些变体。
- en: '![CH02_F05_Sutton](../../OEBPS/Images/CH02_F05_Sutton.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F05_Sutton](../../OEBPS/Images/CH02_F05_Sutton.png)'
- en: Figure 2.5 Average and median career win shares by place of birth
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 按出生地划分的平均和职业赢分中位数
- en: The y-axes are standardized between the two plots through similar calls to the
    `ylim()` function; otherwise, the y-axis scales would be different between the
    two visualizations, and the height of the bars would be identical, defeating the
    point of showing the differences between means and medians.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对`ylim()`函数的类似调用，两个图表之间的y轴被标准化；否则，两个可视化之间的y轴刻度将不同，条形的高度将相同，这样就无法展示均值和中位数之间的差异。
- en: 'We’ve affixed the means and medians atop the bars by again calling the `geom_text()`
    function. But the values don’t *exactly* match the results in `tenth_tibble` because
    we’ve also called the base R `trunc()` function, which rounds the means and medians
    *down* to their nearest whole number, just for aesthetic reasons. The label placements
    can be adjusted vertically and/or horizontally with the `vjust` and `hjust` arguments,
    respectively; be prepared to experiment with the `vjust` and `hjust` arguments
    until you’re finally pleased with how it looks:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次调用`geom_text()`函数将平均值和中位数放置在条形图顶部。但数值并不完全匹配`tenth_tibble`中的结果，因为我们还调用了基础R的`trunc()`函数，该函数将平均值和中位数四舍五入到最近的整数，仅出于美观原因。标签的位置可以通过`vjust`和`hjust`参数在垂直和/或水平方向上调整；准备好通过实验`vjust`和`hjust`参数直到你对最终的外观满意：
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Our plots are temporarily held in memory rather than immediately printed. By
    calling the `plot_layout()` function from the `patchwork` package, our plots are
    bundled into a single graphical object in which the two bar charts are printed
    side by side (due to the fact that we passed the `ncol`, or number of columns,
    argument to equal `2`):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图表暂时保存在内存中而不是立即打印出来。通过调用`plot_layout()`函数从`patchwork`包中，我们的图表被捆绑成一个单一的可视化对象，其中两个条形图并排打印（由于我们传递了`ncol`，即列数，参数使其等于`2`）：
- en: '[PRE47]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There are two significant conclusions to draw from these two bar charts:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 从这两张条形图中可以得出两个重要的结论：
- en: Players born in the United States, on average, accrued more career win shares
    than players born elsewhere.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在美国出生的球员，平均而言，其职业生涯的胜利份额比在其他地方出生的球员更多。
- en: The means are significantly greater than the medians. Means are sensitive to
    outliers, whereas medians are not; that the means are greater than the medians
    suggests they are influenced by superstar production where win shares per superstar
    are greater than 100.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均值显著大于中位数。平均值对异常值敏感，而中位数则不敏感；平均值大于中位数表明它们受到了超级巨星生产的影响，其中超级巨星的胜利份额超过100。
- en: 'This same exercise is repeated here, except the variable `Born2` is swapped
    out for the derived variable `College2` (see figure 2.6):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重复相同的练习，只是将变量`Born2`替换为派生变量`College2`（见图2.6）：
- en: '[PRE48]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![CH02_F06_Sutton](../../OEBPS/Images/CH02_F06_Sutton.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F06_Sutton](../../OEBPS/Images/CH02_F06_Sutton.png)'
- en: Figure 2.6 Average and median win shares between those players who first attended
    a college or university and those who did not
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 那些最初就读于大学或学院和那些没有就读于大学或学院的球员的平均和中值胜利份额
- en: 'We then call the `plot_layout()` function a second time to pack our last two
    bar charts into a single graphical representation:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次调用`plot_layout()`函数，将最后两个条形图打包成一个单一的可视化表示：
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Between the two levels, or factors, in the variable `College2`, the means are
    essentially equal and the medians are essentially equal; however, the means are
    again significantly greater than the medians.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在`College2`变量的两个水平或因素之间，平均值和中位数基本上是相等的；然而，平均值再次显著大于中位数。
- en: 'Our final chunk of `dplyr` code takes the draft data set and then passes `Born2`,
    `College2`, *and* the variable `Pos2` to the `summarize()` function to then compute
    the mean and median win shares for every combination of these three variables.
    We’re doing this because we next intend to visualize mean and median win shares
    between every combination of `Born2`, `College2`, and `Pos2` in just a pair of
    complementary facet plots. The first three and last three observations of `twelfth_tibble`,
    where the results are cast, are returned by consecutive calls to the base R `head``()`
    and `tail()` functions:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的`dplyr`代码块将选秀数据集传递给`summarize()`函数，并将`Born2`、`College2`以及变量`Pos2`传递给它，以计算这三个变量的每一种组合的平均和中值胜利份额。我们这样做是因为我们接下来打算通过一对互补的面板图来可视化`Born2`、`College2`和`Pos2`每一种组合的平均和中值胜利份额。`twelfth_tibble`中结果被转换的前三个和最后三个观察值是通过连续调用基础R的`head()`和`tail()`函数得到的：
- en: '[PRE50]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Our final visualization is a pair of facet plots—once more, a facet plot is
    a type of visualization that displays two or more subsets of the data—with averages
    on the left and medians on the right, packed into one 2 × 2 object. Note that
    we’ve made a second call to the `theme()` function in order to orient our x-axis
    labels at 45 degrees in lieu of the `ggplot2` default, which, of course, orients
    the labels horizontally (see figure 2.7):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的可视化是一对面图——再次强调，面图是一种显示数据两个或更多子集的可视化类型，左边的平均值和右边的中位数被压缩到一个2×2的对象中。请注意，我们再次调用了`theme()`函数，将x轴标签旋转45度，而不是使用`ggplot2`的默认设置，后者当然是将标签水平排列（见图2.7）：
- en: '[PRE51]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '![CH02_F07_Sutton](../../OEBPS/Images/CH02_F07_Sutton.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![CH02_F07_Sutton](../../OEBPS/Images/CH02_F07_Sutton.png)'
- en: Figure 2.7 Average and median career win shares by place of birth, college or
    no college, and position
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 按出生地、是否上大学和位置的平均和中等职业生涯胜利份额
- en: 'Again, rather than printing the two facet plots separately, they are instead
    bundled into one graphical object and then printed accordingly:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们并没有分别打印两个面图，而是将它们打包成一个图形对象，然后相应地打印出来：
- en: '[PRE52]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: No doubt the most obvious and fascinating results from our pair of facet plots
    are in the upper-left panels. Bigs, Centers, and Swingmen born in the United States
    who did not attend a college or university before entering the NBA draft accrued
    significantly more win shares on average than other players at other positions
    regardless of where they were born and regardless of whether or not they first
    attended college.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，我们两个面图中最明显和最吸引人的结果出现在左上角的板块。出生于美国、在进入NBA选秀前没有上过大学的大个子、中锋和摇摆人，平均获得的胜利份额显著高于其他位置上的球员，无论他们出生在哪里，无论他们是否首先上大学。
- en: The median win shares for these same players, however, aren’t so distinct when
    compared to other players with different `Born2` and `College2` dispositions,
    again hinting at the effect just a few superstars can have.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与具有不同`Born2`和`College2`特征的球员相比，这些球员的中等胜利份额并不那么明显，这再次暗示了少数超级巨星可能产生的影响。
- en: This brings our exploration of the draft data set to a close. As you can see,
    a lot can be gleaned from a data set simply by applying standard or traditional
    exploration methods; it’s not always necessary to test or model data, whatever
    the subject matter, in order to gain valuable insights. Before moving on, we’ll
    save a copy of draft—after all the data wrangling—for chapter 3.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们对草案数据集的探索告一段落。正如您所看到的，仅通过应用标准或传统探索方法，就可以从数据集中获取大量信息；无论主题是什么，都不一定需要测试或建模数据，以便获得有价值的见解。在继续之前，我们将保存一份草案的副本——毕竟，这是在数据整理之后——用于第3章。
- en: 2.6 Writing data
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 写入数据
- en: 'One of our first operations was to call the `read_csv()` function to import
    a data set previously saved as a .csv file. Now, having finished our EDA, we want
    to generate an output file. To do that, we’ll call the base R `write.csv()` function
    to create a new .csv file. This new file will be imported at the top of chapter
    3\. Rather than importing the original draft data set again—and then repeating
    the same data wrangling operations—a copy of draft, draft2, which equals the final
    configuration of the draft data set—will be imported instead. As long as you have
    a working directory set, `write.csv()` works very much like the `read_csv()` function;
    that is, you merely need to pass the name of the file:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步操作是调用`read_csv()`函数来导入之前保存为.csv文件的数据集。现在，在完成我们的EDA之后，我们想要生成一个输出文件。为此，我们将调用基础R的`write.csv()`函数来创建一个新的.csv文件。这个新文件将在第3章的开头导入。我们不会再次导入原始的草案数据集——然后重复相同的数据整理操作——而是导入一个副本，即`draft2`，它等于草案数据集的最终配置。只要您设置了工作目录，`write.csv()`的工作方式与`read_csv()`非常相似；也就是说，您只需要传递文件名：
- en: '[PRE53]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: One of the first operations in the following chapter will be to import draft2
    for analysis above and beyond what was otherwise performed here—with implications
    that are profound and maybe even disconcerting.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将首先导入`draft2`进行分析，这超出了此处进行的分析——其影响可能是深远的，甚至可能令人不安。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned how to install and load packages, read and write data, wrangle data,
    compute basic statistics, and create visual content—and we learned about win shares
    and other NBA data in the process.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了如何安装和加载包、读取和写入数据、整理数据、计算基本统计量以及创建可视化内容——在这个过程中我们还了解了胜利份额和其他NBA数据。
- en: Most acquired data in the real world is messy, or at least not in a structure
    that works for subsequent analysis. Statisticians, data scientists, business analysts,
    and anyone working with data are therefore required to spend most of their time
    wrangling data rather than analyzing it.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现实世界中，大多数获取的数据都是杂乱的，或者至少不是适合后续分析的结构。因此，统计学家、数据科学家、商业分析师以及任何与数据打交道的人都需要花费大部分时间整理数据，而不是分析数据。
- en: As far as wrangling data is concerned, we learned how to remove variables, remove
    observations, convert variables from one class to another, create new variables,
    summarize data by groups, and even transform a data set from a wide format to
    a long one.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据整理方面，我们学习了如何删除变量、删除观测值、将变量从一类转换为另一类、创建新变量、按组汇总数据，甚至将数据集从宽格式转换为长格式。
- en: We got our first glimpse of the `ggplot2` package, which we used to create a
    histogram, paired boxplots, facet plots, a correlation heat map, and bar charts;
    we also called several `ggplot()` functions to customize our visual content and
    apply best practices.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首次了解了`ggplot2`包，我们用它创建了直方图、成对箱线图、分面图、相关热图和条形图；我们还调用了几个`ggplot()`函数来定制我们的视觉内容并应用最佳实践。
- en: We demonstrated how to go about exploring a data set in full—but with purpose
    and with focus. Exploring data by computing it and visualizing it is a valuable
    exercise that leads to interesting and actionable insights and sets the table
    for deeper analysis.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们展示了如何全面探索数据集——但要有目的性和专注力。通过计算和可视化数据来探索数据是一项有价值的练习，它能带来有趣和可操作的见解，并为更深入的分析做好准备。
- en: The methods applied here work on any data set, be they health records, sales
    figures, customer service statistics, or win shares.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里应用的方法适用于任何数据集，无论是健康记录、销售数据、客户服务统计还是胜利份额。
- en: First-round NBA draft picks between 2000 and 2009 had very different professional
    careers. While a few players accrued many win shares over the course of their
    respective careers, most players accrued fewer than 25 career win shares.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2000年至2009年的第一轮NBA选秀球员有着非常不同的职业生涯。虽然一些球员在其职业生涯中积累了大量的胜利份额，但大多数球员累积的职业生涯胜利份额不到25个。
- en: It would appear—at least based on the analysis conducted thus far—that players
    who accrued the most career win shares were picked very high in the first round,
    and lesser-skilled players were picked later in the first round. This will be
    further explored in great detail in chapter 3 through the application of more
    advanced analytical techniques.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据到目前为止进行的分析，似乎那些累积了最多职业生涯胜利份额的球员在第一轮被选中得非常高，而技能较低的球员则在第一轮的后期被选中。这一点将在第3章通过应用更先进的分析技术进行更深入的探讨。
