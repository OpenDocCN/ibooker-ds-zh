- en: 8 Deploying the model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 部署模型
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Overview of model deployment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型部署概述
- en: Deployment versus one-off scoring
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署与一次性评分的比较
- en: Why deployment is a difficult topic
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么部署是一个难题
- en: Steps for deploying your model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署模型步骤
- en: Introduction to pipelines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道简介
- en: Maintaining a model after it has been deployed
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署后的模型维护
- en: 'In chapter 6, we went through the process of iteratively training the deep
    learning model for predicting streetcar delays, and in chapter 7, we went through
    a further set of experiments to explore the behavior of the model. Now that we
    have a trained model, we are going to look at two ways to deploy the model or,
    in other words, make it possible for streetcar users to get predictions about
    whether their streetcar trips are going to be delayed. First, we’ll get an overview
    of the deployment process. Next, we’ll contrast the one-off scoring we introduced
    in chapter 6 with deployment. Then we will go through the specific steps to deploy
    the model by using two approaches: a web page and Facebook Messenger. Next, we
    will describe how to encapsulate the data preparation process by using pipelines
    and go over the details of implementing pipelines for the streetcar delay prediction
    model. We will wrap up the chapter with a review of how to maintain a model when
    it has been deployed.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章中，我们经历了迭代训练深度学习模型以预测电车延误的过程，在第7章中，我们进行了一系列实验来探索模型的行为。现在我们有一个训练好的模型，我们将探讨两种部署模型的方法，或者换句话说，使电车用户能够获得关于他们的电车行程是否会延误的预测。首先，我们将概述部署过程。接下来，我们将对比第6章中引入的一次性评分与部署。然后，我们将通过两种方法（一个网页和Facebook
    Messenger）具体说明部署模型的具体步骤。接下来，我们将描述如何使用管道封装数据准备过程，并回顾实现电车延误预测模型管道的细节。我们将以回顾如何维护已部署的模型来结束本章。
- en: NOTE In this chapter, to prevent confusion between the Keras deep learning model
    that we have trained for streetcar delay prediction and the Rasa chatbot model
    used in the second deployment approach, we will refer to the former as the Keras
    model if there is any chance of ambiguity.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本章中，为了避免混淆我们在第6章中为预测电车延误而训练的Keras深度学习模型和在第2种部署方法中使用的Rasa聊天机器人模型，如果有任何歧义，我们将把前者称为Keras模型。
- en: 8.1 Overview of model deployment
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 模型部署概述
- en: Deployment is a critical step in making a deep learning model useful. *Deployment*
    means making our trained model available to users or other applications outside
    the context of your development environment. In other words, deployment is everything
    we need to do to make our trained model useful for the outside world. Deployment
    could mean making the model available to other applications via a REST API or,
    as in our case, making it directly accessible to the users, who want to know whether
    their streetcar trips are going to be delayed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 部署是使深度学习模型变得有用的关键步骤。*部署*意味着使我们的训练模型在开发环境之外对用户或其他应用程序可用。换句话说，部署是我们需要做的所有事情，以便我们的训练模型对外界有用。部署可能意味着通过REST
    API使模型可供其他应用程序使用，或者在我们这个案例中，直接使它对希望了解他们的电车行程是否会延误的用户可用。
- en: If we revisit the end-to-end diagram from chapter 4, deployment encompasses
    the right side of figure 8.1.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾第4章的端到端图，部署涵盖了图8.1的右侧。
- en: '![CH08_F01_Ryan](../Images/CH08_F01_Ryan.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F01_Ryan](../Images/CH08_F01_Ryan.png)'
- en: Figure 8.1 The end-to-end flow from raw dataset to deployed trained model
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 从原始数据集到部署的训练模型的端到端流程
- en: 'In this chapter, we are going to deploy our trained model by using two techniques:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用两种技术来部署我们的训练模型：
- en: '*Web deployment* —This minimal deployment uses Flask ([https://flask .palletsprojects.com/en/1.1.x](https://flask.palletsprojects.com/en/1.1.x)),
    a basic web application framework for Python, to serve web pages where a user
    can specify the parameters for their trip and see the model’s prediction. This
    solution consists of a Python flask_server.py file for the Flask server and related
    code, along with two HTML files to get the scoring parameters ([home.html](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/deploy_web/templates/home.html))
    and display the result ([show-prediction.html](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/deploy_web/templates/show-prediction.html)).
    The HTML page home.html contains JavaScript functions to collect the scoring parameters
    (such as route, direction, and time). These scoring parameters are passed to the
    Python code in flask_server.py , which applies the pipelines to the scoring parameters
    and applies the trained model to the output of the pipelines. By default, Flask
    serves the web pages at localhost. In chapter 9, we describe how you can use ngrok
    ([https://ngrok.com](https://ngrok.com)) to make the web pages served at localhost
    available to users who don’t have access to your development system.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*网页部署* —— 这种最小化部署使用Flask ([https://flask.palletsprojects.com/en/1.1.x](https://flask.palletsprojects.com/en/1.1.x))，这是一个基本的Python网页应用框架，用于提供网页，用户可以指定他们的行程参数并查看模型的预测。此解决方案包括用于Flask服务器的Python
    flask_server.py文件和相关代码，以及两个HTML文件以获取评分参数（如路线、方向和时间）并显示结果（[home.html](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/deploy_web/templates/home.html)和[show-prediction.html](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/deploy_web/templates/show-prediction.html)）。HTML页面home.html包含JavaScript函数以收集评分参数（如路线、方向和时间）。这些评分参数传递给flask_server.py中的Python代码，该代码将管道应用于评分参数，并将训练好的模型应用于管道的输出。默认情况下，Flask在本地主机上提供网页。在第9章中，我们将描述如何使用ngrok
    ([https://ngrok.com](https://ngrok.com))使本地主机上提供的网页可供无法访问您的开发系统的用户使用。'
- en: '*Facebook Messenger deployment* —The web deployment is simple, but the user
    experience is not ideal. To provide a better user experience, we are also going
    to deploy our model with a Rasa chatbot that is exposed in Facebook Messenger.
    To deploy our model, we will incorporate the trained model that we completed in
    chapter 6 and integrate it into the Python layer of Rasa, along with pipelines
    to prepare new data points to have predictions made on them by the model. The
    user will enter their requests to determine whether a particular streetcar trip
    will be delayed via Facebook Messenger. Our Rasa chatbot will parse these requests
    and pass on the trip information (route, direction, and date/time) to [Python
    code that is associated with the Rasa chatbot](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/deploy/actions.py).
    This Python code (the scoring code) will apply the pipelines to the trip information,
    apply the trained Keras model to the output of the pipelines, and compose a response
    based on the prediction made by the trained Keras model. Finally, this response
    will come back to the user in Facebook Messenger.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Facebook Messenger部署* —— 网页部署很简单，但用户体验并不理想。为了提供更好的用户体验，我们还将使用在Facebook Messenger中公开的Rasa聊天机器人来部署我们的模型。为了部署我们的模型，我们将结合在第6章中完成的训练模型，并将其集成到Rasa的Python层中，同时整合管道以准备新的数据点，以便模型进行预测。用户将通过Facebook
    Messenger输入他们的请求，以确定特定的电车行程是否会延误。我们的Rasa聊天机器人将解析这些请求，并将行程信息（路线、方向和日期/时间）传递给[与Rasa聊天机器人关联的Python代码](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/deploy/actions.py)。此Python代码（评分代码）将管道应用于行程信息，将训练好的Keras模型应用于管道的输出，并根据训练好的Keras模型的预测结果编写响应。最后，这个响应将通过Facebook
    Messenger返回给用户。'
- en: 8.2 If deployment is so important, why is it so hard?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 如果部署如此重要，为什么它如此困难？
- en: Deployment is the difference between a model that’s an experiment and a model
    that can provide benefit. Unfortunately, deployment tends to be glossed over in
    introductory material about deep learning, and even professional cloud providers
    have not yet been able to make deployment simple. Why is this the case?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 部署是实验模型和能够提供益处的模型之间的区别。遗憾的是，在关于深度学习的入门材料中，部署往往被忽略，甚至专业的云服务提供商也还没有能够使部署变得简单。为什么情况会是这样？
- en: Deployment is hard because it involves a variety of technical topics that go
    way beyond the deep learning stack that we have covered in this book so far. To
    deploy a model in an industrial-strength production environment, you have to work
    with a broad technology stack that could include a cloud platform like Azure or
    AWS, Docker and Kubernetes for containerization and orchestration, REST APIs to
    provide a callable interface for your trained model, and web infrastructure to
    provide a frontend for your model. This stack is complex and technically demanding.
    To do even a minimal, dead-simple web deployment (as described in sections 8.5
    and 8.6), you need to work with a web server, HTML, and JavaScript, all of which
    are additional to everything you’ve learned so far about machine learning in general
    and deep learning in particular.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 部署之所以困难，是因为它涉及各种技术主题，这些主题远远超出了我们在本书中迄今为止所涵盖的深度学习堆栈。要在工业级的生产环境中部署一个模型，您必须与一个广泛的技术堆栈合作，这可能包括Azure或AWS这样的云平台，Docker和Kubernetes进行容器化和编排，REST
    API为您的训练模型提供一个可调用的接口，以及Web基础设施为您的模型提供一个前端。这个堆栈复杂且技术要求高。要进行甚至是最基本的、简单的Web部署（如第8.5节和第8.6节所述），您需要与Web服务器、HTML和JavaScript合作，所有这些都超出了您迄今为止关于机器学习（特别是深度学习）所学的所有内容。
- en: 'In this chapter, we present two contrasting deployment approaches: web deployment
    and Facebook Manager deployment. Web deployment is relatively easy, but the user
    experience is not ideally suited to the problem of predicting delays for streetcar
    trips. Real users of the model are not likely to want to go to a separate website
    to find out whether their streetcars are going to be delayed. But they might very
    well be happy to have a brief chat in Facebook Messenger to get the same information.
    Both deployment options are free and use an open-source stack (with the exception
    of Facebook Messenger itself). Both deployment options also allow you to exercise
    deployment completely from your own local system while at the same time providing
    access to other people with whom you want to share the model results.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了两种对比的部署方法：网站部署和Facebook Manager部署。网站部署相对容易，但用户体验并不理想地适合预测电车行程延误的问题。模型的真实用户不太可能想要去一个单独的网站来查看他们的电车是否会延误。但他们可能会非常乐意在Facebook
    Messenger中简短地聊天来获取相同的信息。这两种部署选项都是免费的，并使用开源堆栈（除了Facebook Messenger本身）。这两种部署选项还允许您完全从自己的本地系统进行部署，同时为其他人提供访问权限，以便与他们共享模型结果。
- en: 8.3 Review of one-off scoring
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 一次性评分回顾
- en: In chapter 6, you learned how to take a new data record and apply the trained
    model to it to get a prediction. We call this quick way of exercising the trained
    model *one-off* *scoring*. You can exercise the Python file [one_off_scoring.py](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/deploy/one_off_scoring.py)
    to see an example of how you can prepare a single data point manually and use
    the trained model to get a prediction (also called a score) for this data point.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章中，您学习了如何将新的数据记录应用于训练模型以获得预测。我们称这种快速执行训练模型的方法为“一次性评分”。您可以通过练习Python文件[one_off_scoring.py](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/deploy/one_off_scoring.py)来查看如何手动准备单个数据点并使用训练模型为该数据点获得预测（也称为评分）的示例。
- en: To understand what full deployment means, let’s contrast one-off scoring with
    full deployment. Figure 8.2 summarizes one-off scoring.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解全面部署的含义，让我们对比一下一次性评分与全面部署。图8.2总结了一次性评分。
- en: '![CH08_F02_Ryan](../Images/CH08_F02_Ryan.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F02_Ryan](../Images/CH08_F02_Ryan.png)'
- en: Figure 8.2 Summary of one-off scoring in a Python session
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 Python会话中一次性评分的总结
- en: 'You do one-off scoring in the context of a Python session, and you need to
    manually prepare the data point that you want to score. Instead of dealing directly
    with the values that you want to score—such as `route = 501` , `direction = westbound`
    , and `time = 1:00 pm today` —you need to have a data point that has already been
    through all the data transformations, such as assigning an integer value to replace
    `501` as the route value. Further, you have to assemble the data point into the
    structure that the model expects: a list of numpy arrays. When you have prepared
    a data point in the required format and applied the trained model to get a prediction
    for it, you can display the prediction in the Python session. As you can see,
    one-off scoring is suitable for doing a quick sanity test of the trained model,
    but because one-off scoring is done in a Python session and requires manual preparation
    of the input data, it’s not a suitable way to test your model at scale or make
    it available to an end user.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你在Python会话的上下文中进行一次性评分，并且你需要手动准备你想要评分的数据点。而不是直接处理你想要评分的值——例如`route = 501`、`direction
    = westbound`和`time = 1:00 pm today`——你需要一个已经通过所有数据转换的数据点，例如将整数值分配给替换`501`作为路线值。此外，你必须将数据点组装成模型期望的结构：一个numpy数组的列表。当你已经以所需的格式准备了一个数据点并应用了训练好的模型来获取其预测时，你可以在Python会话中显示预测结果。正如你所看到的，一次性评分适合对训练好的模型进行快速合理性测试，但由于一次性评分是在Python会话中进行的，并且需要手动准备输入数据，因此它不是在规模上测试你的模型或使其可供最终用户使用的方法。
- en: 8.4 The user experience with web deployment
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 使用Web部署的用户体验
- en: For the streetcar delay prediction problem, we need a simple way for the user
    to specify what trip they want to get a delay prediction for, along with an easy
    way to show the model’s prediction. Web deployment is the easiest way to achieve
    this goal.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于电车延误预测问题，我们需要一种简单的方法让用户指定他们想要获取延误预测的行程，以及一种简单的方法来展示模型的预测。Web部署是实现这一目标的最简单方式。
- en: 'In section 8.5, we will get into the details of setting up web deployment for
    your trained deep learning model, but first, let’s review what the user experience
    will be with the completed web deployment (as shown in figure 8.3):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8.5节中，我们将详细介绍为您的训练有素的深度学习模型设置Web部署的细节，但首先，让我们回顾一下完成Web部署后的用户体验（如图8.3所示）：
- en: 'The user goes to `home.html` (served by Flask at `localhost:5000`) and selects
    the details of the trip they want a prediction for: route, direction, year, month,
    day of month, day of the week, and hour.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户访问`home.html`（由Flask在`localhost:5000`上提供）并选择他们想要预测的行程的详细信息：路线、方向、年份、月份、月份中的某一天、星期中的某一天和小时。
- en: The user clicks the Get Prediction button.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户点击“获取预测”按钮。
- en: The prediction is displayed in show-prediction.html.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预测结果在`show-prediction.html`中显示。
- en: The user can click Get Another Prediction to return to `home.html` and enter
    details about another trip.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户可以点击“获取另一个预测”返回到`home.html`并输入关于另一个行程的详细信息。
- en: '![CH08_F03_Ryan](../Images/CH08_F03_Ryan.png)'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![CH08_F03_Ryan](../Images/CH08_F03_Ryan.png)'
- en: Figure 8.3 The user experience with web deployment
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.3 使用Web部署的用户体验
- en: 8.5 Steps to deploy your model with web deployment
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 使用Web部署部署您的模型步骤
- en: In section 8.4, we went through the user experience with the web-deployed model.
    This section leads you through the steps to set up local web deployment of your
    trained model.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8.4节中，我们探讨了Web部署模型的用户体验。本节将引导你通过设置本地Web部署的训练有素模型的步骤。
- en: As noted in section 8.4, web deployment depends on Flask to serve the web pages
    and associated code for the deployment. An end-to-end description of Flask is
    beyond the scope of this book, but if you want to get more background on this
    easy-to-use Python web application framework, the tutorial at [http://mng.bz/oRPy](http://mng.bz/oRPy)
    provides an excellent overview.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如第8.4节所述，Web部署依赖于Flask来提供部署所需的网页和相关代码。本书不涉及Flask的端到端描述，但如果你想要了解更多关于这个易于使用的Python网络应用程序框架的背景信息，[http://mng.bz/oRPy](http://mng.bz/oRPy)上的教程提供了一个优秀的概述。
- en: Flask is not your only choice for web serving in Python. Django ([https://www
    .djangoproject.com](https://www.djangoproject.com)) is another Python web application
    framework that trades the simplicity of Flask for a richer function set. See [http://mng.bz/nzPV](http://mng.bz/nzPV)
    for a good comparison of Flask and Django. For the purposes of the streetcar delay
    prediction project, I chose Flask because we don’t need a sophisticated web application
    to deploy the model and because Flask is easier to get started with.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Flask不是Python中网络服务的唯一选择。Django（[https://www.djangoproject.com](https://www.djangoproject.com)）是另一个Python网络应用程序框架，它以Flask的简单性换取了更丰富的功能集。有关Flask和Django的良好比较，请参阅[http://mng.bz/nzPV](http://mng.bz/nzPV)。对于电车延误预测项目，我选择了Flask，因为我们不需要复杂的网络应用程序来部署模型，而且Flask更容易上手。
- en: When you have cloned the GitHub repo ([http://mng.bz/v95x](http://mng.bz/v95x))
    associated with this book, you will see the directory structure in the following
    listing.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你克隆了与本书相关的GitHub repo ([http://mng.bz/v95x](http://mng.bz/v95x))后，你将看到以下列表中的目录结构。
- en: Listing 8.1 Code in the repo related to deployment
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1与部署相关的代码
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The files related to web deployment, shown next, are in the deploy_web subdirectory
    .
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例中显示的与网络部署相关的文件位于deploy_web子目录中。
- en: Listing 8.2 Code in the repo related to web deployment
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.2与网络部署相关的代码
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Contains definitions of pipeline classes
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含管道类定义
- en: '❷ Config file for web deployment: pipeline filenames, model filename, and debug
    settings'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 网络部署配置文件：管道文件名、模型文件名和调试设置
- en: ❸ Main Python file for the Flask server and for applying the pipelines and trained
    model to the user’s input parameters about their streetcar trip
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Flask服务器的主Python文件，以及将管道和训练模型应用于用户关于他们的电车之旅的输入参数
- en: ❹ CSS file for display characteristics of HTML files
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 用于显示HTML文件显示特性的CSS文件
- en: ❺ Alternate CSS file (used to force updates during development)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 交替CSS文件（用于开发期间强制更新）
- en: ❻ HTML file for entering scoring parameters
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 用于输入评分参数的HTML文件
- en: ❼ HTML file for displaying scoring results
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 用于显示评分结果的HTML文件
- en: 'With the files in place, here are the steps to take to get the web deployment
    working:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件就绪后，以下是使网络部署工作所需的步骤：
- en: Go to the deploy_web subdirectory in your local instance of the repo.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往本地实例的repo中的deploy_web子目录。
- en: Edit the deploy_web_config.yml config file to specify which trained model and
    pipeline files you want to use for the deployment. If you are using model and
    pipeline files that you created yourself by following the instructions in chapter
    6, ensure that you are using pipeline and model files that come from the same
    run, as shown in the next listing.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑deploy_web_config.yml配置文件以指定你想要用于部署的训练模型和管道文件。如果你是按照第6章中的说明自己创建的模型和管道文件，请确保你使用的是来自同一运行的管道和模型文件，如下一个列表所示。
- en: Listing 8.3 Parameters to set in the web config file for web deployment
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表8.3网络部署配置文件中要设置的参数
- en: '[PRE2]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Replace the values for the parameter pipeline1_filename and pipeline2_filename
    parameters with the filenames of the pipeline files you want to use—pickle files
    in the pipelines subdirectory that is a sibling of the deploy_web subdirectory.
    For the pipeline files and the model file only, specify the filename; the rest
    of the path will be generated in flask_server.py.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❶ 将参数pipeline1_filename和pipeline2_filename的值替换为你想要使用的管道文件名——位于deploy_web子目录的兄弟目录pipelines子目录中的pickle文件。对于管道文件和模型文件，只需指定文件名；其余路径将由flask_server.py生成。
- en: ❷ Replace the value for the model_filename parameter with the name of the file
    where you saved the trained model that you want to use—an h5 file in the models
    subdirectory.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❷ 将model_filename参数的值替换为你保存想要使用的训练模型的文件名——位于models子目录中的h5文件。
- en: 'If you have not already done so, enter this command to install Flask:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，请输入以下命令来安装Flask：
- en: '[PRE3]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Enter this command to start the Flask server and related code:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令以启动Flask服务器和相关代码：
- en: '[PRE4]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Enter this URL in a browser to load home.html:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中输入此URL以加载home.html：
- en: '[PRE5]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If everything has worked, you see home.html, as shown in figure 8.4.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切正常，你会看到home.html，如图8.4所示。
- en: '![CH08_F04_Ryan](../Images/CH08_F04_Ryan.png)'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![CH08_F04_Ryan](../Images/CH08_F04_Ryan.png)'
- en: Figure 8.4 home.html displayed when you load localhost:5000 in your browser
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.4在浏览器中加载localhost:5000时显示的home.html
- en: Do a sanity test. Set scoring parameters by selecting values for route, direction,
    and the time/date parameters and then clicking Get Prediction. This click kicks
    off processing (loading the pipelines, loading the trained model, and running
    the scoring parameters through the pipelines and the trained model) that may take
    some time, so please be patient if it takes a few seconds for this step to complete.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行一次合理性测试。通过选择路线、方向和时间/日期参数的值来设置评分参数，然后点击获取预测。此点击将启动可能需要一些时间的处理（加载管道、加载训练模型以及将评分参数通过管道和训练模型运行）。因此，如果这一步需要几秒钟才能完成，请耐心等待。
- en: If your web deployment was successful, you see show-prediction.html with the
    prediction for your trip, as shown in figure 8.5.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的Web部署成功，您将看到显示预测结果的`show-prediction.html`页面，如图8.5所示。
- en: '![CH08_F05_Ryan](../Images/CH08_F05_Ryan.png)'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![CH08_F05_Ryan](../Images/CH08_F05_Ryan.png)'
- en: Figure 8.5 Successful sanity test of web deployment
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.5 Web部署成功的合理性测试
- en: If you want to try another set of scoring parameters, click Get Another Prediction
    to get back to home.html, where you can enter scoring parameters for a new trip.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想尝试另一组评分参数，请点击获取另一个预测以返回`home.html`，在那里您可以输入新旅行的评分参数。
- en: 'That’s it. If you’ve reached this point, you have done a successful web deployment
    of a trained deep learning model. As you can see, even this simple deployment
    required a set of technology that we have not previously needed to use in this
    book, including Flask, HTML, and JavaScript. As you will see in section 8.8, to
    get a smoother user experience by deploying the model in Facebook Messenger, we
    will need an even bigger set of components. This requirement for a set of technical
    components illustrates the point made in section 8.2: deploying a deep learning
    model is not easy because deployment currently takes a stack of technology that
    is distinct from the technology we use to prepare the dataset and train the model.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。如果您已经达到这个阶段，您已经成功部署了一个训练好的深度学习模型。如您所见，即使这个简单的部署也要求我们使用一组之前在这本书中没有使用过的技术，包括Flask、HTML和JavaScript。正如您将在第8.8节中看到的那样，为了通过在Facebook
    Messenger中部署模型来获得更流畅的用户体验，我们需要一个更大的组件集。这种对技术组件集的需求说明了第8.2节中提出的问题：部署深度学习模型并不容易，因为当前的部署需要一套与准备数据集和训练模型所使用的技术截然不同的技术栈。
- en: If you want to share your deployment with others, you can use ngrok to make
    localhost on your local system available to users outside your local system, as
    described in chapter 9\. Note that if you use the free version of ngrok, you will
    only be able to have one ngrok server running at a time, so you won’t be able
    to run the web deployment and the Facebook Messenger deployment simultaneously.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想与他人分享您的部署，可以使用ngrok将本地系统上的localhost对本地系统外的用户开放，如第9章所述。请注意，如果您使用ngrok的免费版本，您一次只能运行一个ngrok服务器，因此您无法同时运行Web部署和Facebook
    Messenger部署。
- en: 8.6 Behind the scenes with web deployment
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 Web部署背后的场景
- en: Let’s take a closer look at what’s happening behind the scenes with web deployment.
    Figure 8.6 shows the flow through the stack, from the user entering the details
    about their intended streetcar trip in home.html to the user getting a response
    in show-prediction.html. See the following list for more details on the numbered
    steps in figure 8.6.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看Web部署背后的情况。图8.6显示了从用户在`home.html`中输入他们计划乘坐的电车旅行的详细信息到用户在`show-prediction.html`中获得响应的流程。以下列表提供了图8.6中编号步骤的更多详细信息。
- en: '![CH08_F06_Ryan](../Images/CH08_F06_Ryan.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F06_Ryan](../Images/CH08_F06_Ryan.png)'
- en: Figure 8.6 The round trip from query to answer with web deployment
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 Web部署中从查询到答案的往返流程
- en: In the home.html web page served by Flask at localhost:5000, the user selects
    the details about their streetcar trip by choosing them from drop-down lists for
    route, direction, and time/date; then the user clicks the Get Prediction button.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在由Flask在localhost:5000上提供的`home.html`网页中，用户通过从路线、方向和时间/日期的下拉列表中选择详细信息来选择他们的电车旅行；然后用户点击获取预测按钮。
- en: The JavaScript function `getOption` `()` in home.html extracts the scoring parameters
    that the user selected in the drop-down lists and builds a URL that includes these
    scoring parameters. The JavaScript function `link_with_args` `()` sets the link
    associated with the Get Prediction button to include the URL that is built in
    `getOption()` , as the next listing shows.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: home.html中的JavaScript函数`getOption` `()` 提取用户在下拉列表中选择的评分参数，并构建包含这些评分参数的URL。JavaScript函数`link_with_args`
    `()` 将与获取预测按钮关联的链接设置为包含在`getOption()`中构建的URL，如下一列表所示。
- en: Listing 8.4 Code for JavaScript function getOption()
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表8.4 JavaScript函数getOption()的代码
- en: '[PRE6]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Create querySelector objects for each scoring parameter.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❶ 为每个评分参数创建querySelector对象。
- en: ❷ Load the values for each scoring parameter into a JS variable.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❷ 将每个评分参数的值加载到JS变量中。
- en: ❸ Set the prefix for the target URL.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❸ 设置目标URL的前缀。
- en: ❹ Add arguments for each scoring parameter value to the target URL.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❹ 将每个评分参数值作为参数添加到目标URL中。
- en: '❺ Call getOption() to build the target URL. The target URL will look like this:
    /show-prediction/?route=501&direction=e&year=2019&month=1&daym=1&day=6&hour=5.'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❺ 调用getOption()构建目标URL。目标URL将类似于这样：/show-prediction/?route=501&direction=e&year=2019&month=1&daym=1&day=6&hour=5。
- en: ❻ Set the target URL as the target of the link associated with the Get Prediction
    button.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❻ 将目标URL设置为与获取预测按钮关联的链接的目标。
- en: flask_server.py includes view functions ([http://mng.bz/v9xm](http://mng.bz/v9xm))—functions
    in Flask modules that handle different routes/URLs—for each of the HTML files
    that make up the deployment. The view function for show-prediction contains the
    scoring code in the next listing.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: flask_server.py包括视图函数([http://mng.bz/v9xm](http://mng.bz/v9xm))——处理组成部署的HTML文件的Flask模块中的不同路由/URLs的函数——为每个HTML文件。show-prediction视图函数包含下一列表中的评分代码。
- en: Listing 8.5 Code for the view function for show-prediction
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表8.5 用于show-prediction视图函数的代码
- en: '[PRE7]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ View function for home.html; this is the function that gets executed when
    the user navigates to localhost:5000.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❶ home.html的视图函数；这是当用户导航到localhost:5000时执行的功能。
- en: ❷ The view function for home.html renders the web page.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❷ home.html的视图函数渲染网页。
- en: ❸ View function for show-prediction.html; this is the function that gets executed
    when the user clicks the Get Prediction link in home.html.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❸ show-prediction.html的视图函数；这是当用户在home.html中点击获取预测链接时执行的功能。
- en: ❹ Load the arguments from the URL—the scoring parameters loaded by the link_with_args()
    JavaScript function in home.html—into a Python dictionary.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❹ 将从URL中加载的参数（由home.html中的link_with_args() JavaScript函数加载的评分参数）加载到Python字典中。
- en: ❺ Load the trained model. Note that model_path is built earlier in flask _server.py,
    using values loaded from the config file deploy_web_config.yml.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❺ 加载训练好的模型。注意，model_path在flask _server.py中之前已构建，使用从部署配置文件deploy_web_config.yml中加载的值。
- en: ❻ Load the pipeline objects.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❻ 加载管道对象。
- en: ❼ Create a dataframe to contain the scoring parameters.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❼ 创建一个包含评分参数的数据框。
- en: ❽ Load the scoring parameters into the dataframe.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❽ 将评分参数加载到数据框中。
- en: ❾ Apply the pipelines to the scoring parameters dataframe.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❾ 将管道应用于评分参数数据框。
- en: ❿ Apply the trained model to the output of the pipelines to get a prediction.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❿ 将训练好的模型应用于管道的输出以获得预测。
- en: ⓫ Convert the prediction to a string.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ⓫ 将预测转换为字符串。
- en: ⓬ Create a dictionary for the output prediction string.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ⓬ 创建一个用于输出预测字符串的字典。
- en: ⓭ Render show-prediction.html with the prediction string as an argument.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ⓭ 使用预测字符串作为参数渲染show-prediction.html。
- en: Flask serves show-prediction.html, showing the prediction string generated by
    the view function for show-prediction.html in flask_server.py.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Flask提供show-prediction.html，显示由flask_server.py中的show-prediction.html视图函数生成的预测字符串。
- en: This section provided some details on what is happening behind the scenes when
    you exercise the web deployment. The point of this web deployment was to illustrate
    a simple yet complete deployment. You can probably see (particularly if you are
    an experienced web developer) opportunities for improving the web deployment.
    It would be nice to have the prediction displayed in home.html rather than on
    a separate page, for example. It would also be good to provide a single button
    in home.html to let the user specify that they want to take the trip now. To keep
    the deployment as basic as possible, I erred on the side of simplicity in this
    web deployment. Sections 8.7-8.10 describe a more elegant deployment that is,
    in my opinion, much better suited to the streetcar delay prediction problem. Nevertheless,
    the web deployment described here provides a simple structure that you can adapt
    (with a few modifications to the HTML and JavaScript) for basic deployment of
    other machine learning models.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了一些关于当你使用Web部署时幕后发生的事情的细节。这个Web部署的目的是展示一个简单但完整的部署。你可能已经看到了（尤其是如果你是一个经验丰富的Web开发者）改进Web部署的机会。例如，将预测显示在home.html而不是单独的页面上会很好。同样，提供一个按钮在home.html中让用户指定他们现在想要出行也是一个很好的主意。为了使部署尽可能简单，我在这个Web部署中选择了简单的一侧。第8.7-8.10节描述了一个更优雅的部署，在我看来，它更适合街车延误预测问题。尽管如此，这里描述的Web部署提供了一个简单的结构，你可以通过一些对HTML和JavaScript的修改来适应其他机器学习模型的基本部署。
- en: 8.7 The user experience with Facebook Messenger deployment
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7 Facebook Messenger部署的用户体验
- en: 'The user experience with web deployment is simple, but it has some serious
    limitations:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Web部署的用户体验很简单，但它有一些严重的限制：
- en: The user has to go to a specific website.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户必须访问一个特定的网站。
- en: They have to enter all the information about their trip. Nothing is assumed.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们必须输入他们旅行的所有信息。没有任何假设。
- en: The entry of the trip parameters and the prediction appear on separate web pages.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旅行参数的输入和预测出现在不同的网页上。
- en: 'We could address all these issues in the web deployment directly by spending
    more time refining it, but there is a better way to improve the user’s experience:
    deployment in Facebook Messenger. Figure 8.7 shows how simple it is for the user
    to get a prediction on their trip in the Facebook Messenger deployment.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过花费更多时间来细化它，直接在Web部署中解决所有这些问题，但有一种更好的方法来提升用户体验：在Facebook Messenger中进行部署。图8.7展示了在Facebook
    Messenger部署中用户获取旅行预测是多么简单。
- en: '![CH08_F07_Ryan](../Images/CH08_F07_Ryan.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F07_Ryan](../Images/CH08_F07_Ryan.png)'
- en: Figure 8.7 New data points scored with the deployed model
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 使用部署的模型得到的新数据点
- en: Contrast the user’s scoring experience with Facebook Messenger deployment with
    their experience with web deployment. Using the model deployed with Facebook Messenger,
    the user has only to enter an English sentence in Facebook Messenger to get back
    a prediction. The user can provide minimal information and still get a prediction.
    Best of all, the user enters the request and gets back the prediction in Facebook
    Messenger, a natural environment for this kind of lightweight interaction.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户在Facebook Messenger部署中的评分体验与他们在Web部署中的体验进行对比。使用通过Facebook Messenger部署的模型，用户只需在Facebook
    Messenger中输入一个英文句子，就能得到预测。用户可以提供最少的信息，仍然可以得到预测。最好的是，用户在Facebook Messenger中输入请求并得到预测，这是这种轻量级交互的自然环境。
- en: Another benefit of deploying the model via Facebook Messenger with Rasa is flexibility.
    In figure 8.8, pairs of queries are labeled with numbers from 1 to 4\. Consider
    the pairs of queries that are tagged with the same number. Each query in these
    pairs has the same meaning, and the Rasa model is capable of detecting this despite
    the phrasing differences between each member of the pairs. The Rasa model gets
    part of this capability from the examples in [nlu.md](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/deploy/data/nlu.md)
    (single-utterance examples) and [stories.md](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/deploy/data/stories.md)
    (multi-utterance examples) that the Rasa model was trained with. These two sets
    of training examples give Rasa its ability to parse the aspects of language specific
    to streetcar trips.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Facebook Messenger 和 Rasa 部署模型的好处之一是灵活性。在图 8.8 中，查询对被标记为 1 到 4 的数字。考虑带有相同数字的查询对。这些对中的每个查询都有相同的意思，而
    Rasa 模型能够检测到这一点，尽管这些对中的每个成员的措辞有所不同。Rasa 模型从 Rasa 模型训练中使用的例子中获得了部分这种能力，这些例子包括 [nlu.md](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/deploy/data/nlu.md)（单句示例）和
    [stories.md](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/deploy/data/stories.md)（多句示例）。这两组训练示例赋予了
    Rasa 解析特定于电车行程的语言方面的能力。
- en: '![CH08_F08_Ryan](../Images/CH08_F08_Ryan.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F08_Ryan](../Images/CH08_F08_Ryan.png)'
- en: Figure 8.8 The Rasa model correctly assesses pairs of queries as being identical.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 Rasa 模型正确评估查询对为相同。
- en: 'A big part of the capability of chatbots written with Rasa comes from exploiting
    Rasa’s default natural language processing (NLP) capability. It’s worth mentioning
    that Rasa’s NLP capability is based on deep learning. So deep learning drives
    two parts of the end-to-end solution (including the Facebook Messenger deployment
    described in this chapter), as shown in figure 8.9:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Rasa 编写的聊天机器人的能力很大一部分来自于利用 Rasa 的默认自然语言处理（NLP）能力。值得一提的是，Rasa 的 NLP 能力基于深度学习。因此，深度学习推动了端到端解决方案的两个部分（包括本章中描述的
    Facebook Messenger 部署），如图 8.9 所示：
- en: The streetcar delay prediction deep learning model we have been creating throughout
    this book
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在这本书中一直在创建的电车延误预测深度学习模型
- en: The deep learning that underlies the NLP that we get by using Rasa as part of
    the deployment of the streetcar delay model
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过将 Rasa 作为电车延误模型部署的一部分来获取的 NLP 深度学习
- en: '![CH08_F09_Ryan](../Images/CH08_F09_Ryan.png)'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![CH08_F09_Ryan](../Images/CH08_F09_Ryan.png)'
- en: Figure 8.9 Deep learning drives two parts of the end-to-end solution with Facebook
    Messenger deployment.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.9 深度学习驱动 Facebook Messenger 部署的端到端解决方案的两个部分。
- en: 8.8 Behind the scenes with Facebook Messenger deployment
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.8 Facebook Messenger 部署背后的场景
- en: 'What is happening behind the scenes when a user enters a question about a streetcar
    trip in Facebook Messenger? Figure 8.10 shows the flow through the stack from
    the query entered by the user to the response displayed in Facebook Messenger.
    See the following list for more details on the numbered steps in figure 8.10:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在 Facebook Messenger 中输入有关电车行程的问题时，幕后发生了什么？图 8.10 显示了从用户输入的查询到在 Facebook
    Messenger 中显示的响应的流程。以下列表提供了图 8.10 中编号步骤的更多详细信息：
- en: When the user enters a query in English in Facebook Messenger, the query is
    caught by a simple Rasa chatbot.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户在 Facebook Messenger 中用英语输入查询时，该查询会被一个简单的 Rasa 聊天机器人捕获。
- en: 'Rasa applies an NLP model to the query to get the key values (called *slots*
    ) that specify details about the trip for which the user wants a prediction: the
    route name or number, the direction, and the time.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rasa 将一个 NLP 模型应用于查询以获取用户想要预测的行程的关键值（称为 *槽位*），这些值指定了关于行程的详细信息：路线名称或编号、方向和时间。
- en: Rasa passes these slot values to a custom action class (part of the scoring
    code in [actions.py](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/deploy/actions.py))
    written in Python. The code in that class parses the slot values and sets default
    values for any slots that are empty. In particular, if the user doesn’t specify
    any time information in their query, the custom action sets the day of the week,
    month, and year to equal the current date and time.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rasa 将这些槽位值传递给一个自定义动作类（[actions.py](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/deploy/actions.py)
    中评分代码的一部分），该类是用 Python 编写的。该类中的代码解析槽位值，并为任何空槽位设置默认值。特别是，如果用户在他们的查询中没有指定任何时间信息，自定义动作将星期几、月份和年份设置为当前日期和时间。
- en: The custom action prepares the trip details, using the same pipelines that were
    used to prepare the training data. (See sections 8.11-8.13 for more background
    on pipelines.) Then the custom action scores the prepared trip details by invoking
    the trained deep learning model on them.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义操作准备行程细节，使用与准备训练数据相同的管道。（有关管道的更多背景信息，请参阅第8.11-8.13节。）然后，自定义操作通过在准备好的行程细节上调用训练好的深度学习模型来对这些细节进行评分。
- en: Finally, the custom action composes a response that is sent back to the user
    in Facebook Messenger.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，自定义操作在Facebook Messenger中向用户发送一个响应。
- en: '![CH08_F10_Ryan](../Images/CH08_F10_Ryan.png)'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![CH08_F10_Ryan](../Images/CH08_F10_Ryan.png)'
- en: Figure 8.10 The round trip from query to answer with Facebook Messenger deployment
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.10 使用Facebook Messenger部署的从查询到答案的往返过程
- en: 8.9 More background on Rasa
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.9 关于Rasa的更多背景信息
- en: A complete review of the Rasa chatbot framework is beyond the scope of this
    book. Further, the repo contains all the updated Rasa files that you need for
    the model deployment. When you have followed the steps in section 8.10, you should
    not need to update any of the Rasa-related files. But if you want some more details
    about how Rasa works, this section provides some additional background on the
    essential concepts in Rasa, along with some pointers to more detailed information.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对Rasa聊天机器人框架的全面审查超出了本书的范围。此外，仓库包含您为模型部署所需的全部更新后的Rasa文件。当您按照第8.10节中的步骤操作后，您不应需要更新任何与Rasa相关的文件。但如果您想了解更多关于Rasa如何工作的细节，本节提供了关于Rasa基本概念的额外背景信息，以及一些指向更详细信息的方法。
- en: Rasa is an open-source chatbot development framework that lets you create and
    train chatbots with natural language interfaces. It provides a simple set of interfaces
    that let you take advantage of its built-in NLP without having to deal with the
    details of training an NLP model. Rasa connects with Python to let you code sophisticated
    actions in response to user input. It also supports connections to a variety of
    messaging platforms, including Facebook Messenger. In sum, the Rasa framework
    gives us everything we need for a simple deployment, from interpretation of natural
    language to a connection to Python to an end-user interface with Facebook Messenger.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Rasa是一个开源的聊天机器人开发框架，允许您使用自然语言界面创建和训练聊天机器人。它提供了一套简单的接口，让您可以利用其内置的NLP，而无需处理训练NLP模型的细节。Rasa与Python连接，让您能够编写复杂的动作以响应用户输入。它还支持连接到各种消息平台，包括Facebook
    Messenger。总之，Rasa框架为我们提供了从自然语言解释到Python连接再到Facebook Messenger的最终用户界面的所有简单部署所需的一切。
- en: 'The Rasa interface is built around a series of chatbot concepts:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Rasa界面是围绕一系列聊天机器人概念构建的：
- en: '*Intent* —The objective of the user input, such as getting a prediction.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*意图* —用户输入的目标，例如获取预测。'
- en: '*Action* —An action that can be performed by the chatbot system. A simple action
    could be a canned text response (such as returning `hello` in response to a greeting).
    In the case of our deep learning model deployment, we define an action as the
    class `ActionPredictDelayComplete` in Python in the actions.py file. This action
    takes the slot values extracted by Rasa from the user input, fills in values not
    specified by the slots, runs the values through the pipelines, applies the output
    of the pipelines to the trained model, and finally composes a response to the
    user based on the trained model’s prediction.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*动作* —聊天机器人系统可以执行的动作。一个简单的动作可能是一个预先准备好的文本响应（例如在问候时返回`hello`）。在我们的深度学习模型部署中，我们将动作定义为Python中的`actions.py`文件中的`ActionPredictDelayComplete`类。此动作接受Rasa从用户输入中提取的槽位值，填写未由槽位指定的值，将值通过管道运行，将管道的输出应用于训练好的模型，并最终根据训练模型的预测为用户编写响应。'
- en: '*Slot* —A set of keys and values that captures essential input from the user.
    In the case of our deep learning model deployment, slots are defined for all the
    input columns that the model is expecting (route, direction, hour, month, and
    so on).'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*槽位* —一组键和值，用于捕获用户的基本输入。在我们的深度学习模型部署中，为模型期望的所有输入列（路线、方向、小时、月份等）定义了槽位。'
- en: '*Story* —An abstraction of a conversation between a user and the chatbot that
    can represent multiple back-and-forth exchanges. The main story in our deep learning
    model deployment is a simple exchange: the user asks whether a trip is going to
    be delayed, and the bot provides a response to indicate delay or no delay.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*故事* —用户与聊天机器人之间对话的抽象，可以表示多次来回交流。在我们深度学习模型部署中的主要故事是一个简单的交流：用户询问一次旅行是否会延误，机器人提供响应以指示延误或无延误。'
- en: Figure 8.11 shows the key files used to train a Rasa model along with the Rasa
    objects defined in each file. When you train a Rasa model (as you will do in section
    8.10), Rasa uses the training data in the nlu.md and stories.md files to train
    the model.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 显示了用于训练 Rasa 模型的关键文件以及每个文件中定义的 Rasa 对象。当您训练 Rasa 模型（您将在第 8.10 节中这样做）时，Rasa
    使用 nlu.md 和 stories.md 文件中的训练数据来训练模型。
- en: '![CH08_F11_Ryan](../Images/CH08_F11_Ryan.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F11_Ryan](../Images/CH08_F11_Ryan.png)'
- en: Figure 8.11 The key Rasa files and objects defined in them
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 定义在 Rasa 中的关键文件和对象
- en: The other key file in the Rasa framework is actions.py, the file that contains
    the Python custom actions. If Facebook Messenger is the pretty face of the deployment
    and Rasa’s NLP capability is its lovely voice, actions.py is the brains of the
    deployment. Let’s take a closer look at the code in actions.py that gets the slot
    values that Rasa sets.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Rasa 框架中的另一个关键文件是 actions.py，该文件包含 Python 自定义操作。如果 Facebook Messenger 是部署的漂亮面孔，Rasa
    的 NLP 能力是其可爱的声音，那么 actions.py 就是部署的大脑。让我们更详细地看看 actions.py 中的代码，该代码获取 Rasa 设置的槽位值。
- en: The connection between Rasa and actions.py is the tracker structure in the custom
    class in actions.py. The `tracker.get_slot()` method lets you get the values of
    slots set by Rasa, or `None` if Rasa did not set a value for a slot. This loop
    in actions.py iterates through the slot values passed from Rasa and loads the
    scoring dataframe column that corresponds with the slot value or with the default
    if the slot value is not set, as shown in the next listing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Rasa 与 actions.py 之间的连接是 actions.py 中自定义类中的跟踪器结构。`tracker.get_slot()` 方法允许您获取
    Rasa 设置的槽位值，或者如果 Rasa 没有设置槽位值，则为 `None`。actions.py 中的此循环遍历从 Rasa 传递的槽位值，并加载与槽位值相对应的评分数据框列，如果没有设置槽位值，则使用默认值，如下一列表所示。
- en: Listing 8.6 Code to load slot values from Rasa into a dataframe
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 从 Rasa 加载槽位值到数据框的代码
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ If the slot is set, use its value.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果设置了槽位，则使用其值。
- en: ❷ If the date is set by Rasa to today, use the default value, which is the current
    date.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果日期由 Rasa 设置为今天，则使用默认值，即当前日期。
- en: ❸ Otherwise, for the dataframe that will be scored, set the value to be equal
    to the slot value from Rasa.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 否则，对于将要评分的数据框，将值设置为等于 Rasa 的槽位值。
- en: ❹ If Rasa did not set the value (such as for date and time), use the default,
    which is the current time/date.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果 Rasa 没有设置值（例如日期和时间），则使用默认值，即当前时间/日期。
- en: This section provided a brief overview of some of the key concepts in Rasa.
    For more details, you can get an overview of Rasa and its architecture at [https://rasa.com](https://rasa.com/).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本节简要概述了 Rasa 的一些关键概念。有关更多详细信息，您可以在 [https://rasa.com](https://rasa.com/) 上了解
    Rasa 及其架构。
- en: 8.10 Steps to deploy your model in Facebook Messenger with Rasa
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.10 使用 Rasa 在 Facebook Messenger 中部署您的模型的步骤
- en: This section describes the steps to deploy your model using Facebook Messenger.
    When you have completed these steps, you will have a deployed deep learning model
    that you can query from Facebook Messenger.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了使用 Facebook Messenger 部署您的模型的步骤。完成这些步骤后，您将拥有一个部署的深度学习模型，您可以从 Facebook Messenger
    中查询它。
- en: When you have cloned the GitHub repo ([http://mng.bz/v95x](http://mng.bz/v95x))
    associated with this book, you’ll find the files associated with Facebook Messenger
    deployment in the deploy subdirectory, as shown next.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当您克隆与本书相关的 GitHub 仓库 ([http://mng.bz/v95x](http://mng.bz/v95x)) 时，您将在 deploy
    子目录中找到与 Facebook Messenger 部署相关的文件，如下所示。
- en: Listing 8.7 Code in the repo related to Facebook Messenger deployment
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.7 与 Facebook Messenger 部署相关的代码
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ File containing custom actions for the Rasa model
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 包含 Rasa 模型自定义操作的文件
- en: ❷ Rasa config file
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Rasa 配置文件
- en: ❸ Rasa credentials file
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Rasa 凭证文件
- en: ❹ Contains definitions of pipeline classes
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 包含管道类的定义
- en: '❺ Config file for actions.py: pipeline filenames, model filename, and debug
    settings'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ actions.py 的配置文件：管道文件名、模型文件名和调试设置
- en: '❻ Rasa domain file: specifies intents, slots, and actions'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ Rasa 领域文件：指定意图、槽位和操作
- en: '❼ Rasa endpoints file: Specifies the URL of the endpoint for custom actions.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ Rasa 端点文件：指定自定义操作的端点 URL。
- en: '❽ Rasa nlu.md file: Single-utterance training data for the Rasa model'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ Rasa nlu.md 文件：Rasa 模型的单轮对话训练数据
- en: '❾ Rasa stories.md file: Multi-utterance level training data for the Rasa model'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ Rasa stories.md 文件：Rasa 模型的多轮对话训练数据
- en: ❿ Directory containing Rasa models
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 包含 Rasa 模型的目录
- en: 'In steps 1 to 4, you will complete the basic setup by installing Python (if
    you don’t already have it installed on your local system) and the Rasa open source
    chatbot environment:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 1 到 4 中，您将通过安装 Python（如果您尚未在本地系统上安装它）和 Rasa 开源聊天机器人环境来完成基本设置：
- en: If you don’t already have Python 3.7 installed in your local system, install
    it ([https://www.python.org/downloads](https://www.python.org/downloads)).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您本地系统上尚未安装 Python 3.7，请安装它 ([https://www.python.org/downloads](https://www.python.org/downloads))。
- en: NOTE There is an issue with the TensorFlow dependency with Rasa in Python 3.8,
    so ensure that you are in Python 3.7 to avoid problems in the Rasa installation
    step. Also note that Rasa has incompatibilities with TensorFlow 2, so the Python
    environment that you use for the Facebook Messenger deployment needs to be separate
    from the Python environment that you use for training the Keras mode.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：Python 3.8 中 TensorFlow 依赖项与 Rasa 存在问题，因此请确保您使用的是 Python 3.7，以避免在 Rasa 安装步骤中出现问题。另外请注意，Rasa
    与 TensorFlow 2 不兼容，因此您用于 Facebook Messenger 部署的 Python 环境需要与您用于训练 Keras 模型的 Python
    环境分开。
- en: 'Install the open-source chatbot framework Rasa ([https://rasa.com/docs/rasa/
    user-guide/installation](https://rasa.com/docs/rasa/user-guide/installation)):'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装开源聊天机器人框架 Rasa ([https://rasa.com/docs/rasa/user-guide/installation](https://rasa.com/docs/rasa/user-guide/installation))：
- en: '[PRE10]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you are in Windows, and the Rasa install fails with a message indicating
    that you need C++, you can download and install Visual C++ Build Tools ([http://mng.bz/4BA5](http://mng.bz/4BA5)).
    When you have installed the build tools, rerun the Rasa install:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在 Windows 上，并且 Rasa 安装失败，显示需要 C++ 的消息，您可以下载并安装 Visual C++ Build Tools ([http://mng.bz/4BA5](http://mng.bz/4BA5))。安装构建工具后，重新运行
    Rasa 安装：
- en: Go to the deploy directory in your clone of the repo.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往您克隆的仓库中的部署目录。
- en: 'Run the following command in the deploy directory to set up a basic Rasa environment:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在部署目录中运行以下命令以设置基本的 Rasa 环境：
- en: '[PRE11]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the following command in your deploy directory to invoke actions.py in
    the Python environment for Rasa. If you get any messages about missing libraries,
    run `pip install` to add missing libraries:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的部署目录中运行以下命令以在 Rasa 的 Python 环境中调用 actions.py。如果您收到任何关于缺少库的消息，请运行 `pip install`
    以添加缺少的库：
- en: '[PRE12]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In steps 6 to 13, you will set up ngrok (used to connect the deployment environment
    on your local system with Facebook Messenger) and set up the Facebook app and
    Facebook page that you need to connect your deployment environment with Facebook
    Messenger:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在步骤 6 到 13 中，您将设置 ngrok（用于连接本地系统上的部署环境与 Facebook Messenger）并设置您需要连接到 Facebook
    Messenger 的 Facebook 应用和 Facebook 页面：
- en: Install ngrok ([https://ngrok.com/download](https://ngrok.com/download)).
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 ngrok ([https://ngrok.com/download](https://ngrok.com/download))。
- en: 'In the directory where you installed ngrok, invoke ngrok to make your localhost
    available to Facebook Messenger on port 5005\. Here is the command for Windows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您安装 ngrok 的目录中，调用 ngrok 使您的本地主机在端口 5005 上可供 Facebook Messenger 使用。以下是 Windows
    的命令：
- en: '[PRE13]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Make a note of the https forwarding URL in the ngrok output, as shown in figure
    8.12; you will need that URL to complete step 13.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记下 ngrok 输出的 https 转发 URL，如图 8.12 所示；您将需要该 URL 来完成步骤 13。
- en: '![CH08_F12_Ryan](../Images/CH08_F12_Ryan.png)'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![CH08_F12_Ryan](../Images/CH08_F12_Ryan.png)'
- en: Figure 8.12 Output of invoking ngrok
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.12 调用 ngrok 的输出
- en: 'Run the following command in the deploy directory to train the Rasa model:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在部署目录中运行以下命令以训练 Rasa 模型：
- en: '[PRE14]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Follow the instructions at [http://mng.bz/Qxy1](http://mng.bz/Qxy1) to add a
    new Facebook app. Make note of the page access token and app secret; you will
    need to update the credentials.yml file with these values in step 11.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下说明 [http://mng.bz/Qxy1](http://mng.bz/Qxy1) 添加新的 Facebook 应用。记下页面访问令牌和应用程序密钥；您需要在步骤
    11 中使用这些值更新 credentials.yml 文件。
- en: 'Update the credentials.yml file in the deploy directory to set the verify token
    (a string value you choose) and secret and page-access-token (provided during
    the Facebook app setup you did in step 10):'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新部署目录中的 credentials.yml 文件，以设置验证令牌（您选择的字符串值）和密钥以及页面访问令牌（在步骤 10 中您设置的 Facebook
    应用设置期间提供）：
- en: '[PRE15]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run the following command in the deploy directory to start the Rasa server,
    using the credentials you set in credentials.yml in step 11:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在部署目录中运行以下命令以启动 Rasa 服务器，使用您在步骤 11 中设置的 credentials.yml 中的凭据：
- en: '[PRE16]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the Facebook app you created in step 10, choose Messenger -> Settings, scroll
    down to the Webhooks section, and click Edit Callback URL. Replace the initial
    part of the Callback URL value with the https forwarding URL that you noted when
    you invoked ngrok in step 7\. Enter the verify token that you set in credentials.yml
    in step 11 in the Verify Token field, and click Verify and Save, as shown in figure
    8.13.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第 10 步中创建的 Facebook 应用中，选择 Messenger -> 设置，滚动到 Webhooks 部分，并点击编辑回调 URL。将回调
    URL 值的初始部分替换为你在第 7 步调用 ngrok 时记录的 https 转发 URL。在验证令牌字段中输入你在第 11 步设置的 credentials.yml
    中的验证令牌，然后点击验证并保存，如图 8.13 所示。
- en: '![CH08_F13_Ryan](../Images/CH08_F13_Ryan.png)'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![CH08_F13_Ryan](../Images/CH08_F13_Ryan.png)'
- en: Figure 8.13 Setting the webhook callback URL for Facebook Messenger
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.13 设置 Facebook Messenger 的 webhook 回调 URL
- en: 'Finally, in steps 14 and 15, validate your deployment in Facebook Messenger:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在第 14 步和第 15 步中，验证你在 Facebook Messenger 中的部署：
- en: 'In Facebook Messenger (mobile or web application), search for the ID of the
    Facebook page you created in step 10, and send the following message to that ID:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Facebook Messenger（移动或网页应用）中，搜索你在第 10 步中创建的 Facebook 页面的 ID，并向该 ID 发送以下消息：
- en: '[PRE17]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If your deployment was successful, you will see a response like the one shown
    being served from my local system in figure 8.14\. Don’t worry about whether the
    prediction is for a delay; only confirm that you get a response.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的部署成功，你将看到如图 8.14 所示的响应，这是从我本地系统提供的。不用担心预测是否为延迟；只需确认你收到了响应。
- en: '![CH08_F14_Ryan](../Images/CH08_F14_Ryan.png)'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![CH08_F14_Ryan](../Images/CH08_F14_Ryan.png)'
- en: Figure 8.14 Successful sanity test of model deployment with Facebook Messenger
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.14 使用 Facebook Messenger 成功进行模型部署的合理性测试
- en: 8.11 Introduction to pipelines
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.11 管道简介
- en: 'Now that we have gone through the process of deploying the model, we need to
    review an essential part of the process that makes it possible to prepare user
    input so that it’s ready for the model to generate a prediction on it: pipelines.
    By using pipelines, we can apply exactly the same preparation steps (such as assigning
    numeric identifiers to values in categorical columns) to the streetcar trip details
    entered by users that we applied to the training data when we were training the
    Keras model.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了模型的部署过程，我们需要回顾一个重要的过程部分，它使得准备用户输入以便模型能够对其生成预测成为可能：管道。通过使用管道，我们可以将完全相同的准备步骤（例如，将分类列中的值分配给数值标识符）应用于用户输入的电车行程详情，这些步骤与我们训练
    Keras 模型时应用于训练数据时相同。
- en: Let’s look at how the user expects to enter requests for delay predictions on
    streetcar trips in the Facebook Messenger deployment and compare it with what
    the trained model expects to get as input for predictions. Figure 8.15 illustrates
    the gap between the user request and what the model expects as input.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看用户在 Facebook Messenger 部署中期望如何输入对电车行程延迟预测的请求，并将其与训练模型期望作为预测输入的内容进行比较。图
    8.15 展示了用户请求与模型期望输入之间的差距。
- en: '![CH08_F15_Ryan](../Images/CH08_F15_Ryan.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F15_Ryan](../Images/CH08_F15_Ryan.png)'
- en: Figure 8.15 How to get from user input to what the model expects
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.15 如何从用户输入转换为模型期望的格式
- en: We need to have a way to conveniently prepare data that the user provides for
    new predictions in the format that the trained model expects. As we saw in section
    8.6, Rasa gets us part of the way by extracting the essential information from
    the user’s request and extrapolating missing information, as shown in figure 8.16.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要有一种方便的方式来准备用户提供的用于新预测的数据，使其符合训练模型期望的格式。正如我们在第 8.6 节中看到的，Rasa 通过从用户的请求中提取必要信息并推断缺失信息，帮助我们走了一半的路，如图
    8.16 所示。
- en: '![CH08_F16_Ryan](../Images/CH08_F16_Ryan.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F16_Ryan](../Images/CH08_F16_Ryan.png)'
- en: Figure 8.16 How to get from Rasa output to what the model expects
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 如何从 Rasa 输出转换为模型期望的格式
- en: How do we convert the data point that Rasa extracts from the user input to what
    the model expects? In particular, how do we convert categorical values such as
    route, month, and day of the week to the integer identifiers that the model expects?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将 Rasa 从用户输入中提取的数据点转换为模型期望的格式？特别是，我们如何将诸如路线、月份和星期几这样的分类值转换为模型期望的整数标识符？
- en: One approach would be to have functions in the training code that encode categorical
    values available to the scoring code. In the scoring code, we could invoke these
    same functions to encode the categorical values (such as route and direction)
    in new data points to which we want to apply the model. The problem is how to
    ensure that the same mappings are used for new data as we used on the dataset
    during training. If “2019” was mapped to “5” in the training process, for example,
    how do we ensure that the identical mapping happens for “2019” in the scoring
    process? We could pickle the encoder objects we used during the training process,
    and unpickle and apply these same encoders when we are using the trained model
    to score new data, but this process would be cumbersome and error-prone. What
    we need is a convenient way to encapsulate the data preparation process that we
    used to prepare the training data so that we can apply the same process to new
    data points that will be scored by the trained model. A proven way to accomplish
    this goal is to use the pipeline facility ([http://mng.bz/X0Pl](https://shortener.manning.com/X0Pl))
    provided by scikit-learn.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是在训练代码中包含函数，这些函数将评分代码可用的分类值编码。在评分代码中，我们可以调用这些相同的函数来对新数据点（我们希望应用模型的数据点）中的分类值（如路线和方向）进行编码。问题是如何确保在评分过程中使用与我们在训练数据集期间使用的相同映射。例如，如果“2019”在训练过程中被映射为“5”，那么我们如何确保在评分过程中“2019”发生相同的映射？我们可以将训练过程中使用的编码器对象进行pickle，然后在使用训练模型评分新数据时解pickle并应用这些相同的编码器，但这个过程会繁琐且容易出错。我们需要的是一个方便的方式来封装我们用来准备训练数据的数据准备过程，以便我们可以将相同的流程应用于将被训练模型评分的新数据点。实现这一目标的有效方法之一是使用scikit-learn提供的管道功能([http://mng.bz/X0Pl](https://shortener.manning.com/X0Pl))。
- en: The pipeline facility in scikit-learn makes it possible to encapsulate all the
    data transformations (plus the model itself, if you wish) in an object that you
    can train as one piece. When you have trained a pipeline, you can apply it when
    you score new data points; the pipeline handles all the data transformations on
    the new data point and then applies the model to get a result.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: scikit-learn中的管道功能使得将所有数据转换（以及如果您愿意，还包括模型本身）封装在一个对象中成为可能，您可以将其作为一个整体进行训练。当您训练了一个管道后，您可以在评分新数据点时应用它；管道会处理新数据点上的所有数据转换，然后应用模型以获得结果。
- en: The pipeline facility in scikit-learn was designed to be applied with the classic
    machine learning algorithms included in scikit-learn, including support vector
    machines, logistic regression, and random forest. It is possible to create a scikit-learn
    pipeline that incorporates a Keras deep learning model, but I have not been able
    to create such a pipeline successfully with a multi-input Keras model such as
    the streetcar delay prediction model. For this reason, when we apply scikit-learn
    pipelines in this book, they cover only the data preparation steps and do not
    encapsulate the model itself.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: scikit-learn中的管道功能是为了与scikit-learn中包含的经典机器学习算法一起使用而设计的，包括支持向量机、逻辑回归和随机森林。虽然可以创建一个包含Keras深度学习模型的scikit-learn管道，但我还没有能够成功地创建一个多输入Keras模型（如电车延误预测模型）的此类管道。因此，当我们在这本书中应用scikit-learn管道时，它们仅涵盖数据准备步骤，并不封装模型本身。
- en: Further, to get around issues with dividing the dataset into train, validate,
    and test after applying the final data preparation step (converting the dataset
    from a Pandas dataframe to a dictionary of numpy arrays), we use two pipelines
    chained together. The first pipeline encodes categorical values (and deals with
    any remaining missing values), and the second pipeline converts the dataset from
    a Pandas dataframe to the dictionary of numpy arrays that the model expects. See
    section 8.12 for the key code elements that make up these two pipelines.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了解决在应用最终数据准备步骤（将数据集从Pandas dataframe转换为numpy数组字典）后将数据集分为训练、验证和测试时的问题，我们使用两个管道串联。第一个管道编码分类值（并处理任何剩余的缺失值），第二个管道将数据集从Pandas
    dataframe转换为模型期望的numpy数组字典。请参阅第8.12节，了解构成这两个管道的关键代码元素。
- en: Figure 8.17 shows how new data points to be scored by the trained model get
    entered by the user, interpreted by Rasa, and then processed by the pipelines
    so that they are in the correct format for the trained Keras model to make a prediction
    on.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17显示了用户如何输入将被训练模型评分的新数据点，Rasa如何解释这些数据点，然后通过管道处理，以便它们以正确的格式供训练的Keras模型进行预测。
- en: '![CH08_F17_Ryan](../Images/CH08_F17_Ryan.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F17_Ryan](../Images/CH08_F17_Ryan.png)'
- en: Figure 8.17 The complete flow from user input to what the model expects
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.17 从用户输入到模型期望的完整流程
- en: The pipelines that are applied to new data points entered by the user before
    the trained model is applied to the new data points are identical to the pipelines
    that are applied to the dataset before training the model, as shown in figure
    8.18.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在将训练模型应用于新数据点之前，应用于用户输入的新数据点的管道与在训练模型之前应用于数据集的管道相同，如图 8.18 所示。
- en: '![CH08_F18_Ryan](../Images/CH08_F18_Ryan.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F18_Ryan](../Images/CH08_F18_Ryan.png)'
- en: Figure 8.18 Training data flows through the same pipeline as data that is being
    scored
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18 训练数据通过与评分数据相同的管道
- en: In this section, we introduced the idea of pipelines and showed at a high level
    where they fit in the training and deployment processes. In the next section,
    we will dig into the code that defines the pipelines.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了管道的概念，并从高层次上展示了它们在训练和部署过程中的位置。在下一节中，我们将深入研究定义管道的代码。
- en: 8.12 Defining pipelines in the model training phase
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.12 模型训练阶段定义管道
- en: Now that we have looked at the overall purpose of the pipelines, let’s go through
    the details of the code that implements the pipelines used in the streetcar delay
    prediction project. In this section, we will review how the pipelines get defined
    in the streetcar_ model_training notebook. In section 8.13, we’ll review the details
    of how the pipelines are applied to new data points in the scoring process as
    part of model deployment.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了管道的整体目的，让我们来看看实现街道延误预测项目中使用的管道的代码细节。在本节中，我们将回顾如何在 streetcar_model_training
    笔记本中定义管道。在第 8.13 节中，我们将回顾管道在模型部署过程中的评分过程中应用于新数据点的细节。
- en: 'The pipeline facility in scikit-learn comes with a set of transformation classes
    that you can use off the shelf, or you can create your own custom transformers
    by creating new classes as children of the core pipeline classes. For the streetcar
    delay prediction project, we created custom transformers by deriving new Python
    classes from the classes provided by scikit-learn. You can find the definitions
    for these classes in [custom_ classes.py](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/notebooks/custom_classes.py)
    :'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: scikit-learn 中的管道功能附带了一组可现成使用的转换类，或者您可以通过创建新的类作为核心管道类的子类来创建自己的自定义转换器。对于街道延误预测项目，我们通过从
    scikit-learn 提供的类中派生新的 Python 类来创建自定义转换器。您可以在 [custom_classes.py](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/notebooks/custom_classes.py)
    中找到这些类的定义：
- en: '`encode_categorical` —Encode categorical columns like route, direction, and
    year.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encode_categorical` — 对类别列（如路线、方向和年份）进行编码。'
- en: '`prep_for_keras_input` —Transform the dataset from a Pandas dataframe to the
    format expected by the Keras model: a dictionary of numpy arrays.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prep_for_keras_input` — 将数据集从 Pandas 数据框转换为 Keras 模型期望的格式：一个 numpy 数组的字典。'
- en: '`fill_empty` —Replace empty values with placeholder values.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill_empty` — 用占位符值替换空值。'
- en: '`encode_text` —Encode text columns (not used for the streetcar delay project).'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encode_text` — 对文本列进行编码（未用于街道延误项目）。'
- en: 'You might wonder why these class definitions are in a separate file from the
    rest of the code. There are two reasons:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道为什么这些类定义与代码的其他部分分开在一个单独的文件中。有两个原因：
- en: These classes are needed by the streetcar_model_training notebook, which contains
    the code for training the model, and by actions.py , which contains the scoring
    code for the Facebook Messenger deployment. Because both Python programs need
    access to the same class definitions, it makes sense to put the class definitions
    in a separate file that both can import.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些类需要由包含训练模型代码的 streetcar_model_training 笔记本和包含 Facebook Messenger 部署评分代码的 actions.py
    使用。由于这两个 Python 程序都需要访问相同的类定义，因此将类定义放在一个单独的文件中，这两个程序都可以导入，是有意义的。
- en: The class definitions do not resolve correctly if they are included directly
    in the scoring code file. Putting the class definitions in a separate file allows
    them to resolve correctly when the classes are imported into the scoring code
    [actions.py](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/deploy/actions.py).
    The import statements are
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果直接将类定义包含在评分代码文件中，类定义将无法正确解析。将类定义放在单独的文件中允许它们在将类导入评分代码 [actions.py](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/deploy/actions.py)
    时正确解析。导入语句如下：
- en: '[PRE18]'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s look at how the pipeline is defined in the training phase in the streetcar_model_
    training notebook. First, we create instantiations of three of the classes defined
    in [custom_classes.py](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/notebooks/custom_classes.py):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在 streetcar_model_training 笔记本中训练阶段如何定义管道。首先，我们创建 [custom_classes.py](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/notebooks/custom_classes.py)
    中定义的三个类的实例：
- en: '[PRE19]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Two things to note:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两点需要注意：
- en: If this is your first exposure to the object-oriented aspects of Python, don’t
    worry. You can think of the preceding definitions as creating three objects, each
    of which has a type equal to the corresponding class. The classes inherit data
    structures and functions from their parent classes, so with these objects, you
    can apply both the functions that are explicitly defined in their class as well
    as the functions that they inherit from their parent classes, `BaseEstimator`
    and `TransformerMixin`.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这是你第一次接触 Python 的面向对象方面，不要担心。你可以将前面的定义视为创建三个对象，每个对象都具有与其对应的类相同的类型。这些类从其父类继承数据结构和函数，因此，使用这些对象，你可以应用它们在类中明确定义的函数以及它们从父类
    `BaseEstimator` 和 `TransformerMixin` 继承的函数。
- en: Because there are no text columns in the dataset, we are not creating an object
    of the `encode_text` class.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于数据集中没有文本列，我们没有创建 `encode_text` 类的对象。
- en: 'Next, we define two pipeline objects, using the class instantiations that we
    created. The first pipeline incorporates the classes for filling empty values
    and encoding categorical columns. The second pipeline incorporates the class that
    converts the dataset from a Pandas dataframe to a list of numpy arrays:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义两个管道对象，使用我们创建的类实例。第一个管道包含了用于填充空值和编码分类列的类。第二个管道包含了将数据集从 Pandas 数据框转换为
    numpy 数组列表的类：
- en: '[PRE20]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we set the parameters for the class instantiations in the pipeline:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为管道中的类实例设置参数：
- en: '[PRE21]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These statements set the parameters defined in the `set_params` functions in
    each class. The syntax is the class name followed by two underscores, followed
    by the parameter name and then the value being assigned to the parameter. In figure
    8.19, the top box shows the `set_params` statement with the `col_list` parameter
    of the `encode_categorical` class highlighted. The bottom box shows where the
    `col_list` parameter is specified in the `encode_categorical` class definition.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句设置了在各个类中定义的 `set_params` 函数中定义的参数。语法是类名后跟两个下划线，然后是参数名和分配给参数的值。在图 8.19 中，顶部框显示了带有
    `encode_categorical` 类的 `col_list` 参数的 `set_params` 语句。底部框显示了在 `encode_categorical`
    类定义中指定 `col_list` 参数的位置。
- en: '![CH08_F19_Ryan](../Images/CH08_F19_Ryan.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F19_Ryan](../Images/CH08_F19_Ryan.png)'
- en: Figure 8.19 The set_param statement sets values for parameters defined in the
    pipeline classes.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.19 set_param 语句为管道类中定义的参数设置值。
- en: 'Now that the parameters have been set, let’s look at how we apply the first
    pipeline to encode categorical columns. The first statement in the following code
    fits the pipeline and transforms the input dataframe, and the second statement
    saves the fitted pipeline so it can be used when it is time to score new data
    points:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在参数已经设置好了，让我们看看如何应用第一个管道来编码分类列。以下代码中的第一行将管道拟合并转换输入的数据框，第二行将拟合的管道保存起来，以便在需要评分新数据点时使用：
- en: '[PRE22]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `fit_transform` statement invokes the following methods from the `encode
    _categorical` customer transformer class, as shown in the next listing.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`fit_transform` 语句调用了 `encode_categorical` 客户端转换器类中的以下方法，如下一列表所示。'
- en: Listing 8.8 Code invoked by the fit_transform statement
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 由 fit_transform 语句调用的代码
- en: '[PRE23]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ In the fit method of the class, the encoder is instantiated.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在类的 fit 方法中，编码器被实例化。
- en: ❷ In the transform method of the class, the encoder that was instantiated in
    the fit method is applied.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在类的 transform 方法中，fit 方法中实例化的编码器被应用。
- en: Now that we have reviewed the code that defines the pipelines, it’s worth digging
    deeper to determine what *fitting* means in the context of a pipeline. In this
    context, *fitting* means that any portions of the pipeline that need to be trained
    are trained with the input data. For the portion of the pipeline that encodes
    categorical values, training the pipeline means setting the correspondence between
    input values in the categorical columns and the integer identifiers that will
    replace them. To return to the example from section 8.11, if “2019” is mapped
    to “5” when the model is trained, for new data items that are scored in deployment,
    “2019” is also mapped to “5.” This is exactly what we want, and we have it thanks
    to pipelines.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了定义管道的代码，深入探讨一下在管道的上下文中，“拟合”意味着什么。在这种情况下，“拟合”意味着需要训练的管道部分使用输入数据进行训练。对于编码分类值的管道部分，训练管道意味着设置分类列中的输入值与将替换它们的整数标识符之间的对应关系。回到第
    8.11 节的例子，如果模型训练时将“2019”映射到“5”，则在部署时评分的新数据项中，“2019”也将映射到“5”。这正是我们想要的，也是由于管道的存在而实现的。
- en: 8.13 Applying pipelines in the scoring phase
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.13 评分阶段应用管道
- en: In section 8.12, we went through the details of how the pipelines were defined,
    trained, and saved in the model training phase. In this section, we’ll go through
    how these pipelines are applied in the scoring phase with the deployed Keras model.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8.12 节中，我们详细介绍了管道在模型训练阶段是如何定义、训练和保存的。在本节中，我们将介绍如何使用部署的 Keras 模型将这些管道应用于评分阶段。
- en: The scoring code in [actions.py](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/deploy/actions.py)
    (for Facebook Messenger deployment) or flask_server.py (for web deployment) imports
    the custom transformer classes from custom_classes.py and loads the trained pipelines
    that were saved in the streetcar_ model_training notebook. Figure 8.20 summarizes
    how the pipeline elements are related among these three files.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 评分代码位于 [actions.py](https://github.com/ryanmark1867/deep_learning_for_structured_data/blob/master/deploy/actions.py)（用于
    Facebook Messenger 部署）或 flask_server.py（用于 Web 部署）中，它从 custom_classes.py 中导入自定义转换器类，并加载在
    streetcar_model_training 笔记本中保存的训练好的管道。图 8.20 总结了这三个文件中管道元素之间的关系。
- en: 'Let’s review the pipeline-related portions of the scoring code. The statements
    shown here are the same for the web deployment and the Facebook Messenger deployment.
    First, the scoring code imports the custom transformer class definitions with
    code that’s identical to the code in the model training code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下评分代码中与管道相关的部分。这里显示的语句对于 Web 部署和 Facebook Messenger 部署是相同的。首先，评分代码使用与模型训练代码中相同的代码导入自定义转换器类定义：
- en: '[PRE24]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The definition for the custom action in the scoring code includes the following
    statements to load the trained pipelines that were saved in the model training
    phase:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 评分代码中自定义动作的定义包括以下语句，用于加载在模型训练阶段保存的训练好的管道：
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![CH08_F20_Ryan](../Images/CH08_F20_Ryan.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F20_Ryan](../Images/CH08_F20_Ryan.png)'
- en: Figure 8.20 Relationships among the files containing pipeline code
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.20 包含管道代码的文件之间的关系
- en: 'The scoring code loads the data points for the streetcar trip that we want
    to get a delay prediction for into the Pandas dataframe `score_df` . In the following
    statements, the pipelines are applied to this dataframe:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 得分代码将我们想要获取延误预测的街车行程的数据点加载到 Pandas 数据框 `score_df` 中。在以下语句中，将这些管道应用于此数据框：
- en: '[PRE26]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now the output of these pipelines can be applied to the trained model to get
    a prediction about whether the streetcar trip is going to be delayed:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以将这些管道的输出应用于训练好的模型，以预测街车行程是否会延误：
- en: '[PRE27]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have now been through how pipelines are used in the streetcar delay project,
    from the definition of the pipelines in the model training phase to the application
    of pipelines to new data points in the scoring phase with a deployed model. Pipelines
    are powerful tools that make deployment more straightforward by encapsulating
    the data transformation steps used in the training process so that they can be
    used conveniently in the scoring process. In the streetcar delay prediction project,
    we train pipelines for data preparation in the model training phase and then use
    the same pipelines to prepare new input data points in the scoring phase for both
    web deployment and Facebook Messenger deployment.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了在电车延误项目中如何使用管道，从模型训练阶段的管道定义到部署模型在评分阶段对新数据点的应用。管道是强大的工具，通过封装训练过程中使用的用于数据转换的步骤，使得它们可以在评分过程中方便地使用。在电车延误预测项目中，我们在模型训练阶段训练用于数据准备的管道，然后在评分阶段使用相同的管道准备新的输入数据点，用于Web部署和Facebook
    Messenger部署。
- en: 8.14 Maintaining a model after deployment
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.14 部署后维护模型
- en: Deployment is not the end of the road for a trained model. In a full-blown deployment
    of a deep learning model, it is essential to monitor the model in production to
    ensure that its performance does not get worse over time. If the performance does
    get worse (a phenomenon called *model drift* or *concept drift* ), it is necessary
    to retrain the model on fresh data. Figure 8.21 summarizes the cycle of model
    maintenance. When a model has been trained and deployed, its performance needs
    to be assessed. If necessary, the model needs to be retrained with data that includes
    more recent data points. Then the retrained model needs to be deployed.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 部署并不是训练好的模型的终点。在深度学习模型的全面部署中，监控生产中的模型以确保其性能不会随着时间的推移而变差是至关重要的。如果性能确实变差（称为*模型漂移*或*概念漂移*的现象），则有必要在新鲜数据上重新训练模型。图8.21总结了模型维护的周期。当模型经过训练和部署后，需要评估其性能。如果需要，需要使用包括更多近期数据点的数据重新训练模型。然后，需要部署重新训练后的模型。
- en: '![CH08_F21_Ryan](../Images/CH08_F21_Ryan.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F21_Ryan](../Images/CH08_F21_Ryan.png)'
- en: Figure 8.21 Model maintenance cycle
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 模型维护周期
- en: A thorough description of maintaining a deep learning model in an industrial-strength
    deployment is beyond the scope of this book. (You can find some good advice at
    [http://mng.bz/yry7](http://mng.bz/yry7) and [http://mng.bz/ModE](http://mng.bz/ModE)
    , and a great overview that includes deployment options at [http://mng.bz/awRx](http://mng.bz/awRx).)
    But we can look at an example of what happens if the model maintenance cycle is
    not followed after a model is deployed. Consider the credit card fraud detection
    example from chapter 1\. One of the signals that a credit card fraud prediction
    model could pick up is two transactions happening on the same day with the same
    card in physical retail locations that are impossible to travel between in a day.
    It is currently impossible to get commercial flights to take you between Quebec
    City and Singapore in less than 24 hours, for example, so if the same card is
    used in one day to pay for a meal at a high-end restaurant in Quebec City and
    to pay for a diamond ring at a jewelry store in Singapore, something is wrong.
    But what happens if an airline starts to offer direct flights between Quebec City
    and Singapore so it becomes possible to be in both cities in the same day? What
    if a more drastic change occurs, such as supersonic passenger air travel making
    a comeback in the early 2030s? Such a change would disrupt any fraud detection
    model that relied on the signal of same-day purchases in distant cities. The data
    that feeds machine learning models often comes from the real world, and the real
    world keeps changing in unpredictable ways. We need to expect that our models
    will need to be retrained regularly on fresh data.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在工业级部署中维护深度学习模型的详细描述超出了本书的范围。（你可以在[http://mng.bz/yry7](http://mng.bz/yry7) 和
    [http://mng.bz/ModE](http://mng.bz/ModE) 找到一些好的建议，以及一个包括部署选项的概述，见 [http://mng.bz/awRx](http://mng.bz/awRx)。）但我们可以看看在模型部署后不遵循模型维护周期会发生什么。以第1章中的信用卡欺诈检测为例。信用卡欺诈预测模型可能捕捉到的信号之一是同一天在物理零售地点使用同一张卡进行的两次交易，而这些地点在一天内不可能往返。例如，目前不可能在24小时内乘坐商业航班从魁北克城飞往新加坡，所以如果同一天在同一张卡在魁北克城的高端餐厅支付餐费和在新加坡的珠宝店支付钻石戒指，那就说明有问题。但如果航空公司开始提供魁北克城和新加坡之间的直飞航班，使得在同一天内可以到达这两个城市，会发生什么？如果发生更剧烈的变化，比如在2030年代初超音速客机旅行卷土重来，又会怎样？这样的变化将破坏任何依赖于在遥远城市同一天购买信号的欺诈检测模型。为机器学习模型提供的数据通常来自现实世界，而现实世界以不可预测的方式不断变化。我们需要预期我们的模型将需要定期在新鲜数据上重新训练。
- en: 'How often do models need to be retrained? What model performance measurements
    need to be monitored to determine when retraining is necessary? Can we simply
    swap the old model out of production and swap in the new model, or do we need
    to keep both in production and use a blended score (with some proportion from
    the old model and some from the new model) for a transition period to avoid sudden
    changes in the end user’s experience? See [https://mlinproduction.com/model-retraining](https://mlinproduction.com/model-retraining)
    and [http://mng.bz/ggyZ](http://mng.bz/ggyZ) for a more detailed examinations
    of retraining issues. Here is a brief summary of some best practices for model
    retraining:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 模型需要多久重新训练一次？需要监控哪些模型性能指标来确定何时需要重新训练？我们是否可以简单地替换掉旧模型并替换上新模型，或者我们需要在生产中保留两个模型，并在过渡期间使用一个混合评分（部分来自旧模型，部分来自新模型）以避免用户体验的突然变化？请参阅
    [https://mlinproduction.com/model-retraining](https://mlinproduction.com/model-retraining)
    和 [http://mng.bz/ggyZ](http://mng.bz/ggyZ) 了解关于重新训练问题的更详细讨论。以下是关于模型重新训练的一些最佳实践的简要总结：
- en: Save the performance measurements so you can do assessments of performance of
    the deployed model. To assess the accuracy of your predictions, you will need
    to have the predictions and the matching real-world outcomes. For the streetcar
    delay problem, to assess the model performance in production for a month, we need
    the actual delay data along with predictions that the model would make for the
    route/direction/time-slot combinations for that month. If we save predictions
    that are made during a month, we can compare those predictions with the actual
    delay data when it becomes available for a month.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存性能指标，以便对部署模型的性能进行评估。为了评估预测的准确性，你需要有预测和匹配的真实世界结果。对于电车延误问题，为了评估一个月内生产中的模型性能，我们需要实际的延误数据和模型对该月路线/方向/时间段组合的预测。如果我们保存一个月内做出的预测，我们可以在一个月后将其与实际延误数据进行比较。
- en: Pick a performance measurement that gives you a way to assess how your model
    is doing without excessive latency. Consider the credit card fraud problem. Suppose
    that we put a model into production to predict whether transactions are fraudulent,
    and our performance measurement for the deployed model depends on having a complete
    report of actual fraudulent transactions for a month. It may take several months
    to get complete conclusions on all transactions in a given month that are actually
    fraudulent. In this case, it would be better to have a performance measurement
    that worked with transactions that were conclusively determined to be fraudulent
    within the same month. In short, a performance measurement that yields good results
    soon enough to allow you to make retraining decisions quickly is better than a
    performance measurement that yields great results but risks having a poorly performing
    model deployed for many months.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个性能度量指标，它能够让你评估模型表现而不会产生过多的延迟。以信用卡欺诈问题为例。假设我们将一个模型投入生产以预测交易是否为欺诈，而我们部署的模型性能度量依赖于一个月内实际欺诈交易的完整报告。可能需要几个月的时间才能得出给定月份所有实际欺诈交易的完整结论。在这种情况下，拥有一个与同一个月内确定无疑为欺诈的交易一起工作的性能度量会更好。简而言之，一个能够尽快产生良好结果以便你快速做出重新训练决策的性能度量比一个产生卓越结果但可能使表现不佳的模型部署数月之久的性能度量要好。
- en: Do an experiment with historical data to get an idea of how quickly your deployed
    model’s performance will degrade. For the credit card fraud problem, you could
    train your model with data up to the end of 2018 and then apply the trained model
    to get predictions on transactions for the first 6 months of 2019\. You can compare
    those predictions with the data you have for actual fraudulent transactions for
    those 6 months to see whether the accuracy of the model trained on 2018 data gets
    worse over time on the 2019 data. This process may give you a sense of how quickly
    your model performance degrades, but it won’t be foolproof, because depending
    on the problem, your data can change in unexpected ways.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用历史数据进行实验，以了解你的部署模型性能将如何快速退化。对于信用卡欺诈问题，你可以用2018年底的数据来训练你的模型，然后应用训练好的模型来预测2019年前6个月的交易。你可以将这些预测与那些6个月的实际欺诈交易数据进行比较，以查看基于2018年数据的模型在2019年数据上的准确性是否会随着时间的推移而变差。这个过程可能会让你对模型性能退化速度有一个概念，但这并不是万无一失的，因为根据问题的不同，你的数据可能会以意想不到的方式发生变化。
- en: Repeat the data exploration steps you did before training the model on new data.
    Recall the data exploration that we did in chapter 3\. If we were to repeat these
    steps on new streetcar delay data as it becomes available, we could detect shifts
    in the characteristics of the data and retrain the model if we find significant
    shifts.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在新数据上重复你在训练模型之前所做的数据探索步骤。回想一下我们在第3章中进行的那些数据探索。如果我们对新街车延误数据重复这些步骤，一旦数据可用，我们就可以检测到数据特征的变化，并在发现显著变化时重新训练模型。
- en: Let’s look at the model retraining question in the context of the streetcar
    delay prediction model. First, let’s look at the raw data. The raw data gets updated
    monthly with a delay of two to three months. In January, for example, the latest
    delay data is from the previous October. With a decent development environment,
    the end-to-end process, from downloading the latest raw data to deploying an updated
    model, takes less than an hour. With that low a cost, it would be possible to
    retrain the model every month, but would it be necessary? The data exploration
    we did in chapter 3 showed that there were some long-term trends (such as delays
    becoming shorter but more frequent) but no huge oscillations between months. We
    could probably get away with refreshing the model every quarter, but to be sure,
    we would want to monitor the model for accuracy by comparing predictions with
    actual delay data for new months as they become available.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以街车延误预测模型为例，看看模型重新训练的问题。首先，让我们看看原始数据。原始数据每月更新一次，但会有两到三个月的延迟。例如，一月份的最新延误数据来自前一年的十月。在良好的开发环境中，从下载最新原始数据到部署更新模型的端到端过程不到一个小时。以这么低的成本，我们每个月重新训练模型是可能的，但这是否必要？我们在第3章中进行的那些数据探索显示，存在一些长期趋势（例如，延误时间变短但更频繁），但月份之间没有巨大的波动。我们可能可以每季度刷新一次模型，但要确保这一点，我们希望通过将预测与可用新月份的实际延误数据进行比较来监控模型的准确性。
- en: Further, we might want to run some experiments training the model only on more
    recent data, for example by keeping a three-year rolling window for training data
    rather than training on the entire dataset since January 2014.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可能想要进行一些实验，只使用更近期的数据进行模型训练，例如通过保持三年滚动窗口作为训练数据，而不是从2014年1月以来的整个数据集进行训练。
- en: Finally, we would want to provide our users a way to give direct feedback on
    their experience with the end application. Direct feedback from a subset of users
    can reveal model problems that monitoring overlooks.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望为用户提供一种直接反馈他们使用最终应用体验的方式。来自用户子集的直接反馈可以揭示监控中忽视的模型问题。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A trained deep learning model is not useful by itself. To make it useful, you
    need to deploy it, making it accessible to other programs or to users who need
    to take advantage of the model’s predictions. Deployment is challenging because
    it involves a set of technical capabilities that is distinct from the technical
    approaches that you have learned about in the data preparation and model training
    chapters of this book.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个训练好的深度学习模型本身并没有用处。为了使其变得有用，你需要部署它，使其能够被其他程序或需要利用模型预测的用户访问。部署是一个挑战，因为它涉及一系列与本书数据准备和模型训练章节中学到的技术方法不同的技术能力。
- en: You can get a minimal deployment of your model by using Flask, a Python web
    framework library, along with a set of HTML pages. With this combination of Flask,
    HTML, and JavaScript, your users can enter the details about their intended streetcar
    trips in a web page and get predictions on whether the trips will be delayed.
    Behind the scenes, the trained deep learning model is invoked with the trip details
    and produces a prediction, which is prepared to be displayed in a web page.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用Flask，一个Python网络框架库，以及一组HTML页面来获得你模型的最低部署。通过Flask、HTML和JavaScript的组合，你的用户可以在网页中输入他们计划乘坐的电车旅行的详细信息，并获得关于旅行是否会延误的预测。在幕后，训练好的深度学习模型使用旅行详细信息被调用，并产生一个预测，该预测被准备在网页中显示。
- en: If you want a smoother user experience, you can deploy your trained deep learning
    model by using a combination of the Rasa chatbot framework and Facebook Messenger.
    When you have completed this deployment, your users can message the chatbot in
    Facebook Messenger with an English-language question such as “Will Route 501 east
    be delayed?” and get an answer back (delay/no delay) in Facebook Messenger. Behind
    the scenes, the Rasa chatbot extracts the key details from the question the user
    entered in Facebook Messenger, invokes a Python module that applies the trained
    deep learning model to get a prediction for these details, and prepares the prediction
    for display in Facebook Messenger.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要更流畅的用户体验，你可以通过结合使用Rasa聊天机器人框架和Facebook Messenger来部署你的训练好的深度学习模型。当你完成部署后，你的用户可以通过Facebook
    Messenger向聊天机器人发送英语问题，例如“501路东行是否会延误？”并在Facebook Messenger中得到回答（延误/不延误）。在幕后，Rasa聊天机器人从用户在Facebook
    Messenger中输入的问题中提取关键细节，调用一个Python模块，应用训练好的深度学习模型对这些细节进行预测，并将预测结果准备在Facebook Messenger中显示。
- en: Pipelines allow you to encapsulate the data preparation steps (including assigning
    numeric values to categorical column entries and converting the dataset from a
    Pandas dataframe to the format required by the Keras deep learning model) so that
    identical transformations can be applied to the data at training time and at scoring
    time (when the trained model is being applied to new data points, such as the
    time/route/direction combination for a streetcar trip).
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道允许你封装数据准备步骤（包括为分类列条目分配数值和将数据集从Pandas数据框转换为Keras深度学习模型所需的格式），以便在训练时间和评分时间（当训练好的模型被应用于新的数据点时，例如电车旅行的/时间/路线/方向组合）应用相同的转换。
- en: When you have deployed a trained deep learning model, you need to monitor its
    performance. If the data changes, the performance of the model may degrade over
    time, and you may need to retrain the model on more recent data and then replace
    the currently deployed model with the retrained model.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你部署了一个训练好的深度学习模型后，你需要监控其性能。如果数据发生变化，模型的性能可能会随着时间的推移而下降，你可能需要使用更近期的数据进行模型重新训练，然后替换当前部署的模型。
