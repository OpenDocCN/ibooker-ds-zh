- en: 8 Understanding rates of change
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 理解变化率
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Calculating the average rate of change in a mathematical function
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算数学函数的平均变化率
- en: Approximating the instantaneous rate of change at a point
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 近似某点的瞬时变化率
- en: Picturing how the rate of change is itself changing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 想象变化率本身是如何变化的
- en: Reconstructing a function from its rate of change
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其变化率重建函数
- en: 'In this chapter, I introduce you to two of the most important concepts from
    calculus: the derivative and the integral. Both of these are operations that work
    with functions. The *derivative* takes a function and gives you another function
    measuring its rate of change. The *integral* does the opposite; it takes a function
    representing a rate of change and gives you back a function measuring the original,
    cumulative value.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我向你介绍了微积分中最重要的一些概念：导数和积分。这两个操作都与函数一起工作。*导数*接受一个函数并给你另一个函数，该函数测量其变化率。*积分*做的是相反的事情；它接受一个表示变化率的函数，并给你一个测量原始累积值的函数。
- en: I focus on a simple example from my own work in data analysis for oil production.
    The set up we’ll picture is a pump lifting crude oil out of a well, which then
    flows through a pipe into a tank. The pipe is equipped with a meter that continuously
    measures the rate of fluid flow, and the tank is equipped with a sensor that detects
    the height of fluid in the tank and reports the volume of oil stored within (figure
    8.1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我将专注于我从自己的石油生产数据分析工作中提取的一个简单例子。我们将设想的情况是一个泵从油井中抽出原油，然后通过管道流入油罐。管道配备了一个连续测量流体流速的仪表，油罐配备了一个传感器，它可以检测油罐中液体的高度并报告存储在其中的油的体积（图8.1）。
- en: '![](../Images/CH08_F01_Orland.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F01_Orland.png)'
- en: Figure 8.1 Schematic diagram of a pump lifting oil from a well and pumping it
    into a tank
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 从油井中抽取油并将其泵入油罐的泵的示意图
- en: The volume sensor measurements tell us the volume of oil in the tank as a function
    of time, while the flow meter measurements tell us the volume flowing into the
    tank per hour, also as a function of time. In this example, the volume is the
    cumulative value and the flow rate is its rate of change.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 体积传感器的测量告诉我们油罐中油的体积作为时间的函数，而流量计的测量告诉我们每小时流入油罐的体积，这也是作为时间的函数。在这个例子中，体积是累积值，流速是其变化率。
- en: In this chapter, we solve two main problems. First, in our example, we start
    with known, cumulative volumes over time and calculate the flow rate as a function
    of time using the derivative. Second, we do the opposite task, starting with the
    flow rate as a function of time and calculating the cumulative volume of oil in
    the tank over time using the integral. Figure 8.2 shows this process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解决两个主要问题。首先，在我们的例子中，我们从一个已知的时间累积体积开始，使用导数计算作为时间的函数的流速。其次，我们执行相反的任务，从一个作为时间的函数的流速开始，使用积分计算油罐中油的累积体积。图8.2展示了这个过程。
- en: '![](../Images/CH08_F02_Orland.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F02_Orland.png)'
- en: Figure 8.2 Finding the flow rate over time from the volume using the derivative
    and then finding the volume over time from the flow rate using the integral
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 使用导数从体积中找到随时间变化的流速，然后使用积分从流速中找到随时间变化的体积
- en: We’ll write a function called `get_flow_rate(volume_function)` that takes the
    volume function as an input and returns a new Python function that gives the flow
    rate at any time. Then we’ll write a second function, `get_volume(flow_rate_function)`,
    that takes the flow rate function and returns a Python function giving volume
    over time. I intersperse a few smaller examples along the way as a warm up to
    help you think about rates of change.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个名为`get_flow_rate(volume_function)`的函数，它接受体积函数作为输入，并返回一个新Python函数，该函数在任何时间给出流速。然后我们将编写第二个函数`get_volume(flow_rate_function)`，它接受流速函数并返回一个Python函数，该函数给出随时间变化的体积。我在过程中穿插一些较小的例子作为热身，帮助你思考变化率。
- en: Even though its big ideas aren’t that complicated or foreign, calculus gets
    a bad reputation because it requires so much tedious algebra. For that reason,
    I focus on introducing new ideas in this chapter but not a lot of new techniques.
    Most of the examples require only the linear function math that we covered in
    chapter 7\. Let’s get started!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它的基本思想并不复杂或陌生，但微积分因其需要大量的繁琐代数而名声不佳。因此，我在本章中侧重于介绍新思想，而不是很多新技术。大多数例子只需要我们在第7章中覆盖的线性函数数学。让我们开始吧！
- en: 8.1 Calculating average flow rate from volume
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 从体积计算平均流速
- en: Let’s start by assuming we know the volume in the tank over time, which is encoded
    as a Python function called `volume`. This function takes as an argument, the
    time in hours after a predefined starting point, and returns the volume of oil
    in the tank at that time, measured in a unit called barrels (abbreviated “bbl”).
    To keep the focus on the ideas rather than the algebra, I won’t even tell you
    the formula for the `volume` function (though you can see it in the source code
    if you’re curious). All you need to do for now is to call it and to plot it. When
    you plot it, you’ll see something like figure 8.3.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先假设我们知道随时间变化的罐中体积，这被编码为一个名为 `volume` 的 Python 函数。这个函数接受一个参数，即从预定义的起始点之后的小时数，并返回该时间点的油罐体积，以桶（缩写为“bbl”）为单位。为了将重点放在思想上而不是代数上，我甚至不会告诉你
    `volume` 函数的公式（尽管如果你好奇可以在源代码中看到它）。你现在需要做的只是调用它并绘制它。当你绘制它时，你会看到类似于图 8.3 的东西。
- en: '![](../Images/CH08_F03_Orland.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F03_Orland.png)'
- en: Figure 8.3 A plot of the `volume` function shows the volume of oil in the tank
    over time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 `volume` 函数的绘图显示了随时间变化的油罐体积。
- en: We want to move in the direction of finding the flow rate into the tank at any
    point in time, so for our first baby step, let’s calculate this in an intuitive
    way. In this example, let’s write a function `average_flow_rate(v,` `t1,` `t2)`
    that takes a volume function `v`, a start time `t1`, and an end time `t2`, and
    returns a number that is the *average flow rate* into the tank on the time interval.
    That is, it tells us the overall number of barrels per hour entering the tank.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望朝着在任何时间点找到进入罐中流速的方向前进，因此，作为我们的第一步，让我们以直观的方式计算这个值。在这个例子中，让我们编写一个函数 `average_flow_rate(v,
    t1, t2)`，它接受一个体积函数 `v`，一个起始时间 `t1` 和一个结束时间 `t2`，并返回一个数字，表示在时间间隔内进入罐的平均流速。也就是说，它告诉我们每小时进入罐中的总桶数。
- en: 8.1.1 Implementing an average_flow_rate function
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 实现 average_flow_rate 函数
- en: 'The word *per* in “barrels per hour” suggests that we’re going to do some division
    to get our answer. The way to calculate the average flow rate is to take the total
    change in volume divided by the elapsed time:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: “每小时桶数”中的“每”一词表明我们将进行一些除法来得到答案。计算平均流速的方法是将总体体积变化除以经过的时间：
- en: '![](../Images/CH08_F03_Orland_EQ01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F03_Orland_EQ01.png)'
- en: 'The elapsed time between the starting time *t*[1] and the ending time *t*[2]
    measured in hours is *t*[2] − *t*[1]. If we have a function *V*(*t*) that tells
    us volume as a function of time, the overall change in volume is the volume at
    *t*[2] minus the volume at *t*[1], or *V*(*t*[2]) − *V*(*t*[1]). That gives us
    a more specific equation to work with:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从起始时间 *t*[1] 到结束时间 *t*[2] 测量的时间（以小时为单位）是 *t*[2] − *t*[1]。如果我们有一个函数 *V*(*t*)，它告诉我们体积作为时间的函数，总体体积变化是
    *t*[2] 时的体积减去 *t*[1] 时的体积，即 *V*(*t*[2]) − *V*(*t*[1])。这给了我们一个更具体的方程来工作：
- en: '![](../Images/CH08_F03_Orland_EQ02.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F03_Orland_EQ02.png)'
- en: This is how we calculate rates of change in different contexts. For instance,
    your speed when driving a car is the rate at which you cover distance with respect
    to time. To calculate your average speed for a drive, you divide your total distance
    traveled in miles by the elapsed time in hours to get a result in miles per hour
    (mph). To know the distance traveled and time elapsed, you need to check your
    clock and odometer at the beginning and end of the trip.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们计算不同情境中变化率的方法。例如，当你开车时，你的速度是你相对于时间覆盖距离的速率。为了计算你的平均速度，你将行驶的总英里数除以经过的小时数，以每小时英里（mph）的结果。为了知道行驶的距离和经过的时间，你需要在旅行的开始和结束时检查你的时钟和里程表。
- en: 'Our formula for average flow rate depends on the volume function *V* and the
    starting and ending times *t*[1] and *t*[2], which are the parameters we’ll pass
    to the corresponding Python function. The body of the function is a direct translation
    of this mathematical formula to Python:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的平均流速公式依赖于体积函数 *V* 和起始时间 *t*[1] 和结束时间 *t*[2]，这些是我们将传递给相应 Python 函数的参数。函数的主体是将这个数学公式直接翻译成
    Python：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This function is simple, but important enough to walk through as an example
    calculation. Let’s use the `volume` function (plotted in figure 8.3 and included
    in the source code) and say we want to know the average flow rate into the tank
    between the 4-hr mark and the 9-hr mark. In this case, `t1` `=` `4` and `t2` `=`
    `9`. To find the starting and ending volumes, we can evaluate the `volume` function
    at these times:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数很简单，但重要到足以作为一个示例计算来讲解。让我们使用`volume`函数（如图8.3所示，并包含在本书的源代码中），并假设我们想知道在4小时标记和9小时标记之间油罐的平均流速。在这种情况下，`t1`
    `=` `4` 和 `t2` `=` `9`。为了找到起始和结束的体积，我们可以在这两个时间点上评估`volume`函数：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Rounding for simplicity, the difference between the two volumes is 5.25 bbl
    − 3.3 bbl = 1.95 bbl, and the total elapsed time is 9 hr − 4 hr = 5 hr. Therefore,
    the average flow rate into the tank is roughly 1.95 bbl divided by 5 hr or 0.39
    bbl/hr. Our function confirms we got this right:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化计算，两个体积之间的差值是5.25 bbl − 3.3 bbl = 1.95 bbl，总经过时间是9 hr − 4 hr = 5 hr。因此，油罐的平均流速大约是1.95
    bbl除以5 hr，即0.39 bbl/hr。我们的函数确认我们得到了正确的结果：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](../Images/CH08_F04_Orland.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F04_Orland.png)'
- en: Figure 8.4 A secant line connects the starting and ending points on the volume
    graph.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 一条割线连接了体积图上的起始点和结束点。
- en: This completes our first basic example of finding the rate of change of a function.
    That wasn’t too bad! Before we move on to some more interesting examples, let’s
    spend a bit more time interpreting what the volume function does.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们寻找函数变化率的第一个基本示例。这并不太难！在我们继续一些更有趣的例子之前，让我们花更多的时间来解释体积函数的作用。
- en: 8.1.2 Picturing the average flow rate with a secant line
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 使用割线描绘平均流速
- en: Another useful way to think about the average rate of change in volume over
    time is to look at the volume graph. Let’s focus on the two points on the volume
    graph between which we calculated the average flow rate. In figure 8.4, the points
    are shown as dots on the graph, and I’ve drawn a line passing through them. A
    line passing through two points on a graph like this is called a *secant line*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到体积随时间变化的平均变化率，另一种有用的思考方式是查看体积图。让我们专注于我们计算平均流速的两个体积图上的点。在图8.4中，这些点在图上显示为点，我画了一条穿过它们的线。穿过这种图上两点的一条线被称为**割线**。
- en: As you can see, the graph is higher at 9 hrs than at 4 hrs because the volume
    of oil in the tank increased during this period. This causes the secant line connecting
    the starting and ending points to slope upward. It turns out the slope of the
    secant tells us *exactly* what the average flow rate is on the time interval.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，由于在这个时间段内油罐中的油量增加，所以在9小时时的图形比4小时时更高。这导致连接起始点和结束点的割线向上倾斜。结果证明，割线的斜率**精确地**告诉我们时间间隔内的平均流速。
- en: Here’s why. Given two points on a line, the slope is the change in the vertical
    coordinate divided by the change in the horizontal coordinate. In this case, the
    vertical coordinate goes from *V*(*t*[1]) to *V*(*t*[2]) for a change of *V*(*t*[2])
    − *V*(*t*[1]), and the horizontal coordinate goes from *t*[1] to *t*[2] for a
    change of *t*[2] − *t*[1]. The slope is then (*V*(*t*[2]) − *V*(*t*[1])) divided
    by (*t*[2] − *t*[1]), exactly the same calculation as the average flow rate (figure
    8.5)!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 原因如下。给定直线上的两个点，斜率是垂直坐标变化除以水平坐标变化。在这种情况下，垂直坐标从*V*(*t*[1])变为*V*(*t*[2])，变化为*V*(*t*[2])
    − *V*(*t*[1])，水平坐标从*t*[1]变为*t*[2]，变化为*t*[2] − *t*[1]。斜率因此是(*V*(*t*[2]) − *V*(*t*[1]))除以(*t*[2]
    − *t*[1])，这与平均流速的计算完全相同（图8.5）！
- en: '![](../Images/CH08_F05_Orland.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F05_Orland.png)'
- en: Figure 8.5 We calculate the slope of a secant line in the same way as the average
    rate of change of the `volume` function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 我们以计算`volume`函数平均变化率相同的方式计算割线的斜率。
- en: As we continue, you can picture secant lines on graphs to reason about the average
    rate of change in a function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续的过程中，您可以在图上想象割线来推理函数的平均变化率。
- en: 8.1.3 Negative rates of change
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 负变化率
- en: One case worth a brief mention is that the secant line can have a *negative*
    slope. Figure 8.6 shows the graph of a different `volume` function, which you
    can find implemented as `decreasing_volume` in the source code for this book.
    Figure 8.6 plots the volume in the tank decreasing over time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 值得简要提及的一个例子是割线可以具有**负**斜率。图8.6显示了不同**体积**函数的图形，您可以在本书的源代码中找到作为`decreasing_volume`实现的代码。图8.6显示了油罐中体积随时间减少的情况。
- en: '![](../Images/CH08_F06_Orland.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F06_Orland.png)'
- en: Figure 8.6 A different `volume` function shows that the volume in the tank decreases
    over time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 不同的 `volume` 函数显示油箱中的体积随时间减少。
- en: This example isn’t compatible with our previous example because we don’t expect
    oil to be flowing out of the tank back into the ground. But it does illustrate
    that a secant line can go downward, for instance, from *t* = 0 to *t* = 4\. On
    this time interval, the change in volume is −3.2 bbl (figure 8.7).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与我们的前一个例子不兼容，因为我们不期望油会从油箱流回地面。但它确实说明了割线可以向下延伸，例如，从 *t* = 0 到 *t* = 4。在这个时间段内，体积变化为
    -3.2 bbl（图8.7）。
- en: '![](../Images/CH08_F07_Orland.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F07_Orland.png)'
- en: Figure 8.7 Two points on a graph that define a secant line with a negative slope
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 定义具有负斜率的割线的图上的两个点
- en: In this case, the slope is −3.2 bbl divided by 4 hr or -0.8 bbl/hr. That means
    that the rate at which oil is entering the tank is -0.8 bbl/hr. A more sensible
    way to say this is that oil is *leaving* the tank at a rate of 0.8 bbl/hr. Regardless
    of whether the `volume` function is increasing or decreasing, our `average_flow_rate`
    function is reliable. In this case,
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，斜率为 -3.2 bbl除以4小时，即 -0.8 bbl/小时。这意味着油进入油箱的速度为 -0.8 bbl/小时。更合理的说法是，油以0.8
    bbl/小时的速度*离开*油箱。无论 `volume` 函数是增加还是减少，我们的 `average_flow_rate` 函数都是可靠的。在这种情况下，
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Equipped with this function to measure the average flow rate, we can go a step
    further in the next section−figuring out how the flow rate changes over time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 配备了这个函数来测量平均流速，我们可以在下一节中更进一步−了解流速随时间的变化。
- en: 8.1.4 Exercises
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.4 练习
- en: '| **Exercise 8.1**: Suppose you start a road trip at noon when your odometer
    reads 77,641 miles, and you end your road trip at 4:30 in the afternoon with your
    odometer reading 77,905 miles. What was your average speed during the trip?**Solution**:
    The total distance traveled is 77,905 − 77,641 = 264 miles covered over 4.5 hrs.
    The average speed is 264 mi / 4.5 hr or about 58.7 mph. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **练习8.1**：假设您在中午出发开始长途旅行，当时您的里程表读数为77,641英里，您在下午4:30结束旅行，当时里程表读数为77,905英里。旅行中的平均速度是多少？**解答**：总行程为77,905
    − 77,641 = 264英里，覆盖了4.5小时。平均速度为264英里 / 4.5小时，约为58.7英里/小时。|'
- en: '| **Exercise 8.2**: Write a Python function `secant_line(f,x1,x2)` that takes
    a function `*f*(*x*)` and two values, `x1` and `x2`, and that returns a new function
    representing a secant line over time. For instance, if you ran `line` `=` `secant_line
    (f,x1,x2)`, then `line(3)` would give you the *y* value of the secant line at
    *x* = 3.**Solution**:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习8.2**：编写一个Python函数 `secant_line(f,x1,x2)`，该函数接受一个函数 `*f*(*x*)` 和两个值 `x1`
    和 `x2`，并返回一个表示随时间变化的割线的函数。例如，如果您运行 `line` `=` `secant_line (f,x1,x2)`，那么 `line(3)`
    将给出在 *x* = 3处的割线的 *y* 值。**解答**：'
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 8.3**: Write a function that uses the code from the previous exercise
    to plot a secant line of a function `f` between two given points.**Solution**:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习8.3**：编写一个函数，使用前一个练习中的代码来绘制两个给定点之间函数 `f` 的割线。**解答**：'
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 8.2 Plotting the average flow rate over time
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 随时间绘制平均流速
- en: One of our big objectives for this chapter is to start with the volume function
    and recover the flow rate function. To find the flow rate as a function of time,
    we need to ask how rapidly the volume of the tank is changing at different points
    in time. For starters, we can see in figure 8.8 that the flow rate is changing
    over time−different secant lines on the volume graph have different slopes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章的一个主要目标是，从体积函数开始，恢复流速函数。为了找到流速作为时间的函数，我们需要了解油箱在不同时间点的体积变化速度。首先，我们可以从图8.8中看到，流速随时间变化−体积图上的不同割线具有不同的斜率。
- en: '![](../Images/CH08_F08_Orland.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F08_Orland.png)'
- en: Figure 8.8 Different secant lines on the volume graph have different slopes,
    indicating that the flow rate is changing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 体积图上的不同割线具有不同的斜率，表明流速在变化。
- en: In this section, we get closer to finding the flow rate as a function of time
    by calculating the average flow rate on different intervals. We break up the 10-hr
    period into a number of smaller intervals of a fixed duration (for example, ten,
    1-hr intervals) and calculate the average flow rate for each one.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过在不同时间段计算平均流速来更接近找到流速作为时间的函数。我们将10小时的时间段分成多个较短且固定持续时间的小时间段（例如，十个1小时的时间段），并为每个时间段计算平均流速。
- en: 'We package this work in a function called `interval_flow_rates(v,t1, t2,dt)`,
    where `v` is the volume function, `t1` and `t2` are the starting and ending times,
    and `dt` is the fixed duration of the time intervals. This function returns a
    list of pairs of time and flow rate. For instance, if we break the 10 hrs into
    1-hr segments, the result should look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这项工作封装在一个名为`interval_flow_rates(v,t1, t2,dt)`的函数中，其中`v`是体积函数，`t1`和`t2`是起始和结束时间，`dt`是时间间隔的固定持续时间。此函数返回时间与流速的成对列表。例如，如果我们将10小时分成1小时段，结果应该如下所示：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Where each `...` would be replaced by the flow rate in the corresponding hour.
    Once we get these pairs, we can draw them as a scatter plot alongside the flow
    rate function from the beginning of the chapter and compare the results.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 其中每个`...`将被相应小时的流速所替换。一旦我们得到这些成对，我们就可以将它们作为散点图绘制在章节开头的流速函数旁边，并比较结果。
- en: 8.2.1 Finding the average flow rate in different time intervals
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 在不同时间间隔中寻找平均流速
- en: 'As a first step to implementing `interval_flow_rates()`, we need to find the
    starting points for each time interval. This means finding a list of time values
    from the starting time `t1` to the ending time `t2` in increments of the interval
    length `dt`. There’s a handy function in Python’s NumPy library called `arange`
    that does this for us. For instance, starting from time zero and going to time
    10 in 0.5-hr increments gives us the following interval start times:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实现`interval_flow_rates()`的第一步，我们需要找到每个时间间隔的起始点。这意味着找到从起始时间`t1`到结束时间`t2`的时间值列表，增量是时间间隔长度`dt`。Python的NumPy库中有一个方便的函数叫做`arange`，它可以为我们完成这个任务。例如，从时间零开始，以0.5小时为增量到时间10，我们得到以下时间间隔起始时间：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that the end time of 10 hrs isn’t included in the list. This is because
    we list the *start* time for each half hour, and the half hour from *t* =10 to
    *t* =10.5 isn’t part of the overall time interval we’re considering.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，10小时结束时间不包括在列表中。这是因为我们列出每个半小时的起始时间，而从`t` =10到`t` =10.5的半小时不是我们考虑的整体时间间隔的一部分。
- en: 'For each of these interval start times, adding `dt` returns the corresponding
    interval end times. For instance, the interval starting at 3.5 hrs in the preceding
    list ends at 3.5 + 0.5 = 4.0 hrs. To implement the `interval_flow_rates` function,
    we just need to use our `average_flow_rate` function on each of the intervals.
    Here’s how the complete function looks:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些时间间隔的起始时间，加上`dt`将返回相应的结束时间。例如，在前面列表中，从3.5小时开始的时间间隔结束于3.5 + 0.5 = 4.0小时。要实现`interval_flow_rates`函数，我们只需在各个时间间隔上使用我们的`average_flow_rate`函数。下面是这个完整函数的示例：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ For every interval start time t, finds the average flow rate from t to t+dt.
    (We want the list of pairs of t with the corresponding rate.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对于每个时间间隔的起始时间`t`，计算从`t`到`t+dt`的平均流速。（我们想要的是`t`与相应流速的成对列表。）
- en: 'If we pass in our `volume` function with 0 hrs and 10 hrs as the start and
    end times, and 1 hr as the interval length, we get a list telling us the flow
    rate in each hour:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`volume`函数与0小时和10小时作为起始和结束时间，以及1小时作为时间间隔长度传递，我们将得到一个列表，告诉我们每个小时的流速：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can tell a few things by looking at this list. The average flow rate is always
    positive, meaning that there is a net addition of oil into the tank in each hour.
    The flow rate decreases to its lowest value around hours 3 and 4 and then increases
    to its highest value in the final hour. This is even clearer if we plot it on
    a graph.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看这个列表，我们可以得出一些结论。平均流速始终为正，这意味着在每小时中油罐中都有净增加的油量。流速在3小时和4小时左右降至最低值，然后在最后一小时增加到最高值。如果我们在图上绘制，这会更加清晰。
- en: 8.2.2 Plotting the interval flow rates
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 绘制时间间隔流速图
- en: 'We can use Matplotlib’s `scatter` function to quickly make a plot of these
    flow rates over time. This function plots a set of points on a graph, given a
    list of horizontal coordinates followed by a list of vertical coordinates. We
    need to pull out the times and flow rates as two separate lists of 10 numbers
    and then pass them to the function. To avoid repeating this process, we can build
    it all into one function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Matplotlib的`scatter`函数快速绘制这些流速随时间变化的图表。该函数在给定的水平坐标列表后面跟一个垂直坐标列表的情况下，在图上绘制一系列点。我们需要提取时间和流速作为两个单独的10数字列表，然后将它们传递给该函数。为了避免重复这个过程，我们可以将其全部构建到一个函数中：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Calling `plot_interval_flow_rates(volume,0,10,1)` generates a scatter plot of
    the data produced by `interval_flow_rates`. Figure 8.9 shows the result of plotting
    the `volume` function from zero to 10 hrs in increments of 1 hr.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`plot_interval_flow_rates(volume,0,10,1)`生成由`interval_flow_rates`产生的数据的散点图。图8.9显示了从0小时到10小时以1小时为增量绘制`volume`函数的结果。
- en: '![](../Images/CH08_F09_Orland.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F09_Orland.png)'
- en: Figure 8.9 A plot of the average flow rate in each hour
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 每小时的平均流量图
- en: 'This confirms what we saw in the data: the average flow rate decreases to its
    lowest value around hours 3 and 4 and then increases again after that to a highest
    rate of nearly 1.5 bbl/hr. Let’s compare these average flow rates with the actual
    flow rate function. Again, I don’t want you to worry about the formula for flow
    rate as a function of time. I include a `flow_rate` function in the source code
    for this book that we can plot (figure 8.10), along with the scatter plot.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这证实了我们从数据中看到的情况：平均流量在3小时和4小时左右降至最低值，然后在此之后再次增加，达到近1.5桶/小时的最高速率。让我们将这些平均流量与实际流量函数进行比较。同样，我不想让你担心流量随时间变化的公式。我在这本书的源代码中包含了一个`flow_rate`函数，我们可以绘制它（图8.10），以及散点图。
- en: '![](../Images/CH08_F10_Orland.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F10_Orland.png)'
- en: Figure 8.10 A plot of the average flow rate in each hour (dots) and the actual
    flow rate (smooth curve) per hour
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 每小时的平均流量图（点）和每小时的实际流量图（平滑曲线）
- en: These two plots tell the same story, but they don’t quite line up. The difference
    is that the dots measure average flow rates, whereas the `flow_rate` function
    shows the *instantaneous* value of the flow rate at any point in time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个图表讲述的是同一个故事，但它们并不完全吻合。区别在于点测量平均流量，而`flow_rate`函数显示了在任何时间点的流量*瞬时值*。
- en: To understand this, it’s helpful to think of the road trip example again. If
    you cover 60 miles in 1 hr, your average speed is 60 mph. However, it’s unlikely
    your speedometer read exactly 60 mph at every instant of the hour. At some point
    on the open road, your *instantaneous speed* might have been 70 mph, while at
    another time in traffic, you might have slowed down to 50 mph.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点，再次思考长途旅行的例子可能会有所帮助。如果你在1小时内行驶了60英里，你的平均速度是60英里/小时。然而，你的速度计在每小时的每一瞬间都显示60英里/小时的可能性不大。在开阔道路上某个地方，你的*瞬时速度*可能达到70英里/小时，而在交通中，你可能会减速到50英里/小时。
- en: Similarly, the flow rate meter on the pipeline needn’t agree with the average
    flow rate on the subsequent hour. It turns out that if you make the time intervals
    smaller, the graphs are in closer agreement. Figure 8.11 shows the plot of the
    average flow rates at 20-min intervals (1/3hrs) next to the flow rate function.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，管道上的流量计不需要与下一小时的平均流量一致。实际上，如果你使时间间隔更小，图表会更接近。图8.11显示了20分钟间隔（1/3小时）的平均流量图，与流量函数并排。
- en: '![](../Images/CH08_F11_Orland.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F11_Orland.png)'
- en: Figure 8.11 The graph of the flow rate over time compared with the average flow
    rates at 20-min intervals
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 流量随时间变化的图表与20分钟间隔的平均流量图
- en: The average flow rates are still not a perfect match to the instantaneous flow
    rates, but they’re a lot closer. In the next section, we’ll run with this idea
    and calculate the flow rates on extremely small intervals, where the difference
    between average and instantaneous rates is imperceptible.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 平均流量仍然与瞬时流量不完全匹配，但它们要接近得多。在下一节中，我们将继续这个想法，并计算极小时间间隔的流量，其中平均流量和瞬时流量的差异几乎不可察觉。
- en: 8.2.3 Exercises
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 练习
- en: '| **Exercise 8.4**: Plot the `decreasing_volume` flow rates over time at 0.5-hr
    intervals. When is its flow rate the lowest? That is, when is oil leaving the
    tank at the fastest rate?**Solution**: Running `plot_interval_flow_rates(decreasing_volume,0,
    10,0.5)`, we can see that the rate is the lowest (most negative) just before the
    5-hr mark.![](../Images/CH08_F11_Orland_UN01.png) |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **练习8.4**：以0.5小时为间隔绘制`decreasing_volume`流量随时间的变化。何时其流量最低？也就是说，何时油罐中油流出速度最快？**解答**：运行`plot_interval_flow_rates(decreasing_volume,0,
    10,0.5)`，我们可以看到在5小时前流量最低（最负值）！![图片](../Images/CH08_F11_Orland_UN01.png) |'
- en: '| **Exercise 8.5**: Write a `linear_volume_function` and plot the flow rate
    over time to show that it is constant.**Solution**: A `linear_volume_function(*t*)`
    has the form *V*(*t*) = *at* + *b* for the constants *a* and *b*. For instance,'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习8.5**：编写一个`linear_volume_function`并绘制流量随时间的变化图以显示它是恒定的。**解答**：一个`linear_volume_function(*t*)`的形式为
    *V*(*t*) = *at* + *b*，其中 *a* 和 *b* 是常数。例如，'
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](../Images/CH08_F11_Orland_UN02.png)This graph shows that for a linear volume
    function, the flow rate is constant over time. |'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图像](../Images/CH08_F11_Orland_UN02.png)此图显示，对于线性体积函数，流量随时间保持恒定。|'
- en: 8.3 Approximating instantaneous flow rates
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 近似瞬时流量
- en: 'As we calculate the average rate of change in our `volume` function over smaller
    and smaller time intervals, we get closer and closer to measuring what’s going
    on in a single instant. But if we try to measure the average rate of change in
    volume at a single instant, meaning an interval whose start and end times are
    the same, we run into trouble. At a time *t*, the formula for average flow rate
    would read:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们计算体积函数在越来越小的时段时间内的平均变化率，我们越来越接近测量单个瞬间的实际情况。但如果我们尝试测量单个瞬间的体积平均变化率，即起始时间和结束时间相同的区间，我们会遇到麻烦。在时间
    *t* 时，平均流量公式的读数如下：
- en: '![](../Images/CH08_F11_Orland_UN02_EQ03.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH08_F11_Orland_UN02_EQ03.png)'
- en: Dividing 0/0 is undefined, so this method doesn’t work. This is where algebra
    no longer helps us, and we need to turn to reasoning from calculus. In calculus,
    there’s an operation called the *derivative* that sidesteps this undefined division
    problem to tell you the instantaneous rate of change in a function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 0除以0是未定义的，所以这种方法不起作用。这就是代数不再帮助我们，我们需要转向微积分推理的地方。在微积分中，有一个称为**导数**的运算，它绕过这个未定义的除法问题，告诉你函数的瞬时变化率。
- en: In this section, I explain why the instantaneous flow rate function, which in
    calculus is called *the derivative* of the volume function, is well-defined and
    how to approximate it. We’ll write a function `instantaneous_flow_rate(v,t)` that
    takes a volume function *v* and a single point in time *t*, and returns an approximation
    of the instantaneous rate at which oil is flowing into the tank. This result is
    the number of barrels per hour, which should match the value of the `instantaneous_flow_rate`
    function exactly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将解释瞬时流量函数（在微积分中称为体积函数的**导数**）为何定义良好，以及如何近似它。我们将编写一个函数 `instantaneous_flow_rate(v,t)`，它接受一个体积函数
    *v* 和一个时间点 *t*，并返回油流入油罐的瞬时流量的近似值。这个结果是以每小时桶数表示的，应该与 `instantaneous_flow_rate`
    函数的值完全匹配。
- en: 'Once we do that, we’ll write a second function `get_flow_rate_function(*v*)`,
    which is the curried version of `instantaneous_flow_rate()`. Its argument is a
    volume function, and it returns a function that takes a time and returns an instantaneous
    flow rate. This function completes our first of two major objectives for this
    chapter: starting with a volume function and producing a corresponding flow rate
    function.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，我们将编写第二个函数 `get_flow_rate_function(*v*)`，它是 `instantaneous_flow_rate()`
    的柯里化版本。它的参数是一个体积函数，它返回一个函数，该函数接受一个时间并返回一个瞬时流量。这个函数完成了我们本章的两个主要目标中的第一个：从一个体积函数开始，生成相应的流量函数。
- en: 8.3.1 Finding the slope of small secant lines
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 求小割线的斜率
- en: Before we do any coding, I want to convince you that it makes sense to talk
    about an “instantaneous flow rate” in the first place. To do that, let’s zoom
    in on the volume graph around a single instant and see what’s going on (figure
    8.12). Let’s pick the point where *t* = 1 hour and look at a smaller window around
    it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行任何编码之前，我想说服你首先讨论“瞬时流量”是有意义的。为此，让我们放大单个瞬间的体积图，看看发生了什么（图8.12）。让我们选择 *t* =
    1小时的位置，并观察它周围的小窗口。
- en: '![](../Images/CH08_F12_Orland.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH08_F12_Orland.png)'
- en: Figure 8.12 Zooming in on the 1-hr window around *t* = 1 hr
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 在 *t* = 1小时附近的1小时窗口放大
- en: On this smaller time interval, we no longer see much of the curviness of the
    volume graph. That is, the steepness of the graph has less variability than on
    the whole 10-hr window. We can measure this by drawing some secant lines and seeing
    that their slopes are fairly close (figure 8.13).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个较短的时间间隔内，我们不再看到体积图曲线的很多部分。也就是说，图形的陡峭程度在整个10小时窗口中变化较小。我们可以通过绘制一些割线并观察它们的斜率相当接近（图8.13）来测量这一点。
- en: '![](../Images/CH08_F13_Orland.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH08_F13_Orland.png)'
- en: Figure 8.13 Two secant lines around *t* = 1 hr have similar slopes, meaning
    that the flow rate doesn’t change much during this time interval.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 在 *t* = 1小时附近的两个割线具有相似的斜率，这意味着在这个时间间隔内流量变化不大。
- en: If we zoom in even further, the steepness of the graph looks more and more constant.
    Zooming in to the interval between 0.9 hrs and 1.1 hrs, the volume graph is almost
    a straight line. If you draw a secant line over this interval, you can barely
    see the graph rise above the secant line (figure 8.14).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进一步放大，图表的陡峭度看起来越来越恒定。将放大到 0.9 小时和 1.1 小时之间的间隔，体积图几乎是一条直线。如果你在这段间隔上画一条割线，几乎看不到图表高于割线的上升（图8.14）。
- en: '![](../Images/CH08_F14_Orland.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F14_Orland.png)'
- en: Figure 8.14 The volume graph looks nearly straight at a smaller interval around
    *t* = 1 hr.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 在 *t* = 1 小时附近的较小时间间隔内，体积图看起来几乎是直线。
- en: Finally, if we zoom in to the window between *t* = 0.99 hrs and *t* = 1.01 hrs,
    the volume graph is indistinguishable from a straight line (figure 8.15). At this
    level, a secant line appears to overlap exactly with the graph of the function
    appearing like one line.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们放大到 *t* = 0.99 小时和 *t* = 1.01 小时之间的窗口，体积图与直线无法区分（图8.15）。在这个层面上，割线似乎与函数图完全重叠，看起来像一条线。
- en: '![](../Images/CH08_F15_Orland.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F15_Orland.png)'
- en: Figure 8.15 Zooming in even closer, the volume graph is visually indistinguishable
    from a straight line.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 进一步放大，体积图在视觉上与直线无法区分。
- en: 'If you keep zooming in, the graph continues to look like a line. It’s not that
    the graph *is* a line at this point, it’s that it gets closer and closer to looking
    like a line the closer you zoom in. The leap in reasoning that we can make in
    calculus is that there’s a single, best line approximating a smooth graph like
    the volume graph at any point. Here are a few calculations showing that the slopes
    of smaller and smaller secant lines *converge* to a single value, suggesting we
    really are approaching a single “best” approximation of the slope:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你继续放大，图表看起来会越来越像一条线。并不是图表在这个点**就是**一条线，而是当你放大时，它越来越接近看起来像一条线。在微积分中，我们可以做出的推理飞跃是，在任何一点，都有一个单一的、最佳的线来逼近像体积图这样的平滑图表。以下是一些计算，表明越来越小的割线斜率会收敛到一个单一的值，这表明我们确实正在接近斜率的单一“最佳”逼近：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Unless those zeroes are a big coincidence, the number we’re approaching is 0.421875
    bbl/hr. We can conclude that the line of best approximation for the volume function
    at the point *t* = 1 hr has a slope of 0.421875\. If we zoom out again (figure
    8.16), we can see what this line of best approximation looks like.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除非这些零点是极大的巧合，我们趋近的数字是 0.421875 bbl/hr。我们可以得出结论，在 *t* = 1 小时时体积函数的最佳逼近线的斜率为 0.421875。如果我们再次放大（图8.16），我们可以看到这条最佳逼近线的外观。
- en: '![](../Images/CH08_F16_Orland.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F16_Orland.png)'
- en: Figure 8.16 A line with slope 0.421875 is the best approximation of the volume
    function at time *t* = 1 hr.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 在时间 *t* = 1 小时时，斜率为 0.421875 的线是体积函数的最佳逼近。
- en: 'This line is called the *tangent line* to the volume graph at the point *t*
    = 1, and it’s distinguished by the fact that it lies flat against the volume graph
    at that point. Because the tangent line is the line that best approximates the
    volume graph, its slope is the best measure of the instantaneous slope of that
    graph and, therefore, the instantaneous flow rate at *t* = 1\. Lo and behold,
    the `flow_rate` function I’ve provided in the source code gives us exactly the
    same number that the smaller and smaller secant line slopes approach:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这条线被称为在点 *t* = 1 处体积图的**切线**，它之所以与众不同，是因为它在该点与体积图平行。因为切线是最佳逼近体积图的线，所以它的斜率是衡量该图瞬时斜率（即，*t*
    = 1 处的瞬时流速）的最佳指标。瞧瞧，我提供的源代码中的`flow_rate`函数给出的数字正是越来越小的割线斜率所趋近的数字：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To have a tangent line, a function needs to be “smooth.” As a mini-project at
    the end of this section, you can try repeating this exercise with a function that’s
    not smooth, and you’ll see that there’s no line of best approximation. When we
    can find a tangent line to the graph of a function at a point, its slope is called
    the *derivative of the function at the point*. For instance, the derivative of
    the volume function at the point *t* = 1 is equal to 0.421875 (barrels per hour).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要有一条切线，一个函数需要是“平滑”的。在本节末尾的迷你项目中，你可以尝试用不平滑的函数重复这个练习，你会发现没有最佳逼近线。当我们能在某一点找到函数图的切线时，该点的斜率被称为该函数的**导数**。例如，体积函数在
    *t* = 1 处的导数等于 0.421875（桶/小时）。
- en: 8.3.2 Building the instantaneous flow rate function
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 构建瞬时流速函数
- en: Now that we’ve seen how to calculate instantaneous rates of change of the volume
    function, we have what we need to implement the `instantaneous_flow_rate` function.
    There’s one major obstacle to automating the procedure we previously used, which
    is that Python can’t “eyeball” the slopes of several small secant lines and decide
    what number they’re converging to. To get around this, we can calculate slopes
    of smaller and smaller secant lines until they stabilize to some fixed number
    of decimal digits.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何计算体积函数的瞬时变化率，我们有了实现`instantaneous_flow_rate`函数所需的一切。我们之前使用的程序自动化的一个主要障碍是，Python无法“目测”几条小割线段的斜率并决定它们收敛到哪个数字。为了解决这个问题，我们可以计算越来越小的割线线段的斜率，直到它们稳定到一定的小数位数。
- en: For instance, we could have decided that we were going to find the slopes of
    a series of secant lines, each a tenth as wide as the previous, until the values
    stabilized to four decimal places. The following table shows the slopes once again.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能决定要找到一系列割线线的斜率，每一条都比前一条窄十分之一，直到数值稳定到四位小数。以下表格再次显示了斜率。
- en: '| Secant line interval | Secant line slope |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 割线线段间隔 | 割线线段斜率 |'
- en: '| 0.5 to 1.5 | 0.42578125 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 0.5 to 1.5 | 0.42578125 |'
- en: '| 0.9 to 1.1 | 0.4220312499999988 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 0.9 to 1.1 | 0.4220312499999988 |'
- en: '| 0.99 to 1.01 | 0.42187656249998945 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 0.99 to 1.01 | 0.42187656249998945 |'
- en: '| 0.999 to 1.001 | 0.42187501562509583 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 0.999 to 1.001 | 0.42187501562509583 |'
- en: In the last two rows, the slopes agree to four decimal places (they differ by
    less than 10^(−4)), so we could round the final result to 0.4219 and call that
    our result. This isn’t the exact result of 0.421875, but it’s a solid approximation
    to the specified number of digits.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两行中，斜率在四位小数上是一致的（它们之间的差异小于10^(-4)），因此我们可以将最终结果四舍五入到0.4219，并将其称为我们的结果。这并不是0.421875的确切结果，但它是对指定小数位数的良好近似。
- en: 'Fixing the number of digits of the approximation, we now have a way to know
    if we are done. If after some large number of steps, we still haven’t converged
    to the specified number of digits, we can say that there is no line of best approximation
    and, therefore, no derivative at the point. Here’s how this procedure translates
    to Python:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 固定近似数的小数位数后，我们现在有了一种方法来判断是否完成。如果在经过大量步骤之后，我们还没有收敛到指定的小数位数，我们可以认为不存在最佳近似线，因此在该点没有导数。以下是这个程序如何转换为Python代码：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ If two numbers differ by less than a tolerance of 10^(−*d*), then they agree
    to d decimal places.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果两个数字之间的差异小于10^(-*d*)的容差，则它们在d位小数上一致。
- en: ❷ Calculates a first secant line slope on an interval spanning *h* = 1 units
    on either side of the target point t
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在目标点t两侧各1个单位长度的间隔上计算第一条割线线的斜率
- en: ❸ As a crude approximation, we only try 2·digits iterations before giving up
    on the convergence.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 作为粗略近似，我们在放弃收敛之前只尝试2·digits次迭代。
- en: ❹ At each step, calculates the slope of a new secant line around the point t
    on a 10 times smaller interval
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在每一步，计算围绕点t在10倍更小间隔上的新割线线的斜率
- en: ❺ If the last two approximations differ by less than the tolerance, rounds the
    result and returns it
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果最后两个近似值之间的差异小于容差，则四舍五入结果并返回
- en: ❻ Otherwise, runs the loop again with a smaller interval
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 否则，以更小的间隔再次运行循环
- en: ❼ If we exceed the maximum number of iterations, the procedure has not converged
    to a result.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 如果我们超过了最大迭代次数，则程序没有收敛到结果。
- en: 'I arbitrarily chose six digits as the default precision, so this function matches
    our result for the instantaneous flow rate at the 1-hr mark:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我任意选择了六位数字作为默认精度，因此这个函数与我们在1小时标记处的瞬时流速结果相匹配：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can now compute the instantaneous flow rate at any point in time, which means
    we have the complete data of the flow rate function. Next, we can plot it and
    confirm it matches the `flow_rate` function I provide in the source code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以计算任何时间点的瞬时流速，这意味着我们有了流速函数的完整数据。接下来，我们可以绘制它并确认它是否与我在源代码中提供的`flow_rate`函数相匹配。
- en: 8.3.3 Currying and plotting the instantaneous flow rate function
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 对瞬时流速函数进行柯西和绘图
- en: 'For a function that behaves like the `flow_rate` function in the source code,
    taking a time variable and returning a flow rate, we need to curry the `instantaneous_flow
    _rate` function. The curried function takes a volume function (`v`) and returns
    a flow rate function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个像源代码中的`flow_rate`函数那样表现的行为，接受一个时间变量并返回一个流速，我们需要对`instantaneous_flow_rate`函数进行柯西。柯西函数接受一个体积函数（`v`）并返回一个流速函数：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of `get_flow_rate_function(*v*)` is a function that should be identical
    to the function `flow_rate` in the source code. We can plot these both over the
    10-hr period to confirm and, indeed, figure 8.17 shows that their graphs are indistinguishable:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_flow_rate_function(v*)`的输出是一个函数，它应该与源代码中的`flow_rate`函数相同。我们可以在10小时的时间段内绘制这两个函数以确认，确实，图8.17显示它们的图形无法区分：'
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![](../Images/CH08_F17_Orland.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F17_Orland.png)'
- en: Figure 8.17 Plotting the `flow_rate` function alongside the `get_flow_rate`
    function shows that the graphs are indistinguishable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 将`flow_rate`函数与`get_flow_rate`函数一起绘制，显示它们的图形无法区分。
- en: We’ve completed our first major goal of this chapter, producing the flow rate
    function from the volume function. As I mentioned at the beginning of the chapter,
    this procedure is called *taking a derivative*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了本章的第一个主要目标，从体积函数中产生了流量函数。正如我在本章开头提到的，这个过程被称为**求导**。
- en: Given a function like the `volume` function, another function giving its instantaneous
    rate of change at any given point is called its *derivative*. You can think of
    the derivative as an operation that takes one (sufficiently smooth) function and
    returns another function measuring the rate of change of the original (figure
    8.18). In this case, it would be correct to say that the flow rate function is
    the derivative of the volume function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个像“体积”函数这样的函数，另一个在任意给定点给出其瞬时变化率的函数被称为其**导数**。你可以将导数想象成一个操作，它接受一个（足够平滑的）函数并返回另一个函数，测量原始函数的变化率（图8.18）。在这种情况下，可以说流量函数是体积函数的导数。
- en: '![](../Images/CH08_F18_Orland.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F18_Orland.png)'
- en: Figure 8.18 You can think of the derivative as a machine that takes a function
    and returns another function, measuring the rate of change of the input function.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18 你可以将导数想象成一个机器，它接受一个函数并返回另一个函数，测量输入函数的变化率。
- en: 'The derivative is a general procedure that works on *any* function *f*(*x*),
    which is smooth enough to have tangent lines at every point. The derivative of
    a function *f* is written *f*'' (and reads “*f* prime”), so *f*''(*x*) means the
    instantaneous rate of change in *f* with respect to *x*. Specifically, *f*''(5)
    is the derivative of *f*(*x*) at *x* = 5, measuring the slope of a tangent line
    to *f* at *x* = 5\. There are some other common notations for the derivative of
    a function including:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 导数是一个通用的过程，它适用于任何足够平滑以在每一点都有切线的函数f(x)。函数f的导数写作f'（并读作“f的导数”），所以f'(x)表示f相对于x的瞬时变化率。具体来说，f'(5)是f(x)在x
    = 5处的导数，测量f在x = 5处的切线斜率。函数导数还有一些其他常见的表示法，包括：
- en: '![](../Images/CH08_F11_Orland_UN02_EQ03a.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F11_Orland_UN02_EQ03a.png)'
- en: The *df *and *dx* are meant to signify infinitesimal (infinitely small) changes
    in *f* and *x*, respectively, and their quotient gives the slope of an infinitesimal
    secant line. The last notation of the three is nice because it makes *d*/*dx*
    look like an operation applied to *f*(*x*). In many contexts, you’ll see standalone
    derivative operators like *d*/*dx*. This, in particular, means “the operation
    of taking the derivative with respect to *x*.” Figure 8.19 shows a schematic of
    how these notations fit together.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: df和dx分别表示f和x的无限小（无限小）变化，它们的商给出了无限小割线的斜率。这三个表示法中的最后一个很好，因为它使d/dx看起来像是对f(x)应用的操作。在许多情况下，你会看到独立的导数运算符，如d/dx。这特别意味着“对x求导的操作。”图8.19显示了这些表示法如何结合在一起。
- en: '![](../Images/CH08_F19_Orland.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F19_Orland.png)'
- en: Figure 8.19 The “derivative with respect to x” as an operation that takes a
    function and returns a new function
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 “关于x的导数”作为一个操作，它接受一个函数并返回一个新的函数
- en: We make more use of derivatives throughout the rest of this book, but for now,
    let’s turn to the counterpart operation−the integral.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将更多地使用导数，但就目前而言，让我们转向其对应操作——积分。
- en: 8.3.4 Exercises
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.4 练习
- en: '| **Exercise 8.6**: Confirm that the graph of the `volume` function is *not*
    a straight line on the interval from 0.999 hrs to 1.001 hrs.**Solution**: If it
    were a straight line, it would equal its secant line at every point. However,
    the secant line from 0.999 hrs to 1.001 hrs has a different value than the `volume`
    function at *t* = 1 hr:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习8.6**：确认“体积”函数在0.999小时到1.001小时的时间间隔内**不是**一条直线。**解答**：如果它是一条直线，那么在每一个点上它都等于其割线。然而，从0.999小时到1.001小时的割线在t
    = 1小时时的值与“体积”函数不同：'
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| **Exercise 8.7**: Approximate the slope of a tangent line to the volume graph
    at *t* = 8 by computing the slopes of smaller and smaller secant lines around
    *t* = 8.**Solution**:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习8.7**：通过计算围绕`t` = 8的越来越小的割线的斜率，来近似`t` = 8时体积图的切线斜率。**解答**：'
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It appears that the instantaneous rate of change at *t* = 8 is 0.75 bbl/hr.
    |
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来在`t` = 8时的瞬时变化率是0.75桶/小时。|
- en: '| **Exercise 8.8**: For the `sign` function defined in Python, convince yourself
    that it doesn’t have a derivative at *x* = 0:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习8.8**：对于Python中定义的`sign`函数，说服自己它在`x` = 0处没有导数：'
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Solution**: On smaller and smaller intervals, the slope of a secant line
    gets bigger and bigger rather than converging on a single number:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**解答**：在越来越小的间隔内，割线的斜率越来越大，而不是收敛到一个单一的数字：'
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is because the `sign` function jumps from −1 to 1 immediately at *x* =
    0, and it doesn’t look like a straight line when you zoom in on it. |
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`sign`函数在`x` = 0处立即从-1跳到1，当你放大查看时，它看起来并不像一条直线。|
- en: 8.4 Approximating the change in volume
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 近似体积变化
- en: 'For the rest of the chapter, I’m going to focus on our second major objective:
    starting with a known flow rate function and recovering the volume function. This
    is the reverse of the process of finding a derivative because we assume we know
    the rate of change of a function, and we want to recover the original function.
    In calculus, this is called *integration*.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我将专注于我们的第二个主要目标：从一个已知的流量函数中恢复体积函数。这是求导过程的逆过程，因为我们假设我们知道函数的变化率，我们想要恢复原始函数。在微积分中，这被称为**积分**。
- en: I’ll break the task of recovering the volume function into a few smaller examples,
    which will help you get a sense of how integration works. For the first example,
    we write two Python functions to help us find the change in volume in the tank
    over a specified period of time.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我会将恢复体积函数的任务分解成几个更小的例子，这将帮助你了解积分是如何工作的。对于第一个例子，我们编写两个Python函数来帮助我们找到在指定时间段内油箱中的体积变化。
- en: We call the first function `brief_volume_change(q,t,dt)`, taking a flow rate
    function `q`, a time `t`, and a short time duration `dt`, which returns the approximate
    change in volume from time *t* to time *t* + *dt*. This function calculates its
    result by assuming the time interval is so short that the flow rate does not change
    by much.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称第一个函数为`brief_volume_change(q,t,dt)`，它接受一个流量函数`q`，一个时间`t`，以及一个短的时间持续时间`dt`，该函数返回从时间`t`到时间`t
    + dt`的体积变化的近似值。这个函数通过假设时间间隔非常短，流量变化不大来计算其结果。
- en: We call the second function `volume_change(q,t1,t2,dt)` and, as the difference
    in naming suggests, we use it to calculate the volume change on any time interval,
    not just a brief one. Its arguments are the flow rate function `q`, a start time
    `t1`, an end time `t2`, and a small time interval `dt`. The function breaks the
    time interval down into increments of duration `dt`, which are short enough to
    use the `brief_volume _change` function. The total volume change returned is the
    sum of all of the volume changes on the short time intervals.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称第二个函数为`volume_change(q,t1,t2,dt)`，正如命名上的差异所暗示的，我们用它来计算任何时间间隔的体积变化，而不仅仅是短暂的时间间隔。它的参数是流量函数`q`，一个起始时间`t1`，一个结束时间`t2`，以及一个小的时间间隔`dt`。该函数将时间间隔分解为持续时间`dt`的增量，这些增量足够短，可以使用`brief_volume_change`函数。返回的总体积变化是所有短时间间隔体积变化的总和。
- en: 8.4.1 Finding the change in volume for a short time interval
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 在短时间间隔内寻找体积变化
- en: To understand the rationale behind the `brief_volume_change` function, let’s
    return to the familiar example of a speedometer on a car. If you glance at your
    speedometer and it reads exactly 60 mph, you might predict that in the next 2
    hrs, you’ll travel 120 miles, which is 2 hrs times 60 mph. That estimate could
    be correct if you’re lucky, but it’s also possible that the speed limit increases
    or that you exit the freeway and park the car. The point is, one glance at a speedometer
    won’t help you estimate the distance traveled over a long period.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解`brief_volume_change`函数背后的原理，让我们回到熟悉的汽车速度表例子。如果你瞥了一眼速度表，它显示正好是60英里/小时，你可能会预测在接下来的2小时内，你会行驶120英里，这是2小时乘以60英里/小时。如果你运气好，这个估计可能是正确的，但也有可能速度限制提高了，或者你离开了高速公路并停车。关键是，仅仅看一眼速度表并不能帮助你估计长时间内的行驶距离。
- en: On the other hand, if you used the value of 60 mph to calculate how far you
    traveled in a single *second* after looking at the speedometer, you’d probably
    get a very accurate answer; your speed is not going to change that much over a
    single second. A second is 1/3,600 of an hour, so 60 mph times 1/3,600 per hour
    gives you 1/60 of a mile, or 88 feet. Unless you’re actively slamming on the brakes
    or flooring the gas pedal, this is probably a good estimate.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你使用60英里/小时的速度来计算你在查看速度表后单秒内行驶的距离，你可能会得到一个非常准确的答案；你的速度在一秒内不会变化太多。一秒是小时的1/3600，所以60英里/小时乘以每小时的1/3600给你1/60英里，或88英尺。除非你正在积极地踩刹车或油门到底，这很可能是一个好的估计。
- en: 'Returning to flow rates and volumes, let’s assume that we’re working with a
    short enough duration that the flow rate is roughly constant. In other words,
    the flow rate on the time interval is close to the average flow rate on the time
    interval, so we can apply our original equation:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到流速和体积，假设我们正在处理一个足够短的时间段，使得流速大致恒定。换句话说，时间间隔内的流速接近时间间隔内的平均流速，因此我们可以应用我们的原始方程：
- en: '![](../Images/CH08_F19_Orland_EQ05.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F19_Orland_EQ05.png)'
- en: 'Rearranging this equation, we can get an approximation for the change in volume:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 重新排列这个方程，我们可以得到体积变化的近似：
- en: '![](../Images/CH08_F19_Orland_EQ06.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F19_Orland_EQ06.png)'
- en: 'Our `small_volume_change` function is just a translation of this assumed formula
    into Python code. Given a flow rate function `q`, we can find the flow rate at
    the input time `t` as `q(*t*)`, and we just need to multiply it by the duration
    `dt` to get the change in volume:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`small_volume_change`函数只是将这个假设公式翻译成Python代码。给定一个流速函数`q`，我们可以找到输入时间`t`的流速为`q(*t*)`，我们只需要将其乘以持续时间`dt`以得到体积的变化：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Because we have an actual pair of volume and flow rate functions, we can now
    test how good our approximation is. As expected, the prediction is not great for
    a whole hour interval:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们现在有一对实际的体积和流速函数，我们可以现在测试我们的近似有多好。正如预期的那样，对于整个小时的间隔，预测并不太好：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'That approximation is off by about 70%. By comparison, we get a great approximation
    on a time interval of 0.01 hrs. The result is within 1% of the actual volume change:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个近似值偏差大约70%。相比之下，我们在0.01小时的时间间隔上得到了很好的近似。结果是实际体积变化的1%以内：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Because we can get good approximations for the volume change on small time intervals,
    we can piece them together to get the volume change on a longer interval.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们可以得到小时间间隔内体积变化的良好近似，我们可以将它们拼接起来以得到较长时间间隔的体积变化。
- en: 8.4.2 Breaking up time into smaller intervals
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2 将时间分成更小的间隔
- en: To implement the function `volume_change(q,t1,t2,dt)`, we split the time from
    `t1` to `t2` into intervals of duration `dt`. For simplicity, we’ll only handle
    values of `dt` that evenly divide `t2` - `t1` so that we break the time period
    into a whole number of intervals.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现函数`volume_change(q,t1,t2,dt)`，我们将从`t1`到`t2`的时间分成持续时间为`dt`的间隔。为了简单起见，我们只会处理可以均匀除尽`t2`
    - `t1`的`dt`值，这样我们就可以将时间周期分成整数的间隔。
- en: 'Once again, we can use the NumPy `arange` function to get the starting time
    for each of the intervals. The function call `np.arange(t1,t2,dt)` gives us an
    array of times from `t1` to `t2` in increments of `dt`. For each time value `t`
    in this array, we can find the volume change in the ensuing time interval using
    `small_volume_change`. Finally, we need to sum the results to get the total volume
    change over all of the intervals. This can be done in roughly one line:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以使用NumPy的`arange`函数来获取每个间隔的起始时间。函数调用`np.arange(t1,t2,dt)`给我们一个从`t1`到`t2`，以`dt`为增量的时间数组。对于这个数组中的每个时间值`t`，我们可以使用`small_volume_change`找到随后时间间隔的体积变化。最后，我们需要将结果相加以得到所有间隔的总体积变化。这可以在大约一行代码中完成：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With this function, we can break up the time from 0 to 10 hrs into 100 time
    intervals of duration 0.1 hrs and sum the volume changes during each. The result
    matches the actual volume change to one decimal place:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，我们可以将0到10小时的时间分成100个持续时间为0.1小时的时间间隔，并计算每个时间间隔内的体积变化。结果与实际体积变化匹配到小数点后一位：
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we break the time into smaller and smaller intervals, the results get better
    and better. For instance:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将时间分成越来越小的间隔，结果会越来越好。例如：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As with the process of taking a derivative, we can make the intervals smaller
    and smaller, and our results will converge to the expected answer. Calculating
    the overall change in a function on some interval from its rate of change is called
    a *definite integral*. We’ll return to the definition of the definite integral
    in the last section, but for now, let’s focus on how to picture it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 就像求导的过程一样，我们可以使间隔越来越小，我们的结果将收敛到预期的答案。从某个区间内的变化率计算函数的整体变化被称为**定积分**。我们将在最后一节回到定积分的定义，但现在是时候关注如何描绘它了。
- en: 8.4.3 Picturing the volume change on the flow rate graph
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.3 在流量图上描绘体积变化
- en: 'Suppose we’re breaking the 10-hr period into 1-hr intervals, even though we
    know this won’t give us very accurate results. The only 10 points on the flow
    rate graph we care about are the beginning times of each interval: 0 hrs, 1 hrs,
    2 hrs, 3 hrs, and so on, up to 9 hrs. Figure 8.20 shows these points marked on
    a graph.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将10小时的时间段划分为1小时的间隔，即使我们知道这不会给我们非常准确的结果。我们唯一关心的流量图上的10个点，是每个间隔的开始时间：0小时，1小时，2小时，3小时，以此类推，直到9小时。图8.20显示了这些点在图上的标记。
- en: '![](../Images/CH08_F20_Orland.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F20_Orland.png)'
- en: Figure 8.20 Plotting the points used to calculate `volume_change(flow_rate,0,10,1)`
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20 绘制用于计算`volume_change(flow_rate,0,10,1)`的点
- en: Our calculation assumed the flow rates in each of the intervals remained constant,
    which is clearly not the case. Within each of these intervals, the flow rate visibly
    changes. In our assumption, it’s as if we’re working with a different flow rate
    function, whose graph is constant during every hour. Figure 8.21 shows what these
    intervals look like next to the original.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算假设每个间隔内的流量保持恒定，这显然是不正确的。在每个这样的间隔内，流量明显是变化的。在我们的假设中，这就像我们正在使用一个不同的流量函数，其图形在每小时都是恒定的。图8.21显示了这些间隔与原始图形并排的样子。
- en: '![](../Images/CH08_F21_Orland.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F21_Orland.png)'
- en: Figure 8.21 If we assumed flow rate were constant on each interval, its graph
    would look like a staircase going down and back up.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 如果我们假设每个间隔内的流量是恒定的，其图形将看起来像一座上下起伏的楼梯。
- en: In each interval, we calculate the flow rate (which is the height of each flat
    graph segment) times the elapsed time of 1 hr (which is the width of each graph
    segment). Each small volume we calculate is a height multiplied by a width on
    the graph, or the area of an imaginary rectangle. Figure 8.22 shows the rectangles
    filled in.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个间隔内，我们计算流量（即每个平坦图形段的高度）乘以1小时的经过时间（即每个图形段的宽度）。我们计算出的每个小体积是图上的高度乘以宽度，或者是一个想象中的矩形的面积。图8.22显示了填充的矩形。
- en: '![](../Images/CH08_F22_Orland.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F22_Orland.png)'
- en: Figure 8.22 The overall change in volume as a sum of the areas of 10 rectangles
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 体积的整体变化是10个矩形面积的累加
- en: '![](../Images/CH08_F23_Orland.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F23_Orland.png)'
- en: Figure 8.23 The volume as a sum of the area of 30 rectangles (top) or 100 rectangles
    (bottom) under the flow rate graph (figure 8.20)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23 流量图下方的体积是30个矩形面积（顶部）或100个矩形面积（底部）的累加
- en: As we shorten the time intervals, we see our results improve. Visually, that
    corresponds with more rectangles that can hug the graph more closely. Figure 8.23
    shows what the rectangles look like using 30 intervals of 1/3 hrs (20 mins) each,
    or 100 intervals of 0.1 hrs each.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间间隔的缩短，我们看到我们的结果在改善。直观上看，这对应着更多的矩形可以更紧密地贴合图形。图8.23显示了使用30个1/3小时（20分钟）的间隔或100个0.1小时间隔的矩形的样子。
- en: From these pictures, you can see that as our intervals get smaller and our computed
    result approaches the actual change in volume, the rectangles come closer and
    closer to filling the space under the flow rate graph. The insight here is that
    the area under the flow rate graph on a given time interval *is (approximately)
    equal to* the volume added to the tank on the same interval.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些图片中，你可以看到，随着我们的间隔变小，我们的计算结果接近实际的体积变化，矩形越来越接近填充流量图下方的空间。这里的见解是，在给定时间间隔下流量图下方的面积（近似地）等于同一时间间隔内添加到水箱中的体积。
- en: A sum of the areas of rectangles approximating the area under a graph is called
    a *Riemann sum*. Riemann sums made of skinnier and skinnier rectangles converge
    to the area under a graph, much the same way as slopes of smaller and smaller
    secant lines converge to the slope of a tangent line. We’ll return to the convergence
    of Riemann sums and definite integrals, but first let’s make some more progress
    toward finding the volume over time.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 将近似图形下方的矩形面积之和称为**黎曼和**。由越来越瘦的矩形组成的黎曼和收敛到图形下的面积，这与越来越小的割线斜率收敛到切线斜率的方式非常相似。我们将回到黎曼和与定积分的收敛性，但首先让我们在找到随时间变化的体积方面取得更多进展。
- en: 8.4.4 Exercises
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.4 练习
- en: '| **Exercise 8.9**: Approximately how much oil is added to the tank in the
    first 6 hrs? In the last 4 hrs? During which time interval is more added?**Solution**:
    In the first 6 hrs, about 1.13 bbls of oil are pumped into the tank, which is
    less than the roughly 3.24 bbls pumped into the tank in the last 4 hrs:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习8.9**：在前6小时内大约向油罐中添加了多少油？在最后4小时内？在哪个时间段添加的更多？**解答**：在前6小时内，大约有1.13桶油被泵入油罐，这比在最后4小时内泵入油罐的大约3.24桶油要少：'
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 8.5 Plotting the volume over time
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 随时间绘制体积
- en: In the previous section, we were able to start with the flow rate and come up
    with approximations for the *change* in volume over a given time interval. Our
    main goal is to come up with the *total* volume in the tank at any given point
    in time.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们能够从流速开始，对给定时间间隔内的体积变化进行近似。我们的主要目标是得到任何给定时间点的油罐**总**体积。
- en: 'Here’s a trick question for you: if oil flows into the tank at a constant rate
    of 1.2 bbl/hr for 3 hrs, how much oil is in the tank after 3 hrs? The answer is:
    we don’t know because I didn’t tell you how much was in the tank to begin with!
    Fortunately, if I tell you, then the answer is easy to figure out. For instance,
    if 0.5 bbls were in the tank to begin with, then 3.6 bbls were added during this
    period, and 0.5 + 3.6 = 4.1 bbls are in the tank at the end of the 3-hr period.
    Adding the initial volume at time zero to the change in volume to any time *T*,
    we can find the total volume at time *T*.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个技巧问题：如果油以每小时1.2桶的恒定速率流入油罐3小时，3小时后油罐中有多少油？答案是：我们不知道，因为我没有告诉你最初油罐中有多少油！幸运的是，如果告诉我，那么答案就很容易找出。例如，如果最初油罐中有0.5桶油，那么在这段时间内添加了3.6桶油，0.5
    + 3.6 = 4.1桶油在3小时结束时在油罐中。将时间零的初始体积加到任何时间*T*的体积变化上，我们可以找到时间*T*的总体积。
- en: In our last examples for this section, we turn this idea into code to reconstruct
    a volume function. We implement a function called `approximate_volume(q,v0, dt,T)`,
    which takes a flow rate `q`, an initial volume of oil in the tank `v0`, a small
    time interval `dt`, and a time `T` in question. The output of the function is
    an approximation of the total volume in the tank at time `T`, by adding the starting
    volume `v0` to the change in volume from time zero to time `T`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后几个例子中，我们将这个想法转化为代码来重建体积函数。我们实现了一个名为`approximate_volume(q,v0, dt,T)`的函数，它接受一个流速`q`，油罐中初始的油体积`v0`，一个小的时间间隔`dt`，以及一个需要的时间`T`。该函数的输出是时间`T`时油罐中总体积的近似值，通过将起始体积`v0`加到从时间零到时间`T`的体积变化上。
- en: Once we do that, we can curry it to get a function called `approximate_volume
    _function(q,v0,dt)`, which produces a function giving the approximate volume as
    a function of time. The function returned by `approximate_volume_function` is
    a volume function we can plot alongside our original volume function for comparison.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们做到了这一点，我们就可以通过它得到一个名为`approximate_volume_function(q,v0,dt)`的函数，该函数产生一个作为时间函数的近似体积。`approximate_volume_function`返回的函数是我们可以在与原始体积函数进行比较时绘制的体积函数。
- en: 8.5.1 Finding the volume over time
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.1 随时间找到体积
- en: 'The basic formula we’ll use is as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的公式如下：
- en: volume at time *T* = (volume at time 0) + (change in volume from time 0 to time
    *T*)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 时间*T*的体积 = (时间0的体积) + (从时间0到时间*T*的体积变化)
- en: 'We need to provide the first term of the sum, the volume in the tank at time
    zero, because there’s no way to infer it from the flow rate function. Then we
    can use our `volume_change` function to find the volume from time zero to time
    *T*. Here’s what the implementation looks like:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供求和的第一个项，即时间零时的罐内体积，因为没有方法可以从流速函数中推断它。然后我们可以使用我们的`volume_change`函数来找到从时间零到时间*T*的体积。下面是实现的示例：
- en: '[PRE29]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To curry this function, we can define a new function taking the first three
    arguments as parameters and returning a new function that takes the last parameter,
    `T` :'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算这个函数，我们可以定义一个新的函数，它将前三个参数作为参数，并返回一个新的函数，该函数接受最后一个参数`T`：
- en: '[PRE30]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This function directly produces a plottable volume function from our `flow_rate`
    function. Because the `volume` function I provide in the source code has `volume(0)`
    equal to 2.3, let’s use that value for `v0`. Finally, let’s try a `dt` value of
    0.5, meaning we’re calculating our changes in volume in half-hour (30 mins) intervals.
    Let’s see how this looks plotted against the original volume function (figure
    8.24):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数直接从我们的`flow_rate`函数生成一个可绘制的体积函数。因为我在源代码中提供的`volume`函数的`volume(0)`等于2.3，所以让我们用这个值作为`v0`。最后，让我们尝试一个`dt`值为0.5，这意味着我们以半小时（30分钟）的间隔计算体积变化。让我们看看这与原始体积函数（图8.24）的对比效果：
- en: '[PRE31]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![](../Images/CH08_F24_Orland.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F24_Orland.png)'
- en: Figure 8.24 A plot of the output of `approximate _volume_function`(jagged line)
    alongside the original `volume` function (smooth line)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24 `approximate_volume_function`（锯齿线）与原始`volume`函数（平滑线）的输出对比图
- en: The good news is that the output is pretty close to our original volume function!
    But the result produced by `approximate_volume_function` is jagged, having steps
    every 0.5 hrs. You might guess that this has to do with our `dt` value of 0.5
    and that we’ll get a better approximation if we reduce this value. This is correct,
    but let’s dig in to how the volume change is computed to see exactly why the graph
    looks like this, and why a smaller time interval will improve it.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，输出非常接近我们的原始体积函数！但是`approximate_volume_function`产生的结果是锯齿状的，每隔0.5小时有一个步骤。你可能猜测这与我们的`dt`值0.5有关，如果我们减小这个值，我们会得到更好的近似。这是正确的，但让我们深入了解体积变化是如何计算的，以确切地了解为什么图表看起来是这样的，以及为什么更小的时间间隔会改善它。
- en: 8.5.2 Picturing Riemann sums for the volume function
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.2 体积函数的黎曼和图示
- en: 'At any point in time, the volume in the tank computed by our approximate `volume`
    function is the sum of the initial volume in the tank plus the change in volume
    to that point. For *t* = 4 hrs, the equation looks like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时间点，我们通过近似`volume`函数计算的罐中体积是初始罐中体积加上到该点的体积变化。对于`t` = 4小时，方程看起来是这样的：
- en: volume at 4 hrs = (volume at 0 hrs) + (change in volume from 0 hr to 4 hrs)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 4小时时的体积 = （0小时时的体积）+ （从0小时到4小时的体积变化）
- en: The result of this sum gives us one point on the graph at the 4-hr mark. The
    value at any other time is computed the same way. In this case, the sum consists
    of the 2.3 bbls at time zero plus a Riemann sum, giving us the change from 0 hrs
    to 4 hrs. This is the sum of eight rectangles, each having a width of 0.5 hrs,
    which fit evenly into the 4-hr window. The result is approximately 3.5 bbls (figure
    8.25).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个和的结果给我们提供了图表上4小时标记的一个点。任何其他时间的值都是用相同的方式计算的。在这种情况下，和包括时间零点的2.3桶，以及一个黎曼和，给出了从0小时到4小时的变化。这是八个矩形的和，每个矩形的宽度为0.5小时，它们均匀地分布在4小时的窗口内。结果是大约3.5桶（图8.25）。
- en: '![](../Images/CH08_F25_Orland.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F25_Orland.png)'
- en: Figure 8.25 The volume in the tank at 4 hrs using a Riemann sum
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25 使用黎曼和计算4小时时罐中的体积
- en: We could do the same thing for any other point in time. For example, figure
    8.26 shows the result for 8 hrs in.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为任何其他时间点做同样的事情。例如，图8.26显示了8小时的结果。
- en: '![](../Images/CH08_F26_Orland.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F26_Orland.png)'
- en: Figure 8.26 The volume in the tank at 8 hrs using a Riemann sum
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.26 使用黎曼和计算8小时时罐中的体积
- en: 'In this case, the answer is approximately 4.32 bbls in the tank at the 8-hr
    mark. This required summing 8/0.5 = 16 rectangle areas. These two values show
    up as points on the graph we produced (figure 8.27):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，答案是8小时标记时罐中大约4.32桶。这需要求和8/0.5 = 16个矩形面积。这两个值出现在我们生成的图表上（图8.27）的点：
- en: '![](../Images/CH08_F27_Orland.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F27_Orland.png)'
- en: Figure 8.27 The two previous results shown on the approximate volume graph
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.27 在近似体积图上显示的前两个结果
- en: In both of these cases, we could get from zero to the point in time in question
    using a whole number of timesteps. To produce this graph, our Python code computes
    a lot of Riemann sums, corresponding to whole number hours and half hours, as
    well as all the points plotted in between.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们可以通过使用整数的timesteps从零到问题中的时间点。为了生成这个图表，我们的Python代码计算了大量的黎曼和，对应于整数小时和半小时，以及所有绘制在之间的点。
- en: 'How does our code get the approximate volume at 3.9 hrs, which isn’t divisible
    by the *dt* value of 0.5 hrs? Looking back at the implementation of `volume_change
    (q,t1,t2,dt)`, we made one small change in the volume calculation, corresponding
    to the area of one rectangle for every start time in `np.arange(t1,t2,dt)`. When
    we find the volume change from 0 to 3.9 hrs with a *dt* of 0.5, our rectangles
    are given by:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何得到 3.9 小时的近似体积，这个值不能被 0.5 小时的 *dt* 值整除？回顾 `volume_change(q,t1,t2,dt)` 的实现，我们在体积计算中做了一点点改变，对应于
    `np.arange(t1,t2,dt)` 中每个起始时间的一个矩形的面积。当我们用 0.5 的 *dt* 值从 0 到 3.9 小时计算体积变化时，我们的矩形如下所示：
- en: '[PRE32]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Even though the eight rectangles of width 0.5 hr go past the 3.9-hr mark, we
    calculate the area of all eight! To be completely clean, we should have probably
    shortened our last time interval to 0.4 hrs, lasting from the end of the 7th time
    interval at 3.5 hrs to the end time of 3.9 hrs, and no further. As a mini-project
    at the end of this section, you can try updating the `volume_change` function
    to use a smaller duration for the last time interval, if necessary. For now, I’ll
    ignore this oversight.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管宽度为 0.5 小时的八个矩形超过了 3.9 小时的标记，我们计算了所有八个矩形的面积！为了完全干净，我们可能应该缩短最后一个时间间隔到 0.4 小时，从第
    7 个时间间隔的结束时间 3.5 小时持续到 3.9 小时的结束时间，不再继续。作为一个本节末尾的小型项目，你可以尝试更新 `volume_change`
    函数，如果需要的话，使用更短的时间间隔。现在，我将忽略这个疏忽。
- en: In the last section, we saw that we got better results by shrinking the *dt*
    value and, therefore, the widths of the rectangles. In addition to fitting the
    graph better, smaller rectangles are likely to have less error even if they slightly
    overshoot the end of a time interval. For instance, while 0.5-hr intervals can
    only add up to 3.5 hrs or 4.0 hrs but not 3.9 hrs, 0.1-hr intervals can add up
    evenly to 3.9 hrs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了通过缩小 *dt* 值以及因此矩形的宽度，我们得到了更好的结果。除了更好地拟合图表外，较小的矩形即使略微超出时间间隔的末端，也可能会产生更少的误差。例如，0.5
    小时的时间间隔只能累计到 3.5 小时或 4.0 小时，但不能累计到 3.9 小时，而 0.1 小时的时间间隔可以均匀累计到 3.9 小时。
- en: 8.5.3 Improving the approximation
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.3 改进近似
- en: 'Let’s try using smaller values of *dt*, corresponding to smaller rectangle
    sizes, and see the improvements we get. Here’s the approximation with `dt` = 0.1
    hrs (figure 8.28 plots the results). The steps on the graph are barely visible,
    but they are smaller, and the graph stays closer to the actual volume graph than
    it did with 0.5-hr intervals:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用更小的 *dt* 值，对应于更小的矩形尺寸，并看看我们得到的改进。这是 `dt` = 0.1 小时的近似（图 8.28 展示了结果）。图表上的步骤几乎看不见，但它们更小，并且图表比
    0.5 小时的时间间隔更接近实际的体积图表：
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![](../Images/CH08_F28_Orland.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F28_Orland.png)'
- en: Figure 8.28 With dt = 0.1 hr, the graphs nearly match.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.28 当 `dt` = 0.1 小时时，图表几乎吻合。
- en: 'With even smaller timesteps, like `dt` =0.01 hrs, the graphs are nearly indistinguishable
    (figure 8.29):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更小的步长，例如 `dt` = 0.01 小时，图表几乎无法区分（见图 8.29）：
- en: '[PRE34]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Even though the graphs appear to match exactly, we can ask the question of how
    accurate is this approximation. The graphs of the approximate `volume` functions
    with smaller and smaller values of `dt` get closer and closer to the actual volume
    graph at every point, so we could say the values are *converging* to the actual
    volume values. But at each step, the approximation still might disagree with the
    actual volume measurement.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管图表看起来完全匹配，但我们仍然可以问这个近似有多准确。随着 `dt` 值越来越小，近似 `体积` 函数的图表在每一个点都越来越接近实际的体积图表，因此我们可以说这些值正在
    *收敛* 到实际的体积值。但在每一步，近似仍然可能与实际的体积测量值不一致。
- en: '![](../Images/CH08_F29_Orland.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F29_Orland.png)'
- en: Figure 8.29 With 0.01-hr timesteps, the graph of the approximate `volume` function
    is indistinguishable from the actual `volume` function.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.29 当时间步长为 0.01 小时时，近似 `体积` 函数的图表与实际 `体积` 函数几乎无法区分。
- en: 'Here’s a way we could find the volume at any point to an arbitrary precision
    (within any tolerance we want). For any point `t` in time, we can recalculate
    `volume_change(q,0,t,dt)` with smaller and smaller values of `dt` until the outputs
    stop changing by more than the tolerance value. This looks a lot like our function
    to make repeated approximations of the derivative until they stabilize:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一种方法，我们可以找到任意点的体积，达到任意精度（在任意我们想要的公差范围内）。对于时间点 `t`，我们可以通过使用越来越小的 `dt` 值重新计算
    `volume_change(q,0,t,dt)`，直到输出停止变化超过公差值。这很像我们用来重复近似导数直到它们稳定下来的函数：
- en: '[PRE35]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For instance, the volume *v*(1) is exactly 2.878125 bbls, and we can ask for
    any precision estimation of this result that we want. For example, for three digits,
    we get
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，体积 *v*(1) 精确为 2.878125 桶，我们可以要求任何精度的结果。例如，对于三位数字，我们得到
- en: '[PRE36]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'and for six digits, we get the exact answer:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对于六位数字，我们得到精确答案：
- en: '[PRE37]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you run this code yourself, you’ll see the second computation takes quite
    a while. This is because it has to run a Riemann sum consisting of millions of
    small volume changes to get the answer to this precision. There’s probably no
    realistic use for this function, which computes volume values to an arbitrary
    precision, but it illustrates the point that with smaller and smaller *dt* values,
    our volume approximation *converges* to the exact value of the `volume` function.
    The result it is converging to is called the *integral* of the flow rate.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你亲自运行这段代码，你会看到第二次计算花费了相当长的时间。这是因为它必须运行包含数百万个小体积变化的黎曼和，以得到这个精确度的答案。这个函数计算任意精度的体积值可能没有实际用途，但它说明了随着
    *dt* 值越来越小，我们的体积近似值会**收敛**到 `volume` 函数的精确值。它收敛到的结果被称为流速的**积分**。
- en: 8.5.4 Definite and indefinite integrals
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.4 定积分与不定积分
- en: 'In the last two sections, we *integrated* the flow rate function to obtain
    the volume function. Like taking a derivative, finding an integral is a general
    procedure that you can do with functions. We can integrate any function specifying
    a rate of change to get a function giving a compatible, cumulative value. If we
    know the speed of a car as a function of time, for example, we can integrate it
    to get the distance traveled as a function of time. In this section, we look at
    two types of integrals: definite integrals and indefinite integrals.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两节中，我们**积分**了流速函数以获得体积函数。就像求导数一样，求积分是一个通用的步骤，你可以对函数进行操作。我们可以对任何指定变化率的函数进行积分，以得到一个提供兼容累积值的函数。例如，如果我们知道汽车的速度是时间的函数，我们可以对其进行积分，以得到随时间变化的行驶距离。在本节中，我们将探讨两种类型的积分：定积分和不定积分。
- en: A *definite integral* tells you the total change in a function on some interval
    from its derivative function. The function and a pair of start and end values
    for the argument, which in our case is time, specify the definite integral. The
    output is a single number, which gives the cumulative change. For instance, if
    *f*(*x*) is our function of interest and *f*'(*x*) is the derivative of *f*(*x*),
    then the change in *f* from *x* = *a* to *x* = *b* is *f*(*b*) − *f*(*a*), and
    it can be found by taking a definite integral (figure 8.30).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**定积分**告诉你函数在某个区间上的总变化，这个区间是从其导数函数得到的。函数和参数的起始和结束值对，在我们的例子中是时间，指定了定积分。输出是一个单一的数字，它给出了累积变化。例如，如果
    *f*(*x*) 是我们感兴趣的功能，而 *f*''(*x*) 是 *f*(*x*) 的导数，那么 *f* 从 *x* = *a* 到 *x* = *b*
    的变化是 *f*(*b*) − *f*(*a*)，并且可以通过取定积分（图8.30）来找到。'
- en: '![](../Images/CH08_F30_Orland.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F30_Orland.png)'
- en: Figure 8.30 The definite integral takes the rate of change (derivative) of a
    function and a specified interval and recovers the cumulative change in the function
    on that interval.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.30 定积分取函数的速率变化（导数）和指定的区间，并恢复该区间上函数的累积变化。
- en: 'In calculus, the definite integral of *f*(*x*) from *x* = *a* to *x* = *b*
    is written like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在微积分中，从 *x* = *a* 到 *x* = *b* 的 *f*(*x*) 的定积分写作如下：
- en: '![](../Images/CH08_F30_Orland_EQ07.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH08_F30_Orland_EQ07.png)'
- en: and its value is *f*(*b*) − *f*(*a*). The big ʃ symbol is the integral symbol,
    *a* and *b* are called the *bounds of integration, f*'(*x*) is the function being
    integrated, and *dx* indicates that the integral is being taken with respect to
    *x*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 其值为 *f*(*b*) − *f*(*a*)。大写的积分符号 ʃ 是积分符号，*a* 和 *b* 被称为积分的**界限**，f*'(*x*) 是被积函数，而
    *dx* 表示积分是相对于 *x* 进行的。
- en: Our `volume_change` function approximates definite integrals, and as we saw
    in section 8.4.3, it also approximates the area under the flow rate graph. It
    turns out that the definite integral of a function on an interval is equal to
    the area under the rate graph on that interval. For most rate functions you meet
    in the wild, the graphs will be nice enough that you can approximate the area
    underneath them with skinnier and skinnier rectangles, and your approximations
    will converge to a single value.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `volume_change` 函数近似定积分，正如我们在第8.4.3节中看到的，它也近似流速图下的面积。结果证明，函数在区间上的定积分等于该区间速率图下的面积。对于你在野外遇到的多数速率函数，图形将足够好，你可以用越来越瘦的矩形来近似它们下面的面积，并且你的近似值会收敛到一个单一的值。
- en: After taking a definite integral, let’s look at an indefinite integral. The
    *indefinite integral* takes the derivative of a function and recovers the original
    function. For instance, if you know that *f*(*x*) is the derivative of *f*(*x*),
    then to reconstruct *f*(*x*), you have to find the indefinite integral of *f*(*x*).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算定积分之后，让我们看看不定积分。*不定积分*取函数的导数并恢复原始函数。例如，如果你知道 *f*(*x*) 是 *f*(*x*) 的导数，那么为了重建
    *f*(*x*)，你必须找到 *f*(*x*) 的不定积分。
- en: The catch is that the derivative *f*(*x*) on its own is not enough to reconstruct
    the original function *f*(*x*). As we saw with `get_volume_function`, which computed
    a definite integral, you need to know an initial value of *f*(*x*), like *f*(0)
    for instance. The value of *f*(*x*) can then be found by adding a definite integral
    to *f*(0). Because
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题是，导数 *f*(*x*) 单独不足以重建原始函数 *f*(*x*)。正如我们在 `get_volume_function` 中看到的那样，它计算了一个定积分，你需要知道
    *f*(*x*) 的初始值，例如 *f*(0)。然后可以通过将定积分加到 *f*(0) 上来找到 *f*(*x*) 的值。因为
- en: '![](../Images/CH08_F30_Orland_EQ08.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F30_Orland_EQ08.png)'
- en: 'we can get any value of *f*(*x*) as:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以得到 *f*(*x*) 的任何值：
- en: '![](../Images/CH08_F30_Orland_EQ09.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F30_Orland_EQ09.png)'
- en: Note we have to use a different name *t* for the argument of *f* because *x*
    becomes a bound of integration here. The indefinite integral of a function *f*(*x*)
    is written as
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们必须为 *f* 的自变量使用不同的名字 *t*，因为在这里 *x* 成为了积分的界限。函数 *f*(*x*) 的不定积分写作
- en: '![](../Images/CH08_F30_Orland_EQ10.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F30_Orland_EQ10.png)'
- en: which looks like a definite integral but without specified bounds. If, for example,
    *g*(*x*) = ʃ *f*(*x*) *dx*, then *g*(*x*) is said to be an *antiderivative* of
    *f*(*x*). Antiderivatives are not unique, and in fact, there is a different function
    *g*(*x*) whose derivative is *f*(*x*) for any initial value *g*(0) that you choose.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一个定积分，但没有指定界限。例如，如果 *g*(*x*) = ʃ *f*(*x*) *dx*，那么 *g*(*x*) 被称为 *f*(*x*)
    的*反导数*。反导数不是唯一的，实际上，对于你选择的任何初始值 *g*(0)，都有一个不同的函数 *g*(*x*)，其导数是 *f*(*x*)。
- en: This is a lot of terminology to absorb in a short time, but fortunately, we
    spend the rest of the second part of this book reviewing it. We’ll continue to
    work with functions and their rates of change using derivatives and integrals
    to switch between them interchangeably.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在短时间内吸收这么多术语确实很多，但幸运的是，我们在这本书的第二部分剩余部分会回顾它们。我们将继续使用导数和积分在它们之间相互切换，来处理函数及其变化率。
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: The average rate of change in a function, say *f*(*x*), is the change in the
    value of *f* on some *x* interval divided by the length of the interval. For instance,
    the average rate of change in *f*(*x*) from *x* = *a* to *x* = *b* is
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的平均变化率，比如 *f*(*x*)，是 *f* 在某个 *x* 间隔上的值的变化除以间隔的长度。例如，从 *x* = *a* 到 *x* = *b*
    的 *f*(*x*) 的平均变化率是
- en: '![](../Images/CH08_F30_Orland_EQ11.png)'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](../Images/CH08_F30_Orland_EQ11.png)'
- en: The average rate of change in a function can be pictured as the steepness of
    a *secant line*, a line passing through the graph of the function at two points.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的平均变化率可以想象成一条*割线*的陡度，这是一条穿过函数图形上两点的线。
- en: Zooming in on the graph of a smooth function, it appears indistinguishable from
    a straight line. The line it looks like is the best linear approximation for the
    function in that area, and its slope is called the *derivative* of the function.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个光滑函数的图形上放大，它看起来与一条直线无法区分。看起来像的线是该区域内函数的最佳线性近似，其斜率被称为函数的*导数*。
- en: You can approximate the derivative by taking the slopes of secant lines on successively
    smaller intervals containing the point. This approximates the instantaneous rate
    of change in the function at the point of interest.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过取包含该点的连续更小的间隔上的割线的斜率来近似导数。这近似了函数在感兴趣点的瞬时变化率。
- en: The *derivative* of a function is another function that tells you the instantaneous
    rate of change at every point. You can plot the derivative of a function to see
    its rate of change over time.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的导数是另一个函数，它告诉你每个点的瞬时变化率。你可以绘制函数的导数来观察其随时间的变化率。
- en: Starting with a derivative of a function, you can figure out how it changes
    over time by breaking it into brief intervals and assuming the rate is constant
    on each. If each interval is short enough, the rate will be approximately constant
    and summed to find the total. This approximates the definite integral of a function.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个函数的导数开始，你可以通过将其分解为短暂的时间间隔并假设在每个间隔上速率是恒定的，来找出它随时间的变化情况。如果每个间隔足够短，速率将大致保持恒定，并累加以找到总量。这近似于函数的定积分。
- en: Knowing the initial value of a function and taking the definite integral of
    its rate on various intervals, you can reconstruct the function. This is called
    the *indefinite integral* of the function.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道函数的初始值，并在各种时间间隔上对其速率取定积分，你可以重建该函数。这被称为函数的**不定积分**。
