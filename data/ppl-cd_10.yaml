- en: 7 Defining a pipeline as code for microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 为微服务定义管道代码
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Using a Jenkins multibranch pipeline plugin and GitFlow model
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jenkins多分支管道插件和GitFlow模型
- en: Defining multibranch pipelines for containerized microservices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义容器化微服务的多分支管道
- en: Triggering a Jenkins job on push events using GitHub webhooks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GitHub钩子触发Jenkins作业的推送事件
- en: Exporting Jenkins jobs configuration as XML and cloning Jenkins jobs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Jenkins作业配置导出为XML并克隆Jenkins作业
- en: 'The previous chapters covered how to deploy a Jenkins cluster on multiple cloud
    providers by using automation tools: HashiCorp Packer and Terraform. In this chapter,
    we will define a continuous integration (CI) pipeline for Dockerized microservices.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的章节介绍了如何通过使用自动化工具：HashiCorp Packer和Terraform在多个云服务提供商上部署Jenkins集群。在本章中，我们将定义一个针对Docker化微服务的持续集成（CI）管道。
- en: In chapter 1, you learned that CI is continuously testing and building all changes
    of the source code before integrating them into the central repository. Figure
    7.1 summarizes the stages in this workflow.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1章中，你了解到CI是在将源代码更改集成到中央存储库之前，持续测试和构建所有更改。图7.1总结了此工作流程的阶段。
- en: '![](Images/CH07_F01_Labouardy.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F01_Labouardy.png)'
- en: Figure 7.1 Continuous integration stages
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 持续集成阶段
- en: 'Every change to the source code triggers the CI pipeline, which launches the
    automated tests. This comes with many benefits:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每次对源代码的更改都会触发CI管道，启动自动化测试。这带来了许多好处：
- en: Detecting bugs and issues earlier, which results in a dramatic decrease in maintenance
    time and costs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 早期检测错误和问题，这导致维护时间和成本显著降低
- en: Ensuring that the codebase continues to work and meets the spec requirements
    as the system grows
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保随着系统的发展，代码库继续工作并满足规范要求
- en: Improving team velocity by establishing a fast-feedback loop
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过建立快速反馈循环来提高团队速度
- en: While automated tests come with multiple benefits, they’re extremely time-consuming
    to implement and execute. Therefore, we will use a testing framework based on
    the target service runtime and requirements.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管自动化测试带来了许多好处，但它们的实现和执行非常耗时。因此，我们将使用基于目标服务运行时和要求的测试框架。
- en: Once tests are successful, the source code is compiled and an artifact is built.
    Then it will be packaged and stored in a remote registry for version control and
    deployment later.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦测试成功，源代码将被编译并构建一个工件。然后它将被打包并存储在远程注册表中，以便进行版本控制和后续部署。
- en: Chapter 8 covers how to write a classic CI pipeline for containerized microservices.
    The end result will look like the CI pipeline in figure 7.2.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第8章介绍了如何编写一个经典的CI管道，用于容器化微服务。最终结果将类似于图7.2中的CI管道。
- en: '![](Images/CH07_F02_Labouardy.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F02_Labouardy.png)'
- en: Figure 7.2 Target CI pipeline
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 目标CI管道
- en: These steps cover the most basic flow of a continuous integration process. In
    the following chapters, once you are comfortable with this workflow, we’ll go
    even further. We’ll start by creating our multibranch pipeline from scratch with
    Jenkins and continuously running pipelines with GitHub webhooks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤涵盖了持续集成过程的最基本流程。在接下来的章节中，一旦你对这个工作流程感到舒适，我们将更进一步。我们将从零开始创建我们的多分支管道，使用Jenkins和GitHub钩子持续运行管道。
- en: 7.1 Introducing microservices-based applications
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 介绍基于微服务的应用程序
- en: It can be challenging to create a reliable CI/CD process for a microservices
    architecture. The goal of the pipeline is to allow teams to build and deploy their
    services quickly and independently, without disrupting other teams or destabilizing
    the application as a whole.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为微服务架构创建一个可靠的CI/CD流程可能具有挑战性。管道的目标是允许团队快速独立地构建和部署他们的服务，而不会干扰其他团队或破坏整个应用程序的稳定性。
- en: To illustrate how to define a CI/CD pipeline from scratch for containerized
    microservices, I have implemented a simple web application based on a microservices
    architecture. We are going to integrate and deploy a web-based application called
    Watchlist, where users can browse the top 100 greatest movies of all time and
    add them to their watching list.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何从头开始定义容器化微服务的CI/CD管道，我实现了一个基于微服务架构的简单Web应用程序。我们将集成并部署一个名为Watchlist的基于Web的应用程序，用户可以浏览史上最伟大的100部电影，并将它们添加到他们的观看列表中。
- en: The project includes tests, benchmarks, and everything needed to run the application
    locally and on the cloud. The deployed application will look like figure 7.3.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 项目包括测试、基准测试以及运行应用程序本地和云端的所需一切。部署的应用程序将类似于图7.3。
- en: '![](Images/CH07_F03_Labouardy.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F03_Labouardy.png)'
- en: Figure 7.3 Watchlist marketplace UI
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 观看列表市场UI
- en: Figure 7.4 illustrates the application architecture and flow.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4说明了应用程序架构和流程。
- en: '![](Images/CH07_F04_Labouardy.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F04_Labouardy.png)'
- en: Figure 7.4 The Loader service takes an array of movies in JSON format and forwards
    them one by one to a message queue (for example, Amazon SQS). From there, a Parser
    service will consume the items and fetch the movie’s details from the IMDb database
    and save the result into MongoDB. Finally, the data is served through a RESTful
    API by the Store service and visualized with the Marketplace UI.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 加载器服务将JSON格式的电影数组逐个转发到消息队列（例如，Amazon SQS）。从那里，解析器服务将消费这些项目，从IMDb数据库中获取电影的详细信息，并将结果保存到MongoDB中。最后，通过商店服务通过RESTful
    API提供数据，并通过市场UI进行可视化。
- en: Note *Amazon Simple Queue Service* (SQS) is a distributed message queuing service.
    It is intended to provide a highly scalable managed message queue to resolve issues
    arising from producer-consumer problems and to decouple distributed application
    services. See [https://aws.amazon.com/sqs/](https://aws.amazon.com/sqs/) for more
    details.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 *Amazon Simple Queue Service*（SQS）是一个分布式消息队列服务。它旨在提供一个高度可扩展的托管消息队列，以解决由生产者-消费者问题引起的问题，并解耦分布式应用程序服务。有关更多详细信息，请参阅[https://aws.amazon.com/sqs/](https://aws.amazon.com/sqs/)。
- en: The architecture is composed of multiple services written in different languages
    to illustrate the advantages of the microservices paradigm and the use of Jenkins
    to automate the build and deployment process of different runtime environments.
    Table 7.1 lists the microservices.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 架构由多种语言编写的多个服务组成，以展示微服务范式的优势以及使用Jenkins来自动化不同运行时环境的构建和部署过程。表7.1列出了微服务。
- en: Table 7.1 Application microservices
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 应用程序微服务
- en: '| Service | Language | Description |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 服务 | 语言 | 描述 |'
- en: '| Loader | Python | Responsible for reading a JSON file containing a list of
    movies and pushing each movie item to Amazon SQS. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 加载器 | Python | 负责读取包含电影列表的JSON文件，并将每个电影项目推送到Amazon SQS。|'
- en: '| Parser | Golang | Responsible for consuming movies by subscribing to SQS
    and scraping movie information from the IMDb website ([www.imdb.com](https://www.imdb.com))
    and storing the metadata (movie’s name, cover, description, and so forth) into
    MongoDB. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 解析器 | Golang | 负责通过订阅SQS并从IMDb网站（[www.imdb.com](https://www.imdb.com)）抓取电影信息，并将元数据（电影名称、封面、描述等）存储到MongoDB中。|'
- en: '| Store | Node.js | Responsible for serving a RESTful API with endpoints to
    fetch a list of movies and insert new movies into the watch list database in the
    MongoDB server. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 商店 | Node.js | 负责提供RESTful API，具有端点用于从MongoDB服务器中的观看列表数据库中获取电影列表和插入新电影。|'
- en: '| Marketplace | Angular and TypeScript | Responsible for serving a frontend
    to browse movies by calling the Store RESTful API. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 市场平台 | Angular和TypeScript | 负责通过调用Store RESTful API提供前端以浏览电影。|'
- en: Before we dig deeper into the CI workflow for the application, let’s see how
    the distributed application source code will be organized. When you start moving
    to microservices, one of the big challenges you will be facing is the organization
    of the codebase.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨应用程序的CI工作流程之前，让我们看看分布式应用程序源代码将如何组织。当你开始转向微服务时，你将面临的一个重大挑战就是代码库的组织。
- en: Do you create a repository for each service or a single repo for all services?
    Each pattern has its own advantages and disadvantages.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你是为每个服务创建一个仓库，还是为所有服务创建一个单一仓库？每种模式都有其自身的优缺点。
- en: '*Multiple repositories*—You can have multiple teams independently developing
    a service (clear ownership). Plus, smaller codebases are easier to maintain, test,
    and deploy with less team coordination. However, having independent teams might
    create localized knowledge across the organization and result in teams lacking
    an understanding of the bigger picture of the project.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多个仓库*——你可以有多个团队独立开发一个服务（清晰的归属感）。此外，较小的代码库更容易维护、测试和部署，且团队协调较少。然而，独立的团队可能会在组织内部产生局部知识，导致团队缺乏对项目整体图景的理解。'
- en: '*Mono repository*—Having a single source-control repository comes with a simplified
    project organization with less overhead from managing project dependencies. It
    also improves the overall work culture when teams work on a mono repository. However,
    versioning might become more complicated, and performance and scalability issues
    may arise.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单仓库*——拥有单个源代码控制仓库可以简化项目组织，减少管理项目依赖的开销。它也有助于提高团队在单仓库上工作时的工作文化。然而，版本控制可能会变得更加复杂，性能和可扩展性问题也可能出现。'
- en: Both patterns have pros and cons, and neither is a silver bullet. You should
    understand their benefits and limitations, and use them to make an informed decision
    on what’s best for you and your project.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种模式都有优点和缺点，都不是万能的解决方案。你应该了解它们的优点和局限性，并据此做出明智的决定，选择最适合你和你项目的方案。
- en: The way you structure your codebase will impact the design of the CI/CD pipeline.
    Having a project hosted on a single repository might result in a single pipeline
    with fairly complex stages. Pipeline size and complexity are often a huge pain
    point. As the number of services evolves within an organization, the management
    of pipelines becomes a bigger issue as well. In the end, most pipelines end as
    a spaghetti mix of npm, pip, and Maven scripts sprinkled with some bash scripts
    all over the place. On the other side, adopting a multiple-repositories strategy
    might result in multiple pipelines to manage and code duplication. Fortunately,
    solutions are available to reduce pipeline management, including using shared
    pipeline segments and shared Groovy scripts.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码库结构将影响 CI/CD 管道的构建。一个项目托管在单个仓库中可能会导致一个相当复杂的单一管道。管道的大小和复杂性通常是巨大的痛点。随着组织内部服务数量的增加，管道的管理也成为一个更大的问题。最终，大多数管道都变成了一个混乱的混合体，其中包含了
    npm、pip 和 Maven 脚本，到处散布着一些 bash 脚本。另一方面，采用多仓库策略可能会导致需要管理的多个管道和代码重复。幸运的是，有解决方案可以减少管道管理，包括使用共享管道段和共享
    Groovy 脚本。
- en: Note Chapter 14 covers how to write a shared library in Jenkins to share common
    code and steps across multiple pipelines.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：第 14 章介绍了如何在 Jenkins 中编写共享库以在多个管道之间共享通用代码和步骤。
- en: This book illustrates how to build CI/CD pipelines for both patterns. For microservices,
    we will adopt the multiple repositories strategy. We will cover the mono-repo
    approach while building CI/CD pipelines for serverless functions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将说明如何为这两种模式构建 CI/CD 管道。对于微服务，我们将采用多仓库策略。在构建无服务器函数的 CI/CD 管道时，我们将涵盖单仓库方法。
- en: First, create four Git repositories to store the source code for each service
    (Loader, Parser, Store, and Marketplace). In this book, I’m using GitHub, but
    any SCM system can be used, such as GitLab, Bitbucket, or even SVN. Make sure
    you have Git installed on the machine that you will use to perform the steps mentioned
    in the following section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建四个 Git 仓库以存储每个服务的源代码（Loader、Parser、Store 和 Marketplace）。在这本书中，我使用 GitHub，但任何源代码管理系统都可以使用，例如
    GitLab、Bitbucket，甚至是 SVN。确保你在将要执行以下章节中提到的步骤的机器上安装了 Git。
- en: Note Throughout this book, we will use the GitFlow model for branch management.
    For more information, read chapter 2.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本书中，我们将使用 GitFlow 模型进行分支管理。更多信息请参阅第 2 章。
- en: 'Once the repositories are created, clone them to your workspace and create
    three main branches: develop, preprod, and master branches to help organize the
    code and isolate the under-development code from the one running in production.
    This branching strategy is a slimmer version of the GitFlow workflow branching
    model.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了仓库，就将它们克隆到你的工作区，并创建三个主要分支：develop、preprod 和 master 分支，以帮助组织代码并将正在开发中的代码与生产中运行的代码隔离开。这种分支策略是
    GitFlow 工作流分支模型的简化版本。
- en: Note The complete Jenkinsfile for each service can be found in the chapter7/
    microservices folder within the book’s GitHub repository.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：每个服务的完整 Jenkinsfile 可以在本书 GitHub 仓库的 chapter7/microservices 文件夹中找到。
- en: 'Use the following commands to create the target branches and push them to the
    remote repository:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建目标分支并将它们推送到远程仓库：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To view the branches in the Git repository, run this command in your terminal:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Git 仓库中的分支，请在你的终端中运行以下命令：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'An asterisk (`*`) will be next to the branch that you’re currently on (develop).
    Output similar to the following should be displayed in your terminal session:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 星号 (`*`) 将会出现在你当前所在的分支旁边（develop）。在你的终端会话中应该会显示类似以下的输出：
- en: '![](Images/CH07_F04_UN01_Labouardy.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F04_UN01_Labouardy.png)'
- en: 'Next, copy the code from the book’s GitHub repository to each Git repository
    on the develop branch, and then push the changes to the remote repository:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将书籍 GitHub 仓库中的代码复制到每个 Git 仓库的开发分支，然后将更改推送到远程仓库：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The GitHub repository should look like figure 7.5.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 仓库应类似于图 7.5。
- en: '![](Images/CH07_F05_Labouardy.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F05_Labouardy.png)'
- en: Figure 7.5 The Loader GitHub repository has the service source’s code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 Loader GitHub 仓库包含服务源代码。
- en: Note For now, we push the changes directly to the develop branch. Later, you
    will see how to create pull requests and set up a review process with Jenkins.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：目前，我们直接将更改推送到开发分支。稍后，您将看到如何创建拉取请求并使用 Jenkins 设置审查流程。
- en: The movies-loader source code is available in the chapter7/microservices/movies-loader
    folder. Repeat the same process to create the movies-parser, movies-store, and
    movies-marketplace GitHub repositories.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: movies-loader 源代码位于 chapter7/microservices/movies-loader 文件夹中。重复相同的步骤来创建 movies-parser、movies-store
    和 movies-marketplace GitHub 仓库。
- en: 7.2 Defining multibranch pipeline jobs
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 定义多分支流水线作业
- en: To integrate the application source code with Jenkins, we need to create Jenkins
    jobs to continuously build it. Head over to Jenkins web dashboard and click the
    New Item button at the top-left corner, or click the Create New Jobs link to create
    a new job, as shown in figure 7.6.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要将应用程序源代码与 Jenkins 集成，我们需要创建 Jenkins 作业以持续构建它。转到 Jenkins 网页仪表板，点击左上角的“新建项目”按钮，或点击“创建新作业”链接来创建新作业，如图
    7.6 所示。
- en: '![](Images/CH07_F06_Labouardy.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F06_Labouardy.png)'
- en: Figure 7.6 Jenkins new job creation
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 Jenkins 新作业创建
- en: Note For a step-by-step guide on deploying Jenkins, refer to chapter 5.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关部署 Jenkins 的分步指南，请参阅第 5 章。
- en: On the resultant page, you will be presented with various types of Jenkins jobs
    to choose from. Enter the name of the project, scroll down, select Multibranch
    Pipeline, and click the OK button. The Multibranch Pipeline option allows us to
    automatically create a pipeline for each branch on the source-control repository.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果页面上，您将看到各种类型的 Jenkins 作业可供选择。输入项目名称，向下滚动，选择多分支流水线，然后点击“确定”按钮。多分支流水线选项允许我们自动为源控制仓库中的每个分支创建流水线。
- en: Figure 7.7 shows the multibranch job pipeline for the movies-loader service.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 显示了 movies-loader 服务的多分支作业流水线。
- en: '![](Images/CH07_F07_Labouardy.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F07_Labouardy.png)'
- en: Figure 7.7 Jenkins new job settings
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 Jenkins 新作业设置
- en: Note The Jenkins Multibranch Pipeline plugin ([https://plugins.jenkins.io/workflow-multibranch/](https://plugins.jenkins.io/workflow-multibranch/))
    is installed by default on the baked Jenkins master AMI.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Jenkins 多分支流水线插件（[https://plugins.jenkins.io/workflow-multibranch/](https://plugins.jenkins.io/workflow-multibranch/））默认安装在预制的
    Jenkins 主机 AMI 上。
- en: 'I’ll briefly summarize the new job types here and then explain each in more
    detail in upcoming chapters:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我将简要总结这里的新作业类型，然后在接下来的章节中更详细地解释每个类型：
- en: '*Freestyle project*—This is a classic way of creating a Jenkins job, wherein
    each CI stage is represented by using UI components and forms. The job is a web-based
    configuration, and any modification is done through the Jenkins dashboard.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自由风格项目*—这是创建 Jenkins 作业的经典方式，其中每个 CI 阶段都通过 UI 组件和表单来表示。作业是基于网页的配置，任何修改都是通过
    Jenkins 仪表板进行的。'
- en: '*Inheritance project*—The purpose of this project type is to bring true inheritance
    of properties between multiple job definitions to Jenkins. It allows you to share
    common properties only once and create Jenkins jobs to inherit them across many
    projects.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*继承项目*—此项目类型的目的在于在多个作业定义之间实现 Jenkins 中的真正属性继承。它允许您只需共享一次公共属性，然后创建 Jenkins 作业以在许多项目中继承它们。'
- en: '*Pipeline*—This job type lets you either paste a Jenkinsfile directly into
    the job UI or reference a single Git repository as the source and then specify
    a single branch where the Jenkinsfile is located. This job can be useful if you
    plan to use a trunk-based workflow to manage your project source code.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*流水线*—此作业类型允许您直接将 Jenkinsfile 粘贴到作业 UI 中，或者将单个 Git 仓库作为源并指定 Jenkinsfile 所在的单个分支。如果您计划使用基于主干的工作流程来管理项目源代码，此作业可能很有用。'
- en: '*Folder*—This is a way to group multiple projects together rather than a type
    of project itself. This is different from the view tabs on the Jenkins dashboard,
    which provide just a filter. Rather, this is like a directory folder on the server,
    storing nested items.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件夹*—这是一种将多个项目组合在一起的方法，而不是项目本身的一种类型。这与 Jenkins 仪表板上的视图选项卡不同，后者仅提供过滤器。相反，这就像服务器上的目录文件夹，存储嵌套项。'
- en: '*Multibranch pipeline*—This is a type of project we will use through this book.
    As its name indicates, it allows us to automatically create nested jobs for each
    Git branch containing a Jenkinsfile.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多分支管道*——这是我们将在本书中使用的项目类型。正如其名称所示，它允许我们为包含Jenkinsfile的每个Git分支自动创建嵌套作业。'
- en: '*Organization*—Certain source-control platforms provide a mechanism for grouping
    multiple repositories into organizations. This project type allows you to use
    a Jenkinsfile in the repositories within an organization and execute a pipeline
    based on the Jenkinsfile. Currently, the project type supports only GitHub and
    Bitbucket organizations.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组织*——某些源代码控制平台提供了一种将多个仓库分组到组织中的机制。此项目类型允许你在组织内的仓库中使用Jenkinsfile，并基于Jenkinsfile执行管道。目前，此项目类型仅支持GitHub和Bitbucket组织。'
- en: Note The trunk-based strategy uses one central repository with a single entry
    (called a *trunk* or *master*) for all changes to the project.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：基于主干的策略使用一个中央仓库，所有对项目的更改都通过一个单一入口（称为*主干*或*master*）进行。
- en: To be clear, having these new job types available depends on having the requisite
    plugins installed. If you baked the Jenkins master machine image with the list
    of plugins provided in chapter 4’s section 4.3.2, you will get all the job types
    discussed in the preceding list.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确起见，这些新工作类型的可用性取决于是否安装了必要的插件。如果你使用第4章4.3.2节中提供的插件列表烘焙了Jenkins主机机器镜像，你将获得前面列表中讨论的所有工作类型。
- en: 7.3 Git and GitHub integration
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 Git和GitHub集成
- en: The pipeline script (Jenkinsfile) will be versioned in GitHub. Therefore, we
    need to configure the Jenkins job to fetch it from the remote repository.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 管道脚本（Jenkinsfile）将在GitHub上版本化。因此，我们需要配置Jenkins作业以从远程仓库获取它。
- en: Set a name and description in the General section. Then, select the code source
    from the Branch Sources section. Configure the pipeline to refer to GitHub for
    source-control management by selecting GitHub from the drop-down list; see figure
    7.8.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在“常规”部分设置名称和描述。然后，从“分支源”部分选择代码源。通过从下拉列表中选择GitHub来配置管道以引用GitHub进行源代码管理；参见图7.8。
- en: '![](Images/CH07_F08_Labouardy.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F08_Labouardy.png)'
- en: Figure 7.8 Branch Sources configuration
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 分支源配置
- en: For checkout credentials, open a new tab and go to the Jenkins dashboard. Click
    Credentials and then System. On the Global Credentials page, from the menu on
    the left, click the Add Credentials link. Next, create a new Jenkins global credential
    of type Username and Password to access the microservices projects in Git. The
    GitHub username and password can be set as shown in figure 7.9\. However, it’s
    not recommended to use a personal GitHub account.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于检出凭证，打开一个新标签页并转到Jenkins仪表板。点击凭证，然后点击系统。在全局凭证页面上，从左侧菜单中，点击添加凭证链接。接下来，创建一个新的Jenkins全局凭证，类型为用户名和密码，以访问Git中的微服务项目。GitHub用户名和密码可以设置如图7.9所示。然而，不建议使用个人GitHub账户。
- en: Note The Jenkins Credentials plugin ([https://plugins.jenkins.io/credentials/](https://plugins.jenkins.io/credentials/))
    is installed by default on the baked Jenkins master machine image. It is part
    of the essential plugins listed in chapter 4’s section 4.3.2.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Jenkins凭证插件（[https://plugins.jenkins.io/credentials/](https://plugins.jenkins.io/credentials/））默认安装在烘焙的Jenkins主机机器镜像上。它是第4章4.3.2节中列出的基本插件之一。
- en: '![](Images/CH07_F09_Labouardy.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F09_Labouardy.png)'
- en: Figure 7.9 Jenkins credentials provider
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 Jenkins凭证提供者
- en: Therefore, I have created a dedicated Jenkins service account on GitHub and
    used an access token instead of the account password. You can create the access
    token by signing in with the GitHub credentials and navigating to Settings. Then,
    from the left menu, select Developer Settings and select Personal Access Tokens,
    as shown in figure 7.10.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我在GitHub上创建了一个专门的Jenkins服务账户，并使用访问令牌而不是账户密码。你可以通过使用GitHub凭证登录并导航到设置来创建访问令牌。然后，从左侧菜单中选择开发者设置，并选择个人访问令牌，如图7.10所示。
- en: '![](Images/CH07_F10_Labouardy.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F10_Labouardy.png)'
- en: Figure 7.10 GitHub personal access tokens
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 GitHub个人访问令牌
- en: Click the Generate New Token button, give a name to the access token, and select
    the `repo` access from the list of authorized scopes, as shown in figure 7.11\.
    For private repositories, you must ensure that the `repo` scope is selected, and
    not just the `repo:status` and `public_repo` scopes. The token name is helpful,
    as you’ll likely have many of these tokens for many applications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 点击生成新令牌按钮，为访问令牌命名，并从授权范围列表中选择 `repo` 访问，如图 7.11 所示。对于私有仓库，您必须确保已选择 `repo` 范围，而不仅仅是
    `repo:status` 和 `public_repo` 范围。令牌名称很有帮助，因为您可能为许多应用程序拥有许多这样的令牌。
- en: '![](Images/CH07_F11_Labouardy.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11 Jenkins 专为 GitHub 访问的令牌](Images/CH07_F11_Labouardy.png)'
- en: Figure 7.11 Jenkins dedicated token for GitHub access
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 Jenkins 专为 GitHub 访问的令牌
- en: As the GitHub warning in figure 7.12 indicates, you must copy the token after
    you generate it, as you won’t be able to see it again. If you fail to do so, your
    only recourse will be to regenerate the token.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 7.12 所示的 GitHub 警告指出，您必须在生成令牌后复制它，因为您将无法再次看到它。如果您未能这样做，您唯一的选择将是重新生成令牌。
- en: '![](Images/CH07_F12_Labouardy.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 Labouardy](Images/CH07_F12_Labouardy.png)'
- en: Figure 7.12 Jenkins personal access token
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 Jenkins 个人访问令牌
- en: Paste in the GitHub personal access token to the Password field. Give a unique
    ID to your GitHub credentials by typing a string in the ID field and add a meaningful
    description to the Description field, as shown in figure 7.13\. Then click the
    Save button.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将 GitHub 个人访问令牌粘贴到密码字段中。通过在 ID 字段中输入一个字符串为您的 GitHub 凭据提供一个唯一的 ID，并在描述字段中添加一个有意义的描述，如图
    7.13 所示。然后点击保存按钮。
- en: '![](Images/CH07_F13_Labouardy.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 Labouardy](Images/CH07_F13_Labouardy.png)'
- en: Figure 7.13 GitHub credentials configuration on Jenkins
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.13 Jenkins 上的 GitHub 凭据配置](Images/CH07_F13_Labouardy.png)'
- en: Go back to the job configuration tab, shown in figure 7.14, and select the credentials
    you created from the Credentials drop-down list. Set the repository HTTPS clone
    URL and set the discovering behavior to allow scanning of all repository branches.
    Then, scroll all the way down and click the Apply and Save buttons.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 返回图 7.14 所示的作业配置选项卡，从凭据下拉列表中选择您创建的凭据。设置仓库 HTTPS 克隆 URL 并将发现行为设置为允许扫描所有仓库分支。然后，滚动到页面底部并点击应用和保存按钮。
- en: '![](Images/CH07_F14_Labouardy.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 Jenkins 个人访问令牌](Images/CH07_F14_Labouardy.png)'
- en: Figure 7.14 GitHub repository configuration on Jenkins
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.14 Jenkins 上的 GitHub 仓库配置](Images/CH07_F14_Labouardy.png)'
- en: Note We cover Jenkins advanced scanning behaviors and strategies in chapter
    9.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们将在第 9 章中介绍 Jenkins 高级扫描行为和策略。
- en: Jenkins will scan the GitHub repository, looking for branches with a Jenkinsfile
    in the root repository. So far, there are none, and we can check that by clicking
    the Scan Repository Log button from the left sidebar.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 将扫描 GitHub 仓库，寻找根仓库中具有 Jenkinsfile 的分支。到目前为止，还没有找到，我们可以通过从左侧侧边栏点击扫描仓库日志按钮来验证这一点。
- en: Note In this book, we will use the concept of pipeline as code instead of representing
    each CI stage within the UI as in a Jenkins classic freestyle job. The pipeline
    will be described in a Jenkinsfile.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在这本书中，我们将使用“管道即代码”的概念，而不是像 Jenkins 经典自由式作业那样在 UI 中表示每个 CI 阶段。管道将在 Jenkinsfile
    中进行描述。
- en: The log output confirms that no Jenkinsfile has been found yet in the GitHub
    repository, as shown in figure 7.15.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 日志输出确认，GitHub 仓库中尚未找到 Jenkinsfile，如图 7.15 所示。
- en: '![](Images/CH07_F15_Labouardy.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.15 Labouardy](Images/CH07_F15_Labouardy.png)'
- en: Figure 7.15 Jenkins repository scanning logs
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.15 Jenkins 仓库扫描日志](Images/CH07_F15_Labouardy.png)'
- en: It’s time to create a Jenkinsfile. Using your favorite text editor or IDE, create
    and save a new text file with the name `Jenkinsfile` at the root of your local
    movies-loader Git repository. Copy the following scripted pipeline code and paste
    it into your empty Jenkinsfile.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建一个 Jenkinsfile 了。使用您喜欢的文本编辑器或 IDE，在您本地 movies-loader Git 仓库的根目录下创建并保存一个名为
    `Jenkinsfile` 的新文本文件。复制以下脚本化管道代码并将其粘贴到您的空 Jenkinsfile 中。
- en: Listing 7.1 Jenkinsfile using a scripted approach
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.1 使用脚本方法的 Jenkinsfile
- en: '[PRE3]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note We are using scripted pipeline syntax to write most of the Jenkinsfile.
    However, the declarative approach will be given when the CI pipeline is completed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们将在 Jenkinsfile 中使用脚本化管道语法来编写大部分内容。然而，当 CI 管道完成时，将采用声明式方法。
- en: The `Checkout` stage, as its name indicates, will simply check out the code
    at the reference point that triggered the run. You can customize the checkout
    process by providing additional parameters. Also, the stages will be executed
    on Jenkins workers—hence, the use of the `workers` label on the node block. We’re
    assuming we have a Jenkins worker already set up on the Jenkins instance labeled
    `workers`. If no label is provided, Jenkins will run the pipeline on the first
    executor that becomes available on any machine (master or worker).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Checkout`阶段，正如其名称所示，将简单地检出触发运行的参考点处的代码。您可以通过提供额外的参数来自定义检出过程。此外，阶段将在Jenkins工作节点上执行——因此，在节点块中使用了`workers`标签。我们假设我们已经在标记为`workers`的Jenkins实例上设置了一个Jenkins工作节点。如果没有提供标签，Jenkins将在任何机器（主节点或工作节点）上可用的第一个执行器上运行管道。'
- en: 'Save your edited Jenkinsfile and push the changes to the develop branch by
    running the following commands:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 保存您编辑后的Jenkinsfile，并通过运行以下命令将更改推送到develop分支：
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The Jenkinsfile lives with the source code in GitHub. Therefore, like any code,
    it can be peer-reviewed, commented on, and approved before being merged into main
    branches; see figure 7.16.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkinsfile与源代码一起存储在GitHub中。因此，就像任何代码一样，它可以在合并到主分支之前进行同行评审、评论和批准；见图7.16。
- en: '![](Images/CH07_F16_Labouardy.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F16_Labouardy.png)'
- en: Figure 7.16 Jenkinsfile is stored along with source code
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 Jenkinsfile与源代码一起存储
- en: Go back to the Jenkins dashboard, and to trigger the scanning again, click the
    Scan Repository Now button. By default, this will automatically trigger builds
    for all newly discovered branches, as shown in figure 7.17.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Jenkins仪表板，并再次触发扫描，请点击“立即扫描仓库”按钮。默认情况下，这将自动触发所有新发现的分支的构建，如图7.17所示。
- en: '![](Images/CH07_F17_Labouardy.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F17_Labouardy.png)'
- en: Figure 7.17 Jenkinsfile detected on develop branch
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17 在develop分支上检测到的Jenkinsfile
- en: In our current setup, a Jenkinsfile has been found only on the develop branch.
    If we click the movies-loader job again. Jenkins should have created a nested
    job for the develop branch, as you can see in figure 7.18\. There was no pipeline
    scheduled for the preprod and master branches since there was no Jenkinsfile on
    them yet.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的设置中，仅在develop分支上找到了Jenkinsfile。如果我们再次点击movies-loader作业，Jenkins应该为develop分支创建了一个嵌套作业，如图7.18所示。由于预生产和master分支上还没有Jenkinsfile，因此没有为这些分支安排任何管道。
- en: '![](Images/CH07_F18_Labouardy.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F18_Labouardy.png)'
- en: Figure 7.18 Build job triggered on the develop branch
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18 在develop分支上触发的构建作业
- en: Note If you ever have problems with jobs for branches not being created or built
    automatically, check the Scan Repository Log item from the left job sidebar.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您遇到分支作业未自动创建或构建的问题，请检查左侧作业侧边栏中的“扫描仓库日志”项。
- en: The build should be triggered on the develop branch automatically, and the checkout
    stage will be executed and turned green. Note that the Git client should be installed
    on the worker where the build is executed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应该自动在develop分支上触发，检出阶段将被执行并变为绿色。请注意，Git客户端应该安装在执行构建的工作节点上。
- en: The Jenkins Stage view, shown in figure 7.19, lets us visualize the progress
    of various stages of the pipeline in real-time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins阶段视图，如图7.19所示，让我们能够实时可视化管道各个阶段的进度。
- en: '![](Images/CH07_F19_Labouardy.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F19_Labouardy.png)'
- en: Figure 7.19 Pipeline execution
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19 管道执行
- en: Note The Jenkins Stage view is a new feature that comes as a part of release
    2.*x*. It works only with Jenkins Pipeline and Jenkins Multibranch pipeline jobs.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Jenkins阶段视图是作为2.*x*版本的一部分新功能出现的。它仅与Jenkins Pipeline和Jenkins Multibranch pipeline作业一起工作。
- en: Click the Checkout stage column to view the stage’s logs. You can see that Jenkins
    has cloned the movies-loader GitHub repository and checked out the develop branch
    to fetch the latest source code changes from the remote repository, as shown in
    figure 7.20.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 点击检出阶段列以查看阶段的日志。您可以看到Jenkins已克隆了movies-loader GitHub仓库，并检出develop分支以从远程仓库获取最新的源代码更改，如图7.20所示。
- en: '![](Images/CH07_F20_Labouardy.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F20_Labouardy.png)'
- en: Figure 7.20 Checkout stage logs
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20 检出阶段日志
- en: To view the complete build log, look for the Build History on the left side.
    The Build History tab will list all the builds that have been run. Click the last
    build number; see figure 7.21.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的构建日志，请查找左侧的“构建历史”。构建历史记录选项卡将列出所有已运行的构建。点击最后一个构建编号；见图7.21。
- en: '![](Images/CH07_F21_Labouardy.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F21_Labouardy.png)'
- en: Figure 7.21 Build number settings
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.21 构建编号设置
- en: Then, click the Console Output item from the left corner. The complete build
    logs will be displayed, as shown in figure 7.22.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击左上角的控制台输出项。完整的构建日志将会显示，如图 7.22 所示。
- en: '![](Images/CH07_F22_Labouardy.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F22_Labouardy.png)'
- en: Figure 7.22 Build console logs
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.22 构建控制台日志
- en: Now that we have created a Jenkins job for movies-loader, let’s create another
    Jenkins job for the movies-parser service; once again, head over to Jenkins main
    page and click the New Item button. However, to save time, copy the configuration
    from the previous job, as shown in figure 7.23.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为 movies-loader 创建了一个 Jenkins 作业，接下来让我们为 movies-parser 服务创建另一个 Jenkins
    作业；再次，前往 Jenkins 主页并点击新建项目按钮。然而，为了节省时间，请复制前一个作业的配置，如图 7.23 所示。
- en: '![](Images/CH07_F23_Labouardy.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F23_Labouardy.png)'
- en: Figure 7.23 Parser job’s creation
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.23 解析作业创建
- en: Click the OK button. The movies-parser job will reflect all features of the
    cloned movies-loader job. Update appropriately the GitHub repository HTTPS clone
    URL, job description, and display name, as shown in figure 7.24.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 点击确定按钮。movies-parser 作业将反映克隆的 movies-loader 作业的所有功能。根据图 7.24 更新 GitHub 仓库 HTTPS
    克隆 URL、作业描述和显示名称。
- en: '![](Images/CH07_F24_Labouardy.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F24_Labouardy.png)'
- en: Figure 7.24 Parser job GitHub configuration
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.24 解析作业 GitHub 配置
- en: Push the same Jenkinsfile used in the previous job to the develop branch of
    the movies-parser GitHub repository. Then click Apply for changes to take effect.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前作业中使用的相同的 Jenkinsfile 推送到 movies-parser GitHub 仓库的 develop 分支。然后点击应用更改以使更改生效。
- en: After saving, the build will always run from the current version of Jenkinsfile
    into the repository, as shown in figure 7.25.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，构建将始终从 Jenkinsfile 的当前版本运行到仓库中，如图 7.25 所示。
- en: '![](Images/CH07_F25_Labouardy.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F25_Labouardy.png)'
- en: Figure 7.25 Parser job list of active branches
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.25 解析作业活动分支列表
- en: Follow the same steps to create Jenkins jobs for the movies-store and movies-marketplace
    services.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相同的步骤创建 movies-store 和 movies-marketplace 服务的 Jenkins 作业。
- en: While Git is the most used distributed version control nowadays, Jenkins comes
    with built-in support for Subversion. To use source code from a Subversion repository,
    you simply provide the corresponding Subversion URL—it will work fine with any
    of the three Subversion protocols of HTTP, SVN, or File. Jenkins will check that
    the URL is valid as soon as you enter it. If the repository requires authentication,
    you can create a Jenkins credential of type Username with Password, and select
    it from the Credentials drop-down list, as shown in figure 7.26.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Git 是目前最常用的分布式版本控制系统，但 Jenkins 内置了对 Subversion 的支持。要使用来自 Subversion 仓库的源代码，你只需提供相应的
    Subversion URL——它将很好地与 HTTP、SVN 或 File 中的任何三个 Subversion 协议一起工作。Jenkins 将在您输入
    URL 时立即检查该 URL 是否有效。如果仓库需要身份验证，您可以从图 7.26 所示的凭据下拉列表中创建一个类型为用户名的凭据，并选择它。
- en: '![](Images/CH07_F26_Labouardy.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F26_Labouardy.png)'
- en: Figure 7.26 SVN repository configuration
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.26 SVN 仓库配置
- en: You can fine-tune the way Jenkins obtains the latest source code from your Subversion
    repository by selecting an appropriate value in the Check-out Strategy drop-down
    list.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在“检出策略”下拉列表中选择适当的值来微调 Jenkins 从你的 Subversion 仓库获取最新源代码的方式。
- en: 7.4 Discovering Jenkins jobs’ XML configuration
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 发现 Jenkins 作业的 XML 配置
- en: Another way to create or clone a multibranch pipeline job is to export the config.xml
    file of an existing job. The XML file contains, as you might expect, the configuration
    details for the build job.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 创建或克隆一个多分支管道作业的另一种方法是导出现有作业的 config.xml 文件。如你所预期，该 XML 文件包含了构建作业的配置细节。
- en: You can view the XML configuration of a job by pointing your browser to JENKINS
    _DNS/job/JOB_NAME/config.xml. It should dump the job XML definition in the browser
    page, as shown in figure 7.27.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将浏览器指向 JENKINS _DNS/job/JOB_NAME/config.xml 来查看作业的 XML 配置。它应该在浏览器页面中输出作业
    XML 定义，如图 7.27 所示。
- en: '![](Images/CH07_F27_Labouardy.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F27_Labouardy.png)'
- en: Figure 7.27 Job XML configuration
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.27 作业 XML 配置
- en: Save the job definition in an XML file and update the XML tags in table 7.2
    with the appropriate values based on the target Jenkins job you’re planning to
    create.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将作业定义保存为 XML 文件，并根据你计划创建的目标 Jenkins 作业，在表 7.2 中更新相应的 XML 标签。
- en: Table 7.2 XML tags
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.2 XML 标签
- en: '| XML tag | Description |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| XML 标签 | 描述 |'
- en: '| `<description>` | Meaningful description explaining in a few words the purpose
    of the Jenkins job |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `<description>` | 有意义的描述，用几句话解释 Jenkins 作业的目的 |'
- en: '| `<displayName>` | Jenkins job’s display name; general practice is to use
    the name of the repository storing the source code as a value for display name
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `<displayName>` | Jenkins作业的显示名称；通常的做法是将存储源代码的仓库名称用作显示名称的值 |'
- en: '| `<repository>` | Name of the GitHub repository holding the source code, such
    as movies-store |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `<repository>` | 存储源代码的GitHub仓库名称，例如movies-store |'
- en: '| `<repositoryURL>` | GitHub repository HTTPS clone URL, set in the following
    format: https://github.com/username/repository.git |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `<repositoryURL>` | GitHub仓库HTTPS克隆URL，格式如下：https://github.com/username/repository.git
    |'
- en: Note In chapter 14, we will cover how to use the Jenkins CLI to automate the
    import and export of multiple jobs and plugins in Jenkins.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在第14章中，我们将介绍如何使用Jenkins CLI自动化导入和导出Jenkins中的多个作业和插件。
- en: The following listing is an example of an XML config file for the movies-store
    job. It illustrates a typical structure of a Jenkins job XML configuration.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表是movies-store作业的XML配置文件示例。它展示了Jenkins作业XML配置的典型结构。
- en: Listing 7.2 Movies store config.xml
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2 电影存储配置.xml
- en: '[PRE5]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Defines the job’s name and description
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义作业的名称和描述
- en: ❷ Defines the project GitHub repository URL (HTTPS format)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 定义项目的GitHub仓库URL（HTTPS格式）
- en: ❸ Tells Jenkins to scan all branches in the GitHub repository looking for a
    Jenkinsfile
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 告知Jenkins扫描GitHub仓库中的所有分支以查找Jenkinsfile
- en: Note The XML has been cropped for brevity. The full job XML definition is available
    in the GitHub repository in chapter7/jobs/movies-store.xml.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了简洁，XML已被裁剪。完整的作业XML定义可在GitHub仓库的chapter7/jobs/movies-store.xml中找到。
- en: Once you have updated the config.xml file with the appropriate values, issue
    an HTTP POST request with the job XML definition as a payload to the Jenkins URL
    with a query parameter `name` equal to the target job’s name. Figure 7.28 shows
    an example for creating a movies-store job with a Postman HTTP API client.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您已使用适当的值更新了config.xml文件，请向包含作业XML定义的负载的Jenkins URL发出HTTP POST请求，查询参数`name`等于目标作业的名称。图7.28展示了使用Postman
    HTTP API客户端创建movies-store作业的示例。
- en: Note If CSRF protection is enabled on Jenkins, you will need to create an API
    token instead of a crumb issuer token. For more information, refer to chapter
    2.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果Jenkins启用了CSRF保护，您需要创建一个API令牌而不是crumb发行者令牌。有关更多信息，请参阅第2章。
- en: '![](Images/CH07_F28_Labouardy.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F28_Labouardy.png)'
- en: Figure 7.28 Job creation Jenkins RESTful API with Postman
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.28 使用Postman创建作业的Jenkins RESTful API
- en: 'A one-line cURL command can also be used to clone and create a new job:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一行cURL命令来克隆并创建一个新的作业：
- en: '[PRE6]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Jenkins API token (`API_TOKEN` variable) can be created from the Jenkins
    dashboard by logging with the user that you want to generate the API token for.
    Then open the user profile page and click Configure to open the user configuration
    page.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins API令牌（`API_TOKEN`变量）可以通过登录到Jenkins仪表板并使用您想要生成API令牌的用户来创建。然后打开用户配置文件页面，并点击“配置”以打开用户配置页面。
- en: Locate the Add new Token button, give a name to the new token, and click the
    Generate button, as shown in figure 7.29\. Retrieve the token and replace the
    `API_ TOKEN` variable in the preceding cURL commands with the generated token
    value.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 定位到“添加新令牌”按钮，为新令牌命名，然后点击“生成”按钮，如图7.29所示。获取令牌，并将前面的cURL命令中的`API_TOKEN`变量替换为生成的令牌值。
- en: '![](Images/CH07_F29_Labouardy.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F29_Labouardy.png)'
- en: Figure 7.29 Jenkins API token generation
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.29 Jenkins API令牌生成
- en: Note Jenkins jobs can also be created by copying the XML file directly to the
    /var/lib/jenkins/jobs/<*Job name*> folder on the Jenkins master instance and restarting
    Jenkins with the `service` `jenkins` `restart` command for changes to take effect.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Jenkins作业也可以通过直接将XML文件复制到Jenkins主实例的/var/lib/jenkins/jobs/<*作业名称*>文件夹中，并使用`service
    jenkins restart`命令重启Jenkins来创建，以便更改生效。
- en: Once the four Jenkins jobs are created, you should have the jobs shown in figure
    7.30 on the Jenkins main page. You can organize these jobs in one view by creating
    a Jenkins folder. You can create a folder named Watchlist and move these jobs
    to it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了四个Jenkins作业，您应该在Jenkins主页上看到图7.30所示的作业。您可以通过创建一个Jenkins文件夹来将这些作业组织在一个视图中。您可以创建一个名为Watchlist的文件夹，并将这些作业移动到其中。
- en: '![](Images/CH07_F30_Labouardy.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F30_Labouardy.png)'
- en: Figure 7.30 Microservices jobs in Jenkins
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.30 Jenkins中的微服务作业
- en: 'To do so, follow these steps: From the sidebar, click New Item, enter `Watchlist`
    as a name in the text box, and select Folder to create the folder. To move the
    existing jobs to the folder, click the arrow to the right of the job and select
    Move. Select Watchlist as the desired folder and click Move.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，请按照以下步骤操作：从侧边栏中点击新建项目，在文本框中输入 `Watchlist` 作为名称，并选择文件夹以创建文件夹。要将现有作业移动到文件夹中，点击作业右侧的箭头并选择移动。选择
    `Watchlist` 作为目标文件夹并点击移动。
- en: 'The microservices jobs will be accessible with the following URL format: JENKINS_DNS/job/Watchlist/job.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务作业可以通过以下 URL 格式访问：JENKINS_DNS/job/Watchlist/job。
- en: 'The Jenkins CLI can be used to import or export a job even if its usage is
    deprecated and not recommended for security vulnerabilities (at least for Jenkins
    2.53 and older versions). You can run this command to import your Jenkins job
    XML file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 Jenkins CLI 的使用已被弃用且不推荐用于安全漏洞（至少对于 Jenkins 2.53 及更早版本），也可以使用它来导入或导出作业。你可以运行以下命令来导入你的
    Jenkins 作业 XML 文件：
- en: '[PRE7]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: An alternative authentication method is to use an access token by replacing
    the `-auth` option with the `username:token` argument.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种身份验证方法是使用访问令牌，通过将 `-auth` 选项替换为 `username:token` 参数。
- en: 7.5 Configuring SSH authentication with Jenkins
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 配置 Jenkins 的 SSH 验证
- en: Previously, you learned to configure GitHub on Jenkins with username and password
    credentials. We also covered how to create a GitHub API access token with granular
    permissions. This section covers how to use SSH keys instead to authenticate with
    project repositories.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你学习了如何使用用户名和密码凭据在 Jenkins 上配置 GitHub。我们还介绍了如何创建具有细粒度权限的 GitHub API 访问令牌。本节将介绍如何使用
    SSH 密钥而不是凭据来验证项目仓库。
- en: Note You can generate a one-purpose SSH key for SSH authentication with remote
    Git repositories by using the `ssh-keygen` command.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以使用 `ssh-keygen` 命令生成一个用于 SSH 验证的单一用途 SSH 密钥。
- en: First, configure the Jenkins public SSH key on GitHub. You can configure SSH
    on the GitHub repository by going to the repository settings and adding a deploy
    key from the Deploy Keys section. Or simply configure the SSH key globally from
    the user profile settings. Give a name such as `Jenkins` and paste the public
    key (from the id_rsa.pub file); see figure 7.31.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，配置 GitHub 上的 Jenkins 公共 SSH 密钥。你可以通过访问仓库设置并在部署密钥部分添加部署密钥来配置 GitHub 仓库上的 SSH。或者，简单地从用户配置文件设置中全局配置
    SSH 密钥。给一个如 `Jenkins` 的名称，并将公钥（从 id_rsa.pub 文件中）粘贴进去；见图 7.31。
- en: '![](Images/CH07_F31_Labouardy.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F31_Labouardy.png)'
- en: Figure 7.31 GitHub SSH configuration
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.31 GitHub SSH 配置
- en: Note Once a key has been attached to one repository as a deploy key, it cannot
    be used on another repository.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一旦一个密钥被用作一个仓库的部署密钥，它就不能用于另一个仓库。
- en: 'To determine whether the key is successfully configured, type the following
    command on your Jenkins SSH session. Use the `-i` flag to provide the path to
    the Jenkins private key:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定密钥是否已成功配置，请在你的 Jenkins SSH 会话中输入以下命令。使用 `-i` 标志提供 Jenkins 私钥的路径：
- en: '[PRE8]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the response looks something like `Hi` `username`, the key has been properly
    configured.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应看起来像 `Hi` `username`，则密钥已正确配置。
- en: Now go to Credentials from the left pane inside the Jenkins console and click
    Global. Then select Add Credentials and create a credential of type SSH Username
    with Private Key. Give it a name and set the value of the SSH private key, as
    shown in figure 7.32\. The Username should be the username for the GitHub account
    that hosts the project. In the Passphrase text box, write the passphrase given
    while generating the SSH RSA key. If not set, leave it blank.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到 Jenkins 控制台左侧的凭据，并点击全局。然后选择添加凭据，创建一个类型为 SSH 用户名的凭据。给它一个名称，并设置 SSH 私钥的值，如图
    7.32 所示。用户名应该是托管项目的 GitHub 账户的用户名。在密码短语文本框中，写下生成 SSH RSA 密钥时给出的密码短语。如果没有设置，请留空。
- en: '![](Images/CH07_F32_Labouardy.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F32_Labouardy.png)'
- en: Figure 7.32 Configuring GitHub SSH credentials on Jenkins
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.32 在 Jenkins 上配置 GitHub SSH 凭据
- en: Head back to the Jenkins job, and under Branch Sources, choose Git from the
    drop-down list, set the repository SSH clone URL, and select the saved credentials
    title name; see figure 7.33.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 Jenkins 作业，在分支源下，从下拉列表中选择 Git，设置仓库 SSH 克隆 URL，并选择已保存的凭据标题名称；见图 7.33。
- en: '![](Images/CH07_F33_Labouardy.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH07_F33_Labouardy.png)'
- en: Figure 7.33 Configuring the Jenkins job to use SSH keys
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.33 配置 Jenkins 作业以使用 SSH 密钥
- en: 'If you go to the build output, it should clearly list that the SSH key is being
    used for authentication. The following is sample output highlighting the same:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看构建输出，它应该清楚地列出正在使用SSH密钥进行身份验证。以下是一个突出显示相同内容的示例输出：
- en: '![](Images/CH07_F33_UN02_Labouardy.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F33_UN02_Labouardy.png)'
- en: Until now, the `Checkout` stage has been using the credentials and settings
    configured in the current Jenkins job. If you want to customize the settings and
    use specific credentials, you can replace it with the following listing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`Checkout`阶段一直使用当前Jenkins作业中配置的凭据和设置。如果您想自定义设置并使用特定的凭据，可以替换以下列表。
- en: Listing 7.3 Customized git clone command
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.3 定制的git clone命令
- en: '[PRE9]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This example will clone the develop branch of the movies-loader GitHub repository,
    using the SSH credentials saved in the github-ssh Jenkins credentials.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本例将使用存储在github-ssh Jenkins凭证中的SSH凭据克隆movies-loader GitHub仓库的develop分支。
- en: 7.6 Triggering Jenkins builds with GitHub webhooks
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 使用GitHub webhooks触发Jenkins构建
- en: So far, we have always built the pipeline manually by clicking the Build Now
    button. It works but is not very convenient. All team members would have to remember
    that after committing to the repository, they need to open Jenkins and start the
    build.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们总是通过点击构建现在按钮手动构建管道。它工作得很好，但不是很方便。所有团队成员都必须记住，在提交到仓库后，他们需要打开Jenkins并开始构建。
- en: To trigger the jobs by push event, we will create a webhook on the GitHub repository
    of each service, as illustrated in figure 7.34\. Remember, a Jenkinsfile should
    also be present on the respective branch to tell Jenkins what it needs to do when
    it finds a change in the repository.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过推送事件触发作业，我们将在每个服务的GitHub仓库上创建一个webhook，如图7.34所示。记住，相应的分支上也应该有一个Jenkinsfile，以便告诉Jenkins在发现仓库中的更改时需要做什么。
- en: Note *Webhooks* are user-defined HTTP callbacks. They are triggered by an event
    in a web application and can facilitate integrating different applications or
    third-party APIs.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*Webhooks*是用户定义的HTTP回调。它们由Web应用程序中的事件触发，可以促进不同应用程序或第三方API的集成。
- en: '![](Images/CH07_F34_Labouardy.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F34_Labouardy.png)'
- en: Figure 7.34 Webhook explained
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.34 Webhook解释
- en: Navigate to the GitHub repository that you want to connect to Jenkins and click
    the repository Settings option. In the menu on the left, click Webhooks, as shown
    in figure 7.35.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到您想要连接到Jenkins的GitHub仓库，并点击仓库设置选项。在左侧菜单中，点击Webhooks，如图7.35所示。
- en: GitHub webhooks allow you to notify external services when certain Git events
    happen (push, merge, commit, fork, and so forth) by sending a POST request to
    the configured service URL.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub webhooks允许您通过向配置的服务URL发送POST请求，在发生某些Git事件（推送、合并、提交、分支等）时通知外部服务。
- en: '![](Images/CH07_F35_Labouardy.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F35_Labouardy.png)'
- en: Figure 7.35 GitHub Webhooks section
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.35 GitHub Webhooks部分
- en: 'Click the Add Webhook button to bring up the associated dialog, shown in figure
    7.36\. Fill in the form with the following values:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 点击添加Webhook按钮，弹出相关对话框，如图7.36所示。填写以下值：
- en: 'The payload URL should be in the following format: JENKINS_URL/github-webhook/
    (make sure it includes the last forward slash).'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载URL应采用以下格式：JENKINS_URL/github-webhook/（确保包括最后一个正斜杠）。
- en: The content type can be either application/json or application/x-www-form-urlencoded.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容类型可以是application/json或application/x-www-form-urlencoded。
- en: Select the push event as a trigger and leave the Secret field empty (unless
    a secret has been created and configured in the Jenkins Configure System > GitHub
    Plugin section).
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择推送事件作为触发器，并保留密钥字段为空（除非在Jenkins Configure System > GitHub Plugin部分创建了并配置了密钥）。
- en: '![](Images/CH07_F36_Labouardy.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F36_Labouardy.png)'
- en: Figure 7.36 Jenkins webhook settings
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.36 Jenkins webhook设置
- en: Leave the rest of the options at their default values and then click the Add
    Webhook button. A test payload should be sent to Jenkins to set up the hook. If
    the payload is successfully received by Jenkins, you should see the webhook with
    a green check mark, as shown in figure 7.37.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 将其余选项保留为默认值，然后点击添加Webhook按钮。应向Jenkins发送测试负载以设置钩子。如果负载成功被Jenkins接收，您应该看到带有绿色勾选标记的webhook，如图7.37所示。
- en: '![](Images/CH07_F37_Labouardy.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F37_Labouardy.png)'
- en: Figure 7.37 Jenkins webhook settings
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.37 Jenkins webhook设置
- en: 'With these GitHub updates done, if you push some changes to the Git repository,
    a new event should get kicked off automatically. In this scenario, we update the
    README.md file:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些GitHub更新后，如果您将更改推送到Git仓库，应该会自动触发一个新事件。在这种情况下，我们更新README.md文件：
- en: '![](Images/CH07_F37_UN03_Labouardy.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F37_UN03_Labouardy.png)'
- en: Go back to your Jenkins project, and you’ll see that a new job was triggered
    automatically from the commit we made at the previous step. Click the little arrow
    next to the job and choose Console Output. Figure 7.38 shows the output.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 返回您的Jenkins项目，您将看到在上一步骤中执行的提交自动触发了新的作业。点击作业旁边的箭头并选择控制台输出。图7.38显示了输出。
- en: The update readme message confirms that the build was triggered automatically
    upon pushing the new README.md to the GitHub repository. Now, every time you publish
    your changes to your remote repository, GitHub will trigger your new Jenkins job.
    Create a similar webhook on the remaining GitHub repositories by following the
    same procedure.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 更新README的消息确认，在将新的README.md推送到GitHub仓库后，构建被自动触发。现在，每次您将更改发布到远程仓库时，GitHub都会触发您的新Jenkins作业。通过遵循相同的程序，在剩余的GitHub仓库上创建类似的webhook。
- en: '![](Images/CH07_F38_Labouardy.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F38_Labouardy.png)'
- en: Figure 7.38 GitHub push event
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.38 GitHub推送事件
- en: Note If you want SVN users to continuously trigger Jenkins jobs after every
    commit, you can either configure Jenkins to periodically poll the SVN server or
    set up a post-commit hook on the remote repository.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您想使SVN用户在每次提交后持续触发Jenkins作业，您可以选择配置Jenkins定期轮询SVN服务器，或者在远程仓库上设置post-commit钩子。
- en: In a different situation, the Jenkins dashboard might not be accessible from
    a public network. Instead of executing jobs manually, you can set up a public
    reverse proxy as middleware between the GitHub server and Jenkins, and configure
    the GitHub webhook to use the middleware URL. Figure 7.39 explains how to use
    AWS managed services to set up a webhook forwarder for a Jenkins instance within
    a VPC.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的情况下，Jenkins仪表板可能无法从公共网络访问。您可以通过在GitHub服务器和Jenkins之间设置一个公共反向代理作为中间件，并配置GitHub
    webhook使用中间件URL来代替手动执行作业。图7.39解释了如何使用AWS托管服务在VPC内为Jenkins实例设置webhook转发器。
- en: '![](Images/CH07_F39_Labouardy.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F39_Labouardy.png)'
- en: Figure 7.39 GitHub webhook setup with API Gateway
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.39使用API网关设置GitHub webhook
- en: Note You can generalize this approach to other services too, such as Bitbucket
    or DockerHub—or anything, really, that emits webhooks.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以将这种方法推广到其他服务，例如Bitbucket或DockerHub——或者任何实际上会发出webhooks的服务。
- en: If you’re using AWS as a cloud provider, you can use a managed proxy called
    Amazon API Gateway to invoke a Lambda function when a POST request is invoked
    on a specific endpoint, as shown in figure 7.40.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用AWS作为云提供商，您可以使用名为Amazon API Gateway的托管代理，在特定端点上对POST请求进行调用时调用Lambda函数，如图7.40所示。
- en: '![](Images/CH07_F40_Labouardy.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F40_Labouardy.png)'
- en: Figure 7.40 Triggering a Lambda function with API Gateway
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.40使用API网关触发Lambda函数
- en: The Lambda function will receive the GitHub payload from API Gateway and relay
    it to the Jenkins server. The following listing is a function entry point written
    in JavaScript.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数将从API网关接收GitHub有效负载并将其转发到Jenkins服务器。以下列表是一个用JavaScript编写的函数入口点。
- en: Listing 7.4 Lambda function handler
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.4 Lambda函数处理程序
- en: '[PRE10]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To deploy the GitHub webhook and AWS resources, we will use Terraform. But
    first, we need to create a deployment package with the Lambda function index.js
    entry point. The deployment package is a zip file that can be generated with the
    following command:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署GitHub webhook和AWS资源，我们将使用Terraform。但首先，我们需要创建一个包含Lambda函数index.js入口点的部署包。部署包是一个可以通过以下命令生成的zip文件：
- en: '[PRE11]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note This section assumes you’re familiar with the usual Terraform plan/apply
    workflow. If you’re new to Terraform, refer to chapter 5.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本节假设您熟悉Terraform的常规计划/应用工作流程。如果您是Terraform的新手，请参阅第5章。
- en: Next, we define a lambda.tf file containing the Terraform resource definition
    for an AWS Lambda function. We set the runtime to be a Node.js runtime environment
    (the Lambda handler is written in JavaScript). We define an environment variable
    named `JENKINS_URL` with a value pointing to the Jenkins web dashboard URL, as
    shown in the next listing.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个名为lambda.tf的文件，其中包含AWS Lambda函数的Terraform资源定义。我们将运行时设置为Node.js运行环境（Lambda处理程序是用JavaScript编写的）。我们定义一个名为`JENKINS_URL`的环境变量，其值指向Jenkins网页仪表板的URL，如下一列表所示。
- en: Listing 7.5 Lambda function based on Node.js runtime
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.5基于Node.js运行的Lambda函数
- en: '[PRE12]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Then, we define an API Gateway RESTful API to trigger the preceding Lambda function
    when a POST request occurs on the /webhook endpoint. Create a new file, apigateway.tf,
    in the same directory as our lambda.tf from the previous step and paste the following
    content.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个 API Gateway RESTful API，当在 /webhook 端点发生 POST 请求时触发前面的 Lambda 函数。在上一步骤的
    lambda.tf 相同目录下创建一个新文件 apigateway.tf，并粘贴以下内容。
- en: Listing 7.6 API Gateway RESTful API
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 API Gateway RESTful API
- en: '[PRE13]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, in the following listing, we create an API Gateway deployment to activate
    the configuration and expose the API at a URL that can be used for webhook configuration.
    We use a Terraform output variable to display the API deployment URL by referencing
    the API deployment stage.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在以下列表中，我们创建一个 API Gateway 部署以激活配置，并在可用于 webhook 配置的 URL 上公开 API。我们使用 Terraform
    输出变量通过引用 API 部署阶段来显示 API 部署 URL。
- en: Listing 7.7 API new deployment stage
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 API 新部署阶段
- en: '[PRE14]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Before issuing the `terraform` `apply` command, you need to define the variables
    used in the preceding resources. The variables.tf file will contain the list of
    variables, which are detailed in table 7.3.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在发出 `terraform apply` 命令之前，您需要定义前面资源中使用的变量。variables.tf 文件将包含变量列表，这些变量在表 7.3
    中详细说明。
- en: Table 7.3 GitHub webhook proxy’s Terraform variables
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.3 GitHub webhook 代理的 Terraform 变量
- en: '| Variable | Type | Value | Description |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 类型 | 值 | 描述 |'
- en: '| `region` | String | `none` | The AWS region in which to deploy AWS resources.
    It can also be sourced from the `AWS_REGION` environment variable. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `region` | 字符串 | `none` | 部署 AWS 资源的 AWS 区域。它也可以从 `AWS_REGION` 环境变量中获取。|'
- en: '| `shared_creden tials_file` | String | `none` | The path to the shared credentials
    file. If this is not set and a profile specified, ~/.aws/credentials will be used.
    |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `shared_credentials_file` | 字符串 | `none` | 共享凭据文件的路径。如果没有设置此值且指定了配置文件，则使用
    ~/.aws/credentials。|'
- en: '| `aws_profile` | String | `profile` | The AWS profile name as set in the shared
    credentials file. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `aws_profile` | 字符串 | `profile` | 在共享凭据文件中设置的 AWS 配置文件名称。|'
- en: '| `jenkins_url` | String | `none` | The Jenkins URL, which has the format http://IP:8080,
    or uses HTTPS if an SSL certificate is being used. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `jenkins_url` | 字符串 | `none` | Jenkins URL，格式为 http://IP:8080，或使用 HTTPS（如果使用
    SSL 证书）。|'
- en: When Terraform finishes deploying the AWS resources, a new Lambda function called
    `GitHubWehookForwarder` should be created with a trigger of type API Gateway,
    as shown in figure 7.41.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Terraform 完成部署 AWS 资源后，应创建一个名为 `GitHubWehookForwarder` 的新 Lambda 函数，其触发类型为
    API Gateway，如图 7.41 所示。
- en: '![](Images/CH07_F41_Labouardy.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F41_Labouardy.png)'
- en: Figure 7.41 `GitHubWebhookForwarder` Lambda function
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.41 `GitHubWebhookForwarder` Lambda 函数
- en: Furthermore, Terraform will display the RESTful API deployment URL, which you
    can use to create a webhook on the target GitHub repository, as shown in figure
    7.42.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Terraform 将显示 RESTful API 部署 URL，您可以使用它来在目标 GitHub 仓库上创建 webhook，如图 7.42
    所示。
- en: '![](Images/CH07_F42_Labouardy.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F42_Labouardy.png)'
- en: Figure 7.42 GitHub webhook based on API Gateway URL
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.42 基于 API Gateway URL 的 GitHub webhook
- en: Webhooks should be flowing now. You can make a change to your repository and
    check that a build starts soon after. You also can add an extra security layer,
    by requiring a request secret and validating the incoming request signature on
    the Lambda function side.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Webhooks 应该现在正在流动。您可以对您的仓库进行更改，并检查构建是否很快开始。您还可以通过要求请求密钥并在 Lambda 函数端验证传入请求签名来添加额外的安全层。
- en: If you’re running Jenkins locally, you can use a build trigger to poll SCM and
    schedule it to run periodically, as shown in figure 7.43\. In such a case, Jenkins
    would regularly check the repository, and if anything changed, it would run the
    job.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在本地运行 Jenkins，可以使用构建触发器轮询 SCM 并定期运行，如图 7.43 所示。在这种情况下，Jenkins 将定期检查仓库，如果发生任何更改，它将运行作业。
- en: '![](Images/CH07_F43_Labouardy.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH07_F43_Labouardy.png)'
- en: Figure 7.43 Under the job’s settings, you can define the interval of checks.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.43 在作业设置下，您可以定义检查的间隔。
- en: After running the pipeline manually for the first time, the automatic trigger
    is set. Then it checks GitHub every minute, and for new commits, starts a build.
    To test that it works as expected, you can commit and push anything to the GitHub
    repository and see that the build starts.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 首次手动运行管道后，自动触发器被设置。然后它每分钟检查 GitHub，对于新的提交，开始构建。为了测试它是否按预期工作，您可以将任何内容提交到 GitHub
    仓库并查看构建是否开始。
- en: Note Polling SCM, even if it’s less intuitive, might be useful if Git commits
    are frequent and the build takes a long time, so executing a build upon a push
    event every time would cause an overload.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：轮询源代码管理（SCM），即使它不太直观，如果Git提交频繁且构建时间较长，可能仍然有用，因为每次推送事件都执行构建可能会导致过载。
- en: So far, you have learned how to integrate Git repositories with Jenkins and
    define multibranch pipeline jobs. And we have ended up creating our first complete
    commit pipeline. However, with the current state, it doesn’t do much. In the following
    chapters, we will see what improvements can be made to make the commit pipeline
    even better, and we will start by running automated tests within the Jenkins pipelines.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了如何将Git仓库与Jenkins集成并定义多分支流水线作业。我们最终创建了我们第一个完整的提交流水线。然而，在当前状态下，它并没有做太多。在接下来的章节中，我们将看到可以对提交流水线进行哪些改进，以便使其更加完善，并且我们将从在Jenkins流水线中运行自动化测试开始。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A webhook is a mechanism to automatically trigger the build of a Jenkins project
    upon a commit pushed in a remote Git repository.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webhook是一种机制，可以在远程Git仓库中提交提交时自动触发Jenkins项目的构建。
- en: The development workflow should be carefully chosen inside the team or organization
    because it affects the CI process and defines the way the code is developed.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队或组织内部应仔细选择开发工作流程，因为它会影响持续集成（CI）过程并定义代码的开发方式。
- en: Using multi-repo or mono-repo strategies to organize the codebase will define
    the complexity of a CI/CD pipeline as the number of applications evolves within
    an organization.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多仓库或单仓库策略来组织代码库将定义持续集成/持续部署（CI/CD）管道的复杂性，因为组织内部的应用程序数量会随着时间而演变。
- en: A pipeline can go through the standard code development process (code review,
    pull requests, automated testing, and so forth) when a Jenkinsfile and application
    source code live together on the same Git repository.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Jenkinsfile和应用程序源代码位于同一Git仓库中时，流水线可以经过标准的代码开发过程（代码审查、拉取请求、自动化测试等）。
- en: Jenkins stores configuration files for the jobs it runs in an XML file. Editing
    these XML configuration files has the same effect as editing Jenkins jobs through
    the web dashboard.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins将运行作业的配置文件存储在一个XML文件中。编辑这些XML配置文件的效果与通过Web仪表板编辑Jenkins作业相同。
- en: A reverse proxy can be useful to let Git webhooks reach a running Jenkins server
    behind a firewall.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向代理可以用来让Git webhook到达位于防火墙后面的运行中的Jenkins服务器。
