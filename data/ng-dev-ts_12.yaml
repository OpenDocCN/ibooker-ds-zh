- en: Chapter 13\. Interacting with servers using the WebSocket protocol
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第13章 使用WebSocket协议与服务器交互
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Implementing a server data push to Angular clients
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现服务器数据推送到Angular客户端
- en: Broadcasting data from the server to multiple clients
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从服务器向多个客户端广播数据
- en: Splitting ngAuction into two projects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将ngAuction拆分为两个项目
- en: Implementing bidding in ngAuction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ngAuction中实现竞标
- en: 'WebSocket is a low-overhead binary protocol supported by all modern web browsers
    (see [https://en.wikipedia.org/wiki/WebSocket](https://en.wikipedia.org/wiki/WebSocket)).
    It allows bidirectional message-oriented streaming of text and binary data between
    browsers and web servers. In contrast to HTTP, WebSocket is not a request/response-based
    protocol, and both server apps and client apps can initiate data push to the other
    party as soon as the data becomes available, in real time. This makes the WebSocket
    protocol a good fit for the following types of applications:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 是一种由所有现代网络浏览器支持的低开销二进制协议（参见 [https://en.wikipedia.org/wiki/WebSocket](https://en.wikipedia.org/wiki/WebSocket)）。它允许浏览器和Web服务器之间双向的消息流式传输文本和二进制数据。与HTTP不同，WebSocket不是一个基于请求/响应的协议，服务器应用程序和客户端应用程序可以在数据可用时立即向对方发起数据推送，实现实时通信。这使得WebSocket协议非常适合以下类型的应用程序：
- en: Live trading/auctions/sports notifications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时交易/拍卖/体育通知
- en: Controlling medical equipment over the web
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过网络控制医疗设备
- en: Chat applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聊天应用程序
- en: Multiplayer online games
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多玩家在线游戏
- en: Real-time updates in social streams
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社交流中的实时更新
- en: Live charts
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时图表
- en: 'All of these apps have one thing in common: there’s a server (or a device)
    that may need to send an immediate notification to the user because some important
    event happened elsewhere. This is different from the use case when the user decides
    to send a request to the server for fresh data. For example, if a stock trade
    happens on the stock exchange, the notification has to be immediately sent to
    all users.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些应用程序都有一个共同点：存在一个服务器（或设备），可能需要立即向用户发送通知，因为某个重要事件发生在其他地方。这与用户决定向服务器发送请求以获取新数据的使用案例不同。例如，如果股票交易在证券交易所发生，通知必须立即发送给所有用户。
- en: Another example is an online auction. If user Joe is considering bidding on
    a certain product, and user Mary (located 1,000 miles away) decides to increase
    the bid on the same product, you’d better push the notification to Joe right away
    as opposed to waiting until Joe refreshes the window.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是在线拍卖。如果用户Joe正在考虑对某个产品进行竞标，而用户Mary（位于1,000英里之外）决定提高对该产品的出价，您最好立即将通知推送给Joe，而不是等到Joe刷新窗口。
- en: We’ll start this chapter with a brief comparison of HTTP and WebSocket protocols,
    and then we’ll show you how a Node server can push data to a plain web page and
    to an Angular app.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，简要比较HTTP和WebSocket协议，然后向您展示如何使用Node服务器将数据推送到普通网页和Angular应用程序。
- en: 'In the hands-on section, you’ll continue working on ngAuction. You’ll start
    by splitting ngAuction into two projects: client and server. The server app will
    start two servers: the HTTP server will serve data, and the WebSocket server can
    receive user bids and push real-time bid notifications, emulating a scenario in
    which multiple users can bid on auctioned products. The Angular client interacts
    with both servers.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践部分，您将继续在ngAuction上工作。您将从将ngAuction拆分为两个项目：客户端和服务器开始。服务器应用程序将启动两个服务器：HTTP服务器将提供数据，WebSocket服务器可以接收用户出价并推送实时出价通知，模拟多个用户可以对拍卖产品进行竞价的场景。Angular客户端与这两个服务器进行交互。
- en: 13.1\. Comparing HTTP and WebSockets
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1\. 比较HTTP和WebSocket
- en: With the request-based HTTP protocol, a client sends a request over a connection
    and waits for a response to come back, as shown in [figure 13.1](#ch13fig01).
    Both the request and the response use the same browser-server connection. First,
    the request goes out, and then the response comes back via the same “wire.” Think
    of a narrow bridge over a river where cars from both sides have to take turns
    crossing the bridge. In the web realm, this type of communications is called *half-duplex*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 基于请求的HTTP协议，客户端通过连接发送请求并等待响应返回，如图13.1所示。请求和响应都使用相同的浏览器-服务器连接。首先，请求发送出去，然后响应通过相同的“线路”返回。想象一下，河上的一座狭窄桥梁，两边的汽车必须轮流过桥。在Web领域，这种类型的通信被称为*半双工*。
- en: Figure 13.1\. Half-duplex communication
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.1\. 半双工通信
- en: '![](Images/13fig01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13fig01.jpg)'
- en: 'The WebSocket protocol allows data to travel in both directions simultaneously
    (*full-duplex*) over the same connection, as shown in [figure 13.2](#ch13fig02),
    and any party can initiate the data exchange. It’s like a two-lane road. Another
    analogy is a phone conversation where two callers can speak and be heard at the
    same time. The WebSocket connection is kept alive, which has an additional benefit:
    low latency in the interaction between the server and the client.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 协议允许数据在同一连接上同时双向传输（*全双工*），如图 13.2 所示，任何一方都可以启动数据交换。这就像是一条双车道道路。另一个类比是电话通话，两个通话者可以同时说话并被听到。WebSocket
    连接保持活跃，这有额外的益处：服务器和客户端之间交互的低延迟。
- en: Figure 13.2\. Full-duplex communication
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.2\. 全双工通信
- en: '![](Images/13fig02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片 13.2](Images/13fig02.jpg)'
- en: A typical HTTP request/response adds several hundred bytes (HTTP headers) to
    the application data. Say you want to write a web app that reports the latest
    stock prices every second. With HTTP, such an app would need to send an HTTP request
    (about 300 bytes) and receive a stock price that would arrive with an additional
    300 bytes of an HTTP response object.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 HTTP 请求/响应会在应用数据上添加几百字节（HTTP 头部）。假设你想编写一个每秒报告最新股票价格的 Web 应用程序。使用 HTTP，这样的应用程序需要发送一个
    HTTP 请求（大约 300 字节）并接收一个股票价格，该价格会附带额外的 300 字节的 HTTP 响应对象。
- en: 'With WebSockets, the overhead is as low as a couple of bytes. Besides, there’s
    no need to keep sending requests for the new price quote every second—this stock
    may not be traded for a while. Only when the stock price changes will the server
    push the new value to the client. Note the following observation (see goo.gl/zjj7Es):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 WebSocket，开销低至几个字节。此外，无需每秒都发送请求以获取新的价格报价——这种股票可能一段时间内不会交易。只有当股票价格发生变化时，服务器才会将新的值推送到客户端。注意以下观察结果（见
    goo.gl/zjj7Es）：
- en: '*Reducing kilobytes of data to 2 bytes is more than “a little more byte efficient,”
    and reducing latency from 150 ms (TCP round trip to set up the connection plus
    a packet for the message) to 50 ms (just the packet for the message) is far more
    than marginal. In fact, these two factors alone are enough to make WebSocket seriously
    interesting to Google.*'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*将千字节的数据减少到 2 字节不仅仅是“稍微节省一些字节”，将延迟从 150 毫秒（TCP 往返设置连接加上消息的包）减少到 50 毫秒（仅仅是消息的包）则远远超出了边际。实际上，这两个因素单独就足以使
    WebSocket 对 Google 来说变得非常有趣。*'
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Ian Hickson*'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*伊恩·希克斯*'
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: Although most browsers support the binary protocol HTTP/2 (see [https://http2.github.io](https://http2.github.io))—which
    is more efficient than HTTP and also allows data push from the servers—it’s not
    a replacement for the WebSocket protocol. The WebSocket protocol offers an API
    that allows pushing *data* to the client’s app running in the browser, whereas
    HTTP/2 pushes *static resources* to the browser and is mainly for faster app delivery.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数浏览器支持二进制协议 HTTP/2（见 [https://http2.github.io](https://http2.github.io)）——它比
    HTTP 更高效，并且还允许服务器推送数据——但它并不是 WebSocket 协议的替代品。WebSocket 协议提供了一个 API，允许将 *数据* 推送到浏览器中运行的客户端应用程序，而
    HTTP/2 推送 *静态资源* 到浏览器，主要用于更快的应用程序交付。
- en: '|  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Every browser supports a `WebSocket` object for creating and managing a socket
    connection to the server (see [http://mng.bz/1j4g](http://mng.bz/1j4g)). Initially,
    the browser establishes a regular HTTP connection with the server, but then your
    app requests a connection upgrade specifying the server’s URL that supports the
    WebSocket connection. After that, the communication succeeds without the need
    of HTTP. The URLs of the WebSocket endpoints start with ws instead of http—for
    instance, ws://localhost:8085.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个浏览器都支持一个 `WebSocket` 对象，用于创建和管理到服务器的套接字连接（见 [http://mng.bz/1j4g](http://mng.bz/1j4g)）。最初，浏览器会与服务器建立一个常规的
    HTTP 连接，但随后你的应用程序请求升级连接，指定支持 WebSocket 连接的服务器 URL。之后，通信成功，无需 HTTP。WebSocket 端点的
    URL 以 ws 开头而不是 http——例如，ws://localhost:8085。
- en: The WebSocket protocol is based on events and callbacks. For example, when your
    browser app establishes a connection with the server, it receives the `connection`
    event, and your app invokes a callback to handle this event. To handle the data
    that the server may send over this connection, expect the `message` event providing
    the corresponding callback. If the connection is closed, the `close` event is
    dispatched so your app can react accordingly. In case of an error, the `WebSocket`
    object gets the `error` event.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket协议基于事件和回调。例如，当您的浏览器应用与服务器建立连接时，它会接收到`connection`事件，并且您的应用调用回调来处理此事件。为了处理服务器可能通过此连接发送的数据，请期待提供相应回调的`message`事件。如果连接关闭，`close`事件会被触发，以便您的应用可以相应地做出反应。在发生错误的情况下，`WebSocket`对象会接收到`error`事件。
- en: On the server side, you’ll have to process similar events. Their names may be
    different depending on the WebSocket software you use on the server. Let’s write
    some code where a Node server will send data to the Angular app over WebSockets.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，您将不得不处理类似的事件。它们的名称可能取决于您在服务器上使用的WebSocket软件。让我们编写一些代码，其中Node服务器将通过WebSocket向Angular应用发送数据。
- en: 13.2\. Pushing data from a Node server to a plain client
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2. 从Node服务器向普通客户端推送数据
- en: 'WebSockets are supported by most server-side platforms (Java, .NET, Python,
    and others). In [chapter 12](kindle_split_021.xhtml#ch12), you started working
    with Node servers, and you’ll continue using Node for implementing your WebSocket
    server. In this section, you’ll implement one particular use case: the server
    pushes data to a browser client as soon as the client connects to the socket.
    Since either party can start sending data over the WebSocket connection, you’ll
    see that WebSockets aren’t about request/response communication. Your simple client
    won’t need to send a request for data—the server will initiate the communications.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数服务器端平台（Java、.NET、Python等）都支持WebSocket。在第12章中，您开始使用Node服务器进行工作，您将继续使用Node来实现您的WebSocket服务器。在本节中，您将实现一个特定的用例：客户端连接到socket后，服务器立即向浏览器客户端推送数据。由于任一方都可以开始通过WebSocket连接发送数据，您会看到WebSocket并不涉及请求/响应通信。您的简单客户端不需要发送数据请求——服务器将发起通信。
- en: 'Several Node packages implement the WebSocket protocol, and you’ll use the
    npm package called `ws` ([www.npmjs.com/package/ws](http://www.npmjs.com/package/ws)).
    You can install this package and its type definitions by entering the following
    commands in your project directory:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 几个Node包实现了WebSocket协议，您将使用名为`ws`的npm包([www.npmjs.com/package/ws](http://www.npmjs.com/package/ws))。您可以在项目目录中输入以下命令来安装此包及其类型定义：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The type definitions are needed so the TypeScript compiler won’t complain when
    you use the API from the `ws` package. Besides, this file is handy for seeing
    the APIs and types available.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 需要类型定义，这样TypeScript编译器就不会在您使用`ws`包的API时发出警告。此外，此文件便于查看可用的API和类型。
- en: '|  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The code that comes with this chapter has a directory called server, which contains
    the file package.json that lists both `ws` and `@types/ws` as dependencies. You
    just need to run the `npm install` command. Source code can be found at [https://github.com/Farata/angulartypescript](https://github.com/Farata/angulartypescript)
    and [www.manning.com/books/angular-development-with-typescript-second-edition](http://www.manning.com/books/angular-development-with-typescript-second-edition).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本章附带代码中有一个名为`server`的目录，其中包含名为`package.json`的文件，列出了`ws`和`@types/ws`作为依赖项。您只需运行`npm
    install`命令。源代码可以在[https://github.com/Farata/angulartypescript](https://github.com/Farata/angulartypescript)和[www.manning.com/books/angular-development-with-typescript-second-edition](http://www.manning.com/books/angular-development-with-typescript-second-edition)找到。
- en: '|  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Your first WebSocket server will be pretty simple: it’ll push the text “This
    message was pushed by the WebSocket server” to an HTML/JavaScript client (no Angular)
    as soon as the socket connection is established. We purposely don’t want the client
    to send any requests to the server so we can illustrate that a socket is a two-way
    street and that the server can push data without any request ceremony.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您的第一个WebSocket服务器将会非常简单：一旦建立了socket连接，它就会将文本“此消息由WebSocket服务器推送”推送到HTML/JavaScript客户端（不使用Angular）。我们故意不希望客户端向服务器发送任何请求，这样我们可以说明socket是双向的，服务器可以在没有任何请求仪式的情况下推送数据。
- en: Your app creates two servers. The HTTP server runs on port 8000 and is responsible
    for sending an HTML page to the browser. When this page is loaded, it immediately
    connects to the WebSocket server that runs on port 8085\. This server will push
    the message with the greeting as soon as the connection is established. The code
    of this app is located in the server/simple-websocket-server.ts file and is shown
    in the following listing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序创建了两个服务器。HTTP 服务器在端口 8000 上运行，负责向浏览器发送 HTML 页面。当此页面加载时，它会立即连接到运行在端口 8085
    上的 WebSocket 服务器。此服务器将在连接建立后立即推送带有问候的消息。此应用程序的代码位于 server/simple-websocket-server.ts
    文件中，如下所示。
- en: Listing 13.1\. simple-websocket-server.ts
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.1\. simple-websocket-server.ts
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* You’ll use Server from the ws module to instantiate a WebSocket server.**'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 你将使用 ws 模块中的 Server 来实例化 WebSocket 服务器。**'
- en: '***2* When the HTTP client connects with the root path, the HTTP server will
    send back this HTML file.**'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当 HTTP 客户端通过根路径连接时，HTTP 服务器将发送回此 HTML 文件。**'
- en: '***3* Starts the HTTP server on port 8000**'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在端口 8000 上启动 HTTP 服务器**'
- en: '***4* Starts the WebSocket server on port 8085**'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在端口 8085 上启动 WebSocket 服务器**'
- en: '***5* Listens to connection event from clients**'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 监听来自客户端的连接事件**'
- en: '***6* Pushes the message to the newly connected client**'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将消息推送到新连接的客户端**'
- en: '***7* Handles connection errors**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 处理连接错误**'
- en: As soon as any client connects to your WebSocket server via port 8085, the connection
    event is dispatched on the server, and it’ll also receive a reference to the object
    that represent this particular client’s connection. Using the `send()` method,
    the server sends the greeting to this client. If another client connects to the
    same socket on port 8085, it’ll also receive the same greeting.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦任何客户端通过端口 8085 连接到你的 WebSocket 服务器，服务器上就会触发连接事件，并且它还会收到代表此特定客户端连接的对象引用。使用
    `send()` 方法，服务器向此客户端发送问候。如果另一个客户端连接到同一端口的套接字，它也会收到相同的问候。
- en: '|  |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'As soon as the new client connects to the server, the reference to this connection
    is added to the `wsServer.clients` array so you can broadcast messages to all
    connected clients if needed: `wsServer.clients.forEach (client => client.send(''...''));`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新客户端连接到服务器，此连接的引用就会被添加到 `wsServer.clients` 数组中，这样你就可以在需要时向所有已连接的客户端广播消息：`wsServer.clients.forEach
    (client => client.send('...'));`。
- en: '|  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In your app, the HTTP and WebSocket servers run on different ports, but you
    could reuse the same port by providing the newly created `httpServer` instance
    to the constructor of the WebSocket server, as shown in the following listing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中，HTTP 和 WebSocket 服务器运行在不同的端口上，但你可以通过将新创建的 `httpServer` 实例提供给 WebSocket
    服务器的构造函数来重用相同的端口，如下所示。
- en: Listing 13.2\. Reusing the same port for both servers
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.2\. 两个服务器重用相同的端口
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Creates an instance of the HTTP server on port 8000**'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在端口 8000 上创建 HTTP 服务器实例**'
- en: '***2* Creates an instance of the WebSocket server based on the existing HTTP
    server**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 基于现有的 HTTP 服务器创建 WebSocket 服务器实例**'
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In the hands-on section, you’ll reuse port 8000 for both HTTP and WebSocket
    communications (see the ng-auction/server/ws-auction.ts file).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在动手实践部分，你将重用端口 8000 用于 HTTP 和 WebSocket 通信（请参阅 ng-auction/server/ws-auction.ts
    文件）。
- en: '|  |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The content of the server/simple-websocket-client.html file is shown in the
    next listing. This is a plain HTML/JavaScript client that doesn’t use any frameworks.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器/简单-websocket-client.html 文件的内容显示在下一条列表中。这是一个不使用任何框架的纯 HTML/JavaScript 客户端。
- en: Listing 13.3\. simple-websocket-client.html
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.3\. simple-websocket-client.html
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Establishes the socket connection**'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 建立套接字连接**'
- en: '***2* When the message arrives from the socket, displays its content in the
    <span> element**'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当消息从套接字到达时，在 <span> 元素中显示其内容**'
- en: '***3* In case of an error, the browser logs the error message on the console.**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果发生错误，浏览器将在控制台记录错误消息。**'
- en: When the browser downloads this file, its script connects to your WebSocket
    server at ws://localhost:8085\. At this point, the server upgrades the protocol
    from HTTP to WebSocket. Note that the protocol is `ws` and not `http`. For a secure
    socket connection, use the `wss` protocol.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器下载此文件时，其脚本会连接到你的 WebSocket 服务器，地址为 ws://localhost:8085。在此点，服务器将协议从 HTTP
    升级到 WebSocket。请注意，协议是 `ws` 而不是 `http`。对于安全的套接字连接，请使用 `wss` 协议。
- en: 'To see this sample in action, run `npm install` in the server directory, compile
    the code by running the `tsc` command, and then start the server as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此示例的实际效果，请在服务器目录中运行 `npm install`，通过运行 `tsc` 命令编译代码，然后按照以下方式启动服务器：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You’ll see the following messages on the console:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在控制台看到以下消息：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Open the Chrome browser and its Dev Tools at http://localhost:8000\. You’ll
    see the message, as shown on the left in [figure 13.3](#ch13fig03). Under the
    Network tab on the right, you see two requests made to the server at localhost.
    The first one loads the simple-websocket-client.html file, and the second makes
    a request to the WebSocket that’s open on port 8085 on your server.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Chrome 浏览器并打开其开发者工具，访问 http://localhost:8000。你将看到消息，如图 13.3 所示的左侧。在右侧的“网络”标签页中，你可以看到对本地服务器的两个请求。第一个请求加载了
    simple-websocket-client.html 文件，第二个请求是对服务器上 8085 端口上打开的 WebSocket 的请求。
- en: Figure 13.3\. Getting the message from the socket
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.3\. 从套接字获取消息
- en: '![](Images/13fig03_alt.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片 13.3](Images/13fig03_alt.jpg)'
- en: In this example, the HTTP protocol is used only to initially load the HTML file.
    Then the client requests the protocol upgrade to WebSocket (status code 101),
    and from then on this web page won’t use HTTP. You can monitor data going over
    the socket using the Frames tab in Chrome Developer Tools. In this demo, you wrote
    a WebSocket client in JavaScript using the browser’s native `WebSocket` object,
    but how can an Angular app consume or send messages to the server over WebSockets?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，仅使用 HTTP 协议最初加载 HTML 文件。然后客户端请求将协议升级到 WebSocket（状态码 101），从那时起，这个网页将不再使用
    HTTP。你可以使用 Chrome 开发者工具中的帧标签页监控通过套接字传输的数据。在这个演示中，你使用浏览器原生的 `WebSocket` 对象编写了一个
    WebSocket 客户端，但一个 Angular 应用如何通过 WebSocket 消费或发送消息到服务器呢？
- en: 13.3\. Using WebSockets in Angular clients
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3\. 在 Angular 客户端中使用 WebSocket
- en: In Angular, you usually wrap all communications with servers into injectable
    services. In several apps in [chapter 12](kindle_split_021.xhtml#ch12), you did
    it with `HttpClient`, and you’ll do it with the `WebSocket` object. But these
    two objects differ in that `HttpClient` is already an Angular injectable service
    that you’d *inject* into a service class of your app, whereas `WebSocket` is a
    native browser object, and you’ll *create* it inside a service class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Angular 中，你通常将所有与服务器的通信包装到可注入的服务中。在 [第 12 章](kindle_split_021.xhtml#ch12)
    中的一些应用程序中，你使用 `HttpClient` 做过这件事，你也将使用 `WebSocket` 对象。但这两个对象在 `HttpClient` 已经是一个
    Angular 可注入服务，你会在应用程序的服务类中 *注入* 它，而 `WebSocket` 是一个原生浏览器对象，你将在服务类内部 *创建* 它。
- en: There’s another major difference between `HttpClient` and `WebSocket`. If making
    HTTP requests using `HttpClient` would return an observable with a single value,
    the `WebSocket` object offers an API that’s easy to turn into an observable stream
    of multiple values like changing stock prices or bids on products.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient` 和 `WebSocket` 之间还有一个主要区别。如果使用 `HttpClient` 发送 HTTP 请求会返回一个包含单个值的可观察对象，那么
    `WebSocket` 对象提供了一个易于转换为多个值（如股票价格或产品竞标）的可观察流 API。'
- en: Think of a WebSocket as a data producer that can emit values, and an `Observable`
    object can relay these values to subscribers (for example, Angular components).
    In Angular, you can either manually create a service producing an observable stream
    from a WebSocket connection or use the `WebSocketSubject` offered by RxJS. In
    this chapter, you’ll see both ways of handling WebSocket messages in Angular clients.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将 WebSocket 视为一个可以发出值的 数据生产者，而 `Observable` 对象可以将这些值传递给订阅者（例如 Angular 组件）。在
    Angular 中，你可以手动创建一个从 WebSocket 连接生成可观察流的服务，或者使用 RxJS 提供的 `WebSocketSubject`。在本章中，你将看到在
    Angular 客户端处理 WebSocket 消息的两种方式。
- en: But first, let’s see how to wrap any `Observable` emitting values into an Angular
    service.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们看看如何将任何发出值的 `Observable` 包装到 Angular 服务中。
- en: 13.3.1\. Wrapping an observable stream into a service
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.1\. 将可观察流包装到服务中
- en: In this section, you’ll create an observable service that emits hardcoded values
    without connecting to any server. In [section D.5](kindle_split_028.xhtml#app04lev1sec5)
    in [appendix D](kindle_split_028.xhtml#app04), we explain how to use the `Observable.create()`
    method, providing an observer as an argument. If you haven’t read [appendix D](kindle_split_028.xhtml#app04)
    yet, do it now.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将创建一个可观察服务，该服务会发出硬编码的值，而不连接到任何服务器。在 [附录 D 的 13.5 节](kindle_split_028.xhtml#app04lev1sec5)中，我们解释了如何使用
    `Observable.create()` 方法，并提供一个观察者作为参数。如果你还没有阅读 [附录 D](kindle_split_028.xhtml#app04)，请现在阅读。
- en: The following listing creates a service with a method that takes an observer
    as an argument and emits the current time every second.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表创建了一个服务，该服务有一个方法，该方法接受一个观察者作为参数，并每秒发出当前时间。
- en: Listing 13.4\. observable.service.ts
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.4\. observable.service.ts
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Returns an observable stream of dates**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回日期的可观察流**'
- en: '***2* Creates an observable**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建可观察对象**'
- en: '***3* Provides an observer**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 提供观察者**'
- en: '***4* Emits the new date every second**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 每秒发射新的日期**'
- en: In this service, you create an instance of the `Observable` object, assuming
    that the subscriber will provide an `Observer` that knows what to do with the
    emitted data. Whenever the observable invokes the `next(new Date())` method on
    the observer, the subscriber will receive the current date and time. Your data
    stream never throws an error and never completes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在此服务中，你创建一个`Observable`对象的实例，假设订阅者将提供一个知道如何处理发射数据的`Observer`。每当可观察对象在观察者上调用`next(new
    Date())`方法时，订阅者将接收到当前的日期和时间。你的数据流永远不会抛出错误，也永远不会完成。
- en: You’ll inject the `ObservableService` into the `AppComponent`, which invokes
    the `createObservableService()` method and subscribes to its stream of values,
    creating an observer that knows what to do with data. The observer just assigns
    the received time to the `currentTime` variable that renders the time on the UI,
    as shown in the following listing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你将`ObservableService`注入到`AppComponent`中，它调用`createObservableService()`方法并订阅其值流，创建一个知道如何处理数据的观察者。观察者只是将接收到的时间分配给渲染UI上时间的`currentTime`变量，如下列所示。
- en: Listing 13.5\. observableservice/app.component.ts
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.5\. observableservice/app.component.ts
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Displays the time using the date pipe**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用日期管道显示时间**'
- en: '***2* Injects the service that wraps the observable**'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入封装可观察对象的服务**'
- en: '***3* Creates the observable and starts emitting dates**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建可观察对象并开始发射日期**'
- en: '***4* Subscribes to the stream of dates**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 订阅日期流**'
- en: 'This app doesn’t use any servers, and you can see it in action here. Run it
    by entering the following command in the client directory (after `npm install`):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序不使用任何服务器，你可以在以下位置看到它的运行情况。在客户端目录中运行以下命令来运行它（在`npm install`之后）：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the browser window, the current time will be updated every second. You use
    the `DatePipe` here with the format `'mediumTime'`, which displays only hours,
    minutes, and seconds (all date formats are described in the Angular `DatePipe`
    documentation at [http://mng.bz/78lD](http://mng.bz/78lD)).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器窗口中，当前时间将每秒更新一次。你在这里使用`DatePipe`，格式为`'mediumTime'`，它只显示小时、分钟和秒（所有日期格式都在Angular
    `DatePipe`文档中描述，见[http://mng.bz/78lD](http://mng.bz/78lD))。
- en: This simple example demonstrates a basic technique for creating an injectable
    service that wraps an observable stream so components or user services can subscribe
    to it. In this case, you use `setInterval()`, but you could replace it with any
    application-specific code that generates one or more values and emits them as
    a stream.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此简单示例演示了创建一个可注入服务的基本技术，该服务封装了一个可观察流，以便组件或用户服务可以订阅它。在这种情况下，你使用`setInterval()`，但你可以用任何特定于应用程序的代码替换它，该代码生成一个或多个值并将它们作为流发射出来。
- en: Don’t forget about error handling and completing the stream if need be. The
    following listing shows an observable that sends one element to the observer,
    may throw an error, and notifies the observer that streaming is complete.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记错误处理以及在必要时完成流。以下列表显示了一个向观察者发送一个元素的可观察对象，可能会抛出错误，并通知观察者流已完成的示例。
- en: Listing 13.6\. Sending errors and completion events
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.6\. 发送错误和完成事件
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Sends the text value to the observer**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将文本值发送给观察者**'
- en: '***2* Emulates an error situation**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 模拟错误情况**'
- en: '***3* Sends the error to the observer**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将错误发送给观察者**'
- en: '***4* Always let the observer know that the data streaming is over.**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 总是让观察者知道数据流已结束。**'
- en: If you uncomment the line with `throw`, the preceding program will jump over
    “some other code” and continue in the `catch` section, where you invoke `observer.error()`.
    This will result in the invocation of the error handler on the subscriber, if
    there is one.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你取消注释带有`throw`的行，前面的程序将跳过“某些其他代码”并继续在`catch`部分，在那里你调用`observer.error()`。这将导致如果有的话，在订阅者上调用错误处理程序。
- en: The data producer for your observable stream was the time generator, but it
    could be a WebSocket server generating some useful values. Let’s create an Angular
    service that communicates with a WebSocket server.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你的可观察流的数据生产者是时间生成器，但它可以是生成一些有用值的WebSocket服务器。让我们创建一个与WebSocket服务器通信的Angular服务。
- en: 13.3.2\. Angular talking to a WebSocket server
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.3.2\. 角度与WebSocket服务器通信
- en: In the hands-on section, you’ll implement a real-world use case of an Angular
    client communicating with a server over WebSockets. This is how users of ngAuction
    will place bids and receive notifications of bids made by other users.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作部分，您将实现一个 Angular 客户端通过 WebSockets 与服务器通信的实际情况。这就是 ngAuction 的用户如何进行竞标并接收其他用户竞标通知的方式。
- en: In this section, we’ll show you a very basic way to wrap a `WebSocket` into
    an Angular client. This is going to be a rather simple wrapper for the `WebSocket`
    object, but in the hands-on section, you’ll use a more robust `WebSocketSubject`
    that comes with RxJS.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示一种非常基本的方法，将 `WebSocket` 包装到 Angular 客户端中。这将是一个相当简单的 `WebSocket`
    对象包装器，但在实际操作部分，您将使用一个更健壮的 `WebSocketSubject`，它随 RxJS 一起提供。
- en: Your next Angular app will include a service that interacts with the Node WebSocket
    server. The server-side tier can be implemented with any technology that supports
    WebSockets. [Figure 13.4](#ch13fig04) illustrates the architecture of such an
    application (think of bidding messages going between the client and server over
    the socket connection).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您的下一个 Angular 应用程序将包括一个与 Node WebSocket 服务器交互的服务。服务器端层可以使用支持 WebSockets 的任何技术实现。[图
    13.4](#ch13fig04) 展示了此类应用程序的架构（想象一下，竞标消息在客户端和服务器之间通过套接字连接进行交换）。
- en: Figure 13.4\. Angular interacting with a server via a socket
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.4\. Angular 通过套接字与服务器交互
- en: '![](Images/13fig04_alt.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13fig04_alt.jpg)'
- en: The code in [listing 13.7](#ch13ex07) wraps the browser’s `WebSocket` object
    into an observable stream. This service creates an instance of the `WebSocket`
    object that’s connected to the WebSocket server based on the provided URL, and
    the client instance handles messages received from the server.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 13.7](#ch13ex07) 中的代码将浏览器的 `WebSocket` 对象包装成一个可观察的流。此服务根据提供的 URL 创建一个连接到
    WebSocket 服务器的 `WebSocket` 对象实例，客户端实例处理从服务器接收到的消息。'
- en: Your `WebSocketService` also has a `sendMessage()` method so the client can
    send messages to the server as well. Prior to sending the message, the service
    checks whether the connection is still open (the `WebSocket.readyState === 1`),
    as shown in the following listing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 `WebSocketService` 还有一个 `sendMessage()` 方法，因此客户端也可以向服务器发送消息。在发送消息之前，该服务会检查连接是否仍然打开（`WebSocket.readyState
    === 1`），如下面的列表所示。
- en: Listing 13.7\. wsservice/websocket.service.ts
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.7\. wsservice/websocket.service.ts
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* The WebSocket is open.**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* WebSocket 已打开。**'
- en: '***2* This method emits messages received from the specified URL.**'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 此方法会发出从指定 URL 收到的消息。**'
- en: '***3* Connects to the WebSocket server**'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 连接到 WebSocket 服务器**'
- en: '***4* Creates an Observable object**'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建一个 Observable 对象**'
- en: '***5* Sends the message received from the server to the subscriber**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将从服务器接收到的消息发送给订阅者**'
- en: '***6* Sends an error received from the server to the subscriber**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将从服务器接收到的错误发送给订阅者**'
- en: '***7* If the server closes the socket, notifies the subscriber**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 如果服务器关闭套接字，则通知订阅者**'
- en: '***8* Returns a callback so the caller can unsubscribe**'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 返回一个回调，以便调用者可以取消订阅**'
- en: '***9* Checks if the connection is open**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 检查连接是否打开**'
- en: '***10* Sends the message to the server**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 将消息发送到服务器**'
- en: '***11* Notifies the caller that the connection was closed**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11* 通知调用者连接已关闭**'
- en: Note that your observer returns a callback, so if the caller invokes the `unsubscribe()`
    method, this callback will be invoked. It’ll close the connection, sending a 1000
    status code and the message explaining the reason for closing. You can see all
    allowed codes for closing the connection at [http://mng.bz/5V07](http://mng.bz/5V07).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您的观察者返回一个回调，因此如果调用者调用 `unsubscribe()` 方法，则此回调将被调用。它将关闭连接，发送状态码 1000 和解释关闭原因的消息。您可以在
    [http://mng.bz/5V07](http://mng.bz/5V07) 查看所有允许的关闭连接的状态码。
- en: Now let’s write the `AppComponent` that subscribes to the `WebSocketService`,
    which is injected into the `AppComponent` shown in [figure 13.4](#ch13fig04).
    This component, shown in the following listing, can also send messages to the
    server when the user clicks the Send Message to Server button.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写 `AppComponent`，它订阅 `WebSocketService`，该服务注入到 [图 13.4](#ch13fig04) 中所示的
    `AppComponent` 中。此组件，如下面的列表所示，当用户点击发送消息到服务器按钮时，也可以向服务器发送消息。
- en: Listing 13.8\. wsservice/app.component.ts
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.8\. wsservice/app.component.ts
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* This property will hold the reference to the subscription.**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 此属性将保留订阅的引用。**'
- en: '***2* Injects the service**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注入服务**'
- en: '***3* Connects to the server**'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 连接到服务器**'
- en: '***4* Handles the data received from the server**'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 处理从服务器接收到的数据**'
- en: '***5* Sends the message to the server**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 向服务器发送消息**'
- en: '***6* Closes the WebSocket connection**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 关闭 WebSocket 连接**'
- en: Note that you store the reference to the subscription in the `wsSubscription`
    property, and when the user clicks the Disconnect button, this component unsubscribes
    from the observable. That invokes the callback defined in the observer, closing
    the connection to the WebSocket.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您将订阅的引用存储在 `wsSubscription` 属性中，当用户点击“断开连接”按钮时，此组件从可观察对象中取消订阅。这会调用观察者中定义的回调，关闭
    WebSocket 连接。
- en: The client is ready. Now we’ll show you the code for the server that will communicate
    with this client. The callback function that’s invoked on the connection event
    sends the greeting to the client and adds two more event handler functions to
    the object that represents this particular client.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端已准备好。现在我们将向您展示与该客户端通信的服务器代码。在连接事件上调用的回调函数向客户端发送问候，并将两个更多的事件处理函数添加到表示此特定客户端的对象中。
- en: One function handles messages received from the client, and another handles
    errors (you’ll log the error code). This server is implemented in the two-way-websocket-server.ts
    file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数处理来自客户端的消息，另一个处理错误（您将记录错误代码）。此服务器在 two-way-websocket-server.ts 文件中实现。
- en: Listing 13.9\. server/two-way-websocket-server.ts
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.9\. server/two-way-websocket-server.ts
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Starts the WebSocket serve**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 启动 WebSocket 服务器**'
- en: '***2* A new client connected**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 新客户端已连接**'
- en: '***3* Greets the newly connected client**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 向新连接的客户端问候**'
- en: '***4* Listens to the message from this client**'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 监听来自此客户端的消息**'
- en: '***5* Logs the error from this connection, if any**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 记录此连接的错误，如果有**'
- en: '***6* The client disconnected, so you log the reason.**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 客户端已断开连接，因此您记录了原因。**'
- en: 'To see this app in action, start the server by running the following command
    from the server directory:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此应用程序的实际运行情况，请从服务器目录运行以下命令以启动服务器：
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then build and start the Angular app from the client directory as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照以下步骤从客户端目录构建并启动 Angular 应用程序：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To emulate a scenario where more than one client is connected to the same WebSocket
    server, open two browsers at http://localhost:4200. Each of the apps will receive
    a greeting from the server, and you’ll be able to send messages to the server
    by clicking the Send Message to Server button.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要模拟多个客户端连接到同一 WebSocket 服务器的场景，请同时在 http://localhost:4200 打开两个浏览器。每个应用程序都将收到服务器的问候，您可以通过点击“发送消息到服务器”按钮向服务器发送消息。
- en: We took the screenshot in [figure 13.5](#ch13fig05) after the button is clicked
    once (Chrome Developer Tools has the WS and Frames tabs opened under Network).
    On the right, you see the greeting message that arrived from the server and the
    message that the client sent to the server.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮点击一次后（在 Chrome 开发者工具中，网络下打开了 WS 和 Frames 选项卡），我们拍摄了 [图 13.5](#ch13fig05)
    中的截图。在右侧，您可以看到从服务器到达的问候消息和客户端发送到服务器的消息。
- en: Figure 13.5\. Getting the message in Angular from Node
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.5\. 从 Node 获取消息的 Angular
- en: '![](Images/13fig05_alt.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片 13.5](Images/13fig05_alt.jpg)'
- en: '[Figure 13.6](#ch13fig06) shows the screenshot taken after the client clicks
    the Send Message to Server button, then Disconnect, and then Send Message to Server
    again.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13.6](#ch13fig06) 展示了客户端点击“发送消息到服务器”按钮后，断开连接，然后再次发送消息到服务器的截图。'
- en: Figure 13.6\. Send, disconnect, and send again
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.6\. 发送、断开连接，然后再次发送
- en: '![](Images/13fig06_alt.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片 13.6](Images/13fig06_alt.jpg)'
- en: '|  |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Browsers don’t enforce the same-origin policy on WebSocket connections. That’s
    why you’re able to exchange data between the client originating from port 4200
    and the server running on port 8085\. Refer to the documentation of whatever server-side
    technology you use to see what protection is available for WebSockets.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器不对 WebSocket 连接执行同源策略。这就是为什么您能够交换来自端口 4200 的客户端和运行在端口 8085 上的服务器之间的数据。请参阅您使用的任何服务器端技术文档，以了解
    WebSocket 可用的保护措施。
- en: '|  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Integrating WebSockets with server-side messaging systems**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**将 WebSocket 与服务器端消息系统集成**'
- en: Imagine your server uses a messaging system; let’s use ActiveMQ as an example.
    Say you’d like to enable your JavaScript client to exchange data with ActiveMQ
    over WebSockets. If you decide to program such data exchange from scratch, you
    need to come up with a way to notify the server’s endpoint that the data sent
    by the client should be redirected into an ActiveMQ queue with a specific name.
    Then the server-side code needs to format the client’s message to be accepted
    by ActiveMQ according to its internal protocol. Also, the server-side app needs
    to keep track of all connected clients, and possibly implement some heartbeats
    to monitor the health of the socket connection. That’s a lot of coding.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的服务器使用消息系统；让我们以 ActiveMQ 为例。假设你希望启用你的 JavaScript 客户端通过 WebSockets 与 ActiveMQ
    交换数据。如果你决定从头开始编写这样的数据交换程序，你需要想出一个方法来通知服务器端点，客户端发送的数据应该被重定向到具有特定名称的 ActiveMQ 队列。然后服务器端代码需要格式化客户端的消息，使其符合
    ActiveMQ 的内部协议。此外，服务器端应用程序需要跟踪所有已连接的客户端，并可能实现一些心跳来监控套接字连接的健康状况。这需要大量的编码工作。
- en: The good news is that WebSockets can use subprotocols to integrate with server-side
    messaging systems. For example, server-side code can map the WebSocket endpoint
    to an existing queue in ActiveMQ. This way, when a server’s software places a
    message into a queue, it’s automatically pushed to the client. Similarly, when
    a client sends a message to a WebSocket endpoint, it’s placed in the queue on
    the server. Implementing heartbeats comes down to providing a configuration option.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是 WebSockets 可以使用子协议与服务器端消息系统集成。例如，服务器端代码可以将 WebSocket 端点映射到 ActiveMQ 中的现有队列。这样，当服务器软件将消息放入队列时，它会自动推送到客户端。同样，当客户端向
    WebSocket 端点发送消息时，它会被放置在服务器上的队列中。实现心跳功能只需提供一个配置选项。
- en: STOMP is one of the popular subprotocols used for sending text messages over
    WebSockets (see [http://mng.bz/PPsy](http://mng.bz/PPsy)). It describes a client-side
    message broker that communicates with its server-side peer. For client STOMP support,
    we use ng2-stompjs, available at [http://mng.bz/KdIM](http://mng.bz/KdIM).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: STOMP 是用于通过 WebSockets 发送文本消息的流行子协议之一（见 [http://mng.bz/PPsy](http://mng.bz/PPsy)）。它描述了一个客户端消息代理，它与服务器端对等体进行通信。对于客户端
    STOMP 支持，我们使用 ng2-stompjs，可在 [http://mng.bz/KdIM](http://mng.bz/KdIM) 获取。
- en: The server-side admin should install a STOMP connector for their messaging server
    (ActiveMQ has native STOMP support). In such a setup, client-server communication
    is more robust and requires less coding on the application level.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端管理员应为其消息服务器（ActiveMQ 具有本机 STOMP 支持）安装 STOMP 连接器。在这种配置中，客户端-服务器通信更加健壮，并且需要在应用程序级别上编写更少的代码。
- en: '|  |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In [chapter 12](kindle_split_021.xhtml#ch12), you learned how to communicate
    with a web server via HTTP. In this chapter, we introduced the WebSocket protocol.
    The next version of ngAuction will use both communication protocols, but first
    let’s see how the materials covered in this chapter apply to the new functionality
    of ngAuction that you’re about to implement.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 12 章](kindle_split_021.xhtml#ch12)中，你学习了如何通过 HTTP 与 Web 服务器进行通信。在本章中，我们介绍了
    WebSocket 协议。ngAuction 的下一个版本将使用这两种通信协议，但首先让我们看看本章涵盖的材料如何应用于你即将实施的 ngAuction 的新功能。
- en: The WebSocket protocol isn’t based on the request/response model, and the WebSocket
    server can initiate the communication with the client without any additional ceremony.
    This is a valuable feature for ngAuction, because the server knows first when
    any users place a bid on each auctioned product in this multi-user app. Because
    the server doesn’t need to wait for the client’s requests for data, it can push
    the newly placed bids to all users that are connected to this WebSocket server.
    That means the server can push the latest bids to all users in real time.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 协议不是基于请求/响应模型，WebSocket 服务器可以在没有任何额外仪式的情况下主动与客户端通信。这对于 ngAuction 来说是一个非常有价值的特性，因为服务器首先知道任何用户在多用户应用程序中对每个拍卖产品的出价。由于服务器不需要等待客户端的数据请求，它可以实时将新出的价推送到所有连接到该
    WebSocket 服务器的用户。这意味着服务器可以实时将最新的出价推送给所有用户。
- en: '13.4\. Hands-on: Node server with WebSockets support'
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4. 实践：支持 WebSockets 的 Node 服务器
- en: 'In this section, we’ll review the refactored version of ngAuction that comes
    with this chapter. In real auctions, multiple users can bid on products. When
    the server receives a bid from a user, the bid server should broadcast the latest
    bid to all users who are watching selected products. This version of ngAuction
    accomplishes the following main tasks:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾本章附带的重构版本的 ngAuction。在真实拍卖中，多个用户可以对产品进行竞标。当服务器收到用户的竞标时，竞标服务器应向所有观看选定产品的用户广播最新的竞标。本版本的
    ngAuction 完成了以下主要任务：
- en: Split ngAuction into two separate projects, client and server, and store the
    product data and images on the server.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 ngAuction 分为两个独立的项目，客户端和服务器，并将产品数据和图像存储在服务器上。
- en: Modify the client so it’ll use the `HttpClient` service to make requests to
    the server to get products data.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改客户端，使其使用 `HttpClient` 服务向服务器发送请求以获取产品数据。
- en: On the server side, implement HTTP and WebSocket servers. The HTTP server will
    serve product data.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端，实现 HTTP 和 WebSocket 服务器。HTTP 服务器将提供产品数据。
- en: The WebSocket server will accept user bids on selected products, and all other
    users can see the latest bids pushed by the server.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket 服务器将接受用户对选定产品的竞标，所有其他用户都可以看到服务器推送的最新竞标。
- en: '[Figure 13.7](#ch13fig07) shows the rendered `ProductDetailComponent` with
    the button that will allow a user to place bids in $5 increments. If a user clicks
    this button once, the price will change to $75 on their UI, as well as for all
    other users having the product-detail view open for the same product. The server
    will broadcast (via a WebSocket connection) the latest bid amounts to all users
    who are looking at this product.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13.7](#ch13fig07) 展示了渲染后的 `ProductDetailComponent`，其中包含一个按钮，允许用户以 $5 的增量进行竞标。如果用户点击此按钮一次，价格将在他们的
    UI 上变为 $75，以及所有其他打开相同产品详细视图的用户。服务器将通过 WebSocket 连接向所有查看此产品的用户广播最新的竞标金额。'
- en: Figure 13.7\. The `ProductDetailComponent` with a bid button
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.7\. 带有竞标按钮的 `ProductDetailComponent`
- en: '![](Images/13fig07_alt.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13fig07_alt.jpg)'
- en: To implement this functionality, you’ll add WebSocket support to the server
    and create a new `BidService` on the client. [Figure 13.8](#ch13fig08) shows the
    main players involved in client-server communications in this version of ngAuction.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此功能，您需要在服务器上添加 WebSocket 支持，并在客户端创建一个新的 `BidService`。[图 13.8](#ch13fig08)
    展示了在本版本 ngAuction 中涉及客户端-服务器通信的主要参与者。
- en: Figure 13.8\. Client-server communications in ngAuction
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.8\. ngAuction 中的客户端-服务器通信
- en: '![](Images/13fig08_alt.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13fig08_alt.jpg)'
- en: 'The *DI* in [figure 13.8](#ch13fig08) stands for *dependency injection*. Angular
    injects the `HttpClient` service into `ProductService`, which in turn is injected
    into three components: `CategoriesComponent`, `SearchComponent`, and `ProductComponent`.
    `ProductService` is responsible for all HTTP-based communications with the server.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13.8](#ch13fig08) 中的 *DI* 代表 *依赖注入*。Angular 将 `HttpClient` 服务注入到 `ProductService`
    中，后者反过来被注入到三个组件中：`CategoriesComponent`、`SearchComponent` 和 `ProductComponent`。`ProductService`
    负责与服务器所有基于 HTTP 的通信。'
- en: The `BidService` wraps all WebSocket-based communications with the server. It’s
    injected into the `ProductDetailComponent`. When a user opens the product-detail
    view, the new bids (if any) will be displayed. When a user places a new bid, the
    `BidService` will push the message to the server. When the WebSocket server pushes
    a new bid, the `BidService` receives the bid, and the `ProductDetailComponent`
    renders it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`BidService` 包装了与服务器所有基于 WebSocket 的通信。它被注入到 `ProductDetailComponent` 中。当用户打开产品详细视图时，如果有新的竞标，将显示新的竞标。当用户放置新的竞标时，`BidService`
    将消息推送到服务器。当 WebSocket 服务器推送新的竞标时，`BidService` 接收竞标，并 `ProductDetailComponent`
    渲染它。'
- en: '[Figure 13.8](#ch13fig08) shows two more injectable values: `API_BASE_URL`
    and `WS_URL`. The former will contain the URL of the HTTP server, and the latter,
    the URL of the WebSocket server. To inject these values, you’ll use `InjectionToken`.
    Both URLs are configurable, and their values are stored in the Angular project
    in the environments/environment.ts and environments/environment.prod.ts files.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13.8](#ch13fig08) 展示了两个额外的可注入值：`API_BASE_URL` 和 `WS_URL`。前者将包含 HTTP 服务器的
    URL，后者，WebSocket 服务器的 URL。要注入这些值，您将使用 `InjectionToken`。这两个 URL 都是可配置的，并且它们的值存储在
    Angular 项目的 environments/environment.ts 和 environments/environment.prod.ts 文件中。'
- en: The environment.ts file is used in dev mode and is shown in the following listing.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: environment.ts 文件用于开发模式，如下所示。
- en: Listing 13.10\. environment.ts
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.10\. environment.ts
- en: '[PRE15]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The environment.prod.ts file is used in production mode, and because the Angular
    app is expected to be deployed on the same server that serves data, there’s no
    need to specify the full URL for HTTP communications, as shown in the following
    listing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: environment.prod.ts 文件用于生产模式，由于 Angular 应用预计将部署在提供数据的服务器上，因此不需要指定 HTTP 通信的完整
    URL，如下面的列表所示。
- en: Listing 13.11\. environment.prod.ts
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.11\. environment.prod.ts
- en: '[PRE16]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 13.4.1\. Running ngAuction in dev mode
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.4.1\. 以 dev 模式运行 ngAuction
- en: 'ngAuction consists of two projects now, so you need to run `npm install` in
    each project, and then start the server and the client separately. To start the
    server, change to the server directory, compile all the TypeScript code into JavaScript
    by running `tsc`, and start the server as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ngAuction 现在由两个项目组成，因此你需要在每个项目中运行 `npm install`，然后分别启动服务器和客户端。要启动服务器，切换到服务器目录，通过运行
    `tsc` 将所有 TypeScript 代码编译成 JavaScript，然后按照以下方式启动服务器：
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To start the Angular app, go to the client directory and run the following
    command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 Angular 应用，转到客户端目录并运行以下命令：
- en: '[PRE18]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You’ll see the same UI of ngAuction that you created in [chapter 11](kindle_split_020.xhtml#ch11),
    but now product data and images come from the server via the HTTP connection.
    Open your Chrome browser at http://localhost:4200, select a product, and click
    the bid button. You’ll see how the price increases by $5\. Now open another browser
    (such as Firefox) at http://localhost:4200, select the same product, and you’ll
    see the latest price. Place a new bid in that second browser, and the new bid
    is shown in both browsers. The server pushes the new bid to all connected clients.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到与你在[第 11 章](kindle_split_020.xhtml#ch11)中创建的 ngAuction 相同的 UI，但现在产品数据和图片通过
    HTTP 连接从服务器获取。打开你的 Chrome 浏览器，访问 http://localhost:4200，选择一个产品，并点击竞标按钮。你会看到价格以
    $5 的幅度增加。现在打开另一个浏览器（例如 Firefox），访问 http://localhost:4200，选择相同的产品，你会看到最新的价格。在第二个浏览器中提交新的竞标，新的竞标将在两个浏览器中显示。服务器将新的竞标推送到所有已连接的客户端。
- en: After reading in [chapter 12](kindle_split_021.xhtml#ch12) about the same-origin
    restriction and proxying client requests, you may be wondering how the app loaded
    from port 4200 can access data on the HTTP server running on port 9090 without
    configuring the proxy on the client. It’s because this time, you used a special
    CORS package on the Node server for unrestricted access from any client. You’ll
    see how to do this in the next section.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了[第 12 章](kindle_split_021.xhtml#ch12)中关于同源限制和代理客户端请求的内容后，你可能想知道从端口 4200
    加载的应用如何在不配置客户端代理的情况下访问运行在端口 9090 上的 HTTP 服务器。这是因为这次，你在 Node 服务器上使用了特殊的 CORS 包，以实现来自任何客户端的无限制访问。你将在下一节中看到如何做到这一点。
- en: 13.4.2\. Reviewing the ngAuction server code
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.4.2\. 回顾 ngAuction 服务器代码
- en: By now, you know how to create and start HTTP and WebSocket servers using Node.js,
    Express, and the `ws` package, and you won’t repeat that part. In this section,
    we’ll review the code fragments of the server that are relevant to the new functionality
    of ngAuction. You’ll split the server code into four TypeScript files. [Figure
    13.9](#ch13fig09) shows the structure of the ngAuction server directory that comes
    with this chapter.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经知道如何使用 Node.js、Express 和 `ws` 包创建和启动 HTTP 和 WebSocket 服务器，这部分内容将不再重复。在本节中，我们将回顾与
    ngAuction 新功能相关的服务器代码片段。你将把服务器代码拆分为四个 TypeScript 文件。[图 13.9](#ch13fig09) 展示了本章提供的
    ngAuction 服务器目录结构。
- en: Figure 13.9\. ngAuction server structure
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.9\. ngAuction 服务器结构
- en: '![](Images/13fig09_alt.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13fig09_alt.jpg)'
- en: In ngAuction from [chapter 11](kindle_split_020.xhtml#ch11), the data folder
    was located in the Angular project; now, you move the data to the server. In [chapter
    11](kindle_split_020.xhtml#ch11), the code that read products.json and the functions
    to get all the products or products by ID was located in the product .service.ts
    file, and now is located in the db-auction.ts file. The main.ts file contains
    the code to launch both HTTP and WebSocket servers. The ws-auction.ts file has
    the code supporting WebSocket communication with ngAuction clients.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 11 章](kindle_split_020.xhtml#ch11)中的 ngAuction，数据文件夹位于 Angular 项目中；现在，你将数据移动到服务器。在[第
    11 章](kindle_split_020.xhtml#ch11)，读取 products.json 的代码和获取所有产品或按 ID 获取产品的函数位于
    product .service.ts 文件中，现在位于 db-auction.ts 文件中。main.ts 文件包含启动 HTTP 和 WebSocket
    服务器的代码。ws-auction.ts 文件包含支持与 ngAuction 客户端进行 WebSocket 通信的代码。
- en: Launching the HTTP and WebSocket servers
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 启动 HTTP 和 WebSocket 服务器
- en: Let’s start the code review from the main.ts file that’s used to launch the
    servers. The code in this file is similar to simple-websocket-server.ts from [section
    13.2](#ch13lev1sec2), but this time you don’t start HTTP and WebSocket servers
    on different ports—they both use port 9090\. Another difference is that you create
    an instance of the HTTP server using the `createServer()` function, one of Node’s
    interfaces (see [https://nodejs.org/api/http.html](https://nodejs.org/api/http.html)),
    as shown in the following listing.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从用于启动服务器的main.ts文件开始代码审查。这个文件中的代码与第13.2节中的simple-websocket-server.ts类似，但这次你不需要在不同的端口上启动HTTP和WebSocket服务器——它们都使用端口9090。另一个区别是，你使用Node的一个接口`createServer()`创建HTTP服务器的实例，正如以下列表所示。
- en: Listing 13.12\. main.ts
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.12\. main.ts
- en: '[PRE19]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Forwards requests containing /api to the Express router**'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将包含/api的请求转发到Express路由器**'
- en: '***2* Creates an instance of the http.Server object**'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建http.Server对象实例**'
- en: '***3* Creates an instance of BidServer using its HTTP peer**'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用其HTTP对等实例创建BidServer**'
- en: '***4* Launches both servers**'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 启动两个服务器**'
- en: This code creates an instance of the HTTP server with Node’s `createServer()`,
    and you pass Express as a callback function to handle all HTTP requests. To start
    your WebSocket server, you invoke the `createBidServer()` function from ws-auction.ts.
    But first, let’s review your RESTful HTTP server.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用Node的`createServer()`创建HTTP服务器的实例，并将Express作为回调函数传递以处理所有HTTP请求。要启动你的WebSocket服务器，你从ws-auction.ts中调用`createBidServer()`函数。但首先，让我们审查你的RESTful
    HTTP服务器。
- en: The HTTP server
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: HTTP服务器
- en: In [chapter 12](kindle_split_021.xhtml#ch12), section 12.2.2, you created a
    simple Node/Express server that handles requests for products. In this section,
    you’ll see a more advanced version of such a server. Here, you’ll use the Express
    `Router` to route HTTP requests. You’ll also use the CORS module to allow requests
    from all browsers to ignore the same-origin restriction. That’s why you can start
    the client using `ng serve` without the need to configure a proxy.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在第12章中，12.2.2节，你创建了一个简单的Node/Express服务器，用于处理产品请求。在本节中，你将看到这样一个服务器的更高级版本。在这里，你将使用Express的`Router`来路由HTTP请求。你还将使用CORS模块来允许所有浏览器忽略同源限制。这就是为什么你可以使用`ng
    serve`启动客户端而不需要配置代理。
- en: Finally, the product data won’t be hardcoded—you moved the data-handling part
    into the db-auction.ts script. Your HTTP REST server is implemented in the rest-auction.ts
    file, shown in the following listing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，产品数据不会硬编码——你将数据处理部分移动到了db-auction.ts脚本中。你的HTTP REST服务器在rest-auction.ts文件中实现，如下列表所示。
- en: Listing 13.13\. rest-auction.ts
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.13\. rest-auction.ts
- en: '[PRE20]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Imports the CORS module**'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入CORS模块**'
- en: '***2* Imports the data-handling functions**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入数据处理函数**'
- en: '***3* Creates and exports the Express Router instance**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建并导出Express Router实例**'
- en: '***4* Uses CORS to allow requests from all clients**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用CORS允许所有客户端请求**'
- en: '***5* Uses the async keyword to mark the function as asynchronous**'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用async关键字标记函数为异步**'
- en: '***6* Uses the await keyword to avoid nesting code in then() callbacks**'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 使用await关键字避免在then()回调中嵌套代码**'
- en: 'In [section 13.4.1](#ch13lev2sec3), we stated that the dev server on the client
    will run on port 4200, and the REST server will run on port 9090\. To overcome
    the same-origin restriction, you use the Express package CORS to enable access
    from all origins (see [http://mng.bz/aNxM](http://mng.bz/aNxM)). If you open package.json
    in the server directory, you’ll find the dependency `"cors": "^2.8.4"` there.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '在第13.4.1节中，我们提到客户端的开发服务器将在端口4200上运行，而REST服务器将在端口9090上运行。为了克服同源限制，你使用Express包CORS来启用所有来源的访问（见[http://mng.bz/aNxM](http://mng.bz/aNxM)）。如果你在服务器目录中打开package.json，你会在其中找到依赖项`"cors":
    "^2.8.4"`。'
- en: In this server, you create an instance of the Express `Router` object and use
    it to route HTTP GET requests based on the provided path.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个服务器中，你创建了一个Express `Router`对象的实例，并使用它根据提供的路径路由HTTP GET请求。
- en: Note the use of the `async` and `await` keywords. You didn’t use them for product
    retrieval in [chapter 12](kindle_split_021.xhtml#ch12), section 12.2.2, because
    product data was stored in an array, and functions like `getProducts()` were synchronous
    there. Now you use the data-handling functions from db-auction.ts, and they read
    data from a file, which is an asynchronous operation.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `async` 和 `await` 关键字的使用。在[第 12 章](kindle_split_021.xhtml#ch12)的第 12.2.2
    节中，您没有使用它们来检索产品，因为产品数据存储在数组中，并且那里的 `getProducts()` 等函数是同步的。现在您使用 db-auction.ts
    中的数据处理函数，它们从文件中读取数据，这是一个异步操作。
- en: Using the `async` and `await` keywords makes the async code look as if it’s
    synchronous (see [section A.12.4](kindle_split_025.xhtml#app01lev2sec16) in [appendix
    A](kindle_split_025.xhtml#app01) for more details).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `async` 和 `await` 关键字可以使异步代码看起来像是同步的（有关更多详细信息，请参阅[附录 A 的 A.12.4 节](kindle_split_025.xhtml#app01lev2sec16)）。
- en: The data-handling script
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 数据处理脚本
- en: Your HTTP server uses the db-auction.ts script for all data-handling operations.
    This script has methods to read products from the products.json file as well as
    search products based on provided search criteria. We won’t be reviewing the entire
    code of the db-auction.ts script, but we will discuss the code changes compared
    to product.service.ts from the version of ngAuction included with [chapter 11](kindle_split_020.xhtml#ch11),
    as shown in the following listing.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 HTTP 服务器使用 db-auction.ts 脚本进行所有数据处理操作。此脚本包含从 products.json 文件中读取产品以及根据提供的搜索条件搜索产品的函数。我们不会审查
    db-auction.ts 脚本的全部代码，但我们将讨论与 ngAuction 第 11 章中包含的版本的产品.service.ts 相比所做的代码更改，如下所示。
- en: Listing 13.14\. db-auction.ts (partial listing)
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.14\. db-auction.ts（部分列表）
- en: '[PRE21]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Defines a new type to store an array of products**'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义一个新的类型来存储产品数组**'
- en: '***2* Makes fs.readFile to return a promise**'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使 fs.readFile 返回一个 promise**'
- en: '***3* Declares a promise for reading products.json**'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 声明读取 products.json 的 promise**'
- en: '***4* Reads products.json**'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 读取 products.json**'
- en: '***5* This function gets category names for each product.**'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 此函数获取每个产品的分类名称。**'
- en: '***6* Gets rid of duplicate categories**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 移除重复的分类**'
- en: '***7* This function updates the product price based on the latest bid.**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 此函数根据最新的出价更新产品价格。**'
- en: 'In [chapter 11](kindle_split_020.xhtml#ch11), the products.json file was located
    on the client side, and `ProductService` read this file using the `HttpClient`
    service, as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 11 章](kindle_split_020.xhtml#ch11)中，products.json 文件位于客户端，`ProductService`
    使用 `HttpClient` 服务读取此文件，如下所示：
- en: '[PRE22]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now this file is located on the server, and you read it using Node’s `fs` module,
    which includes functions for working with the filesystem (see [https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html)).
    You also use another Node module, `util`, that includes a number of useful utilities,
    and you use `util.promisify()` to read the file returning the data as a promise
    (see [http://mng.bz/Z009](http://mng.bz/Z009)) instead of providing a callback
    to `fs.readFile`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个文件位于服务器上，您使用 Node 的 `fs` 模块来读取它，该模块包含用于处理文件系统的函数（有关更多详细信息，请参阅[https://nodejs.org/api/fs.html](https://nodejs.org/api/fs.html)）。您还使用另一个
    Node 模块 `util`，它包含许多有用的实用工具，并使用 `util.promisify()` 将文件读取操作返回的数据作为 promise（请参阅[http://mng.bz/Z009](http://mng.bz/Z009)），而不是向
    `fs.readFile` 提供回调。
- en: In several places in db-auction.ts, you see `await db$`, which means “execute
    the `db$` promise and wait until it resolves or rejects.” The `db$` promise knows
    how to read the products.json file.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在 db-auction.ts 的几个地方，您会看到 `await db$`，这意味着“执行 `db$` promise 并等待其解析或拒绝。”`db$`
    promise 知道如何读取 products.json 文件。
- en: Now that we’ve discussed how your RESTful server works, let’s get familiar with
    the code of the WebSocket server.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了您的 RESTful 服务器的工作方式，那么让我们熟悉 WebSocket 服务器的代码。
- en: The WebSocket server
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: WebSocket 服务器
- en: The ws-auction.ts script implements your WebSocket server that can receive bids
    from users and notify users about new bids. A bid is represented by a `BidMessage`
    type containing the product ID and the bid amount (price), as shown in the following
    listing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ws-auction.ts 脚本实现了您的 WebSocket 服务器，该服务器可以接收用户的出价并通知用户有关新出价的信息。出价由包含产品 ID 和出价金额（价格）的
    `BidMessage` 类型表示，如下所示。
- en: Listing 13.15\. `BidMessage` from ws-auction.ts
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.15\. ws-auction.ts 中的 `BidMessage`
- en: '[PRE23]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `createBidServer()` function creates an instance of the class `BidServer`,
    using the provided instance of `http.Server`, as shown in the next listing.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`createBidServer()` 函数使用提供的 `http.Server` 实例创建 `BidServer` 类的实例，如下所示。'
- en: Listing 13.16\. `createBidServer()` from ws-auction.ts
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.16\. ws-auction.ts 中的 `createBidServer()`
- en: '[PRE24]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `BidServer` class contains the standard WebSocket callbacks `onConnection()`,
    `onMessage()`, `onClose()`, and `onError()`. The constructor of this class creates
    an instance of `ws.Server` (you use the `ws` package there) and defines the `onConnection()`
    callback method to the WebSocket `connection` event. The outline of the `BidServer`
    class is shown in the following listing.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`BidServer` 类包含标准的 WebSocket 回调 `onConnection()`、`onMessage()`、`onClose()`
    和 `onError()`。这个类的构造函数创建了一个 `ws.Server` 实例（在那里你使用 `ws` 包），并将 `onConnection()`
    回调方法定义为 WebSocket 的 `connection` 事件。`BidServer` 类的轮廓如下面的列表所示。'
- en: Listing 13.17\. The structure of `BidServer`
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.17\. `BidServer` 的结构
- en: '[PRE25]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* Handler for the WebSocket connection event**'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* WebSocket 连接事件处理器**'
- en: '***2* Handler for the message event**'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 消息事件处理器**'
- en: '***3* Handler for the close event**'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 关闭事件处理器**'
- en: '***4* Handler for the error event**'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 错误事件处理器**'
- en: Now let’s review the implementation of each method, starting with `constructor()`
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来回顾每个方法的实现，从 `constructor()` 开始。
- en: Listing 13.18\. The constructor
  id: totrans-274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.18\. 构造函数
- en: '[PRE26]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* Instantiates the WebSocket server using the HTTP server instance**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 HTTP 服务器实例实例化 WebSocket 服务器**'
- en: '***2* Defines the handler of the connection event**'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 定义连接事件处理器**'
- en: When your ngAuction client connects to `BidServer`, the `onConnection()` callback
    is invoked. The argument of this callback is the `WebSocket` object representing
    a single client’s connection. When the client makes the initial request to switch
    the protocol from HTTP to `WebSocket`, it’ll invoke the `onConnection()` callback,
    shown in the following listing.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的 ngAuction 客户端连接到 `BidServer` 时，会调用 `onConnection()` 回调。这个回调的参数是一个 `WebSocket`
    对象，代表单个客户端的连接。当客户端发起从 HTTP 协议切换到 `WebSocket` 协议的初始请求时，它会调用 `onConnection()` 回调，如下面的列表所示。
- en: Listing 13.19\. Handling the connection event
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.19\. 处理连接事件
- en: '[PRE27]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Listens to message events**'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 监听消息事件**'
- en: '***2* Listens to error events**'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 监听错误事件**'
- en: '***3* Listens to close events**'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 监听关闭事件**'
- en: '***4* Reports the number of connected clients**'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 报告连接客户端的数量**'
- en: The `onConnection()` method assigns the callback methods for the WebSocket events
    `message`, `close`, and `error`. When the `ws` module creates an instance of the
    WebSocket server, it stores the references to connected clients in the `wsServer.clients`
    property. On every connection, you print on the console the number of connected
    clients. The next listing reviews the callback methods one by one, starting from
    `onMessage()`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`onConnection()` 方法为 WebSocket 事件 `message`、`close` 和 `error` 分配回调方法。当 `ws`
    模块创建 WebSocket 服务器实例时，它将连接客户端的引用存储在 `wsServer.clients` 属性中。每次连接时，你会在控制台上打印连接客户端的数量。下一个列表将逐个回顾回调方法，从
    `onMessage()` 开始。'
- en: Listing 13.20\. Handling the client messages
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.20\. 处理客户端消息
- en: '[PRE28]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* Parses the client’s BidMessage**'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 解析客户端的 BidMessage**'
- en: '***2* Updates the bid amount in your in-memory database**'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 更新内存数据库中的竞标金额**'
- en: '***3* Sends new product bid information to all subscribers**'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 向所有订阅者发送新产品竞标信息**'
- en: The `onMessage()` callback gets the user’s bid on the product and updates the
    amount in your simple in-memory database implemented in the db-auction.ts script.
    If a user opens the product-detail view, they become a subscriber to notifications
    about all users bids, so you push the new bid over the socket to each subscriber.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`onMessage()` 回调获取用户对产品的竞标并更新 db-auction.ts 脚本中实现的简单内存数据库中的金额。如果用户打开产品详情视图，他们将成为所有用户竞标通知的订阅者，因此你将新的竞标通过套接字推送到每个订阅者。'
- en: Next, we’ll review the callback for the `close` event. When a user closes the
    product-detail view, the WebSocket connection is closed as well. In this case,
    the closed connection is removed from `wsServer.clients`, so no bid notifications
    will be sent to a nonexistent connection, as shown in the following listing.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将回顾 `close` 事件的回调。当用户关闭产品详情视图时，WebSocket 连接也会关闭。在这种情况下，关闭的连接将从 `wsServer.clients`
    中移除，因此不会向不存在的连接发送竞标通知，如下面的列表所示。
- en: Listing 13.21\. Handling closed connections
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.21\. 处理关闭连接
- en: '[PRE29]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the `onError()` callback, you extract the error message from the provided
    `Error` object and log the error on the console.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onError()` 回调中，你从提供的 `Error` 对象中提取错误消息并在控制台上记录错误。
- en: Listing 13.22\. Handling WebSocket errors
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.22\. 处理 WebSocket 错误
- en: '[PRE30]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[Figure 13.10](#ch13fig10) shows the same product-detail view open in Chrome
    and Firefox browsers. The latest bid is synchronized in both views as soon as
    the user clicks the bid button in any of the browsers.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[图13.10](#ch13fig10)显示了在Chrome和Firefox浏览器中打开的相同产品详细信息视图。用户在任一浏览器中点击投标按钮后，最新投标立即在两个视图中同步。'
- en: Figure 13.10\. Synchronized bids in two browsers
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.10\. 两个浏览器中的同步投标
- en: '![](Images/13fig10_alt.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13fig10_alt.jpg)'
- en: '|  |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Homework**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**作业**'
- en: Your ngAuction isn’t a production-grade auction, and you may find some edge
    cases that aren’t properly handled. We’ll describe one of them in case you want
    to improve this app.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 您的ngAuction不是一个生产级别的拍卖，您可能会发现一些边缘情况没有得到妥善处理。我们将描述其中之一，以防您想改进这个应用程序。
- en: Imagine that the current bid of the product is $70, and Joe clicks the bid button
    to make a $75 bid. At the same time, Mary, who was also shown $70 as the latest
    product bid, also clicks the bid button. There could be a situation when Joe’s
    request will change the bid to $75 on the server, and some milliseconds later,
    Mary’s $75 bid arrives to the server. Currently, the `BidServer` will just replace
    Joe’s $75 with Mary’s $75, and each of them will assume that he or she placed
    a $75 bid.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 假设当前产品的投标金额是$70，Joe点击投标按钮进行$75的投标。同时，Mary也看到了$70作为最新的产品投标，她也点击了投标按钮。可能存在这样的情况：Joe的请求将投标金额在服务器上更改为$75，几毫秒后，Mary的$75投标到达服务器。目前，`BidServer`将只是用Mary的$75替换Joe的$75，他们每个人都会假设自己投了$75的标。
- en: To prevent this from happening, modify the code in the `BidServer` to reject
    the bid unless the bid amount is greater than the existing one. In such scenarios,
    send the losing user a message containing the new minimum bid amount.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，请修改`BidServer`中的代码，以拒绝投标，除非投标金额大于现有金额。在这种情况下，向输掉的用户发送一条包含新最低投标金额的消息。
- en: '|  |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: We’ve covered the server-side code of ngAuction; let’s see what changed on the
    client side compared to the version in [chapter 11](kindle_split_020.xhtml#ch11).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了ngAuction的服务器端代码；让我们看看与第11章版本相比客户端发生了什么变化。
- en: 13.4.3\. What changed in the ngAuction client code
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 13.4.3\. ngAuction客户端代码中的变化
- en: As stated in the previous section, the main change in the Angular code of ngAuction
    is that you moved to the server the file with product data and images, and the
    code that reads these files. Accordingly, you added the code to `ProductService`
    to interact with the HTTP server using the `HttpClient` service covered in [chapter
    12](kindle_split_021.xhtml#ch12).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，ngAuction的Angular代码的主要变化是将包含产品数据和图像的文件以及读取这些文件的代码移到了服务器上。相应地，您在`ProductService`中添加了代码，以使用第12章中介绍的`HttpClient`服务与HTTP服务器进行交互。
- en: Remember that the `ProductComponent` is responsible for rendering the product
    view that includes `ProductDetailComponent` and `ProductSuggestionComponent` with
    the grid of suggested products, and you modified the code of both components.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`ProductComponent`负责渲染包含`ProductDetailComponent`和`ProductSuggestionComponent`（带有建议产品网格）的产品视图，并且您修改了这两个组件的代码。
- en: Also, you added the bid.service.ts file to communicate with the WebSocket service
    and modified the code in product-detail.component.ts so the user can place bids
    on a product and see other user bids. Let’s review the changes related to the
    product view.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您添加了`bid.service.ts`文件以与WebSocket服务通信，并修改了`product-detail.component.ts`中的代码，以便用户可以对产品进行投标并查看其他用户的投标。让我们回顾与产品视图相关的更改。
- en: Two observables in the ProductComponent
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: ProductComponent中的两个观察者
- en: First, the product view would change if the user looks at the details of one
    product and then selects another one from the suggested products grid. The route
    doesn’t change (the user is still looking at the product view), and `ProductComponent`
    subscribes to an observable from `ActivatedRoute` that emits the newly selected
    `productId` and retrieves the corresponding product details, as shown in the following
    listing.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果用户查看一个产品的详细信息然后从建议产品网格中选择另一个产品，产品视图会发生变化。路由不会改变（用户仍在查看产品视图），`ProductComponent`订阅了来自`ActivatedRoute`的观察者，该观察者发出新选中的`productId`并检索相应的产品详细信息，如下所示。
- en: Listing 13.23\. Handling changed parameters from `ActivatedRoute`
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.23\. 处理来自`ActivatedRoute`的更改参数
- en: '[PRE31]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* Gets the new productId**'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取新的productId**'
- en: '***2* Handles the possibly invalid productId.**'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 处理可能无效的productId。**'
- en: '***3* Retrieves the selected product details**'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 获取所选产品的详细信息**'
- en: In [listing 13.23](#ch13ex23), you retrieve `productId` from `ActivatedRoute`
    and pass it over to the `ProductService`, using the `switchMap` operator. The
    `filter` operator is just a precaution to weed out the falsy product IDs. For
    example, a user can manually enter an erroneous URL like http://localhost:4200/products/A23,
    and you don’t want to request the details for a nonexistent product.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 13.23](#ch13ex23) 中，您从 `ActivatedRoute` 中检索 `productId` 并使用 `switchMap`
    操作符将其传递给 `ProductService`。`filter` 操作符仅作为预防措施，以排除虚假的产品 ID。例如，用户可以手动输入一个错误的 URL，如
    http://localhost:4200/products/A23，您不希望请求不存在的产品详情。
- en: The template of the product component includes the `<nga-product-detail>` component,
    which gets a selected product via its input property `product`, as shown in the
    following listing.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 产品组件的模板包括 `<nga-product-detail>` 组件，它通过其输入属性 `product` 获取选定的产品，如下所示。
- en: Listing 13.24\. Passing a selected product to `ProductDetailComponent`
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.24\. 将选定的产品传递给 `ProductDetailComponent`
- en: '[PRE32]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* Extracts the Product object with async pipe**'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用异步管道提取产品对象**'
- en: '***2* Passes the selected Product to the ProductDetailComponent**'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将选定的 Product 传递给 ProductDetailComponent**'
- en: You place the code that unwraps product data inside the `*ngIf` directive because
    the product data is retrieved asynchronously, and you want to make sure that the
    `product$` observable emitted the data that you bind to the input property of
    the `ProductDetailComponent`. Let’s see how the `ProductDetailComponent` handles
    the received product.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 您将提取产品数据的代码放在 `*ngIf` 指令内部，因为产品数据是异步检索的，并且您想确保 `product$` 可观察对象发出的数据与您绑定到 `ProductDetailComponent`
    输入属性的属性数据相匹配。让我们看看 `ProductDetailComponent` 如何处理接收到的产品。
- en: Placing and monitoring bids in ProductDetailComponent
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在 ProductDetailComponent 中放置和监控出价
- en: The UI of the `ProductDetailComponent` is shown in [figure 13.10](#ch13fig10).
    This component gets the product to display via its input property `product`. If
    a user clicks the bid button, the new bid ($5 more than the current one) is sent
    over the WebSocket connection using `BidService`, which implements all communications
    with the `BidServer`. If another user connected to the `BidServer` bids on the
    same product, the bid amount on the product-detail view will be immediately updated.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductDetailComponent` 的 UI 如 [图 13.10](#ch13fig10) 所示。该组件通过其输入属性 `product`
    获取要显示的产品。如果用户点击出价按钮，则使用 `BidService` 通过 WebSocket 连接发送新的出价（比当前出价高 5 美元），`BidService`
    实现了与 `BidServer` 的所有通信。如果另一个连接到 `BidServer` 的用户对同一产品出价，产品详情视图中的出价金额将立即更新。'
- en: 'The `ProductDetailComponent` class has the private RxJS subject `productChange$`
    and the observable `latestBids$`, which merges the data of two observables:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductDetailComponent` 类具有私有的 RxJS 主题 `productChange$` 和可观察的 `latestBids$`，它合并了两个可观察对象的数据：'
- en: '`productChange$` handles the case when a user opens the product-detail view
    and then selects another product from the list “More items to consider.” When
    the binding to the input parameter `product` changes, the lifecycle hook `ngOnChanges()`
    intercepts the change, and `productChange$` emits the product data.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`productChange$` 处理用户打开产品详情视图并从“更多考虑的项目”列表中选择另一个产品的情况。当输入参数 `product` 的绑定发生变化时，生命周期钩子
    `ngOnChanges()` 会拦截变化，并 `productChange$` 发出产品数据。'
- en: '`latestBids$` emits the new value when either `productChange$` or `BidService`
    pushes the new bid received from the server.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `productChange$` 或 `BidService` 推送从服务器接收的新出价时，`latestBids$` 发出新值。
- en: You have two data sources that can emit values, and on any emission you need
    to update the view. That’s why you combine two observables with the RxJS operator
    `combineLatest`. The code of the product-detail.component.ts file is shown in
    the following listing.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 您有两个数据源可以发出值，并且在任何发出时都需要更新视图。这就是为什么您使用 RxJS 操作符 `combineLatest` 将两个可观察对象组合在一起。product-detail.component.ts
    文件的代码如下所示。
- en: Listing 13.25\. product-detail.component.ts
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.25\. product-detail.component.ts
- en: '[PRE33]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Injects the BidService**'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注入 BidService**'
- en: '***2* Combines the values of two observables**'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 合并两个可观察对象的值**'
- en: '***3* The first observable starts emission with the currently displayed product.**'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 第一个可观察对象以当前显示的产品开始发出**'
- en: '***4* The second observable emits bids.**'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 第二个可观察对象发出出价。**'
- en: '***5* Checks whether the arrived bid was made on the current product**'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 检查到达的出价是否针对当前产品**'
- en: '***6* If new bid was placed, uses its value; otherwise, uses the product price**'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 如果放置了新的出价，则使用其值；否则，使用产品价格**'
- en: '***7* Emits the newly selected product**'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 发射新选择的产品**'
- en: '***8* Places the bid on this product**'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 在此产品上放置出价**'
- en: 'The RxJS operator `combineLatest` (see [http://mng.bz/Y28Y](http://mng.bz/Y28Y))
    subscribes to the values emitted by two observables and invokes the merge function
    when either of the observables emits the value. In this case, it’s either the
    value emitted by `productChange$` or by `bidService.priceUpdates$` (the `BidService`
    code is included in the next section). Here’s your merge function:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 操作符 `combineLatest`（参见 [http://mng.bz/Y28Y](http://mng.bz/Y28Y)）订阅了两个可观察对象发出的值，并在任一可观察对象发出值时调用合并函数。在这种情况下，要么是
    `productChange$` 发出的值，要么是 `bidService.priceUpdates$`（`BidService` 代码包含在下一节中）。以下是你的合并函数：
- en: '[PRE34]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The values emitted by these two observables are represented as the arguments
    `(product, bid)`, and this function returns either `product.price` or `bid.price`,
    depending on which observable emitted the value. This value will be used for rendering
    on the product-detail view.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个可观察对象发出的值表示为参数 `(product, bid)`，这个函数返回 `product.price` 或 `bid.price`，具体取决于哪个可观察对象发出了值。这个值将用于在产品详情视图中进行渲染。
- en: Because the `combineLatest` operator requires both observables to emit a value
    to initially invoke the merge function, you apply the `startWith` operator (see
    [http://mng.bz/OL9z](http://mng.bz/OL9z)) to ensure that there’s an initial emission
    of the provided value before the observable will start making its regular emissions.
    For the initial values, you use the `product` for one observable, and either `BidMessage`
    or null for the other. When the `ProductDetailComponent` is initially rendered,
    the observable `bidService .priceUpdates$` emits null.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `combineLatest` 操作符需要两个可观察对象都发出值以最初调用合并函数，所以你应用了 `startWith` 操作符（参见 [http://mng.bz/OL9z](http://mng.bz/OL9z)），以确保在可观察对象开始进行常规发射之前，提供值有一个初始发射。对于初始值，你使用一个可观察对象的
    `product`，另一个使用 `BidMessage` 或 null。当 `ProductDetailComponent` 首次渲染时，可观察对象 `bidService
    .priceUpdates$` 发出 null。
- en: 'Your combined observable is declared in the `ngOnInit()` lifecycle hook, and
    its values are rendered in the template using the `async` pipe. You do it inside
    the `*ngIf` directive so the falsy values aren’t rendered:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你的组合可观察对象在 `ngOnInit()` 生命周期钩子中声明，其值使用 `async` 管道在模板中渲染。你是在 `*ngIf` 指令内部完成的，这样就不会渲染假值：
- en: '[PRE35]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When the user clicks the bid button, you invoke `bidService.placeBid()`, which
    internally checks whether the connection to `BidServer` has to be opened or is
    already opened. The next listing from product-detail.component.html shows how
    the bid button is implemented in the template.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击投标按钮时，你调用 `bidService.placeBid()`，该函数内部检查是否需要打开与 `BidServer` 的连接或连接已经打开。下一节中的
    `product-detail.component.html` 展示了如何在模板中实现投标按钮。
- en: Listing 13.26\. The bid button in the template
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.26\. 模板中的投标按钮
- en: '[PRE36]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Places the bid that’s $5 higher than the latest bid/price**'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 将投标金额定为比最新投标/价格高 $5**'
- en: '***2* Shows the next bid amount on the button**'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 在按钮上显示下一个投标金额**'
- en: Now let’s see how the `BidService` class communicates with the server, using
    the WebSocket protocol.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 `BidService` 类如何使用 WebSocket 协议与服务器通信。
- en: Using RxJS to communicate with the WebSocket server
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 RxJS 与 WebSocket 服务器通信
- en: In [section 13.3.2](#ch13lev2sec2), we showed a very basic way of writing the
    client code communicating with a WebSocket server. In ngAuction, you’ll use a
    more robust WebSocket service included with RxJS, which means you can use it in
    any Angular project.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 13.3.2 节](#ch13lev2sec2)，我们展示了编写与 WebSocket 服务器通信的客户端代码的一种非常基本的方法。在 ngAuction
    中，你将使用 RxJS 包含的更健壮的 WebSocket 服务，这意味着你可以在任何 Angular 项目中使用它。
- en: RxJS offers an implementation of the WebSocket service based on the `Subject`
    explained in [section D.6](kindle_split_028.xhtml#app04lev1sec6) in [appendix
    D](kindle_split_028.xhtml#app04). The RxJS `Subject` is both an observer and observable.
    In other words, it can receive and emit data, which makes it a good fit for handling
    WebSocket data streams. The RxJS `WebSocketSubject` is a wrapper around the standard
    browser `WebSocket` object and is located in the rxjs/websocket file.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS 提供了一个基于 `Subject` 的 WebSocket 服务实现，该 `Subject` 在 [附录 D](kindle_split_028.xhtml#app04)
    中的 [D.6 节](kindle_split_028.xhtml#app04lev1sec6) 中进行了说明。RxJS 的 `Subject` 既是观察者又是可观察对象。换句话说，它可以接收和发出数据，这使得它非常适合处理
    WebSocket 数据流。RxJS 的 `WebSocketSubject` 是标准浏览器 `WebSocket` 对象的包装器，位于 `rxjs/websocket`
    文件中。
- en: '|  |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Prior to RxJS 6, the `WebSocketSubject` class was located in the rxjs/observable/dom/WebSocketSubject
    file.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxJS 6 之前，`WebSocketSubject` 类位于 `rxjs/observable/dom/WebSocketSubject` 文件中。
- en: '|  |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In its simplest form, `WebSocketSubject` can accept a string with the URL of
    the WebSocket endpoint or an instance of the `WebSocketSubjectConfig` object,
    where you can provide additional configuration. When your code subscribes to `WebSocketSubject`,
    it either uses the existing connection or creates a new one. Unsubscribing from
    `WebSocketSubject` closes the connection if there are no other subscribers listening
    to the same WebSocket endpoint.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单形式中，`WebSocketSubject` 可以接受一个包含 WebSocket 端点 URL 的字符串或 `WebSocketSubjectConfig`
    对象的实例，其中你可以提供额外的配置。当你的代码订阅 `WebSocketSubject` 时，它要么使用现有的连接，要么创建一个新的连接。从 `WebSocketSubject`
    取消订阅如果没有任何其他订阅者监听相同的 WebSocket 端点，则会关闭连接。
- en: When the server pushes data to the socket, `WebSocketSubject` emits the data
    as an observable value. In case of an error, `WebSocketSubject` emits the error
    like any other observable. If the server pushes data but there are no subscribers,
    the values will be buffered and emitted as soon as a new client subscribes.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器将数据推送到 socket 时，`WebSocketSubject` 会将数据作为可观察值发出。在发生错误的情况下，`WebSocketSubject`
    会像任何其他可观察对象一样发出错误。如果服务器推送数据但没有订阅者，值将被缓冲，并在新客户端订阅时立即发出。
- en: '|  |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: There’s a difference in handling messages by a regular RxJS `Subject` and the
    `WebSocketSubject`, though. If you call `next()` on `Subject`, it emits data to
    all subscribers, but if you call `next()` on `WebSocketSubject`, it won’t. Remember
    that there’s a server between an observable and subscribers, and it’s up to the
    server to decide when to emit values.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然处理消息的方式在常规 RxJS `Subject` 和 `WebSocketSubject` 之间有所不同。如果你在 `Subject` 上调用 `next()`，它会向所有订阅者发出数据，但如果你在
    `WebSocketSubject` 上调用 `next()`，则不会。记住，在可观察对象和订阅者之间有一个服务器，何时发出值由服务器决定。
- en: '|  |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The ngAuction client that comes with this chapter includes the file shared/services/bid.service.ts,
    which uses `WebSocketSubject`. `BidService` is a singleton that’s used only by
    `ProductDetailComponent`, which subscribes to it using the `async` pipe. When
    a user closes the product-detail view, the component gets destroyed, and the `async`
    pipe unsubscribes, closing the WebSocket connection. Let’s review the code of
    script bid.service.ts.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 本章附带 ngAuction 客户端包括 shared/services/bid.service.ts 文件，该文件使用 `WebSocketSubject`。`BidService`
    是一个单例，仅由 `ProductDetailComponent` 使用，它使用 `async` 管道订阅它。当用户关闭产品详情视图时，组件被销毁，`async`
    管道取消订阅，关闭 WebSocket 连接。让我们回顾一下 bid.service.ts 脚本的代码。
- en: Listing 13.27\. bid.service.ts
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.27\. bid.service.ts
- en: '[PRE37]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* A getter for the private property _wsSubject**'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 私有属性 _wsSubject 的 getter**'
- en: '***2* The WebSocket-Subject was never created or is already disconnected.**'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* WebSocket-Subject 永远没有被创建或已经断开连接。**'
- en: '***3* Connects to BidServer**'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 连接到 BidServer**'
- en: '***4* Gets a reference to the subject’s observable**'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 获取主题的可观察对象的引用**'
- en: '***5* Injects the URL of the WebSocket server**'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 注入 WebSocket 服务器 URL**'
- en: '***6* Pushes the new bid to BidServer**'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将新出价推送到 BidServer**'
- en: The `BidService` singleton includes the `priceUpdates$` getter, which returns
    the observable. `ProductDetailComponent` uses this getter in `ngOnInit()`. That
    means `priceUpdates$` opens a WebSocket connection (through `this.wsSubject` getter)
    as soon as `ProductDetailComponent` is rendered, and the `async` pipe is a subscriber
    in the template of this component.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`BidService` 单例包含 `priceUpdates$` getter，它返回可观察对象。`ProductDetailComponent`
    在 `ngOnInit()` 中使用此 getter。这意味着 `priceUpdates$` 一旦 `ProductDetailComponent` 渲染，就会打开
    WebSocket 连接（通过 `this.wsSubject` getter），并且 `async` 管道是该组件模板中的订阅者。'
- en: '`BidService` also has a private property, `_wsSubject`, and the getter `wsSubject`,
    used internally. When the getter is accessed the very first time from `priceUpdates$`,
    the `_wsSubject` variable doesn’t exist, and a new instance of `WebSocketSubject`
    is created, establishing a connection with the WebSocket server.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`BidService` 还有一个私有属性 `_wsSubject` 和内部使用的 `wsSubject` getter。当从 `priceUpdates$`
    第一次访问 getter 时，`_wsSubject` 变量不存在，并且会创建一个新的 `WebSocketSubject` 实例，与 WebSocket
    服务器建立连接。'
- en: If a user navigates away from the product-detail view, the connection is closed.
    Because `BidService` is a singleton, if a user closes and reopens the product-detail
    view, the instance of `BidService` won’t be re-created, but because the connection
    status is closed (`_wsSubject.closed`), it will be reestablished.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户离开产品详情视图，连接将被关闭。因为 `BidService` 是一个单例，如果用户关闭并重新打开产品详情视图，`BidService` 的实例不会重新创建，但由于连接状态已关闭
    (`_wsSubject.closed`)，它将被重新建立。
- en: The URL of the WebSocket server (`WS_URL`) is stored in environment.ts for the
    dev environment and in environment.prod.ts for production. This value is injected
    into the `wsUrl` variable using the `@Inject` directive.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket服务器的URL（`WS_URL`）在开发环境中存储在`environment.ts`中，在生产环境中存储在`environment.prod.ts`中。此值通过`@Inject`指令注入到`wsUrl`变量中。
- en: This concludes the code review of the ngAuction updates that implement communication
    between the Angular client and two servers. Run ngAuction as described in [section
    13.4.1](#ch13lev2sec3), and ngAuction becomes operational.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了ngAuction更新代码审查，这些更新实现了Angular客户端与两个服务器之间的通信。按照[第13.4.1节](#ch13lev2sec3)所述运行ngAuction，ngAuction将变为可用状态。
- en: Summary
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The WebSocket protocol offers unique features that aren’t available with HTTP,
    which makes it a better choice for certain use cases. Both the client and the
    server can initiate communication.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket协议提供了HTTP所不具备的独特功能，这使得它在某些用例中成为更好的选择。客户端和服务器都可以发起通信。
- en: The WebSocket protocol doesn’t use the request/response model.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebSocket协议不使用请求/响应模型。
- en: You can create an Angular service that turns WebSocket events into an observable
    stream.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以创建一个Angular服务，将WebSocket事件转换为可观察的流。
- en: The RxJS library includes a `Subject`-based implementation of WebSocket support
    in the `WebSocketSubject` class, and you can use it in any Angular app.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJS库在`WebSocketSubject`类中包含了基于`Subject`的WebSocket支持实现，你可以在任何Angular应用中使用它。
