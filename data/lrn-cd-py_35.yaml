- en: 'Lesson 29\. Capstone project: document similarity'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第29课\. 核心项目：文档相似度
- en: After reading [lesson 29](#ch29), you’ll be able to
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第29课](#ch29)之后，你将能够
- en: Take as input two files and determine their similarity
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以两个文件作为输入并确定它们的相似度
- en: Write organized code by using functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用函数编写有组织的代码
- en: Understand how to work with dictionaries and lists in a real-life setting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实际环境中了解如何使用字典和列表。
- en: How similar are two sentences? Paragraphs? Essays? You can write a program incorporating
    dictionaries and lists to calculate the similarity of two pieces of work. If you’re
    a teacher, you could use this to check for similarity between essay submissions.
    If you’re making changes to your own documents, you can use this program as a
    sort of version control, comparing versions of your documents to see where major
    changes were made.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 两个句子、段落或文章有多相似？你可以编写一个程序，结合字典和列表来计算两篇作品的相似度。如果你是教师，你可以使用这个程序来检查论文提交之间的相似度。如果你正在修改自己的文档，你可以使用这个程序作为版本控制，比较文档的不同版本，以查看主要更改发生在哪里。
- en: '|  |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The problem
  id: totrans-7
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You’re given two files containing text. Using the names of the files, write
    a program that reads the documents and uses a metric to determine how similar
    they are. Documents that are exactly the same should get a score of 1, and documents
    that don’t have any words in common should get a score of 0.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你被提供了包含文本的两个文件。使用文件名，编写一个程序来读取文档，并使用一个指标来确定它们的相似度。完全相同的文档应得分为1，没有任何共同单词的文档应得分为0。
- en: '|  |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Given this problem description, you need to decide a few things:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个问题描述，你需要决定一些事情：
- en: Do you count punctuation from the files or only words?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否计算文件中的标点符号或仅计算单词？
- en: Do you care about the ordering of the words in files? If two files have the
    same words but in different order, are they still the same?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你关心文件中单词的顺序吗？如果两个文件有相同的单词但顺序不同，它们仍然是相同的吗？
- en: What metric do you use to assign a numerical value to the similarity?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用什么指标来为相似度分配数值？
- en: These are important questions to answer, but when given a problem, a more important
    action is to break it into subtasks. Each subtask will become its own module,
    or a *function* in Python terms.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是需要回答的重要问题，但当一个问题时，更重要的行动是将它分解成子任务。每个子任务将成为它自己的模块，或者用Python术语来说，是一个*函数*。
- en: 29.1\. Breaking the problem into tasks
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.1\. 将问题分解为任务
- en: 'If you reread the problem statement, you can see that a few natural divisions
    exist for self-contained tasks:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新阅读问题陈述，你可以看到存在一些自然划分，用于自包含的任务：
- en: Get the filename, open the file, and read the information.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取文件名，打开文件，并读取信息。
- en: Get all the words in a file.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取文件中的所有单词。
- en: Map each word to how often it occurs. Let’s agree that order doesn’t matter
    for now.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个单词映射到其出现的频率。让我们先同意，目前顺序不重要。
- en: Calculate the similarity.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算相似度。
- en: Notice that in breaking down the tasks, you haven’t made any specific decisions
    about implementations. You have only broken down your original problem.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到在分解任务时，你还没有对实现方式做出任何具体决定。你只是分解了你的原始问题。
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Thinking like a programmer**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**像程序员一样思考**'
- en: When thinking about how to break down your problem, choose and write tasks in
    such a way that they can be reusable. For example, make a task that reads a filename
    and gives you back the file contents, as opposed to a task that reads exactly
    two filenames and gives you back their contents. The idea is that the function
    that reads one filename is more versatile and, if needed, you can call it two
    (or more) times.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当思考如何分解你的问题时，选择并编写任务，使它们可以重用。例如，创建一个任务，读取文件名并返回文件内容，而不是读取确切两个文件名并返回它们的内容。想法是，读取一个文件名的函数更灵活，如果需要，你可以调用它两次（或更多次）。
- en: '|  |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 29.2\. Reading file information
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.2\. 读取文件信息
- en: The first step is to write a function that takes in a filename, reads the contents,
    and gives you back the contents in useable form. A good choice for the return
    would be to give you back all the contents of the file as a (possibly large) string.
    [Listing 29.1](#ch29ex01) shows you the function to do this. It uses Python functions
    to open the file by using the filename given, read the entire contents into a
    string, and return that string. When the function is called on the name of a file,
    it’ll return a string with all the file contents.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是编写一个函数，它接受一个文件名，读取内容，并以可用的形式返回内容。一个不错的选择是返回文件的所有内容作为一个（可能很大的）字符串。[列表29.1](#ch29ex01)展示了执行此操作的函数。它使用Python函数通过提供的文件名打开文件，将整个内容读入一个字符串，并返回该字符串。当函数被文件名调用时，它将返回包含所有文件内容的字符串。
- en: Listing 29.1\. Reading a file
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表29.1\. 读取文件
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '***1* Docstring**'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 文档字符串**'
- en: '***2* Python function to open the file by using the filename**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用文件名打开文件的 Python 函数**'
- en: '***3* Python function to read all contents as a string**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 读取所有内容作为字符串的 Python 函数**'
- en: '***4* Return string**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 返回字符串**'
- en: '***5* Function call**'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 函数调用**'
- en: After you write a function, you should test and, if necessary, debug it. To
    test this function, you need to create a file with contents. Create an empty text
    document in the same folder where you have your .py file for this lesson. Populate
    the text file with content and save it; I used Shakespeare’s “Sonnet 18.” Now,
    in the .py file, you can call the function with
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在你编写一个函数之后，你应该测试它，并在必要时进行调试。为了测试这个函数，你需要创建一个包含内容的文件。在这个课程中，在你的 .py 文件所在的同一文件夹中创建一个空的文本文档。将内容填充到文本文件中并保存；我使用了莎士比亚的“第18首十四行诗”。现在，在
    .py 文件中，你可以通过以下方式调用函数
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you run the file, the console should print the entire contents of the file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行文件时，控制台应该打印出文件的全部内容。
- en: '|  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Thinking like a programmer**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**像程序员一样思考**'
- en: The point of writing functions is to make your life easier. Functions should
    be self-contained pieces of code that you need to debug only once but that you
    can reuse many times. When you’re integrating more than one function, you need
    to debug only the way they interact as opposed to debugging the functions themselves.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 编写函数的目的是让你的生活变得更简单。函数应该是自包含的代码块，你只需要调试一次，但可以多次重用。当你集成多个函数时，你需要调试的是它们如何交互，而不是调试函数本身。
- en: '|  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 29.3\. Saving all words from the file
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.3\. 保存文件中的所有单词
- en: Now you have a function that returns a string containing all the contents of
    a file. One giant string isn’t helpful to a computer. Remember that Python works
    with objects, and a large string containing a bunch of text is one object. You’d
    like to break this large string into parts. If you’re comparing two documents,
    a natural breakdown of the string would be to separate it into words.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有一个返回包含文件所有内容的字符串的函数。一个巨大的字符串对计算机没有帮助。记住Python与对象一起工作，包含大量文本的大字符串是一个对象。你希望将这个大字符串分成几部分。如果你正在比较两个文档，字符串的自然分解是将它分成单词。
- en: '|  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Thinking like a programmer**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**像程序员一样思考**'
- en: When faced with a task, you’ll often need to decide which data structures (types)
    to use. Before beginning to code, think about each data type you’ve learned about
    and decide whether it’s an appropriate one to use. When more than one may work,
    pick the simplest one.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 面对一项任务时，你通常会需要决定使用哪种数据结构（类型）。在开始编码之前，考虑你学过的每个数据类型，并决定它是否是合适的。当有多种可能的工作方式时，选择最简单的一种。
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'This task of breaking down a string will be done using a function. Its input
    is a string. Its output can be one of many things. With more coding practice,
    you’ll more quickly recognize when to use certain object types and why. In this
    case, you’ll separate all the words in the string into a list, with each word
    being an element in the list. [Listing 29.2](#ch29ex02) shows the code. It first
    does a bit of cleanup by replacing newlines with a space and removes all special
    characters. The expression `string.punctuation` is a string itself whose value
    is the set of all the punctuation characters that a string object could have:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个将字符串分解的任务将通过一个函数来完成。它的输入是一个字符串。它的输出可以是许多种东西之一。随着编码实践的增多，你将更快地认识到何时使用某些对象类型以及为什么。在这种情况下，你将把字符串中的所有单词分离成一个列表，其中每个单词都是列表中的一个元素。[列表29.2](#ch29ex02)展示了代码。它首先进行一些清理，将换行符替换为空格，并移除所有特殊字符。表达式`string.punctuation`本身也是一个字符串，其值是字符串对象可能具有的所有标点符号的集合：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After the text has been cleaned up, you use the `split` operation to split the
    string on the space character and give back a list of all words (because all words
    are separated by a space).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本清理完毕后，你使用`split`操作在空格字符上拆分字符串，并返回一个包含所有单词的列表（因为所有单词都由空格分隔）。
- en: Listing 29.2\. Finding words from a string
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表29.2\. 从字符串中查找单词
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Brings in functions related to strings**'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 引入与字符串相关的函数**'
- en: '***2* Replaces newlines with a space**'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将换行符替换为空格**'
- en: '***3* Uses preset punctuation characters from string**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用字符串中的预设标点符号**'
- en: '***4* Replaces punctuation characters with the empty string**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将标点符号替换为空字符串**'
- en: '***5* Makes a list of all words by using a space separator**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用空格分隔符制作所有单词的列表**'
- en: '***6* Returns list of words**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 返回单词列表**'
- en: '***7* Function call**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 函数调用**'
- en: '|  |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Thinking like a programmer**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**像程序员一样思考**'
- en: Before running a function on large input files, try it on a smaller test file
    with a couple of words. That way, if anything goes wrong, you don’t have to look
    through hundreds of lines to figure out what’s wrong.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在对大型输入文件运行函数之前，先在包含几个单词的小测试文件上尝试。这样，如果出了问题，你不必查看数百行代码来找出问题所在。
- en: '|  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You run this function on the text file sonnet18.txt:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你在sonnet18.txt文本文件上运行此函数：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you type the following code, you’ll get back a list of all the words in
    the console:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入以下代码，你将在控制台得到所有单词的列表：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This prints the following list for sonnet18.txt:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这会为sonnet18.txt打印以下列表：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 29.4\. Mapping words to their frequency
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.4\. 将单词映射到它们的频率
- en: Now that you have a list of words, you have a Python object with which you can
    work more in-depth to analyze its contents. At this point, you should be thinking
    about how to find the similarity between two documents. At the very least, you’ll
    probably want to know the quantity of each word in the document.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个单词列表，你有一个Python对象，你可以更深入地分析其内容。在这个阶段，你应该在考虑如何找到两个文档之间的相似度。至少，你可能想知道文档中每个单词的数量。
- en: Notice that when you created the list of words, the list contained all the words,
    in order, from the original string. If there were duplicate words, they were added
    in as another list element. To give you more information about the words, you’d
    like to pair up each word to how often it occurs. Hopefully, the phrase *pair
    up* led you to believe that a Python dictionary would be an appropriate data structure.
    In this particular case, you’ll be building a frequency dictionary. The following
    listing shows you the code to accomplish this.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你创建单词列表时，列表包含了从原始字符串中按顺序排列的所有单词。如果有重复的单词，它们会被添加为另一个列表元素。为了给你更多关于单词的信息，你希望将每个单词与其出现的频率配对。希望“配对”这个短语让你相信Python字典将是一个合适的数据结构。在这种情况下，你将构建一个频率字典。以下列表显示了完成此任务的代码。
- en: Listing 29.3\. Making a frequency dictionary for words
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表29.3\. 为单词制作频率字典
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Initially empty dictionary**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 初始空字典**'
- en: '***2* Looks at each word in list**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 查看列表中的每个单词**'
- en: '***3* If word already in dictionary...**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果单词已在字典中...**'
- en: '***4* ...adds one to its count**'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* ...将其计数加一**'
- en: '***5* Word not in dictionary yet**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 字典中尚无此单词**'
- en: '***6* Adds word and sets its count to 1**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 添加单词并将其计数设置为1**'
- en: '***7* Returns dictionary**'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 返回字典**'
- en: '***8* Function call**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 函数调用**'
- en: A frequency dictionary is a useful application of dictionaries in this problem.
    It maps a word to the number of times you see it in the text. You can use this
    information when you compare two documents.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 频率字典是字典在此问题中的一个有用应用。它将一个单词映射到你在文本中看到它的次数。当你比较两个文档时，你可以使用这些信息。
- en: 29.5\. Comparing two documents by using a similarity score
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.5\. 通过相似度分数比较两个文档
- en: 'Now you have to decide which formula you’d like to use to compare two documents,
    given the number of times each word occurs. To begin with, the formula doesn’t
    need to be too complicated. As an initial pass, you can use a simple metric to
    make the comparison and see how well it does. Suppose these steps will calculate
    the score, by using a running sum over each word:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你必须决定使用哪个公式来比较两个文档，给定每个单词出现的次数。首先，公式不需要太复杂。作为一个初始步骤，你可以使用一个简单的指标来进行比较，看看效果如何。假设以下步骤将通过每个单词的运行总和来计算分数：
- en: Look for a word in both frequency dictionaries (one for each document).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两个频率字典中查找一个单词（每个文档一个）。
- en: If it’s in both, add the difference between the counts. If it appears in only
    one of them, add the count for that one (effectively adding the difference between
    the count from one dictionary and 0 from the other one).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它在两个中都有，添加计数的差异。如果它只出现在其中一个中，添加那个计数的值（实际上添加了一个字典中的计数与另一个字典中的0之间的差异）。
- en: The score is the division between the total difference and the total number
    of words in both documents.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分数是总差异与两个文档中单词总数的比值。
- en: After coming up with a metric, it’s important to do a sanity check. If the documents
    are exactly the same, the difference between all the word counts in both frequency
    dictionaries is 0\. Dividing this by the total number of words in both dictionaries
    gives 0\. If the documents don’t have any words in common, the difference summed
    up will be “total words in one document” + “total words in other document.” Dividing
    this by the total number of words in both documents gives a ratio of 1\. The ratios
    make sense except that you want documents that are exactly the same to have a
    ratio of 1, and ones that are completely different to have a ratio of 0\. To solve
    this, subtract the ratio from 1.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在提出一个度量标准后，进行合理性检查是很重要的。如果文档完全相同，两个频率字典中所有单词计数的差异为0。将这个值除以两个字典中单词的总数得到0。如果文档没有共同的单词，差异的总和将是“一个文档中的总单词数”加上“另一个文档中的总单词数”。将这个值除以两个文档中单词的总数得到一个比率为1。这些比率是有意义的，除了你希望完全相同的文档具有比率为1，而完全不同的文档具有比率为0。为了解决这个问题，从1中减去比率。
- en: '[Listing 29.4](#ch29ex04) shows the code to calculate the similarity, given
    two input dictionaries. The code iterates over the keys of one dictionary; it
    doesn’t matter which one, because you’ll iterate over the other dictionary in
    another loop.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表29.4](#ch29ex04)显示了给定两个输入字典计算相似度的代码。代码遍历一个字典的键；哪个都无关紧要，因为你将在另一个循环中遍历另一个字典。'
- en: As you’re going through the keys of one dictionary, you check whether the key
    is also in the other dictionary. Recall that you’re looking at the value for each
    key; the value is the number of times the word occurs in one text. If the word
    is in both dictionaries, take the difference between the two frequency counts.
    If it isn’t, take the count from the one dictionary in which it exists.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遍历一个字典的键时，检查该键是否也在另一个字典中。回想一下，你正在查看每个键的值；值是单词在一个文本中出现的次数。如果单词在两个字典中，取两个频率计数的差异。如果它不在，取存在于其中一个字典中的计数。
- en: After you finish going through one dictionary, go through the other dictionary.
    You no longer need to look at the difference between the two dictionary values
    because you already counted that previously. Now you’re just looking to see whether
    any words in the other dictionary weren’t in the first one. If so, add up their
    counts.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成遍历一个字典后，再遍历另一个字典。你不再需要查看两个字典值之间的差异，因为你已经之前计算过。现在你只是查看另一个字典中是否有任何单词不在第一个字典中。如果有，将它们的计数相加。
- en: Finally, when you have the sum of the differences, divide that by the total
    number of words in both dictionaries. Take 1 minus that value to match the original
    problem specifications for scoring.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你有了差异的总和时，将其除以两个字典中单词的总数。取这个值的1减去，以匹配原始问题的评分规范。
- en: Listing 29.4\. Calculate similarity given two input dictionaries
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表29.4\. 给定两个输入字典计算相似度
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Iterates over words in one dictionary**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 遍历一个字典中的单词**'
- en: '***2* Word is in both dictionaries**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 单词同时出现在两个字典中**'
- en: '***3* Adds the difference in frequencies**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 添加频率差异**'
- en: '***4* Word doesn’t appear in the other dictionary**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 单词未出现在另一个字典中**'
- en: '***5* Adds the entire frequency**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 添加整个频率**'
- en: '***6* Iterates over words in other dictionary**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 遍历另一个字典中的单词**'
- en: '***7* Counted word in both dictionaries; looks only at words not in dict1**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 在两个字典中都计算过的单词；只查看不在dict1中的单词**'
- en: '***8* Adds entire frequency**'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 添加整个频率**'
- en: '***9* Total number of words in both dictionaries**'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 两个字典中的总单词数**'
- en: '***10* Divides difference by total number of words**'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 将差异除以总单词数**'
- en: '***11* Subtracts difference from 1**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11* 从1中减去差值**'
- en: '***12* Rounds to 2 decimal places and returns score between 0 and 1**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***12* 四舍五入到两位小数并返回介于0和1之间的分数**'
- en: The function returns a float number between 0 and 1\. The lower the number,
    the less similar the documents are, and vice versa.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 函数返回一个介于0和1之间的浮点数。数字越低，文档越不相似，反之亦然。
- en: 29.6\. Putting it all together
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.6\. 将所有内容组合在一起
- en: 'The final step is to test the code on text files. Before using your program
    on two separate files, do a sanity check: first, use the same file as both texts
    to check that the score you get is 1.0, and then use the sonnet file and an empty
    file for the other to check that the score you get is 0.0.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在文本文件上测试代码。在将你的程序用于两个单独的文件之前，先进行一次合理性检查：首先，使用相同的文件作为两个文本来检查你得到的评分是否为 1.0，然后使用十四行诗文件和一个空文件作为另一个来检查你得到的评分是否为
    0.0。
- en: Now, use Shakespeare’s “Sonnet 18” and “Sonnet 19” to test two pieces of work,
    and then modify “Sonnet 18” by changing the word *summer* to *winter* to see if
    the program found them to be almost exactly the same.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用莎士比亚的“十四行诗 18”和“十四行诗 19”来测试两篇作品，然后修改“十四行诗 18”，将单词“夏天”改为“冬天”，以查看程序是否认为它们几乎完全相同。
- en: 'The text of “Sonnet 18” was shown earlier. Here’s the text for “Sonnet 19”:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: “十四行诗 18”的文本之前已经展示过。以下是“十四行诗 19”的文本：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The following listing opens two files, reads their words, makes the frequency
    dictionary, and calculates their similarity.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表打开两个文件，读取它们的单词，创建频率字典，并计算它们的相似度。
- en: Listing 29.5\. Code to run the document similarity program
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 29.5. 运行文档相似度程序的代码
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When I run the program on “Sonnet 18” and “Sonnet 19” the similarity score is
    0.24\. It makes sense that it’s closer to 0 because they’re two different pieces
    of work. When I run the program on “Sonnet 18” and my modified “Sonnet 18” (with
    three instances of the word *summer* changed to *winter*), the score is 0.97\.
    This also makes sense because the two pieces are almost the same.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在“十四行诗 18”和“十四行诗 19”上运行程序时，相似度评分为 0.24。它们是两篇不同的作品，所以得分接近 0 是有道理的。当我将程序运行在“十四行诗
    18”和我修改过的“十四行诗 18”（将三个“夏天”的实例改为“冬天”）上时，评分为 0.97。这也是有道理的，因为这两篇作品几乎相同。
- en: 29.7\. One possible extension
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 29.7. 一种可能的扩展
- en: You can make your program more robust by looking at pairs of words instead of
    single words. After you read the file as a string, look at pairs of words, called
    *bigrams*, and save them in a list. Looking at bigrams instead of words can improve
    your program because pairs of words often give a better indication of similarity
    in languages. This could lead to a more accurate setup and a better model of written
    text. If you want, you could also use a mixture of bigrams and words when you
    calculate a similarity score.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看单词对而不是单个单词来使你的程序更健壮。在你将文件作为字符串读取之后，查看单词对，称为“二元组”，并将它们保存在列表中。查看二元组而不是单词可以提高你的程序，因为单词对在语言中通常能更好地指示相似度。这可能导致更准确的设置和更好的书面文本模型。如果你想的话，你还可以在计算相似度评分时使用二元组和单词的混合。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this lesson, my objective was to teach you how to write a program that reads
    in two files, converts their content to a string, uses a list to store all the
    words in a file, and then makes a frequency dictionary to store each word and
    the number of times it occurred in a file. You compared two frequency dictionaries
    by counting the differences between the word counts in each dictionary to come
    up with a score for how similar the files were. Here are the major takeaways:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节课中，我的目标是教你如何编写一个程序，该程序读取两个文件，将它们的内容转换为字符串，使用列表存储文件中的所有单词，然后创建一个频率字典来存储每个单词及其在文件中出现的次数。你通过比较两个频率字典中单词计数的差异来得出文件相似度的评分。以下是主要收获：
- en: You wrote modular code by using functions that could be reused.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你通过使用可重用的函数编写了模块化代码。
- en: You used lists to store individual elements.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用列表来存储单个元素。
- en: You used a dictionary to map a word to its count.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用字典将一个单词映射到其计数。
