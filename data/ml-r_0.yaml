- en: Part 1\. Introduction
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分. 简介
- en: While this first part of the book includes only two chapters, it is essential
    to provide you with the basic knowledge and skills you’ll rely on throughout the
    book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这本书的第一部分只有两章，但提供给您在整本书中都将依赖的基本知识和技能是至关重要的。
- en: '[Chapter 1](kindle_split_010.html#ch01) introduces you to some basic machine
    learning terminology. Having a good vocabulary for the core concepts can help
    you see the big picture of machine learning and aid in your understanding of the
    more complex topics we’ll explore later in the book. This chapter teaches you
    what machine learning is, how it can benefit (or harm) us, and how we can categorize
    different types of machine learning tasks. The chapter finishes by explaining
    why we’re using R for machine learning, what datasets you’ll be working with,
    and what you can expect to learn from the book.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第一章](kindle_split_010.html#ch01)向您介绍了某些基本的机器学习术语。拥有核心概念的良好词汇量可以帮助您看到机器学习的整体图景，并有助于您理解我们在书中稍后将要探讨的更复杂主题。本章教您什么是机器学习，它如何（或可能）对我们有益或有害，以及我们如何对不同的机器学习任务进行分类。本章最后解释了为什么我们使用R进行机器学习，您将使用哪些数据集，以及您可以期待从本书中学到什么。'
- en: In [chapter 2](kindle_split_011.html#ch02), we take a brief detour away from
    machine learning and focus on developing your R skills by covering a collection
    of packages known as the *tidyverse*. The packages of the tidyverse provide us
    with the tools to store, manipulate, transform, and visualize our data using more
    human-readable, intuitive code. You don’t need to use the tidyverse when working
    on machine learning projects, but doing so helps you simplify your data-wrangling
    processes. We’ll use tidyverse tools in the projects throughout the book, so a
    solid grounding in them in [chapter 2](kindle_split_011.html#ch02) can help you
    in the rest of the chapters. I’m sure you’ll find that these skills improve your
    general R programming and data science skills.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](kindle_split_011.html#ch02)中，我们暂时离开机器学习，专注于通过介绍名为*tidyverse*的一系列包来提高您的R技能。tidyverse的包为我们提供了使用更易于阅读、更直观的代码来存储、操作、转换和可视化数据的工具。在处理机器学习项目时，您不需要使用tidyverse，但这样做可以帮助您简化数据处理过程。我们将在本书的项目中使用tidyverse工具，因此在第二章中对其有扎实的了解将有助于您在后续章节中。我相信您会发现这些技能提高了您的R编程和数据科学技能。
- en: Beginning with [chapter 2](kindle_split_011.html#ch02), I encourage you to start
    coding along with me. To maximize your retention of knowledge, I strongly recommend
    that you run the code examples in your own R session and save your .R files so
    you can refer back to your code in the future. Make sure you understand how each
    line of code relates to its output.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第二章](kindle_split_011.html#ch02)开始，我鼓励您与我一起开始编码。为了最大限度地提高您对知识的保留，我强烈建议您在自己的R会话中运行代码示例，并保存您的.R文件，这样您可以在将来参考您的代码。确保您理解每一行代码与其输出之间的关系。
- en: Chapter 1\. Introduction to machine learning
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一章. 机器学习简介
- en: '*This chapter covers*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: What machine learning is
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是机器学习
- en: Supervised vs. unsupervised machine learning
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监督学习与无监督学习
- en: Classification, regression, dimension reduction, and clustering
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类、回归、降维和聚类
- en: Why we’re using R
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们使用R
- en: Which datasets we will use
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用哪些数据集
- en: You interact with machine learning on a daily basis whether you recognize it
    or not. The advertisements you see online are of products you’re more likely to
    buy based on the things you’ve previously bought or looked at. Faces in the photos
    you upload to social media platforms are automatically identified and tagged.
    Your car’s GPS predicts which routes will be busiest at certain times of day and
    replots your route to minimize journey length. Your email client progressively
    learns which emails you want and which ones you consider spam, to make your inbox
    less cluttered; and your home personal assistant recognizes your voice and responds
    to your requests. From small improvements to our daily lives such as these, to
    big, society-changing ideas such as self-driving cars, robotic surgery, and automated
    scanning for other Earth-like planets, machine learning has become an increasingly
    important part of modern life.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否意识到，你每天都在与机器学习互动。你在线上看到的广告是基于你之前购买或查看的产品更有可能购买的产品。你上传到社交媒体平台的照片中的人脸会自动识别并标记。你的汽车的GPS预测在一天中的某些时间哪些路线会最繁忙，并重新规划路线以缩短行程。你的电子邮件客户端会逐渐学习你想要的电子邮件和你认为垃圾邮件的电子邮件，以使你的收件箱更整洁；你的家庭个人助理能识别你的声音并回应你的请求。从这些对我们日常生活的小改进，到自动驾驶汽车、机器人手术和自动扫描其他类地行星等改变社会的大想法，机器学习已经成为现代生活越来越重要的部分。
- en: 'But here’s something I want you to understand right away: machine learning
    isn’t solely the domain of large tech companies or computer scientists. *Anyone*
    with basic programming skills can implement machine learning in their work. If
    you’re a scientist, machine learning can give you extraordinary insights into
    the phenomena you’re studying. If you’re a journalist, it can help you understand
    patterns in your data that can delineate your story. If you’re a businessperson,
    machine learning can help you target the right customers and predict which products
    will sell the best. If you’re someone with a question or problem, and you have
    sufficient data to answer it, machine learning can help you do just that. While
    you won’t be building intelligent cars or talking robots after reading this book
    (like Google and Deep Mind), you will have gained the skills to make powerful
    predictions and identify informative patterns in your data.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一件事我想让你立刻明白：机器学习不仅仅是大型科技公司或计算机科学家的领域。**任何人**只要有基本的编程技能，就可以在自己的工作中实现机器学习。如果你是一位科学家，机器学习可以让你对所研究的现象有非凡的洞察力。如果你是一位记者，它可以帮助你理解数据中的模式，从而描绘你的故事。如果你是一位商人，机器学习可以帮助你定位正确的客户并预测哪些产品会卖得最好。如果你有疑问或问题，并且你有足够的数据来回答它，机器学习可以帮助你做到这一点。虽然阅读这本书后，你们不会建造智能汽车或会说话的机器人（就像谷歌和Deep
    Mind那样），但你们将获得做出强大预测和识别数据中信息性模式的能力。
- en: I’m going to teach you the theory and practice of machine learning at a level
    that anyone with a basic knowledge of R can follow. Ever since high school, I’ve
    been terrible at mathematics, so I don’t expect you to be great at it either.
    Although the techniques you’re about to learn are based in math, I’m a firm believer
    that there are no hard concepts in machine learning. All of the processes we’ll
    explore together will be explained graphically and intuitively. Not only does
    this mean you’ll be able to apply and understand these processes, but you’ll also
    learn all this without having to wade through mathematical notation. If, however,
    you are mathematically minded, you’ll find equations presented through the book
    that are “nice to know,” rather than “need to know.”
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我将用任何具备R语言基础知识的读者都能理解的水平，教你们机器学习的理论和实践。自从高中以来，我就对数学很糟糕，所以我不期望你们在这方面很出色。尽管你们即将学习的技巧基于数学，但我坚信机器学习中没有难以理解的概念。我们将一起探索的所有过程都将通过图形和直观的方式进行解释。这不仅意味着你们将能够应用和理解这些过程，而且你们将无需通过数学符号就能学到所有这些知识。然而，如果你对数学有浓厚的兴趣，你会发现书中呈现的方程式是“了解即可”，而不是“必须知道”。
- en: In this chapter, we’re going to define what I actually mean by *machine learning*.
    You’ll learn the difference between an algorithm and a model, and discover that
    machine learning techniques can be partitioned into types that help guide us when
    choosing the best one for a given task.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将定义我实际上所说的**机器学习**是什么。你们将了解算法和模型之间的区别，并发现机器学习技术可以根据类型划分，这有助于我们在选择给定任务的最佳技术时进行指导。
- en: 1.1\. What is machine learning?
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1. 什么是机器学习？
- en: Imagine you work as a researcher in a hospital. What if, when a new patient
    is checked in, you could calculate the risk of them dying? This would allow the
    clinicians to treat high-risk patients more aggressively and result in more lives
    being saved. But where would you start? What data would you use? How would you
    get this information from the data? The answer is to use machine learning.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你是一家医院的科研人员。如果当新患者入院时，你能计算出他们死亡的风险呢？这将允许临床医生更加积极地治疗高风险患者，并最终挽救更多生命。但你应该从哪里开始呢？你将使用哪些数据？你将如何从数据中获取这些信息？答案是使用机器学习。
- en: Machine learning, sometimes referred to as *statistical learning*, is a subfield
    of artificial intelligence (AI) whereby *algorithms* “learn” patterns in data
    to perform specific tasks. Although algorithms may sound complicated, they aren’t.
    In fact, the idea behind an algorithm is not complicated at all. An algorithm
    is simply a step-by-step process that we use to achieve something that has a beginning
    and an end. Chefs have a different word for algorithms—they call them “recipes.”
    At each stage in a recipe, you perform some kind of process, like beating an egg,
    and then you follow the next instruction in the recipe, such as mixing the ingredients.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习，有时被称为*统计学习*，是人工智能（AI）的一个子领域，其中*算法*“学习”数据中的模式以执行特定任务。尽管算法可能听起来很复杂，但实际上并不复杂。事实上，算法背后的想法一点也不复杂。算法只是一个一步一步的过程，我们用它来实现有开始和结束的事情。厨师们对算法有不同的说法——他们称之为“食谱”。在食谱的每个阶段，你执行某种过程，比如打鸡蛋，然后你遵循食谱中的下一个指令，比如混合原料。
- en: Have a look in [figure 1.1](#ch01fig01) at an algorithm I made for making a
    cake. It starts at the top and progresses through the various operations needed
    to get the cake baked and served up. Sometimes there are decision points where
    the route we take depends on the current state of things, and sometimes we need
    to go back or *iterate* to a previous step of the algorithm. While it’s true that
    extremely complicated things can be achieved with algorithms, I want you to understand
    that they are simply sequential chains of simple operations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下[图1.1](#ch01fig01)中我制作的制作蛋糕的算法。它从顶部开始，通过一系列操作来烘焙并供应蛋糕。有时会有决策点，我们选择的路线取决于当前的情况，有时我们需要返回或*迭代*到算法的先前步骤。虽然确实可以用算法实现极其复杂的事情，但我希望你能理解，它们只是简单操作的顺序链。
- en: Figure 1.1\. An algorithm for making and serving a cake. We start at the top
    and, after performing each operation, follow the next arrow. Diamonds are decision
    points, where the arrow we follow next depends on the state of our cake. Dotted
    arrows show routes that iterate back to previous operations. This algorithm takes
    ingredients as its input and outputs cake with either ice cream or custard!
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.1。制作和供应蛋糕的算法。我们从顶部开始，并在执行每个操作后，跟随下一个箭头。菱形是决策点，我们接下来跟随的箭头取决于我们蛋糕的状态。虚线箭头显示返回先前操作的路线。这个算法以原料作为输入，输出带有冰淇淋或奶油的蛋糕！
- en: '![](fig1-1_alt.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1](fig1-1_alt.jpg)'
- en: So, having gathered data on your patients, you train a machine learning algorithm
    to learn patterns in the data associated with the patients’ survival. Now, when
    you gather data on a new patient, the algorithm can estimate the risk of that
    patient dying.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在收集了患者的数据之后，你训练一个机器学习算法来学习与患者生存相关的数据模式。现在，当你收集到一个新患者的数据时，该算法可以估算该患者死亡的风险。
- en: As another example, imagine you work for a power company, and it’s your job
    to make sure customers’ bills are estimated accurately. You train an algorithm
    to learn patterns of data associated with the electricity use of households. Now,
    when a new household joins the power company, you can estimate how much money
    you should bill them each month.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，想象一下，你为一家电力公司工作，你的工作是确保客户的账单估算准确。你训练一个算法来学习与家庭电力使用相关的数据模式。现在，当一个新的家庭加入电力公司时，你可以估算每个月应该向他们收取多少费用。
- en: Finally, imagine you’re a political scientist, and you’re looking for types
    of voters that no one (including you) knows about. You train an algorithm to identify
    patterns of voters in survey data, to better understand what motivates voters
    for a particular political party. Do you see any similarities between these problems
    and the problems you would like to solve? Then—provided the solution is hidden
    somewhere in your data—you can train a machine learning algorithm to extract it
    for you.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，假设你是一位政治学家，你正在寻找没有人（包括你）知道的选民类型。你训练一个算法来识别调查数据中的选民模式，以更好地理解什么因素激励特定政治党的选民。你在这两个问题上看到了任何相似之处吗？那么——如果解决方案隐藏在你的数据中——你可以训练一个机器学习算法来为你提取它。
- en: 1.1.1\. AI and machine learning
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1\. 人工智能与机器学习
- en: Arthur Samuel, a scientist at IBM, first used the term *machine learning* in
    1959\. He used it to describe a form of AI that involved training an algorithm
    to learn to play the game of checkers. The word *learning* is what’s important
    here, as this is what distinguishes machine learning approaches from traditional
    AI.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: IBM的科学家亚瑟·萨缪尔在1959年首次使用了*机器学习*这个术语。他用来描述一种涉及训练算法学习如何玩国际象棋的AI形式。这里的*学习*这个词很重要，因为它区分了机器学习方法与传统AI。
- en: 'Traditional AI is programmatic. In other words, you give the computer a set
    of rules so that when it encounters new data, it knows precisely which output
    to give. An example of this would be using `if else` statements to classify animals
    as dogs, cats, or snakes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 传统AI是程序化的。换句话说，你给计算机一套规则，这样当它遇到新数据时，它就知道应该给出哪个输出。一个例子就是使用`if else`语句来分类动物为狗、猫或蛇：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this R code, I’ve created three rules, mapping every possible input available
    to us to an output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段R代码中，我创建了三条规则，将我们可用的每一个可能的输入映射到一个输出：
- en: If the animal has four legs and climbs trees, it’s a cat.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果动物有四条腿且会爬树，它就是猫。
- en: If the animal has four legs and does not climb trees, it’s a dog.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果动物有四条腿且不会爬树，它就是狗。
- en: Otherwise, the animal is a snake.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，该动物是蛇。
- en: 'Now, if we apply these rules to the data, we get the expected answers:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们将这些规则应用于数据，我们会得到预期的答案：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The problem with this approach is that we need to know in advance all the possible
    outputs the computer should give, and the system will never give us an output
    that we haven’t told it to give. Contrast this with the machine learning approach,
    where instead of telling the computer the rules, we give it the data and allow
    it to learn the rules for itself. The advantage of this approach is that the machine
    can “learn” patterns we didn’t even know existed in the data—and the more data
    we provide, the better it gets at learning those patterns ([figure 1.2](#ch01fig02)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点在于我们需要事先知道计算机应该给出的所有可能的输出，而系统永远不会给出我们没有告诉它给出的输出。这与机器学习方法形成对比，在机器学习方法中，我们不是告诉计算机规则，而是给它数据，并允许它自己学习规则。这种方法的优点是机器可以“学习”我们甚至不知道数据中存在的模式——我们提供的数据越多，它在学习这些模式方面就越好（[图1.2](#ch01fig02)）。
- en: Figure 1.2\. Traditional AI vs. machine learning AI. In traditional AI applications,
    we provide the computer with a complete set of rules. When it’s given data, it
    outputs the relevant answers. In machine learning, we provide the computer with
    data and the answers, and it learns the rules for itself. When we pass new data
    through these rules, we get answers for this new data.
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.2\. 传统AI与机器学习AI的比较。在传统的AI应用中，我们向计算机提供一套完整的规则。当它接收到数据时，它会输出相关的答案。在机器学习中，我们向计算机提供数据和答案，然后它自己学习规则。当我们通过这些规则传递新的数据时，我们得到这些新数据的答案。
- en: '![](fig1-2_alt.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](fig1-2_alt.jpg)'
- en: 1.1.2\. The difference between a model and an algorithm
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2\. 模型与算法的区别
- en: In practice, we call a set of rules that a machine learning algorithm learns
    a *model*. Once the model has been learned, we can give it new observations, and
    it will output its predictions for the new data. We refer to these as models because
    they represent real-world phenomena in a simplistic enough way that we and the
    computer can interpret and understand it. Just as a model of the Eiffel Tower
    may be a good representation of the real thing but isn’t exactly the same, so
    statistical models are attempted representations of real-world phenomena but won’t
    match them perfectly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们称机器学习算法学习的一组规则为*模型*。一旦模型被学习，我们可以给它提供新的观察数据，它将输出对新数据的预测。我们称之为模型，因为它们以足够简单的方式表示现实世界现象，以至于我们和计算机可以解释和理解它。就像埃菲尔铁塔的模型可能很好地代表了真实的事物，但并不完全相同一样，所以统计模型是现实世界现象的尝试性表示，但不会完美匹配。
- en: '|  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You may have heard the famous phrase coined by the statistician George Box that
    “All models are wrong, but some are useful”; this refers to the approximate nature
    of models.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过统计学家乔治·博克斯提出的著名短语：“所有模型都是错误的，但有些是有用的”，这指的是模型的近似性质。
- en: '|  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The process by which the model is learned is referred to as the *algorithm*.
    As we discovered earlier, an algorithm is just a sequence of operations that work
    together to solve a problem. So how does this work in practice? Let’s take a simple
    example. Say we have two continuous variables, and we would like to train an algorithm
    that can predict one (the *outcome* or *dependent* variable) given the other (the
    *predictor* or *independent* variable). The relationship between these variables
    can be described by a straight line that can be defined using only two parameters:
    its slope and where it crosses the y-axis (the y-intercept). This is shown in
    [figure 1.3](#ch01fig03).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 学习模型的过程被称为*算法*。正如我们之前发现的，算法只是一系列共同工作的操作，用于解决问题。那么在实践中是如何工作的呢？让我们举一个简单的例子。假设我们有两个连续变量，我们希望训练一个算法，可以基于另一个变量（*结果*或*依赖*变量）预测一个（*预测器*或*独立*变量）。这些变量之间的关系可以用一条直线来描述，这条直线可以用仅两个参数来定义：它的斜率和它与y轴交叉的位置（y截距）。这如图[图1.3](#ch01fig03)所示。
- en: Figure 1.3\. Any straight line can be described by its slope (the change in
    y divided by the change in *x*) and its intercept (where it crosses the y-axis
    when *x* = 0). The equation *y* = intercept + slope * *x* can be used to predict
    the value of *y* given a value of *x*.
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.3\. 任何直线都可以用其斜率（y的变化除以x的变化）和其截距（当x=0时与y轴交叉的位置）来描述。方程 *y* = intercept + slope
    * *x* 可以用来预测给定x值的y值。
- en: '![](fig1-3.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图1-3](fig1-3.jpg)'
- en: An algorithm to learn this relationship could look something like the example
    in [figure 1.4](#ch01fig04). We start by fitting a line with no slope through
    the mean of all the data. We calculate the distance each data point is from the
    line, square it, and sum these squared values. This *sum of squares* is a measure
    of how closely the line fits the data. Next, we rotate the line a little in a
    clockwise direction and measure the sum of squares for *this* line. If the sum
    of squares is bigger than it was before, we’ve made the fit worse, so we rotate
    the slope in the other direction and try again. If the sum of squares gets smaller,
    then we’ve made the fit better. We continue with this process, rotating the slope
    a little less each time we get closer, until the improvement on our previous iteration
    is smaller than some preset value we’ve chosen. The algorithm has iteratively
    learned the model (the slope and y-intercept) needed to predict future values
    of the output variable, given only the predictor variable. This example is slightly
    crude but hopefully illustrates how such an algorithm could work.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 学习这种关系的算法可能看起来像[图1.4](#ch01fig04)中的例子。我们首先通过所有数据的平均值拟合一条没有斜率的直线。我们计算每个数据点到直线的距离，平方它，并将这些平方值相加。这个*平方和*是衡量直线拟合数据紧密程度的指标。接下来，我们将直线顺时针旋转一点，并测量这条直线的平方和。如果平方和比之前更大，那么我们使拟合变得更差，所以我们将斜率旋转到另一个方向并再次尝试。如果平方和变得更小，那么我们使拟合变得更好。我们继续这个过程，每次我们更接近时，斜率的旋转幅度都稍微小一点，直到我们之前迭代的改进小于我们选择的某个预设值。该算法通过迭代学习模型（斜率和y截距），根据预测变量预测输出变量的未来值。这个例子稍微有些粗糙，但希望它能说明这样的算法是如何工作的。
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: One of the initially confusing but eventually fun aspects of machine learning
    is that there is a plethora of algorithms to solve the same type of problem. The
    reason is that different people have come up with slightly different ways of solving
    the same problem, all trying to improve upon previous attempts. For a given task,
    it is our job as data scientists to choose which algorithm(s) will learn the best-performing
    model.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习最初令人困惑但最终有趣的方面之一是，有大量的算法可以解决同一类型的问题。原因是不同的人提出了略微不同的解决同一问题的方法，所有这些方法都在试图改进之前的尝试。对于给定的任务，作为数据科学家，我们的任务是选择哪个算法（或算法组合）将学习到最佳性能的模型。
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: While certain algorithms tend to perform better than others with certain types
    of data, no single algorithm will always outperform all others on all problems.
    This concept is called the *no free lunch theorem*. In other words, you don’t
    get something for nothing; you need to put some effort into working out the best
    algorithm for your particular problem. Data scientists typically choose a few
    algorithms they know tend to work well for the type of data and problem they are
    working on, and see which algorithm generates the best-performing model. You’ll
    see how we do this later in the book. We can, however, narrow down our initial
    choice by dividing machine learning algorithms into categories, based on the function
    they perform and how they perform it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然某些算法在处理某些类型的数据时可能比其他算法表现更好，但没有任何一个算法会在所有问题上始终优于所有其他算法。这个概念被称为**没有免费午餐定理**。换句话说，你不会得到不劳而获的东西；你需要付出一些努力来找出最适合你特定问题的最佳算法。数据科学家通常会选择一些他们知道对于他们正在处理的数据类型和问题表现良好的算法，并查看哪个算法生成的模型性能最佳。你将在本书后面的章节中看到我们是如何做到这一点的。然而，我们可以通过根据它们执行的功能和执行方式将机器学习算法分为类别来缩小我们的初始选择范围。
- en: Figure 1.4\. A hypothetical algorithm for learning the parameters of a straight
    line. This algorithm takes two continuous variables as inputs and fits a straight
    line through the mean. It iteratively rotates the line until it finds a solution
    that minimizes the sum of squares. The parameters of the line are output as the
    learned model.
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.4\. 一个假设的算法，用于学习直线的参数。此算法将两个连续变量作为输入，并通过均值拟合一条直线。它迭代地旋转直线，直到找到一个最小化平方和的解。直线的参数作为学习模型输出。
- en: '![](fig1-4_alt.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](fig1-4_alt.jpg)'
- en: 1.2\. Classes of machine learning algorithms
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2. 类别机器学习算法
- en: 'All machine learning algorithms can be categorized by their learning type and
    the task they perform. There are three learning types:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 所有机器学习算法都可以根据它们的学习类型和执行的任务进行分类。有三种学习类型：
- en: Supervised
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监督
- en: Unsupervised
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无监督
- en: Semi-supervised
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半监督
- en: 'The type depends on how the algorithms learn. Do they require us to hold their
    hand through the learning process? Or do they learn the answers for themselves?
    Supervised and unsupervised algorithms can be further split into two classes each:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 类型取决于算法的学习方式。它们需要我们通过学习过程来引导吗？还是它们自己学习答案？监督和无监督算法可以进一步分为每类两个子类：
- en: Supervised
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监督
- en: Classification
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类
- en: Regression
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归
- en: Unsupervised
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无监督
- en: Dimension reduction
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维度降低
- en: Clustering
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚类
- en: The class depends on what the algorithms learn to *do*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 该类别取决于算法学习去**做什么**。
- en: So we categorize algorithms by how they learn and what they learn to do. But
    why do we care about this? Well, there are *a lot* of machine learning algorithms
    available to us. How do we know which one to pick? What kind of data do they require
    to function properly? Knowing which categories different algorithms belong to
    makes our job of selecting the most appropriate ones much simpler. In the next
    section, I cover how each of the classes is defined and why it’s different from
    the others. By the end of this section, you’ll have a clear understanding of why
    you would use algorithms from one class over another. By the end of the book,
    you’ll have the skills to apply a number of algorithms from each class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们根据它们的学习方式和它们学习去做的事情来分类算法。但我们为什么要关心这个呢？嗯，我们有**很多**机器学习算法可供选择。我们如何知道该选择哪一个？它们需要什么类型的数据才能正常工作？了解不同算法属于哪些类别可以使我们选择最合适的算法的工作变得简单得多。在下一节中，我将介绍每个类别的定义以及为什么它们与其他类别不同。在本节结束时，你将清楚地了解为什么你会选择一个类别的算法而不是另一个类别的算法。到本书结束时，你将具备应用每个类别中多个算法的技能。
- en: 1.2.1\. Differences between supervised, unsupervised, and semi-supervised learning
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1. 监督、无监督和半监督学习之间的差异
- en: Imagine you are trying to get a toddler to learn about shapes by using blocks
    of wood. In front of them, they have a ball, a cube, and a star. You ask them
    to show you the cube, and if they point to the correct shape, you tell them they
    are correct; if they are incorrect, you also tell them. You repeat this procedure
    until the toddler can identify the correct shape almost all of the time. This
    is called *supervised learning*, because you, the person who already knows which
    shape is which, are supervising the learner by telling them the answers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你试图通过使用木块来让幼儿学习形状。在他们面前，他们有一个球、一个立方体和一个星星。你要求他们给你展示立方体，如果他们指向正确的形状，你就告诉他们他们是对的；如果他们错了，你也告诉他们。你重复这个过程，直到幼儿几乎每次都能正确识别形状。这被称为**监督学习**，因为你知道哪种形状是哪种的人，通过告诉他们答案来监督学习者。
- en: Now imagine a toddler is given multiple balls, cubes, and stars but this time
    is also given three bags. The toddler has to put all the balls in one bag, the
    cubes in another bag, and the stars in another, but you won’t tell them if they’re
    correct—they have to work it out for themselves from nothing but the information
    they have in front of them. This is called *unsupervised learning*, because the
    learner has to identify patterns themselves with no outside help.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一个幼儿被给了多个球、立方体和星星，但这次还给了三个袋子。幼儿必须把所有的球放在一个袋子里，立方体放在另一个袋子里，星星放在另一个袋子里，但你不会告诉他们是否正确——他们必须自己根据面前的信息来解决这个问题。这被称为**无监督学习**，因为学习者必须自己识别模式，没有任何外部帮助。
- en: A machine learning algorithm is said to be *supervised* if it uses a ground
    truth or, in other words, *labeled data*. For example, if we wanted to classify
    a patient biopsy as healthy or cancerous based on its gene expression, we would
    give an algorithm the gene expression data, labeled with whether that tissue was
    healthy or cancerous. The algorithm now knows which cases come from each of the
    two types, and it tries to learn patterns in the data that discriminate them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个机器学习算法使用的是真实数据或换句话说，是**标记数据**，那么它被称为**监督学习**。例如，如果我们想根据基因表达将患者的活检分类为健康或癌症，我们会给算法提供标记的基因表达数据，标明该组织是健康还是癌症。现在算法知道哪些案例来自两种类型中的每一种，并试图学习数据中的模式来区分它们。
- en: Another example would be if we were trying to estimate a person’s monthly credit
    card expenditure. We could give an algorithm information about other people, such
    as their income, family size, whether they own their home, and so on, including
    how much they typically spent on their credit card in a month. The algorithm looks
    for patterns in the data that can predict these values in a reproducible way.
    When we collect data from a new person, the algorithm can estimate how much they
    will spend, based on the patterns it learned.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子可能是如果我们试图估算一个人的月度信用卡支出。我们可以向算法提供有关其他人的信息，例如他们的收入、家庭规模、是否拥有自己的房子等等，包括他们通常一个月在信用卡上花费的金额。算法会寻找数据中的模式，以可重复的方式预测这些值。当我们从新的人那里收集数据时，算法可以根据它学到的模式来估算他们将花费多少。
- en: A machine learning algorithm is said to be *unsupervised* if it does not use
    a ground truth and instead looks on its own for patterns in the data that hint
    at some underlying structure. For example, let’s say we take the gene expression
    data from lots of cancerous biopsies and ask an algorithm to tell us if there
    are clusters of biopsies. A *cluster* is a group of data points that are similar
    to each other but different from data in other clusters. This type of analysis
    can tell us if we have subgroups of cancer types that we may need to treat differently.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个机器学习算法不使用真实数据，而是自己寻找数据中的模式，这些模式暗示着某些潜在的结构，那么它被称为**无监督学习**。例如，假设我们从许多癌症活检中提取基因表达数据，并要求一个算法告诉我们是否有活检的集群。**集群**是一组彼此相似但与其他集群中的数据不同的数据点。这种分析可以告诉我们是否有需要不同方式治疗的癌症亚型。
- en: Alternatively, we may have a dataset with a large number of variables—so many
    that it is difficult to interpret the data and look for relationships manually.
    We can ask an algorithm to look for a way of representing this high-dimensional
    dataset in a lower-dimensional one, while maintaining as much information from
    the original data as possible. Take a look at the summary in [figure 1.5](#ch01fig05).
    If your algorithm uses labeled data (a ground truth), then it is supervised, and
    if it does not use labeled data, then it is unsupervised.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可能有一个包含大量变量的数据集——如此之多以至于难以手动解释数据并寻找关系。我们可以要求一个算法寻找一种方法，在尽可能保持原始数据信息的情况下，将这个高维数据集表示为低维数据集。看看[图1.5](#ch01fig05)的总结。如果你的算法使用标记数据（真实标签），那么它是监督的；如果没有使用标记数据，那么它是无监督的。
- en: Figure 1.5\. Supervised vs. unsupervised machine learning. Supervised algorithms
    take data that is already labeled with a ground truth and build a model that can
    predict the labels of unlabeled, new data. Unsupervised algorithms take unlabeled
    data and learn patterns within it, such that new data can be mapped onto these
    patterns.
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.5. 监督学习与无监督学习。监督算法使用已经标记有真实标签的数据来构建一个可以预测未标记、新数据标签的模型。无监督算法使用未标记的数据，并从中学习模式，使得新数据可以被映射到这些模式上。
- en: '![](fig1-5_alt.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5](fig1-5_alt.jpg)'
- en: '|  |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Semi-supervised learning**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**半监督学习**'
- en: Most machine learning algorithms will fall into one of these categories, but
    there is an additional approach called *semi-supervised* learning. As its name
    suggests, semi-supervised machine learning is not quite supervised and not quite
    unsupervised.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数机器学习算法都将属于这些类别之一，但还有一种称为*半监督学习*的额外方法。正如其名称所暗示的，半监督机器学习既不是完全监督的，也不是完全无监督的。
- en: Semi-supervised learning often describes a machine learning approach that combines
    supervised and unsupervised algorithms together, rather than strictly defining
    a class of algorithms in and of itself. The premise of semi-supervised learning
    is that, often, labeling a dataset requires a large amount of manual work by an
    expert observer. This process may be very time consuming, expensive, and error
    prone, and may be impossible for an entire dataset. So instead, we expertly label
    as many of the cases as is feasibly possible, and then we build a supervised model
    using only the labeled data. We pass the rest of our data (the unlabeled cases)
    into the model to get their predicted labels, called *pseudo-labels* because we
    don’t know if all of them are actually correct. Now we combine the data with the
    manual labels and pseudo-labels, and use the result to train a new model.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 半监督学习通常描述的是一种机器学习方法，它将监督和无监督算法结合起来，而不是严格定义一个算法类别。半监督学习的前提是，通常，标记数据集需要专家观察者进行大量手动工作。这个过程可能非常耗时、昂贵且容易出错，可能对于整个数据集来说都是不可能的。因此，我们尽可能精确地标记尽可能多的案例，然后我们只使用标记的数据来构建一个监督模型。我们将剩余的数据（未标记的案例）输入模型以获取它们的预测标签，这些标签被称为*伪标签*，因为我们不知道它们是否全部正确。现在我们将数据与手动标签和伪标签结合起来，并使用结果来训练一个新的模型。
- en: This approach allows us to train a model that learns from both labeled and unlabeled
    data, and it can improve overall predictive performance because we are able to
    use all of the data at our disposal. If you would like to learn more about semi-supervised
    learning after completing this book, see *Semi-Supervised Learning* by Olivier
    Chapelle, Bernhard Scholkopf, and Alexander Zien (MIT Press, 2006). This reference
    may seem quite old, but it is still very good.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许我们训练一个模型，该模型可以从标记和无标记的数据中学习，并且它可以提高整体预测性能，因为我们能够使用所有可以利用的数据。如果你在完成这本书后想了解更多关于半监督学习的信息，请参阅Olivier
    Chapelle、Bernhard Scholkopf和Alexander Zien合著的《半监督学习》（MIT Press，2006年）。这个参考可能看起来相当过时，但它仍然非常好。
- en: '|  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Within the supervised and unsupervised categories, machine learning algorithms
    can be further categorized by the tasks they perform. Just as a mechanical engineer
    knows which tools to use for the task at hand, so the data scientist needs to
    know which algorithms they should use for their task. There are four main classes
    to choose from: classification, regression, dimension reduction, and clustering.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在监督和无监督类别中，机器学习算法可以根据它们执行的任务进一步分类。正如机械工程师知道如何使用适当的工具来完成手头的任务一样，数据科学家需要知道他们应该使用哪些算法来完成他们的任务。有四个主要类别可供选择：分类、回归、降维和聚类。
- en: 1.2.2\. Classification, regression, dimension reduction, and clustering
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2\. 分类、回归、降维和聚类
- en: 'Supervised machine learning algorithms can be split into two classes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 监督机器学习算法可以分为两类：
- en: '*Classification algorithms* take labeled data (because they are supervised
    learning methods) and learn patterns in the data that can be used to predict a
    *categorical* output variable. This is most often a *grouping variable* (a variable
    specifying which group a particular case belongs to) and can be *binomial* (two
    groups) or *multinomial* (more than two groups). Classification problems are very
    common machine learning tasks. Which customers will default on their payments?
    Which patients will survive? Which objects in a telescope image are stars, planets,
    or galaxies? When faced with problems like these, you should use a classification
    algorithm.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分类算法*接受标记数据（因为它们是监督学习方法），并学习数据中的模式，这些模式可以用来预测一个*分类*的输出变量。这通常是一个*分组变量*（指定特定案例属于哪个组的变量）可以是*二项式*（两组）或*多项式*（多于两组）。分类问题是机器学习任务中非常常见的问题。哪些客户会拖欠付款？哪些患者会存活？望远镜图像中的哪些物体是恒星、行星或星系？面对这些问题时，你应该使用分类算法。'
- en: '*Regression algorithms* take labeled data and learn patterns in the data that
    can be used to predict a *continuous* output variable. How much carbon dioxide
    does a household contribute to the atmosphere? What will the share price of a
    company be tomorrow? What is the concentration of insulin in a patient’s blood?
    When faced with problems like these, you should use a regression algorithm.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*回归算法*接受标记数据，并学习数据中的模式，这些模式可以用来预测一个*连续*的输出变量。一个家庭对大气贡献了多少二氧化碳？一家公司的股价明天会怎样？患者血液中胰岛素的浓度是多少？面对这些问题时，你应该使用回归算法。'
- en: 'Unsupervised machine learning algorithms can also be split into two classes:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 无监督机器学习算法也可以分为两类：
- en: '*Dimension-reduction algorithms* take unlabeled (because they are unsupervised
    learning methods) and high-dimensional data (data with many variables) and learn
    a way of representing it in a lower number of dimensions. Dimension-reduction
    algorithms may be used as an exploratory technique (because it’s very difficult
    for humans to visually interpret data in more than two or three dimensions at
    once) or as a preprocessing step in the machine learning pipeline (it can help
    mitigate problems such as *collinearity* and the *curse of dimensionality*, terms
    I’ll define in later chapters). Dimension-reduction algorithms can also be used
    to help us visually confirm the performance of classification and clustering algorithms
    (by allowing us to plot the data in two or three dimensions).'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*降维算法*接受未标记的（因为它们是无监督学习方法）和高维数据（具有许多变量的数据），并学习一种方法，以更少的维度来表示它。降维算法可以用作探索性技术（因为人类很难同时视觉解释两个或三个以上的维度）或作为机器学习管道中的预处理步骤（它可以帮助缓解诸如*多重共线性*和*维度诅咒*等问题，这些术语我将在后面的章节中定义）。降维算法还可以帮助我们通过允许我们在两个或三个维度中绘制数据来直观地确认分类和聚类算法的性能。'
- en: '*Clustering algorithms* take unlabeled data and learn patterns of clustering
    in the data. A *cluster* is a collection of observations that are more similar
    to each other than to data points in other clusters. We assume that observations
    in the same cluster share some unifying features that make them identifiably different
    from other clusters. Clustering algorithms may be used as an exploratory technique
    to understand the structure of our data and may indicate a grouping structure
    that can be fed into classification algorithms. Are there subtypes of patient
    responders in a clinical trial? How many classes of respondents were there in
    the survey? Do different types of customers use our company? When faced with problems
    like these, you should use a clustering algorithm.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*聚类算法*接受未标记数据，并学习数据中的聚类模式。一个*簇*是一组相互之间比其他簇中的数据点更相似的观察值。我们假设同一簇中的观察值共享一些统一特征，使它们与其他簇可识别地不同。聚类算法可以用作探索性技术来了解我们的数据结构，并可能表明可以输入到分类算法中的分组结构。临床试验中是否存在患者反应的亚型？调查中有多少个受访者类别？不同类型的客户是否使用我们的公司？面对这些问题时，你应该使用聚类算法。'
- en: See [figure 1.6](#ch01fig06) for a summary of the different types of algorithms
    by type and function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 见[图1.6](#ch01fig06)以总结不同类型算法的类型和功能。
- en: 'By separating machine learning algorithms into these four classes, you will
    find it easier to select appropriate ones for the tasks at hand. This is why the
    book is structured the way it is: we first tackle classification, then regression,
    then dimension reduction, and then clustering, so you can build a clear mental
    picture of your toolbox of available algorithms for a particular application.
    Deciding which class of algorithm to choose from is usually straightforward:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将机器学习算法分为这四类，你会发现选择合适的算法来完成手头任务更容易。这就是本书结构安排的原因：我们首先处理分类，然后是回归，接着是降维，最后是聚类，这样你可以清晰地构建起针对特定应用的算法工具箱的清晰心理图像。决定选择哪种算法类别通常很简单：
- en: If you need to predict a categorical variable, use a classification algorithm.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要预测一个分类变量，请使用分类算法。
- en: If you need to predict a continuous variable, use a regression algorithm.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要预测一个连续变量，请使用回归算法。
- en: If you need to represent the information of many variables with fewer variables,
    use dimension reduction.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要用更少的变量来表示许多变量的信息，请使用降维。
- en: If you need to identify clusters of cases, use a clustering algorithm.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要识别案例的簇，请使用聚类算法。
- en: 1.2.3\. A brief word on deep learning
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.3. 简述深度学习
- en: 'If you’ve done more than a little reading about machine learning, you have
    probably come across the term *deep learning*, and you may have even heard the
    term in the media. Deep learning is a subfield of machine learning (all deep learning
    is machine learning, but not all machine learning is deep learning) that has become
    extremely popular in the last 5 to 10 years for two main reasons:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读过关于机器学习的相关内容，你很可能已经遇到过“深度学习”这个术语，甚至可能在媒体上听说过。深度学习是机器学习的一个子领域（所有深度学习都是机器学习，但并非所有机器学习都是深度学习），在过去5到10年中因其两个主要原因而变得极为流行：
- en: It can produce models with outstanding performance.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以产生具有卓越性能的模型。
- en: We now have the computational power to apply it more broadly.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在有了更广泛的计算能力来应用它。
- en: Deep learning uses *neural networks* to learn patterns in data, a term referring
    to the way in which the structure of these models superficially resembles neurons
    in the brain, with connections to pass information between them. The relationship
    between AI, machine learning, and deep learning is summarized in [figure 1.7](#ch01fig07).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习使用**神经网络**来学习数据中的模式，这个术语指的是这些模型的结构在表面上类似于大脑中的神经元，它们之间有连接来传递信息。人工智能、机器学习和深度学习之间的关系总结在[图1.7](#ch01fig07)中。
- en: Figure 1.6\. Classification, regression, dimension reduction, and clustering.
    Classification and regression algorithms build models that predict categorical
    and continuous variables of unlabeled, new data, respectively. Dimension-reduction
    algorithms create a new representation of the original data in fewer dimensions
    and map new data onto this representation. Clustering algorithms identify clusters
    within the data and map new data onto these clusters.
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.6. 分类、回归、降维和聚类。分类和回归算法构建模型来预测未标记的新数据的分类和连续变量。降维算法在更少的维度中创建原始数据的新表示，并将新数据映射到这个表示上。聚类算法在数据中识别簇，并将新数据映射到这些簇上。
- en: '![](fig1-6_alt.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图1-6替代](fig1-6_alt.jpg)'
- en: Figure 1.7\. The relationship between artificial intelligence (AI), machine
    learning, and deep learning. Deep learning comprises a collection of techniques
    that form a subset of machine learning techniques, which themselves are a subfield
    of AI.
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.7. 人工智能（AI）、机器学习与深度学习之间的关系。深度学习包含一系列技术，这些技术构成了机器学习技术的一个子集，而机器学习本身又是人工智能的一个子领域。
- en: '![](fig1-7.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图1-7](fig1-7.jpg)'
- en: 'While it’s true that deep learning methods will typically outperform “shallow”
    learning methods (a term sometimes used to distinguish machine learning methods
    that are not deep learning) for the same dataset, they are not always the best
    choice. Deep learning methods often are not the most appropriate method for a
    given problem for three reasons:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然深度学习方法对于同一数据集通常会比“浅层”学习方法（有时用来区分不是深度学习的机器学习方法）表现更好，但它们并不总是最佳选择。深度学习方法通常不是解决特定问题的最合适方法，原因有三：
- en: '***They are computationally expensive.*** By expensive, we don’t mean monetary
    cost, of course: we mean they require a lot of computing power, which means they
    can take a long time (hours or even days!) to train. Arguably this is a less important
    reason not to use deep learning, because if a task is important enough to you,
    you can invest the time and computational resources required to solve it. But
    if you can train a model in a few minutes that performs well, then why waste additional
    time and resources?'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***它们在计算上非常昂贵。*** 当然，我们这里所说的“昂贵”并不是指货币成本，而是指它们需要大量的计算能力，这意味着它们可能需要很长时间（几个小时甚至几天！）来训练。可以说，这不是不使用深度学习的一个不那么重要的原因，因为如果你认为某个任务很重要，你可以投入所需的时间和计算资源来解决它。但如果你能在几分钟内训练出一个表现良好的模型，那么为什么还要浪费额外的时间和资源呢？'
- en: '***They tend to require more data.*** Deep learning models typically require
    hundreds to thousands of cases in order to perform extremely well. This largely
    depends on the complexity of the problem at hand, but shallow methods tend to
    perform better on small datasets than their deep learning counterparts.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***它们往往需要更多的数据。*** 深度学习模型通常需要数百到数千个案例才能表现出色。这很大程度上取决于手头问题的复杂性，但浅层方法在小数据集上的表现通常优于它们的深度学习对应物。'
- en: '***The rules are less interpretable.*** By their nature, deep learning models
    favor performance over model interpretability. Arguably, our focus should be on
    performance; but often we’re not only interested in getting the right output,
    we’re also interested in the rules the algorithm learned because these help us
    to interpret things about the real world and may help us further our research.
    The rules learned by a neural network are not easy to interpret.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***规则的可解释性较低。*** 从本质上讲，深度学习模型更倾向于性能而非模型的可解释性。可以说，我们的重点应该是性能；但通常我们不仅对获得正确的输出感兴趣，我们还对算法学到的规则感兴趣，因为这些有助于我们理解关于现实世界的事情，并可能帮助我们进一步研究。神经网络学到的规则不易解释。'
- en: So while deep learning methods can be extraordinarily powerful, shallow learning
    techniques are still invaluable tools in the arsenal of data scientists.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然深度学习方法可能非常强大，但浅层学习技术仍然是数据科学家武器库中的无价之宝。
- en: '|  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意事项
- en: Deep learning algorithms are particularly good at tasks involving complex data,
    such as image classification and audio transcription.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习算法特别擅长处理涉及复杂数据的任务，例如图像分类和音频转录。
- en: '|  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: Because deep learning techniques require a lot of additional theory, I believe
    they require their own book, and so we will not discuss them here. If you would
    like to learn how to apply deep learning methods (and, after completing this book,
    I suggest you do), I strongly recommend *Deep Learning with R* by Francois Chollet
    and Joseph J. Allaire (Manning, 2018).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于深度学习技术需要大量的额外理论，我认为它们需要自己的书籍，因此我们在这里不会讨论它们。如果您想了解如何应用深度学习方法（并且完成这本书后，我建议您这样做），我强烈推荐Francois
    Chollet和Joseph J. Allaire合著的《使用R进行深度学习》（Manning, 2018）。
- en: 1.3\. Thinking about the ethical impact of machine learning
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3. 考虑机器学习的伦理影响
- en: Machine learning can be a force for good, whether that’s helping people understand
    nature or assisting organizations to better manage their resources. But machine
    learning also has the potential to do great harm. For example, in 2017, a study
    was published showing that a machine learning model could predict—with startling
    accuracy—a person’s sexual orientation from nothing but an image of their face.^([[1](#ch01fn01)])
    While the authors had no sinister intentions, the study raised concerns about
    the potential misuse of machine learning. Imagine if a country in which it is
    still illegal to be gay (happily, Botswana legalized homosexuality in 2019, so
    this number should now be 71) used a model like this to persecute or even execute
    people?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: ¹
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Yilun Wang and Michal Kosinski, “Deep Neural Networks Are More Accurate than
    Humans at Detecting Sexual Orientation from Facial Images,” 2017, [https://osf.io/zn79k](https://osf.io/zn79k).
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 王一伦和米哈伊尔·科斯金斯基，“从面部图像中检测性取向，深度神经网络比人类更准确，”2017年，[https://osf.io/zn79k](https://osf.io/zn79k).
- en: 'Here’s another example: in 2015, it was discovered that Google’s algorithm
    for image recognition would classify images of people of color as images of gorillas.^([[2](#ch01fn02)])
    The ethical consideration here is that the data the algorithm was trained on was
    biased toward images of white people and did a poor job of making accurate (and
    non-racist) predictions on images of non-white people. To avoid this kind of bias,
    it is imperative that our datasets are adequately representative of the population
    our model will be let loose on. Whether this is done using sensible sampling strategies
    or by testing for and correcting biases after training, it is our responsibility
    to ensure that our models aren’t biased against particular groups of subjects.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子：2015年，发现谷歌的图像识别算法会将有色人种的图像分类为大猩猩。[^[[2](#ch01fn02)]]. 这里的伦理考虑是，该算法训练所使用的数据偏向于白人图像，在非白人图像上做出了不准确（和非种族主义）的预测。为了避免这种偏见，确保我们的数据集充分代表我们的模型将要释放的人群至关重要。无论是通过合理的抽样策略来完成，还是在训练后测试和纠正偏见，我们都有责任确保我们的模型不会对特定群体产生偏见。
- en: ²
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Jessica Guynn, “Google Photos Labeled Black People ‘Gorillas,’” *USA Today*,
    2015, [http://mng.bz/j5Na](http://mng.bz/j5Na).
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Jessica Guynn, “Google Photos Labeled Black People ‘Gorillas,’” *USA Today*,
    2015, [http://mng.bz/j5Na](http://mng.bz/j5Na).
- en: An additional ethical concern with regard to machine learning research is one
    of security and credibility. While it may seem like something taken directly from
    a science fiction film, machine learning research has now reached a point where
    models can create videos of a person speaking, from just an image of their face.
    Researchers have used this so-called *deep fake* technology to produce videos
    of Barack Obama speaking whatever audio they provide.^([[3](#ch01fn03)]) Imagine
    misusing this technology to fabricate evidence of a defendant in a criminal trial
    making a statement they never made. Similar technology has also been used to replace
    one person’s face in a video with another person’s face. Sadly and notoriously,
    this has been misused to swap celebrities’ faces into pornographic videos. Imagine
    the potential of this for ruining a person’s career and dignity.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习研究的一个额外的伦理问题涉及安全和可信度。虽然这听起来像是直接来自科幻电影中的情节，但机器学习研究现在已经达到一个地步，模型可以从一个人的面部图像创建他们说话的视频。研究人员已经使用这种所谓的*深度伪造*技术来制作巴拉克·奥巴马说话的任何他们提供的音频的视频。[^[[3](#ch01fn03)]].
    想象一下，如果滥用这项技术来伪造一个在刑事审判中被告从未说过的话的证据。类似的技术也已被用来在视频中用一个人的脸替换成另一个人的脸。遗憾的是，这被滥用来将名人面孔换成色情视频。想象一下这可能会对一个人的职业生涯和尊严造成多大的破坏。
- en: ³
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³
- en: ''
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Supasorn Suwajanakorn, Steven M. Seitz, and Ira Kemelmacher-Shlizerman, “Synthesizing
    Obama: Learning Lip Sync from Audio,” *ACM Transactions on Graphics* 36 (4), article
    95, 2017, [http://mng.bz/WOQg](http://mng.bz/WOQg).'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Supasorn Suwajanakorn, Steven M. Seitz, and Ira Kemelmacher-Shlizerman, “Synthesizing
    Obama: Learning Lip Sync from Audio,” *ACM Transactions on Graphics* 36 (4), article
    95, 2017, [http://mng.bz/WOQg](http://mng.bz/WOQg).'
- en: The previous point brings me to the issue of data protection and consent. In
    order to train useful machine learning models that perform well, we need data.
    But it’s important to consider whether the data you are using was collected ethically.
    Does it contain personal, sensitive, or financial information? Does the data belong
    to anyone? If so, have they given informed consent as to how it will be used?
    A spotlight was shined on these issues in 2018 when the consultancy firm Cambridge
    Analytica mined the social media data of millions of people without their consent.
    The subsequent media outcry and liquidation of Cambridge Analytica should serve
    as a stark reminder as to the importance of ethical data-collection procedures.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个观点让我想到了数据保护和同意的问题。为了训练表现良好的有用机器学习模型，我们需要数据。但是，考虑你使用的数据是否是按照伦理收集的很重要。它是否包含个人、敏感或财务信息？数据是否属于任何人？如果是的话，他们是否已经就其如何使用提供了知情同意？2018年，咨询公司剑桥分析公司未经同意挖掘了数百万人的社交媒体数据，这些问题受到了关注。随后媒体的强烈抗议和剑桥分析公司的清算应该成为对伦理数据收集程序重要性的一个鲜明提醒。[^[[3](#ch01fn03)]]
- en: 'Two more ethical considerations are these:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个伦理考虑因素是：
- en: When a model suggests a particular course of action, should we follow its prediction
    blindly, or take it under advisement?
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个模型建议采取特定的行动方案时，我们应该盲目地跟随它的预测，还是仅仅作为参考？
- en: Who is culpable when something goes wrong?
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当事情出错时，谁应该承担责任？
- en: 'Imagine that we have a machine learning model that tells us whether to operate
    on a patient based on their diagnostic data. Would you be happy to follow the
    advice of the model if it had been shown to be correct in all previous cases?
    What about a model that predicts whether a defendant is guilty or innocent? You
    could argue that this second example is ridiculous, but it highlights my point:
    should humans be involved in the decision-making processes informed by machine
    learning? If so, *how* should humans be involved in these processes? The answers
    to these questions depend on the decision being made, how it affects the people
    involved, and whether human emotions should be considered in the decision-making
    process.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们有一个机器学习模型，它根据患者的诊断数据告诉我们是否对病人进行手术。如果它在所有之前的案例中都已被证明是正确的，你会愿意遵循模型的建议吗？关于一个预测被告是否有罪或无罪的模型呢？你可以认为第二个例子是荒谬的，但它突出了我的观点：人类应该参与由机器学习信息支持的决策过程吗？如果是这样，*人类应该如何参与这些过程*？这些问题的答案取决于所做出的决策、它对涉及的人的影响，以及是否应该在决策过程中考虑人类情感。
- en: 'The issue of culpability poses this question: when a decision made by a machine
    learning algorithm leads to harm, who is responsible? We live in societies in
    which people are held accountable for their actions. When something bad happens,
    rightly or wrongly, we expect that someone will be found culpable. In 2018, a
    car with self-driving capability collided with and killed a pedestrian.^([[4](#ch01fn04)])
    Who was culpable? The manufacturer? The person in the car? The pedestrian? Does
    it matter if the pedestrian was jaywalking? Ethical quandaries like these need
    to be considered and carefully worked out before such machine learning technologies
    are released into the world.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 责任问题提出了这个问题：当机器学习算法做出的决策导致伤害时，谁应该负责？我们生活在一个要求人们对其行为负责的社会。当发生不好的事情时，无论是对是错，我们都期望有人会被发现负有责任。2018年，一辆具备自动驾驶能力的汽车与一名行人相撞并致其死亡.^([[4](#ch01fn04)])
    谁应该负责？制造商？车上的那个人？行人？如果行人是在闯红灯，这有关系吗？在将这些机器学习技术发布到世界之前，需要考虑并仔细解决这类道德困境。
- en: ⁴
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “Death of Elaine Herzberg,” Wikipedia, [http://mng.bz/8zqK](http://mng.bz/8zqK).
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “Elaine Herzberg之死”，维基百科，[http://mng.bz/8zqK](http://mng.bz/8zqK)。
- en: 'When you train a machine learning model, I request that you ask yourself these
    five questions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你训练一个机器学习模型时，我要求你问自己这五个问题：
- en: Are my intentions ethical?
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的意图是否道德？
- en: Even if my intentions are ethical, could someone else do harm with my model?
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使我的意图是道德的，其他人是否可能用我的模型造成伤害？
- en: Is my model biased in a way that can cause harm or discriminate?
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的模型是否存在可能导致伤害或歧视的偏见？
- en: Has the data been collected ethically?
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据是否被道德地收集？
- en: Once deployed, how will humans fit into the decisions made by the model?
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦部署，人类将如何适应模型所做的决策？
- en: If the answer to any of them makes you feel uneasy, please carefully consider
    if what you’re doing is ethical. Just because we *can* do something, doesn’t mean
    we *should*. If you would like to explore a deeper discussion of how to perform
    ethical machine learning, I suggest *Towards a Code of Ethics for Artificial Intelligence*
    by Paula Boddington (Springer, 2017).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对任何问题的回答让你感到不安，请仔细考虑你所做的事情是否道德。仅仅因为我们*能够*做某事，并不意味着我们*应该*这样做。如果你想深入了解如何进行道德机器学习，我建议阅读Paula
    Boddington的《迈向人工智能道德规范》（Springer，2017年）。
- en: 1.4\. Why use R for machine learning?
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4. 为什么使用 R 进行机器学习？
- en: 'There is something of a rivalry between the two most commonly used data science
    languages: R and Python. Anyone who is new to machine learning will choose one
    or the other to get started, and their decision will often be guided by the learning
    resources they have access to, which one is more commonly used in their field
    of work, and which one their colleagues use. There are no machine learning tasks
    that are only possible to apply in one language or the other, although some of
    the more cutting-edge deep learning approaches are easier to apply in Python (they
    tend to be written in Python first and implemented in R later). Python, while
    very good for data science, is a more general-purpose programming language, whereas
    R is geared specifically for mathematical and statistical applications. This means
    users of R can focus purely on data but may feel restricted if they ever need
    to build applications based on their models.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种最常用的数据科学语言之间，R和Python，存在某种竞争关系。任何刚开始学习机器学习的人都会选择其中之一来入门，他们的选择通常会受到他们可访问的学习资源、他们所在领域的工作中哪种语言更常见以及他们的同事使用哪种语言的影响。没有只能在一种语言中应用的机器学习任务，尽管一些更前沿的深度学习方法在Python中应用起来更容易（它们通常首先用Python编写，然后才在R中实现）。Python虽然非常适合数据科学，但它是一种更通用的编程语言，而R则专门针对数学和统计应用。这意味着R的用户可以纯粹关注数据，但如果他们需要基于他们的模型构建应用程序，可能会感到受限。
- en: There really isn’t an overall winner when pitching these two against each other
    for data science (although of course everyone has their favorite). So why have
    I chosen to write a book about machine learning in R? Because there are modern
    tools in R designed specifically to make data science tasks simple and human-readable,
    such as those from the *tidyverse* (we’ll cover these tools in depth in [chapter
    2](kindle_split_011.html#ch02)).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当将这两个语言对比用于数据科学时，实际上并没有一个绝对的优势（尽管当然每个人都有他们偏爱的语言）。那么我为什么选择写一本关于R中机器学习的书呢？因为R中有专门设计来简化数据科学任务并使其易于人类阅读的现代工具，例如来自*tidyverse*的工具（我们将在第2章中深入探讨这些工具）。
- en: Traditionally, machine learning algorithms in R were scattered across multiple
    packages written by different authors. This meant you would need to learn to use
    new functions with different arguments and implementations each time you wanted
    to apply a new algorithm. Proponents of Python could use this as an example of
    why it was better suited for machine learning, because Python has the well-known
    scikit-learn package that has a plethora of built-in machine learning algorithms.
    But R has now followed suit, with the caret and mlr packages. While mlr is quite
    similar to caret in purpose and functionality, I believe mlr is more flexible
    and intuitive; so, we’ll be using mlr in the book.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，R中的机器学习算法分散在由不同作者编写的多个包中。这意味着每次你想应用一个新的算法时，都需要学习使用具有不同参数和实现的新的函数。Python的支持者可能会用这个例子来说明为什么Python更适合机器学习，因为Python有一个著名的scikit-learn包，它包含大量的内置机器学习算法。但R现在也效仿了这一做法，有了caret和mlr包。虽然mlr在目的和功能上与caret相当相似，但我认为mlr更加灵活和直观；因此，我们在书中将使用mlr。
- en: The mlr package (which stands for *machine learning in R*) provides an interface
    for a large number of machine learning algorithms and allows you to perform extremely
    complicated machine learning tasks with very little coding. Where possible, we
    will use the mlr package throughout this book so that when you’re finished, you’ll
    be proficient at using one of the most modern machine learning packages available.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: mlr包（代表*R中的机器学习*）为大量机器学习算法提供了一个接口，并允许你用非常少的代码执行极其复杂的机器学习任务。在可能的情况下，我们将在这本书中始终使用mlr包，这样当你完成学习后，你将能够熟练使用目前最现代的机器学习包之一。
- en: 1.5\. Which datasets will we use?
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5. 我们将使用哪些数据集？
- en: To make your learning process as fun and interesting as possible, we will use
    real datasets in our machine learning pipelines. R comes with a considerable number
    of built-in datasets, which are supplemented by datasets that come with packages
    we’ll be loading into our R sessions. I decided to use datasets that come with
    R or its packages, to make it easier for you to work through the book while offline.
    We’ll use these datasets to help us build our machine learning models and compare
    how different models perform on different types of data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的学习过程尽可能有趣和吸引人，我们将在我们的机器学习管道中使用真实数据集。R语言自带相当数量的内置数据集，这些数据集通过我们将加载到R会话中的包中的数据集得到补充。我决定使用R或其包中自带的数据集，以便你在离线状态下更容易地完成本书。我们将使用这些数据集来帮助我们构建机器学习模型，并比较不同模型在不同类型数据上的表现。
- en: '|  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: With so many datasets to choose from, after completing each chapter, I suggest
    you apply what you’ve learned to a different dataset.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这么多数据集中选择，完成每一章后，我建议你将所学应用到不同的数据集上。
- en: '|  |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 1.6\. What will you learn in this book?
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6. 在这本书中你将学到什么？
- en: 'This book gives you a hands-on introduction to machine learning with R. To
    benefit from the book, you should be comfortable with basic R coding, such as
    loading packages and working with objects and data structures. You will learn
    the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书通过R语言为你提供了一个动手学习的机器学习入门。为了从本书中受益，你应该熟悉基本的R语言编码，例如加载包和操作对象和数据结构。你将学习以下内容：
- en: How to organize, tidy, and plot your data using the tidyverse
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用tidyverse组织、整理和绘制你的数据
- en: Critical concepts such as overfitting, underfitting, and bias-variance trade-off
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如过拟合、欠拟合和偏差-方差权衡等关键概念
- en: How to apply several machine learning algorithms from each of the four classes
    (classification, regression, dimension reduction, and clustering)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何应用来自四个类别（分类、回归、降维和聚类）中的几个机器学习算法
- en: How to validate model performance and prevent overfitting
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何验证模型性能并防止过拟合
- en: How to compare multiple models to decide on the best one for your purpose
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何比较多个模型以决定最适合你目的的最佳模型
- en: Throughout the book, we’ll use interesting examples to learn concepts and apply
    our knowledge. When possible, we will also apply multiple algorithms to the same
    dataset so you get a feel for how different algorithms perform under certain situations.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将使用有趣的例子来学习概念并应用我们的知识。在可能的情况下，我们还将将多个算法应用于同一数据集，以便你了解不同算法在特定情况下的表现。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Artificial intelligence is the appearance of intelligent knowledge by a computer
    process.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人工智能是计算机过程产生智能知识的表现。
- en: Machine learning is a subfield of artificial intelligence, where the computer
    learns relationships in data to make predictions about future, unseen data or
    to identify meaningful patterns that help us understand our data better.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习是人工智能的一个子领域，其中计算机通过学习数据中的关系来对未来的、未见过的数据进行预测，或者识别有助于我们更好地理解数据的有意义模式。
- en: A machine learning algorithm is the process by which patterns and rules in the
    data are learned. A model is a collection of those patterns and rules that accepts
    new data, applies the rules to it, and outputs an answer.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习算法是通过学习数据中的模式和规则的过程。模型是一组这些模式和规则，它接受新的数据，将这些规则应用于数据，并输出答案。
- en: Deep learning is a subfield of machine learning, which is, itself, a subfield
    of AI.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度学习是机器学习的一个子领域，而机器学习本身又是人工智能的一个子领域。
- en: Machine learning algorithms are categorized/divided as supervised and unsupervised,
    depending on whether they learn from ground-truth-labeled data (supervised learning)
    or unlabeled data (unsupervised learning).
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据它们是否从真实标签数据（监督学习）或无标签数据（无监督学习）中学习，机器学习算法被分为监督学习和无监督学习。
- en: Supervised learning algorithms are categorized/divided as classification (if
    they predict a categorical variable) or regression (if they predict a continuous
    variable).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监督学习算法被分为分类（如果它们预测一个分类变量）或回归（如果它们预测一个连续变量）。
- en: Unsupervised learning algorithms are categorized/divided as dimension reduction
    (if they find a lower-dimension representation of the data) or clustering (if
    they identify clusters of cases in the data).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无监督学习算法被分为降维（如果它们找到数据的低维表示）或聚类（如果它们在数据中识别案例簇）。
- en: Along with Python, R is a popular data science language and contains many tools
    and built-in datasets that simplify the process of data science and machine learning.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了 Python 之外，R 也是一种流行的数据科学语言，它包含许多工具和内置数据集，这些工具和数据集简化了数据科学和机器学习的过程。
- en: Chapter 2\. Tidying, manipulating, and plotting data with the tidyverse
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章\. 使用 tidyverse 整理、操作和绘制数据
- en: '*This chapter covers*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding the tidyverse
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 tidyverse
- en: What is meant by *tidy* data
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是“tidy”数据
- en: Installing and loading the tidyverse
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和加载 tidyverse
- en: Using the tibble, dplyr, ggplot2, tidyr, and purrr packages
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 tibble、dplyr、ggplot2、tidyr 和 purrr 包
- en: I’m really excited to start teaching machine learning to you. But before we
    dive into that, I want to teach you some skills that are going to make your learning
    experience simpler and more effective. These skills will also improve your general
    data science and R programming skills.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常兴奋地开始教你机器学习。但在我们深入探讨之前，我想教你一些技能，这些技能将使你的学习体验更加简单和有效。这些技能还将提高你的数据科学和 R 编程技能。
- en: 'Imagine that I asked you to build me a car (a typical request between friends).
    You could go old-fashioned: you could purchase the metal, glass, and other components;
    hand-cut all the pieces; hammer them into shape; and rivet them together. The
    car might look beautiful and work perfectly, but it would take a very long time
    to build, and it would be hard for you to remember exactly what you did if you
    had to make another one.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我要求你为我造一辆车（朋友之间常见的请求）。你可以选择老式方法：你可以购买金属、玻璃和其他组件；手工切割所有零件；用锤子将其塑形；并用铆钉将其固定在一起。这辆车可能看起来很漂亮，工作得也很完美，但建造它需要非常长的时间，而且如果你需要再造一辆，你可能很难确切地记住你做了什么。
- en: Instead, you could take a modern approach and use robotic arms in your factory.
    You could program them to cut and bend the pieces into predefined shapes and assemble
    the pieces for you. In this scenario, building a car would be much faster and
    simpler for you, and it would be easy for you to reproduce the same process in
    the future.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以采取一种现代方法，在工厂中使用机械臂。你可以编程它们来切割和弯曲零件成预定义的形状，并为你组装零件。在这种情况下，对你来说，制造一辆汽车会更快、更简单，而且你很容易在未来重复同样的过程。
- en: Now imagine that I make a more reasonable request and ask you to reorganize
    and plot a dataset, ready to be passed through a machine learning pipeline. You
    could use base R functions for this, and they would work fine. But the code would
    be long, it wouldn’t be very human-readable (so in a month you’d struggle to remember
    what you did), and the plots would be cumbersome to produce.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我提出一个更合理的要求，让你重新组织和绘制一个数据集，以便通过机器学习流程。你可以使用基本的 R 函数来完成这个任务，它们会运行得很好。但是代码会很长，可读性不会很高（所以一个月后你可能会很难记住你做了什么），而且生成图表会相当繁琐。
- en: Instead, you could take a more modern approach and use functions from the *tidyverse*
    family of packages. These functions help simplify the data-manipulation process,
    are very human-readable, and allow you to produce very attractive graphics with
    minimal typing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以采取更现代的方法，并使用来自 *tidyverse* 包族的功能。这些功能有助于简化数据处理过程，可读性很高，并且允许你通过最少的输入生成非常吸引人的图形。
- en: 2.1\. What is the tidyverse, and what is tidy data?
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. tidyverse 是什么，tidy 数据是什么？
- en: The purpose of this book is to give you the skills to apply machine learning
    approaches to your data. While it isn’t my intention to cover all other aspects
    of data science (nor could I, in a single book), I do want to introduce you to
    the tidyverse. Before you can input your data into a machine learning algorithm,
    it needs to be in a format that the algorithm is happy to work with.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目的是给你提供将机器学习方法应用于你的数据的技能。虽然我的意图不是涵盖数据科学的各个方面（在一个单本书中我也无法做到），但我确实想介绍你认识 tidyverse。在你将数据输入到机器学习算法之前，它需要以算法愿意处理的形式存在。
- en: The tidyverse is an “opinionated collection of R packages designed for data
    science,” created for the purpose of making data science tasks in R simpler, more
    human-readable, and more reproducible. The packages are “opinionated” because
    they are designed to make tasks the package authors consider to be good practice,
    easy, and make tasks they consider to be bad practice, difficult. The name comes
    from the concept of *tidy data*, a data structure in which
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: tidyverse 是一个“有偏见的 R 包集合，专为数据科学设计”，旨在使 R 中的数据科学任务更简单、更易于阅读和复现。这些包之所以“有偏见”，是因为它们旨在使包作者认为的良好实践变得容易，而使他们认为的不良实践变得困难。这个名字来源于
    *tidy data* 的概念，这是一种数据结构，其中
- en: Each row represents a single observation.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一行代表一个单独的观察。
- en: Each column represents a variable.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一列代表一个变量。
- en: Take a look at the data in [table 2.1](#ch02table01). Imagine that we take four
    runners and put them on a new training regime. We want to know if the regime is
    improving their running times, so we record their best times just before the new
    training starts (month 0), and for three months thereafter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 看看 [表 2.1](#ch02table01) 中的数据。想象一下，我们取四位跑者并将他们置于新的训练计划中。我们想知道这个计划是否在提高他们的跑步时间，因此我们记录了他们在新训练开始前（月份
    0）以及之后的三个月的最佳时间。
- en: Table 2.1\. An example of untidy data. This table contains the running times
    for four runners, taken immediately before starting a new training regime and
    then for three months thereafter.
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 2.1\. 不整洁数据的示例。此表包含四位跑者在开始新的训练计划之前以及之后的三个月的跑步时间。
- en: '| Athlete | Month 0 | Month 1 | Month 2 | Month 3 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 运动员 | 月份 0 | 月份 1 | 月份 2 | 月份 3 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Joana | 12.50 | 12.1 | 11.98 | 11.99 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| Joana | 12.50 | 12.1 | 11.98 | 11.99 |'
- en: '| Debi | 14.86 | 14.9 | 14.70 | 14.30 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| Debi | 14.86 | 14.9 | 14.70 | 14.30 |'
- en: '| Sukhveer | 12.10 | 12.1 | 12.00 | 11.80 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| Sukhveer | 12.10 | 12.1 | 12.00 | 11.80 |'
- en: '| Kerol | 19.60 | 19.7 | 19.30 | 19.00 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| Kerol | 19.60 | 19.7 | 19.30 | 19.00 |'
- en: 'This is an example of *untidy* data. Can you see why? Well, let’s go back to
    our rules. Does each row represent a single observation? Nope. In fact, we have
    four observations per row (one for each month). Does each column represent a variable?
    Nope. There are only three variables in this data: the athlete, the month, and
    the best time, and yet we have five columns!'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不整洁数据的示例。你能看出为什么吗？好吧，让我们回到我们的规则。每一行代表一个单独的观察吗？不。实际上，每一行有四个观察（每个月份一个）。每一列代表一个变量吗？不。此数据中只有三个变量：运动员、月份和最佳时间，但我们有五个列！
- en: How would the same data look in tidy format? [Table 2.2](#ch02table02) shows
    you.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的数据在整洁格式下看起来会怎样？[表 2.2](#ch02table02) 展示了这一点。
- en: Table 2.2\. This table contains the same data as [table 2.1](#ch02table01),
    but in tidy format.
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 2.2\. 此表包含与 [表 2.1](#ch02table01) 相同的数据，但以整洁格式呈现。
- en: '| Athlete | Month | Best |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 运动员 | 月份 | 最佳 |'
- en: '| --- | --- | --- |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Joana | 0 | 12.50 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| Joana | 0 | 12.50 |'
- en: '| Debi | 0 | 14.86 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| Debi | 0 | 14.86 |'
- en: '| Sukhveer | 0 | 12.10 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| Sukhveer | 0 | 12.10 |'
- en: '| Kerol | 0 | 19.60 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| Kerol | 0 | 19.60 |'
- en: '| Joana | 1 | 12.10 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| Joana | 1 | 12.10 |'
- en: '| Debi | 1 | 14.90 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| Debi | 1 | 14.90 |'
- en: '| Sukhveer | 1 | 12.10 |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| Sukhveer | 1 | 12.10 |'
- en: '| Kerol | 1 | 19.70 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| Kerol | 1 | 19.70 |'
- en: '| Joana | 2 | 11.98 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| Joana | 2 | 11.98 |'
- en: '| Debi | 2 | 14.70 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| Debi | 2 | 14.70 |'
- en: '| Sukhveer | 2 | 12.00 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| Sukhveer | 2 | 12.00 |'
- en: '| Kerol | 2 | 19.30 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| Kerol | 2 | 19.30 |'
- en: '| Joana | 3 | 11.99 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| Joana | 3 | 11.99 |'
- en: '| Debi | 3 | 14.30 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| Debi | 3 | 14.30 |'
- en: '| Sukhveer | 3 | 11.80 |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| Sukhveer | 3 | 11.80 |'
- en: '| Kerol | 3 | 19.00 |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| Kerol | 3 | 19.00 |'
- en: This time, we have the column Month that contains the month identifiers that
    were previously used as separate columns, and the Best column, which holds the
    best time for each athlete for each month. Does each row represent a single observation?
    Yes! Does each column represent a variable? Yes! So this data is in tidy format.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们有了包含之前作为单独列使用的月份标识符的“月份”列，以及包含每个运动员每月最佳时间的“最佳”列。每一行代表一个单独的观察吗？是的！每一列代表一个变量吗？是的！因此，这些数据是整洁格式。
- en: 'Ensuring that your data is in tidy format is an important early step in any
    machine learning pipeline, and so the tidyverse includes the package tidyr, which
    helps you achieve this. The other packages in the tidyverse work with tidyr and
    each other to help you do the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的数据是整洁格式是任何机器学习流程中的早期重要步骤，因此 tidyverse 包含 tidyr 包，它可以帮助你实现这一点。tidyverse 中的其他包与
    tidyr 和彼此一起工作，帮助你完成以下任务：
- en: Organize and display your data in a sensible way (tibble)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以合理的方式组织和显示你的数据（tibble）
- en: Manipulate and subset your data (dplyr)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作和子集你的数据（dplyr）
- en: Plot your data (ggplot2)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制你的数据（ggplot2）
- en: Replace `for` loops with a functional programming approach (purrr)
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `for` 循环替换为函数式编程方法（purrr）
- en: 'All of the operations available to you in the tidyverse are achievable using
    base R code, but I strongly suggest that you incorporate the tidyverse in your
    work: it will help you keep your code simpler, more human-readable, and reproducible.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在 tidyverse 中你可以执行的所有操作都可以使用 base R 代码实现，但我强烈建议你在工作中使用 tidyverse：它将帮助你使代码更简单、更易于阅读，并且可重复。
- en: '|  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Core and optional packages of the tidyverse**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**tidyverse 的核心和可选包**'
- en: 'I’m going to teach you to use the tibble, dplyr, ggplot2, tidyr, and purrr
    packages of the tidyverse. These are part of the “core” tidyverse packages, along
    with these:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我将教你如何使用 tidyverse 的 tibble、dplyr、ggplot2、tidyr 和 purrr 包。这些是 tidyverse 的“核心”包，还包括以下这些：
- en: readr, for reading data into R from external files
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: readr，用于将外部文件中的数据读入 R
- en: forcats, for working with factors
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: forcats，用于处理因子
- en: stringr, for working with strings
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stringr，用于处理字符串
- en: In addition to these core packages that can be loaded together, the tidyverse
    includes a number of optional packages that need to be loaded individually.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以一起加载的核心包之外，tidyverse 还包括一些需要单独加载的可选包。
- en: To learn more about the other tools of the tidyverse, see *R for Data Science*
    by Garrett Grolemund and Hadley Wickham (O’Reilly Media, 2016).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于 tidyverse 其他工具的信息，请参阅 Garrett Grolemund 和 Hadley Wickham 所著的《R for Data
    Science》（O’Reilly 媒体，2016年）。
- en: '|  |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.2\. Loading the tidyverse
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. 加载 tidyverse
- en: The packages of the tidyverse can all be installed and loaded together (recommended)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: tidyverse 的包都可以一起安装和加载（推荐）
- en: '[PRE2]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'or installed and loaded individually as needed:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 或根据需要安装和单独加载：
- en: '[PRE3]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 2.3\. What the tibble package is and what it does
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3\. tibble 包是什么以及它的作用
- en: If you have been doing any form of data science or analysis in R, you will surely
    have come across data frames as a structure for storing rectangular data. Data
    frames work fine and, for a long time, were the only way to store rectangular
    data with columns of different types (in contrast to matrices, which can only
    handle data of the same type), but very little has been done to improve the aspects
    of data frames that data scientists dislike.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾在 R 中进行过任何形式的数据科学或分析，你肯定遇到过数据框作为存储矩形数据的结构。数据框工作得很好，并且长期以来一直是存储具有不同类型列的矩形数据的唯一方式（与只能处理相同类型数据的矩阵相比），但很少对数据科学家不喜欢的数据框方面进行改进。
- en: '|  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Data is *rectangular* if each row has a number of elements equal to the number
    of columns, and each column has a number of elements equal to the number of rows.
    Data isn’t always of this kind!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每一行都有与列数相等的元素数量，并且每一列都有与行数相等的元素数量，则数据是*矩形的*。数据并不总是这种类型！
- en: '|  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The tibble package introduces a new data structure, the tibble, to “keep the
    features that have stood the test of time, and drop the features that used to
    be convenient but are now frustrating” ([http://mng.bz/1wxj](http://mng.bz/1wxj)).
    Let’s see what’s meant by this.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: tibble 包引入了一种新的数据结构，即 tibble，目的是“保留那些经得起时间考验的特性，并丢弃那些曾经方便但现在令人沮丧的特性”([http://mng.bz/1wxj](http://mng.bz/1wxj))。让我们看看这是什么意思。
- en: 2.3.1\. Creating tibbles
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1\. 创建 tibbles
- en: 'Creating tibbles with the `tibble()` function works the same as creating data
    frames:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `tibble()` 函数创建 tibbles 与创建数据框的工作方式相同：
- en: '[PRE4]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Tells us it’s a tibble with four rows and two columns**'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 告诉我们这是一个有四行两列的 tibble**'
- en: '***2* Variable names**'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 变量名**'
- en: '***3* Variable classes: <int> = integer, <chr> = character**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 变量类型：<int> = 整数，<chr> = 字符**'
- en: 'If you’re used to working with data frames, you will immediately notice two
    differences in how tibbles are printed:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于使用数据框，你将立即注意到 tibbles 打印时的两个不同之处：
- en: When you print a tibble, it tells you that it’s a tibble and its dimensions.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你打印一个 tibble 时，它会告诉你它是一个 tibble 以及其维度。
- en: Tibbles tell you the type of each variable.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tibbles 会告诉你每个变量的类型。
- en: This second feature is particularly useful in avoiding errors due to incorrect
    variable types.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个特性特别有用，可以避免因变量类型不正确而导致的错误。
- en: '|  |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: When printing a tibble, `<int>` denotes an integer variable, `<chr>` denotes
    a character variable, `<dbl>` denotes a floating-point number (decimal), and `<lgl>`
    denotes a logical variable.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印一个 tibble 时，`<int>` 表示整数变量，`<chr>` 表示字符变量，`<dbl>` 表示浮点数（小数），`<lgl>` 表示逻辑变量。
- en: '|  |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.3.2\. Converting existing data frames into tibbles
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.2\. 将现有数据框转换为 tibbles
- en: 'Just as you can coerce objects into data frames using the `as.data.frame()`
    function, you can coerce objects into tibbles using the `as_tibble()` function:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以使用`as.data.frame()`函数将对象强制转换为数据框一样，你也可以使用`as_tibble()`函数将对象强制转换为tibbles：
- en: '[PRE5]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|  |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, we’ll be working with data already built into R. Often, we need
    to read data into our R session from a .csv file. To load the data as a tibble,
    you use the `read_csv()` function. `read_csv()` comes from the readr package,
    which is loaded when you call `library(tidyverse)`, and is the tidyverse version
    of `read.csv()`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用R中已经构建好的数据。通常，我们需要从.csv文件中读取数据到R会话中。要作为tibble加载数据，你使用`read_csv()`函数。`read_csv()`来自readr包，当调用`library(tidyverse)`时加载，是tidyverse版本的`read.csv()`。
- en: '|  |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.3.3\. Differences between data frames and tibbles
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3\. 数据框和tibbles之间的区别
- en: If you’re used to working with data frames, you’ll notice a few differences
    with tibbles. I’ve summarized the most notable differences between data frames
    and tibbles in this section.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于使用数据框，你将注意到与tibbles有一些不同。我在本节中总结了数据框和tibbles之间最显著的区别。
- en: Tibbles don’t convert your data types
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Tibbles不会转换你的数据类型
- en: A common frustration people have when creating data frames is that they convert
    string variables to factors by default. This can be annoying because it may not
    be the best way to handle the variables. To prevent this conversion, you must
    supply the `stringsAsFactors = FALSE` argument when creating a data frame.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们创建数据框时，常见的烦恼是他们默认将字符串变量转换为因子。这可能很烦人，因为这可能不是处理变量的最佳方式。为了防止这种转换，在创建数据框时必须提供`stringsAsFactors
    = FALSE`参数。
- en: 'In contrast, tibbles don’t convert string variables to factors by default.
    This behavior is desirable because automatic conversion of data to certain types
    can be a frustrating source of bugs:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，tibbles 默认不会将字符串变量转换为因子。这种行为是可取的，因为自动将数据转换为特定类型可能会成为令人沮丧的bug来源：
- en: '[PRE6]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you want a variable to be a factor in a tibble, you simply wrap the `c()`
    function inside `factor()`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望一个变量在tibble中是因子类型，你只需将`c()`函数包裹在`factor()`函数内部即可：
- en: '[PRE7]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Concise output, regardless of data size
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 简洁的输出，无论数据大小
- en: When you print a data frame, all the columns are printed to the console (by
    default), making it difficult to view early variables and cases. When you print
    a tibble, it only prints the first 10 rows and the number of columns that fit
    on your screen (by default), making it easier to get a quick understanding of
    the data. Note that the names of variables that aren’t printed are listed at the
    bottom of the output. Run the following code, and contrast the output of the `starwars`
    tibble (which is included with dplyr and available when you call `library(tidyverse)`)
    with how it looks when converted into a data frame.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印数据框时，所有列都会打印到控制台（默认情况下），这使得查看早期变量和案例变得困难。当你打印tibble时，它只打印默认情况下适合屏幕的前10行和列数，这使得快速了解数据变得更容易。注意，未打印的变量名称列在输出底部列出。运行以下代码，对比`starwars`
    tibble（包含在dplyr中，当调用`library(tidyverse)`时可用）的输出与转换为数据框时的外观。
- en: Listing 2.1\. The `starwars` data as a tibble and a data frame
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.1\. `starwars`数据作为tibble和数据框
- en: '[PRE8]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|  |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `data()` function loads into your global environment a dataset that is included
    with base R or an R package. Use `data()` with no arguments to list all the datasets
    available for your currently loaded packages.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`data()`函数将包含在R基础包或R包中的数据集加载到你的全局环境中。使用不带参数的`data()`来列出当前加载的包中可用的所有数据集。'
- en: '|  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Subsetting with [ always returns another tibble
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用`[`进行子集操作始终返回另一个tibble
- en: 'When subsetting a data frame, the `[` operator will return another data frame
    if you keep more than one column, or a vector if you keep only one. When subsetting
    a tibble, the `[` operator will *always* return another tibble. If you wish to
    explicitly return a tibble column as a vector, use either the `[[` or `$` operator
    instead. This behavior is desirable because we should be explicit in whether we
    want a vector or rectangular data structure, to avoid bugs:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当对数据框进行子集操作时，如果你保留多于一个列，`[`运算符将返回另一个数据框；如果你只保留一个列，则返回一个向量。当对tibble进行子集操作时，`[`运算符将*始终*返回另一个tibble。如果你希望显式地将tibble列作为向量返回，可以使用`[[`或`$`运算符。这种行为是可取的，因为我们应该明确我们想要向量还是矩形数据结构，以避免bug：
- en: '[PRE9]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|  |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: An exception to this is if you subset a data frame using a single index with
    no comma (such as `myDf[1]`). In this case, the `[` operator *will* return a single-column
    data frame, but this method doesn’t allow us to combine row and column subsetting.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个例外是，如果你使用单个索引（没有逗号，例如 `myDf[1]`）对数据框进行子集化。在这种情况下，`[` 操作符将返回一个单列数据框，但这种方法不允许我们结合行和列的子集化。
- en: '|  |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Variables are created sequentially
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 变量是按顺序创建的
- en: 'When building a tibble, variables are created sequentially so that later variables
    can reference those defined earlier. This means we can create variables on the
    fly that refer to other variables in the same function call:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建 tibble 时，变量是按顺序创建的，以便后续变量可以引用之前定义的变量。这意味着我们可以在同一函数调用中动态创建引用其他变量的变量：
- en: '[PRE10]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|  |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Exercise 1**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 1**'
- en: Load the `mtcars` dataset using the `data()` function, convert it into a tibble,
    and explore it using the `summary()` function.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `data()` 函数加载 `mtcars` 数据集，将其转换为 tibble，并使用 `summary()` 函数进行探索。
- en: '|  |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.4\. What the dplyr package is and what it does
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4\. dplyr 包是什么以及它做什么
- en: 'When working with data, we often need to perform operations on it such as the
    following-:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '在处理数据时，我们经常需要执行以下操作-:'
- en: Selecting only the rows and/or columns of interest
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择感兴趣的行和/或列
- en: Creating new variables
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新变量
- en: Arranging the data in ascending or descending order of certain variables
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按某些变量的升序或降序排列数据
- en: Getting summary statistics
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取汇总统计量
- en: There may also be a natural grouping structure in the data that we would like
    to maintain when performing these operations. The dplyr package allows us to perform
    these operations in a very intuitive way. Let’s work through an example.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行这些操作时，数据中可能也存在我们希望保持的自然分组结构。dplyr 包允许我们以非常直观的方式执行这些操作。让我们通过一个例子来操作。
- en: 2.4.1\. Manipulating the CO2 dataset with dplyr
  id: totrans-305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.1\. 使用 dplyr 操作 CO2 数据集
- en: Let’s load the built-in CO2 dataset in R. We have a tibble with 84 cases and
    5 variables, documenting the uptake of carbon dioxide by different plants under
    various conditions. I’m going to use this dataset to teach you some fundamental
    dplyr skills.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 R 中加载内置的 CO2 数据集。我们有一个包含 84 个案例和 5 个变量的 tibble，记录了在不同条件下不同植物对二氧化碳的吸收情况。我将使用这个数据集来教你们一些基本的
    dplyr 技能。
- en: Listing 2.2\. Exploring the CO2 dataset
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2\. 探索 CO2 数据集
- en: '[PRE11]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let’s say we want to *select* only columns 1, 2, 3, and 5\. We can do this using
    the `select()` function. In the `select()` function call in the following listing,
    the first argument is the data; then we supply either the numbers or names of
    the columns we wish to select, separated by commas.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只想 *选择* 第 1、2、3 和 5 列。我们可以使用 `select()` 函数来完成这个操作。在以下列表中的 `select()` 函数调用中，第一个参数是数据；然后我们提供我们希望选择的列的数字或名称，用逗号分隔。
- en: Listing 2.3\. Selecting columns using `select()`
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.3\. 使用 `select()` 选择列
- en: '[PRE12]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|  |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Exercise 2**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 2**'
- en: Select all of the columns of your `mtcars` tibble except the `qsec` and `vs`
    variables.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你的 `mtcars` tibble 的所有列，除了 `qsec` 和 `vs` 变量。
- en: '|  |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now let’s suppose we wish to *filter* our data to include only cases whose uptake
    was greater than 16\. We can do this using the `filter()` function. The first
    argument of `filter()` is, once again, the data, and the second argument is a
    logical expression that will be evaluated for each row. We can include multiple
    conditions here by separating them with commas.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们希望 *过滤* 数据，只包含吸收量大于 16 的案例。我们可以使用 `filter()` 函数来完成这个操作。`filter()` 的第一个参数再次是数据，第二个参数是一个逻辑表达式，它将对每一行进行评估。我们可以通过逗号分隔来包含多个条件。
- en: Listing 2.4\. Filtering rows using `filter()`
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.4\. 使用 `filter()` 过滤行
- en: '[PRE13]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|  |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Exercise 3**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 3**'
- en: Filter your `mtcars` tibble to include only cases with a number of cylinders
    (`cyl`) *not* equal to 8.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤你的 `mtcars` tibble，只包含气缸数（`cyl`）不等于 8 的案例。
- en: '|  |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Next, we would like to *group* by individual plants and *summarize* the data
    to get the mean and standard deviation of uptake within each group. We can achieve
    this using the `group_by()` and `summarize()` functions, respectively.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望按单个植物 *分组* 并使用 `group_by()` 和 `summarize()` 函数分别对数据进行汇总，以获取每个组内吸收量的平均值和标准差。
- en: In the `group_by()` function, the first argument is—you guessed it—the data
    (see the pattern here?), followed by the grouping variable. We can group by more
    than one variable by separating them with commas. When we print `groupedData`,
    not much has changed except that we get an indication above the data saying that
    they are grouped, the variable by which they are grouped, and how many groups
    there are. This tells us that any further operations we apply will be performed
    on a group-by-group basis.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `group_by()` 函数中，第一个参数是——没错——数据（看这里的模式？），后面跟着分组变量。我们可以通过逗号分隔来按多个变量进行分组。当我们打印
    `groupedData` 时，除了数据上方有一个表示它们已分组的指示，以及它们是根据哪个变量分组的以及有多少组之外，没有太多变化。这告诉我们，我们将对每个组进行进一步的操作。
- en: Listing 2.5\. Grouping data with `group_by()`
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.5\. 使用 `group_by()` 分组数据
- en: '[PRE14]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|  |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You can remove a grouping structure from a tibble by wrapping it in the `ungroup()`
    function.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将 tibble 包裹在 `ungroup()` 函数中来移除分组结构。
- en: '|  |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'In the `summarize()` function, the first argument is the data; in the second
    argument, we name the new variables we’re creating, followed by an `=` sign, followed
    by a definition of that variable. We can create as many new variables as we like
    by separating them by commas. In [listing 2.6](#ch02ex06), we create two summary
    variables: the mean of the uptake for each group (`meanUp`) and the standard deviation
    of the uptake for each group (`sdUp`). Now, when we print `summarizedData`, we
    can see that aside from our grouping variable, our original variables have been
    replaced with the summary variables we just created.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `summarize()` 函数中，第一个参数是数据；在第二个参数中，我们命名我们正在创建的新变量，后面跟着一个 `=` 符号，然后是该变量的定义。我们可以通过逗号分隔来创建尽可能多的新变量。在
    [列表 2.6](#ch02ex06) 中，我们创建了两个汇总变量：每个组的吸收量平均值（`meanUp`）和每个组的吸收量标准差（`sdUp`）。现在，当我们打印
    `summarizedData` 时，我们可以看到除了我们的分组变量外，我们的原始变量已经被我们刚刚创建的汇总变量所取代。
- en: Listing 2.6\. Creating summaries of variables using `summarize()`
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.6\. 使用 `summarize()` 创建变量的汇总
- en: '[PRE15]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, we will *mutate* a new variable from the existing ones to calculate
    the coefficient of variation for each group, and then we’ll *arrange* the rows
    in the data so that the row with the smallest value of the new variable is at
    the top, and the row with the largest value is at the bottom. We can do this with
    the `mutate()` and `arrange()` functions.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将从现有变量中**突变**一个新变量来计算每个组的变异系数，然后我们将使用 `mutate()` 和 `arrange()` 函数对数据进行排序，使得新变量值最小的行在顶部，值最大的行在底部。我们可以使用
    `mutate()` 和 `arrange()` 函数来完成此操作。
- en: For the `mutate()` function, the first argument is the data. The second argument
    is the name of the new variable to be created, followed by an `=` sign, followed
    by its definition. We can create as many new variables as we like by separating
    them with commas.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `mutate()` 函数，第一个参数是数据。第二个参数是新变量的名称，后面跟着一个 `=` 符号，然后是其定义。我们可以通过逗号分隔来创建尽可能多的新变量。
- en: Listing 2.7\. Creating new variables using `mutate()`
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.7\. 使用 `mutate()` 创建新变量
- en: '[PRE16]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|  |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Argument evaluation in dplyr functions is sequential, meaning we could have
    defined the `CV` variable in the `summarize()` function by referencing the `meanUp`
    and `sdUp` variables, even though they hadn’t been created yet!
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: dplyr 函数中的参数评估是顺序的，这意味着我们可以在 `summarize()` 函数中通过引用 `meanUp` 和 `sdUp` 变量来定义 `CV`
    变量，即使它们尚未创建！
- en: '|  |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The `arrange()` function takes the data as the first argument, followed by
    the variable(s) we wish to arrange the cases by. We can arrange by multiple columns
    by separating them with commas: doing so will arrange the cases in the order of
    the first variable, and any ties will be ordered based on their value of the second
    variable, and so on with subsequent ties.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`arrange()` 函数将数据作为第一个参数，后面跟着我们希望按其排列案例的变量。我们可以通过逗号分隔多个列来按多列排列：这样做将按第一个变量的顺序排列案例，任何平局将根据第二个变量的值进行排序，依此类推。'
- en: Listing 2.8\. Arranging tibbles by variables using `arrange()`
  id: totrans-343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.8\. 使用 `arrange()` 按变量排列 tibbles
- en: '[PRE17]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|  |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you want to arrange a tibble in *descending* order of a variable’s values,
    simply wrap the variable in `desc()`: `arrange(mutatedData, desc(CV))`.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要根据变量的值将 tibble 排序为**降序**，只需将变量包裹在 `desc()` 中：`arrange(mutatedData, desc(CV))`。
- en: '|  |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.4.2\. Chaining dplyr functions together
  id: totrans-349
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.2\. 连接 dplyr 函数
- en: Everything we did in [section 2.4.1](#ch02lev2sec4) could be achieved using
    base R, but I hope you can see that the dplyr functions—or *verbs*, as they’re
    often called (because they are human-readable and clearly imply what they do)—help
    make the code simpler and more human-readable. But the power of dplyr really comes
    from the ability to chain these functions together into intuitive, sequential
    processes.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2.4.1节](#ch02lev2sec4)中做的所有事情都可以使用基础R实现，但我希望你能看到dplyr函数——通常被称为*动词*（因为它们是可读的，并且清楚地表明了它们的作用）——有助于使代码更简单、更易读。但dplyr的真正力量来自于将函数链在一起形成直观、顺序的过程的能力。
- en: 'At each stage of our CO2 data manipulation, we saved the intermediate data
    and applied the next function to it. This is tedious, creates lots of unnecessary
    data objects in our R environment, and is not as human-readable. Instead, we can
    use the pipe operator, `%>%`, which becomes available when we load dplyr. The
    pipe passes the output of the function on its left as the first argument to the
    function on its right. Let’s look at a basic example:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们处理CO2数据的每个阶段，我们都保存了中间数据，并对其应用下一个函数。这样做很繁琐，在我们的R环境中创建了大量的不必要的数据对象，而且可读性也不强。相反，我们可以使用管道操作符`%>%`，当我们加载dplyr时它就可用。管道将左侧函数的输出作为右侧函数的第一个参数。让我们看看一个基本的例子：
- en: '[PRE18]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `%>%` operator takes the output of the `c()` function on the left (a vector
    of length 5), and “pipes” it into the first argument of the `mean()` function.
    We can use the `%>%` operator to chain multiple functions together to make the
    code more concise and human-readable.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`%>%`操作符将左侧`c()`函数的输出（长度为5的向量）"管道"到`mean()`函数的第一个参数。我们可以使用`%>%`操作符将多个函数链在一起，使代码更简洁、更易读。'
- en: Remember how I made a point of saying that the first argument of each dplyr
    function is the data? Well, the reason this is so important and useful is that
    it allows us to pipe the data from the previous operation into the next one. The
    entire process of data manipulation we went through in [section 2.4.1](#ch02lev2sec4)
    becomes the following listing.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我强调过每个dplyr函数的第一个参数是数据吗？嗯，这之所以如此重要且有用，是因为它允许我们将前一个操作的数据管道传输到下一个操作。我们在[第2.4.1节](#ch02lev2sec4)中经历的数据处理整个流程变成了以下列表。
- en: Listing 2.9\. Chaining dplyr operations together with `%>%`
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.9. 使用`%>%`操作符将dplyr操作链在一起
- en: '[PRE19]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Read the code from top to bottom, and every time you come to a `%>%` operator,
    say “and then.” You would read it as “Take the CO2 data, *and then* select these
    columns, *and then* filter these rows, *and then* group by this variable, *and
    then* summarize with these variables, *and then* mutate this new variable, *and
    then* arrange in order of this variable and save the output as `arrangedData`.
    Can you see that this is how you might explain your data-manipulation process
    to a colleague in plain English? This is the power of dplyr: being able to perform
    complex data manipulations in a logical, human-readable way.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 从上到下阅读代码，每次遇到`%>%`操作符时，就说出“然后”。你会读作“取CO2数据，*然后*选择这些列，*然后*过滤这些行，*然后*按此变量分组，*然后*用这些变量汇总，*然后*突变这个新变量，*然后*按此变量的顺序排列并保存输出为`arrangedData`。你能看到这是你如何用普通英语向同事解释你的数据处理过程吗？这就是dplyr的力量：能够以逻辑的、可读的方式执行复杂的数据处理。
- en: '|  |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is conventional to start a new line after a `%>%` operator to help make the
    code easier to read.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在`%>%`操作符之后开始新一行是一种惯例，有助于使代码更容易阅读。
- en: '|  |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Exercise 4**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习4**'
- en: Group the `mtcars` tibble by the `gear` variable, summarize the medians of the
    `mpg` and `disp` variables, and mutate a new variable that is the `mpg` median
    divided by the `disp` median, all chained together with the `%>%` operator.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 将`mtcars` tibble按`gear`变量分组，总结`mpg`和`disp`变量的中位数，并突变一个新变量，该变量是`mpg`中位数除以`disp`中位数，所有这些操作都通过`%>%`操作符链在一起。
- en: '|  |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 2.5\. What the ggplot2 package is and what it does
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5. ggplot2包是什么以及它做什么
- en: 'In R, there are three main plotting systems:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在R中，有三个主要的绘图系统：
- en: Base graphics
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础图形
- en: Lattice
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lattice
- en: ggplot2
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ggplot2
- en: Arguably, ggplot2 is the most popular system among data scientists; and as it’s
    part of the tidyverse, we will use this system to plot our data throughout this
    book. The “gg” in ggplot2 stands for *grammar of graphics*, a school of thought
    that says any data graphic can be created by combining data with layers of plot
    components such as axes, tickmarks, gridlines, dots, bars, and lines. By layering
    plot components like this, you can use ggplot2 to create communicative, attractive
    plots in a very intuitive way.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 不可否认，ggplot2是数据科学家中最受欢迎的系统之一；由于它是tidyverse的一部分，我们将使用这个系统在本书中绘制我们的数据。ggplot2中的“gg”代表*图形语法*，这是一种思想流派，认为任何数据图形都可以通过将数据与绘图组件的层（如轴、刻度、网格线、点、条形和线）相结合来创建。通过以这种方式分层绘图组件，您可以使用ggplot2以非常直观的方式创建具有沟通性和吸引力的图表。
- en: Let’s load the iris dataset that comes with R and create a scatter plot of two
    of its variables. This data was collected and published by Edgar Anderson in 1935
    and contains length and width measurements of the petals and sepals of three species
    of iris plant.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加载R中附带的数据集iris，并创建其两个变量的散点图。这些数据由Edgar Anderson在1935年收集并发表，包含三种鸢尾花植物花瓣和萼片的长度和宽度测量值。
- en: Figure 2.1\. A scatter plot created with ggplot2\. The `Sepal.Length` variable
    is mapped to the x aesthetic, and the `Sepal.Width` variable is mapped to the
    y aesthetic. A black-and-white theme was applied by adding the `theme_bw()` layer.
  id: totrans-373
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.1\. 使用ggplot2创建的散点图。`Sepal.Length`变量映射到x美学，`Sepal.Width`变量映射到y美学。通过添加`theme_bw()`层应用了黑白主题。
- en: '![](fig2-1_alt.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图2-1的替代图片](fig2-1_alt.jpg)'
- en: The code to create the plot in [figure 2.1](#ch02fig01) is shown in [listing
    2.10](#ch02ex10). The function `ggplot()` takes the data you supply as the first
    argument and the function `aes()` as the second (more about this in a moment).
    This creates a plotting environment, axis, and axis labels based on the data.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图2.1中图表的代码显示在[代码清单2.10](#ch02ex10)。函数`ggplot()`将您提供的数据作为第一个参数，将函数`aes()`作为第二个参数（稍后将有更多关于此的介绍）。这创建了一个基于数据的绘图环境、轴和轴标签。
- en: The `aes()` function is short for *aesthetic mappings*, which, if you’re used
    to base R plotting, may be new to you. An *aesthetic* is a feature of a plot that
    can be controlled by a variable in the data. Examples of aesthetics include the
    x-axis, y-axis, color, shape, size, and even transparency of the data points drawn
    on the plot. In the function call in [listing 2.10](#ch02ex10), we have asked
    `ggplot()` to map the `Sepal.Length` and `Sepal.Width` variables to the x- and
    y-axes, respectively.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`aes()`函数代表*美学映射*，如果您习惯了基本的R绘图，这可能对您来说是新的。*美学*是图表的一个特征，可以通过数据中的变量来控制。美学的例子包括x轴、y轴、颜色、形状、大小，甚至是绘制在图上的数据点的透明度。在[代码清单2.10](#ch02ex10)中的函数调用中，我们要求`ggplot()`将`Sepal.Length`和`Sepal.Width`变量分别映射到x轴和y轴。'
- en: Listing 2.10\. Plotting data with the `ggplot()` function
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单2.10\. 使用`ggplot()`函数绘制数据
- en: '[PRE20]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|  |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Notice that we don’t need to wrap the variable names in quotes; `ggplot()` is
    clever!
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要用引号括起变量名；`ggplot()`很聪明！
- en: '|  |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: We finish the line with the `+` symbol, which we use to add additional layers
    to our plot (we can add as many layers as it takes to create our desired plot).
    Convention states that when we add additional layers to our plots, we finish the
    current layer with `+` and place the next layer on a new line. This helps maintain
    readability.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以`+`符号结束行，我们使用`+`来添加我们的绘图中的额外层（我们可以添加尽可能多的层来创建我们想要的图表）。惯例是，当我们向我们的图表添加额外的层时，我们以`+`结束当前层，并在新行上放置下一层。这有助于保持可读性。
- en: '|  |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 备注
- en: When adding layers to the initial `ggplot()` function call, each line needs
    to finish with `+`; you cannot put the `+` on a new line.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 当向初始`ggplot()`函数调用添加层时，每一行都需要以`+`结束；您不能将`+`放在新行上。
- en: '|  |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'The next layer is a function called `geom_point()`. *Geom* stands for *geometric
    object*, which is a graphical element used to represent data points, such as bars,
    lines, box and whiskers, and so on; the functions to produce these layers are
    all named `geom_[graphical element]`. For example, let’s add two new layers to
    our plot: `geom_density_2d()`, which adds density contours; and `geom_smooth()`,
    which fits a smoothed line with confidence bands to the data (see [figure 2.2](#ch02fig02)).'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 下一层是一个名为`geom_point()`的函数。*Geom*代表*几何对象*，这是一种用于表示数据点的图形元素，例如条形、线条、箱线图和更多；用于生成这些层的函数都命名为`geom_[图形元素]`。例如，让我们向我们的图表添加两个新的层：`geom_density_2d()`，它添加密度轮廓；以及`geom_smooth()`，它将带有置信带的平滑线拟合到数据（见[图2.2](#ch02fig02)）。
- en: Figure 2.2\. The same scatter plot as in [figure 2.1](#ch02fig01), with 2D density
    contours and a smoothed line added as layers using the `geom_density_2d()` and
    `geom_smooth` functions, respectively.
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.2\. 与[图2.1](#ch02fig01)相同的散点图，添加了2D密度等高线和平滑线作为层，分别使用`geom_density_2d()`和`geom_smooth`函数。
- en: '![](fig2-2_alt.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![图片](fig2-2_alt.jpg)'
- en: The plot is reasonably complex, and to achieve the same in base R would take
    many lines of code. Here’s how easy this is to achieve with ggplot2!
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表相当复杂，要在基础R中实现相同的效果需要很多行代码。而使用ggplot2则非常简单！
- en: Listing 2.11\. Adding geom layers to a `ggplot` object
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[代码列表2.11\. 向`ggplot`对象添加geom层]'
- en: '[PRE21]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|  |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can save a `ggplot` as a named object and simply add new layers to that
    object, instead of creating the plot from scratch each time.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`ggplot`保存为命名对象，并简单地向该对象添加新层，而不是每次都从头开始创建图表。
- en: '|  |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Finally, it’s often important to highlight a grouping structure within the data,
    and we can do this by adding a color or shape aesthetic mapping, as shown in [figure
    2.3](#ch02fig03). The code to produce these plots is shown in [listing 2.12](#ch02ex12).
    The only difference between them is that `species` is given as the argument to
    the `shape` or `col` (color) aesthetic.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通常很重要的一点是要突出数据中的分组结构，我们可以通过添加颜色或形状美学映射来实现这一点，如图2.3所示。生成这些图表的代码在[代码列表2.12](#ch02ex12)中展示。它们之间的唯一区别是`species`被用作`shape`或`col`（颜色）美学的参数。
- en: Figure 2.3\. The same scatter plot as in [figure 2.1](#ch02fig01), with the
    `Species` variable mapped to the `shape` and `col` aesthetics
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.3\. 与[图2.1](#ch02fig01)相同的散点图，将`Species`变量映射到形状和`col`美学
- en: '![](fig2-3_alt.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![图片](fig2-3_alt.jpg)'
- en: Listing 2.12\. Mapping `species` to the `shape` and `color` aesthetics
  id: totrans-401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[代码列表2.12\. 将`species`映射到形状和颜色美学]'
- en: '[PRE22]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|  |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-404
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how `ggplot()` automatically produces a legend when you add aesthetic
    mappings other than x and y. With base graphics, you would have to produce these
    manually!
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`ggplot()`在添加除x和y之外的美学映射时，会自动生成图例。在基础图形中，你必须手动生成这些图例！
- en: '|  |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: One final thing I want to teach you about `ggplot()` is its extremely powerful
    *faceting* functionality. Sometimes we may wish to create subplots of our data
    where each subplot, or *facet*, displays data belonging to some group present
    in the data.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想教你们关于`ggplot()`的最后一个非常强大的功能——*分面*功能。有时我们可能希望创建子图，其中每个子图或*面元*显示数据中属于某个分组的数据。
- en: 'For example, [figure 2.4](#ch02fig04) shows the same iris data, but this time
    faceted by the `Species` variable. The code to create this plot is shown in [listing
    2.13](#ch02ex13): I’ve simply added a `facet_wrap()` layer to the `ggplot` call,
    and specified I want it to facet by `(~Species)`.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[图2.4](#ch02fig04)显示了相同的数据，但这次按`Species`变量分面。创建此图表的代码在[代码列表2.13](#ch02ex13)中展示：我只是在`ggplot`调用中添加了一个`facet_wrap()`层，并指定我想按`(~Species)`分面。
- en: Figure 2.4\. The same data is shown, but with different iris species plotted
    on separate subplots or facets.
  id: totrans-409
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4\. 展示了相同的数据，但不同鸢尾花物种分别绘制在单独的子图或面元上。
- en: '![](fig2-4_alt.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![图片](fig2-4_alt.jpg)'
- en: Listing 2.13\. Grouping subplots with the `facet_wrap()` function
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[代码列表2.13\. 使用`facet_wrap()`函数分组子图]'
- en: '[PRE23]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'While there is much more you can do with ggplot2 than is presented here (including
    customizing the appearance of virtually everything), I just want to give you an
    understanding of how to create the basic plots needed to replicate those you’ll
    find throughout the book. If you want to take your data-visualization skills to
    the next level, I strongly recommend *ggplot2: Elegant Graphics for Data Analysis*
    by Hadley Wickham (Springer International Publishing, 2016).'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ggplot2还有更多功能（包括几乎可以自定义任何外观），但我只想让你了解如何创建复制书中图表所需的基本图表。如果你想将数据可视化技能提升到下一个层次，我强烈推荐Hadley
    Wickham的《ggplot2：数据分析的优雅图形》（Springer International Publishing，2016年）。
- en: '|  |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: The order of plot elements on a ggplot is important! Plot elements are layered
    on sequentially, so elements added later in a `ggplot()` call will be *on top*
    of all the others. Reorder the `geom_density_2d()` and `geom_point()` functions
    used to create [figure 2.2](#ch02fig02), and look closely to see what happens
    (the plot might look the same, but it’s not!).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: ggplot中的绘图元素顺序很重要！绘图元素是按顺序叠加的，所以在一个`ggplot()`调用中添加的元素将位于所有其他元素之上。重新排列用于创建[图2.2](#ch02fig02)的`geom_density_2d()`和`geom_point()`函数，并仔细观察发生了什么（图表可能看起来相同，但实际上并不相同！）。
- en: '|  |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Exercise 5**'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习5**'
- en: Create a scatter plot of the `drat` and `wt` variables from your `mtcars` tibble,
    and color the dots by the `carb` variable. See what happens when you wrap the
    `carb` aesthetic mapping in `as.factor()`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的 `mtcars` tibble 中创建 `drat` 和 `wt` 变量的散点图，并按 `carb` 变量着色点。看看当你将 `carb` 美学映射包裹在
    `as.factor()` 中时会发生什么。
- en: '|  |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.6\. What the tidyr package is and what it does
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6\. tidyr 包是什么以及它做什么
- en: In [section 2.1](#ch02lev1sec1), we looked at an example of data that was not
    tidy and then at the same data after restructuring it in tidy format. Quite often,
    as data scientists, we don’t have much control over the format data is in when
    it comes to us; we commonly have to restructure untidy data into a tidy format
    so that we can pass it into our machine learning pipelines. Let’s make an untidy
    tibble and convert it into its tidy format.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 2.1 节](#ch02lev1sec1) 中，我们查看了一个非整洁数据示例，然后是重新结构化为整洁格式后的相同数据。作为数据科学家，我们通常对数据格式没有太多控制权；我们通常必须将不整洁的数据重新结构化为整洁格式，以便我们可以将其传递到我们的机器学习管道中。让我们创建一个不整洁的
    tibble 并将其转换为它的整洁格式。
- en: '[Listing 2.14](#ch02ex14) shows a tibble of fictitious patient data, where
    patients’ body mass index (BMI) was measured at month 0, month 3, and month 6
    after the start of some imaginary intervention. Is this data tidy? Well, no. There
    are only three variables in the data:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.14](#ch02ex14) 展示了一个虚构的患者数据 tibble，其中患者的身体质量指数（BMI）在开始某些想象中的干预措施后的第 0
    个月、第 3 个月和第 6 个月进行了测量。这是整洁数据吗？嗯，不是。数据中只有三个变量：'
- en: Patient ID
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 患者ID
- en: The month the measurement was taken
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量时月份
- en: The BMI measurement
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BMI 测量
- en: 'But we have four columns! Also, each row doesn’t contain the data for a single
    observation: it contains all the observations made on that patient.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们有四列！而且每一行并不包含单个观察的数据：它包含了在该患者身上进行的所有观察数据。
- en: Listing 2.14\. Untidy tibble
  id: totrans-429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.14\. 不整洁的 tibble
- en: '[PRE24]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To convert this untidy tibble into its tidy counterpart, we can use tidyr’s
    `gather()` function. The `gather()` function takes the data as its first argument.
    The `key` argument defines the name of the new variable that will represent the
    columns we are “gathering.” In this case, the columns we are gathering are named
    `Month0`, `Month3`, and `Month6`, so we call the new column that will hold these
    *keys* `Month`. The `value` argument defines the name of the new variable that
    will represent the data from the columns we are gathering. In this case, the values
    were BMI measurements, so we call the new column that will represent these values
    `BMI`. The final argument is a vector defining which variables to gather and convert
    into the key-value pairs. By using `-Patient`, we are telling `gather()` to use
    all the variables except the identifying variable, `Patient`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这个不整洁的 tibble 转换为其整洁对应物，我们可以使用 tidyr 的 `gather()` 函数。`gather()` 函数将数据作为其第一个参数。`key`
    参数定义了将代表我们“聚集”的列的新变量名称。在这种情况下，我们正在聚集的列命名为 `Month0`、`Month3` 和 `Month6`，因此我们将包含这些
    *keys* 的新列称为 `Month`。`value` 参数定义了将代表我们从聚集的列中获取的数据的新变量名称。在这种情况下，值是 BMI 测量值，因此我们将代表这些值的新的列称为
    `BMI`。最后一个参数是一个定义要聚集并转换为键值对的变量的向量。通过使用 `-Patient`，我们告诉 `gather()` 使用除标识变量 `Patient`
    之外的所有变量。
- en: Listing 2.15\. Tidying data with the `gather()` function
  id: totrans-432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.15\. 使用 `gather()` 函数整理数据
- en: '[PRE25]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We could have achieved the same result by typing the following, instead (note
    that the tibbles returned by the two listings are identical).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过输入以下内容达到相同的结果（注意，两个列表返回的 tibble 是相同的）。
- en: Listing 2.16\. Different ways to select columns for gathering
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.16\. 选择列进行聚集的不同方式
- en: '[PRE26]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|  |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Converting data to wide format**'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**将数据转换为宽格式**'
- en: 'The data structure in the `patientData` tibble is called *wide* format, where
    observations for a single case are placed in the same row, across multiple columns.
    Mostly we want to work with tidy data because it makes our lives simpler: we can
    see immediately which variables we have, grouping structures are made clear, and
    most functions are designed to work easily with tidy data. There are, however,
    some rare occasions where we need to convert our tidy data into wide format, perhaps
    because a function we need expects the data in this format. We can convert tidy
    data into its wide format using the `spread()` function:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构在`patientData` tibble中被称为*宽格式*，其中单个案例的观测值放置在同一行，跨越多个列。我们通常想要处理整洁数据，因为它使我们的生活更简单：我们可以立即看到我们有哪些变量，分组结构变得清晰，并且大多数函数都设计得可以轻松与整洁数据一起工作。然而，有些罕见的情况下，我们需要将我们的整洁数据转换为宽格式，可能是因为我们需要的函数期望数据以这种格式。我们可以使用`spread()`函数将整洁数据转换为宽格式：
- en: '[PRE27]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Its use is the opposite of `gather()`: we supply the `key` and `value` arguments
    as the names of the key and value columns we created using the `gather()` function,
    and the function converts these into wide format for us.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用与`gather()`相反：我们提供`key`和`value`参数作为使用`gather()`函数创建的键和值列的名称，该函数为我们将这些转换为宽格式。
- en: '|  |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Exercise 6**'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习6**'
- en: Gather the `vs`, `am`, `gear`, and `carb` variables from your `mtcars` tibble
    into a single key-value pair.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 将`mtcars` tibble中的`vs`、`am`、`gear`和`carb`变量收集到一个单个键值对中。
- en: '|  |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.7\. What the purrr package is and what it does
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.7\. purrr包是什么以及它做什么
- en: The last tidyverse package I’m going to show you is purrr (with three r’s).
    R gives us the tools to use it as a functional programming language. This means
    it gives us the tools to treat all computations like mathematical functions that
    return their values, without altering anything in the workspace.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我将要向你展示的最后一个tidyverse包是purrr（有三个r）。R为我们提供了将其用作函数式编程语言所需的工具。这意味着它为我们提供了将所有计算视为返回其值而不改变工作区中的任何内容的数学函数的工具。
- en: '|  |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When a function does something other than return a value (such as draw a plot
    or alter an environment), it’s called a *side effect* of the function. A function
    that does not produce any side effects is said to be a *pure* function.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数执行的操作不仅仅是返回一个值（例如绘制一个图表或改变环境），我们称其为函数的*副作用*。一个不产生任何副作用的函数被称为*纯函数*。
- en: '|  |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: A simple example of functions that do and do not produce side effects is shown
    in [listing 2.17](#ch02ex17). The `pure()` function returns the value of `a +
    1` but does not alter anything in the global environment. The `side_effects()`
    function uses the super-assignment operator `<<-` to reassign the object `a` in
    the global environment. Each time you run the `pure()` function, it gives the
    same output; but running the `side_effect()` function gives a new value each time
    (and will impact the output of subsequent `pure()` function calls as well).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是否产生副作用的一个简单例子可以在[列表2.17](#ch02ex17)中找到。`pure()`函数返回`a + 1`的值，但不会改变全局环境中的任何内容。`side_effects()`函数使用超级赋值运算符`<<-`重新分配全局环境中的对象`a`。每次运行`pure()`函数，它都会给出相同的输出；但运行`side_effect()`函数每次都会给出一个新的值（并且还会影响后续`pure()`函数调用的输出）。
- en: Listing 2.17\. Creating a list of numeric vectors
  id: totrans-454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.17\. 创建一个数值向量的列表
- en: '[PRE28]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Calling functions without side effects is usually desirable because it’s easier
    to predict what the function will do. If a function has no side effects, it can
    be substituted with a different implementation without breaking anything in your
    code.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 调用没有副作用的函数通常是可取的，因为这更容易预测函数将做什么。如果一个函数没有副作用，它可以被替换为不同的实现，而不会破坏你的代码中的任何内容。
- en: An important consequence is that `for` loops, which when used on their own can
    create unwanted side effects (such as modifying existing variables), can be wrapped
    inside other functions. Functions that wrap `for` loops inside them allow us to
    iterate over each element of a vector/list (including columns and rows of data
    frames or tibbles), apply a function to that element, and return the result of
    the whole iterative process.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的后果是，`for`循环，当单独使用时可以产生不希望出现的副作用（例如修改现有变量），可以被包裹在其他函数中。将`for`循环包裹在内的函数允许我们遍历向量/列表的每个元素（包括数据框或tibble的列和行），对该元素应用一个函数，并返回整个迭代过程的输出结果。
- en: '|  |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-459
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re familiar with the `apply()` family of base R functions, functions
    from the purrr package help us achieve the same thing, but using a consistent
    syntax and some convenient features.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉基础 R 的 `apply()` 家族函数，`purrr` 包中的函数帮助我们实现相同的功能，但使用一致的语法和一些方便的特性。
- en: '|  |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 2.7.1\. Replacing for loops with map()
  id: totrans-462
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.7.1\. 用 map() 替换 for 循环
- en: The purrr package provides a set of functions that allow us to apply a function
    to each element of a list. Which purrr function to use depends on the number of
    inputs and what we want our output to be; in this section, I’ll demonstrate the
    importance of the most commonly used functions from this package.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`purrr` 包提供了一套函数，允许我们对列表的每个元素应用一个函数。我们使用哪个 `purrr` 函数取决于输入的数量以及我们想要的输出类型；在本节中，我将演示这个包中最常用函数的重要性。'
- en: 'Imagine that we have a list of three numeric vectors:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含三个数值向量的列表：
- en: '[PRE29]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let’s say we want to apply a function to each of the three list elements
    separately, such as the `length()` function to return the length of each element.
    We could use a `for` loop to do this, iterating over each list element and saving
    the length as an element of a new list that we predefine to save time:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要分别对三个列表元素应用一个函数，比如使用 `length()` 函数来返回每个元素的长度。我们可以使用 `for` 循环来做这件事，遍历每个列表元素，并将长度保存为新列表的一个元素，我们预先定义这个新列表以节省时间：
- en: '[PRE30]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This code is difficult to read, requires us to predefine an empty vector to
    prevent the loop from being slow, and has a side effect: if we run the loop again,
    it will overwrite the `elementLengths` list.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码难以阅读，需要我们预先定义一个空向量以防止循环变慢，并且有一个副作用：如果我们再次运行循环，它将覆盖 `elementLengths` 列表。
- en: Instead, we can replace the `for` loop with the `map()` function. The first
    argument of all the functions in the `map` family is the data we’re iterating
    over. The second argument is the function we’re applying to each list element.
    Take a look at [figure 2.5](#ch02fig05), which illustrates how the `map()` function
    applies a function to every element of a list/vector and returns a list containing
    the outputs.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以用 `map()` 函数来替换 `for` 循环。`map` 家族中所有函数的第一个参数是我们正在迭代的 数据。第二个参数是我们应用到的每个列表元素的函数。看看
    [图 2.5](#ch02fig05)，它说明了 `map()` 函数如何将一个函数应用到列表/向量的每个元素上，并返回一个包含输出的列表。
- en: 'In this example, the `map()` function applies the `length()` function to each
    element of the `listOfNumerics` list and returns these values as a list. Notice
    that the `map()` function also uses the names of the input elements as the names
    of the output elements (`a`, `b`, and `c`):'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`map()` 函数将 `length()` 函数应用到 `listOfNumerics` 列表的每个元素上，并返回这些值作为一个列表。注意，`map()`
    函数还使用输入元素的名称作为输出元素的名称（`a`、`b` 和 `c`）：
- en: '[PRE31]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|  |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-473
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re familiar with the `apply` family of functions, `map()` is the purrr
    equivalent of `lapply()`.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 `apply` 家族的基础 R 函数，`map()` 就是 `purrr` 的 `lapply()` 对应函数。
- en: '|  |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Figure 2.5\. The `map()` function takes a vector or list as input, applies a
    function to each element individually, and returns a list of the returned values.
  id: totrans-476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.5\. `map()` 函数接受一个向量或列表作为输入，对每个元素单独应用一个函数，并返回一个包含返回值的列表。
- en: '![](fig2-5_alt.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![](fig2-5_alt.jpg)'
- en: I hope you can immediately see how much simpler this is to code, and how much
    easier it is to read, than the `for` loop!
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能立即看到，这比 `for` 循环简单得多，而且更容易阅读！
- en: 2.7.2\. Returning an atomic vector instead of a list
  id: totrans-479
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.7.2\. 返回原子向量而不是列表
- en: 'So the `map()` function always returns a list. But what if, instead of returning
    a list, we wanted to return an atomic vector? The purrr package provides a number
    of functions to do just that:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 `map()` 函数总是返回一个列表。但如果，我们想要返回一个原子向量而不是列表，怎么办？`purrr` 包提供了一系列函数来完成这个任务：
- en: '`map_dbl()` returns a vector of doubles (decimals).'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map_dbl()` 返回一个双精度浮点数向量。'
- en: '`map_chr()` returns a character vector.'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map_chr()` 返回一个字符向量。'
- en: '`map_int()` returns a vector of integers.'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map_int()` 返回一个整数向量。'
- en: '`map_lgl()` returns a logical vector.'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map_lgl()` 返回一个逻辑向量。'
- en: Each of these functions returns an atomic vector of the type specified by its
    suffix. In this way, we are forced to think about and predetermine what type of
    data our output should be. For example, as shown in [listing 2.18](#ch02ex18),
    we can return the lengths of each of our `listOfNumerics` list elements just as
    before, using the `map_int()` function. Just like `map()`, the `map_int()` function
    applies the `length()` function to each element of our list, but it returns the
    output as a vector of integers. We can do the same thing using the `map_chr()`
    function, which coerces the output into a character vector, but the `map_lgl()`
    function throws an error because it can’t coerce the output into a logical vector.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数中的每一个都返回一个由其后缀指定的原子向量。这样，我们被迫思考和预先确定我们的输出应该是哪种类型的数据。例如，正如[代码清单2.18](#ch02ex18)所示，我们可以像以前一样使用`map_int()`函数返回我们的`listOfNumerics`列表中每个元素的长度。就像`map()`一样，`map_int()`函数将`length()`函数应用到我们的列表的每个元素上，但它返回一个整数向量。我们可以使用`map_chr()`函数做同样的事情，它会将输出强制转换为字符向量，但`map_lgl()`函数会抛出一个错误，因为它无法将输出强制转换为逻辑向量。
- en: '|  |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-487
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Forcing us to explicitly state the type of output we want to return prevents
    bugs from unexpected types of output.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 强迫我们明确声明我们想要的输出类型可以防止意外类型输出导致的错误。
- en: '|  |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 2.18\. Returning atomic vectors
  id: totrans-490
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.18\. 返回原子向量
- en: '[PRE32]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|  |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Exercise 7**'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习7**'
- en: Use a function from the purrr package to return a logical vector indicating
    whether the sum of the values in each column of the `mtcars` dataset is greater
    than 1,000.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自purrr包的函数返回一个逻辑向量，指示`mtcars`数据集中每列值的总和是否大于1,000。
- en: '|  |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Finally, we can use the `map_df()` function to return a tibble instead of a
    list.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`map_df()`函数返回一个tibble而不是列表。
- en: Listing 2.19\. Returning a tibble with `map_df()`
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.19\. 使用`map_df()`返回一个tibble
- en: '[PRE33]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 2.7.3\. Using anonymous functions inside the map() family
  id: totrans-499
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.7.3\. 在map()家族中使用匿名函数
- en: Sometimes we want to apply a function to each element of a list that we haven’t
    defined yet. Functions that we define on the fly are called *anonymous functions*
    and can be useful when the function we’re applying isn’t going to be used often
    enough to warrant assigning it to an object. Using base R, we define an anonymous
    function by simply calling the `function()` function.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想要将一个函数应用到我们尚未定义的列表的每个元素上。在即兴定义的函数称为*匿名函数*，当我们要应用的函数不太可能经常使用到足以将其分配给一个对象时，它们非常有用。使用基础R，我们通过简单地调用`function()`函数来定义一个匿名函数。
- en: Listing 2.20\. Defining an anonymous function with `function()`
  id: totrans-501
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.20\. 使用`function()`定义匿名函数
- en: '[PRE34]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|  |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the `.` in the anonymous function. This represents the element that `map()`
    is currently iterating over.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 注意匿名函数中的`.`。这代表`map()`当前正在迭代的元素。
- en: '|  |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The expression after `function(.)` is the body of the function. There is nothing
    wrong with this syntax—it works perfectly fine—but purrr provides a shorthand
    for `function(.)`: the `~` (tilde) symbol. Therefore, we could simplify the `map()`
    call to'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`function(.)`后面的表达式是函数的主体。这种语法没有问题——它工作得很好——但purrr提供了`function(.)`的简写：波浪号`~`符号。因此，我们可以简化`map()`调用为'
- en: '[PRE35]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: by substituting `~` for `function(.)`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用`~`替换`function(.)`。
- en: 2.7.4\. Using walk() to produce a function’s side effects
  id: totrans-510
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.7.4\. 使用walk()产生函数的副作用
- en: 'Sometimes we want to iterate over a function for its side effects. Probably
    the most common example is when we want to produce a series of plots. In this
    situation, we can use the `walk()` function to apply a function to each element
    of a list to produce the function’s side effects. The `walk()` function also returns
    the original input data we pass it, so it’s useful for plotting an intermediate
    step in a series of piped operations. Here’s an example of `walk()` being used
    to create a separate histogram for each element of our list:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想要迭代一个函数以产生其副作用。最常见的一个例子是我们想要生成一系列图表。在这种情况下，我们可以使用`walk()`函数将一个函数应用到列表的每个元素上，以产生函数的副作用。`walk()`函数还会返回我们传递给它的原始输入数据，因此它在一系列管道操作中的中间步骤绘图时非常有用。以下是一个使用`walk()`为列表中的每个元素创建单独直方图的例子：
- en: '[PRE36]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|  |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The `par(mfrow = c(1, 3))` function call simply splits the plotting device into
    two rows and four columns for base plots.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '`par(mfrow = c(1, 3))`函数调用只是将绘图设备分成两行四列，用于基本绘图。'
- en: '|  |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The resulting plot is shown in [figure 2.6](#ch02fig06).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表显示在[图2.6](#ch02fig06)中。
- en: 'But what if we want to use the name of each list element as the title for its
    histogram? We can do this using the `iwalk()` function, which makes the name or
    index of each element available to us. In the function we supply to `iwalk()`,
    we can use `.x` to reference the list element we’re iterating over and `.y` to
    reference its name/index:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想使用每个列表元素的名称作为其直方图的标题呢？我们可以使用`iwalk()`函数，它使我们能够获取每个元素的名字或索引。在提供给`iwalk()`的函数中，我们可以使用`.x`来引用正在迭代的列表元素，使用`.y`来引用其名称/索引：
- en: '[PRE37]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|  |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-521
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Each of the `map()` functions has an `i` version that lets us reference each
    element’s name/index.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`map()`函数都有一个`i`版本，允许我们引用每个元素的名字/索引。
- en: '|  |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Figure 2.6\. The result of “walking” the `hist()` function over each element
    of our list using `walk()`
  id: totrans-524
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.6\. 使用`walk()`函数遍历列表中每个元素的`hist()`函数的结果
- en: '![](fig2-6_alt.jpg)'
  id: totrans-525
  prefs: []
  type: TYPE_IMG
  zh: '![](fig2-6_alt.jpg)'
- en: The resulting plot is shown in [figure 2.7](#ch02fig07). Notice that now each
    histogram’s title shows the name of the list element it’s plotting.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图显示在[图2.7](#ch02fig07)。注意，现在每个直方图的标题显示了它所绘制的列表元素的名称。
- en: Figure 2.7\. The result of “walking” the `hist()` function over each element
    of our list using `iwalk()`
  id: totrans-527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.7\. 使用`iwalk()`遍历列表中每个元素的`hist()`函数的结果
- en: '![](fig2-7_alt.jpg)'
  id: totrans-528
  prefs: []
  type: TYPE_IMG
  zh: '![](fig2-7_alt.jpg)'
- en: 2.7.5\. Iterating over multiple lists simultaneously
  id: totrans-529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.7.5\. 同时遍历多个列表
- en: 'Sometimes the data we wish to iterate over isn’t contained in a single list.
    Imagine that we want to multiply each element in our list by a different value.
    We can store these values in a separate list and use the `map2()` function to
    iterate over both lists simultaneously, multiplying the element in the first list
    by the element in the second. This time, instead of referencing our data with
    `.`, we specifically reference the first and second lists using `.x` and `.y`,
    respectively:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们想要迭代的不是单个列表中的数据。想象一下，我们想要将列表中的每个元素乘以不同的值。我们可以将这些值存储在单独的列表中，并使用`map2()`函数同时遍历这两个列表，将第一个列表中的元素乘以第二个列表中的元素。这次，我们不是使用`.`来引用数据，而是分别使用`.x`和`.y`来特别引用第一个和第二个列表：
- en: '[PRE38]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, imagine that instead of iterating over just two lists, we want to iterate
    over three or more. The `pmap()` function allows us to iterate over multiple lists
    simultaneously. I use `pmap()` when I want to test multiple combinations of arguments
    for a function. The `rnorm()` function draws a random sample from the normal distribution
    and has three arguments: `n` (the number of samples), `mean` (the center of the
    distribution), and `sd` (the standard deviation). We can create a list of values
    for each and then use `pmap()` to iterate over each list to run the function on
    each combination.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，如果我们想迭代的不只是两个列表，而是三个或更多。`pmap()`函数允许我们同时遍历多个列表。当我想要测试函数的多个参数组合时，我会使用`pmap()`。`rnorm()`函数从正态分布中抽取随机样本，有三个参数：`n`（样本数量）、`mean`（分布的中心）和`sd`（标准差）。我们可以为每个参数创建一个值列表，然后使用`pmap()`迭代每个列表，对每种组合运行函数。
- en: We start by using the `expand.grid()` function to create a data frame containing
    every combination of the input vectors. Because data frames are really just lists
    of columns, supplying one to `pmap()` will iterate a function over each column
    in the data frame. Essentially, the function we ask `pmap()` to iterate over will
    be run using the arguments contained in each row of the data frame. Therefore,
    `pmap()` will return eight different random samples, one corresponding to each
    combination of arguments in the data frame.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`expand.grid()`函数创建一个包含所有输入向量组合的数据框。因为数据框实际上只是列的列表，所以提供给`pmap()`的数据框将迭代数据框中的每一列。本质上，我们要求`pmap()`迭代的函数将使用数据框每一行的参数运行。因此，`pmap()`将返回八个不同的随机样本，每个样本对应数据框中参数组合的一种。
- en: Because the first argument of all `map` family functions is the data we wish
    to iterate over, we can chain them together using the `%>%` operator. The following
    code pipes the random samples returned by `pmap()` into the `iwalk()` function
    to draw a separate histogram for each sample, labeled with its index.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有`map`族函数的第一个参数是我们想要迭代的的数据，所以我们可以使用`%>%`运算符将它们连接起来。以下代码将`pmap()`返回的随机样本传递给`iwalk()`函数，为每个样本绘制一个单独的直方图，并标注其索引。
- en: Listing 2.21\. Using `pmap()` to iterate over multiple lists
  id: totrans-535
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.21\. 使用`pmap()`遍历多个列表
- en: '[PRE39]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The resulting plot is shown in [figure 2.8](#ch02fig08).
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 结果图显示在[图2.8](#ch02fig08)中。
- en: Figure 2.8\. The `pmap()` function was used to iterate the `rnorm()` function
    over three vectors of arguments. The output from `pmap()` was piped into `iwalk()`
    to iterate the `hist()` function over each random sample.
  id: totrans-538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.8。使用了 `pmap()` 函数对三个参数向量进行迭代 `rnorm()` 函数。`pmap()` 的输出被传递到 `iwalk()` 中，以迭代每个随机样本的
    `hist()` 函数。
- en: '![](fig2-8_alt.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![fig2-8_alt.jpg](fig2-8_alt.jpg)'
- en: Don’t worry if you haven’t memorized all of the tidyverse functions I just covered—we’ll
    be using these tools throughout the book in our machine learning pipelines. There’s
    also much more we can do with tidyverse tools than I’ve covered here, but this
    will certainly be enough for you to solve the most common data-manipulation problems
    you’ll encounter. Now that you’re armed with the knowledge of how to use this
    book, in the next chapter we’ll dive into the theory of machine learning.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有记住我刚才提到的所有 tidyverse 函数，不要担心——我们将在本书的机器学习管道中一直使用这些工具。此外，我们还可以使用 tidyverse
    工具做更多的事情，但我所涵盖的这些内容将足以解决你将遇到的最常见的数据操作问题。现在，你已经掌握了如何使用这本书的知识，在下一章中，我们将深入探讨机器学习的理论。
- en: Summary
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The tidyverse is a collection of R packages that simplifies the organization,
    manipulation, and plotting of data.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tidyverse 是一系列 R 包的集合，它简化了数据的组织、操作和绘图。
- en: Tidy data is rectangular data where each row is a single observation and each
    column is a variable. It’s often important to ensure that data is in tidy format
    before passing it into machine learning functions.
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整洁数据是矩形数据，其中每一行是一个单独的观测值，每一列是一个变量。在将数据传递给机器学习函数之前，确保数据处于整洁格式通常很重要。
- en: Tibbles are a modern take on data frames that have better rules for printing
    rectangular data, never change variable types, and always return another tibble
    when subsetted using `[`.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tibbles 是对数据框的现代改进，它具有更好的打印矩形数据的规则，永远不会改变变量类型，并且在用 `[` 子集时总是返回另一个 tibble。
- en: The dplyr package provides human-readable, verb-like functions for data-manipulation
    processes, the most important of which are `select()`, `filter()`, `group_by()`,
    `summarize()`, and `arrange()`.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dplyr 包提供了人类可读的、动词样式的数据操作函数，其中最重要的是 `select()`、`filter()`、`group_by()`、`summarize()`
    和 `arrange()`。
- en: The most powerful aspect of dplyr is the ability to pipe functions together
    using the `%>%` operator, which passes the output of the function on its left
    as the first argument of the function on its right.
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dplyr 的最强大之处在于能够使用 `%>%` 操作符将函数连接起来，该操作符将左侧函数的输出作为右侧函数的第一个参数。
- en: The ggplot2 package is a modern and popular plotting system for R that lets
    you create effective plots in a simple, layered way.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ggplot2 包是一个现代且流行的 R 语言绘图系统，它允许你以简单、分层的方式创建有效的图表。
- en: The tidyr package provides the important function `gather()`, which lets you
    easily convert untidy data into tidy format. The opposite of this function is
    `spread()`, which converts tidy data into wide format.
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tidyr 包提供了重要的 `gather()` 函数，它允许你轻松地将不整洁的数据转换为整洁格式。与此函数相反的是 `spread()`，它将整洁数据转换为宽格式。
- en: The purrr package provides a simple, consistent way to iteratively apply functions
    over each element in a list.
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: purrr 包提供了一种简单、一致的方式来迭代地对列表中的每个元素应用函数。
- en: Solutions to exercises
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习解答
- en: 'Load `mtcars`, convert it to a tibble, and explore it with `summary()`:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载 `mtcars`，将其转换为 tibble，并使用 `summary()` 进行探索：
- en: '[PRE40]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Select all columns except `qsec` and `vs`:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择除 `qsec` 和 `vs` 之外的所有列：
- en: '[PRE41]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Filter for rows with cylinder numbers *not* equal to 8:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 筛选出气缸数不等于 8 的行：
- en: '[PRE42]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Group by `gear`, summarize the medians of `mpg` and `disp`, and mutate a new
    variable that is the `mpg` median divided by the `disp` median:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 `gear` 分组，计算 `mpg` 和 `disp` 的中位数，并创建一个新变量，该变量是 `mpg` 中位数除以 `disp` 中位数：
- en: '[PRE43]'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a scatter plot of the `drat` and `wt` variables, and color by `carb`:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `drat` 和 `wt` 变量的散点图，并按 `carb` 分色：
- en: '[PRE44]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Gather `vs`, `am`, `gear`, and `carb` into a single key-value pair:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `vs`、`am`、`gear` 和 `carb` 聚合成一个单一的关键值对：
- en: '[PRE45]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Iterate over each column of `mtcars`, returning a logical vector:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `mtcars` 的每一列进行迭代，返回一个逻辑向量：
- en: '[PRE46]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
