- en: Chapter 7\. Exception handling
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章\. 异常处理
- en: '| Exam objectives covered in this chapter | What you need to know |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '| 本章涵盖的考试目标 | 你需要了解的内容 |'
- en: '| --- | --- |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **[8.3]** Describe the advantages of Exception handling. | The need for and
    advantages of exception handlers. |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| **[8.3]** 描述异常处理的优点。 | 异常处理器需求和优点。|'
- en: '| **[8.1]** Differentiate among checked exceptions, unchecked exceptions, and
    Errors. | Differences and similarities between checked exceptions, RuntimeExceptions,
    and Errors. Differences and similarities in the way these exceptions and errors
    are handled in code. |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| **[8.1]** 区分检查型异常、非检查型异常和错误。 | 检查型异常、RuntimeExceptions和错误之间的差异和相似之处。这些异常和错误在代码中处理方式上的差异和相似之处。|'
- en: '| **[8.2]** Create a try-catch block and determine how exceptions alter normal
    program flow. | How to create a try-catch-finally block. Understand the flow of
    code when the enclosed code throws an exception or error. How to create nested
    try-catch-finally blocks. |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| **[8.2]** 创建try-catch块并确定异常如何改变正常程序流程。 | 如何创建try-catch-finally块。当封装的代码抛出异常或错误时的代码流程。如何创建嵌套的try-catch-finally块。|'
- en: '| **[8.4]** Create and invoke a method that throws an exception. | How to create
    methods that throw exceptions. Rules that cover when overriding or overridden
    methods throw or don’t throw exceptions. How to determine the flow of control
    when an invoked method throws an exception. How to apply this to cases when one
    is thrown without a try block and from a try block (with appropriate and insufficient
    exception handlers). The difference in calling methods that throw or don’t throw
    exceptions. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| **[8.4]** 创建并调用一个抛出异常的方法。 | 如何创建抛出异常的方法。覆盖或被覆盖的方法抛出或未抛出异常的规则。当调用方法抛出异常时，如何确定控制流的流程。如何将此应用于没有try块抛出异常以及从try块（带有适当的和不足的异常处理器）抛出的情况。抛出或未抛出异常的方法调用差异。|'
- en: '| **[8.5]** Recognize common exception classes (such as NullPointerException,
    Arithmetic-Exception, ArrayIndexOutOfBounds-Exception, ClassCastException) | How
    to recognize the code that can throw these exceptions and handle them appropriately.
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| **[8.5]** 识别常见的异常类（如NullPointerException、Arithmetic-Exception、ArrayIndexOutOfBounds-Exception、ClassCastException）
    | 如何识别可能抛出这些异常的代码，并适当地处理它们。|'
- en: Imagine you’re about to board an airplane to Geneva to attend an important conference.
    At the last minute, you learn that the flight has been cancelled because the pilot
    isn’t feeling well. Fortunately, the airline quickly arranges for an alternative
    pilot, allowing the flight to take off at its originally scheduled time. What
    a relief!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你即将登机前往日内瓦参加一个重要的会议。在最后一刻，你得知航班已被取消，因为飞行员感觉不适。幸运的是，航空公司迅速安排了备用飞行员，使得航班能够按照原定时间起飞。多么令人欣慰啊！
- en: This example illustrates how exceptional conditions can modify the initial flow
    of an action and demonstrates the need to handle those conditions appropriately.
    In Java, an exceptional condition (like the illness of a pilot) can affect the
    normal code flow (airline flight operation). In this context, the arrangement
    for an alternative pilot can be compared to an exception handler.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了异常条件如何可以修改动作的初始流动，并展示了适当处理这些条件的必要性。在Java中，一个异常条件（如飞行员生病）可能会影响正常的代码流程（航空公司航班运营）。在这种情况下，为备用飞行员所做的安排可以比作异常处理器。
- en: Depending on the nature of the exceptional condition, you may or may not be
    able to recover completely. For example, would airline management have been able
    to get your flight off the ground if, instead, an earthquake had damaged much
    of the airport?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据异常条件的性质，你可能能够完全恢复，也可能不能。例如，如果地震破坏了大部分机场，航空公司管理能否让你的航班起飞？
- en: 'In the exam, you’ll be asked similar questions with respect to Java code and
    exceptions. With that in mind, this chapter covers the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在考试中，你将针对Java代码和异常被问及类似的问题。考虑到这一点，本章涵盖了以下内容：
- en: Understanding and identifying exceptions arising in code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和识别代码中出现的异常
- en: Determining how exceptions alter the normal program flow
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定异常如何改变正常程序流程
- en: Understanding the need to handle exceptions separately in your code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的代码中单独处理异常的需求
- en: Using `try`-`catch`-`finally` blocks to handle exceptions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`try`-`catch`-`finally`块处理异常
- en: Differentiating between checked exceptions, unchecked exceptions, and errors
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分检查型异常、非检查型异常和错误
- en: Invoking methods that may throw exceptions
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用可能抛出异常的方法
- en: Recognizing common exception categories and classes
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别常见的异常类别和类
- en: You might feel like we’re covering a lot in this chapter, but remember that
    we aren’t going to delve into too much background information because I assume
    you already know the definitions and uses of classes and methods, class inheritance,
    arrays, and `ArrayList`s. Our focus in this chapter is on the exam objectives
    and what you need to know about exceptions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得本章内容很多，但请记住，我们不会深入探讨太多背景信息，因为我假设你已经知道类和方法、类继承、数组和`ArrayList`的定义和用法。本章的重点是考试目标和关于异常你需要了解的内容。
- en: In this chapter, I won’t discuss a `try` statement with multiple `catch` clauses,
    automatic closing of resources with a `try`-with-resources statement, or the creation
    of custom exceptions. These topics are covered in the next level of Java certification
    (in the OCP Java SE 8 Programmer II exam).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我不会讨论带有多个`catch`子句的`try`语句、使用`try`-with-resources语句自动关闭资源或创建自定义异常。这些主题将在Java认证的下一级别（在OCP
    Java SE 8程序员II级考试中）介绍。
- en: 7.1\. Exceptions in Java
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1\. Java中的异常
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[8.3] Describe the advantages of Exception handling'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[8.3] 描述异常处理的优点'
- en: '|  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this section, you’ll learn what exceptions are in Java, why you need to handle
    exceptions separately from the main code, and all about their advantages and disadvantages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解Java中的异常是什么，为什么需要将异常处理与主代码分开，以及它们的优缺点。
- en: 7.1.1\. A taste of exceptions
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1\. 体验异常
- en: In [figure 7.1](#ch07fig01), do you think the code in bold in the classes `ArrayAccess`,
    `OpenFile`, and `MethodAccess` has anything in common?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图7.1](#ch07fig01)中，你认为在`ArrayAccess`、`OpenFile`和`MethodAccess`类中加粗的代码有什么共同点吗？
- en: Figure 7.1\. Getting a taste of exceptions in Java
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1\. 体验Java中的异常
- en: '![](07fig01_alt.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig01_alt.jpg)'
- en: 'I’m sure, given this chapter’s title, that this question was easy to answer.
    Each of these three statements is associated with throwing an exception or an
    error. Let’s look at them individually:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我确信，鉴于本章的标题，这个问题很容易回答。这三个陈述都与抛出异常或错误相关。让我们分别看看它们：
- en: '*Class* `ArrayAccess`—Because the length of the array `students` is `3`, trying
    to access the element at array position `5` is an exceptional condition, as shown
    in [figure 7.2](#ch07fig02).'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类* `ArrayAccess`—由于数组`students`的长度是`3`，尝试访问数组位置`5`的元素是一个异常条件，如图7.2所示。'
- en: Figure 7.2\. An example of `ArrayIndexOutOfBoundsException`
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.2\. `ArrayIndexOutOfBoundsException`的例子
- en: '![](07fig02_alt.jpg)'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](07fig02_alt.jpg)'
- en: '*Class* `OpenFile`—The constructor of the class `FileInputStream` throws a
    checked exception, `FileNotFoundException` (as shown in [figure 7.3](#ch07fig03)).
    If you try to compile this code without enclosing it within a `try` block and
    catching it, or marking it to be thrown by the method `main` (by using the `throws`
    statement), or catching this exception, your code will fail to compile. (I’ll
    discuss checked exceptions in detail in [section 7.2.3](#ch07lev2sec6).)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类* `OpenFile`—`FileInputStream`类的构造函数抛出一个检查异常`FileNotFoundException`（如图7.3所示）。如果你尝试在不将其包含在`try`块中捕获它，或者标记为由`main`方法抛出（使用`throws`语句），或者捕获这个异常的情况下编译此代码，你的代码将无法编译。（我将在[7.2.3节](#ch07lev2sec6)中详细讨论检查异常。）'
- en: Figure 7.3\. An example of `FileNotFoundException`
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.3\. `FileNotFoundException`的例子
- en: '![](07fig03_alt.jpg)'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](07fig03_alt.jpg)'
- en: '*Class* `MethodAccess`—As you can see in [figure 7.4](#ch07fig04), the method
    `myMethod` calls itself recursively, without specifying an exit condition. These
    recursive calls result in a `StackOverflowError` at runtime.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类* `MethodAccess`—如图7.4所示，`myMethod`方法递归调用自身，没有指定退出条件。这些递归调用在运行时导致`StackOverflowError`。'
- en: Figure 7.4\. An example of `StackOverflowError`
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.4\. `StackOverflowError`的例子
- en: '![](07fig04_alt.jpg)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](07fig04_alt.jpg)'
- en: These examples of exceptions are typical of what you’ll find on the OCA Java
    SE 8 Programmer I exam. Let’s move on and explore exceptions and their handling
    in Java so that you can spot code that throws exceptions and handle them accordingly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些异常的例子在OCA Java SE 8程序员I级考试中很典型。让我们继续前进，探索Java中的异常及其处理，以便你能识别出抛出异常的代码并相应地处理它们。
- en: '|  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**File I/O in Java**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java中的文件I/O**'
- en: File I/O isn’t covered on this exam, but you may notice it mentioned in questions
    related to exception handling. I’ll cover it quickly here just to the extent required
    for this exam.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 文件I/O在本考试中不涉及，但你可能会在有关异常处理的问题中看到它被提及。在这里，我将简要介绍它，仅限于本考试所需。
- en: File I/O involves multiple classes that enable you to read data from and write
    it to a source. This data source can be persistent storage, memory, or even network
    connections. Data can be read and written as streams of binary or character data.
    Some file I/O classes only read data from a source, some write data to a source,
    and some do both.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 文件I/O涉及多个类，这些类使你能够从源读取数据并将其写入。这个数据源可以是持久存储、内存，甚至是网络连接。数据可以作为二进制或字符数据的流来读取和写入。一些文件I/O类只从源读取数据，一些将数据写入源，还有一些两者都做。
- en: 'In this chapter, you’ll work with three classes from the file I/O API: `java.io.File`,
    `java.io.FileInputStream`, and `java.io.FileOutputStream`. `File` is an abstract
    representation of file and directory pathnames. You can *open* a `File` and then
    read from and write to it. A `FileInputStream` obtains input bytes using an object
    of the class `File`. It defines the methods `read` to read bytes and `close` to
    close this stream. A `FileOutputStream` is an output stream for writing data to
    a `File`. It defines the methods `write` to write bytes and `close` to close this
    stream.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将使用文件I/O API中的三个类：`java.io.File`、`java.io.FileInputStream`和`java.io.FileOutputStream`。`File`是对文件和目录路径名的抽象表示。您可以*打开*一个`File`，然后从中读取和写入。`FileInputStream`使用`File`类的对象获取输入字节。它定义了`read`方法来读取字节和`close`方法来关闭此流。`FileOutputStream`是用于将数据写入`File`的输出流。它定义了`write`方法来写入字节和`close`方法来关闭此流。
- en: Creating an object of the class `FileInputStream` or `FileOutputStream` can
    throw the checked exception `java.io.FileNotFoundException`. The methods `read`,
    `write`, and `close` defined in classes `FileInputStream` and `FileOutputStream`
    can throw the checked exception `java.io.IOException`. Note that `FileNotFound-Exception`
    subclasses `IOException`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`FileInputStream`或`FileOutputStream`类的对象可能会抛出检查型异常`java.io.FileNotFoundException`。在`FileInputStream`和`FileOutputStream`类中定义的`read`、`write`和`close`方法可能会抛出检查型异常`java.io.IOException`。请注意，`FileNotFoundException`是`IOException`的子类。
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.1.2\. Why handle exceptions separately?
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.2. 为什么单独处理异常？
- en: 'Imagine you want to post some comments on a blogging website. To make a comment,
    you must complete the following steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想在博客网站上发布一些评论。要发表评论，您必须完成以下步骤：
- en: Access the blogging website.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问博客网站。
- en: Log into your account.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录您的账户。
- en: Select the blog you want to comment on.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您想要评论的博客。
- en: Post your comments.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布您的评论。
- en: The preceding list might seem like an ideal set of steps. In actual conditions,
    you may have to verify whether you’ve completed a previous step before you can
    progress with the next step. [Figure 7.5](#ch07fig05) modifies the previous steps.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表可能看起来像是一组理想的步骤。在实际情况下，你可能必须验证是否完成了前面的步骤，然后才能进行下一步。![图7.5](#ch07fig05)修改了前面的步骤。
- en: Figure 7.5\. Expected code flow lost in combating exception conditions, without
    separate exception handlers
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.5. 在没有单独的异常处理程序的情况下，对抗异常条件时丢失的预期代码流程
- en: '![](07fig05_alt.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5](07fig05_alt.jpg)'
- en: The modified logic ([figure 7.5](#ch07fig05)) requires the code to check conditions
    before a user can continue with the next step. This checking of conditions at
    multiple places introduces new steps for users and also new paths of execution
    of the original steps. The difficult part of these modified paths is that they
    may leave users confused about the steps involved in the tasks they’re trying
    to accomplish. [Figure 7.6](#ch07fig06) shows how exception handling can help.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的逻辑([图7.5](#ch07fig05))要求代码在用户继续下一步之前检查条件。这种在多个地方检查条件引入了新的步骤，也引入了原始步骤的新执行路径。这些修改后的路径的难点在于，它们可能会使用户对试图完成的任务中涉及的步骤感到困惑。[图7.6](#ch07fig06)展示了异常处理如何有所帮助。
- en: Figure 7.6\. Defining exception-handling code separate from the main code logic
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.6. 将异常处理代码与主代码逻辑分开定义
- en: '![](07fig06_alt.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6](07fig06_alt.jpg)'
- en: The code in [figure 7.6](#ch07fig06) defines the original steps required to
    post comments to a blog, along with some exception-handling code. Because the
    exception handlers are defined separately, any confusion with what steps you need
    to accomplish to post comments on the website has been clarified. In addition,
    this code doesn’t compromise on checking the completion of a step before moving
    on to the next step, courtesy of appropriate exception handlers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.6](#ch07fig06)中的代码定义了发布博客评论所需的原始步骤，以及一些异常处理代码。由于异常处理程序是单独定义的，因此关于您需要完成哪些步骤才能在网站上发布评论的任何混淆都得到了澄清。此外，由于适当的异常处理程序，此代码在移动到下一步之前检查步骤完成的情况，没有妥协。'
- en: 7.1.3\. Does exception handling offer any other benefits?
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.3\. 异常处理提供其他好处吗？
- en: Apart from separating concerns between defining the regular program logic and
    the exception-handling code, exceptions also can help pinpoint the offending code
    (code that throws an exception), together with the method in which it is defined,
    by providing a stack trace of the exception or error.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在定义常规程序逻辑和异常处理代码之间分离关注点之外，异常还可以通过提供异常或错误的堆栈跟踪来帮助定位有问题的代码（抛出异常的代码），以及定义它的方法。
- en: '|  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A *stack* trace is so called because it gives you a way to trace back the stack—the
    sequence of method calls that generated the error (covered in detail in [section
    7.2](#ch07lev1sec2)).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*堆栈跟踪* 被称为这样是因为它提供了一种回溯堆栈的方法——生成错误的方法调用序列（在 [7.2 节](#ch07lev1sec2) 中详细说明）。'
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Here’s an example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`method2()` tries to access the array element of `students` at index `5`, which
    is an invalid index for the array `students`, so the code throws the exception
    `ArrayIndexOutOfBoundsException` at runtime. [Figure 7.7](#ch07fig07) shows the
    stack trace when this exception is thrown. It includes the runtime exception message
    and the list of methods that were involved in calling the code that threw the
    exception, starting from the entry point of this application, the `main` method.
    You can match the line numbers specified in the stack trace in [figure 7.7](#ch07fig07)
    to the line numbers in the code.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`method2()` 尝试访问 `students` 数组在索引 `5` 的元素，这是 `students` 数组的无效索引，因此代码在运行时抛出
    `ArrayIndexOutOfBoundsException` 异常。[图 7.7](#ch07fig07) 展示了抛出此异常时的堆栈跟踪。它包括运行时异常消息和调用抛出异常的代码的方法列表，从应用程序的入口点
    `main` 方法开始。您可以将 [图 7.7](#ch07fig07) 中的堆栈跟踪指定的行号与代码中的行号进行匹配。'
- en: Figure 7.7\. Tracing the line of code that threw an exception at runtime
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.7\. 追踪运行时抛出异常的代码行
- en: '![](07fig07_alt.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig07_alt.jpg)'
- en: '|  |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The stack trace gives you a trace of the methods that were called when the JVM
    encountered an unhandled exception. Stack traces are read from the bottom up.
    In [figure 7.7](#ch07fig07), the trace starts with the `main` method (the last
    line of the stack trace) and continues up to the method containing the code that
    threw the exception. Depending on the complexity of your code, a stack trace can
    range from a few lines to hundreds of lines of code. A stack trace works with
    handled and unhandled exceptions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈跟踪提供了 JVM 遇到未处理的异常时调用的方法的跟踪。堆栈跟踪是从下往上读取的。在 [图 7.7](#ch07fig07) 中，跟踪从 `main`
    方法（堆栈跟踪的最后一行）开始，一直延续到包含抛出异常的代码的方法。根据您代码的复杂性，堆栈跟踪可以从几行到几百行代码不等。堆栈跟踪与已处理和未处理的异常都兼容。
- en: '|  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Let’s move on and look at more details of exception propagation and at the creation
    of `try`-`catch`-`finally` blocks to take care of exceptions in code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，看看异常传播的更多细节，以及创建 `try`-`catch`-`finally` 块来处理代码中的异常。
- en: Before diving into the details of exception handling, let’s look at the multiple
    flavors of exceptions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解异常处理之前，让我们看看异常的多种形式。
- en: 7.2\. Categories of exceptions
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 异常的分类
- en: '|  |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[[8.1](kindle_split_022.html#ch08lev1sec1)] Differentiate among checked exceptions,
    unchecked exceptions, and Errors'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[[8.1](kindle_split_022.html#ch08lev1sec1)] 区分检查型异常、非检查型异常和错误'
- en: '|  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The Java compiler and its runtime treat the exception categories in a different
    manner. This implies that separate rules exist to define methods that throw exceptions
    and code that handles them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Java 编译器和其运行时以不同的方式处理异常类别。这意味着存在不同的规则来定义抛出异常的方法和处理它们的代码。
- en: 'In this section, you’ll learn about the categories of exceptions in Java: checked
    exceptions, runtime exceptions, and errors.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解 Java 中异常的分类：检查型异常、运行时异常和错误。
- en: 7.2.1\. Identifying exception categories
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1\. 识别异常类别
- en: 'As depicted in [figure 7.8](#ch07fig08), exceptions can be divided into three
    main categories:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 7.8](#ch07fig08) 所示，异常可以分为三大类：
- en: Checked exceptions
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查型异常
- en: Runtime exceptions
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时异常
- en: Errors
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: 'Figure 7.8\. Categories of exceptions: checked exceptions, runtime exceptions,
    and errors'
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.8\. 异常的分类：检查型异常、运行时异常和错误
- en: '![](07fig08.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig08.jpg)'
- en: '|  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Runtime exceptions and errors are collectively referred to as unchecked exceptions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时异常和错误统称为非检查型异常。
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Of these three types, checked exceptions require most of your attention when
    it comes to coding and using methods. Runtime exceptions represent programming
    errors. Checks should be inserted to prevent runtime exceptions from being thrown.
    There are few options you can use for the errors, because they’re thrown by the
    JVM.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三种类型中，当涉及到编码和使用方法时，检查异常需要你最多的注意。运行时异常代表编程错误。应该插入检查以防止抛出运行时异常。对于错误，你可以使用的选项很少，因为它们是由
    JVM 抛出的。
- en: For the OCA Java SE 8 Programmer I exam, it’s important to have a crystal-clear
    understanding of these three categories of exceptions, including their similarities
    and differences.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 OCA Java SE 8 程序员 I 考试，对这三种异常类别有一个清晰的理解非常重要，包括它们的相似之处和不同之处。
- en: 7.2.2\. Class hierarchy of exception classes
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2\. 异常类别的类层次结构
- en: Exception categories are related to each other; all extend the class `java.lang.Throwable`
    (as shown in the class hierarchy in [figure 7.9](#ch07fig09)).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 异常类别相互关联；它们都扩展了 `java.lang.Throwable` 类（如图 7.9 所示的类层次结构）。
- en: Figure 7.9\. Class hierarchies of exception categories
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.9\. 异常类别的类层次结构
- en: '![](07fig09.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig09.jpg)'
- en: 'Here’s the categorization of exceptions based on their class hierarchy:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们的类层次结构，以下是异常的分类：
- en: '*Checked exceptions*—`java.lang.Exception` and its subclasses (excluding `java.lang.RuntimeException`
    and its subclasses)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查异常*—`java.lang.Exception` 及其子类（不包括 `java.lang.RuntimeException` 及其子类）'
- en: '*Runtime exceptions*—`java.lang.RuntimeException` and its subclasses'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运行时异常*—`java.lang.RuntimeException` 及其子类'
- en: '*Errors*—`java.lang.Error` and its subclasses'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*错误*—`java.lang.Error` 及其子类'
- en: Let’s examine each of these categories in detail.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细考察这些类别中的每一个。
- en: 7.2.3\. Checked exceptions
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.3\. 检查异常
- en: When we talk about handling exceptions, *checked* exceptions take up most of
    our attention.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论异常处理时，*检查* 异常占据了我们的大部分注意力。
- en: What is a checked exception?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是检查异常？
- en: A checked exception is an unacceptable condition *foreseen* by the author of
    a method but outside their immediate control. For an example, `FileNotFoundException`
    is a checked exception. This exception is thrown if the file that the code is
    trying to access can’t be found. A method, say, `readFile()`, can declare it to
    be thrown when it’s unable to access the target file.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查异常是指方法作者预见到但无法直接控制的不容接受的条件 *预见*。例如，`FileNotFoundException` 是一个检查异常。如果代码尝试访问的文件找不到，就会抛出这个异常。一个方法，比如
    `readFile()`，可以声明在无法访问目标文件时抛出它。
- en: Checked exceptions are so named because they’re checked during compilation.
    If a method call throws a checked exception, the compiler checks and ensures that
    the calling method is either handling the exception or declaring it to be rethrown.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查异常之所以被称为检查异常，是因为它们在编译时进行检查。如果一个方法调用抛出检查异常，编译器会检查并确保调用方法要么处理该异常，要么声明它将被重新抛出。
- en: checked exception is a subclass of the class `java.lang.Exception`, but it’s
    not a subclass of `java.lang.RuntimeException`. It’s interesting to note, however,
    that the class `java.lang.RuntimeException` itself is a subclass of the class
    `java.lang.Exception`.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查异常是 `java.lang.Exception` 类的子类，但它不是 `java.lang.RuntimeException` 的子类。然而，值得注意的是，`java.lang.RuntimeException`
    类本身是 `java.lang.Exception` 类的子类。
- en: '|  |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: In this exam, you may have to select which type of reference variable to use
    to store the object of the thrown checked exception in a handler. To answer such
    questions correctly, remember that a checked exception subclasses `java.lang.Exception`
    but not `java.lang.RuntimeException`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次考试中，你可能需要选择使用哪种类型的引用变量来在处理程序中存储抛出的检查异常的对象。要正确回答这类问题，请记住，检查异常是 `java.lang.Exception`
    的子类，但不是 `java.lang.RuntimeException` 的子类。
- en: '|  |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'A checked exception is part of the API and is well documented. For a quick
    example, here’s the declaration of the constructor of the class `java.io.FileInputStream`
    in the Java API:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 检查异常是 API 的一部分，并且有很好的文档记录。以下是一个快速示例，展示了 Java API 中 `java.io.FileInputStream`
    类构造函数的声明：
- en: '[PRE1]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Checked exceptions are unacceptable conditions that a programmer *foresees*
    at the time of writing a method. By declaring these exceptions as checked exceptions,
    the author of the method makes its users aware of the exceptional conditions that
    can arise from its use. The user of a method with a checked exception must handle
    the exceptional condition accordingly.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 受检异常是在编写方法时程序员 *预见* 的不可接受的条件。通过将这些异常声明为受检异常，方法的作者让用户意识到可能由其使用引起的异常条件。使用带有受检异常的方法的用户必须相应地处理异常条件。
- en: 7.2.4\. Runtime exceptions
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.4\. 运行时异常
- en: Although you’ll spend most of your time and energy combating checked exceptions,
    the runtime exceptions will give you the most headaches. This is particularly
    true when you’re preparing to work on real-life projects. Some examples of runtime
    exceptions are `NullPointerException` (the most common one), `ArrayIndexOutOfBounds-Exception`,
    and `ClassCastException`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你将花费大部分的时间和精力来应对受检异常，但运行时异常会给你带来最多的麻烦。这尤其在你准备实际项目时更为明显。一些运行时异常的例子包括 `NullPointerException`（最常见的一种）、`ArrayIndexOutOfBoundsException`
    和 `ClassCastException`。
- en: What is a runtime exception?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是运行时异常？
- en: A runtime exception is a representation of a programming error. These occur
    from inappropriate use of a piece of code. For example, `NullPointerException`
    is a runtime exception that occurs when a piece of code tries to execute some
    code on a variable that hasn’t been assigned an object and points to `null`. Another
    example is `ArrayIndexOutOfBoundsException`, which is thrown when a piece of code
    tries to access an array element at a nonexistent position.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时异常是编程错误的表示。这些异常通常是由于对代码的不当使用引起的。例如，`NullPointerException` 是一种运行时异常，当一段代码尝试在一个尚未分配对象且指向
    `null` 的变量上执行代码时发生。另一个例子是 `ArrayIndexOutOfBoundsException`，当一段代码尝试访问一个不存在位置的数组元素时抛出。
- en: A runtime exception is named so because it isn’t feasible to determine whether
    a method call will throw a runtime exception until it executes.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时异常之所以被称为运行时异常，是因为在方法执行之前无法确定方法调用是否会抛出运行时异常。
- en: A runtime exception is a subclass of `java.lang.RuntimeException`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时异常是 `java.lang.RuntimeException` 的子类。
- en: It’s optional to declare a runtime exception in the signature of a method. It’s
    up to the person who writes the code to decide whether to declare it explicitly
    or not.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法签名中声明运行时异常是可选的。是否显式声明它取决于编写代码的人。
- en: '|  |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Together, runtime exceptions and errors are referred to as unchecked exceptions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时异常和错误统称为非受检异常。
- en: '|  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.2.5\. Errors
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.5\. 错误
- en: Whether you’re preparing for this exam or your real-life projects, you need
    to know when the JVM throws errors. These errors are considered to be *serious*
    exceptional conditions and they can’t be directly controlled by your code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是准备考试还是实际项目，你都需要知道 JVM 在何时抛出错误。这些错误被认为是 *严重* 的异常条件，它们不能直接被你的代码控制。
- en: What is an error?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是错误？
- en: An error is a serious exception thrown by the JVM as a result of an error in
    the environment state that processes your code. For example, `NoClassDefFound-Error`
    is an error thrown by the JVM when it’s unable to locate the .class file that
    it’s supposed to run. `StackOverflowError` is another error thrown by the JVM
    when the size of the memory required by the stack of a Java program is greater
    than what the JRE has offered for the Java application. This error might also
    occur as a result of infinite or highly nested loops.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误是 JVM 由于处理你的代码的环境状态错误而抛出的严重异常。例如，`NoClassDefFound-Error` 是 JVM 在无法找到它应该运行的
    `.class` 文件时抛出的错误。`StackOverflowError` 是 JVM 在 Java 程序所需的栈大小超过 JRE 为 Java 应用程序提供的内存时抛出的另一个错误。这个错误也可能由于无限循环或深度嵌套循环而出现。
- en: An error is a subclass of class `java.lang.Error`.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误是 `java.lang.Error` 类的子类。
- en: An error need not be a part of a method signature.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误不必是方法签名的一部分。
- en: An error can be caught by an exception handler, but it shouldn’t be.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误可以被异常处理器捕获，但通常不应该这样做。
- en: Let’s move on to creating methods that throw exceptions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建抛出异常的方法。
- en: 7.3\. Creating a method that throws an exception
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3\. 创建抛出异常的方法
- en: '|  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[8.4] Create and invoke a method that throws an exception'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[8.4] 创建并调用抛出异常的方法'
- en: '|  |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this section, you’ll explore the need to create methods that throw exceptions.
    You’ll also work with the `throw` and `throws` keywords to define methods that
    throw exceptions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将探索创建抛出异常的方法的需求。你还将使用`throw`和`throws`关键字来定义抛出异常的方法。
- en: 'Why do you need methods that throw exceptions? Imagine that you’re assigned
    the task of finding a specific book and then reading and explaining its contents
    to a class of students. The required sequence looks like the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你需要抛出异常的方法？想象一下，你被分配了一个找到特定书籍并阅读和向一班学生解释其内容的任务。所需的顺序如下：
- en: Get the specified book.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取指定的书籍。
- en: Read aloud its contents.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大声朗读其内容。
- en: Explain the contents to a class of students.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向一班学生解释内容。
- en: But what happens if you can’t find the specified book? You can’t proceed with
    the rest of the actions without it, so you need to report back to the person who
    assigned the task to you. This unexpected event (the missing book) prevents you
    from completing your task. By reporting it, you want the *originator* of this
    request to take corrective or alternate steps.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你找不到指定的书籍会发生什么？没有它，你无法继续执行其他操作，因此你需要向分配任务给你的人报告。这个意外事件（缺失的书籍）阻止了你完成任务。通过报告它，你希望这个请求的发起者采取纠正或替代措施。
- en: Let’s code the preceding task as the `teachClass` method, as shown in [figure
    7.10](#ch07fig10), which uses the `throw` statement and `throws` clause. This
    example code is for demonstration purposes only, because it uses the `BookNotFoundException`
    exception and the `locateBook()`, `readBook()`, and `explainContents()` methods,
    which aren’t defined.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前面的任务编码为`teachClass`方法，如图7.10所示，它使用了`throw`语句和`throws`子句。此示例代码仅用于演示目的，因为它使用了`BookNotFoundException`异常以及`locateBook()`、`readBook()`和`explainContents()`方法，这些方法尚未定义。
- en: Figure 7.10\. Using *`throw`* and *`throws`* to create methods that can throw
    exceptions
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.10. 使用`throw`和`throws`创建可以抛出异常的方法
- en: '![](07fig10_alt.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig10_alt.jpg)'
- en: The code in [figure 7.10](#ch07fig10) is simple to follow. On execution of the
    code `throw new BookNotFoundException()`, the execution of `teachClass()` halts.
    The JVM creates an instance of `BookNotFoundException` and sends it off to the
    caller of `teachClass()` so alternate arrangements can be made.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10中的代码易于理解。在执行`throw new BookNotFoundException()`代码时，`teachClass()`的执行将停止。JVM创建了一个`BookNotFoundException`的实例，并将其发送给`teachClass()`的调用者，以便做出替代安排。
- en: The `throw` statement is used to *throw* an instance of `BookNotFoundException`.
    The `throws` statement is used in the declaration of the `teachClass()` method
    to signal that it can throw `BookNotFoundException`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw`语句用于抛出`BookNotFoundException`的实例。`throws`语句用于`teachClass()`方法的声明中，以表示它可以抛出`BookNotFoundException`。'
- en: Why does a method choose to throw an exception as opposed to handling it itself?
    It’s a contract between the *calling* method and the *called* method. Referring
    to the `teachClass()` method shown in [figure 7.9](#ch07fig09), the *caller* of
    `teachClass` would like to be informed if `teachClass()` is unable to find the
    specified book. The `teachClass()` method doesn’t handle `BookNotFoundException`
    because its responsibilities don’t include working around a missing book.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么方法选择抛出异常而不是自己处理？这是调用方法与被调用方法之间的契约。参考图7.9中显示的`teachClass()`方法，`teachClass`的调用者希望如果`teachClass()`无法找到指定的书籍，能够得到通知。`teachClass()`方法不处理`BookNotFoundException`，因为它的职责不包括处理缺失的书籍。
- en: The preceding example helps identify a situation when you’d *want* a method
    to throw an exception, rather than handling it itself. It shows you how to use
    and compare the statements `throw` and `throws`—to *throw* exceptions and to signal
    that a method *might* throw an exception. The example also shows that a calling
    method can define alternate code, when the called method doesn’t complete successfully
    and throws an exception. Apart from testing this logic, the exam will test you
    on how to create and use methods that throw checked or unchecked exceptions and
    errors, along with several other rules.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子有助于确定你希望方法抛出异常而不是自己处理的情况。它展示了如何使用和比较`throw`和`throws`语句——用于抛出异常以及表示方法可能抛出异常。示例还展示了当被调用方法没有成功完成并抛出异常时，调用方法可以定义替代代码。除了测试这个逻辑之外，考试还将测试你如何创建和使用抛出检查或非检查异常和错误的方法，以及一些其他规则。
- en: 7.3.1\. Create a method that throws a checked exception
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1. 创建一个抛出检查异常的方法
- en: 'Let’s create a simple method that doesn’t handle the checked exception thrown
    by it, by using the statements `throw` and `throws`. The class `DemoThrowsException`
    defines the `readFile()` method, which includes a `throws` clause in its method
    declaration. The actual throwing of an exception is accomplished by the `throw`
    statement:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的方法，它不处理由它抛出的已检查异常，使用`throw`和`throws`语句。`DemoThrowsException`类定义了`readFile()`方法，它在方法声明中包含一个`throws`子句。实际抛出异常是通过`throw`语句完成的：
- en: '![](480fig01_alt.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](480fig01_alt.jpg)'
- en: A method can have multiple comma-separated class names of exceptions in its
    `throws` clause. Including runtime exceptions or errors in the method declaration
    isn’t required. Including them in the documentation is the preferred way to mention
    them. A method can still throw runtime exceptions or errors, without including
    them in its `throws` clause.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法的`throws`子句可以包含多个以逗号分隔的异常类名。在方法声明中包含运行时异常或错误不是必需的。在文档中提及它们是首选方式。即使没有在`throws`子句中包含，方法仍然可以抛出运行时异常或错误。
- en: '|  |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Syntactically, you don’t always need a combination of `throw` and `throws` statements
    to create a method that throws an exception (checked or unchecked). You can replace
    the `throw` statement with a method that throws an exception.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法上，您不一定需要`throw`和`throws`语句的组合来创建抛出异常（已检查或未检查）的方法。您可以用抛出异常的方法来替换`throw`语句。
- en: '|  |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.3.2\. Handle-or-declare rule
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.2\. 处理或声明规则
- en: 'To use a method that throws a *checked exception*, you must do one of the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用抛出已检查异常的方法，您必须执行以下操作之一：
- en: '***Handle the exception—*** Enclose the code within a `try` block and *catch*
    the thrown exception.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***处理异常——*** 将代码放在`try`块中，并*捕获*抛出的异常。'
- en: '***Declare it to be thrown—*** Declare the exception to be thrown by using
    the `throws` clause.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***声明抛出——*** 使用`throws`子句声明要抛出的异常。'
- en: '***Handle and declare—*** Implement both of the preceding options together.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***处理和声明——*** 同时实现上述两种选项。'
- en: '|  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: The rule of either handling or declaring an exception is also referred to as
    the *handle-or-declare rule*. To use a method that throws a checked exception,
    you must either handle the exception or declare it to be thrown. But this rule
    applies only to checked exceptions and not to unchecked exceptions.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 处理或声明异常的规则也被称为*处理或声明规则*。要使用抛出已检查异常的方法，您必须处理该异常或声明它将被抛出。但此规则仅适用于已检查异常，不适用于未检查异常。
- en: '|  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.3.3\. Creating a method that throws runtime exceptions or errors
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.3\. 创建抛出运行时异常或错误的方法
- en: When creating a method that throws a runtime exception or error, including the
    exception or error name in the `throws` clause isn’t required. A method that throws
    a runtime exception or error isn’t subject to the handle-or-declare rule.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个抛出运行时异常或错误的方法时，在`throws`子句中包含异常或错误名称不是必需的。抛出运行时异常或错误的方法不受处理或声明规则的限制。
- en: 'Let’s see this concept in action by modifying the preceding example so the
    `readFile()` method throws `NullPointerException` (a runtime exception) when a
    `null` value is passed to it (code changes are shown in bold in this example and
    throughout the rest of the chapter):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过修改前面的示例来观察这个概念的实际应用，使`readFile()`方法在传入`null`值时抛出`NullPointerException`（运行时异常）（本例中代码更改以粗体显示，并在本章的其余部分中显示）：
- en: '![](481fig01_alt.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](481fig01_alt.jpg)'
- en: 'The exam might trick you by including the names of runtime exceptions and errors
    in one method’s declaration and leaving them out in another. (You *can* include
    the name of unchecked exceptions in the `throws` clause, but you don’t have to.)
    Assuming that the rest of the code remains the same, the following method declaration
    is correct:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 考试可能会通过在一个方法的声明中包含运行时异常和错误的名称，而在另一个方法中省略它们来欺骗您。（您可以在`throws`子句中包含未检查异常的名称，但不必这样做。）假设其余代码保持不变，以下方法声明是正确的：
- en: '![](482fig01_alt.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](482fig01_alt.jpg)'
- en: '|  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Adding runtime exceptions or errors to a method’s declaration isn’t required.
    A method can throw a runtime exception or error irrespective of whether its name
    is included in its `throws` clause.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法声明中添加运行时异常或错误不是必需的。无论其名称是否包含在`throws`子句中，方法都可以抛出运行时异常或错误。
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.3.4\. A method can declare to throw all types of exceptions, even if it doesn’t
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.4\. 一个方法可以声明抛出所有类型的异常，即使它没有
- en: 'In the following example, the class `ThrowExceptions` defines multiple methods,
    which declare to throw different exception types. The class `ThrowExceptions`
    compiles successfully, even though its methods don’t include the code that might
    throw these exceptions:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`ThrowExceptions`类定义了多个方法，这些方法声明抛出不同的异常类型。即使`ThrowExceptions`类的方法不包含可能抛出这些异常的代码，该类也能成功编译：
- en: '[PRE2]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Although a `try` block can define a handler for unchecked exceptions not thrown
    by it, it can’t do so for checked exceptions (other than `Exception`):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一个`try`块可以定义一个处理它未抛出的未检查异常的处理程序，但它不能为检查异常（除了`Exception`）这样做：
- en: '![](482fig02_alt.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](482fig02_alt.jpg)'
- en: In the preceding code, `method6()`, `method7()`, `method8()`, and `method9()`
    compile even though their `try` block doesn’t define code to throw the exception
    being handled by its `catch` block. But `method10()` won’t compile.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`method6()`、`method7()`、`method8()`和`method9()`即使它们的`try`块没有定义代码来抛出由其`catch`块处理的异常，也能编译。但`method10()`不能编译。
- en: '|  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: A method can declare to throw any type of exception, checked or unchecked, even
    if it doesn’t do so. But a `try` block can’t define a `catch` block for a checked
    exception (other than `Exception`) if the `try` block doesn’t throw that checked
    exception or use a method that declares to throw that checked exception.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法可以声明抛出任何类型的异常，无论是检查的还是未检查的，即使它没有这样做。但是，如果`try`块没有抛出该检查异常或使用声明抛出该检查异常的方法，则`try`块不能为检查异常（除了`Exception`）定义一个`catch`块。
- en: '|  |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In the next section, we’ll detail what happens when an exception is thrown and
    how to handle that.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将详细说明抛出异常时会发生什么以及如何处理它。
- en: 7.4\. What happens when an exception is thrown?
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4. 抛出异常时会发生什么？
- en: '|  |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[[8.2](kindle_split_023.html#ch08lev1sec2)] Create a try-catch block and determine
    how exceptions alter normal program flow'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[[8.2](kindle_split_023.html#ch08lev1sec2)] 创建一个try-catch块并确定异常如何改变正常程序流程'
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[8.4] Create and invoke a method that throws an exception'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[8.4] 创建并调用一个抛出异常的方法'
- en: '|  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this section, we’ll uncover what happens when an exception is thrown in Java.
    We’ll work through several examples to understand how the normal flow of code
    is disrupted when an exception is thrown. We’ll also define an alternative program
    flow for code that may throw exceptions using `try`-`catch`-`finally` blocks.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将揭示在Java中抛出异常时会发生什么。我们将通过几个示例来了解当抛出异常时，代码的正常流程是如何被打断的。我们还将定义一个使用`try-catch-finally`块的替代程序流程，以处理可能抛出异常的代码。
- en: As with all other Java objects, an exception is an object. All types of exceptions
    subclass `java.lang.Throwable`. When a piece of code hits an obstacle in the form
    of an exceptional condition, it creates an object of the class `java.lang.Throwable`
    (at runtime, an object of the most appropriate subtype is created), initializes
    it with the necessary information (such as its type, an optional textual description,
    and the offending program’s state), and hands it over to the JVM. The JVM blows
    a siren in the form of this exception and looks for an appropriate code block
    that can “handle” this exception. The JVM keeps account of all the methods that
    were called when it hit the offending code, so to find an appropriate exception
    handler it looks through all the tracked method calls.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他Java对象一样，异常是一个对象。所有类型的异常都是`java.lang.Throwable`的子类。当一段代码遇到以异常条件形式出现的障碍时，它会创建一个`java.lang.Throwable`类的对象（在运行时，创建一个最合适的子类型对象），并用必要的信息（如其类型、可选的文本描述以及有问题的程序状态）初始化它，然后将它交给JVM。JVM通过这个异常发出警报，并寻找可以“处理”这个异常的适当代码块。JVM记录了它遇到有问题的代码时调用过的所有方法，因此为了找到一个适当的异常处理程序，它会查看所有跟踪的方法调用。
- en: Reexamine the class `Trace` and the `ArrayIndexOutOfBoundsException` thrown
    by it, as mentioned in [section 7.1.3](#ch07lev2sec3). [Figure 7.11](#ch07fig11)
    illustrates the propagation of the exception `ArrayIndexOutOfBoundsException`
    thrown by `method2` through all the methods.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 重新审视第7.1.3节中提到的`Trace`类及其抛出的`ArrayIndexOutOfBoundsException`异常。[图7.11](#ch07fig11)说明了`method2`抛出的`ArrayIndexOutOfBoundsException`异常通过所有方法的传播。
- en: Figure 7.11\. Propagation of an exception through multiple method calls
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.11. 异常通过多个方法调用的传播
- en: '![](07fig11_alt.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](07fig11_alt.jpg)'
- en: To understand how an exception propagates through method calls, it’s important
    to understand how method calls work. An application starts its execution with
    the method `main`, and `main` may call other methods. When `main` calls another
    method, the called method should complete its execution before `main` can complete
    its own execution.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解异常如何在方法调用中传播，了解方法调用的工作方式很重要。应用程序从 `main` 方法开始执行，`main` 可能会调用其他方法。当 `main`
    调用另一个方法时，被调用的方法应该在其完成执行之前，`main` 才能完成自己的执行。
- en: An operating system (OS) keeps track of the code that it needs to execute using
    a *stack*. A stack is a type of list in which the items that are added last to
    it are the first ones to be taken off it—last in, first out. This stack uses a
    *stack pointer* to point to the instructions that the OS should execute.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统（OS）使用一个 *栈* 来跟踪它需要执行的代码。栈是一种列表，其中最后添加到其中的项目是第一个被取出的——后进先出。这个栈使用一个 *栈指针*
    来指向操作系统应该执行的指令。
- en: 'Now that you have this basic information under your belt, here’s a step-by-step
    discussion of exception propagation, as shown in [figure 7.11](#ch07fig11):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了这些基本信息，下面将逐步讨论异常传播，如图 7.11 所示：
- en: When the method `main` starts its execution, its instructions are pushed onto
    the stack.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `main` 方法开始执行时，其指令被推入栈中。
- en: The method `main` calls the method `method1`, and instructions for `method1`
    are pushed onto the stack.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法 `main` 调用方法 `method1`，并将 `method1` 的指令推入栈中。
- en: '`method1` calls `method2`; instructions for `method2` are pushed onto the stack.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`method1` 调用 `method2`；`method2` 的指令被推入栈中。'
- en: '`method2` throws an exception: `ArrayIndexOutOfBoundsException`. Because `method2`
    doesn’t handle this exception itself, it’s passed to the method that called it—`method1`.'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`method2` 抛出一个异常：`ArrayIndexOutOfBoundsException`。因为 `method2` 没有自己处理这个异常，所以它被传递给了调用它的方法——`method1`。'
- en: '`method1` doesn’t define any exception handler for `ArrayIndexOutOfBounds-Exception`,
    so it hands this exception over to its calling method—`main`.'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`method1` 没有为 `ArrayIndexOutOfBounds-Exception` 定义任何异常处理器，所以它将这个异常传递给其调用方法——`main`。'
- en: There are no exception handlers for `ArrayIndexOutOfBoundsException` in `main`.
    Because there are no further methods that handle `ArrayIndexOutOfBounds-Exception`,
    execution of the class `Trace` stops.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 中没有为 `ArrayIndexOutOfBoundsException` 定义异常处理器。因为没有其他方法处理 `ArrayIndexOutOfBounds-Exception`，所以
    `Trace` 类的执行停止。
- en: You can use `try`-`catch`-`finally` blocks to define code to execute when an
    exception is thrown, as discussed in the next section.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `try`-`catch`-`finally` 块来定义当抛出异常时要执行的代码，如下一节所述。
- en: 7.4.1\. Creating try-catch-finally blocks
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.1\. 创建 try-catch-finally 块
- en: 'When you work with exception handlers, you often hear the terms `try`, `catch`,
    and `finally`. Before you start to work with these concepts, I’ll answer three
    simple questions:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理异常处理器时，你经常会听到 `try`、`catch` 和 `finally` 这些术语。在你开始使用这些概念之前，我会回答三个简单的问题：
- en: '*Try what?* First, you *try* to execute your code. If it doesn’t execute as
    planned, you handle the exceptional conditions using a `catch` block.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尝试什么？* 首先，你尝试执行你的代码。如果它没有按计划执行，你将使用 `catch` 块来处理异常情况。'
- en: '*Catch what?* You *catch* the exceptional event arising from the code enclosed
    within the `try` block and handle the event by defining appropriate exception
    handlers.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*捕获什么？* 你捕获 `try` 块内代码产生的异常事件，并通过定义适当的异常处理器来处理事件。'
- en: '*What does finally do?* Finally, you execute a set of code, in all conditions,
    regardless of whether the code in the `try` block throws any exceptions.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*finally 块的作用是什么？* 最后，你执行一组代码，在所有条件下，无论 `try` 块中的代码是否抛出任何异常。'
- en: Let’s compare a `try`-`catch`-`finally` block with a real-life example. Imagine
    you’re going river rafting on your vacation. Your instructor informs you that
    while rafting, you *might* fall off the raft into the river while crossing the
    rapids. In such a condition, you should try to use your oar or the rope thrown
    toward you to get back into the raft. You *might* also drop your oar into the
    river while rowing your raft. In such a condition, you should not panic and should
    stay seated. Whatever happens, you’re paying for this adventure sport.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个现实生活中的例子来比较 `try`-`catch`-`finally` 块。想象一下，你在度假期间去漂流。你的教练告诉你，在穿越急流时，你可能会从船上掉入河中。在这种情况下，你应该尝试使用你的浆或向你扔来的绳子回到船上。在划船的时候，你也可能会把浆掉入河中。在这种情况下，你不应该惊慌，应该保持坐姿。无论发生什么，你都在为这项冒险运动付费。
- en: 'Compare this to Java code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与 Java 代码进行比较：
- en: You can compare river rafting to a class whose methods *might* throw exceptions.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将划橡皮筏比作一个其方法 *可能会* 抛出异常的类。
- en: Crossing the rapids and rowing a raft are methods that *might* throw exceptions.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 穿越急流和划桨是可能会抛出异常的方法。
- en: Falling off the raft and dropping your oar are the exceptions.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从筏上掉下来和丢弃你的桨是异常情况。
- en: The steps for getting back into the raft and not panicking are the exception
    handlers—code that executes when an exception arises.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回到筏上并且不慌张的步骤是异常处理程序——当出现异常时执行的代码。
- en: The fact that you pay for the sport, whether you stay in the boat or not, can
    be compared to the `finally` block.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论你是否留在船上，你为这项运动支付的费用可以与 `finally` 块相比较。
- en: 'Let’s implement the previous real-life examples by defining appropriate classes
    and methods. To start with, here are two barebones exception classes—`FallInRiver-Exception`
    and `DropOarException`—that can be thrown by methods in the class `RiverRafting`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过定义适当的类和方法来实现之前的现实生活示例。首先，这里有两个基本的异常类——`FallInRiver-Exception` 和 `DropOarException`——这些异常可以被
    `RiverRafting` 类中的方法抛出：
- en: '[PRE3]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You can create an exception of your own—a custom exception—by extending the
    class `Exception` (or any of its subclasses). Although the creation of custom
    classes is not on this exam, you may see questions in the exam that create and
    use custom exceptions. Perhaps these are included because hardly any checked exceptions
    from the Java API are on this exam. Coding questions on the exam may create and
    use custom exceptions.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建自己的异常——一个自定义异常——通过扩展 `Exception` 类（或其任何子类）。尽管自定义类的创建不在此考试范围内，你可能会在考试中看到创建和使用自定义异常的问题。也许这些问题的存在是因为Java
    API中几乎没有已检查异常出现在这个考试中。考试中的编码问题可能会创建和使用自定义异常。
- en: '|  |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Following is a definition of class `RiverRafting`. Its methods `crossRapid`
    and `rowRaft` may throw exceptions of type `FallInRiverException` and `DropOarException`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对类 `RiverRafting` 的定义。它的方法 `crossRapid` 和 `rowRaft` 可能会抛出类型为 `FallInRiverException`
    和 `DropOarException` 的异常：
- en: '![](486fig01_alt.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](486fig01_alt.jpg)'
- en: The method `crossRapid` at ![](num-1.jpg) throws the exception `FallInRiverException`.
    When you call this method, you should define an exception handler for this exception.
    Similarly, the method `rowRaft` at ![](num-2.jpg) throws the exception `DropOarException`.
    When you call this method, you should define an exception handler for this exception.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ![](num-1.jpg) 处的 `crossRapid` 方法抛出异常 `FallInRiverException`。当你调用此方法时，你应该为此异常定义一个异常处理程序。同样，在
    ![](num-2.jpg) 处的 `rowRaft` 方法抛出异常 `DropOarException`。当你调用此方法时，你应该为此异常定义一个异常处理程序。
- en: When you execute methods that may throw *checked exceptions* (exceptions that
    don’t extend the class `RuntimeException`), enclose the code within a `try` block.
    `catch` blocks that follow a `try` block should handle all the checked exceptions
    thrown by the code enclosed in the `try` block (checked exceptions are covered
    in detail in [section 7.2.3](#ch07lev2sec6)).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行可能会抛出 *已检查异常*（不扩展 `RuntimeException` 类的异常）的方法时，应将代码放在 `try` 块中。跟在 `try`
    块后面的 `catch` 块应该处理 `try` 块中抛出的所有已检查异常（已检查异常在 [7.2.3节](#ch07lev2sec6) 中详细说明）。
- en: The code shown in [figure 7.12](#ch07fig12) uses the class `RiverRafting` as
    defined previously and depicts the flow of control when the code on line 3 (`riverRafting.crossRapid(11);`)
    throws an exception of type `FallInRiverException`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.12](#ch07fig12) 中显示的代码使用了之前定义的 `RiverRafting` 类，并描述了当第3行代码（`riverRafting.crossRapid(11);`）抛出类型为
    `FallInRiverException` 的异常时的控制流程。'
- en: Figure 7.12\. Modified flow of control when an exception is thrown
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.12\. 抛出异常时的修改后的控制流程
- en: '![](07fig12_alt.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig12_alt.jpg)'
- en: 'The example in [figure 7.12](#ch07fig12) shows how exceptions alter the normal
    program flow. If the code on line 3 throws an exception (`FallInRiverException`),
    the code on lines 4 and 5 won’t execute. In this case, control is transferred
    to the code block that handles `FallInRiverException`. Then control is transferred
    to the `finally` block. After the execution of the `finally` block, the code that
    follows the `try`-`catch`-`finally` block is executed. The output of the previous
    code is as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.12](#ch07fig12) 中的示例显示了异常如何改变正常的程序流程。如果第3行代码抛出异常（`FallInRiverException`），第4行和第5行代码将不会执行。在这种情况下，控制权转移到处理
    `FallInRiverException` 的代码块。然后控制权转移到 `finally` 块。在 `finally` 块执行完毕后，将执行 `try`-`catch`-`finally`
    块之后的代码。前述代码的输出如下：'
- en: '[PRE4]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you modify the previous example code as follows, no exceptions are thrown
    by the code on line 3 (modifications in bold):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将之前的示例代码修改如下，第 3 行的代码将不会抛出异常（粗体部分为修改）：
- en: '![](487fig01_alt.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](487fig01_alt.jpg)'
- en: 'The output of the previous code is as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的输出如下：
- en: '[PRE5]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What do you think the output of the code would be if the method `rowRaft` threw
    an exception? Try it for yourself!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为如果 `rowRaft` 方法抛出异常，代码的输出会是什么？自己试一试！
- en: '|  |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: The `finally` block executes regardless of whether the `try` block throws an
    exception.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: The `finally` block executes regardless of whether the `try` block throws an
    exception.
- en: '|  |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Single try block, multiple catch blocks, and a finally block
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 单个 `try` 块，多个 `catch` 块和一个 `finally` 块
- en: For a `try` block, you can define multiple `catch` blocks but only a single
    `finally` block. Multiple `catch` blocks are used to handle different types of
    exceptions. A `finally` block is used to define *cleanup* code—code that closes
    and releases resources, such as file handlers and database or network connections.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `try` 块，你可以定义多个 `catch` 块，但只能有一个 `finally` 块。多个 `catch` 块用于处理不同类型的异常。`finally`
    块用于定义 *清理* 代码——关闭和释放资源（如文件句柄、数据库或网络连接）的代码。
- en: When it comes to code, it makes sense to verify a concept by watching it in
    action. Let’s work through a simple example so that you can better understand
    how to use the `try`-`catch`-`finally` block.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到代码时，通过观察其运行情况来验证一个概念是有意义的。让我们通过一个简单的例子来了解一下如何使用 `try`-`catch`-`finally`
    块。
- en: In the following listing, the constructor of the class `FileInputStream` may
    throw a `FileNotFoundException`, and calling the method `read` on an object of
    `FileInputStream`, such as `fis`, may throw an `IOException`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，`FileInputStream` 类的构造函数可能会抛出 `FileNotFoundException`，在 `FileInputStream`
    对象（例如 `fis`）上调用 `read` 方法可能会抛出 `IOException`。
- en: Listing 7.1\. Code flow with multiple `catch` statements and a `finally` block
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.1\. 带有多个 `catch` 语句和 `finally` 块的代码流程
- en: '![](488fig01_alt.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](488fig01_alt.jpg)'
- en: '[Table 7.1](#ch07table01) compares the code output that occurs depending on
    whether the system is able or unable to open (and read) file.txt.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 7.1](#ch07table01) 比较了根据系统是否能够打开（和读取）file.txt 而发生的代码输出。'
- en: Table 7.1\. Output of code in [listing 7.1](#ch07lis01) when the system is unable
    to open file.txt and when the system is able to open file.txt but unable to read
    it
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 7.1\. 当系统无法打开 file.txt 时以及当系统能够打开 file.txt 但无法读取时的代码输出
- en: '| Output if the system is unable to open file.txt | Output if the system is
    able to open file.txt but unable to read it |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 系统无法打开 file.txt 时的输出 | 系统能够打开 file.txt 但无法读取时的输出 |'
- en: '| --- | --- |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| File not found finally Next task.. | File Opened File Closing Exception finally
    Next task.. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 文件未找到 finally 下一个任务.. | 文件已打开 文件关闭 异常 finally 下一个任务.. |'
- en: 'In either of the cases described in [table 7.1](#ch07table01), the `finally`
    block executes, and after its execution, control is transferred to the statement
    following the `try-catch` block. Here’s the output of the class `MultipleExceptions`
    if none of its code throws an exception:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [表 7.1](#ch07table01) 中描述的任何情况下，`finally` 块都会执行，并在其执行后，控制权转移到 `try-catch`
    块之后的语句。以下是 `MultipleExceptions` 类在没有代码抛出异常时的输出：
- en: '[PRE6]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It’s time now to attempt this chapter’s first Twist in the Tale exercise. When
    you execute the code in this exercise, you’ll understand what happens when you
    change the placement of the exception handlers (answers are in the appendix).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候尝试本章的第一个故事转折练习了。当你执行这个练习中的代码时，你会了解当你更改异常处理程序的位置时会发生什么（答案在附录中）。
- en: Twist in the Tale 7.1
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事转折 7.1
- en: Let’s modify the placement of the `finally` block in [listing 7.1](#ch07lis01)
    and see what happens.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 [列表 7.1](#ch07lis01) 中 `finally` 块的位置，看看会发生什么。
- en: Given that file.txt doesn’t exist on your system, what is the output of the
    following code?
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 假设系统上不存在 file.txt 文件，以下代码的输出是什么？
- en: '[PRE7]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code prints
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码打印
- en: '[PRE8]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code prints
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码打印
- en: '[PRE9]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code prints `File not found`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码打印 `文件未找到`。
- en: The code fails to compile.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码无法编译。
- en: 7.4.2\. Using a method that throws a checked exception
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.2\. 使用抛出检查异常的方法
- en: 'To use a method that throws a *checked exception*, you must follow the handle-or-declare
    rule ([section 7.3.2](#ch07lev2sec10)). In the following code, the method `main`
    in the class `TestRiverRafting` won’t compile because it doesn’t handle or declare
    the checked exception `FallInRiverException` declared to be thrown by the method
    `crossRapid`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用抛出 *检查型异常* 的方法，你必须遵循处理或声明规则（[第 7.3.2 节](#ch07lev2sec10)）。在以下代码中，类 `TestRiverRafting`
    中的 `main` 方法无法编译，因为它没有处理或声明由 `crossRapid` 方法声明的检查型异常 `FallInRiverException`：
- en: '![](490fig01_alt.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](490fig01_alt.jpg)'
- en: 'The `main` method in the classes `Handle`, `Declare`, and `HandleAndDeclare`
    compiles successfully because they follow the handle-or-declare rule:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Handle`、`Declare` 和 `HandleAndDeclare` 类中的 `main` 方法能够成功编译，因为它们遵循了处理或声明规则：
- en: '[PRE10]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|  |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: To use a method that throws a *checked exception*, you must follow the handle-or-declare
    rule.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用抛出 *检查型异常* 的方法，你必须遵循处理或声明规则。
- en: '|  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.4.3\. Using a method that throws a runtime exception
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.3\. 使用抛出运行时异常的方法
- en: 'If a method throws a runtime exception, the exception name isn’t required to
    be included in the method’s declaration (though it is allowed). To use a method
    that throws a runtime exception, you don’t need to follow the declare-or-handle
    rule. Here’s an example:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法抛出运行时异常，则不需要在方法声明中包含异常名称（尽管允许这样做）。要使用抛出运行时异常的方法，你不需要遵循声明或处理规则。以下是一个示例：
- en: '![](491fig01_alt.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](491fig01_alt.jpg)'
- en: 'Here’s another example. Examine the following code, which throws a runtime
    exception (`ArrayIndexOutOfBoundsException`):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子。检查以下代码，它抛出一个运行时异常（`ArrayIndexOutOfBoundsException`）：
- en: '![](492fig01_alt.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](492fig01_alt.jpg)'
- en: The preceding code doesn’t print output from `System.out.println("All seems
    to be well")`. The code execution halts with the exception thrown by the code
    that tries to output the value of `students[5]`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码没有从 `System.out.println("一切看起来都很顺利")` 打印输出。代码执行因尝试输出 `students[5]` 的值而抛出的异常而中断。
- en: 'It’s possible to create an exception handler for the exception `ArrayIndexOutOfBoundsException`
    thrown by the previous example code, as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为前述示例代码中抛出的 `ArrayIndexOutOfBoundsException` 异常创建一个异常处理器，如下所示：
- en: '[PRE11]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the previous code is as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的输出如下：
- en: '[PRE12]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the same way you can *catch* a checked exception, you can also catch a `Runtime-Exception`.
    On real projects, the preferred approach is to avoid runtime exceptions by including
    appropriate checks. For example, in the previous code, you can prevent `ArrayIndexOutOfBoundsException`
    from being thrown by using appropriate checks:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以 *捕获* 检查型异常，你也可以捕获 `Runtime-Exception`。在实际项目中，首选的方法是通过包含适当的检查来避免运行时异常。例如，在之前的代码中，你可以通过使用适当的检查来防止抛出
    `ArrayIndexOutOfBoundsException`：
- en: '![](492fig02_alt.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图片](492fig02_alt.jpg)'
- en: 7.4.4\. Using a method that throws an error
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.4\. 使用抛出错误的的方法
- en: Errors are serious exceptions thrown by the JVM, such as when it runs out of
    stack memory or can’t find the definition of a class. You shouldn’t define code
    to handle errors. You should instead let the JVM handle the errors.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是 JVM 抛出的严重异常，例如当 JVM 内存不足或找不到类的定义时。你不应该定义代码来处理错误。相反，你应该让 JVM 处理错误。
- en: In the remainder of this section, we’ll look at some frequently asked questions
    on `try`-`catch`-`finally` blocks that often overwhelm certification aspirants.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的剩余部分，我们将探讨一些关于 `try`-`catch`-`finally` 块的常见问题，这些问题常常让认证考生感到困惑。
- en: 7.4.5\. Will a finally block execute even if the catch block defines a return
    statement?
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.5\. 即使 catch 块定义了 return 语句，finally 块也会执行吗？
- en: 'Imagine the following scenario: a guy promises to buy diamonds for his girlfriend
    and treat her to coffee. The girl inquires about what will happen if he meets
    with an exceptional condition during the diamond purchase, such as inadequate
    funds. To the girl’s disappointment, the boy replies that he’ll still treat her
    to coffee.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 想象以下场景：一个男孩承诺为他的女朋友买钻石，并带她喝咖啡。女孩询问如果他在购买钻石时遇到异常情况，比如资金不足，会发生什么。让女孩失望的是，男孩回答说他会仍然带她喝咖啡。
- en: You can compare the `try` block to the purchase of diamonds and the `finally`
    block to the coffee treat. The girl gets the coffee treat regardless of whether
    the boy successfully purchases the diamonds. [Figure 7.13](#ch07fig13) shows this
    conversation.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `try` 块比作购买钻石，将 `finally` 块比作咖啡待遇。无论男孩是否成功购买钻石，女孩都会得到咖啡待遇。[图 7.13](#ch07fig13)
    展示了这次对话。
- en: Figure 7.13\. A little humor to help you remember that a `finally` block executes
    regardless of whether an exception is thrown
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.13\. 一点幽默来帮助你记住，`finally`块无论是否抛出异常都会执行
- en: '![](07fig13_alt.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig13_alt.jpg)'
- en: It’s interesting to note that a `finally` block will execute even if the code
    in the `try` block or any of the `catch` blocks defines a `return` statement.
    Examine the code in [figure 7.14](#ch07fig14) and its output, and note when the
    class `ReturnFromCatchBlock` is unable to open file.txt.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，即使`try`块或任何`catch`块中的代码定义了`return`语句，`finally`块也会执行。检查[图7.14](#ch07fig14)中的代码及其输出，并注意当类`ReturnFromCatchBlock`无法打开file.txt时。
- en: Figure 7.14\. The `finally` block executes even if an exception handler defines
    a `return` statement.
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.14\. 即使异常处理器定义了`return`语句，`finally`块也会执行。
- en: '![](07fig14_alt.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig14_alt.jpg)'
- en: As you can see from [figure 7.14](#ch07fig14)’s code output, the flow of control
    doesn’t return to the method `main` when the `return` statement executes in the
    `catch` handler of `FileNotFoundException`. It continues with the execution of
    the `finally` block before control is transferred back to the `main` method. Note
    that control isn’t transferred to the `println` statement `"Next task.. "` that
    follows the `try` block because the `return` statement is encountered in the `catch`
    block, as mentioned previously.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 从[图7.14](#ch07fig14)的代码输出中可以看出，当在`FileNotFoundException`的`catch`处理器中执行`return`语句时，控制流不会返回到`main`方法。它继续执行`finally`块，然后再将控制权转回到`main`方法。注意，控制权不会转移到`try`块后面的`println`语句`"Next
    task.. "`，因为如前所述，在`catch`块中遇到了`return`语句。
- en: 'Going back to the example of the guy and his girlfriend, a few tragic conditions,
    such as an earthquake or tornado, can cancel the coffee treat. Similarly, there
    are a few scenarios in Java in which a `finally` block does not execute:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 回到那个男生和他女朋友的例子，一些悲剧性的条件，比如地震或龙卷风，可以取消咖啡待遇。同样，在Java中也有一些场景，`finally`块不会执行：
- en: '*Application termination—*The `try` or the `catch` block executes `System.exit`,
    which immediately terminates the application.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用程序终止—*`try`或`catch`块执行`System.exit`，立即终止应用程序。'
- en: '***Fatal errors—*** A crash of the JVM or the OS occurs.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***致命错误—*** JVM或操作系统崩溃。'
- en: In the exam, you may be questioned on the correct order of two or more exception
    handlers. Does order matter? See for yourself in [section 7.4.9](#ch07lev2sec21).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在考试中，你可能会被问到两个或多个异常处理器的正确顺序。顺序重要吗？看看你自己[第7.4.9节](#ch07lev2sec21)。
- en: 7.4.6\. What happens if both a catch and a finally block define return statements?
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.6\. 如果`catch`和`finally`块都定义了返回语句会发生什么？
- en: In the previous section, you saw that the `finally` block executes even if a
    `catch` block defines a `return` statement. For a method that defines a `try`-`catch`-`finally`
    block, what is returned to the calling method if both `catch` and `finally` return
    a value?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你看到即使`catch`块定义了`return`语句，`finally`块也会执行。对于一个定义了`try`-`catch`-`finally`块的方法，如果`catch`和`finally`都返回一个值，调用方法会返回什么？
- en: 'Here’s an example:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '![](494fig01_alt.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](494fig01_alt.jpg)'
- en: The output of the preceding code is
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出是
- en: '[PRE13]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If both the `catch` and `finally` blocks define `return` statements, the calling
    method will receive a value from the `finally` block.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`catch`和`finally`块都定义了`return`语句，调用方法将从`finally`块接收一个值。
- en: 7.4.7\. What happens if a finally block modifies the value returned from a catch
    block?
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.7\. 如果`finally`块修改了从`catch`块返回的值会发生什么？
- en: 'If a `catch` block returns a primitive data type, the `finally` block can’t
    modify the value being returned by it. Here’s an example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`catch`块返回一个原始数据类型，`finally`块不能修改它返回的值。这里有一个例子：
- en: '![](495fig01_alt.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](495fig01_alt.jpg)'
- en: 'The output of the preceding code is as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE14]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Even though the `finally` block adds `10` to the variable `returnVal`, this
    modified value is not returned to the method `main`. Control in the `catch` block
    *copies* the value of `returnVal` to be returned before it executes the `finally`
    block, so the returned value is not modified when `finally` executes.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`finally`块给变量`returnVal`增加了`10`，这个修改后的值也不会返回到`main`方法。在执行`finally`块之前，`catch`块中的控制流会将`returnVal`的值复制并返回，所以当`finally`执行时，返回的值不会被修改。
- en: 'Will the preceding code behave in a similar manner if the method returns an
    object? See for yourself:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法返回一个对象，上述代码会以类似的方式行为吗？看看你自己：
- en: '![](496fig01_alt.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](496fig01_alt.jpg)'
- en: 'This is the output of the preceding code:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上述代码的输出：
- en: '[PRE15]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this case, the `catch` block returns an object of the class `StringBuilder`.
    When the `finally` block executes, it can access the value of the object referred
    to by the variable `returnVal` and can modify it. The modified value is returned
    to the method `main`. Remember that primitives are passed by value and objects
    are passed by reference.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`catch` 块返回 `StringBuilder` 类的对象。当 `finally` 块执行时，它可以访问由变量 `returnVal`
    指向的对象的值，并且可以修改它。修改后的值返回到 `main` 方法。记住，原始数据类型是按值传递的，而对象是按引用传递的。
- en: '|  |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: Watch out for code that returns a value from the `catch` block and modifies
    it in the `finally` block. If a `catch` block returns a primitive data type, the
    `finally` block can’t modify the value being returned by it. If a `catch` block
    returns an object, the `finally` block can modify the state of the object being
    returned by it.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意从 `catch` 块返回值并在 `finally` 块中修改它的代码。如果一个 `catch` 块返回一个原始数据类型，`finally` 块不能修改它返回的值。如果一个
    `catch` 块返回一个对象，`finally` 块可以修改它返回的对象的状态。
- en: '|  |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.4.8\. Can a try block be followed only by a finally block?
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.8\. 一个 try 块是否只能跟随一个 finally 块？
- en: 'Syntactically, you can define a `try` block that might only be followed by
    a `finally` block:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 语法上，你可以定义一个可能只跟随一个 `finally` 块的 `try` 块：
- en: '[PRE16]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here’s the output of the preceding code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '[PRE17]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Because `main()` in the preceding code throws an unchecked exception, `NullPointer-Exception`,
    it compiles successfully. But if the code enclosed within a `try` block declares
    to throw a checked exception, either it must be followed by a `catch` block, or
    the method in which it is defined must declare to throw it.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 因为前面代码中的 `main()` 抛出了一个未检查的异常 `NullPointer-Exception`，所以它编译成功。但如果 `try` 块中声明的代码抛出一个检查异常，则它必须后面跟着一个
    `catch` 块，或者定义它的方法必须声明抛出它。
- en: 7.4.9\. Does the order of the exceptions caught in the catch blocks matter?
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.9\. 在 catch 块中捕获的异常的顺序重要吗？
- en: Order doesn’t matter for unrelated classes. But it does matter for related classes
    sharing an IS-A relationship because `catch` blocks are checked from the top down
    to find a suitable one to handle a given exception.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无关的类，顺序并不重要。但对于具有 IS-A 关系的关联类，顺序很重要，因为 `catch` 块是从上到下检查以找到处理给定异常的合适块。
- en: In the latter case, if you try to catch an exception of the base class before
    an exception of the derived class, your code will fail to compile. This behavior
    may seem bizarre, but there’s a valid reason for it. As you know, an object of
    a derived class can be assigned to a variable of a base class. Similarly, if you
    try to catch an exception of a base class before its derived class, the exception
    handler for the derived class can never be reached, so the code will fail to compile.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在后一种情况下，如果你在派生类的异常之前尝试捕获基类的异常，你的代码将无法编译。这种行为可能看起来很奇怪，但有一个合理的理由。正如你所知，派生类的对象可以被分配给基类的变量。同样，如果你在派生类之前尝试捕获基类的异常，派生类的异常处理程序将永远无法到达，因此代码将无法编译。
- en: Examine the code in [figure 7.15](#ch07fig15), which has been modified by defining
    the `catch` block for `IOException` before the `catch` block for `FileNotFoundException`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 [图 7.15](#ch07fig15) 中的代码，它已经通过在 `FileNotFoundException` 的 `catch` 块之前定义
    `IOException` 的 `catch` 块而进行了修改。
- en: Figure 7.15\. The order of placement of exception handlers is important.
  id: totrans-344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.15\. 异常处理程序放置的顺序很重要。
- en: '![](07fig15_alt.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig15_alt.jpg)'
- en: '[Figure 7.16](#ch07fig16) depicts an interesting way to remember that order
    matters. As you know, a thrown exception looks for an appropriate exception handler,
    starting with the first handler and working toward the last. Let’s compare a thrown
    exception to a tiger and the exception handlers to doors that allow certain types
    of creatures to enter. Like a thrown exception, the tiger should start with the
    first door and move on to the rest of the doors until a match is found.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7.16](#ch07fig16) 展示了一种有趣的方式来记住顺序的重要性。正如你所知，抛出的异常会寻找合适的异常处理程序，从第一个处理程序开始，一直到最后一个。让我们将抛出的异常比作老虎，将异常处理程序比作允许某些类型的生物进入的门。就像抛出的异常一样，老虎应该从第一个门开始，然后继续到其余的门，直到找到匹配项。'
- en: Figure 7.16\. A visual way to remember that the order matters for exceptions
    caught in the `catch` blocks
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.16\. 一种视觉方式来记住在 `catch` 块中捕获的异常的顺序很重要
- en: '![](07fig16.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig16.jpg)'
- en: The tiger starts with the first door, which allows all animals to enter. Voilà!
    The tiger enters the first door and never reaches the second door, which is meant
    specifically for tigers. In Java, when such a condition arises, the Java compiler
    refuses to compile the code because the later exception handler code will never
    execute. Java doesn’t compile code if it contains unreachable statements.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 老虎从第一个门开始，允许所有动物进入。哇！老虎进入了第一个门，永远不会到达专为老虎准备的第二个门。在Java中，当出现这种情况时，Java编译器会拒绝编译代码，因为后续的异常处理代码将永远不会执行。如果代码中包含不可达的语句，Java不会编译代码。
- en: Rules to remember
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 需要记住的规则
- en: 'Here are a few more rules you’ll need to answer the questions in the OCA Java
    SE 8 Programmer I exam:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些规则，你需要回答OCA Java SE 8程序员I考试中的问题：
- en: A `try` block may be followed by multiple `catch` blocks, and the `catch` blocks
    may be followed by a single `finally` block.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`try`块可以后面跟着多个`catch`块，而`catch`块后面可以跟着一个单独的`finally`块。
- en: A `try` block may be followed by either a `catch` or a `finally` block or both.
    But a `finally` block alone won’t suffice if code in the `try` block throws a
    checked exception. In this case, you need to catch the checked exception or declare
    it to be thrown by your method. Otherwise, your code won’t compile.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`try`块可以后面跟着一个`catch`块或一个`finally`块，或者两者都有。但如果`try`块中的代码抛出一个受检异常，单独的`finally`块是不够的。在这种情况下，你需要捕获受检异常或声明你的方法会抛出它。否则，你的代码无法编译。
- en: The `try`, `catch`, and `finally` blocks can’t exist independently.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`、`catch`和`finally`块不能独立存在。'
- en: The `finally` block can’t appear before a `catch` block.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finally`块不能出现在`catch`块之前。'
- en: A `finally` block always executes, regardless of whether the code throws an
    exception.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finally`块总是执行，无论代码是否抛出异常。'
- en: 7.4.10\. Can I rethrow an exception or the error I catch?
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.10\. 我能否重新抛出一个异常或我捕获的错误？
- en: 'You can do whatever you want with an exception. Rethrow it, pass it on to a
    method, assign it to another variable, upload it to a server, send it in an SMS,
    and so on. Examine the following code:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对异常做任何你想做的事情。重新抛出它，将其传递给一个方法，将其赋值给另一个变量，上传到服务器，通过短信发送，等等。检查以下代码：
- en: '![](499fig01_alt.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](499fig01_alt.jpg)'
- en: 'Oops! The previous code fails to compile, and you get the following compilation
    error message:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！之前的代码无法编译，你得到了以下编译错误信息：
- en: '[PRE18]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When you rethrow a checked exception, it’s treated like a regular thrown checked
    exception, meaning that all the rules of handling a checked exception apply to
    it. In the previous example, the code neither caught the rethrown `FileNotFoundException`
    exception nor declared that the method `myMethod` would throw it using the `throw`
    clause. Hence, the code failed to compile.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 当你重新抛出一个受检异常时，它会被当作一个常规的抛出的受检异常来处理，这意味着处理受检异常的所有规则都适用于它。在先前的例子中，代码既没有捕获重新抛出的`FileNotFoundException`异常，也没有使用`throw`子句声明方法`myMethod`会抛出它。因此，代码无法编译。
- en: 'The following (modified) code declares that the method `myMethod` throws a
    `FileNotFoundException`, and it compiles successfully:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 以下（修改后的）代码声明方法`myMethod`会抛出`FileNotFoundException`，并且可以成功编译：
- en: '![](499fig02_alt.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](499fig02_alt.jpg)'
- en: Another interesting point to note is that the previous code doesn’t apply to
    a `Runtime-Exception`. You can rethrow a runtime exception, but you’re not required
    to catch it, nor must you modify your method signature to include the `throws`
    clause. The simple reason for this rule is that `RuntimeException`s aren’t checked
    exceptions, and they may not be caught or declared to be thrown by your code (exception
    categories are discussed in detail in [section 7.2](#ch07lev1sec2)).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的有趣点是，之前的代码不适用于`RuntimeException`。你可以重新抛出一个运行时异常，但不需要捕获它，也不需要修改你的方法签名以包含`throws`子句。这个规则简单的原因是`RuntimeException`不是受检异常，它们可能不会被你的代码捕获或声明为抛出（异常类别在[第7.2节](#ch07lev1sec2)中详细讨论）。
- en: 7.4.11\. Can I declare my methods to throw a checked exception instead of handling
    it?
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.11\. 我能否声明我的方法抛出一个受检异常而不是处理它？
- en: 'If a method doesn’t wish to handle the checked exceptions thrown by a method
    it calls, it can declare to *throw* these exceptions using the `throws` clause
    in its own method declaration. Examine the following example, in which the method
    `myMethod` doesn’t include an exception handler; instead, it rethrows the `IOException`
    thrown by a constructor of the class `FileInputStream` using the `throws` clause
    in its declaration:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法不希望处理它调用的方法抛出的受检异常，它可以在自己的方法声明中使用`throws`子句来声明抛出这些异常。考察以下示例，其中方法`myMethod`没有包含异常处理器；相反，它使用声明中的`throws`子句重新抛出由`FileInputStream`类的构造函数抛出的`IOException`：
- en: '![](500fig01_alt.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](500fig01_alt.jpg)'
- en: Any method that calls `myMethod` must now either catch the exception `IOException`
    or declare that it will be rethrown in its method signature.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 任何调用`myMethod`的方法现在必须要么捕获异常`IOException`，要么在其方法签名中声明它将被重新抛出。
- en: 7.4.12\. I can create nested loops, so can I create nested try-catch blocks
    too?
  id: totrans-370
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.12\. 我可以创建嵌套循环，那么我也能创建嵌套的`try`-`catch`块吗？
- en: The simple answer is yes, you can define a `try`-`catch`-`finally` block within
    another `try`-`catch`-`finally` block. Theoretically, the levels of nesting for
    the `try`-`catch`-`finally` blocks have no limits.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的答案是肯定的，你可以在另一个`try`-`catch`-`finally`块内定义一个`try`-`catch`-`finally`块。理论上，`try`-`catch`-`finally`块的嵌套级别没有限制。
- en: 'In the following example, another set of `try`-`catch` blocks is defined in
    the `try` and `finally` blocks of the outer `try` block:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，在外部`try`块的`try`和`finally`块中定义了另一组`try`-`catch`块：
- en: '![](500fig02_alt.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](500fig02_alt.jpg)'
- en: Now comes another Twist in the Tale exercise that’ll test your understanding
    of the exceptions thrown and caught by nested `try`-`catch` blocks. In this one,
    an inner `try` block defines code that throws a `NullPointerException`. But the
    inner `try` block doesn’t define an exception handler for this exception. Will
    the outer `try` block catch this exception? See for yourself (answer in the appendix).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来一个Twist in the Tale练习，这将测试你对嵌套`try`-`catch`块抛出和捕获的异常的理解。在这个练习中，内部`try`块定义了抛出`NullPointerException`的代码。但内部`try`块没有为这个异常定义异常处理器。外部`try`块会捕获这个异常吗？亲自看看（答案见附录）。
- en: Twist in the Tale 7.2
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Twist in the Tale 7.2
- en: Given that players.txt exists on your system and that the assignment of `players`,
    shown in bold, doesn’t throw any exceptions, what’s the output of the following
    code?
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的系统上存在`players.txt`文件，并且如粗体所示，`players`的分配不会抛出任何异常，那么以下代码的输出是什么？
- en: '[PRE19]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code prints
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码打印
- en: '[PRE20]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code prints
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码打印
- en: '[PRE21]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The code throws a runtime exception.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码抛出一个运行时异常。
- en: The code fails to compile.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码无法编译。
- en: 7.4.13\. Should I handle errors?
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.4.13\. 我应该处理错误吗？
- en: 'Although you can define code to handle errors, you shouldn’t. You should instead
    let the JVM handle the errors. The following example shows how it’s possible to
    catch an error:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以定义代码来处理错误，但你不应该这样做。相反，你应该让JVM处理错误。以下示例显示了如何捕获错误：
- en: '![](502fig01_alt.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](502fig01_alt.jpg)'
- en: Though you shouldn’t handle errors in your code, what happens if you do? Will
    the exception handler that handles the code execute? See for yourself by answering
    the question in the following Twist in the Tale exercise (answer in the appendix).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你不应该在代码中处理错误，但如果你这样做会发生什么？处理代码的异常处理器会执行吗？通过回答以下故事中的Twist in the Tale练习来亲自看看（答案见附录）。
- en: Twist in the Tale 7.3
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Twist in the Tale 7.3
- en: Will the code in the error-handling block execute? What do you think is the
    output of the following code?
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理块中的代码会执行吗？你认为以下代码的输出是什么？
- en: '[PRE22]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the next section, you’ll work with specific exception classes and errors
    that are on the exam.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将处理考试中的特定异常类和错误。
- en: 7.5\. Common exception classes and categories
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5\. 常见异常类和类别
- en: '|  |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[8.5] “Recognize common exception classes (such as NullPointerException, ArithmeticException,
    ArrayIndexOutOfBoundsException, ClassCastException)”'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[8.5] “识别常见异常类（如NullPointerException、ArithmeticException、ArrayIndexOutOfBoundsException、ClassCastException）”'
- en: '|  |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this section, we’ll take a look at common exception classes and categories
    of exceptions. You’ll also learn about the scenarios in which these exceptions
    are thrown and how to handle them.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看常见的异常类和异常类别。你还将了解这些异常被抛出的场景以及如何处理它们。
- en: For this exam, you should be familiar with the scenarios that lead to these
    commonly thrown exception classes and categories and how to handle them. [Table
    7.2](#ch07table02) lists common errors and exceptions. Although the exam specifically
    lists four runtime exceptions, you might see the other common exception and error
    classes on the exam.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这次考试，您应该熟悉导致这些常见异常类和类别的情况以及如何处理它们。[表7.2](#ch07table02)列出了常见错误和异常。尽管考试具体列出了四个运行时异常，但在考试中您可能会看到其他常见的异常和错误类。
- en: Table 7.2\. Common errors and exceptions
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表7.2. 常见错误和异常
- en: '| Runtime exceptions | Errors |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| 运行时异常 | 错误 |'
- en: '| --- | --- |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ArrayIndexOutOfBoundsException | ExceptionInInitializerError |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| ArrayIndexOutOfBoundsException | ExceptionInInitializerError |'
- en: '| IndexOutOfBoundsException | StackOverflowError |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| IndexOutOfBoundsException | StackOverflowError |'
- en: '| ClassCastException | NoClassDefFoundError |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| ClassCastException | NoClassDefFoundError |'
- en: '| IllegalArgumentException | OutOfMemoryError |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| IllegalArgumentException | OutOfMemoryError |'
- en: '| ArithmeticException |   |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| ArithmeticException |   |'
- en: '| NullPointerException |   |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| NullPointerException |   |'
- en: '| NumberFormatException |   |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| NumberFormatException |   |'
- en: The OCA Java SE 8 Programmer I exam objectives require that you understand which
    of the previously mentioned errors and exceptions are thrown by the JVM and which
    should be thrown programmatically. From the discussion of errors earlier in this
    chapter, you know that errors represent issues associated with the JRE, such as
    `OutOfMemoryError`. As a programmer, you *shouldn’t* throw or catch these errors—leave
    them for the JVM. The definition of runtime exceptions notes that these are the
    kinds of exceptions that are thrown by the JVM, which shouldn’t be thrown by you
    programmatically.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: OCA Java SE 8程序员I级考试目标要求您理解之前提到的哪些错误和异常是由JVM抛出的，哪些应该通过程序抛出。从本章前面关于错误的讨论中，您知道错误代表与JRE相关的问题，例如`OutOfMemoryError`。作为程序员，您**不应该**抛出或捕获这些错误——让JVM处理。运行时异常的定义指出，这些是JVM抛出的异常，您不应该在程序中抛出。
- en: Let’s review each of these in detail.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一详细回顾这些内容。
- en: 7.5.1\. ArrayIndexOutOfBoundsException and IndexOutOfBoundsException
  id: totrans-414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.1. `ArrayIndexOutOfBoundsException`和`IndexOutOfBoundsException`
- en: As shown in [figure 7.17](#ch07fig17), `ArrayIndexOutOfBoundsException` and
    `IndexOutOfBounds-Exception` are runtime exceptions, which share an IS-A relationship.
    `IndexOutOfBoundsException` is subclassed by `ArrayIndexOutOfBoundsException`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图7.17](#ch07fig17)所示，`ArrayIndexOutOfBoundsException`和`IndexOutOfBounds-Exception`是运行时异常，它们之间存在IS-A关系。`IndexOutOfBoundsException`是`ArrayIndexOutOfBoundsException`的子类。
- en: Figure 7.17\. Class hierarchy of `ArrayIndexOutOfBoundsException`
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '![图7.17](#ch07fig17) 类`ArrayIndexOutOfBoundsException`的类层次结构'
- en: '![](07fig17.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig17.jpg)'
- en: An `ArrayIndexOutOfBoundsException` is thrown when a piece of code tries to
    access an array out of its bounds (either an array is accessed at a position less
    than 0 or at a position greater than or equal to its length). An `IndexOutOfBoundsException`
    is thrown when a piece of code tries to access a list, like an `ArrayList`, using
    an illegal index.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 当一段代码尝试访问超出其边界的数组（数组被访问的位置小于0或大于或等于其长度）时，将抛出`ArrayIndexOutOfBoundsException`异常。当一段代码尝试使用非法索引访问列表，如`ArrayList`时，将抛出`IndexOutOfBoundsException`异常。
- en: 'Assume that an array and list have been defined as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 假设已经定义了一个数组和列表，如下所示：
- en: '[PRE27]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following lines of code will throw an `ArrayIndexOutOfBoundsException`:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行将抛出`ArrayIndexOutOfBoundsException`异常：
- en: '![](504fig01_alt.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![图片](504fig01_alt.jpg)'
- en: 'The following lines of code will throw an `IndexOutOfBoundsException`:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行将抛出`IndexOutOfBoundsException`异常：
- en: '![](504fig02_alt.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![图片](504fig02_alt.jpg)'
- en: Why do you think the JVM has taken the responsibility on itself to throw this
    exception? One of the main reasons is that this exception isn’t known until runtime
    and depends on the array or list position that’s being accessed by a piece of
    code. Most often, a variable is used to specify this array or list position, and
    its value may not be known until runtime.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 您认为JVM为什么承担了抛出这个异常的责任？其中一个主要原因是这个异常直到运行时才知道，并且依赖于代码访问的数组或列表位置。通常，一个变量用于指定这个数组或列表位置，其值可能直到运行时才知道。
- en: '|  |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-427
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: When you try to access an invalid array position, `ArrayIndexOutOfBoundsException`
    is thrown. When you try to access an invalid `ArrayList` position, `IndexOutOfBoundsException`
    is thrown.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试访问无效的数组位置时，将抛出`ArrayIndexOutOfBoundsException`异常。当尝试使用非法索引访问`ArrayList`等列表时，将抛出`IndexOutOfBoundsException`异常。
- en: '|  |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You can avoid these exceptions from being thrown if you check whether the index
    position you’re trying to access is greater than or equal to `0` and less than
    the size of your array or `ArrayList`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查你要尝试访问的索引位置是否大于或等于 `0` 并且小于你的数组或 `ArrayList` 的大小，你可以避免抛出这些异常。
- en: 7.5.2\. ClassCastException
  id: totrans-431
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.2\. `ClassCastException`
- en: Before I start discussing the example I’ll use for this exception, take a quick
    look at [figure 7.18](#ch07fig18) to review the class hierarchy of this exception.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在我开始讨论这个异常的例子之前，快速看一下 [图 7.18](#ch07fig18) 以复习这个异常的类层次结构。
- en: Figure 7.18\. Class hierarchy of `ClassCastException`
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.18\. `ClassCastException` 的类层次结构
- en: '![](07fig18.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig18.jpg)'
- en: Examine the code in the next listing, where the line of code that throws the
    `ClassCastException` is shown in bold.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 检查下一列表中的代码，其中抛出 `ClassCastException` 的代码行以粗体显示。
- en: Listing 7.2\. An example of code that throws `ClassCastException`
  id: totrans-436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.2\. 抛出 `ClassCastException` 的代码示例
- en: '![](505fig01_alt.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![图片](505fig01_alt.jpg)'
- en: A `ClassCastException` is thrown when an object fails an IS-A test with the
    class type to which it’s being cast. In the preceding example, class `Ink` is
    the base class for classes `ColorInk` and `BlackInk`. The JVM throws a `ClassCastException`
    in the previous case because the code in bold tries to explicitly cast an object
    of `ColorInk` to `BlackInk`.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象在类型转换时失败 IS-A 测试时，会抛出 `ClassCastException`。在先前的例子中，类 `Ink` 是 `ColorInk`
    和 `BlackInk` 类的基类。在先前的案例中，JVM 抛出 `ClassCastException`，因为粗体部分的代码试图显式地将 `ColorInk`
    类型的对象转换为 `BlackInk` 类型。
- en: 'Note that this line of code avoided the compilation error because the variable
    `inks` defines an `ArrayList` of type `Ink`, which can store objects of type `Ink`
    and all its subclasses. The code then correctly adds the permitted objects: one
    each of `BlackInk` and `ColorInk`. If the code had defined an `ArrayList` of type
    `BlackInk` or `ColorInk`, the code would have failed the compilation, as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此代码行避免了编译错误，因为变量 `inks` 定义了一个类型为 `Ink` 的 `ArrayList`，它可以存储 `Ink` 类型的对象及其所有子类的对象。然后代码正确地添加了允许的对象：一个
    `BlackInk` 和一个 `ColorInk`。如果代码定义了一个类型为 `BlackInk` 或 `ColorInk` 的 `ArrayList`，则代码将无法编译，如下所示：
- en: '![](506fig01_alt.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![图片](506fig01_alt.jpg)'
- en: 'Here’s the compilation error thrown by the previously modified piece of code:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前修改过的代码块抛出的编译错误：
- en: '[PRE28]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can use the `instanceof` operator to verify whether an object can be cast
    to another class before casting it. Assuming that the definition of classes `Ink`,
    `ColorInk`, and `BlackInk` are the same as defined in the previous example, the
    following lines of code will avoid the `ClassCastException`:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在类型转换之前使用 `instanceof` 操作符来验证一个对象是否可以被转换为另一个类。假设 `Ink`、`ColorInk` 和 `BlackInk`
    类的定义与先前的例子中相同，以下代码行将避免 `ClassCastException`：
- en: '![](506fig02_alt.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![图片](506fig02_alt.jpg)'
- en: In the previous example, the condition (`inks.get(0)instanceofBlackInk`) evaluates
    to `false`, so the `then` part of the `if` statement doesn’t execute.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，条件 (`inks.get(0)instanceofBlackInk`) 评估为 `false`，因此 `if` 语句的 `then`
    部分不会执行。
- en: In the following Twist in the Tale exercise, I’ll introduce an interface used
    in the casting example in [listing 7.2](#ch07lis02) (answer in the appendix).
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的 Twist in the Tale 练习中，我将介绍在 [列表 7.2](#ch07lis02) 中的类型转换例子中使用的接口（答案见附录）。
- en: Twist in the Tale 7.4
  id: totrans-447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事转折 7.4
- en: 'Let’s introduce an interface used in [listing 7.2](#ch07lis02) and see how
    it behaves. Following is the modified code. Examine the code and select the correct
    options:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍一个在 [列表 7.2](#ch07lis02) 中使用的接口，并看看它的行为。以下是修改后的代码。检查代码并选择正确的选项：
- en: '[PRE29]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`printable = (Printable)blackInk` will throw compilation error'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`printable = (Printable)blackInk` 将会抛出编译错误'
- en: '`printable = (Printable)blackInk` will throw runtime exception'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`printable = (Printable)blackInk` 将会抛出运行时异常'
- en: '`printable = (Printable)blackInk` will throw checked exception'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`printable = (Printable)blackInk` 将会抛出检查异常'
- en: 'The following line of code will fail to compile:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码行将无法编译：
- en: '[PRE30]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 7.5.3\. IllegalArgumentException
  id: totrans-455
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.3\. `IllegalArgumentException`
- en: As the name of this exception suggests, `IllegalArgumentException` is thrown
    to specify that a method has passed illegal or inappropriate arguments. Its class
    hierarchy is shown in [figure 7.19](#ch07fig19).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 如同这个异常的名称所暗示的，`IllegalArgumentException` 被抛出以指定一个方法传递了非法或不适当的参数。其类层次结构如图 7.19
    所示。
- en: Figure 7.19\. Class hierarchy of `IllegalArgumentException`
  id: totrans-457
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.19\. `IllegalArgumentException` 的类层次结构
- en: '![](07fig19.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig19.jpg)'
- en: 'Even though it’s a runtime exception, programmers usually use this exception
    to validate the arguments that are passed to a method. The exception constructor
    is passed a descriptive message, specifying the exception details. Examine the
    following code:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个运行时异常，但程序员通常使用这个异常来验证传递给方法的参数。异常构造函数传递了一个描述性的消息，指定了异常的详细信息。请检查以下代码：
- en: '[PRE31]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The previous method validates the various method parameters passed to it and
    throws an appropriate `IllegalArgumentException` if they don’t meet the requirements
    of the method. Each object of the `IllegalArgumentException` is passed a different
    `String` message that briefly describes it.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方法验证了传递给它的各种方法参数，如果它们不符合方法的要求，则抛出适当的 `IllegalArgumentException`。`IllegalArgumentException`
    的每个对象都传递了一个不同的 `String` 消息，简要描述了它。
- en: 7.5.4\. NullPointerException
  id: totrans-462
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.4\. `NullPointerException`
- en: The `NullPointerException`, shown in [figure 7.20](#ch07fig20), is the quintessential
    exception.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 7.20](#ch07fig20) 所示的 `NullPointerException` 是一个典型的异常。
- en: Figure 7.20\. Class hierarchy of `NullPointerException`
  id: totrans-464
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.20\. `NullPointerException` 的类层次结构
- en: '![](07fig20.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig20.jpg)'
- en: I imagine that almost all Java programmers have had a taste of this exception,
    but let’s look at an explanation for it.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 我想象几乎所有 Java 程序员都尝过这个异常的滋味，但让我们来看看它的解释。
- en: 'This exception is thrown by the JVM if you try to access a non-static method
    or a variable through a `null` value. The exam can have interesting code combinations
    to test you on whether a particular piece of code will throw a `NullPointerException`.
    The key is to ensure that the reference variable has been assigned a non-`null`
    value. In particular, I’ll address the following cases:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试通过 `null` 值访问非静态方法或变量，JVM 会抛出这个异常。考试可能会有有趣的代码组合来测试您是否会在特定的代码片段中抛出 `NullPointerException`。关键是确保引用变量已被分配了一个非
    `null` 值。特别是，我将讨论以下情况：
- en: Accessing members of a reference variable that is explicitly assigned a `null`
    value
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问显式分配了 `null` 值的引用变量的成员
- en: Using an uninitialized local variable, which may *seem* to throw a `NullPointerException`
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未初始化的局部变量，这可能会 *看似* 抛出 `NullPointerException`
- en: Attempting to access nonexistent array positions
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试访问不存在的数组位置
- en: Using members of an array element that are assigned a `null` value
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分配了 `null` 值的数组元素的成员
- en: 'Let’s get started with the first case, in which a variable is explicitly assigned
    a `null` value:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一种情况开始，其中变量被显式地分配了一个 `null` 值：
- en: '![](508fig01_alt.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![](508fig01_alt.jpg)'
- en: 'The preceding code tries to access the method `add` on the variable `list`,
    which has been assigned a `null` value. It throws an exception, as follows:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码尝试访问变量 `list` 上的 `add` 方法，而该变量已被分配了一个 `null` 值。这会抛出一个异常，如下所示：
- en: '[PRE32]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'By default, the `static` and instance variables of a class are assigned a `null`
    value. In the previous example, the `static` variable `list` is assigned an explicit
    `null` value. To help you clarify the code and avoid any possible doubt, `list`
    is assigned an explicit `null` value. When the method `main` tries to execute
    the method `add` on the variable `list`, it calls a method on a `null` value.
    This call causes the JVM to throw a `Null-Pointer-Exception` (which is a `RuntimeException`).
    If you define the variable `list` as an instance variable and don’t assign an
    explicit value to it, you’ll get the same result (`NullPointerException` being
    thrown at runtime). Because the `static` method `main` can’t access the instance
    variable `list`, you’ll need to create an object of the class `ThrowNullPointerException`
    to access it:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，类的 `static` 和实例变量被分配一个 `null` 值。在之前的例子中，`static` 变量 `list` 被显式地分配了一个 `null`
    值。为了帮助您澄清代码并避免任何可能的疑问，`list` 被显式地分配了一个 `null` 值。当 `main` 方法尝试在变量 `list` 上执行 `add`
    方法时，它会在一个 `null` 值上调用一个方法。这个调用会导致 JVM 抛出一个 `Null-Pointer-Exception`（这是一个 `RuntimeException`）。如果您将变量
    `list` 定义为一个实例变量并且没有给它分配一个显式值，您将得到相同的结果（在运行时抛出 `NullPointerException`）。因为 `static`
    方法 `main` 无法访问实例变量 `list`，您需要创建 `ThrowNullPointerException` 类的一个对象来访问它：
- en: '![](509fig01_alt.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![](509fig01_alt.jpg)'
- en: 'You can prevent a `NullPointerException` from being thrown by checking whether
    an object is `null` before trying to access its member:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在尝试访问对象的成员之前检查该对象是否为 `null` 来防止抛出 `NullPointerException`：
- en: '![](509fig02_alt.jpg)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
  zh: '![](509fig02_alt.jpg)'
- en: What happens if you modify the previous code as follows? Will it still throw
    a `NullPointerException`?
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将之前的代码修改如下，会发生什么？它还会抛出 `NullPointerException` 吗？
- en: '![](509fig03.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![](509fig03.jpg)'
- en: Interestingly, the previous code fails to compile. `list` is defined as a local
    variable inside the method `main`, and by default local variables aren’t assigned
    a value—not even a `null` value. If you attempt to use an uninitialized local
    variable, your code will fail to compile. Watch out for similar questions in the
    exam.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，之前的代码无法编译。`list`是在`main`方法内部定义的局部变量，并且默认情况下局部变量没有赋予值——甚至没有`null`值。如果你尝试使用未初始化的局部变量，你的代码将无法编译。在考试中注意类似的问题。
- en: 'Another set of conditions when code may throw the `NullPointerException` involves
    the use of arrays:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码可能抛出`NullPointerException`的另一组条件涉及数组的使用：
- en: '![](510fig01_alt.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![图片](510fig01_alt.jpg)'
- en: In the preceding code, the static variable `oldLaptops` is assigned a `null`
    value by default. Its array elements are neither initialized nor assigned a value.
    The code that tries to access the array’s second element throws a `NullPointerException`.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，静态变量`oldLaptops`默认赋予`null`值。它的数组元素既未初始化也未赋予值。尝试访问数组第二个元素的代码将抛出`NullPointerException`。
- en: 'In the following code, two array elements of the variable `newLaptops` are
    initialized and assigned a default value of `null`. If you call the method `toString`
    on the second element of the variable `newLaptops`, it results in a `NullPointerException`
    being thrown:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，变量`newLaptops`的两个数组元素被初始化并赋予默认值`null`。如果你在变量`newLaptops`的第二元素上调用`toString`方法，它将导致抛出`NullPointerException`：
- en: '![](510fig02_alt.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![图片](510fig02_alt.jpg)'
- en: 'If you modify the code at ![](num-1.jpg) as follows, it won’t throw an exception—it’ll
    print the value `null`. This is because the object-based `System.out.println()`
    overload calls the object-based `String.valueOf()` overload, which itself checks
    whether the object to “print” is `null`, in which case it will output `null` without
    calling any `toString()` method:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将代码在![图片](num-1.jpg)处进行修改如下，它不会抛出异常——它将打印值`null`。这是因为基于对象的`System.out.println()`重载调用了基于对象的`String.valueOf()`重载，它本身会检查要“打印”的对象是否为`null`，如果是，则输出`null`而不会调用任何`toString()`方法：
- en: '![](510fig03_alt.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![图片](510fig03_alt.jpg)'
- en: '|  |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-491
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: In the exam, watch out for code that tries to use an uninitialized local variable.
    Because such variables aren’t initialized with even a `null` value, you can’t
    print their value using the `System.out.println` method. Such code *won’t* compile.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在考试中，请注意那些尝试使用未初始化局部变量的代码。因为这样的变量甚至没有初始化为`null`值，所以你不能使用`System.out.println`方法打印它们的值。这样的代码*无法*编译。
- en: '|  |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Let’s modify the previous code that uses the variable `oldLaptops` and check
    your understanding of `NullPointerException`s. Here’s another Twist in the Tale
    hands-on exercise for you (answers in the appendix).
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前使用变量`oldLaptops`的代码，并检查你对`NullPointerException`的理解。这里有一个故事转折的动手练习供你完成（答案见附录）。
- en: Twist in the Tale 7.5
  id: totrans-495
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 故事转折7.5
- en: Let’s check your understanding of the `NullPointerException`. Here’s a code
    snippet. Examine the code and select the correct answers.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查你对`NullPointerException`的理解。这里有一个代码片段。检查代码并选择正确的答案。
- en: '[PRE33]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Code on line 1 will throw `NullPointerException`
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第1行的代码将抛出`NullPointerException`
- en: Code on lines 1 and 3 will throw `NullPointerException`
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第1行和第3行的代码将抛出`NullPointerException`
- en: Only code on line 4 will throw `NullPointerException`
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有第4行的代码将抛出`NullPointerException`
- en: Code on lines 3 and 5 will throw `NullPointerException`
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第3行和第5行的代码将抛出`NullPointerException`
- en: 7.5.5\. ArithmeticException
  id: totrans-502
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.5. `ArithmeticException`
- en: When the JVM encounters an exceptional mathematical condition, like dividing
    an integer by zero, it throws `ArithmeticException` (the class hierarchy shown
    in [figure 7.21](#ch07fig21)). Note that division by 0 is not the same as division
    by 0.0\. In this section, we’ll cover the results of division of integers and
    decimals by 0 and 0.0.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 当JVM遇到异常数学条件，例如整除以零时，它将抛出`ArithmeticException`（如图7.21所示，展示了类层次结构）。请注意，除以0与除以0.0不同。在本节中，我们将介绍整数和十进制数除以0和0.0的结果。
- en: Figure 7.21\. Class hierarchy of `ArithmeticException`
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.21。`ArithmeticException`的类层次结构
- en: '![](07fig21.jpg)'
  id: totrans-505
  prefs: []
  type: TYPE_IMG
  zh: '![图片](07fig21.jpg)'
- en: 'The following summarizes the cause of an `ArithmeticException`:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 以下总结了`ArithmeticException`的原因：
- en: A division will be performed as an integer division as long as only integers
    are involved. As soon as there’s a floating-point number, then everything is computed
    in floating-point arithmetic (true for all arithmetic operations, by the way).
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要只涉及整数，除法将作为整数除法执行。一旦有浮点数，那么所有计算都将在浮点算术中进行（实际上对所有算术运算都适用）。
- en: An integer division by zero throws an `ArithmeticException`.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数除以零会抛出`ArithmeticException`。
- en: A floating-point division by zero won’t throw any exception but rather will
    return `±Infinity` or `NaN`, depending on the first operand.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点除以零不会抛出任何异常，而是返回`±Infinity`或`NaN`，具体取决于第一个操作数。
- en: Division of an integer value by 0
  id: totrans-510
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 整数除以0
- en: 'Although it might seem simple to spot an occurrence of this exception, assumptions
    can be wrong. Let’s start with a simple and explicit example (which is easy to
    spot):'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个异常的发生可能看起来很简单，但假设可能是错误的。让我们从一个简单且明确的例子开始（这个例子很容易发现）：
- en: '![](511fig01_alt.jpg)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
  zh: '![图片](511fig01_alt.jpg)'
- en: 'On execution, the previous code will throw an `ArithmeticException` with a
    similar message:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时，前面的代码将抛出一个具有类似消息的`ArithmeticException`：
- en: '[PRE34]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here’s an example of comparatively complex code that you might see on the exam.
    Do you think it will throw an `ArithmeticException`? Also, do you think that the
    answer seems obvious like in the preceding code?
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个可能在考试中看到的相对复杂的代码示例。你认为它会抛出`ArithmeticException`吗？你也认为答案像前面的代码一样明显吗？
- en: '[PRE35]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding code throws `ArithmeticException` for the operation `x1/x2` because
    the value of `x2` is `0`. With the initialization of the variable `y`, the value
    of variable `a` is incremented by 1, from 10 to 11 (due to the post-fix increment
    operator). The variable `x2` is initialized with a value that’s equal to 11 and
    less than a, which is 0.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: The preceding code throws `ArithmeticException` for the operation `x1/x2` because
    the value of `x2` is `0`. With the initialization of the variable `y`, the value
    of variable `a` is incremented by 1, from 10 to 11 (due to the post-fix increment
    operator). The variable `x2` is initialized with a value that’s equal to 11 and
    less than a, which is 0.
- en: '|  |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: In the exam, watch out for division with integers. If the divisor is 0, the
    integer value that’s being divided doesn’t matter. Such an operation will throw
    an `ArithmeticException`.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在考试中，要注意整数的除法。如果除数是0，被除的整数值无关紧要。此类操作将抛出`ArithmeticException`。
- en: '|  |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'What do you think would be the answer if you divide 0 by 0? What do you think
    is the output of the following code: `1`, `0`, or `ArithmeticException`?'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为除以0的答案会是什么？你认为以下代码的输出是`1`，`0`，还是`ArithmeticException`？
- en: '[PRE36]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Division of an integer number by 0 will result in an `ArithmeticException`.
    So the preceding code will also throw an `ArithmeticException`.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 整数除以0将导致`ArithmeticException`。因此，前面的代码也将抛出`ArithmeticException`。
- en: '|  |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-526
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Division of a negative or positive integer value by 0 will result in an `ArithmeticException`.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 负数或正整数除以0的结果将是`ArithmeticException`。
- en: '|  |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Here’s an explicit example of dividing 0 by 0:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个除以0的显式示例：
- en: '![](513fig01_alt.jpg)'
  id: totrans-530
  prefs: []
  type: TYPE_IMG
  zh: '![图片](513fig01_alt.jpg)'
- en: '|  |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-532
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Division of 0 by 0 results in an `ArithmeticException`.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 除以0的结果是`ArithmeticException`。
- en: '|  |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Division of a decimal value by 0
  id: totrans-535
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小数除以0
- en: 'If you divide a positive decimal number by 0, the answer is `Infinity`:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将正小数除以0，答案是`Infinity`：
- en: '![](513fig02_alt.jpg)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
  zh: '![图片](513fig02_alt.jpg)'
- en: 'If you divide a negative decimal number by 0, the answer is `-Infinity`:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将负小数除以0，答案是`-Infinity`：
- en: '![](513fig03_alt.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![图片](513fig03_alt.jpg)'
- en: '|  |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: If you divide a positive decimal value by 0, the result is `Infinity`. If you
    divide a negative decimal value by 0, the result is `-Infinity`.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将正小数除以0，结果是`Infinity`。如果你将负小数除以0，结果是`-Infinity`。
- en: '|  |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Here’s an interesting question: what do you think is the result of division
    of 0.0 by 0? Here’s a quick code snippet:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的问题：你认为0.0除以0的结果会是什么？这里有一个简短的代码片段：
- en: '![](513fig04_alt.jpg)'
  id: totrans-545
  prefs: []
  type: TYPE_IMG
  zh: '![图片](513fig04_alt.jpg)'
- en: '|  |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-547
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: Division of 0.0 by 0 results in `NaN` (Not a Number).
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0除以0的结果是`NaN`（不是一个数字）。
- en: '|  |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Any mathematical operation with a `NaN` results in `NaN`.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 任何包含`NaN`的数学运算结果都是`NaN`。
- en: Division of integers or decimals by 0.0
  id: totrans-551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 整数或小数除以0.0
- en: 'Dividing by 0 and dividing by 0.0 don’t give you the same results. Let’s revisit
    the previous examples, starting with the modified version of the first example
    in this section:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 除以0和除以0.0的结果并不相同。让我们回顾前面的例子，从本节第一个例子的修改版开始：
- en: '![](513fig05_alt.jpg)'
  id: totrans-553
  prefs: []
  type: TYPE_IMG
  zh: '![图片](513fig05_alt.jpg)'
- en: The preceding code doesn’t throw an `ArithmeticException`. It outputs `Infinity`.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码不会抛出`ArithmeticException`。它输出`Infinity`。
- en: '|  |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Exam Tip
  id: totrans-556
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: When a positive integer or decimal value is divided by 0.0, the result is `Infinity`.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 当正整数或小数除以0.0时，结果是`Infinity`。
- en: '|  |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Here’s another modified example:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个修改后的例子：
- en: '[PRE37]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here’s the output of the preceding code:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '[PRE38]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code doesn’t throw an `ArithmeticException`. The variable `x1`
    is assigned a negative integer value, that is, `-17`. The variable `x2` is assigned
    the value `0`. When the variable `x3` of type `double` is initialized with the
    value of `x2`, it’s promoted to a `double` value, assigning `0.0` to `x3`. When
    a negative integer value is divided by 0.0, the result is `–Infinity`.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码不会抛出 `ArithmeticException`。变量 `x1` 被分配了一个负整数值，即 `-17`。变量 `x2` 被分配了值 `0`。当
    `double` 类型的变量 `x3` 使用 `x2` 的值初始化时，它被提升为 `double` 值，将 `0.0` 分配给 `x3`。当一个负整数值除以
    `0.0` 时，结果是 `–Infinity`。
- en: '|  |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-565
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试技巧
- en: When a negative integer or decimal value is divided by 0.0, the result is `–Infinity`.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个负整数或小数除以 `0.0` 时，结果是 `–Infinity`。
- en: '|  |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.5.6\. NumberFormatException
  id: totrans-568
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.6\. 数值格式异常
- en: What happens if you try to convert “87” and “9m#” to numeric values? The former
    value is OK, but you can’t convert the latter value to a numeric value unless
    it’s an encoded value, straight from a James Bond movie, that can be converted
    to anything.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试将“87”和“9m#”转换为数值，会发生什么？前者值是正确的，但你无法将后者值转换为数值，除非它是一个编码值，直接来自一部詹姆斯·邦德电影，可以转换为任何东西。
- en: As shown in [figure 7.22](#ch07fig22), `NumberFormat-Exception` is a runtime
    exception. It’s thrown to indicate that the application tried to convert a string
    (with an inappropriate format) to one of the numeric types.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 7.22](#ch07fig22) 所示，`NumberFormat-Exception` 是一个运行时异常。它被抛出以指示应用程序尝试将一个字符串（具有不适当的格式）转换为数值类型之一。
- en: Figure 7.22\. Class hierarchy of `NumberFormatException`
  id: totrans-571
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.22\. `NumberFormatException` 的类层次结构
- en: '![](07fig22.jpg)'
  id: totrans-572
  prefs: []
  type: TYPE_IMG
  zh: '![07fig22.jpg]'
- en: 'Multiple classes in the Java API define parsing methods. One of the most frequently
    used methods is `parseInt` from the class `Integer`. It’s used to parse a `String`
    argument as a signed (negative or positive) decimal integer. Here are some examples:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: Java API 中的多个类定义了解析方法。最常用的方法之一是来自 `Integer` 类的 `parseInt` 方法。它用于将 `String` 参数解析为有符号（负数或正数）的十进制整数。以下是一些示例：
- en: '![](515fig01_alt.jpg)'
  id: totrans-574
  prefs: []
  type: TYPE_IMG
  zh: '![图片](515fig01_alt.jpg)'
- en: 'Starting in Java 7, you can use underscores (_) in numeric literal values.
    But you can’t use them in `String` values passed to the method `parseInt`. The
    letters `ABCD` aren’t used in the decimal number system, but they can be used
    in the hexadecimal number system, so you can convert the hexadecimal literal value
    `"12ABCD"` to the decimal number system by specifying the base of the number system
    as `16`:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Java 7 开始，你可以在数值字面量中使用下划线（_）。但是，你无法在传递给 `parseInt` 方法的 `String` 值中使用它们。字母
    `ABCD` 在十进制数制中不使用，但在十六进制数制中可以使用，因此你可以通过指定数制的基数为 `16` 将十六进制字面量值 `"12ABCD"` 转换为十进制数制：
- en: '![](515fig02_alt.jpg)'
  id: totrans-576
  prefs: []
  type: TYPE_IMG
  zh: '![图片](515fig02_alt.jpg)'
- en: 'Note that the argument `16` is passed to the method `parseInt`, not to the
    method `println`. The following will not compile:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，参数 `16` 是传递给 `parseInt` 方法，而不是传递给 `println` 方法。以下将无法编译：
- en: '![](515fig03_alt.jpg)'
  id: totrans-578
  prefs: []
  type: TYPE_IMG
  zh: '![图片](515fig03_alt.jpg)'
- en: You may throw `NumberFormatException` from your own method to indicate that
    there’s an issue with the conversion of a `String` value to a specified numeric
    format (decimal, octal, hexadecimal, binary), and you can add a customized exception
    message. One of the most common candidates for this exception is methods that
    are used to convert a command-line argument (accepted as a `String` value) to
    a numeric value. Please note that all command-line arguments are accepted in a
    `String` array as `String` values.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从自己的方法中抛出 `NumberFormatException` 来指示 `String` 值转换为指定数值格式（十进制、八进制、十六进制、二进制）存在问题，并且你可以添加自定义异常消息。这种异常最常见的候选方法是用于将命令行参数（作为
    `String` 值接受）转换为数值的方法。请注意，所有命令行参数都作为 `String` 数组以 `String` 值的形式接受。
- en: 'The following is an example of code that throws a `NumberFormatException` programmatically-:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个程序抛出 `NumberFormatException` 的示例：
- en: '![](515fig04_alt.jpg)'
  id: totrans-581
  prefs: []
  type: TYPE_IMG
  zh: '![图片](515fig04_alt.jpg)'
- en: 'The conversion of the hexadecimal literal `16b` to the decimal number system
    is successful. But the conversion of the hexadecimal literal `65v` to the decimal
    number system fails, and the previous code will give the following output:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制字面量 `16b` 转换为十进制数制是成功的。但是，十六进制字面量 `65v` 转换为十进制数制失败，并且前面的代码将给出以下输出：
- en: '[PRE39]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now let’s take a look at some of the common errors that are covered on this
    exam.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下这次考试中涵盖的一些常见错误。
- en: 7.5.7\. ExceptionInInitializerError
  id: totrans-585
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.7\. 初始化异常
- en: The `ExceptionInInitializerError` error is typically thrown by the JVM when
    a static initializer in your code throws any type of `RuntimeException`. [Figure
    7.23](#ch07fig23) shows the class hierarchy of `ExceptionInInitializer-Error`.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExceptionInInitializerError`错误通常由JVM在代码中的静态初始化块抛出任何类型的`RuntimeException`时抛出。[图7.23](#ch07fig23)显示了`ExceptionInInitializer-Error`的类层次结构。'
- en: Figure 7.23\. Class hierarchy of `xceptionInInitializerError`
  id: totrans-587
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.23\. `ExceptionInInitializerError`的类层次结构
- en: '![](07fig23.jpg)'
  id: totrans-588
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig23.jpg)'
- en: 'A `static` initializer block is defined using the keyword `static`, followed
    by curly braces, in a class. This block is defined within a class but not within
    a method. It’s usually used to execute code when a class loads for the first time.
    Runtime exceptions arising from any of the following will throw this error:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中定义一个`static`初始化块，使用关键字`static`，后跟大括号。此块在类中定义，但不在方法中定义。它通常用于在类首次加载时执行代码。以下任何情况引发的运行时异常都会抛出此错误：
- en: Execution of an anonymous `static` block
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行匿名`static`块
- en: Initialization of a `static` variable
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化`static`变量
- en: Execution of a `static` method (called from either of the previous two items)
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个`static`方法（从前面两个项目中的任何一个调用）
- en: 'The `static` initializer block of the class defined in the following example
    will throw a `NumberFormatException`, and when the JVM tries to load this class,
    it’ll throw an `ExceptionInInitializerError`:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中定义的类的`static`初始化块将抛出`NumberFormatException`，当JVM尝试加载这个类时，它将抛出`ExceptionInInitializerError`：
- en: '[PRE40]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Following is the error message when the JVM tries to load the class `DemoExceptionInInitializerError`:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 当JVM尝试加载类`DemoExceptionInInitializerError`时，以下是其错误信息：
- en: '[PRE41]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|  |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-598
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: Beware of code that seems to be simple in the OCA Java SE 8 Programmer I exam.
    The class `DemoExceptionInInitializerError` (mentioned previously) seems deceptively
    simple, but it’s a good candidate for an exam question. As you know, this class
    throws the error `ExceptionInInitializerError` when the JVM tries to load it.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在OCA Java SE 8程序员I考试中，注意看似简单的代码。前面提到的`DemoExceptionInInitializerError`类看似简单，但它是一个很好的考试问题候选者。正如你所知，当JVM尝试加载这个类时，它会抛出`ExceptionInInitializerError`错误。
- en: '|  |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In the following example, initialization of a static variable results in a
    `NullPointer-Exception` being thrown. When this class is loaded by the JVM, it
    throws an `ExceptionInInitializerError`:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，静态变量的初始化导致抛出`NullPointerException`。当JVM加载这个类时，它将抛出`ExceptionInInitializerError`：
- en: '[PRE42]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The error message when the JVM tries to load the `DemoException-InInitializer-Error1`
    class is as follows:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 当JVM尝试加载`DemoException-InInitializer-Error1`类时，错误信息如下：
- en: '[PRE43]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now let’s move on to the exception thrown by a `static` method, which may be
    called by the `static` initializer block or to initialize a `static` variable.
    Examine the following code, in which `MyException` is a user-defined `RuntimeException`:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续讨论由`static`方法抛出的异常，这些方法可能由`static`初始化块调用或用于初始化`static`变量。检查以下代码，其中`MyException`是一个用户定义的`RuntimeException`：
- en: '![](517fig01_alt.jpg)'
  id: totrans-606
  prefs: []
  type: TYPE_IMG
  zh: '![](517fig01_alt.jpg)'
- en: 'This is the error thrown by the class `DemoExceptionInInitializerError2`:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`DemoExceptionInInitializerError2`类抛出的错误：
- en: '[PRE44]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Did you notice that the error `ExceptionInInitializerError` can be caused only
    by a runtime exception? This happens for valid reasons, of course.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到错误`ExceptionInInitializerError`只能由运行时异常引起吗？这当然有合理的理由。
- en: If a static initializer block throws an error, it doesn’t recover from it to
    come back to the code to throw an `ExceptionInInitializerError`. This error can’t
    be thrown if a `static` initializer block throws an object of a checked exception
    because the Java compiler is intelligent enough to determine this condition and
    doesn’t allow you to throw an unhandled checked exception from a static initialization
    block.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 如果静态初始化块抛出错误，它不会从错误中恢复并返回代码以抛出`ExceptionInInitializerError`异常。如果静态初始化块抛出一个受检异常的对象，则无法抛出此错误，因为Java编译器足够智能，可以确定这种条件，并且不允许你在静态初始化块中抛出未处理的受检异常。
- en: '|  |'
  id: totrans-611
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Exam Tip
  id: totrans-612
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 考试提示
- en: '`ExceptionInInitializerError` can be caused by an object of `RuntimeException`
    only. It can’t occur as the result of an error or checked exception thrown by
    the `static` initialization block.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExceptionInInitializerError`只能由`RuntimeException`的对象引起。它不能作为`static`初始化块抛出的错误或受检异常的结果发生。'
- en: '|  |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.5.8\. StackOverflowError
  id: totrans-615
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.8\. `StackOverflowError`
- en: The `StackOverflowError` error extends `Virtual-MachineError` (as shown in [figure
    7.24](#ch07fig24)). As its name suggests, you should leave it to be managed by
    the JVM.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackOverflowError` 错误扩展了 `Virtual-MachineError`（如图 7.24 所示）。正如其名称所暗示的，你应该将其留给
    JVM 管理。'
- en: Figure 7.24\. Class hierarchy of `StackOverflowError`
  id: totrans-617
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.24\. `StackOverflowError` 的类层次结构
- en: '![](07fig24.jpg)'
  id: totrans-618
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig24.jpg)'
- en: 'This error is thrown by the JVM when a Java program calls itself so many times
    that the memory stack allocated to execute the Java program “overflows” (*overflows*
    means that the stack exceeds a certain size). Examine the following code, in which
    a method calls itself recursively without an exit condition-:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 Java 程序调用自身多次，以至于执行 Java 程序分配的内存栈“溢出”时（“溢出”意味着栈超过了某个大小），JVM 会抛出此错误。检查以下代码，其中方法递归调用自身而没有退出条件：
- en: '![](518fig01_alt.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
  zh: '![](518fig01_alt.jpg)'
- en: 'The following error is thrown by the previous code:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码抛出了以下错误：
- en: '[PRE45]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 7.5.9\. NoClassDefFoundError
  id: totrans-623
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.9\. NoClassDefFoundError
- en: What would happen if you failed to set your classpath and, as a result, the
    JVM was unable to load the class that you wanted to access or execute? Or what
    would happen if you tried to run your application before compiling it (and so
    no .class file would be found for the class you were trying to use)? In both these
    conditions, the JVM would throw a `NoClassDefFoundError` (the class hierarchy
    shown in [figure 7.25](#ch07fig25)).
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你未能设置你的类路径，结果 JVM 无法加载你想要访问或执行的类，会发生什么？或者，如果你在编译应用程序之前尝试运行它（因此找不到你试图使用的类的
    .class 文件），会发生什么？在这两种情况下，JVM 将抛出 `NoClassDefFoundError`（如图 7.25 所示的类层次结构）。
- en: Figure 7.25\. Class hierarchy of `NoClassDefFoundError`
  id: totrans-625
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.25\. `NoClassDefFoundError` 的类层次结构
- en: '![](07fig25.jpg)'
  id: totrans-626
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig25.jpg)'
- en: 'This is what the Java API documentation says about this error:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Java API 文档关于此错误的说明：
- en: '*Thrown if the Java Virtual Machine or a `ClassLoader` instance tries to load
    in the definition of a class (as part of a normal method call or as part of creating
    a new instance using the `new` expression) and no definition of the class could
    be found.^([[1](#ch07fn01)])*'
  id: totrans-628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果 Java 虚拟机或 `ClassLoader` 实例尝试加载类的定义（作为正常方法调用的一部分或作为使用 `new` 表达式创建新实例的一部分），并且找不到类的定义，则会抛出异常。[1](#ch07fn01)*'
- en: ''
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ¹
  id: totrans-630
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-631
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The `NoClassDefFoundError` documentation can be found in the Javadoc: [http://docs.oracle.com/javase/8/docs/api/java/lang/NoClassDefFoundError.html](http://docs.oracle.com/javase/8/docs/api/java/lang/NoClassDefFoundError.html).'
  id: totrans-632
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`NoClassDefFoundError` 的文档可以在 Javadoc 中找到：[http://docs.oracle.com/javase/8/docs/api/java/lang/NoClassDefFoundError.html](http://docs.oracle.com/javase/8/docs/api/java/lang/NoClassDefFoundError.html)。'
- en: Because this particular error isn’t a coding issue, I don’t have a coding example
    for you. As you can see from the error hierarchy diagram in [figure 7.25](#ch07fig25),
    this is a linkage error arising from a missing class file definition at runtime.
    Like every system error, this error shouldn’t be handled by the code and should
    be left to be handled exclusively by the JVM.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个特定的错误不是编码问题，我没有为你提供一个编码示例。正如你可以从图 7.25 中的错误层次结构图中看到的，这是一个在运行时由于缺少类文件定义而产生的链接错误。像每个系统错误一样，这个错误不应该由代码处理，而应该完全由
    JVM 处理。
- en: '|  |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-635
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t confuse the exception thrown by `Class.forName()`, used to load the class,
    and `NoClassDefFoundError,` thrown by the JVM. `Class.forName()` throws `ClassNotFoundException`.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆用于加载类的 `Class.forName()` 抛出的异常和 JVM 抛出的 `NoClassDefFoundError`。`Class.forName()`
    抛出 `ClassNotFoundException`。
- en: '|  |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.5.10\. OutOfMemoryError
  id: totrans-638
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.5.10\. OutOfMemoryError
- en: What happens if you create and use a *lot* of objects in your application—for
    example, if you load a large chunk of persistent data to be processed by your
    application? In such a case, the JVM may run out of memory *on the heap*, and
    the garbage collector may not be able to free more memory for the JVM. In this
    case, the JVM is unable to create any more objects on the heap. An `OutOfMemoryError`
    will be thrown (the class hierarchy shown in [figure 7.26](#ch07fig26)).
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在应用程序中创建并使用了大量的对象——例如，如果你加载了大量持久数据供应用程序处理，会发生什么？在这种情况下，JVM 可能会在堆上耗尽内存，垃圾收集器可能无法为
    JVM 释放更多内存。在这种情况下，JVM 无法在堆上创建更多对象。将抛出 `OutOfMemoryError`（如图 7.26 所示的类层次结构）。
- en: Figure 7.26\. Class hierarchy of `OutOfMemoryError`
  id: totrans-640
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.26\. `OutOfMemoryError` 的类层次结构
- en: '![](07fig26.jpg)'
  id: totrans-641
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig26.jpg)'
- en: You’ll always work with a finite heap size, no matter what platform you work
    on, so you can’t create and use an unlimited number of objects in your application.
    To get around this error, you need to either limit the number of resources or
    objects that your application creates or increase the heap size on the platform
    you’re working with.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您在哪个平台上工作，您都将始终与有限的堆大小一起工作，因此您不能在应用程序中创建和使用无限数量的对象。为了解决这个问题，您需要限制应用程序创建的资源或对象数量，或者增加您正在工作的平台上的堆大小。
- en: A number of tools are available (which are beyond the scope of this book) that
    can help you monitor the number of objects created in your application.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具（这些工具超出了本书的范围）可以帮助您监控应用程序中创建的对象数量。
- en: 7.6\. Summary
  id: totrans-644
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6. 摘要
- en: In this chapter, we discussed the need for exception handling, as well as the
    advantages of defining the exception-handling code separately from the program
    logic. You saw how this approach helps separate concerns about defining the regular
    program logic and exception-handling code. We also looked at the code syntax,
    specifically `try`-`catch`-`finally` blocks, for implementing exception-handling
    code. Code that throws an exception should be enclosed within a `try` block that’s
    immediately followed by a `catch` and/or a `finally` block. A `try` block can
    be followed by multiple `catch` blocks but only a single `finally` block. A `finally`
    block can’t be placed before a `try` block. A `try` block must be followed by
    at least one `catch` or `finally` block. The `try`, `catch`, and `finally` blocks
    can’t exist independently.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了异常处理的需求，以及将异常处理代码与程序逻辑分开定义的优势。您看到了这种方法如何帮助分离定义常规程序逻辑和异常处理代码的关心点。我们还探讨了实现异常处理代码的代码语法，特别是`try`-`catch`-`finally`块。抛出异常的代码应包含在`try`块中，该块紧随`catch`和/或`finally`块之后。`try`块可以后跟多个`catch`块，但只能有一个`finally`块。`finally`块不能放在`try`块之前。`try`块必须后跟至少一个`catch`或`finally`块。`try`、`catch`和`finally`块不能独立存在。
- en: 'Next, we delved into the different categories of exceptions: checked exceptions,
    runtime or unchecked exceptions, and errors. Checked exceptions are subclasses
    of the class `java.lang.Exception`. Unchecked exceptions are subclasses of the
    class `java.lang.RuntimeException`, which itself is a subclass of the class `java.lang.Exception`.
    Errors are subclasses of `java.lang.Error`. All of these exceptions are subclasses
    of `java.lang.Throwable`.'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们深入探讨了异常的不同类别：检查异常、运行时或非检查异常、错误。检查异常是`java.lang.Exception`类的子类。非检查异常是`java.lang.RuntimeException`类的子类，而`java.lang.RuntimeException`本身又是`java.lang.Exception`类的子类。错误是`java.lang.Error`类的子类。所有这些异常都是`java.lang.Throwable`类的子类。
- en: A checked exception is an unacceptable condition foreseen by the author of a
    method but outside the immediate control of the code. A runtime exception represents
    a programming error—these occur because of inappropriate use of another piece
    of code. Errors are serious exceptions, thrown by the JVM, as a result of an error
    in the environment state that processes your code.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 检查异常是方法作者预见但不在代码直接控制范围内的不可接受条件。运行时异常代表编程错误——这些错误是由于对其他代码的不当使用而发生的。错误是严重的异常，由JVM抛出，是由于处理您的代码的环境状态错误导致的。
- en: In the final sections of this chapter, we covered commonly occurring exceptions
    and errors, such as `NullPointerException`, `IllegalArgumentException`, `StackOverflowError`,
    and more. For each of these errors and exceptions, I explained the conditions
    in which they may be thrown in code and whether they should be explicitly handled
    in exception handlers.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后几节中，我们讨论了常见异常和错误，例如`NullPointerException`、`IllegalArgumentException`、`StackOverflowError`等。对于这些错误和异常，我解释了它们在代码中可能抛出的条件以及是否应该在异常处理器中显式处理。
- en: 7.7\. Review notes
  id: totrans-649
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7. 复习笔记
- en: This section lists the main points of all the sections covered in this chapter.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 本节列出了本章涵盖的所有部分的要点。
- en: 'Why handle exceptions separately:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要单独处理异常：
- en: Handling exceptions separately enables you to define the main logic of your
    code together.
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将异常单独处理使您能够一起定义代码的主要逻辑。
- en: Without the use of separate exception handlers, the main logic of your code
    would be lost in combating the exceptional conditions. (See [figure 7.5](#ch07fig05)
    for an example.)
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不使用单独的异常处理器，您的代码的主要逻辑将丢失在应对异常条件的过程中。（参见[图7.5](#ch07fig05)以获取示例。）
- en: Exception handlers separate the concerns of defining regular program logic from
    exception-handling code.
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理器将定义常规程序逻辑与异常处理代码的关注点分开。
- en: Exceptions help pinpoint the offending code, together with the method in which
    it’s defined, by providing a stack trace of the exception or error.
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常通过提供异常或错误的堆栈跟踪，帮助确定有问题的代码以及定义它的方法。
- en: The JVM may send the stack trace of an unhandled exception to the Java console.
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM可能会将未处理的异常的堆栈跟踪发送到Java控制台。
- en: 'Categories of exceptions:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 异常的分类：
- en: 'Exceptions are divided into three categories: checked exceptions, runtime (or
    unchecked exceptions), and errors. These three categories share IS-A relationships
    (inheritance).'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常分为三类：检查型异常、运行时（或非检查型）异常和错误。这三个类别共享IS-A关系（继承）。
- en: Subclasses of the class `java.lang.RuntimeException` are categorized as runtime
    exceptions.
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.RuntimeException`类的子类被归类为运行时异常。'
- en: Subclasses of the class `java.lang.Error` are categorized as errors.
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Error`类的子类被归类为错误。'
- en: Subclasses of the class `java.lang.Exception` are categorized as checked exceptions
    if they’re not subclasses of the class `java.lang.RuntimeException`.
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类的子类不是`java.lang.RuntimeException`的子类，则`java.lang.Exception`的子类被归类为检查型异常。
- en: The class `java.lang.RuntimeException` is a subclass of the class `java.lang.Exception`.
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.RuntimeException`类是`java.lang.Exception`类的子类。'
- en: The class `java.lang.Exception` is a subclass of the class `java.lang.Throwable`.
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Exception`类是`java.lang.Throwable`类的子类。'
- en: The class `java.lang.Error` is also a subclass of the class `java.lang.Throwable`.
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Error`类也是`java.lang.Throwable`类的子类。'
- en: The class `java.lang.Throwable` inherits the class `java.lang.Object`.
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Throwable`类继承自`java.lang.Object`类。'
- en: 'Checked exceptions:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 检查型异常：
- en: A checked exception is an unacceptable condition foreseen by the author of a
    method but outside the immediate control of the code.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查型异常是方法作者预见但不在代码直接控制范围内的不可接受条件。
- en: A checked exception is a subclass of the `java.lang.Exception` class but not
    a subclass of `java.lang.RuntimeException`. It’s interesting to note, however,
    that the class `java.lang.RuntimeException` itself is a subclass of the class
    `java.lang.Exception`.
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查型异常是`java.lang.Exception`类的子类，但不是`java.lang.RuntimeException`的子类。然而，值得注意的是，`java.lang.RuntimeException`类本身也是`java.lang.Exception`类的子类。
- en: If a method calls another method that may throw a checked exception, either
    it must be enclosed within a `try-catch` block, or the method should declare this
    exception to be thrown in its method signature.
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个方法调用另一个可能抛出检查型异常的方法，那么它必须被包含在一个`try-catch`块中，或者该方法应在方法签名中声明抛出此异常。
- en: 'Runtime exceptions:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时异常：
- en: Runtime exceptions represent programming errors. These occur from inappropriate
    use of another piece of code. For example, `NullPointerException` is a runtime
    exception that occurs when a piece of code tries to execute some code on a variable
    that hasn’t been assigned an object and points to `null`. Another example is `ArrayIndexOutOfBoundsException`,
    which is thrown when a piece of code tries to access an array of list elements
    at a nonexistent position.
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时异常代表编程错误。这些错误通常是由于对其他代码的不当使用而发生的。例如，`NullPointerException`是一个运行时异常，当一段代码尝试在一个尚未分配对象的变量上执行代码并指向`null`时发生。另一个例子是`ArrayIndexOutOfBoundsException`，当一段代码尝试访问一个列表元素在不存在位置上的数组时抛出。
- en: A runtime exception is a subclass of `java.lang.RuntimeException`.
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时异常是`java.lang.RuntimeException`的子类。
- en: A runtime exception might not be a part of the method signature, even if a method
    may throw it.
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使一个方法可能抛出运行时异常，运行时异常也可能不是方法签名的一部分。
- en: A runtime exception may not necessarily be caught by a `try-catch` block.
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时异常不一定会被`try-catch`块捕获。
- en: 'Errors:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：
- en: An error is a serious exception, thrown by the JVM as a result of an error in
    the environment state, which processes your code. For example, `NoClassDefFoundError`
    is an error thrown by the JVM when it’s unable to locate the .class file it’s
    supposed to run.
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误是一个严重的异常，由JVM在环境状态错误时抛出，该错误处理你的代码。例如，`NoClassDefFoundError`是JVM在无法找到它应该运行的`.class`文件时抛出的错误。
- en: '`StackOverflowError` is another error, thrown by the JVM when the size of the
    memory required by the stack of the Java program is greater than what the JRE
    has offered for the Java application. This error usually occurs as a result of
    infinite or highly nested loops.'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackOverflowError`是另一种错误，当Java程序栈所需的内存大小超过JRE为Java应用程序提供的内存时，JVM会抛出此错误。此错误通常是由于无限循环或高度嵌套的循环引起的。'
- en: An error is a subclass of the class `java.lang.Error`.
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误是`java.lang.Error`类的一个子类。
- en: An error need not be a part of a method signature.
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误不必是方法签名的一部分。
- en: Although you can handle errors syntactically, there’s little that you can do
    when these errors occur. Usually, ordinary programs aren’t expected to recover
    from errors.
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然你可以从语法上处理错误，但当这些错误发生时，你能做的很少。通常，普通程序不被期望从错误中恢复。
- en: 'Creating a method that throws an exception:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 创建抛出异常的方法：
- en: A method uses a `throw` statement to throw an exception or error.
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法使用`throw`语句抛出异常或错误。
- en: A method uses a `throws` clause in its signature to declare that it might throw
    an exception.
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法使用其签名中的`throws`子句来声明它可能会抛出异常。
- en: A method can have multiple comma-separated class names of exceptions in its
    `throws` clause. Including runtime exceptions or errors in the method declaration
    isn’t required.
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法可以在其`throws`子句中有多个以逗号分隔的异常类名。在方法声明中包括运行时异常或错误不是必需的。
- en: Syntactically, you don’t always need a combination of `throw` and `throws` statements
    to create a method that throws an exception (checked or unchecked). You can replace
    the `throw` statement with a method that throws an exception.
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法上，你不必总是需要一个`throw`和`throws`语句的组合来创建一个抛出异常的方法（受检或非受检）。你可以用一个抛出异常的方法来替换`throw`语句。
- en: 'To use a method that throws a checked exception, you must do one of the following:'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用抛出受检异常的方法，你必须执行以下操作之一：
- en: '*Handle the exception*—Enclose the code within a `try` block and catch the
    thrown exception.'
  id: totrans-687
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理异常*——将代码放在`try`块中并捕获抛出的异常。'
- en: '*Declare it to be thrown*—Declare the exception to be thrown by using the `throws`
    clause.'
  id: totrans-688
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*声明抛出*——使用`throws`子句声明要抛出的异常。'
- en: '*Handle and declare*—Implement both of the preceding options together.'
  id: totrans-689
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*处理和声明*——同时实现上述两种选项。'
- en: While creating a method that throws a runtime exception or error, including
    the exception or error name in the `throws` clause isn’t required.
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建抛出运行时异常或错误的函数时，包括异常或错误名称在`throws`子句中不是必需的。
- en: A method that throws a runtime exception or error isn’t subject to the handle-or-declare
    rule.
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出运行时异常或错误的函数不受处理或声明规则的约束。
- en: A method can declare to throw all types of exceptions, even if it doesn’t. But
    a `try` block can’t define a `catch` block for a checked exception (other than
    `Exception`) if the `try` block doesn’t throw that checked exception or use a
    method that declares to throw that checked exception.
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种方法可以声明抛出所有类型的异常，即使它实际上并不抛出。但是，如果`try`块没有抛出该受检异常或使用声明抛出该受检异常的方法，则不能为该受检异常（除了`Exception`）定义一个`catch`块。
- en: 'What happens when an exception is thrown:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常时会发生什么：
- en: An exception is an object of the class `java.lang.Throwable`.
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常是`java.lang.Throwable`类的一个对象。
- en: When a piece of code hits an obstacle in the form of an exceptional condition,
    it creates an object of subclass `java.lang.Throwable`, initializes it with the
    necessary information (such as its type and optionally a textual description and
    the offending program’s state), and hands it over to the JVM.
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一段代码遇到以异常条件形式出现的障碍时，它会创建一个`java.lang.Throwable`子类的对象，用必要的信息（例如其类型和可选的文本描述以及有问题的程序状态）初始化它，并将其交给JVM。
- en: Enclose the code that may throw an exception within a `try` block.
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可能抛出异常的代码放在`try`块中。
- en: Define `catch` blocks to include alternative code to execute when an exceptional
    condition arises.
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`catch`块以包含在出现异常条件时执行的替代代码。
- en: A `try` block can be followed by one or more `catch` blocks.
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`块可以后跟一个或多个`catch`块。'
- en: The `catch` blocks must be followed by zero or one `finally` block.
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catch`块之后必须跟零个或一个`finally`块。'
- en: The `finally` block executes regardless of whether the code in the `try` block
    throws an exception.
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finally`块无论`try`块中的代码是否抛出异常都会执行。'
- en: The order in which the `catch` blocks are placed matters. If the caught exceptions
    have an inheritance relationship, the base class exceptions can’t be caught before
    the derived class exceptions. An attempt to do this will result in compilation
    failure.
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catch` 块的放置顺序很重要。如果捕获的异常之间存在继承关系，则不能在派生类异常之前捕获基类异常。尝试这样做会导致编译失败。'
- en: A `finally` block will execute even if a `try` or `catch` block defines a `return`
    statement.
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使一个 `try` 或 `catch` 块定义了 `return` 语句，`finally` 块也会执行。
- en: If both `catch` and `finally` blocks define `return` statements, the calling
    method will receive the value from the `finally` block.
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `catch` 和 `finally` 块都定义了 `return` 语句，调用方法将接收到 `finally` 块的值。
- en: If a `catch` block returns a primitive data type, a `finally` block can’t modify
    the value being returned by it.
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `catch` 块返回一个原始数据类型，`finally` 块不能修改它返回的值。
- en: If a `catch` block returns an object, a `finally` block can modify the value
    being returned by it.
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `catch` 块返回一个对象，`finally` 块可以修改它返回的值。
- en: A `finally` block alone won’t suffice with a `try` block if code in the `try`
    block throws a checked exception. In this case, you’ll need to catch the checked
    exception or define in the method signature that the exception is thrown, or your
    code won’t compile.
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `try` 块中的代码抛出检查型异常，单独的 `finally` 块不足以与 `try` 块一起使用。在这种情况下，你需要捕获检查型异常或在方法签名中定义异常被抛出，否则你的代码将无法编译。
- en: None of the `try`, `catch`, and `finally` blocks can exist independently.
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`、`catch` 和 `finally` 块不能独立存在。'
- en: The `finally` block can’t appear before a `catch` block.
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finally` 块不能出现在 `catch` 块之前。'
- en: You can rethrow an error that you *catch* in an exception handler.
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在异常处理程序中重新抛出你捕获的错误。
- en: You can either handle an exception or declare it to be thrown by your method.
    In the latter case, you need not handle the exception in your code. This applies
    to checked exceptions.
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以处理异常或声明你的方法抛出异常。在后一种情况下，你不需要在代码中处理异常。这适用于检查型异常。
- en: You can create nested exception handlers.
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以创建嵌套的异常处理程序。
- en: A `try`, `catch`, or `finally` block can define another `try`-`catch`-`finally`
    block. Theoretically, there’s no limit on the allowed level of nesting of `try`-`catch`-`finally`
    blocks.
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `try`、`catch` 或 `finally` 块可以定义另一个 `try`-`catch`-`finally` 块。理论上，`try`-`catch`-`finally`
    块的嵌套级别没有限制。
- en: 'Commonly occurring exceptions, categories, and classes:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 常见异常、类别和类：
- en: In typical programming conditions, the `ArrayIndexOutOfBoundsException` shouldn’t
    be thrown programmatically.
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在典型的编程条件下，不应通过编程方式抛出 `ArrayIndexOutOfBoundsException`。
- en: One of the main reasons for the JVM taking the responsibility on itself for
    throwing this exception is that this exception isn’t known until runtime and depends
    on the array or list position that’s being accessed by a piece of code. Most often,
    a variable is used to specify this array or list position, and its value may not
    be known until runtime.
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM 负责抛出此异常的主要原因是此异常直到运行时才知道，并且依赖于代码访问的数组或列表位置。通常，一个变量用于指定此数组或列表位置，其值可能直到运行时才知道。
- en: '`ClassCastException` is a runtime exception. `java.lang.ClassCastException`
    extends `java.lang.RuntimeException`.'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClassCastException` 是一个运行时异常。`java.lang.ClassCastException` 继承自 `java.lang.RuntimeException`。'
- en: '`ClassCastException` is thrown when an object fails an IS-A test with the class
    type it is being cast to.'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个对象在将其转换为其他类类型时失败 IS-A 测试时，会抛出 `ClassCastException`。
- en: You can use the operator `instanceof` to verify whether an object can be cast
    to another class before casting it.
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行转换之前，你可以使用 `instanceof` 操作符来验证一个对象是否可以被转换为另一个类。
- en: '`IllegalArgumentException` is a runtime exception. `java.lang.Illegal-Argument-Exception`
    extends `java.lang.RuntimeException`.'
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IllegalArgumentException` 是一个运行时异常。`java.lang.Illegal-Argument-Exception`
    继承自 `java.lang.RuntimeException`。'
- en: An `IllegalArgumentException` is thrown to specify that a method has been passed
    illegal or inappropriate arguments.
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出 `IllegalArgumentException` 以指定方法已被传递非法或不适当的参数。
- en: Even though `IllegalArgumentException` is a runtime exception, programmers usually
    use this exception to validate the arguments that are passed to a method, and
    the exception constructor is passed a descriptive message specifying the exception
    details.
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管 `IllegalArgumentException` 是一个运行时异常，但程序员通常使用此异常来验证传递给方法的参数，并且异常构造函数会传递一个描述性的消息，指定异常的详细信息。
- en: As a programmer, you can throw an `IllegalStateException` to signal to the calling
    method that the method that’s being requested for execution isn’t ready to start
    its execution or is in a state in which it can’t execute.
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为程序员，你可以抛出一个`IllegalStateException`来通知调用方法，被请求执行的方法尚未准备好开始执行，或者处于无法执行的状态。
- en: A `NullPointerException` is a runtime exception. The class `java.lang.NullPointerException`
    extends `java.lang.RuntimeException`.
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NullPointerException`是一个运行时异常。类`java.lang.NullPointerException`扩展了`java.lang.RuntimeException`。'
- en: A `NullPointerException` is thrown by the JVM if you try to access a method
    or variable of an uninitialized reference variable.
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你尝试访问一个未初始化的引用变量的方法或变量，JVM会抛出`NullPointerException`。
- en: When the JVM encounters an exceptional mathematical condition, like dividing
    a number by zero, it throws an `ArithmeticException`.
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当JVM遇到异常数学条件，如除以零时，它会抛出`ArithmeticException`。
- en: In division with integers, if the divisor is 0, the integer value that’s being
    divided doesn’t matter. Such an operation will throw an `ArithmeticException`.
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整数除法中，如果除数是0，被除的整数值无关紧要。此类操作将抛出`ArithmeticException`。
- en: Division of a negative or positive integer value by 0 will result in an `Arithmetic-Exception`.
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负数或正整数除以0的结果将是一个`Arithmetic-Exception`。
- en: Division of 0 by 0 results in an `ArithmeticException`.
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0除以0的结果是一个`ArithmeticException`。
- en: If you divide a positive decimal value by 0, the result is `Infinity`. If you
    divide a negative decimal value by 0, the result is `-Infinity`.
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你将一个正小数除以0，结果是`Infinity`。如果你将一个负小数除以0，结果是`-Infinity`。
- en: Division of 0.0 by 0 results in `NaN` (Not a Number).
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.0除以0的结果是`NaN`（不是一个数字）。
- en: When a positive integer or decimal value is divided by 0.0, the result is `Infinity`.
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个正整数或小数除以0.0时，结果是`Infinity`。
- en: When a negative integer or decimal value is divided by 0.0, the result is `–Infinity`.
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个负整数或小数除以0.0时，结果是`–Infinity`。
- en: '`NumberFormatException` is a runtime exception. `java.lang.NumberFormat-Exception`
    extends `java.lang.IllegalArgumentException`. `java.lang.IllegalArgumentException`
    extends `java.lang.RuntimeException`.'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumberFormatException`是一个运行时异常。`java.lang.NumberFormatException`扩展了`java.lang.IllegalArgumentException`。`java.lang.IllegalArgumentException`扩展了`java.lang.RuntimeException`。'
- en: You can throw a `NumberFormatException` from your own method to indicate that
    there’s an issue with the conversion of a `String` value to a specified numeric
    format (decimal, octal, hexadecimal, or binary).
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从自己的方法中抛出一个`NumberFormatException`，以指示将`String`值转换为指定数值格式（十进制、八进制、十六进制或二进制）时存在问题。
- en: 'Runtime exceptions arising from any of the following may throw an `ExceptionInInitializerError`:'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下任何一种情况引发的运行时异常可能会抛出`ExceptionInInitializerError`：
- en: Execution of an anonymous `static` block
  id: totrans-736
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个匿名的`static`块
- en: Initialization of a `static` variable
  id: totrans-737
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化一个`static`变量
- en: Execution of a `static` method (called from either of the previous two items)
  id: totrans-738
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个`static`方法（从前面两个项目中的任何一个调用）
- en: The error `ExceptionInInitializerError` can be thrown only by an object of a
    runtime exception.
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有运行时异常的对象可以抛出错误`ExceptionInInitializerError`。
- en: '`ExceptionInInitializerError` can’t be thrown if a `static` initializer block
    throws an object of a checked exception, because the Java compiler is intelligent
    enough to determine this condition, and it doesn’t allow you to throw an unhandled
    checked exception from a `static` initialization block.'
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个`static`初始化块抛出一个检查异常的对象，则不能抛出`ExceptionInInitializerError`，因为Java编译器足够智能，可以确定这种条件，并且不允许你从一个`static`初始化块中抛出一个未处理的检查异常。
- en: '`StackOverflowError` is an error. `java.lang.StackOverflowError` extends `java.lang.VirtualMachineError`.'
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackOverflowError`是一个错误。`java.lang.StackOverflowError`扩展了`java.lang.VirtualMachineError`。'
- en: Because `StackOverflowError` extends `VirtualMachineError`, it should be left
    to be managed by the JVM.
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为`StackOverflowError`扩展了`VirtualMachineError`，所以它应该由JVM管理。
- en: The `StackOverflowError` error is thrown by the JVM when a Java program calls
    itself so many times that the memory stack allocated to execute the Java program
    “overflows.”
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个Java程序调用自身次数过多，以至于执行Java程序的内存栈“溢出”时，JVM会抛出`StackOverflowError`错误。
- en: '`NoClassDefFoundError` is an `Error`. `java.lang.NoClassDefFoundError` extends
    `java.lang.LinkageError`. `java.lang.LinkageError` extends `java.lang.Error`.'
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoClassDefFoundError`是一个`Error`。`java.lang.NoClassDefFoundError`扩展了`java.lang.LinkageError`。`java.lang.LinkageError`扩展了`java.lang.Error`。'
- en: A `NoClassDefFoundError` is thrown by the JVM or a `ClassLoader` when it’s unable
    to load the definition of a class required to create an object of the class.
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 JVM 或 `ClassLoader` 无法加载创建类对象所需的类定义时，会抛出 `NoClassDefFoundError`。
- en: Don’t confuse the exception thrown by `Class.forName()`, used to load the class,
    and `NoClassDefFoundError`, thrown by the JVM. `Class.forName()` throws a `ClassNotFoundException`.
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要混淆用于加载类的 `Class.forName()` 抛出的异常和 JVM 抛出的 `NoClassDefFoundError`。`Class.forName()`
    抛出 `ClassNotFoundException`。
- en: An `OutOfMemoryError` is thrown by the JVM when it’s unable to create objects
    on the heap and the garbage collector may not be able to free more memory for
    the JVM.
  id: totrans-747
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 JVM 无法在堆上创建对象且垃圾收集器可能无法为 JVM 释放更多内存时，会抛出 `OutOfMemoryError`。
- en: 7.8\. Sample exam questions
  id: totrans-748
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.8\. 样本考试问题
- en: '**[Q7-1.](#ch07qa2q0a1)**'
  id: totrans-749
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-1.](#ch07qa2q0a1)**'
- en: ''
  id: totrans-750
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What is the output of the following code:'
  id: totrans-751
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么：
- en: ''
  id: totrans-752
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-753
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ''
  id: totrans-754
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The code will print `Java`.
  id: totrans-755
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将打印 `Java`。
- en: The code will print `Oracle`.
  id: totrans-756
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将打印 `Oracle`。
- en: The code will not compile.
  id: totrans-757
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将无法编译。
- en: The code will throw an exception or an error at runtime.
  id: totrans-758
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将在运行时抛出异常或错误。
- en: '**[Q7-2.](#ch07qa2q0a2)**'
  id: totrans-759
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-2.](#ch07qa2q0a2)**'
- en: ''
  id: totrans-760
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Select the correct option(s):'
  id: totrans-761
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选择正确的选项（s）：
- en: ''
  id: totrans-762
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You cannot handle runtime exceptions.
  id: totrans-763
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你无法处理运行时异常。
- en: You should not handle errors.
  id: totrans-764
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不应该处理错误。
- en: If a method throws a checked exception, it must be either handled by the method
    or specified in its `throws` clause.
  id: totrans-765
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个方法抛出检查异常，它必须由该方法处理或指定在其 `throws` 子句中。
- en: If a method throws a runtime exception, it may include the exception in its
    `throws` clause.
  id: totrans-766
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个方法抛出运行时异常，它可以在其 `throws` 子句中包含该异常。
- en: Runtime exceptions are checked exceptions.
  id: totrans-767
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时异常是检查异常。
- en: '**[Q7-3.](#ch07qa2q0a3)**'
  id: totrans-768
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-3.](#ch07qa2q0a3)**'
- en: ''
  id: totrans-769
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Examine the following code and select the correct option(s):'
  id: totrans-770
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查以下代码并选择正确的选项（s）：
- en: ''
  id: totrans-771
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-772
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ''
  id: totrans-773
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If the class `EJavaGuruExcep` is executed using the following command, it prints
    `NullPointerException`:'
  id: totrans-774
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用以下命令执行类 `EJavaGuruExcep`，它将打印 `NullPointerException`：
- en: ''
  id: totrans-775
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-776
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ''
  id: totrans-777
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-778
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the class `EJavaGuruExcep` is executed using the following command, it prints
    `IndexOutOfBoundsException`:'
  id: totrans-779
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用以下命令执行类 `EJavaGuruExcep`，它将打印 `IndexOutOfBoundsException`：
- en: ''
  id: totrans-780
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-781
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ''
  id: totrans-782
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-783
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the class `EJavaGuruExcep` is executed using the following command, it prints
    `ArrayIndexOutOfBoundsException`:'
  id: totrans-784
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用以下命令执行类 `EJavaGuruExcep`，它将打印 `ArrayIndexOutOfBoundsException`：
- en: ''
  id: totrans-785
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-786
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ''
  id: totrans-787
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-788
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The code will fail to compile.
  id: totrans-789
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将无法编译。
- en: '**[Q7-4.](#ch07qa2q0a4)**'
  id: totrans-790
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-4.](#ch07qa2q0a4)**'
- en: ''
  id: totrans-791
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-792
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-793
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-794
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ''
  id: totrans-795
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-796
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE52]'
- en: ''
  id: totrans-797
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-798
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-799
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ''
  id: totrans-800
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-801
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-802
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ''
  id: totrans-803
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-804
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-805
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ''
  id: totrans-806
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-807
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The code fails to compile.
  id: totrans-808
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码无法编译。
- en: '**[Q7-5.](#ch07qa2q0a5)**'
  id: totrans-809
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-5.](#ch07qa2q0a5)**'
- en: ''
  id: totrans-810
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-811
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-812
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-813
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ''
  id: totrans-814
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The code outputs a value.
  id: totrans-815
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码输出一个值。
- en: The code outputs a value followed by an exception.
  id: totrans-816
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码输出一个值后跟一个异常。
- en: '`ArithmeticException`'
  id: totrans-817
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ArithmeticException`'
- en: '`NullPointerException`'
  id: totrans-818
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NullPointerException`'
- en: '`IndexOutOfBoundsException`'
  id: totrans-819
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IndexOutOfBoundsException`'
- en: '`ArrayIndexOutOfBoundsException`'
  id: totrans-820
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ArrayIndexOutOfBoundsException`'
- en: Compilation error
  id: totrans-821
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: None of the above
  id: totrans-822
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆非
- en: '**[Q7-6.](#ch07qa2q0a6)**'
  id: totrans-823
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-6.](#ch07qa2q0a6)**'
- en: ''
  id: totrans-824
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following methods will not compile?
  id: totrans-825
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个方法将无法编译？
- en: ''
  id: totrans-826
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-827
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ''
  id: totrans-828
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-829
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-830
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ''
  id: totrans-831
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-832
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-833
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ''
  id: totrans-834
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-835
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-836
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ''
  id: totrans-837
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-838
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-839
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**[Q7-7.](#ch07qa2q0a7)**'
  id: totrans-840
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-7.](#ch07qa2q0a7)**'
- en: ''
  id: totrans-841
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-842
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-843
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-844
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE62]'
- en: ''
  id: totrans-845
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`10`'
  id: totrans-846
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`10`'
- en: '`11`'
  id: totrans-847
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`11`'
- en: '`12`'
  id: totrans-848
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`12`'
- en: Compilation error
  id: totrans-849
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: Runtime exception
  id: totrans-850
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时异常
- en: '**[Q7-8.](#ch07qa2q0a8)**'
  id: totrans-851
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-8.](#ch07qa2q0a8)**'
- en: ''
  id: totrans-852
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-853
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-854
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-855
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE63]'
- en: ''
  id: totrans-856
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-857
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE64]'
- en: ''
  id: totrans-858
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-859
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-860
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE65]'
- en: ''
  id: totrans-861
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-862
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-863
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE66]'
- en: ''
  id: totrans-864
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-865
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-866
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE67]'
- en: ''
  id: totrans-867
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-868
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compilation error
  id: totrans-869
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: '**[Q7-9.](#ch07qa2q0a9)**'
  id: totrans-870
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-9.](#ch07qa2q0a9)**'
- en: ''
  id: totrans-871
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following statements are true?
  id: totrans-872
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个陈述是正确的？
- en: ''
  id: totrans-873
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A user-defined class may not throw an `IllegalStateException`. It must be thrown
    only by Java API classes.
  id: totrans-874
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户定义的类可能不会抛出 `IllegalStateException`。它必须仅由 Java API 类抛出。
- en: '`System.out.println` will throw a `NullPointerException` if an uninitialized
    instance variable of type `String` is passed to it to print its value.'
  id: totrans-875
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果将未初始化的 `String` 类型的实例变量传递给 `System.out.println` 来打印其值，它将抛出 `NullPointerException`。
- en: '`NumberFormatException` is thrown by multiple methods from the Java API when
    invalid numbers are passed on as `String`s to be converted to the specified number
    format.'
  id: totrans-876
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当将无效数字作为 `String` 传递给 Java API 的多个方法以转换为指定的数字格式时，会抛出 `NumberFormatException`。
- en: '`ExceptionInInitializerError` may be thrown by the JVM when a `static` initializer
    in your code throws a `NullPointerException`.'
  id: totrans-877
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你的代码中的 `static` 初始化器抛出 `NullPointerException` 时，JVM 可能会抛出 `ExceptionInInitializerError`。
- en: '**[Q7-10.](#ch07qa2q0a10)**'
  id: totrans-878
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-10.](#ch07qa2q0a10)**'
- en: ''
  id: totrans-879
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-880
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-881
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-882
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE68]'
- en: ''
  id: totrans-883
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-884
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE69]'
- en: ''
  id: totrans-885
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-886
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-887
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE70]'
- en: ''
  id: totrans-888
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-889
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-890
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE71]'
- en: ''
  id: totrans-891
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-892
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-893
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 7.9\. Answers to sample exam questions
  id: totrans-894
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.9\. 样本考试问题答案
- en: '**[Q7-1.](#ch07qa1q1)**'
  id: totrans-895
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-1.](#ch07qa1q1)**'
- en: ''
  id: totrans-896
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'What is the output of the following code:'
  id: totrans-897
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么：
- en: ''
  id: totrans-898
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-899
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE73]'
- en: ''
  id: totrans-900
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The code will print `Java`.
  id: totrans-901
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将打印 `Java`。
- en: The code will print `Oracle`.
  id: totrans-902
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将打印 `Oracle`。
- en: The code will not compile.
  id: totrans-903
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码将无法编译。
- en: '**The code will throw an exception or an error at runtime.**'
  id: totrans-904
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码将在运行时抛出异常或错误。**'
- en: ''
  id: totrans-905
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: d'
  id: totrans-906
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：d
- en: ''
  id: totrans-907
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: This class will throw a `StackOverflowError` at runtime. The easiest
    way to look for a `StackOverflowError` is to locate recursive method calls. In
    the question’s code, the constructor of the class `Course` creates an object of
    the class `Course`, which will call the constructor again. Hence, this becomes
    a recursive call and ends up throwing a `StackOverflowError` at runtime. (As you
    know, an exception or an error can be thrown only at runtime, not compile time.)'
  id: totrans-908
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：此类将在运行时抛出 `StackOverflowError`。寻找 `StackOverflowError` 的最简单方法是在代码中定位递归方法调用。在问题的代码中，`Course`
    类的构造函数创建了一个 `Course` 类的对象，这将再次调用构造函数。因此，这变成了一个递归调用，最终在运行时抛出 `StackOverflowError`。（正如你所知，异常或错误只能在运行时抛出，不能在编译时抛出。）
- en: '**[Q7-2.](#ch07qa1q2)**'
  id: totrans-909
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-2.](#ch07qa1q2)**'
- en: ''
  id: totrans-910
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Select the correct option(s):'
  id: totrans-911
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选择正确的选项：
- en: ''
  id: totrans-912
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You cannot handle runtime exceptions.
  id: totrans-913
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你无法处理运行时异常。
- en: '**You should not handle errors.**'
  id: totrans-914
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你不应该处理错误。**'
- en: '**If a method throws a checked exception, it must be either handled by the
    method or specified in its `throws` clause.**'
  id: totrans-915
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果一个方法抛出检查型异常，它必须由该方法处理或指定在其 `throws` 子句中。**'
- en: '**If a method throws a runtime exception, it may include the exception in its
    `throws` clause.**'
  id: totrans-916
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**如果一个方法抛出运行时异常，它可以在其 `throws` 子句中包含该异常。**'
- en: Runtime exceptions are checked exceptions.
  id: totrans-917
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时异常是检查型异常。
- en: ''
  id: totrans-918
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: b, c, d'
  id: totrans-919
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：b, c, d
- en: ''
  id: totrans-920
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Option (a) is incorrect. You can handle runtime exceptions the
    way you can handle a checked exception in your code: using a `try-catch` block.'
  id: totrans-921
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：选项 (a) 是不正确的。你可以像处理检查型异常一样处理运行时异常：使用 `try-catch` 块。
- en: ''
  id: totrans-922
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (b) is correct. You shouldn’t try to handle errors in your code. Or,
    to put it another way, you can’t do much when an error is thrown by your code.
    Instead of trying to handle errors in your code, you should resolve the code that
    results in these errors. For example, `StackOverflowError` is an error that will
    be thrown by your code if your code executes a method recursively without any
    exit condition. This repetition will consume all the space on the stack and result
    in a `StackOverflowError`.
  id: totrans-923
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (b) 是正确的。你不应该在代码中尝试处理错误。或者换句话说，当你的代码抛出错误时，你无法做太多。与其在代码中尝试处理错误，不如解决导致这些错误的代码。例如，`StackOverflowError`
    是一个错误，如果你的代码在没有任何退出条件的情况下递归执行方法，它将被抛出。这种重复将消耗栈上的所有空间，并导致 `StackOverflowError`。
- en: ''
  id: totrans-924
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (c) is correct. If you fail to implement either of these options, your
    code won’t compile.
  id: totrans-925
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (c) 是正确的。如果你未能实现这些选项中的任何一个，你的代码将无法编译。
- en: ''
  id: totrans-926
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (d) is correct. It isn’t mandatory for runtime exceptions to be included
    in a method’s `throws` clause. Usually this inclusion is unnecessary, but if you
    do include it, your code will execute without any issues.
  id: totrans-927
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (d) 是正确的。运行时异常不需要包含在方法的 `throws` 子句中。通常这种包含是不必要的，但如果你包含了它，你的代码将无任何问题地执行。
- en: ''
  id: totrans-928
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (e) is incorrect. A runtime exception and all its subclasses are *not*
    checked exceptions.
  id: totrans-929
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (e) 是不正确的。运行时异常及其所有子类都不是检查型异常。
- en: '**[Q7-3.](#ch07qa1q3)**'
  id: totrans-930
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-3.](#ch07qa1q3)**'
- en: ''
  id: totrans-931
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Examine the following code and select the correct option(s):'
  id: totrans-932
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查以下代码并选择正确的选项：
- en: ''
  id: totrans-933
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-934
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE74]'
- en: ''
  id: totrans-935
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If the class `EJavaGuruExcep` is executed using the following command, it prints
    `NullPointerException`:'
  id: totrans-936
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如果使用以下命令执行类 `EJavaGuruExcep`，它将打印 `NullPointerException`:'
- en: ''
  id: totrans-937
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-938
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: ''
  id: totrans-939
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-940
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the class `EJavaGuruExcep` is executed using the following command, it prints
    `IndexOutOfBoundsException`:'
  id: totrans-941
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如果使用以下命令执行类 `EJavaGuruExcep`，它将打印 `IndexOutOfBoundsException`:'
- en: ''
  id: totrans-942
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-943
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: ''
  id: totrans-944
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-945
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the class `EJavaGuruExcep` is executed using the following command, it prints
    `ArrayIndexOutOfBoundsException`:'
  id: totrans-946
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如果使用以下命令执行类 `EJavaGuruExcep`，它将打印 `ArrayIndexOutOfBoundsException`:'
- en: ''
  id: totrans-947
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-948
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: ''
  id: totrans-949
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-950
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The code will fail to compile.**'
  id: totrans-951
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码将无法编译。**'
- en: ''
  id: totrans-952
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: d'
  id: totrans-953
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：d
- en: ''
  id: totrans-954
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: The key to answering this question is to be aware of the following
    two facts:'
  id: totrans-955
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：回答此问题的关键是要意识到以下两个事实：
- en: ''
  id: totrans-956
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Exceptions are classes. If an exception’s base class is used in a `catch` block,
    it can catch all the exceptions of its derived class. If you try to catch an exception
    from its derived class afterward, the code won’t compile.
  id: totrans-957
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常是类。如果使用异常的基类在 `catch` 块中，它可以捕获其所有派生类的异常。如果你之后尝试捕获其派生类的异常，代码将无法编译。
- en: '`ArrayIndexOutOfBoundsException` is a derived class of `IndexOutOfBounds-Exception`.'
  id: totrans-958
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArrayIndexOutOfBoundsException` 是 `IndexOutOfBoundsException` 的一个派生类。'
- en: ''
  id: totrans-959
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The rest of the points try to trick you into believing that the question is
    based on the arguments passed to a `main` method.
  id: totrans-960
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 其余的要点试图让你相信问题基于传递给 `main` 方法的参数。
- en: '**[Q7-4.](#ch07qa1q4)**'
  id: totrans-961
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-4.](#ch07qa1q4)**'
- en: ''
  id: totrans-962
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-963
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-964
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-965
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE78]'
- en: ''
  id: totrans-966
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-967
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE79]'
- en: ''
  id: totrans-968
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-969
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-970
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE80]'
- en: ''
  id: totrans-971
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-972
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-973
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE81]'
- en: ''
  id: totrans-974
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-975
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-976
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE82]'
- en: ''
  id: totrans-977
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-978
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The code fails to compile.
  id: totrans-979
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码无法编译。
- en: ''
  id: totrans-980
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: b'
  id: totrans-981
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：b
- en: ''
  id: totrans-982
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: No compilation errors exist with the code.'
  id: totrans-983
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：代码中没有编译错误。
- en: ''
  id: totrans-984
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The method `guru` throws `StackOverflowError`, which is not a checked exception.
    Even though your code shouldn’t throw an error, it is possible syntactically.
    Your code will compile successfully.
  id: totrans-985
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 方法 `guru` 抛出 `StackOverflowError`，这不是一个检查型异常。即使你的代码不应该抛出错误，从语法上讲是可能的。你的代码将成功编译。
- en: ''
  id: totrans-986
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The call to the method `guru` is immediately followed by the keyword `return`,
    which is supposed to end the execution of the method `method`. But the call to
    `guru` is placed within a `try-catch` block, with a `finally` block. Because `guru`
    doesn’t handle the error `StackOverflowError` itself, the control looks for the
    exception handler in the method `method`. This calling method doesn’t handle this
    error but defines a `finally` block. The control then executes the `finally` block.
    Because the code can’t find an appropriate handler to handle this error, it propagates
    to the JVM, which abruptly halts the code.
  id: totrans-987
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 方法 `guru` 的调用紧随 `return` 关键字之后，本应结束 `method` 方法的执行。但是 `guru` 的调用位于一个 `try-catch`
    块中，并包含一个 `finally` 块。由于 `guru` 没有自己处理 `StackOverflowError` 错误，控制流会寻找 `method`
    方法中的异常处理器。调用该方法的方法没有处理这个错误，但定义了一个 `finally` 块。然后控制流执行 `finally` 块。由于代码找不到适当的处理器来处理这个错误，错误会传播到
    JVM，导致代码突然中断。
- en: '**[Q7-5.](#ch07qa1q5)**'
  id: totrans-988
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-5.](#ch07qa1q5)**'
- en: ''
  id: totrans-989
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-990
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-991
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-992
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE83]'
- en: ''
  id: totrans-993
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The code outputs a value.
  id: totrans-994
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码输出一个值。
- en: The code outputs a value followed by an exception.
  id: totrans-995
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码输出一个值后跟一个异常。
- en: '**`ArithmeticException`**'
  id: totrans-996
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`ArithmeticException`**'
- en: '`NullPointerException`'
  id: totrans-997
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NullPointerException`'
- en: '`IndexOutOfBoundsException`'
  id: totrans-998
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IndexOutOfBoundsException`'
- en: '`ArrayIndexOutOfBoundsException`'
  id: totrans-999
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ArrayIndexOutOfBoundsException`'
- en: Compilation error
  id: totrans-1000
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: None of the above
  id: totrans-1001
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上皆非
- en: ''
  id: totrans-1002
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: c'
  id: totrans-1003
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：c
- en: ''
  id: totrans-1004
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Apart from testing your exception-handling skills, this question
    also tests you in operator precedence. The code throws an `ArithmeticException`
    in an attempt to evaluate the following expression:'
  id: totrans-1005
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：除了测试你的异常处理技能外，这个问题还测试了你在运算符优先级方面的能力。代码在尝试评估以下表达式时抛出 `ArithmeticException`：
- en: ''
  id: totrans-1006
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-1007
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE84]'
- en: ''
  id: totrans-1008
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Before execution of the preceding line of code, `arr[1]` stores value `2`, `arr[0]`
    stores value `1`, and `arr[4]` isn’t initialized. So an attempt to access `arr[4]`
    would result in an `ArrayIndexOutOfBoundsException`.
  id: totrans-1009
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在执行前面的代码行之前，`arr[1]` 存储的值是 `2`，`arr[0]` 存储的值是 `1`，而 `arr[4]` 没有被初始化。因此尝试访问 `arr[4]`
    将导致 `ArrayIndexOutOfBoundsException`。
- en: ''
  id: totrans-1010
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In an arithmetic operation, post- and pre-increment operators have the highest
    precedence. So the first pass reduces this equation to
  id: totrans-1011
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在算术运算中，后缀和前缀增量运算符具有最高的优先级。因此，第一次遍历将此方程简化为
- en: ''
  id: totrans-1012
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-1013
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE85]'
- en: ''
  id: totrans-1014
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Both `*` and `/` have equal precedence level here. What matters beyond operator
    precedence is reading the same-level operations from left to right. This is why
    `/` is computed before `*` in the present expression. So an attempt to execute
    `1/0` throws an `ArithmeticException`.
  id: totrans-1015
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这里，`*` 和 `/` 具有相同的优先级。除了运算符优先级之外，重要的是从左到右读取相同优先级的操作。这就是为什么在当前表达式中先计算 `/` 而不是
    `*`。因此尝试执行 `1/0` 会抛出 `ArithmeticException`。
- en: '**[Q7-6.](#ch07qa1q6)**'
  id: totrans-1016
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-6.](#ch07qa1q6)**'
- en: ''
  id: totrans-1017
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following methods will not compile?
  id: totrans-1018
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个方法无法编译？
- en: ''
  id: totrans-1019
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-1020
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE86]'
- en: ''
  id: totrans-1021
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1022
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-1023
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE87]'
- en: ''
  id: totrans-1024
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1025
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-1026
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE88]'
- en: ''
  id: totrans-1027
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1028
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-1029
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE89]'
- en: ''
  id: totrans-1030
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1031
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-1032
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE90]'
- en: ''
  id: totrans-1033
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1034
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1035
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: b, d'
  id: totrans-1036
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：b, d
- en: ''
  id: totrans-1037
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: Methods that compile successfully might not be implemented correctly.
    This question only asks about the methods that will follow the syntax rules so
    that they compile successfully.'
  id: totrans-1038
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 说明：编译成功的代码可能实现不正确。这个问题只询问那些遵循语法规则从而可以编译成功的代码。
- en: ''
  id: totrans-1039
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (a) code compiles successfully. Because `IllegalArgumentException` is
    a runtime exception, `method1()` can throw it without declaring it to be thrown
    in its `throws` statement.
  id: totrans-1040
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (a) 的代码可以成功编译。因为 `IllegalArgumentException` 是一个运行时异常，`method1()` 可以抛出它，而无需在它的
    `throws` 语句中声明。
- en: ''
  id: totrans-1041
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (b) code won’t compile. `method2()` throws a checked exception, that
    is, `Exception`, without declaring it to be thrown in its `throws` statement.
  id: totrans-1042
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (b) 的代码无法编译。`method2()` 抛出一个检查型异常，即 `Exception`，但没有在它的 `throws` 语句中声明。
- en: ''
  id: totrans-1043
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Although the code in option (c) makes little sense, it will compile successfully.
    A method can throw a `StackOverflowError` (an unchecked exception) without including
    it in the `throws` clause of its method declaration.
  id: totrans-1044
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管选项 (c) 中的代码意义不大，但它可以成功编译。一个方法可以抛出 `StackOverflowError`（一个未检查的异常），而无需将其包含在其方法声明的
    `throws` 子句中。
- en: ''
  id: totrans-1045
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (d) code won’t compile. If a method declares to throw a checked exception,
    its body can’t throw a more general exception in its body. `method4()` declares
    to throw `Exception` but throws `Throwable`, which is not allowed (`Exception`
    subclasses `Throwable`).
  id: totrans-1046
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (d) 的代码不会编译。如果一个方法声明抛出已检查的异常，其方法体不能抛出更一般的异常。`method4()` 声明抛出 `Exception`
    但抛出 `Throwable`，这是不允许的（`Exception` 是 `Throwable` 的子类）。
- en: ''
  id: totrans-1047
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (e) code will compile successfully. If a method declares to throw `Exception`,
    it might not actually throw it. This only applies to `Exception` (because `Runtime-Exception`
    subclasses it), runtime exceptions, and errors.
  id: totrans-1048
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (e) 的代码可以成功编译。如果一个方法声明抛出 `Exception`，它实际上可能不会抛出它。这仅适用于 `Exception`（因为 `RuntimeException`
    是它的子类）、运行时异常和错误。
- en: '**[Q7-7.](#ch07qa1q7)**'
  id: totrans-1049
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-7.](#ch07qa1q7)**'
- en: ''
  id: totrans-1050
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1051
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1052
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-1053
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE91]'
- en: ''
  id: totrans-1054
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`10`'
  id: totrans-1055
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`10`'
- en: '`11`'
  id: totrans-1056
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`11`'
- en: '**`12`**'
  id: totrans-1057
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`12`**'
- en: Compilation error
  id: totrans-1058
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: Runtime exception
  id: totrans-1059
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时异常
- en: ''
  id: totrans-1060
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: c'
  id: totrans-1061
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：c
- en: ''
  id: totrans-1062
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: The `try` block executes, incrementing the value of variable `a`
    to `11`. This step is followed by execution of the `finally` block, which also
    increments the value of variable `a` by `1`, to `12`. The method `tryAgain` returns
    the value `12`, which is printed by the method `main`.'
  id: totrans-1063
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：`try` 块执行，变量 `a` 的值增加到 `11`。此步骤之后是执行 `finally` 块，它也将变量 `a` 的值增加 `1`，变为 `12`。`tryAgain`
    方法返回值 `12`，由 `main` 方法打印。
- en: ''
  id: totrans-1064
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There are no compilation issues with the code. A `try` block can be followed
    by a `finally` block without any `catch` blocks. Even though the `try` block doesn’t
    throw any exceptions, it compiles successfully. The following is an example of
    a `try`-`catch` block that won’t compile because it tries to *catch* a checked
    exception that’s never thrown by the `try` block:'
  id: totrans-1065
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 代码没有编译问题。一个 `try` 块可以跟一个 `finally` 块，而不需要任何 `catch` 块。即使 `try` 块没有抛出任何异常，它也可以成功编译。以下是一个不会编译的
    `try`-`catch` 块的例子，因为它试图 *捕获* 一个 `try` 块永远不会抛出的已检查的异常：
- en: ''
  id: totrans-1066
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-1067
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '**[Q7-8.](#ch07qa1q8)**'
  id: totrans-1068
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-8.](#ch07qa1q8)**'
- en: ''
  id: totrans-1069
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1070
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1071
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-1072
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE93]'
- en: ''
  id: totrans-1073
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`Base`'
  id: totrans-1074
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Base`'
- en: '`Derived`'
  id: totrans-1075
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Derived`'
- en: '`Derived` `Base`'
  id: totrans-1076
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Derived` `Base`'
- en: '[PRE94]'
  id: totrans-1077
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE94]'
- en: ''
  id: totrans-1078
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1079
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compilation error
  id: totrans-1080
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译错误
- en: ''
  id: totrans-1081
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: b'
  id: totrans-1082
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：b
- en: ''
  id: totrans-1083
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: The rule that if a base class method doesn’t throw an exception,
    an overriding method in the derived class can’t throw an exception applies only
    to checked exceptions. It doesn’t apply to runtime (unchecked) exceptions or errors.
    A base or overridden method is free to throw any `error` or runtime exception.'
  id: totrans-1084
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：如果基类方法不抛出异常，则派生类中重写的方法也不能抛出异常的规则仅适用于已检查的异常。它不适用于运行时（未检查）异常或错误。基类或重写的方法可以自由地抛出任何
    `error` 或运行时异常。
- en: '**[Q7-9.](#ch07qa1q9)**'
  id: totrans-1085
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-9.](#ch07qa1q9)**'
- en: ''
  id: totrans-1086
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Which of the following statements are true?
  id: totrans-1087
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下哪个陈述是正确的？
- en: ''
  id: totrans-1088
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A user-defined class may not throw an `IllegalStateException`. It must be thrown
    only by Java API classes.
  id: totrans-1089
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户定义的类不能抛出 `IllegalStateException`。它只能由 Java API 类抛出。
- en: '`System.out.println` will throw a `NullPointerException` if an uninitialized
    instance variable of type `String` is passed to it to print its value.'
  id: totrans-1090
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果将未初始化的 `String` 类型的实例变量传递给 `System.out.println` 以打印其值，它将抛出 `NullPointerException`。
- en: '**`NumberFormatException` is thrown by multiple methods from the Java API when
    invalid numbers are passed on as `String`s to be converted to the specified number
    format.**'
  id: totrans-1091
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`NumberFormatException` 在 Java API 的多个方法中抛出，当将无效数字作为 `String` 传递以转换为指定的数字格式时。**'
- en: '**`ExceptionInInitializerError` may be thrown by the JVM when a `static` initializer
    in your code throws a `NullPointerException`**.'
  id: totrans-1092
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当你的代码中的 `static` 初始化器抛出 `NullPointerException` 时，JVM 可能会抛出 `ExceptionInInitializerError`**。'
- en: ''
  id: totrans-1093
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: c, d'
  id: totrans-1094
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：c, d
- en: ''
  id: totrans-1095
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (a) is incorrect. A user-defined class can throw any exception from the
    Java API.
  id: totrans-1096
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (a) 是不正确的。用户定义的类可以抛出 Java API 中的任何异常。
- en: ''
  id: totrans-1097
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Option (b) is incorrect. An uninitialized instance variable of type `String`
    will be assigned a default value of `null`. When you pass this variable to `System.out.println`
    to print it, it will print `null`. If you try to access any non-static member
    (variable or method) of this `null` object, then a `NullPointerException` will
    be thrown.
  id: totrans-1098
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选项 (b) 是错误的。未初始化的类型为 `String` 的实例变量将被分配一个默认值 `null`。当你将这个变量传递给 `System.out.println`
    来打印它时，它会打印 `null`。如果你尝试访问这个 `null` 对象的任何非静态成员（变量或方法），则会抛出 `NullPointerException`。
- en: '**[Q7-10.](#ch07qa1q10)**'
  id: totrans-1099
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q7-10.](#ch07qa1q10)**'
- en: ''
  id: totrans-1100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-1101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: ''
  id: totrans-1102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-1103
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE95]'
- en: ''
  id: totrans-1104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-1105
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE96]'
- en: ''
  id: totrans-1106
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1107
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-1108
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE97]'
- en: ''
  id: totrans-1109
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1110
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-1111
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE98]'
- en: ''
  id: totrans-1112
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1113
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-1114
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE99]'
- en: ''
  id: totrans-1115
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1116
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Answer: d'
  id: totrans-1118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 答案：d
- en: ''
  id: totrans-1119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Explanation: First of all, nested `try-catch` statements don’t throw compilation
    errors.'
  id: totrans-1120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解释：首先，嵌套的 `try-catch` 语句不会抛出编译错误。
- en: ''
  id: totrans-1121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Because the variable `s` hasn’t been initialized, an attempt to access its method
    `length()` will throw a `NullPointerException`. The inner `try-catch` block handles
    this exception and prints `inner`. The control then moves on to complete the remaining
    code in the outer `try-catch` block, printing `2`. Because the `NullPointerException`
    was already handled in the inner `try-catch` block, it’s not handled in the outer
    `try-catch` block.
  id: totrans-1122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 因为变量 `s` 没有被初始化，尝试访问其方法 `length()` 将会抛出 `NullPointerException`。内部的 `try-catch`
    块处理了这个异常并打印了 `inner`。然后控制权转移到外部 `try-catch` 块的剩余代码，打印了 `2`。因为 `NullPointerException`
    已经在内部 `try-catch` 块中被处理，所以它不会被外部 `try-catch` 块处理。
