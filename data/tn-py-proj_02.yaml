- en: 1  How to write and test a Python program
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1  如何编写和测试 Python 程序
- en: '| Before you start working on the exercises, I want to discuss how to write
    programs that are documented and tested. Specifically, we’re going to'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '| 在你开始做练习之前，我想讨论如何编写有文档和测试的程序。具体来说，我们将'
- en: Write a Python program to say “Hello, World!”
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序来输出“Hello, World!”
- en: Handle command-line arguments using `argparse`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `argparse` 处理命令行参数
- en: Run tests for the code with Pytest.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Pytest 运行代码测试。
- en: Learn about `$PATH`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 `$PATH`
- en: Use tools like YAPF and Black to format the code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用像 YAPF 和 Black 这样的工具来格式化代码
- en: Use tools like Flake8 and Pylint to find problems in the code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用像 Flake8 和 Pylint 这样的工具来查找代码中的问题
- en: Use the new.py program to create new programs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 new.py 程序来创建新程序
- en: '| ![](../Images/1-unnumb-1.png) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| ![](../Images/1-unnumb-1.png) |'
- en: 1.1 Creating your first program
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 创建你的第一个程序
- en: It’s pretty common to write “Hello, World!” as your first program in any language,
    so let’s start there. We’re going to work toward making a version that will greet
    whichever name is passed as an argument. It will also print a helpful message
    when we ask for it, and we’ll use tests to make sure it does everything correctly.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何语言中，将“Hello, World!”作为你的第一个程序是很常见的，所以让我们从这里开始。我们将努力制作一个版本，它可以问候作为参数传递的任何名字。当需要时，它还会打印一条有用的消息，我们将使用测试来确保它正确地完成所有操作。
- en: In the 01_hello directory, you’ll see several versions of the hello program
    we’ll write. There is also a program called test.py that we’ll use to test the
    program.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 01_hello 目录中，你会看到我们将要编写的 hello 程序的几个版本。还有一个名为 test.py 的程序，我们将用它来测试程序。
- en: Start off by creating a text file called hello.py in that directory. If you
    are working in VS Code or PyCharm, you can use File > Open to open the 01_hello
    directory as a project. Both tools have something like a File > New menu option
    that will allow you to create a new file in that directory. It’s very important
    to create the hello.py file *inside* the 01_hello directory so that the test.py
    program can find it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在那个目录中创建一个名为 hello.py 的文本文件。如果你在 VS Code 或 PyCharm 中工作，你可以使用文件 > 打开来将 01_hello
    目录作为项目打开。这两个工具都有一个类似文件 > 新建菜单选项，允许你在该目录中创建新文件。在 01_hello 目录内创建 hello.py 文件非常重要，这样
    test.py 程序才能找到它。
- en: 'Once you’ve started a new file, add this line:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始了一个新文件，添加以下行：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It’s time to run your new program! Open a terminal window in VS Code or PyCharm
    or in some other terminal, and navigate to the directory where your hello.py program
    is located. You can run it with the command `python3` `hello.py`--this causes
    Python version 3 to execute the commands in the file named hello.py. You should
    see this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行你的新程序了！在 VS Code 或 PyCharm 中打开一个终端窗口，或者在任何其他终端中，导航到你的 hello.py 程序所在的目录。你可以使用命令
    `python3 hello.py` 来运行它——这将导致 Python 3 版本执行名为 hello.py 的文件中的命令。你应该看到以下内容：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Figure 1.1 shows how it looks in the Repl.it interface.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 显示了它在 Repl.it 界面中的样子。
- en: '![](../Images/1-1.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1-1.png)'
- en: Figure 1.1 Writing and running our first program using Repl.it
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 使用 Repl.it 编写和运行我们的第一个程序
- en: If that was your first Python program, congratulations!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你的第一个 Python 程序，恭喜你！
- en: 1.2 Comment lines
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 注释行
- en: '| In Python, the `#` character and anything following it is ignored by Python.
    This is useful for adding comments to your code or temporarily disabling lines
    of code when testing and debugging. It’s always a good idea to document your programs,
    indicating the purpose of the program or the author’s name and email address,
    or both. We can use a comment for that: | ![](../Images/1-unnumb-2.png) |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 在 Python 中，`#` 字符及其后面的任何内容都会被 Python 忽略。这有助于在代码中添加注释或在测试和调试时临时禁用代码行。始终记录你的程序是个好主意，表明程序的目的或作者的姓名和电子邮件地址，或者两者都要。我们可以用注释来做这件事：|
    ![](../Images/1-unnumb-2.png) |'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you run this program again, you should see the same output as before because
    the “Purpose” line is ignored. Note that any text to the left of the `#` is executed,
    so you can add a comment to the end of a line if you like.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次运行此程序，你应该看到与之前相同的输出，因为“目的”行被忽略了。请注意，任何位于 `#` 左侧的文本都会被执行，所以如果你喜欢，可以在行尾添加注释。
- en: 1.3 Testing your program
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 测试你的程序
- en: The most fundamental idea I want to teach you is how to test your programs.
    I’ve written a test.py program in the 01_hello directory that we can use to test
    our new hello.py program.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我最想教给你的基本思想是如何测试你的程序。我在 01_hello 目录中编写了一个 test.py 程序，我们可以用它来测试我们新的 hello.py
    程序。
- en: We will use pytest to execute all the commands and tell us how many tests we
    passed. We’ll include the `-v` option, which tells `pytest` to create “verbose”
    output. If you run it like this, you should see the following output as the first
    several lines. After that will follow many more lines showing you more information
    about the tests that didn’t pass.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 pytest 来执行所有命令并告诉我们我们通过了多少个测试。我们将包括 `-v` 选项，它告诉 pytest 创建“详细”输出。如果你这样运行它，你应该看到以下输出作为前几行。之后将跟随更多行，显示有关未通过测试的更多信息。
- en: 'Note If you get the error “pytest: command not found,” you need to install
    the `pytest` module. Refer to the “Installing modules” section in the book’s introduction.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '注意：如果你得到“pytest: 命令未找到”的错误，你需要安装 `pytest` 模块。请参阅本书引言中的“安装模块”部分。'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ① The first test always checks that the expected file exists. Here the test
    looks for hello.py.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ① 第一次测试始终检查预期的文件是否存在。这里测试正在寻找 hello.py。
- en: ② The second test tries to run the program with python3 hello.py and then checks
    if the program printed “Hello, World!” If you miss even one character, like forgetting
    a comma, the test will point out the error, so read carefully!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ② 第二次测试尝试使用 python3 hello.py 运行程序，然后检查程序是否打印了 “Hello, World!” 如果你遗漏了任何一个字符，比如忘记了一个逗号，测试将指出错误，所以请仔细阅读！
- en: ③ The third test checks that the program is “executable.” This test fails, so
    next we’ll talk about how to make that pass.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 第三次测试检查程序是否“可执行”。这个测试失败了，所以接下来我们将讨论如何让它通过。
- en: ④ The fourth test asks the program for help and doesn’t get anything. We’re
    going to add the ability to print a “usage” statement that describes how to use
    our program.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 第四次测试请求程序帮助，但没有得到任何回应。我们将添加打印 “usage” 语句的能力，该语句描述了如何使用我们的程序。
- en: ⑤ The last test checks that the program can greet a name that we’ll pass as
    an argument. Since our program doesn’t yet accept arguments, we’ll need to add
    that, too.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 最后一次测试检查程序能否问候我们作为参数传递的名字。由于我们的程序尚未接受参数，我们还需要添加这个功能。
- en: 'I’ve written the tests in an order that I hope will help you write the program
    in a logical fashion. If the program doesn’t pass one of the tests, there’s no
    reason to continue running the tests after it. I recommend you always run the
    tests with the flags `-x`, to stop on the first failing test, and `-v`, to print
    verbose output. You can combine these like `-xv` or `-vx`. Here’s what our tests
    look like with those options:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经按照我希望帮助你以逻辑顺序编写程序的顺序编写了测试。如果程序未通过某个测试，就没有理由在它之后继续运行测试。我建议你始终使用 `-x` 标志运行测试，以在第一个失败的测试时停止，并使用
    `-v` 标志以打印详细输出。你可以将这些标志组合起来，例如 `-xv` 或 `-vx`。以下是使用这些选项时我们的测试看起来像什么：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ① This test fails. No more tests are run because we ran pytest with the -x option.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ① 这个测试失败了。因为我们使用了 -x 选项运行 pytest，所以不再运行更多测试。
- en: ② The angle bracket (>) at the beginning of this line shows the source of the
    subsequent errors.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ② 这行开头的尖括号 (>) 表示后续错误的来源。
- en: ③ The “E” at the beginning of this line shows that this is an “Error” you should
    read. The AssertionError is saying that the test.py program is trying to execute
    the command ./hello.py to see if it will produce the text “Hello, World!”
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 这行开头的 “E” 表示这是一个“错误”你应该阅读。AssertionError 表示 test.py 程序正在尝试执行 ./hello.py 命令以查看它是否会输出文本
    “Hello, World!”
- en: ④ The hyphen character (-) is showing that the actual output from the command
    is “Permission denied.”
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 横杠字符 (-) 表示实际命令的输出是“权限被拒绝。”
- en: ⑤ The plus character (+) shows that the test expected to get “Hello, World!”
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 加号 (+) 表示测试期望得到 “Hello, World!”
- en: Let’s talk about how to fix this error.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈如何修复这个错误。
- en: '1.4 Adding the #! (shebang) line'
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '1.4 添加 #! (shebang) 行'
- en: One thing you have learned so far is that Python programs live in plain text
    files that you ask `python3` to execute. Many other programming languages, such
    as Ruby and Perl, work in the same way--we type Ruby or Perl commands into a text
    file and run it with the right language. It’s common to put a special comment
    line in programs like these to indicate which language needs to be used to execute
    the commands in the file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你到目前为止学到的一件事是，Python 程序生活在纯文本文件中，你要求 `python3` 来执行。许多其他编程语言，如 Ruby 和 Perl，以相同的方式工作--我们把这些语言的命令输入到文本文件中，并用正确的语言运行它。在这些程序中放置一个特殊的注释行来指示需要使用哪种语言来执行文件中的命令是很常见的。
- en: This comment line starts off with `#!`, and the nickname for this is “shebang”
    (pronounced “shuh-bang”--I always think of the `#` as the “shuh” and the `!` as
    the “bang!”). Just as with any other comment, Python will ignore the shebang,
    but the operating system (like macOS or Windows) will use it to decide which program
    to use to run the rest of the file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这条注释行以 `#!` 开头，这个昵称叫“shebang”（发音为“shuh-bang”——我总是把 `#` 想象成“shuh”，把 `!` 想象成“bang！”）。就像任何其他注释一样，Python
    会忽略 shebang，但操作系统（如 macOS 或 Windows）会使用它来决定使用哪个程序来运行文件的其余部分。
- en: 'Here is the shebang you should add:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你应该添加的 shebang：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `env` program will tell you about your “environment.” When I run `env`
    on my computer, I see many lines of output like `USER=kyclark` and `HOME=/Users/kyclark`.
    These values are accessible as the variables `$USER` and `$HOME`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`env` 程序会告诉你关于你的“环境”的信息。当我在我电脑上运行 `env` 时，我看到许多输出行，如 `USER=kyclark` 和 `HOME=/Users/kyclark`。这些值可以作为变量
    `$USER` 和 `$HOME` 访问：'
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you run `env` on your computer, you should see your login name and your home
    directory. They will, of course, have different values from mine, but we both
    (probably) have both of these concepts.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在你电脑上运行 `env`，你应该看到你的登录名和你的主目录。当然，它们的值会与我的不同，但我们（可能）都有这两个概念。
- en: 'You can use the `env` command to find and run programs. If you run `env` `python3`,
    it will run a `python3` program if it can find one. Here’s what I see on my computer:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `env` 命令来查找并运行程序。如果你运行 `env python3`，如果它能找到，就会运行一个 `python3` 程序。以下是我电脑上的显示结果：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `env` program is looking for `python3` in the environment. If Python has
    not been installed, it won’t be able to find it, but it’s also possible that Python
    has been installed more than once. You can use the `which` command to see which
    `python3` it finds:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`env` 程序正在环境中寻找 `python3`。如果 Python 没有安装，它将无法找到它，但 Python 也可能被安装了多次。你可以使用 `which`
    命令来查看它找到了哪个 `python3`：'
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If I run this on Repl.it, I can see that `python3` exists in a different place.
    Where does it exist on your computer?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在 Repl.it 上运行这个命令，我可以看到 `python3` 存在于不同的位置。它在你的电脑上存在在哪里？
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Just as my `$USER` name is different from yours, my `python3` is probably different
    from yours. If the `env` command is able to find a `python3`, it will execute
    it. As shown previously, if you run `python3` by itself, it will open a REPL.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我的 `$USER` 名称与你的不同一样，我的 `python3` 可能也与你的不同。如果 `env` 命令能够找到 `python3`，它就会执行它。如前所述，如果你单独运行
    `python3`，它将打开一个 REPL。
- en: If I were to put my `python3` path as the shebang line, like so,
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我把我的 `python3` 路径放在 shebang 行，就像这样，
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: my program would not work on another computer that has `python3` installed in
    a different location. I doubt it would work on your computer, either. This is
    why you should always use the `env` program to find the `python3` that is specific
    to the machine on which it’s running.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我的程序在另一个安装了 `python3` 但位置不同的电脑上运行，它可能不会工作。我怀疑它在你电脑上也不会工作。这就是为什么你应该始终使用 `env`
    程序来查找特定于运行它的机器的 `python3`。
- en: 'Now your program should look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的程序应该看起来是这样的：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ① The shebang line tells the operating system to use /usr/bin/env to find python3
    to interpret this program.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ① Shebang 行指示操作系统使用 /usr/bin/env 来查找 python3 以解释这个程序。
- en: ② A comment line documenting the purpose of the program
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ② 一条注释行，记录程序的用途
- en: ③ A Python command to print some text to the screen
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 一个 Python 命令，用于将一些文本打印到屏幕上
- en: 1.5 Making a program executable
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 使程序可执行
- en: '| So far we’ve been explicitly telling `python3` to run our program, but since
    we added the shebang, we can execute the program directly and let the OS figure
    out that it should use `python3`. The advantage of this is that we could copy
    our program to a directory where other programs live and execute it from anywhere
    on our computer.The first step in doing this is to make our program “executable”
    using the command `chmod` (*change mode*). Think of it as turning your program
    “on.” Run this command to make hello.py executable: | ![](../Images/1-unnumb-3.png)
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: 到目前为止，我们一直是明确地告诉 `python3` 运行我们的程序，但自从我们添加了 shebang 之后，我们可以直接执行程序，让操作系统自行判断应该使用
    `python3`。这种做法的优势在于，我们可以将我们的程序复制到其他程序所在的目录中，并在电脑的任何位置执行它。完成这一步的第一步是使用 `chmod`
    命令（*改变模式*）使我们的程序“可执行”。把它想象成把你的程序“打开”。运行以下命令使 hello.py 可执行：| ![](../Images/1-unnumb-3.png)
    |
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ① The +x will add an “executable” attribute to the file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ① +x 将向文件添加一个“可执行”属性。
- en: 'Now you can run the program like so:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以这样运行程序：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ① The . / is the current directory, and it’s necessary to run a program when
    you are in the same directory as the program.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ① `./` 是当前目录，当你与程序在同一个目录时运行程序是必要的。
- en: 1.6 Understanding $PATH
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 理解 $PATH
- en: 'One of the biggest reasons to set the shebang line and make your program executable
    is so that you can install your Python programs just like other commands and programs.
    We used the `which` command earlier to find the location of `python3` on the Repl.it
    instance:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 shebang 行并使你的程序可执行的最大原因之一是，你可以像其他命令和程序一样安装你的 Python 程序。我们之前使用了 `which` 命令来找到
    Repl.it 实例中 `python3` 的位置：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'How was the `env` program able to find it? Windows, macOS, and Linux all have
    a `$PATH` variable, which is a list of directories the OS will look in to find
    a program. For instance, here is the `$PATH` for my Repl.it instance:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`env` 程序是如何找到它的？Windows、macOS 和 Linux 都有一个 `$PATH` 变量，它是操作系统查找程序的目录列表。例如，这是我
    Repl.it 实例的 `$PATH`：'
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The directories are separated by colons (`:`). Notice that the directory where
    `python3` lives is the first one in `$PATH`. It’s a pretty long string, so I broke
    it with the `\` character to make it easier to read. If you copy your hello.py
    program to any of the directories listed in your `$PATH`, you can execute a program
    like hello.py without the leading `./` and without having to be in the same directory
    as the program.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 目录之间由冒号 (`:`) 分隔。注意，`python3` 所在的目录是 `$PATH` 中的第一个。这是一个相当长的字符串，所以我用反斜杠 (`\`)
    字符将其断开，以便更容易阅读。如果你将你的 hello.py 程序复制到 `$PATH` 中列出的任何目录，你就可以执行像 hello.py 这样的程序，而不需要前面的
    `./`，也不需要在与程序相同的目录中。
- en: 'Think about `$PATH` like this: If you lose your keys in your house, would you
    start looking in the upper-left kitchen cabinet and work your way through each
    cabinet, and then all the drawers where you keep your silverware and kitchen gadgets,
    and then move on to your bathrooms and bedroom closets? Or would you start by
    looking in places where you normally put your keys, like the key hooks beside
    the front door, and then move on to search the pockets of your favorite jacket
    and your purse or backpack, and then maybe look under the couch cushions, and
    so forth?'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这样想一下 `$PATH`：如果你在家里找不到钥匙，你会从左上角的厨房橱柜开始找，然后逐个检查每个橱柜，接着是存放餐具和厨房小工具的抽屉，然后转到浴室和卧室的衣柜？还是你会先从你通常放钥匙的地方开始找，比如前门旁边的钥匙挂钩，然后继续检查你最喜欢的夹克口袋和钱包或背包，然后可能看看沙发垫下，等等？
- en: The `$PATH` variable is a way of telling your computer to only look in places
    where executable programs can be found. The only alternative is for the OS to
    search *every directory*, and that could take several minutes or possibly even
    hours! You can control both the names of the directories in the `$PATH` variable
    and their relative order so that the OS will find the programs you need.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`$PATH` 变量是告诉计算机只在可执行程序可能存在的位置查找的一种方式。唯一的替代方案是让操作系统搜索 *每一个目录*，这可能会花费几分钟甚至几个小时！你可以控制
    `$PATH` 变量中目录的名称及其相对顺序，以便操作系统可以找到你需要的程序。'
- en: 'It’s very common for programs to be installed into /usr/local/bin, so we could
    try to copy our program there using the `cp` command. Unfortunately, I do not
    have permission to do this on Repl.it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 程序通常会被安装到 `/usr/local/bin`，所以我们可以尝试使用 `cp` 命令将我们的程序复制到那里。不幸的是，我在 Repl.it 上没有权限这样做：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'But I can do this on my own laptop:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我可以在自己的笔记本电脑上这样做：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'I can verify that the program is found:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以验证程序已被找到：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And now I can execute it from any directory on my computer:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以从计算机上的任何目录执行它：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 1.6.1 Altering your $PATH
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.6.1 修改你的 $PATH
- en: Often you may find yourself working on a computer that won’t allow you to install
    programs into your `$PATH`, such as on Repl.it. An alternative is to alter your
    `$PATH` to include a directory where you can put your programs. For instance,
    I often create a bin directory in my home directory, which can often be written
    with the tilde (~).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可能会发现自己正在一台不允许你将程序安装到 `$PATH` 的计算机上工作，比如在 Repl.it 上。一个替代方案是修改你的 `$PATH`，使其包括一个你可以放置程序的目录。例如，我经常在我的主目录中创建一个
    bin 目录，这通常可以用波浪号 (~) 来表示。
- en: 'On most computers, `~/bin` would mean “the bin directory in my home directory.”
    It’s also common to see `$HOME/bin` where `$HOME` is the name of your home directory.
    Here is how I create this directory on the Repl.it machine, copy a program to
    it, and then add it to my `$PATH`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数计算机上，`~/bin` 意味着“我的主目录中的 bin 目录。”也常见到 `$HOME/bin`，其中 `$HOME` 是你主目录的名称。以下是我如何在
    Repl.it 机器上创建这个目录，将程序复制到其中，并将其添加到我的 `$PATH` 的方法：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ① Use the mkdir (“make directory”) command to create ~/bin.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ① 使用 mkdir（“创建目录”）命令创建 ~/bin。
- en: ② Use the cp command to copy the 01_hello/hello.py program to the ~/bin directory.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ② 使用 cp 命令将 01_hello/hello.py 程序复制到 ~/bin 目录。
- en: ③ Put the ~/bin directory first in $PATH.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 将 ~/bin 目录放在 $PATH 的第一位。
- en: ④ Use the which command to look for the hello.py program. If the previous steps
    worked, the OS should now be able to find the program in one of the directories
    listed in $PATH.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 使用 which 命令查找 hello.py 程序。如果前面的步骤成功了，操作系统现在应该能够在 $PATH 中列出的目录之一中找到程序。
- en: Now I can be in any directory,
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以在任何目录下，
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'and I can run it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我可以运行它：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Although the shebang and the executable stuff may seem like a lot of work, the
    payoff is that you can create a Python program that can be installed onto your
    computer or anyone else’s and run just like any other program.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管shebang和可执行内容可能看起来像很多工作，但回报是你可以创建一个Python程序，可以安装到你的电脑或任何其他人的电脑上，就像其他任何程序一样运行。
- en: 1.7 Adding a parameter and help
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 添加参数和帮助
- en: Throughout the book, I’ll use string diagrams to visualize the inputs and outputs
    of the programs we’ll write. If we created one for our program now (as in figure
    1.2), there would be no inputs, and the output would always be “Hello, World!”
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我将使用弦图来可视化我们将要编写的程序的输入和输出。如果我们现在为我们的程序创建一个（如图 1.2 所示），那么将没有输入，输出将始终是“Hello,
    World!”
- en: '![](../Images/1-2.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1-2.png)'
- en: Figure 1.2 A string diagram representing our hello.py program that takes no
    inputs and always produces the same output
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 表示我们的 hello.py 程序的弦图，该程序不接受任何输入并总是产生相同的输出
- en: 'It’s not terribly interesting for our program to always say “Hello, World!”
    It would be nice if it could say “Hello” to something else, like the entire universe.
    We could do this by changing the code as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的程序总是说“Hello, World!”来说，这并不特别有趣。如果它能对其他事物说“Hello”，比如整个宇宙，那就更好了。我们可以通过以下方式更改代码来实现这一点：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: But that would mean we’d have to change the code every time we wanted to make
    it greet a different name. It would be better to change the *behavior* of the
    program without always having to change *the program itself*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但这意味着我们每次想要让它问候不同的名字时，都必须更改代码。更好的做法是在不总是需要更改*程序本身*的情况下更改程序的行为。
- en: 'We can do that by finding the parts of the program that we want to change--like
    the name to greet-- and providing that value as as an *argument* to our program.
    That is, we’d like our program to work like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过找到我们想要更改的程序的部分（比如要问候的名字）并将该值作为*参数*提供给我们的程序来实现这一点。也就是说，我们希望我们的程序像这样工作：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'How would the person using our program know to do this? *It’s our program’s
    responsibility to provide a help message!* Most command-line programs will respond
    to arguments like `-h` and `--help` with helpful messages about how to use the
    programs. We need our program to print something like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们程序的人将如何知道如何这样做？*这是我们的程序的责任，提供帮助信息！* 大多数命令行程序会对 `-h` 和 `--help` 这样的参数做出响应，显示有关如何使用程序的有用信息。我们需要我们的程序打印出类似以下内容：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ① Note that name is called a positional argument.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ① 注意，name 被称为位置参数。
- en: To do this, we can use the `argparse` module. Modules are files of code we can
    bring into our programs. We can also create modules to share our code with other
    people. There are hundreds to thousands of modules you can use in Python, which
    is one of the reasons why it’s so exciting to use the language.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们可以使用 `argparse` 模块。模块是我们可以将它们带入我们程序的代码文件。我们还可以创建模块以与他人共享我们的代码。Python
    中有数百到数千个模块可供使用，这也是为什么使用这种语言如此令人兴奋的原因之一。
- en: The `argparse` module will “parse” the “arguments” to the program. To use it,
    change your program as follows. I recommend you type everything yourself and don’t
    copy and paste.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`argparse` 模块将“解析”程序的“参数”。要使用它，按照以下方式更改你的程序。我建议你自己输入所有内容，不要复制粘贴。'
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ① The shebang line tells the OS which program to use to execute this program.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ① 命令行告诉操作系统使用哪个程序来执行此程序。
- en: ② This comment documents the purpose of the program.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ② 这条注释记录了程序的目的。
- en: ③ We must import the argparse module to use it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 我们必须导入 argparse 模块才能使用它。
- en: ④ The parser will figure out all the arguments. The description appears in the
    help message.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 解析器将确定所有参数。描述将显示在帮助信息中。
- en: ⑤ We need to tell the parser to expect a name that will be the object of our
    salutations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 我们需要告诉解析器预期一个将成为我们问候对象的名称。
- en: ⑥ We ask the parser to parse any arguments to the program.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 我们要求解析器解析程序的任何参数。
- en: ⑦ We print the greeting using the args.name value.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 我们使用 args.name 的值打印问候语。
- en: Figure 1.3 shows a string diagram of our program now.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3显示了我们现在程序的字符串图。
- en: 'Now when you try to run the program like before, it triggers an error and a
    “usage” statement (notice that “usage” is the first word of the output):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你尝试像以前一样运行程序时，会触发一个错误和一个“用法”语句（注意“用法”是输出的第一个单词）：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ① We run the program with no arguments, but the program now expects a single
    argument (a “name”).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ① 我们不带参数运行程序，但现在程序期望一个单独的参数（一个“名称”）。
- en: ② Since the program doesn’t get the expected argument, it stops and prints a
    “usage” message to let the user know how to properly invoke the program.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ② 由于程序没有获取到预期的参数，它停止并打印一个“用法”信息，让用户知道如何正确调用程序。
- en: ③ The error message tells the user that they have not supplied a required parameter
    called “name.”
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 错误信息告诉用户他们没有提供名为“名称”的必需参数。
- en: '![](../Images/1-3.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片1-3](../Images/1-3.png)'
- en: Figure 1.3 Now our string diagram shows that our program can take an argument
    and produce a message based on that value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3现在我们的字符串图显示程序可以接受一个参数并根据该值生成消息。
- en: 'We’ve changed the program so that it requires a name or it won’t run. That’s
    pretty cool! Let’s give it a name to greet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更改了程序，使其需要名称才能运行。这很酷！让我们给它一个问候的名称：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Try running your program with both the `-h` and `--help` arguments, and verify
    that you see the help messages.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`-h`和`--help`参数运行你的程序，并验证你是否看到了帮助信息。
- en: The program works really well now and has nice documentation, all because we
    added those few lines using `argparse`. That’s a big improvement.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 程序现在工作得很好，并且有很好的文档，这都是因为我们添加了那些使用`argparse`的几行代码。这是一个很大的改进。
- en: 1.8 Making the argument optional
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.8 使参数可选
- en: 'Suppose we’d like to run the program like before, with no arguments, and have
    it print “Hello, World!” We can make the `name` optional by changing the name
    of the argument to `--name`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想像以前一样不带参数运行程序，并让它打印“Hello, World!”我们可以通过将参数名称更改为`--name`来使`name`参数可选：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ① The only change to this program is adding -n and --name for the “short” and
    “long” option names. We also indicate a default value. “metavar” will show up
    in the usage to describe the argument.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ① 对这个程序唯一的更改是添加了-n和--name作为“短”和“长”选项名称。我们还指明了一个默认值。“metavar”将在用法中显示，以描述参数。
- en: 'Now we can run it like before:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像以前一样运行它：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Or we can use the `--name` option:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用`--name`选项：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And our help message has changed:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 并且我们的帮助信息已经更改：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ① The argument is now optional and no longer a positional argument. It’s common
    to provide both short and long names to make it easy to type the options. The
    metavar value of “name” appears here to describe what the value should be.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ① 现在参数是可选的，不再是位置参数。提供短名和长名以方便输入选项是很常见的。这里出现“name”的metavar值来描述值应该是什么。
- en: Figure 1.4 shows a string diagram that describes our program.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4显示了一个描述我们程序的字符串图。
- en: '![](../Images/1-4.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片1-4](../Images/1-4.png)'
- en: Figure 1.4 The `name` parameter is now optional. The program will greet a given
    name or will use a default value when it’s missing.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4现在`name`参数是可选的。程序将问候一个给定的名称，或者当它缺失时将使用默认值。
- en: Our program is really flexible now, greeting a default value when run with no
    arguments or allowing us to say “hi” to something else. Remember that parameters
    that start with dashes are *optional*, so they can be left out, and they may have
    default values. Parameters that *don’t* start with dashes are *positional* and
    are usually required, so they do not have default values.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序非常灵活，在没有参数运行时问候默认值，或者允许我们向其他东西说“嗨”。记住，以连字符开头的参数是*可选的*，因此可以省略，并且可能有默认值。不以连字符开头的参数是*位置的*，通常需要，因此没有默认值。
- en: Table 1.1 Two kinds of command-line parameters
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.1两种命令行参数
- en: '| Type | Example | Required | Default |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 示例 | 必需 | 默认 |'
- en: '| Positional | `name` | Yes | No |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 位置 | `name` | 是 | 否 |'
- en: '| Optional | `-n` (short), `--name` (long) | No | Yes |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 可选 | `-n`（短），`--name`（长） | 否 | 是 |'
- en: 1.9 Running our tests
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.9 运行我们的测试
- en: 'Let’s run our tests again to see how we are doing:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行我们的测试，看看我们做得怎么样：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Wow, we’re passing all our tests! I actually get excited whenever I see my programs
    pass all their tests, even when I’m the one who wrote the tests. Before we were
    failing on the usage and input tests. Adding the `argparse` code fixed both of
    those because it allows us to accept arguments when our program runs, and it will
    also create documentation about how to run our program.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们通过了所有的测试！我每次看到我的程序通过所有测试都会感到兴奋，即使是我自己写的测试。在我们之前，使用和输入测试都失败了。添加 `argparse`
    代码修复了这两个问题，因为它允许我们的程序在运行时接受参数，并且它还会创建有关如何运行我们的程序的文档。
- en: 1.10 Adding the main() function
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.10 添加 main() 函数
- en: 'Our program works really well now, but it’s not quite up to community standards
    and expectations. For instance, it’s very common for computer programs--not just
    ones written in Python--to start at a place called `main()`. Most Python programs
    define a function called `main()`, and there is an idiom to call the `main()`
    function at the end of the code, like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序现在工作得很好，但它还没有达到社区的标准和期望。例如，对于计算机程序来说，非常常见的是从名为 `main()` 的地方开始——不仅限于用Python编写的程序。大多数Python程序定义了一个名为
    `main()` 的函数，并且在代码的末尾调用 `main()` 函数是一个惯例，如下所示：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ① def defines a function, named main() in this case. The empty parentheses show
    that this function accepts no arguments.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ① def 定义了一个函数，在这个例子中命名为 main()。空括号表示这个函数不接受任何参数。
- en: ② Every program or module in Python has a name that can be accessed through
    the variable __name__. When the program is executing, __name__ is set to “__main__”.[1](#pgfId-1031136)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ② 每个Python程序或模块都有一个名称，可以通过变量 __name__ 访问。当程序正在执行时，__name__ 被设置为 “__main__”。[1](#pgfId-1031136)
- en: ③ If this is true, call the main() function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 如果这是真的，调用 main() 函数。
- en: As our programs get longer, we’ll start creating more functions. Python programmers
    approach this in different ways, but in this book I will always create and execute
    a `main()` function to be consistent. To start off, we’ll always put the main
    part of our program inside the `main()` function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的程序变得越来越长，我们将开始创建更多的函数。Python程序员以不同的方式处理这个问题，但在这本书中，我将始终创建和执行一个 `main()`
    函数以保持一致性。一开始，我们总是将程序的主体部分放在 `main()` 函数中。
- en: 1.11 Adding the get_args() function
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.11 添加 get_args() 函数
- en: As a matter of personal taste, I like to put all the `argparse` code into a
    separate place that I always call `get_args()`. Getting and validating arguments
    is one concept in my mind, so it belongs by itself. For some programs, this function
    can get quite long.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从个人喜好来说，我喜欢将所有的 `argparse` 代码放在一个单独的地方，我总是称之为 `get_args()`。获取和验证参数在我的脑海中是一个概念，所以它应该单独存在。对于某些程序，这个函数可能会变得相当长。
- en: I always put `get_args()` as the first function so that I can see it immediately
    when I read the source code. I usually put `main()` right after it. You are, of
    course, welcome to structure your programs however you like.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我总是将 `get_args()` 放在第一个函数中，这样我可以在阅读源代码时立即看到它。我通常将 `main()` 放在它之后。当然，你可以按照你喜欢的任何方式来组织你的程序。
- en: 'Here is what the program looks like now:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序看起来是这样的：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ① The get_args() function is dedicated to getting the arguments. All the argparse
    code now lives here.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ① get_args() 函数专门用于获取参数。现在所有的 argparse 代码都放在这里。
- en: ② We need to call return to send the results of parsing the arguments back to
    the main() function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ② 我们需要调用 return 来将解析参数的结果发送回 main() 函数。
- en: ③ The main() function is much shorter now.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ③ main() 函数现在要短得多。
- en: ④ Call the get_args() function to get parsed arguments. If there is a problem
    with the arguments or if the user asks for --help, the program never gets to this
    point because argparse will cause it to exit. If our program does make it t
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ④ 调用 get_args() 函数来获取解析后的参数。如果参数有问题或用户请求 --help，程序将不会到达这一点，因为 argparse 将导致它退出。如果我们的程序真的做到了这一点，那么...
- en: Nothing has changed about the way the program works. We’re just organizing the
    code to group ideas together--the code that deals with `argparse` now lives in
    the `get_args()` function, and everything else lives in `main()`. Just to be sure,
    go run the test suite!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的工作方式没有任何改变。我们只是组织代码，将想法分组在一起——处理 `argparse` 的代码现在位于 `get_args()` 函数中，其余的代码位于
    `main()` 中。为了确保一切正常，去运行测试套件吧！
- en: 1.11.1 Checking style and errors
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.11.1 检查样式和错误
- en: '| ![](../Images/1-unnumb-4.png)  | Our program works really well now. We can
    use tools like Flake8 and Pylint to check if our program has problems. These tools
    are called *linters*, and their job is to suggest ways to improve a program. If
    you haven’t installed them yet, you can use the `pip` module to do so now: |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| ![图片1](../Images/1-unnumb-4.png) | 我们的项目现在运行得非常好。我们可以使用像Flake8和Pylint这样的工具来检查我们的程序是否存在问题。这些工具被称为*linters*，它们的工作是建议改进程序的方法。如果您还没有安装它们，现在可以使用`pip`模块来安装：|'
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The Flake8 program wants me to put two blank lines between each of the function
    `def` definitions:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Flake8程序要求我在每个函数`def`定义之间放置两个空白行：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And Pylint says that the functions are missing documentation (“docstrings”):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Pylint表示函数缺少文档（“docstrings”）：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A *docstring* is a string that occurs just after the `def` of the function.
    It’s common to have several lines of documentation for a function, so programmers
    often will use Python’s triple quotes (single or double) to create a multiline
    string. Following is what the program looks like when I add docstrings. I have
    also used YAPF to format the program and fix the spacing problems, but you are
    welcome to use Black or any other tool you like.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*docstring*是一个出现在函数`def`之后的字符串。对于函数，通常会有几行文档，因此程序员经常使用Python的三重引号（单引号或双引号）来创建多行字符串。以下是我添加文档字符串后的程序的样子。我还使用了YAPF来格式化程序并修复间距问题，但您也可以使用Black或其他您喜欢的工具。'
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ① Triple-quoted, multiline docstring for the entire program. It’s common practice
    to write a long docstring just after the shebang to document the overall purpose
    of the function. I like to include at least my name, email address, and the purpose
    of the script so that any future person using the program will know who wrote
    it, how to get in touch with me if they have problems, and what the program is
    supposed to do.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ① 整个程序的三重引号，多行文档字符串。在shebang之后写一个长的文档字符串来记录函数的整体目的是常见的做法。我喜欢包括至少我的名字、电子邮件地址和脚本的用途，这样任何未来使用这个程序的人都会知道是谁编写的，如果他们有问题如何与我联系，以及程序应该做什么。
- en: ② A big horizontal “line” comment to help me find the functions. You can omit
    these if you don’t like them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ② 一个大的水平“行”注释，帮助我找到函数。如果您不喜欢这些，可以省略。
- en: ③ The docstring for the get_args() function. I like to use triple quotes even
    for a single-line comment, as they help me to see the docstring better.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ③ `get_args()`函数的文档字符串。我喜欢即使是单行注释也使用三重引号，因为它们帮助我更好地看到文档字符串。
- en: ④ The main() function is simply where the program begins, so there’s not much
    to say in the docstring. I think it’s (at least a little) funny to always put
    “Make a jazz noise here,” but you can put whatever you like.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ④ `main()`函数只是程序开始的地方，所以在文档字符串中没有什么好说的。我认为总是放“在这里制造爵士乐声音”是（至少有一点）有趣的，但您可以放任何您喜欢的东西。
- en: To learn how to use YAPF or Black on the command line, run them with the `-h`
    or `--help` flag and read the documentation. If you are using an IDE like VS Code
    or PyCharm, or if you are using the Repl.it interface, there are commands to reformat
    your code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在命令行上使用YAPF或Black，运行它们时使用`-h`或`--help`标志并阅读文档。如果您使用的是VS Code或PyCharm这样的IDE，或者如果您使用的是Repl.it界面，都有命令可以重新格式化您的代码。
- en: 1.12 Testing hello.py
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.12 测试hello.py
- en: We’ve made many changes to our program--are we sure it still works correctly?
    Let’s run our test again.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对我们的程序做了很多修改--我们确定它仍然可以正确运行吗？让我们再次运行我们的测试。
- en: 'This is something you will do literally hundreds of times, so I’ve created
    a shortcut you might like to use. In every directory, you’ll find a file called
    Makefile that looks like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你将实际做数百次的事情，所以我创建了一个你可能喜欢的快捷方式。在每一个目录中，您都会找到一个名为Makefile的文件，看起来像这样：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you have the program `make` installed on your computer, you can run `make`
    `test` when you are in the 01_hello directory. The `make` program will look for
    a Makefile in your current working directory and then look for a recipe called
    “test.” There it will find that the command to run for the “test” target is `pytest`
    `-xv` `test.py`, so it will run that command for you.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在计算机上安装了`make`程序，您可以在01_hello目录中运行`make test`。`make`程序将在您当前的工作目录中查找Makefile，然后查找名为“test”的配方。在那里，它会找到运行“test”目标的命令是`pytest
    -xv test.py`，因此它会为您运行该命令。
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you do not have `make` installed, you might like to install it and learn
    about how Makefiles can be used to execute complicated sets of commands. If you
    do not want to install or use `make`, you can always run `pytest` `-xv` `test.py`
    yourself. They both accomplish the same task.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有安装 `make`，您可能想安装它并了解 Makefiles 如何用于执行复杂的命令集。如果您不想安装或使用 `make`，您始终可以自己运行
    `pytest -xv test.py`。它们都完成相同的任务。
- en: The important point is that we were able to use our tests to verify that our
    program still does exactly what it is supposed to do. As you write programs, you
    may want to try different solutions. Tests give you the freedom to rewrite a program
    (also called “refactoring your code”) and know that it still works.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的点是，我们能够使用我们的测试来验证我们的程序仍然完全按照预期执行。当您编写程序时，您可能想要尝试不同的解决方案。测试让您有自由重写程序（也称为“重构您的代码”）并知道它仍然有效。
- en: 1.13 Starting a new program with new.py
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.13 使用 new.py 开始新程序
- en: '| The `argparse` module is a standard module that is always installed with
    Python. It’s widely used because it can save us so much time in parsing and validating
    the arguments to our programs. You’ll be using `argparse` in every program for
    this book, and you’ll learn how you can use it to convert text to numbers, to
    validate and open files, and much more. There are so many options that I created
    a Python program called new.py that will help you start writing new Python programs
    that use `argparse`. | ![](../Images/1-unnumb-5.png) |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `argparse` 模块是一个标准模块，总是与 Python 一起安装。它被广泛使用，因为它可以为我们节省大量解析和验证程序参数的时间。您将在本书的每个程序中使用
    `argparse`，您将学习如何使用它将文本转换为数字、验证和打开文件以及更多。有如此多的选项，我创建了一个名为 new.py 的 Python 程序，它将帮助您开始编写使用
    `argparse` 的新 Python 程序。| ![图片](../Images/1-unnumb-5.png) |'
- en: 'I have put this new.py program into the bin directory of the GitHub repo. I
    suggest you use it to start every new program you write. For instance, you could
    create a new version of hello.py using new.py. Go to the top level of your repository
    and run this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将这个新的 new.py 程序放入了 GitHub 仓库的 bin 目录中。我建议您在编写每个新程序时都使用它。例如，您可以使用 new.py 创建
    hello.py 的新版本。前往您的仓库顶层并运行以下命令：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The new.py program will not overwrite an existing file unless you tell it to,
    so you can use it without worrying that you might erase your work. Try using it
    to create a program with a different name:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: new.py 程序不会覆盖现有文件，除非您告诉它这样做，因此您可以使用它而不用担心可能会擦除您的工作。尝试使用它创建一个具有不同名称的程序：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now try executing that program:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试执行该程序：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let’s look at the source code of the new program:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看新程序的源代码：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ① The shebang line should use the env program to find the python3 program.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ① 应该使用 env 程序来查找 python3 程序的 shebang 行。
- en: ② This docstring is for the program as a whole.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ② 这个文档字符串是针对整个程序的。
- en: ③ These lines import various modules that the program needs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ③ 这些行导入了程序需要的各种模块。
- en: ④ The get_args() function is responsible for parsing and validating arguments.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ④ get_args() 函数负责解析和验证参数。
- en: ⑤ Define a “positional” argument like our first version of hello.py that had
    a name argument.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ⑤ 定义一个“位置”参数，就像我们 hello.py 的第一个版本中具有名称参数的那样。
- en: ⑥ Define an “optional” argument like when we changed to use the --name option.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ⑥ 定义一个“可选”参数，就像我们改为使用 --name 选项时一样。
- en: ⑦ Define an optional argument that must be an integer value.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ⑦ 定义一个可选参数，该参数必须是整数值。
- en: ⑧ Define an optional argument that must be a file.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ⑧ 定义一个可选参数，该参数必须是文件。
- en: ⑨ Define a “flag” option that is either “on” when present or “off” when absent.
    You’ll learn more about these later.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ⑨ 定义一个“标志”选项，当存在时为“开启”，当不存在时为“关闭”。您将在后面了解更多关于这些内容。
- en: ⑩ Return the parsed arguments to main(). If there are any problems, like if
    the --int value is some text rather than a number like 42, argparse will print
    an error message and the “usage” for the user.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ⑩ 将解析后的参数返回给主函数（main()）。如果有任何问题，比如如果 --int 的值是文本而不是像 42 这样的数字，argparse 将打印错误消息和“用法”信息给用户。
- en: ⑪ Define the main() function where the program starts.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ⑪ 定义主函数（main()），程序从这里开始。
- en: ⑫ The first thing our main() functions will always do is call get_args() to
    get the arguments.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ⑫ 我们的主函数（main()）将始终做的第一件事是调用 get_args() 来获取参数。
- en: ⑬ Each argument’s value is accessible through the long name of the argument.
    It is not required to have both a short and long name, but it is common and tends
    to make your program more readable.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ⑬ 每个参数的值都可以通过参数的长名称访问。不需要同时具有短名称和长名称，但这很常见，并且往往会使您的程序更易于阅读。
- en: ⑭ When the program is being executed, the __name__ value will be equal to the
    text “__main__.”
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ⑭ 当程序正在执行时，__name__的值将等于文本“__main__”。
- en: ⑮ If the condition is true, this calls the main() function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ⑮ 如果条件为真，则调用main()函数。
- en: 'This program will accept the following arguments:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序将接受以下参数：
- en: A single positional argument of the type `str`. *Positional* means it is not
    preceded by a flag to name it but has meaning because of its position relative
    to the command name.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单一的`str`类型的定位参数。*定位*意味着它没有前缀来命名它，但因为它相对于命令名的位置而有意义。
- en: An automatic `-h` or `--help` flag that will cause `argparse` to print the usage.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个自动的`-h`或`--help`标志，这将导致`argparse`打印用法。
- en: A string option called either `-a` or `--arg`.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`-a`或`--arg`的字符串选项。
- en: A named option argument called `-i` or `--int`.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`-i`或`--int`的命名选项参数。
- en: A file option called `-f` or `--file`.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`-f`或`--file`的文件选项。
- en: A Boolean (off/on) flag called `-o` or `--on`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`-o`或`--on`的布尔（开/关）标志。
- en: 'Looking at the preceding list, you can see that new.py has done the following
    for you:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 看看前面的列表，你可以看到new.py为您做了以下事情：
- en: Created a new Python program called hello2.py
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个名为hello2.py的新Python程序
- en: Used a template to generate a working program complete with docstrings, a `main()`
    function to start the program, a `get_args()` function to parse and document various
    kinds of arguments, and code to start the program running in the `main()` function
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板生成一个包含文档字符串、一个用于启动程序的`main()`函数、一个用于解析和记录各种类型的参数的`get_args()`函数以及用于在`main()`函数中启动程序运行的代码的完整工作程序。
- en: Made the new program executable so that it can be run like `./hello2.py`
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使新程序可执行，以便可以像`./hello2.py`一样运行。
- en: The result is a program that you can immediately execute and that will produce
    documentation on how to run it. After you use new.py to create your new program,
    you should open it with your editor and modify the argument names and types to
    suit the needs of your program. For instance, in chapter 2 you’ll be able to delete
    everything but the positional argument, which you should rename from `'positional'`
    to something like `'word'` (because the argument is going to be a word).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个您可以立即执行并生成如何运行该程序的文档的程序。在您使用new.py创建新程序后，您应该使用您的编辑器打开它，并修改参数名称和类型以适应您程序的需求。例如，在第2章中，您将能够删除除了位置参数之外的所有内容，您应该将`'positional'`重命名为类似`'word'`的东西（因为该参数将是一个单词）。
- en: 'Note that you can control the “name” and “email” values that are used by new.py
    by creating a file called .new.py (note the leading dot!) in your home directory.
    Here is mine:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可以通过在您的家目录中创建一个名为.new.py（注意前面的点！）的文件来控制new.py使用的“名称”和“电子邮件”值。以下是我的示例：
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 1.14 Using template.py as an alternative to new.py
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.14 使用template.py作为new.py的替代方案
- en: If you don’t want to use new.py, I have included a sample of the preceding program
    as template/template.py, which you can copy. For instance, in chapter 2 you will
    need to create the program 02_crowsnest/crowsnest.py.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用new.py，我已经包含了前面程序的样本作为template/template.py，您可以复制它。例如，在第2章中，您将需要创建程序02_crowsnest/crowsnest.py。
- en: 'You can do this with new.py from the top level of the repository:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从存储库的顶层使用new.py来做这件事：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Or you can the use `cp` (copy) command to copy the template to your new program:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`cp`（复制）命令将模板复制到您的新的程序中：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The main point is that you won’t have to start every program from scratch. I
    think it’s much easier to start with a complete, working program and modify it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 主要观点是您不必每次都从头开始编写每个程序。我认为从一个完整且可工作的程序开始并对其进行修改要容易得多。
- en: Note You can copy new.py to your ~/bin directory. Then you can use it from any
    directory to create a new program.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以将new.py复制到您的~/bin目录中。然后您可以从任何目录使用它来创建新的程序。
- en: Be sure to skim the appendix--it has many examples of programs that use `argparse`.
    You can copy many of those examples to help you with the exercises.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要浏览附录——它包含了许多使用`argparse`的程序示例。您可以将这些示例中的许多复制过来以帮助您完成练习。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A Python program is plain text that lives in a file. You need the `python3`
    program to interpret and execute the program file.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python程序是存储在文件中的纯文本。您需要`python3`程序来解释和执行程序文件。
- en: You can make a program executable and copy it to a location in your `$PATH`
    so that you can run it like any other program on your computer. Be sure to set
    the shebang to use `env` to find the correct `python3`.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将程序设置为可执行，并将其复制到您的`$PATH`中的某个位置，这样您就可以像运行计算机上的任何其他程序一样运行它。请确保设置shebang以使用`env`来找到正确的`python3`。
- en: The `argparse` module will help you document and parse all the parameters to
    your program. You can validate the types and numbers of arguments, which can be
    positional, optional, or flags. The usage will be automatically generated.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`argparse` 模块将帮助您记录和解析程序的所有参数。您可以验证参数的类型和数量，这些参数可以是位置参数、可选参数或标志。用法将自动生成。'
- en: We will use the `pytest` program to run the test.py programs for each exercise.
    The `make` `test` shortcut will execute `pytest` `-xv` `test.py`, or you can run
    this command directly.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用 `pytest` 程序运行每个练习的 test.py 程序。`make test` 快捷键将执行 `pytest -xv test.py`，或者您可以直接运行此命令。
- en: You should run your tests often to ensure that everything works.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该经常运行测试以确保一切正常工作。
- en: Code formatters like YAPF and Black will automatically format your code to community
    standards, making it easier to read and debug.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码格式化工具如 YAPF 和 Black 将自动将您的代码格式化为社区标准，使其更易于阅读和调试。
- en: Code linters like Pylint and Flake8 can help you correct both programmatic and
    stylistic problems.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码检查工具如 Pylint 和 Flake8 可以帮助您纠正程序性和风格问题。
- en: You can use the new.py program to generate new Python programs that use `argparse`.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 new.py 程序生成使用 `argparse` 的新 Python 程序。
- en: '* * *'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '1 See Python’s documentation of `main` for more information: [https://docs.python.org/3/library/__main
    __.html](https://docs.python.org/3/library/__main__.html).'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 1 请参阅 Python 对 `main` 的文档以获取更多信息：[https://docs.python.org/3/library/__main__.html](https://docs.python.org/3/library/__main__.html)。
