- en: 3 Java 17
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 Java 17
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Text blocks
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Text blocks
- en: Switch Expressions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Switch 表达式
- en: Records
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录
- en: Sealed Types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封闭类型
- en: These represent the major new features that have been added to the Java language
    and platform since the release of Java 11, up to and including Java 17.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代表了自 Java 11 发布以来，直到包括 Java 17 在内，添加到 Java 语言和平台中的主要新特性。
- en: Note To understand the changes in the Java release methodology since Java 8,
    it may be a good idea to review the discussion in chapter 1 or appendix A.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了理解自 Java 8 以来 Java 发布方法的变化，回顾第 1 章或附录 A 的讨论可能是个好主意。
- en: As well as the major, user-visible language upgrades, Java 17 contains many
    internal improvements (especially performance upgrades). However, this chapter
    focuses on the major features that we expect will change the way that you, the
    developer, write Java.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了主要的、用户可见的语言升级之外，Java 17 还包含了许多内部改进（特别是性能升级）。然而，本章重点介绍我们预计将改变开发者编写 Java 方式的主要特性。
- en: 3.1 Text Blocks
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 Text Blocks
- en: Since the very first version, Java 1.0, developers have been complaining about
    Java’s strings. Compared to other programming languages, such as Groovy or Scala
    or Kotlin, Java’s strings have sometimes seemed a little primitive.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Java 1.0 的第一个版本以来，开发者们一直在抱怨 Java 的字符串。与其他编程语言，如 Groovy、Scala 或 Kotlin 相比，Java
    的字符串有时似乎有点原始。
- en: Java has historically provided only one type of string—the straightforward,
    double-quoted string in which certain characters (notably `"` and `\`) must be
    escaped to be used safely. These have, under a surprisingly wide array of circumstances,
    led to the need to produce convoluted escaped strings, even for very common programming
    situations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Java 历史上只提供了一种字符串类型——简单的双引号字符串，其中某些字符（特别是 `"` 和 `\`）必须转义才能安全使用。这些字符在出人意料广泛的情境下，导致了需要产生复杂的转义字符串，即使在非常常见的编程情况下也是如此。
- en: The *Text Blocks* project has been through several iterations as a preview feature
    (we discussed preview features briefly in chapter 1) and is now a standard feature
    in Java 17\. It aims to expand the notion of a string in Java syntax by allowing
    string literals that extend over multiple lines. In turn, that should avoid the
    need for most of the escape sequences that, historically, Java programmers have
    found to be an excessive hindrance.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*Text Blocks* 项目作为一个预览特性已经经历了多次迭代，现在在 Java 17 中已成为标准特性（我们已在第 1 章简短地讨论了预览特性）。它的目标是通过允许跨多行的字符串字面量来扩展
    Java 语法中的字符串概念。反过来，这应该可以避免大多数历史上 Java 程序员发现是过度阻碍的转义序列。'
- en: Note Unlike various other programming languages, Java Text Blocks do not currently
    support *interpolation*, although this feature is under active consideration for
    inclusion in a future version.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：与各种其他编程语言不同，Java Text Blocks 目前不支持 *插值*，尽管这个特性正在积极考虑中，以包含在未来的版本中。
- en: As well as helping to free Java programmers from the bother of dealing with
    excessive escaping of characters, a specific goal of Text Blocks is to allow readable
    strings of code that are not Java but that need to be embedded in a Java program.
    After all, how often do you have to include, for example, SQL or JSON (or even
    XML) in one of your Java programs?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了帮助 Java 程序员摆脱处理字符过度转义的麻烦之外，Text Blocks 的一个具体目标是允许嵌入在 Java 程序中的可读字符串代码，而这些字符串代码不是
    Java 代码。毕竟，你有多经常需要在你的 Java 程序中包含 SQL 或 JSON（甚至 XML）？
- en: Before Java 17, this process could be painful, indeed, and, in fact, many teams
    resorted to using an external templating library with all of its additional complexity.
    Since the arrival of Text Blocks, this is, in many cases, no longer necessary.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 17 之前，这个过程确实可能很痛苦，实际上，许多团队求助于使用带有所有额外复杂性的外部模板库。自从 Text Blocks 出现以来，在许多情况下，这不再是必要的。
- en: 'Let’s see how they work, by considering an SQL query. In this chapter, we’re
    going to use a few examples from financial trading—specifically foreign exchange
    currency trading (FX). Perhaps we have our customer orders stored in a SQL database
    that we will access with a query like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑一个 SQL 查询来看看它们是如何工作的。在本章中，我们将使用一些来自金融交易的例子——特别是外汇货币交易（FX）。也许我们的客户订单存储在一个
    SQL 数据库中，我们将使用如下查询来访问：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You should notice two things. First, the Text Block is started and terminated
    with the sequence `"""`, which was not legal Java prior to version 15\. Second,
    the Text Block can be indented with whitespace at the start of each line—and the
    whitespace will be ignored.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到两点。首先，Text Block 以 `"""` 序列开始和结束，这在 Java 15 之前是不合法的 Java 语法。其次，Text Block
    可以在每行的开头使用空白字符缩进——这些空白字符将被忽略。
- en: 'If we print out the `query` variable, then we get exactly the string we constructed,
    as shown here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印出 `query` 变量，那么我们得到的就是我们构造的字符串，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This happens because a Text Block is a constant expression (of type String),
    just the same as a string literal. The difference is that a Text Block is processed
    by `javac` before recording the constant in the class file as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Text Block 是一个常量表达式（String 类型），就像字符串字面量一样。区别在于 Text Block 在 `javac` 处理并记录到类文件中的常量之前。
- en: Line terminator characters are translated to LF (\u000A), that is, the Unix
    line-ending convention.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行终止符字符被翻译为 LF (\u000A)，即 Unix 行结束约定。
- en: Extra whitespace surrounding the block is removed, to allow for extra indentation
    of Java source code, as per our example.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块周围的额外空白被移除，以便允许 Java 源代码有额外的缩进，正如我们的示例所示。
- en: Any escape sequences in the block are interpreted.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 块中的任何转义序列都将被解释。
- en: These steps are carried out in the above order for a reason. Specifically, interpreting
    escape sequences last means blocks can include literal escape sequences (such
    as `\n`) without them being modified or deleted by earlier steps.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤按照上述顺序执行是有原因的。具体来说，最后解释转义序列意味着块可以包含字面转义序列（如 `\n`），而不会被早期步骤修改或删除。
- en: Note At runtime, there is absolutely no difference between a string constant
    that was obtained from a literal versus a Text Block. The class file does not
    record in any way the original source of the constant.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在运行时，从字面量或 Text Block 获取的字符串常量之间绝对没有任何区别。类文件不会以任何方式记录常量的原始来源。
- en: For more details about Text Blocks, please see JEP 378 ([https://openjdk.java.net/jeps/378](https://openjdk.java.net/jeps/378)).
    Let’s move on and meet the new *Switch Expressions* feature.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Text Blocks 的更多详细信息，请参阅 JEP 378 ([https://openjdk.java.net/jeps/378](https://openjdk.java.net/jeps/378))。让我们继续前进，了解新的
    *Switch Expressions* 功能。
- en: 3.2 Switch Expressions
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 Switch 表达式
- en: 'Since its earliest versions, Java has supported *switch statements*. Java took
    a lot of inspiration for its syntax from the forms present in C and C++, and the
    `switch` statement is no exception, as shown next:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 自从它的早期版本以来，Java 就支持 *switch 语句*。Java 从 C 和 C++ 中的现有形式中汲取了许多语法灵感，`switch` 语句也不例外，如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In particular, Java’s switch statement inherited the property that if a `case`
    doesn’t end with `break`, execution will continue after the next `case`. This
    rule allows the grouping of cases that need identical handling, like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，Java 的 switch 语句继承了这样一个属性：如果一个 `case` 没有以 `break` 结尾，执行将在下一个 `case` 之后继续。这个规则允许将需要相同处理的案例分组，如下所示：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Convenience for this situation, though, brought with it a dark and buggy side.
    Omitting a single `break` is an easy mistake for programmers, both new and old,
    and often introduced errors. In our example, we would get the wrong answer because
    excluding our first `break` would have resulted in messages for both winter and
    spring.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种情况带来了便利，但也带来了暗淡和有缺陷的一面。遗漏单个 `break` 是程序员（无论是新手还是老手）容易犯的错误，并且经常引入错误。在我们的例子中，我们会得到错误的答案，因为省略第一个
    `break` 会导致 winter 和 spring 的消息都被打印出来。
- en: 'Switch statements are also clunky when trying to capture a value for later
    use. For example, if we wanted to grab that message for use elsewhere, instead
    of printing it, we’d have to set up a variable outside the `switch`, set it correctly
    in each branch, and potentially ensure after the `switch` that we actually set
    the value; something like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试捕获一个值以供以后使用时，switch 语句也会显得笨拙。例如，如果我们想获取那条消息以供其他地方使用，而不是打印它，我们就必须在 `switch`
    之外设置一个变量，并在每个分支中正确设置它，并可能确保在 `switch` 之后实际上设置了值；类似于以下这样：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Much like a missed `break`, we now must ensure every case properly sets the
    message variable or risk a bug report in our future. Surely, we can do better.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就像遗漏 `break` 一样，我们现在必须确保每个 case 正确设置消息变量，否则我们未来的错误报告会有风险。当然，我们可以做得更好。
- en: '*Switch Expressions*, introduced in Java 14 (JEP 361), provide alternatives
    to address these shortcomings, while also acting to open future language frontiers.
    This aim includes helping to close a linguistic gap with more functionally oriented
    languages (e.g., Haskell, Scala, or Kotlin). A first version of Switch Expressions
    is more concise, as shown here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 14（JEP 361）中引入的 *Switch 表达式*提供了解决这些不足的替代方案，同时也旨在打开未来的语言前沿。这个目标包括帮助缩小与更多面向函数式语言（例如
    Haskell、Scala 或 Kotlin）的语言差距。Switch 表达式的第一个版本更加简洁，如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this revised form, we no longer set the variable in each branch. Instead,
    each case uses the new `yield` keyword to hand our desired value back to assign
    to the `String` variable, and the expression as a whole *yields a value*—from
    one case branch or another (and each case branch must result in a yield).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种修改后的形式中，我们不再在每个分支中设置变量。相反，每个情况都使用新的 `yield` 关键字将我们想要的值返回以分配给 `String` 变量，整个表达式
    *产生一个值*——从一个情况分支到另一个分支（并且每个情况分支都必须产生一个 `yield`）。
- en: With this example in hand, the name of this new feature—*Switch Expressions*
    versus the existing *Switch Statement*—takes on more meaning. In programming languages,
    a *statement* is a piece of code executed for its side effect. An *expression*
    refers instead to code executed to produce a value. `switch` prior to Java 14
    was only a side-effecting statement, but now it can produce values when used as
    an expression.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这个例子，这个新特性——*Switch 表达式*与现有的*Switch 语句*——的含义更加丰富。在编程语言中，*语句*是指执行时产生副作用的一段代码。而*表达式*则是指执行时产生值的一段代码。在
    Java 14 之前，`switch` 只是一个产生副作用的语句，但现在它可以用作表达式来产生值。
- en: 'Switch Expressions also bring another even more concise syntax, which may well
    prove to be more widely adopted, as shown here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Switch 表达式还带来了另一种更加简洁的语法，这可能会被更广泛地采用，如下所示：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `->` indicates we’re in a switch expression, so those cases don’t need an
    explicit `yield`. Our `default` case shows how a block enclosed in `{}` can be
    used where we don’t have a single value. If you’re using the value of a switch
    expression (as we are by assigning it to `message`), multiline cases must either
    `yield` or `throw`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`->` 表示我们处于 switch 表达式中，因此那些情况不需要显式的 `yield`。我们的 `default` 情况显示了如何在没有单个值的情况下使用
    `{}` 包裹的块。如果你正在使用 switch 表达式的值（就像我们通过将其分配给 `message` 一样），多行情况必须 `yield` 或 `throw`。'
- en: But the new labeling format isn’t just more helpful and shorter—it solves real
    problems. For one, multiple cases are directly supported by the comma-delimited
    list after the `case`. This solves the problem that previously required dangerous
    switch fall-through. A switch expression in the new labeling syntax never falls
    through, closing off that stumbling block for everyone.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但新的标签格式不仅更有帮助且更短，它还解决了实际问题。首先，多个情况通过 `case` 后的逗号分隔列表直接支持。这解决了之前需要危险的 switch
    穿透问题。新的标签语法中的 switch 表达式永远不会穿透，为每个人关闭了这个障碍。
- en: 'The added safeguards don’t end there. Another common way to mess up your switch
    statements is to miss a case you should have handled. If we remove the `default`
    line from the previous example, we get a compile error, as shown next:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 增加的安全保障还不止这些。破坏 switch 语句的另一种常见方式是遗漏了你应该处理的情况。如果我们从上一个例子中删除 `default` 行，就会得到一个编译错误，如下所示：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Unlike switch statements, Switch Expressions must handle every possible case
    for your input type, or your code won’t even compile. That’s an excellent guarantee
    to help you cover all the bases. It also combines nicely with Java’s enums, as
    we can see if we rewrite the switch to use typesafe constants rather than `int`s
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与 switch 语句不同，Switch 表达式必须处理你输入类型的每个可能的情况，否则你的代码甚至无法编译。这是一个很好的保证，可以帮助你覆盖所有的基础。它还很好地与
    Java 的枚举结合，正如我们通过将 `switch` 重写为使用类型安全的常量而不是 `int` 一样：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This new capability is useful as a standalone feature, because it allows us
    to simplify a very common case of the use of `switch`, behaving a bit like a function,
    yielding an output value based on the input value. In fact, the rule for Switch
    Expressions is that every possible input value must be guaranteed to produce an
    output value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新功能作为一个独立的功能很有用，因为它允许我们简化 `switch` 的一个非常常见的用法，表现得有点像函数，根据输入值产生一个输出值。实际上，Switch
    表达式的规则是，必须保证每个可能的输入值都能产生一个输出值。
- en: Note If all the possible enum constants are present in a switch expression,
    the match is *total* and it is not necessary to include a `default` case—the compiler
    can use the exhaustiveness of the enum constants.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果所有可能的枚举常量都出现在一个 Switch 表达式中，匹配是 *完全的*，因此不需要包含一个 `default` 情况——编译器可以使用枚举常量的完备性。
- en: However, for Switch Expressions that take, for instance, an `int`, we must include
    a `default` clause as it is not feasible to list all approximately four billion
    possible values.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于例如接受 `int` 类型的 Switch 表达式，我们必须包含一个 `default` 子句，因为列出大约四十亿个可能值是不切实际的。
- en: Switch Expressions are also a stepping-stone toward a major feature, Pattern
    Matching, in a possible future version of Java, which we will discuss both later
    in this chapter and later in the book. For now, let’s move on to meet the next
    new feature, Records.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Switch 表达式也是通往 Java 未来版本中一个主要特性——模式匹配——的垫脚石，我们将在本章后面和书中后面讨论这一点。现在，让我们继续前进，来认识下一个新特性，即
    Records。
- en: 3.3 Records
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 Records
- en: 'Records are a new form of Java class designed to do the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Records 是一种新的 Java 类形式，旨在执行以下操作：
- en: Provide a first-class means for modeling data-only aggregates
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种一等方法来建模仅包含数据的聚合
- en: Close a possible gap in Java’s type system
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弥合 Java 类型系统的一个可能差距
- en: Provide language-level syntax for a common programming pattern
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为常见的编程模式提供语言级别的语法
- en: Reduce class boilerplate
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少类样板代码
- en: The ordering of these bullet points is important, and in fact, Records are more
    about language semantics than they are about boilerplate reduction and syntax
    (although the second aspect is what many developers tend to focus on). Let’s start
    by explaining the basic idea of what a Java record is.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目符号的顺序很重要，实际上，Records 更关注语言语义，而不是样板代码的减少和语法（尽管第二个方面是许多开发者倾向于关注的）。让我们首先解释一下
    Java 记录的基本概念。
- en: The idea of Records is to extend the Java language and create a way to say that
    a class is “the fields, just the fields, and nothing but the fields.” By making
    that statement about our class, the compiler can help us by creating all the methods
    automatically and having all the fields participate in methods like `hashCode()`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Records 的理念是扩展 Java 语言，并创建一种方式来说明一个类是“仅仅是字段，没有其他”。通过对我们类的这种声明，编译器可以帮助我们自动创建所有方法，并让所有字段参与像
    `hashCode()` 这样的方法。
- en: 'Note This is the way that the semantics “a record is a transparent carrier
    of the fields” defines the syntax: “accessor methods and other boilerplate are
    automatically derived from the record definition.”'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这是语义“记录是字段的透明载体”定义语法的这种方式：“访问器方法和其他样板代码自动从记录定义中派生。”
- en: To see how it shows up in day-to-day programming, remember that one of the most
    common complaints about Java is that you need to write a lot of code for a class
    to be useful. Quite often we need to write
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解它在日常编程中的表现，请记住，关于 Java 最常见的抱怨之一是你需要编写很多代码才能使一个类变得有用。通常，我们需要编写
- en: '`toString()`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toString()`'
- en: '`hashCode()` and `equals()`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hashCode()` 和 `equals()`'
- en: Getter methods
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取器方法
- en: Public constructor
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共构造函数
- en: and so on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。
- en: For simple domain classes, these methods are usually boring, repetitive, and
    the kind of thing that could easily be mechanically generated (and IDEs often
    provide this capability), but until we had Records, the language didn’t provide
    any way to do this directly. This frustrating gap is actually worse when we’re
    reading someone else’s code. For example, it might look like the author is using
    an IDE-generated `hashCode()` and `equals()` that uses all the fields of the class,
    but how can we be sure without checking each line of the implementation? What
    happens if a field is added during refactoring and the methods are not regenerated?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的领域类，这些方法通常是无聊的、重复的，并且很容易被机械地生成（IDEs 通常提供这种功能），但直到我们有了 Records，语言并没有提供直接这样做的方法。当我们阅读别人的代码时，这种令人沮丧的差距实际上更糟。例如，它可能看起来作者正在使用
    IDE 生成的 `hashCode()` 和 `equals()`，它使用了类的所有字段，但我们如何能确定而不检查实现中的每一行呢？如果重构期间添加了字段而方法没有重新生成会发生什么？
- en: Records solve these problems. If a type is declared as a record, it is making
    a strong statement, and the compiler and runtime will treat it accordingly. Let’s
    see it in action.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Records 解决了这些问题。如果一个类型被声明为记录，它就是一个强有力的声明，编译器和运行时会相应地处理它。让我们看看它是如何付诸实践的。
- en: To really explain this feature fully, we need a nontrivial example domain, so
    let’s continue to use FX currency trading. Don’t worry if you’re not familiar
    with the concepts used in this area—we’ll explain what you need to know as we
    go along. Later in the book, we’re going to continue the theme of financial examples,
    so this is a good place to get started.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全解释这个特性，我们需要一个非平凡的示例领域，所以让我们继续使用FX货币交易。如果你对这个领域使用的概念不熟悉，请不要担心——我们会随着我们的进展解释你需要知道的内容。在本书的后面部分，我们将继续探讨金融示例的主题，所以这是一个好的开始点。
- en: 'Let’s walk through how we can use Records and a few other features to improve
    our modeling of the domain and get cleaner, less verbose, and simpler code as
    a result. Consider an order that we want to place when trading FX. The basic order
    type might consist of the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们如何使用Records和一些其他功能来改进我们的领域建模，并因此得到更干净、更简洁、更简单的代码。考虑当我们进行FX交易时想要下订单的情况。基本订单类型可能包括以下内容：
- en: Number of units I’m buying or selling (in millions of currency units)
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我要购买或出售的单位数量（以货币单位的百万计）
- en: The “side”—whether I’m buying or selling (often called *Bid* and *Ask*)
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “方向”——我是买入还是卖出（通常称为*Bid*和*Ask*）
- en: The currencies I’m exchanging (the *currency pair*)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我要兑换的货币（*货币对*）
- en: The time I placed my order
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我下单的时间
- en: How long my order is good for before it times out (the *time-to-live* or *TTL*)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的订单在超时前有效的时间（*TTL*或*存活时间*）
- en: 'So, if I have £1M and want to sell it for US dollars within the next second,
    and I want $1.25 for each £, then I am “buying the GBP/USD rate at $1.25 now,
    good for 1s.” In Java, we might declare a domain class like this (we’re calling
    it “classic” to call out that we have to do this with a class for now—better ways
    are coming):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我有一千万英镑，想在下一秒内换成美元，并且我想要每英镑1.25美元，那么我现在就是“以1.25美元的价格买入GBP/USD汇率，有效期为1秒。”在Java中，我们可能会声明一个领域类，如下所示（我们称之为“classic”，以表明我们目前必须使用类来做这件事——更好的方法即将到来）：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That’s a lot of code, but it means that my order can be created like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很多，但它的意思是我的订单可以像这样创建：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: But how much of the code to declare the class is really necessary? In older
    versions of Java, most developers would probably just declare the fields and then
    use their IDE to autogenerate all the methods. Let’s see how Records improve the
    situation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但声明类的代码中，真正必要的部分有多少呢？在Java的旧版本中，大多数开发者可能会只是声明字段，然后使用他们的IDE来自动生成所有方法。让我们看看Records如何改善这种情况。
- en: Note Java doesn’t provide any way to talk about a data aggregate other than
    by defining a class, so it is clear that any type containing “just the fields”
    will be a class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Java没有提供除了通过定义一个类之外的方式来谈论数据聚合的方法，所以很明显，任何只包含“只是字段”的类型都将是一个类。
- en: The new concept is a *record class* (or usually just record). This is an immutable
    (in the usual “all fields are final” Java sense), transparent carrier for a fixed
    set of values, known as the *record components*. Each component gives rise to
    a final field that holds the provided value and an accessor method to retrieve
    the value. The field name and the accessor name match the name of the component.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 新的概念是一个 *record class*（或通常简称为record）。这是一个不可变（在通常的“所有字段都是final”的Java意义上），透明的固定值集的载体，被称为
    *record components*。每个组件都会产生一个final字段来存储提供的值和一个访问器方法来检索该值。字段名和访问器名与组件名匹配。
- en: The list of fields provides a *state description* for the record. In a general
    class, there might be no relation between a field `x`, the constructor argument
    `x`, and the accessor `x()`, but in a record, they are *by definition* talking
    about the same thing—a record *is* its state.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 字段列表为record提供了一个 *状态描述*。在一般类中，字段`x`、构造函数参数`x`和访问器`x()`之间可能没有关系，但在record中，它们是
    *定义上* 指的是同一件事——record *就是* 它的状态。
- en: 'To allow us to create new instances of record classes, a constructor is also
    generated—called the *canonical constructor*—which has a parameter list that exactly
    matches the declared state description. The Java language also now provides concise
    syntax for declaring Records, in which all the programmer needs to do is to declare
    the component names and types that make up the record, like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够创建record类的新的实例，还会生成一个构造函数——称为 *规范构造函数*——它有一个参数列表，与声明的状态描述完全匹配。Java语言现在也提供了简洁的语法来声明Records，其中程序员只需要声明构成record的组件名称和类型，如下所示：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By writing this record declaration, we are not just saving some typing, we are
    making a much stronger, semantic statement. The `FXOrder` type *is* just the state
    provided, and any instance *is* just a transparent aggregate of the field values.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写这个记录声明，我们不仅节省了一些输入，我们还做出了一个更强的、语义上的声明。`FXOrder` 类型 *就是* 提供的状态，任何实例 *就是*
    字段值的透明聚合。
- en: 'If we now examine the class file with `javap` (which we will meet properly
    in chap-ter 4), we can see that the compiler has autogenerated a bunch of boilerplate
    code for us:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在使用 `javap` 检查类文件（我们将在第 4 章中详细介绍），我们可以看到编译器已经为我们自动生成了一堆样板代码：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This looks remarkably like the set of methods we had to write in the code for
    the class-based implementation. In fact, the constructor and accessor methods
    all behave exactly as before. However, methods like `toString()` and `equals()`
    use an implementation that might be surprising to some developers, as shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常像我们为了基于类的实现而必须编写的那些方法集。实际上，构造函数和访问器方法的行为与之前完全相同。然而，像 `toString()` 和 `equals()`
    这样的方法使用了一种可能让一些开发者感到惊讶的实现方式，如下所示：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That is, the `toString()` method (and `equals()` and `hashCode()`) are implemented
    using an `invokedynamic`-based mechanism. This is a powerful technique that we
    will meet later in the book (in chapters 4 and 16).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，`toString()` 方法（以及 `equals()` 和 `hashCode()`）是通过基于 `invokedynamic` 的机制实现的。这是一种我们将在本书后面的章节（第
    4 章和第 16 章）中遇到的有力技术。
- en: 'We can also see that there is a new class, `java.lang.Record`, that will act
    as the supertype for all record classes. It is abstract and declares `equals()`,
    `hashCode()` and `toString()` to be abstract methods. The `java.lang.Record` class
    cannot be directly extended, as we can see by trying to compile some code like
    this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到，有一个新的类 `java.lang.Record`，它将作为所有记录类的超类型。它是抽象的，并声明 `equals()`、`hashCode()`
    和 `toString()` 为抽象方法。`java.lang.Record` 类不能直接扩展，正如我们可以通过尝试编译一些像这样的代码来看到：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The compiler will reject this attempt:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将拒绝这个尝试：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The only way to get a record is to explicitly declare one and have `javac` create
    the class file. This also ensures that all record classes are created as final.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 获取记录的唯一方法是通过显式声明一个记录并让 `javac` 创建类文件。这也确保了所有记录类都被创建为最终的。
- en: 'As well as the autogeneration of methods and boilerplate reduction, a couple
    of other core Java features also have special characteristics when applied to
    Records. First, Records must obey a special contract regarding the `equals()`
    method: if a record `R` has components `c1`, `c2`, ... `cn`, and if a record instance
    is copied as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了方法的自动生成和样板代码的减少之外，当应用于记录时，Java 的几个核心特性也具有特殊的特点。首先，记录必须遵守关于 `equals()` 方法的特殊契约：如果一个记录
    `R` 有组件 `c1`、`c2`、... `cn`，并且如果记录实例按照以下方式复制：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: then it must be the case that `r.equals(copy)` is `true`. Note that this invariant
    is in addition to the usual familiar contract regarding `equals()` and `hashCode()`—it
    does not replace it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`r.equals(copy)` 必须是 `true`。请注意，这个不变性是在关于 `equals()` 和 `hashCode()` 的通常熟悉契约的基础上增加的——它并不取代它。
- en: At this point, let’s move on to talk about some of the more design-level aspects
    of the Records feature. To do so, it’s helpful to recall how enums work in Java.
    An enum in Java is a special form of class that implements a design pattern (*finitely
    many typesafe instances*) but with minimal syntax overhead—the compiler generates
    a bunch of code for us.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，让我们继续讨论记录功能的一些更设计层面的方面。为了做到这一点，回忆一下 Java 中枚举的工作方式是有帮助的。Java 中的枚举是一种特殊的类形式，它实现了一个设计模式（*有限数量的类型安全实例*）但具有最少的语法开销——编译器为我们生成了一堆代码。
- en: Similarly, a record in Java is a special form of class that implements a pattern
    (*Data Carrier* aka *Just Holds Fields*) with minimal syntax. All of the boilerplate
    code that we expect will be autogenerated for us by the compiler. However, although
    the simple concept of a Data Carrier class that just holds fields makes intuitive
    sense, what does that really mean in detail?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Java 中的记录是一种特殊的类形式，它实现了一个模式（*数据载体* 即 *仅包含字段*）并具有最少的语法。我们期望的所有样板代码都将由编译器自动生成。然而，尽管仅包含字段的数据载体类的简单概念在直觉上是有意义的，但这在细节上究竟意味着什么呢？
- en: 'When Records were first being discussed, a lot of possible different designs
    were considered. For example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次讨论记录时，考虑了许多可能的不同设计。例如：
- en: Boilerplate reduction of POJOs
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POJOs 的样板代码减少
- en: Java Beans 2.0
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java Beans 2.0
- en: Named tuples
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名元组
- en: Product types (a form of *algebraic data type*)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品类型（一种代数数据类型的形式）
- en: 'These possibilities were discussed by Brian Goetz in his original design sketch
    ([http://mng.bz/M5j8](http://mng.bz/M5j8)) in some detail. Each design option
    comes with additional secondary questions that follow from the choice of the design
    center for Records, questions such as:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 布赖恩·戈茨在他的原始设计草图（[http://mng.bz/M5j8](http://mng.bz/M5j8)）中详细讨论了这些可能性。每个设计选项都伴随着从记录设计中心的选择中产生的附加次要问题，例如：
- en: Can Hibernate proxy them?
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate能否代理它们？
- en: Are they fully compatible with classic Java Beans?
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是否与经典Java Bean完全兼容？
- en: Do they support name erasure/“shape malleability”?
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是否支持名称擦除/“形状可塑性”？
- en: Will they come with Pattern Matching and destructuring?
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是否会包含模式匹配和结构化？
- en: It would have been plausible to base the Records feature on any one of the above
    four approaches—each has advantages and disadvantages. However, the final design
    decision is that Records are *named tuples*. This is partially driven by a key
    design idea in Java’s type system— *nominal typing*. Let’s take a closer look
    at this key idea.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果记录功能基于上述四种方法中的任何一种——每种方法都有其优点和缺点——似乎是合理的。然而，最终的设计决策是记录是*命名元组*。这在一定程度上是由Java类型系统中的一个关键设计理念驱动的——*名义类型化*。让我们更深入地了解一下这个关键理念。
- en: 3.3.1 Nominal typing
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 名义类型化
- en: The nominal approach to static typing is the idea that every piece of Java storage
    (variables, fields) has a definite type and that each type has a name, which should
    be (at least somewhat) meaningful to humans.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型化的名义方法是指每个Java存储（变量、字段）都有一个确定的类型，并且每种类型都有一个名称，这个名称应该（至少在一定程度上）对人类有意义。
- en: 'Even in the case of anonymous classes, the types still have names—it’s just
    that the compiler assigns the names and they are not valid names for types in
    the Java language (but are still OK within the JVM). For example, we can see this
    in jshell:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在匿名类的情况下，类型仍然有名称——只是编译器分配了名称，这些名称在Java语言中不是有效的类型名称（但在JVM内部仍然是可以的）。例如，我们可以在jshell中看到这一点：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that even though the anonymous classes were declared in exactly the same
    way, the compiler still produced two different anonymous classes, `$0` and `$1`,
    and would not allow the assignment, because in the Java type system, the variables
    have different types.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管匿名类是以完全相同的方式声明的，但编译器仍然生成了两个不同的匿名类`$0`和`$1`，并且不允许赋值，因为在Java类型系统中，变量具有不同的类型。
- en: Note There are other (non-Java) languages where the overall shape of class (e.g.,
    what fields and methods it has) can be used as the type (rather than an explicit
    type name). This is called *structural typing*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在其他（非Java）语言中，类的整体形状（例如，它有哪些字段和方法）可以用作类型（而不是显式的类型名称）。这被称为*结构化类型化*。
- en: 'It would have been a major change if Records had broken with Java’s heritage
    and brought in structural typing for Records. As a result, the “Records are nominal
    tuples” design choice means that we expect that Records will work best where we
    might use tuples in other languages. This includes use cases such as compound
    map keys, or to simulate multireturn from a method. An example compound map key
    might look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果记录与Java的传统相悖，引入了结构化类型，这将是一个重大的变化。因此，“记录是名义元组”的设计选择意味着我们期望记录在可能使用其他语言中的元组的地方表现最佳。这包括复合映射键的使用，或者模拟方法的多返回值。一个复合映射键的例子可能如下所示：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Conversely, Records will not necessarily work well as a replacement for existing
    code that currently uses Java Beans. A number of reasons exist, notably that Java
    Beans are mutable whereas Records are not and that they have different conventions
    for their accessors. Records name their accessor methods the same as the field
    names (possible because field and method names are separately namespaced in Java)
    whereas Beans prepend `get` and `set`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，记录不一定能很好地作为现有代码的替代品，这些代码目前使用Java Bean。存在许多原因，特别是Java Bean是可变的，而记录是不可变的，并且它们对访问器的约定不同。记录将访问器方法命名为与字段名相同（这是因为在Java中字段和方法名称是分开命名空间的）而Bean则使用`get`和`set`前缀。
- en: Records do allow some additional flexibility above and beyond the simple, single-line
    declaration form because they are genuine classes. Specifically, the developer
    can define additional methods, constructors, and static fields apart from the
    autogenerated defaults. However, these capabilities should be used carefully.
    Remember that the design intent of Records is to allow the developer to group
    related fields as a single, immutable data item.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 记录确实允许一些额外的灵活性，超出简单的单行声明形式，因为它们是真正的类。具体来说，开发者可以定义额外的函数、构造函数和静态字段，除了自动生成的默认值之外。然而，这些功能应该谨慎使用。记住，记录的设计意图是允许开发者将相关字段组合成一个单一的不可变数据项。
- en: One example of a use additional method that a record might create is a static
    factory method to simulate default values for some of the record parameters. Another
    example might be a `Person` class (with immutable date of birth) that might define
    a `currentAge()` method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 记录可能创建的一个使用额外方法的例子是一个静态工厂方法，用于模拟某些记录参数的默认值。另一个例子可能是一个`Person`类（具有不可变的出生日期），它可能定义一个`currentAge()`方法。
- en: 'A good rule of thumb is: the more tempting it is to add a lot of additional
    methods and so on to the basic Data Carrier (or to make it implement several interfaces),
    the more likely it is that a full class should be used, rather than a record.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的经验法则是：越是有诱惑力添加大量额外的方法等到基本数据载体（或使其实现多个接口），就越有可能应该使用一个完整的类，而不是记录。
- en: 3.3.2 Compact record constructors
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 紧凑记录构造函数
- en: 'One important possible exception to the simplicity/“full class” rule of thumb
    is the use of *compact constructors*, which are described like this in the language
    specification:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 简单性/“完整类”规则的一个可能的重要例外是使用*紧凑构造函数*，语言规范中是这样描述的：
- en: The formal parameters of a compact constructor of a record class are implicitly
    declared. They are given by the derived formal parameter list of the record class.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类的紧凑构造函数的正式参数是隐式声明的。它们由记录类的派生正式参数列表给出。
- en: The intention of a compact constructor declaration is that only validation and/or
    normalization code need be given in the body of the canonical constructor; the
    remaining initialization code is supplied by the compiler.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 紧凑构造函数声明的意图是，在规范构造函数体中只需要给出验证和/或规范化代码；其余的初始化代码由编译器提供。
- en: —Java Language Specification
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ——Java语言规范
- en: 'For example, we might want to validate orders to make sure that they don’t
    attempt to buy or sell negative quantities or set an invalid time-to-live as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能想要验证订单，以确保它们不会尝试购买或出售负数量或设置无效的存活时间，如下所示：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: One advantage that Java Records have over the anonymous tuples found in other
    languages is that the constructor body of a record allows for code to be run when
    Records are created. This allows for validation to occur (and exceptions to be
    thrown if an invalid state is passed). This would not be possible in purely structural
    tuples.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Java记录相对于其他语言中找到的匿名元组的一个优点是，记录的构造函数体允许在创建记录时运行代码。这允许进行验证（如果传递了无效状态，则抛出异常）。这在纯结构元组中是不可能的。
- en: It might also make sense to use static factory methods within the body of the
    record, for example, to work around the lack of default parameter values in Java.
    In our trading example we might include a static factory like this
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录体中使用静态工厂方法也可能是有意义的，例如，为了解决Java中默认参数值的缺乏。在我们的交易示例中，我们可能包括一个这样的静态工厂：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: to declare a quick way to create orders with defaulted parameters. This could
    also be declared as an alternate constructor, of course. The developer should
    choose which approach makes sense to them in each circumstance.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个快速创建具有默认参数的订单的方法。当然，这也可以声明为一个替代构造函数。开发者应该选择在每个情况下对他们有意义的做法。
- en: 'One other use for alternate constructors is to create Records for use as compound
    map keys, as in this example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用替代构造函数的用途是创建用于作为复合映射键的记录，如下例所示：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The type `OrderPartition` can then be easily used as a map key. For instance,
    we might want to construct an order book for use in our trade matching engine,
    like so:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，类型`OrderPartition`可以很容易地用作映射键。例如，我们可能想要构建一个用于我们的交易匹配引擎的订单簿，如下所示：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, when a new order is received, the `addOrder()` method extracts the appropriate
    order partition (consisting of a tuple of the currency pair and buy/sell side)
    and uses it to add the new order to the appropriate price-ranked order book. The
    new order might match against existing orders already on the books (which is called
    “crossing” of orders), so we need to check if it does in the `checkForCrosses()`
    method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当收到新的订单时，`addOrder()` 方法会提取适当的订单分区（由货币对和买卖双方的元组组成）并使用它将新订单添加到相应的价格排名订单簿中。新订单可能与簿上已有的订单相匹配（这被称为“订单交叉”），因此我们需要在
    `checkForCrosses()` 方法中检查它是否匹配。
- en: Sometimes we might want not to use the compact constructor and instead have
    a full, explicit canonical constructor. This signals that we need to do actual
    work in the constructor—and the number of use cases for this with simple Data
    Carrier classes is small. However, for some situations, like the need to make
    defensive copies of incoming parameters, this is necessary. As a result, the possibility
    of an explicit canonical constructor is permitted by the compiler—but think very
    carefully before making use of this approach.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能不想使用紧凑的构造函数，而是有一个完整、显式的规范构造函数。这表明我们需要在构造函数中实际工作——对于简单数据载体类，这种用法的用例数量很少。然而，在某些情况下，例如需要制作传入参数的防御性副本时，这是必要的。因此，编译器允许使用显式规范构造函数的可能性——但在使用这种方法之前请仔细思考。
- en: Records are intended to be simple Data Carriers, a version of tuples that fits
    into Java’s established type system in a logical and consistent manner. This will
    help many applications make domain classes clearer and smaller. It will also help
    teams eliminate many hand-coded implementations of the underlying pattern. It
    should also reduce or remove the need for libraries like Lombok.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Records 的目的是作为简单的数据载体，是元组的一种版本，它以逻辑和一致的方式适应 Java 的既定类型系统。这将帮助许多应用程序使域类更清晰、更小。它还将帮助团队消除许多底层模式的代码实现。它还应该减少或消除对
    Lombok 等库的需求。
- en: Many developers are already reporting significant improvements when starting
    to use Records. They also combine extremely well with another new feature that
    also arrived in Java 17—Sealed Types.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者已经开始报告在使用 Records 后的显著改进。它们还与 Java 17 中出现的另一个新特性——Sealed Types 结合得非常好。
- en: 3.4 Sealed Types
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 密封类型
- en: Java’s enums are a well-known language feature. They allow the programmer to
    model a finite set of alternatives that represent all possible values of a type—effectively
    typesafe constants.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Java 的枚举是一个众所周知的语言特性。它允许程序员对有限集合的替代方案进行建模，这些替代方案代表了一个类型的所有可能值——实际上是类型安全的常量。
- en: 'To continue our FX example, let’s consider an `OrderType` enum to denote different
    types of order:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续我们的 FX 示例，让我们考虑一个 `OrderType` 枚举来表示不同的订单类型：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This represents two possible types of FX order: a *market* order that will
    take whatever the current best price is, and a *limit* order that will execute
    only when a specific price is available. The platform implements enums by having
    the Java compiler automatically generate a special form of class type.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了两种可能的 FX 订单类型：一种 *市价* 订单，它将接受当前最佳价格，以及一种 *限价* 订单，它仅在特定价格可用时才会执行。平台通过让 Java
    编译器自动生成特殊形式的类类型来实现枚举。
- en: Note The runtime actually treats the library type `java.lang.Enum` (which all
    enum classes directly extend) in a slightly special way compared to other classes,
    but the details of this need not concern us here.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：运行时实际上以与其他类略有不同的方式处理库类型 `java.lang.Enum`（所有枚举类都直接扩展），但这里的细节不需要我们关心。
- en: 'Let’s decompile this enum and see what the compiler generates as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们反编译这个枚举，看看编译器生成了什么，如下所示：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Within the class file, all the possible values of the enum are defined as `public`
    `static final` variables, and the constructor is private, so additional instances
    cannot be constructed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在类文件中，枚举的所有可能值都定义为 `public` `static final` 变量，构造函数是私有的，因此不能构造额外的实例。
- en: In effect, an enum is like a generalization of the Singleton pattern, except
    that instead of being only one instance of the class, there are a finite number.
    This pattern is extremely useful, especially because it gives us a notion of *exhaustiveness*—given
    a not-null `OrderType` object, we can know for sure that it is either the `MARKET`
    or the `LIMIT` instance.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，枚举类似于 Singleton 模式的泛化，除了它不是类的一个实例，而是有限数量的实例。这个模式非常有用，尤其是因为它给了我们一个关于 *完备性*
    的概念——给定一个非空的 `OrderType` 对象，我们可以确定它要么是 `MARKET` 实例，要么是 `LIMIT` 实例。
- en: However, suppose we want to model many different orders in Java 11\. We must
    choose between two unpalatable alternatives. First, we can choose to have a single
    implementing class (or record), `FXOrder`, with a state field holding the actual
    type. This pattern works because the state field is of enum type and provides
    the bits that indicate which type is really meant for this specific object. This
    is obviously suboptimal, because it requires the application programmer to keep
    track of bits that are really the proper concern of the type system. Alternatively,
    we can declare an abstract base class, `BaseOrder`, and have concrete types, `MarketOrder`
    and `LimitOrder`, that subclass it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设我们想在 Java 11 中模拟许多不同的订单。我们必须在两种不令人满意的替代方案之间做出选择。首先，我们可以选择只有一个实现类（或记录），`FXOrder`，其中包含一个状态字段来持有实际类型。这种模式之所以有效，是因为状态字段是枚举类型，并提供了指示哪个类型真正适用于此特定对象的位。这显然是不太理想的，因为它要求应用程序程序员跟踪类型系统真正关心的位。或者，我们可以声明一个抽象基类，`BaseOrder`，并具有具体类型，`MarketOrder`
    和 `LimitOrder`，它们是它的子类。
- en: The issue here is that Java has always been designed as an open language that
    is extensible by default. Classes are compiled at one time, and subclasses can
    be compiled years (or even decades) later. As of Java 11, the only class inheritance
    constructs permitted in the Java language are open inheritance (default) and no
    inheritance (`final`).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，Java 一直被设计为一个开放的语言，默认可扩展。类一次编译，子类可以在多年（甚至几十年）后编译。截至 Java 11，Java 语言中允许的唯一类继承结构是开放继承（默认）和没有继承（`final`）。
- en: Classes can declare a package-private constructor, which effectively means “can
    only be extended by package-mates,” but nothing in the runtime prevents users
    from creating new classes in packages that are not part of the platform, so this
    is an incomplete protection at best.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以声明一个包私有构造函数，这实际上意味着“只能被包成员扩展”，但在运行时没有任何东西可以阻止用户在平台不包含的包中创建新类，所以这最多只是一种不完整的保护。
- en: If we define a `BaseOrder` class, then nothing prevents a third party from creating
    a `EvilOrder` class that inherits from `BaseOrder`. Worse still, this unwanted
    extension can happen years (or decades) after the `BaseOrder` type was compiled,
    which is hugely undesirable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义一个 `BaseOrder` 类，那么没有任何东西可以阻止第三方创建一个继承自 `BaseOrder` 的 `EvilOrder` 类。更糟糕的是，这种不受欢迎的扩展可以在
    `BaseOrder` 类型编译多年（甚至几十年）之后发生，这是非常不希望的。
- en: 'The conclusion is that until now, developers have been constrained and must
    use a field to hold the actual type of the `BaseOrder` if they want to be future-proof.
    Java 17 has changed this state of affairs, by allowing a new way to control inheritance
    in a more fine-grained way: the *sealed type*.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，到目前为止，开发者一直受到限制，如果他们想要确保未来兼容性，就必须使用一个字段来持有 `BaseOrder` 的实际类型。Java 17 改变了这种状况，通过允许一种新的方式以更细粒度的方式控制继承：*密封类型*。
- en: Note This capability is present in several other programming languages in various
    forms and has become somewhat fashionable in recent years, although it is actually
    quite an old idea.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这种能力以各种形式存在于几种其他编程语言中，近年来已经变得相当流行，尽管实际上它是一个相当古老的想法。
- en: 'In its Java incarnation, the concept that sealing expresses is the idea that
    a type can be extended, but only by a known list of subtypes and no others. Let’s
    look at the new syntax for a simple example of a `Pet` class (we’ll return to
    FX examples in a moment):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在其 Java 实现（incarnation）中，密封（sealing）所表达的概念是一个类型可以被扩展，但只能由已知的子类型列表扩展，而不能由其他类型扩展。让我们通过一个简单的
    `Pet` 类（我们稍后会回到 FX 示例）的例子来看看新的语法：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The class `Pet` is declared as `sealed`, which is not a keyword that has been
    permitted in Java until now. Unqualified, `sealed` means that the class can be
    extended only inside the current compilation unit. Therefore, the subclasses have
    to be nested within the current class. We also declare `Pet` to be `abstract`
    because we don’t want any general `Pet` instances, only `Pet.Cat` and `Pet.Dog`
    objects. This provides us with a nice way to implement the object-oriented (OO)
    modeling pattern we described earlier, without the drawbacks that we discussed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `Pet` 被声明为 `sealed`，这并不是 Java 之前允许的关键字。未指定的情况下，`sealed` 表示该类只能在本编译单元内部扩展。因此，子类必须嵌套在当前类内部。我们还声明
    `Pet` 为 `abstract`，因为我们不希望有任何一般的 `Pet` 实例，只有 `Pet.Cat` 和 `Pet.Dog` 对象。这为我们提供了一种很好的方式来实现我们之前描述的面向对象（OO）建模模式，而不必承担我们讨论的缺点。
- en: 'Sealing can also be used with interfaces, and it’s quite possible that the
    interface form will be more widely used in practice than the class form. Let’s
    take a look at what happens when we want to use sealing to help model different
    types of FX orders:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 密封也可以与接口一起使用，并且在实际应用中，接口形式可能比类形式更广泛地使用。让我们看看当我们想要使用密封来帮助建模不同类型的FX订单时会发生什么：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There are several things to notice here. First, `FXOrder` is now a `sealed`
    interface. Second, we can see the use of a second new keyword, `permits`, which
    allows the developer to list the permissible implementations of this sealed interface—and
    our implementations are Records.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的地方。首先，`FXOrder`现在是一个`sealed`接口。其次，我们可以看到第二个新关键字`permits`的使用，它允许开发者列出这个密封接口的允许实现——我们的实现是记录。
- en: Note When you use `permits`, the implementing classes do not have to live within
    the same file and can be separate compilation units.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当你使用`permits`时，实现类不必位于同一文件中，可以是独立的编译单元。
- en: Finally, we have the nice bonus—because `MarketOrder` and `LimitOrder` are proper
    classes, they can have behaviors specific to their types. For example, a market
    order just takes the best price available immediately and does not need to specify
    a price. On the other hand, a limit order needs to specify the price that the
    order will accept and how long it is prepared to wait to try to achieve it (the
    time-to-live or *TTL*). This would not have been straightforward if we were using
    a field to indicate the “real type” of the object, because all methods for all
    subtypes would have to be present on the base type or force us to use ugly downcasts.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个很好的额外奖励——因为`MarketOrder`和`LimitOrder`是合适的类，它们可以拥有特定于其类型的操作。例如，市价单立即采取可用的最佳价格，无需指定价格。另一方面，限价单需要指定订单将接受的价格以及它准备等待多长时间来尝试实现它（生存时间或*TTL*）。如果我们使用字段来指示对象的“真实类型”，这不会很直接，因为所有子类型的方法都必须存在于基类型上，或者迫使我们使用丑陋的下转型。
- en: If we now program with these types, we know that any `FXOrder` instance that
    we encounter must either be a `MarketOrder` or a `LimitOrder`. What’s more, the
    compiler can use this information, too. Library code can now safely assume that
    these are the only possibilities, and this assumption cannot be violated by client
    code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在用这些类型编程，我们知道我们遇到的任何`FXOrder`实例必须是`MarketOrder`或`LimitOrder`之一。更重要的是，编译器也可以使用这个信息。库代码现在可以安全地假设这些是唯一可能的选择，并且这个假设不能被客户端代码违反。
- en: 'Java’s OO model represents the two most fundamental concepts of the relationship
    between types. Specifically, `"Type` `` `X `` `IS-A` ``Y`"`` `and` `"Type` ``
    `X `` `HAS-A` ``Y`."`` Sealed Types represent an object-oriented concept that
    previously could not be modeled in Java: `"Type` `` `X `` `IS-EITHER-A` `Y` `OR`
    ``Z`."`` Alternatively, they can also be thought of as'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Java的OO模型代表了类型之间关系的两个最基本概念。具体来说，是`"Type X IS-A Y"`和`"Type X HAS-A Y"`。密封类型代表了一种面向对象的概念，以前在Java中无法建模：`"Type
    X IS-EITHER-A Y OR Z"`。或者，它们也可以被视为
- en: A halfway house between `final` and open classes
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`final`和开放类之间的折中方案
- en: The enum pattern applied to types instead of instances
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将枚举模式应用于类型而不是实例
- en: In terms of OO programming theory, they represent a new kind of formal relationship,
    because the set of possible types for `o` is the *union* of `Y` and `Z`. Accordingly,
    this is known as a *union type* or *sum type* in various languages, but don’t
    be confused—they are different from C’s `union`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程理论方面，它们代表了一种新的形式关系，因为`o`的可能类型集合是`Y`和`Z`的并集。因此，这被称为各种语言中的*联合类型*或*求和类型*，但不要混淆——它们与C的`union`不同。
- en: For example, Scala programmers can implement a similar idea using case classes
    and their own version of the `sealed` keyword (and we’ll meet Kotlin’s take on
    this idea later).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Scala程序员可以使用类似的想法，使用case类和它们自己的`sealed`关键字版本（我们稍后会遇到Kotlin对这个想法的看法）。
- en: Beyond the JVM, the Rust language also provides a notion of *disjoint union*
    types, although it refers to them using the `enum` keyword, which is potentially
    *extremely* confusing for Java programmers. In the functional programming world,
    some languages (e.g., Haskell) provide a feature called *algebraic data types*
    that contain sum types as a special case. In fact, the combination of Sealed Types
    and Records also provides Java 17 with a version of this feature.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 JVM 之外，Rust 语言还提供了一种称为 *不交联合* 类型的概念，尽管它使用 `enum` 关键字来引用，这对 Java 程序员来说可能 *极其*
    混淆。在函数式编程领域，一些语言（例如 Haskell）提供了一种称为 *代数数据类型* 的功能，其中包含作为特殊情况的和类型。实际上，Sealed Types
    和 Records 的组合也为 Java 17 提供了这一功能的版本。
- en: 'On the face of it, these types seem like a completely new concept in Java,
    but their deep similarity to enums should provide a good starting point for many
    Java programmers. In fact, something similar to these types already exists in
    one place: the type of the exception parameter in a multicatch clause.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，这些类型在 Java 中似乎是一个全新的概念，但它们与枚举的深层相似性应该为许多 Java 程序员提供一个良好的起点。事实上，与这些类型相似的东西已经存在于一个地方：多捕获子句中异常参数的类型。
- en: 'From the Java Language Specification (JLS 11, section 14.20):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Java 语言规范（JLS 11，第 14.20 节）：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: However, in the multicatch case, the true union type cannot be written as the
    type of a local variable—it is *nondenotable*. We cannot create a local variable
    typed as the true union type in the case of multicatch.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在多捕获的情况下，真正的联合类型不能写成局部变量的类型——它是 *不可表示的*。在多捕获的情况下，我们不能创建一个类型为真正联合类型的局部变量。
- en: 'We should make one final point about Java’s Sealed Types: they must have a
    base class that all the permitted types extend (or a common interface that all
    permitted types must implement). It is not possible to express a type that is
    “ISA-String-OR-Integer,” because the types `String` and `Integer` have no common
    inheritance relationship apart from `Object`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该关于 Java 的 Sealed Types 提出一点：它们必须有一个基类，所有允许的类型都扩展（或一个所有允许的类型都必须实现的公共接口）。无法表达一个“ISA-String-OR-Integer”的类型，因为
    `String` 和 `Integer` 类型除了 `Object` 之外没有共同的继承关系。
- en: Note Some other languages do permit the construction of general union types,
    but it’s not possible in Java.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：一些其他语言允许构建通用联合类型，但在 Java 中这是不可能的。
- en: Let’s move on to discuss another new language feature that was delivered in
    Java 17—a new form of the `instanceof` keyword.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论 Java 17 中引入的另一个新语言特性——`instanceof` 关键字的新形式。
- en: 3.5 New form of instanceof
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 新的 instanceof 形式
- en: 'Despite being part of the language since Java 1.0, the `instanceof` operator
    sometimes gets a certain amount of bad press from some Java developers. In its
    simplest form, it provides a simple test: `x` `instanceof` `Y` returns `true`
    if the value `x` can be assigned to a variable of type `Y` and `false` otherwise
    (with the caveat that `null` `instanceof` `Y` is `false` for every `Y`).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管自 Java 1.0 以来就是语言的一部分，但 `instanceof` 操作符有时会从一些 Java 开发者那里得到一些负面评价。在其最简单的形式中，它提供了一个简单的测试：`x`
    `instanceof` `Y` 如果值 `x` 可以赋给类型 `Y` 的变量，则返回 `true`，否则返回 `false`（前提是 `null` `instanceof`
    `Y` 对于每个 `Y` 都是 `false`）。
- en: This definition has been derided as undermining object-oriented design, because
    it implies a lack of preciseness in the types of objects and possibly in the choice
    of parameter types. However, in practice, in some scenarios the developer must
    confront an object that has a type that is not fully known at compile time. For
    example, consider an object that has been obtained reflectively about which little
    or nothing is known.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种定义被批评为破坏面向对象设计，因为它暗示了对象类型和参数类型选择的不精确性。然而，在实践中，在某些场景中，开发者必须面对一个在编译时类型不完全已知的对象。例如，考虑一个通过反射获得的对象，对其了解甚少。
- en: 'In these circumstances, the appropriate thing to do is to use `instanceof`
    to check that the type is as expected and then perform a downcast. The `instanceof`
    test provides a guard condition that ensures that the cast will not cause a `ClassCastException`
    at runtime. The resulting code looks like this example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，正确的方法是使用 `instanceof` 来检查类型是否符合预期，然后进行向下转型。`instanceof` 测试提供了一个保护条件，确保转型不会在运行时引发
    `ClassCastException`。生成的代码如下所示：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'From the point of view of the developer, the new `instanceof` capability available
    in Java 17 is very simple—it simply provides a way to avoid the cast, as shown
    here:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，Java 17 中提供的新的 `instanceof` 功能非常简单——它仅仅提供了一种避免转型的方法，如下所示：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ s is in scope on this branch.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ s 在此分支中是有效的。
- en: ❷ s is not in scope on the “else” branch.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在“else”分支上，s不在作用域内。
- en: ❸ s is not in scope once the if statement has ended.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一旦if语句结束，s就不再在作用域内。
- en: However, although it might not seem that important, we get an important clue
    from the way that the JEP for this feature was named. JEP 394 was titled “Pattern
    Matching for instanceof,” and it introduces a new concept—the *pattern*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管这可能看起来并不重要，但我们从为这个功能的JEP命名方式中得到了一个重要的线索。JEP 394的标题是“为instanceof的模式匹配”，它引入了一个新概念——*模式*。
- en: Note It is very important to understand that this is a different usage of *pattern
    matching* than that used in text processing and regular expressions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 非常重要的一点是要理解，这与在文本处理和正则表达式中所使用的*模式匹配*是不同的用法。
- en: 'In this context, a pattern is a combination of the following two things:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，一个模式是以下两个事物的组合：
- en: A predicate (aka test) that will be applied to a value
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个将被应用于值的谓词（又称测试）
- en: A set of local variables, known as *pattern variables*, that are to be extracted
    from the value
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一组局部变量，称为*模式变量*，将从值中提取
- en: The key point is that the pattern variables are extracted only if the predicate
    is successfully applied to the value.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点是，只有当谓词成功应用于值时，才会提取模式变量。
- en: In Java 17, the `instanceof` operator has been extended to take either a type
    or a *type pattern*, where a type pattern consists of a predicate that specifies
    a type, along with a single pattern variable.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 17中，`instanceof`运算符已被扩展为接受类型或*类型模式*，其中类型模式由指定类型的谓词和一个模式变量组成。
- en: Note We will meet type patterns in more detail in the next section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 我们将在下一节中更详细地介绍类型模式。
- en: As it stands, the upgraded `instanceof` does not seem to be very significant,
    but it is the first time that patterns have been seen in the Java language, and
    as we will see, more usages are coming! This is but the first step.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 目前看来，升级后的`instanceof`似乎并不非常显著，但这却是Java语言中首次出现模式，正如我们将看到的，更多的用法即将到来！这只是第一步。
- en: Having completed our tour of new Java 17 language features, it’s time to look
    to the future and return to the subject of preview features.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了对Java 17新语言特性的巡礼后，是时候展望未来，并回到预览功能的主题上。
- en: 3.6 Pattern Matching and preview features
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 模式匹配和预览功能
- en: In chapter 1, we introduced the concept of preview features, but we couldn’t
    give a good example of one, because Java 11 didn’t have any preview features!
    Now that we’re talking about Java 17, we can carry on with the discussion.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1章，我们介绍了预览功能的概念，但我们无法给出一个很好的例子，因为Java 11没有任何预览功能！现在我们正在谈论Java 17，我们可以继续讨论。
- en: In fact, all of the new language features that we’ve met in this chapter, including
    Switch Expressions, Records, and Sealed Types, went through the same lifecycle.
    They started out as preview features and went through one or more rounds of public
    preview before being delivered as final features. For example, sealed classes
    were previewed in Java 15, and again in 16, before being delivered as a final
    feature in Java 17 LTS.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们在本章中遇到的所有新语言特性，包括Switch表达式、记录和密封类型，都经历了相同的生命周期。它们最初作为预览功能出现，并在成为最终功能之前经历了一轮或多轮公开预览。例如，密封类在Java
    15中进行了预览，然后在16中也进行了预览，最终在Java 17 LTS中作为最终功能发布。
- en: In this section, we’re going to meet a preview feature that extends Pattern
    Matching from `instanceof` to `switch`. Java 17 includes a version of this feature,
    but only as a first preview version (see chapter 1 for more details on preview
    features). The syntax is liable to change before the final release (and the feature
    may even be withdrawn, although this is most unlikely for Pattern Matching).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将遇到一个扩展模式匹配从`instanceof`到`switch`的预览功能。Java 17包括这个功能的版本，但仅作为第一个预览版本（有关预览功能的更多详细信息，请参阅第1章）。语法可能在最终发布前发生变化（尽管这个功能被撤回的可能性很小，但对于模式匹配来说，这种情况最不可能发生）。
- en: 'Let’s see how Pattern Matching can be used in a simple case to improve some
    code that has to deal with objects of unknown type. We can use the new form of
    `instanceof` to write some safe code like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看模式匹配如何在简单情况下被用来改进一些必须处理未知类型对象的代码。我们可以使用新的`instanceof`形式来编写一些安全的代码，如下所示：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is quickly going to get cumbersome and verbose, though. Instead, we could
    introduce type patterns into a `switch` expression, as well as the simple `instanceof`
    Boolean expressions we already have. In the syntax of the current (Java 17) preview
    feature, we can rewrite the previous code into a simple form:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这很快就会变得繁琐且冗长。相反，我们可以在`switch`表达式和简单的`instanceof`布尔表达式中引入类型模式。在当前（Java 17）预览功能的语法中，我们可以将之前的代码重写为简单形式：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ Null is now allowed as a case label to prevent the possibility of NullPointerException.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 现在允许将`Null`作为情况标签，以防止`NullPointerException`的可能性。
- en: 'For those developers who want to experiment with code like this, we should
    explain how to build and run with preview features. If we try to compile code
    like the previous example that uses a preview feature, we get an error, as shown
    next:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些想要尝试类似代码的开发者，我们应该解释如何使用预览功能进行构建和运行。如果我们尝试编译使用预览功能的类似上一个示例的代码，我们会得到一个错误，如下所示：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The compiler helpfully hints that we might need to enable preview features,
    so we try again with the flag enabled:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器友好地提示我们可能需要启用预览功能，所以我们再次尝试启用标志：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The story is similar at runtime as well:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时的情况也类似：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, if we include the preview flag, then the code will finally run:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们包含预览标志，那么代码最终将运行：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The need to constantly enable the preview features is a pain, but it is designed
    to protect developers from having any code that uses unfinished features from
    escaping into production and causing problems there. Similarly, it’s important
    to note the message about class file version that appeared when we tried to run
    a class containing preview features without the runtime flag. If we have explicitly
    compiled with preview features, we do not get a standard class file, and most
    teams should not be running that code in production.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 恒常地启用预览功能确实很麻烦，但它是为了保护开发者，防止任何使用未完成功能的代码逃入生产环境并造成问题。同样，重要的是要注意，当我们尝试在没有运行时标志的情况下运行包含预览功能的类时出现的关于类文件版本的提示。如果我们明确编译了预览功能，我们不会得到标准的类文件，而且大多数团队不应该在生产环境中运行该代码。
- en: 'The preview version of Pattern Matching in Java 17 also has functionality to
    integrate closely with Sealed Types. Specifically, patterns can take advantage
    of the fact that Sealed Types offer exclusivity of the possible types that can
    be seen. For example, when processing FX order responses, we may have the following
    base type:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Java 17中模式匹配的预览版本还具有与Sealed Types紧密集成的功能。具体来说，模式可以利用Sealed Types提供的可能看到类型的唯一性。例如，在处理FX订单响应时，我们可能有以下基本类型：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can combine this with a switch expression and type patterns, to give some
    code like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此与`switch`表达式和类型模式结合起来，给出以下代码：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that a) we explicitly include a `case null` to ensure this code is null-safe
    (and won’t throw a `NullPointerException`), and b) we do not need a default. The
    second point is because the compiler can examine all of the permitted subtypes
    of `FXOrderResponse` and can conclude that the pattern match is *total*, it covers
    every possibility that could ever occur and so a default case would be dead code
    under all circumstances. In the case where the match is not total, and some cases
    are not covered, a default would be needed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到a)我们明确包含了一个`case null`来确保此代码是null安全的（并且不会抛出`NullPointerException`），以及b)我们不需要默认情况。第二个原因是因为编译器可以检查`FXOrderResponse`的所有允许的子类型，并且可以得出结论，模式匹配是*完全的*，它涵盖了可能发生的所有可能性，因此默认情况在所有情况下都是无效代码。在匹配不是完全的情况下，并且某些情况没有被覆盖时，需要默认情况。
- en: 'The first preview also includes *guarded patterns*, which allow a pattern to
    be decorated with a Boolean guard condition, so the overall pattern matches only
    if both the pattern predicate and the guard are true. For example, let’s suppose
    we want to see the details only of large filled orders. We can change the fill
    case in the previous example to some code like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次预览还包括*受保护的模式*，这允许一个模式被布尔守卫条件装饰，因此只有当模式谓词和守卫都为真时，整体模式才匹配。例如，假设我们只想看到大型填充订单的详细信息。我们可以将上一个示例中的填充情况更改为以下代码：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that the more specific case (small orders of less than 100 units) is tested
    first, and only if it fails does the match attempt the next case, which is the
    unguarded match for fills. The pattern variable is also already in scope for any
    guard conditions. We will return to Pattern Matching in chapter 18 when we discuss
    the future of Java and talk about some features that didn’t make it in time for
    Java 17\.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，更具体的案例（小于100个单位的少量订单）首先进行测试，并且只有当它失败时，匹配尝试下一个案例，即填充的无保护匹配。模式变量也已经适用于任何保护条件。我们将在第18章中回到模式匹配，当我们讨论
    Java 的未来并讨论一些未能及时加入 Java 17 的特性时。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Java 17 introduced a number of new features that developers will immediately
    be able to take advantage of in their own code:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 17 引入了许多新特性，开发者可以立即在自己的代码中利用这些特性：
- en: Text Blocks for multiline strings.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本块，用于多行字符串。
- en: Switch Expressions for a more modern switch experience.
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开关表达式，提供更现代的开关体验。
- en: Records as transparent carriers of data.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录作为透明数据载体。
- en: Sealed Types—an important new OO modeling concept.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装类型——一个重要的新面向对象建模概念。
- en: Pattern Matching—although not fully delivered as of Java 17, it clearly shows
    the direction of travel of the language in the coming versions.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配——尽管在 Java 17 中尚未完全实现，但它清楚地显示了语言在即将到来的版本中的发展方向。
