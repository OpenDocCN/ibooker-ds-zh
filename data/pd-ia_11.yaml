- en: 9 The GroupBy object
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 GroupBy对象
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Splitting a `DataFrame` into groups by using the `groupby` method
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`groupby`方法按组拆分`DataFrame`
- en: Extracting first and last rows from groups in a `GroupBy` object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`GroupBy`对象中的组中提取第一行和最后一行
- en: Performing aggregate operations on `GroupBy` groups
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`GroupBy`组上执行聚合操作
- en: Iterating over `DataFrames` in a `GroupBy` object
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历`GroupBy`对象中的`DataFrame`
- en: The pandas library’s `GroupBy` object is a storage container for grouping `DataFrame`
    rows into buckets. It provides a set of methods to aggregate and analyze each
    independent group in the collection. It allows us to extract rows at specific
    index positions within each group. It also offers a convenient way to iterate
    over the groups of rows. There’s lots of power packed into a `GroupBy` object,
    so let’s see what it’s capable of doing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: pandas库的`GroupBy`对象是一个用于将`DataFrame`行分组到桶中的存储容器。它提供了一套方法来聚合和分析集合中的每个独立组。它允许我们在每个组中提取特定索引位置的行。它还提供了一个方便的方式来遍历行的组。`GroupBy`对象中包含了很多强大的功能，所以让我们看看它能做什么。
- en: 9.1 Creating a GroupBy object from scratch
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 从头创建一个GroupBy对象
- en: 'Let’s create a new Jupyter Notebook and import the pandas library:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的Jupyter Notebook并导入pandas库：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We’ll kick things off with a small example and dive into more of the technical
    details in section 9.2\. Let’s begin by creating a `DataFrame` that stores the
    prices of fruits and vegetables in a supermarket:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个小的例子开始，并在第9.2节中深入更多技术细节。让我们首先创建一个`DataFrame`，它存储了超市中水果和蔬菜的价格：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The Type column identifies the group to which an Item belongs. There are two
    groups of items in the supermarket data set: fruits and vegetables. We can use
    terms such as *groups*, *buckets*, and *clusters* interchangeably to describe
    the same idea. Multiple rows fall into the same category.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类型列标识一个项目所属的组。在超市数据集中有两种项目组：水果和蔬菜。我们可以使用诸如*组*、*桶*和*簇*等术语来互换地描述相同的概念。多行可能属于同一类别。
- en: The `GroupBy` object organizes `DataFrame` rows into buckets based on shared
    values in a column. Suppose that we are interested in the average price of a fruit
    and the average price of a vegetable. If we could isolate the `"Fruit"` rows and
    `"Vegetable"` rows into separate groups, it would be easier to perform the calculations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupBy`对象根据列中的共享值将`DataFrame`行组织到桶中。假设我们感兴趣的是水果的平均价格和蔬菜的平均价格。如果我们能将`"Fruit"`行和`"Vegetable"`行隔离到不同的组中，那么进行计算会更容易。'
- en: 'Let’s begin by invoking the `groupby` method on the supermarket `DataFrame`.
    We need to pass it the column whose values pandas will use to create the groups.
    The next example provides the Type column. The method returns an object we haven’t
    seen yet: a `DataFrameGroupBy`. The `DataFrameGroupBy` object is separate and
    distinct from a `DataFrame`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在超市`DataFrame`上调用`groupby`方法开始。我们需要传递给它pandas将用于创建组的列。下一个示例提供了类型列。该方法返回一个我们尚未见过的对象：一个`DataFrameGroupBy`。`DataFrameGroupBy`对象与`DataFrame`是分开且独立的：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The Type column has two unique values, so the `GroupBy` object will store two
    groups. The `get_group` method accepts a group name and returns a `DataFrame`
    with the corresponding rows. Let’s pull out the `"Fruit"` rows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 类型列有两个唯一值，因此`GroupBy`对象将存储两个组。`get_group`方法接受一个组名并返回一个包含相应行的`DataFrame`。让我们提取出`"Fruit"`行：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can also pull out the `"Vegetable"` rows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以提取出`"Vegetable"`行：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `GroupBy` object excels at aggregate operations. Our original goal was
    to calculate the average price of the fruits and vegetables in supermarket. We
    can invoke the `mean` method on `groups` to calculate the average price of items
    within each group. With a few lines of code, we’ve successfully split, aggregated,
    and analyzed a data set:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupBy`对象在聚合操作方面表现出色。我们的原始目标是计算超市中水果和蔬菜的平均价格。我们可以在`groups`上调用`mean`方法来计算每个组内项目的平均价格。通过几行代码，我们已经成功拆分、聚合和分析了一个数据集：'
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the foundational knowledge under our belts, let’s move on to a more complex
    data set.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了基础知识之后，让我们继续到一个更复杂的数据集。
- en: 9.2 Creating a GroupBy object from a data set
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 从数据集中创建一个GroupBy对象
- en: 'The Fortune 1000 is a listing of the 1,000 largest companies in the United
    States by revenue. The list is updated annually by the business magazine *Fortune*.
    The fortune1000.csv file is a collection of Fortune 1000 companies from 2018\.
    Each row includes a company’s name, revenue, profits, employee count, sector,
    and industry:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 《财富》1000强是美国按收入排名的前1,000家大公司的名单。《财富》杂志每年更新一次这个名单。fortune1000.csv文件是2018年的《财富》1000强公司的集合。每一行包括公司的名称、收入、利润、员工人数、行业和子行业：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A sector can have many companies. Apple and Amazon.com both belong to the `"Technology"`
    sector, for example.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个行业可以拥有许多公司。例如，苹果和亚马逊都属于“技术”行业。
- en: An industry is a subcategory within a sector. The `"Pipelines"` and `"Petroleum
    Refining"` industries fall in the `"Energy"` sector, for example.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 行业是某个行业内的子类别。例如，“管道”和“石油精炼”行业属于“能源”行业。
- en: 'The Sector column holds 21 unique sectors. Suppose that we want to find the
    average revenue across the companies within each sector. Before we use the `GroupBy`
    object, let’s solve the problem by taking an alternative approach. Chapter 5 showed
    us how to create a Boolean `Series` to extract a subset of rows from a `DataFrame`.
    The next example pulls out all companies with a Sector value of `"Retailing"`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: “行业”列包含21个独特的行业。假设我们想要找到每个行业内的公司的平均收入。在我们使用`GroupBy`对象之前，让我们通过一个替代方法来解决这个问题。第5章向我们展示了如何创建一个布尔`Series`来从`DataFrame`中提取子集。下一个示例提取了所有“零售”行业的公司：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can pull out the Revenues column from the subset by using square brackets:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用方括号从子集中提取出收入列：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we can calculate the Retailing sector’s average revenue by invoking
    the `mean` method on the Revenues column:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过在收入列上调用`mean`方法来计算“零售”行业的平均收入：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code is suitable for calculating the average revenue of one sector.
    We’ll need to write a lot of additional code, however, to apply the same logic
    to the other 20 sectors in `fortune`. The code is not particularly scalable. Python
    can automate some of the repetition, but the `GroupBy` object offers the best
    solution out of the box. The pandas developers have already solved this problem
    for us.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码适用于计算一个行业的平均收入。然而，我们需要编写大量的额外代码，才能将相同的逻辑应用于《财富》中的其他20个行业。代码的可扩展性不高。Python可以自动化一些重复性工作，但`GroupBy`对象提供了现成的最佳解决方案。pandas开发者已经为我们解决了这个问题。
- en: 'Let’s invoke the `groupby` method on the fortune `DataFrame`. The method accepts
    the column whose values pandas will use to group the rows. A column is a good
    candidate for a grouping if it stores categorical data for the rows. Make sure
    that there are parent categories under which multiple rows fall. The data set
    has 1,000 unique companies but only 21 unique sectors, for example, so the Sector
    column is a good fit for aggregate analysis:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`fortune`的`DataFrame`上调用`groupby`方法。该方法接受一个列，pandas将使用该列的值来分组行。如果列存储了行的分类数据，则列是分组的良好候选。确保有多个行属于其下的父类别。例如，数据集有1,000个独特的公司，但只有21个独特的行业，因此行业列非常适合进行汇总分析：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s output the `sectors` variable to see what kind of object we’re working
    with:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们输出`sectors`变量，看看我们正在处理什么类型的对象：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A `DataFrameGroupBy` object is a bundle of `DataFrame`s. Behind the scenes,
    pandas repeated the extraction process we used for the `"Retailing"` sector but
    for all 21 values in the Sector column.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrameGroupBy`对象是一组`DataFrame`。在幕后，pandas重复了我们用于“零售”行业的提取过程，但针对“行业”列中的所有21个值。'
- en: 'We can count the number of groups in `sectors` by passing the `GroupBy` object
    into Python’s built-in `len` function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`GroupBy`对象传递给Python的内置`len`函数来计算`sectors`中的组数：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `sectors` `GroupBy` object has 21 `DataFrame`s. The number is equal to
    the number of unique values in `fortune`’s Sector column, which we can discover
    by invoking the `nunique` method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`sectors` `GroupBy`对象有21个`DataFrame`。这个数字等于`fortune`的“行业”列中唯一值的数量，我们可以通过调用`nunique`方法来发现这一点：'
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'What are the 21 sectors, and how many companies from fortune belong to each
    one? The `size` method on the `GroupBy` object returns a `Series` with an alphabetical
    list of the groups and their row counts. The following output tells us that 25
    fortune companies have a Sector value of `"Aerospace & Defense"`, 14 have a value
    of `"Apparel"`, and so on:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有哪些21个行业，以及《财富》杂志中每个行业有多少家公司？在`GroupBy`对象上的`size`方法返回一个包含按字母顺序排列的组和它们行数的`Series`。以下输出告诉我们，有25家《财富》公司属于“航空航天与国防”行业，14家属于“服装”行业，等等：
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we’ve bucketed our fortune rows, let’s explore what we can do with
    a `GroupBy` object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将财富行分桶，让我们探索我们可以用`GroupBy`对象做什么。
- en: 9.3 Attributes and methods of a GroupBy object
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 GroupBy对象的属性和方法
- en: 'One way to visualize our `GroupBy` object is as a dictionary that maps the
    21 sectors to a collection of fortune rows belonging to each one. The `groups`
    attribute stores a dictionary with these group-to-row associations; its keys are
    sector names, and its values are `Index` objects storing the row index positions
    from the fortune `DataFrame`. The dictionary has 21 total key-value pairs, but
    I’ve limited the following output to the first two pairs to save space:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的`GroupBy`对象可视化为字典，将21个行业映射到每个行业所属的财富行集合。`groups`属性存储一个字典，其中包含这些组到行的关联；其键是行业名称，其值是存储来自财富`DataFrame`的行索引位置的`Index`对象。该字典共有21个键值对，但我已将以下输出限制在前两个对以节省空间：
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The output tells us that rows with index positions 26, 50, 58, 98, and so on
    have a value of `"Aerospace & Defense"` in fortune’s Sector column.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 输出告诉我们，索引位置为26、50、58、98等行的财富中的“Sector”列的值为`"Aerospace & Defense"`。
- en: 'Chapter 4 introduced the `loc` accessor for extracting `DataFrame` rows and
    columns by index label. Its first argument is the row index label, and its second
    argument is the column index label. Let’s extract a sample fortune row to confirm
    that pandas is pulling it into the correct sector group. We’ll try 26, the first
    index position listed in the `"Aerospace & Defense"` group:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第4章介绍了用于通过索引标签提取`DataFrame`行和列的`loc`访问器。其第一个参数是行索引标签，第二个参数是列索引标签。让我们提取一个样本财富行以确认pandas是否将其拉入正确的行业组。我们将尝试`26`，这是`"Aerospace
    & Defense"`组中列出的第一个索引位置：
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'What if we want to find the highest-performing company (by revenue) within
    each sector? The `GroupBy` object’s `first` method extracts the first row listed
    for each sector in fortune. Because our fortune `DataFrame` is sorted by revenue,
    the first company pulled out for each sector will be the highest-performing company
    within that sector. The return value of `first` is a 21-row `DataFrame` (one company
    per sector):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想找到每个行业中表现最好的公司（按收入计算）怎么办？`GroupBy`对象的`first`方法提取了财富中每个行业的第一个列表。因为我们的财富`DataFrame`按收入排序，所以每个行业提取出的第一家公司将是该行业表现最好的公司。`first`的返回值是一个21行的`DataFrame`（每个行业一家公司）：
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The complementary `last` method extracts the last company from fortune that
    belongs to each sector. Again, pandas pulls the rows out in the order in which
    they appear in the `DataFrame`. Because fortune sorts companies in descending
    order by revenue, the following results reveal the companies with the lowest revenue
    per sector:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 相补的`last`方法从属于每个行业的财富中提取最后一家公司。同样，pandas按照它们在`DataFrame`中出现的顺序提取行。因为财富按收入降序排列公司，所以以下结果揭示了每个行业中收入最低的公司：
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `GroupBy` object assigns index positions to the rows in each sector group.
    The first fortune row in the `"Aerospace & Defense"` sector has an index position
    of 0 within its group. Likewise, the first fortune row in the `"Apparel"` sector
    has an index position of 0 within its group. The index positions are independent
    between groups.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupBy`对象为每个行业组中的行分配索引位置。`"Aerospace & Defense"`行业的第一个财富行在其组中的索引位置为0。同样，`"Apparel"`行业的第一个财富行在其组中的索引位置为0。索引位置在组之间是独立的。'
- en: 'The `nth` method extracts the row at a given index position within its group.
    If we invoke the `nth` method with an argument of `0`, we get the first company
    within each sector. The next `DataFrame` is identical to the one returned by the
    `first` method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第`n`种方法从其组中提取给定索引位置的行。如果我们用`0`作为参数调用`nth`方法，我们将得到每个行业中的第一家公司。下一个`DataFrame`与`first`方法返回的相同：
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The next example passes an argument of `3` to the `nth` method to pull out
    the fourth row from each sector in the fortune `DataFrame`. The results include
    the 21 companies that are ranked fourth-best by revenue in their sector:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例将`3`作为参数传递给`nth`方法，以从`fortune` `DataFrame`中的每个行业提取第四行。结果包括在其行业中按收入排名第四的21家公司：
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice that the value for the `"Apparel"` sector is `"Ralph Lauren"`. We can
    confirm the output is correct by filtering for the `"Apparel"` rows in fortune.
    Notice that `"Ralph Lauren"` is fourth in line:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`"Apparel"`行业的值是`"Ralph Lauren"`。我们可以通过在财富中过滤`"Apparel"`行来确认输出是否正确。注意`"Ralph
    Lauren"`是第四行：
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `head` method extracts multiple rows from each group. In the next example,
    `head(2)` extracts the first two rows for each sector within fortune. The result
    is a `DataFrame` with 42 rows (21 unique sectors, with two rows for each sector).
    Don’t confuse this `head` method on a `GroupBy` object with the `head` method
    on a `DataFrame` object:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`head`方法从每个组中提取多行。在下一个示例中，`head(2)`提取每个部门在财富中的前两行。结果是包含42行的`DataFrame`（21个独特部门，每个部门两行）。不要将`GroupBy`对象上的此`head`方法与`DataFrame`对象上的`head`方法混淆：'
- en: '[PRE22]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The complementary `tail` method extracts the last rows from each group. `tail(3)`
    pulls the last three rows for each sector, for example. The result is a 63-row
    `DataFrame` (21 sectors x 3 rows):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 相补的`tail`方法从每个组中提取最后一行。例如，`tail(3)`提取每个部门的最后三行。结果是63行的`DataFrame`（21个部门 x 3行）：
- en: '[PRE23]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can use the `get_group` method to extract all rows in a given group. The
    method returns a `DataFrame` containing the rows. The next example shows all companies
    in the `"Energy"` sector:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`get_group`方法提取给定组中的所有行。该方法返回包含行的`DataFrame`。下一个示例显示`"Energy"`部门中的所有公司：
- en: '[PRE24]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now that we understand a `GroupBy` object’s mechanics, let’s discuss how we
    can aggregate the values in every nested group.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`GroupBy`对象的机制，让我们讨论如何对每个嵌套组中的值进行聚合。
- en: 9.4 Aggregate operations
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 聚合操作
- en: 'We can invoke methods on the `GroupBy` object to apply aggregate operations
    to every nested group. The `sum` method, for example, adds the column values in
    each group. By default, pandas targets all numeric columns in the original `DataFrame`.
    In the next example, the `sum` method calculates the sum per sector for the three
    numeric columns (Revenues, Profits, and Employees) in the fortune `DataFrame`.
    We invoke the `sum` method on the `GroupBy` object:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`GroupBy`对象上调用方法来对每个嵌套组应用聚合操作。例如，`sum`方法将每个组中的列值相加。默认情况下，pandas针对原始`DataFrame`中的所有数值列。在下一个示例中，`sum`方法计算了财富`DataFrame`中三个数值列（收入、利润和员工）的每个部门的总和。我们在`GroupBy`对象上调用`sum`方法：
- en: '[PRE25]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let’s double-check a sample calculation. Pandas lists the sum of company revenue
    in `"Aerospace & Defense"` as $383,835\. We can use the `get_group` method to
    retrieve the nested `"Aerospace & Defense"` `DataFrame`, target its Revenues column,
    and use the `sum` method to calculate its sum:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一个样本计算。Pandas将公司在`"Aerospace & Defense"`中的收入总和列示为$383,835。我们可以使用`get_group`方法检索嵌套的`"Aerospace
    & Defense"` `DataFrame`，针对其收入列，并使用`sum`方法计算其总和：
- en: '[PRE26]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The values are equal. Pandas is correct! With a single `sum` method call, the
    library applied the calculation logic to each nested `DataFrame` in the `sectors`
    `GroupBy` object. We’ve performed an aggregate analysis for all of a column’s
    groups with a minimal amount of code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 值是相等的。Pandas是正确的！通过单个`sum`方法调用，库将计算逻辑应用于`sectors` `GroupBy`对象中的每个嵌套`DataFrame`。我们用最少的代码对列的所有分组进行了聚合分析。
- en: 'The `GroupBy` object supports many other aggregation methods. The next example
    invokes the `mean` method to calculate the average of the Revenues, Profits, and
    Employees columns per sector. Again, pandas includes only numeric columns in its
    calculations:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupBy`对象支持许多其他聚合方法。下一个示例调用`mean`方法计算每个部门的收入、利润和员工列的平均值。同样，pandas只包括其计算中的数值列：'
- en: '[PRE27]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can target a single fortune column by passing its name inside square brackets
    after the `GroupBy` object. Pandas returns a new object, a `SeriesGroupBy`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`GroupBy`对象后面传递其名称并在方括号内传递来针对单个财富列。Pandas返回一个新的对象，一个`SeriesGroupBy`：
- en: '[PRE28]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Under the hood, the `DataFrameGroupBy` object stores a collection of `SeriesGroupBy`
    objects. The `SeriesGroupBy` objects can perform aggregate operations on individual
    columns from fortune. Pandas will organize the results by sector. The next example
    calculates the sum of revenue by sector:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，`DataFrameGroupBy`对象存储了一个`SeriesGroupBy`对象的集合。`SeriesGroupBy`对象可以对财富中的单个列执行聚合操作。Pandas将结果按部门组织。下一个示例按部门计算收入总和：
- en: '[PRE29]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The next example calculates the average number of employees per sector:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例计算每个部门的平均员工数量：
- en: '[PRE30]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `max` method returns the maximum value from a given column. In the next
    example, we extract the highest Profits column value for each sector. The best-performing
    company in the `"Aerospace & Defense"` sector has profits of $8,197:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`max`方法从给定列返回最大值。在下一个示例中，我们提取每个部门的最高利润列值。在`"Aerospace & Defense"`部门表现最好的公司利润为$8,197：'
- en: '[PRE31]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The complementary `min` method returns the minimum value in a given column.
    The next example displays the minimum employee count per sector. The smallest
    number of employees at a company in the `"Aerospace & Defense"` sector is 5,157:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 相补的 `min` 方法返回给定列中的最小值。下一个示例显示每个部门的最低员工人数。在 `"Aerospace & Defense"` 部门中，公司最少的员工人数是
    5,157：
- en: '[PRE32]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `agg` method applies multiple aggregate operations to different columns
    and accepts a dictionary as its argument. In each key-value pair, the key denotes
    a `DataFrame` column, and the value specifies the aggregate operation to apply
    to the column. The next example extracts the lowest revenue, highest profit, and
    average number of employees for each sector:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`agg` 方法将多个聚合操作应用于不同的列，并接受一个字典作为其参数。在每一对键值中，键表示 `DataFrame` 的列，而值指定要应用于该列的聚合操作。下一个示例提取每个部门的最低收入、最高利润和平均员工人数：'
- en: '[PRE33]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Pandas returns a `DataFrame` with the aggregation dictionary’s keys as column
    headers. The sectors remain index labels.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas 返回一个 `DataFrame`，其中聚合字典的键作为列标题。部门仍然是索引标签。
- en: 9.5 Applying a custom operation to all groups
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5 对所有组应用自定义操作
- en: Suppose that we want to apply a custom operation to each nested group in a `GroupBy`
    object. In section 9.4, we used the `GroupBy` object’s `max` method to find each
    sector’s maximum revenue. Let’s say we want to identify the company with the highest
    revenue in each sector. We solved this problem earlier, but let’s now assume that
    fortune is unordered.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要对 `GroupBy` 对象中的每个嵌套组应用一个自定义操作。在第 9.4 节中，我们使用了 `GroupBy` 对象的 `max` 方法来找到每个部门的最高收入。假设我们想要识别每个部门收入最高的公司。我们之前已经解决了这个问题，但现在假设财富是无序的。
- en: 'A `DataFrame`’s `nlargest` method extracts the rows with the greatest value
    in a given column. Here’s a quick refresher. The next example returns the five
    fortune rows with the greatest values in the Profits column:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrame` 的 `nlargest` 方法提取给定列中值最大的行。这里有一个快速回顾。下一个示例返回利润列中值最大的五个财富行：'
- en: '[PRE34]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If we could invoke the `nlargest` method on each nested `DataFrame` in `sectors`,
    we’d get the results we seek. We’d get the company with the highest revenue in
    each sector.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能在 `sectors` 中的每个嵌套 `DataFrame` 上调用 `nlargest` 方法，我们就能得到我们想要的结果。我们将在每个部门中得到收入最高的公司。
- en: We can use the `GroupBy` object’s `apply` method here. The method expects a
    function as an argument. It invokes the function once for each group in the `GroupBy`
    object. Then it collects the return values from the function invocations and returns
    them in a new `DataFrame`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `GroupBy` 对象的 `apply` 方法在这里。该方法期望一个函数作为参数。它对 `GroupBy` 对象中的每个组调用一次函数。然后它收集函数调用的返回值，并将它们以新的
    `DataFrame` 的形式返回。
- en: 'First, let’s define a `get_largest_row` function that accepts a single argument:
    a `DataFrame`. The function will return the `DataFrame` row with the greatest
    value in the Revenues column. The function is dynamic; it can perform the logic
    on any `DataFrame` as long as it has a Revenues column:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个 `get_largest_row` 函数，它接受一个参数：一个 `DataFrame`。该函数将返回 Revenues 列中值最大的
    `DataFrame` 行。该函数是动态的；只要它有一个 Revenues 列，它就可以对任何 `DataFrame` 执行逻辑：
- en: '[PRE35]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we can invoke the `apply` method and pass in the uninvoked `get_largest_row`
    function. Pandas invokes `get_largest_row` once for each sector and returns a
    `DataFrame` with the companies with the highest revenue in their sector:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以调用 `apply` 方法，并传入未调用的 `get_largest_row` 函数。Pandas 对每个部门调用一次 `get_largest_row`，并返回一个
    `DataFrame`，其中包含每个部门收入最高的公司：
- en: '[PRE36]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Use the `apply` method when pandas does not support a custom aggregation you’d
    like to apply to each nested group.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Pandas 不支持您想要应用于每个嵌套组的自定义聚合时，请使用 `apply` 方法。
- en: 9.6 Grouping by multiple columns
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6 按多个列分组
- en: 'We can create a `GroupBy` object with values from multiple `DataFrame` columns.
    This operation is optimal when a combination of column values serves as the best
    identifier for a group. The next example passes a list of two strings to the `groupby`
    method. Pandas groups the rows first by the Sector column’s values and then by
    the Industry column’s values. Remember that a company’s industry is a subcategory
    within a larger sector:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用来自多个 `DataFrame` 列的值来创建一个 `GroupBy` 对象。当列值的组合是最佳标识符时，此操作是最佳的。下一个示例将两个字符串的列表传递给
    `groupby` 方法。Pandas 首先按 Sector 列的值分组，然后按 Industry 列的值分组。请记住，公司的行业是更大部门内的一个子类别：
- en: '[PRE37]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `GroupBy` object’s `size` method now returns a `MultiIndex` `Series` with
    a count of rows for each internal group. This `GroupBy` object has a length of
    82, which means that fortune has 82 unique combinations of sector and industry:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupBy`对象的`size`方法现在返回一个包含每个内部组行数的`MultiIndex` `Series`。这个`GroupBy`对象长度为82，这意味着`fortune`有82个独特的部门与行业组合：'
- en: '[PRE38]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `get_group` method requires a tuple of values to extract a nested `DataFrame`
    from the `GroupBy` collection. The next example targets rows with a sector of
    `"Business Services"` and industry of `"Education"`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_group`方法需要一个值元组来从`GroupBy`集合中提取嵌套`DataFrame`。下一个示例针对部门为`"Business Services"`和行业为`"Education"`的行：'
- en: '[PRE39]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For all aggregations, pandas returns a `MultiIndex DataFrame` with the calculations.
    The next example calculates the sum of the three numeric columns in `fortune`
    (Revenues, Profits, and Employees), grouped first by sector and then by the industries
    within each sector:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有聚合操作，pandas返回一个包含计算的`MultiIndex DataFrame`。下一个示例计算了`fortune`中三个数值列（收入、利润和员工人数）的总和，首先按部门分组，然后按每个部门内的行业分组：
- en: '[PRE40]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can target individual fortune columns for aggregation by using the same
    syntax as in section 9.5\. Enter the column in square brackets after the `GroupBy`
    object; then invoke the aggregation method. The next example calculates the average
    revenue for companies within each sector/industry combo:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与第9.5节相同的语法来针对单个`fortune`列进行聚合。在`GroupBy`对象后输入列名，然后调用聚合方法。下一个示例计算了每个部门/行业组合中公司的平均收入：
- en: '[PRE41]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In summary, a `GroupBy` object is an optimal data structure for splitting, organizing,
    and aggregating a `DataFrame`’s values. If you need to use multiple columns to
    identify buckets, pass the `groupby` method a list of columns.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`GroupBy`对象是一个用于分割、组织和聚合`DataFrame`值的最佳数据结构。如果你需要使用多个列来识别分组，可以将列的列表传递给`groupby`方法。
- en: 9.7 Coding challenge
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7 编码挑战
- en: 'This coding challenge’s data set, cereals.csv, is a listing of 80 popular breakfast
    cereals. Each row includes a cereal’s name, manufacturer, type, calories, grams
    of fiber, and grams of sugar. Let’s take a look:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个编码挑战的数据集，cereals.csv，是80种流行早餐谷物的列表。每一行包括谷物的名称、制造商、类型、卡路里、纤维克数和糖克数。让我们看一下：
- en: '[PRE42]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Good luck!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你好运！
- en: 9.7.1 Problems
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.1 问题
- en: 'Here are the challenges:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是挑战：
- en: Group the cereals, using the Manufacturer column’s values.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用制造商列的值对谷物进行分组。
- en: Determine the total number of groups, and the number of cereals per group.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定总组数和每组中的谷物数量。
- en: Extract the cereals that belong to the manufacturer/group `"Nabisco"`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取属于制造商/组`"Nabisco"`的谷物。
- en: Calculate the average of values in the Calories, Fiber, and Sugars columns for
    each manufacturer.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每个制造商卡路里、纤维和糖列值的平均值。
- en: Find the maximum value in the Sugars column for each manufacturer.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到每个制造商糖列中的最大值。
- en: Find the minimum value in the Fiber column for each manufacturer.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到每个制造商在纤维列中的最小值。
- en: Extract the cereal with the lowest amount of grams of sugar per manufacturer
    in a new `DataFrame`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从每个制造商中提取糖含量最低的谷物到一个新的`DataFrame`中。
- en: 9.7.2 Solutions
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7.2 解决方案
- en: 'Let’s dive into the solutions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入解决方案：
- en: 'To group the cereals by manufacturer, we can invoke the `groupby` method on
    the cereals `DataFrame` and pass in the Manufacturer column. Pandas will use the
    column’s unique values to organize the groups:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要按制造商对谷物进行分组，我们可以在谷物的`DataFrame`上调用`groupby`方法，并传入制造商列。Pandas将使用列的唯一值来组织分组：
- en: '[PRE43]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To find the total number of groups/manufacturers, we can pass the `GroupBy`
    object into Python’s built-in `len` function:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找到组/制造商的总数，我们可以将`GroupBy`对象传递给Python的内置`len`函数：
- en: '[PRE44]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you’re curious, the `GroupBy` object’s `size` method returns a `Series`
    with a count of cereals per group:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你好奇，`GroupBy`对象的`size`方法返回一个包含每组分谷物数量的`Series`：
- en: '[PRE45]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To identify cereals belonging to the `"Nabisco"` group, we can invoke the `get_group`
    method on our `GroupBy` object. Pandas will return the nested `DataFrame` with
    `"Nabisco"` rows:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要识别属于`"Nabisco"`组的谷物，我们可以在我们的`GroupBy`对象上调用`get_group`方法。Pandas将返回包含`"Nabisco"`行的嵌套`DataFrame`：
- en: '[PRE46]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To calculate the averages of the numeric columns in `cereals`, we can invoke
    the `mean` method on the `manufacturers` `GroupBy` object. Pandas will aggregate
    all numeric columns in cereals by default:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要计算`cereals`中数值列的平均值，我们可以在`manufacturers`的`GroupBy`对象上调用`mean`方法。Pandas默认会聚合`cereals`中的所有数值列：
- en: '[PRE47]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we are tasked with finding the maximum Sugars value per manufacturer.
    We can use square brackets after a `GroupBy` object to identify which column’s
    values to aggregate. Then we provide the correct aggregate method, which is `max`
    in this case:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们的任务是找到每个制造商的最大糖分值。我们可以在`GroupBy`对象后面使用方括号来标识要聚合的列的值。然后我们提供正确的聚合方法，在这种情况下是`max`：
- en: '[PRE48]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To find the smallest fiber value per manufacturer, we can swap the column to
    Fiber and invoke the `min` method:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找到每个制造商的最小纤维值，我们可以将列交换为纤维并调用`min`方法：
- en: '[PRE49]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we need to identify the cereal row for each manufacturer with the
    lowest value in the Sugars column. We can solve this problem by using the `apply`
    method and a custom function. The `smallest_sugar_row` function uses the `nsmallest`
    method to pull the `DataFrame` row with the smallest value in the Sugars column.
    Then we use `apply` to invoke the custom function on each `GroupBy` group:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要为每个制造商识别出糖分列中值最低的谷物行。我们可以通过使用`apply`方法和自定义函数来解决这个问题。`smallest_sugar_row`函数使用`nsmallest`方法来提取糖分列中值最小的`DataFrame`行。然后我们使用`apply`在每一个`GroupBy`组上调用自定义函数：
- en: '[PRE50]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Congratulations on completing the coding challenge!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成了编码挑战！
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A `GroupBy` object is a container of `DataFrame`s.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GroupBy`对象是一个`DataFrame`的容器。'
- en: Pandas buckets rows into `GroupBy` `DataFrame`s by using values across one or
    more columns.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas通过使用一个或多个列的值将行划分到`GroupBy` `DataFrame`中。
- en: The `first` and `last` methods return the first and last rows from each `GroupBy`
    group. The row order in the original `DataFrame` determines the row order in each
    group.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first`和`last`方法从每个`GroupBy`组中返回第一行和最后一行。原始`DataFrame`中的行顺序决定了每个组中的行顺序。'
- en: The `head` and `tail` methods extract multiple rows from each group in the `GroupBy`
    object based on the row’s positions in the original `DataFrame`.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`head`和`tail`方法根据行在原始`DataFrame`中的位置从`GroupBy`对象中的每个组中提取多行。'
- en: The `nth` method extracts a row from each `GroupBy` group by its index position.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nth`方法通过索引位置从每个`GroupBy`组中提取一行。'
- en: Pandas can perform aggregate calculations such as sum, average, max, and min
    for each group in a `GroupBy` object.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pandas可以通过`GroupBy`对象对每个组执行聚合计算，如求和、平均值、最大值和最小值。
- en: The `agg` method applies different aggregate operations to different columns.
    We pass it a dictionary with columns as keys and aggregation as values.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`agg`方法将不同的聚合操作应用于不同的列。我们传递一个字典，其中列作为键，聚合作为值。'
- en: The `apply` method invokes a function on each `DataFrame` in a `GroupBy` object.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply`方法在`GroupBy`对象中的每个`DataFrame`上调用一个函数。'
