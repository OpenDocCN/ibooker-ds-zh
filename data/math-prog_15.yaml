- en: 13 Analyzing sound waves with a Fourier series
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 使用傅里叶级数分析声波
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Defining and playing sound waves with Python and PyGame
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python和PyGame定义和播放声波
- en: Turning sinusoidal functions into playable musical notes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将正弦函数转换为可演奏的音乐音符
- en: Combining two sounds by adding their sound waves as functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将声波作为函数相加来组合两个声音
- en: Decomposing a sound wave function into its Fourier series to see its musical
    notes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将声波函数分解为其傅里叶级数以查看其音乐音符
- en: 'For a lot of part 2, we’ve focused on using calculus to simulate moving objects.
    In this chapter, I’ll show you a completely different application: working with
    audio data. Digital audio data is a computer representation of *sound waves*,
    which are repeating changes of pressure in the air that our ears perceive as sound.
    We’ll think of sound waves as functions that we can add and scale as vectors,
    and then we can use integrals to understand what kinds of sounds they represent.
    As a result, our exploration of sound waves combines a lot of what you’ve learned
    about both linear algebra and calculus in earlier chapters.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分的很多内容中，我们专注于使用微积分来模拟运动物体。在本章中，我将向你展示一个完全不同的应用：处理音频数据。数字音频数据是计算机对声波的表示，声波是我们耳朵感知为声音的空气压力的重复变化。我们将声波视为可以像向量一样相加和缩放的函数，然后我们可以使用积分来理解它们代表的声音类型。因此，我们对声波的研究结合了你在前几章中学到的关于线性代数和微积分的很多内容。
- en: I won’t go too deep into the physics of sound waves, but it’s useful to understand
    how they work at a basic level. What we perceive as sound isn’t air pressure itself,
    but rather rapid changes in air pressure that cause our eardrums to vibrate. For
    instance, if you play a violin, you drag the bow across one of the strings and
    cause the string to vibrate. The vibrating string causes the air around it to
    rapidly change pressure, and the changes in pressure propagate through the air
    as sound waves until they reach your ear. At that point, your eardrum vibrates
    at the same rate, and you perceive a sound (figure 13.1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入探讨声波的物理原理，但了解它们在基本层面的工作方式是有用的。我们感知到的声音并不是空气压力本身，而是空气压力的快速变化，这些变化导致我们的耳膜振动。例如，如果你拉小提琴，你会将弓拉过一根弦，使弦振动。振动的弦使其周围的空气快速改变压力，压力的变化以声波的形式传播，直到到达你的耳朵。在那个时刻，你的耳膜以相同的速率振动，你感知到声音（图13.1）。
- en: '![](../Images/CH13_F01_Orland.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH13_F01_Orland.png)'
- en: Figure 13.1 Schematic diagram of the sound of a violin reaching an eardrum
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 小提琴声到达耳膜示意图
- en: You can think of a digital audio file as a function describing a vibration over
    time. Audio software interprets the function and instructs your speakers to vibrate
    accordingly, producing sound waves of a similar shape in the air around the speakers.
    For our purposes, it doesn’t matter exactly what the function represents, but
    you can interpret it loosely as describing air pressure over time (figure 13.2).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将数字音频文件视为描述随时间变化的振动的函数。音频软件解释该函数并指示你的扬声器相应地振动，在扬声器周围的空气中产生形状相似的声波。就我们的目的而言，函数的确切表示并不重要，但你可以将其松散地解释为描述随时间变化的空气压力（图13.2）。
- en: '![](../Images/CH13_F02_Orland.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH13_F02_Orland.png)'
- en: Figure 13.2 Thinking of sound waves as functions, loosely interpreted as representing
    pressure over time
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 将声波视为函数，松散地解释为表示随时间变化的压力
- en: Interesting sounds like musical notes have sound waves with repeating patterns,
    like the one shown in figure 13.2\. The rate at which the function repeats itself
    is called the *frequency* and tells how high or low the musical note sounds. The
    quality, or *timbre*, of the sound is controlled by the shape of the repeating
    pattern, for instance, whether it sounds more like a violin, a trumpet, or a human
    voice.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 像音乐音符这样的有趣声音具有重复模式的声波，如图13.2所示。函数重复自身的速率称为*频率*，它告诉我们音乐音符的高低。声音的*音色*由重复模式的形状控制，例如，它听起来更像是小提琴、喇叭还是人声。
- en: 13.1 Combining sound waves and decomposing them
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 结合声波并分解它们
- en: Throughout this chapter, we do mathematical operations on functions and use
    Python to play them as actual sounds. The two main things we’ll do are combining
    existing sound waves to make new ones and then decomposing complex sound waves
    into simpler ones. For instance, we can combine several musical notes into a chord
    and then we can decompose a chord to see its musical notes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对函数进行数学运算，并使用Python将它们作为实际声音播放。我们将做的主要两件事是将现有的声波组合成新的声波，然后将复杂的声波分解成更简单的声波。例如，我们可以将几个音符组合成一个和弦，然后我们可以将和弦分解以查看其音符。
- en: 'Before we do that, however, we need to cover the basic building blocks: sound
    waves and musical notes. I start by showing you how to use Python to turn a sequence
    of numbers, representing a sound wave, into a real sound coming out of your speakers.
    To make a sound corresponding to a function, we extract some *y* values from the
    graph of the function and pass these to the audio library as an array. This is
    a process called *sampling*(figure 13.3).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们这样做之前，我们需要了解基本构建块：声波和音符。我先向您展示如何使用Python将代表声波的一系列数字转换为从您的扬声器中发出的真实声音。为了制作与函数相对应的声音，我们从函数的图形中提取一些*y*值，并将这些值作为数组传递给音频库。这个过程被称为*采样*(图13.3)。
- en: The main sound wave functions we’ll use are *periodic* *functions*, whose graphs
    are built from the same repeating shape. Specifically, we’ll use *sinusoidal*
    *functions*, a family of periodic functions including sine and cosine that produce
    natural-sounding musical notes. After sampling them to turn them into sequences
    of numbers, we’ll build Python functions to play musical notes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的主要声波函数是*周期性*函数，其图形由相同的重复形状构成。具体来说，我们将使用*正弦波*函数，这是一个包括正弦和余弦在内的周期函数族，可以产生自然音调的音符。在将它们采样转换为数字序列后，我们将构建Python函数来播放音符。
- en: Once we can produce individual notes, we’ll write Python code to help us combine
    different notes to create chords and other complex sounds. We’ll do this by adding
    the functions defining each of the sound waves together. We’ll see that combining
    a few musical notes can make a chord, and combining dozens of musical notes together
    can produce some quite interesting and qualitatively dissimilar sounds.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们能够产生单个音符，我们将编写Python代码来帮助我们组合不同的音符以创建和弦和其他复杂的声音。我们将通过将定义每个声波的函数相加来实现这一点。我们将看到，组合几个音符可以形成一个和弦，而组合几十个音符可以产生一些相当有趣且在性质上不同的声音。
- en: '![](../Images/CH13_F03_Orland.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH13_F03_Orland.png)'
- en: Figure 13.3 Starting with the graph of a function *f*(*t*) (top) and sampling
    some of the y values (bottom) to send to an audio library
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 从函数*f(t)*的图形（顶部）开始，采样一些*y*值（底部）以发送到音频库
- en: Our last goal will be to decompose a function representing any sound wave into
    a sum of (pure) musical notes and their corresponding volumes, which make up the
    sound wave (figure 13.4). Such a decomposition into a sum is called a *Fourier
    series*(pronounced *FOR-ee-yay)*. Once we’ve found the sound waves making up a
    Fourier series, we can play them together and get the original sound.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一个目标是将表示任何声波的函数分解为（纯）音符及其对应音量的和，这些音符构成了声波（图13.4）。这种分解成和的过程称为*傅里叶级数*(发音为*FOR-ee-yay*)。一旦我们找到了构成傅里叶级数的声波，我们就可以一起播放它们，得到原始声音。
- en: '![](../Images/CH13_F04_Orland.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH13_F04_Orland.png)'
- en: Figure 13.4 Decomposing a sound wave function into a combination of simpler
    ones using a Fourier series
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 使用傅里叶级数将声波函数分解为更简单的组合
- en: Mathematically, finding a Fourier series means writing a function as a sum or,
    more specifically, a linear combination of sine and cosine functions. This procedure
    and its variants are among the most important algorithms of all time. Methods
    similar to the ones we’ll cover are used in common applications like MP3 compression,
    as well as in more grandiose ones like the recent Nobel prize-winning detection
    of gravitational waves.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，找到傅里叶级数意味着将一个函数写成和的形式，或者更具体地说，是正弦和余弦函数的线性组合。这个程序及其变体是所有时间中最重要的算法之一。与我们将要介绍的方法类似的方法被用于常见的应用，如MP3压缩，以及更宏伟的应用，如最近获得诺贝尔奖的引力波探测。
- en: It’s one thing to look at these sound waves as graphs, but it’s another to actually
    hear them coming out of your speakers. Let’s make some noise!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 看这些声波作为图形是一回事，但真正听到它们从您的扬声器中发出是另一回事。让我们制造一些噪音！
- en: 13.2 Playing sound waves in Python
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 在Python中播放声波
- en: To play sounds in Python, we turn to the PyGame library that we used in a few
    of the preceding chapters. A particular function in this library takes an array
    of numbers as input and plays a sound as a result. As a first step, we use a random
    sequence of numbers in Python and write code to interpret and play these sounds
    with PyGame. This will just be *noise*(yes, that’s a technical term!) rather than
    beautiful music at this point, but we need to start somewhere.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python中播放声音，我们转向在前面几个章节中使用过的PyGame库。这个库中的一个特定函数接受一个数字数组作为输入，并播放声音作为结果。作为第一步，我们使用Python中的随机数字序列，并编写代码来使用PyGame解释和播放这些声音。目前这将是*噪音*（是的，这是一个技术术语！）而不是美丽的音乐，但我们需要从某个地方开始。
- en: After producing some noise, we’ll make a slightly more appealing sound by running
    the same process on a sequence of numbers that have repeating patterns, rather
    than just being completely random. This sets us up for the next section, where
    we’ll get a sequence of repeating numbers by sampling a periodic function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在产生一些噪音之后，我们将通过在具有重复模式的数字序列上运行相同的过程，而不是完全随机的数字序列，来制作一个稍微更有吸引力的声音。这为我们设置了下一节的内容，我们将通过采样周期函数来获取重复数字的序列。
- en: 13.2.1 Producing our first sound
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.1 生成我们的第一个声音
- en: Before we pass PyGame an array of numbers representing a sound, we need to tell
    it how the numbers should be interpreted. There are several technical details
    about audio data here, and I’ll explain them so you know how PyGame thinks about
    that, but these details won’t be critical to the rest of the chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将表示声音的数字数组传递给PyGame之前，我们需要告诉它如何解释这些数字。这里有一些关于音频数据的详细技术信息，我会解释它们，这样你就知道PyGame是如何考虑这些的，但这些细节对于本章的其余部分不是关键的。
- en: In this application, we use conventions typically used in CD audio. Specifically,
    we’ll represent one second of audio with an array of 44,100 values, each of which
    is a 16-bit integer (between −32,768 and 32,767). These numbers roughly represent
    the intensity of the sound at every step of time, with 44,100 steps in a second.
    This is not unlike how we represented an image in chapter 6\. Instead of an array
    of values giving the brightness of pixels, we have an array of values giving the
    intensity of a sound wave at different moments in time. Eventually, we’ll get
    these numbers as the *y*-coordinates of points on a sound wave graph, but for
    now, we’re going to pick them randomly to make *some* noise.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用中，我们使用CD音频中常用的约定。具体来说，我们将用包含44,100个值的数组来表示一秒钟的音频，每个值都是一个16位整数（介于-32,768和32,767之间）。这些数字大致代表了每个时间步骤的声音强度，每秒钟有44,100个步骤。这与我们在第6章中表示图像的方式类似。而不是一个表示像素亮度的值数组，我们有一个表示不同时间点的声音波强度的值数组。最终，我们将这些数字作为声音波图上点的*y*坐标，但就目前而言，我们将随机选择它们来制造*一些*噪音。
- en: 'We also use a single *channel*, meaning we only play one sound wave as opposed
    to *stereo* audio, which produces two sound waves simultaneously, one in the left
    speaker and one in the right. The other thing we configure is the bit depth of
    the sound. While frequency is analogous to the resolution of an image, *bit depth*
    is like the number of allowable pixel colors, more bit depth means a more refined
    range of sound intensities. We used three numbers between 0 and 256 for the color
    of a pixel, but here, we use a single 16-bit number to represent the sound intensity
    at a moment in time. With these parameters selected, the first step in our code
    is to import PyGame and initialize the sound library:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用单个*通道*，这意味着我们只播放一个声音波，而不是*立体声*音频，后者同时产生两个声音波，一个在左扬声器，一个在右扬声器。我们配置的另一件事是声音的比特深度。虽然频率类似于图像的分辨率，但*比特深度*就像允许的像素颜色数量，比特深度越高，意味着声音强度范围越精细。我们使用介于0到256之间的三个数字来表示像素的颜色，但在这里，我们使用一个16位数字来表示某一时刻的声音强度。选择这些参数后，我们代码中的第一步是导入PyGame并初始化声音库：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ −16 indicates a bit depth of 16 and an input of 16-bit signed integers ranging
    from −32,768 to 32,767
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ -16表示16位比特深度，输入为16位有符号整数，范围从-32,768到32,767
- en: 'To start with the simplest possible example, we can generate one second of
    audio by creating a NumPy array of 44,100 random integers between −32,768 and
    32,767\. We can do this in one line with NumPy’s `randint` function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以通过创建一个包含44,100个介于-32,768和32,767之间的随机整数的NumPy数组来生成一秒钟的音频。我们可以使用NumPy的`randint`函数在一行内完成此操作：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To interpret this array as a sound wave, we can plot its first few values on
    a scatter graph. I’ve included a `plot_sequence` function in the source code for
    this book to help you quickly plot an array of integer values like this. If you
    run `plot_sequence (arr,max=100)`, you get a picture of the first 100 values of
    this array. As compared to numbers sampled from a smooth function, these numbers
    are all over the place (figure 13.5).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这个数组解释为声波，我们可以在散点图上绘制它的前几个值。我在这本书的源代码中包含了一个`plot_sequence`函数，以帮助您快速绘制这样的整数数组。如果你运行`plot_sequence
    (arr, max=100)`，你会得到这个数组前100个值的图像。与从平滑函数中采样的数字相比，这些数字分布得非常广泛（图13.5）。
- en: '![](../Images/CH13_F05_Orland.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH13_F05_Orland.png)'
- en: Figure 13.5 Sampled values from a sound wave (left) vs. our random values (right)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 声波采样值（左）与我们的随机值（右）的比较
- en: If you connect the dots, you can picture them as defining a function over this
    time period. Figure 13.6 shows two graphs of the array of numbers with the dots
    connected, showing the first 100 and 441 numbers, respectively. This data is completely
    random, so there’s nothing particularly interesting to see, but this will be the
    first sound wave we play.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你连接这些点，你可以想象它们定义了这个时间段内的一个函数。图13.6显示了连接点的数字数组的两张图，分别显示了前100个和441个数字。这些数据是完全随机的，所以没有什么特别有趣的东西可以看，但这将是我们将要播放的第一个声波。
- en: Because 44,100 values define the whole second of sound, the 441 values on the
    bottom define the sound during the first one-hundredth of a second. Next, we can
    play the sound using a library call.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因为44,100个值定义了一秒钟的声音，所以底部的441个值定义了第一个百分之一秒内的声音。接下来，我们可以使用一个库调用来播放声音。
- en: '![](../Images/CH13_F06_Orland.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH13_F06_Orland.png)'
- en: Figure 13.6 The first 100 values (top) and the first 441 values (bottom) connected
    to define a function
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 连接到定义函数的前100个值（顶部）和前441个值（底部）
- en: CAUTION Before you run the next few lines of Python code, make sure your speaker
    volume isn’t too high. The first sound we’ve made won’t be that pleasant, not
    to mention, you don’t want to hurt your ears!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在运行下面的几行Python代码之前，请确保你的扬声器音量不要太大。我们制作的第一个声音不会那么愉快，更不用说，你也不想伤害你的耳朵！
- en: 'To play the sound, you can run:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放声音，你可以运行：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The result should sound like one second of static, as if you turned on the radio
    without tuning it to a station. A sound wave like this, consisting of random values
    over time, is called *white noise*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该听起来像一秒钟的静电，就像你打开了收音机但没有调到任何频道一样。这种随时间变化随机值的声波被称为*白噪音*。
- en: 'About the only thing you can adjust about white noise is the volume. The human
    ear responds to changes in pressure, and the bigger the sound wave, the bigger
    the changes in pressure, and the louder the perceived sound. If this white noise
    was unpleasantly loud for you, you can create a quieter version by generating
    sound data consisting of smaller numbers. For instance, this white noise is generated
    by numbers ranging from −10,000 to 10,000:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 关于白噪音，你唯一能调整的可能是音量。人耳对压力的变化有反应，声音波越大，压力变化越大，听到的声音就越响。如果你觉得这个白噪音对你来说声音太大，你可以通过生成由较小数字组成的声数据来创建一个更安静版本。例如，这个白噪音是由从-10,000到10,000的数字生成的：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This sound should be nearly identical to the first white noise you played, except
    that it is quieter. The loudness of a sound wave depends on how big the function
    values are, and the measure of this is called the *amplitude* of the wave. In
    this case, because the values vary 10,000 units from the average value of 0, the
    amplitude is said to be 10,000.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声音应该几乎与你播放的第一个白噪音相同，只是它更安静。声波的响度取决于函数值的大小，这种测量的结果被称为波的*振幅*。在这种情况下，因为值从平均值的0变化了10,000个单位，所以振幅被认为是10,000。
- en: Although some people find white noise soothing, it’s not very interesting. Let’s
    produce a more interesting sound, namely a musical note.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有些人觉得白噪音很舒缓，但它并不很有趣。让我们产生一个更有趣的声音，即一个音符。
- en: 13.2.2 Playing a musical note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.2 演奏一个音符
- en: 'When we hear a musical note, our ears are detecting a pattern in the vibrations
    in contrast to the randomness of white noise. We can put together a series of
    44,100 numbers with an obvious pattern, and you’ll hear them produce a musical
    note. Specifically, let’s start by repeating the number 10,000 fifty times and
    then repeating the number −10,000 fifty times. I picked 10,000 because we just
    saw it’s a big enough amplitude to make the sound wave audible. Figure 13.7 shows
    the plot for the first 100 numbers returned from the following code snippet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们听到一个音符时，我们的耳朵正在检测振动中的模式，与白噪声的随机性形成对比。我们可以组合一系列具有明显模式的44,100个数字，你会听到它们产生一个音符。具体来说，让我们先重复数字10,000五十次，然后重复数字-10,000五十次。我选择10,000是因为我们刚刚看到它有足够大的振幅，可以使声音波可听。图13.7显示了以下代码片段返回的前100个数字的图表：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Repeats each value in the list the specified number of times
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 列表中每个值重复指定的次数
- en: 'If we repeat this sequence of 100 numbers 441 times, we have 44,100 total values
    that define one second of audio. To achieve this, we can use another handy NumPy
    function, called `tile`, which repeats a given array a specified number of times:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重复这个100个数字的序列441次，我们就有44,100个总值来定义一秒的音频。为了实现这一点，我们可以使用另一个方便的NumPy函数，称为`tile`，它将给定的数组重复指定的次数：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](../Images/CH13_F07_Orland.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH13_F07_Orland.png)'
- en: Figure 13.7 A plot of the sequence, consisting of the number 10,000 repeated
    50 times followed by the number −10,000 repeated 50 times.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 由数字10,000重复50次，然后是数字-10,000重复50次组成的序列的图表。
- en: Figure 13.8 shows the plot of the first 1,000 values of the array with the “dots”
    connected. You can see that it jumps back and forth between 10,000 and −10,000
    every 50 numbers. That means the pattern repeats every 100 numbers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8显示了数组前1,000个值的图表，其中“点”是连接的。你可以看到它每隔50个数字在10,000和-10,000之间跳来跳去。这意味着模式每100个数字重复一次。
- en: '![](../Images/CH13_F08_Orland.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH13_F08_Orland.png)'
- en: Figure 13.8 A plot of the first 1,000 of 44,100 numbers shows the repeating
    pattern.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8展示了44,100个数字中的前1,000个的图表，显示了重复的模式。
- en: This waveform is called a *square wave* because its graph has sharp, 90° corners.
    (Note that the vertical lines are only there because MatPlotLib connects all of
    the dots; there are no values of the sequence between 10,000 and −10,000, just
    a dot at 10,000 connected to a dot at −10,000.)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个波形被称为**方波**，因为它的图形有尖锐的90°角。（注意，垂直线只是为了说明MatPlotLib连接了所有的点；在10,000和-10,000之间没有序列的值，只是在10,000处有一个点连接到-10,000处的点。）
- en: 'The 44,100 numbers represent one second, so the 1,000 numbers graphed in figure
    13.8 represent 1/44.1 seconds (or 0.023 seconds) of audio. Playing this sound
    data using the following lines produces a clear musical note. This is approximately
    the note A (or A[4] in scientific pitch notation). You can listen to it with the
    same `play()` method as used in section 13.2.1:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 44,100个数字代表一秒，所以图13.8中绘制的1,000个数字代表1/44.1秒（或0.023秒）的音频。使用以下行播放这些声音数据会产生一个清晰的音符。这大约是音符A（或科学音高记号中的A[4]）。你可以使用与第13.2.1节中相同的`play()`方法来听它。
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The rate of repetition (in this case, 441 repetitions per second) is called
    the *frequency* of the sound wave, and it determines the *pitch* of the note,
    or how high or low the note sounds. Frequencies of repetition are measured in
    units of *hertz*, abbreviated Hz, where 441 Hz means the same thing as 441 per
    second. The most common definition for the pitch A is 440 Hz, but 441 is close
    enough, and it conveniently divides the CD sampling rate of 44,100 values per
    second.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重复的速率（在这种情况下，每秒441次重复）称为声音波的**频率**，它决定了音符的**音调**，即音符听起来有多高或多低。重复频率的单位是*赫兹*，缩写为Hz，其中441
    Hz意味着每秒441次。音调A最常见的规定是440 Hz，但441足够接近，并且它方便地除以每秒44,100个值的CD采样率。
- en: Interesting sound waves come from *periodic* functions, which repeat themselves
    on fixed intervals like the square wave in figure 13.8\. The repeated sequence
    for the square wave consists of 100 numbers, and we repeat it 441 times to get
    44,100 numbers giving one second of audio. That’s a repetition rate of 441 Hz
    or once every 0.0023 seconds. What our ear detects as a musical note is this rate
    of repetition. In the next section, we’ll play sounds corresponding to the most
    important periodic functions, sine and cosine, at different frequencies.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的声波来自**周期性**的函数，它们在固定的区间内重复，就像图13.8中的方波。方波的重复序列由100个数字组成，我们重复它441次来得到44,100个数字，从而得到一秒钟的音频。这是441
    Hz的重复率，或者每0.0023秒一次。我们耳朵检测到的音乐音符就是这个重复率。在下一节中，我们将播放与最重要的周期性函数正弦和余弦在不同频率下相对应的声音。
- en: 13.2.3 Exercises
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.3 练习
- en: '| **Exercise 13.1**: Our musical note A was a pattern that repeated 441 times
    in one second. Create a similar pattern that repeats 350 times in one second,
    which produces the musical note F.**Solution**: Fortunately, the frequency of
    44,100 Hz is divisible by 350: 44,100 / 350 = 126\. With 63 values of 10,000 and
    63 values of −10,000, we can repeat that sequence 350 times to create one second
    of audio. The resulting note sounds lower than the A and is indeed an F:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习13.1**：我们的音符A在一秒钟内重复了441次。创建一个在一秒钟内重复350次的类似模式，这将产生音符F。**解答**：幸运的是，44,100
    Hz的频率可以被350整除：44,100 / 350 = 126。我们有63个10,000和63个-10,000的值，我们可以重复这个序列350次来创建一秒钟的音频。这个音符听起来比A低，确实是一个F：'
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 13.3 Turning a sinusoidal wave into a sound
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 将正弦波转换为声音
- en: The sound we played with the square wave was a recognizable musical note, but
    it wasn’t very natural sounding. That’s because in nature, things don’t usually
    vibrate in square waves. More often, vibrations are *sinusoidal*, meaning if we
    measure and graph these, we get results that look like the graphs of the sine
    or cosine functions. These functions turn out to be mathematically natural as
    well, so we can use them as the building blocks for the music we’re going to make.
    After sampling the notes and passing them to PyGame, you’ll be able to hear the
    difference between a square wave and a sinusoidal wave.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用方波播放的声音是一个可识别的音符，但听起来并不很自然。这是因为在大自然中，事物通常不会以方波形式振动。更常见的是振动是**正弦波形的**，这意味着如果我们测量并绘制这些波形，我们会得到类似于正弦或余弦函数的图形。这些函数在数学上也是自然的，因此我们可以将它们作为我们即将制作的音乐的构建块。在采样音符并将它们传递给PyGame之后，你将能够听到方波和正弦波之间的区别。
- en: 13.3.1 Making audio from sinusoidal functions
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.1 从正弦函数制作音频
- en: The sinusoidal functions sine and cosine, which we’ve used several times already
    in this book, are intrinsically periodic functions. That’s because their inputs
    are interpreted as angles; if you rotate 360° or 2*π* radians, you’re back where
    you started, and the sine and cosine functions return the same values. Therefore,
    sin(*t*) and cos(*t*) repeat themselves every 2*π* units as shown in figure 13.9.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中已经多次使用过的正弦和余弦函数，本质上是有周期性的函数。这是因为它们的输入被解释为角度；如果你旋转360°或2*π*弧度，你将回到起点，正弦和余弦函数将返回相同的值。因此，sin(*t*)和cos(*t*)每隔2*π*单位重复一次，如图13.9所示。
- en: '![](../Images/CH13_F09_Orland.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图13.12](../Images/CH13_F09_Orland.png)'
- en: Figure 13.9 Every 2*π* units, the function sin(*t*) repeats the same value.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 每隔2*π*单位，函数sin(*t*)重复相同的值。
- en: This interval of repetition is called the *period* of the periodic function,
    so for both sine and cosine, the period is 2*π*. When you graph them (figure 13.10),
    you can see that they look the same between 0 and 2*π* as they do between 2*π*
    and 4*π*, or between 4*π* and 6*π*, and so on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重复的区间被称为周期函数的**周期**，所以对于正弦和余弦，周期是2*π*。当你绘制它们时（图13.10），你可以看到它们在0到2*π*之间看起来和2*π*到4*π*之间，或者4*π*到6*π*之间，以及如此等等，看起来是一样的。
- en: '![](../Images/CH13_F10_Orland.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图13.11](../Images/CH13_F10_Orland.png)'
- en: Figure 13.10 Because the sine function is periodic with period 2*π*, its graph
    has the same shape over every 2*π* interval.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10 因为正弦函数的周期是2*π*，所以它的图形在每个2*π*区间内都有相同的形状。
- en: The only difference for the cosine function is that the graph is shifted by
    *π*/2 units to the left, but it still repeats itself every 2*π* units (figure
    13.11).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于余弦函数，唯一的区别是图形向左移动了*π*/2个单位，但它仍然每隔2*π*单位重复一次（图13.11）。
- en: '![](../Images/CH13_F11_Orland.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图13.10](../Images/CH13_F11_Orland.png)'
- en: Figure 13.11 The graph of the cosine function has the same shape as the graph
    of the sine function, but it is shifted to the left. It also repeats itself every
    2*π* units.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11 余弦函数的图形与正弦函数的图形形状相同，但它向左移动。它也每2*π*个单位重复一次。
- en: For the purposes of audio, one repetition every 2*π* seconds is a frequency
    of 1/2*π* or about 0.159 Hz, which turns out to be too small to be audible by
    the human ear. The amplitude of 1.0 also turns out to be too small to hear in
    16-bit audio. To solve this, let’s write a Python function, `make_sinusoid(frequency,amplitude)`,
    which produces a sine function that is stretched or compressed vertically and
    horizontally to have a more desirable frequency and amplitude. A frequency of
    441 Hz and an amplitude of 10,000 should represent an audible sound wave.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于音频来说，每2*π*秒重复一次的频率是1/2*π*或大约0.159 Hz，这对人类耳朵来说太小，无法听到。1.0的振幅也太小，在16位音频中无法听到。为了解决这个问题，让我们编写一个Python函数`make_sinusoid(frequency,amplitude)`，该函数产生一个正弦函数，垂直和水平拉伸或压缩以具有更理想的频率和振幅。441
    Hz的频率和10,000的振幅应该代表一个可听到的声波。
- en: Once we’ve produced that function, we want to extract 44,100 evenly spaced values
    of the function to pass to PyGame. The process of extracting function values like
    this is called *sampling*, so we can write a function called `sample(f,start,end,count)`
    that gets the specified count number of values of *f*(*t*) in the range of *t*
    values between `start` and `end`. Once we have our desired sinusoid function,
    we can run `sample (sinusoid,0,1,44100)` to get an array of 44,100 samples to
    pass to PyGame, and we’ll hear what a sinusoidal wave sounds like.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们生成了那个函数，我们希望提取44,100个均匀分布的函数值传递给PyGame。提取这种函数值的过程称为*采样*，因此我们可以编写一个名为`sample(f,start,end,count)`的函数，该函数在`t`值在`start`和`end`之间的范围内获取*f*(*t*)的指定计数值。一旦我们得到了所需的正弦函数，我们可以运行`sample
    (sinusoid,0,1,44100)`来获取一个包含44,100个样本的数组，传递给PyGame，我们就能听到正弦波的声音。
- en: 13.3.2 Changing the frequency of a sinusoid
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.2 改变正弦波的频率
- en: As a first example, let’s create a sinusoid with a frequency of 2, meaning a
    function shaped like a sine graph but repeating itself twice between zero and
    one. The period of the sine function is 2*π*, so by default, it takes 4*π* units
    to repeat itself twice (figure 13.12).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个例子，让我们创建一个频率为2的正弦波，这意味着一个类似于正弦图形的函数，但在零和一之间重复两次。正弦函数的周期是2*π*，所以默认情况下，它需要4*π*个单位来重复两次（图13.12）。
- en: '![](../Images/CH13_F12_Orland.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH13_F12_Orland.png)'
- en: Figure 13.12 The sine function repeats itself twice between t = 0 and t = 4*π*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12 正弦函数在t = 0和t = 4*π*之间重复两次。
- en: To get two periods of the sine function graph, we need the sine function to
    receive values from 0 to 4*π* as inputs, but we want the input variable *t* to
    vary from 0 to 1\. To achieve that, we can use the function sin(4*π**t*). From
    *t* = 0 to *t* = 1, all of the values between 0 and 4*π* are passed to the sine
    function. The plot of sin(4*π**t*) in figure 13.13 has the same graph as figure
    13.12 but with two full periods of the sine function squished into the first 1.0
    units.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到正弦函数图形的两个周期，我们需要正弦函数接收从0到4*π*的输入值，但我们希望输入变量*t*从0到1变化。为了实现这一点，我们可以使用函数sin(4*π**t**)。从*t*
    = 0到*t* = 1，0到4*π*之间的所有值都传递给正弦函数。图13.13中sin(4*π**t**)的图形与图13.12相同，但将正弦函数的两个完整周期挤压到第一个1.0单位内。
- en: '![](../Images/CH13_F13_Orland.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH13_F13_Orland.png)'
- en: Figure 13.13 The graph of sin(4*π*t) is sinusoidal, repeating itself twice in
    every unit of t for a frequency of 2.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.13 sin(4*π*t)的图形是正弦的，在t的每个单位内重复两次，频率为2。
- en: The period of the function sin(4*π**t*) is ½ instead of 2*π*, so the “squishing
    factor” is 4*π*. That is, the original period was 2*π*, and the reduced period
    is 4*π* times shorter. In general, for any constant *k*, a function of the form
    *f*(*t*) = sin(*kt*) has a period shrunk by a factor of *k* to 2*π*/ *k*. The
    frequency is increased by a factor of *k* from the usual value of 1/(2*π*) to
    *k*/2*π*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 函数sin(4*π**t**)的周期是½而不是2*π*，所以“挤压因子”是4*π*。也就是说，原始周期是2*π*，而缩短后的周期是4*π*的1/4。一般来说，对于任何常数*k*，形式为*f*(*t*)
    = sin(*kt*)的函数的周期将缩短*k*倍到2*π*/ *k*。频率将增加*k*倍，从通常的1/(2*π*)增加到*k*/2*π*。
- en: If we want a sinusoidal function with a frequency of 441, the appropriate value
    of *k* would be 441 · 2 · *π*. That gives us a frequency of
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个频率为441的正弦函数，适当的*k*值将是441 · 2 · *π*。这给我们一个频率为
- en: '![](../Images/CH13_F13_Orland_EQ01.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH13_F13_Orland_EQ01.png)'
- en: 'Increasing the amplitude of the sinusoid is simpler by comparison. All you
    need to do is multiply the sine function by a constant factor, and the amplitude
    increases by the same factor. With that, we have what we need to define our `make_sinusoid`
    function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相比，增加正弦波的振幅要简单得多。你只需要将正弦函数乘以一个常数因子，振幅就会以相同的因子增加。有了这个，我们就有了定义我们的`make_sinusoid`函数所需的一切：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Defines *f*(*t*)−the sinusoidal function that is returned
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义*f*(*t*) - 返回的正弦函数
- en: ❷ Multiplies the input t by 2 ⋅ *π* times the frequency, then multiplies the
    output of the sine function by the amplitude
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将输入t乘以2 ⋅ *π*倍的频率，然后将正弦函数的输出乘以振幅
- en: 'We can test this, for example, by making a sinusoidal function with a frequency
    of 5 and an amplitude of 4, and plotting it (figure 13.14) from *t* = 0 to *t*
    = 1:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个频率为5、振幅为4的正弦函数并从*t* = 0到*t* = 1绘制它（图13.14）来测试这一点：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](../Images/CH13_F14_Orland.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH13_F14_Orland.png)'
- en: Figure 13.14 The graph of `make_sinusoid(5,4)` has a height (amplitude) of 4
    and repeats itself 5 times from t = 0 to t = 5, so it has a frequency of 5.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14 `make_sinusoid(5,4)`的图形高度（振幅）为4，从t = 0到t = 5重复5次，因此频率为5。
- en: Next, we work with the sound wave function that is the result of `make_sinusoid
    (441,8000)` having a frequency of 441 Hz and an mplitude of 8,000.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们处理由`make_sinusoid (441,8000)`得到的声音波函数，其频率为441 Hz，振幅为8,000。
- en: 13.3.3 Sampling and playing the sound wave
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.3 采样和播放声音波
- en: To play the sound wave mentioned in the last section, we need to sample it to
    get the array of numbers that are playable by PyGame. Let’s set
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放上一节中提到的声音波，我们需要对其进行采样以获取PyGame可播放的数字数组。让我们设置
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: so the `sinusoid` function from *t* = 0 to *t* = 1 represents 1 second of a
    sound wave we try to play. We pick 44,100 values of *t*, evenly spaced between
    0 and 1, and the resulting function values are the corresponding values of sinusoid(*t*).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从*t* = 0到*t* = 1的正弦函数代表我们尝试播放的声音波的1秒钟。我们选择44,100个*t*的值，在0和1之间均匀分布，并且相应的函数值是正弦函数(*t*)的对应值。
- en: 'We can use the NumPy function `np.arange`, which provides evenly spaced numbers
    on a given interval. For instance, `np.arange(0,1,0.1)` gives 10 evenly spaced
    values, starting from 0 and below 1 at 0.1 unit intervals:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用NumPy函数`np.arange`，它提供了一个给定区间上的均匀分布的数字。例如，`np.arange(0,1,0.1)`给出10个均匀分布的值，从0开始，在0.1单位间隔下小于1：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For our application, we want to use 44,100 time values between 0 and 1, which
    are evenly spaced by 1/44100 units:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用，我们希望在0和1之间使用44,100个时间值，这些值由1/44100单位均匀分布：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We want to apply the sinusoid function to every entry of this array to produce
    another NumPy array as a result. The NumPy function `np.vectorize(f)` takes a
    Python function `f` and produces a new one that applies the same operation to
    *every* entry of an array. So for us, `np.vectorize(sinusoid)(arr)` applies the
    sinusoid function to every entry of an array.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将正弦函数应用于数组的每个条目，以产生另一个作为结果的NumPy数组。NumPy函数`np.vectorize(f)`接受一个Python函数`f`并产生一个新的函数，该函数将相同的操作应用于数组的*每个*条目。因此，对于我们来说，`np.vectorize(sinusoid)(arr)`将正弦函数应用于数组的每个条目。
- en: 'This is almost a complete procedure for sampling a function. The last detail
    we need to include is converting the outputs to 16-bit integer values using the
    `astype` method on NumPy arrays. Putting these steps together, we can build the
    following general sampling function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎是一个完整的函数采样过程。我们需要包含的最后细节是将输出转换为使用NumPy数组的`astype`方法得到的16位整数值。将这些步骤组合起来，我们可以构建以下通用的采样函数：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Inputs are the function f to sample the start and end of the range and the
    number of values we want.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 输入是函数f，用于采样范围的起始和结束以及我们想要的值的数量。
- en: ❷ Creates a version of f that can be applied to a NumPy array
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个可以应用于NumPy数组的f版本
- en: ❸ Creates the evenly spaced input values for the function over the desired range
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为函数在所需范围内创建均匀分布的输入值
- en: ❹ Applies the function to every value in the NumPy array
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将函数应用于NumPy数组中的每个值
- en: ❺ Converts the resulting array to 16-bit integer values and returns it
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将结果数组转换为16位整数并返回
- en: 'Equipped with the following function, you can hear the sound of a 441 Hz sinusoidal
    wave:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 配备以下函数，你可以听到441 Hz正弦波的声波：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you play this alongside the 441 Hz square wave, you’ll notice that it plays
    the same note; in other words, it has the same pitch. However, the quality of
    the sound is much different; the sinusoidal wave plays a much smoother sound.
    It sounds almost like it could be coming out of a flute rather than out of an
    old-school video game. This quality of sound is called *timbre*(pronounced *TAM-ber)*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将它与 441 Hz 的方波一起播放，你会注意到它演奏的是同一个音符；换句话说，它有相同的音高。然而，声音的质量大不相同；正弦波演奏的声音要平滑得多。它听起来几乎像是来自长笛而不是老式电子游戏。这种声音的质量被称为
    *音色*(发音为 *TAM-ber)*。
- en: For the rest of the chapter, we focus on sound waves that are built as combinations
    of sinusoids. It turns out that with the right combination, you can approximate
    any shape of wave and, therefore, any timbre you want.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将专注于由正弦波组合而成的声波。结果是，通过正确的组合，你可以近似任何波形的波，因此可以近似任何你想要的音色。
- en: 13.3.4 Exercises
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3.4 练习
- en: '| **Exercise 13.2**: Plot the tangent function tan(*t*) = sin(*t*)/cos(*t*).
    What is its period?**Solution**: The tangent function gets infinitely big in every
    period, so it helps to plot it with a restricted range of *y* values:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 13.2**：绘制正切函数 tan(t) = sin(t)/cos(t)。它的周期是多少？**解答**：正切函数在每个周期内都会变得无限大，因此最好在限制的
    y 值范围内绘制它：'
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Limits the graph window to a y range of −10 < y < 10A graph of tan(*x*), which
    is periodic, looks like this:![](../Images/CH13_F14_Orland_UN01.png)Because tan(*t*)
    depends only on the values of cos(*t*) and sin(*t*), it should repeat itself at
    least every 2*π* units. In fact, it repeats itself *twice* every 2*π* units; we
    can see on the graph that its period is *π*. |
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将图形窗口限制在 y 范围 -10 < y < 10 内。一个周期性的 tan(x) 图形看起来是这样的！![图像](../Images/CH13_F14_Orland_UN01.png)因为
    tan(t) 只依赖于 cos(t) 和 sin(t) 的值，它至少应该在每 2π 个单位重复一次。实际上，它在每 2π 个单位重复两次；我们可以从图中看到它的周期是
    π。|
- en: '| **Exercise 13.3**: What is the frequency of sin(3*π**t*)? What is the period?**Solution**:
    The frequency of sin(*t*) is 1/(2*π*) and multiplying the argument by 3*π* increases
    this frequency by a factor of 3*π*. The resulting frequency is (3*π*)/(2*π*) =
    3/2\. The period is the reciprocal of this value, which is 2/3. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **练习 13.3**：sin(3πt) 的频率是多少？周期是多少？**解答**：sin(t) 的频率是 1/(2π)，将自变量乘以 3π 会将这个频率增加
    3π 倍。得到的频率是 (3π)/(2π) = 3/2。周期是这个值的倒数，即 2/3。|'
- en: '| **Exercise 13.4**: Find the value of *k* such that cos(*kt*) has a frequency
    of 5\. Plot the resulting function cos(*kt*) from zero to one and show that it
    repeats itself 5 times.**Solution**: The default frequency of cos(*t*) is 1/2*π*,
    so cos(*kt*) has a frequency of *k*/2*π*. If we want this value to equal 5, we
    need to have *k* = 10*π*. The resulting function is cos(10*π**t*):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 13.4**：找到 k 的值，使得 cos(kt) 的频率为 5。绘制从零到一的 cos(kt) 函数，并证明它重复了 5 次。**解答**：cos(t)
    的默认频率是 1/(2π)，所以 cos(kt) 的频率是 k/(2π)。如果我们想这个值等于 5，我们需要 k = 10π。得到的函数是 cos(10πt)：'
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here is its graph, where it repeats itself five times between the values *t*
    = 0 to *t* = 1.![](../Images/CH13_F14_Orland_UN02.png) |
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是它的图形，它在 t = 0 到 t = 1 之间重复了五次！![图像](../Images/CH13_F14_Orland_UN02.png)|
- en: 13.4 Combining sound waves to make new ones
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4 将声波组合成新的声波
- en: In chapter 6, you learned that functions can be treated like vectors; you can
    add functions or multiply them by scalars to produce new functions. When you create
    linear combinations of functions defining sound waves, you can create new, interesting
    sounds.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 6 章中，你学习了函数可以被当作向量来处理；你可以将函数相加或者用标量乘以它们来产生新的函数。当你创建定义声波的函数的线性组合时，你可以创造出新的、有趣的声音。
- en: The simplest way to combine two sound waves in Python is to sample both and
    then add the corresponding values of the two arrays to create a new one. We start
    by writing some Python code to add sampled sound waves of different frequencies,
    and the result they produce will sound like a musical chord, just as if you strummed
    several strings of a guitar at once.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中将两个声波组合的最简单方法是采样两个声波，然后将两个数组的对应值相加来创建一个新的声波。我们首先编写一些 Python 代码来添加不同频率的采样声波，它们产生的结果听起来就像是一个音乐和弦，就像你同时弹奏吉他上的几根弦一样。
- en: Once we do that, we can do a more advanced and more surprising example−we’ll
    add together several dozen sinusoidal sound waves of different frequencies in
    a prescribed linear combination, and the result will look and sound like the square
    wave from before.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们做到了这一点，我们就可以进行一个更高级、更令人惊讶的例子——我们将把几十个不同频率的正弦声波按照规定的线性组合加在一起，其结果看起来和听起来就像之前那个方波一样。
- en: 13.4.1 Adding sampled sound waves to build a chord
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.1 将采样声音波相加以构建和弦
- en: 'NumPy arrays can be added using the ordinary `+` operator in Python, making
    the job of adding sampled sound waves easy. Here’s a small example showing that
    NumPy does addition by adding the corresponding values of each array to build
    a new array:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 数组可以使用 Python 中的普通 `+` 运算符进行相加，这使得添加采样声音波变得容易。以下是一个小示例，说明 NumPy 通过将每个数组的对应值相加以构建新数组来进行加法操作：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It turns out that doing this operation with two sampled sound waves produces
    the same sound as if you played both at once. Here are two samples: our sinusoid
    at 441 Hz and a second sinusoid at 551 Hz, approximately 5/4 of the frequency
    of the first:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，使用两个采样声音波进行此操作会产生与同时播放两个声音相同的音效。这里有两组样本：我们 441 Hz 的正弦波和第二个正弦波，其频率约为第一个的
    5/4：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you ask PyGame to start one and immediately start playing the next, it plays
    the two sounds almost simultaneously. If you run the following code, you should
    hear a chord consisting of two different musical notes. If you run either of the
    last two lines on its own, you hear one of the two individual notes:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你让 PyGame 同时开始播放一个并立即开始播放下一个，它会几乎同时播放两个声音。如果你运行以下代码，你应该听到由两个不同的音符组成的和弦。如果你单独运行最后两行中的任何一行，你会听到两个单独的音符之一：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, using NumPy, we can add the two sample arrays to produce a new one and
    play it with PyGame. When `sample1` and `sample2` are added, a new array of length
    44,100 is created, containing the sums of entries from `sample1` and `sample2`.
    If you play the result, it sounds exactly like playing the previous sounds:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 NumPy，我们可以将两个样本数组相加以生成一个新的数组，并用 PyGame 播放它。当 `sample1` 和 `sample2` 相加时，会创建一个长度为
    44,100 的新数组，包含来自 `sample1` 和 `sample2` 的条目之和。如果你播放这个结果，听起来就像播放之前的声音一样：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 13.4.2 Picturing the sum of two sound waves
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.2 绘制两个声音波的叠加
- en: Let’s see what this looks like in terms of the graphs of the sound waves. Here
    are the first 400 points of `sample1`(441 Hz) and `sample2`(551 Hz). In figure
    13.15, you can see that sample 1 makes it through four periods, while sample 2
    makes it through five periods.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在声音波形的图形方面这看起来是什么样子。以下是 `sample1`(441 Hz) 和 `sample2`(551 Hz) 的前 400 个点。在图
    13.15 中，你可以看到样本 1 完成了四个周期，而样本 2 完成了五个周期。
- en: '![](../Images/CH13_F15_Orland.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH13_F15_Orland.png)'
- en: Figure 13.15 Plotting the first 400 points of `sample1` and `sample2`
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.15 绘制 `sample1` 和 `sample2` 的前 400 个点
- en: '![](../Images/CH13_F16_Orland.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH13_F16_Orland.png)'
- en: Figure 13.16 Plotting the sum of the two waves, `sample1 + sample2`
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.16 绘制两个波的叠加，`sample1 + sample2`
- en: It might come as a surprise that the sum of `sample1` and `sample2` doesn’t
    produce a sinusoid even though it’s built out of two sinusoids. Instead, the sequence
    `sample1 + sample2` traces a wave whose amplitude seems to fluctuate. Figure 13.16
    shows what the sum looks like.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会令人惊讶，尽管 `sample1` 和 `sample2` 是由两个正弦波构建的，但它们的和并不产生正弦波。相反，`sample1 + sample2`
    的序列绘制出一个振幅似乎波动的波形。图 13.16 显示了总和的外观。
- en: Let’s look closely at the summation to see how we got this shape. Near the 85th
    point of the sample, the waves are both large and positive, so the 85th point
    of the sum is also large and positive. Around the 350th point, both waves have
    large, negative values and so does their sum. When two waves align, their sum
    is even bigger (and louder), which is called *constructive interference*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看叠加，看看我们是如何得到这个形状的。在样本的第 85 个点附近，两个波都是大的正值，所以总和的第 85 个点也是大的正值。在 350 个点附近，两个波都有大的负值，它们的和也是如此。当两个波对齐时，它们的和甚至更大（更响亮），这被称为
    *构造性干涉*。
- en: There’s an interesting effect in figure 13.17, where the values are opposite
    (at the 200th point). For example, `sample1` is large and positive while `sample2`
    is large and negative. This causes their sum to be close to zero even though neither
    wave on its own is close to zero. When two waves cancel each other out like this,
    it is called *destructive interference*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.17 中有一个有趣的效果，其中值是相反的（在第 200 个点）。例如，`sample1` 是大的正值，而 `sample2` 是大的负值。这导致它们的和接近零，尽管单独的每个波都不接近零。当两个波以这种方式相互抵消时，这被称为
    *破坏性干涉*。
- en: '![](../Images/CH13_F17_Orland.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH13_F17_Orland.png)'
- en: Figure 13.17 The absolute value of the sum wave is large where there is constructive
    interference and small where there is destructive interference.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.17 总波的绝对值在发生构造性干涉的地方很大，而在发生破坏性干涉的地方很小。
- en: Because the waves have different frequencies, they go in and out of sync with
    each other, alternating between constructive and destructive interference. As
    a consequence, the sum of the waves is not a sinusoid; rather, it appears to change
    amplitude over time. Figure 13.17 displays the two graphs lined up, showing the
    relationship between the two samples and their sum.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于波具有不同的频率，它们会相互进入和退出同步，在建设性和破坏性干涉之间交替。因此，波的叠加不是一个正弦波；相反，它似乎随时间改变振幅。图 13.17
    显示了两个图形并排排列，显示了两个样本及其总和之间的关系。
- en: As you can see, the relative frequencies of summed sinusoids have an influence
    on the shape of the resulting graph. Next, I show you an even more extreme example
    of this as we build a linear combination with several dozen sinusoidal functions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，叠加正弦波的相对频率会影响结果的图形形状。接下来，我将向您展示一个更极端的例子，当我们使用几十个正弦函数构建线性组合时。
- en: 13.4.3 Building a linear combination of sinusoids
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.3 构建正弦波的线性组合
- en: 'Let’s start with a big collection of sinusoids of different frequencies. We
    can make a list (as long as we want) of sine functions, starting with:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一大堆不同频率的正弦波开始。我们可以制作一个（只要我们想要）正弦函数的列表，从：
- en: sin(2*π*t), sin(4*π*t), sin(6*π*t), sin(8*π*t), ...
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: sin(2*π*t)，sin(4*π*t)，sin(6*π*t)，sin(8*π*t)，...
- en: These functions have the frequencies 1, 2, 3, 4, and so on. Likewise, the list
    of cosine functions, starting with
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的频率为 1，2，3，4，等等。同样，余弦函数的列表，从
- en: cos(2*π*t), cos(4*π*t), cos(6*π*t), cos(8*π*t), ...
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: cos(2*π*t)，cos(4*π*t)，cos(6*π*t)，cos(8*π*t)，...
- en: has the respective frequencies 1, 2, 3, 4, and so on. The idea is that with
    so many different frequencies at our disposal, we can create a wide variety of
    different shapes by taking linear combinations of these functions. For reasons
    we’ll see later, I’ll also include a constant function *f*(*x*) = 1 in the linear
    combination. If we pick some highest frequency *N*, the most general linear combination
    of the sines, cosines, and a constant is given by figure 13.18.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 分别具有 1，2，3，4 等频率。我们的想法是，有了这么多不同的频率可供选择，我们可以通过这些函数的线性组合创建各种不同的形状。由于我们将在后面看到的原因，我还会在线性组合中包括一个常量函数
    *f*(*x*) = 1。如果我们选择某个最高频率 *N*，正弦、余弦和常量的最一般线性组合如图 13.18 所示。
- en: '![](../Images/CH13_F18_Orland.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH13_F18_Orland.png)'
- en: Figure 13.18 The sine and cosine functions in our linear combination
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.18 我们线性组合中的正弦和余弦函数
- en: 'This linear combination is a Fourier series, and it is, itself, a function
    of the variable *t*. It is specified by 2 *N* + 1 numbers: the constant term *a*
    0, the coefficients *a*[1] through *aN* on the cosine functions, and the coefficients
    *b*[1] through *bN* on the sine functions. We can evaluate the function by plugging
    a given *t* value into every sine and cosine, and adding the linear combination
    of results. Let’s do this in Python, so we can easily test out a few different
    Fourier series.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个线性组合是一个傅里叶级数，它本身是变量 *t* 的函数。它由 2 *N* + 1 个数字指定：常数项 *a* 0，余弦函数上的系数 *a*[1] 到
    *aN*，以及正弦函数上的系数 *b*[1] 到 *bN*。我们可以通过将给定的 *t* 值插入每个正弦和余弦函数，并将结果的线性组合相加来评估该函数。让我们在
    Python 中这样做，这样我们可以轻松地测试几个不同的傅里叶级数。
- en: 'The `fourier_series` function takes a single constant *a* 0, and lists *a*
    and *b* containing the coefficients *a*[1], ... , *aN* and *b*[1], ... , *bN*,
    respectively. This function works even if the arrays are different lengths; it’s
    as if the unspecified coefficients are zero. Note that the sine and cosine frequencies
    start from one, while Python’s enumerate starts with zero, so (*n* + 1) is the
    frequency corresponding to the coefficient at index *n* in either of the arrays:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`fourier_series` 函数接受一个单个常数 *a* 0，并列出 *a* 和 *b* 包含的系数 *a*[1]，... ，*aN* 和 *b*[1]，...
    ，*bN*，分别。此函数即使在数组长度不同的情况下也能正常工作；未指定的系数被视为零。请注意，正弦和余弦频率从 1 开始，而 Python 的 `enumerate`
    从 0 开始，因此 (*n* + 1) 是对应于任一数组中索引 *n* 处系数的频率：'
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Creates a constant function that returns 1 for any input
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个常量函数，对于任何输入都返回 1
- en: ❷ Evaluates all cosine terms with their respective constants and adds the results
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用各自的常量评估所有余弦项，并将结果相加
- en: ❸ Evaluates the sine terms with their respective constants and adds the results
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用各自的常量评估正弦项，并将结果相加
- en: ❹ Adds both of the results with the constant coefficient *a*[0] times the value
    of the constant function (1)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将两个结果与常量系数 *a*[0] 乘以常量函数（1）的值相加
- en: 'Here’s an example for calling this function with *b*[4] = 1 and *b*[5] = 1,
    and all other constants are 0\. This is a very short Fourier series, sin(8*π**t*)
    + sin(10*π**t*), whose plot is shown in figure 13.19\. Because the ratio of the
    frequencies is 4 : 5, the shape of the result should look like the last graph
    we plotted (figure 13.17):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，调用此函数时 *b*[4] = 1 和 *b*[5] = 1，而所有其他常数为 0。这是一个非常短的傅里叶级数，sin(8πt) + sin(10πt)，其图形如图
    13.19 所示。因为频率之比为 4:5，所以结果的形状应该类似于我们最后绘制的图形（图 13.17）：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](../Images/CH13_F19_Orland.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH13_F19_Orland.png)'
- en: Figure 13.19 The graph of the Fourier series sin(8*π*t) + sin(10*π*t)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.19 傅里叶级数 sin(8πt) + sin(10πt) 的图形
- en: This is a good test to see if our function is working, but it doesn’t show the
    full power of the Fourier series yet. Next, we try a Fourier series with more
    terms.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的测试，看看我们的函数是否工作，但它还没有展示傅里叶级数的全部威力。接下来，我们尝试一个具有更多项的傅里叶级数。
- en: 13.4.4 Building a familiar function with sinusoids
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.4 使用正弦波构建熟悉函数
- en: 'Let’s create a Fourier series that still has no constant and no cosine terms,
    but a lot more sine terms. Specifically, we use the following sequence of values
    for *b*[1], *b*[2], *b*[3], and so on:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个傅里叶级数，它仍然没有常数项和余弦项，但有很多正弦项。具体来说，我们使用以下序列的值来设置 *b*[1]，*b*[2]，*b*[3]，等等：
- en: '![](../Images/CH13_F19_Orland_EQ04.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH13_F19_Orland_EQ04.png)'
- en: Or *b[n]* = 0 for every even *n*, while *b[n]* = 4/(*n**π*) when *n* is odd.
    This gives us a base to make a Fourier series with as many terms as we want. For
    instance, the first non-zero term is
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 或者 *b[n]* = 0 对于每个偶数 *n*，而当 *n* 为奇数时，*b[n]* = 4/(nπ)。这为我们提供了一个基础，可以构建任意项数的傅里叶级数。例如，第一个非零项是
- en: '![](../Images/CH13_F19_Orland_EQ05.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH13_F19_Orland_EQ05.png)'
- en: and with the next term that gets added, the series becomes
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在添加下一个项之后，级数变为
- en: '![](../Images/CH13_F19_Orland_EQ06.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH13_F19_Orland_EQ06.png)'
- en: Figure 13.20 A plot of the first term and then the first two terms of the Fourier
    series
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.20 傅里叶级数的第一项和前两项的图形
- en: Here is the code, and figure 13.20 shows the graphs of these two functions plotted
    simultaneously.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码，图 13.20 显示了这两个函数同时绘制的图形。
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![](../Images/CH13_F20_Orland.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH13_F20_Orland.png)'
- en: Figure 13.20 A plot of the first term and then the first two terms of the Fourier
    series
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.20 傅里叶级数的第一项和前两项的图形
- en: 'Using a list comprehension, we can make a much longer list of the coefficients,
    *b[n]*, and construct the Fourier series programmatically. We can leave the list
    of cosine coefficients empty, and it will be as if all of the *a[n]* values are
    set to 0:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表推导，我们可以创建一个更长的系数列表，*b[n]*，并程序化地构建傅里叶级数。我们可以留出余弦系数列表为空，那么所有 *a[n]* 的值都将被设置为
    0：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Lists the values of bn = 4/n*π* for odd values of n and bn = 0, otherwise
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 列出 bn = 4/nπ 对于 n 的奇数值和 bn = 0，否则
- en: This list covers 1 ≤ *n* < 10, so the non-zero coefficients are *b*[1], *b*[3],
    *b*[5], *b*[7], and *b*[9]. With these terms, the graph of the series looks like
    figure 13.21.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表涵盖了 1 ≤ *n* < 10，所以非零系数是 *b*[1]，*b*[3]，*b*[5]，*b*[7]，和 *b*[9]。有了这些项，级数的图形看起来像图
    13.21。
- en: '![](../Images/CH13_F21_Orland.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH13_F21_Orland.png)'
- en: Figure 13.21 A sum of the first 5 non-zero terms of the Fourier series
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.21 傅里叶级数前 5 个非零项的总和
- en: This is an interesting pattern of constructive and destructive interference!
    Around *t* = 0 and *t* = 1, all of the sine functions are simultaneously increasing,
    while around *t* = 0.5, they are all simultaneously decreasing. This constructive
    interference is the dominant effect, while alternating constructive and destructive
    interference keeps the graph relatively flat in the other regions. With *n* ranging
    up to 19, as shown in figure 13.22, there are 10 non-zero terms and this effect
    is even more striking.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的构造性和破坏性干涉模式！在 *t* = 0 和 *t* = 1 附近，所有的正弦函数同时增加，而在 *t* = 0.5 附近，它们同时减少。这种构造性干涉是主要效应，而交替的构造性和破坏性干涉使其他区域的图形相对平坦。当
    *n* 的范围达到 19 时，如图 13.22 所示，有 10 个非零项，这种效应更加明显。
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we let *n* range all the way up to 99, we get a sum of 50 sine functions,
    and the function becomes nearly flat outside of a few big jumps (figure 13.23).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 *n* 的范围扩展到 99，我们得到 50 个正弦函数的总和，函数在几个大的跳跃之外几乎变得平坦（图 13.23）。
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![](../Images/CH13_F22_Orland.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH13_F22_Orland.png)'
- en: Figure 13.22 The first 10 non-zero terms of the Fourier series
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.22 傅里叶级数的前 10 个非零项
- en: '![](../Images/CH13_F23_Orland.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH13_F23_Orland.png)'
- en: Figure 13.23 With 99 terms, the graph of the Fourier series is nearly flat,
    apart from big steps at 0, 0.5, and 1.0.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.23 使用 99 项时，傅里叶级数的图形几乎平坦，除了在 0、0.5 和 1.0 处的大步。
- en: If you zoom out, you can see that this Fourier series comes close to the square
    wave we plotted at the beginning of the chapter (figure 13.24).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你放大查看，你可以看到这个傅里叶级数接近我们在本章开头绘制的方波（图 13.24）。
- en: '![](../Images/CH13_F24_Orland.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH13_F24_Orland.png)'
- en: Figure 13.24 The first 50 non-zero terms of the Fourier series are close to
    a square wave, like the first function we met in this chapter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.24 傅里叶级数的前 50 个非零项接近方波，就像我们在本章遇到的第一项函数。
- en: What we’ve done here is to build an approximation of the square wave function
    as a linear combination of sinusoids. It’s counterintuitive that we can do this!
    After all, all of the sinusoids in the Fourier series are round and smooth, and
    the square wave is flat and jagged. We’ll conclude this chapter by showing how
    to reverse engineer this approximation, starting with any periodic function and
    recovering the coefficients for a Fourier series that approximates it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是将方波函数构建为一个正弦波的线性组合的近似。我们能够做到这一点是反直觉的！毕竟，傅里叶级数中的所有正弦波都是圆滑的，而方波是平坦且锯齿状的。我们将通过展示如何从任何周期函数开始并恢复其傅里叶级数的系数来逆向工程这个近似，以结束本章。
- en: 13.4.5 Exercises
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4.5 练习
- en: '| **Exercise 13.5−Mini Project**: Create a manipulated version of the square
    wave Fourier series so that its frequency is 441 Hz, then sample it and confirm
    that it doesn’t just look like the square wave. It should sound like the square
    wave as well. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| **练习 13.5-迷你项目**：创建一个方波傅里叶级数的处理版本，使其频率为 441 Hz，然后对其进行采样并确认它不仅看起来像方波。它应该听起来也像方波。|'
- en: 13.5 Decomposing a sound wave into its Fourier series
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.5 将声音波分解为其傅里叶级数
- en: 'Our last goal is to take an arbitrary periodic function, like the square wave,
    and figure out how to write it (or at least an approximation of it) as a linear
    combination of sinusoidal functions. This means breaking any sound wave into a
    combination of pure notes. As a basic example, we’ll look at a sound wave defining
    a chord and identify which notes make up the chord. More profoundly, we can break
    any sound into musical notes: a person talking, a dog barking, or a car revving
    its engine. Behind this result are some elegant mathematical ideas, and you now
    have all the background you need to understand them.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的目的是将任意周期函数，如方波，找出如何将其（或至少其近似）表示为正弦函数的线性组合。这意味着将任何声音波分解为纯音符的组合。作为一个基本示例，我们将查看定义和弦的声音波，并确定哪些音符构成了和弦。更深刻的是，我们可以将任何声音分解为音乐音符：一个人说话，一只狗吠叫，或一辆汽车轰鸣。在这个结果背后是一些优雅的数学思想，而现在你已经拥有了理解它们所需的所有背景知识。
- en: The process of breaking a function into its Fourier series is analogous to writing
    a vector as a linear combination of basis vectors as we did in part 1\. Here’s
    how the analogy works. We’ll work in the vector space of functions and think of
    a function like the square wave, as a function of interest. Then, we’ll think
    of our basis as the set of functions sin(2*π**t*), sin(4*π**t*), sin(6*π**t*),
    and so on. In section 13.3, we approximated the square wave as a linear combination
    beginning with
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个函数分解为其傅里叶级数的过程类似于我们在第一部分中将一个向量表示为基向量的线性组合。这个类比是如何工作的。我们将在函数的向量空间中工作，并将一个函数，如方波，视为一个感兴趣的函数。然后，我们将基视为函数集
    sin(2*π**t**)、sin(4*π**t**)、sin(6*π**t**) 等等。在第 13.3 节中，我们将方波近似为从
- en: '![](../Images/CH13_F24_Orland_EQ07.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH13_F24_Orland_EQ07.png)'
- en: You can picture two of the basis vectors, sin(2*π**t*) and sin(6*π**t*), as
    defining two perpendicular directions in the infinite-dimensional space of functions
    with many other directions defined by the other basis vectors. The square wave
    has a component of length 4/*π* in the sin(2*π**t*) direction and a component
    of length 4/3*π* in the sin(6*π**t*) direction. These are the first two in what
    would be an infinite list of coordinates for the square wave in this basis (figure
    13.25).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将两个基向量 sin(2*π**t**) 和 sin(6*π**t**) 视为定义无限维函数空间中的两个垂直方向，其他方向由其他基向量定义。方波在
    sin(2*π**t**) 方向有一个长度为 4/*π* 的分量，在 sin(6*π**t**) 方向有一个长度为 4/3*π* 的分量。这些是这个基下方波无限列表中的前两个坐标（图
    13.25）。
- en: '![](../Images/CH13_F25_Orland.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH13_F25_Orland.png)'
- en: Figure 13.25 You can think of the square wave as a vector in the space of functions
    with a component length of 4/*π* in the sin(2*π*t) direction and component length
    of 4/3*π* in the sin(6*π*t) direction. The square wave has infinitely many more
    components beyond these two.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.25 你可以将方波视为函数空间中的一个向量，其sin(2*π*t)方向上的分量长度为4/*π*，sin(6*π*t)方向上的分量长度为4/3*π*。方波在这两个分量之外还有无限多个分量。
- en: We can write a `fourier_coefficients(f,N)` function that takes a function *f*
    , which is periodic with period one, and a number *N* of desired coefficients.
    The function treats the constant function, as well as the functions cos(2*n**π**t*)
    and sin(2*n**π**t*) from 1 ≤ *n* < *N*, as directions in the vector space of functions
    and find the components of *f* in those directions. It returns the Fourier coefficient
    *a*[0], representing the constant function, a list of Fourier coefficients *a*[1],
    *a*[2], ..., *aN*, and a list of Fourier coefficients *b*[1], *b*[2], ..., *bN*
    as a result.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个 `fourier_coefficients(f,N)` 函数，该函数接受一个周期为1的函数 *f* 和一个所需的系数数量 *N*。该函数将常数函数以及从1
    ≤ *n* < *N* 的cos(2*n**π**t*)和sin(2*n**π**t*)函数视为函数空间中的方向，并找到 *f* 在这些方向上的分量。它返回表示常数函数的傅里叶系数
    *a*[0]，以及一系列傅里叶系数 *a*[1]，*a*[2]，...，*aN* 和一系列傅里叶系数 *b*[1]，*b*[2]，...，*bN*。
- en: 13.5.1 Finding vector components with an inner product
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.1 使用内积找到向量分量
- en: In chapter 6, we covered how to do vector sums and scalar multiples with functions
    in analogy with the operations with 2D and 3D vectors. Another tool we need is
    an analogy for the dot product. The dot product is one example of an *inner product*,
    a way of multiplying two vectors to get a scalar that measures how aligned are
    the two vectors.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章中，我们介绍了如何使用函数进行向量加法和标量乘法，这些操作与2D和3D向量的操作类似。我们还需要一个与点积相对应的工具。点积是**内积**的一个例子，它通过将两个向量相乘得到一个标量，该标量衡量了两个向量的对齐程度。
- en: Let’s think back to the 3D world for a moment and show how to use the dot product
    to find components of a 3D vector, then we’ll do the same thing to find components
    of a function in the basis of sinusoidal functions. Suppose our goal is to find
    the components of the vector ***v*** = (3, 4, 5) in the directions of the standard
    basis vectors, ***e***[1] = (1, 0, 0), ***e***[2] = (0, 1, 0), and ***e***[3]
    = (0, 0, 1). This question is so obvious that we never put much thought into it.
    The components are 3, 4, and 5, respectively; that’s what the coordinates (3,
    4, 5) mean!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时回顾一下3D世界，并展示如何使用点积找到3D向量的分量，然后我们将做同样的事情来找到正弦函数基中的函数分量。假设我们的目标是找到向量 ***v***
    = (3, 4, 5) 在标准基向量 ***e***[1] = (1, 0, 0)，***e***[2] = (0, 1, 0)，和 ***e***[3]
    = (0, 0, 1) 方向上的分量。这个问题如此明显，以至于我们从未深入思考过。分量分别是3，4，和5，这就是坐标(3, 4, 5)的含义！
- en: 'Here, I’ll show you another way to find the components of ***v*** = (3, 4,
    5) using the dot product. It’s going to be overkill because we already have the
    answer, but it will be useful for the case of function vectors. Notice that each
    of the dot products of ***v*** with a standard basis vector gives us back one
    of the components:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将向您展示另一种使用点积找到 ***v*** = (3, 4, 5) 的分量方法。这将是多余的，因为我们已经有了答案，但对于函数向量的情况将很有用。请注意，***v***
    与标准基向量的每个点积都给我们回一个分量：
- en: '*v* · *e*[1] = (3, 4, 5) · (1, 0,0) = 3 + 0 + 0 = 3'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*v* · *e*[1] = (3, 4, 5) · (1, 0,0) = 3 + 0 + 0 = 3'
- en: '*v* · *e*[2] = (3, 4, 5) · (0, 1,0) = 0 + 4 + 0 = 4'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*v* · *e*[2] = (3, 4, 5) · (0, 1,0) = 0 + 4 + 0 = 4'
- en: '*v* · *e*[3] = (3, 4, 5) · (0, 0,1) = 0 + 0 + 5 = 5'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*v* · *e*[3] = (3, 4, 5) · (0, 0,1) = 0 + 0 + 5 = 5'
- en: 'These dot products immediately tell us how to build *v* as a linear combination
    of the standard basis: ***v*** = 3***e***[1] + 4***e***[2] + 5***e***[3]. Be careful.
    This only works because the dot product agrees with our definitions of lengths
    and angles. Any pair of perpendicular standard basis vectors has zero dot product:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这些点积立即告诉我们如何将 *v* 表示为标准基的线性组合：***v*** = 3***e***[1] + 4***e***[2] + 5***e***[3]。请注意，这仅因为点积与我们的长度和角度定义一致。任何一对垂直的标准基向量都具有零点积：
- en: '*e*[1] · *e*[2] = *e*[2] · *e*[3] = *e*[3] · *e*[1] = 0'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*e*[1] · *e*[2] = *e*[2] · *e*[3] = *e*[3] · *e*[1] = 0'
- en: 'And the dot products of standard basis vectors with themselves yield their
    (squared) lengths of one:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 标准基向量与自身的点积产生它们的（平方）长度为1：
- en: '*e*[1] · *e*[1] = *e*[2] · *e*[2] = *e*[3] · *e*[3] = |*e*[1]|² = |*e*[2]|²
    = |*e*[3]|² = 1'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*e*[1] · *e*[1] = *e*[2] · *e*[2] = *e*[3] · *e*[3] = |*e*[1]|² = |*e*[2]|²
    = |*e*[3]|² = 1'
- en: Another way to look at these relationships is that, according to the dot product,
    none of the standard basis vectors have components in the direction of the other
    standard basis vectors. Furthermore, each standard basis vector has component
    1 in its own direction. If we want to invent an inner product to calculate components
    of functions, we need our basis to have the same desirable properties. In other
    words, we need to know that our basis functions, like sin(2*π**t*), cos(2*π**t*),
    and so on, are all perpendicular and have length 1\. We’ll create an inner product
    for functions and test these facts.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这些关系的方法是，根据点积，标准基向量在另一个标准基向量的方向上没有分量。此外，每个标准基向量在其自身方向上的分量是 1。如果我们想发明一个内积来计算函数的分量，我们需要我们的基具有相同的理想特性。换句话说，我们需要知道我们的基函数，如
    sin(2*π**t*)，cos(2*π**t*) 等，都是垂直的并且长度为 1。我们将为函数创建一个内积并测试这些事实。
- en: 13.5.2 Defining an inner product for periodic functions
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.2 为周期函数定义内积
- en: 'Suppose *f*(*t*) and *g*(*t*) are two functions defined on the interval from
    *t* = 0 to *t* = 1, and that these repeat themselves every one unit of *t*. We
    can write the inner product of *f* and *g* as <*f* , *g* > and define it by a
    definite integral:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *f*(*t*) 和 *g*(*t*) 是在区间 *t* = 0 到 *t* = 1 上定义的两个函数，并且它们每隔一个单位的 *t* 重复一次。我们可以将
    *f* 和 *g* 的内积写作 <*f* , *g* >，并通过一个定积分来定义它：
- en: '![](../Images/CH13_F25_Orland_EQ11.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/CH13_F25_Orland_EQ11.png)'
- en: 'Let’s implement this in Python code, approximating the integral as a Riemann
    sum (as we did in chapter 8), so you can get a sense for how this inner product
    works like the familiar dot product. This Riemann sum defaults to 1,000 time steps
    as shown here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Python 代码中实现这一点，将积分近似为 Riemann 和（就像我们在第 8 章中做的那样），这样你就可以了解这个内积是如何像熟悉的点积一样工作的。这个
    Riemann 和默认为 1,000 个时间步长，如下所示：
- en: '[PRE27]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ The dt size defaults to 1/1000 = 0.001.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ dt 的大小默认为 1/1000 = 0.001。
- en: ❷ For each time step, the contribution to the integral is *f*(*t*) * g(*t*)
    * dt. The integral’s result is multiplied by 2, according to the formula.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对于每个时间步长，积分的贡献是 *f*(*t*) * g(*t*) * dt。根据公式，积分的结果乘以 2。
- en: Like the dot product, this integral approximation is a sum of products of values
    from the input vectors. Instead of being a sum of products of coordinates, it
    is a sum of products of function values. You can think of a function’s values
    as a set of infinitely many coordinates, and this inner product as being a kind
    of “infinite dot product” over these coordinates.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '与点积类似，这个积分近似是输入向量值的乘积之和。它不是坐标乘积之和，而是函数值乘积之和。你可以将函数的值视为一组无限多的坐标，而这个内积可以看作是这些坐标上的“无限点积”。 '
- en: 'Let’s take this inner product for a spin. For convenience, let’s define some
    Python functions to create the *n*^(th) sine and cosine functions in our basis,
    and then we can test them with the `inner_product` function. These functions are
    like simplified versions of the `make_sinusoid` function from section 13.3.2:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨这个内积。为了方便起见，让我们定义一些 Python 函数来创建我们基中的第 *n* 次正弦和余弦函数，然后我们可以使用 `inner_product`
    函数来测试它们。这些函数类似于第 13.3.2 节中 `make_sinusoid` 函数的简化版本：
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ s(n) takes a whole number n and returns the function sin(2n*π*t).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ s(n) 接受一个整数 n 并返回函数 sin(2n*π*t)。
- en: ❷ c(n) takes a whole number n and returns the function cos(2n*π*t).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ c(n) 接受一个整数 n 并返回函数 cos(2n*π*t)。
- en: A dot product of two 3D vectors like (1, 0, 0) and (0, 1, 0) returns zero, confirming
    they are perpendicular. Our inner product shows that all of our pairs’ basis functions
    are (approximately) perpendicular. For instance,
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 两个三维向量（1, 0, 0）和（0, 1, 0）的点积为零，这证实了它们是垂直的。我们的内积表明，我们所有的基函数对（近似地）都是垂直的。例如，
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'These numbers are extremely close to zero, confirming that sin(2*π**t*) and
    cos(2*π**t*) are perpendicular, and sin(2*π**t*) and sin(4*π**t*) are perpendicular,
    as well as cos(6*π**t*) and cos(20*π**t*). Using exact integration formulas, which
    we won’t cover here, it’s possible to *prove* that for any whole numbers *n* and
    *m* :'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字非常接近零，证实了 sin(2*π**t*) 和 cos(2*π**t*) 是垂直的，以及 sin(2*π**t*) 和 sin(4*π**t*)
    也是垂直的，同样 cos(6*π**t*) 和 cos(20*π**t*) 也是垂直的。使用我们在这里不会介绍的精确积分公式，可以 *证明* 对于任何整数
    *n* 和 *m*：
- en: 〈sin(2*n*π*t*), cos(2*m*π*t*)〉 = 0
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 〈sin(2*n*π*t*), cos(2*m*π*t*)〉 = 0
- en: And for any pair of distinct whole numbers *n* and *m*, both
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何两个不同的整数 *n* 和 *m*，都有
- en: 〈sin(2*n*π*t*), sin(2*m*π*t*)〉 = 0
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 〈sin(2*n*π*t*), sin(2*m*π*t*)〉 = 0
- en: and
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: 〈cos(2*n*π*t*), cos(2*m*π*t*)〉 = 0
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 〈cos(2*n*π*t*), cos(2*m*π*t*)〉 = 0
- en: 'This is a way of saying that with respect to this inner product, all of our
    sinusoidal basis functions are perpendicular; none has a component in the direction
    of another. The other thing we need to check is that the inner product implies
    our basis vectors have components of 1 in their own directions. Indeed, within
    numerical error, this looks to be true:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，相对于这个内积，我们所有的正弦基函数都是相互垂直的；没有一个在另一个方向上有分量。我们还需要检查的是，内积意味着我们的基向量在自己的方向上有1的分量。实际上，在数值误差范围内，这似乎是真的：
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Even though we won’t go through it here, using integral formulas makes it possible
    to prove directly that for any whole number *n*
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这里不会详细讲解，但使用积分公式可以直接证明，对于任何整数 *n*
- en: 〈sin(2*n*π*t*), sin(2*n*π*t*)〉 = 1
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 〈sin(2*n*π*t*), sin(2*n*π*t*)〉 = 1
- en: and
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: 〈cos(2*n*π*t*), cos(2*n*π*t*)〉 = 1
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 〈cos(2*n*π*t*), cos(2*n*π*t*)〉 = 1
- en: The last bit of tidying up we need to do is to include our constant function
    in this discussion. I promised before that I’d explain why we need to include
    a constant term in the Fourier series, and now I can give an initial explanation.
    The constant function is required to build a complete basis of functions; not
    including this would be like omitting ***e***[2] from the basis for 3D space and
    going forward with ***e***[1] and ***e***[3]. If you did that, there’d be functions
    you simply couldn’t build out of basis vectors.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件整理工作是将常数函数包含在这个讨论中。我之前承诺过要解释为什么我们需要在傅里叶级数中包含常数项，现在我可以给出一个初步的解释。常数函数是构建完整函数基所必需的；如果不包含它，就像在3D空间的基中省略
    ***e***[2]，只使用 ***e***[1] 和 ***e***[3] 一样。如果你这样做，有些函数你就无法用基向量构建出来。
- en: 'Any constant function is perpendicular to every sine and cosine function in
    our basis, but we need to pick the value of the constant function so that it has
    component 1 in its own direction. That is, if we implement a Python function `const(*t*)`,
    we should find that `inner_product(const,const)` returns 1\. The right constant
    value for `const` to return turns out to be 1/√2 (and you can check in the following
    exercise that this value makes sense!):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 任何常数函数都垂直于我们基中的所有正弦和余弦函数，但我们需要选择常数函数的值，使其在自身方向上的分量是1。也就是说，如果我们实现一个Python函数 `const(*t*)`，我们应该找到
    `inner_product(const,const)` 返回1。`const` 返回的正确常数值是 1/√2（你可以在下面的练习中检查这个值是否合理！）：
- en: '[PRE31]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With this defined, we can confirm the constant function has the right properties:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在此定义的基础上，我们可以确认常数函数具有正确的属性：
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We now have the tools we need to find the Fourier coefficients of a periodic
    function. These coefficients are nothing more than components of the function
    in the basis we’ve defined.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经拥有了寻找周期函数傅里叶系数所需的工具。这些系数不过是函数在我们定义的基中的组成部分。
- en: 13.5.3 Writing a function to find Fourier coefficients
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.3 编写一个寻找傅里叶系数的函数
- en: In the 3D example, we saw that the dot product of a vector ***v*** with a basis
    vector ***e*** *i* gave us the component of ***v*** in the direction of ***e***
    *i*. We’ll use the same process for a periodic function *f* .
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D示例中，我们看到了向量 ***v*** 与基向量 ***e*** *i* 的点积给出了 ***v*** 在 ***e*** *i* 方向上的分量。我们将对周期函数
    *f* 使用相同的过程。
- en: 'The coefficients *a[n]* for *n* ≥ 1 tell us the components of *f* in the direction
    of the basis function cos(2*n**π**t*). They are computed as the inner products
    of *f* with these basis functions:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *n* ≥ 1 的系数 *a[n]* 告诉我们 *f* 在基函数 cos(2*n**π**t*) 方向上的分量。它们是通过计算 *f* 与这些基函数的内积来得到的：
- en: '*a[n]* = 〈*f*, cos(2*n*π*t*)〉 , n ≥ 1'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*a[n]* = 〈*f*, cos(2*n*π*t*)〉 , n ≥ 1'
- en: 'Likewise, every Fourier coefficient *b[n]* tells us the component of *f* in
    the direction of a basis function sin(2*n**π**t*) and can also be computed with
    an inner product:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，每个傅里叶系数 *b[n]* 告诉我们 *f* 在基函数 sin(2*n**π**t*) 方向上的分量，也可以通过内积来计算：
- en: '*b[n]* = 〈*f*, sin(2*n*π*t*)〉'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '*b[n]* = 〈*f*, sin(2*n*π*t*)〉'
- en: 'Finally, the number *a* 0 is the inner product of *f* with the constant function,
    whose value is 1/√2\. All of these Fourier coefficients can be computed with Python
    functions we’ve already written, so we’re ready to assemble the `fourier_coefficients`
    function we set out to write. Remember, the first argument to the function is
    the function we want to analyze, and the second argument is the maximum number
    of sine and cosine terms we want:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，系数 *a* 0 是 *f* 与常数函数的内积，其值为 1/√2。所有这些傅里叶系数都可以使用我们之前编写的Python函数来计算，因此我们准备好编写
    `fourier_coefficients` 函数。记住，函数的第一个参数是我们想要分析的功能，第二个参数是我们想要的最大正弦和余弦项数：
- en: '[PRE33]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ The constant term *a*[0] is the inner product of *f* with the constant basis
    function.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 常数项 *a*[0] 是 f 与常数基函数的内积。
- en: ❷ The coefficients an are given by inner products of f with cos(2n*π*t) for
    1 < *n* < *N* + 1.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 系数 an 是 f 与 cos(2n*π*t) 的内积，对于 1 < *n* < *N* + 1。
- en: ❸ The coefficients bn are given by inner products of f with sin(2n*π*t) for
    1 ≤ *n* < *N* + 1.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 系数 bn 是 f 与 sin(2n*π*t) 的内积，对于 1 ≤ *n* < *N* + 1。
- en: As a sanity check, a Fourier series should give back its own coefficients. For
    instance
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 作为合理性检查，傅里叶级数应该返回其自身的系数。例如
- en: '[PRE34]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note If you want the inputs and outputs to match non-zero constant terms, you
    need to revise the const function to be *f*(*t*) = 1/√2 instead of *f*(*t*) =
    1\. See exercise 13.8.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你想让输入和输出匹配非零常数项，你需要将 const 函数修改为 *f*(*t*) = 1/√2 而不是 *f*(*t*) = 1。参见练习13.8。
- en: Now that we can automatically compute Fourier coefficients, we can conclude
    our exploration by building some Fourier approximations of interestingly shaped
    periodic functions.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够自动计算傅里叶系数，我们可以通过构建一些有趣形状的周期函数的傅里叶近似来结束我们的探索。
- en: 13.5.4 Finding the Fourier coefficients for the square wave
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.4 求方波的傅里叶系数
- en: We saw in the last section that the Fourier coefficients for the square wave
    were all zero except for the *b[n]* coefficients for odd *n* values. That is,
    the Fourier series is built as a linear combination of the function sin(2*n**π**t*)
    for odd values of *n*. For odd *n*, the coefficient was *bn = 4/n**π*. I didn’t
    explain why those were the coefficients, but now we can check our work.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个章节中看到，方波的傅里叶系数除了奇数 *n* 值的 *b[n]* 系数外都是零。也就是说，傅里叶级数是由 sin(2*n**π**t*) 的奇数
    *n* 值的线性组合构成的。对于奇数 *n*，系数是 *bn = 4/n**π*。我没有解释为什么这些是系数，但现在我们可以检查我们的工作。
- en: To make a square wave that repeats itself every unit of *t*, we can use the
    value `t%1` in Python, which computes the fractional part of *t*. Because, for
    example, `2.3` `%` `1` is `0.3` and `0.3` `%` `1` is `0.3`, a function written
    in terms of `t` `%` 1 is automatically periodic with the period 1\. The square
    wave has a value of +1 when `t` `%` `1` `<` `0.5` and −1 otherwise
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使周期为 *t* 的方波重复出现，我们可以在 Python 中使用 `t%1` 的值，它计算 *t* 的分数部分。因为，例如，`2.3` `%` `1`
    是 `0.3`，而 `0.3` `%` `1` 仍然是 `0.3`，以 `t` `%` 1 为术语编写的函数自动具有周期 1。当 `t` `%` `1` `<`
    `0.5` 时，方波值为 +1，否则为 −1。
- en: '[PRE35]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let’s look at the first 10 Fourier coefficients for this square wave. Run
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个方波的第一个10个傅里叶系数。运行
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'and you’ll see that *a*[0] and the entries of *a* are all small, as with every
    other entry of *b*. The values of *b*[1], *b*[3], *b*[5], and so on are represented
    by `b[0],` `b[2],` `b[4]`, ..., because Python arrays are zero-indexed. These
    are all close to the expected values:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到 *a*[0] 和 *a* 的条目都很小，就像 *b* 的其他条目一样。*b*[1]、*b*[3]、*b*[5] 等的值由 `b[0]`、`b[2]`、`b[4]`
    等表示，因为 Python 数组是零索引的。这些值都接近预期的值：
- en: '[PRE37]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We already saw that a Fourier series with these coefficients is a solid approximation
    of the square wave graph. Let’s conclude this section by looking at two example
    functions we haven’t seen before and plotting the Fourier series alongside the
    original functions to show that the approximation works.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，具有这些系数的傅里叶级数是对方波图的稳健近似。让我们通过查看两个我们之前没有见过的示例函数，并将傅里叶级数与原始函数一起绘制来结束本节，以展示近似是如何工作的。
- en: 13.5.5 Fourier coefficients for other waveforms
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.5 其他波形的傅里叶系数
- en: Next, we consider more functions beyond the square wave graph that can be modeled
    using a Fourier transform. Figure 13.26 shows a new, interestingly shaped waveform
    called a *sawtooth wave*.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们考虑更多可以用傅里叶变换建模的函数，而不仅仅是方波图。图13.26显示了新的、有趣形状的波形，称为锯齿波。
- en: '![](../Images/CH13_F26_Orland.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH13_F26_Orland.png)'
- en: Figure 13.26 A sawtooth wave plotted over five periods
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.26 一个锯齿波在五个周期内绘制
- en: On the intervals from *t* = 0 to *t* = 1, the sawtooth wave is identical to
    the function *f*(*t*) = *t* and then it repeats itself every one unit. To define
    the sawtooth wave as a Python function, we can simply write
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *t* = 0 到 *t* = 1 的区间内，锯齿波与函数 *f*(*t*) = *t* 相同，然后每单位重复一次。为了将锯齿波定义为 Python
    函数，我们可以简单地写出
- en: '[PRE38]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To see its Fourier series approximation with up to 10 sine and cosine terms,
    we can plug the Fourier coefficients directly into our Fourier series function.
    Plotting it alongside the sawtooth, as shown in figure 13.27, we can see it has
    a good fit.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到其包含最多10个正弦和余弦项的傅里叶级数近似，我们可以直接将傅里叶系数代入我们的傅里叶级数函数中。如图13.27所示，将其与锯齿波一起绘制，我们可以看到它有很好的拟合度。
- en: '[PRE39]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![](../Images/CH13_F27_Orland.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH13_F27_Orland.png)'
- en: Figure 13.27 The original sawtooth wave from figure 13.26 with its Fourier series
    approximation
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.27 图13.26中的原始锯齿波及其傅里叶级数近似
- en: Once again, it’s striking how close we can come to a function with sharp corners
    using only a linear combination of smooth sine and cosine waves. This function
    happens to have a non-zero constant coefficient *a*[0]. That’s required because
    this function only has values above zero, while sine and cosine functions contribute
    negative values.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，使用仅由平滑的正弦和余弦波线性组合来逼近具有尖锐角的功能，其接近程度令人印象深刻。这个函数恰好有一个非零的常数系数 *a*[0]。这是必需的，因为此函数的值仅在零以上，而正弦和余弦函数贡献的是负值。
- en: As a final example, take a look at the following function defined as `speedbumps(*t*)`
    in the source code for this book. Figure 13.28 shows the graph.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的例子，看看这本书源代码中定义的以下函数 `speedbumps(*t*)`。图13.28显示了该函数的图形。
- en: '![](../Images/CH13_F28_Orland.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH13_F28_Orland.png)'
- en: Figure 13.28 The `speedbumps(*t*)` function that alternates between flat stretches
    and round bumps
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.28 在源代码中定义为 `speedbumps(*t*)` 的函数，它在平坦的延伸和圆形突起之间交替
- en: The implementation of this function isn’t important, but this one is an interesting
    example because it has non-zero coefficients for the cosine functions and all
    zeros for the sines. Even with 10 terms, we get a good approximation. Figure 13.29
    shows the graph of the Fourier series with *a*[0] and ten cosine terms (the coefficients
    *b[n]* are all zero).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的实现并不重要，但这个例子很有趣，因为它对于余弦函数有非零系数，而对于正弦函数则全部为零。即使有10项，我们也能得到一个好的近似。图13.29显示了包含
    *a*[0] 和十个余弦项（系数 *b[n]* 全为零）的傅里叶级数的图形。
- en: '![](../Images/CH13_F29_Orland.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH13_F29_Orland.png)'
- en: Figure 13.29 The constant term and first 10 cosine terms for the Fourier series
    of the `speedbumps(*t*)` function
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.29 `speedbumps(*t*)` 函数傅里叶级数的常数项和前10个余弦项
- en: You can see some wobbles when we graph these approximations, but when these
    waveforms are translated to sound, the Fourier series can be good enough. Because
    we are able to transform waveforms of all shapes to lists of their Fourier coefficients,
    we can store and transmit audio files efficiently.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们绘制这些近似时，可以看到一些波动，但当这些波形转换为声音时，傅里叶级数可以足够好。因为我们能够将所有形状的波形转换为它们的傅里叶系数列表，我们可以有效地存储和传输音频文件。
- en: 13.5.6 Exercises
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5.6 练习
- en: '| **Exercise 13.6**: The vectors ***u***[1] = (2, 0, 0), ***u***[2] = (0, 1,
    1), and ***u***[3] = (1, 0, −1) form a basis for ℝ³. For a vector ***v*** = (3,
    4, 5), compute three dot products *a*[1] = *v* · ***u***[1], *a*[2] = *v* · ***u***[2],
    and *a*[3] = *v* · ***u***[3]. Show that ***v*** is *not* equal to *a*[1] ***u***[1]
    + *a*[2] ***u***[2] + *a*[3] ***u***[3]. Why aren’t they equal?**Solution**: The
    dot products are*a*[1] = ***v*** · ***u***[1] = (3, 4, 5) · (2, 0, 0) = 6*a*[2]
    = ***v*** · ***u***[2] = (3, 4, 5) · (0, 1, 1) = 9*a*[3] = ***v*** · ***u***[3]
    = (3, 4, 5) · (1, 0,−1) = −2That makes the linear combination 6 · (2, 0, 0) +
    9 · (0, 1, 1) − 2 · (1, 0, −1) = (16, 9, 2), which is not equal to (3, 4, 5).
    This approach does not give the correct result because these basis vectors do
    not have length 1 and are not perpendicular to each other. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| **练习13.6**: 向量 ***u***[1] = (2, 0, 0), ***u***[2] = (0, 1, 1), 和 ***u***[3]
    = (1, 0, −1) 构成 ℝ³ 的一个基。对于向量 ***v*** = (3, 4, 5)，计算三个点积 *a*[1] = *v* · ***u***[1],
    *a*[2] = *v* · ***u***[2], 和 *a*[3] = *v* · ***u***[3]。证明 ***v*** 不等于 *a*[1] ***u***[1]
    + *a*[2] ***u***[2] + *a*[3] ***u***[3]。为什么它们不相等？**解答**: 点积为*a*[1] = ***v*** ·
    ***u***[1] = (3, 4, 5) · (2, 0, 0) = 6*a*[2] = ***v*** · ***u***[2] = (3, 4, 5)
    · (0, 1, 1) = 9*a*[3] = ***v*** · ***u***[3] = (3, 4, 5) · (1, 0,−1) = −2。这使得线性组合
    6 · (2, 0, 0) + 9 · (0, 1, 1) − 2 · (1, 0, −1) = (16, 9, 2)，这并不等于 (3, 4, 5)。这种方法不能给出正确的结果，因为这些基向量长度不为1，且它们之间不垂直。|'
- en: '| **Exercise 13.7-Mini Project**: Suppose *f*(*t*) is constant, meaning *f*(*t*)
    = *k*. Use the integral formula for the inner product to find a value *k* making
    <*f* , *f* > = 1\. (Yes, I’ve already told you that *k* =1/√2 but see if you can
    get to that value yourself!) |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| **练习13.7-迷你项目**: 假设 *f*(*t*) 是常数，即 *f*(*t*) = *k*。使用内积的积分公式找到一个值 *k* 使得 <*f*
    , *f* > = 1。是的，我已经告诉你 *k* =1/√2，但看看你是否能自己得到这个值！|'
- en: '| **Solution**: If *f*(*t*) = *k*, then <*f* , *f* > is given by the integral:![](../Images/CH13_F29_Orland_EQ18.png)(The
    area under the constant function *k*² from 0 to 1 is *k*².) If we want 2 *k*²
    to equal 1, then *k*² = and *k* = √1/2 = 1/√2. |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| **解答**：如果 *f*(*t*) = *k*，那么 <*f* , *f* > 由以下积分给出：![](../Images/CH13_F29_Orland_EQ18.png)（常数函数
    *k*² 从 0 到 1 下的面积是 *k*²。）如果我们想使 2 *k*² 等于 1，那么 *k*² = ，*k* = √1/2 = 1/√2。|'
- en: '| **Exercise 13.8**: Update the `fourier_series` function to use *f*(*t*) =
    1/√2 for the constant function instead of *f*(*t*) = 1.**Solution**:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 13.8**：更新 `fourier_series` 函数，使用 *f*(*t*) = 1/√2 作为常数函数，而不是 *f*(*t*)
    = 1。**解答**：'
- en: '[PRE40]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ Multiplies the coefficient *a*[0] by the constant function *f*(*t*) = 1/√2
    to the Fourier series result regardless of the value of t |
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将系数 *a*[0] 乘以常数函数 *f*(*t*) = 1/√2，并将其加到傅里叶级数的结果中，无论 t 的值如何 |
- en: '| **Exercise 13.9−Mini Project**: Play a sawtooth wave at 441 Hz and compare
    it with the square and sinusoidal waves you played at that frequency.**Solution**:
    We can create a modified sawtooth wave function with amplitude 8,000 and frequency
    441 and then sample it to pass to PyGame:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '| **练习 13.9-迷你项目**：播放 441 Hz 的锯齿波，并将其与您在该频率下播放的方波和正弦波进行比较。**解答**：我们可以创建一个振幅为
    8,000、频率为 441 的修改后的锯齿波函数，然后对其进行采样，传递给 PyGame：'
- en: '[PRE41]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: People often compare the sound of a sawtooth wave to that of a string instrument,
    like a violin. |
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 人们常常将锯齿波的声音与弦乐器，如小提琴的声音相比较。|
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Sound waves are pressure changes over time that propagate through the air to
    our ears where we perceive these as sounds. We can represent a sound wave as a
    function that loosely represents the change in air pressure over time.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声波是随时间传播的空气压力变化，到达我们的耳朵时，我们将其感知为声音。我们可以将声波表示为一个函数，该函数大致表示随时间变化的空气压力变化。
- en: PyGame and most other digital audio systems used *sampled* audio. Rather than
    a function defining a sound wave, these systems use arrays of values of the function
    taken at uniform intervals. For instance, CD audio commonly uses 44,100 values
    for each second of audio.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyGame 和大多数其他数字音频系统使用 *采样* 音频。这些系统不是使用定义声波函数，而是使用函数在均匀间隔下的值数组。例如，CD 音频通常每秒使用
    44,100 个值。
- en: Sound waves with random shapes sound like noise, while waves with shapes that
    repeat on fixed intervals produce well-defined musical notes. A function that
    repeats its values on a certain interval is called a *periodic function*.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形状随机的声波听起来像噪音，而形状在固定间隔内重复的波产生明确的音乐音符。在某个间隔上重复其值的函数称为 *周期函数*。
- en: The sine and cosine functions are periodic functions, and their graphs repeat
    curved shapes called *sinusoids.*
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正弦和余弦函数是周期函数，它们的图形重复称为 *正弦波* 的曲线形状。
- en: Sine and cosine repeat their values every 2*π* units. That value is called their
    *period*. The *frequency* of a periodic function is the reciprocal of the period,
    which is 1/(2*π*) for sine and cosine.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正弦和余弦函数每 2*π* 个单位重复其值。这个值称为它们的 *周期*。周期函数的 *频率* 是周期的倒数，对于正弦和余弦来说，是 1/(2*π*)。
- en: A function of the form sin(2*n**π**t*) or cos(2*n**π**t*) has frequency *n*.
    High frequency sound wave functions produce high-pitched musical notes.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 形式为 sin(2*n**π**t*) 或 cos(2*n**π**t*) 的函数具有频率 *n*。高频声波函数产生高音调的音符。
- en: The maximum height of a periodic function is called its *amplitude*. Multiplying
    a sine or cosine function by a number increases the amplitude of the function
    and the volume of the corresponding sound wave.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 周期函数的最大高度称为其 *振幅*。将正弦或余弦函数乘以一个数字会增加函数的振幅和相应声波的音量。
- en: To create the effect of two sounds playing at once, you can add the functions
    that define their corresponding sound waves to create a new function and a new
    sound wave. Generally, you can take any linear combination of existing sound waves
    to create a new sound wave.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建同时播放两个声音的效果，您可以添加定义它们对应声波的函数，以创建一个新的函数和一个新的声波。通常，您可以通过现有声波的任何线性组合来创建一个新的声波。
- en: A linear combination of a constant function along with functions of the form
    sin(2*n**π**t*) and cos(2*n**π**t*) for various values of *n* is called a *Fourier
    series*. Despite being built out of smooth sine and cosine functions, Fourier
    series can be good approximations for any periodic functions, even those with
    sharp corners like square waves.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由一个常数函数以及形式为 sin(2*n**π**t*) 和 cos(2*n**π**t*) 的函数的线性组合，对于各种 *n* 的值，称为傅里叶级数。尽管傅里叶级数是由平滑的正弦和余弦函数构建的，但它可以很好地近似任何周期函数，甚至那些具有尖锐拐角的函数，如方波。
- en: You can think of the constant function along with the sines and cosines at different
    frequencies as a basis for the vector space of periodic functions. The linear
    combination of these basis vectors that best approximate a given function are
    called *Fourier coefficients*.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将不同频率的正弦和余弦函数以及常数函数视为周期函数向量空间的基。这些基向量的线性组合，用以最佳逼近给定函数的，被称为**傅里叶系数**。
- en: We can use the dot product of a 2D or 3D vector with a standard basis vector
    to find its component in the direction of that basis vector.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用二维或三维向量与标准基向量的点积来找到其在该基向量方向上的分量。
- en: Analogously, we can take a special inner product of a periodic function with
    a sine or cosine function to find a component associated with that function. The
    inner product for periodic functions is a definite integral taken over a specified
    range, in our case, from zero to one.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，我们可以取一个周期函数与正弦或余弦函数的特殊内积，以找到与该函数相关联的分量。周期函数的内积是在指定范围内取定的定积分，在我们的例子中，是从零到一。
