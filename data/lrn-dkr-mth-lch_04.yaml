- en: 4 Packaging applications from source code into Docker Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 从源代码打包应用程序到 Docker 镜像
- en: 'Building Docker images is easy. In chapter 3 you learned that you just need
    a few instructions in a Dockerfile to package an application to run in a container.
    There’s one other thing you need to know to package your own applications: you
    can also run commands inside Dockerfiles.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像很容易。在第三章中，你学习了只需要在 Dockerfile 中添加一些指令就可以打包一个在容器中运行的应用程序。你需要知道另一件事来打包你自己的应用程序：你还可以在
    Dockerfile 中运行命令。
- en: Commands execute during the build, and any filesystem changes from the command
    are saved in the image layer. That makes Dockerfiles about the most flexible packaging
    format there is; you can expand zip files, run Windows installers, and do pretty
    much anything else. In this chapter you’ll use that flexibility to package applications
    from source code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 命令在构建过程中执行，并且任何来自命令的文件系统更改都将保存在镜像层中。这使得 Dockerfile 变成了最灵活的打包格式之一；你可以展开 zip 文件，运行
    Windows 安装程序，以及做几乎所有其他事情。在本章中，你将利用这种灵活性来从源代码打包应用程序。
- en: 4.1 Who needs a build server when you have a Dockerfile?
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 当你有 Dockerfile 时，还需要构建服务器吗？
- en: Building software on your laptop is something you do for local development,
    but when you’re working in a team there’s a more rigorous delivery process. There’s
    a shared source control system like GitHub where everyone pushes their code changes,
    and there’s typically a separate server (or online service) that builds the software
    when changes get pushed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的笔记本电脑上构建软件是你在本地开发时做的事情，但当你在一个团队中工作时，有一个更严格的交付过程。有一个共享的源代码控制系统，如 GitHub，每个人都在那里推送他们的代码更改，通常还有一个单独的服务器（或在线服务），当更改被推送时，它会构建软件。
- en: That process exists to catch problems early. If a developer forgets to add a
    file when they push code, the build will fail on the build server and the team
    will be alerted. It keeps the project healthy, but the cost is having to maintain
    a build server. Most programming languages need a lot of tools to build projects--figure
    4.1 shows some examples.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程存在是为了尽早发现问题。如果一个开发者在推送代码时忘记添加文件，构建将在构建服务器上失败，并且团队将会被通知。它保持了项目的健康，但代价是必须维护一个构建服务器。大多数编程语言需要很多工具来构建项目--图
    4.1 展示了一些示例。
- en: '![](../Images/4-1.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-1.jpg)'
- en: Figure 4.1 Everyone needs the same set of tools to build a software project.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 每个人都需要相同的工具集来构建一个软件项目。
- en: There’s a big maintenance overhead here. A new starter on the team will spend
    the whole of their first day installing the tools. If a developer updates their
    local tools so the build server is running a different version, the build can
    fail. You have the same issues even if you’re using a managed build service, and
    there you may have a limited set of tools you can install.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很大的维护开销。团队的新成员将花费他们第一天的时间来安装工具。如果一个开发者更新了他们的本地工具，使得构建服务器运行的是不同版本，构建可能会失败。即使你使用的是托管构建服务，你也会遇到同样的问题，在那里你可能只能安装有限的一组工具。
- en: It would be much cleaner to package the build toolset once and share it, which
    is exactly what you can do with Docker. You can write a Dockerfile that scripts
    the deployment of all your tools, and build that into an image. Then you can use
    that image in your application Dockerfiles to compile the source code, and the
    final output is your packaged application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性打包构建工具集并共享它将更加干净利落，这正是你可以使用 Docker 实现的。你可以编写一个 Dockerfile 来脚本化所有工具的部署，并将其构建成一个镜像。然后你可以在你的应用程序
    Dockerfile 中使用该镜像来编译源代码，最终的输出是你的打包应用程序。
- en: Let’s start with a very simple example, because there are a couple of new things
    to understand in this process. Listing 4.1 shows a Dockerfile with the basic workflow.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的例子开始，因为在这个过程中有几个新事物需要理解。列表 4.1 展示了一个具有基本工作流程的 Dockerfile。
- en: Listing 4.1 A multi-stage Dockerfile
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 一个多阶段 Dockerfile
- en: '` FROM diamol/base AS build-stage` ` RUN echo ''Building...'' > /build.txt`
    ` FROM diamol/base AS test-stage`  ` COPY --from=build-stage /build.txt /build.txt`
    ` RUN echo ''Testing...'' >> /build.txt`  ` FROM diamol/base` ` COPY --from=test-stage
    /build.txt /build.txt` ` CMD cat /build.txt`'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '` FROM diamol/base AS build-stage` ` RUN echo ''Building...'' > /build.txt`
    ` FROM diamol/base AS test-stage`  ` COPY --from=build-stage /build.txt /build.txt`
    ` RUN echo ''Testing...'' >> /build.txt`  ` FROM diamol/base` ` COPY --from=test-stage
    /build.txt /build.txt` ` CMD cat /build.txt`'
- en: 'This is called a multi-stage Dockerfile, because there are several stages to
    the build. Each stage starts with a `FROM` instruction, and you can optionally
    give stages a name with the `AS` parameter. Listing 4.1 has three stages: `build-stage`
    , `test-stage` , and the final unnamed stage. Although there are multiple stages,
    the output will be a single Docker image with the contents of the final stage.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为多阶段Dockerfile，因为构建有几个阶段。每个阶段都以`FROM`指令开始，你可以使用`AS`参数为阶段命名。列表4.1有三个阶段：`build-stage`、`test-stage`和最终的未命名阶段。尽管有多个阶段，但输出将是一个包含最终阶段内容的单个Docker镜像。
- en: Each stage runs independently, but you can copy files and directories from previous
    stages. I’m using the `COPY` instruction with the `--from` argument, which tells
    Docker to copy files from an earlier stage in the Dockerfile, rather than from
    the filesystem of the host computer. In this example I generate a file in the
    build stage, copy it into the test stage, and then copy the file from the test
    stage into the final stage.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段都是独立运行的，但你可以从之前的阶段复制文件和目录。我使用带有`--from`参数的`COPY`指令，这告诉Docker从Dockerfile中的早期阶段复制文件，而不是从宿主机的文件系统中复制。在这个例子中，我在构建阶段生成一个文件，将其复制到测试阶段，然后将文件从测试阶段复制到最终阶段。
- en: There’s one new instruction here, `RUN` , which I’m using to write files. The
    `RUN` instruction executes a command inside a container during the build, and
    any output from that command is saved in the image layer. You can execute anything
    in a `RUN` instruction, but the commands you want to run need to exist in the
    Docker image you’re using in the `FROM` instruction. In this example I used `diamol/base`
    as the base image, and it contains the `echo` command, so I knew my `RUN` instruction
    would work.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个新的指令，`RUN`，我使用它来写入文件。`RUN`指令在构建过程中在容器内执行一个命令，并且该命令的任何输出都保存在镜像层中。你可以在`RUN`指令中执行任何操作，但你想运行的命令需要存在于你在`FROM`指令中使用的Docker镜像中。在这个例子中，我使用了`diamol/base`作为基础镜像，它包含`echo`命令，所以我确定我的`RUN`指令会工作。
- en: Figure 4.2 shows what’s going to happen when we build this Dockerfile--Docker
    will run the stages sequentially.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2显示了构建此Dockerfile时将要发生的情况--Docker将按顺序运行阶段。
- en: '![](../Images/4-2.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图4-2](../Images/4-2.jpg)'
- en: Figure 4.2 Executing a multi-stage Dockerfile
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 执行多阶段Dockerfile](../Images/4-2.jpg)'
- en: It’s important to understand that the individual stages are isolated. You can
    use different base images with different sets of tools installed and run whatever
    commands you like. The output in the final stage will only contain what you explicitly
    copy from earlier stages. If a command fails in any stage, the whole build fails.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 理解各个阶段是隔离的很重要。你可以使用不同基础镜像和安装了不同工具集的集合，并运行你喜欢的任何命令。最终阶段的输出将只包含你从早期阶段显式复制的文件。如果任何阶段的命令失败，整个构建将失败。
- en: 'Try it now Open a terminal session to the folder where you stored the book’s
    source code, and build this multi-stage Dockerfile:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 打开一个终端会话到存储本书源代码的文件夹，并构建此多阶段Dockerfile：
- en: '` cd ch04/exercises/multi-stage` ` docker image build -t multi-stage .`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ch04/exercises/multi-stage` ` docker image build -t multi-stage .`'
- en: You’ll see that the build executes the steps in the order of the Dockerfile,
    which gives the sequential build through the stages you can see in figure 4.3.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到构建会按照Dockerfile中的顺序执行步骤，这通过图4.3中可以看到的阶段进行顺序构建。
- en: '![](../Images/4-3.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图4-3](../Images/4-3.jpg)'
- en: Figure 4.3 Building a multi-stage Dockerfile
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 构建多阶段Dockerfile](../Images/4-3.jpg)'
- en: This is a simple example, but the pattern is the same for building apps of any
    complexity with a single Dockerfile. Figure 4.4 shows what the workflow looks
    like for a Java application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，但构建任何复杂性的应用程序的单个Dockerfile的模式是相同的。图4.4显示了Java应用程序的工作流程。
- en: '![](../Images/4-4.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图4-4](../Images/4-4.jpg)'
- en: Figure 4.4 A multi-stage build for a Java application
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 Java应用程序的多阶段构建](../Images/4-4.jpg)'
- en: In the build stage you use a base image that has your application’s build tools
    installed. You copy in the source code from your host machine and run the `build`
    command. You can add a test stage to run unit tests, which uses a base image with
    the test framework installed, copies the compiled binaries from the build stage,
    and runs the tests. The final stage starts from a base image with just the application
    runtime installed, and it copies the binaries from the build stage that have been
    successfully tested in the test stage.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建阶段，您使用一个已安装应用程序构建工具的基础镜像。您从主机机器复制源代码并运行 `build` 命令。您可以在测试阶段添加一个运行单元测试的步骤，该步骤使用已安装测试框架的基础镜像，从构建阶段复制编译的二进制文件，并运行测试。最终阶段从一个仅安装应用程序运行时的基础镜像开始，并从构建阶段复制在测试阶段成功测试的二进制文件。
- en: This approach makes your application truly portable. You can run the app in
    a container anywhere, but you can also build the app anywhere--Docker is the only
    prerequisite. Your build server just needs Docker installed; new team members
    get set up in minutes, and the build tools are all centralized in Docker images,
    so there’s no chance of getting out of sync.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使您的应用程序真正具有可移植性。您可以在任何地方运行应用程序，也可以在任何地方构建应用程序——Docker是唯一的前提条件。您的构建服务器只需要安装Docker；新团队成员可以在几分钟内设置好，构建工具都集中存储在Docker镜像中，因此不会出现不同步的情况。
- en: All the major application frameworks already have public images on Docker Hub
    with the build tools installed, and there are separate images with the application
    runtime. You can use these images directly or wrap them in your own images. You’ll
    get the benefit of using all the latest updates with images that are maintained
    by the project teams.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有主要的应用程序框架已经在Docker Hub上发布了带有构建工具的公共镜像，并且有单独的应用程序运行时镜像。您可以直接使用这些镜像或将其封装在自己的镜像中。您将能够使用由项目团队维护的最新更新的镜像。
- en: '4.2 App walkthrough: Java source code'
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 应用程序概述：Java源代码
- en: We’ll move on to a real example now, with a simple Java Spring Boot application
    that we’ll build and run using Docker. You don’t need to be a Java developer or
    have any Java tools installed on your machine to use this app; everything you
    need will come in Docker images. If you don’t work with Java, you should still
    read through this section--it describes a pattern that works for other compiled
    languages like .NET Core and Erlang.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将转向一个真实示例，我们将使用Docker构建和运行一个简单的Java Spring Boot应用程序。您不需要是Java开发者或在其机器上安装任何Java工具即可使用此应用程序；您所需的一切都将包含在Docker镜像中。如果您不使用Java，您也应该阅读本节内容——它描述了一个适用于其他编译语言（如.NET
    Core和Erlang）的模式。
- en: 'The source code is in the repository for the book, at the folder path `ch04/
    exercises/image-of-the-day` . The application uses a fairly standard set of tools
    for Java: Maven, which is used to define the build process and fetch dependencies,
    and OpenJDK, which is a freely distributable Java runtime and developer kit. Maven
    uses an XML format to describe the build, and the Maven command line is called
    `mvn` . That should be enough information to make sense of the application Dockerfile
    in listing 4.2.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码位于本书的仓库中，路径为 `ch04/ exercises/image-of-the-day` 。应用程序使用了一套相当标准的Java工具：Maven，用于定义构建过程和获取依赖项，以及OpenJDK，它是一个可自由分发的Java运行时和开发工具包。Maven使用XML格式来描述构建，Maven命令行称为
    `mvn` 。这些信息应该足以理解列表4.2中的应用程序Dockerfile。
- en: Listing 4.2 Dockerfile for building a Java app with Maven
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 使用Maven构建Java应用程序的Dockerfile
- en: '` FROM diamol/maven AS builder`  ` WORKDIR /usr/src/iotd` ` COPY pom.xml .`
    ` RUN mvn -B dependency:go-offline`  ` COPY . .` ` RUN mvn package`  ` # app`
    ` FROM diamol/openjdk`  ` WORKDIR /app` ` COPY --from=builder /usr/src/iotd/target/iotd-service-0.1.0.jar
    .`  ` EXPOSE 80` ` ENTRYPOINT ["java", "-jar", "/app/iotd-service-0.1.0.jar"]`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '` FROM diamol/maven AS builder`  ` WORKDIR /usr/src/iotd` ` COPY pom.xml .`
    ` RUN mvn -B dependency:go-offline`  ` COPY . .` ` RUN mvn package`  ` # app`
    ` FROM diamol/openjdk`  ` WORKDIR /app` ` COPY --from=builder /usr/src/iotd/target/iotd-service-0.1.0.jar
    .`  ` EXPOSE 80` ` ENTRYPOINT ["java", "-jar", "/app/iotd-service-0.1.0.jar"]`'
- en: Almost all the Dockerfile instructions here are ones you’ve seen before, and
    the patterns are familiar from examples that you’ve built. It’s a multi-stage
    Dockerfile, which you can tell because there’s more than one `FROM` instruction,
    and the steps are laid out to get maximum benefit from Docker’s image layer cache.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的大多数Dockerfile指令都是您之前见过的，模式与您构建的示例相似。这是一个多阶段Dockerfile，您可以通过存在多个 `FROM` 指令来判断，步骤安排旨在从Docker的镜像层缓存中获得最大效益。
- en: 'The first stage is called `builder` . Here’s what happens in the builder stage:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个阶段被称为 `builder` 。以下是构建阶段发生的情况：
- en: It uses the `diamol/maven` image as the base. That image has the OpenJDK Java
    development kit installed, as well as the Maven build tool.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用 `diamol/maven` 镜像作为基础。该镜像已安装了OpenJDK Java开发套件以及Maven构建工具。
- en: The builder stage starts by creating a working directory in the image and then
    copying in the `pom.xml` file, which is the Maven definition of the Java build.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建阶段的开始是在镜像中创建一个工作目录，然后复制进 `pom.xml` 文件，这是Maven对Java构建的定义。
- en: The first `RUN` statement executes a Maven command, fetching all the application
    dependencies. This is an expensive operation, so it has its own step to make use
    of Docker layer caching. If there are new dependencies, the XML file will change
    and the step will run. If the dependencies haven’t changed, the layer cache is
    used.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个 `RUN` 语句执行Maven命令，获取所有应用程序依赖项。这是一个昂贵的操作，因此它有自己的步骤来利用Docker层缓存。如果有新的依赖项，XML文件将发生变化，该步骤将运行。如果依赖项没有变化，则使用层缓存。
- en: Next the rest of the source code is copied in-- `COPY` `.` `.` means “copy all
    files and directories from the location where the Docker build is running, into
    the working directory in the image.”
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，将剩余的源代码复制进来-- `COPY` `.` `.` 表示“从Docker构建运行的位置，将所有文件和目录复制到镜像中的工作目录。”
- en: The last step of the builder is to run `mvn` `package` , which compiles and
    packages the application. The input is a set of Java source code files, and the
    output is a Java application package called a JAR file.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建阶段的最后一步是运行 `mvn` `package` ，它编译并打包应用程序。输入是一组Java源代码文件，输出是一个名为JAR文件的Java应用程序包。
- en: When this stage completes, the compiled application will exist in the builder
    stage filesystem. If there are any problems with the Maven build--if the network
    is offline and fetching dependencies fails, or if there is a coding error in the
    source--the `RUN` instruction will fail, and the whole build fails.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个阶段完成后，编译的应用程序将存在于构建阶段的文件系统中。如果Maven构建过程中出现任何问题--如果网络离线且获取依赖项失败，或者源代码中存在编码错误--`RUN`
    指令将失败，整个构建将失败。
- en: 'If the builder stage completes successfully, Docker goes on to execute the
    final stage, which produces the application image:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建阶段成功完成，Docker将继续执行最终阶段，该阶段生成应用程序镜像：
- en: It starts from `diamol/openjdk` , which is packaged with the Java 11 runtime,
    but none of the Maven build tools.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从 `diamol/openjdk` 开始，该镜像包含Java 11运行时，但没有Maven构建工具。
- en: This stage creates a working directory and copies in the compiled JAR file from
    the builder stage. Maven packages the application and all its Java dependencies
    in this single JAR file, so this is all that’s needed from the builder.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个阶段创建了一个工作目录，并将构建阶段的编译JAR文件复制进来。Maven将应用程序及其所有Java依赖项打包在这个单一的JAR文件中，因此从构建阶段只需要这个。
- en: The application is a web server that listens on port 80, so that port is explicitly
    listed in the `EXPOSE` instruction, which tells Docker that this port can be published.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该应用程序是一个监听80端口的网络服务器，因此该端口在 `EXPOSE` 指令中明确列出，告诉Docker该端口可以被发布。
- en: The `ENTRYPOINT` instruction is an alternative to the `CMD` instruction--it
    tells Docker what to do when a container is started from the image, in this case
    running Java with the path to the application JAR.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT` 指令是 `CMD` 指令的替代方案--它告诉Docker从镜像启动容器时要做什么，在这种情况下是运行Java并指定应用程序JAR的路径。'
- en: 'Try it now Browse to the Java application source code and build the image:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 浏览到Java应用程序源代码并构建镜像：
- en: '` cd ch04/exercises/image-of-the-day` ` docker image build -t image-of-the-day
    .`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ch04/exercises/image-of-the-day` ` docker image build -t image-of-the-day
    .`'
- en: There’s a lot of output from this build because you’ll see all the logs from
    Maven, fetching dependencies, and running through the Java build. Figure 4.5 shows
    an abbreviated section of my build.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你会看到Maven的所有日志、获取依赖项以及Java构建过程中的日志，所以这个构建过程会产生大量的输出。图4.5显示了构建过程的简略部分。
- en: '![](../Images/4-5.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-5.jpg)'
- en: Figure 4.5 Output from running a Maven build in Docker
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 在Docker中运行Maven构建的输出
- en: So what have you just built? It’s a simple REST API that wraps access to NASA’s
    Astronomy Picture of the Day service ( *[https://apod.nasa.gov](https://apod.nasa.gov)*
    ). The Java app fetches the details of today’s picture from NASA and caches it,
    so you can make repeated calls to this application without repeatedly hitting
    NASA’s service.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚构建了什么？这是一个简单的REST API，它封装了对NASA天文图片每日服务的访问（*[https://apod.nasa.gov](https://apod.nasa.gov)*）。Java应用程序从NASA获取当天图片的详细信息并将其缓存，这样你就可以重复调用此应用程序，而无需反复调用NASA的服务。
- en: The Java API is just one part of the full application you’ll be running in this
    chapter--it will actually use multiple containers, and they need to communicate
    with each other. Containers access each other across a virtual network, using
    the virtual IP address that Docker allocates when it creates the container. You
    can create and manage virtual Docker networks through the command line.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Java API只是你将在本章中运行的全应用程序的一部分——它实际上会使用多个容器，并且它们需要相互通信。容器通过虚拟网络访问彼此，使用Docker在创建容器时分配的虚拟IP地址。你可以通过命令行创建和管理虚拟Docker网络。
- en: 'Try it now Create a Docker network for containers to communicate with each
    other:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：为容器创建一个Docker网络以进行通信：
- en: '` docker network create nat`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker network create nat`'
- en: If you see an error from that command, it’s because your setup already has a
    Docker network called `nat` , and you can ignore the message. Now when you run
    containers you can explicitly connect them to that Docker network using the `--network`
    flag, and any containers on that network can reach each other using the container
    names.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到该命令的错误，那是因为你的设置已经有一个名为`nat`的Docker网络，你可以忽略该消息。现在，当你运行容器时，你可以使用`--network`标志显式地将它们连接到该Docker网络，并且该网络上的任何容器都可以通过容器名称相互访问。
- en: 'Try it now Run a container from the image, publishing port 80 to the host computer,
    and connecting to the `nat` network:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：从图像运行一个容器，将端口80发布到主机计算机，并连接到`nat`网络：
- en: '` docker container run --name iotd -d -p 800:80 --network nat image-of-the-day`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker container run --name iotd -d -p 800:80 --network nat image-of-the-day`'
- en: Now you can browse to http:/ /localhost:800/image and you’ll see some JSON details
    about NASA’s image of the day. On the day I ran the container, the image was from
    a solar eclipse--figure 4.6 shows the details from my API.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以浏览到 http:/ /localhost:800/image，你将看到关于NASA每日图像的一些JSON详细信息。在我运行容器的那天，图像来自日食——图4.6显示了从我API获取的细节。
- en: '![](../Images/4-6.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-6.jpg)'
- en: Figure 4.6 The cached details from NASA in my application container
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 我的应用程序容器中从NASA缓存的详细信息
- en: The actual application in this container isn’t important (but don’t remove it
    yet--we’ll be using it later in the chapter). What’s important is that you can
    build this on any machine with Docker installed, just by having a copy of the
    source code with the Dockerfile. You don’t need any build tools installed, you
    don’t need a specific version of Java--you just clone the code repo, and you’re
    a couple of Docker commands away from running the app.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 容器中的实际应用程序并不重要（但不要现在就删除它——我们将在本章后面使用它）。重要的是，你可以在安装了Docker的任何机器上构建它，只需有一个包含Dockerfile的源代码副本。你不需要安装任何构建工具，也不需要特定的Java版本——你只需克隆代码仓库，然后通过几个Docker命令就可以运行应用程序。
- en: 'One other thing to be really clear on here: the build tools are not part of
    the final application image. You can run an interactive container from your new
    `image-of-the-day` Docker image, and you’ll find there’s no `mvn` command in there.
    Only the contents of the final stage in the Dockerfile get made into the application
    image; anything you want from previous stages needs to be explicitly copied in
    that final stage.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有另一件需要非常清楚的事情：构建工具不是最终应用程序图像的一部分。你可以从新的`image-of-the-day` Docker图像中运行一个交互式容器，你会发现里面没有`mvn`命令。只有Dockerfile中的最终阶段的全部内容被制作成应用程序图像；任何你想要从之前阶段的内容都需要在最终阶段显式复制。
- en: '4.3 App walkthrough: Node.js source code'
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 应用程序概述：Node.js 源代码
- en: We’re going to go through another multi-stage Dockerfile, this time for a Node.js
    application. Organizations are increasingly using diverse technology stacks, so
    it’s good to have an understanding of how different builds look in Docker. Node.js
    is a great option because of its popularity, and also because it’s an example
    of a different type of build--this pattern also works with other scripted languages
    like Python, PHP, and Ruby. The source code for this app is at the folder path
    `ch04/exercises/ access-log` .
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次通过一个多阶段 Dockerfile 进行操作，这次是为一个 Node.js 应用程序。随着组织越来越多地使用多样化的技术栈，了解不同构建在
    Docker 中的样子是很有帮助的。Node.js 是一个很好的选择，因为它很受欢迎，而且它也是一个不同类型构建的例子——这种模式也适用于其他脚本语言，如
    Python、PHP 和 Ruby。这个应用的源代码位于文件夹路径 `ch04/exercises/access-log` 中。
- en: Java applications are compiled, so the source code gets copied into the build
    stage, and that generates a JAR file. The JAR file is the compiled app, and it
    gets copied into the final application image, but the source code is not. It’s
    the same with .NET Core, where the compiled artifacts are DLLs (Dynamic Link Libraries).
    Node.js is different--it uses JavaScript, which is an interpreted language, so
    there’s no compilation step. Dockerized Node.js apps need the Node.js runtime
    and the source code in the application image.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Java 应用程序是编译的，因此源代码被复制到构建阶段，从而生成一个 JAR 文件。JAR 文件是编译后的应用程序，它被复制到最终应用程序镜像中，但源代码不是。.NET
    Core 也是如此，编译后的工件是 DLL（动态链接库）。Node.js 不同，它使用 JavaScript，这是一种解释型语言，因此没有编译步骤。Docker
    化的 Node.js 应用程序需要在应用程序镜像中包含 Node.js 运行时和源代码。
- en: 'There’s still a need for a multi-stage Dockerfile though: it optimizes dependency
    loading. Node.js uses a tool called npm (the Node package manager) to manage dependencies.
    Listing 4.3 shows the full Dockerfile for this chapter’s Node.js application.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，仍然需要一个多阶段 Dockerfile：它优化了依赖项加载。Node.js 使用一个名为 npm（Node 包管理器）的工具来管理依赖项。列表
    4.3 显示了本章 Node.js 应用程序的完整 Dockerfile。
- en: Listing 4.3 Dockerfile for building a Node.js app with npm
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 构建 Node.js 应用程序的 npm Dockerfile
- en: '` FROM diamol/node AS builder`  ` WORKDIR /src` ` COPY src/package.json .`
     ` RUN npm install`  ` # app` ` FROM diamol/node`  ` EXPOSE 80` ` CMD ["node",
    "server.js"]`  ` WORKDIR /app` ` COPY --from=builder /src/node_modules/ /app/node_modules/`
    ` COPY src/ .`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '` FROM diamol/node AS builder`  ` WORKDIR /src` ` COPY src/package.json .`
     ` RUN npm install`  ` # app` ` FROM diamol/node`  ` EXPOSE 80` ` CMD ["node",
    "server.js"]`  ` WORKDIR /app` ` COPY --from=builder /src/node_modules/ /app/node_modules/`
    ` COPY src/ .`'
- en: The goal here is the same as for the Java application--to package and run the
    app with only Docker installed, without having to install any other tools. The
    base image for both stages is `diamol/node` , which has the Node.js runtime and
    npm installed. The builder stage in the Dockerfile copies in the `package.json`
    files, which describe all the application’s dependencies. Then it runs `npm` `install`
    to download the dependencies. There’s no compilation, so that’s all it needs to
    do.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标与 Java 应用程序相同——仅通过安装 Docker 来打包和运行应用程序，而无需安装任何其他工具。两个阶段的基镜像都是 `diamol/node`，其中包含
    Node.js 运行时和 npm。Dockerfile 中的构建阶段会复制 `package.json` 文件，这些文件描述了应用程序的所有依赖项。然后它运行
    `npm install` 来下载依赖项。因为没有编译，所以它只需要做这些。
- en: This application is another REST API. In the final application stage, the steps
    expose the HTTP port and specify the `node` command line as the startup command.
    The last thing is to create a working directory and copy in the application artifacts.
    The downloaded dependencies are copied from the builder stage, and the source
    code is copied from the host computer. The `src` folder contains the JavaScript
    files, including `server.js` , which is the entry point started by the Node.js
    process.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序是另一个 REST API。在最终应用程序阶段，步骤会公开 HTTP 端口并指定 `node` 命令行作为启动命令。最后一件事情是创建一个工作目录并复制应用程序工件。下载的依赖项从构建阶段复制，源代码从主机计算机复制。`src`
    文件夹包含 JavaScript 文件，包括 `server.js`，这是由 Node.js 进程启动的入口点。
- en: We have a different technology stack here, with a different pattern for packaging
    the application. The base images, tools, and commands for a Node.js app are all
    different from a Java app, but those differences are captured in the Dockerfile.
    The process for building and running the app is exactly the same.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有一个不同的技术栈，有一个不同的应用程序打包模式。Node.js 应用程序的基镜像、工具和命令都与 Java 应用程序不同，但这些差异都记录在
    Dockerfile 中。构建和运行应用程序的过程完全相同。
- en: 'Try it now Browse to the Node.js application source code and build the image:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：浏览到 Node.js 应用程序源代码并构建镜像：
- en: '` cd ch04/exercises/access-log` ` docker image build -t access-log .`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ch04/exercises/access-log` ` docker image build -t access-log .`'
- en: You’ll see a whole lot of output from npm (which may show some error and warning
    messages too, but you can ignore those). Figure 4.7 shows part of the output from
    my build. The packages that are downloaded get saved in the Docker image layer
    cache, so if you work on the app and just make code changes, the next build you
    run will be super fast.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到很多来自npm的输出（也可能显示一些错误和警告消息，但你可以忽略那些）。图4.7显示了我构建的部分输出。下载的包被保存在Docker镜像层缓存中，所以如果你只对应用程序进行代码更改，下一次构建将非常快。
- en: '![](../Images/4-7.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-7.jpg)'
- en: Figure 4.7 Building a multi-stage Dockerfile for a Node.js application
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 为Node.js应用程序构建多阶段Dockerfile
- en: The Node.js app you’ve just built is not at all interesting, but you should
    still run it to check that it’s packaged correctly. It’s a REST API that other
    services can call to write logs. There’s an HTTP `POST` endpoint for recording
    a new log, and a `GET` endpoint that shows how many logs have been recorded.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚构建的Node.js应用程序并不有趣，但你仍然应该运行它以检查它是否正确打包。它是一个REST API，其他服务可以调用它来记录日志。有一个HTTP
    `POST`端点用于记录新的日志，还有一个`GET`端点显示已记录的日志数量。
- en: 'Try it now Run a container from the log API image, publishing port 80 to host
    and connecting it to the same `nat` network:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 运行来自日志API镜像的容器，将端口80发布到主机，并将其连接到相同的`nat`网络：
- en: '` docker container run --name accesslog -d -p 801:80 --network nat access-log`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker container run --name accesslog -d -p 801:80 --network nat access-log`'
- en: Now browse to http:/ /localhost:801/stats and you’ll see how many logs the service
    has recorded. Figure 4.8 shows I have zero logs so far--Firefox nicely formats
    the API response, but you may see the raw JSON in other browsers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，浏览到http:/ /localhost:801/stats，你会看到服务已记录了多少日志。图4.8显示我目前还没有日志——Firefox很好地格式化了API响应，但你在其他浏览器中可能会看到原始的JSON。
- en: '![](../Images/4-8.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-8.jpg)'
- en: Figure 4.8 Running the Node.js API in a container
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 在容器中运行Node.js API
- en: The log API is running in Node.js version 10.16, but just like with the Java
    example, you don’t need any versions of Node.js or any other tools installed to
    build and run this app. The workflow in this Dockerfile downloads dependencies
    and then copies the script files into the final image. You can use the exact same
    approach with Python, using Pip for dependencies, or Ruby using Gems.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 日志API正在运行在Node.js版本10.16，但就像Java示例一样，你不需要安装任何版本的Node.js或其他工具来构建和运行此应用程序。在这个Dockerfile中的工作流程首先下载依赖项，然后将脚本文件复制到最终镜像中。你可以使用与Python相同的精确方法，使用Pip进行依赖项，或者使用Ruby使用Gems。
- en: '4.4 App walkthrough: Go source code'
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 应用程序概述：Go源代码
- en: We’ve got one last example of a multi-stage Dockerfile--for a web application
    written in Go. Go is a modern, cross-platform language that compiles to native
    binaries. That means you can compile your apps to run on any platform (Windows,
    Linux, Intel, or Arm), and the compiled output is the complete application. You
    don’t need a separate runtime installed like you do with Java, .NET Core, Node.js,
    or Python, and that makes for extremely small Docker images.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个多阶段Dockerfile的最后一个示例——用于用Go编写的Web应用程序。Go是一种现代、跨平台的编程语言，可以编译成原生二进制文件。这意味着你可以将你的应用程序编译成在任何平台上运行（Windows、Linux、Intel或Arm），编译后的输出是完整的应用程序。你不需要像Java、.NET
    Core、Node.js或Python那样安装单独的运行时，这使得Docker镜像非常小。
- en: There are a few other languages that also compile to native binaries--Rust and
    Swift are popular--but Go has the widest platform support, and it’s also a very
    popular language for cloud-native apps (Docker itself is written in Go). Building
    Go apps in Docker means using a multi-stage Dockerfile approach similar to the
    one you used for the Java app, but there are some important differences. Listing
    4.4 shows the full Dockerfile.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几种其他语言也可以编译成原生二进制文件——Rust和Swift很受欢迎——但Go具有最广泛的平台支持，它也是云原生应用程序（Docker本身是用Go编写的）非常流行的语言。在Docker中构建Go应用程序意味着使用类似于你为Java应用程序使用的方法的多阶段Dockerfile方法，但有一些重要的区别。列表4.4显示了完整的Dockerfile。
- en: Listing 4.4 Dockerfile for building a Go application from source
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4 从源代码构建Go应用程序的Dockerfile
- en: '` FROM diamol/golang AS builder` ` COPY main.go .`  ` RUN go build -o /server`
     ` # app` ` FROM diamol/base`  ` ENV IMAGE_API_URL="http://iotd/image" \` `       ACCESS_API_URL="http://accesslog/access-log"`
    ` CMD ["/web/server"]`  ` WORKDIR web` ` COPY index.html .` ` COPY --from=builder
    /server .` ` RUN chmod +x server`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '` FROM diamol/golang AS builder` ` COPY main.go .`  ` RUN go build -o /server`
     ` # app` ` FROM diamol/base` ` ENV IMAGE_API_URL="http://iotd/image" \` `       ACCESS_API_URL="http://accesslog/access-log"`
    ` CMD ["/web/server"]`  ` WORKDIR web` ` COPY index.html .` ` COPY --from=builder
    /server .` ` RUN chmod +x server`'
- en: Go compiles to native binaries, so each stage in the Dockerfile uses a different
    base image. The builder stage uses `diamol/golang` , which has all the Go tools
    installed. Go applications don’t usually fetch dependencies, so this stage goes
    straight to building the application (which is just one code file, `main.go` ).
    The final application stage uses a minimal image, which just has the smallest
    layer of operating system tools, called `diamol/base` .
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Go编译成原生二进制文件，所以Dockerfile中的每个阶段都使用不同的基础镜像。构建阶段使用`diamol/golang`，其中安装了所有Go工具。Go应用程序通常不会获取依赖项，所以这个阶段直接构建应用程序（这只是一个代码文件，`main.go`）。最终的应用程序阶段使用最小镜像，它只包含最小的操作系统工具层，称为`diamol/base`。
- en: The Dockerfile captures some configuration settings as environment variables
    and specifies the startup command as the compiled binary. The application stage
    ends by copying in the HTML file the application serves from the host and the
    web server binary from the builder stage. Binaries need to be explicitly marked
    as executable in Linux, which is what the final `chmod` command does (this has
    no effect on Windows).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile捕获了一些配置设置作为环境变量，并指定启动命令为编译的二进制文件。应用程序阶段通过从主机复制应用程序所服务的HTML文件和构建阶段的Web服务器二进制文件结束。在Linux中，需要显式标记二进制文件为可执行，这就是最终`chmod`命令的作用（在Windows上没有影响）。
- en: 'Try it now Browse to the Go application source code and build the image:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 浏览到Go应用程序源代码并构建镜像：
- en: '` cd ch04/exercises/image-gallery` ` docker image build -t image-gallery .`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '` cd ch04/exercises/image-gallery` ` docker image build -t image-gallery .`'
- en: This time there won’t be a lot of compiler output, because Go is quiet and only
    writes logs when there are failures. You can see my abbreviated output in figure
    4.9.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这次编译输出不会很多，因为Go很安静，只有在失败时才写入日志。你可以在图4.9中看到我的简略输出。
- en: '![](../Images/4-9.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4-9.jpg)'
- en: Figure 4.9 Building a Go application in a multi-stage Dockerfile
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 在多阶段Dockerfile中构建Go应用程序
- en: This Go application does do something useful, but before you run it, it’s worth
    taking a look at the size of the images that go in and come out.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Go应用程序确实做了些有用的事情，但在运行它之前，看看输入和输出的镜像大小是值得的。
- en: 'Try it now Compare the Go application image size with the Go toolset image:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 比较Go应用程序镜像大小与Go工具集镜像：
- en: '` docker image ls -f reference=diamol/golang -f reference=image-gallery`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '` docker image ls -f reference=diamol/golang -f reference=image-gallery`'
- en: 'Many Docker commands let you filter the output. This command lists all images
    and filters the output to only include images with a reference of `diamol/golang`
    or `image-gallery` --the reference is really just the image name. When you run
    this, you’ll see how important it is to choose the right base images for your
    Dockerfile stages:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Docker命令允许您过滤输出。此命令列出所有镜像，并过滤输出以仅包括具有`diamol/golang`或`image-gallery`引用的镜像——引用实际上只是镜像名称。当你运行这个命令时，你会看到选择正确的Dockerfile阶段的基础镜像是多么重要：
- en: '` REPOSITORY TAG IMAGE ID CREATED SIZE` ` image-gallery latest b41869f5d153
    20 minutes ago 25.3MB` ` diamol/golang latest ad57f5c226fc 2 hours ago 774MB`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '` REPOSITORY TAG IMAGE ID CREATED SIZE` ` image-gallery latest b41869f5d153
    20 minutes ago 25.3MB` ` diamol/golang latest ad57f5c226fc 2 hours ago 774MB`'
- en: On Linux, the image with all the Go tools installed comes in at over 770 MB;
    the actual Go application image is only 25 MB. Remember, that’s the virtual image
    size, so a lot of those layers can be shared between different images. The important
    saving isn’t so much the disk space, but all the software that isn’t in the final
    image. The application doesn’t need any of the Go tools at runtime. By using a
    minimal base image for the application, we’re saving nearly 750 MB of software,
    which is a huge reduction in the surface area for potential attacks.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，安装了所有Go工具的镜像大小超过770MB；实际的Go应用程序镜像仅为25MB。记住，这是虚拟镜像大小，所以很多层可以在不同的镜像之间共享。重要的节省并不是磁盘空间，而是最终镜像中不包含的所有软件。应用程序在运行时不需要任何Go工具。通过为应用程序使用最小的基础镜像，我们节省了近750MB的软件，这大大减少了潜在攻击的表面积。
- en: Now you can run the app. This ties together your work in this chapter, because
    the Go application actually uses the APIs from the other applications you’ve built.
    You should make sure you have those containers running, with the correct names
    from the earlier try-it-now exercises. If you run `docker` `container` `ls` ,
    you should see two containers from this chapter--the Node.js container called
    `accesslog` and the Java container called `iotd` . When you run the Go container,
    it will use the APIs from the other containers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行应用程序了。这总结了本章的工作，因为 Go 应用程序实际上使用了你构建的其他应用程序的 API。你应该确保那些容器正在运行，并且具有之前“尝试一下”练习中正确的名称。如果你运行
    `docker container ls`，你应该看到本章的两个容器--名为 `accesslog` 的 Node.js 容器和名为 `iotd` 的 Java
    容器。当你运行 Go 容器时，它将使用其他容器的 API。
- en: 'Try it now Run the Go application image, publishing the host port and connecting
    to the `nat` network:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 运行 Go 应用程序镜像，发布主机端口并连接到 `nat` 网络：
- en: '`docker container run -d -p 802:80 --network nat image-gallery`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container run -d -p 802:80 --network nat image-gallery`'
- en: 'You can browse to http: */ / localhost:802* and you’ll see NASA’s Astronomy
    Picture of the Day. Figure 4.10 shows the image when I ran my containers.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以浏览到 http://localhost:802/ 并看到 NASA 的每日天文图片。图 4.10 显示了我运行容器时的图像。
- en: '![](../Images/4-10.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/4-10.jpg)'
- en: Figure 4.10 The Go web application, showing data fetched from the Java API
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 Go 网络应用程序，显示从 Java API 获取的数据
- en: Right now you’re running a distributed application across three containers.
    The Go web application calls the Java API to get details of the image to show,
    and then it calls the Node.js API to log that the site has been accessed. You
    didn’t need to install any tools for any of those languages to build and run all
    the apps; you just needed the source code and Docker.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 目前你正在三个容器中运行一个分布式应用程序。Go 网络应用程序调用 Java API 获取要显示的图像详情，然后调用 Node.js API 记录网站已被访问。你不需要为这些语言中的任何一种安装任何工具来构建和运行所有应用程序；你只需要源代码和
    Docker。
- en: Multi-stage Dockerfiles make your project entirely portable. You might use Jenkins
    to build your apps right now, but you could try AppVeyor’s managed CI service
    or Azure DevOps without having to write any new pipeline code--they all support
    Docker, so your pipeline is just `docker` `image` `build` .
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段 Dockerfile 使你的项目完全可移植。你可能现在使用 Jenkins 来构建应用程序，但你可以尝试 AppVeyor 的托管 CI 服务或
    Azure DevOps，而无需编写任何新的管道代码--它们都支持 Docker，所以你的管道只是 `docker image build`。
- en: 4.5 Understanding multi-stage Dockerfiles
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 理解多阶段 Dockerfile
- en: We’ve covered a lot of ground in this chapter, and I’m going to end with some
    key points so you’re really clear on how multi-stage Dockerfiles work, and why
    it’s incredibly useful to build your apps inside containers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们覆盖了很多内容，我将以一些关键点结束，以便你真正清楚地了解多阶段 Dockerfile 的工作原理，以及为什么在容器内构建应用程序非常有用。
- en: The first point is about standardization. I know when you run the exercises
    for this chapter that your builds will succeed and your apps will work because
    you’re using the exact same set of tools that I’m using. It doesn’t matter what
    operating system you have or what’s installed on your machine--all the builds
    run in Docker containers, and the container images have all the correct versions
    of the tools. In your real projects you’ll find that this hugely simplifies on-boarding
    for new developers, eliminates the maintenance burden for build servers, and removes
    the potential for breakages where users have different versions of tools.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点是关于标准化。我知道当你运行本章的练习时，你的构建将成功，你的应用程序将工作，因为你正在使用与我完全相同的工具集。无论你有什么操作系统或你的机器上安装了什么，所有构建都在
    Docker 容器中运行，容器镜像都包含所有正确版本的工具。在你的真实项目中，你会发现这极大地简化了新开发者的入职流程，消除了构建服务器的维护负担，并消除了用户拥有不同版本工具时可能出现的故障风险。
- en: The second point is performance. Each stage in a multi-stage build has its own
    cache. Docker looks for a match in the image layer cache for each instruction;
    if it doesn’t find one, the cache is broken and all the rest of the instructions
    are executed--but only for that stage. The next stage starts again from the cache.
    You’ll be spending time structuring your Dockerfiles carefully, and when you get
    the optimization done, you’ll find 90% of your build steps use the cache.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点是性能。多阶段构建中的每个阶段都有自己的缓存。Docker 在每个指令中都会在镜像层缓存中寻找匹配项；如果没有找到，缓存就会损坏，并且所有其余的指令都会执行--但仅限于该阶段。下一个阶段将从缓存重新开始。你将花费时间仔细构建你的
    Dockerfile，当你完成优化后，你会发现 90% 的构建步骤都使用了缓存。
- en: The final point is that multi-stage Dockerfiles let you fine-tune your build
    so the final application image is as lean as possible. This is not just for compilers--any
    tooling you need can be isolated in earlier stages, so the tool itself isn’t present
    in the final image. A good example is curl--a popular command-line tool you can
    use for downloading content from the internet. You might need that to download
    files your app needs, but you can do that in an early stage in your Dockerfile
    so curl itself isn’t installed in your application image. This keeps image size
    down, which means faster startup times, but it also means you have less software
    available in your application image, which means fewer potential exploits for
    attackers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点是，多阶段Dockerfile让你可以精细调整构建过程，使得最终的应用程序镜像尽可能精简。这不仅仅适用于编译器——你需要的任何工具都可以在早期阶段进行隔离，因此工具本身不会出现在最终镜像中。一个很好的例子是curl——一个流行的命令行工具，你可以用它从互联网上下载内容。你可能需要它来下载你的应用程序需要的文件，但你可以在Dockerfile的早期阶段完成这个操作，这样curl本身就不会安装在你的应用程序镜像中。这有助于减小镜像大小，意味着更快的启动时间，但也意味着你的应用程序镜像中可用的软件更少，这意味着攻击者有更少的潜在漏洞可以利用。
- en: 4.6 Lab
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 实验室
- en: Lab time! You’re going to put into practice what you’ve learned about multi-stage
    builds and optimizing Dockerfiles. In the source code for the book, you’ll find
    a folder at `ch04/lab` which is your starting point. It’s a simple Go web server
    application, which already has a Dockerfile, so you can build and run it in Docker.
    But the Dockerfile is in dire need of optimizing, and that is your job.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 实验时间！你将把关于多阶段构建和优化Dockerfile所学的知识付诸实践。在本书的源代码中，你会在`ch04/lab`文件夹中找到一个起点。这是一个简单的Go网络服务器应用程序，它已经有一个Dockerfile，因此你可以在Docker中构建和运行它。但Dockerfile急需优化，这就是你的任务。
- en: 'There are specific goals for this lab:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本实验有具体的目标：
- en: Start by building an image using the existing Dockerfile, and then optimize
    the Dockerfile to produce a new image.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，使用现有的Dockerfile构建一个镜像，然后优化Dockerfile以生成一个新的镜像。
- en: The current image is 800 MB on Linux and 5.2 GB on Windows. Your optimized image
    should be around 15 MB on Linux or 260 MB on Windows.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前在Linux上的图像大小为800 MB，在Windows上为5.2 GB。你的优化图像在Linux上应约为15 MB，在Windows上约为260
    MB。
- en: If you change the HTML content with the current Dockerfile, the build executes
    seven steps.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用当前的Dockerfile更改HTML内容，构建将执行七个步骤。
- en: Your optimized Dockerfile should only execute a single step when you change
    the HTML.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你更改HTML时，你的优化Dockerfile应只执行一个步骤。
- en: 'As always, there’s a sample solution on the book’s GitHub repository. But this
    is one lab you should really try and find time to do, because optimizing Dockerfiles
    is a valuable skill you’ll use in every project. If you need it, though, my solution
    is here: *[https://github.com/sixeyed/diamol/blob/master/ch04/lab/Dockerfile.optimized](https://github.com/sixeyed/diamol/blob/master/ch04/lab/Dockerfile.optimized)*
    .'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，在本书的GitHub仓库中有一个示例解决方案。但这是一个你应该真正尝试并找到时间做的实验，因为优化Dockerfile是一项非常有价值的技能，你将在每个项目中使用它。不过，如果你需要，我的解决方案在这里：*[https://github.com/sixeyed/diamol/blob/master/ch04/lab/Dockerfile.optimized](https://github.com/sixeyed/diamol/blob/master/ch04/lab/Dockerfile.optimized)*。
- en: No hints this time, although I would say this sample app looks very similar
    to one you’ve already built in this chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这次没有提示，尽管我会说这个示例应用程序看起来非常类似于你在本章中已经构建的一个。
