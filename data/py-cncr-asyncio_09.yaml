- en: 9 Web applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 Web 应用程序
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Creating web applications with aiohttp
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 aiohttp 创建 Web 应用程序
- en: The asynchronous server gateway interface (ASGI)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步服务器网关接口（ASGI）
- en: Creating ASGI web applications with Starlette
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Starlette 创建 ASGI Web 应用程序
- en: Using Django’s asynchronous views
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Django 的异步视图
- en: Web applications power most of the sites we use on the internet today. If you’ve
    worked as a developer for a company with an internet presence, you’ve likely worked
    on a web application at some point in your career. In the world of synchronous
    Python, this means you’ve used frameworks such as Flask, Bottle, or the extremely
    popular Django. With the exception of more recent versions of Django, these web
    frameworks were not built to work with asyncio out of the box. As such, when our
    web applications perform work that could be parallelized, such as querying a database
    or making calls to other APIs, we don’t have options outside of multithreading
    or multiprocessing. This means that we’ll need to explore new frameworks that
    are compatible with asyncio.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用程序为我们在互联网上使用的绝大多数网站提供动力。如果你曾作为拥有互联网存在感的公司的开发者工作，你可能在你的职业生涯中某个时刻参与过 Web
    应用程序的开发。在同步 Python 的世界中，这意味着你使用过 Flask、Bottle 或极其流行的 Django 等框架。除了 Django 的较新版本之外，这些
    Web 框架并不是为了与 asyncio 无缝工作而构建的。因此，当我们的 Web 应用程序执行可以并行化的工作，例如查询数据库或调用其他 API 时，我们除了多线程或多进程之外没有其他选择。这意味着我们需要探索与
    asyncio 兼容的新框架。
- en: In this chapter, we’ll learn about a few popular asyncio-ready web frameworks.
    We’ll first see how to use a framework we’ve already dealt with, aiohttp, to build
    async RESTful APIs. We’ll then learn about the asynchronous server gateway interface,
    or ASGI, which is the async replacement for the WSGI (web server gateway interface)
    and is how many web applications run. Using ASGI with Starlette, we’ll build a
    simple REST API with WebSocket support. We’ll also look at using Django’s asynchronous
    views. Performance of web applications is always a consideration when scaling,
    so we’ll also take a look at performance numbers by benchmarking with a load testing
    tool.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解一些流行的异步 Web 框架。我们首先将看到如何使用我们已经处理过的框架 aiohttp 来构建异步 RESTful API。然后，我们将了解异步服务器网关接口（ASGI），它是
    WSGI（Web 服务器网关接口）的异步替代品，也是许多 Web 应用程序运行的方式。使用 ASGI 和 Starlette，我们将构建一个简单的支持 WebSocket
    的 REST API。我们还将探讨使用 Django 的异步视图。在扩展时，Web 应用程序的性能始终是一个考虑因素，因此我们还将通过使用负载测试工具进行基准测试来查看性能数据。
- en: 9.1 Creating a REST API with aiohttp
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 使用 aiohttp 创建 REST API
- en: Previously, we used aiohttp as a HTTP client to make thousands of concurrent
    web requests to web applications. aiohttp has not only support as a HTTP client
    but also has functionality to create asyncio-ready web application servers as
    well.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用 aiohttp 作为 HTTP 客户端，向 Web 应用程序发送数千个并发 Web 请求。aiohttp 不仅支持作为 HTTP 客户端，还具有创建异步
    Web 应用程序服务器的功能。
- en: 9.1.1 What is REST?
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.1 什么是 REST？
- en: REST is an abbreviation for *representational state transfer*. It is a widely
    used paradigm in modern web application development, especially in conjunction
    with single-page applications with frameworks like React and Vue. REST provides
    us with a stateless, structured way to design our web APIs independently of client-side
    technology. A REST API should be able to interoperate with any number of clients
    from a mobile phone to a browser, and all that should need to change is the client-side
    presentation of the data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: REST 是 *表示状态转移* 的缩写。它是现代 Web 应用程序开发中广泛使用的一种范式，尤其是在与 React 和 Vue 等框架的单页应用程序结合使用时。REST
    为我们提供了一种无状态的、结构化的方式来设计我们的 Web API，而无需考虑客户端技术。REST API 应该能够与从手机到浏览器的任何数量的客户端进行交互，而且唯一需要改变的是数据在客户端的展示方式。
- en: 'The key concept in REST is a *resource*. A resource is typically anything that
    can be represented by a noun. For example, a customer, a product, or an account
    can be RESTful resources. The resources we just listed reference a single customer
    or product. Resources can also be collections, for example, “customers” or “products”
    that have singletons we can access by some unique identifier. Singletons may also
    have sub-resources. A customer could have a list of favorite products as an example.
    Let’s take a look at a couple of REST APIs to get a better understanding:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: REST中的关键概念是*资源*。资源通常是任何可以用名词表示的东西。例如，客户、产品或账户可以是RESTful资源。我们刚刚列出的资源引用单个客户或产品。资源也可以是集合，例如，“客户”或“产品”，我们可以通过某些唯一标识符访问这些集合的单例。单例也可能有子资源。例如，一个客户可能有一个喜欢的产品的列表。让我们看看几个REST
    API，以更好地理解：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have three REST API endpoints here. Our first endpoint, `customers`, references
    a collection of customers. As consumers of this API, we would expect this to return
    a list of customers (this may be paginated as it could potentially be a large
    set). Our second endpoint references a single customer and takes in an `id` as
    a parameter. If we uniquely identify customers with an integer ID, calling `customers/1`
    would give us data for the customer with an `id` of 1\. Our final endpoint is
    an example of a sub-entity. A customer could have a list of favorite products,
    making the list of favorites a sub-entity of a customer. Calling `customers/1/favorites`
    would return the list of favorites for the customer with `id` of 1.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有三个REST API端点。我们的第一个端点`customers`引用客户集合。作为此API的消费者，我们预计这将返回客户列表（这可能分页，因为它可能是一个大型集合）。我们的第二个端点引用单个客户，并接受一个`id`参数。如果我们用整数ID唯一标识客户，调用`customers/1`将给我们ID为1的客户的数据。我们的最后一个端点是一个子实体的例子。一个客户可能有一个喜欢的产品的列表，这使得喜欢列表成为客户的一个子实体。调用`customers/1/favorites`将返回ID为1的客户喜欢的列表。
- en: We’ll design our REST APIs going forward to return JSON as this is typical,
    though we could choose any format that suits our need. REST APIs can sometimes
    support multiple data representations through content negotiation via HTTP headers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计我们的REST API，使其返回JSON，因为这是典型的做法，尽管我们可以选择任何适合我们需求的格式。REST API有时可以通过HTTP头部的内容协商支持多种数据表示。
- en: While a proper look into all the details of REST is outside the scope of this
    book, the creator of REST’s PhD dissertation is a good place to learn about the
    concepts. It is available at [http://mng.bz/1jAg](http://mng.bz/1jAg).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对REST的所有细节进行深入研究超出了本书的范围，但REST的博士论文的作者是一个了解这些概念的好地方。它可在[http://mng.bz/1jAg](http://mng.bz/1jAg)找到。
- en: 9.1.2 aiohttp server basics
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.2 aiohttp服务器基础
- en: Let’s get started by creating a simple “hello world”-style API with aiohttp.
    We’ll start by creating a simple `GET` endpoint that will give us some basic data
    in JSON format about the time and date. We’ll call our endpoint `/time` and will
    expect it to return the month, day, and current time.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个简单的“hello world”风格的API，使用aiohttp。我们将从创建一个简单的`GET`端点开始，该端点将以JSON格式提供关于时间和日期的一些基本数据。我们将我们的端点命名为`/time`，并期望它返回月份、日期和当前时间。
- en: aiohttp provides web server functionality in the `web` module. Once we import
    this, we can define endpoints (called *routes* in aiohttp) with a `RouteTableDef`.
    A `RouteTableDef` provides a decorator that lets us specify a request type (`GET`,
    `POST`, etc.) and a string representing the endpoint name. We can then use the
    `RouteTableDef` decorator to decorate coroutines that will execute when we call
    that endpoint. Inside these decorated coroutines, we can perform whatever application
    logic we’d like and then return data to the client.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: aiohttp在`web`模块中提供了Web服务器功能。一旦我们导入这个模块，我们就可以使用`RouteTableDef`定义端点（在aiohttp中称为*路由*），`RouteTableDef`提供了一个装饰器，允许我们指定请求类型（`GET`、`POST`等）和表示端点名称的字符串。然后我们可以使用`RouteTableDef`装饰器来装饰当调用该端点时将执行的协程。在这些装饰的协程内部，我们可以执行我们想要的任何应用程序逻辑，然后向客户端返回数据。
- en: Creating these endpoints by themselves does nothing, however, and we still need
    to start the web application to serve the routes. We do this by first creating
    an `Application` instance, adding the routes from our `RouteTableDef` and running
    the application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 仅凭创建这些端点本身并不能起到任何作用，我们仍然需要启动Web应用程序来提供路由服务。我们通过首先创建一个`Application`实例，添加来自我们的`RouteTableDef`的路由，然后运行应用程序来实现这一点。
- en: Listing 9.1 The current time endpoint
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1 当前时间端点
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Create a time GET endpoint; when a client calls this endpoint, the time coroutine
    will run.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个时间 GET 端点；当客户端调用此端点时，时间协程将运行。
- en: ❷ Take the result dictionary, and turn it into a JSON response.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将结果字典转换为 JSON 响应。
- en: ❸ Create the web application, register the routes, and run the application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 创建 Web 应用程序，注册路由，并运行应用程序。
- en: In the preceding listing, we first create a time endpoint. `@routes.get('/time')`
    specifies that the decorated coroutine will execute when a client executes a `HTTP`
    `GET` request against the `/time` URI. In our `time` coroutine, we get the month,
    day, and time and store it in a dictionary. We then call `web.json_response`,
    which takes the dictionary and serializes it into JSON format. It also configures
    the HTTP response we send back. In particular, it sets the status code to `200`
    and the content type to `'application/json'`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们首先创建了一个时间端点。`@routes.get('/time')` 指定当客户端对 `/time` URI 执行 `HTTP GET`
    请求时，装饰的协程将执行。在我们的 `time` 协程中，我们获取月份、日期和时间并将其存储在字典中。然后我们调用 `web.json_response`，它将字典序列化为
    JSON 格式。它还配置了我们发送回的 HTTP 响应。特别是，它将状态码设置为 `200`，将内容类型设置为 `'application/json'`。
- en: We then create the web application and start it. First, we create an `Application`
    instance and call `add_routes`. This registers all the decorators we created with
    the web application. We then call `run_app`, which starts the web server. By default,
    this starts the web server on localhost port 8080.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建 Web 应用程序并启动它。首先，我们创建一个 `Application` 实例并调用 `add_routes`。这注册了我们创建的所有装饰器与
    Web 应用程序。然后我们调用 `run_app`，它启动了 Web 服务器。默认情况下，这将在 localhost 的 8080 端口启动 Web 服务器。
- en: 'When we run this, we’ll be able to test this out by either going to `localhost:8080/time`
    in a web browser or using a command-line utility, such as cURL or Wget. Let’s
    test it out with cURL to take a look at the full response by running `curl` `-i`
    `localhost:8080/time`. You should see something like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，我们可以通过在网页浏览器中访问 `localhost:8080/time` 或者使用命令行工具，例如 cURL 或 Wget 来测试它。让我们用
    cURL 来测试一下，运行 `curl -i localhost:8080/time`，你应该会看到以下内容：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This shows that we’ve successfully created our first endpoint with aiohttp!
    One thing you may have noticed from our code listing is that our `time` coroutine
    had a single parameter named `request`. While we didn’t need to use it in this
    example, it will soon become important. This data structure has information about
    the web request the client sent, such as the body, query parameters, and so on.
    To get a glimpse of the headers in the request, add `print(request.headers)` somewhere
    inside the `time` coroutine, and you should see something similar to this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们已成功使用 aiohttp 创建了第一个端点！你可能已经注意到，从我们的代码列表中，我们的 `time` 协程有一个名为 `request`
    的单个参数。虽然在这个例子中我们不需要使用它，但它很快就会变得很重要。这个数据结构包含了客户端发送的 Web 请求的信息，例如请求体、查询参数等。为了查看请求中的头部信息，在
    `time` 协程中某处添加 `print(request.headers)`，你应该会看到类似以下的内容：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 9.1.3 Connecting to a database and returning results
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.3 连接到数据库并返回结果
- en: While our time endpoint shows us the basics, most web applications are not this
    simple. We’ll usually need to connect to a database such as Postgres or Redis,
    and may need to communicate with other REST APIs, for example, if we query or
    update a vendor API we use.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的时间端点展示了基本概念，但大多数 Web 应用程序并不这么简单。我们通常需要连接到数据库，如 Postgres 或 Redis，并且可能需要与其他
    REST API 通信，例如，如果我们查询或更新我们使用的供应商 API。
- en: To see how to do this, we’ll build a REST API around our e-commerce storefront
    database from chapter 5\. Specifically, we’ll design a REST API to get existing
    products from our database as well as create new ones.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何做这件事，我们将围绕第 5 章中的电子商务店面数据库构建一个 REST API。具体来说，我们将设计一个 REST API 来从数据库中获取现有产品以及创建新的产品。
- en: 'The first thing we’ll need to do is create a connection to our database. Since
    we expect our application will have many concurrent users, using a connection
    pool instead of a single connection makes the most sense. The question becomes:
    where can we create and store the connection pool for easy use by our application’s
    endpoints?'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要做的是创建到数据库的连接。由于我们预计应用程序将有许多并发用户，使用连接池而不是单个连接更为合理。问题变成了：我们可以在哪里创建和存储连接池，以便我们的应用程序端点方便使用？
- en: To answer the question of where we can store the connection pool, we’ll need
    to first answer the broader question of where we can store shared application
    data in aiohttp applications. We’ll then use this mechanism to hold a reference
    to our connection pool.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答我们可以在哪里存储连接池的问题，我们首先需要回答一个更广泛的问题：在哪里可以存储 aiohttp 应用程序中的共享应用数据。然后我们将使用这个机制来持有连接池的引用。
- en: 'To store shared data, aiohttp’s `Application` class acts as a dictionary. For
    example, if we had some shared dictionary we wanted all our routes to have access
    to, we could store it in our application as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储共享数据，aiohttp 的 `Application` 类充当字典。例如，如果我们有一些共享字典，我们希望所有路由都可以访问，我们可以在应用程序中按如下方式存储它：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can now access the shared dictionary by executing `app[''shared_dict'']`.
    Next, we need to figure out how to access the application from within a route.
    We could make the app instance global, but aiohttp provides a better way though
    the `Request` class. Every request that our route gets will have a reference to
    the application instance through the `app` field, allowing us easy access to any
    shared data. For example, getting the shared dictionary and returning it as a
    response might look like the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过执行 `app['shared_dict']` 来访问共享字典。接下来，我们需要弄清楚如何在路由内部访问应用程序。我们可以使应用程序实例全局化，但
    aiohttp 提供了一种更好的方法，即通过 `Request` 类。我们路由接收到的每个请求都将通过 `app` 字段有一个对应用程序实例的引用，这使得我们能够轻松访问任何共享数据。例如，获取共享字典并将其作为响应返回可能看起来像以下这样：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’ll use this paradigm to store and retrieve our database connection pool once
    we create it. Now we decide the best place to create our connection pool. We can’t
    easily do it when we create our application instance, as this happens outside
    of any coroutine meaning, and we can’t use the needed `await` expressions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了它，我们将使用这种范式来存储和检索我们的数据库连接池。现在我们决定创建连接池的最佳位置。我们无法在创建应用程序实例时轻松地这样做，因为这发生在任何协程之外，我们无法使用所需的
    `await` 表达式。
- en: 'aiohttp provides a signal handler on the application instance to handle setup
    tasks like this called `on_startup`. You can think of this as a list of coroutines
    that will execute when we start the application. We can add coroutines to run
    on startup by calling `app.on_startup.append(coroutine)`. Each coroutine we append
    to `on_startup` has a single parameter: the `Application` instance. We can store
    our database pool in the application instance passed in to this coroutine once
    we’ve instantiated it.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: aiohttp 在应用程序实例上提供了一个名为 `on_startup` 的信号处理程序来处理此类设置任务。你可以将其视为在启动应用程序时将执行的协程列表。我们可以通过调用
    `app.on_startup.append(coroutine)` 来将协程添加到启动时运行。我们添加到 `on_startup` 的每个协程都有一个单一参数：`Application`
    实例。一旦我们实例化了它，我们就可以将我们的数据库池存储在这个传递给该协程的应用程序实例中。
- en: 'We also need to consider what happens when our web application shuts down.
    We want to actively close and clean up database connections when we shut down;
    otherwise, we could leave dangling connections, putting unneeded stress on our
    database. aiohttp also provides a second signal handler: `on_cleanup`. The coroutines
    in this handler will run when our application closes, giving us an easy place
    to shut down the connection pool. This behaves like the `on_startup` handler in
    that we just call `append` with coroutines we’d like to run.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要考虑当我们的 Web 应用程序关闭时会发生什么。我们希望在关闭时主动关闭和清理数据库连接；否则，我们可能会留下悬空连接，给我们的数据库带来不必要的压力。aiohttp
    还提供了一个第二个信号处理程序：`on_cleanup`。在这个处理程序中的协程将在我们的应用程序关闭时运行，这为我们提供了一个关闭连接池的便捷位置。这就像
    `on_startup` 处理程序一样，我们只需调用 `append` 并传入我们想要运行的协程。
- en: Putting all these pieces together, we can create a web application that creates
    a connection pool to our product database. To test this out, let’s create an endpoint
    that gets all brand data in our database. This will be a GET endpoint called `/brands`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些部分组合起来，我们可以创建一个 Web 应用程序，该应用程序创建一个连接池到我们的产品数据库。为了测试这一点，让我们创建一个获取我们数据库中所有品牌数据的端点。这将是一个名为
    `/brands` 的 GET 端点。
- en: Listing 9.2 Connecting to a product database
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.2 连接到产品数据库
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Create the database pool, and store it in the application instance.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建数据库池，并将其存储在应用程序实例中。
- en: ❷ Destroy the pool in the application instance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在应用程序实例中销毁池。
- en: ❸ Query all brands and return results to the client.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 查询所有品牌并将结果返回给客户端。
- en: ❹ Add the create and destroy pool coroutines to startup and cleanup.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将创建和销毁池的协程添加到启动和清理过程中。
- en: We first define two coroutines to create and destroy the connection pool. In
    `create_ database_pool`, we create a pool and store it in the application under
    the `DB_KEY`. Then, in `destroy_database_pool`, we get the pool from the application
    instance and wait for it to close. When we start our application, we append these
    two coroutines to the `on_startup` and `on_cleanup` signal handlers, respectively.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义两个协程来创建和销毁连接池。在`create_database_pool`中，我们创建一个池并将其存储在应用程序中的`DB_KEY`下。然后，在`destroy_database_pool`中，我们从应用程序实例中获取池并等待其关闭。当我们启动应用程序时，我们将这两个协程分别附加到`on_startup`和`on_cleanup`信号处理程序。
- en: 'Next, we define our brands route. We first grab the database pool from the
    request and run a query to get all brands in our database. We then loop over each
    brand, casting them to dictionaries. This is because aiohttp does not know how
    to serialize asyncpg `Record` instances. When running this application, you should
    be able to go to `localhost:8080/brands` in a browser and see all brands in your
    database displayed as a JSON list, giving you something like the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的品牌路由。我们首先从请求中获取数据库池并运行一个查询以获取我们数据库中的所有品牌。然后，我们遍历每个品牌，将它们转换为字典。这是因为aiohttp不知道如何序列化asyncpg
    `Record` 实例。当运行此应用程序时，你应该能够在浏览器中访问`localhost:8080/brands`并看到数据库中显示的所有品牌作为JSON列表，如下所示：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We’ve now created our first RESTful collection API endpoint. Next, let’s see
    how to create endpoints to create and update singleton resources. We’ll implement
    two endpoints: one GET endpoint to retrieve a product by a specific ID and one
    POST endpoint to create a new product.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了我们的第一个RESTful集合API端点。接下来，让我们看看如何创建创建和更新单例资源的端点。我们将实现两个端点：一个用于通过特定ID检索产品的GET端点和一个用于创建新产品的POST端点。
- en: Let’s start with our GET endpoint for a product. This endpoint will take in
    an integer ID parameter, meaning to get the product with ID 1 we’d call `/products/1`.
    How can we create a route that has a parameter in it? aiohttp lets us parameterize
    our routes by wrapping any parameters in curly brackets, so our product route
    will be `/products/{id}`. When we parameterize like this, we’ll see an entry in
    our request’s `match_info` dictionary. In this case, whatever the user passed
    into the `id` parameter will be available in `request.match_info['id']` as a string.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从产品的GET端点开始。此端点将接受一个整数ID参数，这意味着要获取ID为1的产品，我们将调用`/products/1`。我们如何创建一个包含参数的路由？aiohttp允许我们通过将任何参数包裹在花括号中来参数化我们的路由，因此我们的产品路由将是`/products/{id}`。当我们这样参数化时，我们将在请求的`match_info`字典中看到一个条目。在这种情况下，用户传递给`id`参数的任何内容都将作为字符串在`request.match_info['id']`中可用。
- en: Since we could pass in an invalid string for an ID, we’ll need to add some error
    handling. A client could also ask for an ID that does not exist, so we’ll need
    to handle the “not found” case appropriately as well. For these error cases, we’ll
    return a HTTP 400 status code to indicate the client issued a bad request. For
    the case where the product does not exist, we’ll return a HTTP 404 status code.
    To represent these error cases, aiohttp provides a set of exceptions for each
    HTTP status code. In the error cases, we can just raise them, and the client will
    receive the appropriate status code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能传递一个无效的字符串作为ID，因此我们需要添加一些错误处理。客户端也可能请求一个不存在的ID，因此我们需要适当地处理“未找到”的情况。对于这些错误情况，我们将返回HTTP
    400状态码以指示客户端发出了一个错误请求。对于产品不存在的情况，我们将返回HTTP 404状态码。为了表示这些错误情况，aiohttp为每个HTTP状态码提供了一套异常。在错误情况下，我们可以直接抛出它们，客户端将接收到适当的状态码。
- en: Listing 9.3 Getting a specific product
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.3 获取特定产品
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Get the product_id parameter from the URL.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从URL中获取`product_id`参数。
- en: ❷ Run the query for a single product.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对单个产品运行查询。
- en: ❸ If we have a result, convert it to JSON and send to the client; otherwise,
    send a “404 not found.”
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果我们有结果，将其转换为JSON并发送给客户端；否则，发送“404 not found。”
- en: Next, let’s see how to create a POST endpoint to create a new product in the
    database. We’ll send the data we want in the request body as a JSON string, and
    we’ll then translate that into an insert query. We’ll need to do some error checking
    here to see if the JSON is valid, and if it isn’t, send the client a bad request
    error.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何创建一个用于在数据库中创建新产品的POST端点。我们将以JSON字符串的形式在请求体中发送我们想要的数据，然后将其转换为插入查询。在这里，我们需要进行一些错误检查以查看JSON是否有效，如果不是，则向客户端发送一个错误请求。
- en: Listing 9.4 A create product endpoint
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 创建产品端点
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We first check to see if we even have a body with `request.can_read_body`, and
    if we don’t, we quickly return a bad response. We then grab the request body as
    a dictionary with the `json` coroutine. Why is this a coroutine and not a plain
    method? If we have an especially large request body, the result may be buffered
    and could take some time to read. Instead of blocking our handler waiting for
    all data to come in, we `await` until all data is there. We then insert the record
    into the product table and return a HTTP 201 created status back to the client.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查是否有体`request.can_read_body`，如果没有，我们快速返回一个错误响应。然后，我们使用`json`协程将请求体作为字典获取。为什么这是一个协程而不是一个普通方法？如果我们有一个特别大的请求体，结果可能会被缓冲，并且可能需要一些时间来读取。我们不是阻塞我们的处理器等待所有数据到来，而是`await`直到所有数据都到达。然后我们将记录插入产品表，并将HTTP
    201创建状态返回给客户端。
- en: Using cURL, you should be able to execute something like the following to insert
    a product into your database, getting a HTTP 201 response.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用cURL，你应该能够执行以下操作将产品插入到你的数据库中，并得到HTTP 201响应。
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While the error handling here should be more robust (what happens if the brand
    ID is a string and not an integer or the JSON is malformed?), this illustrates
    how to process `postdata` to insert a record into our database.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里的错误处理应该更加健壮（如果品牌ID是一个字符串而不是整数或JSON格式不正确会发生什么？），但这说明了如何处理`postdata`以将记录插入我们的数据库。
- en: 9.1.4 Comparing aiohttp with Flask
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1.4 比较aiohttp与Flask
- en: Working with aiohttp and an asyncio-ready web framework gives us the benefit
    of using libraries such as asyncpg. Outside of the use of asyncio libraries, are
    there any benefits to using a framework like aiohttp as opposed to a similar synchronous
    framework such as Flask?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用aiohttp和异步就绪的Web框架，我们可以使用如asyncpg之类的库。除了使用asyncio库之外，与类似同步框架（如Flask）相比，使用aiohttp框架有什么好处？
- en: While it highly depends on server configuration, database hardware, and other
    factors, asyncio-based applications can have better throughput with fewer resources.
    In a synchronous framework, each request handler runs from start to finish without
    interruption. In an asynchronous framework, when our `await` expressions suspend
    execution, they give the framework a chance to handle other work, resulting in
    greater efficiency.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它高度依赖于服务器配置、数据库硬件和其他因素，但基于asyncio的应用程序可以使用更少的资源实现更好的吞吐量。在同步框架中，每个请求处理器从开始到结束运行，不会中断。在异步框架中，当我们的`await`表达式挂起执行时，它们给框架一个处理其他工作的机会，从而提高效率。
- en: 'To test this out, let’s build a Flask replacement for our brands endpoint.
    We’ll assume basic familiarity with Flask and synchronous database drivers, although
    even if you don’t know these you should be able to follow the code. To get started,
    we’ll install Flask and psycopg2, a synchronous Postgres driver, with the following
    commands:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，让我们构建一个用于我们的品牌端点的Flask替代品。我们将假设对Flask和同步数据库驱动程序有基本的了解，尽管即使你不了解这些，你也应该能够理解代码。为了开始，我们将使用以下命令安装Flask和psycopg2，一个同步的Postgres驱动程序：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For psycopg, you may run into compile errors on install. If you do, you may
    need to install Postgres tools, and open SSL or another library. A web search
    with your error should yield the answer. Now, let’s implement our endpoint. We’ll
    first create a connection to the database. Then, in our request handler we’ll
    reuse the brand query from our previous example and return the results as a JSON
    array.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于psycopg，你可能会在安装时遇到编译错误。如果你遇到这种情况，你可能需要安装Postgres工具和open SSL或其他库。通过搜索你的错误，你应该能够找到答案。现在，让我们实现我们的端点。我们首先将创建到数据库的连接。然后，在我们的请求处理器中，我们将重用之前示例中的品牌查询，并将结果作为JSON数组返回。
- en: Listing 9.5 A Flask application to retrieve brands
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.5 一个用于检索品牌的Flask应用程序
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we need to run our application. Flask comes with a development server,
    but it is not production-ready and wouldn’t be a fair comparison, especially since
    it would only run one process, meaning we could only handle one request at a time.
    We’ll need to use a production WSGI server to test this. We’ll use Gunicorn for
    this example, though there are many you could choose. Let’s start by installing
    Gunicorn with the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要运行我们的应用程序。Flask自带一个开发服务器，但它不是生产就绪的，并且不会是一个公平的比较，特别是因为它只会运行一个进程，这意味着我们一次只能处理一个请求。我们需要使用一个生产WSGI服务器来测试这一点。我们将使用Gunicorn作为此示例，尽管你可以选择很多其他选项。让我们首先使用以下命令安装Gunicorn：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We’ll be testing this out on an 8-core machine, so we’ll spawn eight workers
    with Gunicorn. Running `gunicorn` `-w` `8` `chapter_09.listing_9_5:app`, and you
    should see eight workers start up:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个 8 核的机器上进行测试，所以我们将使用 Gunicorn 启动八个工作进程。运行 `gunicorn` `-w` `8` `chapter_09.listing_9_5:app`，你应该会看到八个工作进程启动：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This means we have created eight connections to our database and can serve eight
    requests concurrently. Now, we need a tool to benchmark performance between Flask
    and aiohttp. A command-line load tester will work for a quick test. While this
    won’t be the most accurate picture, it will give us a directional idea of performance.
    We’ll use a load tester called wrk, though any load tester, such as Apache Bench
    or Hey, will work. You can view installation instructions on wrk at [https://github.com/wg/wrk.](https://github.com/wg/wrk)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们已经为我们数据库创建了八个连接，并且可以并发处理八个请求。现在，我们需要一个工具来基准测试 Flask 和 aiohttp 的性能。命令行负载测试器适用于快速测试。虽然这不会是最准确的结果，但它会给我们一个性能的方向性想法。我们将使用一个名为
    wrk 的负载测试器，尽管任何负载测试器，如 Apache Bench 或 Hey，都可以工作。你可以在 [https://github.com/wg/wrk.](https://github.com/wg/wrk)
    上查看 wrk 的安装说明。
- en: 'Let’s start by running a 30-second load test on our Flask server. We’ll use
    one thread and 200 connections, simulating 200 concurrent users hitting our app
    as fast as they can. On an 8-core 2.4 Ghz machine you could see results similar
    to the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先对我们的 Flask 服务器运行一个 30 秒的负载测试。我们将使用一个线程和 200 个连接，模拟 200 个并发用户尽可能快地击打我们的应用。在一个
    8 核 2.4 GHz 的机器上，你可能会看到以下类似的结果：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We served about 550 requests per second—not a bad result. Let’s rerun the same
    with aiohttp and compare the results:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每秒处理了大约 550 个请求——这不是一个坏的结果。让我们用 aiohttp 重新运行相同的测试并比较结果：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using aiohttp, we were able to serve over 1,500 requests per second, which is
    about three times what we were able to do with Flask. More importantly, we did
    this with only one process, where Flask needed a total of *eight processes* to
    handle *one-third* of the requests! You could further improve the performance
    of aiohttp by putting NGINX in front of it and starting more worker processes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 aiohttp，我们能够每秒处理超过 1,500 个请求，这大约是我们使用 Flask 能做到的三倍。更重要的是，我们只使用了一个进程，而 Flask
    需要总共 *八个进程* 来处理 *三分之一的请求*！你还可以通过在 aiohttp 前面放置 NGINX 并启动更多工作进程来进一步提高 aiohttp 的性能。
- en: We now know the basics of how to use aiohttp to build a database-backed web
    application. In the world of web applications, aiohttp is a little different than
    most in that it is a web server itself, and it does not conform to WSGI and can
    stand alone on its own. As we saw with Flask, this is not usually the case. Next,
    let’s understand how ASGI works and see how to use it with an ASGI-compliant framework
    called Starlette.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了如何使用 aiohttp 来构建数据库支持的 Web 应用程序的基础。在 Web 应用程序的世界里，aiohttp 与大多数不同之处在于它本身就是一个
    Web 服务器，并且它不遵循 WSGI，可以独立运行。正如我们通过 Flask 看到的，这种情况并不常见。接下来，让我们了解 ASGI 的工作原理，并看看如何使用一个名为
    Starlette 的 ASGI 兼容框架。
- en: 9.2 The asynchronous server gateway interface
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 异步服务器网关接口
- en: When we used Flask in the previous example, we used the Gunicorn WSGI server
    to serve our application. WSGI is a standardized way to forward web requests to
    a web framework, such as Flask or Django. While there are many WSGI servers, they
    were not designed to support asynchronous workloads, as the WSGI specification
    long predates asyncio. As asynchronous web applications become more widely used,
    a way to abstract frameworks from their servers proved necessary. Thus, the *asynchronous
    server gateway interface*, or ASGI, was created. ASGI is a relative newcomer to
    the internet space but already has several popular implementations and frameworks
    that support it, including Django.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用 Flask 时，使用了 Gunicorn WSGI 服务器来提供服务。WSGI 是将网络请求转发到网络框架（如 Flask 或
    Django）的一种标准化方式。虽然有许多 WSGI 服务器，但它们并不是为了支持异步工作负载而设计的，因为 WSGI 规范的出现时间远早于 asyncio。随着异步网络应用的日益普及，一种从框架中抽象出其服务器的方法变得必要。因此，创建了
    *异步服务器网关接口*，或称 ASGI。ASGI 是互联网空间中的相对新来者，但已经有一些流行的实现和框架支持它，包括 Django。
- en: 9.2.1 How does ASGI compare to WSGI?
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2.1 ASGI 与 WSGI 的比较如何？
- en: WSGI was born out of a fractured landscape of web application frameworks. Prior
    to WSGI, the choice of one framework could limit the kinds of usable interface
    web servers, as there was no standardized interface between the two. WSGI addressed
    this by providing a simple API for web servers to talk to Python frameworks. WSGI
    received formal acceptance into the Python ecosystem in 2004 with the acceptance
    of PEP-333 (Python enhancement proposal; [https://www.python.org/dev/peps/pep-0333/](https://www.python.org/dev/peps/pep-0333/))
    and is now the de facto standard for web application deployment.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI 是从破碎的 Web 应用框架景观中诞生的。在 WSGI 之前，选择一个框架可能会限制可用的 Web 服务器接口类型，因为两者之间没有标准化的接口。WSGI
    通过为 Web 服务器提供与 Python 框架通信的简单 API 来解决这个问题。WSGI 在 2004 年随着 PEP-333（Python 增强提案；[https://www.python.org/dev/peps/pep-0333/](https://www.python.org/dev/peps/pep-0333/))
    的接受正式进入 Python 生态系统，现在已成为 Web 应用部署的事实标准。
- en: When it comes to asynchronous workloads however, WSGI does not work. The heart
    of the WSGI specification is a simple Python function. For example, let’s see
    the simplest WSGI application we can build.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当涉及到异步工作负载时，WSGI 就不再适用了。WSGI 规范的核心是一个简单的 Python 函数。例如，让我们看看我们可以构建的最简单的 WSGI
    应用。
- en: Listing 9.6 A WSGI application
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.6 一个 WSGI 应用
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can run this application with Gunicorn by running `gunicorn` `chapter_09.listing_
    9_6` and test it out with `curl` `http:/ /127.0.0.1:8000`. As you can see, there
    isn’t any place for us to use an `await`. In addition, WSGI only supports response/request
    lifecycles, meaning it won’t work with long-lived connection protocols, such as
    WebSockets. ASGI fixes this by redesigning the API to use coroutines. Let’s translate
    our WSGI example to ASGI.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行 `gunicorn` `chapter_09.listing_ 9_6` 来运行此应用，并用 `curl` `http:/ /127.0.0.1:8000`
    进行测试。如您所见，我们没有地方可以使用 `await`。此外，WSGI 只支持响应/请求生命周期，这意味着它不适用于长连接协议，如 WebSockets。ASGI
    通过重新设计 API 以使用协程来解决这个问题。让我们将我们的 WSGI 示例转换为 ASGI。
- en: Listing 9.7 A simple ASGI application
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.7 一个简单的 ASGI 应用
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'An ASGI application function has three parameters: a scope dictionary, a receive
    coroutine, and a send coroutine, which allow us to send and receive data, respectively.
    In our example, we send the start of the HTTP response, followed by the body.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ASGI 应用函数有三个参数：一个作用域字典、一个接收协程和一个发送协程，这允许我们分别发送和接收数据。在我们的例子中，我们发送 HTTP 响应的开始，然后是主体。
- en: 'Now, how do we serve the above application? There are a few implementations
    of ASGI available, but we’ll use a popular one called Uvicorn ([https://www.uvicorn.org/](https://www.uvicorn.org/)).
    Uvicorn is built on top of uvloop and httptools, which are fast C implementations
    of the asyncio event loop (we’re actually not tied to the event loop that comes
    with asyncio, as we’ll learn more in chapter 14) and HTTP parsing. We can install
    Uvicorn by running the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们该如何提供上述应用呢？有几种 ASGI 的实现方式，但我们将使用一个流行的名为 Uvicorn ([https://www.uvicorn.org/](https://www.uvicorn.org/))
    的工具。Uvicorn 是基于 uvloop 和 httptools 构建的，它们是 asyncio 事件循环的快速 C 实现（我们实际上并不依赖于 asyncio
    提供的事件循环，我们将在第 14 章中了解更多）以及 HTTP 解析。我们可以通过运行以下命令来安装 Uvicorn：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can run our application with the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令运行我们的应用：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: And we should see our “hello” message printed if we go to http:/ /localhost:8000\.
    While we used Uvicorn directly here to test things out, it is better practice
    to use Uvicorn with Gunicorn, as Gunicorn will have logic to restart workers on
    crashes for us. We’ll see how to do this with Django in section 9.4.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们访问 http:/ /localhost:8000，我们应该能看到我们的“hello”消息被打印出来。虽然我们在这里直接使用 Uvicorn 来测试，但更好的做法是使用
    Gunicorn 与 Uvicorn 结合，因为 Gunicorn 将具有在崩溃时重启工作进程的逻辑。我们将在第 9.4 节中看到如何使用 Django 来实现这一点。
- en: We should keep in mind that, while WSGI is an accepted PEP, ASGI is not yet
    accepted, and as of this writing it is still relatively new. Expect the details
    of how ASGI works to evolve and change as the asyncio landscape changes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该记住，虽然 WSGI 是一个被接受的 PEP，但 ASGI 还没有被接受，并且截至本文撰写时，它仍然相对较新。预计 ASGI 的工作原理的细节会随着
    asyncio 生态系统的变化而发展和变化。
- en: Now, we know the basics of ASGI and how it compares to WSGI. What we have learned
    is very low-level, though; we want a framework to handle ASGI for us! There are
    a few ASGI-compliant frameworks, let’s look at a popular one.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了 ASGI 的基础知识以及它与 WSGI 的比较。虽然我们学到的内容非常底层，但我们还是希望有一个框架来帮我们处理 ASGI！有几个符合
    ASGI 规范的框架，让我们来看一个流行的例子。
- en: 9.3 ASGI with Starlette
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 使用 Starlette 的 ASGI
- en: 'Starlette is a small ASGI-compliant framework created by Encode, the creators
    of Uvicorn and other popular libraries such as Django REST framework. It offers
    fairly impressive performance (at the time of writing), WebSocket support, and
    more. You can view its documentation at [https://www.starlette.io/](https://www.starlette.io/).
    Let’s see how to implement simple REST and WebSocket endpoints using it. To get
    started, let’s first install it with the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Starlette是由Uvicorn和其他流行库（如Django REST框架）的创建者Encode创建的一个小型ASGI兼容框架。它提供了相当令人印象深刻的性能（在撰写本文时），WebSocket支持以及更多。您可以在[https://www.starlette.io/](https://www.starlette.io/)查看其文档。让我们看看如何使用它实现简单的REST和WebSocket端点。要开始，让我们首先使用以下命令安装它：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 9.3.1 A REST endpoint with Starlette
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.1 使用Starlette的REST端点
- en: 'Let’s start to learn Starlette by reimplementing our brands endpoint from previous
    sections. We’ll create our application by creating an instance of the `Starlette`
    class. This class takes a few parameters that we’ll be interested in using: a
    list of `route` objects and a list of coroutines to run on startup and shutdown.
    `Route` objects are mappings from a string path—brands, in our case—to a coroutine
    or another callable object. Much like aiohttp, these coroutines have one parameter
    representing the request, and they return a response, so our route handle will
    look very similar to our aiohttp version. What is slightly different is how we
    handle sharing our database pool. We still store it on our Starlette application
    instance, but it is inside a state object instead.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过重新实现之前章节中的品牌端点来开始学习Starlette。我们将通过创建`Starlette`类的一个实例来创建我们的应用程序。这个类有几个我们感兴趣的参数：一个`route`对象列表和一个在启动和关闭时运行的协程列表。`Route`对象是将字符串路径（在我们的例子中是品牌）映射到协程或另一个可调用对象的映射。与aiohttp类似，这些协程有一个表示请求的参数，并返回一个响应，所以我们的路由处理程序将非常类似于我们的aiohttp版本。略有不同的是我们处理共享数据库池的方式。我们仍然在我们的Starlette应用程序实例中存储它，但它位于一个状态对象内部。
- en: Listing 9.8 A Starlette brands endpoint
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.8 Starlette品牌端点
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that we have our brands endpoint, let’s use Uvicorn to start it up. We’ll
    start up eight workers, as we did before, with the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了品牌端点，让我们使用Uvicorn来启动它。我们将启动八个工作进程，就像之前一样，使用以下命令：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You should be able to hit this endpoint at `localhost:8000/brands` and see
    the contents of the brand table, as before. Now that we have our application running,
    let’s run a quick benchmark to see how it compares to aiohttp and Flask. We’ll
    use the same wrk command as before with 200 connections over 30 seconds:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够在`localhost:8000/brands`这个端点上访问，并看到品牌表的内容，就像之前一样。现在我们的应用程序正在运行，让我们快速进行基准测试，看看它与aiohttp和Flask相比如何。我们将使用之前相同的wrk命令，200个连接，持续30秒：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We’ve served over 4,000 requests per second, outperforming Flask and even aiohttp
    by a wide margin! Since we only ran one aiohttp worker process earlier, this isn’t
    exactly a fair comparison (we’d get similar numbers with eight aiohttp workers
    behind NGINX), but this shows the throughput power that async frameworks offer.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每秒处理了超过4,000个请求，远远超过了Flask和aiohttp！因为我们之前只运行了一个aiohttp工作进程，所以这并不是一个完全公平的比较（在NGINX后面有八个aiohttp工作进程时，我们会得到类似的数据），但这显示了异步框架提供的吞吐量能力。
- en: 9.3.2 WebSockets with Starlette
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3.2 使用Starlette的WebSocket
- en: In a traditional HTTP request, the client sends a request to the server, the
    server hands a back a response, and that is the end of the transaction. What if
    we want to build a web page that updates without a user having to refresh? For
    example, we may have a live counter of how many users are currently on the site.
    We can do this over HTTP with some JavaScript that polls an endpoint, telling
    us how many users are on the site. We could hit the endpoint every few seconds,
    updating the page with the latest result.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的HTTP请求中，客户端向服务器发送请求，服务器返回一个响应，这就是事务的结束。如果我们想构建一个用户无需刷新就能更新的网页呢？例如，我们可能有一个实时计数器，显示当前有多少用户在网站上。我们可以通过HTTP和一些JavaScript来实现这一点，JavaScript会轮询一个端点，告诉我们网站上有多少用户。我们可以每隔几秒就访问一次端点，用最新的结果更新页面。
- en: While this will work, it has drawbacks. The main drawback is that we’re creating
    an extra load on our web server, each request and response cycle taking time and
    resources. This is especially egregious because our user count might not change
    between requests, causing a strain on our system for no new information (we could
    mitigate this with caching, but the point still stands, and caching introduces
    other complexity and overhead). HTTP polling is the digital equivalent of a child
    in the backseat of the car repeatedly asking, “Are we there yet?”
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可以工作，但它有一些缺点。主要的缺点是我们给我们的 Web 服务器增加了额外的负载，每个请求和响应周期都会消耗时间和资源。这尤其令人反感，因为我们的用户数可能在请求之间没有变化，导致系统在没有新信息的情况下承受压力（我们可以通过缓存来缓解这个问题，但这个观点仍然成立，而且缓存引入了其他复杂性和开销）。HTTP
    轮询在数字上等同于一个坐在车后座的孩子反复问，“我们到了吗？”
- en: WebSockets provide an alternative to HTTP polling. Instead of a request/response
    cycle like HTTP, we establish one persistent socket. Then, we just send data freely
    across that socket. This socket is bidirectional, meaning we can both send data
    to and receive data from our server without having to go through a HTTP request
    lifecycle every time. To apply this to the example of displaying an up-to-date
    user count, once we connect to a WebSocket the server can just *tell* us when
    there is a new user count. As shown in figure 9.1, we don’t need to ask repeatedly,
    creating extra load and potentially receiving data that isn’t new.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 提供了 HTTP 轮询的替代方案。与 HTTP 的请求/响应周期不同，我们建立一个持久的套接字。然后，我们只需在这个套接字上自由发送数据。这个套接字是双向的，这意味着我们可以在不通过
    HTTP 请求生命周期的情况下，向服务器发送数据并从服务器接收数据。要将此应用于显示最新用户数的示例，一旦我们连接到 WebSocket，服务器就可以直接“告诉我们”是否有新的用户数。如图
    9.1 所示，我们不需要反复询问，这会创建额外的负载，并可能接收到不是新的数据。
- en: '![09-01](Images/09-01.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![09-01](Images/09-01.png)'
- en: Figure 9.1 HTTP polling to retrieve data compared to WebSockets
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 与 WebSocket 相比，HTTP 轮询检索数据
- en: 'Starlette provides out-of-the-box support for WebSockets using an easy-to-understand
    interface. To see this in action, we’ll build a simple WebSocket endpoint that
    will tell us how many users are connected to a WebSocket endpoint simultaneously.
    To get started we’ll first need to install WebSocket support:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Starlette 提供了一个易于理解的接口来支持 WebSocket。为了看到这个功能在行动中的样子，我们将构建一个简单的 WebSocket 端点，它会告诉我们有多少用户同时连接到
    WebSocket 端点。要开始，我们首先需要安装 WebSocket 支持：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, we’ll need to implement our WebSocket endpoint. Our game plan will be
    to keep an in-memory list of all connected client WebSockets. When a new client
    connects, we’ll add them to the list and send the new count of users to all clients
    in the list. When a client disconnects, we’ll remove them from the list and update
    other clients about the change in user count as well. We’ll also add some basic
    error handling. If sending one of these messages results in an exception, we’ll
    remove the client from the list.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现我们的 WebSocket 端点。我们的计划是保持一个内存中所有已连接客户端 WebSocket 的列表。当新的客户端连接时，我们将它们添加到列表中，并将新用户数发送给列表中的所有客户端。当客户端断开连接时，我们将它们从列表中移除，并更新其他客户端关于用户数变化的信息。我们还将添加一些基本的错误处理。如果发送这些消息之一导致异常，我们将从列表中移除客户端。
- en: In Starlette, we can subclass `WebSocketEndpoint` to create an endpoint to handle
    a WebSocket connection. This class has a few coroutines we’ll need to implement.
    The first is `on_connect`, which gets fired when a client connects to our socket.
    In `on_connect`, we’ll store the client’s WebSocket in a list and send the length
    of the list to all other sockets. The second coroutine is `on_receive`; this gets
    fired when the client connection sends a message to the server. In our case, we
    won’t need to implement this, as we don’t expect the client to send us any data.
    The final coroutine is `on_disconnect`, which runs when a client disconnects.
    In this case, we’ll remove the client from the list of connected WebSockets and
    update other connected clients with the latest user count.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Starlette 中，我们可以通过继承 `WebSocketEndpoint` 来创建一个端点来处理 WebSocket 连接。这个类有几个协程我们需要实现。第一个是
    `on_connect`，当客户端连接到我们的套接字时会被触发。在 `on_connect` 中，我们将客户端的 WebSocket 存储在一个列表中，并将列表的长度发送给所有其他套接字。第二个协程是
    `on_receive`；当客户端连接向服务器发送消息时会被触发。在我们的案例中，我们不需要实现这个，因为我们不期望客户端向我们发送任何数据。最后一个协程是
    `on_disconnect`，当客户端断开连接时运行。在这种情况下，我们将客户端从已连接 WebSocket 列表中移除，并更新其他已连接客户端的最新用户数。
- en: Listing 9.9 A Starlette WebSocket endpoint
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.9 Starlette WebSocket 端点
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ When a client connects, add it to the list of sockets and notify other users
    of the new count.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当客户端连接时，将其添加到套接字列表中，并通知其他用户新的计数。
- en: ❷ When a client disconnects, remove it from the list of sockets and notify other
    users of the new count.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 当客户端断开连接时，将其从套接字列表中删除，并通知其他用户新的计数。
- en: ❸ Notify other users how many users are connected. If there is an exception
    while sending, remove them from the list.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通知其他用户有多少用户已连接。如果在发送过程中发生异常，请将其从列表中删除。
- en: Now, we’ll need to define a page to interact with our WebSocket. We’ll add create
    a basic script to connect to our WebSocket endpoint. When we receive a message,
    we’ll update a counter on the page with the latest value.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义一个页面来与我们的 WebSocket 交互。我们将创建一个基本的脚本来连接到我们的 WebSocket 端点。当我们收到消息时，我们将使用最新的值更新页面上的计数器。
- en: Listing 9.10 Using the WebSocket endpoint
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.10 使用 WebSocket 端点
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding listing, the script is where most of the work happens. We first
    connect to our endpoint and then define an `onmessage` callback. When the server
    sends us data, this callback runs. In this callback, we grab a special element
    from the DOM and set its content to the data we receive. Note that in our script
    we don’t execute this code until after the `DOMContentLoaded` event, without which
    our counter element may not exist when the script executes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，脚本是最主要的工作部分。我们首先连接到我们的端点，然后定义一个 `onmessage` 回调。当服务器发送数据给我们时，这个回调就会运行。在这个回调中，我们从
    DOM 中获取一个特殊元素并将其内容设置为接收到的数据。请注意，在我们的脚本中，我们不会在 `DOMContentLoaded` 事件之后执行此代码，如果没有这个事件，我们的计数器元素可能在脚本执行时不存在。
- en: If you start the server with `uvicorn` `—workers` `1` `chapter_09.listing_9_9:app`
    and open the web page, you should see the `1` displayed on the page. If you open
    the page multiple times in separate tabs, you should see the count increment on
    all the tabs. When you close a tab, you should see the count decrement across
    all other open tabs. Note that we only use one worker here, as we have shared
    state (the `socket` list) in memory; if we use multiple workers, each worker will
    have its own `socket` list. To deploy properly, you’ll need some persistent store,
    such as a database.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `uvicorn` `—workers` `1` `chapter_09.listing_9_9:app` 启动服务器并打开网页，你应该在页面上看到
    `1`。如果你在单独的标签页中多次打开页面，你应该看到计数在所有标签页上增加。当你关闭一个标签页时，你应该看到所有其他打开标签页的计数减少。请注意，我们在这里只使用一个工作进程，因为我们共享内存中的状态（套接字列表）；如果我们使用多个工作进程，每个工作进程将有自己的
    `socket` 列表。为了正确部署，你需要一些持久存储，例如数据库。
- en: We can now use both aiohttp and Starlette to create asyncio-based web applications
    for both REST and WebSocket endpoints. While these frameworks are popular, they
    are not close in popularity to Django, the 1,000-pound gorilla of Python web frameworks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用 aiohttp 和 Starlette 创建基于 asyncio 的 Web 应用程序，用于 REST 和 WebSocket 端点。虽然这些框架很受欢迎，但它们的受欢迎程度并不接近
    Django，这个 Python Web 框架中的“千磅巨兽”。
- en: 9.4 Django asynchronous views
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 Django 异步视图
- en: Django is one of the most popular and widely used Python frameworks. It has
    a wealth of functionality out of the box, from an ORM (object relational mapper)
    to handle databases to a customizable admin console. Until version 3.0, Django
    applications supported deploying as a WSGI application alone and had little support
    for asyncio outside of the `channels` library. Version 3.0 introduced support
    for ASGI and began the process of making Django fully asynchronous. More recently,
    version 3.1 gained support for asynchronous views, allowing you to use asyncio
    libraries directly in your Django views. At the time of writing, async support
    for Django is new, and the overall feature set is still lacking (for example,
    the ORM is entirely synchronous, but supporting async is in the future). Expect
    support for this to grow and evolve as Django becomes more async-aware.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Django 是最受欢迎和广泛使用的 Python 框架之一。它自带丰富的功能，从处理数据库的 ORM（对象关系映射器）到可定制的管理控制台。直到 3.0
    版本，Django 应用程序仅支持作为 WSGI 应用程序部署，并且除了 `channels` 库之外对 asyncio 的支持很少。3.0 版本引入了对
    ASGI 的支持，并开始了使 Django 完全异步的过程。最近，3.1 版本增加了对异步视图的支持，允许你直接在你的 Django 视图中使用 asyncio
    库。在撰写本文时，Django 的异步支持尚属新功能，整体功能集仍然有所欠缺（例如，ORM 完全是同步的，但支持异步是未来的发展方向）。预计随着 Django
    对异步的感知能力增强，这种支持将会增长和演变。
- en: Let’s learn how to use async views by building a small application that uses
    aiohttp in a view. Imagine that we’re integrating with an external REST API, and
    we want to build a utility to run a few requests concurrently to see response
    times, body length, and how many failures (exceptions) we have. We’ll build a
    view that takes in a URL and request count as query parameters and calls out to
    this URL and aggregates the results, returning them in a tabular format.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过构建一个小型应用程序来学习如何使用异步视图，该应用程序在视图中使用 aiohttp。想象一下，我们正在与外部 REST API 集成，并希望构建一个工具来并发运行几个请求，以查看响应时间、正文长度以及失败（异常）的数量。我们将构建一个视图，该视图接受
    URL 和请求计数作为查询参数，调用该 URL 并汇总结果，以表格格式返回。
- en: 'Let’s get started by ensuring that we have the appropriate version of Django
    installed:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始确保我们安装了适当的 Django 版本：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let’s use the Django admin tool to create the skeleton for our application.
    We’ll call our project `async_views`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 Django 管理工具来创建我们应用程序的框架。我们将我们的项目命名为 `async_views`：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once you run this command, you should see a directory named `async_views` created
    with the following structure:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行此命令，你应该会看到一个名为 `async_views` 的目录被创建，其结构如下：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that we have both a `wsgi.py` and an `asgi.py` file, showing that we can
    deploy to both types of gateway interfaces. You should now be able to use Uvicorn
    to serve the basic Django hello world page. Run the following command from the
    top-level `async_views` directory:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们既有 `wsgi.py` 文件也有 `asgi.py` 文件，这表明我们可以部署到这两种类型的网关接口。你现在应该能够使用 Uvicorn 来提供基本的
    Django 欢迎页面。从顶级 `async_views` 目录运行以下命令：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Then, when you go to `localhost:8000`, you should see the Django welcome page
    (figure 9.2).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当你访问 `localhost:8000` 时，你应该能看到 Django 欢迎页面（图 9.2）。
- en: '![09-02](Images/09-02.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![09-02](Images/09-02.png)'
- en: Figure 9.2 The Django welcome page
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 Django 欢迎页面
- en: Next, we’ll need to create our app, which we’ll call `async_api`. Within the
    `async_ views` directory, run `python` `manage.py` `startapp` `async_api`. This
    will build `model`, `view`, and other files for the `async_api` app.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建我们的应用程序，我们将称之为 `async_api`。在 `async_ views` 目录中，运行 `python manage.py
    startapp async_api`。这将为 `async_api` 应用程序构建 `model`、`view` 和其他文件。
- en: Now, we have everything we need to create our first asynchronous view. Within
    the `async_api` directory there should be a `views.py` file. Inside of this, we
    can specify a view as asynchronous by simply declaring it as a coroutine. In this
    file, we’ll add an async view to make HTTP requests concurrently and display their
    status codes and other data in an HTML table.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经拥有了创建第一个异步视图所需的一切。在 `async_api` 目录中应该有一个 `views.py` 文件。在这个文件中，我们可以通过简单地将其声明为协程来指定一个异步视图。在这个文件中，我们将添加一个异步视图来并发地发出
    HTTP 请求，并在 HTML 表格中显示它们的状态码和其他数据。
- en: Listing 9.11 A Django asynchronous view
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.11 Django 异步视图
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding listing, we first create a coroutine to make a request and
    return a dictionary of the response status, the total time of the request, and
    the length of the response body. Next, we define an async view coroutine named
    `requests_view`. This view gets the URL and request count from the query parameters
    and then makes requests via `get_url_details` concurrently with `gather`. Finally,
    we filter out the successful responses from any failures and put the results in
    a context dictionary that we then pass to `render` to build the response. Note
    that we haven’t built our template for the response yet and are passing in `async_views/requests.html`
    only for right now. Next, let’s build the template, so we can view the results.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们首先创建了一个用于发出请求并返回响应状态、请求总时间和响应正文长度的字典的协程。接下来，我们定义了一个名为 `requests_view`
    的异步视图协程。这个视图从查询参数中获取 URL 和请求计数，然后使用 `gather` 并发地通过 `get_url_details` 发出请求。最后，我们从任何失败中过滤出成功的响应，并将结果放入上下文字典中，然后将其传递给
    `render` 来构建响应。请注意，我们还没有构建响应的模板，现在只传递 `async_views/requests.html`。接下来，让我们构建模板，以便我们可以查看结果。
- en: First, we’ll need to create a `templates` directory under the `async_api` directory,
    then within the templates directory we’ll need to create an `async_api` folder.
    Once we have this directory structure in place, we can add a view inside `async_api/templates/async_api`.
    We’ll call this view `requests.html`, and we’ll loop over the context dictionary
    from our view, putting the results in table format.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在 `async_api` 目录下创建一个 `templates` 目录，然后在模板目录中我们需要创建一个 `async_api` 文件夹。一旦我们有了这个目录结构，我们就可以在
    `async_api/templates/async_api` 中添加一个视图。我们将这个视图命名为 `requests.html`，并遍历来自我们视图的上下文字典，以表格格式放置结果。
- en: Listing 9.12 The requests view
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.12 请求视图
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In our view, we create two tables: one to display any exceptions we encountered,
    and a second to display the successful results we were able to get. While this
    won’t be the prettiest web page ever created, it will have all the relevant information
    we want.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的视图中，我们创建了两个表格：一个用于显示我们遇到的任何异常，另一个用于显示我们能够成功获取的结果。虽然这不会是创建过的最漂亮的网页，但它将包含我们想要的所有相关信息。
- en: 'Next, we’ll need to hook our template and view up to a URL, so it will run
    when we hit it in a browser. In the `async_api` folder, create a `url.py` file
    with the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将我们的模板和视图连接到一个URL，这样它就会在我们用浏览器访问它时运行。在`async_api`文件夹中，创建一个`url.py`文件，内容如下：
- en: Listing 9.13 The async_api/url.py file
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.13 `async_api/url.py`文件
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we’ll need to include the `async_api` app’s URLs within our Django application.
    Within the `async_views/async_views` directory, you should already have a `urls.py`
    file. Inside this file, you’ll need to modify the `urlpatterns` list to reference
    `async_ api`, and once done this should look like the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的Django应用中包含`async_api`应用的URL。在`async_views/async_views`目录中，你应该已经有一个`urls.py`文件。在这个文件中，你需要修改`urlpatterns`列表以引用`async_api`，完成之后它应该看起来像下面这样：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we’ll need to add the `async_views` application to the installed apps.
    In `async_ views/async_views/settings.py`, modify the `INSTALLED_APPS` list to
    include `async_ api`; once done it should look like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将`async_views`应用添加到已安装的应用中。在`async_views/async_views/settings.py`中，修改`INSTALLED_APPS`列表以包含`async_api`；完成之后它应该看起来像这样：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we finally have everything we need to run our application. You can start
    the app with the same `gunicorn` command we used when we first created the Django
    app. Now, you can go to our endpoint and make requests. For example, to hit example.com
    10 times concurrently and get the results, go to:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于有了运行应用程序所需的一切。你可以使用我们首次创建Django应用时使用的相同`gunicorn`命令来启动应用程序。现在，你可以访问我们的端点并发出请求。例如，要并发访问example.com
    10次并获取结果，请访问：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: While numbers will differ on your machine, you should see a page like that shown
    in figure 9.3 displayed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在您的机器上数字可能会有所不同，但你应该会看到一个像图9.3所示的页面。
- en: '![09-03](Images/09-03.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![09-03](Images/09-03.png)'
- en: Figure 9.3 The requests asynchronous view
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 请求异步视图
- en: 'We’ve now built a Django view that can make an arbitrary amount of HTTP requests
    concurrently by hosting it with ASGI, but what if you’re in a situation where
    ASGI isn’t an option? Perhaps you’re working with an older application that relies
    on it; can you still host an async view? We can try this out by running our application
    under Gunicorn with the WSGI application from `wsgi.py` with the synchronous worker
    with the following command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经构建了一个Django视图，可以通过ASGI托管来并发地发出任意数量的HTTP请求，但如果你的情况是ASGI不可用呢？也许你正在使用一个依赖于它的旧应用；你还能托管异步视图吗？我们可以通过以下命令在Gunicorn下运行我们的应用程序来尝试这一点，使用`wsgi.py`中的WSGI应用和同步工作进程：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You should still be able to hit the requests endpoint, and everything will
    work fine. So how does this work? When we run as a WSGI application, a fresh event
    loop is created each time we hit an asynchronous view. We can prove this to ourselves
    by adding a couple of lines of code somewhere in our view:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然应该能够访问请求端点，并且一切都会正常工作。那么这是怎么工作的呢？当我们以WSGI应用运行时，每次我们访问一个异步视图，都会创建一个新的事件循环。我们可以通过在我们的视图中添加几行代码来证明这一点：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `id` function will return an integer that is guaranteed to be unique over
    the lifetime of an object. When running as a WSGI application, each time you hit
    the requests endpoint, this will print a distinct integer, indicating that we
    create a fresh event loop on a per-request basis. Keep the same code when running
    as an ASGI application, and you’ll see the same integer printed every time, since
    ASGI will only have one event loop for the entire application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`函数将返回一个整数，该整数在整个对象的生命周期内保证是唯一的。当作为WSGI应用运行时，每次你访问请求端点，它都会打印一个不同的整数，这表明我们基于每个请求创建了一个新的事件循环。当以ASGI应用运行时保持相同的代码，你将看到每次都会打印相同的整数，因为ASGI将为整个应用程序只有一个事件循环。'
- en: This means we can get the benefits of async views and running things concurrently
    even when running as a WSGI application. However, anything that needs an event
    loop to live across multiple requests won’t work unless you deploy as an ASGI
    application.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以在作为WSGI应用运行时获得异步视图和并发运行的好处。然而，除非你以ASGI应用的形式部署，否则任何需要事件循环跨多个请求运行的东西都不会工作。
- en: 9.4.1 Running blocking work in an asynchronous view
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.1 在异步视图中运行阻塞工作
- en: What about blocking work in an async view? We’re still in a world where many
    libraries are synchronous, but this is incompatible with a single-threaded concurrency
    model. The ASGI specification has a function to deal with these situations named
    `sync_to_async`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在异步视图中进行阻塞工作会怎样呢？我们仍然处于许多库都是同步的世界，但这与单线程并发模型不兼容。ASGI规范有一个函数可以处理这些情况，名为`sync_to_async`。
- en: In chapter 7, we saw that we could run synchronous APIs in thread pool executors
    and get back awaitables we could use with asyncio. The `sync_to_async` function
    essentially does that with a few noteworthy caveats.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章中，我们了解到我们可以在线程池执行器中运行同步API，并获取可以使用asyncio的awaitables。`sync_to_async`函数本质上就是这样做的，但有一些值得注意的注意事项。
- en: The first caveat is that `sync_to_async` has a notion of thread sensitivity.
    In many contexts, synchronous APIs with shared state weren’t designed to be called
    from multiple threads, and doing so could cause race conditions. To deal with
    this, `sync_to_ async` defaults to a “thread sensitive” mode (specifically, this
    function has a `thread_ sensitive` flag that defaults to `True`). This makes any
    sync code we pass in run in Django’s main thread. This means that any blocking
    we do here will block the entire Django application (well, at least one WSGI/ASGI
    worker if we’re running multiple), making us lose some benefits of an async stack
    by doing this.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个注意事项是`sync_to_async`有一个线程敏感性的概念。在许多情况下，具有共享状态的同步API并没有设计成可以从多个线程中调用，这样做可能会导致竞态条件。为了处理这个问题，`sync_to_async`默认为“线程敏感”模式（具体来说，这个函数有一个默认为`True`的`thread_sensitive`标志）。这意味着我们传递给Django的任何同步代码都会在Django的主线程中运行。这意味着我们在这里所做的任何阻塞操作都会阻塞整个Django应用程序（如果我们正在运行多个WSGI/ASGI工作进程，至少会阻塞一个），通过这种方式，我们通过这样做而失去了异步堆栈的一些好处。
- en: If we’re in a situation where thread sensitivity isn’t an issue (in other words,
    when there is no shared state, or the shared state does not rely on being in a
    specific thread), we can change `thread_sensitive` to `False`. This will make
    things run in a new thread per each call, giving us something that won’t block
    Django’s main thread and preserving more benefits of an asynchronous stack.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于线程敏感性不是问题的情况（换句话说，当没有共享状态，或者共享状态不依赖于在特定线程中时），我们可以将`thread_sensitive`更改为`False`。这将使每个调用都在新线程中运行，给我们一个不会阻塞Django主线程的东西，并保留异步堆栈的更多好处。
- en: 'To see this in action, let’s make a new view to test out the variations of
    `sync_ to_async`. We’ll create a function that uses `time.sleep` to put a thread
    to sleep, and we’ll pass that in to `sync_to_async`. We’ll add a query parameter
    to our endpoint, so we can easily switch between thread sensitivity modes to see
    the impact. First, add the following definition to `async_views/async_api/views.py`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这个功能在实际中的应用，让我们创建一个新的视图来测试`sync_to_async`的不同变体。我们将创建一个使用`time.sleep`使线程休眠的函数，并将其传递给`sync_to_async`。我们将向我们的端点添加一个查询参数，这样我们就可以轻松地在线程敏感性模式之间切换，以查看其影响。首先，将以下定义添加到`async_views/async_api/views.py`中：
- en: Listing 9.14 The sync_to_async view
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.14 sync_to_async视图
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, add the following to `async_views/async_api/urls.py` to the `urlpatterns`
    list to wire up the view:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下内容添加到`async_views/async_api/urls.py`中的`urlpatterns`列表中，以连接视图：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, you’ll be able to hit the endpoint. To test this out, let’s sleep for
    5 seconds five times in thread-insensitive mode with the following URL:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将能够访问端点。为了测试这一点，让我们在线程不敏感模式下使用以下URL连续睡眠5秒钟五次：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You’ll notice that this only takes 5 seconds to complete since we’re running
    multiple threads. You’ll also notice if you hit this URL more than once that each
    request still takes only 5 seconds, indicating the requests aren’t blocking each
    other. Now, let’s change the `thread_sensitive` `url` parameter to `True`, and
    you’ll see quite different behavior. First, the view will take 25 seconds to return
    since it is making five 5-second calls sequentially. Second, if you hit the URL
    multiple times, each will block until the other completed, since we’re blocking
    Django’s main thread. The `sync_to_async` function offers us several options to
    use existing code with async views, but you need to be aware of the thread-sensitivity
    of what you’re running, as well as the limitations that this can place on async
    performance benefits.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，由于我们正在运行多个线程，这个过程只需要 5 秒就能完成。如果你多次点击这个 URL，你也会注意到每次请求仍然只需要 5 秒，这表明请求之间并没有互相阻塞。现在，让我们将
    `thread_sensitive` `url` 参数更改为 `True`，你将看到相当不同的行为。首先，视图将需要 25 秒才能返回，因为它正在依次进行五个
    5 秒的调用。其次，如果你多次点击 URL，每个请求都会阻塞，直到另一个请求完成，因为我们正在阻塞 Django 的主线程。`sync_to_async`
    函数为我们提供了几个选项，让我们可以使用现有的代码与异步视图一起使用，但你需要意识到你正在运行的线程敏感性，以及这可能会对异步性能带来的限制。
- en: 9.4.2 Using async code in synchronous views
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4.2 在同步视图中使用异步代码
- en: The next logical question is, “What if I have a synchronous view, but I want
    to use an asyncio library?” The ASGI specification also has a special function
    named `async_ to_sync`. This function accepts a coroutine and runs it in an event
    loop, returning the results in a synchronous fashion. If there is no event loop
    (as is the case in a WSGI application), a new one will be created for us on each
    request; otherwise, this will run in the current event loop (as is the case when
    we run as an ASGI application). To try this out, let’s create a new version of
    our `requests` endpoint as a synchronous view, while still using our async request
    function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个合乎逻辑的问题是，“如果我有一个同步视图，但我想使用 asyncio 库怎么办？” ASGI 规范还有一个名为 `async_to_sync` 的特殊函数。这个函数接受一个协程并在事件循环中运行它，以同步方式返回结果。如果没有事件循环（如
    WSGI 应用程序的情况），则会在每个请求上为我们创建一个新的事件循环；否则，它将在当前事件循环中运行（如我们作为 ASGI 应用程序运行时的情况）。为了尝试这个功能，让我们创建一个新的
    `requests` 端点版本，作为一个同步视图，同时仍然使用我们的异步请求函数。
- en: Listing 9.15 Calling async code in a synchronous view
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.15 在同步视图中调用异步代码
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, add the following to the `urlpatterns` list in `urls.py`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下内容添加到 `urls.py` 中的 `urlpatterns` 列表中：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, you’ll be able to hit the following url and see the same results as we
    saw with our first async view:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将能够点击以下 URL 并看到与我们第一次异步视图相同的结果：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Even in a synchronous WSGI world, `sync_to_async` lets us get some of the performance
    benefits of an asynchronous stack without being fully asynchronous.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在同步 WSGI 世界中，`sync_to_async` 也让我们能够在不完全是异步的情况下获得异步堆栈的一些性能优势。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve learned how to create basic RESTful APIs that hook up to a database with
    aiohttp and asyncpg.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用 aiohttp 和 asyncpg 将基本的 RESTful API 连接到数据库。
- en: We’ve learned how to create ASGI compliant web applications with Starlette.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用 Starlette 创建符合 ASGI 规范的 Web 应用程序。
- en: We’ve learned how to use WebSockets with Starlette to build web applications
    with up-to-date information without HTTP polling.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用 Starlette 和 WebSockets 来构建无需 HTTP 轮询即可提供最新信息的 Web 应用程序。
- en: We’ve learned how to use asynchronous views with Django, and also learned how
    to use async code in synchronous views and vice versa.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学会了如何在 Django 中使用异步视图，并且也学习了如何在同步视图中使用异步代码，反之亦然。
