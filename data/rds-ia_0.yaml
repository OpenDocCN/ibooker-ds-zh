- en: Part 1\. Getting started
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分\. 入门
- en: These first two chapters are an introduction to Redis and offer some basic use
    cases for Redis. After reading these chapters, you should start to get a sense
    for some low-hanging optimizations that Redis might be well suited for in your
    current projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这前两章是 Redis 的介绍，并提供了一些 Redis 的基本用例。阅读这些章节后，你应该开始对 Redis 在你当前项目中可能非常适合的一些低垂的优化有所了解。
- en: Chapter 1\. Getting to know Redis
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 1 章\. 了解 Redis
- en: '*This chapter covers*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: How Redis is like and unlike other software you’ve used
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis 与你使用过的其他软件的相似与不同之处
- en: How to use Redis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Redis
- en: Simple interactions with Redis using example Python code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用示例 Python 代码与 Redis 进行简单交互
- en: Solving real problems with Redis
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Redis 解决实际问题
- en: Redis is an in-memory remote database that offers high performance, replication,
    and a unique data model to produce a platform for solving problems. By supporting
    five different types of data structures, Redis accommodates a wide variety of
    problems that can be naturally mapped into what Redis offers, allowing you to
    solve your problems without having to perform the conceptual gymnastics required
    by other databases. Additional features like replication, persistence, and client-side
    sharding allow Redis to scale from a convenient way to prototype a system, all
    the way up to hundreds of gigabytes of data and millions of requests per second.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 是一个内存远程数据库，提供高性能、复制和独特的数据模型，以解决问题的平台。通过支持五种不同的数据结构，Redis 可以适应各种问题，这些问题可以自然地映射到
    Redis 提供的内容上，让你无需执行其他数据库所需的概念体操即可解决问题。复制、持久化和客户端分片等附加功能使 Redis 能够从方便地原型化系统，扩展到数百
    GB 的数据和每秒数百万次请求。
- en: My first experience with Redis was at a company that needed to search a database
    of client contacts. The search needed to find contacts by name, email address,
    location, and phone number. The system was written to use a SQL database that
    performed a series of queries that would take 10–15 seconds to find matches among
    60,000 clients. After spending a week learning the basics of what was available
    in Redis, I built a search engine that could filter and sort on all of those fields
    and more, returning responses within 50 milliseconds. In just a few weeks of effort
    involving testing and making the system production-worthy, performance improved
    200 times. By reading this book, you can learn about many of the tips, tricks,
    and well-known problems that have been solved using Redis.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我第一次接触 Redis 是在一个需要搜索客户联系数据库的公司。搜索需要通过姓名、电子邮件地址、位置和电话号码来查找联系信息。系统是用 SQL 数据库编写的，执行一系列查询，需要
    10-15 秒才能在 60,000 个客户中找到匹配项。在花费一周时间学习 Redis 的基础知识后，我构建了一个搜索引擎，可以过滤和排序所有这些字段以及更多，响应时间在
    50 毫秒以内。仅仅几周的努力，包括测试和使系统达到生产标准，性能提高了 200 倍。通过阅读这本书，你可以了解许多使用 Redis 解决的技巧、窍门和常见问题。
- en: This chapter will help you to understand where Redis fits within the world of
    databases, and how Redis is useful for solving problems in multiple contexts (communicating
    between different components and languages, and more). Remaining chapters will
    show a variety of problems and their solutions using Redis.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你了解 Redis 在数据库世界中的位置，以及 Redis 如何在多个环境中解决问题（在不同组件和语言之间通信等）。后续章节将展示使用 Redis
    解决的各种问题和解决方案。
- en: Now that you know a bit about how I started using Redis and what we’ll cover,
    let’s talk more about what Redis is, and how it’s probably something you’ve always
    needed, even though you didn’t realize it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了我开始使用 Redis 的方式以及我们将要涵盖的内容，让我们更深入地讨论 Redis 是什么，以及它可能是你一直需要的，即使你没有意识到这一点。
- en: '|  |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Installing redis and python
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安装 redis 和 python
- en: Look in [appendix A](kindle_split_024.html#app01) for quick and dirty installation
    instructions for both Redis and Python.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[附录 A](kindle_split_024.html#app01)中查找 Redis 和 Python 的快速安装说明。
- en: '|  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Using redis from other languages
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用其他语言访问 redis
- en: Though not included in this book, source code for all examples possible will
    be provided in Ruby, Java, and JavaScript (Node.js) shortly after all chapters
    have been completed. For users of the Spring framework, the author of Spring Data’s
    Redis interface, Costin Leau, has teamed up with Redis author Salvatore Sanfilippo
    to produce a one-hour introduction for using Spring with Redis available at [http://www.springsource.org/spring-data/redis](http://www.springsource.org/spring-data/redis).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些示例的源代码不会包含在这本书中，但所有可能的示例源代码将在所有章节完成后不久以 Ruby、Java 和 JavaScript (Node.js)
    的形式提供。对于 Spring 框架的用户，Spring Data Redis 接口的作者 Costin Leau 与 Redis 作者 Salvatore
    Sanfilippo 合作，制作了一个使用 Spring 与 Redis 的一小时入门教程，可在 [http://www.springsource.org/spring-data/redis](http://www.springsource.org/spring-data/redis)
    获取。
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 1.1\. What is Redis?
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1\. 什么是 Redis？
- en: When I say that Redis is a database, I’m only telling a partial truth. Redis
    is a very fast non-relational database that stores a mapping of keys to five different
    types of values. Redis supports in-memory persistent storage on disk, replication
    to scale read performance, and client-side sharding^([[1](#ch01fn01)]) to scale
    write performance. That was a mouthful, but I’ll break it down by parts.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说 Redis 是一个数据库时，我只是在说部分真相。Redis 是一个非常快速的、非关系型数据库，它存储了键到五种不同类型值的映射。Redis 支持在磁盘上的内存持久化存储、用于扩展读性能的复制以及用于扩展写性能的客户端分片^([[1](#ch01fn01)])。这听起来可能有些复杂，但我将分部分来解释。
- en: ¹ Sharding is a method by which you partition your data into different pieces.
    In this case, you partition your data based on IDs embedded in the keys, based
    on the hash of keys, or some combination of the two. Through partitioning your
    data, you can store and fetch the data from multiple machines, which can allow
    a linear scaling in performance for certain problem domains.
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 分片是一种将数据分割成不同部分的方法。在这种情况下，你根据键中嵌入的 ID、键的哈希值或两者的组合来分割数据。通过分割数据，你可以将数据存储和检索到多台机器上，这可以在某些问题域中允许性能的线性扩展。
- en: 1.1.1\. Redis compared to other databases and software
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1\. Redis 与其他数据库和软件的比较
- en: If you’re familiar with relational databases, you’ll no doubt have written SQL
    queries to relate data between tables. Redis is a type of database that’s commonly
    referred to as *NoSQL* or *non-relational*. In Redis, there are no tables, and
    there’s no databasedefined or -enforced way of relating data in Redis with other
    data in Redis.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉关系型数据库，你无疑已经编写过 SQL 查询来关联表中的数据。Redis 是一种通常被称为 *NoSQL* 或 *非关系型* 的数据库类型。在
    Redis 中，没有表，也没有数据库定义或强制执行的方式将 Redis 中的数据与其他 Redis 中的数据关联起来。
- en: It’s not uncommon to hear Redis compared to memcached, which is a very high-performance,
    key-value cache server. Like memcached, Redis can also store a mapping of keys
    to values and can even achieve similar performance levels as memcached. But the
    similarities end quickly—Redis supports the writing of its data to disk automatically
    in two different ways, and can store data in four structures in addition to plain
    string keys as memcached does. These and other differences allow Redis to solve
    a wider range of problems, and allow Redis to be used either as a primary database
    or as an auxiliary database with other storage systems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Redis 与 memcached 进行比较并不罕见，memcached 是一个非常高性能的键值缓存服务器。像 memcached 一样，Redis
    也可以存储键到值的映射，甚至可以达到与 memcached 相似的性能水平。但相似之处很快就会结束——Redis 支持以两种不同的方式自动将数据写入磁盘，并且除了像
    memcached 那样存储纯字符串键之外，还可以存储四种结构的数据。这些以及其他差异使得 Redis 能够解决更广泛的问题，并允许 Redis 被用作主数据库或与其他存储系统一起作为辅助数据库。
- en: In later chapters, we’ll cover examples that show Redis being used for both
    a primary and a secondary storage medium for data, supporting a variety of use
    cases and query patterns. Generally speaking, many Redis users will choose to
    store data in Redis only when the performance or functionality of Redis is necessary,
    using other relational or non-relational data storage for data where slower performance
    is acceptable, or where data is too large to fit in memory economically. In practice,
    you’ll use your judgment as to where you want your data to be stored (primarily
    in Redis, or primarily somewhere else with a copy in Redis), how to ensure data
    integrity (replication, durability, and transactions), and whether Redis will
    fit your needs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中，我们将介绍Redis作为数据的主要和次要存储介质的使用示例，支持各种用例和查询模式。一般来说，许多Redis用户会选择仅在Redis的性能或功能是必需的情况下存储数据，对于性能较慢或数据太大无法经济地存储在内存中的数据，则使用其他关系型或非关系型数据存储。在实践中，您将根据自己的判断来决定数据存储的位置（主要在Redis中，或在其他地方主要存储，同时在Redis中保留副本），如何确保数据完整性（复制、持久性和事务），以及Redis是否满足您的需求。
- en: To get an idea of how Redis fits among the variety of database and cache software
    available, you can see an incomplete listing of a few different types of cache
    or database servers that Redis’s functionality overlaps in [table 1.1](#ch01table01).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Redis在各种数据库和缓存软件中的位置，您可以查看Redis功能重叠的一些不同类型的缓存或数据库服务器的不完整列表，请参阅[表1.1](#ch01table01)。
- en: Table 1.1\. Features and functionality of some databases and cache servers
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表1.1\. 一些数据库和缓存服务器的特性和功能
- en: '| Name | Type | Data storage options | Query types | Additional features |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 类型 | 数据存储选项 | 查询类型 | 其他特性 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Redis | In-memory non-relational database | Strings, lists, sets, hashes,
    sorted sets | Commands for each data type for common access patterns, with bulk
    operations, and partial transaction support | Publish/Subscribe, master/slave
    replication, disk persistence, scripting (stored procedures) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| Redis | 内存中非关系型数据库 | 字符串，列表，集合，散列，有序集合 | 每种数据类型的常见访问模式命令，批量操作和部分事务支持 | 发布/订阅，主/从复制，磁盘持久化，脚本（存储过程）|'
- en: '| memcached | In-memory key-value cache | Mapping of keys to values | Commands
    for create, read, update, delete, and a few others | Multithreaded server for
    additional performance |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| memcached | 内存中键值缓存 | 键到值的映射 | 创建、读取、更新、删除等命令和一些其他命令 | 多线程服务器以提供额外性能|'
- en: '| MySQL | Relational database | Databases of tables of rows, views over tables,
    spatial and third-party extensions | SELECT, INSERT, UPDATE, DELETE, functions,
    stored procedures | ACID compliant (with InnoDB), master/slave and master/master
    replication |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| MySQL | 关系型数据库 | 行表数据库，表视图，空间和第三方扩展 | SELECT, INSERT, UPDATE, DELETE, 函数，存储过程
    | 符合ACID（InnoDB），主/从复制和主/主复制|'
- en: '| PostgreSQL | Relational database | Databases of tables of rows, views over
    tables, spatial and third-party extensions, customizable types | SELECT, INSERT,
    UPDATE, DELETE, built-in functions, custom stored procedures | ACID compliant,
    master/slave replication, multi-master replication (third party) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| PostgreSQL | 关系型数据库 | 行表数据库，表视图，空间和第三方扩展，可自定义类型 | SELECT, INSERT, UPDATE,
    DELETE, 内置函数，自定义存储过程 | 符合ACID，主/从复制，多主复制（第三方）|'
- en: '| MongoDB | On-disk non-relational document store | Databases of tables of
    schema-less BSON documents | Commands for create, read, update, delete, conditional
    queries, and more | Supports map-reduce operations, master/slave replication,
    sharding, spatial indexes |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| MongoDB | 磁盘上非关系型文档存储 | 无模式BSON文档的表数据库 | 创建、读取、更新、删除、条件查询等命令 | 支持map-reduce操作，主/从复制，分片，空间索引|'
- en: 1.1.2\. Other features
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2\. 其他特性
- en: When using an in-memory database like Redis, one of the first questions that’s
    asked is “What happens when my server gets turned off?” Redis has two different
    forms of persistence available for writing in-memory data to disk in a compact
    format. The first method is a point-in-time dump either when certain conditions
    are met (a number of writes in a given period) or when one of the two dump-to-disk
    commands is called. The other method uses an append-only file that writes every
    command that alters data in Redis to disk as it happens. Depending on how careful
    you want to be with your data, append-only writing can be configured to never
    sync, sync once per second, or sync at the completion of every operation. We’ll
    discuss these persistence options in more depth in [chapter 4](kindle_split_015.html#ch04).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用像 Redis 这样的内存数据库时，人们通常会问的第一个问题是：“当我的服务器关闭时会发生什么？”Redis 提供两种不同的持久化形式，可以将内存中的数据以紧凑的格式写入磁盘。第一种方法是满足某些条件（给定时间段内的写入次数）或调用两个写入磁盘命令之一时的时间点转储。另一种方法使用一个只写文件，它会将更改
    Redis 数据的每个命令实时写入磁盘。根据你对数据的谨慎程度，只写写入可以配置为从不同步、每秒同步一次，或在每次操作完成后同步。我们将在第 4 章[更深入地讨论这些持久化选项](kindle_split_015.html#ch04)。
- en: Even though Redis is able to perform well, due to its in-memory design there
    are situations where you may need Redis to process more read queries than a single
    Redis server can handle. To support higher rates of read performance (along with
    handling failover if the server that Redis is running on crashes), Redis supports
    master/slave replication where slaves connect to the master and receive an initial
    copy of the full database. As writes are performed on the master, they’re sent
    to all connected slaves for updating the slave datasets in real time. With continuously
    updated data on the slaves, clients can then connect to any slave for reads instead
    of making requests to the master. We’ll discuss Redis slaves more thoroughly in
    [chapter 4](kindle_split_015.html#ch04).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Redis 能够表现出色，但由于其内存设计，在某些情况下，你可能需要 Redis 处理比单个 Redis 服务器能处理的更多读取查询。为了支持更高的读取性能（以及处理
    Redis 运行的服务器崩溃时的故障转移），Redis 支持主/从复制，其中从服务器连接到主服务器并接收完整数据库的初始副本。由于写入操作在主服务器上执行，因此它们会被发送到所有连接的从服务器以实时更新从服务器数据集。随着从服务器上数据的持续更新，客户端可以连接到任何从服务器进行读取，而不是向主服务器发送请求。我们将在第
    4 章[详细讨论 Redis 从服务器](kindle_split_015.html#ch04)。
- en: 1.1.3\. Why Redis?
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.3\. 为什么选择 Redis？
- en: If you’ve used memcached before, you probably know that you can add data to
    the end of an existing string with `APPEND`. The documentation for memcached states
    that `APPEND` can be used for managing lists of items. Great! You add items to
    the end of the string you’re treating as a list. But then how do you remove items?
    The memcached answer is to use a blacklist to hide items, in order to avoid read/update/write
    (or a database query and memcached write). In Redis, you’d either use a `LIST`
    or a `SET` and then add and remove items directly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用过 memcached，你可能知道你可以使用 `APPEND` 将数据添加到现有字符串的末尾。memcached 的文档指出，`APPEND`
    可以用于管理项目列表。太好了！你将项目添加到你将其视为列表的字符串的末尾。但然后如何删除项目呢？memcached 的答案是使用黑名单来隐藏项目，以避免读取/更新/写入（或数据库查询和
    memcached 写入）。在 Redis 中，你可以使用 `LIST` 或 `SET`，然后直接添加和删除项目。
- en: By using Redis instead of memcached for this and other problems, not only can
    your code be shorter, easier to understand, and easier to maintain, but it’s faster
    (because you don’t need to read a database to update your data). You’ll see that
    there are also many other cases where Redis is more efficient and/or easier to
    use than relational databases.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Redis 而不是 memcached 解决这些问题和其他问题，不仅可以使你的代码更短、更容易理解、更容易维护，而且速度更快（因为你不需要读取数据库来更新你的数据）。你会发现还有许多其他情况下
    Redis 比关系型数据库更高效且/或更容易使用。
- en: One common use of databases is to store long-term reporting data as aggregates
    over fixed time ranges. To collect these aggregates, it’s not uncommon to insert
    rows into a reporting table and then later to scan over those rows to collect
    the aggregates, which then update existing rows in an aggregation table. Rows
    are inserted because, for most databases, inserting rows is a very fast operation
    (inserts write to the end of an on-disk file, not unlike Redis’s append-only log).
    But updating an existing row in a table is fairly slow (it can cause a random
    read and may cause a random write). In Redis, you’d calculate the aggregates directly
    using one of the atomic `INCR` commands—random writes to Redis data are always
    fast, because data is always in memory,^([[2](#ch01fn02)]) and queries to Redis
    don’t need to go through a typical query parser/optimizer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的一个常见用途是将长期报告数据作为固定时间范围内的聚合存储。为了收集这些聚合数据，将行插入到报告表中，然后稍后扫描这些行以收集聚合数据，并更新聚合表中的现有行，这种情况并不少见。行被插入，因为对于大多数数据库来说，插入行是一个非常快的操作（插入写入磁盘文件的末尾，这与
    Redis 的只追加日志类似）。但是，在表中更新现有行相对较慢（它可能引起随机读取，并可能导致随机写入）。在 Redis 中，你可以使用其中一个原子的 `INCR`
    命令直接计算聚合——对 Redis 数据的随机写入总是很快，因为数据始终在内存中，^([[2](#ch01fn02)])，并且对 Redis 的查询不需要通过典型的查询解析器/优化器。
- en: ² To be fair, memcached could also be used in this simple scenario, but with
    Redis, your aggregates can be placed in structures that keep associated aggregates
    together for easy access; the aggregates can be a part of a sorted sequence of
    aggregates for keeping a toplist in real time; and the aggregates can be integer
    or floating point.
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 公平起见，memcached 也可以用于这种简单场景，但使用 Redis，你的聚合可以放置在保持相关聚合在一起以便于访问的结构中；聚合可以是聚合序列的一部分，以实时保持排行榜；聚合可以是整数或浮点数。
- en: By using Redis instead of a relational or other primarily on-disk database,
    you can avoid writing unnecessary temporary data, avoid needing to scan over and
    delete this temporary data, and ultimately improve performance. These are both
    simple examples, but they demonstrate how your choice of tool can greatly affect
    the way you solve your problems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Redis 而不是关系型或其他主要基于磁盘的数据库，你可以避免编写不必要的临时数据，避免需要扫描和删除这些临时数据，并最终提高性能。这些只是简单的例子，但它们展示了你的工具选择如何极大地影响你解决问题的方法。
- en: As you continue to read about Redis, try to remember that almost everything
    that we do is an attempt to solve a problem in real time (except for task queues
    in [chapter 6](kindle_split_017.html#ch06)). I show techniques and provide working
    code for helping you remove bottlenecks, simplify your code, collect data, distribute
    data, build utilities, and, overall, to make your task of building software easier.
    When done right, your software can even scale to levels that would make other
    users of so-called web-scale technologies blush.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你继续阅读关于 Redis 的内容，请记住，我们几乎所做的一切都是为了实时解决问题（除了第 6 章中的任务队列 [chapter 6](kindle_split_017.html#ch06)）。我会展示技术并提供可工作的代码，帮助你消除瓶颈、简化代码、收集数据、分发数据、构建工具，以及总体上使你的软件开发任务变得更简单。当做得正确时，你的软件甚至可以扩展到让其他使用所谓
    Web 规模技术的用户都感到羞愧的水平。
- en: We could keep talking about what Redis has, what it can do, or even why. Or
    I could show you. In the next section, we’ll discuss the structures available
    in Redis, what they can do, and some of the commands used to access them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续讨论 Redis 有什么，它能做什么，甚至为什么。或者我可以给你展示。在下一节中，我们将讨论 Redis 中可用的结构，它们能做什么，以及一些用于访问它们的命令。
- en: 1.2\. What Redis data structures look like
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2. Redis 数据结构的外观
- en: As shown in [table 1.1](#ch01table01), Redis allows us to store keys that map
    to any one of five different data structure types; `STRING`s, `LIST`s, `SET`s,
    `HASH`es, and `ZSET`s. Each of the five different structures have some shared
    commands (`DEL`, `TYPE`, `RENAME`, and others), as well as some commands that
    can only be used by one or two of the structures. We’ll dig more deeply into the
    available commands in [chapter 3](kindle_split_014.html#ch03).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [表 1.1](#ch01table01) 所示，Redis 允许我们存储映射到五种不同数据结构类型的键；`STRING`s、`LIST`s、`SET`s、`HASH`es
    和 `ZSET`s。这五种不同的结构都有一些共享的命令（`DEL`、`TYPE`、`RENAME` 等），以及一些只能由一个或两个结构使用的命令。我们将在第
    3 章中更深入地探讨可用的命令 [chapter 3](kindle_split_014.html#ch03)。
- en: Among the five structures available in Redis, `STRING`s, `LIST`s, and `HASH`es
    should be familiar to most programmers. Their implementation and semantics are
    similar to those same structures built in a variety of other languages. Some programming
    languages also have a set data structure, comparable to Redis `SET`s in implementation
    and semantics. `ZSET`s are somewhat unique to Redis, but are handy when we get
    around to using them. A comparison of the five structures available in Redis,
    what they contain, and a brief description of their semantics can be seen in [table
    1.2](#ch01table02).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Redis提供的五种结构中，`STRING`、`LIST`和`HASH`对于大多数程序员来说应该是熟悉的。它们的实现和语义与其他各种语言中构建的相同结构相似。一些编程语言也有集合数据结构，在实现和语义上与Redis的`SET`类似。`ZSET`在Redis中是独一无二的，但当我们开始使用它们时，它们会变得很有用。Redis中提供的五种结构的比较，它们包含的内容以及它们语义的简要描述，可以在[表1.2](#ch01table02)中看到。
- en: Table 1.2\. The five structures available in Redis
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表1.2\. Redis中可用的五种结构
- en: '| Structure type | What it contains | Structure read/write ability |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 结构类型 | 包含的内容 | 结构的读写能力 |'
- en: '| --- | --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| STRING | Strings, integers, or floating-point values | Operate on the whole
    string, parts, increment/decrement the integers and floats |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| STRING | 字符串、整数或浮点值 | 对整个字符串、部分进行操作，增加/减少整数和浮点数 |'
- en: '| LIST | Linked list of strings | Push or pop items from both ends, trim based
    on offsets, read individual or multiple items, find or remove items by value |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| LIST | 字符串的链表 | 从两端推送或弹出项目，基于偏移量修剪，读取单个或多个项目，根据值查找或删除项目 |'
- en: '| SET | Unordered collection of unique strings | Add, fetch, or remove individual
    items, check membership, intersect, union, difference, fetch random items |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| SET | 唯一字符串的无序集合 | 添加、获取或删除单个项目，检查成员资格，交集、并集、差集，随机获取项目 |'
- en: '| HASH | Unordered hash table of keys to values | Add, fetch, or remove individual
    items, fetch the whole hash |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| HASH | 键到值的无序哈希表 | 添加、获取或删除单个项目，获取整个哈希表 |'
- en: '| ZSET (sorted set) | Ordered mapping of string members to floating-point scores,
    ordered by score | Add, fetch, or remove individual values, fetch items based
    on score ranges or member value |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| ZSET（有序集合） | 字符串成员到浮点分数的有序映射，按分数排序 | 添加、获取或删除单个值，基于分数范围或成员值获取项目 |'
- en: '|  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Command listing
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 命令列表
- en: As we discuss each data type in this section, you’ll find small tables of commands.
    A more complete (but partial) listing of commands for each type can be found in
    [chapter 3](kindle_split_014.html#ch03). If you need a complete command listing
    with documentation, you can visit [http://redis.io/commands](http://redis.io/commands).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节讨论每种数据类型时，您会发现一些命令的小表格。每种类型的命令的更完整（但部分）列表可以在[第3章](kindle_split_014.html#ch03)中找到。如果您需要带有文档的完整命令列表，可以访问[http://redis.io/commands](http://redis.io/commands)。
- en: '|  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Throughout this section, you’ll see how to represent all five of these structures,
    and you’ll get a chance to start using Redis commands in preparation for later
    chapters. In this book, all of the examples are provided in Python. If you’ve
    installed Redis as described in [appendix A](kindle_split_024.html#app01), you
    should also have installed Python and the necessary libraries to use Redis from
    Python as part of that process. If possible, you should have a computer with Redis,
    Python, and the redis-py library installed so that you can try everything out
    while reading.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解如何表示所有五种这些结构，您将有机会开始使用Redis命令，为后续章节做准备。在本书中，所有示例都是用Python提供的。如果您按照[附录A](kindle_split_024.html#app01)中描述的方式安装了Redis，那么您也应该安装了Python以及使用Redis的Python库所需的必要库。如果可能的话，您应该有一个安装了Redis、Python和redis-py库的计算机，这样您就可以在阅读时尝试所有内容。
- en: '|  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Reminder About Installing Redis and Python
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 安装Redis和Python的注意事项
- en: 'Before you continue, you’ll want to install Redis and Python. Again, quick
    and dirty installation instructions for both Redis and Python can be found in
    [appendix A](kindle_split_024.html#app01). Even quicker and dirtier instructions
    for Debian-based Linux distributions are as follows: download Redis from [http://redis.io/download](http://redis.io/download),
    extract, run `make && sudo make install`, and then run `sudo python -m easy_install
    redis hiredis` (*hiredis* is an optional performance-improving C library).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您需要安装Redis和Python。再次提醒，Redis和Python的快速安装说明可以在[附录A](kindle_split_024.html#app01)中找到。对于基于Debian的Linux发行版，更快的安装说明如下：从[http://redis.io/download](http://redis.io/download)下载Redis，解压，运行`make
    && sudo make install`，然后运行`sudo python -m easy_install redis hiredis`（*hiredis*是一个可选的性能提升C库）。
- en: '|  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you’re familiar with procedural or object-oriented programming languages,
    Python should be understandable, even if you haven’t used it before. If you’re
    using another language with Redis, you should be able to translate everything
    we’re doing with Python to your language, though method names for Redis commands
    and the arguments they take may be spelled (or ordered) differently.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉过程式或面向对象的编程语言，即使你没有使用过 Python，Python 也应该是可理解的。如果你使用的是其他 Redis 语言，你应该能够将我们用
    Python 所做的一切翻译成你的语言，尽管 Redis 命令的名称和方法可能拼写（或顺序）不同。
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Redis with Other Languages
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Redis 与其他语言
- en: Though not included in this book, all code listings that can be converted have
    translations to Ruby, JavaScript, and Java available for download from the Manning
    website or linked from this book’s Manning forum. This translated code also includes
    similar descriptive annotations so that you can follow along in your language
    of choice.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书中没有包含，但所有可转换的代码列表都有 Ruby、JavaScript 和 Java 的翻译可供下载，这些翻译可以从 Manning 网站或本书的
    Manning 论坛链接获取。这些翻译代码还包括类似的描述性注释，以便你可以用你选择的语言跟踪。
- en: '|  |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'As a matter of style, I attempt to keep the use of more advanced features of
    Python to a minimum, writing functions to perform operations against Redis instead
    of constructing classes or otherwise. I do this to keep the syntax of Python from
    interfering with the focal point of this book, which is solving problems with
    Redis, and not “look at this cool stuff we can do with Python.” For this section,
    we’ll use a redis-cli console to interact with Redis. Let’s get started with the
    first and simplest structure available in Redis: `STRING`s.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种风格，我尽量减少 Python 更高级特性的使用，编写函数来执行对 Redis 的操作，而不是构建类或其他方式。我这样做是为了让 Python
    的语法不会干扰本书的重点，即用 Redis 解决问题，而不是“看看我们能用 Python 做的酷东西。” 对于本节，我们将使用 redis-cli 控制台与
    Redis 进行交互。让我们从 Redis 中第一个和最简单的结构开始：`STRING`s。
- en: 1.2.1\. Strings in Redis
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1\. Redis 中的字符串
- en: In Redis, `STRING`s are similar to strings that we see in other languages or
    other key-value stores. Generally, when I show diagrams that represent keys and
    values, the diagrams have the key name and the type of the value along the top
    of a box, with the value inside the box. I’ve labeled which part is which as an
    example in [figure 1.1](#ch01fig01), which shows a `STRING` with key `hello` and
    value `world`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Redis 中，`STRING`s 与我们在其他语言或其他键值存储中看到的字符串类似。通常，当我展示表示键和值的图表时，图表的顶部有键名和值的类型，值在框内。我在
    [图 1.1](#ch01fig01) 中标记了哪些部分是哪些，它显示了一个键为 `hello`、值为 `world` 的 `STRING`。
- en: Figure 1.1\. An example of a `STRING, world`, stored under a key, `hello`
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.1\. 一个示例，`STRING, world` 存储在键 `hello` 下
- en: '![](01fig01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig01.jpg)'
- en: The operations available to `STRING`s start with what’s available in other key-value
    stores. We can `GET` values, `SET` values, and `DEL` values. After you have installed
    and tested Redis as described in [appendix A](kindle_split_024.html#app01), within
    redis-cli you can try to `SET`, `GET`, and `DEL` values in Redis, as shown in
    [listing 1.1](#ch01ex01), with the basic meanings of the functions described in
    [table 1.3](#ch01table03).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于 `STRING` 的操作始于其他键值存储中可用的操作。我们可以 `GET` 值、`SET` 值和 `DEL` 值。按照附录 A（kindle_split_024.html#app01）中描述的安装和测试
    Redis 后，在 redis-cli 中，你可以尝试在 Redis 中 `SET`、`GET` 和 `DEL` 值，如 [列表 1.1](#ch01ex01)
    所示，其中函数的基本含义在 [表 1.3](#ch01table03) 中描述。
- en: Table 1.3\. Commands used on `STRING` values
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 1.3\. 用于 `STRING` 值的命令
- en: '| Command | What it does |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 它做什么 |'
- en: '| --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| GET | Fetches the data stored at the given key |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| GET | 从给定键获取数据 |'
- en: '| SET | Sets the value stored at the given key |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| SET | 设置给定键存储的值 |'
- en: '| DEL | Deletes the value stored at the given key (works for all types) |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| DEL | 删除给定键存储的值（适用于所有类型） |'
- en: Listing 1.1\. An example showing the `SET`, `GET`, and `DEL` commands in Redis
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.1\. Redis 中 `SET`、`GET` 和 `DEL` 命令的示例
- en: '![](009fig01_alt.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](009fig01_alt.jpg)'
- en: '|  |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Using redis-cli
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 redis-cli
- en: In this first chapter, I introduce Redis and some commands using the *redis-cli*
    interactive client that comes with Redis. This allows you to get started interacting
    with Redis quickly and easily.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我介绍了 Redis 以及一些使用 Redis 伴随的 *redis-cli* 交互式客户端的命令。这允许你快速轻松地开始与 Redis
    交互。
- en: '|  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In addition to being able to `GET`, `SET`, and `DEL STRING` values, there are
    a handful of other commands for reading and writing parts of `STRING`s, and commands
    that allow us to treat strings as numbers to increment/decrement them. We’ll talk
    about many of those commands in [chapter 3](kindle_split_014.html#ch03). But we
    still have a lot of ground to cover, so let’s move on to take a peek at `LIST`s
    and what we can do with them.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够`GET`、`SET`和`DEL STRING`值之外，还有一些其他命令用于读取和写入`STRING`的部分，以及允许我们将字符串视为数字来递增/递减它们的命令。我们将在[第3章](kindle_split_014.html#ch03)中讨论许多这些命令。但我们还有很多内容要覆盖，所以让我们继续看看`LIST`以及我们可以用它做什么。
- en: 1.2.2\. Lists in Redis
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2\. Redis中的列表
- en: In the world of key-value stores, Redis is unique in that it supports a linked-list
    structure. `LIST`s in Redis store an ordered sequence of strings, and like `STRING`s,
    I represent figures of `LIST`s as a labeled box with list items inside. An example
    of a `LIST` can be seen in [figure 1.2](#ch01fig02).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在键值存储的世界中，Redis的独特之处在于它支持链表结构。Redis中的`LIST`存储了一系列有序的字符串，就像`STRING`一样，我用一个带有列表项的标签框来表示`LIST`。一个`LIST`的例子可以在[图1.2](#ch01fig02)中看到。
- en: Figure 1.2\. An example of a `LIST` with three items under the key, `list-key`.
    Note that `item` can be in the list more than once.
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.2\. 关键字`list-key`下有三个项的`LIST`示例。注意`item`可以在列表中出现多次。
- en: '![](01fig02.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig02.jpg)'
- en: The operations that can be performed on `LIST`s are typical of what we find
    in almost any programming language. We can push items to the front and the back
    of the `LIST` with `LPUSH`/`RPUSH`; we can pop items from the front and back of
    the list with `LPOP`/`RPOP`; we can fetch an item at a given position with `LINDEX`;
    and we can fetch a range of items with `LRANGE`. Let’s continue our Redis client
    interactions by following along with interactions on `LIST`s, as shown in [listing
    1.2](#ch01ex02). [Table 1.4](#ch01table04) gives a brief description of the commands
    we can use on lists.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`LIST`上执行的操作在几乎所有编程语言中都很典型。我们可以使用`LPUSH`/`RPUSH`将项推送到`LIST`的前端和后端；我们可以使用`LPOP`/`RPOP`从列表的前端和后端弹出项；我们可以使用`LINDEX`获取指定位置的项；我们可以使用`LRANGE`获取一系列项。让我们继续我们的Redis客户端交互，通过查看对`LIST`的交互，如[列表1.2](#ch01ex02)所示。[表1.4](#ch01table04)给出了我们可以用在列表上的命令的简要描述。
- en: Table 1.4\. Commands used on `LIST` values
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表1.4\. 对`LIST`值使用的命令
- en: '| Command | What it does |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 它做什么 |'
- en: '| --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| RPUSH | Pushes the value onto the right end of the list |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| RPUSH | 将值推送到列表的右端 |'
- en: '| LRANGE | Fetches a range of values from the list |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| LRANGE | 从列表中获取一系列值 |'
- en: '| LINDEX | Fetches an item at a given position in the list |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| LINDEX | 从列表中获取指定位置的项 |'
- en: '| LPOP | Pops the value from the left end of the list and returns it |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| LPOP | 从列表的左侧弹出值并返回它 |'
- en: Listing 1.2\. The `RPUSH`, `LRANGE`, `LINDEX`, and `LPOP` commands in Redis
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.2\. Redis中的`RPUSH`、`LRANGE`、`LINDEX`和`LPOP`命令
- en: '![](010fig01_alt.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](010fig01_alt.jpg)'
- en: Even if that was all that we could do with `LIST`s, Redis would already be a
    useful platform for solving a variety of problems. But we can also remove items,
    insert items in the middle, trim the list to be a particular size (discarding
    items from one or both ends), and more. We’ll talk about many of those commands
    in [chapter 3](kindle_split_014.html#ch03), but for now let’s keep going to see
    what `SET`s can offer us.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们只能用`LIST`做这么多，Redis也已经是一个解决各种问题的有用平台。但我们还可以删除项，在中间插入项，修剪列表到特定大小（从一端或两端丢弃项），等等。我们将在[第3章](kindle_split_014.html#ch03)中讨论许多这些命令，但现在让我们继续看看`SET`能给我们带来什么。
- en: 1.2.3\. Sets in Redis
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.3\. Redis中的集合
- en: In Redis, `SET`s are similar to `LIST`s in that they’re a sequence of strings,
    but unlike `LIST`s, Redis `SET`s use a hash table to keep all strings unique (though
    there are no associated values). My visual representation of `SET`s will be similar
    to `LIST`s, and [figure 1.3](#ch01fig03) shows an example `SET` with three items.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Redis中，`SET`与`LIST`类似，因为它们都是字符串序列，但与`LIST`不同，Redis的`SET`使用哈希表来保持所有字符串的唯一性（尽管没有关联的值）。我对`SET`的视觉表示将与`LIST`类似，[图1.3](#ch01fig03)显示了包含三个项的示例`SET`。
- en: Figure 1.3\. An example of a `SET` with three items under the key, `set-key`
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.3\. 关键字`set-key`下有三个项的`SET`示例
- en: '![](01fig03.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig03.jpg)'
- en: Because Redis `SET`s are unordered, we can’t push and pop items from the ends
    like we did with `LIST`s. Instead, we add and remove items by value with the `SADD`
    and `SREM` commands. We can also find out whether an item is in the `SET` quickly
    with `SISMEMBER`, or fetch the entire set with `SMEMBERS` (this can be slow for
    large `SET`s, so be careful). You can follow along with [listing 1.3](#ch01ex03)
    in your Redis client console to get a feel for how `SET`s work, and [table 1.5](#ch01table05)
    describes the commands used here.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Redis 的 `SET` 是无序的，我们不能像对 `LIST` 那样从两端推入和弹出项。相反，我们使用 `SADD` 和 `SREM` 命令通过值添加和删除项。我们还可以使用
    `SISMEMBER` 快速确定项是否在 `SET` 中，或者使用 `SMEMBERS` 获取整个集合（对于大型 `SET`，这可能会很慢，所以请小心）。您可以在
    Redis 客户端控制台中跟随[列表 1.3](#ch01ex03) 来了解 `SET` 的工作方式，[表 1.5](#ch01table05) 描述了这里使用的命令。
- en: Table 1.5\. Commands used on `SET` values
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 1.5\. 对 `SET` 值使用的命令
- en: '| Command | What it does |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 执行的操作 |'
- en: '| --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| SADD | Adds the item to the set |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| SADD | 向集合中添加项 |'
- en: '| SMEMBERS | Returns the entire set of items |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| SMEMBERS | 返回整个项集合 |'
- en: '| SISMEMBER | Checks if an item is in the set |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| SISMEMBER | 检查项是否在集合中 |'
- en: '| SREM | Removes the item from the set, if it exists |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| SREM | 如果存在，则从集合中删除项 |'
- en: Listing 1.3\. The `SADD`, `SMEMBERS`, `SISMEMBER`, and `SREM` commands in Redis
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.3\. Redis 中的 `SADD`、`SMEMBERS`、`SISMEMBER` 和 `SREM` 命令
- en: '![](012fig01_alt.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](012fig01_alt.jpg)'
- en: As you can probably guess based on the `STRING` and `LIST` sections, `SET`s
    have many other uses beyond adding and removing items. Three commonly used operations
    with `SET`s include intersection, union, and difference (`SINTER`, `SUNION`, and
    `SDIFF`, respectively). We’ll get into more detail about `SET` commands in [chapter
    3](kindle_split_014.html#ch03), and over half of [chapter 7](kindle_split_018.html#ch07)
    involves problems that can be solved almost entirely with Redis `SET`s. But let’s
    not get ahead of ourselves; we’ve still got two more structures to go. Keep reading
    to learn about Redis `HASH`es.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您对 `STRING` 和 `LIST` 部分的了解，`SET` 有许多其他用途，而不仅仅是添加和删除项。与 `SET` 相关的三个常用操作包括交集、并集和差集（分别对应
    `SINTER`、`SUNION` 和 `SDIFF`）。我们将在[第 3 章](kindle_split_014.html#ch03)中详细介绍 `SET`
    命令，第 7 章[的一半](kindle_split_018.html#ch07)涉及的问题几乎都可以用 Redis `SET` 解决。但让我们不要过于急躁；我们还有两个结构要讨论。继续阅读以了解
    Redis `HASH`。
- en: 1.2.4\. Hashes in Redis
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.4\. Redis 中的哈希
- en: 'Whereas `LIST`s and `SET`s in Redis hold sequences of items, Redis `HASH`es
    store a mapping of keys to values. The values that can be stored in `HASH`es are
    the same as what can be stored as normal `STRING`s: strings themselves, or if
    a value can be interpreted as a number, that value can be incremented or decremented.
    [Figure 1.4](#ch01fig04) shows a diagram of a hash with two values.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Redis 中的 `LIST` 和 `SET` 一样，`HASH` 存储键到值的映射。可以存储在 `HASH` 中的值与作为正常 `STRING`
    存储的值相同：字符串本身，或者如果值可以解释为数字，则该值可以增加或减少。[图 1.4](#ch01fig04) 显示了一个包含两个值的哈希的图。
- en: Figure 1.4\. An example of a `HASH` with two keys/values under the key `hash-key`
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.4\. 一个在 `hash-key` 键下有两个键/值的 `HASH` 示例
- en: '![](01fig04.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig04.jpg)'
- en: In a lot of ways, we can think of `HASH`es in Redis as miniature versions of
    Redis itself. Some of the same commands that we can perform on `STRING`s, we can
    perform on the values inside `HASH`es with slightly different commands. Try to
    follow [listing 1.4](#ch01ex04) to see some commands that we can use to insert,
    fetch, and remove items from `HASH`es. [Table 1.6](#ch01table06) describes the
    commands.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多方面，我们可以将 Redis 中的 `HASH` 视为 Redis 本身的微型版本。我们可以对 `STRING` 执行的一些相同命令，也可以对 `HASH`
    内部的值执行，只需使用稍微不同的命令。尝试跟随[列表 1.4](#ch01ex04) 来查看我们可以用于向 `HASH` 中插入、获取和删除项的命令。[表
    1.6](#ch01table06) 描述了这些命令。
- en: Table 1.6\. Commands used on `HASH` values
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 1.6\. 对 `HASH` 值使用的命令
- en: '| Command | What it does |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 执行的操作 |'
- en: '| --- | --- |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| HSET | Stores the value at the key in the hash |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| HSET | 在哈希中存储键的值 |'
- en: '| HGET | Fetches the value at the given hash key |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| HGET | 获取给定哈希键的值 |'
- en: '| HGETALL | Fetches the entire hash |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| HGETALL | 获取整个哈希 |'
- en: '| HDEL | Removes a key from the hash, if it exists |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| HDEL | 如果存在，则从哈希中删除键 |'
- en: Listing 1.4\. The `HSET`, `HGET`, `HGETALL`, and `HDEL` commands in Redis
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.4\. Redis 中的 `HSET`、`HGET`、`HGETALL` 和 `HDEL` 命令
- en: '![](013fig01_alt.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](013fig01_alt.jpg)'
- en: For those who are familiar with document stores or relational databases, we
    can consider a Redis `HASH` as being similar to a *document* in a document store,
    or a *row* in a relational database, in that we can access or change individual
    or multiple fields at a time. We’re now one structure from having seen all of
    the structures available in Redis. Keep reading to learn what `ZSET`s are and
    a few things that we can do with them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉文档存储或关系型数据库的人来说，我们可以将 Redis 的 `HASH` 视为文档存储中的 *文档* 或关系型数据库中的 *行*，因为我们可以在一次访问或更改单个或多个字段。我们现在已经看到了
    Redis 中所有可用的结构。继续阅读以了解 `ZSET` 是什么以及我们可以用它做什么。
- en: 1.2.5\. Sorted sets in Redis
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.5\. Redis 中的有序集合
- en: Like Redis `HASH`es, `ZSET`s also hold a type of key and value. The keys (called
    *members*) are unique, and the values (called *scores*) are limited to floating-point
    numbers. `ZSET`s have the unique property in Redis of being able to be accessed
    by member (like a `HASH`), but items can also be accessed by the sorted order
    and values of the scores. [Figure 1.5](#ch01fig05) shows an example `ZSET` with
    two items.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Redis 的 `HASH` 类似，`ZSET` 也包含一种键和值。键（称为 *成员*）是唯一的，值（称为 *分数*）限于浮点数。`ZSET` 在
    Redis 中具有独特的属性，可以通过成员（如 `HASH`）访问，但项目也可以通过分数的排序顺序和值进行访问。[图 1.5](#ch01fig05) 展示了一个包含两个项目的示例
    `ZSET`。
- en: Figure 1.5\. An example of a `ZSET` with two members/scores under the key `zset-key`
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.5\. `zset-key` 键下有两个成员/分数的 `ZSET` 示例
- en: '![](01fig05.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![01fig05](01fig05.jpg)'
- en: As is the case with all of the other structures, we need to be able to add,
    remove, and fetch items from `ZSET`s. [Listing 1.5](#ch01ex05) offers add, remove,
    and fetching commands for `ZSET`s similar to those for the other structures, and
    [table 1.7](#ch01table07) describes the commands that we’ll use.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他结构一样，我们需要能够向 `ZSET` 中添加、删除和检索项目。[列表 1.5](#ch01ex05) 提供了类似于其他结构的添加、删除和检索命令，而[表
    1.7](#ch01table07) 描述了我们将使用的命令。
- en: Table 1.7\. Commands used on `ZSET` values
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 1.7\. 在 `ZSET` 值上使用的命令
- en: '| Command | What it does |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 执行的操作 |'
- en: '| --- | --- |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ZADD | Adds member with the given score to the ZSET |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| ZADD | 将具有给定分数的成员添加到 ZSET 中 |'
- en: '| ZRANGE | Fetches the items in the ZSET from their positions in sorted order
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| ZRANGE | 从排序顺序中的位置获取 ZSET 中的项目 |'
- en: '| ZRANGEBYSCORE | Fetches items in the ZSET based on a range of scores |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| ZRANGEBYSCORE | 根据分数范围从 ZSET 中获取项目 |'
- en: '| ZREM | Removes the item from the ZSET, if it exists |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| ZREM | 如果存在，则从 ZSET 中删除项目 |'
- en: Listing 1.5\. The `ZADD`, `ZRANGE`, `ZRANGEBYSCORE`, and `ZREM` commands in
    Redis
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.5\. Redis 中的 `ZADD`、`ZRANGE`、`ZRANGEBYSCORE` 和 `ZREM` 命令
- en: '![](014fig01_alt.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![014fig01_alt](014fig01_alt.jpg)'
- en: Now that you’ve seen `ZSET`s and a little of what they can do, you’ve learned
    the basics of what structures are available in Redis. In the next section, we’ll
    combine the data storage ability of `HASH`es with the built-in sorting ability
    of `ZSET`s to solve a common problem.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 `ZSET` 及其一些功能，你已经学会了 Redis 中可用的基本结构。在下一节中，我们将结合 `HASH` 的数据存储能力和 `ZSET`
    的内置排序能力来解决一个常见问题。
- en: 1.3\. Hello Redis
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3\. 欢迎使用 Redis
- en: Now that you’re more familiar with the structures that Redis offers, it’s time
    to use Redis on a real problem. In recent years, a growing number of sites have
    offered the ability to vote on web page links, articles, or questions, including
    sites such as reddit and Stack Overflow, as shown in [figures 1.6](#ch01fig06)
    and [1.7](#ch01fig07). By taking into consideration the votes that were cast,
    posts are ranked and displayed based on a score relating those votes and when
    the link was submitted. In this section, we’ll build a Redis-based back end for
    a simple version of this kind of site.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对 Redis 提供的结构更加熟悉了，是时候在真实问题中使用 Redis 了。近年来，越来越多的网站提供了对网页链接、文章或问题进行投票的功能，包括如
    Reddit 和 Stack Overflow 这样的网站，如图 1.6（[#ch01fig06](#ch01fig06)）和图 1.7（[#ch01fig07](#ch01fig07)）所示。通过考虑所投的票，帖子根据与这些投票和链接提交时间相关的分数进行排名和显示。在本节中，我们将构建一个基于
    Redis 的后端，用于此类网站的简单版本。
- en: Figure 1.6\. Reddit, a site that offers the ability to vote on articles
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.6\. Reddit，一个提供对文章进行投票功能的网站
- en: '![](01fig06_alt.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![01fig06_alt](01fig06_alt.jpg)'
- en: Figure 1.7\. Stack Overflow, a site that offers the ability to vote on questions
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.7\. Stack Overflow，一个提供对问题进行投票功能的网站
- en: '![](01fig07_alt.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![01fig07_alt](01fig07_alt.jpg)'
- en: 1.3.1\. Voting on articles
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.1\. 对文章进行投票
- en: First, let’s start with some numbers and limitations on our problem, so we can
    solve the problem without losing sight of what we’re trying to do. Let’s say that
    1,000 articles are submitted each day. Of those 1,000 articles, about 50 of them
    are interesting enough that we want them to be in the top-100 articles for at
    least one day. All of those 50 articles will receive at least 200 up votes. We
    won’t worry about down votes for this version.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从一些数字和问题的限制开始，这样我们就可以在不失目标的情况下解决问题。让我们假设每天提交1,000篇文章。在这1,000篇文章中，大约有50篇足够有趣，我们希望它们至少有一天在顶级100篇文章中。所有这50篇文章都将至少收到200个赞。我们不会担心这个版本中的反对票。
- en: When dealing with scores that go down over time, we need to make the posting
    time, the current time, or both relevant to the overall score. To keep things
    simple, we’ll say that the score of an item is a function of the time that the
    article was posted, plus a constant multiplier times the number of votes that
    the article has received.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理随着时间的推移而下降的分数时，我们需要使发布时间、当前时间或两者都与整体分数相关。为了使事情简单，我们将说一个项目的分数是文章发布时间的函数，加上一个常数乘以文章收到的投票数。
- en: The time we’ll use the number of seconds since January 1, 1970, in the UTC time
    zone, which is commonly referred to as *Unix time*. We’ll use Unix time because
    it can be fetched easily in most programming languages and on every platform that
    we may use Redis on. For our constant, we’ll take the number of seconds in a day
    (86,400) divided by the number of votes required (200) to last a full day, which
    gives us 432 “points” added to the score per vote.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用自1970年1月1日以来的秒数，在UTC时区中，这通常被称为*Unix时间*。我们将使用Unix时间，因为它可以在大多数编程语言和可能用于Redis的每个平台上轻松获取。对于我们的常数，我们将使用一天中的秒数（86,400）除以所需的投票数（200）以维持一整天，这给我们带来了每票增加432“点”的分数。
- en: To actually build this, we need to start thinking of structures to use in Redis.
    For starters, we need to store article information like the title, the link to
    the article, who posted it, the time it was posted, and the number of votes received.
    We can use a Redis `HASH` to store this information, and an example article can
    be seen in [figure 1.8](#ch01fig08).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际构建这个，我们需要开始考虑在Redis中使用的结构。首先，我们需要存储文章信息，如标题、文章链接、发布者、发布时间和收到的投票数。我们可以使用Redis的`HASH`来存储这些信息，一个示例文章可以在[图1.8](#ch01fig08)中看到。
- en: Figure 1.8\. An example article stored as a `HASH` for our article voting system
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '![图1.8\. 作为文章投票系统存储的示例文章的`HASH`](01fig08.jpg)'
- en: '![](01fig08.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](01fig08.jpg)'
- en: '|  |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Using the Colon Character as a Separator
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用冒号字符作为分隔符
- en: Throughout this and other chapters, you’ll find that we use the colon character
    (`:`) as a separator between parts of names; for example, in [figure 1.8](#ch01fig08),
    we used it to separate *article* from the ID of the article, creating a sort of
    namespace. The choice of `:` is subjective, but common among Redis users. Other
    common choices include a period (`.`), forward slash (`/`), and even occasionally
    the pipe character (`|`). Regardless of what you choose, be consistent, and note
    how we use colons to define nested namespaces throughout the examples in the book.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和其他章节中，你会发现我们使用冒号字符（`:`）作为名称各部分的分隔符；例如，在[图1.8](#ch01fig08)中，我们用它来区分*文章*和文章的ID，创建了一种命名空间。冒号的选择是主观的，但Redis用户中很常见。其他常见的选择包括点（`.`）、正斜杠（`/`），甚至偶尔的管道字符（`|`）。无论你选择什么，都要保持一致，并注意我们如何在本书的示例中通过冒号定义嵌套命名空间。
- en: '|  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: To store a sorted set of articles themselves, we’ll use a `ZSET`, which keeps
    items ordered by the item scores. We can use our article ID as the member, with
    the `ZSET` score being the article score itself. While we’re at it, we’ll create
    another `ZSET` with the score being just the times that the articles were posted,
    which gives us an option of browsing articles based on article score or time.
    We can see a small example of time- and score-ordered article `ZSET`s in [figure
    1.9](#ch01fig09).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要存储文章本身的有序集合，我们将使用`ZSET`，它按项目分数对项目进行排序。我们可以使用我们的文章ID作为成员，`ZSET`分数就是文章本身的分数。在此过程中，我们还将创建另一个`ZSET`，其分数只是文章发布的时间，这为我们提供了按文章分数或时间浏览文章的选项。我们可以在[图1.9](#ch01fig09)中看到时间排序和分数排序的文章`ZSET`的小示例。
- en: Figure 1.9\. Two sorted sets representing time-ordered and score-ordered article
    indexes
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.9\. 表示按时间排序和按分数排序的文章索引的两个有序集合
- en: '![](01fig09_alt.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9\_alt\.](01fig09_alt.jpg)'
- en: In order to prevent users from voting for the same article more than once, we
    need to store a unique listing of users who have voted for each article. For this,
    we’ll use a `SET` for each article, and store the member IDs of all users who
    have voted on the given article. An example `SET` of users who have voted on an
    article is shown in [figure 1.10](#ch01fig10).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止用户对同一文章重复投票，我们需要存储每个文章投票用户的唯一列表。为此，我们将为每个文章使用一个 `SET`，并存储所有对给定文章进行投票的用户的成员
    ID。一个对文章进行投票的用户 `SET` 示例在 [图 1.10](#ch01fig10) 中展示。
- en: Figure 1.10\. Some users who have voted for article 100408
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.10\. 对文章 100408 投票的一些用户
- en: '![](01fig10.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig10.jpg)'
- en: For the sake of memory use over time, we’ll say that after a week users can
    no longer vote on an article and its score is fixed. After that week has passed,
    we’ll delete the `SET` of users who have voted on the article.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了长期记忆使用，我们可以说一周后用户不能再对文章进行投票，其分数将固定。在那一周过去之后，我们将删除对文章进行投票的 `SET` 用户。
- en: Before we build this, let’s take a look at what would happen if user 115423
    were to vote for article 100408 in [figure 1.11](#ch01fig11).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建这个之前，让我们看看如果用户 115423 在 [图 1.11](#ch01fig11) 中对文章 100408 进行投票会发生什么。
- en: Figure 1.11\. What happens to our structures when user 115423 votes for article
    100408
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.11\. 当用户 115423 对文章 100408 投票时，我们的结构会发生什么变化
- en: '![](01fig11_alt.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig11_alt.jpg)'
- en: Now that you know what we’re going to build, let’s build it! First, let’s handle
    voting. When someone tries to vote on an article, we first verify that the article
    was posted within the last week by checking the article’s post time with `ZSCORE`.
    If we still have time, we then try to add the user to the article’s voted `SET`
    with `SADD`. Finally, if the user didn’t previously vote on that article, we increment
    the score of the article by 432 (which we calculated earlier) with `ZINCRBY` (a
    command that increments the score of a member), and update the vote count in the
    `HASH` with `HINCRBY` (a command that increments a value in a hash). The voting
    code is shown in [listing 1.6](#ch01ex06).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们要构建什么，让我们开始构建！首先，让我们处理投票。当有人尝试对文章进行投票时，我们首先通过 `ZSCORE` 检查文章的发布时间来验证文章是否在最近一周内发布。如果我们还有时间，然后我们尝试通过
    `SADD` 将用户添加到文章的投票 `SET` 中。最后，如果用户之前没有对那篇文章进行投票，我们使用 `ZINCRBY`（一个增加成员分数的命令）将文章的分数增加
    432（我们之前计算过），并使用 `HINCRBY`（一个在哈希中增加值的命令）更新 `HASH` 中的投票计数。投票代码在 [列表 1.6](#ch01ex06)
    中展示。
- en: Listing 1.6\. The `article_vote()` function
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.6\. `article_vote()` 函数
- en: '![](018fig01_alt.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](018fig01_alt.jpg)'
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Redis Transactions
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Redis 事务
- en: In order to be correct, technically our `SADD`, `ZINCRBY`, and `HINCRBY` calls
    should be in a transaction. But since we don’t cover transactions until [chapter
    4](kindle_split_015.html#ch04), we won’t worry about them for now.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确性，技术上我们的 `SADD`、`ZINCRBY` 和 `HINCRBY` 调用应该在事务中进行。但由于我们直到 [第 4 章](kindle_split_015.html#ch04)
    才介绍事务，所以我们现在不会担心它们。
- en: '|  |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Voting isn’t so bad, is it? But what about posting an article?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 投票并不那么糟糕，对吧？但发布文章呢？
- en: 1.3.2\. Posting and fetching articles
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.2\. 发布和检索文章
- en: To post an article, we first create an article ID by incrementing a counter
    with `INCR`. We then create the voted `SET` by adding the poster’s ID to the `SET`
    with `SADD`. To ensure that the `SET` is removed after one week, we’ll give it
    an expiration time with the `EXPIRE` command, which lets Redis automatically delete
    it. We then store the article information with `HMSET`. Finally, we add the initial
    score and posting time to the relevant `ZSET`s with `ZADD`. We can see the code
    for posting an article in [listing 1.7](#ch01ex07).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布文章，我们首先通过 `INCR` 增加计数器来创建文章 ID。然后，我们通过 `SADD` 将发布者的 ID 添加到 `SET` 中来创建投票 `SET`。为了确保
    `SET` 在一周后删除，我们将使用 `EXPIRE` 命令给它设置一个过期时间，这允许 Redis 自动删除它。然后，我们使用 `HMSET` 存储文章信息。最后，我们使用
    `ZADD` 将初始分数和发布时间添加到相关的 `ZSET`s 中。我们可以在 [列表 1.7](#ch01ex07) 中看到发布文章的代码。
- en: Listing 1.7\. The `post_article()` function
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.7\. `post_article()` 函数
- en: '![](019fig01_alt.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](019fig01_alt.jpg)'
- en: Okay, so we can vote, and we can post articles. But what about fetching the
    current top-scoring or most recent articles? For that, we can use `ZRANGE` to
    fetch the article IDs, and then we can make calls to `HGETALL` to fetch information
    about each article. The only tricky part is that we must remember that `ZSET`s
    are sorted in ascending order by their score. But we can fetch items based on
    the reverse order with `ZREVRANGEBYSCORE`. The function to fetch a page of articles
    is shown in [listing 1.8](#ch01ex08).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以我们可以投票，我们可以发布文章。但是，关于获取当前得分最高或最新文章怎么办？为此，我们可以使用`ZRANGE`来获取文章ID，然后我们可以调用`HGETALL`来获取每篇文章的信息。唯一棘手的部分是我们必须记住`ZSET`是按分数升序排序的。但我们可以使用`ZREVRANGEBYSCORE`以相反的顺序获取项目。获取文章页面的函数在[列表1.8](#ch01ex08)中展示。
- en: Listing 1.8\. The `get_articles()` function
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.8. `get_articles()`函数
- en: '![](019fig02_alt.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](019fig02_alt.jpg)'
- en: '|  |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Default arguments and keyword arguments
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 默认参数和关键字参数
- en: 'Inside [listing 1.8](#ch01ex08), we used an argument named `order`, and we
    gave it a default value of `score:`. Some of the details of default arguments
    and passing arguments as names (instead of by position) can be strange to newcomers
    to the Python language. If you’re having difficulty understanding what’s going
    on with function definition or argument passing, the Python language tutorial
    offers a good introduction to what’s going on, and you can jump right to the particular
    section by visiting this shortened URL: [http://mng.bz/KM5x](http://mng.bz/KM5x).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表1.8](#ch01ex08)中，我们使用了一个名为`order`的参数，并给它提供了一个默认值`score:`。对于Python语言的新手来说，默认参数和按名称（而不是按位置）传递参数的一些细节可能有些奇怪。如果你在理解函数定义或参数传递方面遇到困难，Python语言教程提供了一个很好的介绍，你可以通过访问这个缩短的URL直接跳转到特定部分：[http://mng.bz/KM5x](http://mng.bz/KM5x)。
- en: '|  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: We can now get the top-scoring articles across the entire site. But many of
    these article voting sites have groups that only deal with articles of a particular
    topic like cute animals, politics, programming in Java, and even the use of Redis.
    How could we add or alter our code to offer these topical groups?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以获取整个网站上的得分最高的文章。但是，许多这些文章投票网站都有只处理特定主题文章的群体，比如可爱动物、政治、Java编程，甚至Redis的使用。我们如何添加或修改我们的代码来提供这些主题群体？
- en: 1.3.3\. Grouping articles
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.3.3. 文章分组
- en: To offer groups requires two steps. The first step is to add information about
    which articles are in which groups, and the second is to actually fetch articles
    from a group. We’ll use a `SET` for each group, which stores the article IDs of
    all articles in that group. In [listing 1.9](#ch01ex09), we see a function that
    allows us to add and remove articles from groups.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 提供群体需要两个步骤。第一步是添加关于哪些文章属于哪些群体的信息，第二步是从群体中实际获取文章。我们将为每个群体使用一个`SET`，它存储该群体中所有文章的文章ID。在[列表1.9](#ch01ex09)中，我们看到一个允许我们向群体中添加和删除文章的函数。
- en: Listing 1.9\. The `add_remove_groups()` function
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.9. `add_remove_groups()`函数
- en: '![](020fig01_alt.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](020fig01_alt.jpg)'
- en: At first glance, these `SET`s with article information may not seem that useful.
    So far, you’ve only seen the ability to check whether a `SET` has an item. But
    Redis has the capability to perform operations involving multiple `SET`s, and
    in some cases, Redis can perform operations between `SET`s and `ZSET`s.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这些包含文章信息的`SET`可能看起来并不那么有用。到目前为止，你只看到了检查`SET`是否有项目的能力。但是，Redis有执行涉及多个`SET`的操作的能力，在某些情况下，Redis可以在`SET`和`ZSET`之间执行操作。
- en: When we’re browsing a specific group, we want to be able to see the scores of
    all of the articles in that group. Or, really, we want them to be in a `ZSET`
    so that we can have the scores already sorted and ready for paging over. Redis
    has a command called `ZINTERSTORE`, which, when provided with `SET`s and `ZSET`s,
    will find those entries that are in all of the `SET`s and `ZSET`s, combining their
    scores in a few different ways (items in `SET`s are considered to have scores
    equal to 1). In our case, we want the maximum score from each item (which will
    be either the article score or when the article was posted, depending on the sorting
    option chosen).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览特定群体时，我们希望能够看到该群体中所有文章的分数。或者，实际上，我们希望它们在`ZSET`中，这样我们就可以有预先排序好的分数，并准备好进行分页。Redis有一个名为`ZINTERSTORE`的命令，当提供`SET`和`ZSET`时，它会找到所有`SET`和`ZSET`中的条目，以几种不同的方式合并它们的分数（`SET`中的项目被认为是分数等于1）。在我们的情况下，我们想要每个项目的最高分数（这将是文章分数或文章发布时间，取决于选择的排序选项）。
- en: To visualize what is going on, let’s look at [figure 1.12](#ch01fig12). This
    figure shows an example `ZINTERSTORE` operation on a small group of articles stored
    as a `SET` with the much larger (but not completely shown) `ZSET` of scored articles.
    Notice how only those articles that are in both the `SET` and the `ZSET` make
    it into the result `ZSET`?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化正在发生的事情，让我们看看[图1.12](#ch01fig12)。这个图展示了在一个小文章组上进行的`ZINTERSTORE`操作，这些文章存储为一个`SET`，与更大的（但未完全显示）的分数`ZSET`。注意，只有那些同时存在于`SET`和`ZSET`中的文章才会出现在结果`ZSET`中？
- en: Figure 1.12\. The newly created `ZSET`, `score:programming`, is an intersection
    of the `SET` and `ZSET`. Intersection will only keep members from `SET`s/`ZSET`s
    when the members exist in all of the input `SET`s/ `ZSET`s. When intersecting
    `SET`s and `ZSET`s, `SET`s act as though they have a score of 1, so when intersecting
    with an aggregate of `MAX`, we’re only using the scores from the `score:` input
    `ZSET`, because they’re all greater than 1.
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.12. 新创建的`ZSET`，`score:programming`，是`SET`和`ZSET`的交集。交集只会保留所有输入`SET`s/`ZSET`s中存在的成员。当交集`SET`s和`ZSET`s时，`SET`s表现得好像它们有一个分数为1，所以当与`MAX`的聚合交集时，我们只使用`score:`输入`ZSET`中的分数，因为它们都大于1。
- en: '![](01fig12_alt.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig12_alt.jpg)'
- en: To calculate the scores of all of the items in a group, we only need to make
    a `ZINTERSTORE` call with the group and the scored or recent `ZSET`s. Because
    a group may be large, it may take some time to calculate, so we’ll keep the `ZSET`
    around for 60 seconds to reduce the amount of work that Redis is doing. If we’re
    careful (and we are), we can even use our existing `get_articles()` function to
    handle pagination and article data fetching so we don’t need to rewrite it. We
    can see the function for fetching a page of articles from a group in [listing
    1.10](#ch01ex10).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算一个组中所有项目的分数，我们只需要对组和分数或最近的`ZSET`执行一个`ZINTERSTORE`调用。因为一个组可能很大，所以计算可能需要一些时间，所以我们将`ZSET`保留60秒以减少Redis需要执行的工作量。如果我们小心（我们是），甚至可以使用我们现有的`get_articles()`函数来处理分页和文章数据检索，这样我们就不需要重写它。我们可以在[列表1.10](#ch01ex10)中看到从组中检索一页文章的函数。
- en: Listing 1.10\. The `get_group_articles()` function
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.10. `get_group_articles()`函数
- en: '![](021fig01_alt.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](021fig01_alt.jpg)'
- en: On some sites, articles are typically only in one or two groups at most (“all
    articles” and whatever group best matches the article). In that situation, it
    would make more sense to keep the group that the article is in as part of the
    article’s `HASH`, and add one more `ZINCRBY` call to the end of our `article_vote()`
    function. But in our case, we chose to allow articles to be a part of multiple
    groups at the same time (maybe a picture can be both cute and funny), so to update
    scores for articles in multiple groups, we’d need to increment all of those groups
    at the same time. For an article in many groups, that could be expensive, so we
    instead occasionally perform an intersection. How we choose to offer flexibility
    or limitations can change how we store and update our data in any database, and
    Redis is no exception.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些网站上，文章通常只属于一个或两个组（例如“所有文章”和与文章最匹配的组）。在这种情况下，将文章所在的组作为文章的`HASH`的一部分来保留可能更有意义，并在我们的`article_vote()`函数的末尾添加一个额外的`ZINCRBY`调用。但就我们而言，我们选择允许文章同时属于多个组（也许一张图片既可爱又有趣）。因此，为了更新多个组中的文章分数，我们需要同时增加所有这些组的分数。对于属于许多组的文章，这可能很昂贵，所以我们偶尔会执行交集操作。我们如何选择提供灵活性或限制，可以改变我们在任何数据库中存储和更新数据的方式，Redis也不例外。
- en: '|  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Exercise: Down-voting**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习：取消投票**'
- en: 'In our example, we only counted people who voted positively for an article.
    But on many sites, negative votes can offer useful feedback to everyone. Can you
    think of a way of adding down-voting support to `article_vote()` and `post_article()`?
    If possible, try to allow users to switch their votes. Hint: if you’re stuck on
    vote switching, check out `SMOVE`, which I introduce briefly in [chapter 3](kindle_split_014.html#ch03).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们只计算了对文章投赞成票的人。但在许多网站上，负面投票可以为每个人提供有用的反馈。你能想出一种方法来为`article_vote()`和`post_article()`添加取消投票支持吗？如果可能的话，尝试允许用户切换他们的投票。提示：如果你在投票切换上卡住了，可以查看我在[第3章](kindle_split_014.html#ch03)中简要介绍的`SMOVE`。
- en: '|  |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that we can get articles, post articles, vote on articles, and even have
    the ability to group articles, we’ve built a back end for surfacing popular links
    or articles. Congratulations on getting this far! If you had any difficulty in
    following along, understanding the examples, or getting the solutions to work,
    keep reading to find out where you can get help.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够获取文章、发布文章、对文章进行投票，甚至有分组文章的能力，我们已经为显示热门链接或文章构建了一个后端。恭喜您走到这一步！如果您在跟随、理解示例或使解决方案工作方面有任何困难，请继续阅读以了解您可以在哪里获得帮助。
- en: 1.4\. Getting help
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4\. 寻求帮助
- en: If you’re having problems with Redis, don’t be afraid to look for or ask for
    help. Many others will probably have had a similar issue. First try searching
    with your favorite search engine for the particular error message you’re seeing.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Redis上遇到问题，不要害怕寻找或寻求帮助。可能很多人都会遇到类似的问题。首先尝试使用您喜欢的搜索引擎搜索您看到的特定错误信息。
- en: 'If you can’t find a solution to your problem and are having problems with an
    example in this book, go ahead and ask your question on the Manning forums: [http://www.manning-sandbox.com/forum.jspa?forumID=809](http://www.manning-sandbox.com/forum.jspa?forumID=809).
    Either I or someone else who’s familiar with the book should be able to help.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您找不到问题的解决方案，并且在这本书的示例中遇到问题，请前往Manning论坛：[http://www.manning-sandbox.com/forum.jspa?forumID=809](http://www.manning-sandbox.com/forum.jspa?forumID=809)提问。我或熟悉这本书的其他人应该能够帮助您。
- en: If you’re having issues with Redis or solving a problem with Redis that isn’t
    in this book, please join and post your question to the Redis mailing list at
    [https://groups.google.com/d/forum/redis-db/](https://groups.google.com/d/forum/redis-db/).
    Again, either I or someone who’s familiar with Redis should be able to help.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Redis上遇到问题，或者解决的不是这本书中的问题，请加入并发布您的问题到[https://groups.google.com/d/forum/redis-db/](https://groups.google.com/d/forum/redis-db/)的Redis邮件列表。再次提醒，我或熟悉Redis的其他人应该能够帮助您。
- en: And finally, if you’re having difficulties with a particular language or library,
    you can also try the Redis mailing list, but you may have better luck searching
    the mailing list or forum for the library you’re using.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您在特定语言或库上遇到困难，您也可以尝试Redis邮件列表，但您可能更幸运地搜索您使用的库的邮件列表或论坛。
- en: 1.5\. Summary
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5\. 摘要
- en: In this chapter, we covered the basics of what Redis is, and how it’s both similar
    to and different from other databases. We also talked about a few reasons why
    you’ll want to use Redis in your next project. When reading through the upcoming
    chapters, try to remember that we aren’t building toward a single ultimate application
    or tool; we’re looking at a variety of problems that Redis can help you to solve.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Redis的基本知识，以及它与其他数据库的相似之处和不同之处。我们还讨论了您为什么想在下一个项目中使用Redis的几个原因。在阅读即将到来的章节时，请记住，我们并不是在构建一个单一的最終应用程序或工具；我们正在查看Redis可以帮助您解决的各种问题。
- en: If there’s one concept that you should take away from this chapter, it’s that
    Redis is another tool that you can use to solve problems. Redis has structures
    that no other database offers, and because Redis is in-memory (making it fast),
    remote (making it accessible to multiple clients/servers), persistent (giving
    you the opportunity to keep data between reboots), and scalable (via slaving and
    sharding) you can build solutions to a variety of problems in ways that you’re
    already used to.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从这个章节中应该带走一个概念，那就是Redis是您可以用来解决问题的另一个工具。Redis具有其他数据库所不具备的结构，并且由于Redis是内存中的（使其快速），远程的（使其对多个客户端/服务器可访问），持久的（在重启之间保持数据的机会），以及可扩展的（通过从属和分片），您可以用您已经习惯的方式构建解决各种问题的解决方案。
- en: As you read the rest of the book, try to pay attention to how your approach
    to solving problems changes. You may find that your way of thinking about data-driven
    problems moves from “How can I bend my idea to fit into the world of tables and
    rows?” to “Which structures in Redis will result in an easier-to-maintain solution?”
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本书的其余部分时，请注意您解决问题的方法是如何变化的。您可能会发现，您对数据驱动问题的思考方式从“我如何使我的想法适应表格和行界定的世界？”转变为“Redis中的哪些结构将导致更容易维护的解决方案？”
- en: In [chapter 2](kindle_split_012.html#ch02), we’ll use Redis to solve problems
    that come up in the world of web applications, so keep reading to get an even
    bigger sense of what Redis can help you do.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](kindle_split_012.html#ch02)中，我们将使用Redis来解决在Web应用世界中遇到的问题，所以请继续阅读以更深入地了解Redis能帮助您做什么。
- en: Chapter 2\. Anatomy of a Redis web application
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2章\. Redis Web应用的解剖结构
- en: '*This chapter covers*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Login cookies
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录cookie
- en: Shopping cart cookies
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车cookie
- en: Caching generated web pages
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存生成的网页
- en: Caching database rows
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存数据库行
- en: Analyzing web page visits
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析网页访问
- en: In the first chapter, I introduced you to what Redis is about and what it’s
    capable of. In this chapter, I’ll continue on that path, starting to dig into
    several examples that come up in the context of some types of web applications.
    Though I’ve simplified the problems quite a bit compared to what happens in the
    real world, each of these pieces can actually be used with little modification
    directly in your applications. This chapter is primarily meant as a practical
    guide to what you can do with Redis, and [chapter 3](kindle_split_014.html#ch03)
    is more of a command reference.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我向您介绍了Redis是什么以及它能够做什么。在本章中，我将继续沿着这条路径前进，开始深入研究一些在特定类型的Web应用程序上下文中出现的问题示例。虽然与现实世界相比，我已经大大简化了这些问题，但实际上每个部分都可以经过少量修改后直接用于您的应用程序。本章主要作为Redis实际应用的指南，而[第三章](kindle_split_014.html#ch03)则更像是命令参考。
- en: 'To start out, let’s look at what we mean by a web application from the high
    level. Generally, we mean a server or service that responds over the HTTP protocol
    to requests made by web browsers. Here are the typical steps that a web server
    goes through to respond to a request:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从高层次上看看我们所说的Web应用程序是什么。通常，我们指的是一个服务器或服务，它通过HTTP协议对Web浏览器的请求做出响应。以下是Web服务器在响应请求时通常会经历的典型步骤：
- en: '**1**.  The server parses the request.'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 服务器解析请求。'
- en: '**2**.  The request is forwarded to a predefined handler.'
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 请求被转发到预定义的处理程序。'
- en: '**3**.  The handler may make requests to fetch data from a database.'
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 处理程序可能会向数据库请求数据。'
- en: '**4**.  With the retrieved data, the handler then renders a template as a response.'
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 使用检索到的数据，处理程序随后将模板渲染为响应。'
- en: '**5**.  The handler returns the rendered response, which gets passed back to
    the client.'
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**5**. 处理程序返回渲染后的响应，并将其传回客户端。'
- en: This list is a high-level overview of what happens in a typical web server.
    Web requests in this type of situation are considered to be *stateless* in that
    the web servers themselves don’t hold information about past requests, in an attempt
    to allow for easy replacement of failed servers. Books have been written about
    how to optimize every step in that process, and this book does similarly. How
    this book differs is that it explains how to replace some queries against a typical
    relational database with faster queries against Redis, and how to use Redis with
    access patterns that would’ve been too costly using a relational database.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表是典型Web服务器中发生事件的概述。在这种情况下，Web请求被认为是*无状态的*，因为Web服务器本身不保存有关过去请求的信息，试图允许轻松替换失败的服务器。关于如何优化该过程中的每一步都已有书籍出版，本书也做了类似的工作。本书的不同之处在于，它解释了如何用针对Redis的更快查询替换典型关系型数据库中的某些查询，以及如何使用Redis，这在关系型数据库中可能会非常昂贵。
- en: Through this chapter, we’ll look at and solve problems that come up in the context
    of Fake Web Retailer, a fairly large (fake) web store that gets about 100 million
    hits per day from roughly 5 million unique users who buy more than 100,000 items
    per day. These numbers are big, but if we can solve big problems easily, then
    small and medium problems should be even easier. And though these solutions target
    a large web retailer, all but one of them can be handled by a Redis server with
    no more than a few gigabytes of memory, and are intended to improve performance
    of a system responding to requests in real time.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们将探讨并解决在假网络零售商（一个相当大的（假）网络商店）上下文中出现的问题，该商店每天大约有500万独立用户访问，他们每天购买超过10万件商品。这些数字很大，但如果我们可以轻松解决大问题，那么小问题和中等问题应该更容易解决。尽管这些解决方案针对大型网络零售商，但除了一个之外，所有这些解决方案都可以通过不超过几个GB内存的Redis服务器处理，并且旨在提高实时响应请求的系统的性能。
- en: Each of the solutions presented (or some variant of them) has been used to solve
    real problems in production environments. More specifically, by reducing traditional
    database load by offloading some processing and storage to Redis, web pages were
    loaded faster with fewer resources.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 所提出的解决方案（或其某些变体）都已被用于解决生产环境中的实际问题。更具体地说，通过将一些处理和存储任务从传统数据库卸载到Redis，网页加载速度更快，资源消耗更少。
- en: Our first problem is to use Redis to help with managing user login sessions.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要问题是使用Redis帮助管理用户登录会话。
- en: 2.1\. Login and cookie caching
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1. 登录和cookie缓存
- en: 'Whenever we sign in to services on the internet, such as bank accounts or web
    mail, these services remember who we are using *cookies*. Cookies are small pieces
    of data that websites ask our web browsers to store and resend on every request
    to that service. For login cookies, there are two common methods of storing login
    information in cookies: a signed cookie or a token cookie.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时我们在互联网上登录服务，如银行账户或网络邮箱，这些服务都会使用*cookies*来记住我们是谁。Cookies是网站要求我们的网络浏览器存储并在每次请求该服务时重新发送的小数据块。对于登录cookie，有两种常见的将登录信息存储在cookie中的方法：签名cookie或token
    cookie。
- en: '*Signed cookies* typically store the user’s name, maybe their user ID, when
    they last logged in, and whatever else the service may find useful. Along with
    this user-specific information, the cookie also includes a signature that allows
    the server to verify that the information that the browser sent hasn’t been altered
    (like replacing the login name of one user with another).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*签名cookie*通常存储用户的姓名、可能还有他们的用户ID、他们最后一次登录的时间以及服务可能认为有用的其他信息。除了这些特定用户信息外，cookie还包括一个签名，允许服务器验证浏览器发送的信息没有被更改（例如，用一个用户的登录名替换另一个用户的登录名）。'
- en: '*Token cookies* use a series of random bytes as the data in the cookie. On
    the server, the token is used as a key to look up the user who owns that token
    by querying a database of some kind. Over time, old tokens can be deleted to make
    room for new tokens. Some pros and cons for both signed cookies and token cookies
    for referencing information are shown in [table 2.1](#ch02table01).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*Token cookies* 使用一系列随机字节作为cookie中的数据。在服务器上，token用作键，通过查询某种类型的数据库来查找拥有该token的用户。随着时间的推移，可以删除旧token以腾出空间给新token。以下展示了签名cookie和token
    cookie在参考信息方面的优缺点，供[表2.1](#ch02table01)参考。'
- en: Table 2.1\. Pros and cons of signed cookies and token cookies
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.1\. 签名cookie和token cookie的优缺点
- en: '| Cookie type | Pros | Cons |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| Cookie类型 | 优点 | 缺点 |'
- en: '| --- | --- | --- |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Signed cookie | Everything needed to verify the cookie is in the cookie Additional
    information can be included and signed easily | Correctly handling signatures
    is hard It’s easy to forget to sign and/or verify data, allowing security vulnerabilities
    |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 签名cookie | 验证cookie所需的所有信息都包含在cookie中 可以轻松包含和签名附加信息 | 正确处理签名很困难 容易忘记签名和/或验证数据，从而允许安全漏洞
    |'
- en: '| Token cookie | Adding information is easy Very small cookie, so mobile and
    slow clients can send requests faster | More information to store on the server
    If using a relational database, cookie loading/storing can be expensive |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| Token cookie | 添加信息很容易 非常小的cookie，因此移动和慢速客户端可以更快地发送请求 | 需要在服务器上存储更多信息 如果使用关系型数据库，cookie加载/存储可能很昂贵
    |'
- en: For the sake of not needing to implement signed cookies, Fake Web Retailer chose
    to use a token cookie to reference an entry in a relational database table, which
    stores user login information. By storing this information in the database, Fake
    Web Retailer can also store information like how long the user has been browsing,
    or how many items they’ve looked at, and later analyze that information to try
    to learn how to better market to its users.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免实现签名cookie，假网络零售商选择使用token cookie来引用关系型数据库表中的一个条目，该表存储用户登录信息。通过在数据库中存储这些信息，假网络零售商还可以存储用户浏览时长或查看的商品数量等信息，并在以后分析这些信息，以尝试了解如何更好地向用户进行市场营销。
- en: As is expected, people will generally look through many different items before
    choosing one (or a few) to buy, and recording information about all of the different
    items seen, when the user last visited a page, and so forth, can result in substantial
    database writes. In the long term, that data is useful, but even with database
    tuning, most relational databases are limited to inserting, updating, or deleting
    roughly 200–2,000 individual rows every second per database server. Though bulk
    inserts/updates/deletes can be performed faster, a customer will only be updating
    a small handful of rows for each web page view, so higher-speed bulk insertion
    doesn’t help here.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，人们在选择购买一个（或几个）商品之前通常会浏览许多不同的商品，记录下所有看到的不同商品的信息、用户最后一次访问页面的时间等信息，这可能会导致大量的数据库写入操作。从长远来看，这些数据是有用的，但即使经过数据库调整，大多数关系型数据库也仅限于每个数据库服务器每秒插入、更新或删除大约200-2,000条单独的行。尽管批量插入/更新/删除可以更快地执行，但客户每次查看网页时只更新一小部分行，因此更高的批量插入速度在这里并没有帮助。
- en: At present, due to the relatively large load through the day (averaging roughly
    1,200 writes per second, close to 6,000 writes per second at peak), Fake Web Retailer
    has had to set up 10 relational database servers to deal with the load during
    peak hours. It’s our job to take the relational databases out of the picture for
    login cookies and replace them with Redis.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，由于一天中的相对较大负载（平均每秒约1,200次写入，高峰时段接近每秒6,000次写入），假网络零售商不得不在高峰时段设置10个关系型数据库服务器来处理负载。我们的任务是让关系型数据库在登录cookie方面退出舞台，并用Redis来替代。
- en: To get started, we’ll use a `HASH` to store our mapping from login cookie tokens
    to the user that’s logged in. To check the login, we need to fetch the user based
    on the token and return it, if it’s available. The following listing shows how
    we check login cookies.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将使用一个`HASH`来存储我们的从登录cookie令牌到已登录用户的映射。为了检查登录，我们需要根据令牌获取用户，如果它可用，则返回它。以下列表展示了我们如何检查登录cookie。
- en: Listing 2.1\. The `check_token()` function
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.1\. `check_token()` 函数
- en: '![](026fig01_alt.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](026fig01_alt.jpg)'
- en: Checking the token isn’t very exciting, because all of the interesting stuff
    happens when we’re updating the token itself. For the visit, we’ll update the
    login `HASH` for the user and record the current timestamp for the token in the
    `ZSET` of recent users. If the user was viewing an item, we also add the item
    to the user’s recently viewed `ZSET` and trim that `ZSET` if it grows past 25
    items. The function that does all of this can be seen next.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 检查令牌并不令人兴奋，因为所有有趣的事情都发生在我们更新令牌本身的时候。对于访问，我们将更新用户的登录`HASH`并记录令牌在最近用户`ZSET`中的当前时间戳。如果用户正在查看项目，我们还会将该项目添加到用户的最近查看`ZSET`中，并在它增长超过25个项目时对其进行修剪。执行所有这些操作的功能将在下面展示。
- en: Listing 2.2\. The `update_token()` function
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.2\. `update_token()` 函数
- en: '![](027fig01_alt.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](027fig01_alt.jpg)'
- en: And you know what? That’s it. We’ve now recorded when a user with the given
    session last viewed an item and what item that user most recently looked at. On
    a server made in the last few years, you can record this information for at least
    20,000 item views every second, which is more than three times what we needed
    to perform against the database. This can be made even faster, which we’ll talk
    about later. But even for this version, we’ve improved performance by 10–100 times
    over a typical relational database in this context.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗？就是这样。我们现在记录了给定会话的用户上次查看项目的时间和用户最近查看的项目。在最近几年制造的服务器上，你可以每秒记录至少20,000次项目查看的信息，这比我们需要对数据库执行的操作多出三倍。这可以做得更快，我们稍后会讨论。但即使是这个版本，我们也比典型的关系型数据库在这个上下文中提高了10-100倍的性能。
- en: Over time, memory use will grow, and we’ll want to clean out old data. As a
    way of limiting our data, we’ll only keep the most recent 10 million sessions.^([[1](#ch02fn01)])
    For our cleanup, we’ll fetch the size of the `ZSET` in a loop. If the `ZSET` is
    too large, we’ll fetch the oldest items up to 100 at a time (because we’re using
    timestamps, this is just the first 100 items in the `ZSET`), remove them from
    the recent `ZSET`, delete the login tokens from the login `HASH`, and delete the
    relevant viewed `ZSET`s. If the `ZSET` isn’t too large, we’ll sleep for one second
    and try again later. The code for cleaning out old sessions is shown next.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，内存使用量将会增长，我们希望清理旧数据。为了限制我们的数据，我们只保留最近的1,000万次会话.^([[1](#ch02fn01)])
    对于我们的清理，我们将通过循环获取`ZSET`的大小。如果`ZSET`太大，我们将每次最多获取100个最旧的条目（因为我们使用时间戳，这仅仅是`ZSET`中的前100个条目），从最近的`ZSET`中移除它们，从登录`HASH`中删除登录令牌，并删除相关的查看`ZSET`s。如果`ZSET`不是太大，我们将暂停一秒钟，稍后再试。清理旧会话的代码将在下面展示。
- en: ¹ Remember that these sorts of limits are meant as examples that you could use
    in a large-scale production situation. Feel free to reduce these to a much smaller
    number in your testing and development to see that they work.
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 请记住，这些类型的限制是为了作为示例，你可以在大规模生产环境中使用。在测试和开发过程中，你可以将这些限制减少到更小的数字，以验证它们是否有效。
- en: Listing 2.3\. The `clean_sessions()` function
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.3\. `clean_sessions()` 函数
- en: '![](027fig02_alt.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](027fig02_alt.jpg)'
- en: How could something so simple scale to handle five million users daily? Let’s
    check the numbers. If we expect five million unique users per day, then in two
    days (if we always get new users every day), we’ll run out of space and will need
    to start deleting tokens. In one day there are 24 × 3600 = 86,400 seconds, so
    there are 5 million / 86,400 < 58 new sessions every second on average. If we
    ran our cleanup function every second (as our code implements), we’d clean up
    just under 60 tokens every second. But this code can actually clean up more than
    10,000 tokens per second across a network, and over 60,000 tokens per second locally,
    which is 150–1,000 times faster than we need.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如何让如此简单的东西扩展到每天处理五百万用户？让我们来看看数字。如果我们预计每天有五百万个唯一用户，那么在两天（如果我们每天都获得新用户），我们将耗尽空间并需要开始删除令牌。一天有24
    × 3600 = 86,400秒，所以平均每秒有5百万 / 86,400 < 58个新会话。如果我们每秒运行我们的清理函数（如我们的代码实现），我们每秒将清理不到60个令牌。但实际上，我们的代码可以在网络上每秒清理超过10,000个令牌，在本地每秒清理超过60,000个令牌，这比我们需要的速度快150-1,000倍。
- en: '|  |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Where to run cleanup functions
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清理函数的运行位置
- en: This and other examples in this book will sometimes include cleanup functions
    like [listing 2.3](#ch02ex03). Depending on the cleanup function, it may be written
    to be run as a daemon process (like [listing 2.3](#ch02ex03)), to be run periodically
    via a cron job, or even to be run during every execution ([section 6.3](kindle_split_017.html#ch06lev1sec3)
    actually includes the cleanup operation as part of an “acquire” operation). As
    a general rule, if the function includes a `while not QUIT:` line, it’s supposed
    to be run as a daemon, though it could probably be modified to be run periodically,
    depending on its purpose.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的其他示例有时会包括清理函数，例如[列表2.3](#ch02ex03)。根据清理函数的不同，它可能被编写为作为守护进程运行（如[列表2.3](#ch02ex03)），通过cron作业定期运行，或者甚至在每次执行时运行（[第6.3节](kindle_split_017.html#ch06lev1sec3)实际上将清理操作作为“获取”操作的一部分）。一般来说，如果函数包含`while
    not QUIT:`行，它应该作为守护进程运行，尽管根据其目的，它可能被修改为定期运行。
- en: '|  |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Python syntax for passing and receiving a variable number of arguments
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Python传递和接收可变数量参数的语法
- en: 'Inside [listing 2.3](#ch02ex03), you’ll notice that we called three functions
    with a syntax similar to `conn.delete(*vtokens)`. Basically, we’re passing a sequence
    of arguments to the underlying function without previously unpacking the arguments.
    For further details on the semantics of how this works, you can visit the Python
    language tutorial website by visiting this short url: [http://mng.bz/8I7W](http://mng.bz/8I7W).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表2.3](#ch02ex03)内部，你会注意到我们使用类似于`conn.delete(*vtokens)`的语法调用了三个函数。基本上，我们是在不预先解包参数的情况下将一系列参数传递给底层函数。有关此工作方式的语义的更多详细信息，你可以通过访问这个简短的网址访问Python语言教程网站：[http://mng.bz/8I7W](http://mng.bz/8I7W)。
- en: '|  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Expiring data in Redis
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Redis中的过期数据
- en: As you learn more about Redis, you’ll likely discover that some of the solutions
    we present aren’t the only ways to solve the problem. In this case, we could omit
    the recent `ZSET`, store login tokens as plain key-value pairs, and use Redis
    `EXPIRE` to set a future date or time to clean out both sessions and our recently
    viewed `ZSET`s. But using `EXPIRE` prevents us from explicitly limiting our session
    information to 10 million users, and prevents us from performing abandoned shopping
    cart analysis during session expiration, if necessary in the future.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对Redis了解的深入，你可能会发现我们提出的解决方案并不是解决问题的唯一方法。在这种情况下，我们可以省略最近的`ZSET`，将登录令牌作为纯键值对存储，并使用Redis的`EXPIRE`来设置未来的日期或时间来清理会话和最近查看的`ZSET`s。但是使用`EXPIRE`会阻止我们明确地将会话信息限制在1000万用户以内，并阻止我们在会话过期时执行遗弃购物车分析，如果将来需要的话。
- en: '|  |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Those familiar with threaded or concurrent programming may have seen that the
    preceding cleanup function has a race condition where it’s technically possible
    for a user to manage to visit the site in the same fraction of a second when we
    were deleting their information. We’re not going to worry about that here because
    it’s unlikely, and because it won’t cause a significant change in the data we’re
    recording (aside from requiring that the user log in again). We’ll talk about
    guarding against race conditions and about how we can even speed up the deletion
    operation in [chapters 3](kindle_split_014.html#ch03) and [4](kindle_split_015.html#ch04).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉线程或并发编程的人可能会看到，前面的清理函数存在一个竞态条件，技术上用户有可能在我们删除他们的信息时，在相同的一秒内访问网站。我们在这里不会担心这个问题，因为它不太可能发生，而且它不会对我们记录的数据造成重大变化（除了要求用户再次登录）。我们将在第3章和第4章中讨论如何防止竞态条件以及如何加快删除操作的速度。[chapters
    3](kindle_split_014.html#ch03) 和 [4](kindle_split_015.html#ch04)。
- en: We’ve reduced how much we’ll be writing to the database by millions of rows
    every day. This is great, but it’s just the first step toward using Redis in our
    web application. In the next section, we’ll use Redis for handling another kind
    of cookie.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每天减少写入数据库的行数已经减少了数百万行。这很好，但这只是我们在Web应用程序中使用Redis的第一步。在下一节中，我们将使用Redis来处理另一种类型的cookie。
- en: 2.2\. Shopping carts in Redis
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2. Redis中的购物车
- en: One of the first uses of cookies on the web was pioneered by Netscape way back
    in the mid ’90s, and ultimately resulted in the login session cookies we just
    talked about. Originally, cookies were intended to offer a way for a web retailer
    to keep a sort of shopping cart for the user, in order to track what items they
    wanted to buy. Prior to cookies, there were a few different solutions for keeping
    track of shopping carts, but none were particularly easy to use.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上最早使用cookie之一是由Netscape在20世纪90年代中期开创的，最终导致了我们刚才提到的登录会话cookie。最初，cookie的目的是为网络零售商提供一种方式，以便为用户保留一种购物车，以便跟踪他们想要购买的商品。在cookie出现之前，有一些不同的解决方案用于跟踪购物车，但它们都不太容易使用。
- en: The use of shopping cart cookies is common, as is the storage of the entire
    cart itself in the cookie. One huge advantage to storing shopping carts in cookies
    is that you don’t need to write to a database to keep them. But one of the disadvantages
    is that you also need to keep reparsing and validating the cookie to ensure that
    it has the proper format and contains items that can actually be purchased. Yet
    another disadvantage is that cookies are passed with every request, which can
    slow down request sending and processing for large cookies.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车cookie的使用很常见，就像将整个购物车本身存储在cookie中一样。将购物车存储在cookie中的一个巨大优势是，您不需要写入数据库来保持它们。但缺点之一是您还需要重新解析和验证cookie，以确保它具有正确的格式并包含可以实际购买的商品。另一个缺点是cookie会随着每个请求传递，这可能会减慢大型cookie的请求发送和处理速度。
- en: Because we’ve had such good luck with session cookies and recently viewed items,
    we’ll push our shopping cart information into Redis. Since we’re already keeping
    user session cookies in Redis (along with recently viewed items), we can use the
    same cookie ID for referencing the shopping cart.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在会话cookie和最近查看的项目上取得了如此好的运气，我们将我们的购物车信息推送到Redis。由于我们已经在Redis中保存了用户会话cookie（以及最近查看的项目），我们可以使用相同的cookie
    ID来引用购物车。
- en: 'The shopping cart that we’ll use is simple: it’s a `HASH` that maps an item
    ID to the quantity of that item that the customer would like to purchase. We’ll
    have the web application handle validation for item count, so we only need to
    update counts in the cart as they change. If the user wants more than 0 items,
    we add the item(s) to the `HASH` (replacing an earlier count if it existed). If
    not, we remove the entry from the hash. Our `add_to_cart()` function can be seen
    in this listing.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的购物车很简单：它是一个将商品ID映射到客户希望购买的商品数量的`HASH`。我们将让Web应用程序处理商品数量的验证，所以我们只需要在数量变化时更新购物车中的数量。如果用户想要超过0件商品，我们将商品（们）添加到`HASH`中（如果存在，则替换之前的数量）。如果不想要，我们将从哈希中删除条目。我们的`add_to_cart()`函数可以在下面的列表中看到。
- en: Listing 2.4\. The `add_to_cart()` function
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.4. `add_to_cart()`函数
- en: '![](029fig01_alt.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](029fig01_alt.jpg)'
- en: While we’re at it, we’ll update our session cleanup function to include deleting
    old shopping carts as `clean_full_sessions()` in the next listing.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在此同时，我们将更新我们的会话清理函数，以便在下一个列表中包括删除旧的购物车作为`clean_full_sessions()`。
- en: Listing 2.5\. The `clean_full_sessions()` function
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.5. `clean_full_sessions()`函数
- en: '![](030fig01_alt.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](030fig01_alt.jpg)'
- en: 'We now have both sessions and the shopping cart stored in Redis, which helps
    to reduce request size, as well as allows the performing of statistical calculations
    on visitors to our site based on what items they looked at, what items ended up
    in their shopping carts, and what items they finally purchased. All of this lets
    us build (if we want to) features similar to many other large web retailers: “People
    who looked at this item ended up buying this item X% of the time,” and “People
    who bought this item also bought these other items.” This can help people to find
    other related items, which is ultimately good for business.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将会话和购物车都存储在Redis中，这有助于减少请求大小，同时允许基于访问者查看的物品、最终放入购物车的物品以及他们最终购买的物品进行统计计算。所有这些让我们能够构建（如果我们想的话）类似于许多其他大型网络零售商的功能：“查看此物品的人最终购买了此物品X%的时间”，“购买此物品的人也购买了这些其他物品”。这可以帮助人们找到其他相关物品，这对业务最终是有益的。
- en: With both session and shopping cart cookies in Redis, we now have two major
    pieces for performing useful data analysis. Continuing on, let’s look at how we
    can further reduce our database and web front-end load with caching.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在Redis中存储了会话和购物车cookie，我们现在有两个主要的数据分析工具。继续前进，让我们看看我们如何通过缓存进一步减少数据库和Web前端负载。
- en: 2.3\. Web page caching
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3. 网页缓存
- en: When producing web pages dynamically, it’s common to use a templating language
    to simplify page generation. Gone are the days when each page would be written
    by hand. Modern web pages are generated from page templates with headers, footers,
    side menus, toolbars, content areas, and maybe even generated JavaScript.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态生成网页时，通常使用模板语言来简化页面生成。那些每个页面都要手动编写的日子已经过去了。现代网页是从带有标题、页脚、侧菜单、工具栏、内容区域甚至生成的JavaScript的页面模板生成的。
- en: Despite being capable of dynamically generating content, the majority of pages
    that are served on Fake Web Retailer’s website don’t change much on a regular
    basis. Sure, some new items are added to the catalog, old items are removed, sometimes
    there are specials, and sometimes there are even “hot items” pages. But really,
    only a handful of account settings, past orders, shopping cart/checkout, and similar
    pages have content that needs to be generated on every page load.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管能够动态生成内容，但Fake Web Retailer网站上提供的大多数页面在常规情况下变化不大。当然，目录中会添加一些新物品，旧物品会被移除，有时会有特价商品，有时甚至有“热门物品”页面。但事实上，只有少数账户设置、历史订单、购物车/结账等页面需要在每次页面加载时生成内容。
- en: By looking at their view numbers, Fake Web Retailer has determined that 95%
    of the web pages that they serve change at most once per day, and don’t actually
    require content to be dynamically generated. It’s our job to stop generating 95%
    of pages for every load. By reducing the amount of time we spend generating static
    content, we can reduce the number of servers necessary to handle the same load,
    and we can serve our site faster. (Research has shown that reducing the time users
    spend waiting for pages to load increases their desire to use a site and improves
    how they rate the site.)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看它们的观看次数，Fake Web Retailer已经确定他们提供的95%的Web页面每天最多变化一次，实际上并不需要动态生成内容。我们的任务是停止为每次加载生成95%的页面。通过减少我们用于生成静态内容的时间，我们可以减少处理相同负载所需的服务器数量，并且我们可以更快地提供服务。（研究表明，减少用户等待页面加载的时间会增加他们使用网站的愿望，并改善他们对网站的评分。）
- en: All of the standard Python application frameworks offer the ability to add layers
    that can pre- or post-process requests as they’re handled. These layers are typically
    called *middleware* or *plugins*. Let’s create one of these layers that calls
    out to our Redis caching function. If a web request can’t be cached, we’ll generate
    the page and return the content. If a request can be cached, we’ll try to fetch
    and return the page from the cache; otherwise we’ll generate the page, cache the
    result in Redis for up to 5 minutes, and return the content. Our simple caching
    method can be seen in the next listing.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标准的Python应用程序框架都提供了添加层的能力，这些层可以在处理请求时进行预处理或后处理。这些层通常被称为*中间件*或*插件*。让我们创建一个这样的层，它调用我们的Redis缓存函数。如果Web请求无法被缓存，我们将生成页面并返回内容。如果请求可以被缓存，我们将尝试从缓存中获取并返回页面；否则，我们将生成页面，将结果缓存到Redis中，最多5分钟，然后返回内容。我们的简单缓存方法可以在下一列表中看到。
- en: Listing 2.6\. The `cache_request()` function
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.6. `cache_request()` 函数
- en: '![](031fig01_alt.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](031fig01_alt.jpg)'
- en: For that 95% of content that could be cached and is loaded often, this bit of
    code removes the need to dynamically generate viewed pages for 5 minutes. Depending
    on the complexity of content, this one change could reduce the latency for a data-heavy
    page from maybe 20–50ms, down to one round trip to Redis (under 1ms for a local
    connection, under 5ms for computers close to each other in the same data center).
    For pages that used to hit the database for data, this can further reduce page
    load time and database load.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那95%可以缓存且经常加载的内容，这段代码消除了为5分钟动态生成查看页面的需要。根据内容的复杂性，这一变化可以将数据密集型页面的延迟从大约20-50ms降低到一次Redis往返（本地连接下不到1ms，同一数据中心内彼此靠近的计算机下不到5ms）。对于以前需要从数据库获取数据的页面，这可以进一步减少页面加载时间和数据库负载。
- en: Now that we’ve cut loading time for pages that don’t change often, can we keep
    using Redis to cut loading time for pages that do change often? Of course we can!
    Keep reading to find out how.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经减少了那些不经常变化的页面的加载时间，我们是否可以继续使用Redis来减少那些经常变化的页面的加载时间呢？当然可以！继续阅读以了解如何实现。
- en: 2.4\. Database row caching
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4. 数据库行缓存
- en: In this chapter so far, we’ve moved login and visitor sessions from our relational
    database and web browser to Redis, we’ve taken shopping carts out of the relational
    database and put them into Redis, and we’ve cached entire pages in Redis. This
    has helped us improve performance and reduce the load on our relational database,
    which has also lowered our costs.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将登录和访客会话从我们的关系型数据库和网页浏览器移动到Redis，我们将购物车从关系型数据库中移除并放入Redis，并在Redis中缓存整个页面。这有助于我们提高性能并减少对关系型数据库的负载，这也降低了我们的成本。
- en: 'Individual product pages that we’re displaying to a user typically only load
    one or two rows from the database: the user information for the user who’s logged
    in (with our generated pages, we can load that with an AJAX call to keep using
    our cache), and the information about the item itself. Even for pages where we
    may not want to cache the whole page (customer account pages, a given user’s past
    orders, and so on), we could instead cache the individual rows from our relational
    database.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向用户显示的个别产品页面通常只从数据库中加载一到两行：登录用户的用户信息（在我们的生成页面中，我们可以通过AJAX调用加载它以继续使用我们的缓存），以及关于商品本身的信息。即使对于可能不希望缓存整个页面的页面（客户账户页面、特定用户的过去订单等），我们也可以缓存关系型数据库中的个别行。
- en: As an example of where caching rows like this would be useful, let’s say that
    Fake Web Retailer has decided to start a new promotion to both clean out some
    older inventory and get people coming back to spend money. To make this happen,
    we’ll start performing daily deal sales for certain items until they run out.
    In the case of a deal, we can’t cache the full page, because then someone might
    see a version of the page with an incorrect count of items remaining. And though
    we could keep reading the item’s row from the database, that could push our database
    to become over-utilized, which would then increase our costs because we’d need
    to scale our databases up again.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 作为缓存此类行有用的例子，让我们假设假想网络零售商决定开始一项新的促销活动，旨在清理一些库存并吸引人们回来消费。为了实现这一点，我们将对某些商品进行每日特价销售，直到其售罄。在交易的情况下，我们不能缓存整个页面，因为这样可能会有人看到剩余物品数量的错误版本。尽管我们可以从数据库中继续读取商品的行，但这可能会使我们的数据库过度使用，进而增加我们的成本，因为我们需要再次扩展我们的数据库。
- en: To cache database rows in preparation for a heavy load, we’ll write a daemon
    function that will run continuously, whose purpose will be to cache specific database
    rows in Redis, updating them on a variable schedule. The rows themselves will
    be JSON-encoded dictionaries stored as a plain Redis value. We’ll map column names
    and row values to the dictionary keys and values. An example row can be seen in
    [figure 2.1](#ch02fig01).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在重负载前缓存数据库行，我们将编写一个持续运行的守护进程函数，其目的是在可变的时间表上缓存特定的数据库行到Redis中，并更新它们。这些行本身将以JSON编码的字典形式存储为普通的Redis值。我们将映射列名和行值到字典的键和值。一个示例行可以在[图2.1](#ch02fig01)中看到。
- en: Figure 2.1\. A cached database row for an item to be sold online
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.1. 一个用于在线销售的缓存数据库行
- en: '![](02fig01.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图片](02fig01.jpg)'
- en: In order to know when to update the cache, we’ll use two `ZSET`s. Our first
    `ZSET`, the `scheduleZSET`, will use the row ID from the original database row
    as the member of the `ZSET`. We’ll use a timestamp for our schedule scores, which
    will tell us when the row should be copied to Redis next. Our second `ZSET`, the
    `delayZSET`, will use the same row ID for the members, but the score will be how
    many seconds to wait between cache updates.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了知道何时更新缓存，我们将使用两个 `ZSET`。我们的第一个 `ZSET`，即 `scheduleZSET`，将使用原始数据库行的行 ID 作为 `ZSET`
    的成员。我们将使用时间戳作为我们的计划分数，这将告诉我们何时将行复制到 Redis。我们的第二个 `ZSET`，即 `delayZSET`，将使用相同的行
    ID 作为成员，但分数将是缓存更新之间的秒数。
- en: '|  |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Using JSON instead of other formats
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 JSON 而不是其他格式
- en: Our use of JSON instead of XML, Google’s protocol buffers, Thrift, BSON, MessagePack,
    or other serialization formats is a subjective one. We generally use JSON because
    it’s human readable, somewhat concise, and it has fast encoding and decoding libraries
    available in every language with an existing Redis client (as far as we know).
    If your situation requires the use of another format, or if you’d prefer to use
    a different format, then feel free to do so.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使用 JSON 而不是 XML、Google 的协议缓冲区、Thrift、BSON、MessagePack 或其他序列化格式是主观的。我们通常使用
    JSON，因为它易于阅读，相对简洁，并且每个具有现有 Redis 客户端的编程语言都有快速的编码和解码库（据我们所知）。如果你的情况需要使用另一种格式，或者你更愿意使用不同的格式，那么请随意使用。
- en: '|  |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Nested structures
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 嵌套结构
- en: One feature that users of other non-relational databases sometime expect is
    the ability to nest structures. Specifically, some new users of Redis expect that
    a `HASH` should be able to have a value that’s a `ZSET` or `LIST`. Though conceptually
    this is fine, there’s a question that comes up early in such a discussion that
    boils down to a simple example, “How do I increment a value in a `HASH` that’s
    nested five levels deep?” As a matter of keeping the syntax of commands simple,
    Redis doesn’t allow nested structures. If necessary, you can use key names for
    this (`user:123` could be a `HASH` and `user:123:posts` could be a `ZSET` of recent
    posts from that user). Or you can explicitly store your nested structures using
    JSON or some other serialization library of your choice (Lua scripting, covered
    in [chapter 11](kindle_split_023.html#ch11), supports server-side manipulation
    of JSON and MessagePack encoded data).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 其他非关系型数据库的用户有时期望的一个功能是能够嵌套结构。具体来说，一些 Redis 的新用户期望 `HASH` 类型的值可以是 `ZSET` 或 `LIST`。虽然从概念上讲这是可行的，但在这样的讨论中早期出现的一个问题是归结为一个简单的例子，“我如何在嵌套五层的
    `HASH` 中增加一个值？”为了保持命令语法的简单性，Redis 不允许嵌套结构。如果需要，你可以使用键名来实现这一点（例如 `user:123` 可以是一个
    `HASH`，而 `user:123:posts` 可以是该用户最近帖子的 `ZSET`）。或者，你可以显式地使用 JSON 或其他你选择的序列化库来存储你的嵌套结构（Lua
    脚本，在第 11 章中介绍，支持服务器端操作 JSON 和 MessagePack 编码的数据）。
- en: '|  |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In order for rows to be cached on a regular basis by the caching function, we’ll
    first add the row ID to our delay `ZSET` with the given delay. This is because
    our actual caching function will require the delay, and if it’s missing, will
    remove the scheduled item. When the row ID is in the delay `ZSET`, we’ll then
    add the row ID to our schedule `ZSET` with the current timestamp. If we want to
    stop a row from being synced to Redis and remove it from the cache, we can set
    the delay to be less than or equal to 0, and our caching function will handle
    it. Our function to schedule or stop caching can be seen in the following listing.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使缓存函数定期缓存行，我们首先将行 ID 添加到我们的延迟 `ZSET` 中，并指定延迟。这是因为我们的实际缓存函数将需要延迟，如果缺失，它将删除计划的项目。当行
    ID 在延迟 `ZSET` 中时，我们将然后添加行 ID 到我们的计划 `ZSET` 中，并使用当前的时间戳。如果我们想停止行同步到 Redis 并从缓存中删除它，我们可以将延迟设置为小于或等于
    0，我们的缓存函数将处理它。我们的用于计划或停止缓存的函数可以在以下列表中看到。
- en: Listing 2.7\. The `schedule_row_cache()` function
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.7\. `schedule_row_cache()` 函数
- en: '![](033fig01_alt.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](033fig01_alt.jpg)'
- en: Now that we have the scheduling part done, how do we cache the rows? We’ll pull
    the first item from the schedule `ZSET` with its score. If there are no items,
    or if the timestamp returned is in the future, we’ll wait 50 milliseconds and
    try again. When we have an item that should be updated now, we’ll check the row’s
    delay. If the delay for the next caching time is less than or equal to 0, we’ll
    remove the row ID from the delay and schedule `ZSET`s, as well as delete the cached
    row and try again. Finally, for any row that should be cached, we’ll update the
    row’s schedule, pull the row from the database, and save a JSON-encoded version
    of the row to Redis. Our function for doing this can be seen in this listing.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了调度部分，我们如何缓存行？我们将从调度`ZSET`中拉取第一个项目及其分数。如果没有项目，或者返回的时间戳在将来，我们将等待50毫秒后再次尝试。当我们有一个现在应该更新的项目时，我们将检查行的延迟。如果下一次缓存时间的延迟小于或等于0，我们将从延迟和调度`ZSET`s中移除行ID，并删除缓存的行再次尝试。最后，对于任何应该被缓存的行，我们将更新行的调度，从数据库中拉取行，并将行的JSON编码版本保存到Redis。我们执行此操作的功能可以在下面的列表中看到。
- en: Listing 2.8\. The `cache_rows()` daemon function
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.8\. `cache_rows()`守护进程函数
- en: '![](033fig02_alt.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图片](033fig02_alt.jpg)'
- en: With the combination of a scheduling function and a continuously running caching
    function, we’ve added a repeating scheduled autocaching mechanism. With these
    two functions, inventory rows can be updated as frequently as we think is reasonable.
    For a daily deal with inventory counts being reduced and affecting whether someone
    can buy the item, it probably makes sense to update the cached row every few seconds
    if there are many buyers. But if the data doesn’t change often, or when back-ordered
    items are acceptable, it may make sense to only update the cache every minute.
    Both are possible with this simple method.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 结合调度函数和持续运行的缓存函数，我们添加了一个重复的定时自动缓存机制。有了这两个函数，库存行可以更新得像我们认为合理的那样频繁。对于一个每天的交易，库存数量减少并影响某人是否可以购买商品，如果有很多买家，每几秒钟更新缓存的行可能是有意义的。但如果数据不经常改变，或者当后置订单的商品是可以接受的，可能只每分钟更新缓存一次更有意义。这两种方法都可以用这个简单的方法实现。
- en: Now that we’re caching individual rows in Redis, could it be possible to further
    reduce our memory load by caching only some of our pages?
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在Redis中缓存了单个行，是否有可能通过只缓存部分页面来进一步减少我们的内存负载？
- en: 2.5\. Web page analytics
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5\. 网页分析
- en: As people come to the websites that we build, interact with them, maybe even
    purchase something from them, we can learn valuable information. For example,
    if we only pay attention to pages that get the most views, we can try to change
    the way the pages are formatted, what colors are being used, maybe even change
    what other links are shown on the pages. Each one of these changes can lead to
    a better or worse experience on a page or subsequent pages, or even affect buying
    behavior.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们访问我们构建的网站，与他们互动，甚至可能从他们那里购买东西时，我们可以获得有价值的信息。例如，如果我们只关注获得最多浏览量的页面，我们可以尝试改变页面的格式，使用的颜色，甚至可能改变页面上显示的其他链接。这些变化中的每一个都可能影响页面或后续页面的体验，甚至影响购买行为。
- en: In [sections 2.1](#ch02lev1sec1) and [2.2](#ch02lev1sec2), we talked about gathering
    information about items that a user has looked at or added to their cart. In [section
    2.3](#ch02lev1sec3), we talked about caching generated web pages in order to reduce
    page load times and improve responsiveness. Unfortunately, we went overboard with
    our caching for Fake Web Retailer; we cached every one of the 100,000 available
    product pages, and now we’re running out of memory. After some work, we’ve determined
    that we can only reasonably hold about 10,000 pages in the cache.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2.1节](#ch02lev1sec1)和[2.2节](#ch02lev1sec2)中，我们讨论了收集关于用户查看或添加到购物车中的商品的信息。在[第2.3节](#ch02lev1sec3)中，我们讨论了缓存生成的网页以减少页面加载时间和提高响应性。不幸的是，我们在假网络零售商的缓存上做得太过分了；我们缓存了所有100,000个可用的产品页面，现在我们正在耗尽内存。经过一些工作，我们确定我们只能合理地保留大约10,000页在缓存中。
- en: If you remember from [section 2.1](#ch02lev1sec1), we kept a reference to every
    item that was visited. Though we can use that information directly to help us
    decide what pages to cache, actually calculating that could take a long time to
    get good numbers. Instead, let’s add one line to the `update_token()` function
    from [listing 2.2](#ch02ex02), which we see next.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得[第2.1节](#ch02lev1sec1)，我们保留了对每个访问过的项目的引用。虽然我们可以直接使用这些信息来帮助我们决定要缓存哪些页面，但实际上计算这些信息可能需要很长时间才能得到好的数据。相反，让我们向[列表2.2](#ch02ex02)中的`update_token()`函数添加一行，我们将在下面看到。
- en: Listing 2.9\. The updated `update_token()` function
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.9\. 更新的 `update_token()` 函数
- en: '![](034fig01_alt.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.9](034fig01_alt.jpg)'
- en: With this one line added, we now have a record of all of the items that are
    viewed. Even more useful, that list of items is ordered by the number of times
    that people have seen the items, with the most-viewed item having the lowest score,
    and thus having an index of 0\. Over time, some items will be seen many times
    and others rarely. Obviously we only want to cache commonly seen items, but we
    also want to be able to discover new items that are becoming popular, so we know
    when to cache them.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加这一行，我们现在有了所有查看项目的记录。更有用的一点是，这些项目的列表是按人们查看项目的次数排序的，最常查看的项目具有最低的分数，因此索引为 0。随着时间的推移，一些项目会被多次查看，而其他项目则很少被查看。显然，我们只想缓存常见查看的项目，但我们还希望能够发现正在变得流行的新的项目，这样我们就可以知道何时缓存它们。
- en: To keep our top list of pages fresh, we need to trim our list of viewed items,
    while at the same time adjusting the score to allow new items to become popular.
    You already know how to remove items from the `ZSET` from [section 2.1](#ch02lev1sec1),
    but rescaling is new. `ZSET`s have a function called `ZINTERSTORE`, which lets
    us combine one or more `ZSET`s and multiply every score in the input `ZSET`s by
    a given number. (Each input `ZSET` can be multiplied by a different number.) Every
    5 minutes, let’s go ahead and delete any item that isn’t in the top 20,000 items,
    and rescale the view counts to be half has much as they were before. The following
    listing will both delete items and rescale remaining scores.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持页面排行榜的新鲜，我们需要修剪查看项目列表，同时调整分数以允许新项目变得流行。您已经知道如何从 [第 2.1 节](#ch02lev1sec1)
    中的 `ZSET` 中删除项目，但缩放是新的。`ZSET` 有一个名为 `ZINTERSTORE` 的函数，它允许我们合并一个或多个 `ZSET`，并将输入
    `ZSET` 中的每个分数乘以一个给定的数字。（每个输入 `ZSET` 可以乘以不同的数字。）每 5 分钟，我们就可以删除不在前 20,000 个项目中的任何项目，并将查看次数缩放为之前的一半。以下列表将删除项目并缩放剩余的分数。
- en: Listing 2.10\. The `rescale_viewed()` daemon function
  id: totrans-335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.10\. `rescale_viewed()` 守护进程函数
- en: '![](035fig01_alt.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.10](035fig01_alt.jpg)'
- en: With the rescaling and the counting, we now have a constantly updated list of
    the most-frequently viewed items at Fake Web Retailer. Now all we need to do is
    to update our `can_cache()` function to take into consideration our new method
    of deciding whether a page can be cached, and we’re done. You can see our new
    `can_cache()` function here.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 通过缩放和计数，我们现在有了 Fake Web Retailer 最常查看项目的实时列表。现在我们只需要更新我们的 `can_cache()` 函数，使其考虑我们决定页面是否可以缓存的新的方法，然后我们就完成了。您可以在下面看到我们的新
    `can_cache()` 函数。
- en: Listing 2.11\. The `can_cache()` function
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.11\. `can_cache()` 函数
- en: '![](035fig02_alt.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.11](035fig02_alt.jpg)'
- en: And with that final piece, we’re now able to take our actual viewing statistics
    and only cache those pages that are in the top 10,000 product pages. If we wanted
    to store even more pages with minimal effort, we could compress the pages before
    storing them in Redis, use a technology called *edge side includes* to remove
    parts of our pages, or we could pre-optimize our templates to get rid of unnecessary
    whitespace. Each of these techniques and more can reduce memory use and increase
    how many pages we could store in Redis, all for additional performance improvements
    as our site grows.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个最后的部分，我们现在能够使用实际的查看统计信息，并且只缓存那些位于前 10,000 个产品页面中的页面。如果我们想以最小的努力存储更多的页面，我们可以在将页面存储到
    Redis 之前压缩它们，使用名为 *边侧包含* 的技术来删除我们页面的一部分，或者我们可以预先优化我们的模板以去除不必要的空白。这些技术以及更多技术可以减少内存使用，并增加我们可以在
    Redis 中存储的页面数量，所有这些都可以随着我们网站的扩展而提高性能。
- en: 2.6\. Summary
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6\. 摘要
- en: In this chapter, we’ve covered a few methods for reducing database and web server
    load for Fake Web Retailer. The ideas and methods used in these examples are currently
    in use in real web applications today.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了几种减少 Fake Web Retailer 数据库和 Web 服务器负载的方法。这些示例中使用的方法目前在今天的真实 Web 应用程序中正在使用。
- en: If there’s one thing that you should take away from this chapter, it’s that
    as you’re building new pieces that fit within your application, you shouldn’t
    be afraid to revisit and update old components that you’ve already written. Sometimes
    you may find that your earlier solutions got you a few steps toward what you need
    now (as was the case with both shopping cart cookies and web analytics combined
    with our initial login session cookies code). As we continue through this book,
    we’ll keep introducing new topics, and we’ll occasionally revisit them later to
    improve performance or functionality, or to reuse ideas we already understand.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从这个章节中你能带走一件事，那就是当你构建适合你应用的新组件时，你不应该害怕回顾和更新你已经编写过的旧组件。有时你可能会发现，你早期的解决方案已经让你朝着现在的需求前进了几步（就像购物车cookies和结合我们初始登录会话cookies代码的web分析一样）。随着我们继续阅读这本书，我们会不断引入新的主题，并且我们偶尔会回顾它们，以提高性能或功能，或者重用我们已经理解的想法。
- en: Now that you’ve gotten a taste for what Redis can do as part of a real application,
    the next chapter will go over a wider variety of commands available in Redis.
    After you learn more about each structure and what can be done with them, you’ll
    be ready to build even more useful components for other layers of your application
    or stack of services. So what are you waiting for? Keep reading!
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经尝到了Redis作为真实应用一部分所能做的事情，下一章将介绍Redis中可用的更广泛的命令。在你了解更多关于每个结构和可以用它们做什么之后，你将准备好为你的应用的其他层或服务堆栈构建更多有用的组件。那你还在等什么呢？继续阅读吧！
