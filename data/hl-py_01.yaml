- en: Chapter 2\. Hunt the Wumpus
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章：Hunt the Wumpus
- en: '|  |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: '*Writing your first real program*'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写你的第一个真实程序*'
- en: '*How programs work*'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*程序的工作原理*'
- en: '*Some easy ways to organize programs*'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一些组织程序的方法*'
- en: '|  |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now that you have Python set up and installed and know how to enter and run
    a test program, let’s get started with writing a real one. I’ll begin by explaining
    a few of Python’s basic features, and then you’ll create a simple text-based adventure
    game called Hunt the Wumpus.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装并设置了Python，并且知道如何输入和运行测试程序，让我们开始编写一个真实的程序。我将首先解释Python的一些基本功能，然后你将创建一个名为Hunt
    the Wumpus的简单基于文本的冒险游戏。
- en: 'As you progress through the chapter, you’ll add features to your game, building
    on the initial version. This is how most programmers (including the author) learned
    to program: learn just enough about the language to be able to write a simple
    program, and then build up from there. In order to do that, you need more knowledge—but
    you only need to learn a little bit more to be able to make small additions to
    your program. Repeat the process of adding small features a few more times, and
    you’ll have a program that you couldn’t have created in one sitting. Along the
    way, you’ll have learned a lot about the programming language.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对本章的深入，你将为你的游戏添加功能，在初始版本的基础上构建。这就是大多数程序员（包括作者）学习编程的方式：学习足够多的语言知识来编写一个简单的程序，然后从那里开始构建。为了做到这一点，你需要更多的知识——但你只需要学习一点点更多，就能对你的程序进行小的添加。重复添加小功能的过程几次，你将拥有一个你无法一次性创建的程序。在这个过程中，你将学到很多关于编程语言的知识。
- en: In this chapter, you’ll experience the early days of programming first hand,
    as you write your own version of Hunt the Wumpus. The text-based interface is
    ideal for your first program because you only need to know two simple statements
    to handle all of your input and output. Because all of your input will be strings,
    the logic of your program is straightforward and you won’t need to learn a lot
    to start being productive.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将亲身体验编程的早期阶段，编写你自己的Hunt the Wumpus版本。基于文本的界面非常适合你的第一个程序，因为你只需要知道两个简单的语句来处理所有的输入和输出。由于所有的输入都将是以字符串形式，你的程序逻辑简单直接，你不需要学习很多就能开始变得高效。
- en: '|  |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**A brief history of Hunt the Wumpus**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**Hunt the Wumpus的简要历史**'
- en: Hunt the Wumpus was a popular early computer game written by Gregory Yob in
    1976\. It puts you in the shoes of an intrepid explorer, delving into a network
    of caves in search of the hairy, smelly, mysterious beast known only as the wumpus.
    Many hazards faced the player, including bats, bottomless pits, and, of course,
    the wumpus. Because the original game was released with source code, it allowed
    users to create their own versions of Hunt the Wumpus with different caves and
    hazards. Ultimately, reinterpretations of Wumpus led to the development of an
    entire genre of first-person adventure games, such as Adventure and Zork.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 《Hunt the Wumpus》是一款由格雷戈里·约伯（Gregory Yob）在1976年编写的大受欢迎的早期电脑游戏。它让你扮演一位勇敢的探险家，深入一个洞穴网络，寻找只有“wumpus”这个名称的毛茸茸、臭气熏天的神秘生物。玩家面临了许多危险，包括蝙蝠、无底洞，当然还有wumpus。由于原始游戏附带源代码，它允许用户创建具有不同洞穴和危险的Hunt
    the Wumpus版本。最终，Wumpus的重新诠释导致了第一人称冒险游戏整个流派的发展，例如《冒险》和《Zork》。
- en: '|  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: By the end of this chapter, you’ll know how to add features to your fully functioning
    version of Hunt the Wumpus, and you’ll even be able to tweak it to create your
    own version.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将知道如何向你的完全功能版的Hunt the Wumpus添加功能，你甚至可以对其进行调整以创建你自己的版本。
- en: '![](f0029-01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](f0029-01.jpg)'
- en: Before we get to the cave adventures, let’s figure out the basics.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入洞穴冒险之前，让我们弄清楚基础知识。
- en: What’s a program?
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是程序？
- en: As you learned in [chapter 1](kindle_split_009.html#ch01), a program consists
    of statements that tell the computer how to do something. Programs can execute
    simple tasks, such as printing a string to the screen, and can be combined to
    execute complex tasks, like balancing accounts or editing a document.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第一章](kindle_split_009.html#ch01)中学到的，一个程序由告诉电脑如何做某事的语句组成。程序可以执行简单的任务，例如在屏幕上打印字符串，并且可以组合起来执行复杂任务，如平衡账户或编辑文档。
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Program
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 程序
- en: A series of instructions, usually called *statements*, that tell your computer
    how to do certain things.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列指令，通常称为*语句*，告诉你的电脑如何执行某些操作。
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'The basic mechanics of a program are straightforward: Python starts at the
    first line and does what it says, then moves to the next and does what that says,
    and so on. For example, enter this simple Python program:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的基本机制很简单：Python 从第一行开始，执行它所说的，然后移动到下一行并执行它所说的，依此类推。例如，输入这个简单的 Python 程序：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code outputs output the following text to the screen:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将以下文本输出到屏幕上：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Python can do many different types of things. So that you can get started on
    your program as soon as possible, this chapter will give you a brief idea of the
    statements you can use to tell Python what to do. We won’t go into extensive detail,
    but you’ll learn everything you need so that you can follow what’s going on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Python 可以做很多不同类型的事情。因此，你可以尽快开始你的程序，本章将为你简要介绍你可以用来告诉 Python 要做什么的语句。我们不会深入细节，但你将学会你需要知道的一切，以便你能跟上进度。
- en: '![](f0030-01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](f0030-01.jpg)'
- en: There’s a lot to take in, so don’t worry too much if you don’t understand it
    all at once. You can think of programming like this as painting a picture; you’ll
    begin with a light pencil sketch before you get started properly. Some parts will
    be hazy at first, but it’s important to get a sense of the whole before you try
    to make sense of the details.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多内容需要吸收，所以如果你一开始不理解所有内容，不要过于担心。你可以将编程比作画画；你将开始用轻铅笔草图，然后开始正式工作。一开始有些部分可能会模糊不清，但在尝试理解细节之前，对整体有一个感觉是很重要的。
- en: You might also want to read this chapter at your computer, so that you can experiment
    with different statements to see what works and try out your own ideas.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想在电脑上阅读这一章，这样你可以尝试不同的语句来查看哪些有效，并尝试你自己的想法。
- en: We’ll start by investigating that *print* statement you just tried out.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来调查你刚才尝试的 *print* 语句。
- en: Writing to the screen
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向屏幕写入
- en: 'The *print* statement is used to tell the player what’s happening in your game,
    such as which cave the player is in or whether there’s a wumpus nearby. You’ve
    already seen the *print* statement in the Hello World program, but there are some
    extra things that it can do, too. You’re not limited to printing out words; pretty
    much anything in Python can be printed:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*print* 语句用于告诉玩家游戏中的情况，例如玩家在哪个洞穴或附近是否有独角兽。你已经在“Hello World”程序中看到了 *print* 语句，但它还可以做更多的事情。你不仅限于打印文字；Python
    中的几乎所有东西都可以打印出来：'
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can print out lots of things at once by putting a comma between them, like
    this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在它们之间放置逗号来同时打印出很多东西，如下所示：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But printing statements wouldn’t make for an interactive game. Let’s see how
    you can add options.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但打印语句不会使游戏变得互动。让我们看看你如何添加选项。
- en: Remembering things with variables
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用变量记住事情
- en: Python also needs some way to know what’s happening. In the Hunt the Wumpus
    game, for example, Python needs to be able to tell which cave the wumpus is hiding
    in, so it will know when the player has found the wumpus. In programming, we call
    this memory *data*, and it’s stored using a type of object called a *variable*.
    Variables have names so they can be referred to later in the program.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python 也需要一种方式来了解发生了什么。例如，在“寻找独角兽”游戏中，Python 需要知道独角兽藏在哪个洞穴里，这样它就会知道玩家何时找到了独角兽。在编程中，我们称这种记忆为
    *数据*，它使用一种称为 *变量* 的对象类型来存储。变量有名称，这样可以在程序中稍后引用它们。
- en: '![](f0031-01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](f0031-01.jpg)'
- en: 'To tell Python to set a variable, you choose a name for the variable and then
    use the equals sign to tell Python what the variable should be. Variables can
    be letters, numbers, words, or sentences, as well as some other things that we’ll
    cover later. Here’s how to set a variable:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要告诉 Python 设置一个变量，你为变量选择一个名称，然后使用等号告诉 Python 变量应该是什么。变量可以是字母、数字、单词或句子，以及我们稍后将要介绍的其他一些东西。以下是设置变量的方法：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In practice, your program can get quite complex, so it helps if you choose
    a name that tells you what the variable means or how it’s supposed to be used.
    In the Hunt the Wumpus program, you’ll use variable names like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你的程序可能会变得相当复杂，所以选择一个能告诉你变量含义或如何使用的名称会很有帮助。在“寻找独角兽”程序中，你会使用这样的变量名：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: There are some restrictions on what your variable names can be; they can’t start
    with a number, have spaces in them, or conflict with some of the names which Python
    uses for its own purposes. In practice, you won’t run into these limitations if
    you’re using meaningful names.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对你的变量名有一些限制；它们不能以数字开头，不能包含空格，也不能与 Python 用于其自身目的的一些名称冲突。在实践中，如果你使用有意义的名称，你不会遇到这些限制。
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Table 2.1](#ch02table01) gives you an overview of the variable types you’ll
    be using in your Hunt the Wumpus program.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[表2.1](#ch02table01)为你提供了你将在你的“猎杀独眼巨人”程序中使用的变量类型的概述。'
- en: Table 2.1\. Types of variable used in Hunt the Wumpus
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.1\. 在“猎杀独眼巨人”中使用的变量类型
- en: '| Type | Overview |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 概述 |'
- en: '| --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Numbers | Whole numbers like 3 or 527, or floating-point numbers like 2.0
    or 3.14159\. Python won’t switch between them, so you’ll need to be careful in
    some cases; for instance, 3 / 2 is 1 instead of 1.5\. 3.0 / 2 will give the right
    answer. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| Numbers | 包括3或527这样的整数，或2.0或3.14159这样的浮点数。Python不会在它们之间切换，所以某些情况下你需要小心；例如，3
    / 2的结果是1而不是1.5。3.0 / 2将给出正确答案。|'
- en: '| Strings | A sequence of characters, including *a–z*, numbers, and punctuation.
    They can be used for storing words and sentences. Python has a few different ways
    of representing strings: you can use both single or double quotes— ''foo'' or
    "foo"—as well as special versions with triple quotes that can run over multiple
    lines. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| Strings | 字符序列，包括*a–z*、数字和标点符号。它们可以用来存储单词和句子。Python有几种不同的字符串表示方法：你可以使用单引号或双引号—
    ''foo'' 或 "foo"—以及可以跨越多行的特殊版本的三引号。|'
- en: '| Lists | A collection of other variables, which can include other lists. Lists
    begin and end with a square bracket, and the items inside are separated with commas:
    ["foo", "bar", 1, 2, [3, 4, 5]]. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| Lists | 其他变量的集合，可以包括其他列表。列表以方括号开始和结束，内部项用逗号分隔：["foo", "bar", 1, 2, [3, 4,
    5]]。|'
- en: Now that you have variables working, how do you get the player involved?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 既然变量已经工作，你该如何让玩家参与进来？
- en: Asking the player what to do
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 询问玩家该做什么
- en: 'The program also needs some way of asking the player what to do in certain
    situations. For Hunt the Wumpus, you’ll use the *raw_input* command. When Python
    runs that command, it will prompt the player to type something in, and then whatever
    was typed can be stored in a variable:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 程序还需要一种方式来询问玩家在特定情况下该做什么。对于“猎杀独眼巨人”，你将使用*raw_input*命令。当Python运行该命令时，它会提示玩家输入一些内容，然后输入的内容可以存储在一个变量中：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, you need to figure out what to do with user input.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要弄清楚如何处理用户输入。
- en: Making decisions
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 做出决定
- en: 'If that was all there was to programming, it would be kind of boring. All of
    the interesting stuff happens when the player has to make a choice in the game.
    Will they pick cave 2 or cave 8? Is the wumpus hiding in there? Will the player
    be eaten? To tell Python what you want to happen in certain situations, you use
    the *if* statement, which takes a *condition*, such as two variables being equal
    or a variable being equal to something else, and something to do if the condition
    is met:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编程就只有这些，那会相当无聊。所有有趣的事情都发生在玩家在游戏中必须做出选择的时候。他们会选择洞穴2还是洞穴8？独眼巨人是否藏在那里？玩家会被吃掉吗？为了告诉Python在特定情况下你想让它发生什么，你使用*if*语句，它需要一个*条件*，例如两个变量相等或一个变量等于另一个值，以及如果条件满足要执行的操作：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](f0033-01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](f0033-01.jpg)'
- en: 'You can also use an *else* command, which tells Python what to do if the condition
    doesn’t match, like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用*else*命令，它告诉Python如果条件不匹配时要做什么，如下所示：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So that Python can tell the body of the *if* statement from the rest of your
    program, the lines which are part of it are indented. If you put an *if* statement
    within another *if* statement—usually referred to as *nesting*—then you need to
    indent again, for a total of eight spaces. Normally, you’ll use four spaces for
    each level of indentation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Python能够区分*if*语句的正文和你的程序的其他部分，属于它的行需要缩进。如果你在另一个*if*语句中放置一个*if*语句——通常称为*嵌套*——那么你需要再次缩进，总共八格空格。通常，你会在每个缩进级别使用四个空格。
- en: Some common conditions are listed in [table 2.2](#ch02table02).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见条件列于[表2.2](#ch02table02)中。
- en: Table 2.2\. Common conditions
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表2.2\. 常见条件
- en: '| Condition | Overview |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 条件 | 概述 |'
- en: '| --- | --- |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| name == "bob" | True if the variable name stores the string “bob”. Python
    uses two equal signs to distinguish it from assignment: name = "bob" means something
    completely different. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| name == "bob" | 如果变量name存储的是字符串“bob”，则为True。Python使用两个等号来区分它和赋值：name = "bob"意味着完全不同的事情。|'
- en: '| name != "bob" | True if the variable name is something other than the string
    “bob”. != is generally read as “not equals.” |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| name != "bob" | 如果变量name存储的不是字符串“bob”，则为True。!=通常读作“不等于”。|'
- en: '| a > 0 | True if the variable a stores a number that is greater than 0. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| a > 0 | 如果变量a存储的数字大于0，则为True。|'
- en: '| 0 <= a <= 10 | True if a is a number between 0 and 10, inclusive. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 0 <= a <= 10 | 如果a是介于0和10之间的数字（包括0和10），则为True。|'
- en: '| "ab" in "abcde" | You can also tell whether a string is part of another string
    by using in. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| "ab" in "abcde" | 你也可以通过使用 in 来判断一个字符串是否是另一个字符串的一部分。|'
- en: '| not "bob" in "ab" "bob" not in "ab" | Python also has the not and not in
    commands, which reverse the sense of an expression. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| not "bob" in "ab" "bob" not in "ab" | Python 还具有 not 和 not in 命令，它们可以反转表达式的意义。|'
- en: Now that you have a handle on decision-making statements, let’s see what you
    can do to keep the program going.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了决策语句，让我们看看你可以做些什么来使程序继续运行。
- en: Loops
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 循环
- en: 'One of the great things about computers is not that they can do things, but
    that they can do things over and over and over and not get bored. Big lists of
    numbers to add? No problem. Hundreds of lines of files? Ditto. The program only
    needs to know what it’s going to be repeating and when it should stop. In the
    Hunt the Wumpus program, you’ll be using a structure called a *while loop*, which
    loops as long as a condition that you specify is true, and a *break* statement,
    which allows you to control when it stops. Here’s an example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的一个伟大之处不在于它们能做什么，而在于它们能一遍又一遍地做同样的事情而不会感到无聊。一大堆要加的数字？没问题。数百行文件？也是一样。程序只需要知道它将要重复什么，以及何时应该停止。在
    Hunt the Wumpus 程序中，你将使用一个称为 *while 循环* 的结构，它会在指定的条件为真时循环，以及一个 *break* 语句，它允许你控制何时停止。以下是一个示例：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](f0034-01.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0034-01.jpg)'
- en: We’re almost to the end of the tour of Python’s basic features; our last one
    is functions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了对 Python 基本特性的游览；我们最后一个是函数。
- en: Functions
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数
- en: 'There are also a few statements called *functions* in the Wumpus program. They
    usually tell you useful things about your program, the player, or the variables,
    and they look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Wumpus 程序中还有一些称为 *函数* 的语句。它们通常告诉你有关你的程序、玩家或变量的有用信息，它们看起来像这样：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](f0035-01.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0035-01.jpg)'
- en: 'Normally, functions will tell you things by *returning* a value, which you
    can store in a different variable or use directly:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，函数会通过 *返回* 一个值来告诉你一些事情，你可以将这个值存储在另一个变量中或直接使用：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we’ve covered some of the basics, let’s see how you can use them to
    build a simple program. This doesn’t do everything that the original Hunt the
    Wumpus program did, but for now we want to get something off the ground to see
    how it all fits together.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一些基础知识，让我们看看你如何使用它们来构建一个简单的程序。这个程序并不做原始的 Hunt the Wumpus 程序所做的一切，但为了现在，我们想要搭建一些东西来看看它如何组合在一起。
- en: '|  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Incremental programming**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**增量编程**'
- en: 'In later sections of this chapter, you’ll build on this program by adding features
    or refining ones that are already there, and tidy up as you go. This is how most
    programmers tend to work: start simply and build as you go. You can download this
    program from [www.manning.com/hellopython](http://www.manning.com/hellopython),
    but I’d suggest following along and typing it in as you read it. That’ll help
    you remember the individual statements more easily, but you’ll also be establishing
    a key habit which will help you as you write larger programs—start with a small
    program and grow from there.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '在本章的后续部分，你将通过添加功能或改进现有功能来构建这个程序，并在过程中进行整理。大多数程序员通常是这样工作的：开始简单，然后逐步构建。你可以从 [www.manning.com/hellopython](http://www.manning.com/hellopython)
    下载这个程序，但我建议你跟随阅读并输入它。这将帮助你更容易地记住单个语句，但你也将在编写更大的程序时养成一个关键习惯——从一个小的程序开始，然后逐步扩展。 '
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Table 2.3](#ch02table03) lists the basic features that you’ll learn in this
    chapter.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2.3](#ch02table03) 列出了本章中你将学习的基本特性。'
- en: Table 2.3\. Basic Python features
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 2.3\. Python 基本特性
- en: '| Feature | Overview |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 特性 | 概述 |'
- en: '| --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Statements | Usually one line in a program (but can be more) that tells Python
    to do something. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 语句 | 通常是一行程序（但也可以更多）告诉 Python 做某事。|'
- en: '| Variables | Used to refer to information so that a program can use it later.
    There are many different types of information that Python can refer to. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 用于引用信息，以便程序以后可以使用。Python 可以引用许多不同类型的信息。|'
- en: '| if-then-else | This is how you tell Python to make a decision. An *if* statement
    consists of at least a condition such as x == 2 or some_function() < 42 and something
    for Python to do if that expression is true. You can also include an else clause,
    which tells Python what to do if the expression is false. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| if-then-else | 这是告诉 Python 做出决定的方式。一个 *if* 语句至少包含一个条件，例如 x == 2 或 some_function()
    < 42，以及当该表达式为真时 Python 要执行的操作。您还可以包含一个 else 子句，它告诉 Python 当表达式为假时该做什么。|'
- en: '| Loops | Used to repeat certain statements multiple times. They can be either
    while loops, which are based on a condition like an if statement, or for loops,
    which run once for each element of a list. From within a loop, you can use the
    continue statement, which jumps to the next iteration of the loop, or a break
    statement, which breaks out of the loop entirely. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 循环 | 用于重复某些语句多次。它们可以是基于条件（如if语句）的while循环，或者是对列表中的每个元素运行一次的for循环。在循环内部，你可以使用continue语句，它将跳转到循环的下一个迭代，或者使用break语句，它将完全退出循环。|'
- en: '| Functions | A series of statements that can be run to return a value to a
    separate part of your program. They can take input if necessary, or they can read
    (and sometimes write) other variables in your program. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 一系列可以运行以将值返回到程序中其他部分的语句。如果需要，它们可以接受输入，或者它们可以读取（有时写入）程序中的其他变量。|'
- en: '| Indenting | Because you can nest functions, loops, and if statements within
    each other, Python uses white space (normally four spaces per level) at the start
    of a line to tell which statements belong where. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 缩进 | 因为你可以将函数、循环和if语句嵌套在一起，Python在行的开头使用空白（通常每级四个空格）来告诉哪些语句属于哪里。|'
- en: '| Comments | Whenever Python encounters a # character at the start of a line,
    it will ignore that line and not run it. Additionally, if there’s a # character
    that’s not inside a string, it will ignore the rest of the line. Comments are
    used to explain parts of your program, either to other programmers or to yourself
    in a few weeks—when you’ve forgotten most of the details of what you were doing.
    You won’t see too many in the book, because we use numbered comments for code
    listings. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 注释 | 当Python在行的开头遇到#字符时，它将忽略该行并且不会运行它。此外，如果#字符不在字符串内部，它将忽略该行剩余部分。注释用于解释程序的部分，无论是为了其他程序员还是为了几周后的自己——当你已经忘记了大部分你当时所做的事情的细节。在书中你不会看到太多注释，因为我们为代码列表使用编号注释。|'
- en: You’ve learned a lot in this section, but in the next section you’ll put this
    knowledge to good use and write your first program.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本节中学到了很多，但在下一节中，你将把所学知识付诸实践，并编写你的第一个程序。
- en: Your first program
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的第一个程序
- en: Now that you have an understanding of the basics of Python, let’s take a look
    at the program. It’s difficult to see how a program works just by reading about
    individual features, because, in a working program, they all depend on each other.
    In this section, we’ll explore the first version of Hunt the Wumpus and solve
    the first problem that comes up.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Python的基础知识，让我们来看看程序。仅仅通过阅读关于单个特性的描述，很难看到程序是如何工作的，因为在运行中的程序中，它们都相互依赖。在本节中，我们将探索Hunt
    the Wumpus的第一个版本并解决出现的第一问题。
- en: '![](f0036-01.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](f0036-01.jpg)'
- en: '|  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Experimentation is critical to developing an intuition for how Python works,
    and how all of the parts fit together. Without it, you’ll be stuck cut and pasting
    other people’s programs, and when you have a bug, it’ll be impossible to fix.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 实验对于培养对Python如何工作以及所有部分如何相互配合的直觉至关重要。没有它，你将陷入复制粘贴他人的程序，而且当你遇到错误时，将无法修复。
- en: '|  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The first version of Hunt the Wumpus
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Hunt the Wumpus的第一个版本
- en: If you don’t understand the next listing right away, don’t worry. A good way
    to figure out what a program does is to experiment with it—change a few statements,
    run it again, and see what the differences are. Or, copy a few statements into
    another file so you can run them in isolation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一开始不理解接下来的列表，请不要担心。了解一个程序如何工作的一个好方法是实验它——更改几个语句，再次运行它，看看有什么不同。或者，将几个语句复制到另一个文件中，这样你就可以单独运行它们。
- en: Listing 2.1\. Your first version of Hunt the Wumpus
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.1\. Hunt the Wumpus的第一个版本
- en: '![](ch02list1-0.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](ch02list1-0.jpg)'
- en: '![](ch02list1-1.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](ch02list1-1.jpg)'
- en: Let’s start with the “setup” part of the program ![](one.jpg). You’re storing
    a list of numbers in the program, each of which represents a cave. Don’t worry
    too much about the first line—you’ll learn more about the *import* statement in
    [chapter 3](kindle_split_011.html#ch03). The *choice* function will return one
    of the caves, picked at random, and you use it to place the wumpus and the player
    in their starting positions. Note the loop at the end that you use to tell if
    the player and the wumpus are in the same spot—it wouldn’t be a fun game if the
    player got eaten right away!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从程序的“设置”部分开始 ![图片](one.jpg)。你在程序中存储了一个数字列表，每个数字代表一个洞穴。不必太担心第一行——你将在第3章中了解更多关于
    *import* 语句的信息。*choice* 函数将随机返回一个洞穴，你使用它将独眼巨人和玩家放置在起始位置。注意你使用的循环，用于判断玩家和独眼巨人是否在同一位置——如果玩家立刻被吃掉，游戏将不再有趣！
- en: The introductory text ![](two.jpg) tells the player how the game works. You
    use the *len()* function to tell how many caves there are. This is useful because
    you may want to change the number of caves at a later point, and using a function
    like this means you only have to change things in one place when you define the
    list of caves.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 开场白 ![图片](two.jpg) 告诉玩家游戏是如何工作的。你使用 *len()* 函数来告诉洞穴的数量。这很有用，因为你可能想在以后改变洞穴的数量，使用这样的函数意味着你只需要在一个地方更改定义洞穴列表时的事情。
- en: '![](f0038-01.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0038-01.jpg)'
- en: Your main game loop ![](three.jpg) is where the game starts. When playing the
    game, the program gives the player details of what the player can see, asks the
    player to enter a cave, checks to see whether the player has been eaten, and then
    starts over at the beginning. *while* loops will loop as long as their condition
    is true, so *while True:* means “loop over and over again without stopping” (you’ll
    handle the stopping part in a minute).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您的主游戏循环 ![图片](three.jpg) 是游戏开始的地方。当玩游戏时，程序会向玩家提供玩家可以看到的详细信息，要求玩家输入一个洞穴，检查玩家是否被吃掉，然后从头开始。*while*
    循环会在其条件为真时循环，所以 *while True:* 表示“不断循环而不停止”（你将在下一分钟处理停止的部分）。
- en: The first *if* statement ![](four.jpg) tells the player where the player is
    and prints a warning if the wumpus is only one room away (“I smell a wumpus!”).
    Note how you’re using the *player_location* and *wumpus_location* variables. Because
    they’re numbers, you can add to and subtract from them. If the player is in cave
    3, and the wumpus is in cave 4, then the *player_location == wumpus_location*
    - 1 condition will be true, and Python will display the message.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 *if* 语句 ![图片](four.jpg) 告诉玩家玩家的位置，如果独眼巨人只有一个房间之遥，则打印警告信息（“我闻到独眼巨人的气味了！”）。注意你如何使用
    *player_location* 和 *wumpus_location* 变量。因为它们是数字，你可以对它们进行加法和减法操作。如果玩家在洞穴3，而独眼巨人位于洞穴4，那么
    *player_location == wumpus_location* - 1 条件将为真，Python 将显示该消息。
- en: You then ask the player which cave the player wants next ![](five.jpg). You
    do some checking to see that the player has put in the right sort of input. It
    has to be a number, and it has to be one of the caves. Note also that the input
    will be a string, not a number, so you have to convert it using the *int()* function.
    If it doesn’t match what you need, you display a message to the player.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你询问玩家想要去哪个洞穴 ![图片](five.jpg)。你做一些检查以确保玩家输入了正确的输入类型。它必须是一个数字，并且必须是洞穴之一。注意，输入将是一个字符串，而不是数字，所以你必须使用
    *int()* 函数将其转换。如果它不符合你的需求，你将向玩家显示一条消息。
- en: If the input does match a cave number, it will trigger this *else* clause ![](six.jpg).
    It updates the *player_location* variable with the new value and then checks to
    see if the player’s location is the same as the wumpus’s. If it is ... “Aargh!
    You got eaten by a wumpus!” Once the player has been eaten, the game should stop,
    so you use the *break* command to stop your main loop. Python has no more statements
    to execute, and so the game ends.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入与洞穴编号匹配，将触发这个 *else* 子句 ![图片](six.jpg)。它将使用新值更新 *player_location* 变量，然后检查玩家的位置是否与独眼巨人的位置相同。如果是
    ... “啊！你被独眼巨人吃掉了！”一旦玩家被吃掉，游戏应该停止，所以你使用 *break* 命令来停止你的主循环。Python 没有更多的语句要执行，因此游戏结束。
- en: '![](f0039-01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0039-01.jpg)'
- en: Debugging
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调试
- en: If you’ve typed in [listing 2.1](#ch02list1) exactly as written and run it,
    you’ll notice that it doesn’t quite work as planned. In fact, it refuses to run
    at all. The exact results will depend on your computer’s operating system and
    how you’re running your Python program, but you should see something similar to
    what is shown in the following listing. If you don’t, try running your program
    from the command line by typing *python wumpus-1.py*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经按照[列表 2.1](#ch02list1) 的内容输入并运行了，你会注意到它并不完全按计划工作。实际上，它根本无法运行。确切的结果将取决于你的计算机操作系统以及你如何运行你的
    Python 程序，但你应该会看到以下列表中显示的内容。如果你没有，尝试通过在命令行中输入 *python wumpus-1.py* 来运行你的程序。
- en: Listing 2.2\. BANG! Your program explodes
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2\. BANG！你的程序爆炸了
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](f0039-02.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](f0039-02.jpg)'
- en: What’s happened is that there’s a *bug* in the program. There’s a statement
    in [listing 2.1](#ch02list1) that Python doesn’t know how to run. Rather than
    guess what you meant, it will stop and refuse to go any further until you’ve fixed
    it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是程序中有一个 *bug*。在 [列表 2.1](#ch02list1) 中有一个 Python 无法运行的语句。它不会猜测你的意图，而是会停止并拒绝继续运行，直到你修复它。
- en: 'Luckily, the problem is easy to fix: Python tells you what line is at fault
    and the type of error that’s been triggered, and it provides a rough description
    of the problem. In this case, it’s line 10, and the error is *NameError: name*
    *''caves'' is not defined*. Oops—the program tried to access the variable *caves*
    instead of *cave_numbers*. If you change line 10 so that it reads'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '幸运的是，这个问题很容易解决：Python 会告诉你出错的行号和触发的错误类型，并提供对问题的粗略描述。在这种情况下，是第 10 行，错误是 *NameError:
    name* *''caves'' is not defined*。哎呀——程序试图访问变量 *caves* 而不是 *cave_numbers*。如果你将第
    10 行修改为'
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: then the program should run.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，程序应该可以运行。
- en: Congratulations—your first real Python program! Next, let’s see what else you
    can do to improve Hunt the Wumpus.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜——你的第一个真正的 Python 程序！接下来，让我们看看你还能做些什么来改进“抓捕独角兽”。
- en: Experimenting with your program
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实验你的程序
- en: Experimenting with programs is the most common way that most programmers learn
    how to deal with new programming problems and find solutions. You, too, can experiment
    with your new program and see what else you can get it to do. You’re the one typing
    it in, so the wumpus program is yours. You can make it do whatever you want it
    to. If you’re feeling brave, try the following ideas.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实验程序是大多数程序员学习如何处理新的编程问题和找到解决方案的最常见方式。你也可以通过实验你的新程序来看看你还能让它做什么。你是输入的人，所以独角兽程序是你的。你可以让它做任何你想让它做的事情。如果你觉得勇敢，尝试以下想法。
- en: More (or fewer) caves
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多（或少）的洞穴
- en: 'You might find 20 caves to be too many—or too few. Luckily, it’s your program
    now, so you can change the line where you define *cave_numbers* to be smaller
    or larger. Question: what happens if you have only one cave?'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得有 20 个洞穴太多——或者太少。幸运的是，现在这是你的程序，所以你可以修改定义 *cave_numbers* 的行，使其更小或更大。问题：如果你只有一个洞穴会发生什么？
- en: A nicer wumpus
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更好的独角兽
- en: 'You haven’t put a bow and arrow into the game yet, so all the player can do
    is wander aimlessly around the caves until the player bumps into the wumpus and
    gets eaten. Not a very fun game. How about if you change the line where the player
    finds the wumpus to read:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你还没有在游戏中加入弓箭，所以玩家只能漫无目的地在洞穴中徘徊，直到玩家撞到独角兽并被吃掉。这不是一个很有趣的游戏。如果你改变玩家找到独角兽的行，使其读取：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Aww, what a nice wumpus! (The author and publisher disclaim any and all responsibility
    for dry-cleaning your clothes to get out the wumpus smell should you choose this
    option.)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，多可爱的独角兽！（作者和出版社声明，如果你选择这个选项，对于干洗衣服以去除独角兽的味道，他们不承担任何责任。）
- en: More than one wumpus
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多个独角兽
- en: The wumpus must be awfully lonely down in the caves. How about giving it a friend?
    This is a bit trickier; but you already have the existing wumpus code to work
    from. Add a *wumpus_friend_location* variable, and check that wherever you check
    the first *wumpus_location* as shown here.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 独角兽在洞穴里一定非常孤单。给它一个朋友怎么样？这有点棘手；但你已经有了现有的独角兽代码可以从中工作。添加一个 *wumpus_friend_location*
    变量，并检查你检查第一个 *wumpus_location* 的任何地方，如下所示。
- en: Listing 2.3\. Adding a friend for the wumpus
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.3\. 为独角兽添加一个朋友
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that’s a more interesting game!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏更有趣了！
- en: There’s still more you can do to improve the Hunt the Wumpus game, starting
    with the cave structure.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以做更多的事情来改进“抓捕独角兽”游戏，从洞穴结构开始。
- en: '![](f0041-01.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](f0041-01.jpg)'
- en: Making the caves
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 制作洞穴
- en: The first thing that you might have noticed about [listing 2.1](#ch02list1)
    is that the “maze of caves” isn’t a maze. It’s more like a corridor, with the
    caves neatly placed in a line, one after the other. It’s easy to figure out where
    the Wumpus is—move into the next cave in sequence until you smell it. Because
    figuring out the location of the wumpus is such an integral part of the game,
    this is the first thing to fix. While addressing this, you’ll learn a bit more
    about Python’s *lists* and *for**loops*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能首先注意到的关于[列表2.1](#ch02list1)的是，“迷宫洞穴”并不是一个迷宫。它更像是一个走廊，洞穴整齐地排列成一行，一个接一个。很容易找出Wumpus的位置——按顺序进入下一个洞穴，直到你闻到它的气味。因为确定Wumpus的位置是游戏的一个关键部分，所以这是首先要解决的问题。在解决这个问题时，你会对Python的*列表*和*for*循环有更多的了解。
- en: Lists
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列表
- en: 'Assume for a second that you wanted to write a program to help you do your
    shopping. The first thing that you’d need is some way to keep track of what you
    wanted to buy. Python has a built in mechanism for exactly this sort of thing,
    called a *list*. You can create and use it like any other variable:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想写一个程序来帮助你购物。你需要的第一件事是跟踪你想要购买的东西。Python有一个内置机制可以做到这一点，称为*列表*。你可以像使用任何其他变量一样创建和使用它：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you want to find out what’s on your shopping list, you can print it out
    or you can use an *index* to find out what’s in a specific place. Lists will keep
    everything in the order in which you defined it. The only catch is that the index
    of an array starts at 0, rather than 1:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道你的购物清单上有什么，你可以将其打印出来，或者你可以使用一个*索引*来找出特定位置的内容。列表将按照你定义的顺序保留一切。唯一的缺点是数组的索引从0开始，而不是1：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A clever trick if you need it, is that an index of -1 gets the last item in
    your array:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要，一个巧妙的技巧是，索引-1获取数组中的最后一个项目：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can also check whether a particular thing is in your list:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以检查特定的事物是否在你的列表中：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The other cool thing about lists is that they fulfill many purposes. You’re
    not limited to strings or numbers—you can put anything at all in there, including
    other lists. If you had lists for two stores (say, the supermarket and Wumpus
    ‘R’ Us (“for all your Wumpus-hunting needs!”), you could store them in their own
    lists and then store those lists in one big list:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的另一个酷特点是它们可以满足许多用途。你不仅限于字符串或数字——你可以放入任何东西，包括其他列表。如果你有两个商店的列表（比如，超市和Wumpus
    ‘R’ Us（“满足你所有Wumpus狩猎需求！”），你可以将它们存储在自己的列表中，然后将这些列表存储在一个大列表中：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](f0043-01.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0043-01.jpg)'
- en: 'You can also put things into a list and take them out again. If you forget
    to put rope on your list, that’s easily fixed:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将事物放入列表中，然后再取出来。如果你忘记将绳子列入你的列表，那很容易解决：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You want to catch a Wumpus instead of scaring it away, so perhaps the “Wumpus
    B Gone” isn’t such a good idea:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你想捕捉Wumpus而不是将其吓跑，所以“Wumpus B Gone”可能不是一个好主意：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can also cut out parts of a list if you need to, by giving two values separated
    with a colon. This is called *slicing* a list. Python will return another list
    starting at the first index, up to but not including the second index. Remember
    that list indexes start at zero:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要，你也可以通过给出两个用冒号分隔的值来从列表中删除部分内容。这被称为*切片*列表。Python将返回另一个列表，从第一个索引开始，直到但不包括第二个索引。记住列表索引从零开始：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you give a negative value, then Python will measure from the end instead
    of the front:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提供一个负值，那么Python将从后向前测量：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Notice that that last example left out the last index. If you leave a value
    out of a slice like that, Python will use the start or end of the list. These
    two slices are exactly the same as the previous two:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最后一个例子省略了最后一个索引。如果你在切片中省略一个值，Python将使用列表的起始或结束位置。这两个切片与前面的两个完全相同：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, once you’ve taken everything out of a list, you’ll end up with an
    *empty list*, which is represented with two square brackets by themselves: *[]*.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦你从列表中取出所有东西，你将得到一个*空列表*，它由两个方括号本身表示：*[]*。
- en: '|  |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: One difference between Python and some other programs, such as C, is that Python’s
    variables aren’t variables in the classic sense. For the most part, they behave
    as if they are, but they’re more like a label or a pointer to an object in memory.
    When you issue a command like *a = []*, Python creates a new list object and makes
    the *a* variable point to it. If you then issue a command like *b = a*, *b* will
    point to the same list object, and anything that you do via *a* will also appear
    to happen to *b*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Python与其他程序（如C）之间有一个区别，那就是Python的变量在经典意义上并不是变量。大部分情况下，它们表现得像变量，但它们更像是一个标签或内存中对象的指针。当你发出像*a
    = []*这样的命令时，Python创建一个新的列表对象，并使*a*变量指向它。如果你然后发出像*b = a*这样的命令，*b*将指向同一个列表对象，并且通过*a*进行的任何操作也会似乎发生在*b*上。
- en: '|  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now that you know about lists, let’s tackle *for loops*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了列表，让我们来处理**for**循环。
- en: For loops
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**for**循环'
- en: 'Once you have all of your things in a list, a common way to use the list is
    to do something to each item in it. The easiest way to do this is to use a type
    of loop called a *for**loop*. A *for* loop works by repeating some statements
    for every item in a list, and assigns that item to a variable so that you can
    do something with it:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将所有物品列成清单，一个常见的使用清单的方法是对其中的每一项进行某种操作。最简单的方法是使用一种称为**for**循环的循环类型。**for**循环通过重复某些语句来遍历列表中的每一项，并将该项分配给一个变量，这样你就可以对它进行操作：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Except for the variable, *for* loops are much the same as *while* loops. The
    *break* statement which you used in the *while* loop in [listing 2.1](#ch02list1)
    will also work in *for* loops.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了变量之外，**for**循环与**while**循环非常相似。你在[列表2.1](#ch02list1)中的**while**循环中使用的**break**语句在**for**循环中也会起作用。
- en: '|  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This is a common pattern in programming—get a bunch of stuff, and do something
    to everything in your bunch.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在编程中常见的一种模式——获取一堆东西，并对你的每一堆东西做点什么。
- en: '|  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Coding your caves
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编码你的洞穴
- en: In Hunt the Wumpus, each cave is only supposed to connect to a small number
    of other caves. For example, cave 1 might only have tunnels to caves 5, 7, and
    12, and then cave 5 has tunnels to 10, 14, and 17\. This limits the number of
    caves the player can visit at once, and navigating their way through the cave
    system to try and find the wumpus becomes the central challenge of the game.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在“寻找独角兽”游戏中，每个洞穴只应该连接到少量其他洞穴。例如，洞穴1可能只有通往洞穴5、7和12的隧道，然后洞穴5有通往10、14和17的隧道。这限制了玩家一次可以访问的洞穴数量，而通过洞穴系统导航以尝试找到独角兽成为游戏的核心挑战。
- en: '![](f0045-01.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](f0045-01.jpg)'
- en: 'In your first version of Hunt the Wumpus, you were already using a list of
    cave numbers to tell Python where the wumpus and player were. In your new version,
    you’ll use a similar sort of list, but changed so that it can tell you which caves
    can be visited from a particular place. For each cave, you’ll need a list of other
    caves, so what you’re after is a list of lists. In Python, it looks like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在你第一次编写“寻找独角兽”的游戏版本时，你已经使用了一个洞穴编号列表来告诉Python独角兽和玩家的位置。在你的新版本中，你将使用类似类型的列表，但进行了修改，以便它能告诉你从特定位置可以访问哪些洞穴。对于每个洞穴，你需要一个其他洞穴的列表，因此你追求的是一个列表的列表。在Python中，它看起来是这样的：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: What this tells you is that cave 0 (don’t forget that lists start with their
    index at 0) links to caves 2, 3, and 7; cave 1 links to caves 5, 6, and 12; and
    so on. Because the caves are generated randomly, your numbers will be different,
    but the overall structure will be the same. The number of the cave is the same
    as its index in the list so that Python can easily find the exits later. Let’s
    replace section 1 of [listing 2.1](#ch02list1) with the following listing so that
    it sets up your new and improved cave system.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明洞穴0（别忘了列表的索引从0开始）链接到洞穴2、3和7；洞穴1链接到洞穴5、6和12；以此类推。因为洞穴是随机生成的，所以你的数字会不同，但整体结构将是相同的。洞穴的编号与列表中的索引相同，这样Python可以轻松地找到出口。让我们用以下列表替换[列表2.1](#ch02list1)的第1部分，以便它设置你的新改进的洞穴系统。
- en: Listing 2.4\. Setting up your caves
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.4。设置你的洞穴
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You’re still using a *range* function to generate the list of caves, but you’ve
    changed the range so that it starts at 0 instead of 1, to match the indexes of
    your list. Then you make an empty list for each of the caves that you’re supposed
    to have. At this point, it’s a list of unconnected caves.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然使用*range*函数来生成洞穴列表，但你已经改变了范围，使其从0开始而不是1，以匹配列表的索引。然后你为应该拥有的每个洞穴创建一个空列表。在这个阶段，它是一个未连接的洞穴列表。
- en: For each unconnected cave in your list, you pick three other caves at random
    and append them onto this cave’s list of tunnels. To make things easier, you use
    another *for* loop inside the first one, so that if you need to change the number
    of tunnels later, you only need to change the number 3 to whatever you’d like.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你列表中每个未连接的洞穴，你随机选择三个其他洞穴并将它们附加到这个洞穴的隧道列表中。为了使事情更简单，你在第一个循环内部使用另一个 *for* 循环，这样如果你以后需要更改隧道的数量，你只需要将数字
    3 改成你想要的任何数字。
- en: When you’re picking a cave to link to, you use a *temporary variable* to store
    it. The main advantage of this is that you can use a meaningful name to make the
    code much easier to read, because you know what that variable does. Note that
    you could have joined these two lines together by writing *caves[i].append(choice(cave_numbers))*
    instead (using the *choice(cave_numbers)* function directly), but it’s much harder
    to read.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择一个要连接的洞穴时，你使用一个 *临时变量* 来存储它。这样做的主要优点是你可以使用一个有意义的名称来使代码更容易阅读，因为你知道这个变量做什么。请注意，你可以通过写入
    *caves[i].append(choice(cave_numbers))* 来合并这两行（直接使用 *choice(cave_numbers)* 函数），但这会使代码更难阅读。
- en: So that you can check the program is working properly, you print out the list
    of caves. This is usually referred to as a *debug string*, because it’s a handy
    technique when you’re trying to debug a program. You can remove this line once
    the program is running properly, because the player shouldn’t know the caves ahead
    of time.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查程序是否正常工作，你打印出洞穴列表。这通常被称为 *调试字符串*，因为当你试图调试程序时，这是一个方便的技术。一旦程序正常运行，你可以删除这一行，因为玩家不应该提前知道洞穴。
- en: '![](f0046-01.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](f0046-01.jpg)'
- en: 'Now, when you run your program, it should print out a list of caves, like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行你的程序时，它应该会打印出一个洞穴列表，如下所示：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is exactly what to expect. In this one, cave 0 links to caves 8, 7, and
    14; cave 1 links to caves 1, 18, and 4; and so on. Now that you have the list,
    all that you have to do is alter the rest of your program to use it. Sections
    4 and 5 of [listing 2.1](#ch02list1) should be replaced with the following listing.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是你预期的。在这个例子中，洞穴 0 连接到洞穴 8、7 和 14；洞穴 1 连接到洞穴 1、18 和 4；以此类推。现在你有了这个列表，你只需要将程序的其余部分更改为使用它。列表
    2.1 的第 4 和 5 节应替换为以下列表。
- en: Listing 2.5\. Altering your program to use the new cave system
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.5\. 修改程序以使用新的洞穴系统
- en: '![](02list05_alt.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](02list05_alt.jpg)'
- en: You’re only using the cave list to find out which caves the player can enter
    next, so the changes to the code ![](one.jpg) are pretty straightforward. Instead
    of checking whether the player’s input is within the list of cave numbers, you
    check the list for the specific cave you’re in.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你只使用洞穴列表来找出玩家可以进入的下一个洞穴，所以代码的更改 ![](one.jpg) 是相当直接的。你不需要检查玩家的输入是否在洞穴编号列表中，而是检查你所在的特定洞穴列表。
- en: There’s a bug in the code you used to set up your caves. You may not believe
    me, especially if you’ve played a few games already, but there is. Let’s get back
    into debugging mode.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在你用来设置洞穴的代码中有一个错误。你可能不相信我，尤其是如果你已经玩了几局游戏，但确实有。让我们回到调试模式。
- en: Fixing a more subtle bug
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复一个更微妙的错误
- en: What makes the bug hard to spot is that the code runs properly, but sometimes
    the game is impossible to win. In this section, we’ll look at why the game can
    be unwinnable and how to fix it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使错误难以发现的是，代码运行正常，但有时游戏根本无法获胜。在本节中，我们将探讨为什么游戏可能无法获胜以及如何修复它。
- en: '|  |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: These are the worst kind of bugs to hunt down—your program doesn’t crash or
    spit out any obvious errors, but it’s definitely wrong.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是最难追踪的 bug——你的程序不会崩溃或输出任何明显的错误，但它确实有误。
- en: '|  |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: We’ll start by examining how the caves are linked.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将检查洞穴是如何连接的。
- en: The problem
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 问题
- en: The trick is that all the cave tunnels are generated randomly, so they can be
    linked in any possible way. Let’s think about an easier case, with a small cave
    system. Suppose the tunnels happened to link like they do in [figure 2.1](#ch02fig01).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是所有洞穴隧道都是随机生成的，因此它们可以以任何可能的方式连接。让我们考虑一个更容易的情况，一个小型的洞穴系统。假设隧道恰好像 [图 2.1](#ch02fig01)
    中的那样连接。
- en: Figure 2.1\. This isn’t a very fun game.
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.1\. 这不是一个很有趣的游戏。
- en: '![](02fig01.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig01.jpg)'
- en: The player wouldn’t ever be able to catch the wumpus.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家永远无法捕捉到野猪。
- en: With lots of caves, it’s less likely that you’ll strand the player in an isolated
    corner of the map; but, ideally, you’d like the program to be as bulletproof as
    you can make it, so that it’s *impossible*, rather than unlikely.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在有很多洞穴的情况下，玩家被困在地图孤立角落的可能性会降低；但理想情况下，您希望程序尽可能无懈可击，使其*不可能*，而不是不太可能。
- en: The solution
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决方案
- en: You need to make two changes to the map generation to solve the problem. The
    first is to make the tunnels two-way. If you can go from cave 1 to cave 2, then
    you should be able to move back from cave 2 to cave 1.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要对地图生成进行两项更改以解决问题。第一是使隧道双向。如果您可以从洞穴 1 前往洞穴 2，那么您应该能够从洞穴 2 返回洞穴 1。
- en: '![](f0048-01.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](f0048-01.jpg)'
- en: The second is to make sure that every cave is linked together and that there
    are no isolated caves (or networks of caves). This is called a *connected* structure.
    That way, no matter how you join up the rest of the passages, you can be sure
    players can reach every cave, because players can go back the way they came and
    choose a different passage. If players forget which way they came then they can
    still get lost, but that’s their fault rather than yours.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点是确保每个洞穴都相互连接，并且没有孤立的洞穴（或洞穴网络）。这被称为*连通*结构。这样，无论您如何连接其余的通道，您都可以确信玩家可以到达每个洞穴，因为玩家可以沿着来时的路返回并选择另一条通道。如果玩家忘记了他们来的路，他们仍然可能会迷路，但这不是您的错。
- en: Now, how do you use Python to link tunnels?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您如何使用 Python 连接隧道？
- en: Coding connected caves
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编码连通洞穴
- en: Connecting caves is straightforward—when you create a one-way tunnel, you add
    another one way tunnel back the way you came. Every time you say *caves[a].append[b]*,
    you also say *caves[b].append[a]*. The program looks something like the following
    listing.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 连接洞穴很简单——当您创建一个单向隧道时，您需要沿着来时的路再创建一个单向隧道。每次您说 *caves[a].append[b]*，您也说要 *caves[b].append[a]*。程序看起来像以下列表。
- en: Listing 2.6\. Creating a linked cave network
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.6\. 创建一个连通的洞穴网络
- en: '![](02list06.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](02list06.jpg)'
- en: First, create a list of caves that you haven’t visited, and visit cave 0 ![](one.jpg).
    You loop until *unvisited_caves* is empty ![](two.jpg); that is, there are no
    unvisited caves left. You pick one that has fewer than three tunnels to other
    caves ![](three.jpg). If you link 1 cave to 10 others, the game will be too hard,
    because it will be difficult or impossible to work out which tunnel leads to the
    wumpus.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个您尚未访问的洞穴列表，并访问洞穴 0！[](one.jpg)。您循环直到 *unvisited_caves* 为空！[](two.jpg)；也就是说，没有未访问的洞穴了。您选择一个与其他洞穴有少于三个隧道的洞穴！[](three.jpg)。如果您将一个洞穴连接到
    10 个其他洞穴，游戏将太难，因为这将很难或不可能确定哪个隧道通向怪物。
- en: '![](four.jpg) is where you’re building the cave. You pick a random unvisited
    cave, put a tunnel in the old cave to the new one, and then link from the new
    one back to the old one. This way you know that players can find their way back.
    In [figure 2.2](#ch02fig02), you’re adding cave 3 to your structure— it will get
    linked to one of either cave 0, 1, or 2.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![](four.jpg) 是您正在建造洞穴的地方。您选择一个未访问的洞穴，在旧洞穴中放入通往新洞穴的隧道，然后从新洞穴返回到旧洞穴。这样您就可以确信玩家可以找到返回的路。在
    [图 2.2](#ch02fig02) 中，您正在将洞穴 3 添加到您的结构中——它将连接到洞穴 0、1 或 2 中的任何一个。'
- en: Figure 2.2\. Adding cave 3 to your network
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.2\. 将洞穴 3 添加到您的网络中
- en: '![](02fig02.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig02.jpg)'
- en: '![](f0050-01.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](f0050-01.jpg)'
- en: Once you’re done with the cave, you can move it from the unvisited list to the
    visited list ![](five.jpg). Steps ![](three.jpg), ![](four.jpg), and ![](five.jpg)
    get repeated until you run out of caves (*unvisited caves == []*). Your cave structure
    will start to look like [figure 2.3](#ch02fig03).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成了洞穴，您就可以将它从未访问列表移动到已访问列表！[](five.jpg)。步骤 ![](three.jpg)，![](four.jpg)，和
    ![](five.jpg) 会重复进行，直到您没有洞穴（*未访问洞穴 == []*）。您的洞穴结构将开始看起来像 [图 2.3](#ch02fig03)。
- en: Figure 2.3\. That’s much better!
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.3\. 这要好多了！
- en: '![](02fig03.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig03.jpg)'
- en: The progress report lines ![](six.jpg) are optional, but if you include them
    you’ll be able to see your caves in the process of being built, because every
    time Python goes through the loop it will print out the current cave structure.
    It also looks a bit nicer than print caves.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 进度报告行 ![](six.jpg) 是可选的，但如果您包含它们，您将能够在构建过程中看到您的洞穴，因为每次 Python 通过循环时，它都会打印出当前的洞穴结构。它看起来也比打印洞穴更美观。
- en: Now that all the caves are linked, the rest of the job requires adding some
    more one-way tunnels ![](seven.jpg). It’s exactly the same as the previous example,
    except that you’ll already have at least one tunnel in each cave. So that you
    don’t add more than three tunnels, you change your *for* loop into a *while* loop.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的洞穴都已经连接起来，剩下的工作需要添加一些单向隧道 ![seven.jpg](https://example.org/seven.jpg)。这与之前的示例完全相同，只是你每个洞穴中已经有了至少一个隧道。为了不添加超过三个隧道，你将你的
    *for* 循环改为 *while* 循环。
- en: With your cave problem solved, let’s see how functions can improve the readability
    of your code.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你的洞穴问题解决了，让我们看看函数如何提高你代码的可读性。
- en: Clean up your code with functions!
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用函数清理你的代码！
- en: If you’ve been following along with the examples (you should!), you’ll notice
    that your program is growing longer and longer. It’s a relatively short example,
    but, even so, it’s becoming hard to understand what’s happening in the program.
    If you wanted to give a copy of your program to a friend for them to use, they
    might have a hard time figuring out what all the pieces do.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一直跟着示例（你应该这么做！）你会发现你的程序变得越来越长。这是一个相对简短的示例，即便如此，理解程序中发生的事情变得越来越困难。如果你想要把你的程序复制给朋友使用，他们可能很难弄清楚所有部分的功能。
- en: '|  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Remember how we were talking about hiding complexity in [chapter 1](kindle_split_009.html#ch01)?
    Functions are one of the critical ways that Python can hide the complex parts
    of your program.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在第1章 [chapter 1](kindle_split_009.html#ch01) 中讨论过如何隐藏复杂性吗？函数是Python隐藏程序复杂部分的关键方法之一。
- en: '|  |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: It’s time for a spring-cleaning, and you’re going to do that by designing your
    program to use some functions. You’ve been using a few functions so far; they’re
    the *choice(), len(), raw_input()* parts of your code—so you have a rough idea
    of how they work. What you don’t know (yet) is what they really are or how to
    create your own.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进行春季大扫除了，你将通过设计使用一些函数的程序来完成这项工作。到目前为止，你已经使用了一些函数；它们是你的代码中的 *choice(), len(),
    raw_input()* 部分——所以你对它们的工作方式有一个大致的了解。你（目前）不知道它们真正是什么或者如何创建自己的。
- en: Function basics
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数基础
- en: Functions are a way of making a section of your program self contained, often
    referred to as *encapsulation*. It’s an important way of breaking down a program
    into easily understood parts. A good rule of thumb is that each function “should
    do one thing and do it well.” There should be as little overlap between your functions
    as possible. This is similar to the way the parts of a car engine work; if a fan
    belt breaks, you should replace the fan belt—it wouldn’t make much sense to have
    to change your tires or spark plugs as well.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一种使程序的一部分自我包含的方法，通常被称为 *封装*。这是将程序分解成易于理解部分的重要方法。一个好的经验法则是每个函数“应该只做一件事，并且做好它。”你的函数之间应该尽可能少有重叠。这类似于汽车发动机的各个部分是如何工作的；如果风扇皮带断了，你应该更换风扇皮带——同时更换轮胎或火花塞就没有太多意义了。
- en: '![](f0052-01.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![f0052-01.jpg](https://example.org/f0052-01.jpg)'
- en: 'There are several advantages to using functions in your program:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的程序中使用函数有几个优点：
- en: You only have to write that part of the program once, and then you can use it
    wherever you like. Later, if you don’t like the way your program works or you
    find a bug, you only have to change your code in one place.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只需要编写程序的一部分，然后你可以在任何需要的地方使用它。以后，如果你不喜欢程序的工作方式或者发现了一个错误，你只需要在一个地方更改你的代码。
- en: In much the same way you can choose nice variable names that tell you what’s
    going on in your program, you can also choose nice function names that describe
    what the function does.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与你可以选择好的变量名来告诉你程序中正在发生什么一样，你也可以选择好的函数名来描述函数的功能。
- en: One of the reasons your code is hard to understand now is that it’s all in one
    big piece and it’s difficult to tell where parts begin and end. If it were broken
    into smaller parts, with a part for setting up the caves, a part for making a
    tunnel, a part for moving the player, and so on, you would only need to read (and
    understand) one small piece of the program instead of a large chunk.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你现在的代码难以理解的一个原因是它全部是一个大块，很难判断各部分开始和结束的地方。如果它被分解成更小的部分，比如设置洞穴的部分、挖隧道的部分、移动玩家的部分等等，你只需要阅读（和理解）程序的一小部分，而不是一大块。
- en: Functions are one of the main units of encapsulation in Python. Even advanced
    structures such as classes, which we cover in [chapter 6](kindle_split_014.html#ch06),
    are composed of functions. Python also has what are called *first-class functions*,
    which means that you can assign functions to variables and pass them to other
    functions. You’ll learn more about how to use functions like this in [chapter
    7](kindle_split_015.html#ch07).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是 Python 中封装的主要单元之一。即使是我们在第 6 章中介绍的高级结构，如类，也是由函数组成的。Python 还有一种称为 *first-class
    functions* 的功能，这意味着你可以将函数分配给变量并将它们传递给其他函数。你将在第 7 章中了解更多关于如何使用这种函数的信息。
- en: 'Functions have input and output, which you’ve seen already—when you use a function,
    you send it some data and then get back some more data as an answer. Some functions
    will do things themselves, but other functions will return a value after performing
    some calculations. Here’s a simple function that will add two numbers together:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有输入和输出，你已经看到了——当你使用函数时，你发送一些数据给它，然后得到一些更多的数据作为答案。一些函数会自己执行某些操作，但其他函数在执行一些计算后会返回一个值。以下是一个简单的函数，它将两个数字相加：
- en: '[PRE30]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let’s look at the initial line of the function declaration. It starts with the
    reserved word *def*, followed by a name for your function, and then the parameters
    that the function will expect within brackets. When you call the function later
    in your program, you specify what these parameters are—they can be explicit values
    or variables.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看函数声明的第一行。它以保留字 *def* 开头，后面跟着你的函数名，然后是函数期望在括号内接收的参数。当你稍后在程序中调用函数时，你指定这些参数是什么——它们可以是明确的值或变量。
- en: The second line is called a *docstring*, and it’s another useful way of making
    your programs easier to read when combined with good variable and function names.
    It should be a short description of the function and what it does—anything that
    someone might need to know in order to use the function properly. You’ve also
    used a special version of a Python string with three quotes, so that you can extend
    the docstring over more than one line if you need to.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行被称为 *docstring*，这是在结合良好的变量和函数名时使你的程序更容易阅读的另一种有用方式。它应该是函数的简短描述以及它做什么——任何可能需要知道以正确使用函数的内容。你还使用了
    Python 字符串的特殊版本，即三引号，这样你就可以在需要时将 docstring 扩展到多行。
- en: The third line is where the function does its work. In this case it’s easy—add
    *a* and *b* together. The *return* statement tells Python that the function has
    finished and to send the result of *a + b* back to whoever called it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行是函数执行其工作的地方。在这种情况下很容易——将 *a* 和 *b* 相加。*return* 语句告诉 Python 函数已经完成，并将 *a +
    b* 的结果发送给调用者。
- en: Variable scope
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量作用域
- en: 'Python places some limits on functions so they can only affect a small part
    of your program, normally the function itself. Most variables that are set inside
    your functions are known as *local variables*, and you won’t be able to use them
    outside of the function:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Python 对函数施加了一些限制，以便它们只能影响程序的一小部分，通常是函数本身。在函数内部设置的变量大多数被称为 *局部变量*，你将无法在函数外部使用它们：
- en: '[PRE31]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![](f0053-01.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](f0053-01.jpg)'
- en: 'When you try and run this program, you’ll get an error like this one:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试运行这个程序时，你会得到类似于这样的错误：
- en: '[PRE32]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: What happened? You set the *a* variable inside the *create_a()* function, didn’t
    you? Actually, it was only created inside the function. You can think of it as
    “belonging” to *create_a*. As soon as Python has finished with a variable, it
    gets thrown away—in this case, as soon as the function exits.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？你不是在 *create_a()* 函数内设置了 *a* 变量吗？实际上，它只是在函数内部被创建。你可以把它想象成“属于”*create_a*。一旦
    Python 完成对变量的处理，它就会被丢弃——在这种情况下，一旦函数退出。
- en: 'Additionally, you won’t be able to change most variables that have been defined
    outside the function. Instead, when you create a variable, you’ll be creating
    a new one. The following code won’t work:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还将无法更改大多数在函数外部定义的变量。相反，当你创建一个变量时，你将创建一个新的变量。以下代码将无法工作：
- en: '[PRE33]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Unless you tell it otherwise, Python assumes that the *a* variable is supposed
    to be within the *add_one_to_a* function. Trying to access a variable inside of
    a function produces an error like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你明确告知，否则 Python 假设 *a* 变量应该在 *add_one_to_a* 函数内。尝试访问函数内部的变量会产生类似于这样的错误：
- en: '[PRE34]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The rule of thumb to remember is that the variables used in functions and the
    variables used in the rest of your program are different. Within a function, you
    should only use the variables that are passed into it as parameters, and, once
    back in the main part of your program, you should only use the variables that
    are returned from the function.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住的经验法则是，在函数中使用的变量和在其他程序部分使用的变量是不同的。在函数内部，你应该只使用传递给它的参数变量，一旦回到程序的主要部分，你应该只使用从函数返回的变量。
- en: But, like most rules of thumb, there are exceptions. In your program, you’re
    making one exception when you’re modifying the list of caves. In Python, the lists
    of caves and cave networks are a special type of variable called an *object*,
    and behind the scenes you’re sending messages to these objects instead of modifying
    them directly. You’ll learn more about how that works in [chapter 6](kindle_split_014.html#ch06).
    But, for now, think of lists as being a special exception to the rule that you
    can’t modify external variables.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，像大多数经验法则一样，也有例外。在你的程序中，当你修改洞穴列表时，你正在制造一个例外。在Python中，洞穴列表和洞穴网络是一种特殊的变量类型，称为*对象*，而在幕后，你正在向这些对象发送消息而不是直接修改它们。你将在[第6章](kindle_split_014.html#ch06)中了解更多关于它是如何工作的信息。但，现在，将列表视为不能修改外部变量的规则的一个特殊例外。
- en: Shared state
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 共享状态
- en: When functions (or objects) work on a single copy of something, it’s referred
    to as *shared state*. You can use shared state by making functions work on a list
    of caves, but, generally, shared state is a bad thing to have in your programs.
    If you have a bug in one of your functions, Python may *corrupt* your data (perhaps
    truncate it, or replace it with something odd). You won’t notice this until a
    completely separate part of your program tries to read the garbled data and displays
    odd results. When that happens, your program will become much harder to fix, depending
    on the number of functions that access your shared state.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数（或对象）在某个单一副本上工作时，这被称为*共享状态*。你可以通过让函数在洞穴列表上工作来使用共享状态，但通常，在你的程序中拥有共享状态是一个不好的事情。如果你在某个函数中有一个错误，Python可能会*损坏*你的数据（可能截断它，或者用奇怪的东西替换它）。你不会注意到这一点，直到程序的一个完全不同的部分尝试读取这些混乱的数据并显示奇怪的结果。当这种情况发生时，你的程序将变得非常难以修复，这取决于访问共享状态的函数数量。
- en: '|  |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Shared data is a double-edged sword. You need to have some, but it’s also a
    source of bugs—particularly if a lot of functions share the data.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 共享数据是一把双刃剑。你需要有一些，但它也是错误的一个来源——尤其是如果很多函数共享数据的话。
- en: '|  |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In [chapter 6](kindle_split_014.html#ch06), you’ll learn how to limit the number
    of functions that have access to shared state by using another Python structure
    called a *class*. For now, though, you’ll have to be careful; you’ll only modify
    your caves when you set them up, and you’ll leave them alone once you’re playing
    the game.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](kindle_split_014.html#ch06)中，你将学习如何通过使用另一种称为*类*的Python结构来限制可以访问共享状态的函数数量。然而，现在，你必须小心；你只会在设置时修改你的洞穴，一旦你在玩游戏，你就不会去动它们。
- en: '|  |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Data and operations on data**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据和数据处理**'
- en: Most programs can be thought of as a collection of information or data that
    also features rules about ways to interact with that data. The Hunt the Wumpus
    program is no exception. You have a cave structure and locations for the wumpus
    and the player, functions that make changes to that data, and then a main program
    that ties it all together using the functions.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序可以被视为一个信息或数据的集合，同时也包含有关如何与该数据交互的规则。Hunt the Wumpus程序也不例外。你有一个洞穴结构、Wumpus和玩家的位置、修改这些数据的函数，以及一个主程序，它使用这些函数将它们全部结合起来。
- en: Designing your programs this way makes them much easier to write and debug and
    gives you more opportunities to reuse your code than if you had thrown everything
    into one big program or function.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式设计你的程序会使它们更容易编写和调试，并且比将所有东西都扔进一个大程序或函数中，给你更多的代码重用机会。
- en: If you have a *data structure* that fits everything your program needs and makes
    it easy to retrieve the data you need, that’s usually half the battle when it
    comes to writing your program.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个适合你程序所需一切并能轻松检索所需数据的*数据结构*，那么在编写程序时，这通常是战斗的一半。
- en: '|  |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Now that you know what functions are and why you’d want to use them, let’s go
    ahead and see how to break up your wumpus game into individual functions.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了函数是什么以及为什么你想使用它们，让我们继续看看如何将你的Wumpus游戏分解成单独的函数。
- en: Fixing the wumpus
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复Wumpus
- en: 'In principle, encapsulating a program into functions isn’t too hard: look for
    parts of your program that fit some of the following criteria, and try to pull
    them out into functions where they'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在原则上，将程序封装到函数中并不太难：寻找符合以下某些标准的程序部分，并尝试将它们拉出来形成函数，其中它们
- en: Do one particular thing (*self contained*)
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一项特定的事情（*自包含*）
- en: Are repeated several times
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被重复多次
- en: Are hard to understand
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难以理解
- en: When considering the Hunt the Wumpus game, you should be able to see that it
    has three main sections. You’ll start with the simplest functions first and then
    use them to build the rest of your program.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑“抓捕怪物”游戏时，你应该能够看到它有三个主要部分。你将首先从最简单的函数开始，然后使用它们来构建程序的其余部分。
- en: Interacting with the caves
  id: totrans-296
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与洞穴互动
- en: 'When dealing with cave-related tasks, there are several simple actions that
    you perform quite often:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理与洞穴相关的任务时，你经常执行几个简单的操作：
- en: Create a tunnel from one cave to another.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个洞穴到另一个洞穴创建隧道。
- en: Mark a cave as visited.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记洞穴为已访问。
- en: Pick a cave at random, preferably one that is ok to dig a tunnel to.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机选择一个洞穴，最好是适合挖隧道的洞穴。
- en: To make your life easier when working with the list of caves, you can create
    what are known as *convenience functions*. These are functions that perform a
    (potentially complicated) series of actions but hide that complexity when you’re
    using the function in your program. The benefit is that you can perform the actions
    in one step in your main program, and you don’t have to worry about the details
    once you’ve created the function. That makes your program easier to understand
    and helps to reduce bugs in your programs. The next listing introduces some convenience
    functions that you can use to make Hunt the Wumpus clearer and more comprehensible.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你在处理洞穴列表时生活更轻松，你可以创建所谓的*便利函数*。这些函数执行一系列（可能复杂的）操作，但在你使用程序中的函数时隐藏了这种复杂性。好处是，你可以在主程序中一步完成这些操作，一旦创建了函数，你就不必担心细节。这使得你的程序更容易理解，并有助于减少程序中的错误。下一列表介绍了一些便利函数，你可以使用它们使“抓捕怪物”游戏更清晰易懂。
- en: Listing 2.7\. Adding convenience functions
  id: totrans-302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.7\. 添加便利函数
- en: '![](02list07.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![02list07.jpg](02list07.jpg)'
- en: Creating tunnels and visiting caves are both obvious candidates for functions
    ![](one.jpg). It’s easy to make an error by using the wrong variable to refer
    to a cave, and using code like *create_tunnel(cave1, cave2)* makes your program
    much easier to read.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 创建隧道和访问洞穴都是明显的函数候选者 ![one.jpg](one.jpg)。使用错误的变量来引用洞穴很容易出错，而使用像 *create_tunnel(cave1,
    cave2)* 这样的代码可以使你的程序更容易阅读。
- en: In the *choose_cave* function ![](two.jpg), you can hide even more detail. When
    you choose a cave, you’re normally only interested in caves that have fewer than
    three tunnels. Adding that check into the function will remove a lot of duplicated
    code from your main program. Note also that *choose_cave* accepts a list of caves
    as input so you can use it to pick a cave from either the visited or unvisited
    cave list.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *choose_cave* 函数 ![two.jpg](two.jpg) 中，你可以隐藏更多细节。当你选择一个洞穴时，你通常只对少于三个通道的洞穴感兴趣。将这个检查添加到函数中将从你的主程序中删除大量重复代码。注意，*choose_cave*
    接受洞穴列表作为输入，因此你可以用它从已访问或未访问的洞穴列表中选择一个洞穴。
- en: It’s not only the “final” versions of your code that can have convenience functions.
    You can also create convenience functions to help you while programming. If you
    want to debug your code at a later point, a function to print all of your caves
    ![](three.jpg) comes in handy..
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅“最终”版本的代码可以包含便利函数。你还可以创建便利函数来帮助你编程。如果你想稍后调试你的代码，一个打印所有洞穴的函数 ![three.jpg](three.jpg)
    会很有用。
- en: Next let’s turn our attention to how to create your caves.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们关注如何创建你的洞穴。
- en: Creating the caves
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建洞穴
- en: We’ve already talked about the data that a program uses. One good rule of thumb
    is to create functions that do particular things to your data or that tell you
    about your data, and then use only those functions to “talk” to your data. In
    programming terminology, this is normally referred to as an *interface.* With
    an interface to guide you, it’s much harder to make a mistake or get confused
    about what the data means. To some extent, you’ve already started that process.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了程序使用的数据。一个很好的经验法则是创建执行特定操作于数据或告知你关于数据的函数，然后只使用这些函数来“交流”数据。在编程术语中，这通常被称为*接口*。有了接口的引导，你犯错误或对数据的含义感到困惑的可能性会小得多。在某种程度上，你已经开始了这个过程。
- en: 'In Hunt the Wumpus, there are three tasks that you need to perform when creating
    caves that are ideal candidates for functions:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在“寻宝怪”游戏中，创建洞穴时，你需要执行三个任务，这些任务非常适合作为函数：
- en: Set up the cave list.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置洞穴列表。
- en: Make sure all of the caves are linked.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所有洞穴都相互连接。
- en: Make sure there are three tunnels per cave.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保每个洞穴有三个隧道。
- en: 'In [listing 2.8](#ch02list8), three functions do exactly that. These functions
    are the essential core of your program, so it will pay off to try to get them
    right. There are no hard and fast rules, but some signs that your program is well
    written include the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 2.8](#ch02list8) 中，三个函数正是这样做的。这些函数是程序的核心，因此尝试正确实现它们将是有益的。虽然没有硬性规则，但以下是一些表明你的程序编写良好的迹象：
- en: It’s easy to read and understand.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它易于阅读和理解。
- en: It’s easy to find and fix bugs.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它易于查找和修复错误。
- en: You only have to change limited parts of your program when you add new features.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你添加新功能时，你只需要更改程序中有限的部分。
- en: You can reuse some of your functions when modifying the program.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在修改程序时，你可以重用一些函数。
- en: Ultimately, though, what “right” means will vary from program to program depending
    on the design and what that design is trying to achieve.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终“正确”的含义将因程序而异，这取决于设计和该设计试图实现的目标。
- en: Listing 2.8\. Cave-creation functions
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.8\. 洞穴创建函数
- en: '![](02list08.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![02list08.jpg](https://example.org/02list08.jpg)'
- en: Creating the list of caves ![](one.jpg) hasn’t changed much from the previous
    listing, but it’s still a good idea to put well-defined sections of code in their
    own functions for readability.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 创建洞穴列表 ![one.jpg](https://example.org/one.jpg) 与之前的列表没有太大变化，但仍然是一个好主意，将定义良好的代码部分放入它们自己的函数中以提高可读性。
- en: All the hard work of connecting the caves and tunneling is done in *link_caves*
    ![](two.jpg). Did you notice how the convenience functions that you defined in
    the previous listing help to tidy things up even further? Even if you didn’t know
    what this function was doing, it’d be pretty easy to guess.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的艰苦工作，包括连接洞穴和挖掘隧道，都在 *link_caves* ![two.jpg](https://example.org/two.jpg)
    中完成。你注意到你之前定义的便利函数如何进一步整理事情了吗？即使你不知道这个函数在做什么，猜测起来也会很容易。
- en: With *finish_caves*, you haven’t created a convenience function ![](three.jpg).
    It’s the only section of code where you create a one-way tunnel, so the benefit
    is a bit more limited than in the other cases. Whether you create a function in
    cases like this might depend on whether you were planning on adding more functionality
    later. Decisions like this can be something of a stylistic issue, so pick the
    option that feels best for you. You can always change it later if you need to
    repeat some code.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *finish_caves*，你还没有创建一个便利函数 ![three.jpg](https://example.org/three.jpg)。这是唯一一段创建单向隧道的代码，所以它的好处比其他情况要有限一些。在这种情况下是否创建函数可能取决于你是否计划稍后添加更多功能。这样的决定可能是一种风格问题，所以选择对你来说感觉最好的选项。如果你需要重复某些代码，你总是可以稍后更改它。
- en: Finally, let’s bring functions to how Hunt the Wumpus interacts with the player.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如何将功能引入与玩家互动的“寻宝怪”游戏中。
- en: Interacting with the player
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与玩家互动
- en: 'When running the program, there are two tasks that you perform regularly to
    find out what the player wants to do next:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行程序时，你通常会执行两个任务来找出玩家接下来想要做什么：
- en: Tell the player about where they are.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向玩家说明他们所在的位置。
- en: Get some input from the player.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从玩家那里获取一些输入。
- en: Because the appearance of a program is likely to change substantially, either
    due to the feedback of the people using it or from adding new features, it often
    makes sense to keep the interface separated from the rest of the program and interact
    with the player through well-defined mechanisms. The next listing defines two
    functions you’ll use for these two tasks in your user interface.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序的外观可能会因使用者的反馈或添加新功能而大幅改变，因此通常有道理将界面与程序的其他部分分开，并通过定义良好的机制与玩家互动。下面的列表定义了两个函数，你将在用户界面中用于这两个任务。
- en: Listing 2.9\. Player-interaction functions
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.9\. 玩家互动函数
- en: '![](02list09.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![02list09.jpg](https://example.org/02list09.jpg)'
- en: Here’s the mechanism that I was talking about. It doesn’t matter what the player
    enters; this function will always return either a special value of *None* (Python’s
    version of null) if the input wasn’t right, or the number of the cave that the
    player wants to enter. You can check this easily in the main part of your program.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这里就是我所提到的机制。无论玩家输入什么，这个函数都会返回一个特殊值 *None*（Python 的 null 版本），如果输入不正确，或者返回玩家想要进入的洞穴编号。你可以在程序的主要部分轻松检查这一点。
- en: The rest of the program
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 程序的其余部分
- en: Once you have all of these functions, it doesn’t leave much of your program
    that isn’t a function. But this is a good thing, as you’ll see shortly.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了所有这些函数，你的程序中剩下的不是函数的部分就不多了。但这是好事，你很快就会看到。
- en: '[Listing 2.10](#ch02list10) shows the final installment of the updated Hunt
    the Wumpus game. It behaves exactly the same way as the program in [listing 2.6](#ch02list6)
    as far as the player is concerned, but the structure has completely changed. All
    of your tasks are now stored within functions, and the main program uses those
    functions to do everything in the game—display the current cave, get input, move
    the player, and so on.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.10](#ch02list10) 展示了更新后的“捕猎怪物”游戏的最终版本。从玩家的角度来看，它表现得与 [列表 2.6](#ch02list6)
    中的程序完全一样，但结构已经完全改变。你现在所有的任务都存储在函数中，主程序使用这些函数来完成游戏中的所有操作——显示当前洞穴、获取输入、移动玩家等等。'
- en: Listing 2.10\. The refactored wumpus game
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.10\. 重构后的“捕猎怪物”游戏
- en: '[PRE35]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice how short and easy to follow the main part of the program is now. It’s
    only 20 lines, and, because you’ve chosen useful function names, you could probably
    figure out what it does even if you didn’t know anything about Python. That’s
    the ideal that you should be aiming for. Clear, easy-to-understand code will save
    you a lot of time when reading and modifying it later on.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在程序的主要部分是多么简短且易于理解。它只有20行，而且因为你选择了有用的函数名，即使你不了解Python，你也能大概猜出它做什么。这就是你应该追求的理想。清晰、易于理解的代码在阅读和修改它时能节省你大量时间。
- en: '|  |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Simplify**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**简化**'
- en: 'You’ve seen how you refined and simplified the program as you went along, including
    going back and changing parts completely when necessary. If you can simplify your
    code, there’s normally no reason not to. The simpler a program is, the easier
    it is to write, understand, debug, and modify. The refining process is typically
    along the lines that you’ve seen so far in this chapter:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了随着程序的进行，你如何精炼和简化了程序，包括在必要时返回并完全更改部分内容。如果你可以简化你的代码，通常没有不这样做的原因。程序越简单，编写、理解、调试和修改就越容易。精炼过程通常是本章迄今为止你看到的那种方式：
- en: Use meaningful names for both variables and functions.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为变量和函数使用有意义的名称。
- en: Use white space to separate different sections of program.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空白来分隔程序的不同部分。
- en: Store values in intermediate variables.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值存储在中间变量中。
- en: Break up functions so that they do one thing well.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数拆分，使它们擅长做一件事。
- en: Limit the amount of shared state that functions use, and be clear about what
    that shared state is.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制函数使用的共享状态的数量，并清楚地说明共享状态是什么。
- en: '*Perfection is achieved not when there is nothing left to add, but when there
    is nothing left to take away.*'
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*完美不是当你没有东西可以添加时，而是当你没有东西可以移除时。*'
- en: ''
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Antoine de Saint-Exupéry*'
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*安托万·德·圣埃克苏佩里*'
- en: '|  |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Caves ... check. Wumpus ... check. Running around in the caves ... check. A
    way to win the game... Hmm. There’s no way to win the game. Better do something
    about that.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 洞穴 ... 检查完毕。怪物 ... 检查完毕。在洞穴中四处奔跑 ... 检查完毕。赢得游戏的办法 ... 嗯。看来没有赢得游戏的方法。最好做些什么来改变这种情况。
- en: Bows and arrows
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弓和箭
- en: In the traditional wumpus game, you had a bow and one arrow, and when you thought
    that you knew which cave the wumpus was in, you could choose to fire an arrow
    into that cave. If you guessed wrong, too bad!
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的“捕猎怪物”游戏中，你有一把弓和一支箭，当你认为你知道怪物在哪一个洞穴时，你可以选择将箭射入那个洞穴。如果你猜错了，那就太糟糕了！
- en: '![](f0062-01.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![](f0062-01.jpg)'
- en: '|  |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: One of the golden rules of game design is that the player has to be able to
    enjoy your game. Without a bow and arrow, you can still explore and have fun,
    but firing the bow and arrow is how you find out whether your exploration and
    understanding of the cave system is correct.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏设计的黄金法则之一是玩家必须能够享受你的游戏。没有弓和箭，你仍然可以探索并享受乐趣，但射箭是了解你的洞穴系统探索和理解是否正确的方法。
- en: '|  |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'It should be easy to see how to add this sort of feature by now, because it’s
    similar in style to the *get_next_location()* function. You’ll add a total of
    three more functions:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该很容易看出如何添加这种功能，因为它在风格上与 *get_next_location()* 函数相似。你将添加总共三个更多的函数：
- en: Ask whether the player wants to move or shoot.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 询问玩家是想移动还是射击。
- en: Find out where to move.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找移动的位置。
- en: Find out where to fire an arrow.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找射箭的位置。
- en: You’ll also modify the *get_next_location()* function into a general function
    *ask_for_cave*(). That’s what it is already, and you can call it from both your
    movement and firing functions. By writing it this way, your two input functions
    will be short, which helps keep your program manageable. If you add another feature
    later that needs to ask for a cave, then you’ll already have a useful function
    to call on, which makes programming easier and faster.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将修改`get_next_location()`函数成为一个通用函数`ask_for_cave()`。它已经是这样的了，你可以在你的移动和射击函数中调用它。通过这种方式编写，你的两个输入函数将会更短，这有助于保持你的程序可管理。如果你以后添加了需要询问洞穴的新功能，那么你将已经有一个有用的函数可以调用，这使得编程更加容易和快速。
- en: Listing 2.11\. Adding arrows
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.11\. 添加箭头
- en: '![](ch02list11-0.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch02list11-0.jpg)'
- en: '![](ch02list11-1.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch02list11-1.jpg)'
- en: You don’t need to make too many changes to your earlier *get_next_location*
    function; you just need a name change to make its intention clear and some cosmetic
    changes to how the program asks for input ![](one.jpg). The fact that you don’t
    need to make extensive changes is normally a good sign that a function is designed
    properly. If you had to significantly modify your function, it could be a sign
    that the original was trying to do too much at once.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要对你的早期`get_next_location`函数做太多修改；你只需要更改名称以使其意图更清晰，并对程序如何请求输入进行一些外观上的修改（![图片](one.jpg)）。你不需要进行大量修改的事实通常是一个好兆头，表明函数设计得当。如果你必须对函数进行重大修改，这可能是一个迹象，表明原始函数试图一次做太多事情。
- en: '![](f0065-01.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图片](f0065-01.jpg)'
- en: The function *get_action()* ![](two.jpg) is similar to the *ask_for_cave()*
    function, except that the valid input differs. Hmm ... perhaps there’s the possibility
    that you can create a clearer function, one that both of these can call. In [chapter
    6](kindle_split_014.html#ch06), you’ll learn about a good way to do that.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`get_action()`（![图片](two.jpg)）与`ask_for_cave()`函数类似，但有效的输入不同。嗯……也许有可能创建一个更清晰的函数，一个这两个函数都可以调用的函数。在第6章（[kindle_split_014.html#ch06]）中，你将了解到一种很好的实现方法。
- en: It’s not just input that can be made into its own function. Actions within the
    game can be functions too ![](three.jpg). Perhaps *actions* is too strong a word—notice
    how the action functions don’t *do* anything (that is, set any variables); they
    only return what should happen, and then the main program takes action based on
    what the functions tell it to do.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅输入可以变成自己的函数。游戏中的动作也可以是函数！（![图片](three.jpg)）。也许“动作”这个词用得太强了——注意动作函数并不*做*任何事情（也就是说，设置任何变量）；它们只返回应该发生的事情，然后主程序根据函数告诉它做什么来采取行动。
- en: The main part of your program is still as clear as it was previously ![](four.jpg),
    even though you’ve added a major new piece of functionality. If it’s much more
    complicated, that’s usually a sign that you might need to create a new function
    for some parts of your program and simplify the core of what you’re doing.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序的主要部分仍然像之前一样清晰（![图片](four.jpg)），尽管你添加了一个主要的新功能。如果它变得复杂得多，这通常是一个迹象，表明你可能需要为程序的一些部分创建一个新函数，并简化你正在做的核心内容。
- en: More atmosphere
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多氛围
- en: Congratulations! You now have a fully functional Hunt the Wumpus program, which
    you can play over and over again and use to impress your friends. Well, sort of.
    It works, but a number for each cave isn’t atmospheric or impressive. It makes
    your program easier to think about, but it needs that extra bit of polish. How
    about changing the program so that instead of numbers, it uses descriptive names
    for each cave?
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在拥有了一个完全功能化的“寻找Wumpus”程序，你可以反复玩它，并用它来给你的朋友留下深刻印象。嗯，差不多吧。它确实可以工作，但每个洞穴的数字并不具有氛围或令人印象深刻。这使得你的程序更容易思考，但它需要额外的润色。那么，改变程序，使其不再使用数字，而是为每个洞穴使用描述性的名称如何？
- en: '|  |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The core game mechanics are what make Hunt the Wumpus fun, but the final bits
    of polish like this are what distinguish good games from *great* games.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 核心游戏机制是使“寻找Wumpus”有趣的原因，但像这样的最后润色细节是区分好游戏和*伟大*游戏的关键。
- en: '|  |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: One way to do that is to reference a list of cave names stored in your program
    based on the cave number. Instead of displaying the raw cave number, display *cave_names[cave_number]*.
    When you ask the player for a cave, they should instead pick a number from 1 to
    3, with the name of the cave after the number. You’re aiming for something similar
    to what’s shown in the following listing.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点的一种方法是在你的程序中根据洞穴编号引用存储的洞穴名称列表。而不是显示原始的洞穴编号，显示`cave_names[cave_number]`。当你向玩家询问洞穴时，他们应该选择1到3之间的数字，洞穴名称跟在数字后面。你希望达到的效果类似于以下列表所示。
- en: Listing 2.12\. An interface for Hunt the Wumpus
  id: totrans-380
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.12：捕猎独角兽的接口
- en: '[PRE36]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![](f0066-01.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![f0066-01.jpg](#)'
- en: The list of cave names is relatively easy. You can borrow mine or create your
    own. Notice that, in the following listing of cave names, you can break a list
    over multiple lines at the commas between items. This is to make the program easier
    to read and modify.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 洞穴名称列表相对简单。你可以借用我的或者创建自己的。注意，在以下洞穴名称列表中，你可以在项目之间的逗号处将列表拆分成多行。这是为了让程序更容易阅读和修改。
- en: Listing 2.13\. A list of cave names
  id: totrans-384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.13：洞穴名称列表
- en: '[PRE37]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The only other changes that you need to make are to what you’re displaying,
    and what input you’ll accept, as shown in the following listing.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的唯一其他更改是显示的内容以及你将接受的输入，如下面的列表所示。
- en: Listing 2.14\. Hunt the Wumpus—now with 40% more atmosphere!
  id: totrans-387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.14：捕猎独角兽——现在增加了40%的氛围！
- en: '![](02list14_alt.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![02list14_alt.jpg](#)'
- en: Here’s where you print out the current caves and the list of caves the player
    can see ![](one.jpg). They’re all using the printable cave name from your list
    of cave names, rather than the number. Instead of printing the cave list, you’re
    using a *for* loop, with *tunnel* as an index into the list of tunnels. You’re
    also adding one to it to get 1, 2, or 3 rather than the 0, 1, or 2 indexes, to
    make it extra friendly.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你打印当前洞穴和玩家可以看到的洞穴列表的地方 ![one.jpg](#)。它们都使用你的洞穴名称列表中的可打印洞穴名称，而不是数字。你使用一个`for`循环来打印洞穴列表，用`tunnel`作为隧道列表的索引。你还给它加一，以得到1、2或3，而不是0、1或2的索引，使其更加友好。
- en: '![](f0068-01.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![f0068-01.jpg](#)'
- en: Now that you know there are only three valid choices, you can check directly
    for those ![](two.jpg) rather than needing the user to enter the number of the
    cave. You’re also subtracting one from the result, because you need 0, 1, or 2
    for your list index, rather than 1, 2, or 3.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了只有三个有效的选择，你可以直接检查这些 ![two.jpg](#) 而不是需要用户输入洞穴编号。你还从结果中减去一，因为你需要0、1或2作为列表索引，而不是1、2或3。
- en: Even though you’re using 1, 2, and 3 as choices, you still return the cave number
    as an index. All of your changes are contained within the *print_location* and
    *ask_for_cave* functions and use the interface that we talked about earlier, so
    nothing else in your program needs to be changed at all ![](three.jpg).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在使用1、2和3作为选项，你仍然将洞穴编号作为索引返回。你所有的更改都包含在`print_location`和`ask_for_cave`函数中，并使用我们之前讨论过的接口，所以你的程序中不需要做任何其他更改
    ![three.jpg](#)。
- en: Where to from here?
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: You don’t have to stop with the program as listed. There are a number of features
    you can add, including some that were in the original version of Hunt the Wumpus.
    Feel free to invent your own—this is your program now, and you can make it do
    whatever you like.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必停止使用列表中的程序。你可以添加许多功能，包括原始版本中的一些功能。你可以自由地发明自己的——现在这是你的程序，你可以让它做任何你喜欢的事情。
- en: Bats and pits
  id: totrans-395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 蝙蝠和陷阱
- en: 'In the original Hunt the Wumpus, there were other hazards: bats, which carried
    the player to another cave, and pits, which worked in a similar way to the wumpus
    (“I feel a draft!”).'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始的《捕猎独角兽》游戏中，还有其他危险：蝙蝠，它们会把玩家带到另一个洞穴，以及陷阱，它们的工作方式与独角兽类似（“我感觉到了一股冷风！”）。
- en: Making the wumpus move
  id: totrans-397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 让独角兽移动
- en: One wumpus variant made the wumpus move to a different, random cave if the player
    missed with their arrow—instead of causing the player to lose the game.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 一种独角兽变体让独角兽在玩家射箭未命中时移动到另一个随机洞穴——而不是让玩家输掉游戏。
- en: Different cave structures
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不同的洞穴结构
- en: The original Hunt the Wumpus had a static cave structure, in which the caves
    were vertices of a dodecahedron. You don’t necessarily have to follow this format,
    but experimenting with different cave structures could make for a more fun game.
    For example, perhaps you don’t like one-way tunnels; that should be easy to fix.
    Also, in the current version, caves can tunnel to themselves. I happen to like
    that sort of layout, but you may not. Being able to write your own programs means
    that you’re not stuck with my design choices; you’re free to make your own.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的《捕猎独角兽》有一个静态的洞穴结构，其中洞穴是多面体的顶点。你不必一定要遵循这种格式，但尝试不同的洞穴结构可能会让游戏更有趣。例如，也许你不喜欢单向隧道；这应该很容易修复。此外，在当前版本中，洞穴可以通向自己。我恰好喜欢这种布局，但你可能不喜欢。能够编写自己的程序意味着你不必局限于我的设计选择；你可以自由地做出自己的选择。
- en: Summary
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered a lot of material. Not only did you learn the basics of
    Python and how to fit them together to make a program, but we also covered possible
    ways to design your programs and took a look at why certain design choices might
    be better than others.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的内容。你不仅学习了Python的基础知识以及如何将这些知识组合起来编写程序，我们还探讨了设计程序的可能方式，并分析了为什么某些设计选择可能比其他选择更好。
- en: The best way to *start* writing a program is to choose something simple that
    either does part of what you need or describes the core of your program; then,
    build it from there. In Hunt the Wumpus, the first step was to create the initial
    game loop of choosing a cave and allowing the player to move to a different one.
    From there, you were able to develop a proper cave system; after making sure that
    the caves were connected properly, your program became a fully fledged game that
    can be played and won (or lost).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 开始编写程序的最佳方式是选择一个简单的东西，要么是完成你需要的一部分功能，要么是描述程序的核心；然后，从这里开始构建。在《猎捕怪物》游戏中，第一步是创建初始的游戏循环，选择一个洞穴并允许玩家移动到另一个洞穴。从那里，你能够开发一个合适的洞穴系统；在确保洞穴正确连接之后，你的程序变成了一个可以玩并且可以赢（或输）的完整游戏。
- en: The best way to *continue* to develop your program is to refine it as you go,
    by breaking commonly used parts into functions and trying to develop an interface
    between different sections of your program. Because it’s easy to lose track of
    the overall structure in low-level details, such as adding items to lists or making
    sure that caves have three tunnels, a large part of your interfaces will often
    entail hiding superfluous details or making sections of your program easier to
    work with.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 继续开发程序的最佳方式是在进行过程中不断优化它，通过将常用部分分解成函数，并尝试在程序的不同部分之间开发一个接口。因为很容易在低级细节中失去对整体结构的把握，例如向列表中添加项目或确保洞穴有三个隧道，因此你的接口通常会涉及隐藏不必要的细节或使程序的部分更容易操作。
