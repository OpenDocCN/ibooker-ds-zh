- en: 26 Tips, tricks, and techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 26 个技巧、窍门和技术
- en: We’re nearing the end of your month of lunches, so we’d like to share a few
    random extra tips and techniques to round out your education.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '你的午餐月即将结束，因此我们想分享一些随机的额外技巧和技术，以完善你的学习。 '
- en: '26.1 Profiles, prompts, and colors: Customizing the shell'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 26.1 配置文件、提示和颜色：定制外壳
- en: 'Every PowerShell session starts out the same: the same aliases, the same PSDrives,
    the same colors, and so forth. Why not customize the shell a little bit more?'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 PowerShell 会话都以相同的方式开始：相同的别名、相同的 PSDrives、相同的颜色等等。为什么不稍微定制一下外壳呢？
- en: 26.1.1 PowerShell profiles
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.1.1 PowerShell 配置文件
- en: We’ve explained before that there’s a difference between a PowerShell hosting
    application and the PowerShell engine itself. A hosting application, such as the
    console or the VS Code, is a way for you to send commands to the PowerShell engine.
    The engine executes your commands, and the hosting application is responsible
    for displaying the results. The hosting application is also responsible for loading
    and running *profile scripts* each time the shell starts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经解释过，PowerShell 宿主应用程序和 PowerShell 引擎本身之间是有区别的。宿主应用程序，如控制台或 VS Code，是你向
    PowerShell 引擎发送命令的一种方式。引擎执行你的命令，宿主应用程序负责显示结果。宿主应用程序还负责在每次启动外壳时加载和运行 *配置文件脚本*。
- en: 'These profile scripts can be used to customize the PowerShell environment by
    loading modules, changing to a different starting directory, defining functions
    that you’ll want to use, and so forth. For example, here is the profile script
    that Sarah uses on her computer:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置文件脚本可以用来通过加载模块、更改到不同的起始目录、定义你想要使用的函数等方式来定制 PowerShell 环境。例如，以下是莎拉在她的电脑上使用的配置文件脚本：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The profile loads the two modules that Sarah uses the most, and it changes to
    the root of her `C:` drive, which is where Sarah likes to begin working. You can
    put any commands you like into your profile.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置文件加载莎拉使用最多的两个模块，并将其更改到她的 `C:` 驱动器的根目录，这是莎拉喜欢开始工作的位置。你可以将任何你喜欢的命令放入你的配置文件中。
- en: Note You might think there’s no need to load the Active Directory module, because
    PowerShell will implicitly load it as soon as Sarah tries to use one of the commands
    in that module. But that particular module also maps an `AD:` PSDrive, and Sarah
    likes to have that available as soon as the shell starts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可能认为没有必要加载 Active Directory 模块，因为当莎拉尝试使用该模块中的任何命令时，PowerShell 会隐式加载它。但该特定模块还映射了一个
    `AD:` PSDrive，莎拉喜欢在外壳启动时就可用它。
- en: 'There’s no default profile, and the exact profile script that you create will
    depend on how you want it to work. Details are available if you run `help` `about_profiles`,
    but you mainly need to consider whether you’ll be working in multiple different
    hosting applications. For example, we tend to switch back and forth between the
    regular console, Windows Terminal, and VS Code. We like to have the same profile
    running for all three, so we have to be careful to create the right profile script
    file in the right location. We also have to be careful about what goes into that
    profile, as some commands that tweak console-specific settings such as colors
    can cause errors in VS Code or Windows Terminal. Here are the files that the console
    host tries to load, and the order in which it tries to load them:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 没有默认的配置文件，你创建的确切配置文件脚本将取决于你希望它如何工作。如果你运行 `help` `about_profiles`，可以找到详细信息，但你主要需要考虑你是否将在多个不同的宿主应用程序中工作。例如，我们经常在常规控制台、Windows
    Terminal 和 VS Code 之间切换。我们希望所有三个都运行相同的配置文件，因此我们必须小心地在正确的位置创建正确的配置文件脚本文件。我们还要注意配置文件中包含的内容，因为一些调整控制台特定设置（如颜色）的命令可能会在
    VS Code 或 Windows Terminal 中引起错误。以下是控制台宿主尝试加载的文件及其尝试加载的顺序：
- en: $pshome\profile.ps1—This will execute for all users of the computer, no matter
    which host they’re using (remember that `$pshome` is predefined within PowerShell
    and contains the path of the PowerShell installation folder).
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$pshome\profile.ps1`—无论用户使用哪个宿主，此脚本都将为计算机上的所有用户执行（记住 `$pshome` 在 PowerShell
    中是预定义的，包含 PowerShell 安装文件夹的路径）。'
- en: $pshome\Microsoft.PowerShell_profile.ps1—This will execute for all users of
    the computer if they’re using the console host.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$pshome\Microsoft.PowerShell_profile.ps1`—如果计算机上的用户正在使用控制台宿主，则此脚本将执行。'
- en: $pshome/Microsoft.VSCode_profile.ps1—If you are using the VS Code with the PowerShell
    extension, this script will be executed instead.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$pshome/Microsoft.VSCode_profile.ps1`—如果你使用带有 PowerShell 扩展的 VS Code，则此脚本将执行。'
- en: $home\Documents\WindowsPowerShell\profile.ps1—This will execute only for the
    current user (because it lives under the user’s home directory), no matter which
    host they’re using.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$home\Documents\WindowsPowerShell\profile.ps1`—这个配置文件只会为当前用户执行（因为它位于用户的家目录下），无论他们使用哪个主机。'
- en: $home\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1—This will
    execute for the current user if they’re using the console host. If they’re using
    VS Code with the PowerShell extension, the $home\Documents\WindowsPowerShell\Microsoft.VSCode_profile.ps1
    script will be executed instead.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$home\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1`—如果当前用户使用控制台宿主，这个配置文件将会执行。如果他们使用带有PowerShell扩展的VS
    Code，则将执行 $home\Documents\WindowsPowerShell\Microsoft.VSCode_profile.ps1 脚本。'
- en: If one or more of these scripts doesn’t exist, there’s no problem. The hosting
    application will simply skip it and move on to the next one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个或多个这些脚本不存在，没有问题。宿主应用将简单地跳过它并继续下一个。
- en: On 64-bit systems, there are variations for both 32- and 64-bit scripts, because
    there are separate 32- and 64-bit versions of PowerShell itself. You won’t always
    want the same commands run in the 64-bit shell as you do in the 32-bit shell—that
    is, some modules and other extensions are available for only one or the other
    architecture, so you wouldn’t want a 32-bit profile trying to load a 64-bit module
    into the 32-bit shell, because it won’t work.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在64位系统上，32位和64位的脚本都有变体，因为PowerShell本身就有32位和64位版本。你并不总是希望64位shell中运行的命令与32位shell中运行的命令相同——也就是说，某些模块和其他扩展只适用于一个或另一个架构，因此你不会希望32位配置文件尝试将64位模块加载到32位shell中，因为这是不会工作的。
- en: Try it Now Run `$Profile | Format-List -force` and list out all your profiles.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 运行 `$Profile | Format-List -force` 并列出所有配置文件。
- en: 'Note that the documentation in `about_profiles` is different from what we’ve
    listed here, and our experience is that the preceding list is correct. Here are
    a few more points about that list:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`about_profiles` 中的文档与这里列出的不同，并且我们的经验是前面的列表是正确的。以下是关于该列表的几个更多要点：
- en: '`$pshome` is a built-in PowerShell variable that contains the installation
    folder for PowerShell itself; on most systems, that’s in C:\Program Files\PowerShell\7.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$pshome` 是一个内置的PowerShell变量，包含PowerShell本身的安装文件夹；在大多数系统上，它位于C:\Program Files\PowerShell\7。'
- en: '`$home` is another built-in variable that points to the current user’s profile
    folder (such as C:\Users\Sarah).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$home` 是另一个内置变量，指向当前用户的配置文件文件夹（例如C:\Users\Sarah）。'
- en: We’ve used *Documents* to refer to the Documents folder, but on some versions
    of Windows it will be *My Documents*.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们用“*Documents*”来指代“文档”文件夹，但在Windows的一些版本中，它将是“*我的文档*”。
- en: We’ve written “no matter which host they’re using,” but that technically isn’t
    true. It’s true of hosting applications (e.g., VS Code) written by Microsoft,
    but there’s no way to force the authors of non-Microsoft hosting applications
    to follow these rules.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们写了“无论他们使用哪个宿主”，但从技术上讲，这并不完全正确。对于由微软编写的宿主应用（例如，VS Code）来说，这是正确的，但无法强迫非微软宿主应用的作者遵循这些规则。
- en: Because we want the same shell extensions to load whether we’re using the console
    host or the **VS Code**, we chose to customize $home\Documents\WindowsPowerShell\
    profile.ps1, because that profile is run for both of the Microsoft-supplied hosting
    applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们希望无论使用控制台宿主还是**VS Code**，都能加载相同的shell扩展，所以我们选择自定义 $home\Documents\WindowsPowerShell\
    profile.ps1，因为这个配置文件适用于微软提供的两个宿主应用。
- en: Try it Now Take your profile for a test drive by creating one or more profile
    scripts for yourself. Even if all you put in them is a simple message, such as
    `Write-Output` `"It Worked"`, this is a good way to see the different files in
    action. Remember that you have to close the shell (or VS Code) and reopen it to
    see the profile scripts run.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 通过为自己创建一个或多个配置文件脚本来测试你的配置文件。即使你只放入一个简单的消息，例如 `Write-Output` `"It Worked"`，这也是观察不同文件在行动中的好方法。记住，你必须关闭shell（或VS
    Code）并重新打开它才能看到配置文件脚本运行。
- en: Keep in mind that profile scripts are scripts and are subject to your shell’s
    current execution policy. If your execution policy is `Restricted`, your profile
    won’t run; if your policy is `AllSigned`, your profile must be signed. Chapter
    4 discussed the execution policy.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，配置文件脚本也是脚本，并受你的shell当前执行策略的影响。如果你的执行策略是 `Restricted`，则配置文件不会运行；如果你的策略是 `AllSigned`，则配置文件必须经过签名。第4章讨论了执行策略。
- en: Tip In VS Code, you can run the command `code $profile` and it will open the
    VS Code profile. Similarly, in the console, you can run `notepad $profile` and
    it will open your console-specific profile.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：在VS Code中，你可以运行命令`code $profile`，它将打开VS Code配置文件。同样，在控制台中，你可以运行`notepad
    $profile`，它将打开你的控制台特定配置文件。
- en: 26.1.2 Customizing the prompt
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.1.2 自定义提示
- en: 'The PowerShell prompt—the `PS C:\>` that you’ve seen through much of this book—is
    generated by a built-in function called `Prompt`. If you want to customize the
    prompt, you can replace that function. Defining a new `Prompt` function is something
    that can be done in your profile script so that your change takes effect each
    time you open the shell. Here’s the default prompt:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell提示——你在本书的大部分内容中看到的`PS C:\>`——是由一个名为`Prompt`的内置函数生成的。如果你想自定义提示，你可以替换这个函数。在配置文件脚本中定义一个新的`Prompt`函数是一种可以做到的事情，这样每次打开shell时你的更改就会生效。以下是默认提示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This prompt first tests to see whether the `$DebugContext` variable is defined
    in the shell’s `VARIABLE:` drive. If it is, this function adds `[DBG]:` to the
    start of the prompt. Otherwise, the prompt is defined as `PS` along with the current
    location, which is returned by the `Get-Location` cmdlet. If the shell is in a
    nested prompt, as defined by the built-in `$nestedpromptlevel` variable, the prompt
    will have `>>` added to it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提示首先检查shell的`VARIABLE:`驱动器中是否定义了`$DebugContext`变量。如果是，这个函数将在提示的开始处添加`[DBG]:`。如果不是，提示将定义为`PS`以及当前位置，这是由`Get-Location`命令返回的。如果shell处于嵌套提示中，如内置的`$nestedpromptlevel`变量定义的，提示将添加`>>`。
- en: 'Here’s an alternative prompt function. You could enter this directly into any
    profile script to make it the standard prompt for your shell sessions:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个替代的提示函数。你可以直接将其输入到任何配置文件脚本中，使其成为你的shell会话的标准提示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This alternative prompt displays the current time, followed by the current
    computer name (which is contained within square brackets):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个替代提示首先显示当前时间，然后是当前计算机名（位于方括号内）：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that this uses PowerShell’s special behavior with double quotation marks,
    in which the shell will replace variables (such as `$time`) with their contents.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这使用了PowerShell的双引号特殊行为，其中shell将变量（如`$time`）替换为其内容。
- en: 'One of the most useful pieces of code to add to your profile is to change the
    title bar of your PowerShell Windows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加到配置文件中最有用的代码之一是更改PowerShell窗口的标题栏：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 26.1.3 Tweaking colors
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.1.3 调整颜色
- en: In previous chapters, we mentioned how stressed out we can get when a long series
    of error messages scrolls by in the shell. Sarah always struggled in English class
    when she was a kid, and seeing all that red text reminds her of the essays she’d
    get back from Ms. Hansen, all marked up with a red pen. Yuck. Fortunately, PowerShell
    gives you the ability to modify most of the default colors it uses (figure 26.1).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们提到了当一系列长错误消息在shell中滚动时，我们可能会多么紧张。Sarah小时候在英语课上总是很吃力，看到所有红色的文字让她想起了从汉森小姐那里收到的论文，上面用红笔做了很多标记。真恶心。幸运的是，PowerShell让你能够修改它使用的默认颜色的大部分（如图26.1）。
- en: '![](Images/CH26_F01_Plunk.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH26_F01_Plunk.png)'
- en: Figure 26.1 Configuring the default shell screen colors
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图26.1 配置默认shell屏幕颜色
- en: The default text foreground and background colors can be modified by clicking
    the control box in the upper-left corner of PowerShell’s window. From there, select
    Properties, and then select the Colors tab.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的文本前景和背景颜色可以通过点击PowerShell窗口右上角的控制框进行修改。从那里，选择属性，然后选择颜色选项卡。
- en: 'Modifying the colors of errors, warnings, and other messages is a bit trickier
    and requires you to run a command. But you could put this command into your profile
    so that it executes each time you open the shell. Here’s how to change the error
    message foreground color to green, which we find a lot more soothing:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 修改错误、警告和其他消息的颜色稍微复杂一些，需要运行一个命令。但是，你可以将这个命令放入你的配置文件中，以便每次打开shell时执行。以下是将错误消息的前景色更改为绿色的方法，我们发现这要舒适得多：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can change colors for the following settings:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改以下设置的颜色：
- en: '`ErrorForegroundColor`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ErrorForegroundColor`'
- en: '`ErrorBackgroundColor`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ErrorBackgroundColor`'
- en: '`WarningForegroundColor`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WarningForegroundColor`'
- en: '`WarningBackgroundColor`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WarningBackgroundColor`'
- en: '`DebugForegroundColor`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DebugForegroundColor`'
- en: '`DebugBackgroundColor`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DebugBackgroundColor`'
- en: '`VerboseForegroundColor`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VerboseForegroundColor`'
- en: '`VerboseBackgroundColor`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VerboseBackgroundColor`'
- en: '`ProgressForegroundColor`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProgressForegroundColor`'
- en: '`ProgressBackgroundColor`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProgressBackgroundColor`'
- en: 'And here are some of the colors you can choose:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些你可以选择的颜色：
- en: '`Red`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Red`'
- en: '`Yellow`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Yellow`'
- en: '`Black`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`黑色`'
- en: '`White`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`白色`'
- en: '`Green`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`绿色`'
- en: '`Cyan`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`青色`'
- en: '`Magenta`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`洋红色`'
- en: '`Blue`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`蓝色`'
- en: 'There are also dark versions of most of these colors: `DarkRed`, `DarkYellow`,
    `DarkGreen`, `DarkCyan`, `DarkBlue`, and so on.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些颜色也有深色版本：`深红色`、`深黄色`、`深绿色`、`深青色`、`深蓝色`等等。
- en: '26.2 Operators: -as, -is, -replace, -join, -split, -contains, -in'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 26.2 操作符：-as, -is, -replace, -join, -split, -contains, -in
- en: These additional operators are useful in a variety of situations. They let you
    work with data types, collections, and strings.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些额外的操作符在多种情况下都很有用。它们让你能够处理数据类型、集合和字符串。
- en: 26.2.1 -as and -is
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.2.1 -as 和 -is
- en: 'The `-as` operator produces a new object in an attempt to convert an existing
    object into a different type. For example, if you have a number that contains
    a decimal (perhaps from the result of a division operation), you can drop the
    decimal portion by converting, or *casting*, the number to an integer:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`-as` 操作符试图将现有对象转换成另一种类型，从而生成一个新的对象。例如，如果你有一个包含小数的数字（可能是除法操作的结果），你可以通过转换，或者说是*强制类型转换*，这个数字到整数来去除小数部分：'
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The object to be converted comes first, then the `-as` operator, and then, in
    square brackets, the type you want to convert to. Types can include `[string]`,
    `[xml]`, `[int]`, `[single]`, `[double]`, `[datetime]`, and others, although those
    are probably the ones you’ll use the most. Technically, this example of converting
    to an integer will round the fractional number to an integer, rather than just
    truncating the fractional portion of the number.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要转换的对象首先出现，然后是 `-as` 操作符，接着是在方括号中，你想要转换到的类型。类型可以包括 `[string]`、`[xml]`、`[int]`、`[single]`、`[double]`、`[datetime]`
    等，尽管你可能最常使用的是这些类型。技术上，这个将转换为整数的例子会将分数四舍五入到整数，而不是仅仅截断数字的小数部分。
- en: 'The `-is` operator works similarly: it’s designed to return `True` or `False`
    if an object is of a particular type or not. Here are a few one-line examples:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`-is` 操作符的工作方式类似：它被设计用来返回 `True` 或 `False`，以指示一个对象是否为特定类型。以下是一些单行示例：'
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Try it Now Try running each of these one-line commands in the shell to see the
    results.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行这些单行命令以查看结果。
- en: 26.2.2 -replace
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.2.2 -replace
- en: 'The `-replace` operator uses regex and is designed to locate all occurrences
    of one string within another and replace those occurrences with a third string:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`-replace` 操作符使用正则表达式，并设计用来定位另一个字符串中所有出现的特定字符串，并用第三个字符串来替换这些出现：'
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The source string comes first, followed by the `-replace` operator. Then you
    provide the string you want to search for within the source, followed by a comma
    and the string you want to use in place of the search string. In the preceding
    example, we replace `34` with `15`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 源字符串首先出现，然后是 `-replace` 操作符。然后你提供要在源字符串中搜索的字符串，后面跟着一个逗号和用于替换搜索字符串的字符串。在上面的例子中，我们将
    `34` 替换为 `15`。
- en: This is not to be confused with the `string replace()` method, which is a static
    text replace. While they work similarly, they are very different.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `string replace()` 方法不同，后者是静态文本替换。虽然它们的工作方式相似，但它们非常不同。
- en: 26.2.3 -join and -split
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.2.3 -join 和 -split
- en: 'The `-join` and `-split` operators are designed to convert arrays to delimited
    lists, and vice versa. For example, suppose you create an array with five elements:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`-join` 和 `-split` 操作符被设计用来将数组转换为分隔列表，反之亦然。例如，假设你创建了一个包含五个元素的数组：'
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This works because PowerShell automatically treats a comma-separated list as
    an array. Now, let’s say you want to join this array together into a pipe-delimited
    string. You can do that with `-join`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为 PowerShell 会自动将逗号分隔的列表视为数组。现在，假设你想要将这个数组连接成一个以管道符分隔的字符串。你可以使用 `-join`
    操作符来完成这个操作：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Saving that result into a variable will let you reuse it, or even pipe it out
    to a file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将结果保存到变量中可以让你重用它，甚至可以将它输出到文件：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `-split` operator does the opposite: it takes a delimited string and makes
    an array from it. For example, suppose you have a tab-delimited file containing
    one line and four columns. Displaying the contents of the file might look like
    this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`-split` 操作符做的是相反的操作：它将分隔字符串转换为一个数组。例如，假设你有一个包含一行和四列的制表符分隔的文件。显示文件内容可能看起来像这样：'
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Keep in mind that `gc` is an alias for `Get-Content`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`gc` 是 `Get-Content` 的别名。
- en: 'You can use the `-split` operator to break that into four individual array
    elements:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `-split` 操作符将字符串拆分为四个单独的数组元素：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Notice the use of the escape character, a backtick, and a *t* (`` `t ``) to
    define the tab character. This has to be in double quotes so that the escape character
    will be recognized. The resulting array has four elements, and you can access
    them individually by using their index numbers:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到使用了转义字符，反引号，以及一个 *t* (`` `t ``) 来定义制表符字符。这必须放在双引号中，以便识别转义字符。结果数组有四个元素，你可以通过它们的索引号单独访问它们：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 26.2.4 -contains and -in
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.2.4 - 包含和 - 在
- en: 'The `-contains` operator causes much confusion for PowerShell newcomers. You’ll
    see folks try to do this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`-contains` 操作符常常让 PowerShell 新手感到困惑。你会看到人们尝试这样做：'
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In fact, they mean to use the `-like` operator instead:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，它们意味着要使用 `-like` 操作符：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `-like` operator is designed for wildcard string comparisons. The `-contains`
    operator is used to test whether a given object exists within a collection. For
    example, create a collection of string objects, and then test whether a given
    string is in that collection:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`-like` 操作符旨在进行通配符字符串比较。`-contains` 操作符用于测试给定对象是否存在于集合中。例如，创建一个字符串对象集合，然后测试给定字符串是否在该集合中：'
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `-in` operator does the same thing, but it flips the order of the operands
    so that the collection goes on the right and the test object on the left:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`-in` 操作符做同样的事情，但它颠倒了操作数的顺序，使得集合在右边，测试对象在左边：'
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 26.3 String manipulation
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 26.3 字符串操作
- en: Suppose you have a string of text, and you need to convert it to all uppercase
    letters. Or perhaps you need to get the last three characters from the string.
    How would you do it?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一段文本字符串，你需要将其转换为全部大写字母。或者你可能需要从字符串中获取最后三个字符。你将如何操作？
- en: 'In PowerShell, strings are objects, and they come with a great many methods.
    Remember that a method is a way of telling the object to do something, usually
    to itself, and that you can discover the available methods by piping the object
    to `gm`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，字符串是对象，并且它们附带了许多方法。记住，方法是一种告诉对象做什么的方式，通常是对它自己，而且你可以通过将对象管道到 `gm`
    来发现可用的方法：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Some of the more useful `String` methods include the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更有用的 `String` 方法包括以下内容：
- en: '`IndexOf``()`—Tells you the location of a given character within the string:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IndexOf()` — 告诉你给定字符在字符串中的位置：'
- en: '[PRE20]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`Split``()`, `Join``()`, *and* `Replace()`—Operate similarly to the `-split`,
    `-join`, and `-replace` operators we described in the previous section. We tend
    to use the PowerShell operators rather than the `String` methods.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Split()`、`Join()` 和 `Replace()` — 操作类似于我们在上一节中描述的 `-split`、`-join` 和 `-replace`
    操作符。我们倾向于使用 PowerShell 操作符而不是 `String` 方法。'
- en: '`ToLower``()` *and* `ToUpper``()`—Convert the case of a string:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToLower()` 和 `ToUpper()` — 转换字符串的大小写：'
- en: '[PRE21]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`Trim``()`—Removes whitespace from both ends of a string.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trim()` — 从字符串的两端删除空白。'
- en: '`TrimStart``()` and `TrimEnd``()`—Remove whitespace from the beginning or end
    of a string, respectively:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TrimStart()` 和 `TrimEnd()` — 分别从字符串的开始或结束处删除空白：'
- en: '[PRE22]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: All of these `String` methods are great ways to manipulate and modify `String`
    objects. Note that all of these methods can be used with a variable that contains
    a string—as in the `ToLower()` and `Trim()` examples—or they can be used directly
    with a static string, as in the `IndexOf()` example.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些 `String` 方法都是操纵和修改 `String` 对象的极好方式。请注意，所有这些方法都可以与包含字符串的变量一起使用——如在 `ToLower()`
    和 `Trim()` 示例中所示——或者可以直接与静态字符串一起使用，如在 `IndexOf()` 示例中所示。
- en: 26.4 Date manipulation
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 26.4 日期操作
- en: 'Like `String` objects, `Date` (or `DateTime`, if you prefer) objects come with
    a great many methods that allow date and time manipulation and calculation:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `String` 对象一样，`Date`（或如果你更喜欢，`DateTime`）对象也附带了许多方法，允许日期和时间的操作和计算：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that the properties enable you to access just a portion of a `DateTime`,
    such as the day, year, or month:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些属性使你能够访问 `DateTime` 的一部分，例如日期、年份或月份：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The methods enable two things: calculations and conversions to other formats.
    For example, to get the date for 90 days ago, we like to use `AddDays()` with
    a negative number:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法使两件事成为可能：计算和转换为其他格式。例如，为了获取 90 天前的日期，我们喜欢使用 `AddDays()` 并传入一个负数：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The methods whose names start with `To` are designed to provide dates and times
    in an alternative format, such as a short date string:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `To` 开头的方法旨在以不同的格式提供日期和时间，例如短日期字符串：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These methods all use your computer’s current regional settings to determine
    the correct way of formatting dates and times.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法都使用你电脑的当前区域设置来确定正确的时间日期格式化方式。
- en: 26.5 Dealing with WMI dates
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 26.5 处理 WMI 日期
- en: 'While WMI isn’t available in PowerShell 7, we know some of you are still using
    Windows PowerShell 5.1, so we want to share a tidbit of knowledge about how WMI
    tends to store date and time information in difficult-to-use strings. For example,
    the `Win32_OperatingSystem` class tracks the last time a computer was started,
    and the date and time information looks like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然WMI在PowerShell 7中不可用，但我们知道有些人仍在使用Windows PowerShell 5.1，因此我们想分享一些关于WMI倾向于以难以使用的字符串存储日期和时间信息的知识。例如，`Win32_OperatingSystem`类跟踪计算机上次启动的时间，日期和时间信息如下所示：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'PowerShell’s designers knew you wouldn’t be able to easily use this information,
    so they added a pair of conversion methods to every WMI object. Pipe any **WMI**
    object to `gm` and you can see those methods at or near the end:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell的设计者知道你不太可能轻松地使用这些信息，因此他们为每个WMI对象添加了一对转换方法。将任何**WMI**对象通过`gm`管道传输，你可以在末尾或附近看到这些方法：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We cut out most of the middle of this output so that you can easily find the
    `ConvertFromDateTime``()` and `ConvertToDateTime()` methods. In this case, what
    you start with is a **WMI** date and time, and you want to convert that to a normal
    date and time, so you do it like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们删除了大部分中间输出，以便你可以轻松找到`ConvertFromDateTime``()`和`ConvertToDateTime()`方法。在这种情况下，你开始的是一个**WMI**日期和时间，你想要将其转换为正常的日期和时间，所以你这样做：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you want to make that date and time information part of a normal table,
    you can use `Select-Object` or `Format-Table` to create custom, calculated columns
    and properties:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将日期和时间信息作为正常表格的一部分，你可以使用`Select-Object`或`Format-Table`来创建自定义的计算列和属性：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Dates are less of a hassle if you’re using the **CIM** commands, because they
    automatically translate most date/time values into something human readable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是**CIM**命令，日期的处理会简单得多，因为它们会自动将大多数日期/时间值转换为人类可读的格式。
- en: 26.6 Setting default parameter values
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 26.6 设置默认参数值
- en: Most PowerShell commands have at least a few parameters that include default
    values. For example, run `Dir` by itself and it defaults to the current path,
    without you having to specify a `-Path` parameter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数PowerShell命令至少包含几个具有默认值的参数。例如，只运行`Dir`，它默认为当前路径，无需指定`-Path`参数。
- en: Defaults are stored in a special built-in variable named `$PSDefaultParameterValues`.
    The variable is empty each time you open a new shell window, and it’s meant to
    be populated with a hash table (which you could do in a profile script, to have
    your defaults always in effect).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值存储在一个名为`$PSDefaultParameterValues`的特殊内置变量中。每次你打开一个新的shell窗口时，该变量都是空的，并且它的目的是用哈希表（你可以在配置文件脚本中这样做，以便始终有效）填充。
- en: 'For example, let’s say you want to create a new credential object containing
    a username and password, and have that credential automatically apply to all commands
    that have a `-Credential` parameter:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想创建一个新的包含用户名和密码的凭据对象，并让该凭据自动应用于所有具有`-Credential`参数的命令：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Or, you might want to force only the `Invoke-Command` cmdlet to prompt for
    a credential each time it’s run. In this case, rather than assigning a default
    value, you’d assign a script block that executes the `Get-Credential` command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可能只想在每次运行时强制`Invoke-Command` cmdlet提示输入凭据。在这种情况下，而不是分配一个默认值，你会分配一个执行`Get-Credential`命令的脚本块：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can see that the basic format for the `Add()` method’s first argument is
    `<-cmdlet> :<parameter>`, and `<cmdlet>` and can accept wildcards such as `*`.
    The second argument for the `Add()` method is either the value you want to make
    the default, or a script block that executes another command or commands.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`Add()`方法第一个参数的基本格式是`<-cmdlet> :<parameter>`，其中`<cmdlet>`可以接受通配符，如`*`。`Add()`方法的第二个参数是你想要设置为默认值的值，或者是一个执行另一个或多个命令的脚本块。
- en: 'You can always examine `$PSDefaultParameterValues` to see what it contains:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以始终检查`$PSDefaultParameterValues`以查看它包含的内容：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can learn more about this feature by reading the shell’s `about_parameters_
    default_values` help file.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过阅读shell的`about_parameters_default_values`帮助文件来了解更多关于这个功能的信息。
- en: Above and beyond
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 超越
- en: PowerShell variables are controlled by something called *scope*. We offered
    a brief introduction to scope in chapter 16, and it is something that plays into
    these default parameter values.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell变量受称为*作用域*的东西控制。我们在第16章中简要介绍了作用域，它与这些默认参数值有关。
- en: If you set `$PSDefaultParameterValues` at the command line, it’ll apply to all
    scripts and commands run within that shell session. But if you set `$-PSDefaultParameterValues`
    within a script, it’ll apply only to things done by that script. That’s a useful
    technique, because it means you can start a script with a bunch of defaults, and
    they won’t apply to other scripts, or to the shell in general.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过命令行设置`$PSDefaultParameterValues`，它将应用于该shell会话中运行的 所有脚本和命令。但如果你在脚本中设置`$-PSDefaultParameterValues`，它将只应用于该脚本所做的事情。这是一个有用的技巧，因为它意味着你可以用一个脚本开始，并设置很多默认值，这些值不会应用于其他脚本，或shell本身。
- en: This concept of “what happens in the script, stays in the script” is the heart
    of scope. You can read more about scope in the shell’s `about_scope` help file,
    if you’d like to explore further on your own.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: “脚本中发生的事情留在脚本中”这个概念是作用域的核心。如果你想进一步探索，可以阅读shell的`about_scope`帮助文件。
- en: 26.7 Playing with script blocks
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 26.7 玩转脚本块
- en: 'Script blocks are a key part of PowerShell, and you’ve been using them quite
    a bit:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本块是PowerShell的关键部分，你已经使用它们很多了：
- en: The `-FilterScript` parameter of `Where-Object` takes a script block.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Where-Object`的`-FilterScript`参数接受脚本块。'
- en: The `-Process` parameter of `ForEach-Object` takes a script block.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForEach-Object`的`-Process`参数接受脚本块。'
- en: The hash table used to create custom properties with `Select-Object`, or custom
    columns with `Format-Table`, accepts a script block as the value of the `E,` or
    `Expression``,` key.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于使用`Select-Object`创建自定义属性或使用`Format-Table`创建自定义列的哈希表接受脚本块作为`E`或`Expression`键的值。
- en: Default parameter values, as described in the previous section, can be set to
    a script block.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，默认参数值可以设置为脚本块。
- en: Some remoting and job-related commands, including `Invoke-Command` and `Start-Job`,
    accept script blocks on their `-ScriptBlock` parameter.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些远程和作业相关的命令，包括`Invoke-Command`和`Start-Job`，接受脚本块作为`-ScriptBlock`参数。
- en: 'So what is a script block? In general, it’s anything surrounded by curly brackets
    `{}`, with the exception of hash tables, which use curly brackets but are preceded
    by the `@` symbol. You can even enter a script block right from the command line
    and assign it to a variable. You can then use the call operator, `&`, to run the
    block:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么是脚本块呢？一般来说，它是由大括号 `{}` 包围的任何东西，除了哈希表，哈希表使用大括号，但前面有`@`符号。你甚至可以直接从命令行输入脚本块并将其分配给变量。然后你可以使用调用运算符`&`来运行该块：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can do quite a bit more with script blocks. If you’d like to explore the
    possibilities on your own, read the shell’s `about_script_blocks` help file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用脚本块做很多事情。如果你想自己探索可能性，请阅读shell的`about_script_blocks`帮助文件。
- en: 26.8 More tips, tricks, and techniques
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 26.8 更多技巧、窍门和技术
- en: As we said at the outset of this chapter, this is an overview of some random
    little things that we want to show you but that did not fit neatly into one of
    the previous chapters. Of course, you’ll continue to pick up tips and tricks with
    the shell as you learn more about it and gain more experience with it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头所说的，这是一个概述，我们想向你展示一些随机的小东西，但它们并没有很好地融入前面的任何一章。当然，随着你对shell了解得更多，以及你获得更多经验，你将继续从中获得技巧和窍门。
- en: You can check out our Twitter feeds too—@TylerLeonhardt, @TravisPlunk, and @PSJamesP—where
    we routinely share tips and techniques that we discover and find useful. And don’t
    forget the forums at [PowerShell.org](http://PowerShell.org). Sometimes, learning
    bit by bit can be an easy way to become more proficient in a technology, so consider
    these and any other sources you run across as a way to incrementally and continually
    improve your PowerShell expertise.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以查看我们的Twitter动态——@TylerLeonhardt, @TravisPlunk, 和 @PSJamesP——在那里我们定期分享我们发现的和觉得有用的技巧和技术。别忘了PowerShell.org上的论坛。有时候，一点一滴地学习可以是一个更容易成为技术专家的方法，所以请将这些以及其他你遇到的任何来源视为逐步和持续提高你的PowerShell技能的方式。
