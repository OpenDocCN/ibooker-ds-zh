- en: 12 Fetch plans, strategies, and profiles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 获取计划、策略和配置文件
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Working with lazy and eager loading
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用延迟和即时加载
- en: Applying fetch plans, strategies, and profiles
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用获取计划、策略和配置文件
- en: Optimizing SQL execution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化SQL执行
- en: 'In this chapter, we’ll explore Hibernate’s solution for the fundamental ORM
    problem of navigation, as introduced in section 1.2.5: the difference in how you
    access data in Java code and within a relational database. We’ll demonstrate how
    to retrieve data from the database and how to optimize this loading.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索Hibernate解决基本ORM导航问题的解决方案，如第1.2.5节中介绍：在Java代码和关系数据库中访问数据的方式的差异。我们将演示如何从数据库检索数据以及如何优化这种加载。
- en: 'Hibernate provides the following ways to get data out of the database and into
    memory:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate提供了以下从数据库获取数据并将其放入内存的方法：
- en: We can retrieve an entity instance by identifier. This is the most convenient
    method when the unique identifier value of an entity instance is known, such as
    `entityManager.find(Item.class, 123)`.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过标识符检索实体实例。当实体实例的唯一标识符值已知时，这是最方便的方法，例如`entityManager.find(Item.class, 123)`。
- en: We can navigate the entity graph, starting from an already-loaded entity instance,
    by accessing the associated instances through property accessor methods such as
    `someItem.getSeller``().getAddress().getCity()`, and so on. Elements of mapped
    collections are also loaded on demand when we start iterating through a collection.
    Hibernate automatically loads nodes of the graph if the persistence context is
    still open. What data is loaded when we call accessors and iterate through collections,
    and how it’s loaded, is the focus of this chapter.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过访问关联实例的属性访问器方法（如`someItem.getSeller()`().`getAddress()`().`getCity()`等）从已加载的实体实例开始导航实体图。当我们开始遍历集合时，映射集合的元素也会按需加载。如果持久化上下文仍然打开，Hibernate会自动加载图中的节点。当我们调用访问器和遍历集合时加载的数据以及如何加载，是本章的重点。
- en: We can use the Jakarta Persistence Query Language (JPQL), a full object- oriented
    query language based on strings such as `select i from Item i where i.id = ?`.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用Jakarta Persistence Query Language (JPQL)，这是一种基于字符串的完整面向对象查询语言，例如`select
    i from Item i where i.id = ?`。
- en: The `CriteriaQuery` interface provides a type-safe and object-oriented way to
    perform queries without string manipulation.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CriteriaQuery`接口提供了一种类型安全和面向对象的方式来执行查询，而不需要字符串操作。'
- en: We can write native SQL queries, call stored procedures, and let Hibernate take
    care of mapping the JDBC result sets to instances of the domain model classes.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以编写原生SQL查询，调用存储过程，并让Hibernate负责将JDBC结果集映射到领域模型类的实例。
- en: In our JPA applications, we’ll use a combination of these techniques. By now
    you should be familiar with the basic Jakarta Persistence API for retrieving by
    identifier. We’ll keep our JPQL and `CriteriaQuery` examples as simple as possible,
    and you won’t need the SQL query-mapping features.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的JPA应用程序中，我们将使用这些技术的组合。到目前为止，你应该熟悉用于通过标识符检索的基本Jakarta Persistence API。我们将保持我们的JPQL和`CriteriaQuery`示例尽可能简单，你不需要SQL查询映射功能。
- en: Major new features in JPA 2
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 2的主要新特性
- en: We can manually check the initialization state of an entity or an entity property
    with the new `PersistenceUtil` static helper class. We can also create standardized
    declarative fetch plans with the new `EntityGraph` API.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用新的`PersistenceUtil`静态辅助类手动检查实体或实体属性的初始化状态。我们还可以使用新的`EntityGraph` API创建标准化的声明性获取计划。
- en: This chapter analyzes what happens behind the scenes when we navigate the graph
    of the domain model and Hibernate retrieves data on demand. In all the examples,
    we’ll interpret the SQL executed by Hibernate in a comment right immediately after
    the operation that triggered the SQL execution.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分析了当我们导航领域模型图并Hibernate按需检索数据时幕后发生的事情。在所有示例中，我们将在触发SQL执行的操作之后立即在注释中解释Hibernate执行的SQL。
- en: 'What Hibernate loads depends on the *fetch plan*: we define the sub-graph of
    the network of objects that should be loaded. Then we pick the right *fetch strategy*,
    defining *how* the data should be loaded. We can store the selection of plan and
    strategy as a *fetch profile* and reuse it.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate加载的数据取决于*获取计划*：我们定义应该加载的对象网络子图。然后我们选择正确的*获取策略*，定义*如何*加载数据。我们可以将计划和策略的选择存储为*获取配置文件*并重用它。
- en: 'Defining fetch plans and what data should be loaded by Hibernate relies on
    two fundamental techniques: *lazy* and *eager* loading of nodes in the network
    of objects.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 定义获取计划和Hibernate应该加载哪些数据依赖于两种基本技术：对象网络中的*懒惰*和*急切*加载节点。
- en: 12.1 Lazy and eager loading
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 懒惰和急切加载
- en: At some point we must decide what data should be loaded into memory from the
    database. When we execute `entityManager.find(Item.class, 123)`, what is available
    in memory and loaded into the persistence context? What happens if we use `EntityManager#getReference()`
    instead?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，我们必须决定应该从数据库中加载哪些数据到内存中。当我们执行`entityManager.find(Item.class, 123)`时，内存中有什么，被加载到持久上下文中？如果我们使用`EntityManager#getReference()`会发生什么？
- en: In the domain-model mapping, we define the global *default fetch plan*, with
    the `FetchType.LAZY` and `FetchType.EAGER` options on associations and collections.
    This plan is the default setting for all operations involving the persistent domain
    model classes. It’s always active when we load an entity instance by identifier
    and when we navigate the entity graph by following associations and iterating
    through persistent collections.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域模型映射中，我们定义全局的*默认获取计划*，在关联和集合上使用`FetchType.LAZY`和`FetchType.EAGER`选项。此计划是涉及持久领域模型类的所有操作的默认设置。当我们通过标识符加载实体实例以及通过跟随关联和遍历持久集合导航实体图时，它始终处于活动状态。
- en: Our recommended strategy is a *lazy* default fetch plan for all entities and
    collections. If we map all of the associations and collections with `FetchType.LAZY`,
    Hibernate will only load the data we’re accessing. As we navigate the graph of
    the domain model instances, Hibernate will load data on demand, bit by bit. We
    can then override this behavior on a per-case basis when necessary.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐的策略是为所有实体和集合使用一个*懒惰*的默认获取计划。如果我们使用`FetchType.LAZY`映射所有的关联和集合，Hibernate将只加载我们访问的数据。当我们导航领域模型实例的图时，Hibernate将按需、逐步加载数据。在必要时，我们可以根据每个案例覆盖此行为。
- en: To implement lazy loading, Hibernate relies on runtime-generated entity placeholders
    called *proxies* and on *smart wrappers* for collections.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现懒惰加载，Hibernate依赖于运行时生成的实体占位符，称为*代理*，以及集合的*智能包装器*。
- en: 12.1.1 Understanding entity proxies
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.1 理解实体代理
- en: Consider the `getReference()` method of the `EntityManager` API. In section
    10.2.4, we took a first look at this operation and at how it may return a proxy.
    Let’s further explore this important feature and find out how proxies work.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`EntityManager` API的`getReference()`方法。在第10.2.4节中，我们首次了解了此操作及其可能返回代理的方式。让我们进一步探讨这个重要功能，并了解代理是如何工作的。
- en: Note To execute the examples from the source code, you’ll first need to run
    the Ch12.sql script.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要执行源代码中的示例，您首先需要运行Ch12.sql脚本。
- en: 'The following code doesn’t execute any SQL against the database. All Hibernate
    does is create an `Item` proxy: it looks (and smells) like the real thing, but
    it’s only a placeholder:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码不会对数据库执行任何SQL。Hibernate所做的只是创建一个`Item`代理：它看起来（和闻起来）就像真的东西，但它只是一个占位符：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Ⓐ There is no database hitting, meaning there is no `SELECT`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 没有数据库击打，这意味着没有`SELECT`。
- en: Ⓑ Calling the identifier getter (no field access!) doesn’t trigger initialization.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 调用标识符获取器（没有字段访问！）不会触发初始化。
- en: In the persistence context, in memory, we now have this proxy available in persistent
    state, as shown in figure 12.1.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在持久上下文中，现在我们有这个代理在持久状态中可用，如图12.1所示。
- en: '![](../../OEBPS/Images/CH12_F01_Tudose2.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH12_F01_Tudose2.png)'
- en: Figure 12.1 The persistence context, under the control of Hibernate, contains
    an `Item` proxy.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 在Hibernate控制下的持久上下文包含一个`Item`代理。
- en: The proxy is an instance of a runtime-generated subclass of `Item`, carrying
    the identifier value of the entity instance it represents. This is why Hibernate
    (in line with JPA) requires that entity classes have at least a public or protected
    no-argument constructor (the class may have other constructors too). The entity
    class and its methods must not be final; otherwise, Hibernate can’t produce a
    proxy. Note that the JPA specification doesn’t mention proxies; it’s up to the
    JPA provider how lazy loading is implemented.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代理是代表实体实例的运行时生成的`Item`子类的实例，携带该实体实例的标识符值。这就是为什么Hibernate（与JPA一致）要求实体类至少有一个公共或受保护的零参数构造函数（类也可以有其他构造函数）。实体类及其方法不能是最终的；否则，Hibernate无法生成代理。请注意，JPA规范没有提到代理；如何实现懒惰加载取决于JPA提供者。
- en: If we call any method on the proxy that isn’t the “identifier getter,” we’ll
    trigger initialization of the proxy and hit the database. If we call `item.getName()`,
    the SQL `SELECT` to load the `Item` will be executed. The previous example called
    `item.getId()` without triggering initialization because `getId()` *is* the identifier
    getter method in the given mapping; the `getId()` method was annotated with `@Id`.
    If `@Id` was on a field, then calling `getId()`, just like calling any other method,
    would initialize the proxy. (Remember that we usually prefer mappings and access
    on fields, because this allows more freedom when designing accessor methods; see
    section 3.2.3\. It’s up to you whether calling `getId()` without initializing
    a proxy is more important.)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在代理上调用任何不是“标识符获取器”的方法，我们将触发代理的初始化并击中数据库。如果我们调用 `item.getName()`，将执行加载 `Item`
    的 SQL `SELECT`。前面的例子调用 `item.getId()` 没有触发初始化，因为 `getId()` 是给定映射中的标识符获取器方法；`getId()`
    方法被注解为 `@Id`。如果 `@Id` 在一个字段上，那么调用 `getId()`，就像调用任何其他方法一样，将初始化代理。（记住，我们通常更喜欢映射和字段上的访问，因为这允许在设计访问器方法时拥有更多自由；请参阅第
    3.2.3 节。是否调用 `getId()` 而不初始化代理取决于你。）
- en: 'With proxies, be careful how you compare classes. Because Hibernate generates
    the proxy class, it has a funny-looking name, and it is *not* equal to `Item.class`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代理时，请注意如何比较类。因为 Hibernate 生成代理类，它有一个看起来很奇怪的名称，并且它**不等于**`Item.class`：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ⓐ The class is runtime generated and named something like `Item$HibernateProxy$BLsrPly8`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 该类是运行时生成的，名称类似于 `Item$HibernateProxy$BLsrPly8`。
- en: If we really must get the actual type represented by a proxy, we can use the
    `HibernateProxyHelper`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确实需要获取代理表示的实际类型，我们可以使用 `HibernateProxyHelper`。
- en: 'JPA provides `PersistenceUtil`, which we can use to check the initialization
    state of an entity or any of its attributes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 提供了 `PersistenceUtil`，我们可以用它来检查实体或其实体属性的初始化状态：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Ⓐ Executing this line of code would effectively trigger the initialization of
    the item.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 执行这一行代码将有效地触发项目的初始化。
- en: The `isLoaded()` method also accepts the name of a property of the given entity
    (proxy) instance, checking its initialization state. Hibernate offers an alternative
    API with `Hibernate.isInitialized()`. If we call `item.getSeller()`, though, the
    `item` proxy is initialized first.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`isLoaded()` 方法也接受给定实体（代理）实例的属性名称，检查其初始化状态。Hibernate 提供了一个替代 API，即 `Hibernate.isInitialized()`。如果我们调用
    `item.getSeller()`，则首先初始化 `item` 代理。'
- en: 'Hibernate also offers a utility method for quick-and-dirty initialization of
    proxies:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 还提供了一个用于快速初始化代理的实用方法：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Ⓐ The first call hits the database and loads the `Item` data, populating the
    proxy with the item’s name, price, and so on.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 第一次调用将击中数据库并加载 `Item` 数据，用项目的名称、价格等信息填充代理。
- en: Ⓑ Make sure the `@ManyToOne` default of `EAGER` has been overridden with `LAZY`.
    That is why the `seller` of the `item` is not yet initialized.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 确保已经用 `LAZY` 覆盖了 `@ManyToOne` 的默认值 `EAGER`。这就是为什么 `item` 的 `seller` 还未初始化的原因。
- en: Ⓒ By initializing the `seller` of the `item,` we hit the database and load the
    `User` data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 通过初始化 `item` 的 `seller`，我们将触发数据库调用并加载 `User` 数据。
- en: 'The `seller` of the `Item` is a `@ManyToOne` association mapped with `FetchType.LAZY`,
    so Hibernate creates a `User` proxy when the `Item` is loaded. We can check the
    `seller` proxy state and load it manually, just like with the `Item`. Remember
    that the JPA default for `@ManyToOne` is `FetchType.EAGER`! We usually want to
    override this to get a lazy default fetch plan, as we demonstrated in section
    8.3.1 and again here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item` 的 `seller` 是一个通过 `FetchType.LAZY` 映射的 `@ManyToOne` 关联，因此当加载 `Item` 时，Hibernate
    会创建一个 `User` 代理。我们可以检查 `seller` 代理的状态并手动加载它，就像对 `Item` 做的那样。记住，JPA 对 `@ManyToOne`
    的默认值是 `FetchType.EAGER`！我们通常希望覆盖这个默认值以获得一个懒加载的默认获取计划，就像我们在第 8.3.1 节和这里所展示的那样：'
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With such a lazy fetch plan, we might run into a `LazyInitializationException`.
    Consider the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种懒加载获取计划，我们可能会遇到 `LazyInitializationException`。考虑以下代码：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Ⓐ An `Item` entity instance is loaded in the persistence context. Its `seller`
    isn’t initialized; it’s a `User` proxy.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 在持久化上下文中加载了一个 `Item` 实体实例。它的 `seller` 没有初始化；它是一个 `User` 代理。
- en: Ⓑ We can manually detach the data from the persistence context or close the
    persistence context and detach everything.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 我们可以手动从持久化上下文中分离数据或关闭持久化上下文并分离所有内容。
- en: Ⓒ The `PersistenceUtil` helper works without a persistence context. We can check
    at any time whether the data we want to access has been loaded.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `PersistenceUtil` 辅助工具可以在没有持久化上下文的情况下工作。我们可以在任何时候检查我们想要访问的数据是否已经被加载。
- en: Ⓓ In detached state, we can call the identifier getter method of the `User`
    proxy.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 在分离状态中，我们可以调用`User`代理的标识符获取方法。
- en: Ⓔ Calling any other method on the proxy, such as `getUsername()`, will throw
    a `LazyInitializationException`. Data can only be loaded on demand while the persistence
    context manages the proxy, not in detached state.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ 在代理上调用任何其他方法，例如`getUsername()`，将抛出`LazyInitializationException`。数据只能在持久化上下文管理代理时按需加载，而不是在分离状态。
- en: How does lazy loading of one-to-one associations work?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一对一关联的延迟加载是如何工作的？
- en: Lazy loading for one-to-one entity associations is sometimes confusing for new
    Hibernate users. If we consider one-to-one associations based on shared primary
    keys (see section 9.1.1), an association can be proxied only if it’s `optional=false`.
    For example, an `Address` always has a reference to a `User`. If this association
    is nullable and optional, Hibernate must first hit the database to find out whether
    it should apply a proxy or a null, and the purpose of lazy loading is to not hit
    the database at all.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Hibernate的新用户来说，一对一实体关联的延迟加载有时会令人困惑。如果我们考虑基于共享主键的一对一关联（见第9.1.1节），只有当关联的`optional=false`时，才能代理关联。例如，`Address`总是有一个对`User`的引用。如果这个关联是可空的且可选的，Hibernate必须首先访问数据库以确定是否应该应用代理或null，而延迟加载的目的就是根本不访问数据库。
- en: Hibernate proxies are useful beyond simple lazy loading. For example, we can
    store a new `Bid` without loading any data into memory.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate代理除了简单的延迟加载之外还有其他用途。例如，我们可以存储一个新的`Bid`而不将任何数据加载到内存中。
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Ⓐ There is no SQL `SELECT` in this procedure, only one `INSERT`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 在此过程中没有SQL `SELECT`，只有一个`INSERT`。
- en: The first two calls produce proxies of `Item` and `User`, respectively. Then
    the `item` and `bidder` association properties of the transient `Bid` are set
    with the proxies. The `persist()` call queues one SQL `INSERT` when the persistence
    context is flushed, and no `SELECT` is necessary to create the new row in the
    `BID` table. All key values are available as identifier values of the `Item` and
    `User` proxy.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前两次调用分别产生`Item`和`User`的代理。然后，将代理设置到瞬态`Bid`的`item`和`bidder`关联属性中。当持久化上下文刷新时，`persist()`调用将排队一个SQL
    `INSERT`，并且不需要`SELECT`来在`BID`表中创建新行。所有键值都作为`Item`和`User`代理的标识符值可用。
- en: 'Runtime proxy generation, as provided by Hibernate, is an excellent choice
    for transparent lazy loading. The domain model classes don’t have to implement
    any special type or supertype, as some older ORM solutions require. No code generation
    or post-processing of bytecode is needed either, simplifying the build procedure.
    But you should be aware of some potentially negative aspects:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时代理生成，如Hibernate所提供，是透明延迟加载的一个优秀选择。领域模型类不需要实现任何特殊类型或超类型，正如一些较老的ORM解决方案所要求的。也不需要代码生成或字节码的后处理，这简化了构建过程。但你应该意识到一些潜在的负面方面：
- en: Some runtime proxies aren’t completely transparent, such as polymorphic associations
    that are tested with `instanceof`. This problem was demonstrated in section 7.8.1.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些运行时代理并不完全透明，例如使用`instanceof`测试的多态关联。这个问题在第7.8.1节中有所演示。
- en: With entity proxies, you have to be careful not to access fields directly when
    writing custom `equals``()` and `hashCode()` methods, as discussed in section
    10.3.2.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写自定义的`equals()`和`hashCode()`方法时，你必须小心不要直接访问字段，正如第10.3.2节所讨论的。
- en: Proxies can only be used to lazy-load entity associations. They can’t be used
    to lazy-load individual basic properties or embedded components, such as `Item#
    description` or `User#homeAddress`. If you set the `@Basic(fetch = FetchType .LAZY)`
    hint on such a property, Hibernate ignores it; the value is eagerly loaded when
    the owning entity instance is loaded. Optimizing at the level of individual columns
    selected in SQL is unnecessary if you aren’t working with either a significant
    number of optional or nullable columns, or columns containing large values that
    have to be retrieved on demand because of the physical limitations of the system.
    Large values are best represented with large objects (LOBs) instead; they provide
    lazy loading by definition (see “Binary and large value types” in section 6.3.1).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理只能用于懒加载实体关联。它们不能用于懒加载单个基本属性或嵌入式组件，例如`Item# description`或`User#homeAddress`。如果你在这样一个属性上设置了`@Basic(fetch
    = FetchType .LAZY)`提示，Hibernate会忽略它；当拥有实体的实例被加载时，值会被立即加载。如果你不是在处理大量的可选或可空列，或者由于系统的物理限制必须按需检索包含大值的列，那么在SQL中选择的单个列级别进行优化是不必要的。大值最好用大对象（LOBs）表示；它们根据定义提供懒加载（参见第6.3.1节中的“二进制和大值类型”）。
- en: Proxies enable lazy loading of entity instances. For persistent collections,
    Hibernate has a slightly different approach.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 代理允许懒加载实体实例。对于持久化集合，Hibernate采用略有不同的方法。
- en: 12.1.2 Lazy persistent collections
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.2 懒加载持久化集合
- en: We map persistent collections with either `@ElementCollection` for a collection
    of elements of basic or embeddable types or with `@OneToMany` and `@ManyToMany`
    for many-valued entity associations. These collections are, unlike `@ManyToOne`,
    lazy-loaded by default. We don’t have to specify the `FetchType.LAZY` option on
    the mapping.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@ElementCollection`将持久化集合映射为基本或嵌入式类型的元素集合，或者使用`@OneToMany`和`@ManyToMany`将多值实体关联映射为集合。这些集合与`@ManyToOne`不同，默认情况下是懒加载的。我们不需要在映射上指定`FetchType.LAZY`选项。
- en: 'The lazy `bids` one-to-many collection is only loaded when accessed:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载的`bids`一对一集合仅在访问时加载：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Ⓐ The `find()` operation loads the `Item` entity instance into the persistence
    context, as you can see in figure 12.2.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 如您在图12.2中看到的，`find()`操作将`Item`实体实例加载到持久化上下文中。
- en: 'Ⓑ The `Item` instance has a reference to an uninitialized `Set` of `bids`.
    It also has a reference to an uninitialized `User` proxy: the `seller`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ `Item`实例有一个指向未初始化的`bids`集合的引用。它还有一个指向未初始化的`User`代理的引用：`seller`。
- en: Ⓒ The `bids` field is a `Set`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `bids`字段是一个`Set`。
- en: Ⓓ However, the `bids` field is not a `HashSet`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓓ 然而，`bids`字段不是一个`HashSet`。
- en: Ⓔ The `bids` field is a Hibernate proxy class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓔ `bids`字段是一个Hibernate代理类。
- en: '![](../../OEBPS/Images/CH12_F02_Tudose2.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH12_F02_Tudose2.png)'
- en: Figure 12.2 Proxies and collection wrappers are the boundary of the loaded graph
    under Hibernate control.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 在Hibernate控制下，代理和集合包装器是加载图的边界。
- en: Hibernate implements lazy loading (and dirty checking) of collections with its
    own special implementations called *collection wrappers*. Although the `bids`
    certainly look like a `Set`, Hibernate replaced the implementation with an `org.hibernate.collection
    .internal.PersistentSet` while we weren’t looking. It’s not a `HashSet`, but it
    has the same behavior. That’s why it’s so important to program with interfaces
    in the domain model and only rely on `Set` and not `HashSet`. Lists and maps work
    the same way.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate通过其称为*集合包装器*的特殊实现来实现集合的懒加载（和脏检查）。尽管`bids`确实看起来像`Set`，但在我们没有注意到的情况下，Hibernate用`org.hibernate.collection.internal.PersistentSet`替换了实现。它不是一个`HashSet`，但它具有相同的行为。这就是为什么在领域模型中用接口编程并且只依赖于`Set`而不是`HashSet`如此重要的原因。列表和映射也是同样的方式工作。
- en: 'These special collections can detect when we access them, and they load their
    data at that time. As soon as we start iterating through the `bids`, the collection
    and all bids made for the item are loaded:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特殊集合可以检测我们何时访问它们，并在那时加载数据。当我们开始遍历`bids`时，集合和为该物品做出的所有出价都会被加载：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Alternatively, just as for entity proxies, we can call the static `Hibernate.initialize()`
    utility method to load a collection. It will be completely loaded; we can’t say
    “only load the first two bids,” for example. To do that, we’d have to write a
    query.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，就像实体代理一样，我们可以调用静态的`Hibernate.initialize()`实用方法来加载一个集合。它将被完全加载；我们无法说“只加载前两个出价”，例如。要这样做，我们必须编写一个查询。
- en: 'For convenience, so we don’t have to write many trivial queries, Hibernate
    offers a proprietary `LazyCollectionOption.EXTRA` setting on collection mappings:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，这样我们就不必编写许多琐碎的查询，Hibernate在集合映射上提供了一个专有的`LazyCollectionOption.EXTRA`设置：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With `LazyCollectionOption.EXTRA`, the collection supports operations that
    don’t trigger initialization. For example, we could ask for the collection’s size:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`LazyCollectionOption.EXTRA`，集合支持不触发初始化的操作。例如，我们可以请求集合的大小：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `size()` operation triggers a `SELECT COUNT()` SQL query but doesn’t load
    the `bids` into memory. On all extra-lazy collections, similar queries are executed
    for the `isEmpty()` and `contains()` operations. An extra-lazy `Set` checks for
    duplicates with a simple query when we call `add()`. An extra-lazy `List` only
    loads one element if we call `get(index)`. For `Map`, extra-lazy operations are
    `containsKey()` and `containsValue``()`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`size()`操作触发一个`SELECT COUNT()` SQL查询，但不会将`bids`加载到内存中。在所有额外延迟加载的集合上，类似的查询会在`isEmpty()`和`contains()`操作时执行。当我们调用`add()`时，额外的延迟加载`Set`会通过一个简单的查询检查重复项。额外的延迟加载`List`只有在调用`get(index)`时才会加载一个元素。对于`Map`，额外的延迟操作是`containsKey()`和`containsValue()`。'
- en: 12.1.3 Eager loading of associations and collections
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.3 关联和集合的急切加载
- en: 'We’ve recommended a lazy default fetch plan, with `FetchType.LAZY` on all the
    association and collection mappings. Sometimes, although not often, we want the
    opposite: to specify that a particular entity association or collection should
    always be loaded. We want the guarantee that this data is available in memory
    without an additional database hit.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐使用延迟默认获取计划，在所有关联和集合映射上使用`FetchType.LAZY`。有时，尽管不常见，我们希望相反：指定特定的实体关联或集合应该始终被加载。我们希望保证这些数据在内存中可用，而无需额外的数据库访问。
- en: More important, we want a guarantee that, for example, we can access the `seller`
    of an `Item` once the `Item` instance is in detached state. When the persistence
    context is closed, lazy loading is no longer available. If `seller` were an uninitialized
    proxy, we’d get a `LazyInitializationException` when we accessed it in detached
    state. For data to be available in detached state, we need to either load it manually
    while the persistence context is still open or, if we *always* want it loaded,
    change the fetch plan to be eager instead of lazy.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们希望有一个保证，例如，一旦`Item`实例处于分离状态，我们就可以访问其`seller`。当持久化上下文关闭时，延迟加载不再可用。如果`seller`是一个未初始化的代理，当我们以分离状态访问它时，我们会得到一个`LazyInitializationException`。为了在分离状态下提供数据，我们需要在持久化上下文仍然打开时手动加载它，或者如果我们*总是*希望它被加载，将获取计划改为急切而非延迟。
- en: 'Let’s assume that we always require the `seller` and the `bids` of an `Item`
    to be loaded:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们总是需要加载`Item`的`seller`和`bids`：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Ⓐ `FetchType.EAGER` is the default for entity instances.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 实体实例的默认获取计划是`FetchType.EAGER`。
- en: Ⓑ Generally, `FetchType.EAGER` on a collection is not recommended. Unlike `FetchType.LAZY`,
    which is a hint the JPA provider can ignore, `FetchType.EAGER` is a hard requirement.
    The provider has to guarantee that the data is loaded and available in detached
    state; it can’t ignore the setting.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 通常，集合上的`FetchType.EAGER`不被推荐。与`FetchType.LAZY`不同，后者是JPA提供者可以忽略的提示，`FetchType.EAGER`是一个硬性要求。提供者必须保证数据被加载并在分离状态下可用；它不能忽略设置。
- en: 'Consider the collection mapping: is it really a good idea to say “whenever
    an item is loaded into memory, load the bids of the item right away too”? Even
    if we only want to display the item’s name or find out when the auction ends,
    all bids will be loaded into memory. Always eager-loading collections, with `FetchType.EAGER`
    as the default fetch plan in the mapping, usually isn’t a great strategy. (Later
    in this chapter, we’ll analyze the *Cartesian product problem*, which appears
    if we eagerly load several collections.) It’s best if we leave collections set
    with the default `FetchType.LAZY`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑集合映射：说“每当一个项目被加载到内存中时，立即加载该项目的出价”真的好吗？即使我们只想显示项目的名称或找出拍卖何时结束，所有出价都将被加载到内存中。始终使用`FetchType.EAGER`作为默认获取计划的集合延迟加载通常不是一个好策略。（在本章的后面部分，我们将分析如果急切加载多个集合时出现的*笛卡尔积问题*。）如果我们将集合设置为默认的`FetchType.LAZY`，那就最好不过了。
- en: 'If we now `find()` an `Item` (or force the initialization of an `Item` proxy),
    both the `seller` and all the `bids` are loaded as persistent instances into the
    persistence context:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在`find()`一个`Item`（或强制初始化一个`Item`代理），`seller`和所有`bids`都将作为持久实例加载到持久化上下文中：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Ⓐ When calling `detach()`, the fetching is done. There will be no more lazy
    loading.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 当调用`detach()`时，获取操作完成。将不再进行懒加载。
- en: Ⓑ In detached state, the `bids` collection is available, so we can check its
    size.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 在分离状态中，`bids`集合是可用的，因此我们可以检查其大小。
- en: Ⓒ In detached state, the `seller` is available, so we can check its name.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 在分离状态中，`seller`是可用的，因此我们可以检查其名称。
- en: 'For the `find()`, Hibernate executes a single SQL `SELECT` and `JOIN`s three
    tables to retrieve the data. You can see the contents of the persistence context
    in figure 12.3\. Note how the boundaries of the loaded graph are represented:
    each `Bid` has a reference to an uninitialized `User` proxy, the `bidder`. If
    we now detach the `Item`, we access the loaded `seller` and `bids` without causing
    a `LazyInitializationException`. If we try to access one of the `bidder` proxies,
    we’ll get an exception.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`find()`，Hibernate执行一个单一的SQL `SELECT`和三个表的`JOIN`来检索数据。您可以在图12.3中看到持久化上下文的内容。注意加载图的边界是如何表示的：每个`Bid`都有一个指向未初始化的`User`代理`bidder`的引用。如果我们现在断开`Item`的连接，我们可以访问加载的`seller`和`bids`而不会引发`LazyInitializationException`。如果我们尝试访问`bidder`代理之一，我们会得到一个异常。
- en: '![](../../OEBPS/Images/CH12_F03_Tudose2.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH12_F03_Tudose2.png)'
- en: Figure 12.3 The seller and the bids of an `Item` are loaded in the Hibernate
    persistence context.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 `Item`的卖家和出价在Hibernate持久化上下文中加载。
- en: Next, we’ll investigate *how* data should be loaded when we find an entity instance
    by identity and when we navigate the network, using the pointers of the mapped
    associations and collections. We’re interested in what SQL is executed and in
    finding the ideal *fetch strategy*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨当我们通过标识符找到实体实例以及当我们使用映射的关联和集合的指针导航网络时，数据应该如何加载。我们感兴趣的是执行了哪些SQL以及如何找到理想的*获取策略*。
- en: In the following examples, we’ll assume that the domain model has a lazy default
    fetch plan. Hibernate will only load the data we explicitly request and the associations
    and collections we access.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将假设领域模型有一个懒加载的默认获取计划。Hibernate将只加载我们明确请求的数据以及我们访问的关联和集合。
- en: 12.2 Selecting a fetch strategy
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 选择获取策略
- en: Hibernate executes SQL `SELECT` statements to load data into memory. If we load
    an entity instance, one or more `SELECT`s are executed, depending on the number
    of tables involved and the *fetching strategy* we’ve applied. Our goal is to minimize
    the number of SQL statements and to simplify the SQL statements so that querying
    can be as efficient as possible.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate执行SQL `SELECT`语句将数据加载到内存中。如果我们加载一个实体实例，将执行一个或多个`SELECT`，具体取决于涉及的表的数量和我们应用的*获取策略*。我们的目标是最小化SQL语句的数量并简化SQL语句，以便查询尽可能高效。
- en: 'Consider our recommended fetch plan from earlier in this chapter: every association
    and collection should be loaded on demand, lazily. This default fetch plan will
    most likely result in too many SQL statements, each loading only one small piece
    of data. This will lead to the *n+1 selects problem*, so we’ll look at this first.
    The alternative fetch plan, using eager loading, will result in fewer SQL statements,
    because larger chunks of data will be loaded into memory with each SQL query.
    We might then see the *Cartesian product problem*, as SQL result sets become too
    large.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑本章前面推荐的获取计划：每个关联和集合都应该按需、懒加载。这个默认的获取计划很可能会导致过多的SQL语句，每个语句只加载一小块数据。这将导致*n+1
    选择*问题，因此我们首先关注这个问题。使用预加载的替代获取计划将导致更少的SQL语句，因为每次SQL查询都会将更大的数据块加载到内存中。我们可能会看到*笛卡尔积问题*，因为SQL结果集变得过大。
- en: 'We need to find a middle ground between these two extremes: the ideal fetching
    strategy for each procedure and use case in our application. Like with fetch plans,
    we can set a global fetching strategy in the mappings: a default setting that
    is always active. Then, for a particular procedure, we might override the default
    fetching strategy with a custom JPQL `CriteriaQuery`, or even a SQL query.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在两种极端之间找到一个平衡点：我们应用程序中每个过程和用例的理想获取策略。就像获取计划一样，我们可以在映射中设置全局获取策略：一个始终激活的默认设置。然后，对于特定的过程，我们可能会用自定义的JPQL
    `CriteriaQuery`或甚至SQL查询覆盖默认的获取策略。
- en: First, let’s investigate the fundamental issues, starting with the *n+1 selects*
    problem.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们探讨基本问题，从*n+1 选择*问题开始。
- en: 12.2.1 The n+1 selects problem
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 n+1 选择问题
- en: 'This problem is easy to understand with some example code. Let’s assume that
    we mapped a lazy fetch plan, so everything is loaded on demand. The following
    code checks whether the `seller` of each `Item` has a `username`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些示例代码，我们可以很容易地理解这个问题。假设我们映射了一个懒加载计划，所以所有内容都是按需加载的。以下代码检查每个 `Item` 的 `seller`
    是否有 `username`：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Ⓐ Whenever we access a seller, each of them must be loaded with an additional
    `SELECT`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 每当我们访问一个卖家时，每个卖家都必须加载一个额外的 `SELECT`。
- en: You can see the one SQL `SELECT` that load the `Item` entity instances. Then,
    as we iterate through all the `items`, retrieving each `User` requires an additional
    `SELECT`. This amounts to one query for the `Item` plus *n* queries depending
    on how many items we have and whether a particular `User` is selling more than
    one `Item`. Obviously, this is a very inefficient strategy if we know we’ll be
    accessing the `seller` of each `Item`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到一个 SQL `SELECT`，它加载 `Item` 实例。然后，当我们遍历所有 `items` 时，检索每个 `User` 需要额外的 `SELECT`。这相当于对一个
    `Item` 的一个查询加上 *n* 个查询，这取决于我们有多少个项目以及特定的 `User` 是否出售超过一个 `Item`。显然，如果我们知道我们将访问每个
    `Item` 的 `seller`，这是一个非常低效的策略。
- en: 'We can see the same problem with lazily loaded collections. The following example
    checks whether each `Item` has any `bids`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在懒加载集合中看到相同的问题。以下示例检查每个 `Item` 是否有任何 `bids`：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Ⓐ Each `bids` collection has to be loaded with an additional `SELECT`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 每个 `bids` 集合都必须加载一个额外的 `SELECT`。
- en: Again, if we know we’ll be accessing each `bids` collection, loading only one
    at a time is inefficient. If we have 100 bids, we’ll execute 101 SQL queries!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果我们知道我们将访问每个 `bids` 集合，一次只加载一个是不高效的。如果我们有 100 个出价，我们将执行 101 个 SQL 查询！
- en: 'With what we know so far, we might be tempted to change the default fetch plan
    in the mappings and put a `FetchType.EAGER` on the `seller` or `bids` associations.
    But doing so can lead to our next topic: the *Cartesian product* problem.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们目前所知，我们可能会倾向于更改映射中的默认获取计划，并在 `seller` 或 `bids` 关联上放置 `FetchType.EAGER`。但这样做可能会导致我们下一个主题：笛卡尔积问题。
- en: 12.2.2 The Cartesian product problem
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2 笛卡尔积问题
- en: 'If we look at the domain and data model and say, “Every time I need an `Item`,
    I also need the `seller` of that `Item,`” we can map the association with `FetchType.EAGER`
    instead of a lazy fetch plan. We want a guarantee that whenever an `Item` is loaded,
    the `seller` will be loaded right away—we want that data to be available when
    the `Item` is detached and the persistence context is closed:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看领域和数据模型，并说，“每次我需要 `Item` 时，我也需要该 `Item` 的 `seller`，”我们可以使用 `FetchType.EAGER`
    映射关联，而不是懒加载计划。我们希望有一个保证，即每次加载 `Item` 时，`seller` 将立即加载——我们希望在 `Item` 分离和持久化上下文关闭时数据可用：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To implement the eager fetch plan, Hibernate uses an SQL `JOIN` operation to
    load an `Item` and a `User` instance in one `SELECT`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现 eager fetch plan，Hibernate 使用 SQL `JOIN` 操作在一个 `SELECT` 中加载一个 `Item` 和一个
    `User` 实例：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The result set contains one row with data from the `ITEM` table combined with
    data from the `USERS` table, as shown in figure 12.4.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 结果集包含一行数据，来自 `ITEM` 表和 `USERS` 表的数据合并，如图 12.4 所示。
- en: '![](../../OEBPS/Images/CH12_F04_Tudose2.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH12_F04_Tudose2.png)'
- en: Figure 12.4 Hibernate joins two tables to eagerly fetch associated rows.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 Hibernate 通过连接两个表来 eager 获取关联行。
- en: Eager fetching with the default `JOIN` strategy isn’t problematic for `@ManyToOne`
    and `@OneToOne` associations. We can eagerly load, with one SQL query and `JOIN`s,
    an `Item`, its `seller`, the `User`’s `Address`, the `City` they live in, and
    so on. Even if we map all these associations with `FetchType.EAGER`, the result
    set will have only one row.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认的 `JOIN` 策略进行 eager fetching 对 `@ManyToOne` 和 `@OneToOne` 关联没有问题。我们可以通过一个
    SQL 查询和 `JOIN`s 来 eager 加载一个 `Item`、它的 `seller`、用户的 `Address`、他们居住的 `City` 等等。即使我们使用
    `FetchType.EAGER` 映射所有这些关联，结果集也只有一个行。
- en: Hibernate has to stop following the `FetchType.EAGER` plan at *some* point.
    The number of tables joined depends on the global `hibernate.max_fetch_depth`
    configuration property, and by default, no limit is set. Reasonable values are
    small, usually from 1 to 5\. We can even disable `JOIN` fetching of `@ManyToOne`
    and `@OneToOne` associations by setting the property to 0\. If Hibernate reaches
    the limit, it will still eagerly load the data according to the fetch plan, but
    with additional `SELECT` statements. (Note that some database dialects may preset
    this property; for example, `MySQLDialect` sets it to 2.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 必须在某个时候停止遵循 `FetchType.EAGER` 计划。连接的表的数量取决于全局 `hibernate.max_fetch_depth`
    配置属性，默认情况下没有设置限制。合理的值通常很小，通常是 1 到 5。我们甚至可以通过将属性设置为 0 来禁用 `@ManyToOne` 和 `@OneToOne`
    关联的 `JOIN` 检索。如果 Hibernate 达到限制，它仍然会根据预取计划预取数据，但会使用额外的 `SELECT` 语句。（注意，某些数据库方言可能已经预设了此属性；例如，`MySQLDialect`
    将其设置为 2。）
- en: Eagerly loading collections with `JOIN`s, on the other hand, can lead to serious
    performance concerns. If we also switched to `FetchType.EAGER` for the `bids`
    and `images` collections, we’d run into the *Cartesian product problem*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用 `JOIN` 预取集合可能会导致严重的性能问题。如果我们也将 `bids` 和 `images` 集合切换到 `FetchType.EAGER`，我们就会遇到
    *笛卡尔积问题*。
- en: 'This problem appears when we eagerly load two collections with one SQL query
    and a `JOIN` operation. First, let’s create such a fetch plan and then look at
    the problem:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用一个 SQL 查询和一个 `JOIN` 操作预取两个集合时，会出现这个问题。首先，让我们创建这样一个预取计划，然后看看问题：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It doesn’t matter whether both collections are `@OneToMany`, `@ManyToMany`,
    or `@ElementCollection`. Eager fetching more than one collection at once with
    the SQL `JOIN` operator is the fundamental problem, no matter what the collection’s
    content is. If we load an `Item`, Hibernate executes the problematic SQL statement:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 无论两个集合都是 `@OneToMany`、`@ManyToMany` 还是 `@ElementCollection`，都无关紧要。使用 SQL `JOIN`
    操作符一次性获取多个集合是基本问题，无论集合的内容如何。如果我们加载一个 `Item`，Hibernate 将执行有问题的 SQL 语句：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, Hibernate obeyed the eager fetch plan, and we can access the
    `bids` and `images` collections in detached state. The problem is *how* they were
    loaded, with an SQL `JOIN` that results in a product. Look at the result set in
    figure 12.5.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Hibernate 遵循了预取计划，并且我们可以访问处于分离状态的 `bids` 和 `images` 集合。问题是它们是如何被加载的，通过一个产生乘积的
    SQL `JOIN`。看看图 12.5 中的结果集。
- en: '![](../../OEBPS/Images/CH12_F05_Tudose2.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH12_F05_Tudose2.png)'
- en: Figure 12.5 A product is the result of two joins with many rows.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 两个连接的结果是具有多行的乘积。
- en: 'This result set contains many redundant data items, and only the shaded cells
    are relevant for Hibernate. The `Item` has three bids and three images. The size
    of the product depends on the size of the collections we’re retrieving: 3 × 3
    is 9 rows total. Now imagine that we have an `Item` with 50 `bids` and 5 `images`—we’d
    see a result set with possibly 250 rows! We can create even larger SQL products
    when we write our own queries with JPQL or `CriteriaQuery`; imagine what would
    happen if we load 500 items and eager fetch dozens of bids and images with `JOIN`s.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果集包含许多冗余数据项，只有着色的单元格对 Hibernate 是相关的。`Item` 有三个出价和三个图片。乘积的大小取决于我们检索的集合的大小：3
    × 3 总共是 9 行。现在想象一下，如果我们有一个具有 50 个 `bids` 和 5 个 `images` 的 `Item`，我们可能会看到一个包含 250
    行的结果集！当我们使用 JPQL 或 `CriteriaQuery` 编写自己的查询时，我们甚至可以创建更大的 SQL 乘积；想象一下如果我们加载 500
    个项目，并通过 `JOIN` 预取数十个出价和图片会发生什么。
- en: Considerable processing time and memory are required on the database server
    to create such results, which then must be transferred across the network. If
    you’re hoping that the JDBC driver will compress the data on the wire somehow,
    you’re probably expecting too much from database vendors. Hibernate immediately
    removes all duplicates when it marshals the result set into persistent instances
    and collections; the information in cells that aren’t shaded in figure 12.5 will
    be ignored. Obviously, we can’t remove these duplicates at the SQL level; the
    SQL `DISTINCT` operator doesn’t help here.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库服务器上创建此类结果需要大量的处理时间和内存，然后这些结果必须通过网络传输。如果你希望 JDBC 驱动程序以某种方式压缩网络上的数据，你可能对数据库供应商期望过高了。Hibernate
    在将结果集序列化为持久实例和集合时立即删除所有重复项；图 12.5 中未着色的单元格中的信息将被忽略。显然，我们无法在 SQL 层面上删除这些重复项；SQL
    的 `DISTINCT` 操作符在这里不起作用。
- en: Instead of using one SQL query with an extremely large result, three separate
    queries would be faster for retrieving an entity instance and two collections
    at the same time. We’ll focus on this kind of optimization next and see how we
    can find and implement the best fetch strategy. We’ll start again with a default
    lazy fetch plan and try to solve the *n*+1 selects problem first.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用一个包含极大量结果的 SQL 查询相比，同时检索实体实例和两个集合时，三个单独的查询会更快。我们将在下一部分关注这种优化，并看看我们如何找到并实现最佳预取策略。我们将再次从默认的懒加载预取计划开始，并尝试首先解决
    *n*+1 查询问题。
- en: 12.2.3 Prefetching data in batches
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.3 批量预取数据
- en: If Hibernate fetches every entity association and collection only on demand,
    many additional SQL `SELECT` statements may be needed to complete a particular
    procedure. As before, consider a routine that checks whether the `seller` of each
    `Item` has a `username`. With lazy loading, this would require one `SELECT` to
    get all `Item` instances and *n* more `SELECT`s to initialize the `seller` proxy
    of each `Item`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Hibernate 只在需要时预取每个实体关联和集合，可能需要许多额外的 SQL `SELECT` 语句来完成特定的过程。就像之前一样，考虑一个检查每个
    `Item` 的 `seller` 是否有 `username` 的常规操作。使用懒加载，这需要一行 `SELECT` 来获取所有 `Item` 实例，以及
    *n* 行额外的 `SELECT` 来初始化每个 `Item` 的 `seller` 代理。
- en: 'Hibernate offers algorithms that can prefetch data. The first algorithm we’ll
    look at is *batch fetching*, and it works as follows: if Hibernate must initialize
    one `User` proxy, it can go ahead and initialize several with the same `SELECT`.
    In other words, if we already know that there are several `Item` instances in
    the persistence context and that they all have a proxy applied to their `seller`
    association, we may as well initialize several proxies instead of just one when
    we make the round trip to the database.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 提供了可以预取数据的算法。我们将首先查看的算法是 *批量预取*，它的工作原理如下：如果 Hibernate 必须初始化一个 `User`
    代理，它可以继续初始化几个具有相同 `SELECT` 的代理。换句话说，如果我们已经知道持久化上下文中存在多个 `Item` 实例，并且它们的所有 `seller`
    关联都应用了代理，那么我们不妨在数据库往返时初始化几个代理，而不仅仅是其中一个。
- en: 'Let’s see how this works. First, enable batch fetching of `User` instances
    with a proprietary Hibernate annotation:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的。首先，通过一个专有的 Hibernate 注解启用 `User` 实例的批量预取：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This setting tells Hibernate that it may load up to 10 `User` proxies if one
    has to be loaded, all with the same `SELECT`. Batch fetching is often called a
    *blind-guess optimization* because we don’t know how many uninitialized `User`
    proxies may be in a particular persistence context. We can’t say for sure that
    10 is an ideal value—it’s a guess. We know that instead of *n+*1 SQL queries,
    we’ll now see queries, a significant reduction. Reasonable values are usually
    small because we don’t want to load too much data into memory either, especially
    if we aren’t sure we’ll need it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置告诉 Hibernate，如果必须加载，它可以加载多达 10 个 `User` 代理，所有这些代理都使用相同的 `SELECT`。批量预取通常被称为
    *盲猜优化*，因为我们不知道特定持久化上下文中可能有多少未初始化的 `User` 代理。我们无法确定 10 是一个理想值——这是一个猜测。我们知道，与 *n+*1
    SQL 查询相比，我们现在将看到查询，这是一个显著的减少。合理的值通常很小，因为我们不希望将太多数据加载到内存中，尤其是如果我们不确定我们是否需要它。
- en: 'This is the optimized procedure, which checks the `username` of each `seller`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个优化过程，它会检查每个 `seller` 的 `username`：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note the SQL query that Hibernate executes while we iterate through the `items`.
    When we call `item.getSeller().getUserName()` for the first time, Hibernate must
    initialize the first `User` proxy. Instead of only loading a single row from the
    `USERS` table, Hibernate retrieves several rows, and up to 10 `User` instances
    are loaded. Once we access the eleventh `seller`, another 10 are loaded in one
    batch, and so on, until the persistence context contains no uninitialized `User`
    proxies.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Hibernate 在我们遍历 `items` 时执行的 SQL 查询。当我们第一次调用 `item.getSeller().getUserName()`
    时，Hibernate 必须初始化第一个 `User` 代理。Hibernate 不会只从 `USERS` 表中加载一行，而是检索多行，并加载多达 10 个
    `User` 实例。一旦我们访问到第十一个 `seller`，就会再批量加载 10 个，以此类推，直到持久化上下文中不再有未初始化的 `User` 代理。
- en: What is the real batch-fetching algorithm?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的批量预取算法是什么？
- en: Our explanation of batch loading in section 12.2.3 is somewhat simplified, and
    you may see a slightly different algorithm in practice.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 12.2.3 节中对批量加载的解释有些简化，你可能在实践中看到略有不同的算法。
- en: As an example, imagine a batch size of 32\. At startup time, Hibernate creates
    several batch loaders internally. Each loader knows how many proxies it can initialize.
    The goal is to minimize the memory consumption for loader creation and to create
    enough loaders that every possible batch fetch can be produced. Another goal is
    obviously to minimize the number of SQL queries. To initialize 31 proxies, Hibernate
    executes 3 batches (you probably expected 1, because 32 > 31). The batch loaders
    that are applied are 16, 10, and 5, as automatically selected by Hibernate.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设批处理大小为32。在启动时，Hibernate内部创建多个批处理加载器。每个加载器都知道它可以初始化多少个代理。目标是尽量减少加载器创建的内存消耗，并创建足够的加载器，以便可以生成每个可能的批处理抓取。另一个目标显然是尽量减少SQL查询的数量。为了初始化31个代理，Hibernate执行了3个批处理（你可能预计为1个，因为32
    > 31）。应用的批处理加载器是16、10和5，由Hibernate自动选择。
- en: You can customize this batch-fetching algorithm with the `hibernate.batch_fetch_
    style` property in the persistence unit configuration. The default is `LEGACY`,
    which builds and selects several batch loaders on startup. Other options are `PADDED`
    and `DYNAMIC`. With `PADDED`, Hibernate builds only one batch loader SQL query
    on startup with placeholders for 32 arguments in the `IN` clause and then repeats
    bound identifiers if fewer than 32 proxies have to be loaded. With `DYNAMIC`,
    Hibernate dynamically builds the batch SQL statement at runtime, when it knows
    the number of proxies to initialize.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过持久化单元配置中的`hibernate.batch_fetch_style`属性来自定义此批处理抓取算法。默认值为`LEGACY`，它在启动时构建并选择多个批处理加载器。其他选项包括`PADDED`和`DYNAMIC`。使用`PADDED`时，Hibernate在启动时仅构建一个带有`IN`子句中32个占位符的批处理加载器SQL查询，并在需要加载少于32个代理时重复绑定标识符。使用`DYNAMIC`时，Hibernate在运行时动态构建批处理SQL语句，当它知道要初始化的代理数量时。
- en: 'Batch fetching is also available for collections:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理抓取也适用于集合：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we now force the initialization of one `bids` collection, up to five more
    `Item#bids` collections, if they’re uninitialized in the current persistence context,
    are loaded right away:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在强制初始化一个`bids`集合，如果它们在当前持久化上下文中未初始化，则最多可以立即加载五个更多的`Item#bids`集合：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When we call `item.getBids().size()` for the first time while iterating, a whole
    batch of `Bid` collections are preloaded for the other `Item` instances.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在迭代时第一次调用`item.getBids().size()`时，将为其他`Item`实例预加载整个`Bid`集合。
- en: Batch fetching is a simple and often smart optimization that can significantly
    reduce the number of SQL statements that would otherwise be necessary to initialize
    all the proxies and collections. Although we may prefetch data we won’t need,
    and consume more memory, the reduction in database round trips can make a huge
    difference. Memory is cheap, but scaling database servers isn’t.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理抓取是一种简单且通常聪明的优化，可以显著减少初始化所有代理和集合所需的SQL语句数量。尽管我们可能会预取不需要的数据，并消耗更多内存，但减少数据库往返次数可以带来巨大的差异。内存很便宜，但扩展数据库服务器并不便宜。
- en: Another prefetching algorithm that isn’t a blind guess uses subselects to initialize
    many collections with a single statement.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种不是盲目猜测的预取算法使用子查询通过单个语句初始化许多集合。
- en: 12.2.4 Prefetching collections with subselects
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.4 使用子查询预取集合
- en: 'A potentially better strategy for loading all the `bids` of several `Item`
    instances is prefetching with a subselect. To enable this optimization, add a
    Fetch Hibernate annotation to the collection mapping, having the SUBSELECT parameter:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 加载多个`Item`实例的所有`bids`的一个潜在更好的策略是使用子查询进行预取。要启用此优化，请向集合映射添加一个Fetch Hibernate注解，并设置SUBSELECT参数：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Hibernate now initializes all `bids` collections for all loaded `Item` instances
    as soon as we force the initialization of one `bids` collection:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们强制初始化一个`bids`集合，Hibernate现在就会立即初始化所有已加载`Item`实例的所有`bids`集合：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Hibernate remembers the original query used to load the `items`. It then embeds
    this initial query (slightly modified) in a subselect, retrieving the collection
    of `bids` for each `Item`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate会记住用于加载`items`的原始查询。然后，它在子查询中嵌入此初始查询（略有修改），检索每个`Item`的`bids`集合。
- en: Note that the original query that is rerun as a subselect is only remembered
    by Hibernate for a particular persistence context. If we detach an `Item` instance
    without initializing the collection of `bids`, and then merge it with a new persistence
    context and start iterating through the collection, no prefetching of other collections
    occurs.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，作为子查询重新执行的原始查询只由 Hibernate 记忆在特定的持久化上下文中。如果我们没有初始化 `bids` 集合就分离一个 `Item`
    实例，然后将其与一个新的持久化上下文合并并开始遍历集合，则不会预取其他集合。
- en: Batch and subselect prefetching reduce the number of queries necessary for a
    particular procedure if you stick with a global lazy fetch plan in the mappings,
    helping mitigate the *n*+1 selects problem. If, instead, your global fetch plan
    has eager loaded associations and collections, you’ll have to avoid the Cartesian
    product problem—for example, by breaking down a `JOIN` query into several `SELECT`s.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在映射中坚持使用全局懒加载计划，批处理和子查询预取可以减少特定程序所需的查询数量，从而有助于缓解 *n*+1 查询问题。相反，如果你的全局加载计划已经预先加载了关联和集合，你必须避免笛卡尔积问题——例如，通过将
    `JOIN` 查询分解为几个 `SELECT`。
- en: 12.2.5 Eager fetching with multiple SELECTs
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.5 使用多个 SELECT 的 eager fetching
- en: 'When trying to fetch several collections with one SQL query and `JOIN`s, we’ll
    run into the Cartesian product problem, as discussed earlier. Instead of a `JOIN`
    operation, we can tell Hibernate to eagerly load data with additional `SELECT`
    queries and hence avoid large results and SQL products with duplicates:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试使用一个 SQL 查询和 `JOIN` 来获取多个集合时，我们会遇到前面讨论过的笛卡尔积问题。我们可以告诉 Hibernate 使用额外的 `SELECT`
    查询来懒加载数据，从而避免大型结果和重复的 SQL 积：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Ⓐ `FetchMode.SELECT` means that the property should be loaded lazily. The default
    value is `FetchMode.JOIN`, meaning the property would be retrieved eagerly, via
    a `JOIN`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `FetchMode.SELECT` 表示属性应该懒加载。默认值是 `FetchMode.JOIN`，这意味着属性将通过 `JOIN` 查询被检索。
- en: 'Now when an `Item` is loaded, the `seller` and `bids` have to be loaded as
    well:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当加载 `Item` 时，`seller` 和 `bids` 也必须被加载：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Ⓐ Hibernate uses one `SELECT` to load a row from the `ITEM` table. It then
    immediately executes two more `SELECT`s: one loading a row from the `USERS` table
    (the `seller`) and the other loading several rows from the `BID` table (the `bids`).
    The additional `SELECT` queries aren’t executed lazily; the `find()` method produces
    several SQL queries.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ Hibernate使用一个 `SELECT` 从 `ITEM` 表中加载数据行。然后它立即执行另外两个 `SELECT`：一个从 `USERS` 表（卖家）中加载数据行，另一个从
    `BID` 表（出价）中加载数据行。额外的 `SELECT` 查询不是懒加载执行的；`find()` 方法产生了多个 SQL 查询。
- en: Ⓑ Hibernate followed the eager fetch plan; all data is available in detached
    state.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ Hibernate遵循了 eager fetch 计划；所有数据在分离状态下都是可用的。
- en: Still, all of these settings are global; they’re always active. The danger is
    that adjusting one setting for one problematic case in the application might have
    negative side effects on some other procedure. Maintaining this balance can be
    difficult, so our recommendation is to map every entity association and collection
    as `FetchType.LAZY`, as mentioned before.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有这些设置都是全局性的；它们始终处于激活状态。危险在于，为了解决应用中的一个特定问题而调整一个设置可能会对其他一些程序产生负面影响。保持这种平衡可能很困难，因此我们的建议是，如前所述，将每个实体关联和集合映射为
    `FetchType.LAZY`。
- en: A better approach is to *dynamically* use eager fetching and `JOIN` operations
    only when needed, for a particular procedure.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是动态地使用 eager fetching 和 `JOIN` 操作，仅在需要时，针对特定程序。
- en: 12.2.6 Dynamic eager fetching
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.6 动态 eager fetching
- en: 'As in the previous sections, let’s say we have to check the `username` of each
    `Item#seller`. With a lazy global fetch plan, we can load the needed data for
    this procedure and apply a dynamic eager fetch strategy in a query:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所述，假设我们必须检查每个 `Item#seller` 的 `username`。在有懒加载全局计划的情况下，我们可以加载此程序所需的数据，并在查询中应用动态
    eager 加载策略：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Ⓐ Apply a dynamic eager strategy in a query.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 在查询中应用动态 eager 策略。
- en: Ⓑ Detach all.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 分离所有。
- en: Ⓒ Hibernate followed the eager fetch plan; all data is available in detached
    state.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ Hibernate遵循了 eager fetch 计划；所有数据在分离状态下都是可用的。
- en: 'The important keywords in this JPQL query are `join fetch`, telling Hibernate
    to use a SQL `JOIN` (an `INNER JOIN`, actually) to retrieve the `seller` of each
    `Item` in the same query. The same query can be expressed with the `CriteriaQuery`
    API instead of a JPQL string:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 JPQL 查询中，重要的关键字是 `join fetch`，告诉 Hibernate 使用 SQL `JOIN`（实际上是 `INNER JOIN`）在同一查询中检索每个
    `Item` 的 `seller`。相同的查询可以用 `CriteriaQuery` API 来表达，而不是 JPQL 字符串：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Ⓐ Apply an eager strategy in a query dynamically constructed with the `CriteriaQuery`
    API.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 在使用 `CriteriaQuery` API 动态构建的查询中应用 eager 策略。
- en: Ⓑ Detach all.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 分离所有。
- en: Ⓒ Hibernate followed the eager fetch plan; all data is available in detached
    state.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ Hibernate 遵循了 eager 获取计划；所有数据都在分离状态下可用。
- en: 'Dynamic eager join fetching also works for collections. Here we load all `bids`
    of each `Item`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 动态 eager join 获取也适用于集合。在这里，我们加载每个 `Item` 的所有 `bids`：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Ⓐ Apply a dynamic eager strategy in a query.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 在查询中应用动态 eager 策略。
- en: Ⓑ Detach all.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 分离所有。
- en: Ⓒ Hibernate followed the eager fetch plan; all data is available in detached
    state.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ Hibernate 遵循了 eager 获取计划；所有数据都在分离状态下可用。
- en: 'Now let’s do the same with the `CriteriaQuery` API:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们用 `CriteriaQuery` API 做同样的事情：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Ⓐ Apply an eager strategy in a query dynamically constructed with the `CriteriaQuery`
    API.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 在使用 `CriteriaQuery` API 动态构建的查询中应用 eager 策略。
- en: Ⓑ Detach all.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 分离所有。
- en: Ⓒ Hibernate followed the eager fetch plan; all data is available in detached
    state.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ Hibernate 遵循了 eager 获取计划；所有数据都在分离状态下可用。
- en: Note that for collection fetching, a `LEFT OUTER JOIN` is necessary, because
    we also want rows from the `ITEM` table if there are no `bids`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于集合获取，需要 `LEFT OUTER JOIN`，因为我们还希望在没有 `bids` 的情况下从 `ITEM` 表中获取行。
- en: Writing queries by hand isn’t the only available option if we want to override
    the global fetch plan of the domain model dynamically. We can write *fetch profiles*
    declaratively.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想动态地覆盖域模型的全局获取计划，手动编写查询并不是唯一的选择。我们可以声明性地编写 *获取配置文件*。
- en: 12.3 Using fetch profiles
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 使用获取配置文件
- en: 'Fetch profiles complement the fetching options in the query languages and APIs.
    They allow us to maintain the profile definitions in either XML or annotation
    metadata. Early Hibernate versions didn’t have support for special fetch profiles,
    but today Hibernate supports the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 获取配置文件补充了查询语言和 API 中的获取选项。它们允许我们将配置文件定义维护在 XML 或注解元数据中。早期 Hibernate 版本没有特殊获取配置文件的支持，但今天
    Hibernate 支持以下内容：
- en: '*Fetch profiles*—A proprietary API based on the declaration of the profile
    with `@org.hibernate.annotations.FetchProfile` and execution with `Session #enableFetchProfile()`.
    This simple mechanism currently supports overriding lazy-mapped entity associations
    and collections selectively, enabling a `JOIN` eager fetching strategy for a particular
    unit of work.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取配置文件*——一个基于使用 `@org.hibernate.annotations.FetchProfile` 声明配置文件并使用 `Session
    #enableFetchProfile()` 执行的专有 API。这种简单的机制目前支持有选择地覆盖延迟映射的实体关联和集合，为特定的工作单元启用 `JOIN`
    eager 获取策略。'
- en: '*Entity graphs*—Specified in JPA 2.1, we can declare a graph of entity attributes
    and associations with the `@EntityGraph` annotation. This fetch plan, or a combination
    of plans, can be enabled as a hint when executing `EntityManager #find()` or queries
    (JPQL, criteria). The provided graph controls *what* should be loaded; unfortunately,
    it doesn’t control *how* it should be loaded.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实体图*——在 JPA 2.1 中指定，我们可以使用 `@EntityGraph` 注解声明实体属性和关联的图。这个获取计划，或计划的组合，可以在执行
    `EntityManager #find()` 或查询（JPQL、criteria）时作为提示启用。提供的图控制*应该加载什么*；不幸的是，它不控制*如何加载*。'
- en: It’s fair to say that there is room for improvement here, and we expect future
    versions of Hibernate and JPA to offer a unified and more powerful API.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，这里还有改进的空间，我们期待 Hibernate 和 JPA 的未来版本提供统一且更强大的 API。
- en: We can externalize JPQL and SQL statements and move them to metadata. A JPQL
    query *is* a declarative (named) fetch profile; what we’re missing is the ability
    to overlay different plans easily on the same base query. We’ve seen some creative
    solutions with string manipulation that are best avoided. With criteria queries,
    on the other hand, we already have the full power of Java available to organize
    the query-building code. The value of entity graphs is being able to reuse fetch
    plans across any kind of query.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 JPQL 和 SQL 语句外部化并将它们移动到元数据中。一个 JPQL 查询*是*一个声明性（命名）的获取配置文件；我们所缺少的是在相同的基查询上轻松叠加不同计划的的能力。我们已经看到了一些通过字符串操作实现的创造性解决方案，但最好避免使用。另一方面，使用条件查询，我们已经有
    Java 的全部能力来组织查询构建代码。实体图的价值在于能够在任何类型的查询中重用获取计划。
- en: Let’s talk about Hibernate fetch profiles first and how we can override a global
    lazy fetch plan for a particular unit of work.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先谈谈 Hibernate 获取配置文件以及我们如何覆盖特定工作单元的全局延迟获取计划。
- en: 12.3.1 Declaring Hibernate fetch profiles
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.1 声明 Hibernate 获取配置文件
- en: 'Hibernate fetch profiles are global metadata; they’re declared for the entire
    persistence unit. Although we could place the `@FetchProfile` annotation on a
    class, we prefer it as package-level metadata in a package-info.java file:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate 查询配置是全局元数据；它们为整个持久化单元声明。尽管我们可以在类上放置 `@FetchProfile` 注解，但我们更倾向于将其作为包级别的元数据放在
    `package-info.java` 文件中：
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Ⓐ Each profile has a name. This is a simple string isolated in a constant.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 每个配置文件都有一个名称。这是一个简单的字符串，被隔离在常量中。
- en: Ⓑ Each override in a profile names one entity association or collection.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 配置文件中的每个覆盖项命名一个实体关联或集合。
- en: Ⓒ `FetchMode.JOIN` means the property will be retrieved eagerly, via a `JOIN`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ `FetchMode.JOIN` 表示属性将通过连接方式被积极检索。
- en: The profiles can now be enabled for a unit of work. We need the Hibernate API
    to enable a profile. It’s then active for any operation in that unit of work.
    The `Item#seller` may be fetched with a join in the same SQL statement whenever
    an `Item` is loaded with this `EntityManager`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以为工作单元启用配置文件。我们需要 Hibernate API 来启用配置文件。这样，在该工作单元中的任何操作都会激活该配置文件。当使用此 `EntityManager`
    加载 `Item` 时，`Item#seller` 可以通过相同的 SQL 语句通过连接查询来获取。
- en: We can overlay another profile on the same unit of work. In the following example,
    the `Item#seller` and the `Item#bids` collections will be fetched with a join
    in the same SQL statement whenever an `Item` is loaded.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在相同的工作单元上覆盖另一个配置文件。在以下示例中，当加载 `Item` 时，`Item#seller` 和 `Item#bids` 集合将通过相同的
    SQL 语句通过连接查询来获取。
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Ⓐ The `Item#seller` is mapped lazily, so the default fetch plan only retrieves
    the `Item` instance.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `Item#seller` 被映射为延迟加载，因此默认查询计划仅检索 `Item` 实例。
- en: Ⓑ Fetch the `Item#seller` with a join in the same SQL statement whenever an
    `Item` is loaded with this `EntityManager`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓑ 当使用此 `EntityManager` 加载 `Item` 时，通过相同的 SQL 语句通过连接查询获取 `Item#seller`。
- en: Ⓒ Fetch `Item#seller` and `Item#bids` with a join in the same SQL statement
    whenever an `Item` is loaded.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓒ 当加载 `Item` 对象时，使用相同的 SQL 语句通过连接查询 `Item#seller` 和 `Item#bids`。
- en: Basic Hibernate fetch profiles can be an easy solution for fetching optimization
    in smaller or simpler applications. Starting with JPA 2.1, the introduction of
    *entity graphs* enables similar functionality in a standard fashion.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 Hibernate 查询配置可以是一个在小型或简单应用中优化查询的简单解决方案。从 JPA 2.1 版本开始，引入了 *实体图*，以标准方式实现了类似的功能。
- en: 12.3.2 Working with entity graphs
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.2 使用实体图
- en: 'An entity graph is a declaration of entity nodes and attributes, overriding
    or augmenting the default fetch plan when we execute an `EntityManager#find()`
    or put a hint on query operations. This is an example of a retrieval operation
    using an entity graph:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 实体图是实体节点和属性的声明，在执行 `EntityManager#find()` 或在查询操作上放置提示时，它覆盖或增强了默认的查询计划。这是一个使用实体图进行检索操作的示例：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Ⓐ The name of the entity graph we’re using is `Item`, and the hint for the `find()`
    operation indicates it should be the load graph. This means attributes that are
    specified by attribute nodes of the entity graph are treated as `FetchType.EAGER,`
    and attributes that aren’t specified are treated according to their specified
    or default `FetchType` in the mapping.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 我们正在使用的实体图名称是 `Item`，而 `find()` 操作的提示表明它应该是加载图。这意味着由实体图的属性节点指定的属性被视为 `FetchType.EAGER`，而没有指定的属性则根据映射中指定的或默认的
    `FetchType` 处理。
- en: 'The following code shows the declaration of this graph and the default fetch
    plan of the entity class:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了此图的声明和实体类的默认查询计划：
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Ⓐ Entity graphs in metadata have names and are associated with an entity class;
    they’re usually declared in annotations at the top of an entity class. We can
    alternatively put them in XML if we like. If we don’t give an entity graph a name,
    it gets the simple name of its owning entity class, which here is `Item`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ 元数据中的实体图有名称，并与实体类相关联；它们通常在实体类顶部使用注解声明。如果我们愿意，我们也可以将它们放在 XML 中。如果我们没有为实体图指定名称，它将获得其拥有实体类的简单名称，在这里是
    `Item`。
- en: 'If we don’t specify any attribute nodes in the graph, like the empty entity
    graph in the preceding example, the defaults of the entity class are used. In
    `Item`, all associations and collections are mapped lazily; this is the default
    fetch plan. Hence, what we’ve done so far makes little difference, and the `find()`
    operation without any hints will produce the same result: the `Item` instance
    is loaded, and the `seller`, `bids`, and `images` aren’t.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在图中没有指定任何属性节点，就像前面示例中的空实体图一样，则使用实体类的默认值。在 `Item` 中，所有关联和集合都被映射为懒加载；这是默认的抓取计划。因此，我们迄今为止所做的工作影响不大，没有任何提示的
    `find()` 操作将产生相同的结果：加载了 `Item` 实例，但 `seller`、`bids` 和 `images` 没有被加载。
- en: 'Alternatively, we can build an entity graph with an API:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 API 构建一个实体图：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is again an empty entity graph with no attribute nodes, given directly
    to a retrieval operation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个没有属性节点的空实体图，直接提供给检索操作。
- en: 'Let’s say we want to write an entity graph that changes the lazy default of
    `Item#seller` to eager fetching when it’s enabled:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要编写一个实体图，当启用时，将 `Item#seller` 的懒加载默认值更改为主动抓取：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can now enable this graph by name when we want the `Item` and the `seller`
    eagerly loaded:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们要将 `Item` 和 `seller` 主动加载时，我们可以通过名称启用此图：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we don’t want to hardcode the graph in annotations, we can build it with
    the API instead:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想在注解中硬编码图，我们可以使用 API 来构建它：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Ⓐ The `Item_` class belongs to the static metamodel. It is automatically generated
    by including the Hibernate JPA2 Metamodel Generator dependency in the project.
    Take a look back at section 3.3.4 for more details.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Ⓐ `Item_` 类属于静态元模型。它通过在项目中包含 Hibernate JPA2 Metamodel Generator 依赖项自动生成。有关更多详细信息，请参阅第
    3.3.4 节。
- en: 'So far we’ve seen only properties for the `find()` operation. Entity graphs
    can also be enabled for queries, as hints:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了 `find()` 操作的属性。实体图也可以作为提示启用查询。
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Entity graphs can be complex. The following declaration shows how to work with
    reusable subgraph declarations:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 实体图可能很复杂。以下声明显示了如何使用可重用的子图声明：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This entity graph, when enabled as a load graph when retrieving `Bid` instances,
    also triggers eager fetching of `Bid#bidder`, the `Bid#item`, and furthermore
    the `Item#seller` and all `Item#bids`. Although you’re free to name your entity
    graphs any way you like, we recommend that you develop a convention that everyone
    in your team can follow, and move the strings to shared constants.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为加载图启用以检索 `Bid` 实例时，此实体图还会触发 `Bid#bidder`、`Bid#item` 的主动抓取，以及进一步触发 `Item#seller`
    和所有 `Item#bids` 的主动抓取。尽管您可以自由地以任何方式命名您的实体图，但我们建议您开发一个团队中每个人都可以遵循的约定，并将字符串移动到共享常量中。
- en: 'With the entity graph API, the previous plan looks like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用实体图 API，之前的计划看起来是这样的：
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We’ve only seen entity graphs as *load graphs* so far. There is another option:
    we can enable an entity graph as a *fetch graph* with the `javax.persistence.fetchgraph`
    hint. If we execute a `find()` or query operation with a fetch graph, any attributes
    and collections not in the plan will be made `FetchType.LAZY`, and any nodes in
    the plan will be `FetchType.EAGER`. This effectively ignores all `FetchType` settings
    in the entity attribute and collection mappings.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了实体图作为 *加载图*。还有一个选项：我们可以使用 `javax.persistence.fetchgraph` 提示启用实体图作为
    *抓取图*。如果我们使用抓取图执行 `find()` 或查询操作，不在计划中的任何属性和集合将被设置为 `FetchType.LAZY`，而计划中的任何节点将被设置为
    `FetchType.EAGER`。这实际上忽略了实体属性和集合映射中所有的 `FetchType` 设置。
- en: 'Two weak points of the JPA entity graph operations are worth mentioning, because
    you’ll run into them quickly. First, you can only modify fetch plans, not the
    Hibernate fetch strategy (batch/subselect/join/select). Second, declaring an entity
    graph in annotations or XML isn’t fully type-safe: the attribute names are strings.
    The `EntityGraph` API at least is type-safe.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: JPA 实体图操作有两个弱点值得提及，因为您很快就会遇到。首先，您只能修改抓取计划，而不能修改 Hibernate 抓取策略（批量/子选择/连接/选择）。其次，在注解或
    XML 中声明实体图并不完全类型安全：属性名是字符串。至少 `EntityGraph` API 是类型安全的。
- en: Summary
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A fetch profile combines a fetch plan (identifying what data should be loaded)
    with a fetch strategy (how the data should be loaded), encapsulated in reusable
    metadata or code.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抓取配置将抓取计划（标识应加载哪些数据）与抓取策略（如何加载数据）结合起来，封装在可重用的元数据或代码中。
- en: You can create a global fetch plan and define which associations and collections
    should be loaded into memory at all times.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以创建一个全局抓取计划，并定义哪些关联和集合应该始终加载到内存中。
- en: You can define the fetch plan based on use cases, how to access associated entities
    and iterate through collections in the application, and which data should be available
    in detached state.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以根据用例定义获取计划，包括如何访问关联实体以及在应用中遍历集合，以及哪些数据应在分离状态下可用。
- en: You can select the right fetching strategy for the fetch plan. The goal is to
    minimize the number of SQL statements and the complexity of each SQL statement
    that must be executed.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以为获取计划选择合适的获取策略。目标是尽量减少必须执行的SQL语句的数量和每个SQL语句的复杂性。
- en: You can use fetching strategies especially to avoid the *n*+1 selects and Cartesian
    product problems.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用获取策略，特别是为了避免*n*+1次选择和笛卡尔积问题。
