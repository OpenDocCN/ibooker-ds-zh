- en: 11 Finding memory-related issues in an app’s execution
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 在应用程序执行中查找与内存相关的问题
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Sampling an execution to find memory allocation issues
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过采样执行以查找内存分配问题
- en: Profiling a part of the code to identify the root causes of memory allocation
    problems
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剖析代码的一部分以确定内存分配问题的根本原因
- en: Obtaining and reading heap dumps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取和读取堆转储
- en: Every app processes data, and to do this, the app needs to store that data somewhere
    while working with it. The app allocates part of the system’s memory to work with
    the data, but the memory isn’t an infinite resource. All the apps running on a
    system share a finite amount of memory space that the system provides. If an app
    doesn’t wisely manage its allocated memory, it can run out of it, making it impossible
    to continue its work. Even if the app doesn’t run out of memory, using too much
    can make the app slower, so faulty memory allocation can cause performance issues.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都会处理数据，为了完成这项工作，应用程序需要在处理数据的同时将其存储在某个地方。应用程序会分配系统内存的一部分来处理数据，但内存并不是无限的资源。系统上运行的所有应用程序共享系统提供的有限内存空间。如果一个应用程序没有明智地管理其分配的内存，它可能会耗尽内存，使其无法继续工作。即使应用程序没有耗尽内存，使用过多的内存也会使应用程序变慢，因此错误的内存分配可能会引起性能问题。
- en: An app can run slower if it doesn’t optimize its allocation of data in the memory.
    If the app requires more memory than the system provides, the app will stop working
    and throw an error. Thus, side effects of poor memory management are slowness
    in execution and even total app crashes. It’s essential we write app capabilities
    that make the best use of their allocated memory.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序没有优化其在内存中的数据分配，它可能会运行得更慢。如果应用程序需要的内存超过了系统提供的内存，应用程序将停止工作并抛出错误。因此，不良内存管理的副作用是执行缓慢甚至整个应用程序崩溃。我们编写应用程序功能以最大限度地利用其分配的内存是至关重要的。
- en: If the app doesn’t allocate the data it processes in an optimized way, it may
    force the GC to run more often, so the app will become more CPU consumptive.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序没有以优化的方式分配其处理的数据，它可能会迫使垃圾回收器更频繁地运行，因此应用程序将变得更加CPU消耗。
- en: '![](../../OEBPS/Images/icon_guy4.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_guy4.png)'
- en: An app should be as efficient as possible in managing its resources. When we
    discuss the resources of an app, we mainly think about CPU (processing power)
    and memory. In chapters 7 to 10, we discussed how to investigate issues with CPU
    consumption. In this chapter, we’ll focus on identifying problems with how an
    app allocates data in memory.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应该尽可能高效地管理其资源。当我们讨论应用程序的资源时，我们主要考虑CPU（处理能力）和内存。在第7章到第10章中，我们讨论了如何调查CPU消耗问题。在本章中，我们将专注于识别应用程序在内存中分配数据方面的问题。
- en: We’ll start the chapter by discussing execution sampling and profiling for memory
    usage statistics in section 11.1\. You’ll learn how to identify if an app has
    issues with memory usage and how to find which part of the application causes
    them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第11.1节中讨论执行采样和剖析内存使用统计，本章将开始讨论。您将学习如何确定应用程序是否有内存使用问题以及如何找到导致这些问题的应用程序部分。
- en: Then, in section 11.2, we’ll discuss how to get a complete dump (i.e., heap
    dump) of the allocated memory to analyze its contents. In certain cases, when
    the app crashes entirely because of faulty memory management, you cannot profile
    the execution. But getting and analyzing the contents of the app’s allocated memory
    at the moment the problem appears can help you to identify the problem’s root
    cause.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第11.2节中，我们将讨论如何获取完整的转储（即堆转储）以分析其内容。在某些情况下，当应用程序完全因为错误的内存管理而崩溃时，您无法对执行进行剖析。但是，在问题出现时获取和分析应用程序分配内存的内容可以帮助您确定问题的根本原因。
- en: You need to remember a few basic concepts about the way in which a Java app
    allocates and uses memory before continuing with this chapter. If you need a refresher,
    appendix E provides all the information you need to properly understand the ideas
    in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章之前，您需要记住一些关于Java应用程序如何分配和使用内存的基本概念。如果您需要复习，附录E提供了您理解本章中思想所需的所有信息。
- en: 11.1 Sampling and profiling for memory issues
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1 内存问题的采样和剖析
- en: In this section, we use a small application that simulates a faulty implemented
    capability that uses too much of the allocated memory. We use this app to discuss
    investigation techniques you can use to identify issues with memory allocation
    or places in code that can be optimized to use the system’s memory more efficiently.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用一个小应用程序来模拟一个错误实现的、使用过多分配内存的功能。我们使用此应用程序来讨论你可以使用的调查技术，以识别内存分配问题或代码中可以优化以更有效地使用系统内存的地方。
- en: Suppose you have a real application, and you notice that some feature runs slowly.
    You use the techniques we discussed in chapter 6 to analyze resource consumption
    and find that although the app doesn’t “work” very often (consume CPU resources),
    it uses a large amount of memory. When an app uses too much memory, the JVM can
    trigger the garbage collector (GC), which will further consume CPU resources also.
    Remember that the GC is the mechanism that automatically deallocates unneeded
    data from memory (see appendix E for a refresher).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个真实的应用程序，并且你注意到某些功能运行缓慢。你使用我们在第六章中讨论的技术来分析资源消耗，并发现尽管应用程序并不经常“工作”（消耗 CPU
    资源），但它使用了大量的内存。当应用程序使用过多内存时，JVM 可以触发垃圾收集器（GC），这将进一步消耗 CPU 资源。记住，GC 是自动从内存中释放不再需要的数据的机制（参见附录
    E 以获取复习资料）。
- en: Look at figure 11.1\. When discussing how to analyze resource consumption in
    chapter 6, we used the Monitor tab in VisualVM to observe what resources the app
    consumes. You can use the memory widget in this tab to find when the app uses
    an extensive amount of memory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查看图 11.1。在第六章讨论如何分析资源消耗时，我们使用了 VisualVM 的“监视器”选项卡来观察应用程序消耗了哪些资源。您可以使用此选项卡中的内存小部件来查找应用程序何时使用大量内存。
- en: '![](../../OEBPS/Images/CH11_F01_Spilca3.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F01_Spilca3.png)'
- en: Figure 11.1 The memory widget in the Monitor tab in VisualVM helps you to identify
    if the app spends more memory than usual at any given time. Often, widgets in
    the Monitor tab, such as CPU and memory consumption, give us clues on how to continue
    our investigation. When we see that the app consumes an abnormal amount of memory,
    we may decide to continue with memory profiling the execution.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 VisualVM 的“监视器”选项卡中的内存小部件可以帮助你确定应用程序在任意给定时间是否比平常消耗了更多的内存。通常，监视器选项卡中的小部件，如
    CPU 和内存消耗，会给我们提供如何继续调查的线索。当我们看到应用程序消耗了异常大量的内存时，我们可能会决定继续进行内存分析。
- en: The application we use in this chapter is in project da-ch11-ex1\. This small
    web application exposes an endpoint. When calling this endpoint, we give a number,
    and the endpoint creates that many object instances. We basically make a request
    to create one million objects (a large enough number for our experiment) and then
    look at what a profiler tells us about this request execution. This endpoint execution
    simulates what happens in a real-world situation when a given app capability spends
    a lot of the app’s memory resources (figure 11.2).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们使用的应用程序位于项目 da-ch11-ex1 中。这个小型 Web 应用程序暴露了一个端点。当调用此端点时，我们提供一个数字，端点会创建相应数量的对象实例。我们基本上发送一个请求来创建一百万个对象（足够大的数字以供我们的实验使用），然后查看分析器关于此请求执行的信息。此端点执行模拟了在现实世界中，当某个应用程序能力消耗大量应用程序内存资源时会发生什么（图
    11.2）。
- en: '![](../../OEBPS/Images/CH11_UN02_Spilca3.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_UN02_Spilca3.png)'
- en: '![](../../OEBPS/Images/CH11_F02_Spilca3.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F02_Spilca3.png)'
- en: Figure 11.2 When we call the endpoint exposed by the provided project da-ch11-ex1,
    the app creates a large number of instances that consume a considerable part of
    the app’s memory. We’ll analyze this scenario using a profiler.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 当我们调用由提供的项目 da-ch11-ex1 暴露的端点时，应用程序创建了大量实例，消耗了应用程序相当一部分内存。我们将使用分析器分析此场景。
- en: 'To start the project, follow these steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动项目，请按照以下步骤操作：
- en: Start project da-ch11-ex1.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动项目 da-ch11-ex1。
- en: Start VisualVM.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 VisualVM。
- en: Select a process for project da-ch11-ex1 in VisualVM.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VisualVM 中选择项目 da-ch11-ex1 的进程。
- en: Go to the Monitor tab in VisualVM.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 VisualVM 的“监视器”选项卡。
- en: Call the /`products/1000000` endpoint.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `/`products/1000000` 端点。
- en: Observe the memory widget in the Memory tab in VisualVM.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VisualVM 的“内存”选项卡中观察内存小部件。
- en: 'In the Monitor tab in the memory widget, you can see that the app uses a lot
    of memory resources. The widget looks similar to figure 11.1\. What should we
    do when we suspect some app capability doesn’t optimally use the memory resources?
    The investigation process follows two major steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在“监视器”选项卡中的内存小部件中，你可以看到应用程序使用了大量的内存资源。小部件看起来类似于图 11.1。当我们怀疑某些应用程序能力没有最佳地使用内存资源时，我们应该怎么做？调查过程遵循两个主要步骤：
- en: Use memory sampling to get details about the object instances the app stores.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内存采样来获取应用程序存储的对象实例的详细信息。
- en: Use memory profiling (instrumentation) to get additional details about a specific
    part of the code in execution.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内存分析（仪表化）来获取执行中代码特定部分的额外详细信息。
- en: 'Let’s follow the same approach you learned in chapters 7 to 9 for CPU resource
    consumption: get a high-level view of what happens using sampling. To sample an
    app execution for memory usage, select the Sampler tab in VisualVM. Then select
    the Memory button to start a memory usage sampling session. Call the endpoint
    and wait for the execution to end. The VisualVM screen will display the objects
    the app allocates.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遵循在第7章到第9章中学到的相同方法来分析CPU资源消耗：使用采样来获取发生情况的高级视图。为了对应用程序执行进行内存使用采样，请选择VisualVM中的“采样器”选项卡。然后选择“内存”按钮以启动内存使用采样会话。调用端点并等待执行结束。VisualVM屏幕将显示应用程序分配的对象。
- en: 'We are looking for what occupies most of the memory. In most cases, that will
    be one of these two situations:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在寻找占用最多内存的内容。在大多数情况下，这将是以下两种情况之一：
- en: Many object instances of certain types are created and fill up the memory (this
    is what happens in our scenario).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多特定类型的对象实例被创建并填满了内存（这就是我们场景中发生的情况）。
- en: There are not many instances of a certain type, but each instance is very large.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些类型的实例不多，但每个实例都非常大。
- en: 'Many instances filling up the allocated memory makes sense, but how could a
    small number of instances do this? Imagine this scenario: your app processes large
    video files. The app loads maybe two or three files at a time, but since they
    are large, they fill the allocated memory. A developer can analyze whether the
    capability can be optimized. Maybe the app doesn’t need the full files loaded
    in memory but just fragments of them at a time.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 许多实例填满分配的内存是有意义的，但少数实例是如何做到这一点的呢？想象一下这个场景：你的应用程序处理大视频文件。应用程序一次可能加载两三个文件，但由于它们很大，它们填满了分配的内存。开发者可以分析是否可以优化这种能力。也许应用程序不需要一次性将整个文件加载到内存中，而只需要加载它们的一部分。
- en: When we start our investigation, we don’t know which scenario we’ll fall into.
    I usually sort, in descending order, by the amount of memory occupied and then
    by the number of instances. Notice in figure 11.3 that VisualVM shows you the
    memory spent and the number of instances for each sampled type. You need to sort,
    in descending order, by the second and the third columns in the table.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始调查时，我们不知道会陷入哪种场景。我通常会按内存占用量降序排列，然后按实例数量排列。注意图11.3中，VisualVM显示了每种采样类型的内存占用量和实例数量。您需要按表格中的第二列和第三列降序排列。
- en: In figure 11.3, you clearly see that I sorted the table in descending order
    by Live Bytes (space occupied). We can then look for the first type in our app’s
    codebase that appears in the table. Don’t look for primitives, strings, arrays
    of primitives, or arrays of strings. These are usually at the top since they are
    created as a side effect. However, in most cases, they don’t provide any clues
    about the problem.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在图11.3中，你可以清楚地看到我按“活动字节”（占用空间）降序排列了表格。然后我们可以查找我们应用程序代码库中出现在表格中的第一个类型。不要寻找原始数据类型、字符串、原始数据类型的数组或字符串数组。这些通常位于顶部，因为它们作为副作用被创建。然而，在大多数情况下，它们不会提供任何关于问题的线索。
- en: '![](../../OEBPS/Images/CH11_F03_Spilca3.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图11.3](../../OEBPS/Images/CH11_F03_Spilca3.png)'
- en: Figure 11.3 We sort the sampled results in descending order by memory occupied.
    This way, we can see which objects consume most of the memory. We don’t usually
    look for primitives, strings, and arrays of strings or JDK objects in general.
    We are mostly interested in finding the object, directly related to our codebase,
    that is causing the problem. In this case, the `Product` type (which is part of
    our codebase) occupies a large part of the memory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 我们按内存占用量降序排列采样结果。这样，我们可以看到哪些对象消耗了大部分内存。我们通常不会寻找原始数据类型、字符串、字符串数组或通常的JDK对象。我们主要感兴趣的是找到与我们的代码库直接相关的对象，它是导致问题的原因。在这种情况下，`Product`类型（它是我们代码库的一部分）占用了大量内存。
- en: In figure 11.3, we clearly see that type `Product` is causing trouble. It occupies
    a large part of the allocated memory, and in the Live Objects column, we see that
    the app created one million instances of this type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在图11.3中，我们可以清楚地看到类型`Product`引起了问题。它占用了分配内存的大部分，在“活动对象”列中，我们看到应用程序创建了该类型的一百万个实例。
- en: The profiling tool names them Live Objects because sampling only shows you the
    instances that still exist in the memory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 分析工具将它们命名为“活动对象”，因为采样只显示你内存中仍然存在的实例。
- en: '![](../../OEBPS/Images/icon_guy4.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_guy4.png)'
- en: If you need the total number of instances of the type created throughout execution,
    you must use profiling (instrumentation) techniques. We’ll do this later in this
    chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在整个执行过程中创建的类型实例总数，您必须使用剖析（仪器化）技术。我们将在本章后面进行此操作。
- en: 'This app is just an example, but in a real-world app, simply sorting by the
    occupied space may not be enough. We need to figure out whether the problem is
    a large number of instances or whether each instance takes a lot of space. I know
    what you’re thinking: isn’t it clear in this case? Yes, but in a real-world app
    it may not be, so I always recommend that developers also sort in descending order
    by the number of instances to make sure. Figure 11.4 shows the sampled data sorted
    in descending order by the number of instances the app created for each type.
    Again, type `Product` is at the top.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用只是一个示例，但在现实世界的应用中，仅仅按占用空间排序可能不够。我们需要弄清楚问题是不是由于实例数量过多，或者每个实例是否占用了大量空间。我知道你在想什么：在这种情况下不是很明显吗？是的，但在现实世界的应用中可能不是这样，所以我总是建议开发者也按实例数量降序排序以确保。
- en: '![](../../OEBPS/Images/CH11_F04_Spilca3.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F04_Spilca3.png)'
- en: Figure 11.4 We can sort the sampled results by the number of instances (live
    objects). This gives us clues on whether some capability creates a large number
    of objects that are negatively affecting the memory allocation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 我们可以按实例数量（活动对象）对采样结果进行排序。这让我们可以了解某些功能是否创建了大量的对象，这些对象对内存分配产生了负面影响。
- en: 'Sometimes sampling is enough to help you identify the problem. But what if
    you can’t figure out what part of the app creates these objects? When you can’t
    find the problem just by sampling the execution, your next step is profiling (instrumentation).
    Profiling gives you more details, including what part of the code created the
    potentially problematic instances. But remember the rule of thumb: when you use
    profiling, you need to first know what to profile. That’s why we always begin
    by sampling.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有时采样就足以帮助您识别问题。但如果您无法通过采样执行来找出创建这些对象的应用部分呢？当您仅通过采样执行无法找到问题时，您的下一步是进行剖析（仪器化）。剖析提供了更多细节，包括代码的哪个部分创建了可能有问题实例。但请记住经验法则：当您使用剖析时，您需要首先知道要剖析什么。这就是为什么我们总是从采样开始。
- en: Since we know the problem is with the `Product` type, we will profile for it.
    Like you did in chapters 7 to 9, you must specify which part of the app you want
    to profile using an expression. In figure 11.5, I profile only for the `Product`
    type. I do this by using the fully qualified name (package and class name) of
    the class in the Memory settings textbox on the right side of the window.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道问题是出在`Product`类型上，我们将对其进行分析。就像在第7章到第9章中所做的那样，您必须使用表达式指定您想要剖析的应用部分。在图11.5中，我仅对`Product`类型进行了剖析。我通过在窗口右侧的内存设置文本框中使用该类的完全限定名（包和类名）来完成此操作。
- en: '![](../../OEBPS/Images/CH11_F05_Spilca3.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F05_Spilca3.png)'
- en: Figure 11.5 To profile for memory allocation, first specify which packages or
    classes you want to profile, and then start the profiling by pressing the Memory
    button. The profiler will give you relevant details about the profile types, including
    used memory, number of instances, the total number of allocated objects, and the
    number of GC generations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 要对内存分配进行剖析，首先指定您想要剖析的包或类，然后通过按内存按钮开始剖析。剖析器将为您提供有关剖析类型的相关细节，包括使用的内存、实例数量、分配对象的总数以及GC代数。
- en: 'Just as in the case of CPU profiling (chapter 8), you can profile for more
    types at a time or even specify entire packages. Some of the most commonly used
    expressions are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 就像第8章中CPU剖析的情况一样，您可以一次对更多类型进行剖析，甚至可以指定整个包。以下是一些最常用的表达式：
- en: '*Strict-type, fully qualified name* (*e.g.*, `com.example.model.Product`)—Only
    searches for that specific type'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*严格类型，完全限定名*（例如，`com.example.model.Product`）—仅搜索该特定类型'
- en: '*Types in a given package* (*e.g.*, `com.example.model.*`)—Only searches for
    types declared in the package `com.example.model` but not in its subpackages'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*给定包中的类型*（例如，`com.example.model.*`）—仅搜索在包`com.example.model`中声明的类型，但不包括其子包'
- en: '*Types in a given package and its subpackages* (*e.g.*, `com.example.**`)—Searches
    in the given package and all its subpackages'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*给定包及其子包中的类型*（例如，`com.example.**`）—在指定的包及其所有子包中进行搜索'
- en: Always remember to restrict the types you profile as much as possible. If you
    know Product causes the problem, then it makes sense to profile only this type.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住尽可能限制您要分析的类型。如果您知道Product导致了问题，那么只分析这个类型是有意义的。
- en: '![](../../OEBPS/Images/icon_guy4.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_guy4.png)'
- en: In addition to the live objects (which are the instances that still exist in
    memory for that type), you will get the total number of instances of that type
    that the app created. Moreover, you will see how many times those instances “survived”
    the GC (what we call *generations*).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了仍在内存中存在的活动对象（即该类型的实例）之外，您还将获得应用程序创建的该类型实例的总数。此外，您还将看到这些实例“存活”了GC（我们称之为*代数*）多少次。
- en: These details are valuable, but finding what part of the code creates the objects
    is often even more useful. As shown in figure 11.6, for each profiled type, the
    tool displays where the instances were created. Click the plus sign (+) on the
    left side of the line in the table. This capability quickly shows you the root
    cause of the problem.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些细节很有价值，但找到创建对象的代码部分通常更有用。如图11.6所示，对于每个分析类型，工具显示实例是在哪里创建的。点击表格中该行左侧的加号（+）。此功能可以快速显示问题的根本原因。
- en: '![](../../OEBPS/Images/CH11_F06_Spilca3.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F06_Spilca3.png)'
- en: Figure 11.6 The profiler shows the stack trace of the code that created the
    instances of each of the profiled types. This way, you can easily identify what
    part of the app created the problematic instances.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 分析器显示了创建每个分析类型实例的代码的堆栈跟踪。这样，您可以轻松地识别出应用程序的哪个部分创建了有问题的实例。
- en: 11.2 Using heap dumps to find memory leaks
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2 使用堆转储查找内存泄漏
- en: If the app is running, you can profile to identify any capability that can be
    optimized. But what if the app crashed and you suspect this happened due to a
    memory allocation issue? In most cases, app crashes are caused by capabilities
    with memory allocation problems such as memory leaks—the app doesn’t deallocate
    the objects it creates in memory even after it doesn’t need them. Since the memory
    is not infinite, continuously allocating objects will fill the memory at some
    point, causing the app to crash. In a JVM app, this is signaled with an `OutOfMemoryError`
    thrown at run time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序正在运行，您可以分析以识别任何可以优化的功能。但假设应用程序崩溃，并且您怀疑这是由于内存分配问题导致的？在大多数情况下，应用程序崩溃是由具有内存分配问题的功能（如内存泄漏）引起的——应用程序在不需要时不会在内存中释放它创建的对象。由于内存不是无限的，持续分配对象最终会填满内存，导致应用程序崩溃。在JVM应用程序中，这会在运行时通过抛出`OutOfMemoryError`来表示。
- en: If the app is not running, you can’t attach a profiler to investigate the execution.
    But, even so, you have other alternatives to investigate the problem. You can
    use a *heap dump*, which is a snapshot of what the heap memory looked like when
    the app crashed. Although you can collect a heap dump anytime, it is most useful
    when you can’t profile the app for some reason—maybe because the app crashed or
    you simply don’t have access to profile the process and you want to determine
    whether it suffers from any memory allocation issues.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序没有运行，您无法附加分析器来调查执行情况。但即便如此，您还有其他替代方案来调查问题。您可以使用*堆转储*，这是应用程序崩溃时堆内存的快照。尽管您可以在任何时候收集堆转储，但它最有用的时候是您无法因为某些原因分析应用程序——可能是因为应用程序崩溃，或者您根本无法访问分析进程，而您想确定它是否遭受了任何内存分配问题。
- en: In the next section, we’ll discuss three possible ways to get a heap dump, and
    in section 11.2.2, I’ll show you how to use the heap dump to identify memory allocation
    issues and their root causes. In section 11.2.3, we’ll discuss a more advanced
    way of reading a heap dump using a query language called Object Query Language
    (OQL). OQL is similar to SQL, but instead of querying a database, you use OQL
    to query the data in a heap dump.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论三种获取堆转储的可能方法，在11.2.2节中，我将向您展示如何使用堆转储来识别内存分配问题和它们的根本原因。在11.2.3节中，我们将讨论使用一种称为对象查询语言（OQL）的查询语言读取堆转储的更高级方法。OQL类似于SQL，但您不是查询数据库，而是使用OQL查询堆转储中的数据。
- en: 11.2.1 Obtaining a heap dump
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.1 获取堆转储
- en: 'In this section, we’ll discuss three ways to generate a heap dump:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论三种生成堆转储的方法：
- en: Configure the application to generate one automatically in a given location
    when the app crashes because of a memory issue.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置应用程序，在应用程序因内存问题崩溃时自动在指定位置生成堆转储。
- en: Use a profiling tool (such as VisualVM).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分析工具（如VisualVM）。
- en: Use a command-line tool (such as `jcmd` or `jmap`).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行工具（如`jcmd`或`jmap`）。
- en: You can even get a heap dump programmatically. Some frameworks have capabilities
    that can generate a heap dump, which allow developers to integrate app-monitoring
    tools. To learn more about this subject, see the `HotSpotDiagnosticMXBean` class
    in the Java official API documentation ([http://mng.bz/19XZ](http://mng.bz/19XZ)).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以以编程方式获取堆转储。一些框架具有生成堆转储的能力，这允许开发者集成应用程序监控工具。要了解更多关于这个主题的信息，请参阅 Java 官方 API
    文档中的 `HotSpotDiagnosticMXBean` 类（[http://mng.bz/19XZ](http://mng.bz/19XZ)）。
- en: 'Project da-ch11-ex1 implements an endpoint you can use to generate the heap
    dump using the `HotSpotDiagnosticMXBean` class. Calling this endpoint using cURL
    or Postman will create a dump file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 项目 da-ch11-ex1 实现了一个端点，您可以使用 `HotSpotDiagnosticMXBean` 类生成堆转储。使用 cURL 或 Postman
    调用此端点将创建转储文件：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Configuring an app to generate a heap dump when it encounters a memory issue
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 配置应用程序在遇到内存问题时生成堆转储
- en: 'Developers often use a heap dump to investigate an app crash when they suspect
    faulty memory allocation is causing a problem. For this reason, apps are most
    often configured to generate a heap dump of what the memory looked like when the
    app crashed. You should always configure an app to generate a heap dump when it
    stops due to a memory allocation problem. Fortunately, the configuration is easy.
    You just need to add a couple of JVM arguments when the app starts:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者经常使用堆转储来调查应用程序崩溃，当他们怀疑错误的内存分配导致问题时。因此，应用程序通常配置为在应用程序崩溃时生成内存外观的堆转储。您应该始终配置应用程序在由于内存分配问题而停止时生成堆转储。幸运的是，配置很简单。您只需在应用程序启动时添加几个
    JVM 参数：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first argument, `-XX:+HeapDumpOnOutOfMemoryError`, tells the app to generate
    a heap dump when it encounters an `OutOfMemoryError` (the heap gets full). The
    second argument, `XX:HeapDumpPath=heapdump.bin`, specifies the path in the filesystem
    where the dump will be stored. In this case, the file containing the heap dump
    will be named heapdump.bin and will be located close to the executable app, from
    the root of the `classpath` (because we used a relative path). Make sure the process
    has “write” privileges on this path to be able to store the file in the given
    location.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数 `-XX:+HeapDumpOnOutOfMemoryError` 告诉应用程序在遇到 `OutOfMemoryError`（堆已满）时生成堆转储。第二个参数
    `XX:HeapDumpPath=heapdump.bin` 指定了在文件系统中存储转储的路径。在这种情况下，包含堆转储的文件将命名为 heapdump.bin，并将位于可执行应用程序附近，从
    `classpath` 的根目录（因为我们使用了相对路径）。确保进程具有在此路径上的“写入”权限，以便能够将文件存储在指定位置。
- en: 'The following snippet shows the full command for running an app:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了运行应用程序的完整命令：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We’ll use a demo app named da-ch11-ex2 to demonstrate this approach. You can
    find this app in the projects provided with the book. The app in the following
    listing continuously adds instances of type `Product` to a list until the memory
    fills.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用名为 da-ch11-ex2 的演示应用程序来演示这种方法。您可以在本书提供的项目中找到此应用程序。以下列表中的应用程序会持续向列表中添加 `Product`
    类型的实例，直到内存填满。
- en: Listing 11.1 Generating a large numbers of instances that can’t be deallocated
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 11.1 生成大量无法释放的实例
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The loop iterates forever.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 循环无限迭代。
- en: ❷ Adds instances to the list until the memory gets full
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 向列表中添加实例，直到内存填满
- en: 'The next code snippet shows what the simple `Product` type looks like:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了简单的 `Product` 类型的外观：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Maybe you’re wondering why there is a random name for the product instances.
    We’ll need that later when we discuss reading a heap dump in section 11.2.2\.
    For the moment, we’re only interested in how to generate a heap dump to figure
    out why this app is filling its heap memory in seconds.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您想知道为什么产品实例有一个随机名称。我们将在 11.2.2 节中讨论读取堆转储时需要它。目前，我们只对如何生成堆转储以找出为什么这个应用程序在几秒钟内填满其堆内存感兴趣。
- en: '![](../../OEBPS/Images/CH11_F07_Spilca3.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH11_F07_Spilca3.png)'
- en: Figure 11.7 You can configure the JVM arguments from your IDE. Add the values
    in the Run/Debug Configurations before starting the application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 您可以从您的 IDE 中配置 JVM 参数。在启动应用程序之前，在运行/调试配置中添加这些值。
- en: You can use the IDE to run the app and set the arguments. Figure 11.7 shows
    you how to set the JVM arguments in IntelliJ. I also added the `-Xmx` argument
    to limit the heap memory of the app to just 100 MB. That will make the heap dump
    file smaller and our example easier.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 IDE 运行应用程序并设置参数。图 11.7 展示了如何在 IntelliJ 中设置 JVM 参数。我还添加了 `-Xmx` 参数来限制应用程序的堆内存仅为
    100 MB。这将使堆转储文件更小，并且我们的示例更容易理解。
- en: When you run the application, wait a moment, and the app will crash. With only
    100 MB of heap space, the memory shouldn’t take more than a few seconds to get
    full. The project folder contains a file named heapdump.bin, which includes all
    the details about the data in the heap the moment the app stopped. You can open
    this file with VisualVM to analyze it, as presented in figure 11.8.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用时，稍等片刻，应用将会崩溃。只有 100 MB 的堆空间，内存不应该超过几秒钟就满了。项目文件夹中包含一个名为 heapdump.bin 的文件，其中包含应用停止时的堆中所有数据的详细信息。你可以使用
    VisualVM 打开此文件进行分析，如图 11.8 所示。
- en: '![](../../OEBPS/Images/CH11_F08_Spilca3.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F08_Spilca3.png)'
- en: Figure 11.8 You can use VisualVM to open the heap dump file for analysis. Use
    the Load button in the menu to find the file. Open the file, and VisualVM will
    display the heap dump as a tab.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 你可以使用 VisualVM 打开堆转储文件进行分析。使用菜单中的“加载”按钮来查找文件。打开文件，VisualVM 将显示堆转储作为一个标签页。
- en: Obtaining a heap dump using a profiler
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分析器获取堆转储
- en: Sometimes you need to get a heap dump for a running process. In this case, the
    easiest solution is to use VisualVM (or a similar profiling tool) to generate
    the dump. Getting a heap dump with VisualVM is as easy as clicking a button. Just
    use the Heap Dump button in the Monitor tab, as shown in figure 11.9.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要获取正在运行进程的堆转储。在这种情况下，最简单的解决方案是使用 VisualVM（或类似的分析工具）来生成转储。使用 VisualVM 获取堆转储就像点击一个按钮一样简单。只需在监视器标签页中使用堆转储按钮，如图
    11.9 所示。
- en: '![](../../OEBPS/Images/CH11_F09_Spilca3.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F09_Spilca3.png)'
- en: Figure 11.9 Press the Heap Dump button in VisualVM’s Monitor tab to get a heap
    dump for the selected process. VisualVM opens the dump as a tab, and you can further
    investigate it or save it anywhere you want.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 在 VisualVM 的监视器标签页中按下“堆转储”按钮以获取所选进程的堆转储。VisualVM 将转储作为标签页打开，你可以进一步调查它或将其保存到任何你想要的位置。
- en: Obtaining a heap dump with the command line
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行获取堆转储
- en: If you need to get a heap dump for a running process, but your app is deployed
    in an environment in which you don’t have access to connect a profiler to it,
    don’t panic; you still have options. You can use `jmap`, a command-line tool provided
    with the JDK, to generate the heap dump.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要获取正在运行进程的堆转储，但你的应用部署在一个你无法连接分析器的环境中，不要慌张；你仍然有选择。你可以使用 JDK 提供的命令行工具 `jmap`
    来生成堆转储。
- en: 'There are two steps for collecting a heap dump with `jmap`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `jmap` 收集堆转储有两个步骤：
- en: Find the process ID (PID) of the running app for which you want to get the heap
    dump.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到你想获取堆转储的正在运行的应用的进程 ID (PID)。
- en: Use `jmap` to save the dump into a file.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `jmap` 将转储保存到文件中。
- en: 'To find the running-process PID, you can use `jps`, as we did in chapter 10:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到正在运行的进程的 PID，你可以使用 `jps`，就像我们在第 10 章中做的那样：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The second step is using `jmap`. To call `jmap`, specify the PID and the location
    where the heap dump file will be saved. You must also specify that the output
    is a binary file using the `-dump:format=b` parameter. Figure 11.10 shows the
    use of this tool in the command line.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是使用 `jmap`。要调用 `jmap`，需要指定进程 ID (PID) 和堆转储文件将要保存的位置。你还必须使用 `-dump:format=b`
    参数指定输出为二进制文件。图 11.10 展示了在命令行中使用此工具的方法。
- en: '![](../../OEBPS/Images/CH11_F10_Spilca3.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F10_Spilca3.png)'
- en: Figure 11.10 Using `jmap` in the command line to get a heap dump. You need to
    specify the path where the file containing the dump will be saved and the process
    ID for which you generate the dump. The tool saves the heap dump as a binary file
    in the requested location.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 在命令行中使用 `jmap` 获取堆转储。你需要指定包含转储的文件的路径以及为你生成转储的进程 ID。该工具将堆转储作为二进制文件保存在请求的位置。
- en: 'Copy the following code to easily use the command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 复制以下代码以方便使用命令：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now you can open the file you saved with `jmap` in VisualVM for investigation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以打开使用 `jmap` 保存的文件，在 VisualVM 中进行调查。
- en: 11.2.2 Reading a heap dump
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.2 读取堆转储
- en: In this section, we’ll focus on using a heap dump to investigate memory allocation
    issues. The heap dump is like a “picture” of the memory when the dump was generated.
    It contains all the data the app had in the heap, which means you can use it to
    examine the data and the way it was structured. This way, you can determine which
    objects occupied a big part of the allocated memory and understand why the app
    couldn’t deallocate them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点关注使用堆转储来调查内存分配问题。堆转储就像是在转储生成时的内存的“图片”。它包含应用在堆中所有的数据，这意味着你可以用它来检查数据和它的结构方式。这样，你可以确定哪些对象占据了分配内存的大部分，并理解为什么应用无法释放它们。
- en: Remember that in the “picture” (heap dump) you can see everything. If unencrypted
    passwords or any kind of private data is in memory, someone with the heap dump
    will be able to get these details.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在“图片”（堆转储）中你可以看到一切。如果未加密的密码或任何类型的私人数据在内存中，拥有堆转储的人将能够获取这些详细信息。
- en: '![](../../OEBPS/Images/icon_guy4.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图标](../../OEBPS/Images/icon_guy4.png)'
- en: Unlike a thread dump, you cannot analyze a heap dump as plain text. Instead,
    you must use VisualVM (or any profiling tool in general). In this section, we’ll
    use VisualVM to analyze the heap dump we generated for project da-ch11-ex2 in
    section 11.2.1\. You’ll learn to utilize this approach to find the root cause
    of an `OutOfMemoryError`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与线程转储不同，你不能将堆转储作为纯文本进行分析。相反，你必须使用 VisualVM（或任何通用的性能分析工具）。在本节中，我们将使用 VisualVM
    分析我们在 11.2.1 节中为项目 da-ch11-ex2 生成的堆转储。你将学会利用这种方法来找到 `OutOfMemoryError` 的根本原因。
- en: When you open a heap dump in VisualVM, the profiling tool displays a summary
    view of the heap dump (figure 11.11), which provides quick details on the heap
    dump file (e.g., the file size, the total number of classes, the total number
    of instances in the dump). You can use this information to make sure you have
    the correct dump, in case you weren’t the one to extract it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 VisualVM 中打开堆转储时，性能分析工具会显示堆转储的摘要视图（图 11.11），它提供了有关堆转储文件的快速详细信息（例如，文件大小、类总数、转储中的实例总数）。你可以使用这些信息来确保你有正确的转储，以防你不是提取转储的人。
- en: '![](../../OEBPS/Images/CH11_F11_Spilca3.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图标](../../OEBPS/Images/CH11_F11_Spilca3.png)'
- en: Figure 11.11 In the initial screen after opening a heap dump, VisualVM provides
    a summary of the heap dump, which includes information about the dump itself and
    the system where the app was running. The view also shows the types that occupy
    the largest amount of memory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 在打开堆转储后的初始屏幕中，VisualVM 提供了堆转储的摘要，其中包括有关转储本身以及应用程序运行的系统信息。视图还显示了占用最大内存量的类型。
- en: There have been times I’ve had to investigate heap dumps from a support team
    that had access to the environments where the app was running. However, I couldn’t
    access those environments myself, so I had to rely on someone else to get the
    data for me. More than once I had the surprise that I had been given the wrong
    heap dump. I was able to identify the error by looking at the size of the dump
    and comparing it to what I knew was the maximum value configured for the process,
    or even by looking at the operating system or the Java version.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我不得不调查支持团队从应用程序运行的环境访问的堆转储。然而，我自己无法访问这些环境，所以我必须依赖别人为我获取数据。不止一次，我惊讶地发现我得到了错误的堆转储。我通过查看转储的大小并将其与我知道的进程配置的最大值进行比较，或者通过查看操作系统或
    Java 版本来识别错误。
- en: My advice is to first quickly check the summary page and make sure you have
    the correct file. On the summary page, you’ll also find types that occupy a large
    amount of space. I usually don’t rely on this summary and instead go directly
    to the objects view, where I start my investigation. In most cases, the summary
    isn’t enough for me to draw a conclusion.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是首先快速检查摘要页面，确保你有正确的文件。在摘要页面，你还会找到占用大量空间的类型。我通常不依赖这个摘要，而是直接转到对象视图，在那里我开始我的调查。在大多数情况下，摘要对我来说不足以得出结论。
- en: To switch to the objects view, select Objects from the drop-down menu in the
    upper-left corner of the heap dump tab (figure 11.12). This will allow you to
    investigate the object instances in the heap dump.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要切换到对象视图，请从堆转储标签页左上角的下拉菜单中选择对象（图 11.12）。这将允许你调查堆转储中的对象实例。
- en: '![](../../OEBPS/Images/CH11_F12_Spilca3.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图标](../../OEBPS/Images/CH11_F12_Spilca3.png)'
- en: Figure 11.12 You can switch to the Objects view, which makes it easier to investigate
    the instances in the heap dump.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 你可以切换到对象视图，这使得调查堆转储中的实例更容易。
- en: Just as with memory sampling and profiling, we’re searching for the types that
    use the most memory. The best approach is to sort, in descending order, by both
    instances and occupied memory and look for the first types that are part of the
    app’s codebase. Don’t look for types such as primitives, strings, or arrays of
    primitives and strings. There are usually a lot, and they won’t give you many
    clues as to what is wrong.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就像内存采样和性能分析一样，我们正在寻找占用最多内存的类型。最佳方法是按实例和占用内存量降序排序，并查找属于应用程序代码库的第一种类型。不要寻找诸如原始数据类型、字符串或原始数据类型和字符串数组之类的类型。通常有很多这样的类型，而且它们不会给你很多关于错误的线索。
- en: In figure 11.13, you can see, after sorting, that the `Product` type seems to
    be involved in the problem. The `Product` type is the first type that is part
    of the app’s codebase, and it uses a large part of the memory. We need to figure
    out why so many instances have been created and why the GC can’t remove them from
    the memory.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在图11.13中，您可以看到，经过排序后，`Product`类型似乎与问题有关。`Product`类型是应用程序代码库中第一个类型，它使用了大量的内存。我们需要弄清楚为什么创建了这么多实例，以及为什么垃圾收集器不能从内存中删除它们。
- en: '![](../../OEBPS/Images/CH11_F13_Spilca3.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F13_Spilca3.png)'
- en: Figure 11.13 Use sorting on columns to identify which type created a large number
    of instances or takes up a lot of space. Always look for the first object in your
    app codebase. In this case, both in number of instances and size, the `Product`
    type is the first in the list.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13 使用列排序来识别哪种类型创建了大量的实例或占用了大量的空间。始终在您的应用程序代码库中寻找第一个对象。在这种情况下，无论是实例数量还是大小，`Product`类型都是列表中的第一个。
- en: You can select the small plus sign (+) on the left side of the row to get details
    about all the instances for that type. We already know there are more than one
    million `Product` instances, but we still need to find
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过选择行左侧的小加号（+）来获取该类型所有实例的详细信息。我们已经知道有超过一百万个`Product`实例，但我们仍然需要找到
- en: What part of the code creates those instances
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的哪一部分创建了这些实例
- en: Why the GC can’t remove them in time to avoid the app’s failure
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么垃圾收集器不能及时删除它们以避免应用程序失败
- en: You can find what each instance refers to (through fields) and what refers to
    that instance. Since we know the GC cannot remove an instance from the memory
    unless it has no referrers, we look for what refers the instance to see whether
    it is still needed in the processing context or if the app forgot to remove its
    reference.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以找到每个实例所引用的内容（通过字段）以及什么引用了这个实例。由于我们知道垃圾收集器只有在没有引用者的情况下才能从内存中删除实例，因此我们寻找引用实例的内容，以查看它是否仍在处理上下文中需要，或者应用程序是否忘记了删除其引用。
- en: Figure 11.14 shows the expanded view for the details of one of the `Product`
    instances. We can see that the instance refers to a `String` (the product name),
    and its reference is kept in an `Object` array, which is part of an `ArrayList`
    instance. Moreover, the `ArrayList` instance seems to keep a large number of references
    (over one million). This is usually not a good sign, as either the app implements
    an unoptimized capability or we found a memory leak.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14显示了`Product`实例细节的扩展视图。我们可以看到该实例引用了一个`String`（产品名称），并且其引用保存在一个`Object`数组中，该数组是`ArrayList`实例的一部分。此外，`ArrayList`实例似乎保存了大量的引用（超过一百万个）。这通常不是一个好兆头，因为要么应用程序实现了未优化的功能，要么我们发现了内存泄漏。
- en: '![](../../OEBPS/Images/CH11_F14_Spilca3.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F14_Spilca3.png)'
- en: Figure 11.14 References to an instance. By using the heap dump, you can find,
    for each instance, what other instances were being referenced at the time the
    dump was generated. The profiling tool also tells you where a given reference
    is stored in the code. In this case, `ArrayList`, which holds over one million
    references, is a static variable in the `Main` class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14 实例的引用。通过使用堆转储，您可以在每个实例中找到在转储生成时被引用的其他实例。分析工具还告诉您给定引用在代码中的存储位置。在这种情况下，`ArrayList`，它保存了超过一百万个引用，是`Main`类中的一个静态变量。
- en: To understand which is the case, we need to investigate the code using the debugging
    and logging techniques we discussed in chapters 2 to 5\. Fortunately, the profiler
    shows you exactly where to find the list in the code. In our case, the list is
    declared as a static variable in the `Main` class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解哪种情况，我们需要使用我们在第2章到第5章中讨论的调试和日志技术来调查代码。幸运的是，分析器会告诉你如何在代码中找到这个列表。在我们的例子中，这个列表是在`Main`类中声明为一个静态变量。
- en: Using VisualVM, we can easily understand the relationships between objects.
    By combining this technique with other investigation techniques you’ve learned
    throughout the book, you have all the tools you need to address these kinds of
    issues. Complex problems (and apps) may still require significant effort, but
    using this approach will save you a lot of time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用VisualVM，我们可以轻松理解对象之间的关系。通过结合本书中学习到的其他调查技术，您拥有了处理这类问题的所有工具。复杂的问题（和应用程序）可能仍然需要大量的努力，但使用这种方法将为您节省大量时间。
- en: 11.2.3 Using the OQL console to query a heap dump
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2.3 使用OQL控制台查询堆转储
- en: In this section, we’ll discuss a more advanced way of investigating a heap dump.
    We use a querying language similar to SQL to retrieve details from the heap dump.
    The simple approaches we discussed in section 11.2.2 are usually enough to identify
    memory allocation problems’ root causes. But they aren’t sufficient when we need
    to compare the details of two or more heap dumps.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论调查堆转储的更高级方法。我们使用类似于 SQL 的查询语言从堆转储中检索详细信息。我们在 11.2.2 节中讨论的简单方法通常足以识别内存分配问题的根本原因。但当我们需要比较两个或更多堆转储的详细信息时，它们就不够了。
- en: Suppose you want to compare the heap dumps provided for two or more versions
    of an app to determine whether something faulty or unoptimized was implemented
    between the version releases. You can investigate them manually, one by one. But
    I’ll teach you how to write queries that you can easily run on each of them, which
    will save you time. That’s where OQL is an excellent approach. Figure 11.15 shows
    you how to change the view to the OQL console, where you can run queries to investigate
    the heap dump.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要比较为应用的两个或更多版本提供的堆转储，以确定在版本发布之间是否实现了有缺陷或不优化的功能。你可以逐个手动调查它们。但我会教你如何编写可以在每个堆转储上轻松运行的查询，这将为你节省时间。这就是
    OQL 是一种优秀方法的地方。图 11.15 展示了如何将视图切换到 OQL 控制台，在那里你可以运行查询以调查堆转储。
- en: '![](../../OEBPS/Images/CH11_F15_Spilca3.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F15_Spilca3.png)'
- en: Figure 11.15 To switch to the OQL view in VisualVM, choose OQL Console from
    the drop-down menu in the upper-left corner of the heap dump tab.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 要在 VisualVM 中切换到 OQL 视图，请从堆转储标签页左上角的下拉菜单中选择 OQL 控制台。
- en: We’ll discuss a few examples I find most useful, but remember that OQL is more
    complex. (You can find more information on its functions at [http://mng.bz/Pod2](http://mng.bz/Pod2).)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论一些我认为最有用的例子，但请记住，OQL 更复杂。（你可以在 [http://mng.bz/Pod2](http://mng.bz/Pod2)
    上找到更多关于其功能的信息。）
- en: 'Let’s start with a simple one: selecting all the instances of a given type.
    Say we want to get all the instances of type `Product` from the heap dump. To
    use a SQL query to get all the product records from a table in a relational database,
    we would write something like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的一个开始：选择给定类型的所有实例。比如说，我们想要从堆转储中获取所有 `Product` 类型的实例。要使用 SQL 查询从关系数据库中的表中获取所有产品记录，我们会编写类似这样的代码：
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To query all the `Product` instances in a heap dump using OQL, you need to
    write this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 OQL 查询堆转储中的所有 `Product` 实例，你需要编写如下代码：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: NOTE For OQL, keywords such as “select,” “from,” or “where” are always written
    in lowercase. The types are always given with their fully qualified name (package
    + class name).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于 OQL，关键字如“select”、“from”或“where”始终以小写形式书写。类型总是用它们的完全限定名称（包+类名）给出。
- en: '![](../../OEBPS/Images/icon_girl2.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_girl2.png)'
- en: '![](../../OEBPS/Images/CH11_F16_Spilca3.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F16_Spilca3.png)'
- en: Figure 11.16 Running an OQL query with VisualVM. In the OQL console, write the
    OQL query in the textbox on the bottom of the window and click the Run button
    (the green arrow on the left of the text box) to run the query. The results will
    appear above the text box.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16 使用 VisualVM 运行 OQL 查询。在 OQL 控制台中，在窗口底部的文本框中编写 OQL 查询，然后单击运行按钮（文本框左侧的绿色箭头）以运行查询。结果将显示在文本框上方。
- en: Figure 11.16 shows the result of executing the simple query that retrieves all
    the `Product` instances from the heap dump.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16 展示了执行从堆转储中检索所有 `Product` 实例的简单查询结果。
- en: NOTE When learning OQL, use small heap dumps. Real-world heap dumps are usually
    large (4 GB or larger). The OQL queries will be slow. If you are studying only,
    generate and use small-sized heap dumps like we do in this chapter.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在学习 OQL 时，请使用小堆转储。现实世界的堆转储通常很大（4 GB 或更大）。OQL 查询会变慢。如果你只是在学习，请生成并使用我们在本章中使用的类似的小尺寸堆转储。
- en: '![](../../OEBPS/Images/icon_girl2.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_girl2.png)'
- en: You can select any of the queried instances to get its details. You can find
    what keeps a reference to that instance, what that instance refers to, and its
    values (figure 11.17).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择任何查询实例以获取其详细信息。你可以找到保持对该实例引用的内容，该实例引用的内容，以及其值（图 11.17）。
- en: '![](../../OEBPS/Images/CH11_F17_Spilca3.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F17_Spilca3.png)'
- en: Figure 11.17 You can access the details about a queried instance (referees and
    referrers) by clicking it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.17 你可以通过单击来访问查询实例的详细信息（引用者和被引用者）。
- en: 'You can also select values or references referred from certain instances. For
    example, if we want to get all the product names instead of the product instances,
    we can write the following query (figure 11.18):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以选择从某些实例引用的值或引用。例如，如果我们想获取所有产品名称而不是产品实例，我们可以编写以下查询（图11.18）：
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](../../OEBPS/Images/CH11_F18_Spilca3.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F18_Spilca3.png)'
- en: Figure 11.18 Selecting an attribute of a given object type. Just as in Java,
    you can use the standard dot operator to refer to an attribute of an instance.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18：选择给定对象类型的属性。就像在Java中一样，你可以使用标准的点操作符来引用实例的属性。
- en: With OQL, you can extract multiple values at the same time. To do so, you need
    to format them as JSON, as in the next listing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OQL，你可以同时提取多个值。为此，你需要将它们格式化为JSON，如下一列表所示。
- en: Listing 11.2 Using a JSON projection
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表11.2：使用JSON投影
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Curly braces surround the JSON object representation
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 大括号包围了JSON对象表示
- en: ❷ The attribute name takes the value of the product name.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 属性名称取产品名称的值。
- en: ❸ The attribute name_length takes the value of the number of characters in the
    product name.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 属性名称_length取产品名称中字符数的值。
- en: Figure 11.19 shows you the result for running this query.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19显示了运行此查询的结果。
- en: '![](../../OEBPS/Images/CH11_F19_Spilca3.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F19_Spilca3.png)'
- en: Figure 11.19 Selecting multiple values. You can use JSON formatting to obtain
    multiple values with one query.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19：选择多个值。你可以使用JSON格式化在一个查询中获取多个值。
- en: 'You can change this query to, for example, add conditions on one or more of
    the selected values. Say you want to select only the instances that have a name
    longer than 15 characters. You could write a query as presented in the next snippet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将此查询修改为，例如，添加一个或多个选定值的条件。假设你只想选择名称长度超过15个字符的实例。你可以编写如下查询的片段：
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s move on to something slightly more advanced. A query I often use when
    looking into memory issues employs the `referrers()` method to get the objects
    that refer to instances of a specific type. By using built-in OQL functions such
    as this one, you can do plenty of helpful things:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨一些稍微高级一点的内容。在调查内存问题时，我经常使用`referrers()`方法来获取指向特定类型实例的对象。通过使用此类内置OQL函数，你可以做很多有用的事情：
- en: '*Find or query instance referees*—Can tell you if the app has memory leaks'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查找或查询实例引用者*——可以告诉你应用是否有内存泄漏'
- en: '*Find or query instance referrals*—Can tell you if specific instances are the
    cause of memory leaks'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查找或查询实例引用*——可以告诉你特定实例是否是内存泄漏的原因'
- en: '*Find duplicates in instances*—Can tell you if specific capabilities can be
    optimized to use less memory'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在实例中查找重复项*——可以告诉你是否可以将特定功能优化以使用更少的内存'
- en: '*Find subclasses and superclasses of certain instances*—Gives you insight into
    an app’s class design without needing to see the source code'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查找某些实例的子类和超类*——在不查看源代码的情况下，让你了解应用的类设计'
- en: '*Identify long life paths*—Can help you to identify memory leaks'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*识别长生命周期路径*——可以帮助你识别内存泄漏'
- en: 'To get all the unique referrals for instances of type `Product`, you can use
    the following query:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取类型`Product`的所有唯一引用，你可以使用以下查询：
- en: '[PRE12]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Figure 11.20 shows the result for running this query. In this case, we can see
    that all the product instances are referred to by one object—a list. Usually,
    when a large number of instances have a small number of referrals, it’s a sign
    of a memory leak. In our case, a list keeps references to all the `Product` instances,
    preventing the GC from removing them from memory.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20显示了运行此查询的结果。在这种情况下，我们可以看到所有产品实例都被一个对象——列表所引用。通常，当大量实例只有少量引用时，这是一个内存泄漏的迹象。在我们的例子中，列表保留了所有`Product`实例的引用，阻止GC从内存中删除它们。
- en: '![](../../OEBPS/Images/CH11_F20_Spilca3.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH11_F20_Spilca3.png)'
- en: Figure 11.20 Selecting all the unique referrers for instances of a type shows
    you if there’s one object that prevents the GC from removing the instances from
    memory. This can be a quick way to identify a memory leak.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20：选择特定类型的所有唯一引用者，这可以显示是否有一个对象阻止GC从内存中删除实例。这可以是一个快速识别内存泄漏的方法。
- en: 'If the result is not unique, you can count the referrals by instance using
    the next query to find the instances that are potentially involved in a memory
    leak:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结果不唯一，你可以使用以下查询通过实例计数引用，以找到可能涉及内存泄漏的实例：
- en: '[PRE13]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The OQL queries provide a lot of opportunities, and once you write a query,
    you can run it as many times as you need and on different heap dumps.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: OQL查询提供了很多机会，一旦您编写了一个查询，您就可以根据需要多次运行它，并在不同的堆转储上运行。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: An app with capabilities that are not optimized for memory allocation can cause
    performance problems. Optimizing the app to wisely allocate (avoid spending unnecessary
    memory space) the data in memory is essential to an app’s performance.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个未针对内存分配进行优化的应用可能会引起性能问题。优化应用以智能地分配（避免浪费不必要的内存空间）内存中的数据对于应用性能至关重要。
- en: A profiling tool allows you to sample and profile how the memory gets occupied
    during an app’s execution. This can help you identify unoptimized parts of your
    app and provides you with details on what can be improved.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析工具允许您在应用执行期间采样和记录内存的使用情况。这可以帮助您识别应用中未优化的部分，并提供有关可以改进的详细信息。
- en: If new object instances are continuously added to the memory during execution
    but the app never removes the references to new instances, the GC won’t be able
    to delete the references and free the memory. When the memory gets fully occupied,
    the app cannot continue its execution and stops. Before stopping, the app throws
    an `OutOfMemoryError`.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在执行期间不断向内存中添加新的对象实例，但应用从未删除对新实例的引用，垃圾回收器将无法删除引用并释放内存。当内存完全被占用时，应用无法继续执行并停止。在停止之前，应用会抛出`OutOfMemoryError`。
- en: To investigate an `OutOfMemoryError`, we use heap dumps. A heap dump collects
    all the data in the app’s heap memory and allows you to analyze it to figure out
    what went wrong.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要调查`OutOfMemoryError`，我们使用堆转储。堆转储收集应用堆内存中的所有数据，并允许您分析它以找出问题所在。
- en: You can start your app using a couple of JVM arguments to instruct it to generate
    a heap dump at a given path if the app fails with an `OutOfMemoryError`.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用几个JVM参数启动应用，指示它在`OutOfMemoryError`失败时在指定路径生成堆转储。
- en: You can also get a heap dump by using a profiling tool or a command-line tool
    such as `jmap`.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您也可以通过使用性能分析工具或如`jmap`之类的命令行工具来获取堆转储。
- en: To analyze a heap dump, load it in a profiling tool such as VisualVM, which
    allows you to investigate the instances in the dump and their relationships. This
    way, you can figure out what part of the app is not optimized or has memory leaks.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要分析堆转储，请将其加载到VisualVM等性能分析工具中，这允许您调查转储中的实例及其关系。这样，您可以找出应用中哪些部分未优化或存在内存泄漏。
- en: VisualVM offers more advanced ways to analyze the heap dump, such as OQL queries.
    OQL is a querying language similar to SQL that you use to retrieve data from a
    heap dump.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VisualVM提供了分析堆转储的更高级方法，例如OQL查询。OQL是一种类似于SQL的查询语言，您可以使用它从堆转储中检索数据。
