- en: 9 Integration testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 集成测试
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Converting user requirements to descriptive tests
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户需求转换为描述性测试
- en: Writing tests that follow a behavior-driven design pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写遵循行为驱动设计模式的测试
- en: Integrating external dependencies into tests using containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器将外部依赖项集成到测试中
- en: You are sitting in the conference room with your project manager, a QA lead,
    an Ops lead, and the CEO. The project manager stands at the front of the room
    and starts the presentation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你和项目经理、质量保证负责人、运维负责人以及CEO坐在会议室里。项目经理站在房间前面开始演示。
- en: “It’s called a strangler application. The name ‘strangler application’ comes
    from the strangler fig tree, which builds itself around a host tree until the
    host tree dies. As sad as it sounds, we want to eventually sunset our old application.
    We feel our application has been tested enough to start rolling it out to a select
    group of customers. The new service will start out depending on the old service
    like it does today, but over time, we can gradually phase the old one out once
    we are satisfied that we haven’t missed anything.”
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: “它被称为strangler应用程序。‘strangler应用程序’这个名字来源于绞杀榕树，它围绕宿主树生长，直到宿主树死亡。虽然听起来很悲伤，但我们最终希望淘汰我们的旧应用程序。我们觉得我们的应用程序已经经过了足够的测试，可以开始向一小部分客户推出。新服务将像今天一样依赖于旧服务，但随着时间的推移，一旦我们确信没有遗漏任何东西，我们可以逐渐淘汰旧服务。”
- en: You look around the room and notice everyone nodding their heads.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你环顾四周，注意到每个人都点头表示同意。
- en: “This seems to mitigate some of our risks because we can always switch back
    to the old service if we have any problems,” the QA lead adds.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: “这似乎减轻了一些风险，因为我们总可以在有问题时切换回旧服务，”质量保证负责人补充道。
- en: “Exactly. We have built a system for writing flexible software that can be responsive
    to our needs. What are the final pieces we are missing?” your project manager
    adds, looking around the room.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: “确实如此。我们已经建立了一个用于编写灵活软件的系统，该系统能够满足我们的需求。我们缺少的最后一部分是什么？”你的项目经理环顾四周补充道。
- en: The Ops lead chimes in, “A database with all of the translations will be needed
    if we want to shut down the old system.”
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 运维负责人插话说：“如果我们想关闭旧系统，我们需要一个包含所有翻译的数据库。”
- en: Someone from QA adds, “Additional testing around that would be helpful. Can
    we automate that?”
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 质量保证团队中有人补充说：“围绕这一点进行额外的测试会有所帮助。我们可以自动化吗？”
- en: A few weeks ago, you would have never expected that, but now you have established
    some credibility around automated testing. Your team is buying into this new development
    process, and it’s showing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 几周前，你绝对想不到这一点，但现在你在自动化测试方面建立了一些信誉。你的团队正在接受这个新的开发流程，并且效果显著。
- en: You walk up to the board and write
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你走到白板前写下
- en: Convert client calls to database calls.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将客户调用转换为数据库调用。
- en: Migrate old data.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移旧数据。
- en: Establish integration tests that meet feature requirements.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立满足功能要求的集成测试。
- en: “Looks like we have a plan. Great work, everyone,” the CTO says as they stand
    up and walk out of the room. That is your cue to get started.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: “看起来我们有一个计划。大家做得很好，”CTO站起来走出房间时说。这是你开始工作的信号。
- en: 9.1 Phasing out the old
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1 逐步淘汰旧系统
- en: 'Strangler applications are great at converting old code into new code a little
    bit at a time. We already started the process of creating a link between the old
    system and the new system when we created the external client back in chapter
    6\. If you remember, we call the external system if we do not have the value in
    a cache. Our interface looks like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Strangler应用程序擅长逐步将旧代码转换为新代码。当我们回到第6章创建外部客户端时，我们就已经开始创建旧系统与新系统之间的链接了。如果你还记得，如果没有缓存中的值，我们会调用外部系统。我们的接口看起来是这样的：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Up to this point, we’ve built a framework of flexibility. This allows us to
    slowly phase out the old application by using our configuration management along
    with dependency injection to change how the new system interacts with the old
    system. First, we need to choose a database to store our data. Once we are convinced
    everything is working as expected, we will remove the external client and hopefully
    shut the old system down.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经建立了一个灵活性的框架。这使我们能够通过使用配置管理和依赖注入来改变新系统与旧系统交互的方式，逐步淘汰旧应用程序。首先，我们需要选择一个数据库来存储我们的数据。一旦我们确信一切按预期工作，我们将移除外部客户端，并希望关闭旧系统。
- en: To manage this, we will overload our configuration to have a database connection.
    If we see this connection, we will override the external client. We will need
    to add some values to our configuration (see the following listing).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理这一点，我们将重载配置以包含数据库连接。如果我们看到这个连接，我们将覆盖外部客户端。我们需要向配置中添加一些值（见以下列表）。
- en: Listing 9.1 `core.go`
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1 `core.go`
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Adds Database URL for connection
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加数据库URL以进行连接
- en: ❷ Adds port in case the standard port is not in use
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在标准端口未使用的情况下添加端口
- en: To create all of this, we should consider how to verify that our changes are
    working, so we will write some integration tests that test the system as a whole.
    Thus far, we’ve mostly focused on basic unit tests and have simulated external
    integrations. Instead of simulating these integrations, we should also create
    a set of tests to verify these interactions. The most common integration point
    is often between an application and a database. Now we want to move our system
    over to connect to a database instead of calling the external client, but we want
    to have the flexibility to turn the client call on and off.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建所有这些，我们应该考虑如何验证我们的更改是否有效，因此我们将编写一些集成测试来测试整个系统。到目前为止，我们主要关注基本的单元测试并模拟了外部集成。除了模拟这些集成之外，我们还应该创建一系列测试来验证这些交互。最常见的集成点通常是在应用程序和数据库之间。现在我们希望将我们的系统迁移到连接数据库而不是调用外部客户端，但我们希望有灵活性来开启和关闭客户端调用。
- en: First, we will focus on creating a new connection that matches our existing
    interface. Then, based on our configuration, we will make an external service
    call, a database call, or a hybrid that makes an external call only if the value
    is not present in the database. Before we do anything, we should write some tests
    to validate the existing functionality, and then integrate the database and verify
    that it works. These tests will validate the user’s experience rather than the
    overall functionality of a module of code, so we will take a slightly different
    approach than what we did before.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将专注于创建一个新的连接，该连接与我们的现有接口相匹配。然后，根据我们的配置，我们将进行外部服务调用、数据库调用或混合调用，仅在数据库中不存在该值时才进行外部调用。在我们做任何事情之前，我们应该编写一些测试来验证现有功能，然后集成数据库并验证其是否正常工作。这些测试将验证用户体验而不是代码模块的整体功能，因此我们将采取与之前略有不同的方法。
- en: 9.2 Behavior-driven design
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2 行为驱动设计
- en: In chapter 3, we talked about test-driven development (TDD), which helped us
    focus on how a unit of code was intended to function. This meant that we could
    focus on providing the proper inputs to get the expected outputs. We spent time
    verifying that portions of the system were called by mocking them, and it required
    a little bit of our technical knowledge to understand how everything should work.
    We can take this same format and abstract it a bit more. Imagine that your project
    manager, CEO, or even your customers wrote the tests and that you wrote the implementation.
    This is exactly what *behavior-driven design* is supposed to do. We start looking
    at things at a macroscopic level and then look at a larger picture of how the
    product or feature will be used. Instead of focusing on Arranging our tests, Acting
    on our function, and Asserting our values (remember the three As from chapter
    3), we instead focus on a Given, When, Then structure that can be written in clearer
    text and tested against. The following listing provides an example that we can
    use for our application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三章中，我们讨论了测试驱动开发（TDD），这有助于我们关注代码单元的预期功能。这意味着我们可以专注于提供适当的输入以获得预期的输出。我们花费时间通过模拟系统部分来验证它们是否被调用，这需要我们一点技术知识来理解一切应该如何工作。我们可以采用相同的格式并进一步抽象化。想象一下，如果你的项目经理、CEO甚至你的客户编写了测试，而你编写了实现。这正是*行为驱动设计*应该做的事情。我们从宏观层面开始审视事物，然后观察产品或功能将如何被使用的更大图景。我们不再专注于安排测试、对函数进行操作和断言值（记住第三章中的三个A），而是专注于一个Given、When、Then结构，这可以用更清晰的文本编写并对其进行测试。以下列表提供了一个我们可以用于我们应用程序的示例。
- en: Listing 9.2 `app.feature`
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.2 `app.feature`
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The feature is the deliverable item.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 功能是可交付的项目。
- en: ❷ The scenario is how the feature is used.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 场景是功能的使用方式。
- en: ❸ Given, When, Then describes what happens.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Given、When、Then描述了发生了什么。
- en: This domain-specific language (DSL) is known as Gherkin and is used to allow
    nontechnical people to write requirements that can be converted automatically
    into tests. Once in your testing framework, these requirements become your validation
    criteria or assertions in our Arrange, Act, Assert pattern. What’s great about
    this is that you are validating against requirements that someone else wrote or
    that can be referred to as part of your development process. No longer can a project
    manager say you didn’t meet the requirements if they wrote the descriptions and
    all of the tests passed!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种领域特定语言（DSL）被称为 Gherkin，用于允许非技术人员编写可以自动转换为测试的要求。一旦进入你的测试框架，这些要求就变成了你的验证标准或
    Arrange, Act, Assert 模式中的断言。关于这一点很棒的是，你正在验证的是其他人编写的要求，或者可以称为你开发过程的一部分。项目经理再也不能说你没有满足要求，如果他们编写了描述并且所有测试都通过了！
- en: NOTE We are focused on running our BDD tests using a Go runner; however, you
    can write more comprehensive integration suites using Selenium or Cypress.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们专注于使用 Go 运行器运行我们的 BDD 测试；然而，你可以使用 Selenium 或 Cypress 编写更全面的集成测试套件。
- en: What is special about the Gherkin language is that multiple libraries can use
    it. Each one of these features can be tied to specific unit tests or used to test
    user interfaces. The point is that our project managers can start writing code
    for us in this special language, and we can then use it to verify that a feature
    is complete through multiple means. For example, let’s assume we are creating
    a UI with our API. We can use this same feature file to write our Go backend tests,
    JavaScript UI tests, and automated QA end-to-end tests. As long as the feature
    is there but the tests are not implemented, our build will fail. This is intentional
    because the requirements of our system have changed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin 语言的特别之处在于多个库都可以使用它。这些功能中的每一个都可以与特定的单元测试或用于测试用户界面相关联。关键是我们的项目经理可以用这种特殊语言为我们编写代码，然后我们可以通过多种方式使用它来验证一个功能是否完整。例如，假设我们正在使用我们的
    API 创建一个 UI。我们可以使用这个相同的功能文件来编写我们的 Go 后端测试、JavaScript UI 测试和自动化的端到端 QA 测试。只要功能存在但测试未实现，我们的构建就会失败。这是故意的，因为我们的系统需求已经发生了变化。
- en: Taking this feature request, we can plug it into our testing pipeline; however,
    we will not test individual packages but instead test the `main` package, which
    runs the whole application. At a high level, we can verify that we meet the expectations
    of our users. We will use this feature definition to drive our tests. To do this,
    we will use a library called Godog, which falls under the Cucumber project, the
    top open-source project for BDD. Cucumber has written other libraries for other
    languages that support Gherkin as well.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 针对这个功能请求，我们可以将其集成到我们的测试流程中；但是，我们将不会测试单个包，而是测试 `main` 包，它运行整个应用程序。从高层次来看，我们可以验证我们是否满足了用户的需求。我们将使用这个功能定义来驱动我们的测试。为此，我们将使用一个名为
    Godog 的库，它属于 Cucumber 项目，这是 BDD 的顶级开源项目。Cucumber 为支持 Gherkin 的其他语言编写了其他库。
- en: 9.3 Writing BDD tests in Go
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3 在 Go 中编写 BDD 测试
- en: To start, we will set up our BDD testing by writing our feature definitions
    and tests. We will set up our tests and write them, but the expectation is that
    they will fail. Once they are written, we will work on fixing them by attaching
    our database. By the end of the chapter, we will be able to verify that our services
    work entirely as expected.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过编写我们的功能定义和测试来设置我们的 BDD 测试。我们将设置测试并编写它们，但预期它们会失败。一旦编写完成，我们将通过附加我们的数据库来修复它们。到本章结束时，我们将能够验证我们的服务完全符合预期。
- en: The first thing we need to do is install a new tool called Godog. To do this,
    let’s first add an entry to our Makefile (see the following listing).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是安装一个名为 Godog 的新工具。为此，让我们首先在我们的 Makefile 中添加一个条目（见以下列表）。
- en: Listing 9.3 Makefile
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.3 Makefile
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Installs the Godog binary
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安装 Godog 二进制文件
- en: Next, run the installation to verify that it works. We should be able to copy
    our feature to a directory to test. Godog has many different ways to run tests,
    but for now, we will rely on the default behavior, which is to look for feature
    files in a local directory called `features`. Since we will test the API binary,
    we will create that directory in the `cmd` directory.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行安装程序以验证其是否正常工作。我们应该能够将我们的功能复制到目录中以进行测试。Godog 有许多不同的方式来运行测试，但到目前为止，我们将依赖于默认行为，即在一个名为
    `features` 的本地目录中查找功能文件。由于我们将测试 API 二进制文件，我们将在 `cmd` 目录中创建该目录。
- en: Once you’ve created the `cmd/features` directory and copied over our `app .feature`,
    we can navigate to the `cmd` directory and type `godog run`. You should see a
    snippet of generated code like in the following listing.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了`cmd/features`目录并复制了我们的`app .feature`文件，我们就可以导航到`cmd`目录并输入`godog run`。你应该会看到如下列表中所示的生成代码片段。
- en: Listing 9.4 `console`
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.4 `console`
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Our text is converted into functions with similar names capturing particular
    input.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们将文本转换为具有相似名称的函数，以捕获特定的输入。
- en: ❷ Until implemented, we can use this special error type.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在实现之前，我们可以使用这个特殊的错误类型。
- en: ❸ Tests enter here to set up and run each scenario step.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 测试进入这里来设置和运行每个场景步骤。
- en: ❹ Each step has a special capture group that provides input to the appropriate
    function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 每个步骤都有一个特殊的捕获组，它为适当的函数提供输入。
- en: Obviously, this code is incomplete but gives us a basis to start. Copy the text,
    and create a new file called `main_test.go` in that directory. We will also create
    a struct to help capture some of the input we need for our tests. The code will
    look like the following listing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这段代码是不完整的，但它为我们提供了一个开始的基础。复制文本，并在该目录中创建一个名为`main_test.go`的新文件。我们还将创建一个结构体来帮助我们捕获测试所需的某些输入。代码如下所示。
- en: Listing 9.5 `main_test.go`
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.5 `main_test.go`
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ We use the main package so that we can reference the methods inside to start
    the application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们使用主包，这样我们就可以引用其中的方法来启动应用程序。
- en: ❷ Use the Godog library to help set up the tests.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用Godog库来帮助设置测试。
- en: ❸ This struct will help store information throughout the tests.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这个结构体将帮助在整个测试过程中存储信息。
- en: ❹ Functions are now within the context of our feature struct.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 函数现在处于我们的功能结构体的上下文中。
- en: Our test is set up, but we are unable to access and run our main function, so
    we want to create the ability to start a server the same way `main()` does. This
    is typically done by creating a function that houses the logic of the application
    creation and having the `main` function call it. We will refactor our `main.go`
    file to match this pattern (see the following listing).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试已经设置好了，但我们无法访问和运行主函数，因此我们想要创建与`main()`相同的方式来启动服务器。这通常是通过创建一个包含应用程序创建逻辑的函数，并在`main`函数中调用它来完成的。我们将重构`main.go`文件以匹配此模式（见以下列表）。
- en: Listing 9.6 `main.go`
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.6 `main.go`
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ The main function just runs the server now instead of configuring the service’s
    HTTP and service endpoints.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 主函数现在只是运行服务器，而不是配置服务的HTTP和端点。
- en: ❷ This function will assemble the service and HTTP endpoints to be passed to
    the server.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这个函数将组装服务及其HTTP端点，以便传递给服务器。
- en: ❸ The mux router is returned to be attached to an HTTP server.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回mux路由器以附加到HTTP服务器。
- en: You should be able to start your application and have it still work. Now we
    can wire our Godog tests. To verify our results, we will call our API and parse
    the results. While Go has the capability of calling HTTP endpoints, we’ll use
    a library to help us make the code a little easier to read. To do this, install
    `go` `get` `github.com/go-resty/resty/v2`. Resty helps make writing API calls
    a little clearer. For example, if we wanted to call our API using Resty, it would
    look something like the following listing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够启动你的应用程序，并且它仍然可以正常工作。现在我们可以连接我们的Godog测试。为了验证我们的结果，我们将调用我们的API并解析结果。虽然Go有调用HTTP端点的功能，但我们将使用库来帮助我们使代码更容易阅读。为此，安装`go`
    `get` `github.com/go-resty/resty/v2`。Resty帮助使编写API调用更加清晰。例如，如果我们想使用Resty调用我们的API，它将类似于以下列表。
- en: Listing 9.7 Resty example
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.7 Resty示例
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Creates a new request
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新的请求
- en: ❷ Sets the header to be JSON
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置头部为JSON
- en: ❸ Sets query Params for language to German
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 设置查询参数为德语
- en: ❹ Calls the endpoint using GET
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用GET调用端点
- en: We need the input for this call in order to verify our tests. Remember earlier
    when we looked at the methods Godog generated for us? They have string inputs
    that we can set in a feature test structure. Let’s add the code in the following
    listing to our struct.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这个调用的输入来验证我们的测试。记得我们之前查看Godog为我们生成的那些方法吗？它们有字符串输入，我们可以在功能测试结构体中设置这些输入。让我们将以下列表中的代码添加到我们的结构体中。
- en: Listing 9.8 `main_test.go`
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.8 `main_test.go`
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Shared client for tests
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 测试的共享客户端
- en: ❷ Creates a test server to avoid port conflicts
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个测试服务器以避免端口冲突
- en: ❸ The word being used
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 正在使用的单词
- en: ❹ The language being translated to
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 正在翻译到的语言
- en: Now we can store the values in the various steps (see the following listing).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将值存储在各个步骤中（见以下列表）。
- en: Listing 9.9 `main_test.go`
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.9 `main_test.go`
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Saves the values to the struct
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将值保存到结构体中
- en: Let’s initialize our feature struct using the code in the following listing
    to have a server start up and shut down for each scenario.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用下面的列表中的代码初始化我们的功能结构体，以便每个场景都有一个服务器启动和关闭。
- en: Listing 9.10 `main_test.go`
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.10 `main_test.go`
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Creates a shared client
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建共享客户端
- en: ❷ Creates a new feature struct for sharing
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个新的用于共享的功能结构体
- en: ❸ Uses before and after hooks to manage the server
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用前后钩子来管理服务器
- en: ❹ Loads the config from Env (could also use default)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 从环境变量中加载配置（也可以使用默认值）
- en: ❺ Creates the same mux as the main function
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 创建与主函数相同的mux
- en: ❻ Creates the test server
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 创建测试服务器
- en: ❼ Closes the server after the scenario
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 在场景结束后关闭服务器
- en: Finally, we can test the call. We will do this in the `theResponseShouldBe`
    function. In it, we assemble the API call and verify the results as in the following
    listing.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以测试这个调用。我们将在`theResponseShouldBe`函数中这样做。在其中，我们组装API调用并验证结果，如下面的列表所示。
- en: Listing 9.11 `main_test.go`
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.11 `main_test.go`
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Creates the URL to call based on the word
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 根据单词创建要调用的URL
- en: ❷ Sets the language to translate
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置翻译的语言
- en: ❸ Captures the result in a known struct
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将结果捕获到已知的结构体中
- en: ❹ Verifies the word
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 验证单词
- en: And there we have it! Type `godog run` again, and see what the results are.
    Now create another scenario for another language if you want! Does it work? Next,
    let’s add our requirements for the database.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就到这里吧！再次输入`godog run`，看看结果如何。现在如果你想要的话，可以创建另一个语言的场景！它工作了吗？接下来，让我们添加数据库的要求。
- en: 9.4 Adding a database
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4 添加数据库
- en: To start, we’ll add a new requirement that requires us to move outside of our
    static data set and instead uses an external database. This same set of tests
    could have been used for connecting to our external service. Imagine for a minute
    that the QA team is writing all of these requirements against the old system originally.
    Then you move them to the new project as you start your strangler application.
    You will know when you’ve reached a level of parity when all of the tests pass.
    Once we’ve flipped a configuration to use the database, we can once again verify
    that everything is ready to be deployed (see the following listing).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加一个新的要求，这个要求需要我们离开我们的静态数据集，转而使用外部数据库。这组相同的测试原本也可以用于连接我们的外部服务。想象一下，如果QA团队最初是在旧系统上编写所有这些要求，然后你随着你的strangler应用开始，将他们移动到新项目中。当你所有的测试都通过时，你就知道你已经达到了平衡。一旦我们将配置翻转以使用数据库，我们就可以再次验证一切是否都已准备好部署（见下面的列表）。
- en: Listing 9.12 `app.feature`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.12 `app.feature`
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we run our tests now, we should see a failure. Think back to chapter 3 and
    remember our fail, pass, fail pattern. This means our project manager or someone
    else can monitor our progress on a feature as we develop it. Reports can be generated
    to show the coverage and progress toward completing all scenarios within a given
    feature and can be dubbed *feature complete*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行我们的测试，我们应该看到失败。回想一下第3章，并记住我们的失败、通过、失败的模式。这意味着我们的项目经理或其他人可以在我们开发功能时监控我们的进度。可以生成报告来显示特定功能中所有场景的覆盖率和完成进度，并可以被称为*功能完成*。
- en: It’s also extremely important to note that this set of app features can be tested
    on both a backend API and a frontend screen. The completeness of a feature can
    be verified by a series of integration tests, not just a single one!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点非常重要，这个应用功能集可以在后端API和前端屏幕上测试。一个功能的完整性可以通过一系列集成测试来验证，而不仅仅是单一的一个测试！
- en: As for our feature, we can imagine a larger collection of translations that
    we need to verify. Our current solution of keeping all our translations in a switch
    statement in code is not scalable, nor does it allow us to add or remove languages
    without restarting the service, so we will add a database to our system. Databases
    are specialized data storage applications that do a much better job of managing
    and handling our various pieces of data. We will then test the integration between
    our service and the external dependency, which in this case is a database.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的功能，我们可以想象一个更大的翻译集合需要我们验证。我们当前在代码中的switch语句中保留所有翻译的解决方案既不可扩展，也不允许我们在不重新启动服务的情况下添加或删除语言，因此我们将向我们的系统添加数据库。数据库是专门的数据存储应用程序，在管理和处理我们的各种数据方面做得更好。然后我们将测试我们的服务与外部依赖项（在这种情况下是数据库）之间的集成。
- en: There are many database options, but we will use the extremely simple (yet powerful)
    key-value store called Redis, which is very lightweight and will work very similarly
    to the caching mechanism we implemented earlier. We’ll break down this work into
    development and then testing. We need to have a way to establish a connection
    before we can set up our tests. Remember, all we need is a service that implements
    our `Translator` interface, and we can drop it right into our existing handler.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多数据库选项，但我们将使用一个非常简单（但强大）的键值存储，称为 Redis，它非常轻量级，并且将非常类似于我们之前实现的缓存机制。我们将把这个工作分解为开发和测试。在我们设置测试之前，我们需要有一种建立连接的方法。记住，我们只需要一个实现我们的
    `Translator` 接口的服务，然后我们就可以将其直接放入现有的处理器中。
- en: First, let’s add Redis to our infrastructure. Remember in chapter 7 when we
    introduced `docker-compose` to help us build our containers? We will use the same
    technology to manage our dependencies. Let’s add Redis as a dependency to our
    `docker-compose.yml` file, as in the following listing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将 Redis 添加到我们的基础设施中。记得在第 7 章中我们引入了 `docker-compose` 来帮助我们构建容器吗？我们将使用相同的技术来管理我们的依赖项。让我们将
    Redis 作为依赖项添加到我们的 `docker-compose.yml` 文件中，如下所示。
- en: Listing 9.13 `docker-compose.yml`
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.13 `docker-compose.yml`
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Creates a new service called database
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新的名为 database 的服务
- en: ❷ Uses the latest Redis container definition
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用最新的 Redis 容器定义
- en: ❸ Exposes the Redis port for use by the API
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 Redis 端口暴露给 API 使用
- en: ❹ Mounts the database backup for testing use
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将数据库备份挂载用于测试
- en: If you run `docker-compose` `up` `-d database` and then type `docker` `exec`
    `-it` `database redis-cli`, you should see a prompt appear. If you type `ping`,
    you should get a `pong` response. Congratulations! You’ve just started a database!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 `docker-compose` `up` `-d database` 然后输入 `docker` `exec` `-it` `database
    redis-cli`，你应该会看到一个提示出现。如果你输入 `ping`，你应该得到一个 `pong` 响应。恭喜！你刚刚启动了一个数据库！
- en: Let’s create a connection. We already updated our configuration to handle the
    connection string to the database. Now we’ll create a new file in the `translation`
    package. We’ll call it `database.go`. The first thing we do is create a function
    that returns a connection struct. We’ll use this struct to implement the `Translator`
    interface. We’ll create just enough code to be able to start writing our tests.
    Let’s write the code in the following listing.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个连接。我们已经更新了我们的配置来处理数据库的连接字符串。现在我们将在 `translation` 包中创建一个新的文件。我们将称之为 `database.go`。我们首先创建一个返回连接结构体的函数。我们将使用这个结构体来实现
    `Translator` 接口。我们将创建足够的代码以便开始编写我们的测试。让我们在以下列表中编写代码。
- en: Listing 9.14 `database.go`
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.14 `database.go`
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ This is a type verification so that we know our service satisfies the interface.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是一个类型验证，这样我们知道我们的服务满足接口。
- en: ❷ Returns a new connection struct using database configuration
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用数据库配置返回一个新的连接结构体
- en: ❸ A close function is needed to clean up a connection.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 需要一个关闭函数来清理连接。
- en: ❹ Just do the minimal amount of work to get started.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 只做最少的努力以开始。
- en: Now we can create our integration tests. Thanks to our operations team, we were
    able to get a backup of the production database, so as part of our tests, we will
    load the backed-up database into a Docker container and run our service against
    it. This will simulate, as closely as possible, a production environment to test.
    Let’s create the setup for our suite (see the following listing).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们的集成测试了。多亏了我们的运维团队，我们能够获取到生产数据库的备份，因此作为我们测试的一部分，我们将把备份的数据库加载到 Docker
    容器中，并针对它运行我们的服务。这将尽可能地模拟生产环境进行测试。让我们为我们的测试套件创建设置（见以下列表）。
- en: Listing 9.15 `main_test.go`
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.15 `main_test.go`
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ This will run before each suite, which differs from the setup that runs on
    each scenario.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这将在每个测试套件之前运行，这与在每个场景上运行的设置不同。
- en: ❷ Creates a new docker connection pool
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个新的 Docker 连接池
- en: ❸ Mounts the database backup
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将数据库备份挂载
- en: ❹ Runs the docker container
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 运行 Docker 容器
- en: ❺ Shuts down the container when finished
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 完成后关闭容器
- en: Now we need to update our scenario setup as well (see the following listing).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们还需要更新我们的场景设置（见以下列表）。
- en: Listing 9.16 `main_test.go`
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.16 `main_test.go`
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Sets the database to connect to Docker on your machine
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将数据库设置为连接到您机器上的 Docker
- en: ❷ The Docker library randomly creates a port to connect to.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Docker 库随机创建一个端口进行连接。
- en: Finally, we edit our main file to use the new URL from the database we just
    started (see the following code listing).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们编辑我们的主文件以使用我们刚刚启动的数据库的新 URL（见以下代码列表）。
- en: Listing 9.17 `main.go`
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.17 `main.go`
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ If the database is set, we use this as our service through dependency injection.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果数据库已设置，我们通过依赖注入使用这个服务。
- en: Now we can run our tests and see them fail. Great! Let’s update our implementation
    code to retrieve files. According to the documentation, the translated values
    are stored in a format of `language:word`, where all `word` variables are in English,
    so our logic becomes fairly simple, as in the following listing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行我们的测试，并看到它们失败。太好了！让我们更新我们的实现代码来检索文件。根据文档，翻译的值存储在`language:word`的格式中，其中所有`word`变量都是英文，所以我们的逻辑变得相当简单，如下所示。
- en: Listing 9.18 `database.go`
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.18 `database.go`
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Queries the database by constructing the key from the word and language
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过从单词和语言构建键来查询数据库
- en: ❷ Returns the string value
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回字符串值
- en: Run our tests again, and you should see them pass!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行我们的测试，你应该会看到它们通过！
- en: NOTE Hopefully, some of you were wondering why we didn’t create tests specifically
    to test the database instead of relying on the integration tests. This is because
    it was out of the scope for this chapter, but it is a great exercise. You can
    use the same database setup as earlier or look into some other in-memory database
    testing solutions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：希望你们中的一些人在想为什么我们没有创建专门测试数据库的测试，而是依赖于集成测试。这是因为这超出了本章的范围，但它是一个很好的练习。你可以使用之前相同的数据库设置，或者查看一些其他内存数据库测试解决方案。
- en: Can you think of other tests that could be added? Or other features that we
    perhaps didn’t cover?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到其他可以添加的测试吗？或者是我们可能没有涵盖的其他功能？
- en: 9.5 Releasing
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5发布
- en: Let’s look at our testing pyramid (figure 9.1).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的测试金字塔（图9.1）。
- en: '![](../../OEBPS/Images/CH09_F01_Holmes4.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH09_F01_Holmes4.png)'
- en: Figure 9.1 End-to-end tests are smaller at the top because they are more expensive
    and not as dependable. They should be supported by larger suites of integration
    and unit tests. Each layer should run on its own, starting with unit tests and
    progressing up the pyramid in different phases.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1端到端测试在顶部较小，因为它们成本更高且可靠性不高。它们应该由更大的集成和单元测试套件支持。每一层都应该独立运行，从单元测试开始，然后在不同阶段向上推进金字塔。
- en: We have covered all tiers of the pyramid, starting with our unit tests from
    chapter 3, our acceptance tests from chapter 6, and now our integration tests
    from this chapter. Does this mean we’re done? No, not even close. This is when
    you and your team need to start monitoring how much coverage you have and how
    long these tests take. Ideally, you don’t want your test suites to run more than
    5–10 minutes for them to be effective. Integration tests can be separated into
    various groups for speed. For example, a subset of tests can run against the core
    features, while a longer suite could be used for all regressions (old problems).
    This group of tests is often referred to as *functional testing*, or tests that
    verify the specifications of the application. Table 9.1 gives a brief overview
    of these different types.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了金字塔的所有层级，从第3章的单元测试开始，第6章的验收测试，以及现在本章的集成测试。这意味着我们完成了吗？不，还远远没有。这是你和你团队需要开始监控覆盖率以及测试所需时间的时候。理想情况下，你不想让你的测试套件运行超过5-10分钟，这样它们才是有效的。集成测试可以根据速度分成不同的组。例如，测试子集可以针对核心功能运行，而较长的套件可以用于所有回归（旧问题）。这个测试组通常被称为*功能测试*，或验证应用程序规格的测试。表9.1给出了这些不同类型的简要概述。
- en: Table 9.1 Types of functional tests
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1功能测试类型
- en: '| Type | Description | Answers the question |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 | 回答问题 |'
- en: '| Smoke test | Preliminary test to check for basic functionality | Does it
    turn on? |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 烟雾测试 | 检查基本功能的初步测试 | 它能启动吗？ |'
- en: '| Sanity test | Validates high-level calculations such as aggregations or mathematical
    calculations | Is the count of items correct? |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 精神测试 | 验证高级计算，如聚合或数学计算 | 项目数量正确吗？ |'
- en: '| Regression test | Verifies that previously reported bugs have been addressed
    | Did this used to work? |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 回归测试 | 验证之前报告的缺陷是否已解决 | 这之前能工作吗？ |'
- en: '| Usability test | Evaluates customer interactions with the product | How do
    people use this feature? |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 可用性测试 | 评估客户与产品的互动 | 人们如何使用这个功能？ |'
- en: 'When would it be appropriate to run these tests in our chain? In the previous
    chapter, we discussed releases: we want to release only when our code is stable,
    so we want to use these tests as a way of knowing that everything is stable to
    release. In theory, all of our unit tests and acceptance tests should support
    our integration tests, so there shouldn’t be any surprises when we tag or release.
    Yet we want one final guard against releasing broken code, so we will add an integration
    testing phase in our build (see the following code listing) that will happen only
    after a release has been made but before it is pushed to production.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的链中何时运行这些测试是合适的呢？在上一章中，我们讨论了发布：我们希望在代码稳定时才进行发布，因此我们希望使用这些测试作为一种方式来确认一切都已经稳定到可以发布。从理论上讲，我们所有的单元测试和验收测试都应该支持我们的集成测试，所以当我们打标签或发布时，不应该有任何意外。然而，我们还想增加一个最后的防护措施来防止发布有缺陷的代码，因此我们将在构建过程中添加一个集成测试阶段（见下面的代码列表），这个阶段将在发布完成但推送到生产之前发生。
- en: Listing 9.19 `ci.yaml`
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.19 `ci.yaml`
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Installs Godog and runs your smoke tests
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安装Godog并运行你的烟雾测试
- en: ❷ Builds the application only after the smoke tests succeed
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 仅在烟雾测试成功后构建应用程序
- en: ❸ Builds the container only after the smoke tests succeed
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 仅在烟雾测试成功后构建容器
- en: We decide to put the feature tests after the unit tests. This allows us to move
    up the testing tree before we start to build. The way we constructed our integration
    tests means we can get insight if our system works when it starts up. In the days
    of hand-soldered circuit boards, this was known as a *smoke test* because if it
    smoked when it was plugged in, there was a problem. Today’s smoke tests verify
    that a system starts and has basic functionality. Therefore, our integration tests
    can be our smoke tests as well.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定在单元测试之后放置功能测试。这允许我们在开始构建之前提升测试树。我们构建集成测试的方式意味着我们可以在系统启动时获得洞察。在手工焊接电路板的时代，这被称为*烟雾测试*，因为如果插入时冒烟，就存在问题。今天的烟雾测试验证系统是否启动并具有基本功能。因此，我们的集成测试也可以是我们的烟雾测试。
- en: Often, labels are given to certain tests to denote if they are part of a smoke
    test or a larger *regression test* suite. These can correspond to the functional
    testing types. We can possibly run additional checks after our smoke tests run.
    A smoke test failure will stop the pipeline, but a regression suite may be a flag
    for someone to verify that something has changed. This becomes an automated QA
    system that can allow QA members to spend most of their time exploring the system
    to find additional bugs. In the next listing, let’s adjust our scenarios to use
    labels and update one last flag to our CI for smoke tests.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，标签会被赋予某些测试以表示它们是否是烟雾测试的一部分或更大的*回归测试*套件的一部分。这些可以对应于功能测试类型。我们可能在烟雾测试运行后运行额外的检查。烟雾测试失败将停止管道，但回归套件可能是一个标志，提示某人验证是否有所变化。这变成了一种自动化的质量保证系统，可以允许质量保证成员花大部分时间探索系统以找到额外的错误。在下一个列表中，让我们调整我们的场景以使用标签，并更新CI的最后一个标志以进行烟雾测试。
- en: Listing 9.20 `api.feature`
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.20 `api.feature`
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ A separate test type to be run
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 运行一个单独的测试类型
- en: Edit our CI to run only the smoke tests first and then a second step to test
    regressions (see the following listing).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑我们的CI以首先运行烟雾测试，然后进行第二个步骤以测试回归（见下面的列表）。
- en: Listing 9.21 `ci.yaml`
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9.21 `ci.yaml`
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Establishes a longer or more comprehensive test suite to run periodically
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 建立一个更长时间或更全面的测试套件，定期运行
- en: ❷ Specifies the regression suite
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 指定回归套件
- en: As you see your pipeline turn green, the QA manager walks by. Now is a great
    time to show them what you’ve been able to accomplish. You show the different
    feature tests and explain how we can take all of the requirements they want and
    put them in the various test suites. Upon seeing the green scenarios, they smile,
    the first time you’ve seen them do so.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到你的管道变绿时，质量保证经理走过。现在是展示你所能完成的事情的大好时机。你展示了不同的功能测试，并解释了我们如何将他们想要的全部要求放入各种测试套件中。当他们看到绿色的场景时，他们笑了，这是你第一次看到他们这样做。
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Using behavior-driven development helps the whole team establish requirements.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用行为驱动开发有助于整个团队建立需求。
- en: Gherkin provides a universal language to write behavior-driven tests that can
    be implemented by different teams.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gherkin提供了一种通用的语言来编写行为驱动测试，这些测试可以被不同的团队实现。
- en: External dependencies for integration tests can be provided by using containers
    to replicate real-world services.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试的外部依赖可以通过使用容器来复制现实世界的服务来提供。
- en: Tags can be used to help focus test suites and shorten the overall runtime of
    tests.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签可用于帮助聚焦测试套件并缩短测试的整体运行时间。
