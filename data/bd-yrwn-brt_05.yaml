- en: 5 Controlling robots remotely
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 远程控制机器人
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Executing robot commands over the network using SSH
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过SSH在网络中执行机器人命令
- en: Creating web services to control robots
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于控制机器人的Web服务
- en: Calling robot web services from Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Python调用机器人网络服务
- en: Creating Python-based remote execution functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基于Python的远程执行函数
- en: Measuring the execution time of local and remote HTTP commands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量本地和远程HTTP命令的执行时间
- en: Building a high-performance Python client with low-latency calls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建具有低延迟调用的高性能Python客户端
- en: This chapter will teach you how to share your robot over your network so that
    remote Python clients can issue movement commands to control it. Both SSH and
    HTTP protocols will be used, meaning that two solutions from a protocol perspective
    will be offered, each with its own set of benefits and tradeoffs. For the HTTP
    solution, a simple Python client will be created first, followed by a more complex,
    higher-performance low-latency client. Furthermore, different techniques for measuring
    the execution time will be covered as well. This will provide a quantitative basis
    to compare the performance of different protocols and clients.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教会你如何通过网络共享你的机器人，以便远程Python客户端可以发出运动命令来控制它。将使用SSH和HTTP协议，这意味着从协议的角度将提供两种解决方案，每种方案都有其自身的优点和权衡。对于HTTP解决方案，首先将创建一个简单的Python客户端，然后是一个更复杂、性能更高、延迟更低的客户端。此外，还将涵盖不同的测量执行时间的技术。这将提供一个定量基础来比较不同协议和客户端的性能。
- en: Controlling robots remotely is an essential part of many projects, such as using
    apps on mobile phones and laptops to control robots, as well as controlling a
    fleet of robots using a central robot server. The projects in this chapter make
    it possible to control robots in the same room or many miles away. Unlike short-range
    protocols such as Bluetooth, both SSH and HTTP support short- and long-range connectivity.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 远程控制机器人是许多项目的基本部分，例如使用手机和笔记本电脑上的应用程序控制机器人，以及使用中央机器人服务器控制机器人编队。本章中的项目使得可以在同一房间或数英里之外控制机器人。与蓝牙等短距离协议不同，SSH和HTTP都支持短距离和长距离连接。
- en: 5.1 Hardware stack
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 硬件堆栈
- en: Figure 5.1 shows the hardware stack, with the specific components used in this
    chapter highlighted. The robot will be connected to wired networks using the Ethernet
    port and wireless networks using the Wi-Fi hardware. The Wi-Fi connectivity gives
    the robot the greatest freedom of movement, allowing it to move around without
    any attached wires. However, wired Ethernet connections at times can give better
    performance. This chapter will show how to take network performance measurements
    so that these two options can be compared.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1展示了硬件堆栈，本章中使用的特定组件被突出显示。机器人将通过以太网端口连接到有线网络，通过Wi-Fi硬件连接到无线网络。Wi-Fi连接为机器人提供了最大的移动自由度，允许它在没有任何连接线的情况下移动。然而，有时有线以太网连接可以提供更好的性能。本章将展示如何进行网络性能测量，以便比较这两种选项。
- en: '![](../Images/CH05_F01_Alsabbagh.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1](../Images/CH05_F01_Alsabbagh.png)'
- en: 'Figure 5.1 Hardware stack: remote clients will connect using either the Ethernet
    or Wi-Fi hardware.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 硬件堆栈：远程客户端将使用以太网或Wi-Fi硬件进行连接。
- en: 5.2 Software stack
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 软件堆栈
- en: Details of the specific software used in this chapter are illustrated in figure
    5.2 and described in the text that follows. The three main applications in this
    chapter will implement a remote client over the SSH protocol (`ssh_client.py`),
    serving robot web services (`robows.py`), and a web service client using persistent
    connections (client_persist.py). The Tornado web framework will be used to create
    the HTTP solution. The `subprocess` and `argparse` Python modules will be used
    in constructing the SSH solution. The first HTTP client will use the `urllib`
    module, and then a more advanced version will use the `http.client` module.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的特定软件的详细信息在图5.2中展示，并在随后的文本中进行描述。本章将实现三个主要应用：通过SSH协议（`ssh_client.py`）实现远程客户端、提供机器人网络服务（`robows.py`）以及使用持久连接的Web服务客户端（`client_persist.py`）。将使用Tornado
    Web框架来创建HTTP解决方案。在构建SSH解决方案时将使用`subprocess`和`argparse` Python模块。第一个HTTP客户端将使用`urllib`模块，然后是一个更高级的版本，使用`http.client`模块。
- en: '![](../Images/CH05_F02_Alsabbagh.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2](../Images/CH05_F02_Alsabbagh.png)'
- en: 'Figure 5.2 Software stack: the Tornado web framework will expose robot commands
    over the HTTP protocol.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2软件堆栈：Tornado Web框架将通过HTTP协议公开机器人命令。
- en: 'Going deeper: Web frameworks'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨：Web框架
- en: When creating a web application in Python, it is almost always a good idea to
    use a web framework. There are so many details that need to be taken care of when
    creating a web application, and web frameworks do a great job of addressing these
    needs. In Python, we have many great options to choose from, such as the Django
    ([https://www.djangoproject.com](https://www.djangoproject.com)) and Flask ([https://flask.palletsprojects.com](https://flask.palletsprojects.com))
    web frameworks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中创建网络应用时，几乎总是使用网络框架是一个好主意。创建网络应用时需要处理的细节非常多，而网络框架在这方面做得非常好。在Python中，我们有众多优秀的选择，例如Django([https://www.djangoproject.com](https://www.djangoproject.com))和Flask([https://flask.palletsprojects.com](https://flask.palletsprojects.com))网络框架。
- en: In our case, we will use the Tornado web framework ([https://www.tornadoweb.org](https://www.tornadoweb.org))
    because it has a special feature that makes it perfect for our needs. Most web
    frameworks, such as Django and Flask, do not come with a production-ready web
    application server that can safely control hardware such as our robot motors.
    Tornado, however, offers such options. It lets our web application run in a single
    long-running process for the whole life cycle of the web server. This process
    also gets exclusive access to our robot motors, as it will only allow one web
    request to move the robot motors at a time. In this way, we can avoid race conditions
    and keep our web application safe and simple to implement.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将使用Tornado网络框架([https://www.tornadoweb.org](https://www.tornadoweb.org))，因为它具有一个特殊功能，使其非常适合我们的需求。大多数网络框架，如Django和Flask，都不附带一个生产就绪的网络应用服务器，无法安全地控制像我们的机器人电机这样的硬件。然而，Tornado提供了这样的选项。它允许我们的网络应用在整个网络服务器生命周期内运行在一个单一的长运行进程中。此进程也获得了对我们机器人电机的独家访问权限，因为它一次只允许一个网络请求移动机器人电机。这样，我们可以避免竞态条件，并保持我们的网络应用安全且易于实现。
- en: 5.3 Robot testing tips
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 机器人测试技巧
- en: For details on assembling and configuring the robot hardware, check the robot
    assembly guide in appendix C. There are two tips that can help you when working
    with the
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有关组装和配置机器人硬件的详细信息，请参阅附录C中的机器人组装指南。有两个技巧可以帮助您在处理机器人时使用。
- en: assembled robot in this chapter. The first tip is to place the robot on a stand
    when initially testing your code base. Figure 5.3 shows the robot placed on a
    stand that lets its wheels move freely without the robot moving around. In this
    way, you can safely place the robot on a table during testing and not worry about
    accidentally driving it off the table and damaging it. This is particularly useful
    when you have new, untested code that might enter into a state of starting the
    motors and not stopping them, which may send the robot in some direction only
    to crash into a wall or some other object.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中组装的机器人。第一个技巧是在最初测试代码库时将机器人放置在支架上。图5.3显示了机器人放置在支架上，使其轮子可以自由移动而机器人不会移动。这样，您可以在测试期间安全地将机器人放在桌子上，而不用担心不小心将其从桌子上开走并损坏它。这对于您有新代码且尚未测试，可能会进入启动电机而不停止的状态特别有用，这可能导致机器人向某个方向移动，最终撞到墙壁或其他物体。
- en: '![](../Images/CH05_F03_Alsabbagh.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F03_Alsabbagh.png)'
- en: 'Figure 5.3 Robot stand: for safety, the robot can be placed on a stand.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 机器人支架：为了安全起见，可以将机器人放置在支架上。
- en: The second tip is to use SlimRun Ethernet cables instead of standard ones. These
    cables are lighter and thinner than standard network cables, which gives the robot
    more maneuverability when driving with a wired network connection. Figure 5.4
    shows a SlimRun network cable connected to the robot.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个技巧是使用SlimRun以太网电缆而不是标准电缆。这些电缆比标准网络电缆轻且薄，当机器人通过有线网络连接驱动时，这为机器人提供了更多的灵活性。图5.4显示了连接到机器人的SlimRun网络电缆。
- en: '![](../Images/CH05_F04_Alsabbagh.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH05_F04_Alsabbagh.png)'
- en: 'Figure 5.4 Robot network cable: the network cable is connected to the Ethernet
    port on the robot.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 机器人网络电缆：网络电缆连接到机器人上的以太网端口。
- en: Using these two tips can protect your robot against unnecessary damage and make
    it more maneuverable over wired connections. Keep your robot safe because a broken
    robot is no fun.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个技巧可以保护您的机器人免受不必要的损坏，并使其在有线连接中更加灵活。请确保您的机器人安全，因为一个损坏的机器人并不好玩。
- en: 5.4 Controlling robots over SSH
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 通过SSH控制机器人
- en: 'We will use the SSH protocol for our first solution to control robots over
    a network. SSH is easier to get started with because we already have our SSH server
    setup in place, and we will use SSH clients and connections throughout the book
    to connect to our robot. We need to create some Python code on top of SSH to meet
    the following requirements:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 SSH 协议作为我们第一个解决方案来通过网络控制机器人。SSH 更容易上手，因为我们已经设置了 SSH 服务器，并且我们将在整个书中使用 SSH
    客户端和连接来连接到我们的机器人。我们需要在 SSH 之上创建一些 Python 代码以满足以下要求：
- en: Create a Python script that will be executed on the SSH server receiving the
    movement action and optional movement arguments, and perform the robot movements.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个将在 SSH 服务器上执行的 Python 脚本，接收动作和可选的动作参数，并执行机器人动作。
- en: Create a Python function for the SSH client that receives the name of the movement
    action and connects to the robot and remotely executes the same movement.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 SSH 客户端创建一个 Python 函数，该函数接收动作名称并连接到机器人，然后远程执行相同的动作。
- en: 5.4.1 Creating the server-side script
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 创建服务器端脚本
- en: 'The first step is to import all the necessary modules. We import `ArgumentParser`
    from the `argparse` module that is part of the Python standard library and that
    will perform all the heavy lifting for parsing command line arguments. The `motor`
    module is the library created in chapter 3 for controlling the robot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是导入所有必要的模块。我们从 Python 标准库中的 `argparse` 模块导入 `ArgumentParser`，该模块将执行所有繁重的解析命令行参数的工作。`motor`
    模块是第 3 章中创建的用于控制机器人的库：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The function `parse_args` is then defined, and it takes care of all the command
    line argument parsing. It first creates an `ArgumentParser` object and then configures
    the parser. One required argument called `name` will capture the name of the movement.
    Then the optional `--duration` and `--speed` arguments are configured. They are
    both configured with their correct data type and a help message. The last line
    of the function will perform the actual parsing, and it uses the `vars` function
    to return the result as a `dict` object:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后定义了 `parse_args` 函数，并负责处理所有命令行参数解析。它首先创建一个 `ArgumentParser` 对象，然后配置解析器。一个名为
    `name` 的必需参数将捕获动作名称。然后配置可选的 `--duration` 和 `--speed` 参数。它们都配置了正确的数据类型和帮助信息。函数的最后一条语句将执行实际的解析，并使用
    `vars` 函数将结果作为 `dict` 对象返回：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `main` function will first call `parse_args` and save the result in the
    `args` variable. The name of the movement function to be called is then removed
    from `args` and saved in the `name` variable. Now the movement function can be
    looked up from the `motor` module using `getattr`. The next step is to collect
    all the optional arguments that have been specified and save them in a dictionary
    called `kwargs`. Finally, the function to be called is printed and called:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数首先调用 `parse_args` 并将结果保存到 `args` 变量中。要调用的动作函数名称然后从 `args` 中移除并保存到
    `name` 变量中。现在可以使用 `getattr` 从 `motor` 模块中查找动作函数。下一步是收集所有指定的可选参数并将它们保存到一个名为 `kwargs`
    的字典中。最后，打印并调用要调用的函数：'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The full script can be saved as `cli.py` on the Pi and then executed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为 Pi 上的 `cli.py` 文件，然后执行。
- en: 'Listing 5.1 `cli.py`: Creating command line interface to perform robot movements'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 `cli.py`：创建用于执行机器人动作的命令行界面
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following code is a session in the terminal demonstrating different calls
    to the script:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是终端中演示对脚本的不同调用的会话：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The script is first called without any arguments, which shows that the required
    argument validation is working. Next, the script is called with the help option,
    which shows the automatically generated help and usage messages. The robot is
    then requested to move forward with default and custom duration and speed options.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先不带任何参数调用，这表明必需参数验证正在工作。接下来，脚本带帮助选项调用，这显示了自动生成的帮助和用法信息。然后请求机器人以默认和自定义的持续时间和速度选项向前移动。
- en: 'Going deeper: Functions as first-class objects in Python'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解：Python 中的函数作为一等对象
- en: In this section, we were able to use `getattr` to look up a function and save
    it in a variable. This is not possible in all programming languages but is fully
    supported in Python because functions are treated as first-class objects. This
    means they can be assigned to variables, placed in lists, or passed as arguments
    to other functions like any other value. The post “First-class Everything” ([http://mng.bz/g7Bl](http://mng.bz/g7Bl))
    by the creator of the Python language, Guido van Rossum, is a great read to learn
    more about this feature in Python. In fact, this feature applies to all objects
    in Python, not just functions. It makes the language very versatile in terms of
    how we interact with functions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们能够使用`getattr`查找一个函数并将其保存到变量中。这并不是所有编程语言都支持的，但在Python中完全支持，因为函数被视为一等对象。这意味着它们可以被分配给变量、放置在列表中或作为参数传递给其他函数，就像任何其他值一样。Python语言的创造者Guido
    van Rossum的帖子“First-class Everything”（[http://mng.bz/g7Bl](http://mng.bz/g7Bl)）是了解Python中此功能的好文章。实际上，这个特性适用于Python中的所有对象，而不仅仅是函数。这使得语言在如何与函数交互方面非常灵活。
- en: 5.4.2 Running the script remotely
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 远程运行脚本
- en: 'Now that we have our script in place, we will start calling it from our SSH
    client. The SSH client can be any computer that is on the same network as the
    robot. On the client machine, run the following commands to generate SSH keys
    and transfer them to the robot:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经放置了脚本，我们将开始在SSH客户端中调用它。SSH客户端可以是与机器人处于同一网络上的任何计算机。在客户端机器上，运行以下命令以生成SSH密钥并将它们传输到机器人：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The hostname of the Pi was set as `robopi` as part of the installation process
    documented in appendix B. You can now add a line to your client machine’s hosts
    file with the `robopi` hostname and its associated IP address. In this way, you
    can follow the examples and connect to the robot using the name `robopi` instead
    of the robot’s IP address. The How-To Geek website provides an excellent guide
    on how to edit the hosts file on Windows, Mac, and Linux ([http://mng.bz/5owz](http://mng.bz/5owz)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 根据附录B中记录的安装过程，Pi的主机名被设置为`robopi`。现在您可以在客户端机器的hosts文件中添加一行，包含`robopi`主机名及其关联的IP地址。这样，您就可以按照示例使用`robopi`名称而不是机器人的IP地址来连接机器人。How-To
    Geek网站提供了一个关于如何在Windows、Mac和Linux上编辑hosts文件的优秀指南（[http://mng.bz/5owz](http://mng.bz/5owz)）。
- en: 'At this point, you will be able to execute commands on the robot from the client
    machine without having to enter a password and with a non-interactive session.
    What follows is a terminal session run from the client machine:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，您将能够从客户端机器上执行机器人命令，而无需输入密码，并且无需交互式会话。以下是从客户端机器上运行的终端会话：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this session, different remote commands are executed to get the name of
    the current user and the version of the Python interpreter. The Python virtual
    environment used here is the same as the one created during the installation process
    covered in appendix B. Next, we can try to execute the robot script. We will be
    running the script from the standard script location `~/bin` as described in chapter
    2:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个会话中，执行了不同的远程命令来获取当前用户名和Python解释器的版本。这里使用的Python虚拟环境与附录B中安装过程中创建的虚拟环境相同。接下来，我们可以尝试执行机器人脚本。我们将从第2章中描述的标准脚本位置`~/bin`运行脚本：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We have generated the script’s help message and requested the robot to move
    forward remotely over an SSH connection. We can now use the `time` command to
    measure the execution time when commands are run locally and when they are run
    remotely over SSH. The `time` command is available on both Mac and Linux. If you
    are using Windows, you can employ the PowerShell `Measure-Command` instead to
    measure the execution time. The output first shows the time needed to run the
    command locally on the robot and then the time needed to establish an SSH connection
    and execute the command. The timing that we care about is listed under the label
    `real`. In this session, local execution took 10 ms, while the same command over
    SSH took 314 ms:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经生成了脚本的帮助信息，并请求机器人通过SSH连接远程前进。现在我们可以使用`time`命令来测量在本地运行命令和通过SSH远程运行命令时的执行时间。`time`命令在Mac和Linux上都是可用的。如果您使用的是Windows，可以使用PowerShell的`Measure-Command`来测量执行时间。输出首先显示在机器人本地运行命令所需的时间，然后是建立SSH连接并执行命令所需的时间。我们关注的时间列在标签`real`下。在这个会话中，本地执行耗时10毫秒，而通过SSH执行相同的命令耗时314毫秒：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The reason for this additional time is that in this approach, a new SSH connection
    has to be established each time a new command is to be executed. It is useful
    to make these measurements to know what the overhead of this approach is. The
    `motor` module has a `noop` function that performs no operation and is perfect
    for measuring the execution times of purely calling functions in the module:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种额外时间的原因是，在这种方法中，每次要执行新命令时，都必须建立一个新的 SSH 连接。了解这种方法的开销是有用的。`motor` 模块有一个 `noop`
    函数，它执行无操作，非常适合测量模块中纯函数调用的执行时间：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From the output, we can see that a local call takes 713 ms and a remote one
    takes 1,036 ms. The difference is 323 ms, which is in line with our previous sampling
    of SSH overheads. The `time` command is a great way to take quick performance
    measurements. Later in the chapter, as we improve on these performance numbers,
    we will explore more accurate ways to measure performance within Python itself.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到本地调用耗时 713 毫秒，而远程调用耗时 1,036 毫秒。差异为 323 毫秒，这与我们之前对 SSH 过程开销的采样相符。`time`
    命令是进行快速性能测量的好方法。在章节的后面部分，当我们改进这些性能数字时，我们将探讨在 Python 内部更精确地测量性能的方法。
- en: 5.4.3 Creating the client-side script
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.3 创建客户端脚本
- en: 'The next step will be implementing the Python function that runs on the client
    machine, connects to the robot SSH server, and executes the robot commands. The
    `check_output` function is imported from the `subprocess` module, which is part
    of the Python standard library. We can use `check_output` to execute the required
    SSH client commands:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现运行在客户端机器上的 Python 函数，连接到机器人 SSH 服务器并执行机器人命令。`check_output` 函数是从 `subprocess`
    模块导入的，它是 Python 标准库的一部分。我们可以使用 `check_output` 来执行所需的 SSH 客户端命令：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Three constants are then defined. The `SSH_USER` and `SSH_HOST` specify the
    user and host, respectively, to be used for the SSH connections. The `SSH_CLI_CMD`
    has the path to the Python interpreter and robot script to be remotely executed
    on the robot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后定义了三个常量。`SSH_USER` 和 `SSH_HOST` 分别指定用于 SSH 连接的用户和主机。`SSH_CLI_CMD` 包含要远程在机器人上执行的
    Python 解释器和机器人脚本的路径：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we define the `call_ssh` that will SSH as the user `user` to the host
    `host` and execute the provided `remote_cmd` on that remote server:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了 `call_ssh`，它将以用户 `user` 的身份连接到主机 `host` 并在远程服务器上执行提供的 `remote_cmd`：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `remote_robot` receives the name of the robot movement command to perform
    and executes that movement on the remote robot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`remote_robot` 接收要执行的机器人移动命令的名称，并在远程机器人上执行该移动：'
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, the `main` function loops through a list of movements and calls `remote_robot`
    for each movement to perform a demonstration:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main` 函数遍历一系列移动，并对每个移动调用 `remote_robot` 以进行演示：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The full script can be saved as `ssh_client.py` on the client machine and then
    executed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 完整脚本可以保存为客户端机器上的 `ssh_client.py` 并执行。
- en: 'Listing 5.2 `ssh_client.py`: Executing remote script over an SSH connection'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 `ssh_client.py`：通过 SSH 连接执行远程脚本
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This script issues remote commands to the robot, making it move forward, backward,
    and then spin right and left.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本向机器人发出远程命令，使其向前、向后移动，然后向右和向左旋转。
- en: 5.5 Creating web services for robots
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 创建机器人 Web 服务
- en: 'We will now use the HTTP protocol to create web services to control the robot
    remotely. A web service allows machines to make calls to each other over a network.
    We need to implement a set of web services in Python that meet the following requirements:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用 HTTP 协议创建用于远程控制机器人的 Web 服务。Web 服务允许机器在网络中相互调用。我们需要在 Python 中实现一组满足以下要求的
    Web 服务：
- en: A set of web services should be created in Python that can be called with a
    movement action and be given optional speed and duration parameters.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该在 Python 中创建一组可以调用以执行移动动作的 Web 服务，并可以提供可选的速度和持续时间参数。
- en: The web services should use the HTTP methods correctly. Specifically, calls
    using the GET method should not change the state of the robot, and all movement
    requests should be processed using the POST method.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 服务应正确使用 HTTP 方法。具体来说，使用 GET 方法的调用不应改变机器人的状态，并且所有移动请求都应使用 POST 方法处理。
- en: All web service calls should return their data in the JSON format, and any expected
    input data to the web services should also be encoded in the JSON format.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 Web 服务调用都应返回其数据为 JSON 格式，并且任何预期的 Web 服务输入数据也应编码为 JSON 格式。
- en: 5.5.1 Creating our first web service
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.1 创建我们的第一个 Web 服务
- en: 'When creating a web application in Python, it is often a good idea to use a
    web framework. There are many popular options to choose from. We will use the
    Tornado web framework, as it has many features and can safely interact with the
    robot hardware. Run the following line on the Pi to install the Tornado Python
    package:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中创建网络应用程序时，通常使用网络框架是一个好主意。有许多流行的选项可供选择。我们将使用 Tornado 网络框架，因为它具有许多功能，并且可以安全地与机器人硬件交互。在
    Pi 上运行以下行以安装 Tornado Python 包：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can start creating our first web application. This web application will
    expose a single web service that returns the current time on our robot server.
    First, we import the required modules. The `datetime` module will let us get the
    current time on the server. The Tornado `IOLoop` is needed to run the web server.
    The `RequestHandler` and `Application` objects will help us define the behavior
    of our web application:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始创建我们的第一个网络应用程序。这个网络应用程序将公开一个网络服务，该服务返回我们机器人服务器上的当前时间。首先，我们导入所需的模块。`datetime`
    模块将允许我们获取服务器上的当前时间。Tornado 的 `IOLoop` 是运行网络服务器所需的。`RequestHandler` 和 `Application`
    对象将帮助我们定义网络应用程序的行为：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next step is to define the `MainHandler` object that will handle incoming
    requests. We define one method called `get` to handle incoming HTTP GET requests.
    Each time it is called, it will save the current time as a string and then call
    the `write` method with the time stamp in a dictionary. In the Tornado framework,
    whenever you provide the `write` method with a dictionary object, it will automatically
    convert the output to the JSON format and set the appropriate HTTP response headers
    to indicate the content type is JSON:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义将处理 incoming 请求的 `MainHandler` 对象。我们定义了一个名为 `get` 的方法来处理 incoming HTTP
    GET 请求。每次调用它时，它将当前时间作为字符串保存，然后调用字典中的 `write` 方法。在 Tornado 框架中，每次您向 `write` 方法提供字典对象时，它将自动将输出转换为
    JSON 格式，并设置适当的 HTTP 响应头以指示内容类型为 JSON：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then create a Tornado application which will route incoming requests for
    the root path to `MainHandler`. After that, we set the web server to listen on
    port 8888 and start the main event loop, which will kick off the web server and
    handle incoming web requests:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后创建了一个 Tornado 应用程序，该程序将根路径的 incoming 请求路由到 `MainHandler`。之后，我们将网络服务器设置为监听端口
    8888 并启动主事件循环，这将启动网络服务器并处理 incoming 网络请求：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The full script can be saved as `datews.py` on the Pi and then executed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为 `datews.py` 在 Pi 上，然后执行。
- en: 'Listing 5.3 `datews.py`: Creating web service to report time on the robot server'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.3 `datews.py`：创建用于报告机器人服务器时间的网络服务
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Leave the script running in one terminal, and from another terminal connected
    to the Pi, run the following command to test the new web service:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个终端中运行脚本，然后从另一个连接到 Pi 的终端运行以下命令来测试新的网络服务：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The terminal session is using the `curl` command, which is an excellent tool
    for making HTTP requests in the terminal and viewing their responses. The first
    call shows the JSON data returned with a time stamp showing the current time on
    the robot server. We can now run the following command to get more details on
    the response headers:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 终端会话正在使用 `curl` 命令，这是一个在终端中制作 HTTP 请求并查看其响应的出色工具。第一次调用显示了返回的 JSON 数据，其中包含一个时间戳，显示了机器人服务器上的当前时间。我们现在可以运行以下命令来获取更多关于响应头部的详细信息：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This call displays the response headers where we can see that the response content
    type has been correctly set for the JSON output. You can make these web requests
    from any web browser on your network by replacing `localhost` with the IP address
    of the robot on your network.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用显示了响应头，我们可以看到响应内容类型已正确设置为 JSON 输出。您可以通过将 `localhost` 替换为网络上机器人的 IP 地址，从您的网络上的任何网络浏览器进行这些网络请求。
- en: 5.5.2 Creating web services to perform robot movements
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.2 创建执行机器人移动的网络服务
- en: 'We have implemented a simple web service. Now we can upgrade the code to add
    web services to make the robot move around. We must import two more modules. We
    will use the `json` module to parse JSON request data. The `motor` module will
    be used to control the robot motors as in previous chapters:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个简单的网络服务。现在我们可以升级代码以添加网络服务，使机器人能够移动。我们必须导入两个额外的模块。我们将使用 `json` 模块来解析 JSON
    请求数据。`motor` 模块将用于控制机器人电机，正如前几章所述：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We change the URL pattern to accept any string and then pass that as an argument
    when calling the method to handle the request. We do this so that the name of
    the movement to perform can be provided as the URL:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 URL 模式更改为接受任何字符串，然后在调用处理请求的方法时传递该字符串作为参数。我们这样做是为了能够将执行动作的名称作为 URL 提供：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This means we also need to update our previous request method to accept a `name`
    argument:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们还需要更新之前的方法，使其能够接受一个 `name` 参数：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The movement web services will change the state of the robot, so we will perform
    them when we get POST requests. The `post` method will handle these requests by
    first reading the request data and parsing it as JSON data. If the web service
    request has no input data, it will default the value to an empty dictionary. The
    next step is to take the name of the movement function and retrieve the function
    from the `motor` module using `getattr`. We can now call the function using the
    arguments provided in the web service request. The final line of code returns
    a success status message:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 移动 Web 服务将改变机器人的状态，因此我们将在接收到 POST 请求时执行它们。`post` 方法将通过首先读取请求数据并将其解析为 JSON 数据来处理这些请求。如果
    Web 服务请求没有输入数据，它将默认值为空字典。下一步是获取动作函数的名称，并使用 `getattr` 从 `motor` 模块中检索该函数。现在我们可以使用
    Web 服务请求中提供的参数调用该函数。代码的最后一行返回一个成功状态消息：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The full script can be saved as `robows.py` on the Pi and then executed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为 `robows.py` 在 Pi 上，然后执行。
- en: 'Listing 5.4 `robows.py`: Creating web service to perform robot movement commands'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.4 `robows.py`：创建执行机器人动作命令的 Web 服务
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can again leave the script running in one terminal and run the following
    commands from another terminal to test the web services:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将脚本在一个终端中运行，然后从另一个终端运行以下命令来测试 Web 服务：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the terminal session, we first check whether our time web service is still
    working. The second call demonstrates a shorter way to refer to a URL by not specifying
    the protocol. We then make a web service call to move the robot forward and then
    backward. The last two calls show how we can provide custom speed and duration
    settings for our movements.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端会话中，我们首先检查我们的时间 Web 服务是否仍然在运行。第二个调用演示了在不指定协议的情况下引用 URL 的更短方式。然后我们调用 Web 服务来使机器人向前和向后移动。最后两个调用展示了我们如何为我们的动作提供自定义的速度和持续时间设置。
- en: 5.6 Calling web services from Python
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 从 Python 调用 Web 服务
- en: 'Now that we have these powerful web services in place, we can move on to create
    code that calls them from anywhere in the network to make the robot move around.
    We need to implement a web service client in Python that meets the following requirements:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了这些强大的 Web 服务，我们可以继续创建代码，从网络中的任何位置调用它们，使机器人移动。我们需要实现一个满足以下要求的 Python
    Web 服务客户端：
- en: We should implement a function in Python that will receive the movement name
    and a set of optional movement arguments and then place the needed HTTP call to
    the robot web service to execute this movement.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该在 Python 中实现一个函数，该函数将接收动作名称和一组可选的动作参数，然后向机器人 Web 服务发出必要的 HTTP 调用来执行此动作。
- en: The implementation should use HTTP persistent connections to have a better network
    performance by having a lower latency when issuing multiple movement calls.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现应使用 HTTP 持久连接，通过在发出多个动作调用时具有更低的延迟来提高网络性能。
- en: 5.6.1 Using the read–evaluate–print loop to call web services
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.1 使用读取-评估-打印循环调用 Web 服务
- en: 'As a starting step, it will be helpful to start making calls to the web server
    using the Python REPL (read–evaluate–print loop). In this way, we can explore
    the different ways we can call web services and the results and data structures
    they will return. Open a REPL session on the client machine. The first part of
    our REPL adventure will be importing the modules we need. The command `urlopen`
    will be used to make calls to the web server, and `json` will be used to parse
    the JSON responses:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，使用 Python REPL（读取-评估-打印循环）开始向 Web 服务器发起调用将会很有帮助。这样，我们可以探索不同的调用 Web 服务的方式以及它们返回的结果和数据结构。在客户端机器上打开一个
    REPL 会话。我们 REPL 冒险的第一部分将是导入所需的模块。`urlopen` 命令将被用来调用 Web 服务器，而 `json` 将被用来解析 JSON
    响应：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The next line we execute will connect to the web server and consume the web
    service that returns the current time on the robot server. The raw JSON response
    is returned as bytes:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行的下一行将连接到 Web 服务器，并消费返回机器人服务器当前时间的 Web 服务。原始 JSON 响应以字节形式返回：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can save this response into a variable and then parse it so that we can
    access the time stamp value itself:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个响应保存到一个变量中，然后解析它，以便我们可以访问时间戳值本身：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, let’s move on to calling some web services to make the robot move around.
    When we provide a value for the `data` argument, `urlopen` will automatically
    set the HTTP method to be a POST method. The following call will make the robot
    move forward:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续调用一些网络服务来使机器人移动。当我们为 `data` 参数提供一个值时，`urlopen` 将自动将HTTP方法设置为POST方法。以下调用将使机器人向前移动：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can set custom movement options such as the speed with
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置自定义的运动选项，例如速度等
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We have now done enough exploring to slap together the first implementation
    of our web service client.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经探索得足够多了，可以拼凑出我们网络服务客户端的第一个实现。
- en: 5.6.2 Creating a basic web service client
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.2 创建基本的网络服务客户端
- en: 'The initial version of the client will have everything we need, except persistent
    connections. We import the same modules as in the REPL session to make requests
    to the web server and deal with JSON data:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的初始版本将包含我们所需的一切，除了持久连接。我们导入与REPL会话中相同的模块来向Web服务器发送请求并处理JSON数据：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, we define the `ROBO_URL` constant providing the base part of the URLs
    that we will use to make our calls:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义 `ROBO_URL` 常量，提供我们将用于调用的基础URL部分：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `call_api` will place the actual calls to the web service API. It receives
    the full URL and the requested data as a dictionary. It converts the received
    data to a JSON format and then calls the `encode` method to convert it to a bytes
    data type as expected by `urlopen`. Then, `urlopen` is called with the associated
    URL and request data:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`call_api` 将实际调用网络服务API。它接收完整的URL和作为字典的请求数据。它将接收到的数据转换为JSON格式，然后调用 `encode`
    方法将其转换为 `urlopen` 所期望的字节数据类型。然后，使用相关的URL和请求数据调用 `urlopen`：'
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `call_robot` function receives the movement name and any optional movement
    arguments. The URL for the related movement is generated, and then `call_api`
    is called:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`call_robot` 函数接收运动名称和任何可选的运动参数。生成相关运动的URL，然后调用 `call_api`：'
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The remaining parts of the script demonstrate the usage of the client by making
    different calls to `call_robot`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的脚本演示了通过向 `call_robot` 进行不同的调用来使用客户端：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The full script can be saved as `client_basic.py` on the Pi and then executed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为 `client_basic.py` 在Pi上，然后执行。
- en: 'Listing 5.5 `client_basic.py`: Calling a remote web service on the robot from
    a client'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.5 `client_basic.py`：从客户端调用机器人的远程网络服务
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When the script is run, it will make the robot move forward and backward using
    the default duration and speed settings. Next, forward and backward will be called
    again with custom settings. Finally, the robot will be made to spin right and
    left.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本运行时，它将使机器人向前和向后移动，使用默认的持续时间和速度设置。接下来，将再次使用自定义设置调用向前和向后。最后，将使机器人向右和向左旋转。
- en: 'Robots in the real world: Robot swarms'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界的机器人：机器人群体
- en: Having the ability to communicate with our robots in our software is a powerful
    and essential feature for a number of robotic applications. Swarm robotics is
    one of the fields that become possible once you have a mechanism to have robots
    in your swarm communicate with each other. By using the swarm intelligence or
    collective behavior of a swarm of robots, we start getting the emergence of intelligent
    global behavior. This swarm intelligence is found in nature with the sophistication
    in the design of ant colonies and beehives.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的软件中与机器人通信的能力是许多机器人应用中强大且基本的功能。群体机器人学是当你有了让群体中的机器人相互通信的机制后变得可能的一个领域。通过使用群体智能或群体机器人的集体行为，我们开始获得智能全局行为的出现。这种群体智能在自然界中存在，其复杂程度体现在蚂蚁群体和蜂巢的设计中。
- en: The real-world applications of these robot swarms vary from search-and-rescue
    missions to different medical applications. The Big Think ([http://mng.bz/6nDy](http://mng.bz/6nDy))
    article on this subject shows a nice example of a robot swarm and has a good discussion
    of the different practical applications of the technology.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些机器人群体的实际应用范围从搜索和救援任务到不同的医疗应用。关于这个主题的 Big Think ([http://mng.bz/6nDy](http://mng.bz/6nDy))
    文章展示了机器人群体的一个很好的例子，并对该技术的不同实际应用进行了良好的讨论。
- en: 5.6.3 Creating a web service client with persistent connections
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.3 创建具有持久连接的网络服务客户端
- en: 'Now that we have a basic client working, we can upgrade it to have persistent
    connections to improve the performance of our requests. The approach for this
    client will be very similar to the previous one but will use a different set of
    libraries. The first step will be to import the `HTTPConnection` object that offers
    persistent connection capabilities:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个基本的客户端正在运行，我们可以将其升级为具有持久连接以改善我们请求的性能。这个客户端的方法将与之前的一个非常相似，但将使用一组不同的库。第一步将是导入提供持久连接功能的
    `HTTPConnection` 对象：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `call_api` function will need to be changed to accept a connection object.
    After encoding the request body as JSON, we then send the request to the web server
    using the provided connection object. The request will use a POST method and will
    make a call to the provided URL with the generated request body. Then, we can
    use the `getresponse` method to read the response:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`call_api` 函数需要修改为接受一个连接对象。在将请求数据编码为 JSON 格式后，我们使用提供的连接对象将请求发送到 Web 服务器。该请求将使用
    POST 方法，并调用提供的 URL 以及生成的请求数据。然后，我们可以使用 `getresponse` 方法来读取响应：'
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `call_robot` function receives the connection object as an argument and
    passes the movement name as the requested URL and the movement arguments as the
    request body:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`call_robot` 函数接收连接对象作为参数，并将移动名称作为请求 URL，将移动参数作为请求数据：'
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We then create an `HTTPConnection` object with the robot hostname and web server
    port number. A number of calls are then made to `call_robot` to demonstrate its
    functionality:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个带有机器人主机名和 Web 服务器端口号的 `HTTPConnection` 对象。然后对 `call_robot` 进行多次调用以演示其功能：
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The full script can be saved as `client_persist.py` on the Pi and then executed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为 `client_persist.py` 在 Pi 上，然后执行。
- en: 'Listing 5.6 `client_persist.py`: Using persistent connections to call web services'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6 `client_persist.py`：使用持久连接调用 Web 服务
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When the script is run, it will go through three different speed settings and
    make the robot spin right and left at each setting.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本运行时，它将经过三个不同的速度设置，并在每个设置下使机器人向右和向左旋转。
- en: 'Going deeper: Persistent connections'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解：持久连接
- en: Under the hood, HTTP requests are transmitted over a TCP connection. Back in
    the day, each HTTP request would need to go through a new TCP connection. The
    HTTP protocol was then enhanced to allow for persistent connections or the ability
    to make multiple requests over a single TCP connection. This improved the network
    performance of web clients such as web browsers, as it cuts out the overhead of
    opening a new TCP connection for additional HTTP requests. The Mozilla Foundation
    documentation on the HTTP protocol ([https://developer.mozilla.org/Web/HTTP](https://developer.mozilla.org/Web/HTTP))
    covers the topic very well and is an excellent reference for getting more low-level
    details on the subject.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，HTTP 请求是通过 TCP 连接传输的。在过去，每个 HTTP 请求都需要通过一个新的 TCP 连接。HTTP 协议随后得到了增强，允许持久连接或在一个
    TCP 连接上发送多个请求。这提高了像网页浏览器这样的 Web 客户端的网络性能，因为它减少了为额外的 HTTP 请求打开新的 TCP 连接的开销。Mozilla
    基金会的 HTTP 协议文档（[https://developer.mozilla.org/Web/HTTP](https://developer.mozilla.org/Web/HTTP)）对该主题进行了很好的覆盖，是获取更多关于该主题的低级别细节的绝佳参考。
- en: The performance benefits of using persistent connections make it well worth
    the effort. It is a standard feature in all modern web browsers and will help
    us in building time-sensitive real-time robotic applications later in the book.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用持久连接的性能优势使其值得付出努力。它是所有现代网络浏览器的一个标准功能，并将帮助我们构建本书后面章节中时间敏感的实时机器人应用。
- en: 5.6.4 Measuring client performance
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6.4 测量客户端性能
- en: We have gone through all this trouble to add persistent connections. It’s worthwhile
    to create a script to measure the performance of this client. We can use the script
    to compare the timing of a fresh connection compared to reusing a persistent connection.
    These timings can also be compared to the results we obtained from the SSH client
    earlier in the chapter. Finally, we can make a comparison of local web service
    calls and remote calls over Wi-Fi and wired Ethernet connections.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们费尽周折添加了持久连接。创建一个脚本来测量这个客户端的性能是值得的。我们可以使用这个脚本来比较新连接与重用持久连接的时间。这些时间也可以与我们在本章早期获得的
    SSH 客户端的结果进行比较。最后，我们可以比较本地 Web 服务调用和通过 Wi-Fi 和有线以太网连接的远程调用。
- en: 'We will import `mean` to calculate the mean or average of our performance timings
    and `stdev` to calculate their sample standard deviation. The `perf_counter` function
    in the `time` module is to record the start and end times of function calls to
    measure performance. The documentation ([https://docs.python.org/3/library/time.html](https://docs.python.org/3/library/time.html))
    on `perf_counter` provides guidance on using it when doing performance measurements:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将导入`mean`来计算性能时间测量的平均值或平均数，以及`stdev`来计算它们的样本标准差。`time`模块中的`perf_counter`函数用于记录函数调用的开始和结束时间以测量性能。`perf_counter`的文档([https://docs.python.org/3/library/time.html](https://docs.python.org/3/library/time.html))提供了在性能测量中使用它的指导：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `get_noop_timing` function starts by saving the current time using the
    `perf_counter` function. Then, a call will be made to the `noop` movement function
    on the robot server. This is a no-operation call that we can use to measure performance
    between our client and server. Then, we calculate the time elapsed and multiply
    it by a thousand so that the return value is expressed in milliseconds:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_noop_timing`函数首先使用`perf_counter`函数保存当前时间。然后，将对机器人服务器上的`noop`移动函数进行调用。这是一个无操作调用，我们可以用它来测量客户端和服务器之间的性能。然后，我们计算经过的时间并将其乘以一千，以便返回值以毫秒表示：'
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We create a `HTTPConnection` object and make a call to the web server. We do
    this so that the next calls give more consistent results. Next, we create the
    connection object that we will use for all our measurements. The measurement for
    the first web service call is saved in the variable `init` so that we can keep
    track of how long the initial connection establishment and first call took. Then,
    we take one hundred timing samples and save them in `stats`. Now we can output
    the initial, maximum, average, minimum, and standard deviation of samples:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`HTTPConnection`对象并调用网络服务器。我们这样做是为了使后续的调用结果更加一致。接下来，我们创建一个连接对象，我们将使用它来进行所有测量。第一次网络服务调用的测量结果保存在变量`init`中，这样我们就可以跟踪初始连接建立和第一次调用所花费的时间。然后，我们进行一百次时间样本的测量并将它们保存在`stats`中。现在我们可以输出样本的初始值、最大值、平均值、最小值和标准差：
- en: '[PRE47]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The full script can be saved as `client_measure.py` on the Pi and then executed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本可以保存为`client_measure.py`在Pi上，然后执行。
- en: 'Listing 5.7 `client_measure.py`: Measuring performance when calling web services'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.7 `client_measure.py`：调用网络服务时的性能测量
- en: '[PRE48]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When we run the script, it will collect all the performance measurement timings
    and output them to the terminal. The following script was run locally on the robot
    server itself:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行脚本时，它将收集所有性能测量时间并将它们输出到终端。以下脚本是在机器人服务器本地运行的：
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'These numbers give us a sense of the overhead in making the web requests end
    to end, even before having any network packets exit the robot onto the network.
    Let’s look at the numbers we get when we connect to the robot server from a wired
    Ethernet connection on the network:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字让我们对在完成端到端网络请求时的开销有了概念，甚至在任何网络数据包从机器人传输到网络之前。让我们看看当我们从网络上的有线以太网连接到机器人服务器时我们得到的数字：
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Compared to the SSH timings of 1,036 ms, these numbers show a huge difference
    in performance and overhead between the two approaches. We can also see that the
    standard deviation has increased, which is expected when moving to a physical
    network. Next, we measure the timings across a wireless Wi-Fi network:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与1,036毫秒的SSH时间相比，这些数字显示了两种方法在性能和开销方面的巨大差异。我们还可以看到，标准差有所增加，这在转移到物理网络时是预期的。接下来，我们测量通过无线Wi-Fi网络的时间：
- en: '[PRE51]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: These numbers demonstrate that wired network connections can offer better performance
    then wireless ones. Namely, the initial connection time and average and standard
    deviation are all better with a wired connection. Standard deviation measures
    how much variation we have in our measurements. We can see from the standard deviation
    numbers that performance varies more on a wireless network compared to a wired
    network. By comparing the timing of initially establishing a connection (8.05
    ms) to the average timing on a persistent connection (4.21 ms), we can see we
    get an almost double performance gain when using persistent connections.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字表明，有线网络连接可以提供比无线网络更好的性能。具体来说，初始连接时间、平均值和标准差在有线连接下都更好。标准差衡量我们在测量中的变化程度。我们可以从标准差数字中看到，与有线网络相比，无线网络上的性能变化更大。通过比较建立初始连接的时间（8.05毫秒）与持久连接的平均时间（4.21毫秒），我们可以看到使用持久连接时我们获得了近两倍的性能提升。
- en: 'Robots in the real world: Real-time computing'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中的机器人：实时计算
- en: The ability to have low latency communication with our robots makes time-sensitive
    applications such as real-time computing possible. An example of one of these
    types of applications is using analog joysticks to control robot movements, which
    we will do later in the book. This is a very time-sensitive application, and if
    there is a significant lag between joystick interactions and robot movements,
    the whole application will fail to function correctly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的机器人进行低延迟通信的能力使得实时计算等时间敏感型应用成为可能。这些应用类型的一个例子是使用模拟摇杆来控制机器人运动，我们将在本书的后续章节中这样做。这是一个非常时间敏感的应用，如果在摇杆交互和机器人运动之间存在显著的延迟，整个应用将无法正确运行。
- en: Another example is automotive manufacturing where multiple robots are working
    together on a production line to assemble a car. Different robots will weld, drill,
    and pass parts to each other. It is critical that these different tasks are performed
    within set time frames, or the process along the assembly line will be disrupted.
    This article on real-time systems ([http://mng.bz/or1M](http://mng.bz/or1M)) covers
    the topic well in the context of robotics and computer vision.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是汽车制造，其中多个机器人在生产线上一同工作来组装汽车。不同的机器人将进行焊接、钻孔并将部件传递给彼此。确保这些不同的任务在设定的时间框架内完成至关重要，否则装配线上的流程将被打乱。这篇文章关于实时系统（[http://mng.bz/or1M](http://mng.bz/or1M)）在机器人学和计算机视觉的背景下很好地涵盖了这一主题。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Wi-Fi connectivity gives the robot the greatest freedom of movement.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wi-Fi 连接为机器人提供了最大的运动自由度。
- en: Tornado is a feature-rich web framework that can safely interact with the hardware
    on the robot.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tornado 是一个功能丰富的 Web 框架，可以安全地与机器人上的硬件进行交互。
- en: The `argparse` module is part of the Python standard library and can be used
    to parse command line arguments.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`argparse` 模块是 Python 标准库的一部分，可用于解析命令行参数。'
- en: The `time` command can be used to measure the execution time when commands are
    run locally and when they are run remotely over SSH.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time` 命令可用于测量在本地运行命令以及通过 SSH 远程运行命令时的执行时间。'
- en: The `json` module is used to parse JSON request data.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json` 模块用于解析 JSON 请求数据。'
- en: The `urlopen` module can be used to make calls to the web server.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`urlopen` 模块可用于向 Web 服务器发起调用。'
- en: The use of persistent connections provides significant performance gains.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用持久连接可以提供显著的性能提升。
