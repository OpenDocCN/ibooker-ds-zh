- en: 'Lesson 10\. Tuple objects: sequences of any kind of object'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10课。元组对象：任何类型的对象序列
- en: After reading [lesson 10](#ch10), you’ll be able to
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了[第10课](#ch10)之后，你将能够
- en: Create a sequence of any kind of object by using a tuple
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用元组创建任何类型的对象序列
- en: Do a few operations on tuple objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对元组对象进行一些操作
- en: Swap variable values by using tuples
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用元组交换变量值
- en: 'Suppose I give you the simple task of keeping track of your favorite superhero
    characters. Let’s say you have three: Spiderman, Batman, and Superman.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我给你一个简单的任务，就是跟踪你最喜欢的超级英雄角色。比如说你有三个：蜘蛛侠、蝙蝠侠和超人。
- en: 'Using what you know so far, you could try to create a string containing every
    one of these names, separated by a space, like so: `"Spiderman Batman Superman"`.
    Using the commands you learned in [lessons 7](kindle_split_018.html#ch07) and
    [8](kindle_split_019.html#ch08), you’d be able, with a little effort and care,
    to keep track of indices in the string and extract each name as needed.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你目前所学的知识，你可以尝试创建一个包含所有这些名称的字符串，名称之间用空格分隔，如下所示：`"Spiderman Batman Superman"`。使用你在[第7课](kindle_split_018.html#ch07)和[第8课](kindle_split_019.html#ch08)中学到的命令，你只需付出一点努力和关注，就能跟踪字符串中的索引并按需提取每个名称。
- en: 'But what if you kept full names in the string, like so: `"Peter Parker Bruce
    Wayne Clark Kent"`. It now becomes considerably harder to extract each person’s
    name because the first and last names are also separated by spaces. You could
    use other special characters, such as a comma, to separate full names, but this
    doesn’t solve the most annoying problem with using strings to store this data:
    it’s tedious to extract items of interest because you have to keep track of starting
    and ending indices.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你在字符串中保留了全名，如下所示：`"Peter Parker Bruce Wayne Clark Kent"`。现在提取每个人的名字变得更加困难，因为名字的第一部分和最后一部分也由空格分隔。你可以使用其他特殊字符，如逗号，来分隔全名，但这并不能解决使用字符串存储此数据最令人烦恼的问题：提取感兴趣的项目很麻烦，因为你必须跟踪起始和结束索引。
- en: '|  |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑这一点**'
- en: Look in your fridge. Write down all the objects you can see in there, separated
    by commas. Now look in your clothes hamper. Write down all the objects you can
    see in there, separated by commas.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你的冰箱。写下你能看到的所有物品，用逗号分隔。现在看看你的衣服篮子。写下你能看到的所有物品，用逗号分隔。
- en: 'In each set of items:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一组物品中：
- en: How many items did you put down?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你写下了多少个物品？
- en: What is the first item? What is the middle item (if you have an even number
    of items, round down)?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一项是什么？中间项是什么（如果你有偶数个物品，向下取整）？
- en: 'Answer:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：
- en: '*Fridge*: Milk, cheese, cauliflower, carrots, eggs'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*冰箱*：牛奶，奶酪，花椰菜，胡萝卜，鸡蛋'
- en: Five items
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 五个物品
- en: 'First: milk; middle: cauliflower'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先：牛奶；中间：花椰菜
- en: '*Hamper*: T-shirt, socks'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*购物袋*：T恤，袜子'
- en: Two items
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个物品
- en: 'First: T-shirt; middle: T-shirt'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先：T恤；中间：T恤
- en: '|  |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.1\. Tuples as sequences of data
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1\. 元组作为数据序列
- en: Strings store sequences of characters. It’d be a lot more convenient if there
    were a way to store individual objects in a sequence, as opposed to only string
    characters. As you write more-complicated code, it becomes useful to be able to
    represent sequences of any kind of objects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串存储字符序列。如果有一种方法可以存储序列中的单个对象，而不是仅限于字符串字符，那就方便多了。随着你编写更复杂的代码，能够表示任何类型的对象序列就变得很有用。
- en: 10.1.1\. Creating tuple objects
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.1\. 创建元组对象
- en: 'Python has a data type that represents a sequence of any objects, not just
    single-character strings. This data type is a *tuple*. In the same way that a
    string is represented within quotation marks, a tuple is represented in parentheses,
    `()`. Individual objects within the tuple are separated by a comma. An example
    of a tuple is `(1, "a", 9.9)`. Other examples of tuples are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有一种数据类型可以表示任何对象的序列，而不仅仅是单个字符的字符串。这种数据类型是*元组*。与字符串用引号表示的方式相同，元组用括号表示，`()`。元组中的各个对象由逗号分隔。一个元组的例子是
    `(1, "a", 9.9)`。其他元组的例子如下：
- en: '`()`—An empty tuple.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`()`—一个空元组。'
- en: '`(1, 2, 3)`—A tuple containing three integer objects.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(1, 2, 3)`—包含三个整数对象的元组。'
- en: '`("a", "b", "cde", "fg", "h")`—A tuple containing five string objects.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`("a", "b", "cde", "fg", "h")`—包含五个字符串对象的元组。'
- en: '`(1, "2", False)`—A tuple containing an integer, a string, and a Boolean object.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(1, "2", False)`—包含一个整数、一个字符串和一个布尔对象的元组。'
- en: '`(5, (6, 7))`—A tuple containing an integer and another tuple made up of two
    integers.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(5, (6, 7))`—包含一个整数和由两个整数组成的另一个元组的元组。'
- en: '`(5,)`—A tuple containing a single object. Notice the extra comma, which tells
    Python that the parentheses are used to hold a singleton tuple and not to denote
    precedence in a mathematical operation.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(5,)`—包含单个对象的元组。注意额外的逗号，它告诉 Python 括号用于保持单元素元组，而不是在数学运算中表示优先级。'
- en: '|  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 10.1**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 10.1**'
- en: Are each of the following valid tuple objects?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪些是有效的元组对象？
- en: '**[1](kindle_split_056.html#app01qa39q0a1)**'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa39q0a1)**'
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`("carnival",)`'
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`("carnival",)`'
- en: '**[2](kindle_split_056.html#app01qa39q0a2)**'
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa39q0a2)**'
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`("ferris wheel", "rollercoaster")`'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`("ferris wheel", "rollercoaster")`'
- en: '**[3](kindle_split_056.html#app01qa39q0a3)**'
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa39q0a3)**'
- en: ''
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`("tickets")`'
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`("tickets")`'
- en: '**[4](kindle_split_056.html#app01qa39q0a4)**'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](kindle_split_056.html#app01qa39q0a4)**'
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`((), ())`'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`((), ())`'
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.2\. Understanding operations on tuples
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2. 理解元组操作
- en: Tuples are a more general version of strings, because every item in the tuple
    is a separate object. Many operations on tuples are the same as on strings.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是字符串的更通用版本，因为元组中的每个项都是独立的对象。元组上的许多操作与字符串上的操作相同。
- en: 10.2.1\. Getting the tuple length with len()
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1. 使用 len() 获取元组长度
- en: Recall that the command `len()` can be used on other objects, not just on strings.
    When you use `len()` on a tuple, you get a value that represents the number of
    objects inside the tuple. For example, the expression `len((3, 5, "7", "9"))`
    means that you’re finding the length (the number of objects) of the tuple `(3,
    5, "7", "9")`. The expression evaluates to `4` because this tuple has four elements.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`len()` 命令可以用于其他对象，而不仅仅是字符串。当您在元组上使用 `len()` 时，您得到一个表示元组内部对象数量的值。例如，表达式
    `len((3, 5, "7", "9"))` 表示您正在查找元组 `(3, 5, "7", "9")` 的长度（对象数量）。该表达式计算结果为 `4`，因为该元组有四个元素。
- en: '|  |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 10.2**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查 10.2**'
- en: 'Evaluate the following expressions. Then try them in Spyder to check yourself:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 评估以下表达式。然后尝试在 Spyder 中检查：
- en: '**[1](kindle_split_056.html#app01qa40q0a1)**'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa40q0a1)**'
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`len(("hi", "hello", "hey", "hi"))`'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`len(("hi", "hello", "hey", "hi"))`'
- en: '**[2](kindle_split_056.html#app01qa40q0a2)**'
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa40q0a2)**'
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`len(("abc", (1, 2, 3)))`'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`len(("abc", (1, 2, 3)))`'
- en: '**[3](kindle_split_056.html#app01qa40q0a3)**'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa40q0a3)**'
- en: ''
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`len(((1, 2),))`'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`len(((1, 2),))`'
- en: '**[4](kindle_split_056.html#app01qa40q0a4)**'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](kindle_split_056.html#app01qa40q0a4)**'
- en: ''
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`len(())`'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`len(())`'
- en: '|  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.2.2\. Indexing into and slicing a tuple with []
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2. 使用 [] 索引和切片元组
- en: Because tuples are a sequence of objects, indexing into a tuple is the same
    as indexing into a string. You use the `[]` operator, and the first object is
    at index 0, the second object is at index 1, and so on. For example,
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因为元组是对象的序列，所以对元组的索引与对字符串的索引相同。您使用 `[]` 操作符，第一个对象位于索引 0，第二个对象位于索引 1，依此类推。例如，
- en: '`(3, 5, "7", "9")[1]` evaluates to `5`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(3, 5, "7", "9")[1]` 计算结果为 `5`。'
- en: '`(3, (3, 5), "7", "9")[1]` evaluates to `(3, 5)`.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(3, (3, 5), "7", "9")[1]` 计算结果为 `(3, 5)`。'
- en: One difference from strings is in the special case when one of the objects in
    the tuple is another tuple. For example, `(3, (3, ("5", 7), 9), "a")` is a tuple
    whose object at index 1 is another tuple, `(3, ("5", 7), 9)`. In turn, that object
    can also be indexed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串相比，有一个特殊的情况是元组中的一个对象是另一个元组。例如，`(3, (3, ("5", 7), 9), "a")` 是一个元组，其索引为 1
    的对象是另一个元组 `(3, ("5", 7), 9)`。反过来，该对象也可以进行索引。
- en: You can access an element deep down in a sequence of nested tuples by doing
    a series of indexing operations. For example, `(3, (3, ("5", 7), 9), "a")[1][1][1]`
    evaluates to 7\. This is a bit tricky because you can have tuples inside tuples
    inside tuples. [Figure 10.1](#ch10fig01) shows how you can visualize the expression.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过一系列索引操作来访问嵌套元组中的元素。例如，`(3, (3, ("5", 7), 9), "a")[1][1][1]` 计算结果为 7。这有点棘手，因为元组中可以嵌套其他元组。![图
    10.1](#ch10fig01) 展示了如何可视化这个表达式。
- en: Figure 10.1\. The structure of the tuple `(3, (3, ("5", 7), 9), "a")`. The dashed
    lines indicate separate objects in the tuple.
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.1. 元组 `(3, (3, ("5", 7), 9), "a")` 的结构。虚线表示元组中的独立对象。
- en: '![](images/10fig01.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](images/10fig01.jpg)'
- en: 'Going step-by-step, you evaluate the tuple as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步进行，您可以这样评估元组：
- en: '`(3, (3, ("5", 7), 9), "a")[1]` evaluates to the tuple `(3, ("5", 7), 9)`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(3, (3, ("5", 7), 9), "a")[1]` 计算结果为元组 `(3, ("5", 7), 9)`。'
- en: '`(3, ("5", 7), 9)[1]` evaluates to the tuple `("5", 7)`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(3, ("5", 7), 9)[1]` 计算结果为元组 `("5", 7)`。'
- en: '`("5", 7)[1]` evaluates to `7.`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`("5", 7)[1]` 计算结果为 `7.`'
- en: Slicing a tuple is the same as slicing a string, with the same rules. But you
    have to be careful to recognize that you might have other tuples as elements at
    a certain position.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 切片元组与切片字符串相同，遵循相同的规则。但你需要小心地认识到，你可能在某个位置有其他元组作为元素。
- en: '|  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 10.3**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查10.3**'
- en: 'Evaluate the following expressions. Then try them in Spyder to check yourself:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 评估以下表达式。然后在Spyder中尝试它们以检查自己：
- en: '**[1](kindle_split_056.html#app01qa41q0a1)**'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa41q0a1)**'
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`("abc", (1, 2, 3))[1]`'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`("abc", (1, 2, 3))[1]`'
- en: '**[2](kindle_split_056.html#app01qa41q0a2)**'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa41q0a2)**'
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`("abc", (1, 2, "3"))[1][2]`'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`("abc", (1, 2, "3"))[1][2]`'
- en: '**[3](kindle_split_056.html#app01qa41q0a3)**'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa41q0a3)**'
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`("abc", (1, 2), "3", 4, ("5", "6"))[1:3]`'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`("abc", (1, 2), "3", 4, ("5", "6"))[1:3]`'
- en: '**[4](kindle_split_056.html#app01qa41q0a4)**'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](kindle_split_056.html#app01qa41q0a4)**'
- en: ''
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.2.3\. Performing mathematical operations
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.3\. 执行数学运算
- en: 'The same operations you’re allowed to do on strings, you’re allowed to do on
    tuples: addition and multiplication.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在元组上执行与字符串上允许执行相同的操作：加法和乘法。
- en: You can add two tuples to *concatenate* them. For example, `(1, 2) + (-1, -2)`
    evaluates to `(1, 2, -1, -2)`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将两个元组相加以*连接*它们。例如，`(1, 2) + (-1, -2)`的结果是`(1, 2, -1, -2)`。
- en: You can multiply a tuple by an integer to get a tuple that contains the original
    tuple repeated that many times. For example, `(1, 2) * 3` evaluates to `(1, 2,
    1, 2, 1, 2)`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用一个整数乘以一个元组，得到一个包含原始元组重复该次数的元组。例如，`(1, 2) * 3`的结果是`(1, 2, 1, 2, 1, 2)`。
- en: '|  |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 10.4**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查10.4**'
- en: 'Evaluate the following expressions. Then try them in Spyder to check yourself:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 评估以下表达式。然后在Spyder中尝试它们以检查自己：
- en: '**[1](kindle_split_056.html#app01qa42q0a1)**'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa42q0a1)**'
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`len("abc") * ("no",)`'
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`len("abc") * ("no",)`'
- en: '**[2](kindle_split_056.html#app01qa42q0a2)**'
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa42q0a2)**'
- en: ''
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`2 * ("no", "no", "no")`'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`2 * ("no", "no", "no")`'
- en: '**[3](kindle_split_056.html#app01qa42q0a3)**'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa42q0a3)**'
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`(0, 0, 0) + (1,)`'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`(0, 0, 0) + (1,)`'
- en: '**[4](kindle_split_056.html#app01qa42q0a4)**'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[4](kindle_split_056.html#app01qa42q0a4)**'
- en: ''
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`(1, 1) + (1, 1)`'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`(1, 1) + (1, 1)`'
- en: '|  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.2.4\. Swapping objects inside tuples
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.4\. 交换元组内的对象
- en: 'In this section, you’ll see one more interesting way to use tuples. You can
    use tuples to swap the object values associated with variable names, if the variables
    are elements of the tuple. For example, say you start with these two variables:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将看到另一种使用元组的有意思的方法。如果你要交换的变量是元组的元素，你可以使用元组来交换与变量名关联的对象值。例如，假设你开始时有这两个变量：
- en: '[PRE1]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You want to write a line that yields the equivalent of the following swap:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要编写一行代码，实现以下交换的等效结果：
- en: '[PRE2]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Figure 10.2](#ch10fig02) shows the visualization you should have in mind for
    the following code, which accomplishes the swap:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10.2](#ch10fig02)展示了你应记住的以下代码的可视化，该代码实现了交换：'
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Figure 10.2\. Using tuples to swap the values of the two objects between the
    variable names
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2\. 使用元组在变量名之间交换两个对象的值
- en: '![](images/10fig02.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](images/10fig02.jpg)'
- en: You start with `"hello"` bound to the variable `long`, and `"hi"` bound to the
    variable `short`. After the line `(short, long) = (long, short)` is executed,
    the value of `short` is `"hello"`, and the value of `long` is `"hi"`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始时将`"hello"`绑定到变量`long`，将`"hi"`绑定到变量`short`。在执行`(short, long) = (long, short)`这一行后，`short`的值变为`"hello"`，而`long`的值变为`"hi"`。
- en: You might think that having two variables on the left side of the equal sign
    isn’t allowed. But recall that the variables are in the context of a tuple object,
    and surrounded by parentheses, so the item to the left of the equal sign is only
    one object, a tuple. This tuple has variables that are bound to other objects
    at each of its indices. You’ll see why using tuples in this way is useful in [lesson
    19](kindle_split_032.html#ch19).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为等号左边的两个变量是不允许的。但回想一下，变量是在元组对象的上下文中，并且被括号包围的，所以等号左边的项目只有一个对象，一个元组。这个元组在其每个索引处都有绑定到其他对象的变量。你将看到以这种方式使用元组的原因在[第19课](kindle_split_032.html#ch19)中是有用的。
- en: '|  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 10.5**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查10.5**'
- en: 'Write a line to swap the values of the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一行代码来交换以下值：
- en: '**[1](kindle_split_056.html#app01qa43q0a1)**'
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa43q0a1)**'
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**[2](kindle_split_056.html#app01qa43q0a2)**'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa43q0a2)**'
- en: ''
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|  |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this lesson, my objective was to teach you about tuples and how they behave
    in a similar way to strings. You learned how to get elements at each position
    by indexing into a tuple and how to slice a tuple to get at elements inside it;
    these elements can be primitive objects or might even be tuples themselves. Unlike
    strings, an object inside a tuple can be another tuple, effectively nesting tuples
    inside tuples. Lastly, you can use tuples to swap the values of two variables.
    Here are the major takeaways:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这节课中，我的目标是教你关于元组以及它们如何以类似字符串的方式表现。你学习了如何通过索引元组来获取每个位置的元素，以及如何切片元组来获取其内部的元素；这些元素可以是原始对象，甚至可能是元组本身。与字符串不同，元组内的对象可以是另一个元组，从而在元组内部嵌套元组。最后，你可以使用元组来交换两个变量的值。以下是主要收获：
- en: Tuples are sequences of any kind of object, even other tuples.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组是任何类型对象的序列，甚至是其他元组。
- en: You can index into multiple levels of tuples.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以对多级元组进行索引。
- en: You can use tuples to swap the values of variables.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用元组来交换变量的值。
- en: Let’s see if you got this...
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否掌握了这个...
- en: '**[Q10.1](kindle_split_056.html#app01qa44q0a1)**'
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q10.1](kindle_split_056.html#app01qa44q0a1)**'
- en: ''
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a program that initializes the string `word = "echo"`, the empty tuple
    `t = ()`, and the integer `count = 3`. Then, write a sequence of commands by using
    the commands you learned in this lesson to make `t = ("echo", "echo", "echo",
    "cho", "cho", "cho", "ho", "ho", "ho", "o", "o", "o")` and print it. The original
    word is added to the end of the tuple, and then the original word without the
    first letter is added to the tuple, and so on. Each substring of the original
    word gets repeated `count` number of times.
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一个程序，初始化字符串 `word = "echo"`，空元组 `t = ()` 和整数 `count = 3`。然后，使用你在这节课中学到的命令编写一系列命令，使
    `t = ("echo", "echo", "echo", "cho", "cho", "cho", "ho", "ho", "ho", "o", "o",
    "o")` 并打印它。原始单词被添加到元组的末尾，然后添加没有第一个字母的原始单词到元组中，依此类推。原始单词的每个子串都会重复 `count` 次数。
