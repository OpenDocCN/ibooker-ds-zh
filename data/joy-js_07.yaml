- en: 5 Higher-kinded composition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 高阶组合
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Transforming arrays and objects safely with `map` and `flatMap`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `map` 和 `flatMap` 安全地转换数组和对象
- en: Composable design patterns with algebraic data types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代数数据类型的可组合设计模式
- en: Writing a `Validation` data type to remove complex branching logic
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 `Validation` 数据类型以删除复杂的分支逻辑
- en: Chaining ADTs using the new bind operator (`::`)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的绑定运算符（`::`）链式使用 ADT
- en: '*The purpose of abstraction is not to be vague, but to create a new semantic
    level in which one can be absolutely precise.*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*抽象的目的是不是模糊，而是创建一个新的语义层，在其中可以绝对精确。*'
- en: —Edgar Dijkstra
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: —埃德加·迪杰斯特拉
- en: 'In chapter 4, you learned how function composition leads to fluent, compact,
    and declarative code when you use `compose` to chain your function’s inputs and
    outputs as data passes through them. Composition has a lot of benefits because
    it uses JavaScript’s strongest feature, as I’ve said many times: higher-order
    functions. With functions, you can achieve low-level composition at the lowest
    unit of abstraction. But a higher-kinded composition also exists in the way objects
    compose. Making objects compose as strongly as functions do is a key idea that
    we’ll discuss in section 5.3.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 章中，你学习了当使用 `compose` 链接函数的输入和输出，数据通过它们传递时，函数组合如何导致流畅、紧凑和声明式代码。组合有很多好处，因为它使用了
    JavaScript 最强大的功能，正如我多次说过的：高阶函数。使用函数，你可以在最低的抽象单元上实现低级组合。但高阶组合也存在于对象组合的方式中。使对象组合与函数一样强大是我们将在第
    5.3 节中讨论的关键思想。
- en: The type of composable object pattern you’ll learn about in this chapter is
    known as the Algebraic Data Type (ADT) pattern. An ADT is an object with a particular,
    well-known interface that allows a similar abstraction to `compose` to chain multiple
    ADTs together. Much like any class, ADTs can also contain or store other objects,
    but they are much simpler than a class in that they model a single concept, such
    as validation, error handling, null checking, or sequences. Because you’ve learned
    about function composition, you can see that it’s simple to compose functions
    in a world where nothing fails and all the inputs and outputs of your functions
    are well-defined. It’s a different story when you also need to validate data and
    catch exceptions while taking advantage of this pattern. Learning to use ADTs
    is extremely beneficial for this purpose because they provide concise APIs that
    allow you to build whole programs from simpler parts—composition at its core.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你将学习的可组合对象模式被称为代数数据类型（ADT）模式。ADT 是一个具有特定、众所周知接口的对象，它允许类似 `compose` 的抽象来链式连接多个
    ADT。与任何类一样，ADTs 也可以包含或存储其他对象，但它们比类简单得多，因为它们仅模拟一个单一的概念，例如验证、错误处理、空值检查或序列。由于你已经学习了函数组合，你可以看到在没有任何失败且所有函数的输入和输出都定义良好的世界中，组合函数非常简单。但是，当你还需要验证数据并利用此模式捕获异常时，情况就不同了。学习使用
    ADTs 对于此目的非常有用，因为它们提供了简洁的 API，允许你从更简单的部分构建整个程序——这是组合的核心。
- en: Take a moment to reflect on some of the problems we tackled in chapter 4\. Given
    a user’s digital wallet address, for example, we computed the total amount of
    Bitcoin in the blockchain. But what would happen if the provided address was `null`?
    Well, in that case, the program would fail because we didn’t add any guards against
    this possibility.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 抽时间反思一下我们在第 4 章中解决的问题。例如，给定一个用户的数字钱包地址，我们计算了区块链中的比特币总额。但是，如果提供的地址是 `null` 会发生什么？嗯，在这种情况下，程序会失败，因为我们没有添加任何针对这种可能性的保护措施。
- en: More generally, how can we deal with invalid data (`null`, `undefined`) flowing
    through a composition sequence? The syntax of `compose` doesn’t give you much
    room to insert imperative conditional validation statements between functions.
    Rather than clutter each function with common validation logic, your best bet
    is to extract it, as shown in the following listing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地，我们如何处理在组合序列中流动的无效数据（`null`，`undefined`）？`compose` 的语法没有给你多少空间在函数之间插入命令式条件验证语句。与其在每个函数中添加常见的验证逻辑，不如像以下列表所示提取它。
- en: Listing 5.1 Embedding validation checks before each composed function
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 在每个组合函数之前嵌入验证检查
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Pass the data along to the next function in the chain.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将数据传递给链中的下一个函数。
- en: ❷ Otherwise, exit with an error.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 否则，以错误退出。
- en: This process doesn’t work, however, because
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个过程不起作用，因为
- en: It’s repetitive.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是重复的。
- en: You lose the context in which validation takes place, which means that you can’t
    apply specific rules or exit with a proper validation message in the event of
    a failure.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你失去了验证发生的上下文，这意味着在失败的情况下，你无法应用特定的规则或退出并给出适当的验证消息。
- en: Throwing an exception creates a side effect.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常会产生副作用。
- en: As far as the last point is concerned, if the first function fails to produce
    a useful result, chances are that the rest of the flow shouldn’t be allowed to
    continue. The same thing happens when you’re working with some third-party code
    that may throw exceptions. In the imperative world, you would add `try`/`catch`
    guards. But again, `try`/`catch` is not something you can easily plug into `compose`;
    it’s an impedance mismatch between FP and OO, and you’d be fighting against FP
    to try to keep things linear and point-free. Take a look at the next listing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关于最后一点，如果第一个函数未能产生有用的结果，那么其余的流程可能不应该继续进行。当你与可能抛出异常的第三方代码一起工作时，也会发生同样的事情。在命令式世界中，你会添加
    `try`/`catch` 保护。但是，再次强调，`try`/`catch` 并不是你可以轻易插入 `compose` 的东西；它是 FP 和 OO 之间的阻抗不匹配，你将不得不与
    FP 作斗争，以保持事情线性化和无点式。看看下一个列表。
- en: Listing 5.2 The inconvenience of mixing `try`/`catch` with `compose`
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 将 `try`/`catch` 与 `compose` 混合的不便
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Because each function is surrounded by imperative error handling code, you
    can’t take advantage of a declarative, point-free style (chapter 4).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 因为每个函数都被命令式错误处理代码所包围，所以你无法利用声明性和无点式风格（第 4 章）。
- en: This poor design is a result of combining paradigms the wrong way. Instead of
    throwing an error abruptly, we might like to handle this task in a way that mitigates
    the side effect. To fix this problem, we need to add the necessary guardrails
    or wrappers that can control the context in which a function and its validation
    operation execute, yet keep things separate, compact, and declarative. Does that
    sound like a tall order? It is if we don’t have the necessary techniques in place.
    This chapter teaches these techniques, all of which revolve around higher-order
    functions, with the help of some more FP principles.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种糟糕的设计是错误地结合范式的结果。我们可能更喜欢以一种减轻副作用的方式处理这个任务，而不是突然抛出错误。为了解决这个问题，我们需要添加必要的护栏或包装器，以控制函数及其验证操作执行的上下文，同时保持事情分离、紧凑和声明性。这听起来是不是要求很高？如果没有必要的技巧，确实如此。本章教授了这些技巧，所有这些技巧都围绕高阶函数展开，并辅以一些更多的
    FP 原则。
- en: ADTs expose a well-known, universal API that facilitates composability. You’ll
    learn that the `map` interface (in the same spirit as `Array#map`) indicates that
    a particular object behaves like a functor. Similarly, the `flatMap` interface
    indicates that an object behaves like a monad. We’ll unpack both of these terms
    soon. Both of these interfaces allow an ADT to compose with others.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ADT 提供了一个众所周知、通用的 API，它促进了可组合性。你会了解到 `map` 接口（与 `Array#map` 的精神相同）表明一个特定的对象表现得像函子。同样，`flatMap`
    接口表明一个对象表现得像单子。我们很快就会解开这两个术语。这两个接口都允许 ADT 与其他对象进行组合。
- en: NOTE The terms functor and monad originate from category theory, but you don’t
    need to understand mathematics to learn and use them in practice.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：术语“函子”和“单子”起源于范畴论，但你不需要理解数学就能在实践中学以致用。
- en: 'After teaching some of the fundamentals, this chapter works its way up to creating
    an ADT from scratch, tackling the complexity behind validating or checking the
    contents of a block, transaction, and even the entire blockchain data structure.
    By the end, you’ll understand what code like this does:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在教授了一些基础知识之后，本章将逐步深入到从头创建 ADT，解决验证或检查块、事务甚至整个区块链数据结构内容背后的复杂性。到那时，你将理解像这样的代码做什么：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code addresses all the concerns we raised earlier, although how may not
    be obvious yet. The code removes repetition, creates no additional side effects,
    and (best of all) is declarative and point-free. This type of abstraction `Validation`
    creates a closed context around the validation logic. Let’s begin by understanding
    what we mean by closed context.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码解决了我们之前提出的所有问题，尽管具体做法可能还不明显。代码消除了重复，没有产生额外的副作用，而且（最好的是）是声明性和无点式的。这种类型的抽象“验证”在验证逻辑周围创建了一个封闭的上下文。让我们首先理解我们所说的封闭上下文是什么意思。
- en: 5.1 Closing over data types
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 在数据类型上封闭
- en: When we write functions, it would be ideal to assume the perfect application
    state. That is, all the data coming in and out of our functions is always correct
    and valid, and none of the objects in our system have a `null` or `undefined`
    value. This state would allow us to reduce the boilerplate of data checks everywhere.
    Sadly, this situation is never the case. Alternatively, we could think about wrapping
    functions with some abstraction that always checks for invalid data of any nature.
    In this section, we’ll create a simple abstraction to start getting used to the
    pattern presented in this book. In section 5.5, we’ll build on that pattern to
    build an actual ADT.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写函数时，理想的情况是假设完美的应用状态。也就是说，所有进入和离开我们函数的数据始终是正确和有效的，并且我们系统中的对象没有`null`或`undefined`值。这种状态将允许我们减少数据检查的样板代码。遗憾的是，这种情况永远不会发生。或者，我们可以考虑使用某种抽象来包装函数，该抽象始终检查任何类型的不合法数据。在本节中，我们将创建一个简单的抽象，以开始熟悉本书中展示的模式。在第5.5节中，我们将在此基础上构建一个实际的ADT。
- en: Functions can become complex when we interleave their business logic with side
    work such as data validation, error handling, or logging. We can say that these
    concerns are tangential to the task at hand, yet they are important parts of the
    working application. Other tasks may include handling exceptions or logging to
    a file. We’ll call these tasks effects.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将业务逻辑与数据验证、错误处理或日志记录等辅助工作交织在一起时，函数可能会变得复杂。我们可以将这些关注点视为与当前任务无关，但它们是工作应用程序的重要部分。其他任务可能包括处理异常或将日志记录到文件中。我们将这些任务称为效果。
- en: NOTE An effect is not to be confused with a side effect. A side effect may be
    a type of effect, as used in this context, but an effect is more of an arbitrary
    task.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：效果不要与副作用混淆。副作用可能是一种效果，如在这个上下文中使用的效果，但效果更多的是一种任意任务。
- en: 'Let’s focus on one of these effects: data validation. Suppose that you’re writing
    a small algorithm, using a sequence of functions. At each step, you want to make
    sure that the arguments each function receives are valid (not null, greater than
    zero, not empty, and so on). These are important to ensure that the algorithm
    is correct from a practical point of view but are not essential parts of the algorithm
    itself. Instead of cluttering each function, you remove or wrap this effect in
    some form of abstraction.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注这些效果中的一个：数据验证。假设你正在编写一个小算法，使用一系列函数。在每一步，你都想确保每个函数接收到的参数是有效的（非空、大于零、非空等）。这些对于确保算法从实用角度来说是重要的，但不是算法本身的必要部分。而不是在每个函数中添加混乱，你可以以某种形式将这个效果抽象化。
- en: 'Suppose that this hypothetical algorithm has three steps: `f1`, `f2`, and `f3`.
    You already saw the interleaving happening in this code in listing 5.1:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个假设的算法有三个步骤：`f1`、`f2`和`f3`。你已经在列表5.1中的代码中看到了交织发生的情况：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The data is validated before each function runs. Let’s improve this code to
    remove the repetition. Using the lessons of chapter 4, we’ll wrap these functions
    (close over them), using a higher-order function that accepts the function being
    executed as input and the data in curried form. Higher-order functions are great
    at converting some body of code into callable form. This approach would allow
    `validate` to decide whether to apply the function based on the validity of the
    data provided.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个函数运行之前都会进行数据验证。让我们改进这段代码以消除重复。使用第4章的教训，我们将使用接受要执行的函数和以curried形式提供的数据作为输入的高阶函数来包装这些函数（封闭它们）。高阶函数擅长将一些代码转换为可调用形式。这种方法将允许`validate`根据提供的数据的有效性来决定是否应用函数。
- en: 'To illustrate a possible solution, let’s make our problem more concrete by
    focusing only on calling functions, with the condition that the `null` check is
    successful (not null). Consider a function such as `applyIfNotNull`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明一个可能的解决方案，让我们通过仅关注调用函数，并假设`null`检查成功（非空）来使我们的问题更加具体。考虑一个如`applyIfNotNull`的函数：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the null check is repeated around every function call. Because
    `applyIfNotNull` is curried manually, we can remove duplication by mapping it
    over the functions that make up your business logic, as shown in the next listing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在每次函数调用周围都会重复null检查。因为`applyIfNotNull`是手动curried的，所以我们可以通过映射到构成你的业务逻辑的函数上，如下一列表所示来消除重复。
- en: Listing 5.3 Applying multiple functions to `compose` with `map`
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3 使用`map`将多个函数应用于`compose`
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Applies applyIfNotNull to every function and then spreads the resulting array
    as arguments to compose
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将applyIfNotNull应用于每个函数，然后将结果数组作为参数展开传递给compose
- en: 'This step gets us closer to a more declarative, expression-oriented code instead
    of imperative branching logic, but we still need to account for two items:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步使我们的代码更接近于声明式、表达式导向的代码，而不是命令式分支逻辑，但我们仍然需要考虑两个项目：
- en: A `null` check is not the only form of validation we’ll need in the real world.
    We need to support more kinds of logic.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现实世界中，`null`检查并不是我们需要的唯一验证形式。我们需要支持更多种类的逻辑。
- en: We’re using an exception, which is itself a side effect, to break out of the
    logic in a dramatic fashion.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用异常，它本身就是一个副作用，以戏剧性的方式跳出逻辑。
- en: We need to increase the level of abstraction from a function to some form of
    contextual data structure that can somehow keep track of the validation results
    along the way and apply the functions accordingly. One way is to use a wrapper
    object that encapsulates data and abstracts the application of an effect to this
    data as part of exercising its business logic, much as `applyIfNotNull` did earlier,
    in an immutable way without leaking side effects.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从函数级别提升抽象级别，到某种形式上下文数据结构，它可以以某种方式跟踪验证结果，并相应地应用函数。一种方法是用封装数据的包装器对象，将应用效果到这些数据作为其业务逻辑的一部分，就像`applyIfNotNull`之前所做的那样，以不可变的方式执行，而不泄露副作用。
- en: 'Possibly the simplest type of container data structure in JavaScript is `Array`,
    which among its comprehensive set of methods has a few that we can use for this
    type of abstraction:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，可能最简单的容器数据结构是`Array`，在其全面的方法集中，有一些我们可以用于此类抽象的方法：
- en: A static function to construct new containers with a value — For a class `C`,
    this function is usually called `C.of` or `C.unit`. The function, which is similar
    to `Array.of`, is also called a type-lifting function as it allows you to bring
    some typed variable into a context on which you will perform operations. Lifting
    some object and placing it in a box is a good analogy.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个静态函数用于使用值构造新容器——对于一个类`C`，这个函数通常被称为`C.of`或`C.unit`。这个函数，类似于`Array.of`，也被称作类型提升函数，因为它允许你将一些类型变量带入你将要执行操作的环境中。将一些对象提升并放入一个盒子是一个很好的类比。
- en: A function to transform this data — This transformation is usually done via
    a `map` method on the object with a specific contract. `map` is shared by all
    instances, so it should be defined at prototype level (`C.prototype.map`).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个转换这些数据的函数——这种转换通常通过对象上的特定契约的`map`方法来完成。`map`是所有实例共享的，因此它应该在原型级别（`C.prototype.map`）上定义。
- en: A function to extract the result from the container — This function is implementation-specific.
    For arrays, you can use something like `Array#pop`.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个从容器中提取结果的函数——这个函数的实现是特定的。对于数组，你可以使用类似`Array#pop`的东西。
- en: Anything beyond this protocol depends on what additional logic you need for
    the specific wrapper.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 任何超出此协议的内容都取决于你为特定包装器需要的额外逻辑。
- en: Before we start implementing our own wrappers, let’s continue down the path
    of using an array to represent encapsulation and immutability. This practice will
    help us warm up on the coding patterns used by ADTs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现自己的包装器之前，让我们继续使用数组来表示封装和不可变性。这种做法将帮助我们熟悉ADT使用的编码模式。
- en: Wrapping a value inside some container, such as an array literal, gives you
    automatic fluent-coding capabilities on several values, not just one. For the
    sake of this discussion, let’s focus on one value. Consider this example. Given
    a string, suppose that you want to remove duplicate characters and capitalize
    the final string. With input of `"aabbcc"`, for example, the result should be
    `"ABC"`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将值包装在某种容器中，例如数组字面量，可以在多个值上自动提供流畅编码能力，而不仅仅是单个值。为了讨论方便，让我们专注于一个值。考虑这个例子。给定一个字符串，假设你想删除重复字符并将最终字符串转换为大写。例如，对于输入`"aabbcc"`，结果应该是`"ABC"`。
- en: Simple enough. As you know, the best way to apply a sequence of computations
    to an array of elements is through `map`, which is a stateless method, so you’re
    never changing the original array that called it or its elements. This situation
    satisfies the immutability requirement. Also, we need methods to put a value inside
    the array and then a way to extract the data. For this task, we can use lifting
    operations `Array.of` and `Array#pop`, respectively, as shown in the next listing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 足够简单。正如你所知，将一系列计算应用于元素数组的最有效方式是通过`map`，这是一个无状态方法，因此你永远不会改变调用它的原始数组或其元素。这种情况满足不可变性的要求。此外，我们需要方法将值放入数组，然后提取数据。为此任务，我们可以分别使用提升操作`Array.of`和`Array#pop`，如下一列表所示。
- en: Listing 5.4 Mapping functions on an array
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.4 在数组上映射函数
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Uses the capabilities of Set, which accepts an iterable object, to remove
    duplicates
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用 Set 的能力，它接受一个可迭代对象，来移除重复项
- en: ❷ Could have also used Array.prototype.shift or [0]
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 也可以使用 Array.prototype.shift 或 [0]
- en: 'JavaScript gives us some syntactic improvement (in the shape of a box) by using
    the array literal directly:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过直接使用数组字面量，JavaScript 给我们一些语法上的改进（以盒子的形式）：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you want to be a little more precise, you can use the `Array.of` as a generic
    constructor function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更加精确一些，可以使用 `Array.of` 作为泛型构造函数：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'NOTE When you construct a new array, using the `Array` constructor function
    with `new` is not the best way to go about it. This function has unpredictable
    behavior, depending on the type used. The function `new` `Array(''aabbcc'')`,
    for example, creates an array with the single element `[''aabbcc'']`, as we’d
    expect. But `new` `Array(3)` creates an empty array with three empty slots: `[`
    `,` `,` `]`. The `Array.of` API corrects for this situation, but in most cases,
    the simplest approach is to use array literal notation directly: `[''aabbcc''].`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当你构造一个新数组时，使用 `new` 与 `Array` 构造函数并不是最佳做法。这个函数的行为不可预测，取决于使用的类型。例如，`new Array('aabbcc')`
    创建了一个包含单个元素 `['aabbcc']` 的数组，正如我们所期望的。但 `new Array(3)` 创建了一个包含三个空槽的空数组：`[, , ,]`。`Array.of`
    API 修正了这种情况，但在大多数情况下，最简单的方法是直接使用数组字面量表示法：`['aabbcc'].`
- en: The container that results from using an array is analogous to what we call
    an identity context. This term comes from the simple yet popular `identity` function
    `(const` `identity` `=` `a` `=>` `a)`, which you learned about in chapter 4\.
    This function is commonly used in functional programs and echoes the value it’s
    given. In FP, identity means that some value is left untouched.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组产生的容器类似于我们所说的身份上下文。这个术语来源于简单而流行的 `identity` 函数 `(const identity = a => a)`，你可以在第4章中了解到这个函数。这个函数在函数式程序中常用，并回显它所给出的值。在函数式编程（FP）中，身份意味着某些值保持不变。
- en: Similarly, an identity context would not have any computational logic of its
    own. It wraps a single value and doesn’t do any additional processing beyond what
    you provide in your mapping functions; it has no effect on the data. We say that
    it’s contextless, or side-effect-free.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一个身份上下文不会有自己的计算逻辑。它包装一个单一值，并且不会进行任何额外的处理，除了你在映射函数中提供的；它对数据没有影响。我们说它是无上下文的，或者无副作用的。
- en: Let’s take the array example a bit further. One way we could easily implement
    an `Id` class in JavaScript is to extend from `Array`, as shown in listing 5.5\.
    This example is meant only to illustrate how the `map` operator could apply generically
    over simple containers that enclose a single value. Normally, I don’t recommend
    extending (monkey-patching) from standard types; this example is for teaching
    purposes, and its use will become clearer later.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨数组示例。一种在 JavaScript 中轻松实现 `Id` 类的方法是扩展 `Array`，如列表5.5所示。这个例子仅用于说明 `map`
    操作符如何泛型地应用于包含单个值的简单容器。通常，我不推荐从标准类型扩展（猴子补丁）；这个例子是为了教学目的，其用途将在后面变得清晰。
- en: Listing 5.5 Implementing a contextless container by extending from `Array`
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.5 通过扩展 `Array` 实现无上下文容器
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Initializes the underlying array with a size of 1 because we need to wrap
    only a single value
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始化底层数组的大小为1，因为我们只需要包装一个值
- en: ❷ Inherits Array.of as the type-lifting function
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 继承 Array.of 作为类型提升函数
- en: ❸ Inherits Array#pop to extract the value from the container
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 继承 Array#pop 从容器中提取值
- en: Both `Id` and `[]` (empty array) are examples of closed contexts. Although this
    example may not look exciting, there’s more than meets the eye here. Concretely,
    `Id`
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Id` 和 `[]`（空数组）都是封闭上下文的例子。尽管这个例子可能看起来并不激动人心，但这里还有更多值得注意的地方。具体来说，`Id`'
- en: Enables a fluent data transformation API in which each stage performs a predictable
    transformation toward the end result, as in an assembly line.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使数据转换API流畅，其中每个阶段都执行一个可预测的转换，朝着最终结果前进，就像装配线一样。
- en: Provides some level of data encapsulation.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了一定程度的数据封装。
- en: Performs all operations in an immutable fashion because every stage of the process
    returns a new container with a new value. The mapped function may transform the
    data inside `Id` to any shape, as long as it advances our logic toward the final
    outcome. We say that the mapping function is any function from `a` `->` `b` (`a`
    and `b` are any objects) that changes the container from `Id(a)` to a new `Id(b)`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以不可变的方式执行所有操作，因为过程的每个阶段都会返回一个带有新值的新容器。映射函数可以将`Id`内部的数据转换为任何形状，只要它推进我们的逻辑，朝着最终结果前进。我们说映射函数是从`a`到`b`的任何函数（`a`和`b`是任何对象），它将容器从`Id(a)`转换为新的`Id(b)`。
- en: Conceptually, programming with containers metaphorically resembles an assembly
    line or a railway, as shown in figure 5.1.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，使用容器编程比喻性地类似于装配线或铁路，如图5.1所示。
- en: '![](../Images/5-1.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-1.png)'
- en: Figure 5.1 Assembly-style computing with containers. In this case, every step
    of the line maps a different transformation, creating a new intermediate result
    along the way until reaching the desired product.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 使用容器进行装配式计算。在这种情况下，线的每一步都映射不同的转换，沿途创建新的中间结果，直到达到所需的产品。
- en: NOTE In section 5.5.4, you’ll see that implementing validation (which is a binary
    operation) with wrappers will result in two paths or railways.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在5.5.4节中，你会看到使用包装器实现验证（这是一个二元操作）会导致两条路径或铁路。
- en: This last point, which refers to creating new containers as a result of applying
    functions, is the most important one to guarantee that the mapped functions are
    pure. Remember that purity is the key ingredient to make your code simple to reason
    about. Take as examples `Array`’s `sort` and `reverse`, which modify the original
    object in place. These APIs are harder to use because they can lead to unexpected
    behavior. On the other hand, immutable APIs like the ones in section 5.2 are much
    safer to use.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这一点，即通过应用函数创建新容器，是保证映射函数纯净最重要的因素。记住，纯净是使你的代码易于推理的关键成分。以`Array`的`sort`和`reverse`为例，它们会就地修改原始对象。这些API使用起来更困难，因为它们可能导致意外的行为。另一方面，像5.2节中提到的不可变API要安全得多。
- en: '5.2 New Array APIs: {flat, flatMap}'
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 新数组API：{flat, flatMap}
- en: '`Array#{flat,` `flatMap}` are two major additions to the almighty, all-encompassing
    JavaScript `Array` object. You saw these methods used briefly toward the end of
    chapter 4\. Both of these methods allow you to manage multidimensional arrays
    easily:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array#{flat,` `flatMap}`是强大的、包罗万象的JavaScript `Array`对象的两个主要新增功能。你在第4章的结尾简要看到了这些方法的使用。这两个方法都允许你轻松地管理多维数组：'
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Like all the recently added `Array` methods, these operations are immutable;
    instead of changing the original, they create new ones. Let’s start with `flat`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有最近添加的`Array`方法一样，这些操作都是不可变的；它们不会改变原始对象，而是创建新的。让我们从`flat`开始。
- en: 5.2.1 Array.prototype.flat
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 Array.prototype.flat
- en: '`Array#flat` allows you to work with multiple array dimensions without having
    to break out of your lean and fluent pattern. Here are a few examples:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array#flat`允许你在不打破你简洁流畅的模式的情况下处理多个数组维度。以下是一些示例：'
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The method even has the built-in smarts to skip nested nonarray objects. Empty
    slots in the array are left untouched:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法甚至有内置的智能来跳过嵌套的非数组对象。数组中的空槽位保持不变：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A fun fact about `flat` is that you can collapse structures of infinite depth:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`flat`的一个有趣的事实是，你可以折叠无限深度的结构：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`flat` also allows you to work with functions that themselves return arrays.
    Recall from listing 5.4 that `unique` takes a string and returns an array with
    all letters minus duplicates. Mapping `unique` over `[''aa'',` `''bb'',` `''cc'']`,
    for example, would produce a nested structure `[[''a''],` `[''b''],` `[''c'']]`,
    which we can easily flatten at the end:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`flat`还允许你与自身返回数组的函数一起工作。回想一下列表5.4中的`unique`，它接受一个字符串并返回一个包含所有字母但不包含重复字母的数组。例如，将`unique`映射到`[''aa'',`
    `''bb'',` `''cc'']`上会产生一个嵌套结构`[[''a''],` `[''b''],` `[''c'']]`，我们可以在最后轻松地将其展平：'
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Because `map` and `flat` are often used together, JavaScript provides an API
    that takes care of both methods.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`map`和`flat`经常一起使用，JavaScript提供了一个同时处理这两个方法的API。
- en: 5.2.2 Array.prototype.flatMap
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 Array.prototype.flatMap
- en: The `map`-then-`flat` sequence is used frequently in regular day-to-day coding.
    You might iterate over all blocks in the chain and then iterate over all transactions
    within each block, for example. Fortunately, a shortcut called `flatMap` calls
    both operations at the same time, as shown in the following listing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`然后`flat`的序列在日常编码中经常被使用。例如，你可能需要遍历链中的所有块，然后遍历每个块内的所有交易。幸运的是，一个名为`flatMap`的快捷方式同时调用这两个操作，如下所示。'
- en: Listing 5.6 Basic use of `flatMap`
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.6 `flatMap`的基本使用
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ unique returns an array. Instead of producing a nested array, flatMap runs
    the built-in flat logic after mapping the callback function to all elements.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `unique`返回一个数组。`flatMap`在将回调函数映射到所有元素之后，运行内置的扁平化逻辑，而不是产生嵌套数组。
- en: 'We all understand `map` and `flatMap` as operations that allow you to apply
    callback functions to an array. Conceptually, however, these operations extend
    beyond arrays. If you’ve read chapter 4 and understand the basics of functional
    programming, code of this form should resemble a familiar pattern:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都把`map`和`flatMap`理解为允许你将回调函数应用于数组的操作。然而，从概念上讲，这些操作超越了数组。如果你已经阅读了第4章并理解了函数式编程的基本原理，这种形式的代码应该看起来像是一个熟悉的模式：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Would you say that this code looks like composition? As a matter of fact, the
    following code produces the same result (`''ABC''`) as the previous one:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你会说这段代码看起来像是组合吗？事实上，以下代码产生的结果（`'ABC'`）与上一个相同：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How is it that `map` and `compose` lead to the same result? Except for minor
    syntactic differences compared with `compose`, `map` and `flatMap` represent contextual
    composition and are largely equivalent.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`和`compose`是如何得到相同结果的？与`compose`相比，除了微小的语法差异外，`map`和`flatMap`代表上下文组合，在很大程度上是等价的。'
- en: 5.3 The map/compose correspondence
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 map/compose对应关系
- en: In section 5.1, I said that `map` allows objects (like `Id` and others) to apply
    functions. This statement applies equally to `flatMap`. In this section, you’ll
    learn that at a fundamental level, both of these operators behave like `compose`,
    so in essence, using `map` is nothing more than function composition, which cements
    the mental model of functional programming.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在5.1节中，我说过`map`允许对象（如`Id`和其他）应用函数。这个陈述同样适用于`flatMap`。在本节中，你将了解到在根本层面上，这两个操作符的行为类似于`compose`，因此本质上，使用`map`不过是函数组合，这巩固了函数式编程的思维方式。
- en: 'This equivalence is also important technically speaking, because you get all
    of the benefits of using `compose` that we covered in chapter 4, but now applied
    to objects. Let’s demonstrate this equivalence by defining `map` in terms of `compose`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度讲，这种等价性也很重要，因为你可以获得我们在第4章中提到的使用`compose`的所有好处，但现在应用到了对象上。让我们通过将`map`定义为`compose`来演示这种等价性：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now all functions inherit `map` automatically. Using it reveals once again
    the close correspondence between the two:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有函数都自动继承`map`。使用它再次揭示了两者之间的紧密对应关系：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What this correspondence tells us is that all the benefits that you gain with
    the composition of functions can easily be applied to composite types. In our
    simple use cases, `map` is an interface that allows both `Array` and `Id` to compose
    functions, and it will allow any ADT you use to compose functions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对应关系告诉我们，所有通过函数组合获得的好处都可以轻松地应用于复合类型。在我们的简单用例中，`map`是一个接口，允许`Array`和`Id`组合函数，它还将允许你使用的任何ADT组合函数。
- en: Now that you’ve seen how these concepts intertwine, let’s define a universal
    interface for `map` that allows any object that implements it to compose together.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了这些概念是如何交织在一起的，让我们定义一个通用的`map`接口，允许任何实现它的对象组合在一起。
- en: 5.4 Universal contracts
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 通用契约
- en: In the examples earlier in this chapter, you probably noticed that `map` and
    `flatMap` preserve the same caller type. For arrays, both return new arrays; for
    functions, both return new functions. This fact can’t be taken for granted. It’s
    a core part of the `map` interface, one that is universally accepted and allows
    your objects to work with other functional libraries, such as Ramda ([https://ramdajs.com](https://ramdajs.com/))
    or Crocks ([https://crocks.dev](https://crocks.dev)). In this section, you’ll
    learn a little bit about the theory behind patterns such as functors and monads
    and how they are implemented in JavaScript.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的例子中，你可能已经注意到 `map` 和 `flatMap` 保留了相同的调用者类型。对于数组，两者都返回新的数组；对于函数，两者都返回新的函数。这个事实不能被理所当然地接受。它是
    `map` 接口的核心部分，被普遍接受，并允许你的对象与其他函数库（如 Ramda [https://ramdajs.com](https://ramdajs.com/)）或
    Crocks [https://crocks.dev](https://crocks.dev/)）一起工作。在本节中，你将了解一些关于函子和单子等模式背后的理论以及它们在
    JavaScript 中的实现方式。
- en: Fantasy-land
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Fantasy-land
- en: The protocol for how functors and monads work in JavaScript, for the most part,
    abides by the rules put forth in the fantasy-land specification ([https://github.com/
    fantasyland/fantasy-land](https://github.com/fantasyland/fantasy-land)). This
    document is thorough, and I highly recommend that you take the time to understand
    it if you want to become a serious FP programmer. This chapter definitely gives
    you a jump start.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中函子和单子如何工作的协议，在很大程度上，遵循了 fantasy-land 规范中提出的规则（[https://github.com/fantasyland/fantasy-land](https://github.com/fantasyland/fantasy-land)）。这份文档非常详尽，我强烈建议你花时间理解它，如果你想要成为一名严肃的
    FP 程序员的话。这一章肯定能给你一个良好的开端。
- en: The full theory on ADTs is extensive and better covered in books dedicated to
    functional programming or abstract algebra. I’ll cover enough here so that you
    can unlock the FP patterns that enable composable software, beginning with functors.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 ADT 的完整理论非常广泛，最好在专门介绍函数式编程或抽象代数的书籍中找到。在这里，我将涵盖足够的内容，以便你能够解锁使可组合软件成为可能的 FP
    模式，从函子开始。
- en: 5.4.1 Functors
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 函子
- en: A book that focuses on the joy of programming with JavaScript and FP would not
    be complete without a proper dose of functors, because functors bring out the
    best in the language by relying on higher-order functions for data transformation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一本专注于使用 JavaScript 和函数式编程（FP）享受编程乐趣的书籍，如果没有适当剂量的函子，那就不是完整的。因为函子通过依赖高阶函数进行数据转换，从而最能体现语言的优势。
- en: A functor is anything (such as an object) that can be mapped over or that implements
    the map interface properly. Arrays in JavaScript are close to being functors,
    for example, and the `map` method enables a style of programming that’s superior
    to and less error-prone than regular `for` loops. As you learned in section 5.3,
    `compose` makes functions functors too, so you’ve used them quite a bit already
    without realizing it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 函子是任何可以映射或正确实现映射接口的东西（例如对象）。例如，JavaScript 中的数组几乎就是函子，`map` 方法使得编程风格优于常规的 `for`
    循环，并且更不容易出错。正如你在第 5.3 节中学到的，`compose` 也能使函数成为函子，所以你已经在不知不觉中使用了它们很多次。
- en: 'For an object to behave like a functor, it needs to follow two simple rules,
    which follow from the `map`/`compose` equivalence (section 5.3). I’ll use arrays
    again for simplicity to illustrate rules:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一个对象表现得像函子，它需要遵循两个简单的规则，这些规则源于 `map`/`compose` 等价性（第 5.3 节）。为了简单起见，我将再次使用数组来展示规则：
- en: 'Identity — Mapping the identity function over a container yields a new container
    of the same type, which is also a good indicator that `map` should be side-effect-free:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符 — 将恒等函数映射到容器上会产生一个相同类型的新容器，这也是 `map` 应该无副作用的良好指标：
- en: '[PRE20]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Composition — Composing two or more functions, such as `f` after `g,` is equivalent
    to mapping first `g` and then `f`. Both statements are equivalent to `[''A'',`
    `''B'',` `''C'']`:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合 — 组合两个或多个函数，例如 `f` 在 `g` 之后，等同于先映射 `g` 再映射 `f`。这两个陈述都是等价的，如下所示：
- en: '[PRE21]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: and
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE22]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that I’ve been using the word equivalent loosely. The reason is to avoid
    eliciting the other forms of equivalence you’re accustomed to, such as the double
    equals operator (`==),` which is loosely equivalent to type coercion, and triple
    equals (`===`), which is a strict quality in value and type. Equivalent here means
    referentially transparent; the meaning or result of the program doesn’t change
    if you substitute an expression for its value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我一直在使用“等价”这个词来表示。这样做是为了避免引起你习惯的其他形式的等价，例如双等号运算符（`==`），它松散地等同于类型转换，以及三等号（`===`），它在值和类型上是一个严格的等价。在这里，“等价”意味着引用透明；如果你用一个表达式替换其值，程序的意义或结果不会改变。
- en: Implementing a functor involves defining `map` with these simple rules and creating
    the contract of a closed context described in section 5.1, such as the implementing
    of a type-lifting function `F.of`, as well as a mechanism to extract the value
    from the container, such as a `get` method. As you learned in chapter 3, the best
    way to apply reusable interfaces to any object is to use a mixin. Let’s refactor
    `Id` (shown in the next listing) to take advantage of the `Functor` mixin.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个函子涉及定义 `map` 并遵循这些简单规则，以及创建一个封闭上下文的合约，如第 5.1 节中描述的，例如实现一个类型提升函数 `F.of`，以及从容器中提取值的机制，例如
    `get` 方法。正如你在第 3 章中学到的，将可重用接口应用于任何对象的最佳方式是使用混入。让我们重构 `Id`（如下一列表所示），以利用 `Functor`
    混入的优势。
- en: Listing 5.7 `Id` class with minimal context interface
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.7 带最小上下文界面的 `Id` 类
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Type-lifting function
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 类型提升函数
- en: ❷ Getter to extract the value from the container
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取器以从容器中提取值
- en: '`Functor` is a mixin that exposes a `map` method, as shown in the following
    listing. `map` is a higher-order function that applies the given function `f`
    to the wrapped value and stores the result in the same container, like `Array#map`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Functor` 是一个混入，它公开了一个 `map` 方法，如下一列表所示。`map` 是一个高阶函数，它将给定的函数 `f` 应用到包装的值上，并将结果存储在相同的容器中，就像
    `Array#map`。'
- en: Listing 5.8 `Functor` mixin
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.8 `Functor` 混入
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ map accepts a callback function to apply, using identity as default function
    argument
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `map` 接受一个回调函数来应用，默认使用身份函数作为参数
- en: ❷ Applies the callback function to the value and wraps the result in a new instance
    of the same container, using the generic type-lifting function
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将回调函数应用于值，并使用通用类型提升函数将结果包装在相同容器的新的实例中
- en: 'Because the functor contract must preserve the enclosing structure, we can
    figure out the container instance calling it and invoke its static type-lifting
    constructor by using `this.constructor.of``.` The fact that we’re using classes
    makes this procedure simple because it configures the `constructor` property and
    makes it easy to discover. Now let’s extend `Id` with `Functor` as we did with
    `Transaction` back in chapter 3:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函子合约必须保留封装结构，我们可以通过调用它的容器实例来找出它，并通过使用 `this.constructor.of` 来调用其静态类型提升构造函数。由于我们使用的是类，这使得这个过程变得简单，因为它配置了
    `constructor` 属性，并使其易于发现。现在让我们像在第 3 章中处理 `Transaction` 一样扩展 `Id`：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Everything continues to work as before. `Array`#`map` resembles the same contract
    as a `Functor`’s `map`, so we can use it in the same way, as the next listing
    shows.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都像以前一样继续工作。`Array`#`map` 与 `Functor` 的 `map` 具有相同的合约，因此我们可以以相同的方式使用它，如下一列表所示。
- en: Listing 5.9 Sequential data processing with the `Id` functor
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 使用 `Id` 函子进行顺序数据处理
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Mapping from Id returns new Id objects
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 `Id` 映射返回新的 `Id` 对象
- en: Let’s visualize the inner workings of a functor as opening the container to
    expose its value to the mapped function and then rewrapping the value in a new
    container, as shown in figure 5.2.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们可视化函子的内部工作原理，就像打开容器以将其值暴露给映射函数，然后将其重新包装在新的容器中，如图 5.2 所示。
- en: '![](../Images/5-2.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-2.png)'
- en: Figure 5.2 The mapping of functions over a container
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 函数在容器上的映射
- en: If you glance once more at listing 5.9, you’ll notice that it’s fairly generic.
    Except for an implementation of a value-extracting method (`Id#get` or `Array#pop`),
    everything follows the generic functor contracts.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次浏览列表 5.9，你会注意到它是相当通用的。除了一个值提取方法的实现（`Id#get` 或 `Array#pop`）之外，所有内容都遵循通用的函子合约。
- en: Functors let you map a simple function to transform the wrapped value and put
    it back in a new container of the same type. Frontend developers probably recognize
    that the `jQuery` object behaves like a functor. `jQuery` is a functor as well
    and is one of the first JavaScript libraries to popularize this style of coding
    ([https://api.jquery.com/ jquery.map](https://api.jquery.com/jquery.map/)).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 函子让你将一个简单的函数映射到包装的值上，并将其放回相同类型的新容器中。前端开发者可能已经认识到 `jQuery` 对象的行为就像一个函子。`jQuery`
    也是一个函子，并且是第一个推广这种编码风格的 JavaScript 库之一（[https://api.jquery.com/jquery.map](https://api.jquery.com/jquery.map/)）。
- en: Now let’s look at a slightly different case. What would happen if you were to
    map a function that itself returns a container, such as mapping a function that
    returns an `Id` object? From what you’ve learned about arrays in this chapter,
    an operator like `flatMap` is designed to solve this problem. To understand why,
    we’ll study monads.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一个稍微不同的情况。如果你映射一个返回容器的函数，比如映射返回 `Id` 对象的函数，会发生什么？根据你在本章中学到的关于数组的知识，像 `flatMap`
    这样的操作符被设计来解决这个问题。为了理解为什么，我们将研究 monads。
- en: 5.4.2 Monads
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 Monads
- en: Monads are designed to tackle composing container-returning operations. Composing
    functions that return `Id` can result in an `Id` inside another `Id`; when composing
    `Array`, you get a multidimensional array, and so on. You get the idea.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Monads 被设计用来处理组合返回容器的操作。组合返回 `Id` 的函数可能导致一个 `Id` 内部嵌套另一个 `Id`；当你组合 `Array` 时，你会得到一个多维数组，依此类推。你明白了。
- en: 'An object becomes a monad by implementing the functor specification and the
    `flatMap` contract with its own simple protocol. The reason is that we’ll need
    to `map` functions that return wrapped data. Suppose that each of the functions
    in this code snippet returned an `Id`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象通过实现函子规范和 `flatMap` 合约以及它自己的简单协议成为 monad。原因是我们将需要 `map` 返回包装数据的函数。假设这个代码片段中的每个函数都返回一个
    `Id`：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The result would look like figure 5.3.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将类似于图 5.3。
- en: '![](../Images/5-3.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-3.png)'
- en: Figure 5.3 Mapping a function that returns an `Id` containing a wrapped value
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 映射包含包装值的 `Id` 函数
- en: 'Monads take chaining a sequence of computations to the next level so that you
    can compose functions that work with the same container or other containers. We’re
    going to stick with the same container for now, because this pattern is the most
    common one used in practice. For reference, the fantasy-land entry is at [https://github.com/
    fantasyland/fantasy-land#monad](https://github.com/fantasyland/fantasy-land#monad).
    Consider a monad `M` and equivalence as defined in section 5.4.2:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Monads 将链式计算序列提升到下一个层次，这样你就可以组合使用相同容器或其他容器的函数。我们现在将坚持使用相同的容器，因为这种模式在实践中是最常见的。为了参考，fantasy-land
    的条目在 [https://github.com/fantasyland/fantasy-land#monad](https://github.com/fantasyland/fantasy-land#monad)。考虑一个
    monad `M` 和在 5.4.2 节中定义的等价性：
- en: 'Left identity — Type-lifting some value `a` and then calling `flatMap` with
    function `f` should yield the same result as if you simply called `f` with `a`.
    In code, both expressions are equivalent:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左单位性 — 类型提升某个值 `a` 然后使用函数 `f` 调用 `flatMap` 应该产生与直接使用 `a` 调用 `f` 相同的结果。在代码中，这两个表达式是等价的：
- en: '[PRE28]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s showcase left identity with simple arrays:'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们用简单的数组展示左单位性：
- en: '[PRE29]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Right identity — Given a monad instance, calling `flatMap` with the type-lift
    constructor function should produce an equivalent monad. Given a monad instance
    `m`, the snippets in the next listing are equivalent.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右单位性 — 给定一个 monad 实例，使用类型提升构造函数调用 `flatMap` 应该产生一个等价的 monad。给定一个 monad 实例 `m`，下一列表中的代码片段是等价的。
- en: Listing 5.10 `Array` examples that illustrate right identity
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列表 5.10 `Array` 示例，说明右单位性
- en: '[PRE30]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Because the implementation of Array.of in JavaScript has multiple arguments,
    we’re not able to pass the function by name into flatMap; instead, we must use
    a function x => Array.of(x).
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ❶ 因为 JavaScript 中 Array.of 的实现有多个参数，所以我们不能通过名称传递函数到 flatMap；相反，我们必须使用函数 x =>
    Array.of(x)。
- en: 'Associativity — As numbers are associative under addition, monads are associative
    under composition. The precedence instilled by the way you parenthesize an expression
    doesn’t alter the final result. Given a monad instance `m` and functions `f` and
    `g`, the following are equivalent:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合律 — 由于数字在加法下是结合的，因此 monads 在组合下也是结合的。你以括号括起来的方式赋予表达式的优先级不会改变最终结果。给定一个 monad
    实例 `m` 和函数 `f` 和 `g`，以下表达式是等价的：
- en: '[PRE31]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When you work with single values, the action of a `map`-then-`flat` can also
    be understood as returning the result of the mapping function alone, thereby ignoring
    the outermost layer. Our `Monad` mixin in the following listing accomplishes that
    task.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理单个值时，`map`-then-`flat` 的操作也可以理解为仅返回映射函数的结果，从而忽略最外层。以下列表中的 `Monad` 混合实现了这个任务。
- en: Listing 5.11 `Monad` mixin
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.11 `Monad` 混合
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Ignores the extra wrapping layer and assumes that the type is a functor
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 忽略额外的包装层并假设类型是函子
- en: ❷ You may also find this method called bind or chain.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 你也可能发现这个方法被称为 bind 或 chain。
- en: This example teaches us that when we’re dealing with JavaScript arrays specifically,
    `flatMap` is much more efficient than calling `map` and then `flat` manually.
    This procedure is more efficient in terms of CPU cycles and memory footprint.
    Keep in mind that every time you call `map` or `flat`, a new array is created,
    so combining them in one fell swoop prevents the additional overhead.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子告诉我们，当我们具体处理 JavaScript 数组时，`flatMap` 比手动调用 `map` 和 `flat` 更有效率。从 CPU 周期和内存占用角度来看，这个程序更有效率。记住，每次调用
    `map` 或 `flat` 都会创建一个新的数组，所以一次性将它们组合起来可以防止额外的开销。
- en: Method fusion
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 方法融合
- en: 'The fact that arrays behave monadically has many advantages. The law of composition
    is not only a core part of the behavior of functors and monads, but also a performance
    enhancement for container types called method fusion, also known as shortcut fusion.
    In essence, you can use `compose` to fuse or combine the execution of multiple
    calls to `map` into one. Take a look at the examples used for this protocol:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 数组以 monadic 方式行为的事实具有许多优点。组合律不仅是 functors 和 monads 行为的核心部分，也是容器类型方法融合（也称为快捷融合）的性能提升。本质上，你可以使用
    `compose` 将多个对 `map` 的调用融合或组合成一次执行。看看用于此协议的示例：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: and
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Both snippets generate the same output, but the first one uses a quarter of
    the space. `compose` avoids the multiple calls to `map`, each creating another
    copy of the array in memory. With an array this size, the performance is negligible.
    But if we were processing lots of data, method fusion could save us from running
    out of memory. Libraries such as Lodash ([https://lodash.com](https://lodash.com/)),
    which uses lazy evaluation, can analyze an expression that combines calls to `map`,
    `filter`, and others, and then fuse them together.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个片段生成相同的输出，但第一个片段只使用了四分之一的空间。`compose` 避免了对 `map` 的多次调用，每次调用都会在内存中创建另一个数组的副本。对于这么大的数组，性能的提升是可以忽略不计的。但如果我们处理大量数据，方法融合可以帮我们避免内存不足的问题。例如，Lodash
    ([https://lodash.com](https://lodash.com/)) 这样的库，它使用懒计算，可以分析一个结合了 `map`、`filter`
    等调用的表达式，然后将它们融合在一起。
- en: 'For the sake of completeness, consider a similar example using `Id`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，考虑一个使用 `Id` 的类似示例：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For this code to work, we will extend `Id` once more with the monadic behavior
    integrating that mixin:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这段代码能够正常工作，我们将再次通过将 monadic 行为整合到 mixin 中来扩展 `Id`：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Emulating typeclasses
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟类型类
- en: 'There’s another reason why I think mixins are a sound implementation strategy
    here for these APIs: they model an equivalent concept in functional languages
    such as Scala and Haskell. A typeclass allows you to define a generic interface
    so that any object can conform to a certain behavior. `Functor` and `Monad` can
    make any type behave monadically with little work, for example.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这里使用 mixins 作为这些 API 的实现策略还有一个原因：它们在 Scala 和 Haskell 等函数式语言中建模了一个等效的概念。类型类允许你定义一个通用接口，以便任何对象都可以符合某种行为。例如，`Functor`
    和 `Monad` 可以通过很少的工作使任何类型表现出 monadic 行为。
- en: We can continue to optimize this example a little bit more. Earlier, I mentioned
    that monads are also functors. Following that definition, it makes sense to compose
    the `Functor` mixin into the `Monad` mixin. Consider the `Monad` definition in
    the next listing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以继续优化这个例子。之前，我提到 monads 也是一种 functors。根据那个定义，将 `Functor` mixin 组合到 `Monad`
    mixin 中是有意义的。考虑下一个列表中的 `Monad` 定义。
- en: Listing 5.12 Defining `Monad` and `Functor`
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.12 定义 `Monad` 和 `Functor`
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ References map in Functor
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 Functor 中引用 map
- en: ❷ Omits the other method aliases
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 省略了其他方法别名
- en: 'This example shows how flexible and versatile composition is. Now you can make
    a type a `Functor` or a full `Monad` with its full contract:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了组合的灵活性和多功能性。现在你可以通过其完整契约将其类型变成一个 `Functor` 或一个完整的 `Monad`：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At this point, you’ve learned in a basic way how functors and monads are defined.
    Although these sets of rules may feel contrived and limiting, they’re giving you
    immense structure—the same structure you get from using `Array#{map,` `filter,`
    `reduce}` instead of straight `for` loops and `if` conditions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经以基本的方式学习了 functors 和 monads 的定义。尽管这些规则可能感觉是人为的、限制性的，但它们为你提供了巨大的结构——与使用
    `Array#{map,` `filter,` `reduce}` 而不是直接的 `for` 循环和 `if` 条件所得到的相同结构。
- en: Functor and monads are universal interfaces (protocols) that can plug generically
    into many parts of your application. Abide by them, and any third-party code or
    any other parts of your application that implement or support these types know
    exactly how to work with it. A good example of how this protocol integrates with
    other code is the `Promise` object, which you’re probably familiar with. Promises
    are modeled, to some extent, after functors and monads; substitute `then` for
    `map` or `flatMap`, and a lot of these rules discussed in section 5.4 apply. We’ll
    look at promises more closely in chapter 8.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Functor 和 monad 是通用的接口（协议），可以通用地插入到应用程序的许多部分。遵守它们，任何第三方代码或应用程序的其他部分，如果实现或支持这些类型，将确切知道如何与之协同工作。一个很好的例子是
    `Promise` 对象，你可能很熟悉。在某种程度上，Promise 是基于 functors 和 monads 构建的；用 `then` 替换 `map`
    或 `flatMap`，许多第 5.4 节中讨论的规则都适用。我们将在第 8 章中更详细地研究 Promise。
- en: Monads are not an easy pattern to grok, but it’s important to start learning
    about them now; more of these patterns are starting to emerge in modern software
    development, and you don’t want to get caught wrapped in a burrito ([https://youtu.be/
    dkZFtimgAcM](https://youtu.be/dkZFtimgAcM)); you want to be ready.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Monad 模式并不容易理解，但重要的是现在就开始学习它们；这些模式在现代软件开发中越来越多地出现，你不想被卷入一个墨西哥卷饼（[https://youtu.be/dkZFtimgAcM](https://youtu.be/dkZFtimgAcM)）；你想要做好准备。
- en: In practice, you will probably never need to implement `Id` as such in your
    own applications. I did it to show you how the pattern works and how appending
    the `Functor` and `Monad` mixins endow this class with powerful composable behavior.
    The real bang for your buck will come from more embellished, smarter types with
    computational logic of their own within their `map` and `flatMap` methods. In
    section 5.1, I defined a closed context and showed how it models a railway-driven
    approach to data processing. With the basics behind us, we’re going to kick things
    up a notch and create our own ADT to implement contextual validation.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你可能永远不会需要在自己的应用程序中实现 `Id`。我这样做是为了向你展示这个模式的工作原理以及如何通过添加 `Functor` 和 `Monad`
    混合来赋予这个类强大的可组合行为。真正的价值将来自更精致、更智能的类型，它们在 `map` 和 `flatMap` 方法中具有自己的计算逻辑。在第 5.1
    节中，我定义了一个封闭上下文，并展示了它如何模拟铁路驱动的数据处理方法。在掌握基础知识之后，我们将进一步提高标准，并创建我们自己的 ADT 来实现上下文验证。
- en: 5.5 Contextual validation with higher-order functions
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 使用高阶函数进行上下文验证
- en: An ADT is nothing more than an immutable composite data structure that contains
    other types. Most ADT in practice implement the monad contract, much like the
    `Id` container.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ADT 仅仅是一个不可变复合数据结构，其中包含其他类型。实践中大多数 ADT 都实现了 monad 协约，就像 `Id` 容器一样。
- en: 'Before we dive in, it’s worth pointing out that an ADT is a different pattern
    from an Abstract Data Type (which goes by the same acronym): a collection that
    should hold objects of the same type, such as `Array`, `Set`, `Stack`, and `Queue`
    (although JavaScript does not enforce this rule). An Algebraic Data Type pattern,
    on the other hand, can and usually does contain different types. The Algebraic
    part of the name comes from the mathematical protocol of identity, composability,
    and associativity (section 5.4).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨之前，值得指出的是，ADT 与抽象数据类型（简称 ADT）是不同的模式：一个应该包含相同类型对象的集合，例如 `Array`、`Set`、`Stack`
    和 `Queue`（尽管 JavaScript 不强制执行此规则）。另一方面，代数数据类型模式可以且通常包含不同类型。名称中的代数部分来自数学协议中的恒等性、可组合性和结合性（第
    5.4 节）。
- en: In this section, we’ll learn about the fundamentals of ADTs and see how to use
    the Functor and Monad contracts to solve contextual data validation in a composable
    manner.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习 ADT 的基础知识，并了解如何使用 Functor 和 Monad 合约以可组合的方式解决上下文数据验证。
- en: 5.5.1 Kinds of ADTs
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.1 ADT 类型种类
- en: 'ADTs are more prominent in the strongly typed world, where type information
    makes code more explicit and rigorous. (For more information on using types with
    JavaScript, see appendix B.) But there’s still a lot we can do even without type
    information. This section looks at the two most common kinds of ADTs: `Record`
    and `Choice`. Both of these encapsulate some useful coding patterns.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ADT 在强类型世界中更为突出，其中类型信息使代码更加明确和严谨。（有关在 JavaScript 中使用类型的更多信息，请参阅附录 B。）但即使没有类型信息，我们仍然可以做很多事情。本节将探讨两种最常见的
    ADT 类型：`Record` 和 `Choice`。这两个都封装了一些有用的编码模式。
- en: Record
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Record
- en: 'A record type is a composite that contains a fixed number of (usually primitive)
    types, called its operands. This is similar to a database record in which the
    schema describes the types it can hold and has a fixed length. Some JavaScript
    libraries, such as Immutable.js, provide a `Record` type that you can import and
    use. The most common example of a record is an immutable `Pair`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 记录类型是一个包含固定数量（通常是原始类型）的操作数的复合类型。这类似于数据库记录，其中模式描述了它可以持有的类型，并且具有固定长度。一些JavaScript库，如Immutable.js，提供了一个可以导入和使用的
    `Record` 类型。记录最常见的例子是不可变的 `Pair`：
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: A `Pair` is an immutable object with a cardinality of 2 that can be used to
    relate two pieces of information (of any type), such as a username and password,
    a public and private key, a filename with an access mode, or even a key/value
    entry in a map data structure. `Pair` is a generic record type of which `Money`,
    introduced in chapter 4, or a type like `Point(x,` `y)` can be derived implementations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pair` 是一个具有2个基数的不变对象，可以用来关联两块信息（任何类型），例如用户名和密码、公钥和私钥、文件名和访问模式，甚至是在映射数据结构中的键/值条目。`Pair`
    是一个泛型记录类型，其中 `Money`（在第4章中引入）或类似 `Point(x, y)` 的类型可以派生出实现。'
- en: The best use of a `Pair` is to return two related values from a function at
    the same time. Most often, a simple array literal or even a simple object literal
    is used to express a rudimentary `Pair`. Then you can take advantage of destructuring
    to access each field. You could have something like
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pair` 的最佳用途是在函数中同时返回两个相关值。最常见的是，使用简单的数组字面量或甚至简单的对象字面量来表示基本的 `Pair`。然后你可以利用解构来访问每个字段。你可以有如下内容'
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Unfortunately, these two approaches don’t work well because they are mutable,
    and because array is generic, it doesn’t communicate any relationship among its
    values. A record semantically communicates an AND relationship among its values,
    implying they must exist or make sense together (such as username AND password).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，这两种方法并不奏效，因为它们是可变的，并且由于数组是泛型的，它并没有传达其值之间的任何关系。记录在语义上传达了其值之间的逻辑与关系，意味着它们必须存在或一起有意义（例如用户名和密码）。
- en: Records also go by the name of product or tuple. A pair is a 2-tuple, and a
    triple is a 3-tuple, all the way to an n-tuple. JavaScript has no native tuple
    or record concept, but an early proposal might bring it to JavaScript in the near
    future ([https://github .com/tc39/proposal-record-tuple](https://github.com/tc39/proposal-record-tuple)).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 记录也被称为产品或元组。一对是2-元组，一个三元组是3-元组，以此类推到n-元组。JavaScript没有原生的元组或记录概念，但一个早期的提案可能会在不久的将来将其引入JavaScript（[https://github.com/tc39/proposal-record-tuple](https://github.com/tc39/proposal-record-tuple)）。
- en: 5.5.2 Choices
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.2 选择
- en: Whereas a record enforces a logical AND, a choice represents a logical OR relationship
    among its operands or the values it accepts. A choice is also known as a discriminated
    union or a sum type. Like a record, a choice type can hold multiple values, but
    only one of them is used at any point in time. A simple analogy involves using
    JavaScript’s null coalesce and nullish coalesce operators, respectively. Consider
    the simple example in the next listing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 与记录强制逻辑与不同，选择表示操作数或它接受的值之间的逻辑或关系。选择也被称为区分联合或求和类型。与记录一样，选择类型可以持有多个值，但在任何给定时间点只使用其中一个。一个简单的类比是使用JavaScript的null合并和nullish合并运算符。考虑下一个列表中的简单示例。
- en: Listing 5.13 Null and nullish coalesce operators
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.13 Null 和 nullish 合并运算符
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ❶ Evaluates right side when left side contains a falsy value
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当左侧包含一个假值时评估右侧
- en: ❷ Evaluates right side only when left side is null
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 仅当左侧为null时评估右侧
- en: In the case of the null coalesce operator, if `precomputedHash` is not a falsy
    value (null, undefined, empty string, 0, or so on), this expression evaluates
    the left side of the `||` operator; otherwise, it evaluates to the right. I recommend
    that you use the nullish (or nullary) coalesce operator (`??`), as it evaluates
    the right side only when the `precomputedHash` is `null` or `undefined`, which
    is what you intend to do most of the time.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在null合并运算符的情况下，如果 `precomputedHash` 不是一个假值（null、undefined、空字符串、0等），则此表达式评估 `||`
    运算符的左侧；否则，它评估为右侧。我建议你使用nullish（或nullary）合并运算符（`??`），因为它仅在 `precomputedHash` 是
    `null` 或 `undefined` 时评估右侧，这通常是你的意图。
- en: Choice types are often used in cases that involve data checks, data validation,
    or error handling. The reason is that a choice models mutually exclusive branches
    such as success/failure, valid/invalid, and ok/error. These cases are simple binary
    (of cardinality 2) use cases, for which we mistakenly are tempted to abuse Booleans.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 选择类型常用于涉及数据检查、数据验证或错误处理的情况。原因在于选择模型了互斥分支，如成功/失败、有效/无效和 ok/错误。这些情况是简单的二元（基数 2）用例，我们错误地倾向于滥用布尔值。
- en: 'If you have experience with TypeScript, for example, an enumeration type or
    a utility type is a common way to represent an object that could be in one of
    multiple states. Consider this definition:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有 TypeScript 的经验，枚举类型或实用类型是表示可能处于多种状态之一的对象的常见方式。考虑以下定义：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With minimal tooling, you could also extend JavaScript with types (appendix
    B) and use enumerations the same way. Another analogy is a `switch` statement,
    which is often used to invoke conditional logic with multiple possible states.
    With two cases, the logic of a choice type would look something like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用最小工具，你也可以扩展 JavaScript 以使用类型（附录 B）并以相同的方式使用枚举。另一个类比是 `switch` 语句，它通常用于调用具有多个可能状态的条件逻辑。有两个情况时，选择类型的逻辑可能看起来像这样：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Using this structure, consider the hypothetical use case in the next listing
    that checks for the validity of a certain value.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种结构，考虑以下列表中的假设用例，该用例检查某个值的有效性。
- en: Listing 5.14 Using a `switch` statement to perform an action based on one condition
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.14 使用 `switch` 语句根据一个条件执行操作
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ❶ return/break intentionally skipped to return default value
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 故意跳过 return/break 以返回默认值
- en: 'You can think of a choice ADT as always keeping track of multiple mutually
    exclusive states and reacting accordingly. Validating data is no different in
    that you can have only one of two possible outcomes: success or failure.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将选择 ADT 视为始终跟踪多个互斥状态并根据情况做出反应。验证数据与此类似，你只能有两种可能的结果：成功或失败。
- en: 5.5.3 Modeling success and failure with the Validation monad
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.3 使用 Validation 单子建模成功和失败
- en: Data validation is a common programming task, usually involving a lot of code
    splitting (`if`/`else`/`switch` statements) that are often duplicated and scattered
    in several parts of the application. We’re all well aware that code with lots
    of conditionals gets messy and difficult to abstract over, not to mention hard
    to read and expensive to maintain. This section teaches you how to implement and
    use monads to address this issue while keeping your code simple to read, modular,
    and (most important) composable.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 数据验证是常见的编程任务，通常涉及大量的代码拆分（`if`/`else`/`switch` 语句），这些语句经常被复制并分散在应用程序的几个部分中。我们都非常清楚，带有大量条件语句的代码会变得混乱，难以抽象，更不用说难以阅读和维护了。本节将教你如何实现和使用单子来解决这个问题，同时保持你的代码易于阅读、模块化，并且（最重要的是）可组合。
- en: Generally, when implementing an ADT, you must take two dimensions into account.
    One is the kind (record or choice), and the other is the level of composability
    needed (functor or monad). In this section, we will create a `Validation` object
    as a choice type with monadic behavior so that we can compose sequences of individual
    validated operations together. By the end, we’ll finish implementing the logic
    behind the `HasValidation` mixin and use it to run validation code on every element
    of the blockchain in a consistent way.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在实现 ADT 时，你必须考虑两个维度。一个是类型（记录或选择），另一个是需要组合的级别（函子或单子）。在本节中，我们将创建一个具有单子行为的 `Validation`
    对象作为选择类型，以便我们可以将单个验证操作的序列组合在一起。最终，我们将完成 `HasValidation` 混合逻辑的实现，并使用它以一致的方式对区块链中的每个元素运行验证代码。
- en: '`Validation` models two states that make up its computation context, `Success`
    and `Failure`, as shown in figure 5.4.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`Validation` 模型了其计算上下文由两个状态组成，`Success` 和 `Failure`，如图 5.4 所示。'
- en: '![](../Images/5-4.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-4.png)'
- en: Figure 5.4 Structure of the `Validation` type. `Validation` offers a choice
    of `Success` or `Failure`, never both.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 `Validation` 类型的结构。`Validation` 提供了 `Success` 或 `Failure` 的选择，永远不会同时两者都有。
- en: We’ll allow the `Success` branch to apply functions (such as `doWork`) on the
    contained value when it’s active. Indeed, this job sounds like one for `map` and
    `flatMap`. Otherwise, in the event of a validation failure, we’ll skip calling
    the logic and propagate the error encountered. This pattern is useful when you
    need to bubble up an error that occurred during a complex sequence of operations—something
    that `if`/`else` and even `try`/`catch` blocks struggle with.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将允许 `Success` 分支在活动时对包含的值应用函数（如 `doWork`）。实际上，这项工作听起来像是 `map` 和 `flatMap`
    的工作。否则，在验证失败的情况下，我们将跳过调用逻辑并传播遇到的错误。当需要将复杂操作序列中发生的错误向上冒泡时，这种模式很有用——这是 `if`/`else`
    和甚至 `try`/`catch` 块都难以处理的。
- en: In addition, think about how many times you have written validation functions
    that return Boolean. I know I have, but this is a bad habit. By returning a `Validation`
    object from your functions, you’re directly forcing users to handle `Success`
    and `Failure` cases properly instead of testing a Boolean. Another clear benefit
    is that your functions become self-documenting or, in Edsger Dijkstra’s words,
    “more precise.” In JavaScript, this benefit is important because documentation
    is often lacking, and you need to trace through the code to see what exceptions
    are being thrown or any special error values, such as `null` or `undefined`. Acknowledging
    that some operations might fail ahead of time is much better than having your
    users guess that an error, if any, might occur when invoking a particular function.
    We can all agree that returning `false` conveys nothing to the caller about which
    operation or data in question was invalid; there’s no context.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，想想你写了多少次返回布尔值的验证函数。我知道我写过，但这是一个坏习惯。通过从你的函数中返回 `Validation` 对象，你直接强迫用户正确处理
    `Success` 和 `Failure` 情况，而不是测试布尔值。另一个明显的优点是，你的函数变得自文档化，或者用 Edsger Dijkstra 的话说，“更精确。”在
    JavaScript 中，这个优点很重要，因为文档通常缺乏，你需要跟踪代码以查看抛出了哪些异常或任何特殊的错误值，例如 `null` 或 `undefined`。提前承认某些操作可能会失败要好得多，而不是让你的用户猜测在调用特定函数时是否可能发生错误。我们都可以同意，返回
    `false` 并没有向调用者传达有关哪个操作或数据无效的任何信息；没有上下文。
- en: Finally, another good quality of validation procedures is that they fail-fast.
    Because composition chains a function’s inputs and outputs, it’s pointless to
    have functions run with invalid data when an error has already been discovered.
    Short-circuiting is sensible.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，验证过程的一个良好品质是它们能够快速失败。因为组合链连接了一个函数的输入和输出，当已经发现错误时，让函数运行无效数据是没有意义的。短路是有意义的。
- en: 'Let’s look at a hypothetical example in blockchains that involves validating
    whether a block has been tampered with. This check is easily made by recomputing
    a block’s hash and checking it against its own:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个假设的区块链示例，该示例涉及验证一个区块是否被篡改。通过重新计算区块的哈希并与其自身进行比较，这个检查很容易完成：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This function checks for a certain condition and returns a `Success` wrapper
    containing the correct value or a `Failure` object with an error message. This
    function doesn’t care how the error propagates forward or how it would work as
    part of a longer composition chain; it focuses on its own task.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数检查特定条件，并返回包含正确值的 `Success` 包装器或包含错误信息的 `Failure` 对象。此函数不关心错误如何向前传播或作为更长组合链的一部分如何工作；它专注于自己的任务。
- en: Both `Success` and `Failure` branches are part of the `Validation` composite
    and are the central abstractions that drive a series of validations to a final
    result or to an error. `Success` and `Failure` are closed contexts, modeling the
    notion of an operation that passes or fails as a first-class citizen of your application.
    The following listing uses a class to implement this behavior.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`Success` 和 `Failure` 分支都是 `Validation` 组合的一部分，并且是驱动一系列验证到达最终结果或错误的中心抽象。`Success`
    和 `Failure` 是封闭的上下文，将操作成功或失败作为应用程序的一等公民进行建模。以下列表使用一个类来实现这种行为。'
- en: Listing 5.15 Parent `Validation` class
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.15 父 `Validation` 类
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ Value is private and read-only
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 值是私有的且只读的
- en: '❷ Prevents direct instantiation, effectively making Validation an abstract
    class and forcing its behavior to be accessed through its variant types: Success
    and Failure'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 防止直接实例化，有效地使 Validation 成为抽象类，并强制通过其变体类型（Success 和 Failure）访问其行为
- en: ❸ Reads the value from the container
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从容器中读取值
- en: ❹ Generic type-lifting function that returns a new instance of Success
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 泛型类型提升函数，返回 Success 的新实例
- en: ❺ Queries the type of container at runtime; set to false as default to indicate
    that none of the branches is active
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在运行时查询容器的类型；默认设置为false以表示没有分支是激活的
- en: ❻ Provides a generic way to recover
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 提供了一种通用的恢复方式
- en: 'Extending from this class are the concrete variant choices: `Success` and `Failure`.
    The `Success` path is what we call the happy path, so there’s not much to differentiate
    it from the parent. `Failure` overrides the behavior of some of those inherited
    methods, as shown in the next listing.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个类派生出具体的变体选择：`Success`和`Failure`。`Success`路径就是我们所说的快乐路径，所以它与父类没有太多区别。`Failure`覆盖了一些继承方法的某些行为，如下一列表所示。
- en: Listing 5.16 `Success` and `Failure` branches of `Validation`
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.16 `Validation`的`Success`和`Failure`分支
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Overrides the type of container
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 覆盖容器的类型
- en: ❷ Calling get directly on failure is considered to be a programming error.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在失败时直接调用get被认为是编程错误。
- en: Using classes vs. objects to model ADTs
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类与对象来建模ADT
- en: 'I chose to use classes to design `Validation` because this is what the majority
    of JavaScript developers use. Nevertheless, any of the patterns covered in chapters
    2 and 3 (constructor functions, OLOO, mixins) would work as well. For comparison,
    here’s an OLOO version of the `Validation` ADT:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用类来设计`Validation`，因为这正是大多数JavaScript开发者所使用的。尽管如此，第2章和第3章中涵盖的任何模式（构造函数、OLOO、混合）都可以同样工作。为了比较，这里是一个`Validation`
    ADT的OLOO版本：
- en: '[PRE48]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, by not shoehorning class-based design into JavaScript, OLOO
    greatly reduces the amount of complexity in the code by removing the need for
    special syntax for private variables, enforcement of abstract class behavior,
    and all references to class-oriented inheritance mental model (`class`, `extends`)
    while keeping all the same functionality.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过不将基于类的设计强加到JavaScript中，OLOO通过移除私有变量的特殊语法、抽象类行为的强制执行以及所有面向类的继承思维模型（`class`、`extends`）的需求，大大减少了代码的复杂性，同时保持了所有相同的功能。
- en: It may not be immediately obvious, but given that `Validation` can hold only
    a single value at a time (valid value or an error), it’s more memory-efficient
    than record types, which store all values in the tuple.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是立即显而易见的，但鉴于`Validation`一次只能持有单个值（有效值或错误），它比记录类型更节省内存，记录类型将所有值存储在元组中。
- en: Now that we’ve implemented the basic pieces, let’s see them in action.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了基本部分，让我们看看它们是如何工作的。
- en: 5.5.4 Composing with monads
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.4 与单子组合
- en: 'To show this type in action, let’s refactor `countBlocksInFile` (started in
    chapter 4) to a function that also features validation:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这种类型的作用，让我们将`countBlocksInFile`（在第4章开始）重构为一个也具有验证功能的函数：
- en: '[PRE49]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This function reads from a file to a binary buffer, decodes this buffer to
    a UTF-8 string, parses this string to an array of blocks, and finally counts it.
    But this function is missing an important part: checking whether the file exists.
    If the file doesn’t exist, `read` will throw an exception. Likewise, without a
    valid `Buffer` object, `decode` will throw an exception, and so on.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从文件读取到二进制缓冲区，将此缓冲区解码为UTF-8字符串，解析此字符串到块数组，并最终进行计数。但这个函数缺少一个重要的部分：检查文件是否存在。如果文件不存在，`read`将抛出异常。同样，如果没有有效的`Buffer`对象，`decode`将抛出异常，依此类推。
- en: Because the critical point of inflexion is whether the file exists, we can use
    `Validation` to abstract over this split point. Let’s refactor the `read` function
    to return a `Validation` instance instead in the next listing.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因为关键点在于文件是否存在，我们可以使用`Validation`来抽象这个分界点。让我们在下一列表中重构`read`函数，使其返回一个`Validation`实例。
- en: Listing 5.17 Creating a version of `read` that returns a `Validation` result
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.17 创建返回`Validation`结果的`read`版本
- en: '[PRE50]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: ❶ The conditional expression here models the logical OR to decide which branch
    to follow.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这里的条件表达式模拟了逻辑OR以决定要遵循哪个分支。
- en: ❷ An array is useful so that you can concatenate more than one error message.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 数组很有用，这样您就可以连接多个错误消息。
- en: 'Now this code works as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这段代码是这样工作的：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Executing the rest of the code is a matter of mapping each transformation to
    each `Success` container, like any generic functor. The `Functor` mixin is sufficient:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 执行其余代码是将每个转换映射到每个`Success`容器，就像任何泛型函子一样。`Functor`混合足够使用：
- en: '[PRE52]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'By doing this, we get the benefit of tightly coupling the validation branches
    and shared data with the loosely coupled, Lego-style extension of mixins for shared
    behavior. With `map`, this code works as it did with `compose` due to the `map`/`compose`
    equivalence. Once again, you see the deep impact of this ostensibly trivial equivalence:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们得到了将验证分支和共享数据紧密耦合与将共享行为扩展为松耦合的乐高式mixins的好处。由于`map`/`compose`等价性，这段代码在`map`和`compose`下工作得一样好。再次看到这个表面上微不足道的等价性对深层次的影响：
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Furthermore, it’s a common pattern for choice ADTs to map functions on one side
    and skip them (no-op) on the other. `Validation` executes on the success branch,
    which we’ll call the right side, also known as right-biased. In the previous example,
    we made `Success` (the right side) a functor. We also need to account for the
    `Failure` branch so that any composed operations are ignored or skipped in the
    event of a read error. For this purpose, we can create a `NoopFunctor` mixin with
    the same shape as the regular `Functor`, as the next listing shows.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于选择ADT来说，将函数映射到一边并在另一边跳过（无操作）是一个常见的模式。`Validation`在成功分支上执行，我们将它称为右侧，也称为右偏。在先前的例子中，我们将`Success`（右侧）做成一个functor。我们还需要考虑`Failure`分支，以便在读取错误的情况下忽略或跳过任何组合操作。为此，我们可以创建一个与常规`Functor`具有相同形状的`NoopFunctor`
    mixin，如下所示。
- en: Listing 5.18 Using `NoopFunctor` in failure cases to skip calling mapped functions
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.18 在失败情况下使用`NoopFunctor`以跳过调用映射函数
- en: '[PRE54]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ❶ Because the data is left untouched, it’s sensible to return the same object
    to the caller.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 因为数据保持不变，所以返回相同的对象给调用者是有意义的。
- en: 'Let’s assign `NoopFunctor` to `Failure` (the left side):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`NoopFunctor`分配给`Failure`（左侧）：
- en: '[PRE55]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: After we account for both case classes, the flow of execution looks like figure
    5.5.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们考虑了两种情况类之后，执行流程看起来就像图5.5所示。
- en: '![](../Images/5-5.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图5-5](../Images/5-5.png)'
- en: Figure 5.5 Detailed execution of the composition of functions mapped over a
    `Validation` type. When the operations are successful, the container allows each
    operation to map over the wrapped data; otherwise, it skips to a recovery alternative.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 详细展示了在`Validation`类型上映射函数的组合执行。当操作成功时，容器允许每个操作映射到包装的数据；否则，跳转到恢复替代方案。
- en: First, let’s look at a simple example of a failure branch so that you can understand
    how this object handles errors.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看一个简单的失败分支的例子，这样你就可以理解这个对象是如何处理错误的。
- en: 'Suppose that you want to use `Validation` to abstract over checking for null
    objects. First, create the function that implements the branching logic (`fromNullable`):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想使用`Validation`来抽象检查空对象。首先，创建一个实现分支逻辑的函数（`fromNullable`）：
- en: '[PRE56]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This abstraction helps us apply functions to data without having to worry about
    whether the data is defined, as shown in the following listing.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这种抽象帮助我们应用函数到数据上，而无需担心数据是否已定义，如下面的列表所示。
- en: Listing 5.19 Using `fromNullable` to process valid strings
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.19 使用`fromNullable`处理有效的字符串
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ❶ Underlying implementation of map is the NoopFunctor, which ignores the operation
    when data is invalid
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ map的底层实现是NoopFunctor，当数据无效时忽略操作
- en: 'To showcase this type in the real world, let’s use it in our blockchain application.
    Validating or verifying the contents of a blockchain is such an important part
    of this technology that companies specialize in implementing this aspect of the
    protocol. We’re implementing a much more simplified version for this book, of
    course. Aside from `checkTampering` (as implemented in section 5.5.3) we must
    ensure that blocks are in the right position in the chain (`checkIndex`) and that
    their timestamps are greater than or equal to that of the previous one (`checkTimestamp`).
    Both simple rules look like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在现实世界中展示这种类型，让我们在我们的区块链应用程序中使用它。验证或验证区块链的内容是这项技术如此重要的一个部分，以至于公司专门实施这个协议的这部分。当然，我们在这本书中实现的是一个大大简化的版本。除了`checkTampering`（如第5.5.3节中实现）之外，我们还必须确保块在链中的位置正确（`checkIndex`）以及它们的时间戳大于或等于前一个的时间戳（`checkTimestamp`）。这两个简单规则看起来是这样的：
- en: '[PRE58]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We’re going to use currying to make applying these functions easier. Notice
    that we defined these functions as curried functions (see chapter 4) to facilitate
    composing them as a validation sequence. Because blocks are linked in a chain,
    to compare one block, you need to load the previous one (after the genesis block).
    From any block, this process is always simple because each block has a reference
    to the previous block’s hash and a reference to the chain of which it is part,
    as shown in the next listing.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用柯里化来简化这些函数的应用。注意，我们定义了这些函数为柯里化函数（见第4章），以便将它们作为验证序列组合。因为区块是链式连接的，要比较一个区块，你需要加载前一个区块（在创世区块之后）。从任何区块开始，这个过程总是很简单，因为每个区块都有一个指向前一个区块哈希的引用，以及指向它所属链的引用，如下一个列表所示。
- en: Listing 5.20 `isValid` method of `Block`
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.20 `Block`的`isValid`方法
- en: '[PRE59]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ❶ Uses destructuring with variable name change
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用解构并更改变量名
- en: ❷ These functions return either Success or Failure.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这些函数返回成功或失败。
- en: ❸ Alters the block’s data
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 改变了区块的数据
- en: ❹ Validation check fails due to tamper check
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 验证检查因篡改检查失败
- en: This code seems perfectly fine if we want to return a Boolean result, which
    lacks any context of the running operation. The best approach here, however, is
    for `isValid` to return a `Validation` object instead of a Boolean. That way,
    if we want to validate the entire blockchain data structure (not one block), we
    can compose all the `Validation` objects together, and in the event of a failure,
    we could report exactly what the error is.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要返回一个布尔结果，这个代码看起来是完美的，因为它缺少运行操作的任何上下文。然而，在这里，最好的方法是将`isValid`返回一个`Validation`对象而不是布尔值。这样，如果我们想要验证整个区块链数据结构（而不是一个区块），我们可以将所有的`Validation`对象组合在一起，在失败的情况下，我们可以精确地报告错误是什么。
- en: 5.5.5 Higher-kinded composition with Validation
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.5 使用Validation进行高阶组合
- en: 'As we did with `Id` in section 5.4.2, let’s bestow upon `Validation` the ability
    to compose with other objects of the same type and form chains. For this task,
    we can attach the `Monad` mixin, which includes `Functor` as well as the ability
    to `flatMap` other `Validation`-returning functions. For the `Success` branch,
    we can assign the `Monad` mixin:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在5.4.2节中对`Id`所做的那样，让我们赋予`Validation`与其他相同类型对象组合的能力，并形成链。为此任务，我们可以附加`Monad`mixin，它包括`Functor`以及`flatMap`其他返回`Validation`的函数的能力。对于`Success`分支，我们可以分配`Monad`mixin：
- en: '[PRE60]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For `Failure`, we can apply the logicless `NoopMonad`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Failure`，我们可以应用无逻辑的`NoopMonad`：
- en: '[PRE61]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then extending `Failure` is similar:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后扩展`Failure`类似：
- en: '[PRE62]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The next listing shows how you can type-lift a block object into `Validation`.
    Then the ADT takes over, and all you need to do is chain the validation rules,
    like building a small rules engine.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了如何将区块对象类型提升到`Validation`。然后ADT接管，你所需要做的就是链式连接验证规则，就像构建一个小型规则引擎。
- en: Listing 5.21 `Block` validation with `flatMap`
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.21 使用`flatMap`进行`Block`验证
- en: '[PRE63]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: ❶ The curried form is useful so that the block object (the dynamic argument)
    is passed into each call to flatMap.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 柯里化形式是有用的，这样块对象（动态参数）就可以传递到每个`flatMap`调用中。
- en: 'As you can see, this implementation looks a lot more elegant than the previous
    one and serves as another good example of a hybrid OOP/FP implementation using
    mixins. To ensure a more rigorous transition from OO to FP land, you could opt
    to pass a frozen version of the object:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个实现看起来比之前的实现更加优雅，并且是混合OOP/FP实现的一个很好的例子，使用了mixins。为了确保从OO到FP的更严格过渡，你可以选择传递对象的冻结版本：
- en: '[PRE64]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: A happy path run of this algorithm looks like figure 5.6.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的一个快乐路径运行看起来像图5.6。
- en: '![](../Images/5-6.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图5-6](../Images/5-6.png)'
- en: Figure 5.6 Sequential application of different `Validation`-returning check
    functions composed together with `flatMap`
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 使用`flatMap`组合的不同返回`Validation`的检查函数的顺序应用
- en: 'This new version of `isValid` outputs a `Validation` result instead of a Boolean,
    so using in in the `Success` case looks like this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`isValid`版本输出的是`Validation`结果而不是布尔值，所以在`Success`情况下使用它看起来是这样的：
- en: '[PRE65]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If any of the checks fails, `Validation` will be smart about skipping the rest:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何检查失败，`Validation`会智能地跳过其余部分：
- en: '[PRE66]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Perhaps you’re thinking that although this code looks more succinct, having
    to call `flatMap` every time is a bit verbose. Why not try something more point-free?
    In chapter 4, you learned how to create point-free function compositions with
    `compose` and `curry`. You can also achieve a point-free style with monads in
    JavaScript. To understand how this could work, first we need to implement a slightly
    different variation of `compose` called `composeM`, which uses `flatMap` to control
    the flow of data.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你认为虽然这段代码看起来更简洁，但每次都必须调用 `flatMap` 有点冗长。为什么不尝试更无点的方法呢？在第 4 章中，你学习了如何使用 `compose`
    和 `curry` 创建无点函数组合。你还可以在 JavaScript 中使用单子实现无点风格。为了理解这如何工作，首先我们需要实现一个名为 `composeM`
    的 `compose` 的不同变体，它使用 `flatMap` 来控制数据流。
- en: 5.5.6 Point-free coding with monads
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.6 使用单子的无点编程
- en: 'Point-free coding has the advantage of making complex logic much simpler to
    read at a high level. To allow for point-free coding using monads, we need to
    build up a little more plumbing. In section 5.3, you learned that composing two
    functions is equivalent to mapping one over the other. Parting from this idea,
    the following is also correct:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 无点编程的优点是使复杂逻辑在高级别上更容易阅读。为了允许使用单子进行无点编程，我们需要构建更多的管道。在第 5.3 节中，你学习了如何通过映射一个函数到另一个函数来组合两个函数，这个想法，以下也是正确的：
- en: '[PRE67]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Again, you can extend this code to work with a list of functions (instead of
    only two) by using `reduce`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你可以通过使用 `reduce` 来扩展此代码以与函数列表（而不仅仅是两个）一起工作：
- en: '[PRE68]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'By a similar reasoning, a correspondence exists that allows `flatMap` to become
    the basis of composing two monad-returning functions—in our case, `Validation`-returning
    functions. Using code to demonstrate this correspondence follows a similar train
    of thought of the buildup of `compose` in chapter 4 and the `compose`/`map` equivalence
    (section 5.3). I’ll spare you the details for the sake of brevity and focus on
    what’s important. An alternative to `compose2` that works with monads, called
    `composeM2`, is implemented like this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类似的推理，存在一种对应关系，使得 `flatMap` 成为组合两个返回单子的函数的基础——在我们的例子中，是返回 `Validation` 的函数。使用代码来展示这种对应关系遵循了第
    4 章中 `compose` 的构建过程以及 `compose`/`map` 等价性（第 5.3 节）。为了简洁起见，我将省略细节，只关注重要的部分。一个与单子一起工作的
    `compose2` 的替代方案，称为 `composeM2`，其实现方式如下：
- en: '[PRE69]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As you can see, this implementation is similar to the `map`-based implementation
    of `compose2`. Because the functions in the pipeline are returning monad instances,
    `flatMap` is used to apply the function to the value and automatically flatten
    the container along the way. Finally, to support more than two functions, we do
    a similar reduction:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这种实现与基于 `map` 的 `compose2` 实现类似。因为管道中的函数返回单子实例，所以使用 `flatMap` 来应用函数并自动扁平化容器。最后，为了支持超过两个函数，我们进行类似的缩减：
- en: '[PRE70]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Don’t be concerned about understanding all the details or having to implement
    this code anew every time. Functional JavaScript libraries already have support
    for both types of composition; one works at a higher level of abstraction than
    the other. The gist is that you use `compose` to sequence the execution of functions
    that return unwrapped (simple) values and `composeM` for functions that return
    wrapped values (monads). That is why the former is based on `map` and the latter
    is based on `flatMap`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心理解所有细节或每次都必须重新实现此代码。功能 JavaScript 库已经支持这两种类型的组合；一个在比另一个更高的抽象级别上工作。其核心思想是，你使用
    `compose` 来按顺序执行返回未包装（简单）值的函数，而使用 `composeM` 来执行返回包装值（单子）的函数。这就是为什么前者基于 `map`，而后者基于
    `flatMap`。
- en: Now that we’ve defined `composeM`, let’s put it to work. `composeM` orchestrates
    and chains the logic of each function, and `Validation` steers the overall result
    of the entire operation. With the right guardrails in place, you can sequence
    complex chains of code with automatic, built-in data validation along the way,
    as shown in the next listing.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了 `composeM`，让我们来使用它。`composeM` 组织并链接每个函数的逻辑，而 `Validation` 指导整个操作的整体结果。有了适当的护栏，你可以在自动内置数据验证的过程中按顺序执行复杂的代码链，如下一列表所示。
- en: Listing 5.22 `Block` validation with `composeM`
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.22 使用 `composeM` 的 `Block` 验证
- en: '[PRE71]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: There’s no need to test this logic again; you can do this on your own, following
    the previous examples. If you examine the structure of the composition part, you
    again see that it retains its point-free nature where all function arguments (except
    the curried ones) are not directly specified.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要再次测试这个逻辑；你可以根据之前的示例自己来做。如果你检查组成部分的结构，你会再次看到它保留了无点性质，即所有函数参数（除了柯里化的参数）都没有直接指定。
- en: At this point, you’ve learned enough functional programming concepts that you
    can start taking advantage of this paradigm in your day-to-day tasks. Monads are
    not a simple concept to grok, and many books and articles teach it differently,
    but when you understand that behind the scenes, it’s all about `map` (which you
    do understand from working with arrays), things start to fall into place.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学到了足够多的函数式编程概念，可以开始在日常任务中利用这种范式。单子不是一个容易理解的概念，许多书籍和文章以不同的方式教授它，但当你理解幕后的一切都是关于`map`（你从处理数组中理解了它）时，事情开始变得清晰起来。
- en: 'Let’s continue with our blockchain validation scenario. To recap, unlike regular
    data structures, a blockchain can’t be tampered with or altered in any way. Changing
    one block would involve recalculating the hashes of all subsequent blocks in the
    chain. This restriction also ensures that no one can dominate and re-create the
    entire history of the chain, which prevents the infamous 51% attack, because no
    single entity would be able to harness 51% of all the necessary computational
    power to run all these calculations:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的区块链验证场景。为了回顾，与常规数据结构不同，区块链不能被篡改或以任何方式更改。更改一个区块将涉及重新计算链中所有后续区块的哈希值。这种限制还确保没有人能够主导并重新创建整个链的历史，这防止了臭名昭著的51%攻击，因为没有任何单一实体能够利用所有必要的计算能力的51%来运行所有这些计算：
- en: Are the blocks in the right order?
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块的顺序是否正确？
- en: Are the timestamps in proper chronological order?
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳是否按正确的顺序排列？
- en: Is the integrity of the chain intact, and does each block point to the correct
    previous block? (To check, we see whether the `previousHash` of the block equals
    the `hash` property of the block that went before it.)
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链的完整性是否完好无损，并且每个区块是否指向正确的上一个区块？（为了检查，我们查看区块的`previousHash`是否等于它之前区块的`hash`属性。）
- en: Has the block’s data been tampered with? (To check, we recalculate the hash
    of each block. If something changed inside a block, the hash of that block changes.)
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区块的数据是否被篡改？（为了检查，我们重新计算每个区块的哈希值。如果区块内部有任何变化，该区块的哈希值将发生变化。）
- en: Is the length of the hash correct (using only 64-character-length hashes in
    this book)?
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希的长度是否正确（本书中只使用64字符长度的哈希）？
- en: '[PRE72]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The code in listing 5.22 executed only three validation rules. Observe how this
    code snippet shines when you scale out to many more rules. You can follow the
    implementation of each rule in the code accompanying this book. The thing to focus
    on here is how well-structured and readable the algorithm is. You’ll never sacrifice
    readability if you want to add even more rules. Point-free coding with monads
    truly resembles an assembly-line-style, embedded rules engine. This trade of semicolons
    for commas is the reason why monads are also called programmable commas.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.22中的代码仅执行了三个验证规则。观察当扩展到更多规则时，这个代码片段是如何发光的。你可以通过本书附带的代码来跟踪每个规则的实现。这里要关注的是算法的结构化和可读性。如果你想添加更多规则，你永远不会牺牲可读性。使用单子进行无点编码确实类似于流水线式的嵌入式规则引擎。这种将分号换成逗号的交易是为什么单子也被称为可编程逗号。
- en: Up until now, we’ve been able to validate only a single block instance. Fortunately,
    because our code is composable, we can validate any amount of objects needed.
    Blockchains store billions of objects. You can imagine the work involved in validating
    billions of these blocks. As you know, blocks contain transactions, which also
    need to be validated. For this book, it’s simple to think of a blockchain as being
    a list of lists (blocks with transactions), but in reality it’s a tree. All the
    elements of this tree need to be vertically traversed and validated. A single
    error should cause the entire process to halt (fail-fast).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只能验证单个区块实例。幸运的是，因为我们的代码是可组合的，我们可以验证所需的所有数量的对象。区块链存储数十亿个对象。你可以想象验证数十亿这些区块所涉及的工作。正如你所知，区块包含交易，这些交易也需要验证。对于这本书，简单地将区块链视为一系列列表（包含交易的区块）是很容易的，但现实中它是一个树。这个树的所有元素都需要垂直遍历和验证。任何单个错误都应导致整个过程停止（快速失败）。
- en: 5.5.7 Reducing complex data structures
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.7 简化复杂的数据结构
- en: In this section, you’ll learn that having a well-defined, composable interface
    allows you to reduce complex data structures easily.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解到拥有一个定义良好、可组合的接口可以让你轻松地减少复杂的数据结构。
- en: To validate all the objects of a blockchain (the blockchain object itself, all
    its blocks, and all its transactions), we’ll use the `HasValidation` mixin and
    assign it to all the objects involved. The logic implemented by this mixin is
    used to traverse any object of a blockchain and validate its structure, as shown
    in figure 5.7.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证区块链的所有对象（区块链对象本身、所有区块和所有交易），我们将使用 `HasValidation` 混合并将它分配给所有相关的对象。这个混合所实现的逻辑用于遍历区块链的任何对象并验证其结构，如图
    5.7 所示。
- en: '![](../Images/5-7.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7](../Images/5-7.png)'
- en: Figure 5.7 Traversing a blockchain’s objects, starting with the `Blockchain`
    object itself and moving down to each block’s transactions. You can think of the
    routine as forming a treelike structure, with the `Blockchain` object itself as
    the root, blocks as the second-level nodes, and transactions as the leaves of
    the tree.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 从 `Blockchain` 对象本身开始遍历区块链的对象，向下移动到每个区块的交易。你可以将这个例程想象成一个树状结构，其中 `Blockchain`
    对象本身是根节点，区块是第二级节点，交易是树的叶子。
- en: '`HasValidation` augments objects with a new API: `validate`. Also, `HasValidation`requires
    that every element of the blockchain declare an `isValid` method (returning an
    object of type `Validation`, of course) that knows how to check itself. This interface
    is the minimal interface required.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`HasValidation` 为对象增加了一个新的 API：`validate`。此外，`HasValidation` 要求区块链的每个元素都声明一个
    `isValid` 方法（返回类型为 `Validation` 的对象，当然）以知道如何检查自身。这个接口是所需的最小接口。'
- en: '`isValid` is in charge of implementing all the business rules pertaining to
    the object in question, as you saw with `Block` in section 5.5.6\. The algorithm
    uses `validate` recursively and is designed to start verifying a blockchain from
    any node in the tree.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`isValid` 负责实现与所讨论对象相关的所有业务规则，正如你在 5.5.6 节中看到的 `Block` 一样。该算法使用 `validate`
    递归，并设计为从树中的任何节点开始验证区块链。'
- en: 'Before I outline the steps, let me prepare you for the code you’ll see in listing
    5.23\. Because we’re dealing with a tree-like structure, we’ll use recursion to
    traverse all its nodes. The first part of the algorithm involves enumerating the
    object by using the spread operator. Some built-ins are already iterable. We can
    enumerate all the values inside a map like this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在我概述步骤之前，让我为你准备你将在列表 5.23 中看到的代码。因为我们处理的是树状结构，所以我们将使用递归遍历所有节点。算法的第一部分涉及使用展开操作符列举对象。一些内置对象已经是可迭代的。我们可以这样列举一个映射中的所有值：
- en: '[PRE73]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: With JavaScript, you can define how spread behaves in custom objects as well
    with a special property type known as `Symbol.iterator`. You may have played with
    or read code that uses symbols, which are quite powerful. I haven’t covered symbols
    yet or shown how iteration works; I cover these topics in detail in chapter 7\.
    For now, when you see this idiom `[...obj]`, think of it as returning an array
    representation of the object, hypothetically as `obj.toArray``()`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JavaScript，你可以定义在自定义对象中 `spread` 的行为，这通过一个称为 `Symbol.iterator` 的特殊属性类型来实现。你可能玩过或阅读过使用符号的代码，这些符号非常强大。我还没有介绍符号或展示迭代是如何工作的；我将在第
    7 章详细介绍这些主题。现在，当你看到这个惯用语 `[...obj]` 时，请将其视为返回对象的数组表示，假设为 `obj.toArray()`。
- en: 'Here are the main steps:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是主要步骤：
- en: Enumerate the object into an array. In the case of blockchain, this step returns
    an array with all its blocks. For block, it returns all its transactions.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象列举到数组中。在区块链的情况下，这一步返回包含所有区块的数组。对于区块，它返回所有交易。
- en: Reduce the array of each object’s `isValid` result, starting from the object’s
    own `isValid`.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从对象的 `isValid` 开始，减少每个对象的 `isValid` 结果数组。
- en: Call `validate` on each object, and return to step 1.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个对象调用 `validate`，然后返回到步骤 1。
- en: Return `Validation.Success` if all elements validate; otherwise, return `Validation.Failure`.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有元素都通过验证，则返回 `Validation.Success`；否则，返回 `Validation.Failure`。
- en: Listing 5.23 combines the techniques we’ve been learning about, such as `flatMap`
    and `reduce`, to determine whether all the elements in the chain are valid. Remember
    from chapter 4 that `reduce` is a way to think about composition, and by pairing
    it with `flatMap`, you achieve composition of objects, not functions. At each
    step, the algorithm spreads the object being validated (a block will return its
    list of transactions, for example); then it converts the list of objects to a
    list of `Validation` objects by using `map`. Finally, it uses `flatMap` as the
    reducer function to collapse the result to a single `Validation` object. Recursively,
    all the levels are collapsed into the final `validationResult` accumulator variable.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.23 结合了我们一直在学习的技巧，例如 `flatMap` 和 `reduce`，以确定链中的所有元素是否有效。记得在第四章中，`reduce`
    是一种思考组合的方式，通过将其与 `flatMap` 配对，你实现了对象的组合，而不是函数的组合。在每一步中，算法会展开正在验证的对象（例如，一个块会返回其交易列表）；然后它使用
    `map` 将对象列表转换为 `Validation` 对象列表。最后，它使用 `flatMap` 作为归约函数，将结果折叠成一个单一的 `Validation`
    对象。递归地，所有层级都折叠到最终的 `validationResult` 累加器变量中。
- en: Listing 5.23 `HasValidation` mixin
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.23 `HasValidation` 混合器
- en: '[PRE74]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: ❶ Invokes the object's [Symbol.iterator] to enumerate its state through the
    spread operator
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 调用对象的 [Symbol.iterator] 通过扩展运算符遍历其状态
- en: ❷ Reduces the result of all validation calls into a single one
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将所有验证调用的结果归约为一个
- en: ❸ Begins with the result of checking the current object in question
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从检查当前讨论对象的结果开始
- en: 'Given everything that’s happening in listing 5.23, this algorithm is terse
    and compact. I’ll explain it again from the point of view of a reduction now that
    you’ve seen the code because recursion is hard to grok sometimes. Conceptually,
    you can think of validating an entire data structure as somehow reducing it to
    a single value. That’s happening here. `reduce` allows you to specify a starting
    value: the check of the object that starts `validate`. From that point on, you
    start composing a sequence of validation objects, one on top of the other. Then
    `flatMap` folds all the levels to a single value as it traverses down the tree.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 5.23 中发生的一切，这个算法简洁而紧凑。现在你已经看到了代码，我将从归约的角度再次解释它，因为递归有时很难理解。从概念上讲，你可以将验证整个数据结构视为以某种方式将其简化为单个值。这就是在这里发生的事情。`reduce`
    允许你指定一个起始值：开始 `validate` 的对象的检查。从那时起，你开始组合一系列验证对象，一个接一个。然后 `flatMap` 在遍历树的过程中将所有层级折叠成一个单一的值。
- en: One thing that might catch your attention is the arrow function passed to `flatMap`.
    Because we’re not interested in knowing which object is currently passing all
    checks, only that it did, we throw away the input argument. `Validation` is doing
    the heavy lifting of keeping track of the error details for us. If it detects
    an error, the underlying type internally switches from `Success` to `Failure`,
    records the error, and sidesteps the rest of the operations (flat-mapping failures
    on top of failures).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会吸引你注意的一件事是传递给 `flatMap` 的箭头函数。因为我们不关心当前通过所有检查的对象是哪一个，只关心它确实通过了，所以我们丢弃了输入参数。`Validation`
    正在为我们做繁重的任务，跟踪错误详情。如果它检测到错误，底层类型会从内部将 `Success` 切换到 `Failure`，记录错误，并跳过其余的操作（在失败上执行扁平映射）。
- en: The downside of listing 5.23 is that it creates an array in memory at each branch
    of the blockchain. This code will not scale for real-world blockchains with billions
    of objects, however. In chapter 9, we’ll address this problem with a programming
    model that allows us to process infinite amounts of data.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.23 的缺点是它在区块链的每个分支中都会在内存中创建一个数组。然而，这段代码对于拥有数十亿对象的现实世界区块链来说是无法扩展的。在第九章中，我们将使用一种编程模型来解决这个问题，该模型允许我们处理无限量的数据。
- en: 'Remember from chapter 3 that `Blockchain`, `Block`, and `Transaction` all implemented
    this mixin. Now you know how it works. Here’s the snippet of code that attaches
    this mixin to each of the main classes of our domain:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在第三章中，`Blockchain`、`Block` 和 `Transaction` 都实现了这个混合器。现在你知道它是如何工作的。以下是将这个混合器附加到我们领域主要类中的代码片段：
- en: '[PRE75]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Now that you understand how monads work, you’ve gained a universal vocabulary
    that allows you to easily integrate with any other code that understands it, including
    third-party code, and compose like-shaped code
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了 monads 的工作原理，你已经获得了一个通用词汇表，它允许你轻松地与其他任何理解它的代码集成，包括第三方代码，并像形状相似的代码一样进行组合。
- en: 5.5.8 Third-party integration
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.8 第三方集成
- en: If all the APIs we use spoke the same protocol, our job as developers would
    be much easier. Luckily, the universal functor and monad interfaces are well established
    and known, and are already ubiquitous in functional JavaScript libraries, but
    this is not the case for all aspects of software. In this chapter, I briefly mentioned
    Ramda and Crocks as being good functional libraries to use. You may have also
    seen, heard about, or even used Underscore.js or Lodash. These libraries are among
    the most-downloaded NPM libraries.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的所有 API 都使用相同的协议，我们的工作作为开发者将会容易得多。幸运的是，通用的 funtor 和 monad 接口已经建立并广为人知，并且在功能
    JavaScript 库中无处不在，但并非所有软件的方面都是如此。在本章中，我简要提到了 Ramda 和 Crocks 作为好的功能库。你可能也看到过、听说过，甚至使用过
    Underscore.js 或 Lodash。这些库是下载量最大的 NPM 库之一。
- en: Ramda, for example, speaks the language of functors and monads by also following
    the fantasy-land definitions. The following listing shows how `Validation` integrates
    seamlessly with Ramda.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Ramda 通过遵循 fantasy-land 定义，也使用 funtor 和 monad 的语言。以下列表显示了 `Validation` 如何无缝集成到
    Ramda 中。
- en: Listing 5.24 Integrating a custom `Validation` object with FP library Ramda
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.24 将自定义 `Validation` 对象与 FP 库 Ramda 集成
- en: '[PRE76]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: ❶ chain is an alias for flatMap. Ramda calls it chain.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ chain 是 flatMap 的别名。Ramda 称之为 chain。
- en: ❷ Ramda delegates to the functor’s flatMap, if present.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Ramda 如果存在，将委托给 funtor 的 flatMap。
- en: ❸ Shows the default value feature of Validation
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 展示了验证的默认值功能
- en: The function versions of map and `flatMap` imported from Ramda will delegate
    to the object’s `map` and `flatMap`, if present. This integration is possible
    because we’re abiding by the universal contracts that both require.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Ramda 导入的 map 和 `flatMap` 函数版本将委托给对象的 `map` 和 `flatMap`，如果存在。这种集成之所以可能，是因为我们遵守了两者都要求的通用契约。
- en: 'Under the hood, the version of `map` used here is implemented slightly differently
    from our implementation of `map` in the `Functor` mixin shown in listing 5.8:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，这里使用的 `map` 版本与我们在 5.8 列表中展示的 `Functor` 混合中实现的 `map` 版本略有不同：
- en: '[PRE77]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: General-purpose third-party libraries such as Ramda expose curried, standalone
    functions that order arguments to facilitate composition. Those functions have
    a signature like `function` `map(fn,` `F)`, where the functor `F` is the object
    being composed and chained with `compose`. We decided to use a mixin object, so
    in our case, `F` is implied and becomes `this`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 通用第三方库，如 Ramda，通过提供按顺序排列参数的柯里化、独立函数来促进组合。这些函数的签名类似于 `function map(fn, F)`，其中
    funtor `F` 是被组合和链式连接的对象。我们决定使用混合对象，因此在我们的情况下，`F` 是隐含的，变成了 `this`。
- en: Alternatively, we could use JavaScript’s dynamic context binding capabilities
    to create our own extracted forms so that we can arrive at a similar experience
    as with a standalone implementation.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 JavaScript 的动态上下文绑定能力来创建我们自己的提取形式，以便我们可以达到与独立实现相似的经验。
- en: 5.6 Higher-kinded composition with method extraction and dynamic binding
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 使用方法提取和动态绑定进行高阶组合
- en: So far, we’ve made our objects functors and monads by assigning them the proper
    mixins. This isn’t the only way to use the Functor pattern. In this section, you’ll
    learn how you can extract a `map` method as a function that you can apply to any
    type of functor using dynamic binding.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过分配适当的混合将我们的对象变成了 funtor 和 monad。这不是使用 Functor 模式唯一的方法。在本节中，你将学习如何提取一个
    `map` 方法作为一个函数，你可以使用动态绑定将其应用于任何类型的 funtor。
- en: 'You’re already aware that JavaScript makes it simple to change the environment
    or context that a function is bound to by using prototype methods `bind`, `call`,
    or `apply`. Given the `Functor` mixin, we can extract the `map` method with a
    simple destructuring assignment:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道，JavaScript 通过使用原型方法 `bind`、`call` 或 `apply` 可以轻松地更改函数绑定到的环境或上下文。给定 `Functor`
    混合，我们可以通过简单的解构赋值来提取 `map` 方法：
- en: '[PRE78]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Using `Function#call`, we can call it on any functor like so:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Function#call`，我们可以在任何 funtor 上调用它，如下所示：
- en: '[PRE79]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This example is close to a generalized function implementation of `map` like
    the one that ships with Ramda, except with reversed arguments. Calling methods
    this way can be a bit verbose, especially if you want to compose them together.
    Suppose that you want to combine `Success.of(2)` with a function that squares
    its value. Let’s follow this simple example:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子接近于 Ramda 随附的通用 `map` 函数实现，只是参数顺序相反。以这种方式调用方法可能会有些冗长，尤其是如果你想将它们组合在一起。假设你想将
    `Success.of(2)` 与一个平方其值的函数组合起来。让我们跟随这个简单的例子：
- en: '[PRE80]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This style of writing code won’t scale, because as our logic gets more complicated,
    the code gets harder to parse. Let’s try to smooth it with a simple abstraction:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编写代码的风格无法扩展，因为随着我们的逻辑变得更加复杂，代码解析起来也更困难。让我们尝试通过一个简单的抽象来使其平滑：
- en: '[PRE81]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This higher-order function both solves the argument order and uses currying
    to make composition better, which matches closely what you’d get from an external
    library:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这个高阶函数既解决了参数顺序问题，又使用柯里化使组合更好，这与从外部库中获得的结果非常接近：
- en: '[PRE82]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now we can `compose` functors without needing `composeM`:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在不需要 `composeM` 的情况下 `compose` 函子：
- en: '[PRE83]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: NOTE With regard to `apply`, another extension to monads, known as applicative
    monads, builds on functors to provide an interface to apply a function directly
    to a container, similar to what we did here. The method name usually is `ap` or
    `apply`. Applicatives are beyond the scope of this book, but you can learn more
    about them at [http://mng.bz/OE9o](http://mng.bz/OE9o).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：关于 `apply`，单调的另一个扩展，称为应用单调，建立在函子之上，提供了一种将函数直接应用于容器的接口，类似于我们在这里所做的那样。方法名通常是
    `ap` 或 `apply`。应用单调超出了本书的范围，但你可以在 [http://mng.bz/OE9o](http://mng.bz/OE9o) 上了解更多关于它们的信息。
- en: These improvements are good ones, but it would be nice to be able to process
    ADTs fluently directly with our extracted map function without needing anything
    extra. A solution to this problem is in the works, and in the spirit of having
    fun with JavaScript, I will introduce you to the newly proposed bind operator
    ([https://gitub.com/tc39/ proposal-bind-operator](https://gitub.com/tc39/proposal-bind-operator)).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这些改进是好的，但能够直接使用我们提取的映射函数流畅地处理 ADT 会更好，而不需要任何额外的东西。这个问题的解决方案正在开发中，本着在 JavaScript
    中找乐子的精神，我将向你介绍新提出的绑定运算符 ([https://gitub.com/tc39/ proposal-bind-operator](https://gitub.com/tc39/proposal-bind-operator))。
- en: 'This proposal introduces the `::` native operator, which performs a `this`
    binding (as the `Function#{bind,call,apply}` API would) in combination with method
    extraction. It comes in two flavors: binary and unary.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这个提议引入了 `::` 原生运算符，它结合方法提取执行 `this` 绑定（就像 `Function#{bind,call,apply}` API 一样）。它有两种形式：二进制和单目。
- en: 'In binary form (`obj` `::` `method`), the bound object is specified before
    the method:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制形式（`obj` `::` `method`）中，绑定对象在方法之前指定：
- en: '[PRE84]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Much as we do with the pipeline operator, we can now easily call a sequence
    of functor/ monadic transformations on an ADT:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对管道运算符所做的那样，我们现在可以轻松地对 ADT 上的一个序列的函子/单调变换进行调用：
- en: '[PRE85]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Here’s a refactored version of the Ramda code snippet from section 5.5.8 that
    removes the dependency on this library:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第5.5.8节中 Ramda 代码片段的重构版本，它消除了对这个库的依赖：
- en: '[PRE86]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: You may also find the bind operator in unary form (`::obj.method`). Suppose
    that you want to pass a properly bound `console.log` method as a callback function.
    You could use `::console.log`, as in
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可能在单目形式（`::obj.method`）中找到绑定运算符。假设你想要传递一个正确绑定的 `console.log` 方法作为回调函数，你可以使用
    `::console.log`，如下所示：
- en: '[PRE87]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'or as bound to method:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 或者作为绑定方法：
- en: '[PRE88]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Here’s another example:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子：
- en: '[PRE89]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '`SafeIncrementor` is used to safely add to an integer without risking overflow
    or misrepresentation. If you wanted to run this operation over an array of numbers,
    you would have to set the proper bind context so that the incrementor remembers
    what `this.by` refers to using `Function#bind`:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`SafeIncrementor` 用于安全地向整数添加，而不会导致溢出或错误表示。如果你想在数字数组上运行此操作，你必须设置正确的绑定上下文，以便增量器记住
    `this.by` 指的是什么，使用 `Function#bind`：'
- en: '[PRE90]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: With the bind operator in unary form, this code reduces to
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单目形式的绑定运算符，此代码简化为：
- en: '[PRE91]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Both options work in much the same way. The bind operator creates a bound function
    to the object on the left or the right side of the operator. See appendix A for
    details on enabling this feature with Babel.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种选项的工作方式几乎相同。绑定运算符创建了一个绑定到运算符左侧或右侧对象的绑定函数。有关使用 Babel 启用此功能的详细信息，请参阅附录A。
- en: In this chapter, we explored the functor and monad patterns by writing our own
    ADT. `Validation` is not the only ADT; many others exist. In fact, Haskell programs
    execute completely wrapped in the context of an I/O monad so that you can do simple
    things such as write to standard out in a side-effect-free way. ADTs are simple
    yet powerful tools. They allow you to represent everyday common tasks in a composable
    manner. After reading this chapter, you know to never use your data naked. When
    you want to apply functions in a more robust way, try wrapping them inside a container.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过编写自己的ADT（抽象数据类型）来探索了functor和monad模式。`Validation`不是唯一的ADT；还有许多其他ADT。实际上，Haskell程序完全在I/O单子上下文中执行，这样您就可以以无副作用的简单方式写入标准输出。ADT是简单而强大的工具。它们允许您以可组合的方式表示日常常见任务。阅读本章后，您将知道永远不要裸用您的数据。当您想要以更稳健的方式应用函数时，尝试将它们包裹在容器内。
- en: In this chapter, we implemented `Validation` from scratch, but many ADTs are
    widely used in practice. They are becoming so widespread that you can find them
    all as userland libraries and frameworks. Some have even evolved into new additions
    to a language. JavaScript will meet both of these cases with `Promise` (first
    a library, now a native API) and then `Observable` (chapter 9). Although `Promise`s
    do not abide by the same universal interface, they behave like one, as you’ll
    learn in chapter 8.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从零开始实现了`Validation`，但许多ADT在实际应用中广泛使用。它们变得如此普遍，以至于您可以在用户库和框架中找到它们。其中一些甚至演变成了语言的新增功能。JavaScript将通过`Promise`（最初是一个库，现在是原生API）然后是`Observable`（第9章）来满足这两种情况。尽管`Promise`s不遵循相同的通用接口，但它们的行为就像一个接口，您将在第8章中了解到。
- en: By understanding the basic concepts of ADTs, you have a stronger grasp of how
    these APIs work. Composable software doesn’t involve code alone; it also involves
    the platform. JavaScript’s revamped module system is the Holy Grail of composition
    and the subject of chapter 6.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解ADT的基本概念，您对这些API的工作原理有了更牢固的掌握。可组合的软件不仅涉及代码，还涉及平台。JavaScript的模块系统重修是组合的圣杯，也是第6章的主题。
- en: Summary
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Wrapping bare data inside a mappable container provides good encapsulation and
    immutability.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将裸数据包裹在可映射的容器内提供了良好的封装和不可变性。
- en: JavaScript provides an object-like façade for its primitive data types that
    preserves their immutability.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript为其原始数据类型提供了一个类似对象的门面，以保持它们的不可变性。
- en: '`Array#{flat,` `flatMap}` are two new APIs that allow you to work with multidimensional
    arrays in a fluent, composable manner.'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array#{flat,` `flatMap}`是两个新的API，允许您以流畅、可组合的方式处理多维数组。'
- en: '`map` and `compose` have a deep semantic equivalence.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`和`compose`具有深层的语义等价性。'
- en: An ADT can be classified by how many values it can support (record or choice)
    and by the level of composability (functor or monad).
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ADT可以根据它可以支持多少值（记录或选择）以及可组合性水平（函子或单子）来分类。
- en: Functors are objects that implement the `map` interface. Monads are objects
    that implement the `flatMap` interface. Both support a set of mathematically inspired
    protocols that must be followed.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函子是实现`map`接口的对象。单子是实现`flatMap`接口的对象。两者都支持一组必须遵循的数学灵感协议。
- en: Validation is a composite choice ADT modeling `Success` and `Failure` conditions.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Validation是一个复合选择ADT，用于建模`Success`和`Failure`条件。
- en: Whereas `compose` is used for regular function composition, `composeM` is used
    for monadic, higher-kinded composition.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而`compose`用于常规函数组合，`composeM`用于单子、高阶组合。
- en: By implementing the universal protocols of Functor and Monad, you can integrate
    your code easily and seamlessly with third-party FP libraries.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现Functor和Monad的通用协议，您可以轻松且无缝地将代码与第三方FP库集成。
- en: Use the newly proposed pipeline operator to run sequences of monadic transformations
    in a fluent manner.
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新提出的管道操作符以流畅的方式运行一系列单子变换。
