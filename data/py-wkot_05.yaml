- en: 5 Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 文件
- en: Files are an indispensable part of the world of computers, and thus of programming.
    We read data from files, and write to files. Even when something isn’t really
    a file--such as a network connection--we try to use an interface similar to files
    because they’re so familiar.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 文件是计算机世界和编程不可或缺的一部分。我们从文件中读取数据，并将数据写入文件。即使某些东西实际上不是文件——例如网络连接——我们也试图使用与文件类似的接口，因为它们非常熟悉。
- en: To normal, everyday users, there are different types of files--Word, Excel,
    PowerPoint, and PDF, among others. To programmers, things are both simpler and
    more complicated. They’re simpler in that we see files as data structures to which
    we can write strings, and from which we can read strings. But files are also more
    complicated, in that when we read the string into memory, we might need to parse
    it into a data structure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通用户来说，有不同类型的文件——Word、Excel、PowerPoint 和 PDF 等。对于程序员来说，事情既简单又复杂。它们简单，因为我们把文件看作是我们可以写入字符串并从中读取字符串的数据结构。但文件也更复杂，因为当我们把字符串读入内存时，我们可能需要将其解析成数据结构。
- en: Working with files is one of the easiest and most straightforward things you
    can do in Python. It’s also one of the most common things that we need to do,
    since programs that don’t interact with the filesystem are rather boring.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中处理文件是最简单、最直接的事情之一。它也是我们最常需要做的事情之一，因为不与文件系统交互的程序相当无聊。
- en: In this chapter, we’ll practice working with files--reading from them, writing
    to them, and manipulating the data that they contain. Along the way, you’ll get
    used to some of the paradigms that are commonly used when working with Python
    files, such as iterating over a file’s contents and writing to files in a `with`
    block.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将练习处理文件——从它们中读取，向它们写入，以及操作它们包含的数据。在这个过程中，你会习惯于在处理 Python 文件时常用的某些范例，例如遍历文件内容以及在
    `with` 块中写入文件。
- en: In some cases, we’ll work with data formatted as CSV (comma-separated values)
    or JSON (JavaScript object notation), two common formats that modules in Python’s
    standard library handle. If you’ve forgotten the basics of CSV or JSON, I have
    some short reminders in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们将处理以 CSV（逗号分隔值）或 JSON（JavaScript 对象表示法）格式化的数据，这两种格式是 Python 标准库中模块常用的格式。如果你已经忘记了
    CSV 或 JSON 的基础知识，我在本章中提供了一些简短的提醒。
- en: After this chapter, you’ll not only be more comfortable working with files,
    you’ll also better understand how you can translate from in-memory data structures
    (e.g., lists and dicts) to on-disk data formats (e.g., CSV and JSON) and back.
    In this way, files make it possible for you to keep data structures intact--even
    when the program isn’t running or when the computer is shut down--or even to transfer
    such data structures to other computers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，你不仅会更容易地处理文件，而且还会更好地理解如何将内存中的数据结构（例如列表和字典）转换为磁盘上的数据格式（例如 CSV 和 JSON），然后再转换回来。这样，文件使你能够保持数据结构完整——即使程序没有运行或计算机已关闭——甚至可以将此类数据结构传输到其他计算机。
- en: Table 5.1 What you need to know
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1 你需要知道的内容
- en: '| Concept | What is it? | Example | To learn more |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 概念 | 它是什么？ | 示例 | 了解更多 |'
- en: '| Files | Overview of working with files in Python | `f = open(''/etc/passwd'')`
    | [http://mng.bz/D22R](http://mng.bz/D22R) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 文件 | Python 中处理文件的概述 | `f = open(''/etc/passwd'')` | [http://mng.bz/D22R](http://mng.bz/D22R)
    |'
- en: '| `with` | Puts an object in a *context manager* ; in the case of a file, ensures
    it’s flushed and closed by the end of the block | `with open (''file.text'') as
    f:` | [http://mng.bz/6QJy](http://mng.bz/6QJy) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `with` | 将对象放入一个 *上下文管理器*；在文件的情况下，确保在代码块结束时刷新并关闭 | `with open (''file.text'')
    as f:` | [http://mng.bz/6QJy](http://mng.bz/6QJy) |'
- en: '| Context manager | Makes your own objects work in `with` statements | `with
    MyObject() as m:` | [http://mng.bz/B221](http://mng.bz/B221) |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 上下文管理器 | 使你自己的对象在 `with` 语句中工作 | `with MyObject() as m:` | [http://mng.bz/B221](http://mng.bz/B221)
    |'
- en: '| `set.update` | Adds elements to a set | `s.update([10, 20, 30])` | [http://mng.bz/MdOn](http://mng.bz/MdOn)
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `set.update` | 向集合中添加元素 | `s.update([10, 20, 30])` | [http://mng.bz/MdOn](http://mng.bz/MdOn)
    |'
- en: '| `os.stat` | Retrieves information (size, permissions, type) about a file
    | `os.stat(''file.txt'')` | [http://mng.bz/dyyo](http://mng.bz/dyyo) |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `os.stat` | 获取有关文件的信息（大小、权限、类型） | `os.stat(''file.txt'')` | [http://mng.bz/dyyo](http://mng.bz/dyyo)
    |'
- en: '| `os.listdir` | Returns a list of files in a directory | `os.listdir(''/etc/'')`
    | [http://mng.bz/YreB](http://mng.bz/YreB) |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `os.listdir` | 返回目录中的文件列表 | `os.listdir(''/etc/'')` | [http://mng.bz/YreB](http://mng.bz/YreB)
    |'
- en: '| `glob.glob` | Returns a list of files matching a pattern | `glob.glob(''/etc/*.conf'')`
    | [http://mng.bz/044N](http://mng.bz/044N) |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `glob.glob` | 返回匹配模式的文件列表 | `glob.glob(''/etc/*.conf'')` | [http://mng.bz/044N](http://mng.bz/044N)
    |'
- en: '| Dict comprehension | Creates a dict based on an iterator | `{word : len(word)``for
    word in ''ab cde''.split()}` | [http://mng.bz/Vggy](http://mng.bz/Vggy) |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 字典推导式 | 基于迭代器创建字典 | `{word : len(word)``for word in ''ab cde''.split()}`
    | [http://mng.bz/Vggy](http://mng.bz/Vggy) |'
- en: '| `str.split` | Breaks strings apart, returning a list | `# Returns [''ab'',
    ''cd'', ''ef'']``''ab cd ef''.split()` | [http://mng.bz/aR4z](http://mng.bz/aR4z)
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `str.split` | 将字符串分割，返回一个列表 | `# 返回 [''ab'', ''cd'', ''ef'']``''ab cd ef''.split()`
    | [http://mng.bz/aR4z](http://mng.bz/aR4z) |'
- en: '| `hashlib` | Module with cryptographic functions | `import hashlib` | [http://mng.bz/NK2x](http://mng.bz/NK2x)
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `hashlib` | 包含加密函数的模块 | `import hashlib` | [http://mng.bz/NK2x](http://mng.bz/NK2x)
    |'
- en: '| `csv` | Module for working with CSV files | `x = csv.reader(f)` | [http://mng.bz/xWWd](http://mng.bz/xWWd)
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `csv` | 处理CSV文件的模块 | `x = csv.reader(f)` | [http://mng.bz/xWWd](http://mng.bz/xWWd)
    |'
- en: '| `json` | Module for working with JSON | `json.loads(json_string)` | [http://mng.bz/AAAo](http://mng.bz/AAAo)
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `json` | 处理JSON的模块 | `json.loads(json_string)` | [http://mng.bz/AAAo](http://mng.bz/AAAo)
    |'
- en: Exercise 18 ■ Final line
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习18 ■ 最后一行
- en: It’s very common for new Python programmers to learn how they can iterate over
    the lines of a file, printing one line at a time. But what if I’m not interested
    in each line, or even in most of the lines? What if I’m only interested in a single
    line--the final line of the file?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新学习的Python程序员来说，了解他们如何遍历文件的行，一次打印一行，是非常常见的。但如果我们对每一行，甚至大多数行都不感兴趣呢？如果我们只对单行——文件的最后一行——感兴趣呢？
- en: Now, retrieving the final line of a file might not seem like a super useful
    action. But consider the Unix `head` and `tail` utilities, which show the first
    and last lines of a file, respectively--and which I use all the time to examine
    files, particularly log files and configuration files. Moreover, knowing how to
    read specific parts of a file, as opposed to the entire thing, is a useful and
    practical skill to have.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检索文件的最后一行可能看起来不是一个特别有用的操作。但考虑Unix的 `head` 和 `tail` 工具，它们分别显示文件的第一个和最后一行——我经常使用这些工具来检查文件，尤其是日志文件和配置文件。此外，知道如何读取文件的具体部分，而不是整个文件，是一项有用且实用的技能。
- en: In this exercise, write a function (`get_final_line`) that takes a filename
    as an argument. The function should return that file’s final line on the screen.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，编写一个函数 (`get_final_line`)，它接受一个文件名作为参数。该函数应返回屏幕上该文件的最后一行。
- en: Working it out
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理
- en: The solution code uses a number of common Python idioms that I’ll explain here.
    And along the way, you’ll see how using these idioms leads not just to more readable
    code, but also to more efficient execution.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案代码使用了多个常见的Python惯用用法，我将在下面解释。在这个过程中，你会看到使用这些惯用用法不仅使代码更易读，而且还能提高执行效率。
- en: Depending on which arguments you use when calling it, the built-in `open` function
    can return a number of different objects, such as `TextIOWrapper` or `BufferedReader`.
    These objects all implement the same API for working with files and are thus described
    in the Python world as “file-like objects.” Using such an object allows us to
    paper over the many different types of filesystems out there and just think in
    terms of “a file.” Such an object also allows us to take advantage of whatever
    optimizations, such as buffering, the operating system might be using.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根据调用时使用的参数不同，内置的 `open` 函数可以返回多种不同的对象，例如 `TextIOWrapper` 或 `BufferedReader`。这些对象都实现了相同的文件操作API，因此在Python世界中被称为“文件对象”。使用这样的对象允许我们掩盖许多不同的文件系统类型，只需考虑“一个文件”。这样的对象还允许我们利用操作系统可能使用的任何优化，例如缓冲。
- en: 'Here’s how `open` is usually invoked:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是通常调用 `open` 的方式：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this case, `filename` is a string representing a valid file name. When we
    invoke `open` with just one argument, it should be a filename. The second, optional,
    argument is a string that can include multiple characters, indicating whether
    we want to read from, write to, or append to the file (using `r`, `w`, or `a`),
    and whether the file should be read by character (the default) or by bytes (the
    `b` option, in which case we’ll use `rb`, `wb`, or `ab`). (See the sidebar about
    the `b` option and reading the file in byte, or binary, mode.) I could thus more
    fully write the previous line of code as
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`filename`是一个表示有效文件名的字符串。当我们只传递一个参数给`open`时，它应该是一个文件名。第二个可选参数是一个字符串，可以包含多个字符，表示我们想要从文件中读取、写入还是追加（使用`r`、`w`或`a`），以及文件应该按字符（默认）还是按字节（使用`b`选项，在这种情况下我们将使用`rb`、`wb`或`ab`）读取。（有关`b`选项和按字节或二进制模式读取文件的侧边栏信息。）因此，我可以更完整地写出上一行代码如下：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Because we read from files more often than we write to them, `r` is the default
    value for the second argument. It’s quite usual for Python programs not to specify
    `r` if reading from a file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们比写入文件更频繁地读取文件，`r`是第二个参数的默认值。在Python程序中，如果从文件中读取，通常不指定`r`。
- en: 'As you can see here, we’ve put the resulting object into the variable `f`.
    And because file-like objects are all iterable, returning one line per iteration,
    it’s typical to then say this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已经将结果对象放入了变量`f`中。由于文件对象都是可迭代的，每次迭代返回一行，因此通常会说：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But if you’re just planning to iterate over `f` once, then why create it as
    a variable at all? We can avoid the variable definition and simply iterate over
    the file object that `open` returned:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你只是计划对`f`进行一次迭代，那么为什么还要把它作为一个变量创建出来呢？我们可以避免变量定义，直接迭代`open`返回的文件对象：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With each iteration over a file-like object, we get the next line from the file,
    up to and including the `\n` newline character. Thus, in this code, `line` is
    always going to be a string that always contains a single `\n` character at the
    end of it. A blank line in a file will contain just the `\n` newline character.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代文件对象时，我们都会从文件中获取下一行，直到包括`\n`换行符。因此，在这个代码中，`line`始终是一个字符串，其末尾总是包含一个`\n`字符。文件中的空白行将只包含`\n`换行符。
- en: In theory, files should end with an `\n`, such that you’ll never finish the
    file in the middle of a line. In practice, I’ve seen many files that don’t end
    with an `\n`. Keep this in mind whenever you’re printing out a file; assuming
    that a file will always end with a newline character can cause trouble.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，文件应该以`\n`结尾，这样你永远不会在行中间结束文件。实际上，我见过许多不以`\n`结尾的文件。在打印文件时，请记住这一点；假设文件总是以换行符结尾可能会导致问题。
- en: What about closing the file? This code will work, printing the length of each
    line in a file. However, this sort of code is frowned upon in the Python world
    because it doesn’t explicitly close the file. Now, when it comes to reading from
    files, it’s not *that* big of a deal, especially if you’re only opening a small
    number of them at a time. But if you’re writing to files, or if you’re opening
    many files at once, you’ll want to close them--both to conserve resources and
    to ensure that the file has been closed for good.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 那么关于关闭文件呢？这段代码将正常工作，打印出文件中每行的长度。然而，在Python世界中，这种代码是不被推荐的，因为它没有明确关闭文件。现在，当涉及到从文件中读取时，这并不是什么大问题，尤其是如果你一次只打开少量文件。但是，如果你正在写入文件，或者一次打开许多文件，你将想要关闭它们——既为了节省资源，也为了确保文件已经被永久关闭。
- en: 'The way to do that is with the `with` construct. I could rewrite the previous
    code as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，可以使用`with`构造。我可以将之前的代码重写如下：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Instead of opening the file and assigning the file object to `f` directly, we’ve
    opened it within the context of `with`, assigned it to `f` as part of the `with`
    statement, and then opened a block.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是直接打开文件并将文件对象分配给`f`，而是在`with`的上下文中打开它，将`f`作为`with`语句的一部分进行分配，然后打开一个代码块。
- en: There’s more detail about this in the sidebar about `with` and “context managers,”
    but you should know that this is the standard Pythonic way to open a file--in
    no small part because it guarantees that the file has been closed by the end of
    the block.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`with`和“上下文管理器”的更多细节可以在关于`with`的侧边栏中找到，但你应该知道这是标准的Python打开文件方式——这在很大程度上是因为它保证了文件在代码块结束时已经被关闭。
- en: Binary mode using `b`
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`b`的二进制模式
- en: What happens if you open a nontext file, such as a PDF or a JPEG, with `open`
    and then try to iterate over it, one line at a time?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用 `open` 打开一个非文本文件，比如 PDF 或 JPEG，然后逐行迭代它会发生什么？
- en: First, you’ll likely get an error right away. That’s because Python expects
    the contents of a file to be valid UTF-8 formatted Unicode strings. Binary files,
    by definition, don’t use Unicode. When Python tries to read a non-Unicode string,
    it’ll raise an exception, complaining that it can’t define a string with such
    content.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可能会立即得到一个错误。这是因为 Python 期望文件的内容是有效的 UTF-8 格式的 Unicode 字符串。根据定义，二进制文件不使用
    Unicode。当 Python 尝试读取非 Unicode 字符串时，它会引发异常，抱怨它无法定义包含此类内容的字符串。
- en: To avoid that problem, you can and should open the file in *binary* or *bytes*
    mode, adding a `b` to `r`, `w`, or `a` in the second argument to `open`; for example
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，你可以也应该以 *二进制* 或 *字节* 模式打开文件，在 `open` 函数的第二个参数中添加一个 `b` 到 `r`、`w` 或
    `a`；例如
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Opens the file in “r” (read) and “b” (binary) mode
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 以“r”（读取）和“b”（二进制）模式打开文件
- en: ❷ The type of current_line here is bytes, similar to a string but without Unicode
    characters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这里 `current_line` 的类型是字节，类似于字符串但没有 Unicode 字符。
- en: Now you won’t be constrained by a lack of Unicode characters.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你不会因为缺少 Unicode 字符而受限制。
- en: But wait. Remember that with each iteration, Python will return everything up
    to and including the next `\n` character. In a binary file, such a character won’t
    appear at the end of every line, because there are no lines to speak of. Without
    such a character, what you get back from each iteration will probably be nonsense.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等。记住，在每次迭代中，Python 将返回直到并包括下一个 `\n` 字符的所有内容。在二进制文件中，这样的字符不会出现在每一行的末尾，因为没有所谓的行。没有这样的字符，每次迭代返回的内容可能都是无意义的。
- en: The bottom line is that if you’re reading from a binary file, you shouldn’t
    forget to use the `b` flag. But when you do that, you’ll find that you don’t want
    to read the file per line anyway. Instead, you should be using the `read` method
    to retrieve a fixed number of bytes. When `read` returns 0 bytes, you’ll know
    that you’re at the end of the file; for example
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，如果你正在读取二进制文件，你不应该忘记使用 `b` 标志。但是当你这样做的时候，你会发现你根本不想按行读取文件。相反，你应该使用 `read`
    方法来检索固定数量的字节。当 `read` 返回 0 字节时，你就知道你到达了文件的末尾；例如
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Uses “with”, in a “context manager,” to open the file
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用“with”，在“上下文管理器”中打开文件
- en: ❷ Reads up to 1,000 bytes and returns them as a bytes object
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 读取最多 1,000 字节并返回一个字节对象
- en: 'In this particular exercise, you were asked to print the final line of a file.
    One way to do so might look like the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的练习中，你被要求打印文件的最后一行。这样做的一种方法可能如下所示：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This trick works because we iterate over the lines of the file and assign `current_line`
    in each iteration--but we don’t actually do anything in the body of the `for`
    loop. Rather, we use `pass`, which is a way of telling Python to do nothing. (Python
    requires that we have at least one line in an indented block, such as the body
    of a `for` loop.) The reason that we execute this loop is for its side effect--namely,
    the fact that the final value assigned to `current_line` remains in place after
    the loop exits.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧之所以有效，是因为我们遍历文件的每一行，并在每次迭代中分配 `current_line`--但我们实际上并没有在 `for` 循环体中做任何事情。相反，我们使用
    `pass`，这是告诉 Python 不做任何事情的一种方式。（Python 要求我们在缩进块中至少有一行，例如 `for` 循环体。）我们执行这个循环的原因是为了它的副作用--即，`current_line`
    分配的最终值在循环退出后仍然保留。
- en: However, looping over the rows of a file just to get the final one strikes me
    as a bit strange, even if it works. My preferred solution, shown in figure 5.1,
    is to iterate over each line of the file, getting the current line but immediately
    assigning it to `final_line`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仅仅为了获取最后一行而遍历文件行，在我看来有点奇怪，即使它有效。我首选的解决方案，如图 5.1 所示，是遍历文件的每一行，获取当前行，但立即将其分配给
    `final_line`。
- en: '![](../Images/5-1.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5-1.png)'
- en: Figure 5.1 Immediately before printing the final line
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 在打印最后一行之前
- en: When we exit from the loop, `final_line` will contain whatever was in the most
    recent line. We can thus print it out afterwards.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们退出循环时，`final_line` 将包含最新一行中的内容。因此，我们可以在之后打印它。
- en: 'Normally, `print` adds a newline after printing something to the screen. However,
    when we iterate over a file, each line already ends with a newline character.
    This can lead to doubled whitespace between printed output. The solution is to
    stop `print` from displaying anything by overriding the default `\n` value in
    the `end` parameter. By passing `end=''''`, we tell `print` to add `''''`, the
    empty string, after printing `final_line`. For further information about the arguments
    you can pass to `print`, take a look here: [http://mng.bz/RAAZ](http://mng.bz/RAAZ).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`print`在屏幕上打印某些内容后添加一个换行符。但是，当我们遍历一个文件时，每一行已经以换行符结束。这可能导致打印输出之间出现双倍空格。解决方案是停止`print`显示任何内容，通过覆盖`end`参数中的默认`\n`值。通过传递`end=''`，我们告诉`print`在打印`final_line`后添加空字符串`''`。有关您可以传递给`print`的参数的更多信息，请查看这里：[http://mng.bz/RAAZ](http://mng.bz/RAAZ)。
- en: Solution
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Iterates over each line of the file. You don’t need to declare a variable;
    just iterate directly over the result of open.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 遍历文件的每一行。您不需要声明变量；只需直接遍历`open`的结果即可。
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    D24g](http://mng.bz/D24g).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Python Tutor中尝试此代码的版本：[http://mng.bz/D24g](http://mng.bz/D24g)。
- en: Simulating files in Python Tutor
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python Tutor中模拟文件
- en: Philip Guo’s Python Tutor site ([http://mng.bz/2XJX](http://mng.bz/2XJX)), which
    I use for diagrams and also to allow you to experiment with the book’s solutions,
    doesn’t support files. This is understandable--a free server system that lets
    people run arbitrary code is hard enough to create and support. Allowing people
    to work with arbitrary files would add plenty of logistical and security problems.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用的菲利普·郭的Python Tutor网站([http://mng.bz/2XJX](http://mng.bz/2XJX))，用于绘制图表，并允许您尝试书中的解决方案，不支持文件。这是可以理解的——创建并支持一个允许人们运行任意代码的免费服务器系统已经很难了。允许人们处理任意文件将增加大量的后勤和安全问题。
- en: 'However, there is a solution: `StringIO` ([http://mng.bz/PAOP](http://mng.bz/PAOP)).
    `StringIO` objects are what Python calls “file-like objects.” They implement the
    same API as `file` objects, allowing us to read from them and write to them just
    like files. Unlike files, though, `StringIO` objects never actually touch the
    filesystem.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个解决方案：`StringIO` ([http://mng.bz/PAOP](http://mng.bz/PAOP))。`StringIO`对象是Python所说的“文件-like对象”。它们实现了与`file`对象相同的API，使我们能够像文件一样从它们中读取和写入。然而，与文件不同的是，`StringIO`对象实际上从未真正接触过文件系统。
- en: '`StringIO` wasn’t designed for use with the Python Tutor, although it’s a great
    workaround for the limitations there. More typically, I see (and use) `StringIO`
    in automated tests. After all, you don’t really want to have a test touch the
    filesystem; that would make things run much more slowly. Instead, you can use
    `StringIO` to simulate a file.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringIO`并非为与Python Tutor一起使用而设计，尽管它是解决那里限制的一个很好的权宜之计。更典型的是，我看到（并使用）`StringIO`在自动化测试中。毕竟，您真的不希望测试触及文件系统；这将使事情运行得慢得多。相反，您可以使用`StringIO`来模拟一个文件。'
- en: If you’re doing any software testing, you should take a serious look at `StringIO`,
    part of the Python standard library. You can load it with
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在进行任何软件测试，您应该认真考虑Python标准库中的`StringIO`。您可以通过以下方式加载它：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When we’re looking at files, the versions of code that you’ll see in Python
    Tutor thus will be slightly different from the ones in the book itself. However,
    they should work the same way, allowing you to explore the code visually. Unfortunately,
    exercises that involve directory listings can’t be papered over as easily, and
    thus lack any Python Tutor link.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看文件时，Python Tutor中您将看到的代码版本将与书中的版本略有不同。然而，它们应该以相同的方式工作，允许您从视觉上探索代码。不幸的是，涉及目录列表的练习不能轻易地掩盖，因此没有Python
    Tutor链接。
- en: Screencast solution
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 观看此解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: 'Iterating over files, and understanding how to work with the content as (and
    after) you iterate over them, is an important skill to have when working with
    Python. It is also important to understand how to turn the contents of a file
    into a Python data structure--something we’ll look at several more times in this
    chapter. Here are a few ideas for things you can do when iterating through files
    in this way:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 Python 时，迭代文件并理解如何在迭代过程中以及迭代之后处理内容是一项重要的技能。同样重要的是要理解如何将文件内容转换为 Python 数据结构——在本章中我们将多次探讨这一点。以下是在以这种方式迭代文件时可以做的事情的一些想法：
- en: Iterate over the lines of a text file. Find all of the words (i.e., non-whitespace
    surrounded by whitespace) that contain only integers, and sum them.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代文本文件的行。找出所有只包含整数（即由空白字符包围的非空白字符）的单词，并将它们相加。
- en: Create a text file (using an editor, not necessarily Python) containing two
    tab-separated columns, with each column containing a number. Then use Python to
    read through the file you’ve created. For each line, multiply each first number
    by the second, and then sum the results from all the lines. Ignore any line that
    doesn’t contain two numeric columns.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含两列的文本文件（使用编辑器，不一定是 Python），每列包含一个数字。然后使用 Python 读取你创建的文件。对于每一行，将每行的第一个数字乘以第二个数字，然后对所有行的结果进行求和。忽略任何不包含两个数字列的行。
- en: Read through a text file, line by line. Use a dict to keep track of how many
    times each vowel (a, e, i, o, and u) appears in the file. Print the resulting
    tabulation.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐行读取一个文本文件。使用字典来跟踪文件中每个元音字母（a, e, i, o 和 u）出现的次数。打印出结果表格。
- en: Exercise 19 ■ /etc/passwd to dict
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 19 ■ 将 /etc/passwd 转换为字典
- en: It’s both common and useful to think of files as sequences of strings. After
    all, when you iterate over a file object, you get each of the file’s lines as
    a string, one at a time. But it often makes more sense to turn a file into a more
    complex data structure, such as a dict.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件视为字符串序列是既常见又实用的想法。毕竟，当你迭代文件对象时，你会逐行得到文件中的每一行作为字符串。但将文件转换为更复杂的数据结构，如字典，通常更有意义。
- en: In this exercise, write a function, `passwd_to_dict`, that reads from a Unix-style
    “password file,” commonly stored as `/etc/passwd`, and returns a dict based on
    it. If you don’t have access to such a file, you can download one that I’ve uploaded
    at [http://mng.bz/2XXg](http://mng.bz/2XXg).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，编写一个名为 `passwd_to_dict` 的函数，该函数从 Unix 风格的“密码文件”中读取，通常存储为 `/etc/passwd`，并根据它返回一个字典。如果你没有访问此类文件的权限，你可以下载我上传的一个文件，链接为
    [http://mng.bz/2XXg](http://mng.bz/2XXg)。
- en: 'Here’s a sample of what the file looks like:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个文件样例的示例：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each line is one user record, divided into colon-separated fields. The first
    field (index 0) is the username, and the third field (index 2) is the user’s unique
    ID number. (In the system from which I took the `/etc/passwd` file, `nobody` has
    ID `-2`, `root` has ID `0`, and `daemon` has ID `1`.) For our purposes, you can
    ignore all but these two fields.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行代表一个用户记录，由冒号分隔的字段组成。第一个字段（索引 0）是用户名，第三个字段（索引 2）是用户的唯一 ID 号。在我从其中获取 `/etc/passwd`
    文件的系统中，`nobody` 的 ID 是 `-2`，`root` 的 ID 是 `0`，`daemon` 的 ID 是 `1`。为了我们的目的，你可以忽略除了这两个字段之外的所有字段。
- en: Sometimes, the file will contain lines that fail to adhere to this format. For
    example, we generally ignore lines containing nothing but whitespace. Some vendors
    (e.g., Apple) include comments in their `/etc/passwd` files, in which the line
    starts with a `#` character.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，文件将包含不符合此格式的行。例如，我们通常忽略只包含空白的行。一些供应商（例如 Apple）在他们的 `/etc/passwd` 文件中包含注释，其中行以
    `#` 字符开始。
- en: The function `passwd_to_dict` should return a dict based on `/etc/passwd` in
    which the dict’s keys are usernames and the values are the users’ IDs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `passwd_to_dict` 应该返回一个基于 `/etc/passwd` 的字典，其中字典的键是用户名，值是用户的 ID。
- en: Some help from string methods
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一些来自字符串方法的帮助
- en: The string methods `str.startswith`, `str.endswith`, and `str.strip` are helpful
    when doing this kind of analysis and manipulation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串方法 `str.startswith`、`str.endswith` 和 `str.strip` 在进行此类分析和操作时很有帮助。
- en: 'For example, `str.startswith` returns `True` or `False`, depending on whether
    the string starts with a string:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`str.startswith` 根据字符串是否以字符串开头返回 `True` 或 `False`：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Similarly, `str.endswith` tells us whether a string ends with a particular
    string:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`str.endswith` 告诉我们字符串是否以特定的字符串结尾：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`str.strip` removes the whitespace--the space character, as well as `\n`, `\r`,
    `\t`, and even `\v`--on either side of the string. The `str.lstrip` and `str.rstrip`
    methods only remove whitespace on the left and right, respectively. All of these
    methods return strings:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.strip` 会移除字符串两端的空白字符——包括空格字符、`\n`、`\r`、`\t`，甚至 `\v`。`str.lstrip` 和 `str.rstrip`
    方法分别只移除字符串左端和右端的空白字符。所有这些方法都返回字符串：'
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Working it out
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: Once again, we’re opening a text file and iterating over its lines, one at a
    time. Here, we assume that we know the file’s format, and that we can extract
    fields from within each record.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们正在打开一个文本文件并逐行迭代。这里我们假设我们知道文件的格式，并且可以从每个记录中提取字段。
- en: In this case, we’re splitting each line across the `:` character, using the
    `str.split` method. `str.split` always returns a list of strings, although the
    length of that list depends on the number of times that `:` occurs in the string.
    In the case of `/etc/passwd`, we will assume that any line containing `:` is a
    legitimate user record and thus has all of the necessary fields.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `str.split` 方法根据 `:` 字符分割每一行。`str.split` 总是返回一个字符串列表，尽管该列表的长度取决于字符串中
    `:` 出现的次数。在 `/etc/passwd` 的例子中，我们将假设任何包含 `:` 的行都是合法的用户记录，因此具有所有必要的字段。
- en: However, the file might contain comment lines beginning with `#`. If we were
    to invoke `str.split` ([http://mng.bz/aR4z](http://mng.bz/aR4z)) on those lines,
    we’d get back a list, but one containing only a single element--leading to an
    `IndexError` exception if we tried to retrieve `user_info[2]`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，文件可能包含以 `#` 开头的注释行。如果我们对那些行调用 `str.split` ([http://mng.bz/aR4z](http://mng.bz/aR4z))，我们会得到一个列表，但列表中只有一个元素——如果我们尝试检索
    `user_info[2]`，会导致 `IndexError` 异常。
- en: 'It’s thus important that we ignore those lines that begin with `#`. Fortunately,
    we can use a `str.startswith` ([http://mng.bz/PAAw](http://mng.bz/PAAw)) method.
    Specifically, I identify and discard comment and blank lines using this code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，忽略以 `#` 开头的行是很重要的。幸运的是，我们可以使用 `str.startswith` ([http://mng.bz/PAAw](http://mng.bz/PAAw))
    方法。具体来说，我使用以下代码识别并丢弃注释和空白行：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The invocation of `str.startswith` passes it a tuple of two strings. `str.startswith`
    will return `True` if either of the strings in that tuple are found at the start
    of the line. Because every line contains a newline, including blank lines, we
    could say that a line that starts with `\n` is a blank line.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.startswith` 的调用传递给它一个包含两个字符串的元组。如果元组中的任一字符串在行的开头被发现，`str.startswith` 将返回
    `True`。因为每一行都包含换行符，包括空白行，所以我们可以认为以 `\n` 开头的行是空白行。'
- en: Assuming that it has found a user record, our program then adds a new key-value
    pair to `users`. The key is `user_info[0]`, and the value is `user_info[2]`. Notice
    how we can use `user_info[0]` as the name of a key; as long as the value of that
    variable contains a string, we may use it as a dict key.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设程序已经找到了用户记录，然后程序将一个新的键值对添加到 `users` 中。键是 `user_info[0]`，值是 `user_info[2]`。注意我们如何可以使用
    `user_info[0]` 作为键的名称；只要该变量的值包含字符串，我们就可以将其用作字典键。
- en: I use `with` ([http://mng.bz/lGG2](http://mng.bz/lGG2)) here to open the file,
    thus ensuring that it’s closed when the block ends. (See the sidebar about `with`
    and context managers.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用 `with` ([http://mng.bz/lGG2](http://mng.bz/lGG2)) 来打开文件，从而确保在代码块结束时文件被关闭。（参见关于
    `with` 和上下文管理器的侧边栏。）
- en: Solution
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Ignores comment and blank lines
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 忽略注释和空白行
- en: ❷ Turns the line into a list of strings
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将行转换为字符串列表
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/
    lGWR](http://mng.bz/lGWR).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中尝试这个代码版本：[http://mng.bz/lGWR](http://mng.bz/lGWR)。
- en: Screencast solution
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: At a certain point in your Python career, you’ll stop seeing files as sequences
    of characters on a disk, and start seeing them as raw material you can transform
    into Python data structures. Our programs have more semantic power with structured
    data (e.g., dicts) than strings. We can similarly do more and think in deeper
    ways if we read a file into a data structure rather than just into a string.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Python 生涯的某个阶段，你将不再把文件看作是磁盘上的字符序列，而是开始将其视为可以转化为 Python 数据结构的原材料。我们的程序在结构化数据（例如，字典）上比字符串具有更强的语义能力。如果我们把文件读入到一个数据结构中而不是仅仅读入到一个字符串中，我们就可以做更多的事情，并以更深入的方式思考。
- en: For example, imagine a CSV file in which each line contains the name of a country
    and its population. Reading this file as a string, it would be possible--but frustrating--to
    compare the populations of France and Thailand. But reading this file into a dict,
    it would be trivial to make such a comparison.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个CSV文件，其中每行包含一个国家的名称和其人口。以字符串的形式读取这个文件，虽然可能——但令人沮丧——可以比较法国和泰国的人口，但将这个文件读取到字典中，这样的比较就变得非常简单。
- en: 'Indeed, I’m a particular fan of reading files into dicts, in no small part
    because many file formats lend themselves to this sort of translation--but you
    can also use more complex data structures. Here are some additional exercises
    you can try to help you see that connection and make the transformation in your
    code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我特别喜爱将文件读取到字典中，这在很大程度上是因为许多文件格式都适合这种类型的转换——但你也可以使用更复杂的数据结构。以下是一些你可以尝试的额外练习，以帮助你看到这种联系并在你的代码中进行转换：
- en: Read through `/etc/passwd`, creating a dict in which user login shells (the
    final field on each line) are the keys. Each value will be a list of the users
    for whom that shell is defined as their login shell.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取 `/etc/passwd` 文件，创建一个字典，其中用户登录shell（每行的最后一个字段）是键。每个值将是一个列表，包含那些将此shell定义为登录shell的用户整数。
- en: Ask the user to enter integers, separated by spaces. From this input, create
    a dict whose keys are the factors for each number, and the values are lists containing
    those of the users’ integers that are multiples of those factors.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求用户输入整数，用空格分隔。从这个输入中，创建一个字典，其键是每个数字的因子，值是包含那些用户整数列表，这些整数是这些因子的倍数。
- en: From `/etc/passwd`, create a dict in which the keys are the usernames (as in
    the main exercise) and the values are themselves dicts with keys (and appropriate
    values) for user ID, home directory, and shell.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `/etc/passwd` 文件中，创建一个字典，其中键是用户名（如主练习中所示），值是包含用户ID、主目录和shell键（以及相应的值）的字典。
- en: '`with` and context managers'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`with` 和上下文管理器'
- en: 'As we’ve seen, it’s common to open a file as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，通常以如下方式打开文件：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Most people believe, correctly, that using `with` ensures that the file, `f`,
    will be flushed and closed at the end of the block. (You thus don’t have to explicitly
    call `f.close()` to ensure
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人正确地认为，使用 `with` 确保文件 `f` 在代码块结束时会被刷新和关闭。（因此，你不需要显式调用 `f.close()` 来确保）
- en: the contents will be flushed.) But because `with` is overwhelmingly used with
    files, many developers believe that there’s some inherent connection between `with`
    and files. The truth is that `with` is a much more general Python construct, known
    as a *context manager*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: （其内容将被刷新。）但鉴于 `with` 主要与文件一起使用，许多开发者认为 `with` 和文件之间有一些固有的联系。事实是，`with` 是一个更通用的
    Python 构造，被称为 *上下文管理器*。
- en: 'The basic idea is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思路如下：
- en: You use `with`, along with an object and a variable to which you want to assign
    the object.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 `with` 关键字，结合一个对象和一个你想将对象赋值的变量。
- en: The object should know how to behave inside of the context manager.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象应该知道如何在上下文管理器内部表现。
- en: When the block starts, `with` turns to the object. If a `__enter__` method is
    defined on the object, then it runs. In the case of files, the method is defined
    but does nothing other than return the file object itself. Whatever this method
    returns is assigned to the `as` variable at the end of the `with` line.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当代码块开始时，`with` 转向对象。如果对象上定义了 `__enter__` 方法，则它会被执行。在文件的情况下，方法被定义，但除了返回文件对象本身之外，不执行任何操作。这个方法返回的内容会被分配给
    `with` 行末的 `as` 变量。
- en: When the block ends, `with` once again turns to the object, executing its `__exit__`
    method. This method gives the object a chance to change or restore whatever state
    it was using.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当代码块结束时，`with` 再次转向对象，执行其 `__exit__` 方法。这个方法给对象一个机会去改变或恢复它所使用的任何状态。
- en: It’s pretty obvious, then, how `with` works with files. Perhaps the `__enter__`
    method isn’t important and doesn’t do much, but the `__exit__` method certainly
    is important and does a lot--specifically in flushing and closing the file. If
    you pass two or more objects to `with`, the `__enter__` and `__exit__` methods
    are invoked on each of them, in turn.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`with` 与文件一起工作的方式就很明显了。也许 `__enter__` 方法并不重要，也没有做什么，但 `__exit__` 方法确实很重要，并且做了很多——特别是在刷新和关闭文件方面。如果你向
    `with` 传递两个或更多对象，则依次在它们上调用 `__enter__` 和 `__exit__` 方法。
- en: Other objects can and do adhere to the context manager protocol. Indeed, if
    you want, you can write your own classes such that they’ll know how to behave
    inside of a `with` statement. (Details of how to do so are in the “What you need
    to know” table at the start of the chapter.)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 其他对象也可以并确实遵循上下文管理器协议。实际上，如果你想的话，你可以编写自己的类，使它们知道如何在`with`语句内部表现。有关如何做到这一点的详细信息，请参阅章节开头的“你需要知道的内容”表格。
- en: Are context managers only used in the case of files? No, but that’s the most
    common case by far. Two other common cases are (1) when processing database transactions
    and (2) when locking certain sections in multi-threaded code. In both situations,
    you want to have a section of code that’s executed within a certain context--and
    thus, Python’s context management, via `with`, comes to the rescue.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器只用于文件处理的情况吗？不是的，但这是最常见的情况。其他两种常见情况是（1）处理数据库事务时和（2）在多线程代码中锁定某些部分时。在这两种情况下，你希望有一个在特定上下文中执行的代码段——因此，Python的上下文管理通过`with`语句来提供帮助。
- en: 'If you want to learn more about context managers, here’s a good article on
    the subject: [http://mng.bz/B221](http://mng.bz/B221).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于上下文管理器的信息，这里有一篇关于这个主题的好文章：[http://mng.bz/B221](http://mng.bz/B221)。
- en: Exercise 20 ■ Word count
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习20 ■ 单词计数
- en: Unix systems contain many utility functions. One of the most useful to me is
    `wc` ([http:// mng.bz/Jyyo](http://mng.bz/Jyyo)), the word count program. If you
    run `wc` against a text file, it’ll count the characters, words, and lines that
    the file contains.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Unix系统包含许多实用函数。对我最有用的是`wc` ([http:// mng.bz/Jyyo](http://mng.bz/Jyyo))，一个单词计数程序。如果你对文本文件运行`wc`，它会计算文件包含的字符、单词和行数。
- en: 'The challenge for this exercise is to write a `wordcount` function that mimics
    the `wc` Unix command. The function will take a filename as input and will print
    four lines of output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的挑战是编写一个`wordcount`函数，模拟Unix命令`wc`。该函数将文件名作为输入，并将打印四行输出：
- en: Number of characters (including whitespace)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 字符数量（包括空格）
- en: Number of words (separated by whitespace)
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单词数量（由空格分隔）
- en: Number of lines
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行数
- en: Number of unique words (case sensitive, so “NO” is different from “no”)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一单词数量（区分大小写，因此“NO”与“no”不同）
- en: 'I’ve placed a test file (`wcfile.txt`) at [http://mng.bz/B2ml](http://mng.bz/B2ml).
    You may download and use that file to test your implementation of `wc`. Any file
    will do, but if you use this one, your results will match up with mine. That file’s
    contents look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[http://mng.bz/B2ml](http://mng.bz/B2ml)放置了一个测试文件（`wcfile.txt`）。你可以下载并使用该文件来测试你的`wc`实现。任何文件都可以，但如果你使用这个文件，你的结果将与我的一致。该文件的内容如下：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This exercise, like many others in this chapter, tries to help you see the connections
    between text files and Python’s built-in data structures. It’s very common to
    use Python to work with log files and configuration files, collecting and reporting
    that data in a human-readable format.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习，就像本章中的许多其他练习一样，试图帮助你看到文本文件和Python内置数据结构之间的联系。使用Python处理日志文件和配置文件是非常常见的，以人类可读的格式收集和报告数据。
- en: Working it out
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: This program demonstrates a number of Python’s capabilities that many programmers
    use on a daily basis. First and foremost, many people who are new to Python believe
    that if they have to measure four aspects of a file, then they should read through
    the file four times. That might mean opening the file once and reading through
    it four times, or even opening it four separate times. But it’s more common in
    Python to loop over the file once, iterating over each line and accumulating whatever
    data the program can find from that line.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序展示了Python的一些常用功能，许多程序员在日常工作中都会用到。首先，许多刚接触Python的人认为，如果他们需要测量一个文件的四个方面，那么他们应该阅读该文件四次。这可能意味着打开文件一次并阅读四次，甚至分别打开四次。但在Python中，更常见的是一次性遍历文件，迭代每一行，并累积程序从该行中找到的所有数据。
- en: How will we accumulate this data? We could use separate variables, and there’s
    nothing wrong with that. But I prefer to use a dict (figure 5.2), since the counts
    are closely related, and because it also reduces the code I need to produce a
    report.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何累积这些数据？我们可以使用单独的变量，这样做并没有什么不对。但我更喜欢使用字典（图5.2），因为计数紧密相关，而且它还可以减少我生成报告所需的代码量。
- en: 'So, once we’re iterating over the lines of the file, how can we count the various
    elements? Counting lines is the easiest part: each iteration goes over one line,
    so we can simply add 1 to `counts[''lines'']` at the top of the loop.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，一旦我们遍历了文件的行，我们如何计算各种元素的数量呢？计算行数是最简单的一部分：每次迭代都会遍历一行，所以我们可以在循环的顶部简单地将1加到`counts['lines']`上。
- en: Next, we want to count the number of characters in the file. Since we’re already
    iterating over the file, there’s not that much work to do. We get the number of
    characters in the current line by calculating `len(one_line)`, and then adding
    that to `counts['characters']`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要计算文件中的字符数量。由于我们已经在遍历文件，所以没有太多工作要做。我们通过计算`len(one_line)`得到当前行的字符数，然后将其添加到`counts['characters']`中。
- en: Many people are surprised that this includes whitespace characters, such as
    spaces and tabs, as well as newlines. Yes, even an “empty” line contains a single
    newline character. But if we didn’t have newline characters, then it wouldn’t
    be obvious to the computer when it should start a new line. So such characters
    are necessary, and they take up some space.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人惊讶地发现这包括空白字符，如空格和制表符，以及换行符。是的，即使是“空”行也包含一个单独的换行符。但如果没有换行符，那么计算机在何时应该开始新行就不会那么明显了。所以这样的字符是必要的，并且它们占用一些空间。
- en: '![](../Images/5-2.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/5-2.png)'
- en: Figure 5.2 Initialized counts in the dict
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 初始化字典中的计数
- en: Next, we want to count the number of words. To get this count, we turn `one_line`
    into a list of words, invoking `one_line.split`. The solution invokes `split`
    without any arguments, which causes it to use all whitespace--spaces, tabs, and
    newlines--as delimiters. The result is then put into `counts['words']`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要计算单词的数量。为了得到这个计数，我们将`one_line`转换成一个单词列表，通过调用`one_line.split`。解决方案在没有任何参数的情况下调用`split`，这导致它使用所有空白字符——空格、制表符和换行符——作为分隔符。然后将结果放入`counts['words']`中。
- en: The final item to count is unique words. We could, in theory, use a list to
    store new words. But it’s much easier to let Python do the hard work for us, using
    a `set` to guarantee the uniqueness. Thus, we create the `unique_words` set at
    the start of the program, and then use `unique_words.update` ([http://mng.bz/MdOn](http://mng.bz/MdOn))
    to add all of the words in the current line into the set (figure 5.3). For the
    report to work on our dict, we then add a new key-value pair to `counts`, using
    `len(unique_words)` to count the number of words in the set.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要计算的是唯一单词的数量。从理论上讲，我们可以使用列表来存储新单词。但让Python为我们做这项艰苦的工作要容易得多，使用`set`来保证唯一性。因此，我们在程序开始时创建`unique_words`集合，然后使用`unique_words.update`([http://mng.bz/MdOn](http://mng.bz/MdOn))将当前行中的所有单词添加到集合中（图5.3）。然后为了使报告在字典上工作，我们在`counts`中添加一个新的键值对，使用`len(unique_words)`来计算集合中的单词数量。
- en: '![](../Images/5-3.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/5-3.png)'
- en: Figure 5.3 The data structures, including unique words, after several lines
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 几行后的数据结构，包括唯一单词
- en: Solution
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ You can create sets with curly braces, but not if they’re empty! Use set()
    to create a new empty set.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 你可以使用花括号创建集合，但它们不能为空！使用`set()`创建一个新的空集合。
- en: ❷ set.update adds all of the elements of an iterable to a set.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `set.update`会将一个可迭代对象的全部元素添加到集合中。
- en: ❸ Sticks the set’s length into counts for a combined report
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将集合的长度放入计数以生成综合报告
- en: You can work through a version of this code in the Python Tutor at [http://mng.bz/MdZo](http://mng.bz/MdZo).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中运行这个代码的版本，[http://mng.bz/MdZo](http://mng.bz/MdZo)。
- en: Screencast solution
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超出练习范围
- en: 'Creating reports based on files is a common use for Python, and using dicts
    to accumulate information from those files is also common. Here are some additional
    things you can try to do, similar to what we did here:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文件创建报告是Python的常见用途，使用字典累积这些文件的信息也是常见的。这里有一些你可以尝试的其他事情，类似于我们在这里所做的那样：
- en: Ask the user to enter the name of a text file and then (on one line, separated
    by spaces) words whose frequencies should be counted in that file. Count how many
    times those words appear in a dict, using the user-entered words as the keys and
    the counts as the values.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求用户输入一个文本文件的名称，然后（在一行中，用空格分隔）输入应该在该文件中计数的单词。使用用户输入的单词作为键，计数作为值，在字典中计算这些单词出现的次数。
- en: Create a dict in which the keys are the names of files on your system and the
    values are the sizes of those files. To calculate the size, you can use `os.stat`
    ([http://mng.bz/dyyo](http://mng.bz/dyyo)).
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个字典，其中键是系统上的文件名，值是这些文件的大小。要计算大小，可以使用`os.stat` ([http://mng.bz/dyyo](http://mng.bz/dyyo))。
- en: Given a directory, read through each file and count the frequency of each letter.
    (Force letters to be lowercase, and ignore nonletter characters.) Use a dict to
    keep track of the letter frequencies. What are the five most common letters across
    all of these files?
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个目录，遍历每个文件并计算每个字母的频率。（强制字母小写，并忽略非字母字符。）使用字典来跟踪字母频率。这些文件中最常见的五个字母是什么？
- en: Exercise 21 ■ Longest word per file
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习21 ■ 每个文件的最长单词
- en: So far, we’ve worked with individual files. Many tasks, however, require you
    to analyze data in multiple files--such as all of the files in a dict. This exercise
    will give you some practice working with multiple files, aggregating measurements
    across all of them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理单个文件。然而，许多任务需要你分析多个文件中的数据——例如，字典中的所有文件。这个练习将让你练习处理多个文件，汇总所有文件的数据。
- en: In this exercise, write two functions. `find_longest_word` takes a filename
    as an argument and returns the longest word found in the file. The second function,
    `find_all_longest_words`, takes a directory name and returns a dict in which the
    keys are filenames and the values are the longest words from each file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，编写两个函数。`find_longest_word`函数接受一个文件名作为参数，并返回文件中找到的最长单词。第二个函数`find_all_longest_words`接受一个目录名，并返回一个字典，其中键是文件名，值是每个文件中的最长单词。
- en: If you don’t have any text files that you can use for this exercise, you can
    download and use a zip file I’ve created from the five most popular books at Project
    Gutenberg ([https://gutenberg.org/](https://gutenberg.org/)). You can download
    the zip file from [http://mng.bz/rrWj](http://mng.bz/rrWj).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有可用于此练习的文本文件，你可以下载并使用我从Project Gutenberg的五种最流行的书籍中创建的zip文件。你可以从[http://mng.bz/rrWj](http://mng.bz/rrWj)下载zip文件。
- en: '*Note* There are several ways to solve this problem. If you already know how
    to use comprehensions, and particularly dict comprehensions, then that’s probably
    the most Pythonic approach. But if you aren’t yet comfortable with them, and would
    prefer not to jump to read about them in chapter 7, then no worries--you can use
    a traditional `for` loop, and you’ll be just fine.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 解决这个问题的方法有好几种。如果你已经知道如何使用推导式，特别是字典推导式，那么这可能是最Pythonic的方法。但如果你还不熟悉它们，并且不想跳到第7章去阅读有关它们的介绍，那么不用担心——你可以使用传统的`for`循环，你也会做得很好。'
- en: Working it out
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: In this case, you’re being asked to take a directory name and then find the
    longest word in each plain-text file in that directory. As noted, your function
    should return a dict in which the dict’s keys are the filenames and the dict’s
    values are the longest words in each file.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你被要求接受一个目录名，然后在该目录中的每个纯文本文件中找到最长单词。如前所述，你的函数应该返回一个字典，其中字典的键是文件名，值是每个文件中的最长单词。
- en: Whenever you hear that you need to transform a collection of inputs into a collection
    of outputs, you should immediately think about comprehensions--most commonly list
    comprehensions, but set comprehensions and dict comprehensions are also useful.
    In this case, we’ll use a dict comprehension--which means that we’ll create a
    dict based on iterating over a source. The source, in our case, will be a list
    of filenames. The filenames will also provide the dict keys, while the values
    will be the result of passing the filenames to a function.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你听到需要将一组输入转换为输出集合时，你应该立即想到推导式——最常见的是列表推导式，但集合推导式和字典推导式也非常有用。在这种情况下，我们将使用字典推导式——这意味着我们将基于遍历源来创建字典。在我们的例子中，源将是一个文件名列表。文件名也将作为字典的键，而值将是将文件名传递给函数的结果。
- en: In other words, our dict comprehension will
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们的字典推导式将
- en: Iterate over the list of files in the named directory, putting the filename
    in the variable `filename`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历指定目录中的文件列表，将文件名放入变量`filename`中。
- en: For each file, run the function `find_longest_word`, passing `filename` as an
    argument. The return value will be a string, the longest string in the file.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个文件，运行函数`find_longest_word`，传递`filename`作为参数。返回值将是一个字符串，即文件中的最长字符串。
- en: Each filename-longest word combination will become a key-value pair in the dict
    we create.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个文件名-最长单词组合将变成我们创建的字典中的键值对。
- en: How can we implement `find_longest_word`? We could read the file’s entire contents
    into a string, turn that string into a list, and then find the longest word in
    the list with `sorted`. Although this will work well for short files, it’ll use
    a lot of memory for even medium-sized files.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实现 `find_longest_word`？我们可以将文件的整个内容读入一个字符串，将这个字符串转换成一个列表，然后使用 `sorted` 在列表中找到最长的单词。虽然这对于短文件来说效果很好，但对于即使是中等大小的文件，它也会消耗大量的内存。
- en: My solution is thus to iterate over every line of a file, and then over every
    word in the line. If we find a word that’s longer than the current `longest_word`,
    we replace the old word with the new one. When we’re done iterating over the file,
    we can return the longest word that we found.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案是遍历文件的每一行，然后遍历每一行中的每个单词。如果我们找到一个比当前 `longest_word` 更长的单词，我们就用新单词替换旧单词。当我们完成对文件的遍历后，我们可以返回我们找到的最长单词。
- en: Note my use of `os.path.join` ([http://mng.bz/oPPM](http://mng.bz/oPPM)) to
    combine the directory name with a filename. You can think of `os.path.join` as
    a filename-specific version of `str.join`. It has additional advantages, as well,
    such as taking into account the current operating system. On Windows, `os.path.join`
    will use backslashes, whereas on Macs and Unix/Linux systems, it’ll use a forward
    slash.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我使用 `os.path.join` ([http://mng.bz/oPPM](http://mng.bz/oPPM)) 将目录名与文件名组合。你可以将
    `os.path.join` 视为 `str.join` 的文件名特定版本。它还有其他优点，例如考虑当前操作系统。在Windows上，`os.path.join`
    将使用反斜杠，而在Mac和Unix/Linux系统上，它将使用正斜杠。
- en: Solution
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Gets the filename and its full path
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取文件名及其完整路径
- en: ❷ Iterates over all of the files in dirname
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历dirname中的所有文件
- en: ❸ We’re only interested in files, not directories or special files.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们只对文件感兴趣，而不是目录或特殊文件。
- en: Because these functions work with directories, there is no Python Tutor link.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些函数与目录一起工作，所以没有Python Tutor链接。
- en: Screencast solution
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超出练习范围
- en: 'You’ll commonly produce reports about files and file contents using dicts and
    other basic data structures in Python. Here are a few possible exercises to practice
    these ideas further:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会使用Python中的dict和其他基本数据结构来生成关于文件和文件内容的报告。以下是一些练习这些想法的练习题：
- en: Use the `hashlib` module in the Python standard library, and the `md5` function
    within it, to calculate the MD5 hash for the contents of every file in a user-specified
    directory. Then print all of the filenames and their MD5 hashes.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python标准库中的 `hashlib` 模块和其中的 `md5` 函数，计算用户指定目录中每个文件的MD5哈希值。然后打印所有文件名及其MD5哈希值。
- en: Ask the user for a directory name. Show all of the files in the directory, as
    well as how long ago the directory was modified. You will probably want to use
    a combination of `os.stat` and the Arrow package on PyPI ([http://mng.bz/nPPK](http://mng.bz/nPPK))
    to do this easily.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求用户输入目录名。显示目录中的所有文件，以及目录最后修改的时间。你可能需要使用 `os.stat` 和PyPI上的Arrow包（[http://mng.bz/nPPK](http://mng.bz/nPPK)）的组合来轻松完成此操作。
- en: Open an HTTP server’s log file. (If you lack one, then you can read one from
    me at [http://mng.bz/vxxM](http://mng.bz/vxxM).) Summarize how many requests resulted
    in numeric response codes--202, 304, and so on.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开HTTP服务器的日志文件。（如果你没有，你可以从[http://mng.bz/vxxM](http://mng.bz/vxxM)中读取一个。）总结有多少请求导致了数字响应代码--202、304等。
- en: Directory listings
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 目录列表
- en: For a language that claims “there’s one way to do it,” Python has too many ways
    to list files in a directory. The two most common are `os.listdir` and `glob.glob`,
    both of which I’ve mentioned in this chapter. A third way is to use `pathlib`,
    which provides us with an object-oriented API to the filesystem.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一种声称“只有一种方法可以做到”的语言，Python 在目录中列出文件的方式太多了。最常见的是 `os.listdir` 和 `glob.glob`，这两者我在本章中都提到了。第三种方法是使用
    `pathlib`，它为我们提供了面向对象的文件系统API。
- en: The easiest and most standard of these is `os.listdir`, a function in the `os`
    module. It returns a list of strings, the names of files in the directory; for
    example
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最简单、最标准的是 `os.listdir`，它是 `os` 模块中的一个函数。它返回一个字符串列表，包含目录中的文件名；例如
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The good news is that it’s easy to understand and work with `os.listdir`. The
    bad news is that it returns a list of filenames without the directory name, which
    means that to open or work with the files, you’ll need to add the directory name
    at the beginning--ideally with `os.path.join`, which works cross-platform.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，理解和使用`os.listdir`很容易。坏消息是，它返回一个不带目录名的文件名列表，这意味着为了打开或处理文件，你需要在前面添加目录名——理想情况下使用`os.path.join`，它可以在跨平台上工作。
- en: The other problem with `os.listdir` is that you can’t filter the filenames by
    a pattern. You get everything, including subdirectories and hidden files. So if
    you want just all of the `.txt` files in a directory, `os.listdir` won’t be enough.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.listdir`的另一个问题是，你不能通过模式来过滤文件名。你将得到一切，包括子目录和隐藏文件。所以，如果你想在一个目录中只获取所有的`.txt`文件，`os.listdir`就不够用了。'
- en: That’s where the `glob` module comes in. It lets you use patterns, sometimes
    known as *globbing*, to describe the files that you want. Moreover, it returns
    a list of strings--with each string containing the complete path to the file.
    For example, I can get the full paths of the configuration files in `/etc/` on
    my computer with
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`glob`模块发挥作用的地方。它允许你使用模式（有时称为*globbing*）来描述你想要的文件。此外，它返回一个包含字符串的列表——每个字符串都包含文件的完整路径。例如，我可以获取我电脑上`/etc/`目录中配置文件的完整路径：
- en: '[PRE21]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: I don’t need to worry about other files or subdirectories in this case, which
    makes it much easier to work with. For a long time, `glob.glob` was thus my go-to
    function for finding files.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我不需要担心其他文件或子目录，这使得工作变得容易得多。因此，`glob.glob`长期以来一直是我寻找文件的首选函数。
- en: 'Then there’s `pathlib`, a module that comes with the Python standard library
    and makes things easier in many ways. You start by creating a `pathlib.Path` object,
    which represents a file or directory:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是`pathlib`，这是一个随Python标准库一起提供的模块，以多种方式简化了许多事情。你首先创建一个`pathlib.Path`对象，它代表一个文件或目录：
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once you have this `Path` object, you can do lots of things with it that previously
    required separate functions--including the ones I’ve just described. For example,
    you can get an iterator that returns files in the directory with `iterdir`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了这个`Path`对象，你可以用它做很多事情，这些事情以前需要单独的函数来完成——包括我刚才描述的那些。例如，你可以通过`iterdir`获取一个返回目录中文件的迭代器：
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In each iteration, you don’t get a string, but rather a `Path` object (or more
    specifically, on my Mac I get a `PosixPath` object). Having a full-fledged `Path`
    object, rather than a string, allows you to do lots more than just print the filename;
    you can open and inspect the file as well.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，你不会得到一个字符串，而是一个`Path`对象（或者更具体地说，在我的Mac上我得到一个`PosixPath`对象）。拥有一个完整的`Path`对象，而不是一个字符串，允许你做更多的事情，而不仅仅是打印文件名；你还可以打开和检查文件。
- en: 'If you want to get a list of files matching a pattern, as I did with `glob.glob`,
    you can use the `glob` method:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要获取匹配特定模式的文件列表，就像我使用`glob.glob`做的那样，你可以使用`glob`方法：
- en: '[PRE24]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`pathlib` is a great addition to recent Python versions. If you have a chance
    to use it, you should do so; I’ve found that it clarifies and shortens quite a
    bit of my code. A good introduction to `pathlib` is here: [http://mng.bz/4AAV](http://mng.bz/4AAV).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`pathlib`是Python最新版本的一个很好的补充。如果你有机会使用它，你应该这样做；我发现它使我的代码变得更加清晰和简洁。关于`pathlib`的良好介绍在这里：[http://mng.bz/4AAV](http://mng.bz/4AAV)。'
- en: Exercise 22 ■ Reading and writing CSV
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习22 ■ 读取和写入CSV
- en: 'In a CSV file, each record is stored on one line, and fields are separated
    by commas. CSV is commonly used for exchanging information, especially (but not
    only) in the world of data science. For example, a CSV file might contain information
    about different vegetables:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSV文件中，每条记录存储在一行中，字段由逗号分隔。CSV通常用于交换信息，尤其是在数据科学领域（但不仅限于此）。例如，一个CSV文件可能包含有关不同蔬菜的信息：
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Each line in this CSV file contains three fields, separated by commas. There
    aren’t any headers describing the fields, although many CSV files do have them.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个CSV文件中的每一行包含三个字段，由逗号分隔。没有描述字段的标题，尽管许多CSV文件都有。
- en: Sometimes, the comma is replaced by another character, so as to avoid potential
    ambiguity. My personal favorite is to use a `TAB` character (`\t` in Python strings).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，逗号会被另一个字符替换，以避免潜在的歧义。我个人最喜欢使用制表符字符（在Python字符串中为`\t`）。
- en: 'Python comes with a `csv` module ([http://mng.bz/Qyyj](http://mng.bz/Qyyj))
    that handles writing to and reading from CSV files. For example, you can write
    to a CSV file with the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带一个`csv`模块（[http://mng.bz/Qyyj](http://mng.bz/Qyyj)），它可以处理写入和读取CSV文件。例如，你可以使用以下代码写入CSV文件：
- en: '[PRE26]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Creates a csv.writer object, wrapping our file-like object “f”
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个csv.writer对象，包装我们的文件对象“f”
- en: ❷ Writes the integers from 0-4 to the file, separated by commas
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将整数0-4写入文件，用逗号分隔
- en: ❸ Writes this list of strings as a record to the CSV file, separated by commas
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将此字符串列表作为记录写入CSV文件，用逗号分隔
- en: Not all CSV files necessarily look like CSV files. For example, the standard
    Unix `/etc/passwd` file, which contains information about users on a system (but
    no longer users’ passwords, despite its name), separates fields with `:` characters.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有CSV文件都一定看起来像CSV文件。例如，标准的Unix `/etc/passwd` 文件，其中包含系统上用户的信息（尽管其名称为用户密码，但不再包含用户密码），使用冒号字符分隔字段。
- en: 'For this exercise, create a function, `passwd_to_csv`, that takes two filenames
    as arguments: the first is a `passwd`-style file to read from, and the second
    is the name of a file in which to write the output.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，创建一个名为`passwd_to_csv`的函数，它接受两个文件名作为参数：第一个是要从中读取的`passwd`风格文件，第二个是要写入输出的文件名。
- en: The new file’s contents are the username (index 0) and the user ID (index 2).
    Note that a record may contain a comment, in which case it will not have anything
    at index 2; you should take that into consideration when writing the file. The
    output file should use `TAB` characters to separate the elements.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 新文件的 内容是用户名（索引0）和用户ID（索引2）。请注意，记录可能包含注释，在这种情况下，索引2处将没有内容；您在写入文件时应考虑这一点。输出文件应使用制表符（`TAB`）来分隔元素。
- en: Thus, the input will look like this
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，输入将看起来像这样
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'and the output will look like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将看起来像这样：
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that the comment line in the input file is not placed in the output file.
    You can assume that any line with at least two colon-separated fields is legitimate.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到输入文件中的注释行没有放置在输出文件中。您可以假设任何至少包含两个冒号分隔字段的行都是合法的。
- en: How Python handles end of lines and newlines on different OSs
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Python在不同操作系统上如何处理行尾和新行
- en: Different operating systems have different ways of indicating that we’ve reached
    the end of the line. Unix systems, including the Mac, use ASCII 10 (line feed,
    or LF). Windows systems use two characters, namely ASCII 13 (carriage return,
    or CR) + ASCII 10\. Old-style Macs used just ASCII 13.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 不同操作系统有不同的方式来指示我们已到达行尾。Unix系统，包括Mac，使用ASCII 10（换行符，或LF）。Windows系统使用两个字符，即ASCII
    13（回车符，或CR）+ ASCII 10。老式Mac只使用ASCII 13。
- en: Python tries to bridge these gaps by being flexible, and making some good guesses,
    when it reads files. I’ve thus rarely had problems using Python to read text files
    that were created using Windows. By the same token, my students (who typically
    use Windows) generally have no problem reading the files that I’ve created on
    the Mac. Python figures out what line ending is being used, so we don’t need to
    provide any more hints. And inside of the Python program, the line ending is symbolized
    by `\n`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过在读取文件时灵活性和做出一些合理的猜测来弥合这些差距。因此，我很少在使用Python读取使用Windows创建的文本文件时遇到问题。同样，我的学生（通常使用Windows）在读取我在Mac上创建的文件时也通常没有问题。Python会确定正在使用的行结束符，所以我们不需要提供更多的提示。在Python程序内部，行结束符用`\n`表示。
- en: Writing to files, in contrast, is a bit trickier. Python will try to use the
    line ending appropriate for the operating system. So if you’re writing to a file
    on Windows, it’ll use CR+LF (sometimes shown as `\r\n`). If you’re writing to
    a file on a Unix machine, then it’ll just use LF.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，写入文件要复杂一些。Python会尝试使用适合操作系统的行结束符。所以如果你正在向Windows上的文件写入，它将使用CR+LF（有时表示为`\r\n`）。如果你正在Unix机器上写入文件，那么它将只使用LF。
- en: This typically works just fine. But sometimes, you’ll find yourself seeing too
    many or too few newlines when you read from a file. This might mean that Python
    has guessed incorrectly, or that the file used a few different line endings, confusing
    Python’s guessing algorithm.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常工作得很好。但有时，当你从文件中读取时，你会发现自己看到的新行太多或太少。这可能意味着Python的猜测不正确，或者文件使用了几个不同的行结束符，这可能会使Python的猜测算法感到困惑。
- en: In such cases, you can pass a value to the `newline` parameter in the `open`
    function, used to open files. You can try to explicitly use `newline='\n'` to
    force Unix-style newlines, or `newline='\r\n'` to force Windows-style newlines.
    If this doesn’t fix the problem, you might need to examine the file further to
    see how it was defined.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以向 `open` 函数中的 `newline` 参数传递一个值，该函数用于打开文件。你可以尝试显式使用 `newline='\n'`
    来强制使用 Unix 风格的换行符，或者使用 `newline='\r\n'` 来强制使用 Windows 风格的换行符。如果这不能解决问题，你可能需要进一步检查文件，以查看它是如何定义的。
- en: For a complete introduction to working with CSV files in Python, check out [http://
    mng.bz/XPP6/](http://mng.bz/XPP6/).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要全面了解在 Python 中处理 CSV 文件的介绍，请查看 [http:// mng.bz/XPP6/](http://mng.bz/XPP6/)。
- en: Working it out
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决思路
- en: The solution program uses a number of aspects of Python that are useful when
    working with files. We’ve already seen and discussed `with` earlier in this chapter.
    Here, you can see how you can use `with` to open two separate files, or generally
    to define any number of objects. As soon as our block exits, both of the files
    are automatically closed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案程序使用了 Python 在处理文件时非常有用的几个方面。我们已经在本章前面看到了并讨论了 `with`。在这里，你可以看到如何使用 `with`
    来打开两个独立的文件，或者通常定义任意数量的对象。一旦我们的代码块退出，两个文件都会自动关闭。
- en: We define two variables in the `with` statement, for the two files with which
    we’ll be working. The `passwd` file is opened for reading from `/etc/passwd`.
    The `output` file is opened for writing, and writes to `/tmp/output.csv`. Our
    program will act as a go-between, translating from the input file and placing
    a reformatted subset into the output file.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `with` 语句中，我们定义了两个变量，用于我们将要工作的两个文件。`passwd` 文件用于从 `/etc/passwd` 读取。`output`
    文件用于写入，并将内容写入 `/tmp/output.csv`。我们的程序将作为中间件，将输入文件翻译并放置到一个重新格式化的子集输出文件中。
- en: We do this by creating one instance of `csv.reader`, which wraps `passwd`. However,
    because `/etc/passwd` uses colons (`:`) to delimit fields, we must tell this to
    `csv.reader`. Otherwise, it’ll try to use commas, which will likely lead to an
    error--or, worse yet, not lead to an error, despite parsing the file incorrectly.
    Similarly, we define an instance of `csv.writer`, wrapping our `output` file and
    indicating that we want to use `\t` as the delimiter.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个 `csv.reader` 的实例来实现这一点，它包装了 `passwd`。然而，因为 `/etc/passwd` 使用冒号（`:`）来分隔字段，我们必须告诉
    `csv.reader`。否则，它将尝试使用逗号，这很可能会导致错误——或者更糟糕的是，即使文件解析错误，也不会导致错误。同样，我们定义了一个 `csv.writer`
    的实例，包装我们的 `output` 文件，并指示我们想要使用 `\t` 作为分隔符。
- en: Now that we have our objects in place for reading and writing CSV data, we can
    run through the input file, writing a row (line) to the output file for each of
    those inputs. We take the username (from index 0) and the user ID (from index
    2), create a tuple, and pass that tuple to `csv.writerow`. Our `csv.writer` object
    knows how to take our fields and print them to the file, separated by `\t`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为读取和写入 CSV 数据设置了对象，我们可以遍历输入文件，为每个输入写入一行（行）到输出文件。我们取用户名（索引 0）和用户 ID（索引
    2），创建一个元组，并将其传递给 `csv.writerow`。我们的 `csv.writer` 对象知道如何将字段取出来并打印到文件中，字段之间用 `\t`
    分隔。
- en: Perhaps the trickiest thing here is to ensure we don’t try to transform lines
    that contain comments--that is, those which begin with a hash (`#`) character.
    There are a number of ways to do this, but the method that I’ve employed here
    is simply to check the number of fields we got for the current input line. If
    there’s only one field, then it must be a comment line, or perhaps another type
    of malformed line. In such a case, we ignore the line altogether. Another good
    technique would be to check for `#` at the start of the line, perhaps using `str.startswith`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最棘手的事情是确保我们不要尝试转换包含注释的行——即以哈希（`#`）字符开头的行。有几种方法可以做到这一点，但我在这里使用的方法是简单地检查当前输入行得到的字段数量。如果只有一个字段，那么它肯定是一行注释，或者可能是其他类型的格式错误行。在这种情况下，我们完全忽略该行。另一种好的技术是在行首检查
    `#`，可能使用 `str.startswith`。
- en: Solution
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Fields in the input file are separated by colons (“:”).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 输入文件中的字段由冒号（“:”）分隔。
- en: ❷ Fields in the output file are separated by tabs (“\t”).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 输出文件中的字段由制表符（“\t”）分隔。
- en: Because we can’t write to files on the Python Tutor, there is no link for this
    exercise.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法在 Python Tutor 上写入文件，因此此练习没有链接。
- en: Screencast solution
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 观看此解决方案的简短视频教程：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: CSV files are extremely useful and common, and the `csv` module that comes with
    Python works with them very well. If you need something more advanced, then you
    might want to look into `pandas` ([http://mng.bz/yyyq](http://mng.bz/yyyq)), which
    handles a wide array of CSV variations, as well as many other formats.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: CSV文件非常有用且常见，Python自带的`csv`模块与它们配合得非常好。如果你需要更高级的功能，那么你可能需要查看`pandas`（[http://mng.bz/yyyq](http://mng.bz/yyyq)），它可以处理多种CSV变体，以及许多其他格式。
- en: 'Here are several additional exercises you can try to improve your facility
    with CSV files:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的练习，你可以尝试以提高你对CSV文件的操作能力：
- en: Extend this exercise by asking the user to enter a space-separated list of integers,
    indicating which fields should be written to the output CSV file. Also ask the
    user which character should be used as a delimiter in the output file. Then read
    from `/etc/passwd`, writing the user’s chosen fields, separated by the user’s
    chosen delimiter.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过要求用户输入一个以空格分隔的整数列表，指示应该写入输出CSV文件的字段，来扩展这个练习。还要询问用户应该使用哪个字符作为输出文件的分隔符。然后从`/etc/passwd`读取，写入用户选择的字段，字段之间用用户选择的分隔符分隔。
- en: 'Write a function that writes a dict to a CSV file. Each line in the CSV file
    should contain three fields: (1) the key, which we’ll assume to be a string, (2)
    the value, and (3) the type of the value (e.g., `str` or `int`).'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数，将字典写入CSV文件。CSV文件中的每一行应包含三个字段：（1）键，我们假设它是一个字符串，（2）值，以及（3）值的类型（例如，`str`或`int`）。
- en: Create a CSV file, in which each line contains 10 random integers between 10
    and 100\. Now read the file back, and print the sum and mean of the numbers on
    each line.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个CSV文件，其中每行包含10个介于10到100之间的随机整数。现在读取该文件，并打印每行上数字的总和和平均值。
- en: Exercise 23 ■ JSON
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习23 ■ JSON
- en: JSON (described at [http://json.org/](http://json.org/)) is a popular format
    for data exchange. In particular, many web services and APIs send and receive
    data using JSON.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: JSON（描述见[http://json.org/](http://json.org/))是一种流行的数据交换格式。特别是，许多网络服务和API使用JSON发送和接收数据。
- en: JSON-encoded data can be read into a very large number of programming languages,
    including Python. The Python standard library comes with the `json` module ([http://mng.bz/Mddn](http://mng.bz/Mddn)),
    which can be used to turn JSON-encoded strings into Python objects, and vice versa.
    The `json.load` method reads a JSON-encoded string from a file and returns a combination
    of Python objects.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: JSON编码的数据可以被读入到非常多的编程语言中，包括Python。Python标准库包含`json`模块([http://mng.bz/Mddn](http://mng.bz/Mddn))，它可以用来将JSON编码的字符串转换为Python对象，反之亦然。`json.load`方法从文件中读取JSON编码的字符串，并返回一个Python对象的组合。
- en: In this exercise, you’re analyzing test data in a high school. There’s a `scores`
    directory on the filesystem containing a number of files in JSON format. Each
    file represents the scores for one class. Write a function, `print_scores`, that
    takes a directory name as an argument and prints a summary of the student scores
    it finds.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你正在分析一所高中的测试数据。文件系统上有一个名为`scores`的目录，其中包含一些JSON格式的文件。每个文件代表一个班级的分数。编写一个名为`print_scores`的函数，它接受一个目录名作为参数，并打印出它找到的学生分数摘要。
- en: 'If you’re trying to analyze the scores from class 9a, they’d be in a file called
    `9a.json` that looks like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在尝试分析9a班的分数，它们将位于一个名为`9a.json`的文件中，其外观如下：
- en: '[PRE30]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The directory may also contain files for 10th grade (`10a.json`, `10b.json`,
    and `10c.json`) and other grades and classes in the high school. Each file contains
    the JSON equivalent of a list of dicts, with each dict containing scores for several
    different school subjects.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 目录还可能包含10年级的文件（`10a.json`、`10b.json`和`10c.json`）以及高中其他年级和班级的文件。每个文件都包含一个字典列表的JSON等效，每个字典包含几个不同学校科目的分数。
- en: '*Note* Valid JSON uses double quotes (`"`), not single quotes (`''`). This
    can be surprising and frustrating for Python developers to discover.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意*有效的JSON使用双引号（`"`），而不是单引号（`''`）。这对于Python开发者来说可能会令人惊讶和沮丧。'
- en: 'Your function should print the highest, lowest, and average test scores for
    each subject in each class. Given two files (`9a.json` and `9b.json`) in the `scores`
    directory, we would see the following output:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你的函数应该打印出每个班级每个科目的最高分、最低分和平均分。给定`scores`目录中的两个文件（`9a.json`和`9b.json`），我们会看到以下输出：
- en: '[PRE31]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can download a zipfile with these JSON files from [http://mng.bz/Vg1x](http://mng.bz/Vg1x).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[http://mng.bz/Vg1x](http://mng.bz/Vg1x)下载包含这些JSON文件的zip文件。
- en: Working it out
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理
- en: In many languages, the first response to this kind of problem would be “Let’s
    create our own class!” But in Python, while we can (and often do) create our own
    classes, it’s often easier and faster to make use of built-in data structures--lists,
    tuples, and dicts.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多语言中，对于这类问题，第一个反应可能是“让我们创建自己的类！”但在Python中，虽然我们可以（并且经常这样做）创建自己的类，但通常使用内置的数据结构——列表、元组和字典——会更简单、更快。
- en: In this particular case, we’re reading from a JSON file. JSON is a data representation,
    much like XML; it isn’t a data type per se. Thus, if we want to create JSON, we
    must use the `json` module to turn our Python data into JSON-formatted strings.
    And if we want to read from a JSON file, we must read the contents of the file,
    as strings, into our program, and then turn it into Python data structures.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的情况下，我们正在读取JSON文件。JSON是一种数据表示，类似于XML；它本身不是数据类型。因此，如果我们想创建JSON，我们必须使用`json`模块将我们的Python数据转换为JSON格式的字符串。如果我们想从JSON文件中读取，我们必须将文件内容作为字符串读入我们的程序，然后将其转换为Python数据结构。
- en: In this exercise, though, you’re being asked to work on multiple files in one
    directory. We know that the directory is called `scores` and that the files all
    have a `.json` suffix. We could thus use `os.listdir` on the directory, filtering
    (perhaps with a list comprehension) through all of those filenames such that we
    only work on those ending with `.json`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个练习中，你被要求在一个目录中处理多个文件。我们知道该目录名为`scores`，并且所有文件都有`.json`后缀。因此，我们可以使用`os.listdir`在目录上，通过（可能使用列表推导）过滤所有这些文件名，以便我们只处理以`.json`结尾的文件。
- en: However, this seems like a more appropriate place to use `glob` ([http://mng
    .bz/044N](http://mng.bz/044N)), which takes a Unix-style filename pattern with
    (among others) `*` and `?` characters and returns a list of those filenames that
    match the pattern. Thus, by invoking `glob.glob('scores/*.json')`, we get all
    of the files ending in `.json` within the `scores` directory. We can then iterate
    over that list, assigning the current filename (a string) to `filename`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这似乎是使用`glob`（[http://mng.bz/044N](http://mng.bz/044N)）的更合适的地方，它接受Unix风格的文件名模式，其中包含（其他）`*`和`?`字符，并返回匹配该模式的文件名列表。因此，通过调用`glob.glob('scores/*.json')`，我们得到`scores`目录中所有以`.json`结尾的文件。然后我们可以遍历这个列表，将当前文件名（一个字符串）分配给`filename`。
- en: Next, we create a new entry in our `scores` dict, which is where we’ll store
    the scores. This will actually be a dict of dicts, in which the first level will
    be the name of the file--and thus the class--from which we’ve read the data. The
    second-level keys will be the subjects; the dict’s values will be a list of scores,
    from which we can then calculate the statistics we need. Thus, once we’ve defined
    `filename`, we immediately add the filename as a key to `scores`, with a new empty
    dict as the value.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`scores`字典中创建一个新的条目，这是我们存储分数的地方。这实际上将是一个字典的字典，第一级键将是读取数据的文件名——也就是班级的名称。第二级键将是主题；字典的值将是一系列分数，我们可以从中计算出所需的统计数据。因此，一旦我们定义了`filename`，我们就立即将文件名作为键添加到`scores`中，其值为一个新的空字典。
- en: Sometimes, you’ll need to read each line of a file into Python and then invoke
    `json.loads` to turn that line into data. In our case, however, the file contains
    a single JSON array. We must thus use `json.load` to read from the file object
    `infile`, which turns the contents of the file into a Python list of dicts.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要将文件的每一行读入Python，然后调用`json.loads`将那一行转换为数据。在我们的情况下，然而，文件包含一个单独的JSON数组。因此，我们必须使用`json.load`从文件对象`infile`中读取，它将文件内容转换为Python字典列表。
- en: Because `json.load` returns a list of dicts, we can iterate over it. Each test
    result is placed in the `result` variable, which is a dict, in which the keys
    are the subjects and the values are the scores. Our goal is to reveal some statistics
    for each of the subjects in the class, which means that while the input file reports
    scores on a per-student basis, our report will ignore the students in favor of
    the subjects.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`json.load`返回一个字典列表，我们可以遍历它。每个测试结果都放在`result`变量中，它是一个字典，其中的键是主题，值是分数。我们的目标是揭示班级中每个主题的统计数据，这意味着虽然输入文件按学生报告分数，但我们的报告将忽略学生，而侧重于主题。
- en: Given that `result` is a dict, we can iterate over its key-value pairs with
    `result .items()`, using parallel assignment to iterate over the key and value
    (here called `subject` and `score`). Now, we don’t know in advance what subjects
    will be in our file, nor do we know how many tests there will be. As a result,
    it’s easiest for us to store our scores in a list. This means that our `scores`
    dict will have one top-level key for each filename, and one second-level key for
    each subject. The second-level value will be a list, to which we’ll then append
    with each iteration through the JSON-parsed list.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `result` 是一个字典，我们可以使用 `result.items()` 遍历其键值对，使用并行赋值来遍历键和值（在这里称为 `subject`
    和 `score`）。现在，我们事先不知道文件中会有哪些科目，也不知道会有多少次测试。因此，最简单的方法是将我们的分数存储在列表中。这意味着我们的 `scores`
    字典将有一个顶级键对应于每个文件名，一个二级键对应于每个科目。二级值将是一个列表，然后我们将通过每次迭代 JSON 解析的列表来将其追加。
- en: 'We’ll want to add our score to the list:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将我们的分数添加到列表中：
- en: '[PRE32]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Before we can do that, we need to make sure the list exists. One easy way to
    do this is with `dict.setdefault`, which assigns a key-value pair to a dict, but
    only if the key doesn’t already exist. In other words, `d.setdefault(k,` `v)`
    is the same as saying
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够做到这一点之前，我们需要确保列表存在。一种简单的方法是使用 `dict.setdefault`，它将键值对分配给字典，但只有当键不存在时。换句话说，`d.setdefault(k,
    v)` 与说 `d[k] = v` 是相同的
- en: '[PRE33]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We use `dict.setdefault` ([http://mng.bz/aRRB](http://mng.bz/aRRB)) to create
    the list if it doesn’t yet exist. In the next line, we add the score to the list
    for this subject, in this class.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `dict.setdefault` ([http://mng.bz/aRRB](http://mng.bz/aRRB)) 在列表不存在时创建列表。在下一行中，我们将分数添加到该科目的列表中，在这个班级中。
- en: When we’ve completed our initial `for` loop, we have all of the scores for each
    class. We can then iterate over each class, printing the name of the class.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成初始的 `for` 循环后，我们就有了每个班级的所有分数。然后我们可以遍历每个班级，打印班级的名称。
- en: Then, we iterate over each subject for the class. We once again use the method
    `dict.items` to return a key-value pair--in this case, calling them `subject`
    (for the name of the class) and `subject_scores` (for the list of scores for that
    subject). We then use an f-string to produce some output, using the built-in `min`
    ([http://mng.bz/gyyE](http://mng.bz/gyyE)) and `max` ([http://mng.bz/Vgq5](http://mng.bz/Vgq5))
    functions, and then combining `sum` ([http://mng.bz/ eQQv](http://mng.bz/eQQv))
    and `len` to get the average score.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历班级中的每个科目。我们再次使用 `dict.items` 方法来返回键值对——在这种情况下，我们称它们为 `subject`（班级名称）和
    `subject_scores`（该科目的分数列表）。然后我们使用 f-string 生成一些输出，使用内置的 `min` ([http://mng.bz/gyyE](http://mng.bz/gyyE))
    和 `max` ([http://mng.bz/Vgq5](http://mng.bz/Vgq5)) 函数，然后结合 `sum` ([http://mng.bz/eQQv](http://mng.bz/eQQv))
    和 `len` 来获取平均分。
- en: While this program reads from a file containing JSON and then produces output
    on the user’s screen, it could just as easily read from a network connection containing
    JSON, and/or write to a file or socket in JSON format. As long as we use built-in
    and standard Python data structures, the `json` module will be able to take our
    data and turn it into JSON.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个程序从包含 JSON 的文件中读取，然后在用户的屏幕上产生输出，但它同样可以从包含 JSON 的网络连接中读取，并且/或者以 JSON 格式写入文件或套接字。只要我们使用内置和标准的
    Python 数据结构，`json` 模块就能将我们的数据转换为 JSON。
- en: Solution
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE34]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ❶ Reads from the file infile and turns it from JSON into Python objects
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从文件 infile 读取并将其从 JSON 转换为 Python 对象
- en: ❷ Makes sure that subject exists as a key in scores[filename]
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 确保科目在 scores[filename] 中作为键存在
- en: ❸ Summarizes the scores
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 总结分数
- en: Because these functions work with directories, there is no Python Tutor link.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些函数与目录一起工作，所以没有 Python Tutor 链接。
- en: Screencast solution
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个简短的解决方案视频教程：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超出练习范围
- en: 'Here are some more tasks you can try that use JSON:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可以尝试的更多任务，它们使用 JSON：
- en: Convert `/etc/passwd` from a CSV-style file into a JSON-formatted file. The
    JSON file will contain the equivalent of a list of Python tuples, with each tuple
    representing one line from the file.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `/etc/passwd` 从 CSV 风格的文件转换为 JSON 格式的文件。该 JSON 文件将包含一个 Python 元组列表的等价物，每个元组代表文件中的一行。
- en: For a slightly different challenge, turn each line in the file into a Python
    dict. This will require identifying each field with a unique column or key name.
    If you’re not sure what each field in `/etc/passwd` does, you can give it an arbitrary
    name.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了一个稍微不同的挑战，将文件中的每一行转换成一个 Python 字典。这需要为每个字段指定一个唯一的列名或键名。如果你不确定 `/etc/passwd`
    中的每个字段的作用，你可以给它一个任意的名字。
- en: Ask the user for the name of a directory. Iterate through each file in that
    directory (ignoring subdirectories), getting (via `os.stat`) the size of the file
    and when it was last modified. Create a JSON-formatted file on disk listing each
    filename, size, and modification timestamp. Then read the file back in, and identify
    which files were modified most and least recently, and which files are largest
    and smallest, in that directory.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 询问用户目录的名称。遍历该目录中的每个文件（忽略子目录），通过 `os.stat` 获取文件的大小和最后修改时间。在磁盘上创建一个 JSON 格式的文件，列出每个文件名、大小和修改时间戳。然后读取该文件，并确定哪个文件最近修改过，哪个文件最近修改过，以及哪个文件最大和最小，在该目录中。
- en: Exercise 24 ■ Reverse lines
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 24 ■ 反转行
- en: 'In many cases, we want to take a file in one format and save it to another
    format. In this function, we do a basic version of this idea. The function takes
    two arguments: the names of the input file (to be read from) and the output file
    (which will be created).'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们希望将一个格式的文件转换成另一个格式。在这个函数中，我们实现了这个想法的基本版本。该函数接受两个参数：输入文件名（从中读取）和输出文件名（将创建）。
- en: For example, if a file looks like
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果文件看起来像
- en: '[PRE35]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: then the output file will be
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件将是
- en: '[PRE36]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice that the newline remains at the end of the string, while the rest of
    the characters are all reversed.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，字符串末尾保留换行符，而其余字符都被反转了。
- en: Transforming files from one format into another and taking data from one file
    and creating another one based on it are common tasks. For example, you might
    need to translate dates to a different format, move timestamps from Eastern Daylight
    Time into Greenwich Mean Time, or transform prices from euros into dollars. You
    might also want to extract only some data from an input file, such as for a particular
    date or location.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件从一个格式转换成另一个格式，以及从一个文件中提取数据并基于它创建另一个文件是常见的任务。例如，你可能需要将日期转换成不同的格式，将时区从东部夏令时转换成格林威治标准时间，或者将价格从欧元转换成美元。你可能还希望从输入文件中提取某些数据，例如特定日期或位置的数据。
- en: Working it out
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: This solution depends not only on the fact that we can iterate over a file one
    line at a time, but also that we can work with more than one object in a `with`
    statement. Remember that `with` takes one or more objects and allows us to assign
    variables to them. I particularly like the fact that when I want to read from
    one file and write to another, I can just use `with` to open one for reading,
    open a second for writing, and then do what I’ve shown here.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案不仅取决于我们能够逐行迭代文件的事实，还取决于我们能够在 `with` 语句中处理多个对象。记住，`with` 可以接受一个或多个对象，并允许我们给它们赋值。我特别喜欢当我想从一个文件中读取并写入另一个文件时，我只需使用
    `with` 打开一个用于读取，打开一个用于写入，然后做我展示的那样。
- en: I then read through each line of the input file. I then reverse the line using
    Python’s slice syntax--remember that `s[::-1]` means that we want all of the elements
    of `s`, from the start to the end, but I use a step size of -1, which returns
    a reversed version of the string.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我接着读取输入文件的每一行。然后使用 Python 的切片语法反转该行——记住 `s[::-1]` 表示我们想要 `s` 的所有元素，从开始到结束，但我使用步长为
    -1，这会返回一个反转的字符串版本。
- en: Before we can reverse the string, however, we first want to remove the newline
    character that’s the final character in the string. So we first run `str.rstrip()`
    on the current line, and then we reverse it. We then write it to the output file,
    adding a newline character so we’ll actually descend by one line.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们反转字符串之前，我们首先想要移除字符串中最后的换行符。所以我们首先在当前行上运行 `str.rstrip()`，然后反转它。我们将其写入输出文件，并添加一个换行符，这样我们实际上会下降一行。
- en: The use of `with` guarantees that both files will be closed when the block ends.
    When we close a file that we opened for writing, it’s automatically flushed, which
    means we don’t need to worry about whether the data has actually been saved to
    disk.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `with` 语句可以保证在代码块结束时关闭两个文件。当我们关闭我们为写入而打开的文件时，它会自动刷新，这意味着我们不需要担心数据是否实际上已经保存到磁盘。
- en: I should note that people often ask me how to read from and write to the same
    file. Python does support that, with the `r+` mode. But I find that this opens
    the door to many potential problems because of the chance you’ll overwrite the
    wrong character, and thus mess up the format of the file you’re editing. I suggest
    that people use this sort of read-from-one, write-to-the-other code, which has
    roughly the same effect, without the potential danger of messing up the input
    file.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该指出，人们经常问我如何从同一个文件中读取和写入。Python 支持这种模式，使用 `r+` 模式。但我发现，这可能会打开许多潜在问题的门，因为可能会覆盖错误的字符，从而破坏你正在编辑的文件格式。我建议人们使用这种从一读取、到另一写入的代码，它大致有相同的效果，但没有破坏输入文件的风险。
- en: Solution
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE37]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ str.rstrip removes all whitespace from the right side of a string.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `str.rstrip` 从字符串的右侧移除所有空白。
- en: Because these functions work with directories, there is no Python Tutor link.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些函数与目录一起工作，所以没有 Python Tutor 链接。
- en: Screencast solution
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频教程：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: 'Here are some more exercise ideas for translating files from one format to
    another using `with` and this kind of technique:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使用 `with` 和这种技术将文件从一种格式转换为另一种格式的练习想法：
- en: “Encrypt” a text file by turning all of its characters into their numeric equivalents
    (with the built-in `ord` function) and writing that file to disk. Now “decrypt”
    the file (using the built-in `chr` function), turning the numbers back into their
    original characters.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “加密”一个文本文件，将所有字符转换为它们的数值等效（使用内置的 `ord` 函数），并将该文件写入磁盘。现在“解密”该文件（使用内置的 `chr` 函数），将数字转换回原始字符。
- en: Given an existing text file, create two new text files. The new files will each
    contain the same number of lines as the input file. In one output file, you’ll
    write all of the vowels (a, e, i, o, and u) from the input file. In the other,
    you’ll write all of the consonants. (You can ignore punctuation and whitespace.)
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个现有的文本文件，创建两个新的文本文件。新文件将包含与输入文件相同数量的行。在一个输出文件中，你将写入输入文件中的所有元音字母（a、e、i、o 和
    u）。在另一个文件中，你将写入所有辅音字母。（你可以忽略标点和空白。）
- en: The final field in `/etc/passwd` is the *shell*, the Unix command interpreter
    that’s invoked when a user logs in. Create a file, containing one line per shell,
    in which the shell’s name is written, followed by all of the usernames that use
    the shell; for example
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/passwd` 文件的最后一个字段是 *shell*，即用户登录时调用的 Unix 命令解释器。创建一个文件，每行包含一个 shell，shell
    的名称后面跟着使用该 shell 的所有用户名；例如'
- en: '[PRE38]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Summary
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: It’s almost impossible to imagine writing programs without using files. And
    while there are many different types of files, Python is especially well suited
    for working with text files--especially, but not only, including log files and
    configuration files, as well those formatted in such standard ways as JSON and
    CSV.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎无法想象编写程序而不使用文件。虽然有许多不同类型的文件，但 Python 特别适合处理文本文件——特别是，但不仅限于日志文件和配置文件，还包括以这种标准方式格式化的文件，如
    JSON 和 CSV。
- en: 'It’s important to remember a few things when working with files:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文件时，记住以下几点很重要：
- en: You will typically open files for either reading or writing.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你通常会打开文件进行读取或写入。
- en: You can (and should) iterate over files one line at a time, rather than reading
    the whole thing into memory at once.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以（并且应该）逐行迭代文件，而不是一次性将整个内容读入内存。
- en: Using `with` when opening a file for writing ensures that the file will be flushed
    and closed.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `with` 打开文件进行写入确保文件将被刷新并关闭。
- en: The `csv` module makes it easy to read from and write to CSV files.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`csv` 模块使读取和写入 CSV 文件变得容易。'
- en: The `json` module’s `dump` and `load` functions allow us to move between Python
    data structures and JSON-formatted strings.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json` 模块的 `dump` 和 `load` 函数使我们能够在 Python 数据结构和 JSON 格式的字符串之间进行转换。'
- en: Reading from files into built-in Python data types is a common and powerful
    technique.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件读取到内置 Python 数据类型是一种常见且强大的技术。
